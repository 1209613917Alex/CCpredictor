<?xml version="1.0" encoding="utf-8"?>
<Func_Clone>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\tools\terminal.cc" startLine="(126, 0)" endLine="(166, 1)" clone_start="19" clone_end="27">
			<code function_name="main(int argc, char** argv)">int main(int argc, char** argv) {
  google::InitGoogleLogging(argv[0]);
  FLAGS_alsologtostderr = true;
  FLAGS_v = 3;

  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);

  ros::init(argc, argv, "terminal");

  apollo::common::adapter::AdapterManagerConfig config;
  config.set_is_ros(true);
  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(apollo::common::adapter::AdapterConfig::PUBLISH_ONLY);
    sub_config-&gt;set_type(apollo::common::adapter::AdapterConfig::PAD);
  }

  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(apollo::common::adapter::AdapterConfig::RECEIVE_ONLY);
    sub_config-&gt;set_type(apollo::common::adapter::AdapterConfig::CHASSIS);
  }

  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(apollo::common::adapter::AdapterConfig::RECEIVE_ONLY);
    sub_config-&gt;set_type(apollo::common::adapter::AdapterConfig::LOCALIZATION);
  }

  AdapterManager::Init(config);
  AdapterManager::SetChassisCallback(on_chassis);

  help();
  pthread_t pid;
  if (pthread_create(&amp;pid, NULL, terminal_thread, NULL) != 0) {
    AINFO &lt;&lt; "create terminal thread failed.";
    exit(0);
  }
  ros::spin();
  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\tools\terminal.cc" startLine="(126, 0)" endLine="(166, 1)" clone_start="13" clone_end="21">
			<code function_name="main(int argc, char** argv)">int main(int argc, char** argv) {
  google::InitGoogleLogging(argv[0]);
  FLAGS_alsologtostderr = true;
  FLAGS_v = 3;

  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);

  ros::init(argc, argv, "terminal");

  apollo::common::adapter::AdapterManagerConfig config;
  config.set_is_ros(true);
  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(apollo::common::adapter::AdapterConfig::PUBLISH_ONLY);
    sub_config-&gt;set_type(apollo::common::adapter::AdapterConfig::PAD);
  }

  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(apollo::common::adapter::AdapterConfig::RECEIVE_ONLY);
    sub_config-&gt;set_type(apollo::common::adapter::AdapterConfig::CHASSIS);
  }

  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(apollo::common::adapter::AdapterConfig::RECEIVE_ONLY);
    sub_config-&gt;set_type(apollo::common::adapter::AdapterConfig::LOCALIZATION);
  }

  AdapterManager::Init(config);
  AdapterManager::SetChassisCallback(on_chassis);

  help();
  pthread_t pid;
  if (pthread_create(&amp;pid, NULL, terminal_thread, NULL) != 0) {
    AINFO &lt;&lt; "create terminal thread failed.";
    exit(0);
  }
  ros::spin();
  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\tools\teleop.cc" startLine="(382, 0)" endLine="(421, 1)" clone_start="14" clone_end="23">
			<code function_name="main(int32_t argc, char** argv)">int main(int32_t argc, char** argv) {
  google::InitGoogleLogging(argv[0]);
  FLAGS_alsologtostderr = true;
  FLAGS_v = 3;

  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);

  ros::init(argc, argv, "teleop");
  signal(SIGINT, signal_handler);

  apollo::common::adapter::AdapterManagerConfig config;
  config.set_is_ros(true);
  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(apollo::common::adapter::AdapterConfig::PUBLISH_ONLY);
    sub_config-&gt;set_type(
        apollo::common::adapter::AdapterConfig::CONTROL_COMMAND);
  }

  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(apollo::common::adapter::AdapterConfig::RECEIVE_ONLY);
    sub_config-&gt;set_type(apollo::common::adapter::AdapterConfig::CHASSIS);
  }

  apollo::common::adapter::AdapterManager::Init(config);

  Teleop teleop;

  if (teleop.Start() != 0) {
    AERROR &lt;&lt; "Teleop start failed.";
    return -1;
  }
  Teleop::PrintKeycode();

  ros::spin();
  teleop.Stop();
  AINFO &lt;&lt; "Teleop exit done.";
  return 0;
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\tirepressure_71.cc" startLine="(26, 0)" endLine="(36, 1)" clone_start="1" clone_end="9">
			<code function_name="Tirepressure71::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Tirepressure71::Parse(const std::uint8_t* bytes, int32_t length,
                           ChassisDetail* car_status) const {
  car_status-&gt;mutable_safety()-&gt;set_front_left_tire_press(
      front_left_tire(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_front_right_tire_press(
      front_right_tire(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_rear_left_tire_press(
      rear_left_tire(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_rear_right_tire_press(
      rear_right_tire(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(26, 0)" endLine="(48, 1)" clone_start="1" clone_end="6">
			<code function_name="Throttle63::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Throttle63::Parse(const std::uint8_t* bytes, int32_t length,
                       ChassisDetail* car_status) const {
  car_status-&gt;mutable_gas()-&gt;set_throttle_input(pedal_input(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_throttle_cmd(pedal_cmd(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_throttle_output(pedal_output(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_throttle_enabled(is_enabled(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  car_status-&gt;mutable_check_response()-&gt;set_is_vcu_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(26, 0)" endLine="(40, 1)" clone_start="1" clone_end="6">
			<code function_name="Gps6e::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Gps6e::Parse(const std::uint8_t* bytes, int32_t length,
                  ChassisDetail* car_status) const {
  car_status-&gt;mutable_basic()-&gt;set_year(year(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_month(month(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_day(day(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_hours(hours(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_minutes(minutes(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_seconds(seconds(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_compass_direction(
      compass_direction(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_pdop(pdop(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_is_gps_fault(is_gps_fault(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_is_inferred(
      is_inferred_position(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(26, 0)" endLine="(55, 1)" clone_start="1" clone_end="6">
			<code function_name="Brake61::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Brake61::Parse(const std::uint8_t* bytes, int32_t length,
                    ChassisDetail* car_status) const {
  car_status-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_output(pedal_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  car_status-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(206, 0)" endLine="(241, 1)" clone_start="3" clone_end="8">
			<code function_name="UdpStream::write(const uint8_t* data, size_t length)">size_t UdpStream::write(const uint8_t* data, size_t length) {
    ssize_t nsent = 0;
    size_t total_nsent = 0;
    struct sockaddr_in peer_sockaddr;
    bzero(&amp;peer_sockaddr, sizeof(peer_sockaddr));
    peer_sockaddr.sin_family = AF_INET;
    peer_sockaddr.sin_port = _peer_port;
    peer_sockaddr.sin_addr.s_addr = _peer_addr;

    while (length &gt; 0) {
        nsent = ::sendto(_sockfd, data, length, 0,
                                 (struct sockaddr*)&amp;peer_sockaddr, 
                                 (socklen_t) sizeof(peer_sockaddr));
        if (nsent &lt; 0) { // error
            if (errno == EINTR) {
                continue;
            } else {
                // error
                if (errno == EPIPE || errno == ECONNRESET) {
                    _status = Stream::Status::DISCONNECTED;
                    _errno = errno;
                } else if (errno != EAGAIN) {
                    _status = Stream::Status::ERROR;
                    _errno = errno;
                }
                return total_nsent;
            }
        }

        total_nsent += nsent;
        length -= nsent;
        data += nsent;
    }

    return total_nsent;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(139, 0)" endLine="(231, 1)" clone_start="16" clone_end="22">
			<code function_name="TcpStream::connect()">bool TcpStream::connect() {
    if (_sockfd &lt; 0) {
        this-&gt;open();
        if (_sockfd  &lt; 0) {
            // error
            return false;
        }
    }

    if (_status == Stream::Status::CONNECTED) {
        return true;
    }

    fd_set fds;
    timeval timeo = {10, 0};
    int ret = 0;
    sockaddr_in peer_addr;

    bzero(&amp;peer_addr, sizeof(peer_addr));
    peer_addr.sin_family = AF_INET;
    peer_addr.sin_port = _peer_port;
    peer_addr.sin_addr.s_addr = _peer_addr;

    int fd_flags = fcntl(_sockfd, F_GETFL);
    if (fd_flags &lt; 0 || fcntl(_sockfd, F_SETFL, fd_flags | O_NONBLOCK) &lt; 0) {
        ROS_ERROR_STREAM("Failed to set noblock, error: " &lt;&lt; strerror(errno));
        return false;
    }

    while ((ret = ::connect(_sockfd, reinterpret_cast&lt;sockaddr*&gt;(&amp;peer_addr), sizeof(peer_addr)))
                &lt; 0) {
        if (errno == EINTR) {
            ROS_INFO("Tcp connect return EINTR.");
            continue;
        } else {
            if ((errno != EISCONN) &amp;&amp; (errno != EINPROGRESS) &amp;&amp; (errno != EALREADY)) {
                _status = Stream::Status::ERROR;
                _errno = errno;
                ROS_ERROR_STREAM("Connect failed, error: " &lt;&lt;  strerror(errno));
                return false;
            }

            FD_ZERO(&amp;fds);
            FD_SET(_sockfd, &amp;fds);
            ret = select(_sockfd + 1, NULL, &amp;fds, NULL, &amp;timeo);
            if (ret &lt; 0) {
                _status = Stream::Status::ERROR;
                _errno = errno;
                ROS_ERROR_STREAM("Wait connect failed, error: " &lt;&lt; strerror(errno));
                return false;
            } else if (ret == 0) {
                ROS_INFO("Tcp connect timeout.");
                return false;
            } else if (FD_ISSET(_sockfd, &amp;fds)) {
                int error = 0;
                socklen_t len = sizeof(int);

                if (getsockopt(_sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len) &lt; 0) {
                    _status = Stream::Status::ERROR;
                    _errno = errno;
                    ROS_ERROR_STREAM("Getsockopt failed, error: " &lt;&lt; strerror(errno));
                    return false;
                }
                if (error != 0) {
                    _status = Stream::Status::ERROR;
                    _errno = errno;
                    ROS_ERROR_STREAM("Socket error: " &lt;&lt;  strerror(errno));
                    return false;
                }

                // connect successfully
                break;
            } else {
                _status = Stream::Status::ERROR;
                _errno = errno;
                ROS_ERROR("Should not be here.");
                return false;
            }
        }
    }

    if (!init_socket()) {
        close();
        _status = Stream::Status::ERROR;
        _errno = errno;
        ROS_ERROR("Failed to init socket.");
        return false;
    }
    ROS_INFO("Tcp connect success.");
    _status = Stream::Status::CONNECTED;
    login();
    return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\angle.cc" startLine="(52, 0)" endLine="(55, 1)" clone_start="1" clone_end="4">
			<code function_name="cos(Angle8 a)">float cos(Angle8 a) {
  Angle16 b(a.raw() &lt;&lt; 8);
  return cos(b);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\angle.cc" startLine="(47, 0)" endLine="(50, 1)" clone_start="1" clone_end="4">
			<code function_name="sin(Angle8 a)">float sin(Angle8 a) {
  Angle16 b(a.raw() &lt;&lt; 8);
  return sin(b);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\angle.cc" startLine="(57, 0)" endLine="(60, 1)" clone_start="1" clone_end="3">
			<code function_name="tan(Angle8 a)">float tan(Angle8 a) {
  Angle16 b(a.raw() &lt;&lt; 8);
  return tan(b);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\angle.cc" startLine="(52, 0)" endLine="(55, 1)" clone_start="1" clone_end="3">
			<code function_name="cos(Angle8 a)">float cos(Angle8 a) {
  Angle16 b(a.raw() &lt;&lt; 8);
  return cos(b);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\box2d.cc" startLine="(136, 0)" endLine="(150, 1)" clone_start="8" clone_end="15">
			<code function_name="Box2d::DistanceTo(const Vec2d&amp; point) const">double Box2d::DistanceTo(const Vec2d&amp; point) const {
  const double x0 = point.x() - center_.x();
  const double y0 = point.y() - center_.y();
  const double dx =
      std::abs(x0 * cos_heading_ + y0 * sin_heading_) - half_length_;
  const double dy =
      std::abs(x0 * sin_heading_ - y0 * cos_heading_) - half_width_;
  if (dx &lt;= 0.0) {
    return std::max(0.0, dy);
  }
  if (dy &lt;= 0.0) {
    return dx;
  }
  return hypot(dx, dy);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\aabox2d.cc" startLine="(100, 0)" endLine="(112, 1)" clone_start="6" clone_end="13">
			<code function_name="AABox2d::DistanceTo(const AABox2d&amp; box) const">double AABox2d::DistanceTo(const AABox2d&amp; box) const {
  const double dx =
      std::abs(box.center_x() - center_.x()) - box.half_length() - half_length_;
  const double dy =
      std::abs(box.center_y() - center_.y()) - box.half_width() - half_width_;
  if (dx &lt;= 0.0) {
    return std::max(0.0, dy);
  }
  if (dy &lt;= 0.0) {
    return dx;
  }
  return hypot(dx, dy);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\aabox2d.cc" startLine="(88, 0)" endLine="(98, 1)" clone_start="4" clone_end="11">
			<code function_name="AABox2d::DistanceTo(const Vec2d&amp; point) const">double AABox2d::DistanceTo(const Vec2d&amp; point) const {
  const double dx = std::abs(point.x() - center_.x()) - half_length_;
  const double dy = std::abs(point.y() - center_.y()) - half_width_;
  if (dx &lt;= 0.0) {
    return std::max(0.0, dy);
  }
  if (dy &lt;= 0.0) {
    return dx;
  }
  return hypot(dx, dy);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\box2d.cc" startLine="(152, 0)" endLine="(157, 1)" clone_start="1" clone_end="1">
			<code function_name="Box2d::HasOverlap(const LineSegment2d&amp; line_segment) const">bool Box2d::HasOverlap(const LineSegment2d&amp; line_segment) const {
  if (line_segment.length() &lt;= kMathEpsilon) {
    return IsPointIn(line_segment.start());
  }
  return DistanceTo(line_segment) &lt;= kMathEpsilon;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\aabox2d.cc" startLine="(114, 0)" endLine="(119, 1)" clone_start="1" clone_end="1">
			<code function_name="AABox2d::HasOverlap(const AABox2d&amp; box) const">bool AABox2d::HasOverlap(const AABox2d&amp; box) const {
  return std::abs(box.center_x() - center_.x()) &lt;=
             box.half_length() + half_length_ &amp;&amp;
         std::abs(box.center_y() - center_.y()) &lt;=
             box.half_width() + half_width_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\aabox2d.cc" startLine="(100, 0)" endLine="(112, 1)" clone_start="1" clone_end="1">
			<code function_name="AABox2d::DistanceTo(const AABox2d&amp; box) const">double AABox2d::DistanceTo(const AABox2d&amp; box) const {
  const double dx =
      std::abs(box.center_x() - center_.x()) - box.half_length() - half_length_;
  const double dy =
      std::abs(box.center_y() - center_.y()) - box.half_width() - half_width_;
  if (dx &lt;= 0.0) {
    return std::max(0.0, dy);
  }
  if (dy &lt;= 0.0) {
    return dx;
  }
  return hypot(dx, dy);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\control.cc" startLine="(258, 0)" endLine="(290, 1)" clone_start="24" clone_end="30">
			<code function_name="Control::CheckTimestamp()">Status Control::CheckTimestamp() {
  if (!FLAGS_enable_input_timestamp_check || FLAGS_is_control_test_mode) {
    ADEBUG &lt;&lt; "Skip input timestamp check by gflags.";
    return Status::OK();
  }
  double current_timestamp = apollo::common::time::ToSecond(Clock::Now());
  double localization_diff =
      current_timestamp - localization_.header().timestamp_sec();
  if (localization_diff &gt;
      (FLAGS_max_localization_miss_num * control_conf_.localization_period())) {
    AERROR &lt;&lt; "Localization msg lost for " &lt;&lt; std::setprecision(6)
           &lt;&lt; localization_diff &lt;&lt; "s";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "Localization msg timeout");
  }

  double chassis_diff = current_timestamp - chassis_.header().timestamp_sec();
  if (chassis_diff &gt;
      (FLAGS_max_chassis_miss_num * control_conf_.chassis_period())) {
    AERROR &lt;&lt; "Chassis msg lost for " &lt;&lt; std::setprecision(6) &lt;&lt; chassis_diff
           &lt;&lt; "s";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "Chassis msg timeout");
  }

  double trajectory_diff =
      current_timestamp - trajectory_.header().timestamp_sec();
  if (trajectory_diff &gt;
      (FLAGS_max_planning_miss_num * control_conf_.trajectory_period())) {
    AERROR &lt;&lt; "Trajectory msg lost for " &lt;&lt; std::setprecision(6)
           &lt;&lt; trajectory_diff &lt;&lt; "s";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "Trajectory msg timeout");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\control.cc" startLine="(258, 0)" endLine="(290, 1)" clone_start="7" clone_end="13">
			<code function_name="Control::CheckTimestamp()">Status Control::CheckTimestamp() {
  if (!FLAGS_enable_input_timestamp_check || FLAGS_is_control_test_mode) {
    ADEBUG &lt;&lt; "Skip input timestamp check by gflags.";
    return Status::OK();
  }
  double current_timestamp = apollo::common::time::ToSecond(Clock::Now());
  double localization_diff =
      current_timestamp - localization_.header().timestamp_sec();
  if (localization_diff &gt;
      (FLAGS_max_localization_miss_num * control_conf_.localization_period())) {
    AERROR &lt;&lt; "Localization msg lost for " &lt;&lt; std::setprecision(6)
           &lt;&lt; localization_diff &lt;&lt; "s";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "Localization msg timeout");
  }

  double chassis_diff = current_timestamp - chassis_.header().timestamp_sec();
  if (chassis_diff &gt;
      (FLAGS_max_chassis_miss_num * control_conf_.chassis_period())) {
    AERROR &lt;&lt; "Chassis msg lost for " &lt;&lt; std::setprecision(6) &lt;&lt; chassis_diff
           &lt;&lt; "s";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "Chassis msg timeout");
  }

  double trajectory_diff =
      current_timestamp - trajectory_.header().timestamp_sec();
  if (trajectory_diff &gt;
      (FLAGS_max_planning_miss_num * control_conf_.trajectory_period())) {
    AERROR &lt;&lt; "Trajectory msg lost for " &lt;&lt; std::setprecision(6)
           &lt;&lt; trajectory_diff &lt;&lt; "s";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "Trajectory msg timeout");
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(41, 0)" endLine="(47, 1)" clone_start="3" clone_end="7">
			<code function_name="Throttle62::Reset()">void Throttle62::Reset() {
  pedal_cmd_ = 0.0;
  pedal_enable_ = false;
  clear_driver_override_flag_ = false;
  ignore_driver_override_ = false;
  watchdog_counter_ = 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(40, 0)" endLine="(47, 1)" clone_start="4" clone_end="8">
			<code function_name="Brake60::Reset()">void Brake60::Reset() {
  pedal_cmd_ = 0.0;
  boo_cmd_ = false;
  pedal_enable_ = false;
  clear_driver_override_flag_ = false;
  ignore_driver_override_ = false;
  watchdog_counter_ = 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(49, 0)" endLine="(52, 1)" clone_start="1" clone_end="2">
			<code function_name="Throttle62::set_pedal(double pedal)">Throttle62* Throttle62::set_pedal(double pedal) {
  pedal_cmd_ = pedal;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(49, 0)" endLine="(57, 1)" clone_start="1" clone_end="2">
			<code function_name="Brake60::set_pedal(double pedal)">Brake60* Brake60::set_pedal(double pedal) {
  pedal_cmd_ = pedal;
  if (pedal_cmd_ &lt; 1e-3) {
    disable_boo_cmd();
  } else {
    enable_boo_cmd();
  }
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\controller\lat_controller.cc" startLine="(364, 0)" endLine="(396, 1)" clone_start="10" clone_end="17">
			<code function_name="LatController::UpdateStateAnalyticalMatching(SimpleLateralDebug* debug)">void LatController::UpdateStateAnalyticalMatching(SimpleLateralDebug* debug) {
  Eigen::Vector2d com = vehicle_state_.ComputeCOMPosition(lr_);
  ComputeLateralErrors(com.x(), com.y(), vehicle_state_.heading(),
                       vehicle_state_.linear_velocity(),
                       vehicle_state_.angular_velocity(), trajectory_analyzer_,
                       debug);

  // State matrix update;
  // First four elements are fixed;
  matrix_state_(0, 0) = debug-&gt;lateral_error();
  matrix_state_(1, 0) = debug-&gt;lateral_error_rate();
  matrix_state_(2, 0) = debug-&gt;heading_error();
  matrix_state_(3, 0) = debug-&gt;heading_error_rate();

  // Next elements are depending on preview window size;
  for (int i = 0; i &lt; preview_window_; ++i) {
    double preview_time = ts_ * (i + 1);
    auto preview_point =
        trajectory_analyzer_.QueryNearestPointByRelativeTime(preview_time);

    auto matched_point = trajectory_analyzer_.QueryNearestPointByPosition(
        preview_point.x, preview_point.y);

    double dx = preview_point.x - matched_point.x;
    double dy = preview_point.y - matched_point.y;

    double cos_matched_theta = std::cos(matched_point.theta);
    double sin_matched_theta = std::sin(matched_point.theta);
    double preview_d_error = cos_matched_theta * dy - sin_matched_theta * dx;

    matrix_state_(basic_state_size_ + i, 0) = preview_d_error;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\controller\lat_controller.cc" startLine="(316, 0)" endLine="(362, 1)" clone_start="33" clone_end="40">
			<code function_name="LatController::UpdateState(SimpleLateralDebug* debug)">void LatController::UpdateState(SimpleLateralDebug* debug) {
  TrajectoryPoint traj_point;
  Eigen::Vector2d com = vehicle_state_.ComputeCOMPosition(lr_);
  double raw_lateral_error = GetLateralError(com, &amp;traj_point);

  // lateral_error_ = lateral_rate_filter_.Filter(raw_lateral_error);
  debug-&gt;set_lateral_error(lateral_error_filter_.Update(raw_lateral_error));

  // ref_curvature_ = traj_point.kappa;
  debug-&gt;set_curvature(traj_point.kappa);

  // ref_heading_ = traj_point.theta;
  debug-&gt;set_ref_heading(traj_point.theta);

  // heading_error_ =
  //    common::math::NormalizeAngle(vehicle_state_.heading() - ref_heading_);
  debug-&gt;set_heading_error(common::math::NormalizeAngle(
      vehicle_state_.heading() - traj_point.theta));

  // heading_error_rate_ = (heading_error_ - previous_heading_error_) / ts_;
  debug-&gt;set_heading_error_rate(
      (debug-&gt;heading_error() - previous_heading_error_) / ts_);
  // lateral_error_rate_ = (lateral_error_ - previous_lateral_error_) / ts_;
  debug-&gt;set_lateral_error_rate(
      (debug-&gt;lateral_error() - previous_lateral_error_) / ts_);

  // Prepare for next iteration.
  previous_heading_error_ = debug-&gt;heading_error();
  previous_lateral_error_ = debug-&gt;lateral_error();

  // State matrix update;
  // First four elements are fixed;
  matrix_state_(0, 0) = debug-&gt;lateral_error();
  matrix_state_(1, 0) = debug-&gt;lateral_error_rate();
  matrix_state_(2, 0) = debug-&gt;heading_error();
  matrix_state_(3, 0) = debug-&gt;heading_error_rate();

  // Next elements are depending on preview window size;
  for (int i = 0; i &lt; preview_window_; ++i) {
    double preview_time = ts_ * (i + 1);
    Eigen::Vector2d future_position_estimate =
        vehicle_state_.EstimateFuturePosition(preview_time);
    double preview_lateral = GetLateralError(future_position_estimate, nullptr);
    matrix_state_(basic_state_size_ + i, 0) = preview_lateral;
  }
  // preview matrix update;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\polygon2d.cc" startLine="(111, 0)" endLine="(117, 1)" clone_start="2" clone_end="7">
			<code function_name="Polygon2d::DistanceToBoundary(const Vec2d&amp; point) const">double Polygon2d::DistanceToBoundary(const Vec2d&amp; point) const {
  double distance = std::numeric_limits&lt;double&gt;::infinity();
  for (int i = 0; i &lt; num_points_; ++i) {
    distance = std::min(distance, line_segments_[i].DistanceTo(point));
  }
  return distance;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\polygon2d.cc" startLine="(41, 0)" endLine="(51, 1)" clone_start="6" clone_end="11">
			<code function_name="Polygon2d::DistanceTo(const Vec2d&amp; point) const">double Polygon2d::DistanceTo(const Vec2d&amp; point) const {
  CHECK_GE(points_.size(), 3);
  if (IsPointIn(point)) {
    return 0.0;
  }
  double distance = std::numeric_limits&lt;double&gt;::infinity();
  for (int i = 0; i &lt; num_points_; ++i) {
    distance = std::min(distance, line_segments_[i].DistanceTo(point));
  }
  return distance;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\polygon2d.cc" startLine="(119, 0)" endLine="(124, 1)" clone_start="1" clone_end="2">
			<code function_name="Polygon2d::IsPointOnBoundary(const Vec2d&amp; point) const">bool Polygon2d::IsPointOnBoundary(const Vec2d&amp; point) const {
  CHECK_GE(points_.size(), 3);
  return std::any_of(
      line_segments_.begin(), line_segments_.end(),
      [&amp;](const LineSegment2d&amp; poly_seg) { return poly_seg.IsPointIn(point); });
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\polygon2d.cc" startLine="(53, 0)" endLine="(64, 1)" clone_start="1" clone_end="2">
			<code function_name="Polygon2d::DistanceSquareTo(const Vec2d&amp; point) const">double Polygon2d::DistanceSquareTo(const Vec2d&amp; point) const {
  CHECK_GE(points_.size(), 3);
  if (IsPointIn(point)) {
    return 0.0;
  }
  double distance_sqr = std::numeric_limits&lt;double&gt;::infinity();
  for (int i = 0; i &lt; num_points_; ++i) {
    distance_sqr =
        std::min(distance_sqr, line_segments_[i].DistanceSquareTo(point));
  }
  return distance_sqr;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\integral.cc" startLine="(22, 0)" endLine="(48, 1)" clone_start="14" clone_end="19">
			<code function_name="GaussLegendre(const std::function&lt;double(double)&gt;&amp; func,const double lower_bound, const double upper_bound)">double GaussLegendre(const std::function&lt;double(double)&gt;&amp; func,
                     const double lower_bound,
                     const double upper_bound) {
  double t = (upper_bound - lower_bound) * 0.5;
  double m = (upper_bound + lower_bound) * 0.5;

  std::array&lt;double, 5&gt; w;
  w[0] = 0.5688888889;
  w[1] = 0.4786286705;
  w[2] = 0.4786286705;
  w[3] = 0.2369268851;
  w[4] = 0.2369268851;

  std::array&lt;double, 5&gt; x;
  x[0] = 0.0;
  x[1] = 0.5384693101;
  x[2] = -0.5384693101;
  x[3] = 0.9061798459;
  x[4] = -0.9061798459;

  double integral = 0.0;
  for (size_t i = 0; i &lt; 5; ++i) {
    integral += w[i] * func(t * x[i] + m);
  }

  return integral * t;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\integral.cc" startLine="(22, 0)" endLine="(48, 1)" clone_start="7" clone_end="12">
			<code function_name="GaussLegendre(const std::function&lt;double(double)&gt;&amp; func,const double lower_bound, const double upper_bound)">double GaussLegendre(const std::function&lt;double(double)&gt;&amp; func,
                     const double lower_bound,
                     const double upper_bound) {
  double t = (upper_bound - lower_bound) * 0.5;
  double m = (upper_bound + lower_bound) * 0.5;

  std::array&lt;double, 5&gt; w;
  w[0] = 0.5688888889;
  w[1] = 0.4786286705;
  w[2] = 0.4786286705;
  w[3] = 0.2369268851;
  w[4] = 0.2369268851;

  std::array&lt;double, 5&gt; x;
  x[0] = 0.0;
  x[1] = 0.5384693101;
  x[2] = -0.5384693101;
  x[3] = 0.9061798459;
  x[4] = -0.9061798459;

  double integral = 0.0;
  for (size_t i = 0; i &lt; 5; ++i) {
    integral += w[i] * func(t * x[i] + m);
  }

  return integral * t;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\polygon2d.cc" startLine="(53, 0)" endLine="(64, 1)" clone_start="1" clone_end="7">
			<code function_name="Polygon2d::DistanceSquareTo(const Vec2d&amp; point) const">double Polygon2d::DistanceSquareTo(const Vec2d&amp; point) const {
  CHECK_GE(points_.size(), 3);
  if (IsPointIn(point)) {
    return 0.0;
  }
  double distance_sqr = std::numeric_limits&lt;double&gt;::infinity();
  for (int i = 0; i &lt; num_points_; ++i) {
    distance_sqr =
        std::min(distance_sqr, line_segments_[i].DistanceSquareTo(point));
  }
  return distance_sqr;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\polygon2d.cc" startLine="(41, 0)" endLine="(51, 1)" clone_start="1" clone_end="7">
			<code function_name="Polygon2d::DistanceTo(const Vec2d&amp; point) const">double Polygon2d::DistanceTo(const Vec2d&amp; point) const {
  CHECK_GE(points_.size(), 3);
  if (IsPointIn(point)) {
    return 0.0;
  }
  double distance = std::numeric_limits&lt;double&gt;::infinity();
  for (int i = 0; i &lt; num_points_; ++i) {
    distance = std::min(distance, line_segments_[i].DistanceTo(point));
  }
  return distance;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\parser_nodelet.cpp" startLine="(39, 0)" endLine="(71, 1)" clone_start="12" clone_end="17">
			<code function_name="ParserNodelet::onInit()">void ParserNodelet::onInit() {
    ros::NodeHandle&amp; nh = getPrivateNodeHandle();
    std::string gnss_conf;
    std::string raw_data_topic;
    std::string gpgga_topic;
    std::string corr_imu_topic;
    std::string odometry_topic;
    std::string gnss_status_topic;
    std::string ins_status_topic;

    nh.param("gnss_conf", gnss_conf, std::string("./conf/gnss_conf.txt"));
    nh.param("raw_data_topic", raw_data_topic, std::string("/apollo/sensor/gnss/raw_data"));
    nh.param("gpgga_topic", gpgga_topic, std::string("/apollo/sensor/gnss/gpgga"));
    nh.param("corr_imu_topic", corr_imu_topic, std::string("/apollo/sensor/gnss/corrected_imu"));
    nh.param("odometry_topic", odometry_topic, std::string("/apollo/sensor/gnss/odometry"));
    nh.param("gnss_status_topic", gnss_status_topic, std::string("/apollo/sensor/gnss/gnss_status"));
    nh.param("ins_status_topic", ins_status_topic, std::string("/apollo/sensor/gnss/ins_status"));

    _data_parser.reset(new DataParser(
                                nh,
                                raw_data_topic,
                                gpgga_topic,
                                corr_imu_topic,
                                odometry_topic,
                                gnss_status_topic,
                                ins_status_topic));
    if (!_data_parser-&gt;init(gnss_conf)) {
        ROS_ERROR("Init parser nodelet failed.");
        ROS_ERROR_STREAM("Init parser nodelet failed.");
        return;
    }
    ROS_INFO("Init parser nodelet success.");
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\parser_nodelet.cpp" startLine="(39, 0)" endLine="(71, 1)" clone_start="11" clone_end="16">
			<code function_name="ParserNodelet::onInit()">void ParserNodelet::onInit() {
    ros::NodeHandle&amp; nh = getPrivateNodeHandle();
    std::string gnss_conf;
    std::string raw_data_topic;
    std::string gpgga_topic;
    std::string corr_imu_topic;
    std::string odometry_topic;
    std::string gnss_status_topic;
    std::string ins_status_topic;

    nh.param("gnss_conf", gnss_conf, std::string("./conf/gnss_conf.txt"));
    nh.param("raw_data_topic", raw_data_topic, std::string("/apollo/sensor/gnss/raw_data"));
    nh.param("gpgga_topic", gpgga_topic, std::string("/apollo/sensor/gnss/gpgga"));
    nh.param("corr_imu_topic", corr_imu_topic, std::string("/apollo/sensor/gnss/corrected_imu"));
    nh.param("odometry_topic", odometry_topic, std::string("/apollo/sensor/gnss/odometry"));
    nh.param("gnss_status_topic", gnss_status_topic, std::string("/apollo/sensor/gnss/gnss_status"));
    nh.param("ins_status_topic", ins_status_topic, std::string("/apollo/sensor/gnss/ins_status"));

    _data_parser.reset(new DataParser(
                                nh,
                                raw_data_topic,
                                gpgga_topic,
                                corr_imu_topic,
                                odometry_topic,
                                gnss_status_topic,
                                ins_status_topic));
    if (!_data_parser-&gt;init(gnss_conf)) {
        ROS_ERROR("Init parser nodelet failed.");
        ROS_ERROR_STREAM("Init parser nodelet failed.");
        return;
    }
    ROS_INFO("Init parser nodelet success.");
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(175, 0)" endLine="(204, 1)" clone_start="16" clone_end="22">
			<code function_name="UdpStream::read(uint8_t* buffer, size_t max_length)">size_t UdpStream::read(uint8_t* buffer, size_t max_length) {
    ssize_t ret = 0;
    struct sockaddr_in peer_sockaddr;
    socklen_t socklenth = sizeof(peer_sockaddr);
    bzero(&amp;peer_sockaddr, sizeof(peer_sockaddr));
    peer_sockaddr.sin_family = AF_INET;
    peer_sockaddr.sin_port = _peer_port;
    peer_sockaddr.sin_addr.s_addr = _peer_addr;

    while ((ret = ::recvfrom(_sockfd,
                             buffer,
                             max_length,
                             0,
                             (struct sockaddr*)&amp;peer_sockaddr,
                             (socklen_t*)&amp;socklenth)) &lt; 0) {
        if (errno == EINTR) {
            continue;
        } else {
            // error
            if (errno != EAGAIN) {
                _status = Stream::Status::ERROR;
                _errno = errno;
            }
        }

        return 0;
    }

    return ret;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(243, 0)" endLine="(284, 1)" clone_start="17" clone_end="23">
			<code function_name="TcpStream::read(uint8_t* buffer, size_t max_length)">size_t TcpStream::read(uint8_t* buffer, size_t max_length) {
    ssize_t ret = 0;

    if (_status != Stream::Status::CONNECTED) {
        disconnect();
        connect();
        if (_status != Stream::Status::CONNECTED) {
            return 0;
        }
    }

    if (!readable(10000)) {
        return 0;
    }

    while ((ret = ::recv(_sockfd, buffer, max_length, 0)) &lt; 0) {
        if (errno == EINTR) {
            continue;
        } else {
            // error
            if (errno != EAGAIN) {
                _status = Stream::Status::ERROR;
                _errno = errno;
                ROS_ERROR("Read errno %d, error %s.", errno, strerror(errno));
            }
        }

        return 0;
    }

    if (ret == 0) {
        _status = Stream::Status::ERROR;
        _errno = errno;
        ROS_ERROR("Remote closed.");
        disconnect();
        if (connect()) {
            ROS_INFO("Reconnect tcp success.");
        }
    }

    return ret;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(77, 0)" endLine="(77, 45)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::z() const">double VehicleState::z() const { return z_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(75, 0)" endLine="(75, 45)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::y() const">double VehicleState::y() const { return y_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(79, 0)" endLine="(79, 57)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::heading() const">double VehicleState::heading() const { return heading_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(77, 0)" endLine="(77, 45)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::z() const">double VehicleState::z() const { return z_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(81, 0)" endLine="(81, 66)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::linear_velocity() const">double VehicleState::linear_velocity() const { return linear_v_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(79, 0)" endLine="(79, 57)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::heading() const">double VehicleState::heading() const { return heading_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(83, 0)" endLine="(83, 68)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::angular_velocity() const">double VehicleState::angular_velocity() const { return angular_v_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(81, 0)" endLine="(81, 66)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::linear_velocity() const">double VehicleState::linear_velocity() const { return linear_v_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(85, 0)" endLine="(85, 70)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::linear_acceleration() const">double VehicleState::linear_acceleration() const { return linear_a_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(83, 0)" endLine="(83, 68)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::angular_velocity() const">double VehicleState::angular_velocity() const { return angular_v_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\box2d.h" startLine="(120, 2)" endLine="(120, 53)" clone_start="1" clone_end="1">
			<code function_name="half_length() const">  double half_length() const { return half_length_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\box2d.h" startLine="(114, 2)" endLine="(114, 41)" clone_start="1" clone_end="1">
			<code function_name="width() const">  double width() const { return width_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\box2d.h" startLine="(126, 2)" endLine="(126, 51)" clone_start="1" clone_end="1">
			<code function_name="half_width() const">  double half_width() const { return half_width_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\box2d.h" startLine="(120, 2)" endLine="(120, 53)" clone_start="1" clone_end="1">
			<code function_name="half_length() const">  double half_length() const { return half_length_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\box2d.h" startLine="(132, 2)" endLine="(132, 45)" clone_start="1" clone_end="1">
			<code function_name="heading() const">  double heading() const { return heading_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\box2d.h" startLine="(126, 2)" endLine="(126, 51)" clone_start="1" clone_end="1">
			<code function_name="half_width() const">  double half_width() const { return half_width_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\box2d.h" startLine="(138, 2)" endLine="(138, 53)" clone_start="1" clone_end="1">
			<code function_name="cos_heading() const">  double cos_heading() const { return cos_heading_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\box2d.h" startLine="(132, 2)" endLine="(132, 45)" clone_start="1" clone_end="1">
			<code function_name="heading() const">  double heading() const { return heading_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\box2d.h" startLine="(144, 2)" endLine="(144, 53)" clone_start="1" clone_end="1">
			<code function_name="sin_heading() const">  double sin_heading() const { return sin_heading_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\box2d.h" startLine="(138, 2)" endLine="(138, 53)" clone_start="1" clone_end="1">
			<code function_name="cos_heading() const">  double cos_heading() const { return cos_heading_; }</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\controller\lon_controller.cc" startLine="(148, 0)" endLine="(286, 1)" clone_start="111" clone_end="116">
			<code function_name="LonController::ComputeControlCommand(const ::apollo::localization::LocalizationEstimate *localization, const ::apollo::canbus::Chassis *chassis, const ::apollo::planning::ADCTrajectory *planning_published_trajectory, ::apollo::control::ControlCommand *cmd)">Status LonController::ComputeControlCommand(
    const ::apollo::localization::LocalizationEstimate *localization,
    const ::apollo::canbus::Chassis *chassis,
    const ::apollo::planning::ADCTrajectory *planning_published_trajectory,
    ::apollo::control::ControlCommand *cmd) {
  localization_ = localization;
  chassis_ = chassis;
  vehicle_state_ = std::move(VehicleState(localization, chassis));

  trajectory_message_ = planning_published_trajectory;
  if (!control_interpolation_) {
    AERROR &lt;&lt; "Fail to initialize calibration table.";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR,
                  "Fail to initialize calibration table.");
  }

  if (trajectory_analyzer_ == nullptr ||
      trajectory_analyzer_-&gt;seq_num() !=
          trajectory_message_-&gt;header().sequence_num()) {
    trajectory_analyzer_.reset(new TrajectoryAnalyzer(trajectory_message_));
  }
  const LonControllerConf &amp;lon_controller_conf =
      control_conf_-&gt;lon_controller_conf();

  auto debug = cmd-&gt;mutable_debug()-&gt;mutable_simple_lon_debug();
  debug-&gt;Clear();

  double brake_cmd = 0.0;
  double throttle_cmd = 0.0;
  double ts = lon_controller_conf.ts();
  double preview_time = lon_controller_conf.preview_window() * ts;

  if (preview_time &lt; 0.0) {
    AERROR &lt;&lt; "Preview time set as: " &lt;&lt; preview_time &lt;&lt; " less than 0";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR,
                  "Invalid preview time:" + std::to_string(preview_time));
  }
  ComputeLongitudinalErrors(vehicle_state_, trajectory_analyzer_.get(),
                            preview_time, debug);

  double station_error_limit = lon_controller_conf.station_error_limit();
  double station_error_limited = 0.0;
  if (FLAGS_enable_speed_station_preview) {
    station_error_limited =
        apollo::common::math::Clamp(debug-&gt;preview_station_error(),
                                    -station_error_limit, station_error_limit);
  } else {
    station_error_limited = apollo::common::math::Clamp(
        debug-&gt;station_error(), -station_error_limit, station_error_limit);
  }
  double speed_offset =
      station_pid_controller_.Control(station_error_limited, ts);

  double speed_controller_input = 0.0;
  double speed_controller_input_limit =
      lon_controller_conf.speed_controller_input_limit();
  double speed_controller_input_limited = 0.0;
  if (FLAGS_enable_speed_station_preview) {
    speed_controller_input = speed_offset + debug-&gt;preview_speed_error();
  } else {
    speed_controller_input = speed_offset + debug-&gt;speed_error();
  }
  speed_controller_input_limited = apollo::common::math::Clamp(
      speed_controller_input, -speed_controller_input_limit,
      speed_controller_input_limit);

  double acceleration_cmd_closeloop = 0.0;
  if (vehicle_state_.linear_velocity() &lt;= lon_controller_conf.switch_speed()) {
    speed_pid_controller_.SetPID(lon_controller_conf.low_speed_pid_conf());
    acceleration_cmd_closeloop =
        speed_pid_controller_.Control(speed_controller_input_limited, ts);
  } else {
    speed_pid_controller_.SetPID(lon_controller_conf.high_speed_pid_conf());
    acceleration_cmd_closeloop =
        speed_pid_controller_.Control(speed_controller_input_limited, ts);
  }

  double acceleration_cmd =
      acceleration_cmd_closeloop + debug-&gt;preview_acceleration_reference();
  debug-&gt;set_is_full_stop(false);
  if (std::abs(debug-&gt;preview_acceleration_reference()) &lt;=
          FLAGS_max_acceleration_when_stopped &amp;&amp;
      std::abs(debug-&gt;preview_speed_reference()) &lt;=
          FLAGS_max_abs_speed_when_stopped) {
    acceleration_cmd = lon_controller_conf.standstill_acceleration();
    AINFO &lt;&lt; "Stop location reached";
    debug-&gt;set_is_full_stop(true);
  }

  double throttle_deadzone = lon_controller_conf.throttle_deadzone();
  double brake_deadzone = lon_controller_conf.brake_deadzone();
  double calibration_value = 0.0;
  if (FLAGS_use_preview_speed_for_table) {
    calibration_value = control_interpolation_-&gt;Interpolate(
        std::make_pair(debug-&gt;preview_speed_reference(), acceleration_cmd));
  } else {
    calibration_value = control_interpolation_-&gt;Interpolate(
        std::make_pair(chassis_-&gt;speed_mps(), acceleration_cmd));
  }

  if (calibration_value &gt;= 0) {
    throttle_cmd = calibration_value &gt; throttle_deadzone ? calibration_value
                                                         : throttle_deadzone;
    brake_cmd = 0.0;
  } else {
    throttle_cmd = 0.0;
    brake_cmd = -calibration_value &gt; brake_deadzone ? -calibration_value
                                                    : brake_deadzone;
  }

  debug-&gt;set_station_error_limited(station_error_limited);
  debug-&gt;set_speed_controller_input_limited(speed_controller_input_limited);
  debug-&gt;set_acceleration_cmd(acceleration_cmd);
  debug-&gt;set_throttle_cmd(throttle_cmd);
  debug-&gt;set_brake_cmd(brake_cmd);
  debug-&gt;set_acceleration_lookup(acceleration_cmd);
  debug-&gt;set_speed_lookup(chassis_-&gt;speed_mps());
  debug-&gt;set_calibration_value(calibration_value);
  debug-&gt;set_acceleration_cmd_closeloop(acceleration_cmd_closeloop);

  if (FLAGS_enable_csv_debug &amp;&amp; speed_log_file_ != nullptr) {
    fprintf(speed_log_file_,
            "%.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f,"
            "%.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %d,\r\n",
            debug-&gt;station_reference(), debug-&gt;station_error(),
            station_error_limited, debug-&gt;preview_station_error(),
            debug-&gt;speed_reference(), debug-&gt;speed_error(),
            speed_controller_input_limited, debug-&gt;preview_speed_reference(),
            debug-&gt;preview_speed_error(),
            debug-&gt;preview_acceleration_reference(), acceleration_cmd_closeloop,
            acceleration_cmd, debug-&gt;acceleration_lookup(),
            debug-&gt;speed_lookup(), calibration_value, throttle_cmd, brake_cmd,
            debug-&gt;is_full_stop());
  }

  cmd-&gt;set_throttle(throttle_cmd);
  cmd-&gt;set_brake(brake_cmd);
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\controller\lat_controller.cc" startLine="(226, 0)" endLine="(306, 1)" clone_start="69" clone_end="76">
			<code function_name="LatController::ComputeControlCommand(const localization::LocalizationEstimate* localization, const canbus::Chassis* chassis, const planning::ADCTrajectory* planning_published_trajectory, ControlCommand* cmd)">Status LatController::ComputeControlCommand(
    const localization::LocalizationEstimate* localization,
    const canbus::Chassis* chassis,
    const planning::ADCTrajectory* planning_published_trajectory,
    ControlCommand* cmd) {
  vehicle_state_ = std::move(VehicleState(localization, chassis));
  vehicle_state_.set_linear_velocity(
      std::max(vehicle_state_.linear_velocity(), 1.0));

  trajectory_analyzer_ =
      std::move(TrajectoryAnalyzer(planning_published_trajectory));

  SimpleLateralDebug* debug = cmd-&gt;mutable_debug()-&gt;mutable_simple_lat_debug();
  debug-&gt;Clear();

  // Update state = [Lateral Error, Lateral Error Rate, Heading Error, Heading
  // Error Rate, preview lateral error1 , preview lateral error2, ...]
  if (FLAGS_use_state_exact_match) {
    UpdateStateAnalyticalMatching(debug);
  } else {
    UpdateState(debug);
  }

  UpdateMatrix();

  // Compound discrete matrix with road preview model
  UpdateMatrixCompound();

  common::math::SolveLQRProblem(matrix_adc_, matrix_bdc_, matrix_q_, matrix_r_,
                                lqr_eps_, lqr_max_iteration_, &amp;matrix_k_);

  // feedback = - K * state
  // Convert vehicle steer angle from rad to degree and then to steer degree
  // then to 100% ratio
  double steer_angle_feedback = -(matrix_k_ * matrix_state_)(0, 0) * 180 /
                                M_PI * steer_transmission_ratio_ /
                                steer_single_direction_max_degree_ * 100;

  double steer_angle_feedforward = ComputeFeedForward(debug-&gt;curvature());
  double steer_angle = steer_angle_feedback + steer_angle_feedforward;
  // Clamp the steer angle to -100.0 to 100.0
  steer_angle = apollo::common::math::Clamp(steer_angle, -100.0, 100.0);

  steer_angle = digital_filter_.Filter(steer_angle);
  cmd-&gt;set_steering_target(steer_angle);
  cmd-&gt;set_steering_rate(FLAGS_steer_angle_rate);

  // compute extra information for logging and debugging
  double steer_angle_lateral_contribution =
      -matrix_k_(0, 0) * matrix_state_(0, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_lateral_rate_contribution =
      -matrix_k_(0, 1) * matrix_state_(1, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_heading_contribution =
      -matrix_k_(0, 2) * matrix_state_(2, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_heading_rate_contribution =
      -matrix_k_(0, 3) * matrix_state_(3, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  // TODO(yifei): move up temporary values to use debug fields.

  debug-&gt;set_heading(vehicle_state_.heading());
  debug-&gt;set_steer_angle(steer_angle);
  debug-&gt;set_steer_angle_feedforward(steer_angle_feedforward);
  debug-&gt;set_steer_angle_lateral_contribution(steer_angle_lateral_contribution);
  debug-&gt;set_steer_angle_lateral_rate_contribution(
      steer_angle_lateral_rate_contribution);
  debug-&gt;set_steer_angle_heading_contribution(steer_angle_heading_contribution);
  debug-&gt;set_steer_angle_heading_rate_contribution(
      steer_angle_heading_rate_contribution);
  debug-&gt;set_steer_angle_feedback(steer_angle_feedback);
  debug-&gt;set_steering_position(chassis-&gt;steering_percentage());
  debug-&gt;set_ref_speed(vehicle_state_.linear_velocity());
  ProcessLogs(debug, chassis);
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\controller\lat_controller.cc" startLine="(226, 0)" endLine="(306, 1)" clone_start="68" clone_end="74">
			<code function_name="LatController::ComputeControlCommand(const localization::LocalizationEstimate* localization, const canbus::Chassis* chassis, const planning::ADCTrajectory* planning_published_trajectory, ControlCommand* cmd)">Status LatController::ComputeControlCommand(
    const localization::LocalizationEstimate* localization,
    const canbus::Chassis* chassis,
    const planning::ADCTrajectory* planning_published_trajectory,
    ControlCommand* cmd) {
  vehicle_state_ = std::move(VehicleState(localization, chassis));
  vehicle_state_.set_linear_velocity(
      std::max(vehicle_state_.linear_velocity(), 1.0));

  trajectory_analyzer_ =
      std::move(TrajectoryAnalyzer(planning_published_trajectory));

  SimpleLateralDebug* debug = cmd-&gt;mutable_debug()-&gt;mutable_simple_lat_debug();
  debug-&gt;Clear();

  // Update state = [Lateral Error, Lateral Error Rate, Heading Error, Heading
  // Error Rate, preview lateral error1 , preview lateral error2, ...]
  if (FLAGS_use_state_exact_match) {
    UpdateStateAnalyticalMatching(debug);
  } else {
    UpdateState(debug);
  }

  UpdateMatrix();

  // Compound discrete matrix with road preview model
  UpdateMatrixCompound();

  common::math::SolveLQRProblem(matrix_adc_, matrix_bdc_, matrix_q_, matrix_r_,
                                lqr_eps_, lqr_max_iteration_, &amp;matrix_k_);

  // feedback = - K * state
  // Convert vehicle steer angle from rad to degree and then to steer degree
  // then to 100% ratio
  double steer_angle_feedback = -(matrix_k_ * matrix_state_)(0, 0) * 180 /
                                M_PI * steer_transmission_ratio_ /
                                steer_single_direction_max_degree_ * 100;

  double steer_angle_feedforward = ComputeFeedForward(debug-&gt;curvature());
  double steer_angle = steer_angle_feedback + steer_angle_feedforward;
  // Clamp the steer angle to -100.0 to 100.0
  steer_angle = apollo::common::math::Clamp(steer_angle, -100.0, 100.0);

  steer_angle = digital_filter_.Filter(steer_angle);
  cmd-&gt;set_steering_target(steer_angle);
  cmd-&gt;set_steering_rate(FLAGS_steer_angle_rate);

  // compute extra information for logging and debugging
  double steer_angle_lateral_contribution =
      -matrix_k_(0, 0) * matrix_state_(0, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_lateral_rate_contribution =
      -matrix_k_(0, 1) * matrix_state_(1, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_heading_contribution =
      -matrix_k_(0, 2) * matrix_state_(2, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_heading_rate_contribution =
      -matrix_k_(0, 3) * matrix_state_(3, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  // TODO(yifei): move up temporary values to use debug fields.

  debug-&gt;set_heading(vehicle_state_.heading());
  debug-&gt;set_steer_angle(steer_angle);
  debug-&gt;set_steer_angle_feedforward(steer_angle_feedforward);
  debug-&gt;set_steer_angle_lateral_contribution(steer_angle_lateral_contribution);
  debug-&gt;set_steer_angle_lateral_rate_contribution(
      steer_angle_lateral_rate_contribution);
  debug-&gt;set_steer_angle_heading_contribution(steer_angle_heading_contribution);
  debug-&gt;set_steer_angle_heading_rate_contribution(
      steer_angle_heading_rate_contribution);
  debug-&gt;set_steer_angle_feedback(steer_angle_feedback);
  debug-&gt;set_steering_position(chassis-&gt;steering_percentage());
  debug-&gt;set_ref_speed(vehicle_state_.linear_velocity());
  ProcessLogs(debug, chassis);
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(427, 0)" endLine="(455, 1)" clone_start="10" clone_end="16">
			<code function_name="RawStream::ntrip_spin()">void RawStream::ntrip_spin() {
    if (_in_rtk_stream == nullptr) {
        return;
    }
    while (ros::ok()) {
        size_t ret = 0;
        size_t length = _in_rtk_stream-&gt;read(_buffer_ntrip, BUFFER_SIZE);
        if (length &gt; 0) {
            if (_rtk_software_solution) {
                std_msgs::StringPtr rtkmsg_pub(new std_msgs::String);
                if (!rtkmsg_pub) {
                    ROS_ERROR("New rtkmsg failed.");
                    continue;
                }
                rtkmsg_pub-&gt;data.assign(reinterpret_cast&lt;const char*&gt;(_buffer_ntrip), length);
                _rtcm_data_publisher.publish(rtkmsg_pub);
            } else {
                if (_out_rtk_stream == nullptr) {
                    continue;
                }
                ret = _out_rtk_stream-&gt;write(_buffer_ntrip, length);
                if (ret != length) {
                    ROS_ERROR_STREAM("Expect write out rtk stream bytes " &lt;&lt; length
                                     &lt;&lt; " but got " &lt;&lt; ret);
                }
            }
        }
    }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(409, 0)" endLine="(425, 1)" clone_start="7" clone_end="13">
			<code function_name="RawStream::data_spin()">void RawStream::data_spin() {
    _stream_status-&gt;mutable_header()-&gt;set_timestamp_sec(ros::Time::now().toSec());
    _stream_status_publisher.publish(_stream_status);
    while (ros::ok()) {
        size_t length = _data_stream-&gt;read(_buffer, BUFFER_SIZE);
        if (length &gt; 0) {
            std_msgs::StringPtr msg_pub(new std_msgs::String);
            if (!msg_pub) {
                ROS_ERROR("New data sting msg failed.");
                continue;
            }
            msg_pub-&gt;data.assign(reinterpret_cast&lt;const char*&gt;(_buffer), length);
            _raw_data_publisher.publish(msg_pub);
        }
        stream_status_check();
    }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(326, 0)" endLine="(378, 1)" clone_start="25" clone_end="32">
			<code function_name="SerialStream::write(const uint8_t* data, size_t length)">size_t SerialStream::write(const uint8_t* data, size_t length) {
    if (!_is_open) {
        if (!connect()) {
            return 0;
        }
        ROS_INFO_STREAM("Connect " &lt;&lt; _device_name &lt;&lt; " success.");
    }

    size_t total_nsent = 0;
    size_t delay_times = 0;

    while ((length &gt; 0) &amp;&amp; (delay_times &lt; 5)) {
        ssize_t nsent = ::write(_fd, data, length);
        if (nsent &lt; 0) {
            ROS_ERROR_STREAM("Serial stream write data failed, error: "
                             &lt;&lt; strerror(errno));
            switch (errno) {
            case EAGAIN:
            case EINVAL:
                nsent = 0;
                break;

            case EBADF:
            case EIO:
                disconnect();
                if (connect()) {
                    ROS_INFO_STREAM("Reconnect " &lt;&lt; _device_name &lt;&lt; "success.");
                    nsent = 0;
                    break; //has recoverable
                }

            default:
                _status = Stream::Status::ERROR;
                _errno = errno;
                return total_nsent;
            }
        }

        if (nsent == 0) {
            if (!wait_writable(_byte_time_us)) {
                break;
            }
            ++delay_times;
            continue;
        }

        total_nsent += nsent;
        length -= nsent;
        data += nsent;
    }

    return total_nsent;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(269, 0)" endLine="(324, 1)" clone_start="27" clone_end="34">
			<code function_name="SerialStream::read(uint8_t* buffer, size_t max_length)">size_t SerialStream::read(uint8_t* buffer, size_t max_length) {
    if (!_is_open) {
        if (!connect()) {
            return 0;
        }
        ROS_INFO_STREAM("Connect " &lt;&lt; _device_name &lt;&lt; " success.");
    }

    ssize_t bytes_read = 0;
    ssize_t bytes_current_read = 0;

    wait_readable(100000); //wait 10ms

    while (max_length &gt; 0) {
        bytes_current_read = ::read(_fd, buffer, max_length);
        if (bytes_current_read &lt; 0) {
            switch (errno) {
            case EAGAIN:
            case EINVAL:
                bytes_current_read = 0;
                break;

            case EBADF:
            case EIO:
                ROS_ERROR_STREAM("Serial stream read data failed, error: "
                             &lt;&lt; strerror(errno));
                disconnect();
                if (connect()) {
                    ROS_INFO_STREAM("Reconnect " &lt;&lt; _device_name &lt;&lt; "success.");
                    bytes_current_read = 0;
                    break; //has recoverable
                }

            default:
                ROS_ERROR_STREAM_THROTTLE(1, "Serial stream read data failed, error: "
                             &lt;&lt; strerror(errno) &lt;&lt; ", errno: " &lt;&lt; errno);
                _status = Stream::Status::ERROR;
                _errno = errno;
                return bytes_read;
            }
        }

        if (bytes_current_read == 0) {
            if (!bytes_read) {
                check_remove();
                return 0;
            }
            return bytes_read;
        }
        max_length -= bytes_current_read;
        buffer += bytes_current_read;
        bytes_read += bytes_current_read;
    }

    return bytes_read;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(26, 0)" endLine="(53, 1)" clone_start="12" clone_end="22">
			<code function_name="Wheelspeed6a::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Wheelspeed6a::Parse(const std::uint8_t* bytes, int32_t length,
                         ChassisDetail* car_status) const {
  // TODO

  // how to set direction
  // what is "valid"
  // front left
  car_status-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_fl(
      front_left_wheel_speed(bytes, length));
  car_status-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_fl_valid(true);
  // front right
  car_status-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_fr(
      front_right_wheel_speed(bytes, length));
  car_status-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_fr_valid(true);
  // rear left
  car_status-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_rl(
      rear_left_wheel_speed(bytes, length));
  car_status-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_rl_valid(true);
  // rear right
  car_status-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_rr(
      rear_right_wheel_speed(bytes, length));
  car_status-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_rr_valid(true);
  /*
  -?(rr(bytes, length));
  -?(rl(bytes, length));
  -?(fr(bytes, length));
  -?(fl(bytes, length));*/
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(26, 0)" endLine="(53, 1)" clone_start="8" clone_end="18">
			<code function_name="Wheelspeed6a::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Wheelspeed6a::Parse(const std::uint8_t* bytes, int32_t length,
                         ChassisDetail* car_status) const {
  // TODO

  // how to set direction
  // what is "valid"
  // front left
  car_status-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_fl(
      front_left_wheel_speed(bytes, length));
  car_status-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_fl_valid(true);
  // front right
  car_status-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_fr(
      front_right_wheel_speed(bytes, length));
  car_status-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_fr_valid(true);
  // rear left
  car_status-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_rl(
      rear_left_wheel_speed(bytes, length));
  car_status-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_rl_valid(true);
  // rear right
  car_status-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_rr(
      rear_right_wheel_speed(bytes, length));
  car_status-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_rr_valid(true);
  /*
  -?(rr(bytes, length));
  -?(rl(bytes, length));
  -?(fr(bytes, length));
  -?(fl(bytes, length));*/
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\tools\teleop.cc" startLine="(108, 2)" endLine="(250, 3)" clone_start="107" clone_end="114">
			<code function_name="KeyboardLoopThreadFunc()">  void KeyboardLoopThreadFunc() {
    char c = 0;
    int32_t level = 0;
    double brake = 0;
    double throttle = 0;
    double steering = 0;
    struct termios _cooked;
    struct termios _raw;
    int32_t _kfd = 0;
    bool parking_brake = false;
    Chassis::GearPosition gear = Chassis::GEAR_INVALID;
    PadMessage pad_msg;
    ControlCommand&amp; control_command_ = control_command();

    // get the console in raw mode
    tcgetattr(_kfd, &amp;_cooked);
    std::memcpy(&amp;_raw, &amp;_cooked, sizeof(struct termios));
    _raw.c_lflag &amp;= ~(ICANON | ECHO);
    // Setting a new line, then end of file
    _raw.c_cc[VEOL] = 1;
    _raw.c_cc[VEOF] = 2;
    tcsetattr(_kfd, TCSANOW, &amp;_raw);
    puts("Teleop:\nReading from keyboard now.");
    puts("---------------------------");
    puts("Use arrow keys to drive the car.");
    while (IsRunning()) {
      // get the next event from the keyboard
      if (read(_kfd, &amp;c, 1) &lt; 0) {
        perror("read():");
        exit(-1);
      }

      switch (c) {
        case KEYCODE_UP1:  // accelerate
        case KEYCODE_UP2:
          brake = control_command_.brake();
          throttle = control_command_.throttle();
          if (brake &gt; 1e-6) {
            brake = GetCommand(brake, -FLAGS_brake_inc_delta);
            control_command_.set_brake(brake);
          } else {
            throttle = GetCommand(throttle, FLAGS_throttle_inc_delta);
            control_command_.set_throttle(throttle);
          }
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_DN1:  // decelerate
        case KEYCODE_DN2:
          brake = control_command_.brake();
          throttle = control_command_.throttle();
          if (throttle &gt; 1e-6) {
            throttle = GetCommand(throttle, -FLAGS_throttle_inc_delta);
            control_command_.set_throttle(throttle);
          } else {
            brake = GetCommand(brake, FLAGS_brake_inc_delta);
            control_command_.set_brake(brake);
          }
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_LF1:  // left
        case KEYCODE_LF2:
          steering = control_command_.steering_target();
          steering = GetCommand(steering, FLAGS_steer_inc_delta);
          control_command_.set_steering_target(steering);
          printf("Steering Target = %.2f\n", steering);
          break;
        case KEYCODE_RT1:  // right
        case KEYCODE_RT2:
          steering = control_command_.steering_target();
          steering = GetCommand(steering, -FLAGS_steer_inc_delta);
          control_command_.set_steering_target(steering);
          printf("Steering Target = %.2f\n", steering);
          break;
        case KEYCODE_PKBK:  // hand brake
          parking_brake = !control_command_.parking_brake();
          control_command_.set_parking_brake(parking_brake);
          printf("Parking Brake Toggled:%d\n", parking_brake);
          break;
        case KEYCODE_ESTOP:
          control_command_.set_brake(50.0);
          printf("Estop Brake:%.2f\n", control_command_.brake());
          break;
        case KEYCODE_SETT1:  // set throttle
        case KEYCODE_SETT2:
          // read keyboard again
          if (read(_kfd, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          control_command_.set_throttle(level * 10.0);
          control_command_.set_brake(0.0);
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_SETG1:
        case KEYCODE_SETG2:
          // read keyboard again
          if (read(_kfd, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          gear = GetGear(level);
          control_command_.set_gear_location(gear);
          printf("Gear set to %d.\n", level);
          break;
        case KEYCODE_SETB1:
        case KEYCODE_SETB2:
          // read keyboard again
          if (read(_kfd, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          control_command_.set_throttle(0.0);
          control_command_.set_brake(level * 10.0);
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_MODE:
          // read keyboard again
          if (read(_kfd, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          GetPadMessage(pad_msg, level);
          control_command_.mutable_pad_msg()-&gt;CopyFrom(pad_msg);
          sleep(1);
          control_command_.mutable_pad_msg()-&gt;Clear();
          break;
        case KEYCODE_HELP:
        case KEYCODE_HELP2:
          PrintKeycode();
          break;
        default:
          // printf("%X\n", c);
          break;
      }
    }  // keyboard_loop big while
    tcsetattr(_kfd, TCSANOW, &amp;_cooked);
    printf("keyboard_loop thread quited.\n");
    return;
  }  // end of keyboard loop thread</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\tools\teleop.cc" startLine="(108, 2)" endLine="(250, 3)" clone_start="96" clone_end="103">
			<code function_name="KeyboardLoopThreadFunc()">  void KeyboardLoopThreadFunc() {
    char c = 0;
    int32_t level = 0;
    double brake = 0;
    double throttle = 0;
    double steering = 0;
    struct termios _cooked;
    struct termios _raw;
    int32_t _kfd = 0;
    bool parking_brake = false;
    Chassis::GearPosition gear = Chassis::GEAR_INVALID;
    PadMessage pad_msg;
    ControlCommand&amp; control_command_ = control_command();

    // get the console in raw mode
    tcgetattr(_kfd, &amp;_cooked);
    std::memcpy(&amp;_raw, &amp;_cooked, sizeof(struct termios));
    _raw.c_lflag &amp;= ~(ICANON | ECHO);
    // Setting a new line, then end of file
    _raw.c_cc[VEOL] = 1;
    _raw.c_cc[VEOF] = 2;
    tcsetattr(_kfd, TCSANOW, &amp;_raw);
    puts("Teleop:\nReading from keyboard now.");
    puts("---------------------------");
    puts("Use arrow keys to drive the car.");
    while (IsRunning()) {
      // get the next event from the keyboard
      if (read(_kfd, &amp;c, 1) &lt; 0) {
        perror("read():");
        exit(-1);
      }

      switch (c) {
        case KEYCODE_UP1:  // accelerate
        case KEYCODE_UP2:
          brake = control_command_.brake();
          throttle = control_command_.throttle();
          if (brake &gt; 1e-6) {
            brake = GetCommand(brake, -FLAGS_brake_inc_delta);
            control_command_.set_brake(brake);
          } else {
            throttle = GetCommand(throttle, FLAGS_throttle_inc_delta);
            control_command_.set_throttle(throttle);
          }
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_DN1:  // decelerate
        case KEYCODE_DN2:
          brake = control_command_.brake();
          throttle = control_command_.throttle();
          if (throttle &gt; 1e-6) {
            throttle = GetCommand(throttle, -FLAGS_throttle_inc_delta);
            control_command_.set_throttle(throttle);
          } else {
            brake = GetCommand(brake, FLAGS_brake_inc_delta);
            control_command_.set_brake(brake);
          }
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_LF1:  // left
        case KEYCODE_LF2:
          steering = control_command_.steering_target();
          steering = GetCommand(steering, FLAGS_steer_inc_delta);
          control_command_.set_steering_target(steering);
          printf("Steering Target = %.2f\n", steering);
          break;
        case KEYCODE_RT1:  // right
        case KEYCODE_RT2:
          steering = control_command_.steering_target();
          steering = GetCommand(steering, -FLAGS_steer_inc_delta);
          control_command_.set_steering_target(steering);
          printf("Steering Target = %.2f\n", steering);
          break;
        case KEYCODE_PKBK:  // hand brake
          parking_brake = !control_command_.parking_brake();
          control_command_.set_parking_brake(parking_brake);
          printf("Parking Brake Toggled:%d\n", parking_brake);
          break;
        case KEYCODE_ESTOP:
          control_command_.set_brake(50.0);
          printf("Estop Brake:%.2f\n", control_command_.brake());
          break;
        case KEYCODE_SETT1:  // set throttle
        case KEYCODE_SETT2:
          // read keyboard again
          if (read(_kfd, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          control_command_.set_throttle(level * 10.0);
          control_command_.set_brake(0.0);
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_SETG1:
        case KEYCODE_SETG2:
          // read keyboard again
          if (read(_kfd, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          gear = GetGear(level);
          control_command_.set_gear_location(gear);
          printf("Gear set to %d.\n", level);
          break;
        case KEYCODE_SETB1:
        case KEYCODE_SETB2:
          // read keyboard again
          if (read(_kfd, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          control_command_.set_throttle(0.0);
          control_command_.set_brake(level * 10.0);
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_MODE:
          // read keyboard again
          if (read(_kfd, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          GetPadMessage(pad_msg, level);
          control_command_.mutable_pad_msg()-&gt;CopyFrom(pad_msg);
          sleep(1);
          control_command_.mutable_pad_msg()-&gt;Clear();
          break;
        case KEYCODE_HELP:
        case KEYCODE_HELP2:
          PrintKeycode();
          break;
        default:
          // printf("%X\n", c);
          break;
      }
    }  // keyboard_loop big while
    tcsetattr(_kfd, TCSANOW, &amp;_cooked);
    printf("keyboard_loop thread quited.\n");
    return;
  }  // end of keyboard loop thread</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\tools\teleop.cc" startLine="(108, 2)" endLine="(250, 3)" clone_start="84" clone_end="91">
			<code function_name="KeyboardLoopThreadFunc()">  void KeyboardLoopThreadFunc() {
    char c = 0;
    int32_t level = 0;
    double brake = 0;
    double throttle = 0;
    double steering = 0;
    struct termios _cooked;
    struct termios _raw;
    int32_t _kfd = 0;
    bool parking_brake = false;
    Chassis::GearPosition gear = Chassis::GEAR_INVALID;
    PadMessage pad_msg;
    ControlCommand&amp; control_command_ = control_command();

    // get the console in raw mode
    tcgetattr(_kfd, &amp;_cooked);
    std::memcpy(&amp;_raw, &amp;_cooked, sizeof(struct termios));
    _raw.c_lflag &amp;= ~(ICANON | ECHO);
    // Setting a new line, then end of file
    _raw.c_cc[VEOL] = 1;
    _raw.c_cc[VEOF] = 2;
    tcsetattr(_kfd, TCSANOW, &amp;_raw);
    puts("Teleop:\nReading from keyboard now.");
    puts("---------------------------");
    puts("Use arrow keys to drive the car.");
    while (IsRunning()) {
      // get the next event from the keyboard
      if (read(_kfd, &amp;c, 1) &lt; 0) {
        perror("read():");
        exit(-1);
      }

      switch (c) {
        case KEYCODE_UP1:  // accelerate
        case KEYCODE_UP2:
          brake = control_command_.brake();
          throttle = control_command_.throttle();
          if (brake &gt; 1e-6) {
            brake = GetCommand(brake, -FLAGS_brake_inc_delta);
            control_command_.set_brake(brake);
          } else {
            throttle = GetCommand(throttle, FLAGS_throttle_inc_delta);
            control_command_.set_throttle(throttle);
          }
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_DN1:  // decelerate
        case KEYCODE_DN2:
          brake = control_command_.brake();
          throttle = control_command_.throttle();
          if (throttle &gt; 1e-6) {
            throttle = GetCommand(throttle, -FLAGS_throttle_inc_delta);
            control_command_.set_throttle(throttle);
          } else {
            brake = GetCommand(brake, FLAGS_brake_inc_delta);
            control_command_.set_brake(brake);
          }
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_LF1:  // left
        case KEYCODE_LF2:
          steering = control_command_.steering_target();
          steering = GetCommand(steering, FLAGS_steer_inc_delta);
          control_command_.set_steering_target(steering);
          printf("Steering Target = %.2f\n", steering);
          break;
        case KEYCODE_RT1:  // right
        case KEYCODE_RT2:
          steering = control_command_.steering_target();
          steering = GetCommand(steering, -FLAGS_steer_inc_delta);
          control_command_.set_steering_target(steering);
          printf("Steering Target = %.2f\n", steering);
          break;
        case KEYCODE_PKBK:  // hand brake
          parking_brake = !control_command_.parking_brake();
          control_command_.set_parking_brake(parking_brake);
          printf("Parking Brake Toggled:%d\n", parking_brake);
          break;
        case KEYCODE_ESTOP:
          control_command_.set_brake(50.0);
          printf("Estop Brake:%.2f\n", control_command_.brake());
          break;
        case KEYCODE_SETT1:  // set throttle
        case KEYCODE_SETT2:
          // read keyboard again
          if (read(_kfd, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          control_command_.set_throttle(level * 10.0);
          control_command_.set_brake(0.0);
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_SETG1:
        case KEYCODE_SETG2:
          // read keyboard again
          if (read(_kfd, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          gear = GetGear(level);
          control_command_.set_gear_location(gear);
          printf("Gear set to %d.\n", level);
          break;
        case KEYCODE_SETB1:
        case KEYCODE_SETB2:
          // read keyboard again
          if (read(_kfd, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          control_command_.set_throttle(0.0);
          control_command_.set_brake(level * 10.0);
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_MODE:
          // read keyboard again
          if (read(_kfd, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          GetPadMessage(pad_msg, level);
          control_command_.mutable_pad_msg()-&gt;CopyFrom(pad_msg);
          sleep(1);
          control_command_.mutable_pad_msg()-&gt;Clear();
          break;
        case KEYCODE_HELP:
        case KEYCODE_HELP2:
          PrintKeycode();
          break;
        default:
          // printf("%X\n", c);
          break;
      }
    }  // keyboard_loop big while
    tcsetattr(_kfd, TCSANOW, &amp;_cooked);
    printf("keyboard_loop thread quited.\n");
    return;
  }  // end of keyboard loop thread</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\apollo_app.cc" startLine="(38, 0)" endLine="(60, 1)" clone_start="10" clone_end="16">
			<code function_name="ApolloApp::Spin()">int ApolloApp::Spin() {
  ros::AsyncSpinner spinner(1);
  auto status = Init();
  if (!status.ok()) {
    AERROR &lt;&lt; Name() &lt;&lt; " Init failed: " &lt;&lt; status;
    ReportModuleStatus(apollo::hmi::ModuleStatus::UNINITIALIZED);
    return -1;
  }
  ReportModuleStatus(apollo::hmi::ModuleStatus::INITIALIZED);
  status = Start();
  if (!status.ok()) {
    AERROR &lt;&lt; Name() &lt;&lt; " Start failed: " &lt;&lt; status;
    ReportModuleStatus(apollo::hmi::ModuleStatus::STOPPED);
    return -2;
  }
  ReportModuleStatus(apollo::hmi::ModuleStatus::STARTED);
  spinner.start();
  ros::waitForShutdown();
  Stop();
  ReportModuleStatus(apollo::hmi::ModuleStatus::STOPPED);
  AINFO &lt;&lt; Name() &lt;&lt; " exited.";
  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\apollo_app.cc" startLine="(38, 0)" endLine="(60, 1)" clone_start="3" clone_end="9">
			<code function_name="ApolloApp::Spin()">int ApolloApp::Spin() {
  ros::AsyncSpinner spinner(1);
  auto status = Init();
  if (!status.ok()) {
    AERROR &lt;&lt; Name() &lt;&lt; " Init failed: " &lt;&lt; status;
    ReportModuleStatus(apollo::hmi::ModuleStatus::UNINITIALIZED);
    return -1;
  }
  ReportModuleStatus(apollo::hmi::ModuleStatus::INITIALIZED);
  status = Start();
  if (!status.ok()) {
    AERROR &lt;&lt; Name() &lt;&lt; " Start failed: " &lt;&lt; status;
    ReportModuleStatus(apollo::hmi::ModuleStatus::STOPPED);
    return -2;
  }
  ReportModuleStatus(apollo::hmi::ModuleStatus::STARTED);
  spinner.start();
  ros::waitForShutdown();
  Stop();
  ReportModuleStatus(apollo::hmi::ModuleStatus::STOPPED);
  AINFO &lt;&lt; Name() &lt;&lt; " exited.";
  return 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\kalman_filter.h" startLine="(224, 0)" endLine="(235, 1)" clone_start="5" clone_end="10">
			<code function_name="KalmanFilter&lt;T, XN, ZN, UN&gt;::DebugString() const">inline std::string KalmanFilter&lt;T, XN, ZN, UN&gt;::DebugString() const {
  Eigen::IOFormat clean_fmt(4, 0, ", ", " ", "[", "]");
  std::ostringstream strs;
  strs &lt;&lt; "F = " &lt;&lt; F_.format(clean_fmt) &lt;&lt; "\n";
  strs &lt;&lt; "B = " &lt;&lt; B_.format(clean_fmt) &lt;&lt; "\n";
  strs &lt;&lt; "H = " &lt;&lt; H_.format(clean_fmt) &lt;&lt; "\n";
  strs &lt;&lt; "Q = " &lt;&lt; Q_.format(clean_fmt) &lt;&lt; "\n";
  strs &lt;&lt; "R = " &lt;&lt; R_.format(clean_fmt) &lt;&lt; "\n";
  strs &lt;&lt; "x = " &lt;&lt; x_.format(clean_fmt) &lt;&lt; "\n";
  strs &lt;&lt; "P = " &lt;&lt; P_.format(clean_fmt) &lt;&lt; "\n";
  return strs.str();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\kalman_filter.h" startLine="(224, 0)" endLine="(235, 1)" clone_start="4" clone_end="9">
			<code function_name="KalmanFilter&lt;T, XN, ZN, UN&gt;::DebugString() const">inline std::string KalmanFilter&lt;T, XN, ZN, UN&gt;::DebugString() const {
  Eigen::IOFormat clean_fmt(4, 0, ", ", " ", "[", "]");
  std::ostringstream strs;
  strs &lt;&lt; "F = " &lt;&lt; F_.format(clean_fmt) &lt;&lt; "\n";
  strs &lt;&lt; "B = " &lt;&lt; B_.format(clean_fmt) &lt;&lt; "\n";
  strs &lt;&lt; "H = " &lt;&lt; H_.format(clean_fmt) &lt;&lt; "\n";
  strs &lt;&lt; "Q = " &lt;&lt; Q_.format(clean_fmt) &lt;&lt; "\n";
  strs &lt;&lt; "R = " &lt;&lt; R_.format(clean_fmt) &lt;&lt; "\n";
  strs &lt;&lt; "x = " &lt;&lt; x_.format(clean_fmt) &lt;&lt; "\n";
  strs &lt;&lt; "P = " &lt;&lt; P_.format(clean_fmt) &lt;&lt; "\n";
  return strs.str();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(147, 0)" endLine="(163, 1)" clone_start="5" clone_end="16">
			<code function_name="UdpStream::connect()">bool UdpStream::connect() {
    if (_sockfd &lt; 0) {
        this-&gt;open();
        if (_sockfd &lt; 0) {
            return false;
        }
    }

    if (_status == Stream::Status::CONNECTED) {
        return true;
    }

    // upper layer support ping method ??
    login();
    _status = Stream::Status::CONNECTED;
    return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(214, 0)" endLine="(231, 1)" clone_start="7" clone_end="17">
			<code function_name="SerialStream::connect()">bool SerialStream::connect() {
    if (!_is_open) {
        this-&gt;open();
        if (!_is_open) {
            _status = Stream::Status::ERROR;
            _errno = errno;
            return false;
        }
    }

    if (_status == Stream::Status::CONNECTED) {
        return true;
    }

    login();
    _status = Stream::Status::CONNECTED;
    return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\can_comm\can_sender.cc" startLine="(135, 0)" endLine="(148, 1)" clone_start="3" clone_end="10">
			<code function_name="CanSender::Init(CanClient* can_client, bool enable_log)">ErrorCode CanSender::Init(CanClient* can_client, bool enable_log) {
  if (is_init_) {
    AERROR &lt;&lt; "Duplicated Init request.";
    return ErrorCode::CANBUS_ERROR;
  }
  if (can_client == nullptr) {
    AERROR &lt;&lt; "Invalid can client.";
    return ErrorCode::CANBUS_ERROR;
  }
  is_init_ = true;
  can_client_ = can_client;
  enable_log_ = enable_log;
  return ErrorCode::OK;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\can_comm\can_receiver.cc" startLine="(30, 0)" endLine="(45, 1)" clone_start="7" clone_end="14">
			<code function_name="CanReceiver::Init(CanClient* can_client, MessageManager* pt_manager, bool enable_log)">ErrorCode CanReceiver::Init(CanClient* can_client, MessageManager* pt_manager,
                            bool enable_log) {
  can_client_ = can_client;
  pt_manager_ = pt_manager;
  enable_log_ = enable_log;
  if (can_client_ == nullptr) {
    AERROR &lt;&lt; "Invalid can client.";
    return ErrorCode::CANBUS_ERROR;
  }
  if (pt_manager_ == nullptr) {
    AERROR &lt;&lt; "Invalid protocol manager.";
    return ErrorCode::CANBUS_ERROR;
  }
  is_init_ = true;
  return ErrorCode::OK;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\aaboxkdtree2d.h" startLine="(259, 2)" endLine="(323, 3)" clone_start="41" clone_end="47">
			<code function_name="GetNearestObjectInternal(const Vec2d&amp; point,double* const min_distance_sqr, ObjectPtr* const nearest_object) const">  void GetNearestObjectInternal(const Vec2d&amp; point,
                                double* const min_distance_sqr,
                                ObjectPtr* const nearest_object) const {
    if (LowerDistanceSquareToPoint(point) &gt;= *min_distance_sqr - kMathEpsilon) {
      return;
    }
    const double pvalue = (partition_ == PARTITION_X ? point.x() : point.y());
    const bool search_left_first = (pvalue &lt; partition_position_);
    if (search_left_first) {
      if (left_subnode_ != nullptr) {
        left_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                nearest_object);
      }
    } else {
      if (right_subnode_ != nullptr) {
        right_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                 nearest_object);
      }
    }
    if (*min_distance_sqr &lt;= kMathEpsilon) {
      return;
    }

    if (search_left_first) {
      for (int i = 0; i &lt; num_objects_; ++i) {
        const double bound = objects_sorted_by_min_bound_[i];
        if (bound &gt; pvalue &amp;&amp; Square(bound - pvalue) &gt; *min_distance_sqr) {
          break;
        }
        ObjectPtr object = objects_sorted_by_min_[i];
        const double distance_sqr = object-&gt;DistanceSquareTo(point);
        if (distance_sqr &lt; *min_distance_sqr) {
          *min_distance_sqr = distance_sqr;
          *nearest_object = object;
        }
      }
    } else {
      for (int i = 0; i &lt; num_objects_; ++i) {
        const double bound = objects_sorted_by_max_bound_[i];
        if (bound &lt; pvalue &amp;&amp; Square(bound - pvalue) &gt; *min_distance_sqr) {
          break;
        }
        ObjectPtr object = objects_sorted_by_max_[i];
        const double distance_sqr = object-&gt;DistanceSquareTo(point);
        if (distance_sqr &lt; *min_distance_sqr) {
          *min_distance_sqr = distance_sqr;
          *nearest_object = object;
        }
      }
    }
    if (*min_distance_sqr &lt;= kMathEpsilon) {
      return;
    }
    if (search_left_first) {
      if (right_subnode_ != nullptr) {
        right_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                 nearest_object);
      }
    } else {
      if (left_subnode_ != nullptr) {
        left_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                nearest_object);
      }
    }
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\aaboxkdtree2d.h" startLine="(259, 2)" endLine="(323, 3)" clone_start="28" clone_end="34">
			<code function_name="GetNearestObjectInternal(const Vec2d&amp; point,double* const min_distance_sqr, ObjectPtr* const nearest_object) const">  void GetNearestObjectInternal(const Vec2d&amp; point,
                                double* const min_distance_sqr,
                                ObjectPtr* const nearest_object) const {
    if (LowerDistanceSquareToPoint(point) &gt;= *min_distance_sqr - kMathEpsilon) {
      return;
    }
    const double pvalue = (partition_ == PARTITION_X ? point.x() : point.y());
    const bool search_left_first = (pvalue &lt; partition_position_);
    if (search_left_first) {
      if (left_subnode_ != nullptr) {
        left_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                nearest_object);
      }
    } else {
      if (right_subnode_ != nullptr) {
        right_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                 nearest_object);
      }
    }
    if (*min_distance_sqr &lt;= kMathEpsilon) {
      return;
    }

    if (search_left_first) {
      for (int i = 0; i &lt; num_objects_; ++i) {
        const double bound = objects_sorted_by_min_bound_[i];
        if (bound &gt; pvalue &amp;&amp; Square(bound - pvalue) &gt; *min_distance_sqr) {
          break;
        }
        ObjectPtr object = objects_sorted_by_min_[i];
        const double distance_sqr = object-&gt;DistanceSquareTo(point);
        if (distance_sqr &lt; *min_distance_sqr) {
          *min_distance_sqr = distance_sqr;
          *nearest_object = object;
        }
      }
    } else {
      for (int i = 0; i &lt; num_objects_; ++i) {
        const double bound = objects_sorted_by_max_bound_[i];
        if (bound &lt; pvalue &amp;&amp; Square(bound - pvalue) &gt; *min_distance_sqr) {
          break;
        }
        ObjectPtr object = objects_sorted_by_max_[i];
        const double distance_sqr = object-&gt;DistanceSquareTo(point);
        if (distance_sqr &lt; *min_distance_sqr) {
          *min_distance_sqr = distance_sqr;
          *nearest_object = object;
        }
      }
    }
    if (*min_distance_sqr &lt;= kMathEpsilon) {
      return;
    }
    if (search_left_first) {
      if (right_subnode_ != nullptr) {
        right_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                 nearest_object);
      }
    } else {
      if (left_subnode_ != nullptr) {
        left_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                nearest_object);
      }
    }
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\planning\planning.cc" startLine="(119, 0)" endLine="(141, 1)" clone_start="6" clone_end="13">
			<code function_name="Planning::ComputeStartingPointFromVehicleState(const common::vehicle_state::VehicleState&amp; vehicle_state, const double forward_time) const">TrajectoryPoint Planning::ComputeStartingPointFromVehicleState(
    const common::vehicle_state::VehicleState&amp; vehicle_state,
    const double forward_time) const {
  // Eigen::Vector2d estimated_position =
  // vehicle_state.EstimateFuturePosition(forward_time);
  TrajectoryPoint point;
  // point.x = estimated_position.x();
  // point.y = estimated_position.y();
  point.x = vehicle_state.x();
  point.y = vehicle_state.y();
  point.z = vehicle_state.z();
  point.v = vehicle_state.linear_velocity();
  point.a = vehicle_state.linear_acceleration();
  point.kappa = 0.0;
  if (point.v &gt; 0.1) {
    point.kappa =
        vehicle_state.angular_velocity() / vehicle_state.linear_velocity();
  }
  point.dkappa = 0.0;
  point.s = 0.0;
  point.relative_time = 0.0;
  return point;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\common\trajectory_analyzer.cc" startLine="(31, 0)" endLine="(56, 1)" clone_start="14" clone_end="19">
			<code function_name="TrajectoryAnalyzer::TrajectoryAnalyzer( const planning::ADCTrajectory* planning_published_trajectory)">TrajectoryAnalyzer::TrajectoryAnalyzer(
    const planning::ADCTrajectory* planning_published_trajectory) {
  header_time_ = planning_published_trajectory-&gt;header().timestamp_sec();
  seq_num_ = planning_published_trajectory-&gt;header().sequence_num();

  int num_points = planning_published_trajectory-&gt;adc_trajectory_point_size();
  trajectory_points_.reserve(num_points);

  for (int i = 0;
       i &lt; planning_published_trajectory-&gt;adc_trajectory_point_size(); ++i) {
    const auto&amp; published_trajectory_point =
        planning_published_trajectory-&gt;adc_trajectory_point(i);

    TrajectoryPoint point;
    point.s = published_trajectory_point.accumulated_s();
    point.x = published_trajectory_point.x();
    point.y = published_trajectory_point.y();
    point.theta = published_trajectory_point.theta();
    point.kappa = published_trajectory_point.curvature();
    point.v = published_trajectory_point.speed();
    point.a = published_trajectory_point.acceleration_s();
    point.relative_time = published_trajectory_point.relative_time();

    trajectory_points_.push_back(std::move(point));
  }
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\planning\planner\rtk_replay_planner.h" startLine="(48, 2)" endLine="(48, 40)" clone_start="1" clone_end="1">
			<code function_name="~RTKReplayPlanner()">  virtual ~RTKReplayPlanner() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\localization\rtk\rtk_localization.h" startLine="(54, 2)" endLine="(54, 39)" clone_start="1" clone_end="1">
			<code function_name="~RTKLocalization()">  virtual ~RTKLocalization() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\localization\camera\camera_localization.h" startLine="(56, 2)" endLine="(56, 42)" clone_start="1" clone_end="1">
			<code function_name="~CameraLocalization()">  virtual ~CameraLocalization() = default;</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(33, 0)" endLine="(41, 1)" clone_start="3" clone_end="8">
			<code function_name="Steering64::UpdateData(uint8_t* data)">void Steering64::UpdateData(uint8_t* data) {
  set_steering_angle_p(data, steering_angle_);
  set_enable_p(data, steering_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_ignore_driver_override_p(data, ignore_driver_override_);
  set_steering_angle_speed_p(data, steering_angle_speed_);
  set_watchdog_counter_p(data, watchdog_counter_);
  set_disable_audible_warning_p(data, disable_audible_warning_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(33, 0)" endLine="(41, 1)" clone_start="2" clone_end="7">
			<code function_name="Steering64::UpdateData(uint8_t* data)">void Steering64::UpdateData(uint8_t* data) {
  set_steering_angle_p(data, steering_angle_);
  set_enable_p(data, steering_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_ignore_driver_override_p(data, ignore_driver_override_);
  set_steering_angle_speed_p(data, steering_angle_speed_);
  set_watchdog_counter_p(data, watchdog_counter_);
  set_disable_audible_warning_p(data, disable_audible_warning_);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(286, 0)" endLine="(322, 1)" clone_start="3" clone_end="9">
			<code function_name="TcpStream::write(const uint8_t* buffer, size_t length)">size_t TcpStream::write(const uint8_t* buffer, size_t length) {
    ssize_t  nsent = 0;
    size_t total_nsent = 0;

    if (_status != Stream::Status::CONNECTED) {
        disconnect();
        connect();
        if (_status != Stream::Status::CONNECTED) {
            return 0;
        }
    }

    while (length &gt; 0) {
        nsent = ::send(_sockfd, buffer, length, 0);
        if (nsent &lt; 0) {
            if (errno == EINTR) {
                continue;
            } else {
                // error
                if (errno == EPIPE || errno == ECONNRESET) {
                    _status = Stream::Status::DISCONNECTED;
                    _errno = errno;
                } else if (errno != EAGAIN) {
                    _status = Stream::Status::ERROR;
                    _errno = errno;
                }
                return total_nsent;
            }
        }

        total_nsent += nsent;
        length -= nsent;
        buffer += nsent;
    }

    return total_nsent;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(243, 0)" endLine="(284, 1)" clone_start="2" clone_end="8">
			<code function_name="TcpStream::read(uint8_t* buffer, size_t max_length)">size_t TcpStream::read(uint8_t* buffer, size_t max_length) {
    ssize_t ret = 0;

    if (_status != Stream::Status::CONNECTED) {
        disconnect();
        connect();
        if (_status != Stream::Status::CONNECTED) {
            return 0;
        }
    }

    if (!readable(10000)) {
        return 0;
    }

    while ((ret = ::recv(_sockfd, buffer, max_length, 0)) &lt; 0) {
        if (errno == EINTR) {
            continue;
        } else {
            // error
            if (errno != EAGAIN) {
                _status = Stream::Status::ERROR;
                _errno = errno;
                ROS_ERROR("Read errno %d, error %s.", errno, strerror(errno));
            }
        }

        return 0;
    }

    if (ret == 0) {
        _status = Stream::Status::ERROR;
        _errno = errno;
        ROS_ERROR("Remote closed.");
        disconnect();
        if (connect()) {
            ROS_INFO("Reconnect tcp success.");
        }
    }

    return ret;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(256, 0)" endLine="(304, 1)" clone_start="13" clone_end="19">
			<code function_name="RawStream::connect()">bool RawStream::connect() {
    if (_data_stream) {
        if (_data_stream-&gt;get_status() != Stream::Status::CONNECTED) {
            if (!_data_stream-&gt;connect()) {
                ROS_ERROR("data stream connect failed.");
                return false;
            }
            _data_stream_status-&gt;status = Stream::Status::CONNECTED;
            _stream_status-&gt;set_ins_stream_type(apollo::common::gnss_status::StreamStatus::CONNECTED);
        }
    }

    if (_command_stream) {
        if (_command_stream-&gt;get_status() != Stream::Status::CONNECTED) {
            if (!_data_stream-&gt;connect()) {
                ROS_ERROR("command stream connect failed.");
                return false;
            }
            _command_stream_status-&gt;status = Stream::Status::CONNECTED;
        }
    }

    if (_in_rtk_stream) {
        if (_in_rtk_stream-&gt;get_status() != Stream::Status::CONNECTED) {
            if (!_in_rtk_stream-&gt;connect()) {
                ROS_ERROR("in rtk stream connect failed.");
            } else {
                _in_rtk_stream_status-&gt;status = Stream::Status::CONNECTED;
                _stream_status-&gt;set_rtk_stream_in_type(apollo::common::gnss_status::StreamStatus::CONNECTED);
            }
        }
    } else {
        _stream_status-&gt;set_rtk_stream_in_type(apollo::common::gnss_status::StreamStatus::CONNECTED);
    }

    if (_out_rtk_stream) {
        if (_out_rtk_stream-&gt;get_status() != Stream::Status::CONNECTED) {
            if (!_out_rtk_stream-&gt;connect()) {
                ROS_ERROR("out rtk stream connect failed.");
            } else {
                _out_rtk_stream_status-&gt;status = Stream::Status::CONNECTED;
                _stream_status-&gt;set_rtk_stream_out_type(apollo::common::gnss_status::StreamStatus::CONNECTED);
            }
        }
     } else {
        _stream_status-&gt;set_rtk_stream_out_type(apollo::common::gnss_status::StreamStatus::CONNECTED);
    }
    return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(256, 0)" endLine="(304, 1)" clone_start="2" clone_end="8">
			<code function_name="RawStream::connect()">bool RawStream::connect() {
    if (_data_stream) {
        if (_data_stream-&gt;get_status() != Stream::Status::CONNECTED) {
            if (!_data_stream-&gt;connect()) {
                ROS_ERROR("data stream connect failed.");
                return false;
            }
            _data_stream_status-&gt;status = Stream::Status::CONNECTED;
            _stream_status-&gt;set_ins_stream_type(apollo::common::gnss_status::StreamStatus::CONNECTED);
        }
    }

    if (_command_stream) {
        if (_command_stream-&gt;get_status() != Stream::Status::CONNECTED) {
            if (!_data_stream-&gt;connect()) {
                ROS_ERROR("command stream connect failed.");
                return false;
            }
            _command_stream_status-&gt;status = Stream::Status::CONNECTED;
        }
    }

    if (_in_rtk_stream) {
        if (_in_rtk_stream-&gt;get_status() != Stream::Status::CONNECTED) {
            if (!_in_rtk_stream-&gt;connect()) {
                ROS_ERROR("in rtk stream connect failed.");
            } else {
                _in_rtk_stream_status-&gt;status = Stream::Status::CONNECTED;
                _stream_status-&gt;set_rtk_stream_in_type(apollo::common::gnss_status::StreamStatus::CONNECTED);
            }
        }
    } else {
        _stream_status-&gt;set_rtk_stream_in_type(apollo::common::gnss_status::StreamStatus::CONNECTED);
    }

    if (_out_rtk_stream) {
        if (_out_rtk_stream-&gt;get_status() != Stream::Status::CONNECTED) {
            if (!_out_rtk_stream-&gt;connect()) {
                ROS_ERROR("out rtk stream connect failed.");
            } else {
                _out_rtk_stream_status-&gt;status = Stream::Status::CONNECTED;
                _stream_status-&gt;set_rtk_stream_out_type(apollo::common::gnss_status::StreamStatus::CONNECTED);
            }
        }
     } else {
        _stream_status-&gt;set_rtk_stream_out_type(apollo::common::gnss_status::StreamStatus::CONNECTED);
    }
    return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\vehicle_controller.cc" startLine="(26, 0)" endLine="(29, 1)" clone_start="1" clone_end="4">
			<code function_name="VehicleController::driving_mode()">Chassis::DrivingMode VehicleController::driving_mode() {
  std::lock_guard&lt;std::mutex&gt; lock(mode_mutex_);
  return driving_mode_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(719, 0)" endLine="(722, 1)" clone_start="1" clone_end="4">
			<code function_name="LincolnController::chassis_error_code()">Chassis::ErrorCode LincolnController::chassis_error_code() {
  std::lock_guard&lt;std::mutex&gt; lock(chassis_error_code_mutex_);
  return chassis_error_code_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\vehicle_controller.cc" startLine="(31, 0)" endLine="(35, 1)" clone_start="1" clone_end="4">
			<code function_name="VehicleController::set_driving_mode( const Chassis::DrivingMode&amp; driving_mode)">void VehicleController::set_driving_mode(
    const Chassis::DrivingMode&amp; driving_mode) {
  std::lock_guard&lt;std::mutex&gt; lock(mode_mutex_);
  driving_mode_ = driving_mode;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(724, 0)" endLine="(728, 1)" clone_start="1" clone_end="4">
			<code function_name="LincolnController::set_chassis_error_code( const Chassis::ErrorCode&amp; error_code)">void LincolnController::set_chassis_error_code(
    const Chassis::ErrorCode&amp; error_code) {
  std::lock_guard&lt;std::mutex&gt; lock(chassis_error_code_mutex_);
  chassis_error_code_ = error_code;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\aaboxkdtree2d.h" startLine="(259, 2)" endLine="(323, 3)" clone_start="54" clone_end="61">
			<code function_name="GetNearestObjectInternal(const Vec2d&amp; point,double* const min_distance_sqr, ObjectPtr* const nearest_object) const">  void GetNearestObjectInternal(const Vec2d&amp; point,
                                double* const min_distance_sqr,
                                ObjectPtr* const nearest_object) const {
    if (LowerDistanceSquareToPoint(point) &gt;= *min_distance_sqr - kMathEpsilon) {
      return;
    }
    const double pvalue = (partition_ == PARTITION_X ? point.x() : point.y());
    const bool search_left_first = (pvalue &lt; partition_position_);
    if (search_left_first) {
      if (left_subnode_ != nullptr) {
        left_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                nearest_object);
      }
    } else {
      if (right_subnode_ != nullptr) {
        right_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                 nearest_object);
      }
    }
    if (*min_distance_sqr &lt;= kMathEpsilon) {
      return;
    }

    if (search_left_first) {
      for (int i = 0; i &lt; num_objects_; ++i) {
        const double bound = objects_sorted_by_min_bound_[i];
        if (bound &gt; pvalue &amp;&amp; Square(bound - pvalue) &gt; *min_distance_sqr) {
          break;
        }
        ObjectPtr object = objects_sorted_by_min_[i];
        const double distance_sqr = object-&gt;DistanceSquareTo(point);
        if (distance_sqr &lt; *min_distance_sqr) {
          *min_distance_sqr = distance_sqr;
          *nearest_object = object;
        }
      }
    } else {
      for (int i = 0; i &lt; num_objects_; ++i) {
        const double bound = objects_sorted_by_max_bound_[i];
        if (bound &lt; pvalue &amp;&amp; Square(bound - pvalue) &gt; *min_distance_sqr) {
          break;
        }
        ObjectPtr object = objects_sorted_by_max_[i];
        const double distance_sqr = object-&gt;DistanceSquareTo(point);
        if (distance_sqr &lt; *min_distance_sqr) {
          *min_distance_sqr = distance_sqr;
          *nearest_object = object;
        }
      }
    }
    if (*min_distance_sqr &lt;= kMathEpsilon) {
      return;
    }
    if (search_left_first) {
      if (right_subnode_ != nullptr) {
        right_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                 nearest_object);
      }
    } else {
      if (left_subnode_ != nullptr) {
        left_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                nearest_object);
      }
    }
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\aaboxkdtree2d.h" startLine="(259, 2)" endLine="(323, 3)" clone_start="9" clone_end="16">
			<code function_name="GetNearestObjectInternal(const Vec2d&amp; point,double* const min_distance_sqr, ObjectPtr* const nearest_object) const">  void GetNearestObjectInternal(const Vec2d&amp; point,
                                double* const min_distance_sqr,
                                ObjectPtr* const nearest_object) const {
    if (LowerDistanceSquareToPoint(point) &gt;= *min_distance_sqr - kMathEpsilon) {
      return;
    }
    const double pvalue = (partition_ == PARTITION_X ? point.x() : point.y());
    const bool search_left_first = (pvalue &lt; partition_position_);
    if (search_left_first) {
      if (left_subnode_ != nullptr) {
        left_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                nearest_object);
      }
    } else {
      if (right_subnode_ != nullptr) {
        right_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                 nearest_object);
      }
    }
    if (*min_distance_sqr &lt;= kMathEpsilon) {
      return;
    }

    if (search_left_first) {
      for (int i = 0; i &lt; num_objects_; ++i) {
        const double bound = objects_sorted_by_min_bound_[i];
        if (bound &gt; pvalue &amp;&amp; Square(bound - pvalue) &gt; *min_distance_sqr) {
          break;
        }
        ObjectPtr object = objects_sorted_by_min_[i];
        const double distance_sqr = object-&gt;DistanceSquareTo(point);
        if (distance_sqr &lt; *min_distance_sqr) {
          *min_distance_sqr = distance_sqr;
          *nearest_object = object;
        }
      }
    } else {
      for (int i = 0; i &lt; num_objects_; ++i) {
        const double bound = objects_sorted_by_max_bound_[i];
        if (bound &lt; pvalue &amp;&amp; Square(bound - pvalue) &gt; *min_distance_sqr) {
          break;
        }
        ObjectPtr object = objects_sorted_by_max_[i];
        const double distance_sqr = object-&gt;DistanceSquareTo(point);
        if (distance_sqr &lt; *min_distance_sqr) {
          *min_distance_sqr = distance_sqr;
          *nearest_object = object;
        }
      }
    }
    if (*min_distance_sqr &lt;= kMathEpsilon) {
      return;
    }
    if (search_left_first) {
      if (right_subnode_ != nullptr) {
        right_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                 nearest_object);
      }
    } else {
      if (left_subnode_ != nullptr) {
        left_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                nearest_object);
      }
    }
  }</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\planning\planner\planner.h" startLine="(42, 2)" endLine="(42, 22)" clone_start="1" clone_end="1">
			<code function_name="Planner()">  Planner() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\controller\controller.h" startLine="(52, 2)" endLine="(52, 25)" clone_start="1" clone_end="1">
			<code function_name="Controller()">  Controller() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\can_comm\can_sender.h" startLine="(129, 2)" endLine="(129, 24)" clone_start="1" clone_end="1">
			<code function_name="CanSender()">  CanSender() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\can_comm\can_receiver.h" startLine="(48, 2)" endLine="(48, 26)" clone_start="1" clone_end="1">
			<code function_name="CanReceiver()">  CanReceiver() = default;</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\planning\planner\planner.h" startLine="(47, 2)" endLine="(47, 31)" clone_start="1" clone_end="1">
			<code function_name="~Planner()">  virtual ~Planner() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\controller\controller.h" startLine="(57, 2)" endLine="(57, 34)" clone_start="1" clone_end="1">
			<code function_name="~Controller()">  virtual ~Controller() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\can_comm\can_sender.h" startLine="(134, 2)" endLine="(134, 33)" clone_start="1" clone_end="1">
			<code function_name="~CanSender()">  virtual ~CanSender() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\can_comm\can_receiver.h" startLine="(53, 2)" endLine="(53, 35)" clone_start="1" clone_end="1">
			<code function_name="~CanReceiver()">  virtual ~CanReceiver() = default;</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(312, 0)" endLine="(333, 1)" clone_start="5" clone_end="12">
			<code function_name="LincolnController::EnableSpeedOnlyMode()">ErrorCode LincolnController::EnableSpeedOnlyMode() {
  if (driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
      driving_mode() == Chassis::AUTO_SPEED_ONLY) {
    set_driving_mode(Chassis::AUTO_SPEED_ONLY);
    AINFO &lt;&lt; "Already in AUTO_SPEED_ONLY mode";
    return ErrorCode::OK;
  }
  brake_60_-&gt;set_enable();
  throttle_62_-&gt;set_enable();
  steering_64_-&gt;set_disable();

  can_sender_-&gt;Update();
  if (CheckResponse(CHECK_RESPONSE_SPEED_UNIT_FLAG, true) == false) {
    AERROR &lt;&lt; "Failed to switch to AUTO_STEER_ONLY mode.";
    Emergency();
    return ErrorCode::CANBUS_ERROR;
  } else {
    set_driving_mode(Chassis::AUTO_SPEED_ONLY);
    AINFO &lt;&lt; "Switch to AUTO_SPEED_ONLY mode ok.";
    return ErrorCode::OK;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(289, 0)" endLine="(310, 1)" clone_start="5" clone_end="12">
			<code function_name="LincolnController::EnableSteeringOnlyMode()">ErrorCode LincolnController::EnableSteeringOnlyMode() {
  if (driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
      driving_mode() == Chassis::AUTO_STEER_ONLY) {
    set_driving_mode(Chassis::AUTO_STEER_ONLY);
    AINFO &lt;&lt; "Already in AUTO_STEER_ONLY mode";
    return ErrorCode::OK;
  }
  brake_60_-&gt;set_disable();
  throttle_62_-&gt;set_disable();
  steering_64_-&gt;set_enable();

  can_sender_-&gt;Update();
  if (CheckResponse(CHECK_RESPONSE_STEER_UNIT_FLAG, true) == false) {
    AERROR &lt;&lt; "Failed to switch to AUTO_STEER_ONLY mode.";
    Emergency();
    return ErrorCode::CANBUS_ERROR;
  } else {
    set_driving_mode(Chassis::AUTO_STEER_ONLY);
    AINFO &lt;&lt; "Switch to AUTO_STEER_ONLY mode ok.";
    return ErrorCode::OK;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(257, 0)" endLine="(278, 1)" clone_start="3" clone_end="10">
			<code function_name="LincolnController::EnableAutoMode()">ErrorCode LincolnController::EnableAutoMode() {
  if (driving_mode() == Chassis::COMPLETE_AUTO_DRIVE) {
    AINFO &lt;&lt; "already in COMPLETE_AUTO_DRIVE mode";
    return ErrorCode::OK;
  }
  brake_60_-&gt;set_enable();
  throttle_62_-&gt;set_enable();
  steering_64_-&gt;set_enable();

  can_sender_-&gt;Update();
  const int32_t flag =
      CHECK_RESPONSE_STEER_UNIT_FLAG | CHECK_RESPONSE_SPEED_UNIT_FLAG;
  if (!CheckResponse(flag, true)) {
    AERROR &lt;&lt; "Failed to switch to COMPLETE_AUTO_DRIVE mode.";
    Emergency();
    return ErrorCode::CANBUS_ERROR;
  } else {
    set_driving_mode(Chassis::COMPLETE_AUTO_DRIVE);
    AINFO &lt;&lt; "Switch to COMPLETE_AUTO_DRIVE mode ok.";
    return ErrorCode::OK;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\decision\decision.h" startLine="(38, 2)" endLine="(38, 32)" clone_start="1" clone_end="1">
			<code function_name="~Decision()">  virtual ~Decision() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\control.h" startLine="(80, 2)" endLine="(80, 31)" clone_start="1" clone_end="1">
			<code function_name="~Control()">  virtual ~Control() = default;</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\tools\terminal.cc" startLine="(126, 0)" endLine="(166, 1)" clone_start="1" clone_end="8">
			<code function_name="main(int argc, char** argv)">int main(int argc, char** argv) {
  google::InitGoogleLogging(argv[0]);
  FLAGS_alsologtostderr = true;
  FLAGS_v = 3;

  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);

  ros::init(argc, argv, "terminal");

  apollo::common::adapter::AdapterManagerConfig config;
  config.set_is_ros(true);
  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(apollo::common::adapter::AdapterConfig::PUBLISH_ONLY);
    sub_config-&gt;set_type(apollo::common::adapter::AdapterConfig::PAD);
  }

  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(apollo::common::adapter::AdapterConfig::RECEIVE_ONLY);
    sub_config-&gt;set_type(apollo::common::adapter::AdapterConfig::CHASSIS);
  }

  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(apollo::common::adapter::AdapterConfig::RECEIVE_ONLY);
    sub_config-&gt;set_type(apollo::common::adapter::AdapterConfig::LOCALIZATION);
  }

  AdapterManager::Init(config);
  AdapterManager::SetChassisCallback(on_chassis);

  help();
  pthread_t pid;
  if (pthread_create(&amp;pid, NULL, terminal_thread, NULL) != 0) {
    AINFO &lt;&lt; "create terminal thread failed.";
    exit(0);
  }
  ros::spin();
  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\tools\enter_auto_mode.cc" startLine="(92, 0)" endLine="(123, 1)" clone_start="1" clone_end="8">
			<code function_name="main(int argc, char** argv)">int main(int argc, char** argv) {
  google::InitGoogleLogging(argv[0]);
  FLAGS_alsologtostderr = true;
  FLAGS_v = 4;

  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);

  ros::init(argc, argv, "enter_auto_mode");

  // Setup AdapterManager.
  AdapterManagerConfig config;
  config.set_is_ros(true);
  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(AdapterConfig::PUBLISH_ONLY);
    sub_config-&gt;set_type(AdapterConfig::PAD);
  }

  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(AdapterConfig::RECEIVE_ONLY);
    sub_config-&gt;set_type(AdapterConfig::CHASSIS);
  }
  AdapterManager::Init(config);
  AdapterManager::SetChassisCallback(
      apollo::control::SwitchDrivingMode::MonitorDrivingMode);

  // FIXME: delay for ros pub/sub ready
  sleep(1);
  apollo::control::SwitchDrivingMode::EnterAutoMode();
  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\tools\teleop.cc" startLine="(382, 0)" endLine="(421, 1)" clone_start="1" clone_end="8">
			<code function_name="main(int32_t argc, char** argv)">int main(int32_t argc, char** argv) {
  google::InitGoogleLogging(argv[0]);
  FLAGS_alsologtostderr = true;
  FLAGS_v = 3;

  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);

  ros::init(argc, argv, "teleop");
  signal(SIGINT, signal_handler);

  apollo::common::adapter::AdapterManagerConfig config;
  config.set_is_ros(true);
  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(apollo::common::adapter::AdapterConfig::PUBLISH_ONLY);
    sub_config-&gt;set_type(
        apollo::common::adapter::AdapterConfig::CONTROL_COMMAND);
  }

  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(apollo::common::adapter::AdapterConfig::RECEIVE_ONLY);
    sub_config-&gt;set_type(apollo::common::adapter::AdapterConfig::CHASSIS);
  }

  apollo::common::adapter::AdapterManager::Init(config);

  Teleop teleop;

  if (teleop.Start() != 0) {
    AERROR &lt;&lt; "Teleop start failed.";
    return -1;
  }
  Teleop::PrintKeycode();

  ros::spin();
  teleop.Stop();
  AINFO &lt;&lt; "Teleop exit done.";
  return 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(227, 0)" endLine="(344, 1)" clone_start="20" clone_end="25">
			<code function_name="NovatelParser::prepare_message(MessagePtr&amp; message_ptr)">Parser::MessageType NovatelParser::prepare_message(MessagePtr&amp; message_ptr) {
    if (!check_crc()) {
        ROS_ERROR("CRC check failed.");
        return MessageType::NONE;
    }

    uint8_t* message = nullptr;
    novatel::MessageId message_id;
    uint16_t message_length;
    uint16_t gps_week;
    uint32_t gps_millisecs;
    if (_buffer[2] == novatel::SYNC_2_LONG_HEADER) {
        auto header = reinterpret_cast&lt;const novatel::LongHeader*&gt;(_buffer.data());
        message = _buffer.data() + sizeof(novatel::LongHeader);
        gps_week = header-&gt;gps_week;
        gps_millisecs = header-&gt;gps_millisecs;
        message_id = header-&gt;message_id;
        message_length = header-&gt;message_length;
    } else {
        auto header = reinterpret_cast&lt;const novatel::ShortHeader*&gt;(_buffer.data());
        message = _buffer.data() + sizeof(novatel::ShortHeader);
        gps_week = header-&gt;gps_week;
        gps_millisecs = header-&gt;gps_millisecs;
        message_id = header-&gt;message_id;
        message_length = header-&gt;message_length;
    }
    switch (message_id) {
    case novatel::BESTGNSSPOS:
    case novatel::BESTPOS:
    case novatel::PSRPOS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::BestPos), "Incorrect message_length");
        if (message_length != sizeof(novatel::BestPos)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }
        if (handle_best_pos(reinterpret_cast&lt;novatel::BestPos*&gt;(message), gps_week,
                            gps_millisecs)) {
            message_ptr = &amp;_gnss;
            return MessageType::GNSS;
        }
        break;

    case novatel::BESTGNSSVEL:
    case novatel::BESTVEL:
    case novatel::PSRVEL:
        //ROS_ERROR_COND(message_length != sizeof(novatel::BestVel), "Incorrect message_length");
        if (message_length != sizeof(novatel::BestVel)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }
        if (handle_best_vel(reinterpret_cast&lt;novatel::BestVel*&gt;(message), gps_week,
                            gps_millisecs)) {
            message_ptr = &amp;_gnss;
            return MessageType::GNSS;
        }
        break;

    case novatel::CORRIMUDATA:
    case novatel::CORRIMUDATAS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::CorrImuData), "Incorrect message_length");
        if (message_length != sizeof(novatel::CorrImuData)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_corr_imu_data(reinterpret_cast&lt;novatel::CorrImuData*&gt;(message))) {
            message_ptr = &amp;_ins;
            return MessageType::INS;
        }
        break;

    case novatel::INSCOV:
    case novatel::INSCOVS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::InsCov), "Incorrect message_length");
        if (message_length != sizeof(novatel::InsCov)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_ins_cov(reinterpret_cast&lt;novatel::InsCov*&gt;(message))) {
            message_ptr = &amp;_ins;
            return MessageType::INS;
        }
        break;

    case novatel::INSPVA:
    case novatel::INSPVAS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::InsPva), "Incorrect message_length");
        if (message_length != sizeof(novatel::InsPva)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_ins_pva(reinterpret_cast&lt;novatel::InsPva*&gt;(message))) {
            message_ptr = &amp;_ins;
            return MessageType::INS;
        }
        break;

    case novatel::RAWIMUX:
    case novatel::RAWIMUSX:
        //ROS_ERROR_COND(message_length != sizeof(novatel::RawImuX), "Incorrect message_length");
        if (message_length != sizeof(novatel::RawImuX)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_raw_imu_x(reinterpret_cast&lt;novatel::RawImuX*&gt;(message))) {
            message_ptr = &amp;_imu;
            return MessageType::IMU;
        }
        break;

    default:
        break;
    }
    return MessageType::NONE;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(227, 0)" endLine="(344, 1)" clone_start="13" clone_end="18">
			<code function_name="NovatelParser::prepare_message(MessagePtr&amp; message_ptr)">Parser::MessageType NovatelParser::prepare_message(MessagePtr&amp; message_ptr) {
    if (!check_crc()) {
        ROS_ERROR("CRC check failed.");
        return MessageType::NONE;
    }

    uint8_t* message = nullptr;
    novatel::MessageId message_id;
    uint16_t message_length;
    uint16_t gps_week;
    uint32_t gps_millisecs;
    if (_buffer[2] == novatel::SYNC_2_LONG_HEADER) {
        auto header = reinterpret_cast&lt;const novatel::LongHeader*&gt;(_buffer.data());
        message = _buffer.data() + sizeof(novatel::LongHeader);
        gps_week = header-&gt;gps_week;
        gps_millisecs = header-&gt;gps_millisecs;
        message_id = header-&gt;message_id;
        message_length = header-&gt;message_length;
    } else {
        auto header = reinterpret_cast&lt;const novatel::ShortHeader*&gt;(_buffer.data());
        message = _buffer.data() + sizeof(novatel::ShortHeader);
        gps_week = header-&gt;gps_week;
        gps_millisecs = header-&gt;gps_millisecs;
        message_id = header-&gt;message_id;
        message_length = header-&gt;message_length;
    }
    switch (message_id) {
    case novatel::BESTGNSSPOS:
    case novatel::BESTPOS:
    case novatel::PSRPOS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::BestPos), "Incorrect message_length");
        if (message_length != sizeof(novatel::BestPos)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }
        if (handle_best_pos(reinterpret_cast&lt;novatel::BestPos*&gt;(message), gps_week,
                            gps_millisecs)) {
            message_ptr = &amp;_gnss;
            return MessageType::GNSS;
        }
        break;

    case novatel::BESTGNSSVEL:
    case novatel::BESTVEL:
    case novatel::PSRVEL:
        //ROS_ERROR_COND(message_length != sizeof(novatel::BestVel), "Incorrect message_length");
        if (message_length != sizeof(novatel::BestVel)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }
        if (handle_best_vel(reinterpret_cast&lt;novatel::BestVel*&gt;(message), gps_week,
                            gps_millisecs)) {
            message_ptr = &amp;_gnss;
            return MessageType::GNSS;
        }
        break;

    case novatel::CORRIMUDATA:
    case novatel::CORRIMUDATAS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::CorrImuData), "Incorrect message_length");
        if (message_length != sizeof(novatel::CorrImuData)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_corr_imu_data(reinterpret_cast&lt;novatel::CorrImuData*&gt;(message))) {
            message_ptr = &amp;_ins;
            return MessageType::INS;
        }
        break;

    case novatel::INSCOV:
    case novatel::INSCOVS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::InsCov), "Incorrect message_length");
        if (message_length != sizeof(novatel::InsCov)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_ins_cov(reinterpret_cast&lt;novatel::InsCov*&gt;(message))) {
            message_ptr = &amp;_ins;
            return MessageType::INS;
        }
        break;

    case novatel::INSPVA:
    case novatel::INSPVAS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::InsPva), "Incorrect message_length");
        if (message_length != sizeof(novatel::InsPva)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_ins_pva(reinterpret_cast&lt;novatel::InsPva*&gt;(message))) {
            message_ptr = &amp;_ins;
            return MessageType::INS;
        }
        break;

    case novatel::RAWIMUX:
    case novatel::RAWIMUSX:
        //ROS_ERROR_COND(message_length != sizeof(novatel::RawImuX), "Incorrect message_length");
        if (message_length != sizeof(novatel::RawImuX)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_raw_imu_x(reinterpret_cast&lt;novatel::RawImuX*&gt;(message))) {
            message_ptr = &amp;_imu;
            return MessageType::IMU;
        }
        break;

    default:
        break;
    }
    return MessageType::NONE;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\localization\rtk\rtk_localization.cc" startLine="(37, 0)" endLine="(57, 1)" clone_start="9" clone_end="15">
			<code function_name="RTKLocalization::Start()">Status RTKLocalization::Start() {
  AdapterManager::Init(FLAGS_rtk_adapter_config_file);

  // start ROS timer, one-shot = false, auto-start = true
  const double duration = 1.0 / FLAGS_localization_publish_freq;
  timer_ = AdapterManager::CreateTimer(ros::Duration(duration),
                                       &amp;RTKLocalization::OnTimer, this);
  apollo::common::monitor::MonitorBuffer buffer(&amp;monitor_);
  if (!AdapterManager::GetGps()) {
    buffer.ERROR() &lt;&lt; "GPS input not initialized. Check file "
                   &lt;&lt; FLAGS_rtk_adapter_config_file;
    buffer.PrintLog();
    return Status(apollo::common::LOCALIZATION_ERROR, "no GPS adapter");
  }
  if (!AdapterManager::GetImu()) {
    buffer.ERROR("IMU input not initialized. Check your adapter.conf file!");
    buffer.PrintLog();
    return Status(apollo::common::LOCALIZATION_ERROR, "no IMU adapter");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\localization\camera\camera_localization.cc" startLine="(38, 0)" endLine="(75, 1)" clone_start="23" clone_end="30">
			<code function_name="CameraLocalization::Start()">Status CameraLocalization::Start() {
  MonitorBuffer buffer(&amp;monitor_);
  if (!apollo::common::util::GetProtoFromFile(
          FLAGS_camera_parameter_config_file, &amp;camera_parameter_)) {
    buffer.ERROR() &lt;&lt; "Camera parameter is not initialized. Check "
                   &lt;&lt; FLAGS_camera_parameter_config_file;
    buffer.PrintLog();
    return Status(apollo::common::LOCALIZATION_ERROR,
                  "failed to load camera parameter");
  }

  AdapterManager::Init(FLAGS_camera_adapter_config_file);
  // start ROS timer, one-shot = false, auto-start = true
  const double duration = 1.0 / FLAGS_localization_publish_freq;
  timer_ = AdapterManager::CreateTimer(ros::Duration(duration),
                                       &amp;CameraLocalization::OnTimer, this);
  if (!AdapterManager::GetGps()) {
    buffer.ERROR() &lt;&lt; "GPS input not initialized. Check "
                   &lt;&lt; FLAGS_camera_adapter_config_file;
    buffer.PrintLog();
    return Status(apollo::common::LOCALIZATION_ERROR, "no GPS adapter");
  }
  if (!AdapterManager::GetCamera()) {
    buffer.ERROR() &lt;&lt; "Camera input not initialized. Check "
                   &lt;&lt; FLAGS_camera_adapter_config_file;
    buffer.PrintLog();
    return Status(apollo::common::LOCALIZATION_ERROR, "no Camera adapter");
  }
  // IMU is optional
  if (!AdapterManager::GetImu()) {
    buffer.INFO("IMU input not initialized. Check your adapter.conf file!");
    buffer.PrintLog();
    use_imu_ = false;
  } else {
    use_imu_ = true;
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\localization\camera\camera_localization.cc" startLine="(38, 0)" endLine="(75, 1)" clone_start="17" clone_end="23">
			<code function_name="CameraLocalization::Start()">Status CameraLocalization::Start() {
  MonitorBuffer buffer(&amp;monitor_);
  if (!apollo::common::util::GetProtoFromFile(
          FLAGS_camera_parameter_config_file, &amp;camera_parameter_)) {
    buffer.ERROR() &lt;&lt; "Camera parameter is not initialized. Check "
                   &lt;&lt; FLAGS_camera_parameter_config_file;
    buffer.PrintLog();
    return Status(apollo::common::LOCALIZATION_ERROR,
                  "failed to load camera parameter");
  }

  AdapterManager::Init(FLAGS_camera_adapter_config_file);
  // start ROS timer, one-shot = false, auto-start = true
  const double duration = 1.0 / FLAGS_localization_publish_freq;
  timer_ = AdapterManager::CreateTimer(ros::Duration(duration),
                                       &amp;CameraLocalization::OnTimer, this);
  if (!AdapterManager::GetGps()) {
    buffer.ERROR() &lt;&lt; "GPS input not initialized. Check "
                   &lt;&lt; FLAGS_camera_adapter_config_file;
    buffer.PrintLog();
    return Status(apollo::common::LOCALIZATION_ERROR, "no GPS adapter");
  }
  if (!AdapterManager::GetCamera()) {
    buffer.ERROR() &lt;&lt; "Camera input not initialized. Check "
                   &lt;&lt; FLAGS_camera_adapter_config_file;
    buffer.PrintLog();
    return Status(apollo::common::LOCALIZATION_ERROR, "no Camera adapter");
  }
  // IMU is optional
  if (!AdapterManager::GetImu()) {
    buffer.INFO("IMU input not initialized. Check your adapter.conf file!");
    buffer.PrintLog();
    use_imu_ = false;
  } else {
    use_imu_ = true;
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\control.h" startLine="(53, 2)" endLine="(53, 79)" clone_start="1" clone_end="1">
			<code function_name="Control()">  Control() : monitor_(apollo::common::monitor::MonitorMessageItem::CONTROL) {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\canbus.h" startLine="(57, 2)" endLine="(57, 77)" clone_start="1" clone_end="1">
			<code function_name="Canbus()">  Canbus() : monitor_(apollo::common::monitor::MonitorMessageItem::CANBUS) {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\stream_nodelet.cpp" startLine="(49, 0)" endLine="(73, 1)" clone_start="19" clone_end="25">
			<code function_name="StreamNodelet::onInit()">void StreamNodelet::onInit() {
    ros::NodeHandle&amp; nh = getPrivateNodeHandle();
    std::string gnss_conf;
    std::string raw_data_topic;
    std::string rtcm_data_topic;
    std::string stream_status_topic;


    nh.param("gnss_conf", gnss_conf, std::string("./conf/gnss_conf.txt"));
    nh.param("raw_data_topic", raw_data_topic, std::string("/apollo/sensor/gnss/raw_data"));
    nh.param("rtcm_data_topic", rtcm_data_topic, std::string("/apollo/sensor/gnss/rtcm_data"));
    nh.param("stream_status_topic", stream_status_topic, std::string("/apollo/sensor/gnss/stream_status"));

    ROS_INFO_STREAM("gnss conf: " &lt;&lt; gnss_conf);
    ROS_INFO_STREAM("raw data topic: " &lt;&lt; raw_data_topic);

    init_signal();
    _raw_stream.reset(new RawStream(nh, getName(), raw_data_topic, rtcm_data_topic, stream_status_topic));
    if (!_raw_stream-&gt;init(gnss_conf)) {
        ROS_ERROR("Init stream nodelet failed.");
        ROS_ERROR_STREAM("Init stream nodelet failed.");
        return;
    }
    ROS_INFO("Init stream nodelet success.");
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\parser_nodelet.cpp" startLine="(39, 0)" endLine="(71, 1)" clone_start="27" clone_end="33">
			<code function_name="ParserNodelet::onInit()">void ParserNodelet::onInit() {
    ros::NodeHandle&amp; nh = getPrivateNodeHandle();
    std::string gnss_conf;
    std::string raw_data_topic;
    std::string gpgga_topic;
    std::string corr_imu_topic;
    std::string odometry_topic;
    std::string gnss_status_topic;
    std::string ins_status_topic;

    nh.param("gnss_conf", gnss_conf, std::string("./conf/gnss_conf.txt"));
    nh.param("raw_data_topic", raw_data_topic, std::string("/apollo/sensor/gnss/raw_data"));
    nh.param("gpgga_topic", gpgga_topic, std::string("/apollo/sensor/gnss/gpgga"));
    nh.param("corr_imu_topic", corr_imu_topic, std::string("/apollo/sensor/gnss/corrected_imu"));
    nh.param("odometry_topic", odometry_topic, std::string("/apollo/sensor/gnss/odometry"));
    nh.param("gnss_status_topic", gnss_status_topic, std::string("/apollo/sensor/gnss/gnss_status"));
    nh.param("ins_status_topic", ins_status_topic, std::string("/apollo/sensor/gnss/ins_status"));

    _data_parser.reset(new DataParser(
                                nh,
                                raw_data_topic,
                                gpgga_topic,
                                corr_imu_topic,
                                odometry_topic,
                                gnss_status_topic,
                                ins_status_topic));
    if (!_data_parser-&gt;init(gnss_conf)) {
        ROS_ERROR("Init parser nodelet failed.");
        ROS_ERROR_STREAM("Init parser nodelet failed.");
        return;
    }
    ROS_INFO("Init parser nodelet success.");
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(85, 0)" endLine="(89, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6f::vdop(const std::uint8_t* bytes, int32_t length) const">double Gps6f::vdop(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(79, 0)" endLine="(83, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6f::hdop(const std::uint8_t* bytes, int32_t length) const">double Gps6f::hdop(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 5);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(78, 0)" endLine="(83, 1)" clone_start="1" clone_end="6">
			<code function_name="Gps6e::compass_direction(const std::uint8_t* bytes, int32_t length) const">double Gps6e::compass_direction(const std::uint8_t* bytes,
                                int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 4);
  return x * 45.000000;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(91, 0)" endLine="(95, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6f::fix_quality(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6f::fix_quality(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 7);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(85, 0)" endLine="(89, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6f::vdop(const std::uint8_t* bytes, int32_t length) const">double Gps6f::vdop(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(85, 0)" endLine="(89, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6e::pdop(const std::uint8_t* bytes, int32_t length) const">double Gps6e::pdop(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 7);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\polygon2d.cc" startLine="(349, 0)" endLine="(389, 1)" clone_start="29" clone_end="36">
			<code function_name="Polygon2d::GetOverlap(const LineSegment2d&amp; line_segment, Vec2d* const first, Vec2d* const last) const">bool Polygon2d::GetOverlap(const LineSegment2d&amp; line_segment,
                           Vec2d* const first, Vec2d* const last) const {
  CHECK_GE(points_.size(), 3);
  CHECK_NOTNULL(first);
  CHECK_NOTNULL(last);

  if (line_segment.length() &lt;= kMathEpsilon) {
    if (!IsPointIn(line_segment.start())) {
      return false;
    }
    *first = line_segment.start();
    *last = line_segment.start();
    return true;
  }

  double min_proj = line_segment.length();
  double max_proj = 0;
  if (IsPointIn(line_segment.start())) {
    *first = line_segment.start();
    min_proj = 0.0;
  }
  if (IsPointIn(line_segment.end())) {
    *last = line_segment.end();
    max_proj = line_segment.length();
  }
  for (const auto&amp; poly_seg : line_segments_) {
    Vec2d pt;
    if (poly_seg.GetIntersect(line_segment, &amp;pt)) {
      const double proj = line_segment.ProjectOntoUnit(pt);
      if (proj &lt; min_proj) {
        min_proj = proj;
        *first = pt;
      }
      if (proj &gt; max_proj) {
        max_proj = proj;
        *last = pt;
      }
    }
  }
  return min_proj &lt;= max_proj + kMathEpsilon;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\polygon2d.cc" startLine="(445, 0)" endLine="(465, 1)" clone_start="11" clone_end="18">
			<code function_name="Polygon2d::ExtremePoints(const double heading, Vec2d* const first, Vec2d* const last) const">void Polygon2d::ExtremePoints(const double heading, Vec2d* const first,
                              Vec2d* const last) const {
  CHECK_GE(points_.size(), 3);
  CHECK_NOTNULL(first);
  CHECK_NOTNULL(last);

  const Vec2d direction_vec = Vec2d::CreateUnitVec2d(heading);
  double min_proj = std::numeric_limits&lt;double&gt;::infinity();
  double max_proj = -std::numeric_limits&lt;double&gt;::infinity();
  for (const auto&amp; pt : points_) {
    const double proj = pt.InnerProd(direction_vec);
    if (proj &lt; min_proj) {
      min_proj = proj;
      *first = pt;
    }
    if (proj &gt; max_proj) {
      max_proj = proj;
      *last = pt;
    }
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(447, 0)" endLine="(464, 1)" clone_start="11" clone_end="18">
			<code function_name="NovatelParser::handle_corr_imu_data(const novatel::CorrImuData* imu)">bool NovatelParser::handle_corr_imu_data(const novatel::CorrImuData* imu) {
    rfu_to_flu(imu-&gt;x_velocity_change * _imu_measurement_hz,
               imu-&gt;y_velocity_change * _imu_measurement_hz,
               imu-&gt;z_velocity_change * _imu_measurement_hz,
               _ins.mutable_linear_acceleration());
    rfu_to_flu(imu-&gt;x_angle_change * _imu_measurement_hz,
               imu-&gt;y_angle_change * _imu_measurement_hz,
               imu-&gt;z_angle_change * _imu_measurement_hz,
               _ins.mutable_angular_velocity());

    double seconds = imu-&gt;gps_week * SECONDS_PER_WEEK + imu-&gt;gps_seconds;
    if (_ins.measurement_time() != seconds) {
        _ins.set_measurement_time(seconds);
        return false;
    }
    _ins.mutable_header()-&gt;set_timestamp_sec(ros::Time::now().toSec());
    return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(476, 0)" endLine="(513, 1)" clone_start="30" clone_end="38">
			<code function_name="NovatelParser::handle_ins_pva(const novatel::InsPva* pva)">bool NovatelParser::handle_ins_pva(const novatel::InsPva* pva) {
    if (_ins_status != pva-&gt;status) {
        _ins_status = pva-&gt;status;
        ROS_INFO_STREAM("INS status: " &lt;&lt; static_cast&lt;int&gt;(_ins_status));
    }
    _ins.mutable_position()-&gt;set_lon(pva-&gt;longitude);
    _ins.mutable_position()-&gt;set_lat(pva-&gt;latitude);
    _ins.mutable_position()-&gt;set_height(pva-&gt;height);
    _ins.mutable_euler_angles()-&gt;set_x(pva-&gt;roll * DEG_TO_RAD);
    _ins.mutable_euler_angles()-&gt;set_y(-pva-&gt;pitch * DEG_TO_RAD);
    _ins.mutable_euler_angles()-&gt;set_z(azimuth_deg_to_yaw_rad(pva-&gt;azimuth));
    _ins.mutable_linear_velocity()-&gt;set_x(pva-&gt;east_velocity);
    _ins.mutable_linear_velocity()-&gt;set_y(pva-&gt;north_velocity);
    _ins.mutable_linear_velocity()-&gt;set_z(pva-&gt;up_velocity);

    switch (pva-&gt;status) {
    case novatel::InsStatus::ALIGNMENT_COMPLETE:
    case novatel::InsStatus::SOLUTION_GOOD:
        _ins.set_type(apollo::drivers::gnss::Ins::GOOD);
        break;
    case novatel::InsStatus::ALIGNING:
    case novatel::InsStatus::HIGH_VARIANCE:
    case novatel::InsStatus::SOLUTION_FREE:
        _ins.set_type(apollo::drivers::gnss::Ins::CONVERGING);
        break;
    default:
        _ins.set_type(apollo::drivers::gnss::Ins::INVALID);
    }

    double seconds = pva-&gt;gps_week * SECONDS_PER_WEEK + pva-&gt;gps_seconds;
    if (_ins.measurement_time() != seconds) {
        _ins.set_measurement_time(seconds);
        return false;
    }

    _ins.mutable_header()-&gt;set_timestamp_sec(ros::Time::now().toSec());
    return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(466, 0)" endLine="(474, 1)" clone_start="1" clone_end="1">
			<code function_name="NovatelParser::handle_ins_cov(const novatel::InsCov* cov)">bool NovatelParser::handle_ins_cov(const novatel::InsCov* cov) {
    for (int i = 0; i &lt; 9; ++i) {
        _ins.set_position_covariance(i, cov-&gt;position_covariance[i]);
        _ins.set_euler_angles_covariance(INDEX[i],
                                         (DEG_TO_RAD * DEG_TO_RAD) * cov-&gt;attitude_covariance[i]);
        _ins.set_linear_velocity_covariance(i, cov-&gt;velocity_covariance[i]);
    }
    return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(515, 0)" endLine="(570, 1)" clone_start="1" clone_end="1">
			<code function_name="NovatelParser::handle_raw_imu_x(const novatel::RawImuX* imu)">bool NovatelParser::handle_raw_imu_x(const novatel::RawImuX* imu) {
    if (imu-&gt;imu_error != 0) {
        ROS_WARN_STREAM("IMU error. Status: " &lt;&lt; std::hex &lt;&lt; std::showbase &lt;&lt; imu-&gt;imuStatus);
    }
    if (is_zero(_gyro_scale)) {
        novatel::ImuParameter param = novatel::get_imu_parameter(imu-&gt;imu_type);
        ROS_INFO_STREAM("IMU type: " &lt;&lt; static_cast&lt;unsigned&gt;(imu-&gt;imu_type) &lt;&lt; "; "
                  &lt;&lt; "Gyro scale: " &lt;&lt; param.gyro_scale &lt;&lt; "; "
                  &lt;&lt; "Accel scale: " &lt;&lt; param.accel_scale &lt;&lt; "; "
                  &lt;&lt; "Sampling rate: " &lt;&lt; param.sampling_rate_hz &lt;&lt; ".");
      
        if (is_zero(param.sampling_rate_hz)) {
            ROS_ERROR_STREAM_THROTTLE(5, "Unsupported IMU type: " &lt;&lt; static_cast&lt;int&gt;(imu-&gt;imu_type));
            return false;
        }
        _gyro_scale = param.gyro_scale * param.sampling_rate_hz;
        _accel_scale = param.accel_scale * param.sampling_rate_hz;
        _imu_measurement_hz = param.sampling_rate_hz;
        _imu_measurement_span = 1.0 / param.sampling_rate_hz;
        _imu.set_measurement_span(_imu_measurement_span);
    }

    double time = imu-&gt;gps_week * SECONDS_PER_WEEK + imu-&gt;gps_seconds;
    if (_imu_measurement_time_previous &gt; 0.0 &amp;&amp;
        fabs(time - _imu_measurement_time_previous - _imu_measurement_span) &gt; 1e-4) {
        ROS_WARN_STREAM("Unexpected delay between two IMU measurements at: "
                     &lt;&lt; time - _imu_measurement_time_previous);
    }
    _imu.set_measurement_time(time);
    switch (_imu_frame_mapping) {
    case 5:  // Default mapping.
        rfu_to_flu(imu-&gt;x_velocity_change * _accel_scale,
                   -imu-&gt;y_velocity_change_neg * _accel_scale,
                   imu-&gt;z_velocity_change * _accel_scale,
                   _imu.mutable_linear_acceleration());
        rfu_to_flu(imu-&gt;x_angle_change * _gyro_scale,
                   -imu-&gt;y_angle_change_neg * _gyro_scale,
                   imu-&gt;z_angle_change * _gyro_scale,
                   _imu.mutable_angular_velocity());
        break;
    case 6:
        rfu_to_flu(-imu-&gt;y_velocity_change_neg * _accel_scale,
                   imu-&gt;x_velocity_change * _accel_scale,
                   -imu-&gt;z_velocity_change * _accel_scale,
                   _imu.mutable_linear_acceleration());
        rfu_to_flu(-imu-&gt;y_angle_change_neg * _gyro_scale,
                   imu-&gt;x_angle_change * _gyro_scale,
                   -imu-&gt;z_angle_change * _gyro_scale,
                   _imu.mutable_angular_velocity());
        break;
    default:
        ROS_ERROR_STREAM_THROTTLE(5, "Unsupported IMU frame mapping: " &lt;&lt; _imu_frame_mapping);
    }
    _imu_measurement_time_previous = time;
    return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\localization\camera\camera_localization.cc" startLine="(38, 0)" endLine="(75, 1)" clone_start="37" clone_end="38">
			<code function_name="CameraLocalization::Start()">Status CameraLocalization::Start() {
  MonitorBuffer buffer(&amp;monitor_);
  if (!apollo::common::util::GetProtoFromFile(
          FLAGS_camera_parameter_config_file, &amp;camera_parameter_)) {
    buffer.ERROR() &lt;&lt; "Camera parameter is not initialized. Check "
                   &lt;&lt; FLAGS_camera_parameter_config_file;
    buffer.PrintLog();
    return Status(apollo::common::LOCALIZATION_ERROR,
                  "failed to load camera parameter");
  }

  AdapterManager::Init(FLAGS_camera_adapter_config_file);
  // start ROS timer, one-shot = false, auto-start = true
  const double duration = 1.0 / FLAGS_localization_publish_freq;
  timer_ = AdapterManager::CreateTimer(ros::Duration(duration),
                                       &amp;CameraLocalization::OnTimer, this);
  if (!AdapterManager::GetGps()) {
    buffer.ERROR() &lt;&lt; "GPS input not initialized. Check "
                   &lt;&lt; FLAGS_camera_adapter_config_file;
    buffer.PrintLog();
    return Status(apollo::common::LOCALIZATION_ERROR, "no GPS adapter");
  }
  if (!AdapterManager::GetCamera()) {
    buffer.ERROR() &lt;&lt; "Camera input not initialized. Check "
                   &lt;&lt; FLAGS_camera_adapter_config_file;
    buffer.PrintLog();
    return Status(apollo::common::LOCALIZATION_ERROR, "no Camera adapter");
  }
  // IMU is optional
  if (!AdapterManager::GetImu()) {
    buffer.INFO("IMU input not initialized. Check your adapter.conf file!");
    buffer.PrintLog();
    use_imu_ = false;
  } else {
    use_imu_ = true;
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\localization\rtk\rtk_localization.cc" startLine="(37, 0)" endLine="(57, 1)" clone_start="20" clone_end="21">
			<code function_name="RTKLocalization::Start()">Status RTKLocalization::Start() {
  AdapterManager::Init(FLAGS_rtk_adapter_config_file);

  // start ROS timer, one-shot = false, auto-start = true
  const double duration = 1.0 / FLAGS_localization_publish_freq;
  timer_ = AdapterManager::CreateTimer(ros::Duration(duration),
                                       &amp;RTKLocalization::OnTimer, this);
  apollo::common::monitor::MonitorBuffer buffer(&amp;monitor_);
  if (!AdapterManager::GetGps()) {
    buffer.ERROR() &lt;&lt; "GPS input not initialized. Check file "
                   &lt;&lt; FLAGS_rtk_adapter_config_file;
    buffer.PrintLog();
    return Status(apollo::common::LOCALIZATION_ERROR, "no GPS adapter");
  }
  if (!AdapterManager::GetImu()) {
    buffer.ERROR("IMU input not initialized. Check your adapter.conf file!");
    buffer.PrintLog();
    return Status(apollo::common::LOCALIZATION_ERROR, "no IMU adapter");
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\localization\camera\camera_localization.cc" startLine="(77, 0)" endLine="(80, 1)" clone_start="1" clone_end="4">
			<code function_name="CameraLocalization::Stop()">Status CameraLocalization::Stop() {
  timer_.stop();
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\localization\rtk\rtk_localization.cc" startLine="(59, 0)" endLine="(62, 1)" clone_start="1" clone_end="4">
			<code function_name="RTKLocalization::Stop()">Status RTKLocalization::Stop() {
  timer_.stop();
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\localization\camera\camera_localization.cc" startLine="(82, 0)" endLine="(135, 1)" clone_start="1" clone_end="3">
			<code function_name="CameraLocalization::OnTimer(const ros::TimerEvent &amp;event)">void CameraLocalization::OnTimer(const ros::TimerEvent &amp;event) {
  double time_delay = apollo::common::time::ToSecond(Clock::Now()) -
                      last_received_timestamp_sec_;
  MonitorBuffer buffer(&amp;monitor_);
  if (FLAGS_enable_gps_timestamp &amp;&amp;
      time_delay &gt; FLAGS_gps_time_delay_tolerance) {
    buffer.ERROR() &lt;&lt; "GPS message time delay: " &lt;&lt; time_delay;
    buffer.PrintLog();
  }
  if (FLAGS_enable_camera_timestamp &amp;&amp;
      time_delay &gt; FLAGS_camera_time_delay_tolerance) {
    AERROR &lt;&lt; "Camera message time delay: " &lt;&lt; time_delay;
    buffer.ERROR() &lt;&lt; "Camera message time delay: " &lt;&lt; time_delay;
    buffer.PrintLog();
  }

  // Take a snapshot of the current received messages.
  AdapterManager::Observe();

  if (AdapterManager::GetGps()-&gt;Empty()) {
    AERROR &lt;&lt; "GPS message buffer is empty.";
    if (service_started_) {
      buffer.ERROR("GPS message buffer is empty.");
    }
    return;
  }
  if (AdapterManager::GetCamera()-&gt;Empty()) {
    AERROR &lt;&lt; "Camera message buffer is empty.";
    if (service_started_) {
      buffer.ERROR("Camera message buffer is empty.");
    }
    return;
  }
  if (use_imu_ &amp;&amp; AdapterManager::GetImu()-&gt;Empty()) {
    AERROR &lt;&lt; "Imu message buffer is empty.";
    if (service_started_) {
      buffer.ERROR("Imu message buffer is empty.");
    }
    return;
  }

  // publish localization messages
  if (!PublishLocalization()) {
    buffer.ERROR("Publish localization failed");
    buffer.PrintLog();
    return;
  }
  service_started_ = true;

  // watch dog
  RunWatchDog();

  last_received_timestamp_sec_ = apollo::common::time::ToSecond(Clock::Now());
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\localization\rtk\rtk_localization.cc" startLine="(64, 0)" endLine="(100, 1)" clone_start="1" clone_end="3">
			<code function_name="RTKLocalization::OnTimer(const ros::TimerEvent &amp;event)">void RTKLocalization::OnTimer(const ros::TimerEvent &amp;event) {
  double time_delay = apollo::common::time::ToSecond(Clock::Now()) -
                      last_received_timestamp_sec_;
  apollo::common::monitor::MonitorBuffer buffer(&amp;monitor_);
  if (FLAGS_enable_gps_timestamp &amp;&amp;
      time_delay &gt; FLAGS_gps_time_delay_tolerance) {
    buffer.ERROR() &lt;&lt; "GPS message time delay: " &lt;&lt; time_delay;
    buffer.PrintLog();
  }

  // Take a snapshot of the current received messages.
  AdapterManager::Observe();

  if (AdapterManager::GetGps()-&gt;Empty()) {
    AERROR &lt;&lt; "GPS message buffer is empty.";
    if (service_started_) {
      buffer.ERROR("GPS message buffer is empty.");
    }
    return;
  }
  if (AdapterManager::GetImu()-&gt;Empty()) {
    AERROR &lt;&lt; "IMU message buffer is empty.";
    if (service_started_) {
      buffer.ERROR("IMU message buffer is empty.");
    }
    return;
  }

  // publish localization messages
  PublishLocalization();
  service_started_ = true;

  // watch dog
  RunWatchDog();

  last_received_timestamp_sec_ = apollo::common::time::ToSecond(Clock::Now());
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(27, 0)" endLine="(30, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake60::GetPeriod() const">uint32_t Brake60::GetPeriod() const {
  static const uint32_t PERIOD = 20 * 1000;
  return PERIOD;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(27, 0)" endLine="(31, 1)" clone_start="1" clone_end="5">
			<code function_name="Gear66::GetPeriod() const">uint32_t Gear66::GetPeriod() const {
  // on event, so value nonsense
  static const uint32_t PERIOD = 20 * 1000;
  return PERIOD;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(26, 0)" endLine="(31, 1)" clone_start="1" clone_end="6">
			<code function_name="Steering64::GetPeriod() const">uint32_t Steering64::GetPeriod() const {
  // receive rate??
  // receive timeout would trigger fault, letting en=0 and etc.
  static const uint32_t PERIOD = 20 * 1000;
  return PERIOD;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(28, 0)" endLine="(31, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle62::GetPeriod() const">uint32_t Throttle62::GetPeriod() const {
  static const uint32_t PERIOD = 20 * 1000;
  return PERIOD;
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(32, 0)" endLine="(38, 1)" clone_start="1" clone_end="3">
			<code function_name="Brake60::UpdateData(uint8_t* data)">void Brake60::UpdateData(uint8_t* data) {
  set_pedal_p(data, pedal_cmd_);
  set_boo_cmd_p(data, boo_cmd_);
  set_enable_p(data, pedal_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_watchdog_counter_p(data, watchdog_counter_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(33, 0)" endLine="(36, 1)" clone_start="1" clone_end="3">
			<code function_name="Gear66::UpdateData(uint8_t* data)">void Gear66::UpdateData(uint8_t* data) {
  set_gear_p(data, gear_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(33, 0)" endLine="(41, 1)" clone_start="1" clone_end="3">
			<code function_name="Steering64::UpdateData(uint8_t* data)">void Steering64::UpdateData(uint8_t* data) {
  set_steering_angle_p(data, steering_angle_);
  set_enable_p(data, steering_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_ignore_driver_override_p(data, ignore_driver_override_);
  set_steering_angle_speed_p(data, steering_angle_speed_);
  set_watchdog_counter_p(data, watchdog_counter_);
  set_disable_audible_warning_p(data, disable_audible_warning_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(33, 0)" endLine="(39, 1)" clone_start="1" clone_end="3">
			<code function_name="Throttle62::UpdateData(uint8_t* data)">void Throttle62::UpdateData(uint8_t* data) {
  set_pedal_p(data, pedal_cmd_);
  set_enable_p(data, pedal_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_ignore_driver_override_p(data, ignore_driver_override_);
  set_watchdog_counter_p(data, watchdog_counter_);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\line_segment2d.cc" startLine="(58, 0)" endLine="(72, 1)" clone_start="1" clone_end="8">
			<code function_name="LineSegment2d::DistanceTo(const Vec2d&amp; point) const">double LineSegment2d::DistanceTo(const Vec2d&amp; point) const {
  if (length_ &lt;= kMathEpsilon) {
    return point.DistanceTo(start_);
  }
  const double x0 = point.x() - start_.x();
  const double y0 = point.y() - start_.y();
  const double proj = x0 * unit_direction_.x() + y0 * unit_direction_.y();
  if (proj &lt;= 0.0) {
    return hypot(x0, y0);
  }
  if (proj &gt;= length_) {
    return point.DistanceTo(end_);
  }
  return std::abs(x0 * unit_direction_.y() - y0 * unit_direction_.x());
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\line_segment2d.cc" startLine="(96, 0)" endLine="(110, 1)" clone_start="1" clone_end="8">
			<code function_name="LineSegment2d::DistanceSquareTo(const Vec2d&amp; point) const">double LineSegment2d::DistanceSquareTo(const Vec2d&amp; point) const {
  if (length_ &lt;= kMathEpsilon) {
    return point.DistanceSquareTo(start_);
  }
  const double x0 = point.x() - start_.x();
  const double y0 = point.y() - start_.y();
  const double proj = x0 * unit_direction_.x() + y0 * unit_direction_.y();
  if (proj &lt;= 0.0) {
    return Square(x0) + Square(y0);
  }
  if (proj &gt;= length_) {
    return point.DistanceSquareTo(end_);
  }
  return Square(x0 * unit_direction_.y() - y0 * unit_direction_.x());
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="171" clone_end="177">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(26, 0)" endLine="(89, 1)" clone_start="63" clone_end="64">
			<code function_name="Gear67::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Gear67::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t gear = gear_state(bytes, length);
  switch (gear) {
    case 0x01:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_PARKING);
      break;
    case 0x02:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_REVERSE);
      break;
    case 0x03:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_NEUTRAL);
      break;
    case 0x04:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_DRIVE);
      break;
    case 0x05:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_LOW);
      break;
    case 0x00:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_NONE);
      break;
    default:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_INVALID);
      break;
  }

  if (is_driver_override(bytes, length)) {
    // last shift requested by driver
    car_status-&gt;mutable_gear()-&gt;set_is_shift_position_valid(false);
  } else {
    // last shift requested by-wire
    car_status-&gt;mutable_gear()-&gt;set_is_shift_position_valid(true);
  }
  car_status-&gt;mutable_gear()-&gt;set_driver_override(
      is_driver_override(bytes, length));

  int32_t gear_cmd = reported_gear_cmd(bytes, length);
  switch (gear_cmd) {
    case 0x01:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_PARKING);
      break;
    case 0x02:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_REVERSE);
      break;
    case 0x03:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_NEUTRAL);
      break;
    case 0x04:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_DRIVE);
      break;
    case 0x05:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_LOW);
      break;
    case 0x00:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_NONE);
      break;
    default:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_INVALID);
      break;
  }

  car_status-&gt;mutable_gear()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(26, 0)" endLine="(40, 1)" clone_start="13" clone_end="15">
			<code function_name="Gps6e::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Gps6e::Parse(const std::uint8_t* bytes, int32_t length,
                  ChassisDetail* car_status) const {
  car_status-&gt;mutable_basic()-&gt;set_year(year(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_month(month(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_day(day(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_hours(hours(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_minutes(minutes(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_seconds(seconds(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_compass_direction(
      compass_direction(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_pdop(pdop(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_is_gps_fault(is_gps_fault(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_is_inferred(
      is_inferred_position(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(204, 0)" endLine="(209, 1)" clone_start="1" clone_end="6">
			<code function_name="Misc69::turn_signal_status(const std::uint8_t* bytes, int32_t length) const">int32_t Misc69::turn_signal_status(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(91, 0)" endLine="(95, 1)" clone_start="1" clone_end="5">
			<code function_name="Gear67::gear_state(const std::uint8_t* bytes, int32_t length) const">int32_t Gear67::gear_state(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(42, 0)" endLine="(46, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::year(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::year(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 7);
  return x;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(211, 0)" endLine="(216, 1)" clone_start="1" clone_end="3">
			<code function_name="Misc69::high_beam_status(const std::uint8_t* bytes, int32_t length) const">int32_t Misc69::high_beam_status(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(2, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(97, 0)" endLine="(101, 1)" clone_start="1" clone_end="3">
			<code function_name="Gear67::is_driver_override(const std::uint8_t* bytes, int32_t length) const">bool Gear67::is_driver_override(const std::uint8_t* bytes,
                                int32_t length) const {
  Byte frame(bytes + 0);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(48, 0)" endLine="(52, 1)" clone_start="1" clone_end="2">
			<code function_name="Gps6e::month(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::month(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 4);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\controller\lat_controller.cc" startLine="(226, 0)" endLine="(306, 1)" clone_start="69" clone_end="77">
			<code function_name="LatController::ComputeControlCommand(const localization::LocalizationEstimate* localization, const canbus::Chassis* chassis, const planning::ADCTrajectory* planning_published_trajectory, ControlCommand* cmd)">Status LatController::ComputeControlCommand(
    const localization::LocalizationEstimate* localization,
    const canbus::Chassis* chassis,
    const planning::ADCTrajectory* planning_published_trajectory,
    ControlCommand* cmd) {
  vehicle_state_ = std::move(VehicleState(localization, chassis));
  vehicle_state_.set_linear_velocity(
      std::max(vehicle_state_.linear_velocity(), 1.0));

  trajectory_analyzer_ =
      std::move(TrajectoryAnalyzer(planning_published_trajectory));

  SimpleLateralDebug* debug = cmd-&gt;mutable_debug()-&gt;mutable_simple_lat_debug();
  debug-&gt;Clear();

  // Update state = [Lateral Error, Lateral Error Rate, Heading Error, Heading
  // Error Rate, preview lateral error1 , preview lateral error2, ...]
  if (FLAGS_use_state_exact_match) {
    UpdateStateAnalyticalMatching(debug);
  } else {
    UpdateState(debug);
  }

  UpdateMatrix();

  // Compound discrete matrix with road preview model
  UpdateMatrixCompound();

  common::math::SolveLQRProblem(matrix_adc_, matrix_bdc_, matrix_q_, matrix_r_,
                                lqr_eps_, lqr_max_iteration_, &amp;matrix_k_);

  // feedback = - K * state
  // Convert vehicle steer angle from rad to degree and then to steer degree
  // then to 100% ratio
  double steer_angle_feedback = -(matrix_k_ * matrix_state_)(0, 0) * 180 /
                                M_PI * steer_transmission_ratio_ /
                                steer_single_direction_max_degree_ * 100;

  double steer_angle_feedforward = ComputeFeedForward(debug-&gt;curvature());
  double steer_angle = steer_angle_feedback + steer_angle_feedforward;
  // Clamp the steer angle to -100.0 to 100.0
  steer_angle = apollo::common::math::Clamp(steer_angle, -100.0, 100.0);

  steer_angle = digital_filter_.Filter(steer_angle);
  cmd-&gt;set_steering_target(steer_angle);
  cmd-&gt;set_steering_rate(FLAGS_steer_angle_rate);

  // compute extra information for logging and debugging
  double steer_angle_lateral_contribution =
      -matrix_k_(0, 0) * matrix_state_(0, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_lateral_rate_contribution =
      -matrix_k_(0, 1) * matrix_state_(1, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_heading_contribution =
      -matrix_k_(0, 2) * matrix_state_(2, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_heading_rate_contribution =
      -matrix_k_(0, 3) * matrix_state_(3, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  // TODO(yifei): move up temporary values to use debug fields.

  debug-&gt;set_heading(vehicle_state_.heading());
  debug-&gt;set_steer_angle(steer_angle);
  debug-&gt;set_steer_angle_feedforward(steer_angle_feedforward);
  debug-&gt;set_steer_angle_lateral_contribution(steer_angle_lateral_contribution);
  debug-&gt;set_steer_angle_lateral_rate_contribution(
      steer_angle_lateral_rate_contribution);
  debug-&gt;set_steer_angle_heading_contribution(steer_angle_heading_contribution);
  debug-&gt;set_steer_angle_heading_rate_contribution(
      steer_angle_heading_rate_contribution);
  debug-&gt;set_steer_angle_feedback(steer_angle_feedback);
  debug-&gt;set_steering_position(chassis-&gt;steering_percentage());
  debug-&gt;set_ref_speed(vehicle_state_.linear_velocity());
  ProcessLogs(debug, chassis);
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\controller\lon_controller.cc" startLine="(148, 0)" endLine="(286, 1)" clone_start="111" clone_end="117">
			<code function_name="LonController::ComputeControlCommand(const ::apollo::localization::LocalizationEstimate *localization, const ::apollo::canbus::Chassis *chassis, const ::apollo::planning::ADCTrajectory *planning_published_trajectory, ::apollo::control::ControlCommand *cmd)">Status LonController::ComputeControlCommand(
    const ::apollo::localization::LocalizationEstimate *localization,
    const ::apollo::canbus::Chassis *chassis,
    const ::apollo::planning::ADCTrajectory *planning_published_trajectory,
    ::apollo::control::ControlCommand *cmd) {
  localization_ = localization;
  chassis_ = chassis;
  vehicle_state_ = std::move(VehicleState(localization, chassis));

  trajectory_message_ = planning_published_trajectory;
  if (!control_interpolation_) {
    AERROR &lt;&lt; "Fail to initialize calibration table.";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR,
                  "Fail to initialize calibration table.");
  }

  if (trajectory_analyzer_ == nullptr ||
      trajectory_analyzer_-&gt;seq_num() !=
          trajectory_message_-&gt;header().sequence_num()) {
    trajectory_analyzer_.reset(new TrajectoryAnalyzer(trajectory_message_));
  }
  const LonControllerConf &amp;lon_controller_conf =
      control_conf_-&gt;lon_controller_conf();

  auto debug = cmd-&gt;mutable_debug()-&gt;mutable_simple_lon_debug();
  debug-&gt;Clear();

  double brake_cmd = 0.0;
  double throttle_cmd = 0.0;
  double ts = lon_controller_conf.ts();
  double preview_time = lon_controller_conf.preview_window() * ts;

  if (preview_time &lt; 0.0) {
    AERROR &lt;&lt; "Preview time set as: " &lt;&lt; preview_time &lt;&lt; " less than 0";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR,
                  "Invalid preview time:" + std::to_string(preview_time));
  }
  ComputeLongitudinalErrors(vehicle_state_, trajectory_analyzer_.get(),
                            preview_time, debug);

  double station_error_limit = lon_controller_conf.station_error_limit();
  double station_error_limited = 0.0;
  if (FLAGS_enable_speed_station_preview) {
    station_error_limited =
        apollo::common::math::Clamp(debug-&gt;preview_station_error(),
                                    -station_error_limit, station_error_limit);
  } else {
    station_error_limited = apollo::common::math::Clamp(
        debug-&gt;station_error(), -station_error_limit, station_error_limit);
  }
  double speed_offset =
      station_pid_controller_.Control(station_error_limited, ts);

  double speed_controller_input = 0.0;
  double speed_controller_input_limit =
      lon_controller_conf.speed_controller_input_limit();
  double speed_controller_input_limited = 0.0;
  if (FLAGS_enable_speed_station_preview) {
    speed_controller_input = speed_offset + debug-&gt;preview_speed_error();
  } else {
    speed_controller_input = speed_offset + debug-&gt;speed_error();
  }
  speed_controller_input_limited = apollo::common::math::Clamp(
      speed_controller_input, -speed_controller_input_limit,
      speed_controller_input_limit);

  double acceleration_cmd_closeloop = 0.0;
  if (vehicle_state_.linear_velocity() &lt;= lon_controller_conf.switch_speed()) {
    speed_pid_controller_.SetPID(lon_controller_conf.low_speed_pid_conf());
    acceleration_cmd_closeloop =
        speed_pid_controller_.Control(speed_controller_input_limited, ts);
  } else {
    speed_pid_controller_.SetPID(lon_controller_conf.high_speed_pid_conf());
    acceleration_cmd_closeloop =
        speed_pid_controller_.Control(speed_controller_input_limited, ts);
  }

  double acceleration_cmd =
      acceleration_cmd_closeloop + debug-&gt;preview_acceleration_reference();
  debug-&gt;set_is_full_stop(false);
  if (std::abs(debug-&gt;preview_acceleration_reference()) &lt;=
          FLAGS_max_acceleration_when_stopped &amp;&amp;
      std::abs(debug-&gt;preview_speed_reference()) &lt;=
          FLAGS_max_abs_speed_when_stopped) {
    acceleration_cmd = lon_controller_conf.standstill_acceleration();
    AINFO &lt;&lt; "Stop location reached";
    debug-&gt;set_is_full_stop(true);
  }

  double throttle_deadzone = lon_controller_conf.throttle_deadzone();
  double brake_deadzone = lon_controller_conf.brake_deadzone();
  double calibration_value = 0.0;
  if (FLAGS_use_preview_speed_for_table) {
    calibration_value = control_interpolation_-&gt;Interpolate(
        std::make_pair(debug-&gt;preview_speed_reference(), acceleration_cmd));
  } else {
    calibration_value = control_interpolation_-&gt;Interpolate(
        std::make_pair(chassis_-&gt;speed_mps(), acceleration_cmd));
  }

  if (calibration_value &gt;= 0) {
    throttle_cmd = calibration_value &gt; throttle_deadzone ? calibration_value
                                                         : throttle_deadzone;
    brake_cmd = 0.0;
  } else {
    throttle_cmd = 0.0;
    brake_cmd = -calibration_value &gt; brake_deadzone ? -calibration_value
                                                    : brake_deadzone;
  }

  debug-&gt;set_station_error_limited(station_error_limited);
  debug-&gt;set_speed_controller_input_limited(speed_controller_input_limited);
  debug-&gt;set_acceleration_cmd(acceleration_cmd);
  debug-&gt;set_throttle_cmd(throttle_cmd);
  debug-&gt;set_brake_cmd(brake_cmd);
  debug-&gt;set_acceleration_lookup(acceleration_cmd);
  debug-&gt;set_speed_lookup(chassis_-&gt;speed_mps());
  debug-&gt;set_calibration_value(calibration_value);
  debug-&gt;set_acceleration_cmd_closeloop(acceleration_cmd_closeloop);

  if (FLAGS_enable_csv_debug &amp;&amp; speed_log_file_ != nullptr) {
    fprintf(speed_log_file_,
            "%.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f,"
            "%.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %d,\r\n",
            debug-&gt;station_reference(), debug-&gt;station_error(),
            station_error_limited, debug-&gt;preview_station_error(),
            debug-&gt;speed_reference(), debug-&gt;speed_error(),
            speed_controller_input_limited, debug-&gt;preview_speed_reference(),
            debug-&gt;preview_speed_error(),
            debug-&gt;preview_acceleration_reference(), acceleration_cmd_closeloop,
            acceleration_cmd, debug-&gt;acceleration_lookup(),
            debug-&gt;speed_lookup(), calibration_value, throttle_cmd, brake_cmd,
            debug-&gt;is_full_stop());
  }

  cmd-&gt;set_throttle(throttle_cmd);
  cmd-&gt;set_brake(brake_cmd);
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(588, 0)" endLine="(657, 1)" clone_start="24" clone_end="33">
			<code function_name="LincolnController::SecurityDogThreadFunc()">void LincolnController::SecurityDogThreadFunc() {
  if (can_sender_ == nullptr) {
    AERROR &lt;&lt; "Fail to run SecurityDogThreadFunc() because can_sender_ is "
              "nullptr.";
    return;
  }
  while (!can_sender_-&gt;IsRunning()) {
    std::this_thread::yield();
  }

  std::chrono::duration&lt;double, std::micro&gt; default_period{50000};
  int64_t start =
      ::apollo::common::time::AsInt64&lt;::apollo::common::time::micros&gt;(
          ::apollo::common::time::Clock::Now());

  int32_t speed_ctrl_fail = 0;
  int32_t steer_ctrl_fail = 0;

  while (can_sender_-&gt;IsRunning()) {
    const Chassis::DrivingMode mode = driving_mode();
    bool emergency_mode = false;

    // 1. steer control check
    if ((mode == Chassis::COMPLETE_AUTO_DRIVE ||
         mode == Chassis::AUTO_STEER_ONLY) &amp;&amp;
        CheckResponse(CHECK_RESPONSE_STEER_UNIT_FLAG, false) == false) {
      ++steer_ctrl_fail;
      if (steer_ctrl_fail &gt;= kMaxFailAttempt) {
        emergency_mode = true;
        set_chassis_error_code(Chassis::MANUAL_INTERVENTION);
      }
    } else {
      steer_ctrl_fail = 0;
    }

    // 2. speed control check
    if ((mode == Chassis::COMPLETE_AUTO_DRIVE ||
         mode == Chassis::AUTO_SPEED_ONLY) &amp;&amp;
        CheckResponse(CHECK_RESPONSE_SPEED_UNIT_FLAG, false) == false) {
      ++speed_ctrl_fail;
      if (speed_ctrl_fail &gt;= kMaxFailAttempt) {
        emergency_mode = true;
        set_chassis_error_code(Chassis::MANUAL_INTERVENTION);
      }
    } else {
      speed_ctrl_fail = 0;
    }
    if (CheckChassisError()) {
      set_chassis_error_code(Chassis::CHASSIS_ERROR);
      emergency_mode = true;
    }

    if (emergency_mode &amp;&amp; mode != Chassis::EMERGENCY_MODE) {
      Emergency();
    }
    int64_t end =
        ::apollo::common::time::AsInt64&lt;::apollo::common::time::micros&gt;(
            ::apollo::common::time::Clock::Now());
    std::chrono::duration&lt;double, std::micro&gt; elapsed{end - start};
    if (elapsed &lt; default_period) {
      std::this_thread::sleep_for(default_period - elapsed);
      start += (default_period - elapsed).count();
    } else {
      AERROR
          &lt;&lt; "Too much time consumption in LincolnController looping process:"
          &lt;&lt; elapsed.count();
      start = end;
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(588, 0)" endLine="(657, 1)" clone_start="37" clone_end="46">
			<code function_name="LincolnController::SecurityDogThreadFunc()">void LincolnController::SecurityDogThreadFunc() {
  if (can_sender_ == nullptr) {
    AERROR &lt;&lt; "Fail to run SecurityDogThreadFunc() because can_sender_ is "
              "nullptr.";
    return;
  }
  while (!can_sender_-&gt;IsRunning()) {
    std::this_thread::yield();
  }

  std::chrono::duration&lt;double, std::micro&gt; default_period{50000};
  int64_t start =
      ::apollo::common::time::AsInt64&lt;::apollo::common::time::micros&gt;(
          ::apollo::common::time::Clock::Now());

  int32_t speed_ctrl_fail = 0;
  int32_t steer_ctrl_fail = 0;

  while (can_sender_-&gt;IsRunning()) {
    const Chassis::DrivingMode mode = driving_mode();
    bool emergency_mode = false;

    // 1. steer control check
    if ((mode == Chassis::COMPLETE_AUTO_DRIVE ||
         mode == Chassis::AUTO_STEER_ONLY) &amp;&amp;
        CheckResponse(CHECK_RESPONSE_STEER_UNIT_FLAG, false) == false) {
      ++steer_ctrl_fail;
      if (steer_ctrl_fail &gt;= kMaxFailAttempt) {
        emergency_mode = true;
        set_chassis_error_code(Chassis::MANUAL_INTERVENTION);
      }
    } else {
      steer_ctrl_fail = 0;
    }

    // 2. speed control check
    if ((mode == Chassis::COMPLETE_AUTO_DRIVE ||
         mode == Chassis::AUTO_SPEED_ONLY) &amp;&amp;
        CheckResponse(CHECK_RESPONSE_SPEED_UNIT_FLAG, false) == false) {
      ++speed_ctrl_fail;
      if (speed_ctrl_fail &gt;= kMaxFailAttempt) {
        emergency_mode = true;
        set_chassis_error_code(Chassis::MANUAL_INTERVENTION);
      }
    } else {
      speed_ctrl_fail = 0;
    }
    if (CheckChassisError()) {
      set_chassis_error_code(Chassis::CHASSIS_ERROR);
      emergency_mode = true;
    }

    if (emergency_mode &amp;&amp; mode != Chassis::EMERGENCY_MODE) {
      Emergency();
    }
    int64_t end =
        ::apollo::common::time::AsInt64&lt;::apollo::common::time::micros&gt;(
            ::apollo::common::time::Clock::Now());
    std::chrono::duration&lt;double, std::micro&gt; elapsed{end - start};
    if (elapsed &lt; default_period) {
      std::this_thread::sleep_for(default_period - elapsed);
      start += (default_period - elapsed).count();
    } else {
      AERROR
          &lt;&lt; "Too much time consumption in LincolnController looping process:"
          &lt;&lt; elapsed.count();
      start = end;
    }
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\tools\teleop.cc" startLine="(78, 2)" endLine="(106, 3)" clone_start="11" clone_end="17">
			<code function_name="PrintKeycode()">  static void PrintKeycode() {
    system("clear");
    printf("=====================    KEYBOARD MAP   ===================\n");
    printf("HELP:               [%c]     |\n", KEYCODE_HELP);
    printf("Set Action      :   [%c]+Num\n", KEYCODE_MODE);
    printf("                     0 RESET ACTION\n");
    printf("                     1 START ACTION\n");
    printf("\n-----------------------------------------------------------\n");
    printf("Set Gear:           [%c]+Num\n", KEYCODE_SETG1);
    printf("                     0 GEAR_NEUTRAL\n");
    printf("                     1 GEAR_DRIVE\n");
    printf("                     2 GEAR_REVERSE\n");
    printf("                     3 GEAR_PARKING\n");
    printf("                     4 GEAR_LOW\n");
    printf("                     5 GEAR_INVALID\n");
    printf("                     6 GEAR_NONE\n");
    printf("\n-----------------------------------------------------------\n");
    printf("Throttle/Speed up:  [%c]     |  Set Throttle:       [%c]+Num\n",
           KEYCODE_UP1, KEYCODE_SETT1);
    printf("Brake/Speed down:   [%c]     |  Set Brake:          [%c]+Num\n",
           KEYCODE_DN1, KEYCODE_SETB1);
    printf("Steer LEFT:         [%c]     |  Steer RIGHT:        [%c]\n",
           KEYCODE_LF1, KEYCODE_RT1);
    printf("Parkinig Brake:     [%c]     |  Emergency Stop      [%c]\n",
           KEYCODE_PKBK, KEYCODE_ESTOP);
    printf("\n-----------------------------------------------------------\n");
    printf("Exit: Ctrl + C, then press enter to normal terminal\n");
    printf("===========================================================\n");
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\tools\teleop.cc" startLine="(78, 2)" endLine="(106, 3)" clone_start="10" clone_end="16">
			<code function_name="PrintKeycode()">  static void PrintKeycode() {
    system("clear");
    printf("=====================    KEYBOARD MAP   ===================\n");
    printf("HELP:               [%c]     |\n", KEYCODE_HELP);
    printf("Set Action      :   [%c]+Num\n", KEYCODE_MODE);
    printf("                     0 RESET ACTION\n");
    printf("                     1 START ACTION\n");
    printf("\n-----------------------------------------------------------\n");
    printf("Set Gear:           [%c]+Num\n", KEYCODE_SETG1);
    printf("                     0 GEAR_NEUTRAL\n");
    printf("                     1 GEAR_DRIVE\n");
    printf("                     2 GEAR_REVERSE\n");
    printf("                     3 GEAR_PARKING\n");
    printf("                     4 GEAR_LOW\n");
    printf("                     5 GEAR_INVALID\n");
    printf("                     6 GEAR_NONE\n");
    printf("\n-----------------------------------------------------------\n");
    printf("Throttle/Speed up:  [%c]     |  Set Throttle:       [%c]+Num\n",
           KEYCODE_UP1, KEYCODE_SETT1);
    printf("Brake/Speed down:   [%c]     |  Set Brake:          [%c]+Num\n",
           KEYCODE_DN1, KEYCODE_SETB1);
    printf("Steer LEFT:         [%c]     |  Steer RIGHT:        [%c]\n",
           KEYCODE_LF1, KEYCODE_RT1);
    printf("Parkinig Brake:     [%c]     |  Emergency Stop      [%c]\n",
           KEYCODE_PKBK, KEYCODE_ESTOP);
    printf("\n-----------------------------------------------------------\n");
    printf("Exit: Ctrl + C, then press enter to normal terminal\n");
    printf("===========================================================\n");
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\aaboxkdtree2d.h" startLine="(350, 2)" endLine="(378, 3)" clone_start="8" clone_end="14">
			<code function_name="PartitionObjects(const std::vector&lt;ObjectPtr&gt;&amp; objects,std::vector&lt;ObjectPtr&gt;* const left_subnode_objects, std::vector&lt;ObjectPtr&gt;* const right_subnode_objects)">  void PartitionObjects(const std::vector&lt;ObjectPtr&gt;&amp; objects,
                        std::vector&lt;ObjectPtr&gt;* const left_subnode_objects,
                        std::vector&lt;ObjectPtr&gt;* const right_subnode_objects) {
    left_subnode_objects-&gt;clear();
    right_subnode_objects-&gt;clear();
    std::vector&lt;ObjectPtr&gt; other_objects;
    if (partition_ == PARTITION_X) {
      for (ObjectPtr object : objects) {
        if (object-&gt;aabox().max_x() &lt;= partition_position_) {
          left_subnode_objects-&gt;push_back(object);
        } else if (object-&gt;aabox().min_x() &gt;= partition_position_) {
          right_subnode_objects-&gt;push_back(object);
        } else {
          other_objects.push_back(object);
        }
      }
    } else {
      for (ObjectPtr object : objects) {
        if (object-&gt;aabox().max_y() &lt;= partition_position_) {
          left_subnode_objects-&gt;push_back(object);
        } else if (object-&gt;aabox().min_y() &gt;= partition_position_) {
          right_subnode_objects-&gt;push_back(object);
        } else {
          other_objects.push_back(object);
        }
      }
    }
    InitObjects(other_objects);
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\aaboxkdtree2d.h" startLine="(350, 2)" endLine="(378, 3)" clone_start="18" clone_end="24">
			<code function_name="PartitionObjects(const std::vector&lt;ObjectPtr&gt;&amp; objects,std::vector&lt;ObjectPtr&gt;* const left_subnode_objects, std::vector&lt;ObjectPtr&gt;* const right_subnode_objects)">  void PartitionObjects(const std::vector&lt;ObjectPtr&gt;&amp; objects,
                        std::vector&lt;ObjectPtr&gt;* const left_subnode_objects,
                        std::vector&lt;ObjectPtr&gt;* const right_subnode_objects) {
    left_subnode_objects-&gt;clear();
    right_subnode_objects-&gt;clear();
    std::vector&lt;ObjectPtr&gt; other_objects;
    if (partition_ == PARTITION_X) {
      for (ObjectPtr object : objects) {
        if (object-&gt;aabox().max_x() &lt;= partition_position_) {
          left_subnode_objects-&gt;push_back(object);
        } else if (object-&gt;aabox().min_x() &gt;= partition_position_) {
          right_subnode_objects-&gt;push_back(object);
        } else {
          other_objects.push_back(object);
        }
      }
    } else {
      for (ObjectPtr object : objects) {
        if (object-&gt;aabox().max_y() &lt;= partition_position_) {
          left_subnode_objects-&gt;push_back(object);
        } else if (object-&gt;aabox().min_y() &gt;= partition_position_) {
          right_subnode_objects-&gt;push_back(object);
        } else {
          other_objects.push_back(object);
        }
      }
    }
    InitObjects(other_objects);
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(38, 0)" endLine="(50, 1)" clone_start="4" clone_end="10">
			<code function_name="get_serial_baudrate(uint32_t rate)">speed_t get_serial_baudrate(uint32_t rate) {
    switch (rate) {
    case 9600: return B9600;
    case 19200: return B19200;
    case 38400: return B38400;
    case 57600: return B57600;
    case 115200: return B115200;
    case 230400: return B230400;
    case 460800: return B460800;
    case 921600: return B921600;
    default: return 0;
    }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(38, 0)" endLine="(50, 1)" clone_start="3" clone_end="9">
			<code function_name="get_serial_baudrate(uint32_t rate)">speed_t get_serial_baudrate(uint32_t rate) {
    switch (rate) {
    case 9600: return B9600;
    case 19200: return B19200;
    case 38400: return B38400;
    case 57600: return B57600;
    case 115200: return B115200;
    case 230400: return B230400;
    case 460800: return B460800;
    case 921600: return B921600;
    default: return 0;
    }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\polygon2d.cc" startLine="(490, 0)" endLine="(547, 1)" clone_start="28" clone_end="37">
			<code function_name="Polygon2d::MinAreaBoundingBox() const">Box2d Polygon2d::MinAreaBoundingBox() const {
  CHECK_GE(points_.size(), 3);
  if (!is_convex_) {
    Polygon2d convex_polygon;
    ComputeConvexHull(points_, &amp;convex_polygon);
    CHECK(convex_polygon.is_convex());
    return convex_polygon.MinAreaBoundingBox();
  }
  double min_area = std::numeric_limits&lt;double&gt;::infinity();
  double min_area_at_heading = 0.0;
  int left_most = 0;
  int right_most = 0;
  int top_most = 0;
  for (int i = 0; i &lt; num_points_; ++i) {
    const auto&amp; line_segment = line_segments_[i];
    double proj = 0.0;
    double min_proj = line_segment.ProjectOntoUnit(points_[left_most]);
    while ((proj = line_segment.ProjectOntoUnit(points_[Prev(left_most)])) &lt;
           min_proj) {
      min_proj = proj;
      left_most = Prev(left_most);
    }
    while ((proj = line_segment.ProjectOntoUnit(points_[Next(left_most)])) &lt;
           min_proj) {
      min_proj = proj;
      left_most = Next(left_most);
    }
    double max_proj = line_segment.ProjectOntoUnit(points_[right_most]);
    while ((proj = line_segment.ProjectOntoUnit(points_[Prev(right_most)])) &gt;
           max_proj) {
      max_proj = proj;
      right_most = Prev(right_most);
    }
    while ((proj = line_segment.ProjectOntoUnit(points_[Next(right_most)])) &gt;
           max_proj) {
      max_proj = proj;
      right_most = Next(right_most);
    }
    double prod = 0.0;
    double max_prod = line_segment.ProductOntoUnit(points_[top_most]);
    while ((prod = line_segment.ProductOntoUnit(points_[Prev(top_most)])) &gt;
           max_prod) {
      max_prod = prod;
      top_most = Prev(top_most);
    }
    while ((prod = line_segment.ProductOntoUnit(points_[Next(top_most)])) &gt;
           max_prod) {
      max_prod = prod;
      top_most = Next(top_most);
    }
    const double area = max_prod * (max_proj - min_proj);
    if (area &lt; min_area) {
      min_area = area;
      min_area_at_heading = line_segment.heading();
    }
  }
  return BoundingBoxWithHeading(min_area_at_heading);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\polygon2d.cc" startLine="(490, 0)" endLine="(547, 1)" clone_start="40" clone_end="49">
			<code function_name="Polygon2d::MinAreaBoundingBox() const">Box2d Polygon2d::MinAreaBoundingBox() const {
  CHECK_GE(points_.size(), 3);
  if (!is_convex_) {
    Polygon2d convex_polygon;
    ComputeConvexHull(points_, &amp;convex_polygon);
    CHECK(convex_polygon.is_convex());
    return convex_polygon.MinAreaBoundingBox();
  }
  double min_area = std::numeric_limits&lt;double&gt;::infinity();
  double min_area_at_heading = 0.0;
  int left_most = 0;
  int right_most = 0;
  int top_most = 0;
  for (int i = 0; i &lt; num_points_; ++i) {
    const auto&amp; line_segment = line_segments_[i];
    double proj = 0.0;
    double min_proj = line_segment.ProjectOntoUnit(points_[left_most]);
    while ((proj = line_segment.ProjectOntoUnit(points_[Prev(left_most)])) &lt;
           min_proj) {
      min_proj = proj;
      left_most = Prev(left_most);
    }
    while ((proj = line_segment.ProjectOntoUnit(points_[Next(left_most)])) &lt;
           min_proj) {
      min_proj = proj;
      left_most = Next(left_most);
    }
    double max_proj = line_segment.ProjectOntoUnit(points_[right_most]);
    while ((proj = line_segment.ProjectOntoUnit(points_[Prev(right_most)])) &gt;
           max_proj) {
      max_proj = proj;
      right_most = Prev(right_most);
    }
    while ((proj = line_segment.ProjectOntoUnit(points_[Next(right_most)])) &gt;
           max_proj) {
      max_proj = proj;
      right_most = Next(right_most);
    }
    double prod = 0.0;
    double max_prod = line_segment.ProductOntoUnit(points_[top_most]);
    while ((prod = line_segment.ProductOntoUnit(points_[Prev(top_most)])) &gt;
           max_prod) {
      max_prod = prod;
      top_most = Prev(top_most);
    }
    while ((prod = line_segment.ProductOntoUnit(points_[Next(top_most)])) &gt;
           max_prod) {
      max_prod = prod;
      top_most = Next(top_most);
    }
    const double area = max_prod * (max_proj - min_proj);
    if (area &lt; min_area) {
      min_area = area;
      min_area_at_heading = line_segment.heading();
    }
  }
  return BoundingBoxWithHeading(min_area_at_heading);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(141, 0)" endLine="(249, 1)" clone_start="57" clone_end="67">
			<code function_name="LincolnController::chassis()">Chassis LincolnController::chassis() {
  chassis_.Clear();

  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  // 21, 22, previously 1, 2
  if (driving_mode() == Chassis::EMERGENCY_MODE) {
    set_chassis_error_code(Chassis::NO_ERROR);
  }

  chassis_.set_driving_mode(driving_mode());
  chassis_.set_error_code(chassis_error_code());

  // 3
  chassis_.set_engine_started(true);
  // 4
  if (chassis_detail.ems().has_engine_rpm()) {
    chassis_.set_engine_rpm(chassis_detail.ems().engine_rpm());
  } else {
    chassis_.set_engine_rpm(0);
  }
  // 5
  if (chassis_detail.vehicle_spd().has_vehicle_spd()) {
    chassis_.set_speed_mps(chassis_detail.vehicle_spd().vehicle_spd());
  } else {
    chassis_.set_speed_mps(0);
  }
  // 6
  chassis_.set_odometer_m(0);
  // 7
  // lincoln only has fuel percentage
  // to avoid confusing, just don't set
  chassis_.set_fuel_range_m(0);
  // 8
  if (chassis_detail.gas().has_throttle_output()) {
    chassis_.set_throttle_percentage(chassis_detail.gas().throttle_output());
  } else {
    chassis_.set_throttle_percentage(0);
  }
  // 9
  if (chassis_detail.brake().has_brake_output()) {
    chassis_.set_brake_percentage(chassis_detail.brake().brake_output());
  } else {
    chassis_.set_brake_percentage(0);
  }
  // 23, previously 10
  if (chassis_detail.gear().has_gear_state()) {
    chassis_.set_gear_location(chassis_detail.gear().gear_state());
  } else {
    chassis_.set_gear_location(Chassis::GEAR_NONE);
  }
  // 11
  if (chassis_detail.eps().has_steering_angle()) {
    chassis_.set_steering_percentage(chassis_detail.eps().steering_angle() *
                                     100.0 / params_.max_steer_angle());
  } else {
    chassis_.set_steering_percentage(0);
  }
  // 12
  if (chassis_detail.eps().has_epas_torque()) {
    chassis_.set_steering_torque_nm(chassis_detail.eps().epas_torque());
  } else {
    chassis_.set_steering_torque_nm(0);
  }
  // 13
  if (chassis_detail.epb().has_parking_brake_status()) {
    chassis_.set_parking_brake(chassis_detail.epb().parking_brake_status() ==
                               Epb::PBRAKE_ON);
  } else {
    chassis_.set_parking_brake(false);
  }
  // TODO: lincoln beam
  // 14, 15

  // 16, 17
  if (chassis_detail.light().has_turn_light_type() &amp;&amp;
      chassis_detail.light().turn_light_type() != Light::TURN_LIGHT_OFF) {
    if (chassis_detail.light().turn_light_type() == Light::TURN_LEFT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_LEFT);
    } else if (chassis_detail.light().turn_light_type() ==
               Light::TURN_RIGHT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_RIGHT);
    } else {
      chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_NONE);
    }
  } else {
    chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_NONE);
  }
  // 18
  if (chassis_detail.light().has_is_horn_on() &amp;&amp;
      chassis_detail.light().is_horn_on()) {
    chassis_.mutable_signal()-&gt;set_horn(true);
  } else {
    chassis_.mutable_signal()-&gt;set_horn(false);
  }

  // 19, lincoln wiper is too complicated
  // 24
  if (chassis_detail.eps().has_timestamp_65()) {
    chassis_.set_steering_timestamp(chassis_detail.eps().timestamp_65());
  }
  // 26
  if (chassis_error_mask_) {
    chassis_.set_chassis_error_mask(chassis_error_mask_);
  }

  return chassis_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(141, 0)" endLine="(249, 1)" clone_start="38" clone_end="48">
			<code function_name="LincolnController::chassis()">Chassis LincolnController::chassis() {
  chassis_.Clear();

  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  // 21, 22, previously 1, 2
  if (driving_mode() == Chassis::EMERGENCY_MODE) {
    set_chassis_error_code(Chassis::NO_ERROR);
  }

  chassis_.set_driving_mode(driving_mode());
  chassis_.set_error_code(chassis_error_code());

  // 3
  chassis_.set_engine_started(true);
  // 4
  if (chassis_detail.ems().has_engine_rpm()) {
    chassis_.set_engine_rpm(chassis_detail.ems().engine_rpm());
  } else {
    chassis_.set_engine_rpm(0);
  }
  // 5
  if (chassis_detail.vehicle_spd().has_vehicle_spd()) {
    chassis_.set_speed_mps(chassis_detail.vehicle_spd().vehicle_spd());
  } else {
    chassis_.set_speed_mps(0);
  }
  // 6
  chassis_.set_odometer_m(0);
  // 7
  // lincoln only has fuel percentage
  // to avoid confusing, just don't set
  chassis_.set_fuel_range_m(0);
  // 8
  if (chassis_detail.gas().has_throttle_output()) {
    chassis_.set_throttle_percentage(chassis_detail.gas().throttle_output());
  } else {
    chassis_.set_throttle_percentage(0);
  }
  // 9
  if (chassis_detail.brake().has_brake_output()) {
    chassis_.set_brake_percentage(chassis_detail.brake().brake_output());
  } else {
    chassis_.set_brake_percentage(0);
  }
  // 23, previously 10
  if (chassis_detail.gear().has_gear_state()) {
    chassis_.set_gear_location(chassis_detail.gear().gear_state());
  } else {
    chassis_.set_gear_location(Chassis::GEAR_NONE);
  }
  // 11
  if (chassis_detail.eps().has_steering_angle()) {
    chassis_.set_steering_percentage(chassis_detail.eps().steering_angle() *
                                     100.0 / params_.max_steer_angle());
  } else {
    chassis_.set_steering_percentage(0);
  }
  // 12
  if (chassis_detail.eps().has_epas_torque()) {
    chassis_.set_steering_torque_nm(chassis_detail.eps().epas_torque());
  } else {
    chassis_.set_steering_torque_nm(0);
  }
  // 13
  if (chassis_detail.epb().has_parking_brake_status()) {
    chassis_.set_parking_brake(chassis_detail.epb().parking_brake_status() ==
                               Epb::PBRAKE_ON);
  } else {
    chassis_.set_parking_brake(false);
  }
  // TODO: lincoln beam
  // 14, 15

  // 16, 17
  if (chassis_detail.light().has_turn_light_type() &amp;&amp;
      chassis_detail.light().turn_light_type() != Light::TURN_LIGHT_OFF) {
    if (chassis_detail.light().turn_light_type() == Light::TURN_LEFT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_LEFT);
    } else if (chassis_detail.light().turn_light_type() ==
               Light::TURN_RIGHT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_RIGHT);
    } else {
      chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_NONE);
    }
  } else {
    chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_NONE);
  }
  // 18
  if (chassis_detail.light().has_is_horn_on() &amp;&amp;
      chassis_detail.light().is_horn_on()) {
    chassis_.mutable_signal()-&gt;set_horn(true);
  } else {
    chassis_.mutable_signal()-&gt;set_horn(false);
  }

  // 19, lincoln wiper is too complicated
  // 24
  if (chassis_detail.eps().has_timestamp_65()) {
    chassis_.set_steering_timestamp(chassis_detail.eps().timestamp_65());
  }
  // 26
  if (chassis_error_mask_) {
    chassis_.set_chassis_error_mask(chassis_error_mask_);
  }

  return chassis_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\planning\planning_node.cc" startLine="(102, 0)" endLine="(123, 1)" clone_start="13" clone_end="19">
			<code function_name="PlanningNode::ToTrajectoryPb(const double header_time, const std::vector&lt;TrajectoryPoint&gt;&amp; discretized_trajectory)">TrajectoryPb PlanningNode::ToTrajectoryPb(
    const double header_time,
    const std::vector&lt;TrajectoryPoint&gt;&amp; discretized_trajectory) {
  TrajectoryPb trajectory_pb;
  AdapterManager::FillPlanningTrajectoryHeader("planning",
                                               trajectory_pb.mutable_header());

  trajectory_pb.mutable_header()-&gt;set_timestamp_sec(header_time);

  for (const auto&amp; trajectory_point : discretized_trajectory) {
    auto ptr_trajectory_point_pb = trajectory_pb.add_adc_trajectory_point();
    ptr_trajectory_point_pb-&gt;set_x(trajectory_point.x);
    ptr_trajectory_point_pb-&gt;set_y(trajectory_point.y);
    ptr_trajectory_point_pb-&gt;set_theta(trajectory_point.theta);
    ptr_trajectory_point_pb-&gt;set_curvature(trajectory_point.kappa);
    ptr_trajectory_point_pb-&gt;set_relative_time(trajectory_point.relative_time);
    ptr_trajectory_point_pb-&gt;set_speed(trajectory_point.v);
    ptr_trajectory_point_pb-&gt;set_acceleration_s(trajectory_point.a);
    ptr_trajectory_point_pb-&gt;set_accumulated_s(trajectory_point.s);
  }
  return std::move(trajectory_pb);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\planning\planning_node.cc" startLine="(102, 0)" endLine="(123, 1)" clone_start="12" clone_end="18">
			<code function_name="PlanningNode::ToTrajectoryPb(const double header_time, const std::vector&lt;TrajectoryPoint&gt;&amp; discretized_trajectory)">TrajectoryPb PlanningNode::ToTrajectoryPb(
    const double header_time,
    const std::vector&lt;TrajectoryPoint&gt;&amp; discretized_trajectory) {
  TrajectoryPb trajectory_pb;
  AdapterManager::FillPlanningTrajectoryHeader("planning",
                                               trajectory_pb.mutable_header());

  trajectory_pb.mutable_header()-&gt;set_timestamp_sec(header_time);

  for (const auto&amp; trajectory_point : discretized_trajectory) {
    auto ptr_trajectory_point_pb = trajectory_pb.add_adc_trajectory_point();
    ptr_trajectory_point_pb-&gt;set_x(trajectory_point.x);
    ptr_trajectory_point_pb-&gt;set_y(trajectory_point.y);
    ptr_trajectory_point_pb-&gt;set_theta(trajectory_point.theta);
    ptr_trajectory_point_pb-&gt;set_curvature(trajectory_point.kappa);
    ptr_trajectory_point_pb-&gt;set_relative_time(trajectory_point.relative_time);
    ptr_trajectory_point_pb-&gt;set_speed(trajectory_point.v);
    ptr_trajectory_point_pb-&gt;set_acceleration_s(trajectory_point.a);
    ptr_trajectory_point_pb-&gt;set_accumulated_s(trajectory_point.s);
  }
  return std::move(trajectory_pb);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(85, 0)" endLine="(89, 1)" clone_start="4" clone_end="5">
			<code function_name="Gps6e::pdop(const std::uint8_t* bytes, int32_t length) const">double Gps6e::pdop(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 7);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(111, 0)" endLine="(119, 1)" clone_start="8" clone_end="9">
			<code function_name="Steering65::epas_torque(const std::uint8_t* bytes, int32_t length) const">double Steering65::epas_torque(const std::uint8_t* bytes,
                               int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 8);
  if (x &gt; 0x7F) {
    x -= 0x100;
  }
  return x * 0.062500;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(175, 0)" endLine="(187, 1)" clone_start="12" clone_end="13">
			<code function_name="Brakeinfo74::acceleration_over_ground(const std::uint8_t* bytes, int32_t length) const">double Brakeinfo74::acceleration_over_ground(const std::uint8_t* bytes,
                                             int32_t length) const {
  // vehicle acceleration over ground estimate
  Byte frame_high(bytes + 7);
  int32_t high = frame_high.get_byte(0, 2);
  Byte frame_low(bytes + 6);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FF) {
    value -= 0x400;
  }
  return value * 0.035000;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(91, 0)" endLine="(94, 1)" clone_start="1" clone_end="4">
			<code function_name="Gps6e::is_gps_fault(const std::uint8_t* bytes, int32_t length) const">bool Gps6e::is_gps_fault(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(121, 0)" endLine="(124, 1)" clone_start="1" clone_end="4">
			<code function_name="Steering65::is_enabled(const std::uint8_t* bytes, int32_t length) const">bool Steering65::is_enabled(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(189, 0)" endLine="(193, 1)" clone_start="1" clone_end="5">
			<code function_name="Brakeinfo74::is_abs_active(const std::uint8_t* bytes, int32_t length) const">bool Brakeinfo74::is_abs_active(const std::uint8_t* bytes,
                                int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(2);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(96, 0)" endLine="(100, 1)" clone_start="1" clone_end="4">
			<code function_name="Gps6e::is_inferred_position(const std::uint8_t* bytes, int32_t length) const">bool Gps6e::is_inferred_position(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(126, 0)" endLine="(131, 1)" clone_start="1" clone_end="5">
			<code function_name="Steering65::is_driver_override(const std::uint8_t* bytes, int32_t length) const">bool Steering65::is_driver_override(const std::uint8_t* bytes,
                                    int32_t length) const {
  // Cleared on rising edge of EN bit in command message
  Byte frame(bytes + 7);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(195, 0)" endLine="(199, 1)" clone_start="1" clone_end="4">
			<code function_name="Brakeinfo74::is_abs_enabled(const std::uint8_t* bytes, int32_t length) const">bool Brakeinfo74::is_abs_enabled(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(269, 0)" endLine="(324, 1)" clone_start="17" clone_end="24">
			<code function_name="SerialStream::read(uint8_t* buffer, size_t max_length)">size_t SerialStream::read(uint8_t* buffer, size_t max_length) {
    if (!_is_open) {
        if (!connect()) {
            return 0;
        }
        ROS_INFO_STREAM("Connect " &lt;&lt; _device_name &lt;&lt; " success.");
    }

    ssize_t bytes_read = 0;
    ssize_t bytes_current_read = 0;

    wait_readable(100000); //wait 10ms

    while (max_length &gt; 0) {
        bytes_current_read = ::read(_fd, buffer, max_length);
        if (bytes_current_read &lt; 0) {
            switch (errno) {
            case EAGAIN:
            case EINVAL:
                bytes_current_read = 0;
                break;

            case EBADF:
            case EIO:
                ROS_ERROR_STREAM("Serial stream read data failed, error: "
                             &lt;&lt; strerror(errno));
                disconnect();
                if (connect()) {
                    ROS_INFO_STREAM("Reconnect " &lt;&lt; _device_name &lt;&lt; "success.");
                    bytes_current_read = 0;
                    break; //has recoverable
                }

            default:
                ROS_ERROR_STREAM_THROTTLE(1, "Serial stream read data failed, error: "
                             &lt;&lt; strerror(errno) &lt;&lt; ", errno: " &lt;&lt; errno);
                _status = Stream::Status::ERROR;
                _errno = errno;
                return bytes_read;
            }
        }

        if (bytes_current_read == 0) {
            if (!bytes_read) {
                check_remove();
                return 0;
            }
            return bytes_read;
        }
        max_length -= bytes_current_read;
        buffer += bytes_current_read;
        bytes_read += bytes_current_read;
    }

    return bytes_read;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(326, 0)" endLine="(378, 1)" clone_start="17" clone_end="24">
			<code function_name="SerialStream::write(const uint8_t* data, size_t length)">size_t SerialStream::write(const uint8_t* data, size_t length) {
    if (!_is_open) {
        if (!connect()) {
            return 0;
        }
        ROS_INFO_STREAM("Connect " &lt;&lt; _device_name &lt;&lt; " success.");
    }

    size_t total_nsent = 0;
    size_t delay_times = 0;

    while ((length &gt; 0) &amp;&amp; (delay_times &lt; 5)) {
        ssize_t nsent = ::write(_fd, data, length);
        if (nsent &lt; 0) {
            ROS_ERROR_STREAM("Serial stream write data failed, error: "
                             &lt;&lt; strerror(errno));
            switch (errno) {
            case EAGAIN:
            case EINVAL:
                nsent = 0;
                break;

            case EBADF:
            case EIO:
                disconnect();
                if (connect()) {
                    ROS_INFO_STREAM("Reconnect " &lt;&lt; _device_name &lt;&lt; "success.");
                    nsent = 0;
                    break; //has recoverable
                }

            default:
                _status = Stream::Status::ERROR;
                _errno = errno;
                return total_nsent;
            }
        }

        if (nsent == 0) {
            if (!wait_writable(_byte_time_us)) {
                break;
            }
            ++delay_times;
            continue;
        }

        total_nsent += nsent;
        length -= nsent;
        data += nsent;
    }

    return total_nsent;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\common\trajectory_analyzer.cc" startLine="(31, 0)" endLine="(56, 1)" clone_start="16" clone_end="22">
			<code function_name="TrajectoryAnalyzer::TrajectoryAnalyzer( const planning::ADCTrajectory* planning_published_trajectory)">TrajectoryAnalyzer::TrajectoryAnalyzer(
    const planning::ADCTrajectory* planning_published_trajectory) {
  header_time_ = planning_published_trajectory-&gt;header().timestamp_sec();
  seq_num_ = planning_published_trajectory-&gt;header().sequence_num();

  int num_points = planning_published_trajectory-&gt;adc_trajectory_point_size();
  trajectory_points_.reserve(num_points);

  for (int i = 0;
       i &lt; planning_published_trajectory-&gt;adc_trajectory_point_size(); ++i) {
    const auto&amp; published_trajectory_point =
        planning_published_trajectory-&gt;adc_trajectory_point(i);

    TrajectoryPoint point;
    point.s = published_trajectory_point.accumulated_s();
    point.x = published_trajectory_point.x();
    point.y = published_trajectory_point.y();
    point.theta = published_trajectory_point.theta();
    point.kappa = published_trajectory_point.curvature();
    point.v = published_trajectory_point.speed();
    point.a = published_trajectory_point.acceleration_s();
    point.relative_time = published_trajectory_point.relative_time();

    trajectory_points_.push_back(std::move(point));
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\common\trajectory_analyzer.cc" startLine="(31, 0)" endLine="(56, 1)" clone_start="15" clone_end="21">
			<code function_name="TrajectoryAnalyzer::TrajectoryAnalyzer( const planning::ADCTrajectory* planning_published_trajectory)">TrajectoryAnalyzer::TrajectoryAnalyzer(
    const planning::ADCTrajectory* planning_published_trajectory) {
  header_time_ = planning_published_trajectory-&gt;header().timestamp_sec();
  seq_num_ = planning_published_trajectory-&gt;header().sequence_num();

  int num_points = planning_published_trajectory-&gt;adc_trajectory_point_size();
  trajectory_points_.reserve(num_points);

  for (int i = 0;
       i &lt; planning_published_trajectory-&gt;adc_trajectory_point_size(); ++i) {
    const auto&amp; published_trajectory_point =
        planning_published_trajectory-&gt;adc_trajectory_point(i);

    TrajectoryPoint point;
    point.s = published_trajectory_point.accumulated_s();
    point.x = published_trajectory_point.x();
    point.y = published_trajectory_point.y();
    point.theta = published_trajectory_point.theta();
    point.kappa = published_trajectory_point.curvature();
    point.v = published_trajectory_point.speed();
    point.a = published_trajectory_point.acceleration_s();
    point.relative_time = published_trajectory_point.relative_time();

    trajectory_points_.push_back(std::move(point));
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(269, 0)" endLine="(324, 1)" clone_start="1" clone_end="10">
			<code function_name="SerialStream::read(uint8_t* buffer, size_t max_length)">size_t SerialStream::read(uint8_t* buffer, size_t max_length) {
    if (!_is_open) {
        if (!connect()) {
            return 0;
        }
        ROS_INFO_STREAM("Connect " &lt;&lt; _device_name &lt;&lt; " success.");
    }

    ssize_t bytes_read = 0;
    ssize_t bytes_current_read = 0;

    wait_readable(100000); //wait 10ms

    while (max_length &gt; 0) {
        bytes_current_read = ::read(_fd, buffer, max_length);
        if (bytes_current_read &lt; 0) {
            switch (errno) {
            case EAGAIN:
            case EINVAL:
                bytes_current_read = 0;
                break;

            case EBADF:
            case EIO:
                ROS_ERROR_STREAM("Serial stream read data failed, error: "
                             &lt;&lt; strerror(errno));
                disconnect();
                if (connect()) {
                    ROS_INFO_STREAM("Reconnect " &lt;&lt; _device_name &lt;&lt; "success.");
                    bytes_current_read = 0;
                    break; //has recoverable
                }

            default:
                ROS_ERROR_STREAM_THROTTLE(1, "Serial stream read data failed, error: "
                             &lt;&lt; strerror(errno) &lt;&lt; ", errno: " &lt;&lt; errno);
                _status = Stream::Status::ERROR;
                _errno = errno;
                return bytes_read;
            }
        }

        if (bytes_current_read == 0) {
            if (!bytes_read) {
                check_remove();
                return 0;
            }
            return bytes_read;
        }
        max_length -= bytes_current_read;
        buffer += bytes_current_read;
        bytes_read += bytes_current_read;
    }

    return bytes_read;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(326, 0)" endLine="(378, 1)" clone_start="1" clone_end="10">
			<code function_name="SerialStream::write(const uint8_t* data, size_t length)">size_t SerialStream::write(const uint8_t* data, size_t length) {
    if (!_is_open) {
        if (!connect()) {
            return 0;
        }
        ROS_INFO_STREAM("Connect " &lt;&lt; _device_name &lt;&lt; " success.");
    }

    size_t total_nsent = 0;
    size_t delay_times = 0;

    while ((length &gt; 0) &amp;&amp; (delay_times &lt; 5)) {
        ssize_t nsent = ::write(_fd, data, length);
        if (nsent &lt; 0) {
            ROS_ERROR_STREAM("Serial stream write data failed, error: "
                             &lt;&lt; strerror(errno));
            switch (errno) {
            case EAGAIN:
            case EINVAL:
                nsent = 0;
                break;

            case EBADF:
            case EIO:
                disconnect();
                if (connect()) {
                    ROS_INFO_STREAM("Reconnect " &lt;&lt; _device_name &lt;&lt; "success.");
                    nsent = 0;
                    break; //has recoverable
                }

            default:
                _status = Stream::Status::ERROR;
                _errno = errno;
                return total_nsent;
            }
        }

        if (nsent == 0) {
            if (!wait_writable(_byte_time_us)) {
                break;
            }
            ++delay_times;
            continue;
        }

        total_nsent += nsent;
        length -= nsent;
        data += nsent;
    }

    return total_nsent;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\aabox2d.h" startLine="(81, 2)" endLine="(81, 49)" clone_start="1" clone_end="1">
			<code function_name="center_x() const">  double center_x() const { return center_.x(); }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\box2d.h" startLine="(96, 2)" endLine="(96, 49)" clone_start="1" clone_end="1">
			<code function_name="center_x() const">  double center_x() const { return center_.x(); }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\aabox2d.h" startLine="(87, 2)" endLine="(87, 49)" clone_start="1" clone_end="1">
			<code function_name="center_y() const">  double center_y() const { return center_.y(); }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\box2d.h" startLine="(102, 2)" endLine="(102, 49)" clone_start="1" clone_end="1">
			<code function_name="center_y() const">  double center_y() const { return center_.y(); }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\aabox2d.h" startLine="(93, 2)" endLine="(93, 43)" clone_start="1" clone_end="1">
			<code function_name="length() const">  double length() const { return length_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\box2d.h" startLine="(108, 2)" endLine="(108, 43)" clone_start="1" clone_end="1">
			<code function_name="length() const">  double length() const { return length_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\aabox2d.h" startLine="(99, 2)" endLine="(99, 41)" clone_start="1" clone_end="1">
			<code function_name="width() const">  double width() const { return width_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\box2d.h" startLine="(114, 2)" endLine="(114, 41)" clone_start="1" clone_end="1">
			<code function_name="width() const">  double width() const { return width_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\aabox2d.h" startLine="(105, 2)" endLine="(105, 53)" clone_start="1" clone_end="1">
			<code function_name="half_length() const">  double half_length() const { return half_length_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\box2d.h" startLine="(120, 2)" endLine="(120, 53)" clone_start="1" clone_end="1">
			<code function_name="half_length() const">  double half_length() const { return half_length_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\aabox2d.h" startLine="(111, 2)" endLine="(111, 51)" clone_start="1" clone_end="1">
			<code function_name="half_width() const">  double half_width() const { return half_width_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\box2d.h" startLine="(126, 2)" endLine="(126, 51)" clone_start="1" clone_end="1">
			<code function_name="half_width() const">  double half_width() const { return half_width_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\controller\lon_controller.cc" startLine="(108, 0)" endLine="(114, 1)" clone_start="5" clone_end="7">
			<code function_name="LonController::SetDigitalFilterAcceleration( const LonControllerConf &amp;lon_controller_conf)">void LonController::SetDigitalFilterAcceleration(
    const LonControllerConf &amp;lon_controller_conf) {
  double cutoff_freq =
      lon_controller_conf.acceleration_filter_conf().cutoff_freq();
  double ts = lon_controller_conf.ts();
  SetDigitalFilter(ts, cutoff_freq, &amp;digital_filter_acceleration_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\controller\lon_controller.cc" startLine="(116, 0)" endLine="(121, 1)" clone_start="4" clone_end="6">
			<code function_name="LonController::SetDigitalFilterThrottle( const LonControllerConf &amp;lon_controller_conf)">void LonController::SetDigitalFilterThrottle(
    const LonControllerConf &amp;lon_controller_conf) {
  double cutoff_freq = lon_controller_conf.throttle_filter_conf().cutoff_freq();
  double ts = lon_controller_conf.ts();
  SetDigitalFilter(ts, cutoff_freq, &amp;digital_filter_throttle_);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\controller\lon_controller.cc" startLine="(116, 0)" endLine="(121, 1)" clone_start="1" clone_end="6">
			<code function_name="LonController::SetDigitalFilterThrottle( const LonControllerConf &amp;lon_controller_conf)">void LonController::SetDigitalFilterThrottle(
    const LonControllerConf &amp;lon_controller_conf) {
  double cutoff_freq = lon_controller_conf.throttle_filter_conf().cutoff_freq();
  double ts = lon_controller_conf.ts();
  SetDigitalFilter(ts, cutoff_freq, &amp;digital_filter_throttle_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\controller\lon_controller.cc" startLine="(123, 0)" endLine="(128, 1)" clone_start="1" clone_end="6">
			<code function_name="LonController::SetDigitalFilterBrake( const LonControllerConf &amp;lon_controller_conf)">void LonController::SetDigitalFilterBrake(
    const LonControllerConf &amp;lon_controller_conf) {
  double cutoff_freq = lon_controller_conf.brake_filter_conf().cutoff_freq();
  double ts = lon_controller_conf.ts();
  SetDigitalFilter(ts, cutoff_freq, &amp;digital_filter_brake_);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\controller\lon_controller.cc" startLine="(123, 0)" endLine="(128, 1)" clone_start="1" clone_end="1">
			<code function_name="LonController::SetDigitalFilterBrake( const LonControllerConf &amp;lon_controller_conf)">void LonController::SetDigitalFilterBrake(
    const LonControllerConf &amp;lon_controller_conf) {
  double cutoff_freq = lon_controller_conf.brake_filter_conf().cutoff_freq();
  double ts = lon_controller_conf.ts();
  SetDigitalFilter(ts, cutoff_freq, &amp;digital_filter_brake_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\controller\lon_controller.cc" startLine="(130, 0)" endLine="(146, 1)" clone_start="1" clone_end="1">
			<code function_name="LonController::LoadControlCalibrationTable( const LonControllerConf &amp;lon_controller_conf)">void LonController::LoadControlCalibrationTable(
    const LonControllerConf &amp;lon_controller_conf) {
  const auto &amp;control_table = lon_controller_conf.calibration_table();
  AINFO &lt;&lt; "Control calibration table loaded";
  int control_table_size = control_table.calibration_size();
  AINFO &lt;&lt; "Control calibration table size is " &lt;&lt; control_table_size;
  Interpolation2D::DataType xyz;
  for (int i = 0; i &lt; control_table_size; ++i) {
    const auto &amp;calibration = control_table.calibration(i);
    xyz.push_back(std::make_tuple(calibration.speed(),
                                  calibration.acceleration(),
                                  calibration.command()));
  }
  control_interpolation_.reset(new Interpolation2D);
  CHECK(control_interpolation_-&gt;Init(xyz))
      &lt;&lt; "Fail to load control calibration table";
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\planning\planning_node.cc" startLine="(46, 0)" endLine="(96, 1)" clone_start="14" clone_end="22">
			<code function_name="PlanningNode::RunOnce()">void PlanningNode::RunOnce() {
  AdapterManager::Observe();
  if (AdapterManager::GetLocalization() == nullptr) {
    AERROR &lt;&lt; "Localization is not available; skip the planning cycle";
    return;
  }
  if (AdapterManager::GetLocalization()-&gt;Empty()) {
    AERROR &lt;&lt; "localization messages are missing; skip the planning cycle";
    return;
  } else {
    AINFO &lt;&lt; "Get localization message;";
  }

  if (AdapterManager::GetChassis() == nullptr) {
    AERROR &lt;&lt; "Chassis is not available; skip the planning cycle";
    return;
  }
  if (AdapterManager::GetChassis()-&gt;Empty()) {
    AERROR &lt;&lt; "Chassis messages are missing; skip the planning cycle";
    return;
  } else {
    AINFO &lt;&lt; "Get localization message;";
  }

  AINFO &lt;&lt; "Start planning ...";

  const auto&amp; localization =
      AdapterManager::GetLocalization()-&gt;GetLatestObserved();
  VehicleState vehicle_state(localization);

  const auto&amp; chassis = AdapterManager::GetChassis()-&gt;GetLatestObserved();
  bool is_on_auto_mode = chassis.driving_mode() == chassis.COMPLETE_AUTO_DRIVE;

  double planning_cycle_time = 1.0 / FLAGS_planning_loop_rate;
  // the execution_start_time is the estimated time when the planned trajectory
  // will be executed by the controller.
  double execution_start_time =
      apollo::common::time::ToSecond(apollo::common::time::Clock::Now()) +
      planning_cycle_time;

  std::vector&lt;TrajectoryPoint&gt; planning_trajectory;
  bool res_planning = planning_.Plan(vehicle_state, is_on_auto_mode,
      execution_start_time, &amp;planning_trajectory);
  if (res_planning) {
    TrajectoryPb trajectory_pb = ToTrajectoryPb(execution_start_time, planning_trajectory);
    AdapterManager::PublishPlanningTrajectory(trajectory_pb);
    AINFO &lt;&lt; "Planning succeeded";
  } else {
    AINFO &lt;&lt; "Planning failed";
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\planning\planning_node.cc" startLine="(46, 0)" endLine="(96, 1)" clone_start="3" clone_end="11">
			<code function_name="PlanningNode::RunOnce()">void PlanningNode::RunOnce() {
  AdapterManager::Observe();
  if (AdapterManager::GetLocalization() == nullptr) {
    AERROR &lt;&lt; "Localization is not available; skip the planning cycle";
    return;
  }
  if (AdapterManager::GetLocalization()-&gt;Empty()) {
    AERROR &lt;&lt; "localization messages are missing; skip the planning cycle";
    return;
  } else {
    AINFO &lt;&lt; "Get localization message;";
  }

  if (AdapterManager::GetChassis() == nullptr) {
    AERROR &lt;&lt; "Chassis is not available; skip the planning cycle";
    return;
  }
  if (AdapterManager::GetChassis()-&gt;Empty()) {
    AERROR &lt;&lt; "Chassis messages are missing; skip the planning cycle";
    return;
  } else {
    AINFO &lt;&lt; "Get localization message;";
  }

  AINFO &lt;&lt; "Start planning ...";

  const auto&amp; localization =
      AdapterManager::GetLocalization()-&gt;GetLatestObserved();
  VehicleState vehicle_state(localization);

  const auto&amp; chassis = AdapterManager::GetChassis()-&gt;GetLatestObserved();
  bool is_on_auto_mode = chassis.driving_mode() == chassis.COMPLETE_AUTO_DRIVE;

  double planning_cycle_time = 1.0 / FLAGS_planning_loop_rate;
  // the execution_start_time is the estimated time when the planned trajectory
  // will be executed by the controller.
  double execution_start_time =
      apollo::common::time::ToSecond(apollo::common::time::Clock::Now()) +
      planning_cycle_time;

  std::vector&lt;TrajectoryPoint&gt; planning_trajectory;
  bool res_planning = planning_.Plan(vehicle_state, is_on_auto_mode,
      execution_start_time, &amp;planning_trajectory);
  if (res_planning) {
    TrajectoryPb trajectory_pb = ToTrajectoryPb(execution_start_time, planning_trajectory);
    AdapterManager::PublishPlanningTrajectory(trajectory_pb);
    AINFO &lt;&lt; "Planning succeeded";
  } else {
    AINFO &lt;&lt; "Planning failed";
  }
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(286, 0)" endLine="(322, 1)" clone_start="36" clone_end="37">
			<code function_name="TcpStream::write(const uint8_t* buffer, size_t length)">size_t TcpStream::write(const uint8_t* buffer, size_t length) {
    ssize_t  nsent = 0;
    size_t total_nsent = 0;

    if (_status != Stream::Status::CONNECTED) {
        disconnect();
        connect();
        if (_status != Stream::Status::CONNECTED) {
            return 0;
        }
    }

    while (length &gt; 0) {
        nsent = ::send(_sockfd, buffer, length, 0);
        if (nsent &lt; 0) {
            if (errno == EINTR) {
                continue;
            } else {
                // error
                if (errno == EPIPE || errno == ECONNRESET) {
                    _status = Stream::Status::DISCONNECTED;
                    _errno = errno;
                } else if (errno != EAGAIN) {
                    _status = Stream::Status::ERROR;
                    _errno = errno;
                }
                return total_nsent;
            }
        }

        total_nsent += nsent;
        length -= nsent;
        buffer += nsent;
    }

    return total_nsent;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(326, 0)" endLine="(378, 1)" clone_start="52" clone_end="53">
			<code function_name="SerialStream::write(const uint8_t* data, size_t length)">size_t SerialStream::write(const uint8_t* data, size_t length) {
    if (!_is_open) {
        if (!connect()) {
            return 0;
        }
        ROS_INFO_STREAM("Connect " &lt;&lt; _device_name &lt;&lt; " success.");
    }

    size_t total_nsent = 0;
    size_t delay_times = 0;

    while ((length &gt; 0) &amp;&amp; (delay_times &lt; 5)) {
        ssize_t nsent = ::write(_fd, data, length);
        if (nsent &lt; 0) {
            ROS_ERROR_STREAM("Serial stream write data failed, error: "
                             &lt;&lt; strerror(errno));
            switch (errno) {
            case EAGAIN:
            case EINVAL:
                nsent = 0;
                break;

            case EBADF:
            case EIO:
                disconnect();
                if (connect()) {
                    ROS_INFO_STREAM("Reconnect " &lt;&lt; _device_name &lt;&lt; "success.");
                    nsent = 0;
                    break; //has recoverable
                }

            default:
                _status = Stream::Status::ERROR;
                _errno = errno;
                return total_nsent;
            }
        }

        if (nsent == 0) {
            if (!wait_writable(_byte_time_us)) {
                break;
            }
            ++delay_times;
            continue;
        }

        total_nsent += nsent;
        length -= nsent;
        data += nsent;
    }

    return total_nsent;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(380, 0)" endLine="(400, 1)" clone_start="20" clone_end="21">
			<code function_name="SerialStream::wait_readable (uint32_t timeout_us)">bool SerialStream::wait_readable (uint32_t timeout_us) {
    // Setup a select call to block for serial data or a timeout
    timespec timeout_ts;
    fd_set readfds;
    FD_ZERO(&amp;readfds);
    FD_SET(_fd, &amp;readfds);

    timeout_ts.tv_sec = timeout_us / 1000000;
    timeout_ts.tv_nsec = (timeout_us % 1000000) * 1000;
    int r = pselect(_fd + 1, &amp;readfds, NULL, NULL, &amp;timeout_ts, NULL);
    if (r &lt;= 0) {
        return false;
    }

    // This shouldn't happen, if r &gt; 0 our fd has to be in the list!
    if (!FD_ISSET(_fd, &amp;readfds)) {
        return false;
    }
    // Data available to read.
    return true;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(324, 0)" endLine="(344, 1)" clone_start="1" clone_end="9">
			<code function_name="TcpStream::readable(uint32_t timeout_us)">bool TcpStream::readable(uint32_t timeout_us) {
    // Setup a select call to block for serial data or a timeout
    timespec timeout_ts;
    fd_set readfds;
    FD_ZERO(&amp;readfds);
    FD_SET(_sockfd, &amp;readfds);

    timeout_ts.tv_sec = timeout_us / 1000000;
    timeout_ts.tv_nsec = (timeout_us % 1000000) * 1000;
    int r = pselect(_sockfd + 1, &amp;readfds, NULL, NULL, &amp;timeout_ts, NULL);
    if (r &lt; 0) {
        _status = Stream::Status::ERROR;
        _errno = errno;
        ROS_ERROR("Failed to wait tcp data: %d, %s", errno, strerror(errno));
        return false;
    } else if (r == 0 || !FD_ISSET(_sockfd, &amp;readfds)) {
        return false;
    }
    // Data available to read.
    return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(380, 0)" endLine="(400, 1)" clone_start="1" clone_end="9">
			<code function_name="SerialStream::wait_readable (uint32_t timeout_us)">bool SerialStream::wait_readable (uint32_t timeout_us) {
    // Setup a select call to block for serial data or a timeout
    timespec timeout_ts;
    fd_set readfds;
    FD_ZERO(&amp;readfds);
    FD_SET(_fd, &amp;readfds);

    timeout_ts.tv_sec = timeout_us / 1000000;
    timeout_ts.tv_nsec = (timeout_us % 1000000) * 1000;
    int r = pselect(_fd + 1, &amp;readfds, NULL, NULL, &amp;timeout_ts, NULL);
    if (r &lt;= 0) {
        return false;
    }

    // This shouldn't happen, if r &gt; 0 our fd has to be in the list!
    if (!FD_ISSET(_fd, &amp;readfds)) {
        return false;
    }
    // Data available to read.
    return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(402, 0)" endLine="(422, 1)" clone_start="1" clone_end="9">
			<code function_name="SerialStream::wait_writable (uint32_t timeout_us)">bool SerialStream::wait_writable (uint32_t timeout_us) {
    // Setup a select call to block for serial data or a timeout
    timespec timeout_ts;
    fd_set writefds;
    FD_ZERO(&amp;writefds);
    FD_SET(_fd, &amp;writefds);

    timeout_ts.tv_sec = timeout_us / 1000000;
    timeout_ts.tv_nsec = (timeout_us % 1000000) * 1000;
    int r = pselect(_fd + 1, NULL, &amp;writefds, NULL, &amp;timeout_ts, NULL);
    if (r &lt;= 0) {
        return false;
    }

    // This shouldn't happen, if r &gt; 0 our fd has to be in the list!
    if (!FD_ISSET(_fd, &amp;writefds)) {
        return false;
    }
    // Data available to write.
    return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(257, 0)" endLine="(278, 1)" clone_start="14" clone_end="22">
			<code function_name="LincolnController::EnableAutoMode()">ErrorCode LincolnController::EnableAutoMode() {
  if (driving_mode() == Chassis::COMPLETE_AUTO_DRIVE) {
    AINFO &lt;&lt; "already in COMPLETE_AUTO_DRIVE mode";
    return ErrorCode::OK;
  }
  brake_60_-&gt;set_enable();
  throttle_62_-&gt;set_enable();
  steering_64_-&gt;set_enable();

  can_sender_-&gt;Update();
  const int32_t flag =
      CHECK_RESPONSE_STEER_UNIT_FLAG | CHECK_RESPONSE_SPEED_UNIT_FLAG;
  if (!CheckResponse(flag, true)) {
    AERROR &lt;&lt; "Failed to switch to COMPLETE_AUTO_DRIVE mode.";
    Emergency();
    return ErrorCode::CANBUS_ERROR;
  } else {
    set_driving_mode(Chassis::COMPLETE_AUTO_DRIVE);
    AINFO &lt;&lt; "Switch to COMPLETE_AUTO_DRIVE mode ok.";
    return ErrorCode::OK;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(289, 0)" endLine="(310, 1)" clone_start="14" clone_end="22">
			<code function_name="LincolnController::EnableSteeringOnlyMode()">ErrorCode LincolnController::EnableSteeringOnlyMode() {
  if (driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
      driving_mode() == Chassis::AUTO_STEER_ONLY) {
    set_driving_mode(Chassis::AUTO_STEER_ONLY);
    AINFO &lt;&lt; "Already in AUTO_STEER_ONLY mode";
    return ErrorCode::OK;
  }
  brake_60_-&gt;set_disable();
  throttle_62_-&gt;set_disable();
  steering_64_-&gt;set_enable();

  can_sender_-&gt;Update();
  if (CheckResponse(CHECK_RESPONSE_STEER_UNIT_FLAG, true) == false) {
    AERROR &lt;&lt; "Failed to switch to AUTO_STEER_ONLY mode.";
    Emergency();
    return ErrorCode::CANBUS_ERROR;
  } else {
    set_driving_mode(Chassis::AUTO_STEER_ONLY);
    AINFO &lt;&lt; "Switch to AUTO_STEER_ONLY mode ok.";
    return ErrorCode::OK;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(280, 0)" endLine="(287, 1)" clone_start="1" clone_end="1">
			<code function_name="LincolnController::DisableAutoMode()">ErrorCode LincolnController::DisableAutoMode() {
  ResetProtocol();
  can_sender_-&gt;Update();
  set_driving_mode(Chassis::COMPLETE_MANUAL);
  set_chassis_error_code(Chassis::NO_ERROR);
  AINFO &lt;&lt; "Switch to COMPLETE_MANUAL ok.";
  return ErrorCode::OK;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(312, 0)" endLine="(333, 1)" clone_start="1" clone_end="1">
			<code function_name="LincolnController::EnableSpeedOnlyMode()">ErrorCode LincolnController::EnableSpeedOnlyMode() {
  if (driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
      driving_mode() == Chassis::AUTO_SPEED_ONLY) {
    set_driving_mode(Chassis::AUTO_SPEED_ONLY);
    AINFO &lt;&lt; "Already in AUTO_SPEED_ONLY mode";
    return ErrorCode::OK;
  }
  brake_60_-&gt;set_enable();
  throttle_62_-&gt;set_enable();
  steering_64_-&gt;set_disable();

  can_sender_-&gt;Update();
  if (CheckResponse(CHECK_RESPONSE_SPEED_UNIT_FLAG, true) == false) {
    AERROR &lt;&lt; "Failed to switch to AUTO_STEER_ONLY mode.";
    Emergency();
    return ErrorCode::CANBUS_ERROR;
  } else {
    set_driving_mode(Chassis::AUTO_SPEED_ONLY);
    AINFO &lt;&lt; "Switch to AUTO_SPEED_ONLY mode ok.";
    return ErrorCode::OK;
  }
}</code>
		</source>
	</dup>
	<dup count="5">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gyro_6c.cc" startLine="(35, 0)" endLine="(45, 1)" clone_start="10" clone_end="11">
			<code function_name="Gyro6c::roll_rate(const std::uint8_t* bytes, int32_t length) const">double Gyro6c::roll_rate(const std::uint8_t* bytes, int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.000200;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(49, 0)" endLine="(60, 1)" clone_start="11" clone_end="12">
			<code function_name="Accel6b::longitudinal_acceleration(const std::uint8_t* bytes, int32_t length) const">double Accel6b::longitudinal_acceleration(const std::uint8_t* bytes,
                                          int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(36, 0)" endLine="(47, 1)" clone_start="11" clone_end="12">
			<code function_name="Accel6b::lateral_acceleration(const std::uint8_t* bytes, int32_t length) const">double Accel6b::lateral_acceleration(const std::uint8_t* bytes,
                                     int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(73, 0)" endLine="(85, 1)" clone_start="12" clone_end="13">
			<code function_name="Steering65::steering_angle(const std::uint8_t* bytes, int32_t length) const">double Steering65::steering_angle(const std::uint8_t* bytes,
                                  int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x8000) {
    value = value - 0x10000;
  }

  return value * 0.100000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(162, 0)" endLine="(173, 1)" clone_start="11" clone_end="12">
			<code function_name="Brakeinfo74::wheel_torque_actual(const std::uint8_t* bytes, int32_t length) const">double Brakeinfo74::wheel_torque_actual(const std::uint8_t* bytes,
                                        int32_t length) const {
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 6);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FFF) {
    value -= 0x4000;
  }
  return value * 4.000000;
}</code>
		</source>
	</dup>
	<dup count="5">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gyro_6c.cc" startLine="(47, 0)" endLine="(57, 1)" clone_start="1" clone_end="7">
			<code function_name="Gyro6c::yaw_rate(const std::uint8_t* bytes, int32_t length) const">double Gyro6c::yaw_rate(const std::uint8_t* bytes, int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.000200;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(62, 0)" endLine="(73, 1)" clone_start="1" clone_end="8">
			<code function_name="Accel6b::vertical_acceleration(const std::uint8_t* bytes, int32_t length) const">double Accel6b::vertical_acceleration(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte high_frame(bytes + 5);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 4);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(49, 0)" endLine="(60, 1)" clone_start="1" clone_end="8">
			<code function_name="Accel6b::longitudinal_acceleration(const std::uint8_t* bytes, int32_t length) const">double Accel6b::longitudinal_acceleration(const std::uint8_t* bytes,
                                          int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(87, 0)" endLine="(99, 1)" clone_start="1" clone_end="8">
			<code function_name="Steering65::reported_steering_angle_cmd(const std::uint8_t* bytes, int32_t length) const">double Steering65::reported_steering_angle_cmd(const std::uint8_t* bytes,
                                               int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x8000) {
    value = value - 0x10000;
  }

  return value * 0.100000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(175, 0)" endLine="(187, 1)" clone_start="1" clone_end="9">
			<code function_name="Brakeinfo74::acceleration_over_ground(const std::uint8_t* bytes, int32_t length) const">double Brakeinfo74::acceleration_over_ground(const std::uint8_t* bytes,
                                             int32_t length) const {
  // vehicle acceleration over ground estimate
  Byte frame_high(bytes + 7);
  int32_t high = frame_high.get_byte(0, 2);
  Byte frame_low(bytes + 6);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FF) {
    value -= 0x400;
  }
  return value * 0.035000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\data_parser.cpp" startLine="(262, 0)" endLine="(285, 1)" clone_start="1" clone_end="9">
			<code function_name="DataParser::publish_corrimu_pb_message(const MessagePtr message)">void DataParser::publish_corrimu_pb_message(const MessagePtr message) {
    ::apollo::drivers::gnss::Ins *ins = As&lt;::apollo::drivers::gnss::Ins&gt;(message);
    boost::shared_ptr&lt;::apollo::localization::Imu&gt; imu(new ::apollo::localization::Imu());
    if (!imu) {
        ROS_ERROR("New imu failed.");
        return ;
    }
    double unix_sec = apollo::drivers::util::gps2unix(ins-&gt;measurement_time());
    imu-&gt;mutable_header()-&gt;set_timestamp_sec(unix_sec);
    double pub_sec = ros::Time::now().toSec();
    ROS_DEBUG_STREAM("gps timeline imu delay: " &lt;&lt; pub_sec - unix_sec &lt;&lt; " s.");

    auto *imu_msg = imu-&gt;mutable_imu();
    imu_msg-&gt;mutable_linear_acceleration()-&gt;set_x(-ins-&gt;linear_acceleration().y());
    imu_msg-&gt;mutable_linear_acceleration()-&gt;set_y(ins-&gt;linear_acceleration().x());
    imu_msg-&gt;mutable_linear_acceleration()-&gt;set_z(ins-&gt;linear_acceleration().z());

    imu_msg-&gt;mutable_angular_velocity()-&gt;set_x(-ins-&gt;angular_velocity().y());
    imu_msg-&gt;mutable_angular_velocity()-&gt;set_y(ins-&gt;angular_velocity().x());
    imu_msg-&gt;mutable_angular_velocity()-&gt;set_z(ins-&gt;angular_velocity().z());

    ROS_DEBUG_STREAM("local timeline imu delay: " &lt;&lt; (ros::Time::now().toSec() - ins-&gt;mutable_header()-&gt;timestamp_sec()) &lt;&lt; " s.");
    _imu_publisher.publish(imu);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\data_parser.cpp" startLine="(208, 0)" endLine="(260, 1)" clone_start="1" clone_end="10">
			<code function_name="DataParser::publish_odometry_pb_message(const MessagePtr message)">void DataParser::publish_odometry_pb_message(const MessagePtr message) {
    ::apollo::drivers::gnss::Ins *ins = As&lt;::apollo::drivers::gnss::Ins&gt;(message);
    boost::shared_ptr&lt;::apollo::localization::Gps&gt; gps(new ::apollo::localization::Gps());
    if (!gps) {
        ROS_ERROR("New gps failed.");
        return ;
    }

    double unix_sec = apollo::drivers::util::gps2unix(ins-&gt;measurement_time());
    gps-&gt;mutable_header()-&gt;set_timestamp_sec(unix_sec);
    auto *gps_msg = gps-&gt;mutable_localization();
    double pub_sec = ros::Time::now().toSec();
    ROS_DEBUG_STREAM("gps timeline odometry delay: " &lt;&lt; pub_sec - unix_sec &lt;&lt; " s.");

    // 1. pose xyz, TODO: 
    double x = ins-&gt;position().lon();;
    double y = ins-&gt;position().lat();
    x *= DEG_TO_RAD_LOCAL;
    y *= DEG_TO_RAD_LOCAL;

    int ret = pj_transform(_wgs84pj_source, _utm_target, 1, 1, &amp;x, &amp;y, NULL);
    if (ret != 0) {
        ROS_ERROR_STREAM("prj transform failed, x: " &lt;&lt; x &lt;&lt; ", y: " &lt;&lt; y
                         &lt;&lt; ", ret: " &lt;&lt; ret);
        return;
    }

    gps_msg-&gt;mutable_position()-&gt;set_x(x);
    gps_msg-&gt;mutable_position()-&gt;set_y(y);
    gps_msg-&gt;mutable_position()-&gt;set_z(ins-&gt;position().height());

    // 2. orientation, TODO: check
    Eigen::Quaterniond q =
                Eigen::AngleAxisd(ins-&gt;euler_angles().z() - 90 * DEG_TO_RAD_LOCAL, Eigen::Vector3d::UnitZ())
                * Eigen::AngleAxisd(-ins-&gt;euler_angles().y(), Eigen::Vector3d::UnitX())
                * Eigen::AngleAxisd(ins-&gt;euler_angles().x(), Eigen::Vector3d::UnitY());

    gps_msg-&gt;mutable_orientation()-&gt;set_qx(q.x());
    gps_msg-&gt;mutable_orientation()-&gt;set_qy(q.y());
    gps_msg-&gt;mutable_orientation()-&gt;set_qz(q.z());
    gps_msg-&gt;mutable_orientation()-&gt;set_qw(q.w());

    gps_msg-&gt;mutable_linear_velocity()-&gt;set_x(ins-&gt;linear_velocity().x());
    gps_msg-&gt;mutable_linear_velocity()-&gt;set_y(ins-&gt;linear_velocity().y());
    gps_msg-&gt;mutable_linear_velocity()-&gt;set_z(ins-&gt;linear_velocity().z());

    gps_msg-&gt;mutable_angular_velocity()-&gt;set_x(ins-&gt;angular_velocity().x());
    gps_msg-&gt;mutable_angular_velocity()-&gt;set_y(ins-&gt;angular_velocity().y());
    gps_msg-&gt;mutable_angular_velocity()-&gt;set_z(ins-&gt;angular_velocity().z());

    ROS_DEBUG_STREAM("local timeline odometry delay: " &lt;&lt; (ros::Time::now().toSec() - ins-&gt;mutable_header()-&gt;timestamp_sec()) &lt;&lt; " s.");
    _nav_odometry_publisher.publish(gps);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\can_client\fake\fake_can_client.h" startLine="(59, 2)" endLine="(59, 37)" clone_start="1" clone_end="1">
			<code function_name="~FakeCanClient()">  virtual ~FakeCanClient() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\can_client\esd\esd_can_client.h" startLine="(57, 2)" endLine="(57, 36)" clone_start="1" clone_end="1">
			<code function_name="~EsdCanClient()">  virtual ~EsdCanClient() = default;</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\localization\rtk\rtk_localization.cc" startLine="(37, 0)" endLine="(57, 1)" clone_start="9" clone_end="17">
			<code function_name="RTKLocalization::Start()">Status RTKLocalization::Start() {
  AdapterManager::Init(FLAGS_rtk_adapter_config_file);

  // start ROS timer, one-shot = false, auto-start = true
  const double duration = 1.0 / FLAGS_localization_publish_freq;
  timer_ = AdapterManager::CreateTimer(ros::Duration(duration),
                                       &amp;RTKLocalization::OnTimer, this);
  apollo::common::monitor::MonitorBuffer buffer(&amp;monitor_);
  if (!AdapterManager::GetGps()) {
    buffer.ERROR() &lt;&lt; "GPS input not initialized. Check file "
                   &lt;&lt; FLAGS_rtk_adapter_config_file;
    buffer.PrintLog();
    return Status(apollo::common::LOCALIZATION_ERROR, "no GPS adapter");
  }
  if (!AdapterManager::GetImu()) {
    buffer.ERROR("IMU input not initialized. Check your adapter.conf file!");
    buffer.PrintLog();
    return Status(apollo::common::LOCALIZATION_ERROR, "no IMU adapter");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\localization\camera\camera_localization.cc" startLine="(38, 0)" endLine="(75, 1)" clone_start="23" clone_end="32">
			<code function_name="CameraLocalization::Start()">Status CameraLocalization::Start() {
  MonitorBuffer buffer(&amp;monitor_);
  if (!apollo::common::util::GetProtoFromFile(
          FLAGS_camera_parameter_config_file, &amp;camera_parameter_)) {
    buffer.ERROR() &lt;&lt; "Camera parameter is not initialized. Check "
                   &lt;&lt; FLAGS_camera_parameter_config_file;
    buffer.PrintLog();
    return Status(apollo::common::LOCALIZATION_ERROR,
                  "failed to load camera parameter");
  }

  AdapterManager::Init(FLAGS_camera_adapter_config_file);
  // start ROS timer, one-shot = false, auto-start = true
  const double duration = 1.0 / FLAGS_localization_publish_freq;
  timer_ = AdapterManager::CreateTimer(ros::Duration(duration),
                                       &amp;CameraLocalization::OnTimer, this);
  if (!AdapterManager::GetGps()) {
    buffer.ERROR() &lt;&lt; "GPS input not initialized. Check "
                   &lt;&lt; FLAGS_camera_adapter_config_file;
    buffer.PrintLog();
    return Status(apollo::common::LOCALIZATION_ERROR, "no GPS adapter");
  }
  if (!AdapterManager::GetCamera()) {
    buffer.ERROR() &lt;&lt; "Camera input not initialized. Check "
                   &lt;&lt; FLAGS_camera_adapter_config_file;
    buffer.PrintLog();
    return Status(apollo::common::LOCALIZATION_ERROR, "no Camera adapter");
  }
  // IMU is optional
  if (!AdapterManager::GetImu()) {
    buffer.INFO("IMU input not initialized. Check your adapter.conf file!");
    buffer.PrintLog();
    use_imu_ = false;
  } else {
    use_imu_ = true;
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(147, 0)" endLine="(163, 1)" clone_start="16" clone_end="17">
			<code function_name="UdpStream::connect()">bool UdpStream::connect() {
    if (_sockfd &lt; 0) {
        this-&gt;open();
        if (_sockfd &lt; 0) {
            return false;
        }
    }

    if (_status == Stream::Status::CONNECTED) {
        return true;
    }

    // upper layer support ping method ??
    login();
    _status = Stream::Status::CONNECTED;
    return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(139, 0)" endLine="(231, 1)" clone_start="92" clone_end="93">
			<code function_name="TcpStream::connect()">bool TcpStream::connect() {
    if (_sockfd &lt; 0) {
        this-&gt;open();
        if (_sockfd  &lt; 0) {
            // error
            return false;
        }
    }

    if (_status == Stream::Status::CONNECTED) {
        return true;
    }

    fd_set fds;
    timeval timeo = {10, 0};
    int ret = 0;
    sockaddr_in peer_addr;

    bzero(&amp;peer_addr, sizeof(peer_addr));
    peer_addr.sin_family = AF_INET;
    peer_addr.sin_port = _peer_port;
    peer_addr.sin_addr.s_addr = _peer_addr;

    int fd_flags = fcntl(_sockfd, F_GETFL);
    if (fd_flags &lt; 0 || fcntl(_sockfd, F_SETFL, fd_flags | O_NONBLOCK) &lt; 0) {
        ROS_ERROR_STREAM("Failed to set noblock, error: " &lt;&lt; strerror(errno));
        return false;
    }

    while ((ret = ::connect(_sockfd, reinterpret_cast&lt;sockaddr*&gt;(&amp;peer_addr), sizeof(peer_addr)))
                &lt; 0) {
        if (errno == EINTR) {
            ROS_INFO("Tcp connect return EINTR.");
            continue;
        } else {
            if ((errno != EISCONN) &amp;&amp; (errno != EINPROGRESS) &amp;&amp; (errno != EALREADY)) {
                _status = Stream::Status::ERROR;
                _errno = errno;
                ROS_ERROR_STREAM("Connect failed, error: " &lt;&lt;  strerror(errno));
                return false;
            }

            FD_ZERO(&amp;fds);
            FD_SET(_sockfd, &amp;fds);
            ret = select(_sockfd + 1, NULL, &amp;fds, NULL, &amp;timeo);
            if (ret &lt; 0) {
                _status = Stream::Status::ERROR;
                _errno = errno;
                ROS_ERROR_STREAM("Wait connect failed, error: " &lt;&lt; strerror(errno));
                return false;
            } else if (ret == 0) {
                ROS_INFO("Tcp connect timeout.");
                return false;
            } else if (FD_ISSET(_sockfd, &amp;fds)) {
                int error = 0;
                socklen_t len = sizeof(int);

                if (getsockopt(_sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len) &lt; 0) {
                    _status = Stream::Status::ERROR;
                    _errno = errno;
                    ROS_ERROR_STREAM("Getsockopt failed, error: " &lt;&lt; strerror(errno));
                    return false;
                }
                if (error != 0) {
                    _status = Stream::Status::ERROR;
                    _errno = errno;
                    ROS_ERROR_STREAM("Socket error: " &lt;&lt;  strerror(errno));
                    return false;
                }

                // connect successfully
                break;
            } else {
                _status = Stream::Status::ERROR;
                _errno = errno;
                ROS_ERROR("Should not be here.");
                return false;
            }
        }
    }

    if (!init_socket()) {
        close();
        _status = Stream::Status::ERROR;
        _errno = errno;
        ROS_ERROR("Failed to init socket.");
        return false;
    }
    ROS_INFO("Tcp connect success.");
    _status = Stream::Status::CONNECTED;
    login();
    return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(165, 0)" endLine="(173, 1)" clone_start="1" clone_end="9">
			<code function_name="UdpStream::disconnect()">bool UdpStream::disconnect() {
    if (_sockfd &lt;  0) {
        // not open
        return false;
    }

    this-&gt;close();
    return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(233, 0)" endLine="(241, 1)" clone_start="1" clone_end="9">
			<code function_name="TcpStream::disconnect()">bool TcpStream::disconnect() {
    if (_sockfd &lt;  0) {
        // not open
        return false;
    }

    this-&gt;close();
    return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(175, 0)" endLine="(204, 1)" clone_start="1" clone_end="2">
			<code function_name="UdpStream::read(uint8_t* buffer, size_t max_length)">size_t UdpStream::read(uint8_t* buffer, size_t max_length) {
    ssize_t ret = 0;
    struct sockaddr_in peer_sockaddr;
    socklen_t socklenth = sizeof(peer_sockaddr);
    bzero(&amp;peer_sockaddr, sizeof(peer_sockaddr));
    peer_sockaddr.sin_family = AF_INET;
    peer_sockaddr.sin_port = _peer_port;
    peer_sockaddr.sin_addr.s_addr = _peer_addr;

    while ((ret = ::recvfrom(_sockfd,
                             buffer,
                             max_length,
                             0,
                             (struct sockaddr*)&amp;peer_sockaddr,
                             (socklen_t*)&amp;socklenth)) &lt; 0) {
        if (errno == EINTR) {
            continue;
        } else {
            // error
            if (errno != EAGAIN) {
                _status = Stream::Status::ERROR;
                _errno = errno;
            }
        }

        return 0;
    }

    return ret;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(243, 0)" endLine="(284, 1)" clone_start="1" clone_end="2">
			<code function_name="TcpStream::read(uint8_t* buffer, size_t max_length)">size_t TcpStream::read(uint8_t* buffer, size_t max_length) {
    ssize_t ret = 0;

    if (_status != Stream::Status::CONNECTED) {
        disconnect();
        connect();
        if (_status != Stream::Status::CONNECTED) {
            return 0;
        }
    }

    if (!readable(10000)) {
        return 0;
    }

    while ((ret = ::recv(_sockfd, buffer, max_length, 0)) &lt; 0) {
        if (errno == EINTR) {
            continue;
        } else {
            // error
            if (errno != EAGAIN) {
                _status = Stream::Status::ERROR;
                _errno = errno;
                ROS_ERROR("Read errno %d, error %s.", errno, strerror(errno));
            }
        }

        return 0;
    }

    if (ret == 0) {
        _status = Stream::Status::ERROR;
        _errno = errno;
        ROS_ERROR("Remote closed.");
        disconnect();
        if (connect()) {
            ROS_INFO("Reconnect tcp success.");
        }
    }

    return ret;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\tools\terminal.cc" startLine="(126, 0)" endLine="(166, 1)" clone_start="10" clone_end="21">
			<code function_name="main(int argc, char** argv)">int main(int argc, char** argv) {
  google::InitGoogleLogging(argv[0]);
  FLAGS_alsologtostderr = true;
  FLAGS_v = 3;

  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);

  ros::init(argc, argv, "terminal");

  apollo::common::adapter::AdapterManagerConfig config;
  config.set_is_ros(true);
  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(apollo::common::adapter::AdapterConfig::PUBLISH_ONLY);
    sub_config-&gt;set_type(apollo::common::adapter::AdapterConfig::PAD);
  }

  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(apollo::common::adapter::AdapterConfig::RECEIVE_ONLY);
    sub_config-&gt;set_type(apollo::common::adapter::AdapterConfig::CHASSIS);
  }

  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(apollo::common::adapter::AdapterConfig::RECEIVE_ONLY);
    sub_config-&gt;set_type(apollo::common::adapter::AdapterConfig::LOCALIZATION);
  }

  AdapterManager::Init(config);
  AdapterManager::SetChassisCallback(on_chassis);

  help();
  pthread_t pid;
  if (pthread_create(&amp;pid, NULL, terminal_thread, NULL) != 0) {
    AINFO &lt;&lt; "create terminal thread failed.";
    exit(0);
  }
  ros::spin();
  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\tools\teleop.cc" startLine="(382, 0)" endLine="(421, 1)" clone_start="11" clone_end="23">
			<code function_name="main(int32_t argc, char** argv)">int main(int32_t argc, char** argv) {
  google::InitGoogleLogging(argv[0]);
  FLAGS_alsologtostderr = true;
  FLAGS_v = 3;

  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);

  ros::init(argc, argv, "teleop");
  signal(SIGINT, signal_handler);

  apollo::common::adapter::AdapterManagerConfig config;
  config.set_is_ros(true);
  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(apollo::common::adapter::AdapterConfig::PUBLISH_ONLY);
    sub_config-&gt;set_type(
        apollo::common::adapter::AdapterConfig::CONTROL_COMMAND);
  }

  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(apollo::common::adapter::AdapterConfig::RECEIVE_ONLY);
    sub_config-&gt;set_type(apollo::common::adapter::AdapterConfig::CHASSIS);
  }

  apollo::common::adapter::AdapterManager::Init(config);

  Teleop teleop;

  if (teleop.Start() != 0) {
    AERROR &lt;&lt; "Teleop start failed.";
    return -1;
  }
  Teleop::PrintKeycode();

  ros::spin();
  teleop.Stop();
  AINFO &lt;&lt; "Teleop exit done.";
  return 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\can_comm\can_sender.cc" startLine="(178, 0)" endLine="(191, 1)" clone_start="3" clone_end="13">
			<code function_name="CanSender::Stop()">void CanSender::Stop() {
  if (is_running_) {
    AINFO &lt;&lt; "Stopping can sender ...";
    is_running_ = false;
    if (thread_ != nullptr &amp;&amp; thread_-&gt;joinable()) {
      thread_-&gt;join();
    }
    thread_.reset();
  } else {
    AERROR &lt;&lt; "CanSender is not running.";
  }

  AINFO &lt;&lt; "Can client sender stopped [ok].";
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\can_comm\can_receiver.cc" startLine="(117, 0)" endLine="(129, 1)" clone_start="3" clone_end="12">
			<code function_name="CanReceiver::Stop()">void CanReceiver::Stop() {
  if (IsRunning()) {
    AINFO &lt;&lt; "Stopping can client receiver ...";
    is_running_ = false;
    if (thread_ != nullptr &amp;&amp; thread_-&gt;joinable()) {
      thread_-&gt;join();
    }
    thread_.reset();
  } else {
    AINFO &lt;&lt; "Can client receiver is not running.";
  }
  AINFO &lt;&lt; "Can client receiver stopped [ok].";
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\line_segment2d.cc" startLine="(201, 0)" endLine="(213, 1)" clone_start="1" clone_end="10">
			<code function_name="LineSegment2d::GetPerpendicularFoot(const Vec2d&amp; point, Vec2d* const foot_point) const">double LineSegment2d::GetPerpendicularFoot(const Vec2d&amp; point,
                                           Vec2d* const foot_point) const {
  CHECK_NOTNULL(foot_point);
  if (length_ &lt;= kMathEpsilon) {
    *foot_point = start_;
    return point.DistanceTo(start_);
  }
  const double x0 = point.x() - start_.x();
  const double y0 = point.y() - start_.y();
  const double proj = x0 * unit_direction_.x() + y0 * unit_direction_.y();
  *foot_point = start_ + unit_direction_ * proj;
  return std::abs(x0 * unit_direction_.y() - y0 * unit_direction_.x());
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\line_segment2d.cc" startLine="(112, 0)" endLine="(132, 1)" clone_start="1" clone_end="10">
			<code function_name="LineSegment2d::DistanceSquareTo(const Vec2d&amp; point, Vec2d* const nearest_pt) const">double LineSegment2d::DistanceSquareTo(const Vec2d&amp; point,
                                       Vec2d* const nearest_pt) const {
  CHECK_NOTNULL(nearest_pt);
  if (length_ &lt;= kMathEpsilon) {
    *nearest_pt = start_;
    return point.DistanceSquareTo(start_);
  }
  const double x0 = point.x() - start_.x();
  const double y0 = point.y() - start_.y();
  const double proj = x0 * unit_direction_.x() + y0 * unit_direction_.y();
  if (proj &lt;= 0.0) {
    *nearest_pt = start_;
    return Square(x0) + Square(y0);
  }
  if (proj &gt;= length_) {
    *nearest_pt = end_;
    return point.DistanceSquareTo(end_);
  }
  *nearest_pt = start_ + unit_direction_ * proj;
  return Square(x0 * unit_direction_.y() - y0 * unit_direction_.x());
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\line_segment2d.cc" startLine="(74, 0)" endLine="(94, 1)" clone_start="1" clone_end="10">
			<code function_name="LineSegment2d::DistanceTo(const Vec2d&amp; point, Vec2d* const nearest_pt) const">double LineSegment2d::DistanceTo(const Vec2d&amp; point,
                                 Vec2d* const nearest_pt) const {
  CHECK_NOTNULL(nearest_pt);
  if (length_ &lt;= kMathEpsilon) {
    *nearest_pt = start_;
    return point.DistanceTo(start_);
  }
  const double x0 = point.x() - start_.x();
  const double y0 = point.y() - start_.y();
  const double proj = x0 * unit_direction_.x() + y0 * unit_direction_.y();
  if (proj &lt; 0.0) {
    *nearest_pt = start_;
    return hypot(x0, y0);
  }
  if (proj &gt; length_) {
    *nearest_pt = end_;
    return point.DistanceTo(end_);
  }
  *nearest_pt = start_ + unit_direction_ * proj;
  return std::abs(x0 * unit_direction_.y() - y0 * unit_direction_.x());
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(487, 0)" endLine="(586, 1)" clone_start="48" clone_end="55">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR &lt;&lt; "Steering fault detected: "
           &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR &lt;&lt; "Brake fault detected: "
           &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR &lt;&lt; "Throttle fault detected: "
           &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR &lt;&lt; "Gear fault detected: " &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(487, 0)" endLine="(586, 1)" clone_start="16" clone_end="23">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR &lt;&lt; "Steering fault detected: "
           &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR &lt;&lt; "Brake fault detected: "
           &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR &lt;&lt; "Throttle fault detected: "
           &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR &lt;&lt; "Gear fault detected: " &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(487, 0)" endLine="(586, 1)" clone_start="14" clone_end="21">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR &lt;&lt; "Steering fault detected: "
           &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR &lt;&lt; "Brake fault detected: "
           &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR &lt;&lt; "Throttle fault detected: "
           &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR &lt;&lt; "Gear fault detected: " &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\stream_nodelet.cpp" startLine="(49, 0)" endLine="(73, 1)" clone_start="3" clone_end="12">
			<code function_name="StreamNodelet::onInit()">void StreamNodelet::onInit() {
    ros::NodeHandle&amp; nh = getPrivateNodeHandle();
    std::string gnss_conf;
    std::string raw_data_topic;
    std::string rtcm_data_topic;
    std::string stream_status_topic;


    nh.param("gnss_conf", gnss_conf, std::string("./conf/gnss_conf.txt"));
    nh.param("raw_data_topic", raw_data_topic, std::string("/apollo/sensor/gnss/raw_data"));
    nh.param("rtcm_data_topic", rtcm_data_topic, std::string("/apollo/sensor/gnss/rtcm_data"));
    nh.param("stream_status_topic", stream_status_topic, std::string("/apollo/sensor/gnss/stream_status"));

    ROS_INFO_STREAM("gnss conf: " &lt;&lt; gnss_conf);
    ROS_INFO_STREAM("raw data topic: " &lt;&lt; raw_data_topic);

    init_signal();
    _raw_stream.reset(new RawStream(nh, getName(), raw_data_topic, rtcm_data_topic, stream_status_topic));
    if (!_raw_stream-&gt;init(gnss_conf)) {
        ROS_ERROR("Init stream nodelet failed.");
        ROS_ERROR_STREAM("Init stream nodelet failed.");
        return;
    }
    ROS_INFO("Init stream nodelet success.");
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\parser_nodelet.cpp" startLine="(39, 0)" endLine="(71, 1)" clone_start="6" clone_end="14">
			<code function_name="ParserNodelet::onInit()">void ParserNodelet::onInit() {
    ros::NodeHandle&amp; nh = getPrivateNodeHandle();
    std::string gnss_conf;
    std::string raw_data_topic;
    std::string gpgga_topic;
    std::string corr_imu_topic;
    std::string odometry_topic;
    std::string gnss_status_topic;
    std::string ins_status_topic;

    nh.param("gnss_conf", gnss_conf, std::string("./conf/gnss_conf.txt"));
    nh.param("raw_data_topic", raw_data_topic, std::string("/apollo/sensor/gnss/raw_data"));
    nh.param("gpgga_topic", gpgga_topic, std::string("/apollo/sensor/gnss/gpgga"));
    nh.param("corr_imu_topic", corr_imu_topic, std::string("/apollo/sensor/gnss/corrected_imu"));
    nh.param("odometry_topic", odometry_topic, std::string("/apollo/sensor/gnss/odometry"));
    nh.param("gnss_status_topic", gnss_status_topic, std::string("/apollo/sensor/gnss/gnss_status"));
    nh.param("ins_status_topic", ins_status_topic, std::string("/apollo/sensor/gnss/ins_status"));

    _data_parser.reset(new DataParser(
                                nh,
                                raw_data_topic,
                                gpgga_topic,
                                corr_imu_topic,
                                odometry_topic,
                                gnss_status_topic,
                                ins_status_topic));
    if (!_data_parser-&gt;init(gnss_conf)) {
        ROS_ERROR("Init parser nodelet failed.");
        ROS_ERROR_STREAM("Init parser nodelet failed.");
        return;
    }
    ROS_INFO("Init parser nodelet success.");
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\tests\test_monitor.cpp" startLine="(38, 0)" endLine="(65, 1)" clone_start="1" clone_end="8">
			<code function_name="stream_status_callback(const apollo::common::gnss_status::StreamStatus &amp;stream_status)">void stream_status_callback(const apollo::common::gnss_status::StreamStatus &amp;stream_status) {
    switch (stream_status.ins_stream_type()) {
    case apollo::common::gnss_status::StreamStatus::CONNECTED:
        fprintf(stdout, "INS stream is CONNECTED.\r\n");
        break;
    case apollo::common::gnss_status::StreamStatus::DISCONNECTED:
        fprintf(stdout, "INS stream is DISCONNECTED.\r\n");
        break;
    }

    switch (stream_status.rtk_stream_in_type()) {
    case apollo::common::gnss_status::StreamStatus::CONNECTED:
        fprintf(stdout, "rtk stream in is CONNECTED.\r\n");
        break;
    case apollo::common::gnss_status::StreamStatus::DISCONNECTED:
        fprintf(stdout, "rtk stream in is DISCONNECTED.\r\n");
        break;
    }

    switch (stream_status.rtk_stream_out_type()) {
    case apollo::common::gnss_status::StreamStatus::CONNECTED:
        fprintf(stdout, "rtk stream out CONNECTED.\r\n");
        break;
    case apollo::common::gnss_status::StreamStatus::DISCONNECTED:
        fprintf(stdout, "rtk stream out DISCONNECTED.\r\n");
        break;
    }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\tests\test_monitor.cpp" startLine="(23, 0)" endLine="(36, 1)" clone_start="1" clone_end="8">
			<code function_name="ins_status_callback(const apollo::common::gnss_status::InsStatus &amp;ins_status)">void ins_status_callback(const apollo::common::gnss_status::InsStatus &amp;ins_status) {
    switch (ins_status.type()) {
    case apollo::common::gnss_status::InsStatus::GOOD:
        fprintf(stdout, "INS status is GOOD.\r\n");
        break;
    case apollo::common::gnss_status::InsStatus::CONVERGING:
        fprintf(stdout, "INS status is CONVERGING.\r\n");
        break;
    case apollo::common::gnss_status::InsStatus::INVALID:
    default:    
        fprintf(stdout, "INS status is INVALID.\r\n");
        break;
    }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(141, 0)" endLine="(249, 1)" clone_start="36" clone_end="45">
			<code function_name="LincolnController::chassis()">Chassis LincolnController::chassis() {
  chassis_.Clear();

  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  // 21, 22, previously 1, 2
  if (driving_mode() == Chassis::EMERGENCY_MODE) {
    set_chassis_error_code(Chassis::NO_ERROR);
  }

  chassis_.set_driving_mode(driving_mode());
  chassis_.set_error_code(chassis_error_code());

  // 3
  chassis_.set_engine_started(true);
  // 4
  if (chassis_detail.ems().has_engine_rpm()) {
    chassis_.set_engine_rpm(chassis_detail.ems().engine_rpm());
  } else {
    chassis_.set_engine_rpm(0);
  }
  // 5
  if (chassis_detail.vehicle_spd().has_vehicle_spd()) {
    chassis_.set_speed_mps(chassis_detail.vehicle_spd().vehicle_spd());
  } else {
    chassis_.set_speed_mps(0);
  }
  // 6
  chassis_.set_odometer_m(0);
  // 7
  // lincoln only has fuel percentage
  // to avoid confusing, just don't set
  chassis_.set_fuel_range_m(0);
  // 8
  if (chassis_detail.gas().has_throttle_output()) {
    chassis_.set_throttle_percentage(chassis_detail.gas().throttle_output());
  } else {
    chassis_.set_throttle_percentage(0);
  }
  // 9
  if (chassis_detail.brake().has_brake_output()) {
    chassis_.set_brake_percentage(chassis_detail.brake().brake_output());
  } else {
    chassis_.set_brake_percentage(0);
  }
  // 23, previously 10
  if (chassis_detail.gear().has_gear_state()) {
    chassis_.set_gear_location(chassis_detail.gear().gear_state());
  } else {
    chassis_.set_gear_location(Chassis::GEAR_NONE);
  }
  // 11
  if (chassis_detail.eps().has_steering_angle()) {
    chassis_.set_steering_percentage(chassis_detail.eps().steering_angle() *
                                     100.0 / params_.max_steer_angle());
  } else {
    chassis_.set_steering_percentage(0);
  }
  // 12
  if (chassis_detail.eps().has_epas_torque()) {
    chassis_.set_steering_torque_nm(chassis_detail.eps().epas_torque());
  } else {
    chassis_.set_steering_torque_nm(0);
  }
  // 13
  if (chassis_detail.epb().has_parking_brake_status()) {
    chassis_.set_parking_brake(chassis_detail.epb().parking_brake_status() ==
                               Epb::PBRAKE_ON);
  } else {
    chassis_.set_parking_brake(false);
  }
  // TODO: lincoln beam
  // 14, 15

  // 16, 17
  if (chassis_detail.light().has_turn_light_type() &amp;&amp;
      chassis_detail.light().turn_light_type() != Light::TURN_LIGHT_OFF) {
    if (chassis_detail.light().turn_light_type() == Light::TURN_LEFT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_LEFT);
    } else if (chassis_detail.light().turn_light_type() ==
               Light::TURN_RIGHT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_RIGHT);
    } else {
      chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_NONE);
    }
  } else {
    chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_NONE);
  }
  // 18
  if (chassis_detail.light().has_is_horn_on() &amp;&amp;
      chassis_detail.light().is_horn_on()) {
    chassis_.mutable_signal()-&gt;set_horn(true);
  } else {
    chassis_.mutable_signal()-&gt;set_horn(false);
  }

  // 19, lincoln wiper is too complicated
  // 24
  if (chassis_detail.eps().has_timestamp_65()) {
    chassis_.set_steering_timestamp(chassis_detail.eps().timestamp_65());
  }
  // 26
  if (chassis_error_mask_) {
    chassis_.set_chassis_error_mask(chassis_error_mask_);
  }

  return chassis_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(141, 0)" endLine="(249, 1)" clone_start="18" clone_end="27">
			<code function_name="LincolnController::chassis()">Chassis LincolnController::chassis() {
  chassis_.Clear();

  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  // 21, 22, previously 1, 2
  if (driving_mode() == Chassis::EMERGENCY_MODE) {
    set_chassis_error_code(Chassis::NO_ERROR);
  }

  chassis_.set_driving_mode(driving_mode());
  chassis_.set_error_code(chassis_error_code());

  // 3
  chassis_.set_engine_started(true);
  // 4
  if (chassis_detail.ems().has_engine_rpm()) {
    chassis_.set_engine_rpm(chassis_detail.ems().engine_rpm());
  } else {
    chassis_.set_engine_rpm(0);
  }
  // 5
  if (chassis_detail.vehicle_spd().has_vehicle_spd()) {
    chassis_.set_speed_mps(chassis_detail.vehicle_spd().vehicle_spd());
  } else {
    chassis_.set_speed_mps(0);
  }
  // 6
  chassis_.set_odometer_m(0);
  // 7
  // lincoln only has fuel percentage
  // to avoid confusing, just don't set
  chassis_.set_fuel_range_m(0);
  // 8
  if (chassis_detail.gas().has_throttle_output()) {
    chassis_.set_throttle_percentage(chassis_detail.gas().throttle_output());
  } else {
    chassis_.set_throttle_percentage(0);
  }
  // 9
  if (chassis_detail.brake().has_brake_output()) {
    chassis_.set_brake_percentage(chassis_detail.brake().brake_output());
  } else {
    chassis_.set_brake_percentage(0);
  }
  // 23, previously 10
  if (chassis_detail.gear().has_gear_state()) {
    chassis_.set_gear_location(chassis_detail.gear().gear_state());
  } else {
    chassis_.set_gear_location(Chassis::GEAR_NONE);
  }
  // 11
  if (chassis_detail.eps().has_steering_angle()) {
    chassis_.set_steering_percentage(chassis_detail.eps().steering_angle() *
                                     100.0 / params_.max_steer_angle());
  } else {
    chassis_.set_steering_percentage(0);
  }
  // 12
  if (chassis_detail.eps().has_epas_torque()) {
    chassis_.set_steering_torque_nm(chassis_detail.eps().epas_torque());
  } else {
    chassis_.set_steering_torque_nm(0);
  }
  // 13
  if (chassis_detail.epb().has_parking_brake_status()) {
    chassis_.set_parking_brake(chassis_detail.epb().parking_brake_status() ==
                               Epb::PBRAKE_ON);
  } else {
    chassis_.set_parking_brake(false);
  }
  // TODO: lincoln beam
  // 14, 15

  // 16, 17
  if (chassis_detail.light().has_turn_light_type() &amp;&amp;
      chassis_detail.light().turn_light_type() != Light::TURN_LIGHT_OFF) {
    if (chassis_detail.light().turn_light_type() == Light::TURN_LEFT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_LEFT);
    } else if (chassis_detail.light().turn_light_type() ==
               Light::TURN_RIGHT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_RIGHT);
    } else {
      chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_NONE);
    }
  } else {
    chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_NONE);
  }
  // 18
  if (chassis_detail.light().has_is_horn_on() &amp;&amp;
      chassis_detail.light().is_horn_on()) {
    chassis_.mutable_signal()-&gt;set_horn(true);
  } else {
    chassis_.mutable_signal()-&gt;set_horn(false);
  }

  // 19, lincoln wiper is too complicated
  // 24
  if (chassis_detail.eps().has_timestamp_65()) {
    chassis_.set_steering_timestamp(chassis_detail.eps().timestamp_65());
  }
  // 26
  if (chassis_error_mask_) {
    chassis_.set_chassis_error_mask(chassis_error_mask_);
  }

  return chassis_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(141, 0)" endLine="(249, 1)" clone_start="39" clone_end="50">
			<code function_name="LincolnController::chassis()">Chassis LincolnController::chassis() {
  chassis_.Clear();

  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  // 21, 22, previously 1, 2
  if (driving_mode() == Chassis::EMERGENCY_MODE) {
    set_chassis_error_code(Chassis::NO_ERROR);
  }

  chassis_.set_driving_mode(driving_mode());
  chassis_.set_error_code(chassis_error_code());

  // 3
  chassis_.set_engine_started(true);
  // 4
  if (chassis_detail.ems().has_engine_rpm()) {
    chassis_.set_engine_rpm(chassis_detail.ems().engine_rpm());
  } else {
    chassis_.set_engine_rpm(0);
  }
  // 5
  if (chassis_detail.vehicle_spd().has_vehicle_spd()) {
    chassis_.set_speed_mps(chassis_detail.vehicle_spd().vehicle_spd());
  } else {
    chassis_.set_speed_mps(0);
  }
  // 6
  chassis_.set_odometer_m(0);
  // 7
  // lincoln only has fuel percentage
  // to avoid confusing, just don't set
  chassis_.set_fuel_range_m(0);
  // 8
  if (chassis_detail.gas().has_throttle_output()) {
    chassis_.set_throttle_percentage(chassis_detail.gas().throttle_output());
  } else {
    chassis_.set_throttle_percentage(0);
  }
  // 9
  if (chassis_detail.brake().has_brake_output()) {
    chassis_.set_brake_percentage(chassis_detail.brake().brake_output());
  } else {
    chassis_.set_brake_percentage(0);
  }
  // 23, previously 10
  if (chassis_detail.gear().has_gear_state()) {
    chassis_.set_gear_location(chassis_detail.gear().gear_state());
  } else {
    chassis_.set_gear_location(Chassis::GEAR_NONE);
  }
  // 11
  if (chassis_detail.eps().has_steering_angle()) {
    chassis_.set_steering_percentage(chassis_detail.eps().steering_angle() *
                                     100.0 / params_.max_steer_angle());
  } else {
    chassis_.set_steering_percentage(0);
  }
  // 12
  if (chassis_detail.eps().has_epas_torque()) {
    chassis_.set_steering_torque_nm(chassis_detail.eps().epas_torque());
  } else {
    chassis_.set_steering_torque_nm(0);
  }
  // 13
  if (chassis_detail.epb().has_parking_brake_status()) {
    chassis_.set_parking_brake(chassis_detail.epb().parking_brake_status() ==
                               Epb::PBRAKE_ON);
  } else {
    chassis_.set_parking_brake(false);
  }
  // TODO: lincoln beam
  // 14, 15

  // 16, 17
  if (chassis_detail.light().has_turn_light_type() &amp;&amp;
      chassis_detail.light().turn_light_type() != Light::TURN_LIGHT_OFF) {
    if (chassis_detail.light().turn_light_type() == Light::TURN_LEFT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_LEFT);
    } else if (chassis_detail.light().turn_light_type() ==
               Light::TURN_RIGHT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_RIGHT);
    } else {
      chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_NONE);
    }
  } else {
    chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_NONE);
  }
  // 18
  if (chassis_detail.light().has_is_horn_on() &amp;&amp;
      chassis_detail.light().is_horn_on()) {
    chassis_.mutable_signal()-&gt;set_horn(true);
  } else {
    chassis_.mutable_signal()-&gt;set_horn(false);
  }

  // 19, lincoln wiper is too complicated
  // 24
  if (chassis_detail.eps().has_timestamp_65()) {
    chassis_.set_steering_timestamp(chassis_detail.eps().timestamp_65());
  }
  // 26
  if (chassis_error_mask_) {
    chassis_.set_chassis_error_mask(chassis_error_mask_);
  }

  return chassis_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(141, 0)" endLine="(249, 1)" clone_start="34" clone_end="44">
			<code function_name="LincolnController::chassis()">Chassis LincolnController::chassis() {
  chassis_.Clear();

  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  // 21, 22, previously 1, 2
  if (driving_mode() == Chassis::EMERGENCY_MODE) {
    set_chassis_error_code(Chassis::NO_ERROR);
  }

  chassis_.set_driving_mode(driving_mode());
  chassis_.set_error_code(chassis_error_code());

  // 3
  chassis_.set_engine_started(true);
  // 4
  if (chassis_detail.ems().has_engine_rpm()) {
    chassis_.set_engine_rpm(chassis_detail.ems().engine_rpm());
  } else {
    chassis_.set_engine_rpm(0);
  }
  // 5
  if (chassis_detail.vehicle_spd().has_vehicle_spd()) {
    chassis_.set_speed_mps(chassis_detail.vehicle_spd().vehicle_spd());
  } else {
    chassis_.set_speed_mps(0);
  }
  // 6
  chassis_.set_odometer_m(0);
  // 7
  // lincoln only has fuel percentage
  // to avoid confusing, just don't set
  chassis_.set_fuel_range_m(0);
  // 8
  if (chassis_detail.gas().has_throttle_output()) {
    chassis_.set_throttle_percentage(chassis_detail.gas().throttle_output());
  } else {
    chassis_.set_throttle_percentage(0);
  }
  // 9
  if (chassis_detail.brake().has_brake_output()) {
    chassis_.set_brake_percentage(chassis_detail.brake().brake_output());
  } else {
    chassis_.set_brake_percentage(0);
  }
  // 23, previously 10
  if (chassis_detail.gear().has_gear_state()) {
    chassis_.set_gear_location(chassis_detail.gear().gear_state());
  } else {
    chassis_.set_gear_location(Chassis::GEAR_NONE);
  }
  // 11
  if (chassis_detail.eps().has_steering_angle()) {
    chassis_.set_steering_percentage(chassis_detail.eps().steering_angle() *
                                     100.0 / params_.max_steer_angle());
  } else {
    chassis_.set_steering_percentage(0);
  }
  // 12
  if (chassis_detail.eps().has_epas_torque()) {
    chassis_.set_steering_torque_nm(chassis_detail.eps().epas_torque());
  } else {
    chassis_.set_steering_torque_nm(0);
  }
  // 13
  if (chassis_detail.epb().has_parking_brake_status()) {
    chassis_.set_parking_brake(chassis_detail.epb().parking_brake_status() ==
                               Epb::PBRAKE_ON);
  } else {
    chassis_.set_parking_brake(false);
  }
  // TODO: lincoln beam
  // 14, 15

  // 16, 17
  if (chassis_detail.light().has_turn_light_type() &amp;&amp;
      chassis_detail.light().turn_light_type() != Light::TURN_LIGHT_OFF) {
    if (chassis_detail.light().turn_light_type() == Light::TURN_LEFT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_LEFT);
    } else if (chassis_detail.light().turn_light_type() ==
               Light::TURN_RIGHT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_RIGHT);
    } else {
      chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_NONE);
    }
  } else {
    chassis_.mutable_signal()-&gt;set_turn_signal(Signal::TURN_NONE);
  }
  // 18
  if (chassis_detail.light().has_is_horn_on() &amp;&amp;
      chassis_detail.light().is_horn_on()) {
    chassis_.mutable_signal()-&gt;set_horn(true);
  } else {
    chassis_.mutable_signal()-&gt;set_horn(false);
  }

  // 19, lincoln wiper is too complicated
  // 24
  if (chassis_detail.eps().has_timestamp_65()) {
    chassis_.set_steering_timestamp(chassis_detail.eps().timestamp_65());
  }
  // 26
  if (chassis_error_mask_) {
    chassis_.set_chassis_error_mask(chassis_error_mask_);
  }

  return chassis_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\tests\unit_test_stream.cpp" startLine="(168, 0)" endLine="(242, 1)" clone_start="60" clone_end="72">
			<code function_name="tcp_server()">static void tcp_server() {
    struct sockaddr_in addr;
    struct sockaddr_in addr_client;
    socklen_t  addrlen;
    int reuseaddr = 1;
    int fd = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (fd &lt; 0) {
        std::cout &lt;&lt; "create tcp socker failed." &lt;&lt; std::endl;
        return ;
    }

    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &amp;reuseaddr, sizeof(reuseaddr)) &lt; 0) {
        std::cout &lt;&lt; "Set listen socket reuse addr failed: " &lt;&lt;  strerror(errno) &lt;&lt; std::endl;
        return ;
    }

    bzero(&amp;addr, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(TCP_PORT);
    if (::bind(fd, (struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0) {
        std::cout &lt;&lt; "bind tcp socker failed." &lt;&lt; std::endl;
        ::close(fd);
        return;
    }

    if (::listen(fd, 1024) &lt; 0) {
        std::cout &lt;&lt; "listen tcp socker failed." &lt;&lt; std::endl;
        return ;
    }
    s_server_ready = 1;

    int connectfd = -1;
    while (connectfd &lt; 0) {
        connectfd = accept(fd, (struct sockaddr*)&amp;addr_client, &amp;addrlen);
    }

    uint8_t buffer[1024];
    ssize_t len = -1;
    int cnt = 0;
    while (cnt &lt; COMM_TIMES) {
        len = ::recv(connectfd, buffer, 1024, 0);
        if (len &gt; 0) {
            len = ::send(connectfd, buffer, len, 0);
            if (len &lt;= 0) {
                std::cout &lt;&lt; "tcp server send data failed, seq " &lt;&lt; cnt &lt;&lt; "." &lt;&lt; std::endl;
            }
            ++cnt;
        }
    }
    ::close(connectfd);
    connectfd = -1;

    // phrase 2, reconnect
    while (connectfd &lt; 0) {
        connectfd = accept(fd, (struct sockaddr*)&amp;addr_client, &amp;addrlen);
    }

    cnt = 0;
    while (cnt &lt; COMM_TIMES) {
        len = ::recv(connectfd, buffer, 1024, 0);
        if (len &gt; 0) {
            len = ::send(connectfd, buffer, len, 0);
            if (len &lt;= 0) {
                std::cout &lt;&lt; "tcp server send data failed, seq " &lt;&lt; cnt &lt;&lt; "." &lt;&lt; std::endl;
            }
            ++cnt;
        }
    }

    // close
    ::close(connectfd);
    ::close(fd);
    return ;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\tests\unit_test_stream.cpp" startLine="(168, 0)" endLine="(242, 1)" clone_start="41" clone_end="51">
			<code function_name="tcp_server()">static void tcp_server() {
    struct sockaddr_in addr;
    struct sockaddr_in addr_client;
    socklen_t  addrlen;
    int reuseaddr = 1;
    int fd = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (fd &lt; 0) {
        std::cout &lt;&lt; "create tcp socker failed." &lt;&lt; std::endl;
        return ;
    }

    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &amp;reuseaddr, sizeof(reuseaddr)) &lt; 0) {
        std::cout &lt;&lt; "Set listen socket reuse addr failed: " &lt;&lt;  strerror(errno) &lt;&lt; std::endl;
        return ;
    }

    bzero(&amp;addr, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(TCP_PORT);
    if (::bind(fd, (struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0) {
        std::cout &lt;&lt; "bind tcp socker failed." &lt;&lt; std::endl;
        ::close(fd);
        return;
    }

    if (::listen(fd, 1024) &lt; 0) {
        std::cout &lt;&lt; "listen tcp socker failed." &lt;&lt; std::endl;
        return ;
    }
    s_server_ready = 1;

    int connectfd = -1;
    while (connectfd &lt; 0) {
        connectfd = accept(fd, (struct sockaddr*)&amp;addr_client, &amp;addrlen);
    }

    uint8_t buffer[1024];
    ssize_t len = -1;
    int cnt = 0;
    while (cnt &lt; COMM_TIMES) {
        len = ::recv(connectfd, buffer, 1024, 0);
        if (len &gt; 0) {
            len = ::send(connectfd, buffer, len, 0);
            if (len &lt;= 0) {
                std::cout &lt;&lt; "tcp server send data failed, seq " &lt;&lt; cnt &lt;&lt; "." &lt;&lt; std::endl;
            }
            ++cnt;
        }
    }
    ::close(connectfd);
    connectfd = -1;

    // phrase 2, reconnect
    while (connectfd &lt; 0) {
        connectfd = accept(fd, (struct sockaddr*)&amp;addr_client, &amp;addrlen);
    }

    cnt = 0;
    while (cnt &lt; COMM_TIMES) {
        len = ::recv(connectfd, buffer, 1024, 0);
        if (len &gt; 0) {
            len = ::send(connectfd, buffer, len, 0);
            if (len &lt;= 0) {
                std::cout &lt;&lt; "tcp server send data failed, seq " &lt;&lt; cnt &lt;&lt; "." &lt;&lt; std::endl;
            }
            ++cnt;
        }
    }

    // close
    ::close(connectfd);
    ::close(fd);
    return ;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="76" clone_end="84">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length,
                        ChassisDetail* chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\tirepressure_71.cc" startLine="(26, 0)" endLine="(36, 1)" clone_start="3" clone_end="11">
			<code function_name="Tirepressure71::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Tirepressure71::Parse(const std::uint8_t* bytes, int32_t length,
                           ChassisDetail* car_status) const {
  car_status-&gt;mutable_safety()-&gt;set_front_left_tire_press(
      front_left_tire(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_front_right_tire_press(
      front_right_tire(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_rear_left_tire_press(
      rear_left_tire(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_rear_right_tire_press(
      rear_right_tire(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(111, 0)" endLine="(119, 1)" clone_start="1" clone_end="6">
			<code function_name="Brakeinfo74::braking_torque_request(const std::uint8_t* bytes, int32_t length) const">double Brakeinfo74::braking_torque_request(const std::uint8_t* bytes,
                                           int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 4);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 4.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\tirepressure_71.cc" startLine="(38, 0)" endLine="(45, 1)" clone_start="1" clone_end="6">
			<code function_name="Tirepressure71::front_left_tire(const std::uint8_t* bytes, int32_t length) const">int32_t Tirepressure71::front_left_tire(const std::uint8_t* bytes,
                                        int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  return (high &lt;&lt; 8) | low;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\controller\lat_controller.cc" startLine="(226, 0)" endLine="(306, 1)" clone_start="49" clone_end="59">
			<code function_name="LatController::ComputeControlCommand(const localization::LocalizationEstimate* localization, const canbus::Chassis* chassis, const planning::ADCTrajectory* planning_published_trajectory, ControlCommand* cmd)">Status LatController::ComputeControlCommand(
    const localization::LocalizationEstimate* localization,
    const canbus::Chassis* chassis,
    const planning::ADCTrajectory* planning_published_trajectory,
    ControlCommand* cmd) {
  vehicle_state_ = std::move(VehicleState(localization, chassis));
  vehicle_state_.set_linear_velocity(
      std::max(vehicle_state_.linear_velocity(), 1.0));

  trajectory_analyzer_ =
      std::move(TrajectoryAnalyzer(planning_published_trajectory));

  SimpleLateralDebug* debug = cmd-&gt;mutable_debug()-&gt;mutable_simple_lat_debug();
  debug-&gt;Clear();

  // Update state = [Lateral Error, Lateral Error Rate, Heading Error, Heading
  // Error Rate, preview lateral error1 , preview lateral error2, ...]
  if (FLAGS_use_state_exact_match) {
    UpdateStateAnalyticalMatching(debug);
  } else {
    UpdateState(debug);
  }

  UpdateMatrix();

  // Compound discrete matrix with road preview model
  UpdateMatrixCompound();

  common::math::SolveLQRProblem(matrix_adc_, matrix_bdc_, matrix_q_, matrix_r_,
                                lqr_eps_, lqr_max_iteration_, &amp;matrix_k_);

  // feedback = - K * state
  // Convert vehicle steer angle from rad to degree and then to steer degree
  // then to 100% ratio
  double steer_angle_feedback = -(matrix_k_ * matrix_state_)(0, 0) * 180 /
                                M_PI * steer_transmission_ratio_ /
                                steer_single_direction_max_degree_ * 100;

  double steer_angle_feedforward = ComputeFeedForward(debug-&gt;curvature());
  double steer_angle = steer_angle_feedback + steer_angle_feedforward;
  // Clamp the steer angle to -100.0 to 100.0
  steer_angle = apollo::common::math::Clamp(steer_angle, -100.0, 100.0);

  steer_angle = digital_filter_.Filter(steer_angle);
  cmd-&gt;set_steering_target(steer_angle);
  cmd-&gt;set_steering_rate(FLAGS_steer_angle_rate);

  // compute extra information for logging and debugging
  double steer_angle_lateral_contribution =
      -matrix_k_(0, 0) * matrix_state_(0, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_lateral_rate_contribution =
      -matrix_k_(0, 1) * matrix_state_(1, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_heading_contribution =
      -matrix_k_(0, 2) * matrix_state_(2, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_heading_rate_contribution =
      -matrix_k_(0, 3) * matrix_state_(3, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  // TODO(yifei): move up temporary values to use debug fields.

  debug-&gt;set_heading(vehicle_state_.heading());
  debug-&gt;set_steer_angle(steer_angle);
  debug-&gt;set_steer_angle_feedforward(steer_angle_feedforward);
  debug-&gt;set_steer_angle_lateral_contribution(steer_angle_lateral_contribution);
  debug-&gt;set_steer_angle_lateral_rate_contribution(
      steer_angle_lateral_rate_contribution);
  debug-&gt;set_steer_angle_heading_contribution(steer_angle_heading_contribution);
  debug-&gt;set_steer_angle_heading_rate_contribution(
      steer_angle_heading_rate_contribution);
  debug-&gt;set_steer_angle_feedback(steer_angle_feedback);
  debug-&gt;set_steering_position(chassis-&gt;steering_percentage());
  debug-&gt;set_ref_speed(vehicle_state_.linear_velocity());
  ProcessLogs(debug, chassis);
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\controller\lat_controller.cc" startLine="(226, 0)" endLine="(306, 1)" clone_start="53" clone_end="63">
			<code function_name="LatController::ComputeControlCommand(const localization::LocalizationEstimate* localization, const canbus::Chassis* chassis, const planning::ADCTrajectory* planning_published_trajectory, ControlCommand* cmd)">Status LatController::ComputeControlCommand(
    const localization::LocalizationEstimate* localization,
    const canbus::Chassis* chassis,
    const planning::ADCTrajectory* planning_published_trajectory,
    ControlCommand* cmd) {
  vehicle_state_ = std::move(VehicleState(localization, chassis));
  vehicle_state_.set_linear_velocity(
      std::max(vehicle_state_.linear_velocity(), 1.0));

  trajectory_analyzer_ =
      std::move(TrajectoryAnalyzer(planning_published_trajectory));

  SimpleLateralDebug* debug = cmd-&gt;mutable_debug()-&gt;mutable_simple_lat_debug();
  debug-&gt;Clear();

  // Update state = [Lateral Error, Lateral Error Rate, Heading Error, Heading
  // Error Rate, preview lateral error1 , preview lateral error2, ...]
  if (FLAGS_use_state_exact_match) {
    UpdateStateAnalyticalMatching(debug);
  } else {
    UpdateState(debug);
  }

  UpdateMatrix();

  // Compound discrete matrix with road preview model
  UpdateMatrixCompound();

  common::math::SolveLQRProblem(matrix_adc_, matrix_bdc_, matrix_q_, matrix_r_,
                                lqr_eps_, lqr_max_iteration_, &amp;matrix_k_);

  // feedback = - K * state
  // Convert vehicle steer angle from rad to degree and then to steer degree
  // then to 100% ratio
  double steer_angle_feedback = -(matrix_k_ * matrix_state_)(0, 0) * 180 /
                                M_PI * steer_transmission_ratio_ /
                                steer_single_direction_max_degree_ * 100;

  double steer_angle_feedforward = ComputeFeedForward(debug-&gt;curvature());
  double steer_angle = steer_angle_feedback + steer_angle_feedforward;
  // Clamp the steer angle to -100.0 to 100.0
  steer_angle = apollo::common::math::Clamp(steer_angle, -100.0, 100.0);

  steer_angle = digital_filter_.Filter(steer_angle);
  cmd-&gt;set_steering_target(steer_angle);
  cmd-&gt;set_steering_rate(FLAGS_steer_angle_rate);

  // compute extra information for logging and debugging
  double steer_angle_lateral_contribution =
      -matrix_k_(0, 0) * matrix_state_(0, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_lateral_rate_contribution =
      -matrix_k_(0, 1) * matrix_state_(1, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_heading_contribution =
      -matrix_k_(0, 2) * matrix_state_(2, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_heading_rate_contribution =
      -matrix_k_(0, 3) * matrix_state_(3, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  // TODO(yifei): move up temporary values to use debug fields.

  debug-&gt;set_heading(vehicle_state_.heading());
  debug-&gt;set_steer_angle(steer_angle);
  debug-&gt;set_steer_angle_feedforward(steer_angle_feedforward);
  debug-&gt;set_steer_angle_lateral_contribution(steer_angle_lateral_contribution);
  debug-&gt;set_steer_angle_lateral_rate_contribution(
      steer_angle_lateral_rate_contribution);
  debug-&gt;set_steer_angle_heading_contribution(steer_angle_heading_contribution);
  debug-&gt;set_steer_angle_heading_rate_contribution(
      steer_angle_heading_rate_contribution);
  debug-&gt;set_steer_angle_feedback(steer_angle_feedback);
  debug-&gt;set_steering_position(chassis-&gt;steering_percentage());
  debug-&gt;set_ref_speed(vehicle_state_.linear_velocity());
  ProcessLogs(debug, chassis);
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(65, 0)" endLine="(71, 1)" clone_start="1" clone_end="7">
			<code function_name="Steering65::Parse(const std::uint8_t* bytes, int32_t length,const struct timeval&amp; timestamp, ChassisDetail* car_status) const">void Steering65::Parse(const std::uint8_t* bytes, int32_t length,
                       const struct timeval&amp; timestamp,
                       ChassisDetail* car_status) const {
  car_status-&gt;mutable_eps()-&gt;set_timestamp_65(timestamp.tv_sec +
                                              timestamp.tv_usec / 1000000.0);
  Parse(bytes, length, car_status);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(55, 0)" endLine="(61, 1)" clone_start="1" clone_end="7">
			<code function_name="Wheelspeed6a::Parse(const std::uint8_t* bytes, int32_t length,const struct timeval&amp; timestamp, ChassisDetail* car_status) const">void Wheelspeed6a::Parse(const std::uint8_t* bytes, int32_t length,
                         const struct timeval&amp; timestamp,
                         ChassisDetail* car_status) const {
  car_status-&gt;mutable_vehicle_spd()-&gt;set_timestamp_sec(
      timestamp.tv_sec + timestamp.tv_usec / 1000000.0);
  Parse(bytes, length, car_status);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(73, 0)" endLine="(85, 1)" clone_start="1" clone_end="7">
			<code function_name="Steering65::steering_angle(const std::uint8_t* bytes, int32_t length) const">double Steering65::steering_angle(const std::uint8_t* bytes,
                                  int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x8000) {
    value = value - 0x10000;
  }

  return value * 0.100000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(63, 0)" endLine="(71, 1)" clone_start="1" clone_end="7">
			<code function_name="Wheelspeed6a::front_left_wheel_speed(const std::uint8_t* bytes, int32_t length) const">double Wheelspeed6a::front_left_wheel_speed(const std::uint8_t* bytes,
                                            int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\util\file.h" startLine="(52, 0)" endLine="(67, 1)" clone_start="7" clone_end="16">
			<code function_name="SetProtoToASCIIFile(const MessageType &amp;message, const std::string &amp;file_name)">bool SetProtoToASCIIFile(const MessageType &amp;message,
                         const std::string &amp;file_name) {
  using google::protobuf::io::ZeroCopyOutputStream;
  using google::protobuf::io::FileOutputStream;
  using google::protobuf::TextFormat;
  int file_descriptor = open(file_name.c_str(), O_WRONLY | O_CREAT, S_IRWXU);
  if (file_descriptor &lt; 0) {
    // Failed to open;
    return false;
  }
  ZeroCopyOutputStream *output = new FileOutputStream(file_descriptor);
  bool success = TextFormat::Print(message, output);
  delete output;
  close(file_descriptor);
  return success;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\util\file.h" startLine="(78, 0)" endLine="(93, 1)" clone_start="6" clone_end="16">
			<code function_name="GetProtoFromASCIIFile(const std::string &amp;file_name, MessageType *message)">bool GetProtoFromASCIIFile(const std::string &amp;file_name, MessageType *message) {
  using google::protobuf::io::ZeroCopyInputStream;
  using google::protobuf::io::FileInputStream;
  using google::protobuf::TextFormat;
  int file_descriptor = open(file_name.c_str(), O_RDONLY);
  if (file_descriptor &lt; 0) {
    // Failed to open;
    return false;
  }

  ZeroCopyInputStream *input = new FileInputStream(file_descriptor);
  bool success = TextFormat::Parse(input, message);
  delete input;
  close(file_descriptor);
  return success;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\util\file.h" startLine="(78, 0)" endLine="(93, 1)" clone_start="1" clone_end="1">
			<code function_name="GetProtoFromASCIIFile(const std::string &amp;file_name, MessageType *message)">bool GetProtoFromASCIIFile(const std::string &amp;file_name, MessageType *message) {
  using google::protobuf::io::ZeroCopyInputStream;
  using google::protobuf::io::FileInputStream;
  using google::protobuf::TextFormat;
  int file_descriptor = open(file_name.c_str(), O_RDONLY);
  if (file_descriptor &lt; 0) {
    // Failed to open;
    return false;
  }

  ZeroCopyInputStream *input = new FileInputStream(file_descriptor);
  bool success = TextFormat::Parse(input, message);
  delete input;
  close(file_descriptor);
  return success;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\util\file.h" startLine="(104, 0)" endLine="(108, 1)" clone_start="1" clone_end="1">
			<code function_name="GetProtoFromBinaryFile(const std::string &amp;file_name, MessageType *message)">bool GetProtoFromBinaryFile(const std::string &amp;file_name,
                            MessageType *message) {
  std::fstream input(file_name, std::ios::in | std::ios::binary);
  return message-&gt;ParseFromIstream(&amp;input);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(85, 0)" endLine="(89, 1)" clone_start="4" clone_end="5">
			<code function_name="Gps6f::vdop(const std::uint8_t* bytes, int32_t length) const">double Gps6f::vdop(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(136, 0)" endLine="(144, 1)" clone_start="8" clone_end="9">
			<code function_name="Brakeinfo74::braking_torque_actual(const std::uint8_t* bytes, int32_t length) const">double Brakeinfo74::braking_torque_actual(const std::uint8_t* bytes,
                                          int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 4);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 4.000000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(91, 0)" endLine="(95, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6f::fix_quality(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6f::fix_quality(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 7);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(146, 0)" endLine="(152, 1)" clone_start="1" clone_end="7">
			<code function_name="Brakeinfo74::hill_start_assist_mode(const std::uint8_t* bytes, int32_t length) const">int32_t Brakeinfo74::hill_start_assist_mode(const std::uint8_t* bytes,
                                            int32_t length) const {
  // see table for status code
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(4, 2);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(97, 0)" endLine="(101, 1)" clone_start="1" clone_end="4">
			<code function_name="Gps6f::num_satellites(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6f::num_satellites(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 7);
  int32_t x = frame.get_byte(3, 5);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(154, 0)" endLine="(160, 1)" clone_start="1" clone_end="6">
			<code function_name="Brakeinfo74::parking_brake_status(const std::uint8_t* bytes, int32_t length) const">int32_t Brakeinfo74::parking_brake_status(const std::uint8_t* bytes,
                                          int32_t length) const {
  // see table for status code
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(6, 2);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\monitor\monitor_buffer.cc" startLine="(31, 0)" endLine="(53, 1)" clone_start="8" clone_end="16">
			<code function_name="MonitorBuffer::PrintLog()">void MonitorBuffer::PrintLog() {
  if (monitor_msg_items_.empty()) {
    return;
  }
  const auto level = monitor_msg_items_.back().first;
  const auto&amp; msg = monitor_msg_items_.back().second;
  switch (level) {
    case MonitorMessageItem::INFO:
      AINFO &lt;&lt; msg;
      break;
    case MonitorMessageItem::WARN:
      AWARN &lt;&lt; msg;
      break;
    case MonitorMessageItem::ERROR:
      AERROR &lt;&lt; msg;
      break;
    case MonitorMessageItem::FATAL:
      AFATAL &lt;&lt; msg;
      break;
    default:
      AERROR &lt;&lt; "[unknown monitor level]: " &lt;&lt; msg;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\monitor\monitor_buffer.cc" startLine="(31, 0)" endLine="(53, 1)" clone_start="11" clone_end="19">
			<code function_name="MonitorBuffer::PrintLog()">void MonitorBuffer::PrintLog() {
  if (monitor_msg_items_.empty()) {
    return;
  }
  const auto level = monitor_msg_items_.back().first;
  const auto&amp; msg = monitor_msg_items_.back().second;
  switch (level) {
    case MonitorMessageItem::INFO:
      AINFO &lt;&lt; msg;
      break;
    case MonitorMessageItem::WARN:
      AWARN &lt;&lt; msg;
      break;
    case MonitorMessageItem::ERROR:
      AERROR &lt;&lt; msg;
      break;
    case MonitorMessageItem::FATAL:
      AFATAL &lt;&lt; msg;
      break;
    default:
      AERROR &lt;&lt; "[unknown monitor level]: " &lt;&lt; msg;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(53, 0)" endLine="(56, 1)" clone_start="1" clone_end="4">
			<code function_name="Steering64::set_steering_angle(double angle)">Steering64* Steering64::set_steering_angle(double angle) {
  steering_angle_ = angle;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(49, 0)" endLine="(52, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle62::set_pedal(double pedal)">Throttle62* Throttle62::set_pedal(double pedal) {
  pedal_cmd_ = pedal;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(58, 0)" endLine="(61, 1)" clone_start="1" clone_end="4">
			<code function_name="Steering64::set_enable()">Steering64* Steering64::set_enable() {
  steering_enable_ = true;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(54, 0)" endLine="(57, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle62::set_enable()">Throttle62* Throttle62::set_enable() {
  pedal_enable_ = true;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(63, 0)" endLine="(66, 1)" clone_start="1" clone_end="3">
			<code function_name="Steering64::set_disable()">Steering64* Steering64::set_disable() {
  steering_enable_ = false;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(59, 0)" endLine="(62, 1)" clone_start="1" clone_end="3">
			<code function_name="Throttle62::set_disable()">Throttle62* Throttle62::set_disable() {
  pedal_enable_ = false;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(346, 0)" endLine="(423, 1)" clone_start="47" clone_end="55">
			<code function_name="NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs)">bool NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs) {
    _gnss.mutable_position()-&gt;set_lon(pos-&gt;longitude);
    _gnss.mutable_position()-&gt;set_lat(pos-&gt;latitude);
    _gnss.mutable_position()-&gt;set_height(pos-&gt;height_msl + pos-&gt;undulation);
    _gnss.mutable_position_std_dev()-&gt;set_x(pos-&gt;longitude_std_dev);
    _gnss.mutable_position_std_dev()-&gt;set_y(pos-&gt;latitude_std_dev);
    _gnss.mutable_position_std_dev()-&gt;set_z(pos-&gt;height_std_dev);
    _gnss.set_num_sats(pos-&gt;num_sats_in_solution);
    if (_solution_status != pos-&gt;solution_status) {
        _solution_status = pos-&gt;solution_status;
        ROS_INFO_STREAM("Solution status: " &lt;&lt; static_cast&lt;int&gt;(_solution_status));
    }
    if (_position_type != pos-&gt;position_type) {
        _position_type = pos-&gt;position_type;
        ROS_INFO_STREAM("Position type: " &lt;&lt; static_cast&lt;int&gt;(_position_type));
    }
    _gnss.set_solution_status(static_cast&lt;uint32_t&gt;(pos-&gt;solution_status));
    if (pos-&gt;solution_status == novatel::SolutionStatus::SOL_COMPUTED) {
        _gnss.set_position_type(static_cast&lt;uint32_t&gt;(pos-&gt;position_type));
        switch (pos-&gt;position_type) {
        case novatel::SolutionType::SINGLE:
        case novatel::SolutionType::INS_PSRSP:
            _gnss.set_type(apollo::drivers::gnss::Gnss::SINGLE);
            break;
        case novatel::SolutionType::PSRDIFF:
        case novatel::SolutionType::WAAS:
        case novatel::SolutionType::INS_SBAS:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PSRDIFF);
            break;
        case novatel::SolutionType::FLOATCONV:
        case novatel::SolutionType::L1_FLOAT:
        case novatel::SolutionType::IONOFREE_FLOAT:
        case novatel::SolutionType::NARROW_FLOAT:
        case novatel::SolutionType::RTK_DIRECT_INS:
        case novatel::SolutionType::INS_RTKFLOAT:
            _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_FLOAT);
            break;
        case novatel::SolutionType::WIDELANE:
        case novatel::SolutionType::NARROWLANE:
        case novatel::SolutionType::L1_INT:
        case novatel::SolutionType::WIDE_INT:
        case novatel::SolutionType::NARROW_INT:
        case novatel::SolutionType::INS_RTKFIXED:
            _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_INTEGER);
            break;
        case novatel::SolutionType::OMNISTAR:
        case novatel::SolutionType::INS_OMNISTAR:
        case novatel::SolutionType::INS_OMNISTAR_HP:
        case novatel::SolutionType::INS_OMNISTAR_XP:
        case novatel::SolutionType::OMNISTAR_HP:
        case novatel::SolutionType::OMNISTAR_XP:
        case novatel::SolutionType::PPP_CONVERGING:
        case novatel::SolutionType::PPP:
        case novatel::SolutionType::INS_PPP_CONVERGING:
        case novatel::SolutionType::INS_PPP:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PPP);
            break;
        case novatel::SolutionType::PROPOGATED:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PROPAGATED);
            break;
        default:
            _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
        }
    } else {
        _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
        _gnss.set_position_type(0);
    }
    if (pos-&gt;datum_id != novatel::DatumId::WGS84) {
        ROS_ERROR_STREAM_THROTTLE(5, "Unexpected Datum Id: " &lt;&lt; static_cast&lt;int&gt;(pos-&gt;datum_id));
    }

    double seconds = gps_week * SECONDS_PER_WEEK + gps_millisecs * 1e-3;
    if (_gnss.measurement_time() != seconds) {
        _gnss.set_measurement_time(seconds);
        return false;
    }
    return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(346, 0)" endLine="(423, 1)" clone_start="46" clone_end="54">
			<code function_name="NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs)">bool NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs) {
    _gnss.mutable_position()-&gt;set_lon(pos-&gt;longitude);
    _gnss.mutable_position()-&gt;set_lat(pos-&gt;latitude);
    _gnss.mutable_position()-&gt;set_height(pos-&gt;height_msl + pos-&gt;undulation);
    _gnss.mutable_position_std_dev()-&gt;set_x(pos-&gt;longitude_std_dev);
    _gnss.mutable_position_std_dev()-&gt;set_y(pos-&gt;latitude_std_dev);
    _gnss.mutable_position_std_dev()-&gt;set_z(pos-&gt;height_std_dev);
    _gnss.set_num_sats(pos-&gt;num_sats_in_solution);
    if (_solution_status != pos-&gt;solution_status) {
        _solution_status = pos-&gt;solution_status;
        ROS_INFO_STREAM("Solution status: " &lt;&lt; static_cast&lt;int&gt;(_solution_status));
    }
    if (_position_type != pos-&gt;position_type) {
        _position_type = pos-&gt;position_type;
        ROS_INFO_STREAM("Position type: " &lt;&lt; static_cast&lt;int&gt;(_position_type));
    }
    _gnss.set_solution_status(static_cast&lt;uint32_t&gt;(pos-&gt;solution_status));
    if (pos-&gt;solution_status == novatel::SolutionStatus::SOL_COMPUTED) {
        _gnss.set_position_type(static_cast&lt;uint32_t&gt;(pos-&gt;position_type));
        switch (pos-&gt;position_type) {
        case novatel::SolutionType::SINGLE:
        case novatel::SolutionType::INS_PSRSP:
            _gnss.set_type(apollo::drivers::gnss::Gnss::SINGLE);
            break;
        case novatel::SolutionType::PSRDIFF:
        case novatel::SolutionType::WAAS:
        case novatel::SolutionType::INS_SBAS:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PSRDIFF);
            break;
        case novatel::SolutionType::FLOATCONV:
        case novatel::SolutionType::L1_FLOAT:
        case novatel::SolutionType::IONOFREE_FLOAT:
        case novatel::SolutionType::NARROW_FLOAT:
        case novatel::SolutionType::RTK_DIRECT_INS:
        case novatel::SolutionType::INS_RTKFLOAT:
            _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_FLOAT);
            break;
        case novatel::SolutionType::WIDELANE:
        case novatel::SolutionType::NARROWLANE:
        case novatel::SolutionType::L1_INT:
        case novatel::SolutionType::WIDE_INT:
        case novatel::SolutionType::NARROW_INT:
        case novatel::SolutionType::INS_RTKFIXED:
            _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_INTEGER);
            break;
        case novatel::SolutionType::OMNISTAR:
        case novatel::SolutionType::INS_OMNISTAR:
        case novatel::SolutionType::INS_OMNISTAR_HP:
        case novatel::SolutionType::INS_OMNISTAR_XP:
        case novatel::SolutionType::OMNISTAR_HP:
        case novatel::SolutionType::OMNISTAR_XP:
        case novatel::SolutionType::PPP_CONVERGING:
        case novatel::SolutionType::PPP:
        case novatel::SolutionType::INS_PPP_CONVERGING:
        case novatel::SolutionType::INS_PPP:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PPP);
            break;
        case novatel::SolutionType::PROPOGATED:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PROPAGATED);
            break;
        default:
            _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
        }
    } else {
        _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
        _gnss.set_position_type(0);
    }
    if (pos-&gt;datum_id != novatel::DatumId::WGS84) {
        ROS_ERROR_STREAM_THROTTLE(5, "Unexpected Datum Id: " &lt;&lt; static_cast&lt;int&gt;(pos-&gt;datum_id));
    }

    double seconds = gps_week * SECONDS_PER_WEEK + gps_millisecs * 1e-3;
    if (_gnss.measurement_time() != seconds) {
        _gnss.set_measurement_time(seconds);
        return false;
    }
    return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\tools\enter_auto_mode.cc" startLine="(92, 0)" endLine="(123, 1)" clone_start="11" clone_end="24">
			<code function_name="main(int argc, char** argv)">int main(int argc, char** argv) {
  google::InitGoogleLogging(argv[0]);
  FLAGS_alsologtostderr = true;
  FLAGS_v = 4;

  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);

  ros::init(argc, argv, "enter_auto_mode");

  // Setup AdapterManager.
  AdapterManagerConfig config;
  config.set_is_ros(true);
  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(AdapterConfig::PUBLISH_ONLY);
    sub_config-&gt;set_type(AdapterConfig::PAD);
  }

  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(AdapterConfig::RECEIVE_ONLY);
    sub_config-&gt;set_type(AdapterConfig::CHASSIS);
  }
  AdapterManager::Init(config);
  AdapterManager::SetChassisCallback(
      apollo::control::SwitchDrivingMode::MonitorDrivingMode);

  // FIXME: delay for ros pub/sub ready
  sleep(1);
  apollo::control::SwitchDrivingMode::EnterAutoMode();
  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\hmi\ros_node\ros_node_service.cc" startLine="(73, 0)" endLine="(90, 1)" clone_start="3" clone_end="16">
			<code function_name="HMIRosNodeImpl::Init()">void HMIRosNodeImpl::Init() {
  // Setup AdapterManager.
  AdapterManagerConfig config;
  config.set_is_ros(true);
  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(AdapterConfig::PUBLISH_ONLY);
    sub_config-&gt;set_type(AdapterConfig::PAD);
  }

  {
    auto* sub_config = config.add_config();
    sub_config-&gt;set_mode(AdapterConfig::RECEIVE_ONLY);
    sub_config-&gt;set_type(AdapterConfig::CHASSIS);
  }
  AdapterManager::Init(config);
  AdapterManager::SetChassisCallback(MonitorDrivingMode);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(256, 0)" endLine="(304, 1)" clone_start="23" clone_end="33">
			<code function_name="RawStream::connect()">bool RawStream::connect() {
    if (_data_stream) {
        if (_data_stream-&gt;get_status() != Stream::Status::CONNECTED) {
            if (!_data_stream-&gt;connect()) {
                ROS_ERROR("data stream connect failed.");
                return false;
            }
            _data_stream_status-&gt;status = Stream::Status::CONNECTED;
            _stream_status-&gt;set_ins_stream_type(apollo::common::gnss_status::StreamStatus::CONNECTED);
        }
    }

    if (_command_stream) {
        if (_command_stream-&gt;get_status() != Stream::Status::CONNECTED) {
            if (!_data_stream-&gt;connect()) {
                ROS_ERROR("command stream connect failed.");
                return false;
            }
            _command_stream_status-&gt;status = Stream::Status::CONNECTED;
        }
    }

    if (_in_rtk_stream) {
        if (_in_rtk_stream-&gt;get_status() != Stream::Status::CONNECTED) {
            if (!_in_rtk_stream-&gt;connect()) {
                ROS_ERROR("in rtk stream connect failed.");
            } else {
                _in_rtk_stream_status-&gt;status = Stream::Status::CONNECTED;
                _stream_status-&gt;set_rtk_stream_in_type(apollo::common::gnss_status::StreamStatus::CONNECTED);
            }
        }
    } else {
        _stream_status-&gt;set_rtk_stream_in_type(apollo::common::gnss_status::StreamStatus::CONNECTED);
    }

    if (_out_rtk_stream) {
        if (_out_rtk_stream-&gt;get_status() != Stream::Status::CONNECTED) {
            if (!_out_rtk_stream-&gt;connect()) {
                ROS_ERROR("out rtk stream connect failed.");
            } else {
                _out_rtk_stream_status-&gt;status = Stream::Status::CONNECTED;
                _stream_status-&gt;set_rtk_stream_out_type(apollo::common::gnss_status::StreamStatus::CONNECTED);
            }
        }
     } else {
        _stream_status-&gt;set_rtk_stream_out_type(apollo::common::gnss_status::StreamStatus::CONNECTED);
    }
    return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(256, 0)" endLine="(304, 1)" clone_start="36" clone_end="46">
			<code function_name="RawStream::connect()">bool RawStream::connect() {
    if (_data_stream) {
        if (_data_stream-&gt;get_status() != Stream::Status::CONNECTED) {
            if (!_data_stream-&gt;connect()) {
                ROS_ERROR("data stream connect failed.");
                return false;
            }
            _data_stream_status-&gt;status = Stream::Status::CONNECTED;
            _stream_status-&gt;set_ins_stream_type(apollo::common::gnss_status::StreamStatus::CONNECTED);
        }
    }

    if (_command_stream) {
        if (_command_stream-&gt;get_status() != Stream::Status::CONNECTED) {
            if (!_data_stream-&gt;connect()) {
                ROS_ERROR("command stream connect failed.");
                return false;
            }
            _command_stream_status-&gt;status = Stream::Status::CONNECTED;
        }
    }

    if (_in_rtk_stream) {
        if (_in_rtk_stream-&gt;get_status() != Stream::Status::CONNECTED) {
            if (!_in_rtk_stream-&gt;connect()) {
                ROS_ERROR("in rtk stream connect failed.");
            } else {
                _in_rtk_stream_status-&gt;status = Stream::Status::CONNECTED;
                _stream_status-&gt;set_rtk_stream_in_type(apollo::common::gnss_status::StreamStatus::CONNECTED);
            }
        }
    } else {
        _stream_status-&gt;set_rtk_stream_in_type(apollo::common::gnss_status::StreamStatus::CONNECTED);
    }

    if (_out_rtk_stream) {
        if (_out_rtk_stream-&gt;get_status() != Stream::Status::CONNECTED) {
            if (!_out_rtk_stream-&gt;connect()) {
                ROS_ERROR("out rtk stream connect failed.");
            } else {
                _out_rtk_stream_status-&gt;status = Stream::Status::CONNECTED;
                _stream_status-&gt;set_rtk_stream_out_type(apollo::common::gnss_status::StreamStatus::CONNECTED);
            }
        }
     } else {
        _stream_status-&gt;set_rtk_stream_out_type(apollo::common::gnss_status::StreamStatus::CONNECTED);
    }
    return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(26, 0)" endLine="(89, 1)" clone_start="56" clone_end="64">
			<code function_name="Gear67::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Gear67::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t gear = gear_state(bytes, length);
  switch (gear) {
    case 0x01:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_PARKING);
      break;
    case 0x02:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_REVERSE);
      break;
    case 0x03:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_NEUTRAL);
      break;
    case 0x04:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_DRIVE);
      break;
    case 0x05:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_LOW);
      break;
    case 0x00:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_NONE);
      break;
    default:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_INVALID);
      break;
  }

  if (is_driver_override(bytes, length)) {
    // last shift requested by driver
    car_status-&gt;mutable_gear()-&gt;set_is_shift_position_valid(false);
  } else {
    // last shift requested by-wire
    car_status-&gt;mutable_gear()-&gt;set_is_shift_position_valid(true);
  }
  car_status-&gt;mutable_gear()-&gt;set_driver_override(
      is_driver_override(bytes, length));

  int32_t gear_cmd = reported_gear_cmd(bytes, length);
  switch (gear_cmd) {
    case 0x01:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_PARKING);
      break;
    case 0x02:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_REVERSE);
      break;
    case 0x03:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_NEUTRAL);
      break;
    case 0x04:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_DRIVE);
      break;
    case 0x05:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_LOW);
      break;
    case 0x00:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_NONE);
      break;
    default:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_INVALID);
      break;
  }

  car_status-&gt;mutable_gear()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(26, 0)" endLine="(50, 1)" clone_start="17" clone_end="25">
			<code function_name="Gps6f::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Gps6f::Parse(const std::uint8_t* bytes, int32_t length,
                  ChassisDetail* car_status) const {
  car_status-&gt;mutable_basic()-&gt;set_altitude(altitude(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_heading(heading(bytes, length));
  // speed mph -&gt; mps
  car_status-&gt;mutable_basic()-&gt;set_gps_speed(speed(bytes, length) * 0.44704);
  car_status-&gt;mutable_basic()-&gt;set_hdop(hdop(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_vdop(vdop(bytes, length));
  switch (fix_quality(bytes, length)) {
    case 0:
      car_status-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_NO);
      break;
    case 1:
      car_status-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_2D);
      break;
    case 2:
      car_status-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_3D);
      break;
    default:
      car_status-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_INVALID);
      break;
  }
  car_status-&gt;mutable_basic()-&gt;set_num_satellites(
      num_satellites(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(91, 0)" endLine="(95, 1)" clone_start="1" clone_end="3">
			<code function_name="Gear67::gear_state(const std::uint8_t* bytes, int32_t length) const">int32_t Gear67::gear_state(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(52, 0)" endLine="(62, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6f::altitude(const std::uint8_t* bytes, int32_t length) const">double Gps6f::altitude(const std::uint8_t* bytes, int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.250000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\planning\planner\rtk_replay_planner.cc" startLine="(79, 0)" endLine="(127, 1)" clone_start="31" clone_end="44">
			<code function_name="RTKReplayPlanner::ReadTrajectoryFile(const std::string&amp; filename)">void RTKReplayPlanner::ReadTrajectoryFile(const std::string&amp; filename) {
  if (!complete_rtk_trajectory_.empty()) {
    complete_rtk_trajectory_.clear();
  }

  std::ifstream file_in(filename.c_str());
  if (!file_in.is_open()) {
    AERROR &lt;&lt; "RTKReplayPlanner cannot open trajectory file: " &lt;&lt; filename;
    return;
  }

  std::string line;
  // skip the header line.
  getline(file_in, line);

  while (true) {
    getline(file_in, line);
    if (line == "") {
      break;
    }

    auto tokens = apollo::common::util::StringTokenizer::Split(line, "\t ");
    if (tokens.size() &lt; 11) {
      AERROR &lt;&lt; "RTKReplayPlanner parse line failed; the data dimension does not match.";
      AERROR &lt;&lt; line;
      continue;
    }

    TrajectoryPoint point;
    point.x = std::stod(tokens[0]);
    point.y = std::stod(tokens[1]);
    point.z = std::stod(tokens[2]);

    point.v = std::stod(tokens[3]);
    point.a = std::stod(tokens[4]);

    point.kappa = std::stod(tokens[5]);
    point.dkappa = std::stod(tokens[6]);

    point.relative_time = std::stod(tokens[7]);

    point.theta = std::stod(tokens[8]);

    point.s = std::stod(tokens[10]);
    complete_rtk_trajectory_.push_back(point);
  }

  file_in.close();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\planning\planner\rtk_replay_planner.cc" startLine="(79, 0)" endLine="(127, 1)" clone_start="30" clone_end="42">
			<code function_name="RTKReplayPlanner::ReadTrajectoryFile(const std::string&amp; filename)">void RTKReplayPlanner::ReadTrajectoryFile(const std::string&amp; filename) {
  if (!complete_rtk_trajectory_.empty()) {
    complete_rtk_trajectory_.clear();
  }

  std::ifstream file_in(filename.c_str());
  if (!file_in.is_open()) {
    AERROR &lt;&lt; "RTKReplayPlanner cannot open trajectory file: " &lt;&lt; filename;
    return;
  }

  std::string line;
  // skip the header line.
  getline(file_in, line);

  while (true) {
    getline(file_in, line);
    if (line == "") {
      break;
    }

    auto tokens = apollo::common::util::StringTokenizer::Split(line, "\t ");
    if (tokens.size() &lt; 11) {
      AERROR &lt;&lt; "RTKReplayPlanner parse line failed; the data dimension does not match.";
      AERROR &lt;&lt; line;
      continue;
    }

    TrajectoryPoint point;
    point.x = std::stod(tokens[0]);
    point.y = std::stod(tokens[1]);
    point.z = std::stod(tokens[2]);

    point.v = std::stod(tokens[3]);
    point.a = std::stod(tokens[4]);

    point.kappa = std::stod(tokens[5]);
    point.dkappa = std::stod(tokens[6]);

    point.relative_time = std::stod(tokens[7]);

    point.theta = std::stod(tokens[8]);

    point.s = std::stod(tokens[10]);
    complete_rtk_trajectory_.push_back(point);
  }

  file_in.close();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(391, 0)" endLine="(400, 1)" clone_start="1" clone_end="10">
			<code function_name="LincolnController::Brake(double pedal)">void LincolnController::Brake(double pedal) {
  // double real_value = params_.max_acc() * acceleration / 100;
  // TODO
  if (!(driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
        driving_mode() == Chassis::AUTO_SPEED_ONLY)) {
    AINFO &lt;&lt; "The current drive mode does not need to set acceleration.";
    return;
  }
  brake_60_-&gt;set_pedal(pedal);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(404, 0)" endLine="(411, 1)" clone_start="1" clone_end="8">
			<code function_name="LincolnController::Throttle(double pedal)">void LincolnController::Throttle(double pedal) {
  if (!(driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
        driving_mode() == Chassis::AUTO_SPEED_ONLY)) {
    AINFO &lt;&lt; "The current drive mode does not need to set acceleration.";
    return;
  }
  throttle_62_-&gt;set_pedal(pedal);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(404, 0)" endLine="(411, 1)" clone_start="1" clone_end="5">
			<code function_name="LincolnController::Throttle(double pedal)">void LincolnController::Throttle(double pedal) {
  if (!(driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
        driving_mode() == Chassis::AUTO_SPEED_ONLY)) {
    AINFO &lt;&lt; "The current drive mode does not need to set acceleration.";
    return;
  }
  throttle_62_-&gt;set_pedal(pedal);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(417, 0)" endLine="(426, 1)" clone_start="1" clone_end="5">
			<code function_name="LincolnController::Steer(double angle)">void LincolnController::Steer(double angle) {
  if (!(driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
        driving_mode() == Chassis::AUTO_STEER_ONLY)) {
    AINFO &lt;&lt; "The current driving mode does not need to set steer.";
    return;
  }
  const double real_angle = params_.max_steer_angle() * angle / 100.0;
  // reverse sign
  steering_64_-&gt;set_steering_angle(real_angle)-&gt;set_steering_angle_speed(200);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(346, 0)" endLine="(423, 1)" clone_start="38" clone_end="46">
			<code function_name="NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs)">bool NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs) {
    _gnss.mutable_position()-&gt;set_lon(pos-&gt;longitude);
    _gnss.mutable_position()-&gt;set_lat(pos-&gt;latitude);
    _gnss.mutable_position()-&gt;set_height(pos-&gt;height_msl + pos-&gt;undulation);
    _gnss.mutable_position_std_dev()-&gt;set_x(pos-&gt;longitude_std_dev);
    _gnss.mutable_position_std_dev()-&gt;set_y(pos-&gt;latitude_std_dev);
    _gnss.mutable_position_std_dev()-&gt;set_z(pos-&gt;height_std_dev);
    _gnss.set_num_sats(pos-&gt;num_sats_in_solution);
    if (_solution_status != pos-&gt;solution_status) {
        _solution_status = pos-&gt;solution_status;
        ROS_INFO_STREAM("Solution status: " &lt;&lt; static_cast&lt;int&gt;(_solution_status));
    }
    if (_position_type != pos-&gt;position_type) {
        _position_type = pos-&gt;position_type;
        ROS_INFO_STREAM("Position type: " &lt;&lt; static_cast&lt;int&gt;(_position_type));
    }
    _gnss.set_solution_status(static_cast&lt;uint32_t&gt;(pos-&gt;solution_status));
    if (pos-&gt;solution_status == novatel::SolutionStatus::SOL_COMPUTED) {
        _gnss.set_position_type(static_cast&lt;uint32_t&gt;(pos-&gt;position_type));
        switch (pos-&gt;position_type) {
        case novatel::SolutionType::SINGLE:
        case novatel::SolutionType::INS_PSRSP:
            _gnss.set_type(apollo::drivers::gnss::Gnss::SINGLE);
            break;
        case novatel::SolutionType::PSRDIFF:
        case novatel::SolutionType::WAAS:
        case novatel::SolutionType::INS_SBAS:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PSRDIFF);
            break;
        case novatel::SolutionType::FLOATCONV:
        case novatel::SolutionType::L1_FLOAT:
        case novatel::SolutionType::IONOFREE_FLOAT:
        case novatel::SolutionType::NARROW_FLOAT:
        case novatel::SolutionType::RTK_DIRECT_INS:
        case novatel::SolutionType::INS_RTKFLOAT:
            _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_FLOAT);
            break;
        case novatel::SolutionType::WIDELANE:
        case novatel::SolutionType::NARROWLANE:
        case novatel::SolutionType::L1_INT:
        case novatel::SolutionType::WIDE_INT:
        case novatel::SolutionType::NARROW_INT:
        case novatel::SolutionType::INS_RTKFIXED:
            _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_INTEGER);
            break;
        case novatel::SolutionType::OMNISTAR:
        case novatel::SolutionType::INS_OMNISTAR:
        case novatel::SolutionType::INS_OMNISTAR_HP:
        case novatel::SolutionType::INS_OMNISTAR_XP:
        case novatel::SolutionType::OMNISTAR_HP:
        case novatel::SolutionType::OMNISTAR_XP:
        case novatel::SolutionType::PPP_CONVERGING:
        case novatel::SolutionType::PPP:
        case novatel::SolutionType::INS_PPP_CONVERGING:
        case novatel::SolutionType::INS_PPP:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PPP);
            break;
        case novatel::SolutionType::PROPOGATED:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PROPAGATED);
            break;
        default:
            _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
        }
    } else {
        _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
        _gnss.set_position_type(0);
    }
    if (pos-&gt;datum_id != novatel::DatumId::WGS84) {
        ROS_ERROR_STREAM_THROTTLE(5, "Unexpected Datum Id: " &lt;&lt; static_cast&lt;int&gt;(pos-&gt;datum_id));
    }

    double seconds = gps_week * SECONDS_PER_WEEK + gps_millisecs * 1e-3;
    if (_gnss.measurement_time() != seconds) {
        _gnss.set_measurement_time(seconds);
        return false;
    }
    return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(346, 0)" endLine="(423, 1)" clone_start="30" clone_end="38">
			<code function_name="NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs)">bool NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs) {
    _gnss.mutable_position()-&gt;set_lon(pos-&gt;longitude);
    _gnss.mutable_position()-&gt;set_lat(pos-&gt;latitude);
    _gnss.mutable_position()-&gt;set_height(pos-&gt;height_msl + pos-&gt;undulation);
    _gnss.mutable_position_std_dev()-&gt;set_x(pos-&gt;longitude_std_dev);
    _gnss.mutable_position_std_dev()-&gt;set_y(pos-&gt;latitude_std_dev);
    _gnss.mutable_position_std_dev()-&gt;set_z(pos-&gt;height_std_dev);
    _gnss.set_num_sats(pos-&gt;num_sats_in_solution);
    if (_solution_status != pos-&gt;solution_status) {
        _solution_status = pos-&gt;solution_status;
        ROS_INFO_STREAM("Solution status: " &lt;&lt; static_cast&lt;int&gt;(_solution_status));
    }
    if (_position_type != pos-&gt;position_type) {
        _position_type = pos-&gt;position_type;
        ROS_INFO_STREAM("Position type: " &lt;&lt; static_cast&lt;int&gt;(_position_type));
    }
    _gnss.set_solution_status(static_cast&lt;uint32_t&gt;(pos-&gt;solution_status));
    if (pos-&gt;solution_status == novatel::SolutionStatus::SOL_COMPUTED) {
        _gnss.set_position_type(static_cast&lt;uint32_t&gt;(pos-&gt;position_type));
        switch (pos-&gt;position_type) {
        case novatel::SolutionType::SINGLE:
        case novatel::SolutionType::INS_PSRSP:
            _gnss.set_type(apollo::drivers::gnss::Gnss::SINGLE);
            break;
        case novatel::SolutionType::PSRDIFF:
        case novatel::SolutionType::WAAS:
        case novatel::SolutionType::INS_SBAS:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PSRDIFF);
            break;
        case novatel::SolutionType::FLOATCONV:
        case novatel::SolutionType::L1_FLOAT:
        case novatel::SolutionType::IONOFREE_FLOAT:
        case novatel::SolutionType::NARROW_FLOAT:
        case novatel::SolutionType::RTK_DIRECT_INS:
        case novatel::SolutionType::INS_RTKFLOAT:
            _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_FLOAT);
            break;
        case novatel::SolutionType::WIDELANE:
        case novatel::SolutionType::NARROWLANE:
        case novatel::SolutionType::L1_INT:
        case novatel::SolutionType::WIDE_INT:
        case novatel::SolutionType::NARROW_INT:
        case novatel::SolutionType::INS_RTKFIXED:
            _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_INTEGER);
            break;
        case novatel::SolutionType::OMNISTAR:
        case novatel::SolutionType::INS_OMNISTAR:
        case novatel::SolutionType::INS_OMNISTAR_HP:
        case novatel::SolutionType::INS_OMNISTAR_XP:
        case novatel::SolutionType::OMNISTAR_HP:
        case novatel::SolutionType::OMNISTAR_XP:
        case novatel::SolutionType::PPP_CONVERGING:
        case novatel::SolutionType::PPP:
        case novatel::SolutionType::INS_PPP_CONVERGING:
        case novatel::SolutionType::INS_PPP:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PPP);
            break;
        case novatel::SolutionType::PROPOGATED:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PROPAGATED);
            break;
        default:
            _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
        }
    } else {
        _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
        _gnss.set_position_type(0);
    }
    if (pos-&gt;datum_id != novatel::DatumId::WGS84) {
        ROS_ERROR_STREAM_THROTTLE(5, "Unexpected Datum Id: " &lt;&lt; static_cast&lt;int&gt;(pos-&gt;datum_id));
    }

    double seconds = gps_week * SECONDS_PER_WEEK + gps_millisecs * 1e-3;
    if (_gnss.measurement_time() != seconds) {
        _gnss.set_measurement_time(seconds);
        return false;
    }
    return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(346, 0)" endLine="(423, 1)" clone_start="50" clone_end="58">
			<code function_name="NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs)">bool NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs) {
    _gnss.mutable_position()-&gt;set_lon(pos-&gt;longitude);
    _gnss.mutable_position()-&gt;set_lat(pos-&gt;latitude);
    _gnss.mutable_position()-&gt;set_height(pos-&gt;height_msl + pos-&gt;undulation);
    _gnss.mutable_position_std_dev()-&gt;set_x(pos-&gt;longitude_std_dev);
    _gnss.mutable_position_std_dev()-&gt;set_y(pos-&gt;latitude_std_dev);
    _gnss.mutable_position_std_dev()-&gt;set_z(pos-&gt;height_std_dev);
    _gnss.set_num_sats(pos-&gt;num_sats_in_solution);
    if (_solution_status != pos-&gt;solution_status) {
        _solution_status = pos-&gt;solution_status;
        ROS_INFO_STREAM("Solution status: " &lt;&lt; static_cast&lt;int&gt;(_solution_status));
    }
    if (_position_type != pos-&gt;position_type) {
        _position_type = pos-&gt;position_type;
        ROS_INFO_STREAM("Position type: " &lt;&lt; static_cast&lt;int&gt;(_position_type));
    }
    _gnss.set_solution_status(static_cast&lt;uint32_t&gt;(pos-&gt;solution_status));
    if (pos-&gt;solution_status == novatel::SolutionStatus::SOL_COMPUTED) {
        _gnss.set_position_type(static_cast&lt;uint32_t&gt;(pos-&gt;position_type));
        switch (pos-&gt;position_type) {
        case novatel::SolutionType::SINGLE:
        case novatel::SolutionType::INS_PSRSP:
            _gnss.set_type(apollo::drivers::gnss::Gnss::SINGLE);
            break;
        case novatel::SolutionType::PSRDIFF:
        case novatel::SolutionType::WAAS:
        case novatel::SolutionType::INS_SBAS:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PSRDIFF);
            break;
        case novatel::SolutionType::FLOATCONV:
        case novatel::SolutionType::L1_FLOAT:
        case novatel::SolutionType::IONOFREE_FLOAT:
        case novatel::SolutionType::NARROW_FLOAT:
        case novatel::SolutionType::RTK_DIRECT_INS:
        case novatel::SolutionType::INS_RTKFLOAT:
            _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_FLOAT);
            break;
        case novatel::SolutionType::WIDELANE:
        case novatel::SolutionType::NARROWLANE:
        case novatel::SolutionType::L1_INT:
        case novatel::SolutionType::WIDE_INT:
        case novatel::SolutionType::NARROW_INT:
        case novatel::SolutionType::INS_RTKFIXED:
            _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_INTEGER);
            break;
        case novatel::SolutionType::OMNISTAR:
        case novatel::SolutionType::INS_OMNISTAR:
        case novatel::SolutionType::INS_OMNISTAR_HP:
        case novatel::SolutionType::INS_OMNISTAR_XP:
        case novatel::SolutionType::OMNISTAR_HP:
        case novatel::SolutionType::OMNISTAR_XP:
        case novatel::SolutionType::PPP_CONVERGING:
        case novatel::SolutionType::PPP:
        case novatel::SolutionType::INS_PPP_CONVERGING:
        case novatel::SolutionType::INS_PPP:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PPP);
            break;
        case novatel::SolutionType::PROPOGATED:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PROPAGATED);
            break;
        default:
            _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
        }
    } else {
        _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
        _gnss.set_position_type(0);
    }
    if (pos-&gt;datum_id != novatel::DatumId::WGS84) {
        ROS_ERROR_STREAM_THROTTLE(5, "Unexpected Datum Id: " &lt;&lt; static_cast&lt;int&gt;(pos-&gt;datum_id));
    }

    double seconds = gps_week * SECONDS_PER_WEEK + gps_millisecs * 1e-3;
    if (_gnss.measurement_time() != seconds) {
        _gnss.set_measurement_time(seconds);
        return false;
    }
    return true;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(28, 0)" endLine="(31, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle62::GetPeriod() const">uint32_t Throttle62::GetPeriod() const {
  static const uint32_t PERIOD = 20 * 1000;
  return PERIOD;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(26, 0)" endLine="(31, 1)" clone_start="1" clone_end="6">
			<code function_name="Steering64::GetPeriod() const">uint32_t Steering64::GetPeriod() const {
  // receive rate??
  // receive timeout would trigger fault, letting en=0 and etc.
  static const uint32_t PERIOD = 20 * 1000;
  return PERIOD;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(27, 0)" endLine="(30, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake60::GetPeriod() const">uint32_t Brake60::GetPeriod() const {
  static const uint32_t PERIOD = 20 * 1000;
  return PERIOD;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(33, 0)" endLine="(39, 1)" clone_start="1" clone_end="6">
			<code function_name="Throttle62::UpdateData(uint8_t* data)">void Throttle62::UpdateData(uint8_t* data) {
  set_pedal_p(data, pedal_cmd_);
  set_enable_p(data, pedal_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_ignore_driver_override_p(data, ignore_driver_override_);
  set_watchdog_counter_p(data, watchdog_counter_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(33, 0)" endLine="(41, 1)" clone_start="1" clone_end="6">
			<code function_name="Steering64::UpdateData(uint8_t* data)">void Steering64::UpdateData(uint8_t* data) {
  set_steering_angle_p(data, steering_angle_);
  set_enable_p(data, steering_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_ignore_driver_override_p(data, ignore_driver_override_);
  set_steering_angle_speed_p(data, steering_angle_speed_);
  set_watchdog_counter_p(data, watchdog_counter_);
  set_disable_audible_warning_p(data, disable_audible_warning_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(32, 0)" endLine="(38, 1)" clone_start="1" clone_end="6">
			<code function_name="Brake60::UpdateData(uint8_t* data)">void Brake60::UpdateData(uint8_t* data) {
  set_pedal_p(data, pedal_cmd_);
  set_boo_cmd_p(data, boo_cmd_);
  set_enable_p(data, pedal_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_watchdog_counter_p(data, watchdog_counter_);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(26, 0)" endLine="(33, 1)" clone_start="1" clone_end="8">
			<code function_name="Throttleinfo75::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Throttleinfo75::Parse(const std::uint8_t* bytes, int32_t length,
                           ChassisDetail* car_status) const {
  car_status-&gt;mutable_ems()-&gt;set_engine_rpm(engine_rpm(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_accelerator_pedal(
      acc_pedal_percent(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_accelerator_pedal_rate(
      acc_pedal_rate(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6d.cc" startLine="(26, 0)" endLine="(31, 1)" clone_start="1" clone_end="6">
			<code function_name="Gps6d::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Gps6d::Parse(const std::uint8_t* bytes, int32_t length,
                  ChassisDetail* car_status) const {
  car_status-&gt;mutable_basic()-&gt;set_latitude(latitude(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_longitude(longitude(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_gps_valid(is_valid(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(26, 0)" endLine="(34, 1)" clone_start="1" clone_end="9">
			<code function_name="Accel6b::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* chassis_detail) const">void Accel6b::Parse(const std::uint8_t* bytes, int32_t length,
                    ChassisDetail* chassis_detail) const {
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_lat_acc(
      lateral_acceleration(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_long_acc(
      longitudinal_acceleration(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_vert_acc(
      vertical_acceleration(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(35, 0)" endLine="(43, 1)" clone_start="1" clone_end="6">
			<code function_name="Throttleinfo75::engine_rpm(const std::uint8_t* bytes, int32_t length) const">double Throttleinfo75::engine_rpm(const std::uint8_t* bytes,
                                  int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.25;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6d.cc" startLine="(33, 0)" endLine="(57, 1)" clone_start="1" clone_end="6">
			<code function_name="Gps6d::latitude(const std::uint8_t* bytes, int32_t length) const">double Gps6d::latitude(const std::uint8_t* bytes, int32_t length) const {
  Byte frame_0(bytes + 3);
  int32_t value = frame_0.get_byte(0, 7);

  Byte frame_1(bytes + 2);
  int32_t t = frame_1.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_2(bytes + 1);
  t = frame_2.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_3(bytes + 0);
  t = frame_3.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  if (value &gt; 0x3FFFFFFF) {
    value -= 0x80000000;
  }

  return value * (1.000000 / 3.000000) * 1e-6;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(36, 0)" endLine="(47, 1)" clone_start="1" clone_end="6">
			<code function_name="Accel6b::lateral_acceleration(const std::uint8_t* bytes, int32_t length) const">double Accel6b::lateral_acceleration(const std::uint8_t* bytes,
                                     int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.010000;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(26, 0)" endLine="(48, 1)" clone_start="5" clone_end="21">
			<code function_name="Throttle63::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Throttle63::Parse(const std::uint8_t* bytes, int32_t length,
                       ChassisDetail* car_status) const {
  car_status-&gt;mutable_gas()-&gt;set_throttle_input(pedal_input(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_throttle_cmd(pedal_cmd(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_throttle_output(pedal_output(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_throttle_enabled(is_enabled(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  car_status-&gt;mutable_check_response()-&gt;set_is_vcu_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(26, 0)" endLine="(55, 1)" clone_start="11" clone_end="28">
			<code function_name="Brake61::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Brake61::Parse(const std::uint8_t* bytes, int32_t length,
                    ChassisDetail* car_status) const {
  car_status-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_output(pedal_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  car_status-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(26, 0)" endLine="(63, 1)" clone_start="20" clone_end="36">
			<code function_name="Steering65::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Steering65::Parse(const std::uint8_t* bytes, int32_t length,
                       ChassisDetail* car_status) const {
  car_status-&gt;mutable_eps()-&gt;set_steering_angle(steering_angle(bytes, length));
  // no steering angle speed

  car_status-&gt;mutable_eps()-&gt;set_steering_angle_cmd(
      reported_steering_angle_cmd(bytes, length));
  // ?
  car_status-&gt;mutable_eps()-&gt;set_is_steering_angle_valid(true);
  // vehicle speed from steering, kph -&gt; mps
  car_status-&gt;mutable_eps()-&gt;set_vehicle_speed(vehicle_speed(bytes, length) /
                                               3.6);

  // speed, as it has a higher accuracy
  // kph -&gt; mps
  car_status-&gt;mutable_vehicle_spd()-&gt;set_vehicle_spd(
      vehicle_speed(bytes, length) / 3.6);
  car_status-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_spd_valid(true);

  car_status-&gt;mutable_eps()-&gt;set_epas_torque(epas_torque(bytes, length));
  car_status-&gt;mutable_eps()-&gt;set_steering_enabled(is_enabled(bytes, length));
  car_status-&gt;mutable_eps()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  car_status-&gt;mutable_eps()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  car_status-&gt;mutable_eps()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  car_status-&gt;mutable_eps()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  car_status-&gt;mutable_eps()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  car_status-&gt;mutable_eps()-&gt;set_calibration_fault(
      is_calibration_fault(bytes, length));
  car_status-&gt;mutable_eps()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  car_status-&gt;mutable_check_response()-&gt;set_is_eps_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(131, 0)" endLine="(135, 1)" clone_start="1" clone_end="5">
			<code function_name="Steering64::set_watchdog_counter_p(uint8_t* data, int32_t count)">void Steering64::set_watchdog_counter_p(uint8_t* data, int32_t count) {
  count = ProtocolData::BoundedValue(0, 255, count);
  Byte frame(data + 7);
  frame.set_value(count, 0, 8);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(74, 0)" endLine="(78, 1)" clone_start="1" clone_end="5">
			<code function_name="Gear66::set_gear_p(uint8_t* data, int32_t gear)">void Gear66::set_gear_p(uint8_t* data, int32_t gear) {
  gear = ProtocolData::BoundedValue(0, 5, gear);
  Byte frame(data + 0);
  frame.set_value(gear, 0, 3);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(137, 0)" endLine="(144, 1)" clone_start="1" clone_end="6">
			<code function_name="Steering64::set_disable_audible_warning_p(uint8_t* data, bool disable)">void Steering64::set_disable_audible_warning_p(uint8_t* data, bool disable) {
  Byte frame(data + 2);
  if (disable) {
    frame.set_bit_1(4);
  } else {
    frame.set_bit_0(4);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(80, 0)" endLine="(87, 1)" clone_start="1" clone_end="6">
			<code function_name="Gear66::set_clear_driver_override_flag_p(uint8_t* bytes, bool clear)">void Gear66::set_clear_driver_override_flag_p(uint8_t* bytes, bool clear) {
  Byte frame(bytes + 0);
  if (clear) {
    frame.set_bit_1(7);
  } else {
    frame.set_bit_0(7);
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(476, 0)" endLine="(513, 1)" clone_start="16" clone_end="25">
			<code function_name="NovatelParser::handle_ins_pva(const novatel::InsPva* pva)">bool NovatelParser::handle_ins_pva(const novatel::InsPva* pva) {
    if (_ins_status != pva-&gt;status) {
        _ins_status = pva-&gt;status;
        ROS_INFO_STREAM("INS status: " &lt;&lt; static_cast&lt;int&gt;(_ins_status));
    }
    _ins.mutable_position()-&gt;set_lon(pva-&gt;longitude);
    _ins.mutable_position()-&gt;set_lat(pva-&gt;latitude);
    _ins.mutable_position()-&gt;set_height(pva-&gt;height);
    _ins.mutable_euler_angles()-&gt;set_x(pva-&gt;roll * DEG_TO_RAD);
    _ins.mutable_euler_angles()-&gt;set_y(-pva-&gt;pitch * DEG_TO_RAD);
    _ins.mutable_euler_angles()-&gt;set_z(azimuth_deg_to_yaw_rad(pva-&gt;azimuth));
    _ins.mutable_linear_velocity()-&gt;set_x(pva-&gt;east_velocity);
    _ins.mutable_linear_velocity()-&gt;set_y(pva-&gt;north_velocity);
    _ins.mutable_linear_velocity()-&gt;set_z(pva-&gt;up_velocity);

    switch (pva-&gt;status) {
    case novatel::InsStatus::ALIGNMENT_COMPLETE:
    case novatel::InsStatus::SOLUTION_GOOD:
        _ins.set_type(apollo::drivers::gnss::Ins::GOOD);
        break;
    case novatel::InsStatus::ALIGNING:
    case novatel::InsStatus::HIGH_VARIANCE:
    case novatel::InsStatus::SOLUTION_FREE:
        _ins.set_type(apollo::drivers::gnss::Ins::CONVERGING);
        break;
    default:
        _ins.set_type(apollo::drivers::gnss::Ins::INVALID);
    }

    double seconds = pva-&gt;gps_week * SECONDS_PER_WEEK + pva-&gt;gps_seconds;
    if (_ins.measurement_time() != seconds) {
        _ins.set_measurement_time(seconds);
        return false;
    }

    _ins.mutable_header()-&gt;set_timestamp_sec(ros::Time::now().toSec());
    return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(346, 0)" endLine="(423, 1)" clone_start="20" clone_end="29">
			<code function_name="NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs)">bool NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs) {
    _gnss.mutable_position()-&gt;set_lon(pos-&gt;longitude);
    _gnss.mutable_position()-&gt;set_lat(pos-&gt;latitude);
    _gnss.mutable_position()-&gt;set_height(pos-&gt;height_msl + pos-&gt;undulation);
    _gnss.mutable_position_std_dev()-&gt;set_x(pos-&gt;longitude_std_dev);
    _gnss.mutable_position_std_dev()-&gt;set_y(pos-&gt;latitude_std_dev);
    _gnss.mutable_position_std_dev()-&gt;set_z(pos-&gt;height_std_dev);
    _gnss.set_num_sats(pos-&gt;num_sats_in_solution);
    if (_solution_status != pos-&gt;solution_status) {
        _solution_status = pos-&gt;solution_status;
        ROS_INFO_STREAM("Solution status: " &lt;&lt; static_cast&lt;int&gt;(_solution_status));
    }
    if (_position_type != pos-&gt;position_type) {
        _position_type = pos-&gt;position_type;
        ROS_INFO_STREAM("Position type: " &lt;&lt; static_cast&lt;int&gt;(_position_type));
    }
    _gnss.set_solution_status(static_cast&lt;uint32_t&gt;(pos-&gt;solution_status));
    if (pos-&gt;solution_status == novatel::SolutionStatus::SOL_COMPUTED) {
        _gnss.set_position_type(static_cast&lt;uint32_t&gt;(pos-&gt;position_type));
        switch (pos-&gt;position_type) {
        case novatel::SolutionType::SINGLE:
        case novatel::SolutionType::INS_PSRSP:
            _gnss.set_type(apollo::drivers::gnss::Gnss::SINGLE);
            break;
        case novatel::SolutionType::PSRDIFF:
        case novatel::SolutionType::WAAS:
        case novatel::SolutionType::INS_SBAS:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PSRDIFF);
            break;
        case novatel::SolutionType::FLOATCONV:
        case novatel::SolutionType::L1_FLOAT:
        case novatel::SolutionType::IONOFREE_FLOAT:
        case novatel::SolutionType::NARROW_FLOAT:
        case novatel::SolutionType::RTK_DIRECT_INS:
        case novatel::SolutionType::INS_RTKFLOAT:
            _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_FLOAT);
            break;
        case novatel::SolutionType::WIDELANE:
        case novatel::SolutionType::NARROWLANE:
        case novatel::SolutionType::L1_INT:
        case novatel::SolutionType::WIDE_INT:
        case novatel::SolutionType::NARROW_INT:
        case novatel::SolutionType::INS_RTKFIXED:
            _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_INTEGER);
            break;
        case novatel::SolutionType::OMNISTAR:
        case novatel::SolutionType::INS_OMNISTAR:
        case novatel::SolutionType::INS_OMNISTAR_HP:
        case novatel::SolutionType::INS_OMNISTAR_XP:
        case novatel::SolutionType::OMNISTAR_HP:
        case novatel::SolutionType::OMNISTAR_XP:
        case novatel::SolutionType::PPP_CONVERGING:
        case novatel::SolutionType::PPP:
        case novatel::SolutionType::INS_PPP_CONVERGING:
        case novatel::SolutionType::INS_PPP:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PPP);
            break;
        case novatel::SolutionType::PROPOGATED:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PROPAGATED);
            break;
        default:
            _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
        }
    } else {
        _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
        _gnss.set_position_type(0);
    }
    if (pos-&gt;datum_id != novatel::DatumId::WGS84) {
        ROS_ERROR_STREAM_THROTTLE(5, "Unexpected Datum Id: " &lt;&lt; static_cast&lt;int&gt;(pos-&gt;datum_id));
    }

    double seconds = gps_week * SECONDS_PER_WEEK + gps_millisecs * 1e-3;
    if (_gnss.measurement_time() != seconds) {
        _gnss.set_measurement_time(seconds);
        return false;
    }
    return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="115" clone_end="134">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="64" clone_end="82">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length,
                        ChassisDetail* chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(26, 0)" endLine="(63, 1)" clone_start="18" clone_end="34">
			<code function_name="Steering65::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Steering65::Parse(const std::uint8_t* bytes, int32_t length,
                       ChassisDetail* car_status) const {
  car_status-&gt;mutable_eps()-&gt;set_steering_angle(steering_angle(bytes, length));
  // no steering angle speed

  car_status-&gt;mutable_eps()-&gt;set_steering_angle_cmd(
      reported_steering_angle_cmd(bytes, length));
  // ?
  car_status-&gt;mutable_eps()-&gt;set_is_steering_angle_valid(true);
  // vehicle speed from steering, kph -&gt; mps
  car_status-&gt;mutable_eps()-&gt;set_vehicle_speed(vehicle_speed(bytes, length) /
                                               3.6);

  // speed, as it has a higher accuracy
  // kph -&gt; mps
  car_status-&gt;mutable_vehicle_spd()-&gt;set_vehicle_spd(
      vehicle_speed(bytes, length) / 3.6);
  car_status-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_spd_valid(true);

  car_status-&gt;mutable_eps()-&gt;set_epas_torque(epas_torque(bytes, length));
  car_status-&gt;mutable_eps()-&gt;set_steering_enabled(is_enabled(bytes, length));
  car_status-&gt;mutable_eps()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  car_status-&gt;mutable_eps()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  car_status-&gt;mutable_eps()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  car_status-&gt;mutable_eps()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  car_status-&gt;mutable_eps()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  car_status-&gt;mutable_eps()-&gt;set_calibration_fault(
      is_calibration_fault(bytes, length));
  car_status-&gt;mutable_eps()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  car_status-&gt;mutable_check_response()-&gt;set_is_eps_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="148" clone_end="171">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\aabox2d.cc" startLine="(135, 0)" endLine="(145, 1)" clone_start="1" clone_end="10">
			<code function_name="AABox2d::MergeFrom(const Vec2d&amp; other_point)">void AABox2d::MergeFrom(const Vec2d&amp; other_point) {
  const double x1 = std::min(min_x(), other_point.x());
  const double x2 = std::max(max_x(), other_point.x());
  const double y1 = std::min(min_y(), other_point.y());
  const double y2 = std::max(max_y(), other_point.y());
  center_ = Vec2d((x1 + x2) / 2.0, (y1 + y2) / 2.0);
  length_ = x2 - x1;
  width_ = y2 - y1;
  half_length_ = length_ / 2.0;
  half_width_ = width_ / 2.0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\math\aabox2d.cc" startLine="(123, 0)" endLine="(133, 1)" clone_start="1" clone_end="10">
			<code function_name="AABox2d::MergeFrom(const AABox2d&amp; other_box)">void AABox2d::MergeFrom(const AABox2d&amp; other_box) {
  const double x1 = std::min(min_x(), other_box.min_x());
  const double x2 = std::max(max_x(), other_box.max_x());
  const double y1 = std::min(min_y(), other_box.min_y());
  const double y2 = std::max(max_y(), other_box.max_y());
  center_ = Vec2d((x1 + x2) / 2.0, (y1 + y2) / 2.0);
  length_ = x2 - x1;
  width_ = y2 - y1;
  half_length_ = length_ / 2.0;
  half_width_ = width_ / 2.0;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(26, 0)" endLine="(34, 1)" clone_start="7" clone_end="9">
			<code function_name="Accel6b::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* chassis_detail) const">void Accel6b::Parse(const std::uint8_t* bytes, int32_t length,
                    ChassisDetail* chassis_detail) const {
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_lat_acc(
      lateral_acceleration(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_long_acc(
      longitudinal_acceleration(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_vert_acc(
      vertical_acceleration(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(26, 0)" endLine="(50, 1)" clone_start="23" clone_end="25">
			<code function_name="Gps6f::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Gps6f::Parse(const std::uint8_t* bytes, int32_t length,
                  ChassisDetail* car_status) const {
  car_status-&gt;mutable_basic()-&gt;set_altitude(altitude(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_heading(heading(bytes, length));
  // speed mph -&gt; mps
  car_status-&gt;mutable_basic()-&gt;set_gps_speed(speed(bytes, length) * 0.44704);
  car_status-&gt;mutable_basic()-&gt;set_hdop(hdop(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_vdop(vdop(bytes, length));
  switch (fix_quality(bytes, length)) {
    case 0:
      car_status-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_NO);
      break;
    case 1:
      car_status-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_2D);
      break;
    case 2:
      car_status-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_3D);
      break;
    default:
      car_status-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_INVALID);
      break;
  }
  car_status-&gt;mutable_basic()-&gt;set_num_satellites(
      num_satellites(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\fuellevel_72.cc" startLine="(26, 0)" endLine="(29, 1)" clone_start="3" clone_end="4">
			<code function_name="Fuellevel72::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Fuellevel72::Parse(const std::uint8_t* bytes, int32_t length,
                        ChassisDetail* car_status) const {
  car_status-&gt;mutable_battery()-&gt;set_fuel_level(fuel_level(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(36, 0)" endLine="(47, 1)" clone_start="1" clone_end="11">
			<code function_name="Accel6b::lateral_acceleration(const std::uint8_t* bytes, int32_t length) const">double Accel6b::lateral_acceleration(const std::uint8_t* bytes,
                                     int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(52, 0)" endLine="(62, 1)" clone_start="1" clone_end="10">
			<code function_name="Gps6f::altitude(const std::uint8_t* bytes, int32_t length) const">double Gps6f::altitude(const std::uint8_t* bytes, int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.250000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\fuellevel_72.cc" startLine="(31, 0)" endLine="(45, 1)" clone_start="1" clone_end="14">
			<code function_name="Fuellevel72::fuel_level(const std::uint8_t* bytes, int32_t length) const">double Fuellevel72::fuel_level(const std::uint8_t* bytes,
                               int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  // should be in range of
  // [0x0000, 0x0398]
  // or [0xfc68, 0xffff]
  return value * 0.108696;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\version_7f.cc" startLine="(26, 0)" endLine="(54, 1)" clone_start="4" clone_end="18">
			<code function_name="Version7f::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Version7f::Parse(const std::uint8_t* bytes, int32_t length,
                      ChassisDetail* car_status) const {
  switch (module_name(bytes, length)) {
    case 0x01:
      car_status-&gt;mutable_brake()-&gt;set_major_version(
          major_version(bytes, length));
      car_status-&gt;mutable_brake()-&gt;set_minor_version(
          minor_version(bytes, length));
      car_status-&gt;mutable_brake()-&gt;set_build_number(
          build_number(bytes, length));
      break;
    case 0x02:
      car_status-&gt;mutable_gas()-&gt;set_major_version(
          major_version(bytes, length));
      car_status-&gt;mutable_gas()-&gt;set_minor_version(
          minor_version(bytes, length));
      car_status-&gt;mutable_gas()-&gt;set_build_number(build_number(bytes, length));
      break;
    case 0x03:
      car_status-&gt;mutable_eps()-&gt;set_major_version(
          major_version(bytes, length));
      car_status-&gt;mutable_eps()-&gt;set_minor_version(
          minor_version(bytes, length));
      car_status-&gt;mutable_eps()-&gt;set_build_number(build_number(bytes, length));
      break;
    default:
      break;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\version_7f.cc" startLine="(26, 0)" endLine="(54, 1)" clone_start="12" clone_end="25">
			<code function_name="Version7f::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Version7f::Parse(const std::uint8_t* bytes, int32_t length,
                      ChassisDetail* car_status) const {
  switch (module_name(bytes, length)) {
    case 0x01:
      car_status-&gt;mutable_brake()-&gt;set_major_version(
          major_version(bytes, length));
      car_status-&gt;mutable_brake()-&gt;set_minor_version(
          minor_version(bytes, length));
      car_status-&gt;mutable_brake()-&gt;set_build_number(
          build_number(bytes, length));
      break;
    case 0x02:
      car_status-&gt;mutable_gas()-&gt;set_major_version(
          major_version(bytes, length));
      car_status-&gt;mutable_gas()-&gt;set_minor_version(
          minor_version(bytes, length));
      car_status-&gt;mutable_gas()-&gt;set_build_number(build_number(bytes, length));
      break;
    case 0x03:
      car_status-&gt;mutable_eps()-&gt;set_major_version(
          major_version(bytes, length));
      car_status-&gt;mutable_eps()-&gt;set_minor_version(
          minor_version(bytes, length));
      car_status-&gt;mutable_eps()-&gt;set_build_number(build_number(bytes, length));
      break;
    default:
      break;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(49, 0)" endLine="(57, 1)" clone_start="8" clone_end="9">
			<code function_name="Brake60::set_pedal(double pedal)">Brake60* Brake60::set_pedal(double pedal) {
  pedal_cmd_ = pedal;
  if (pedal_cmd_ &lt; 1e-3) {
    disable_boo_cmd();
  } else {
    enable_boo_cmd();
  }
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(59, 0)" endLine="(62, 1)" clone_start="3" clone_end="4">
			<code function_name="Brake60::enable_boo_cmd()">Brake60* Brake60::enable_boo_cmd() {
  boo_cmd_ = true;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(59, 0)" endLine="(62, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake60::enable_boo_cmd()">Brake60* Brake60::enable_boo_cmd() {
  boo_cmd_ = true;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(64, 0)" endLine="(67, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake60::disable_boo_cmd()">Brake60* Brake60::disable_boo_cmd() {
  boo_cmd_ = false;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(64, 0)" endLine="(67, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake60::disable_boo_cmd()">Brake60* Brake60::disable_boo_cmd() {
  boo_cmd_ = false;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(69, 0)" endLine="(72, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake60::set_enable()">Brake60* Brake60::set_enable() {
  pedal_enable_ = true;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(69, 0)" endLine="(72, 1)" clone_start="1" clone_end="3">
			<code function_name="Brake60::set_enable()">Brake60* Brake60::set_enable() {
  pedal_enable_ = true;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(74, 0)" endLine="(77, 1)" clone_start="1" clone_end="3">
			<code function_name="Brake60::set_disable()">Brake60* Brake60::set_disable() {
  pedal_enable_ = false;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(378, 0)" endLine="(407, 1)" clone_start="5" clone_end="16">
			<code function_name="RawStream::stream_status_check()">void RawStream::stream_status_check() {
    bool status_report = false;
    apollo::common::gnss_status::StreamStatus_Type report_stream_status;

    if (_data_stream &amp;&amp; (_data_stream-&gt;get_status() != _data_stream_status-&gt;status)) {
        _data_stream_status-&gt;status = _data_stream-&gt;get_status();
        status_report = true;
        switch_stream_status(_data_stream_status-&gt;status, report_stream_status);
        _stream_status-&gt;set_ins_stream_type(report_stream_status);
    }

    if (_in_rtk_stream &amp;&amp; (_in_rtk_stream-&gt;get_status() != _in_rtk_stream_status-&gt;status)) {
        _in_rtk_stream_status-&gt;status = _in_rtk_stream-&gt;get_status();
        status_report = true;
        switch_stream_status(_in_rtk_stream_status-&gt;status, report_stream_status);
        _stream_status-&gt;set_rtk_stream_in_type(report_stream_status);
    }

    if (_out_rtk_stream &amp;&amp; (_out_rtk_stream-&gt;get_status() != _out_rtk_stream_status-&gt;status)) {
        _out_rtk_stream_status-&gt;status = _out_rtk_stream-&gt;get_status();
        status_report = true;
        switch_stream_status(_out_rtk_stream_status-&gt;status, report_stream_status);
        _stream_status-&gt;set_rtk_stream_out_type(report_stream_status);
    }

    if (status_report) {
        _stream_status-&gt;mutable_header()-&gt;set_timestamp_sec(ros::Time::now().toSec());
        _stream_status_publisher.publish(_stream_status);
    }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(378, 0)" endLine="(407, 1)" clone_start="12" clone_end="23">
			<code function_name="RawStream::stream_status_check()">void RawStream::stream_status_check() {
    bool status_report = false;
    apollo::common::gnss_status::StreamStatus_Type report_stream_status;

    if (_data_stream &amp;&amp; (_data_stream-&gt;get_status() != _data_stream_status-&gt;status)) {
        _data_stream_status-&gt;status = _data_stream-&gt;get_status();
        status_report = true;
        switch_stream_status(_data_stream_status-&gt;status, report_stream_status);
        _stream_status-&gt;set_ins_stream_type(report_stream_status);
    }

    if (_in_rtk_stream &amp;&amp; (_in_rtk_stream-&gt;get_status() != _in_rtk_stream_status-&gt;status)) {
        _in_rtk_stream_status-&gt;status = _in_rtk_stream-&gt;get_status();
        status_report = true;
        switch_stream_status(_in_rtk_stream_status-&gt;status, report_stream_status);
        _stream_status-&gt;set_rtk_stream_in_type(report_stream_status);
    }

    if (_out_rtk_stream &amp;&amp; (_out_rtk_stream-&gt;get_status() != _out_rtk_stream_status-&gt;status)) {
        _out_rtk_stream_status-&gt;status = _out_rtk_stream-&gt;get_status();
        status_report = true;
        switch_stream_status(_out_rtk_stream_status-&gt;status, report_stream_status);
        _stream_status-&gt;set_rtk_stream_out_type(report_stream_status);
    }

    if (status_report) {
        _stream_status-&gt;mutable_header()-&gt;set_timestamp_sec(ros::Time::now().toSec());
        _stream_status_publisher.publish(_stream_status);
    }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(113, 0)" endLine="(117, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_watchdog_counter_applying_brakes(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_watchdog_counter_applying_brakes(const std::uint8_t* bytes,
                                                  int32_t length) const {
  Byte frame(bytes + 6);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(97, 0)" endLine="(101, 1)" clone_start="1" clone_end="5">
			<code function_name="Gear67::is_driver_override(const std::uint8_t* bytes, int32_t length) const">bool Gear67::is_driver_override(const std::uint8_t* bytes,
                                int32_t length) const {
  Byte frame(bytes + 0);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(119, 0)" endLine="(125, 1)" clone_start="1" clone_end="7">
			<code function_name="Brake61::watchdog_counter_source(const std::uint8_t* bytes, int32_t length) const">int32_t Brake61::watchdog_counter_source(const std::uint8_t* bytes,
                                         int32_t length) const {
  // see table for status code
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(103, 0)" endLine="(108, 1)" clone_start="1" clone_end="6">
			<code function_name="Gear67::reported_gear_cmd(const std::uint8_t* bytes, int32_t length) const">int32_t Gear67::reported_gear_cmd(const std::uint8_t* bytes,
                                  int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(4, 3);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(127, 0)" endLine="(130, 1)" clone_start="1" clone_end="3">
			<code function_name="Brake61::is_enabled(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_enabled(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(110, 0)" endLine="(113, 1)" clone_start="1" clone_end="3">
			<code function_name="Gear67::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const">bool Gear67::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 0);
  return frame.is_bit_1(7);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(91, 0)" endLine="(95, 1)" clone_start="1" clone_end="5">
			<code function_name="Gear67::gear_state(const std::uint8_t* bytes, int32_t length) const">int32_t Gear67::gear_state(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(121, 0)" endLine="(127, 1)" clone_start="1" clone_end="7">
			<code function_name="Brakeinfo74::hill_start_assist_status(const std::uint8_t* bytes, int32_t length) const">int32_t Brakeinfo74::hill_start_assist_status(const std::uint8_t* bytes,
                                              int32_t length) const {
  // see table for status code
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(4, 3);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(97, 0)" endLine="(101, 1)" clone_start="1" clone_end="5">
			<code function_name="Gear67::is_driver_override(const std::uint8_t* bytes, int32_t length) const">bool Gear67::is_driver_override(const std::uint8_t* bytes,
                                int32_t length) const {
  Byte frame(bytes + 0);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(129, 0)" endLine="(134, 1)" clone_start="1" clone_end="6">
			<code function_name="Brakeinfo74::is_vehicle_stationary(const std::uint8_t* bytes, int32_t length) const">bool Brakeinfo74::is_vehicle_stationary(const std::uint8_t* bytes,
                                        int32_t length) const {
  // false for moving, true for stationary
  Byte frame(bytes + 1);
  return frame.is_bit_1(7);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(103, 0)" endLine="(108, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear67::reported_gear_cmd(const std::uint8_t* bytes, int32_t length) const">int32_t Gear67::reported_gear_cmd(const std::uint8_t* bytes,
                                  int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(4, 3);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(136, 0)" endLine="(144, 1)" clone_start="1" clone_end="4">
			<code function_name="Brakeinfo74::braking_torque_actual(const std::uint8_t* bytes, int32_t length) const">double Brakeinfo74::braking_torque_actual(const std::uint8_t* bytes,
                                          int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 4);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 4.000000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(154, 0)" endLine="(160, 1)" clone_start="1" clone_end="7">
			<code function_name="Brakeinfo74::parking_brake_status(const std::uint8_t* bytes, int32_t length) const">int32_t Brakeinfo74::parking_brake_status(const std::uint8_t* bytes,
                                          int32_t length) const {
  // see table for status code
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(6, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\version_7f.cc" startLine="(56, 0)" endLine="(61, 1)" clone_start="1" clone_end="6">
			<code function_name="Version7f::module_name(const std::uint8_t* bytes, int32_t length) const">int32_t Version7f::module_name(const std::uint8_t* bytes,
                               int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 8);
  return x;  // 0x03 means Steering/Shifter, otherwise ignore
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(162, 0)" endLine="(173, 1)" clone_start="1" clone_end="7">
			<code function_name="Brakeinfo74::wheel_torque_actual(const std::uint8_t* bytes, int32_t length) const">double Brakeinfo74::wheel_torque_actual(const std::uint8_t* bytes,
                                        int32_t length) const {
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 6);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FFF) {
    value -= 0x4000;
  }
  return value * 4.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\version_7f.cc" startLine="(63, 0)" endLine="(71, 1)" clone_start="1" clone_end="7">
			<code function_name="Version7f::major_version(const std::uint8_t* bytes, int32_t length) const">int32_t Version7f::major_version(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value;
}</code>
		</source>
	</dup>
	<dup count="5">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(73, 0)" endLine="(81, 1)" clone_start="8" clone_end="9">
			<code function_name="Wheelspeed6a::front_right_wheel_speed(const std::uint8_t* bytes, int32_t length) const">double Wheelspeed6a::front_right_wheel_speed(const std::uint8_t* bytes,
                                             int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(63, 0)" endLine="(71, 1)" clone_start="8" clone_end="9">
			<code function_name="Wheelspeed6a::front_left_wheel_speed(const std::uint8_t* bytes, int32_t length) const">double Wheelspeed6a::front_left_wheel_speed(const std::uint8_t* bytes,
                                            int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(52, 0)" endLine="(62, 1)" clone_start="10" clone_end="11">
			<code function_name="Gps6f::altitude(const std::uint8_t* bytes, int32_t length) const">double Gps6f::altitude(const std::uint8_t* bytes, int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.250000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(87, 0)" endLine="(99, 1)" clone_start="12" clone_end="13">
			<code function_name="Steering65::reported_steering_angle_cmd(const std::uint8_t* bytes, int32_t length) const">double Steering65::reported_steering_angle_cmd(const std::uint8_t* bytes,
                                               int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x8000) {
    value = value - 0x10000;
  }

  return value * 0.100000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(35, 0)" endLine="(43, 1)" clone_start="8" clone_end="9">
			<code function_name="Throttleinfo75::engine_rpm(const std::uint8_t* bytes, int32_t length) const">double Throttleinfo75::engine_rpm(const std::uint8_t* bytes,
                                  int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.25;
}</code>
		</source>
	</dup>
	<dup count="5">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(83, 0)" endLine="(91, 1)" clone_start="1" clone_end="9">
			<code function_name="Wheelspeed6a::rear_left_wheel_speed(const std::uint8_t* bytes, int32_t length) const">double Wheelspeed6a::rear_left_wheel_speed(const std::uint8_t* bytes,
                                           int32_t length) const {
  Byte high_frame(bytes + 5);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 4);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(73, 0)" endLine="(81, 1)" clone_start="1" clone_end="9">
			<code function_name="Wheelspeed6a::front_right_wheel_speed(const std::uint8_t* bytes, int32_t length) const">double Wheelspeed6a::front_right_wheel_speed(const std::uint8_t* bytes,
                                             int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(64, 0)" endLine="(71, 1)" clone_start="1" clone_end="8">
			<code function_name="Gps6f::heading(const std::uint8_t* bytes, int32_t length) const">double Gps6f::heading(const std::uint8_t* bytes, int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(101, 0)" endLine="(109, 1)" clone_start="1" clone_end="9">
			<code function_name="Steering65::vehicle_speed(const std::uint8_t* bytes, int32_t length) const">double Steering65::vehicle_speed(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(45, 0)" endLine="(53, 1)" clone_start="1" clone_end="9">
			<code function_name="Throttleinfo75::acc_pedal_percent(const std::uint8_t* bytes, int32_t length) const">double Throttleinfo75::acc_pedal_percent(const std::uint8_t* bytes,
                                         int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 2);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.1;
}</code>
		</source>
	</dup>
	<dup count="5">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(93, 0)" endLine="(101, 1)" clone_start="1" clone_end="4">
			<code function_name="Wheelspeed6a::rear_right_wheel_speed(const std::uint8_t* bytes, int32_t length) const">double Wheelspeed6a::rear_right_wheel_speed(const std::uint8_t* bytes,
                                            int32_t length) const {
  Byte high_frame(bytes + 7);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 6);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(83, 0)" endLine="(91, 1)" clone_start="1" clone_end="4">
			<code function_name="Wheelspeed6a::rear_left_wheel_speed(const std::uint8_t* bytes, int32_t length) const">double Wheelspeed6a::rear_left_wheel_speed(const std::uint8_t* bytes,
                                           int32_t length) const {
  Byte high_frame(bytes + 5);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 4);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(73, 0)" endLine="(77, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6f::speed(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6f::speed(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 8);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(111, 0)" endLine="(119, 1)" clone_start="1" clone_end="4">
			<code function_name="Steering65::epas_torque(const std::uint8_t* bytes, int32_t length) const">double Steering65::epas_torque(const std::uint8_t* bytes,
                               int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 8);
  if (x &gt; 0x7F) {
    x -= 0x100;
  }
  return x * 0.062500;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(55, 0)" endLine="(63, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttleinfo75::acc_pedal_rate(const std::uint8_t* bytes, int32_t length) const">double Throttleinfo75::acc_pedal_rate(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 8);
  if (x &gt; 0x3F) {
    x -= 0x100;
  }
  return x * 0.04;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(26, 0)" endLine="(34, 1)" clone_start="1" clone_end="9">
			<code function_name="Accel6b::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* chassis_detail) const">void Accel6b::Parse(const std::uint8_t* bytes, int32_t length,
                    ChassisDetail* chassis_detail) const {
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_lat_acc(
      lateral_acceleration(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_long_acc(
      longitudinal_acceleration(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_vert_acc(
      vertical_acceleration(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(26, 0)" endLine="(33, 1)" clone_start="1" clone_end="8">
			<code function_name="Throttleinfo75::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Throttleinfo75::Parse(const std::uint8_t* bytes, int32_t length,
                           ChassisDetail* car_status) const {
  car_status-&gt;mutable_ems()-&gt;set_engine_rpm(engine_rpm(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_accelerator_pedal(
      acc_pedal_percent(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_accelerator_pedal_rate(
      acc_pedal_rate(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(36, 0)" endLine="(47, 1)" clone_start="1" clone_end="7">
			<code function_name="Accel6b::lateral_acceleration(const std::uint8_t* bytes, int32_t length) const">double Accel6b::lateral_acceleration(const std::uint8_t* bytes,
                                     int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(35, 0)" endLine="(43, 1)" clone_start="1" clone_end="7">
			<code function_name="Throttleinfo75::engine_rpm(const std::uint8_t* bytes, int32_t length) const">double Throttleinfo75::engine_rpm(const std::uint8_t* bytes,
                                  int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.25;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(135, 0)" endLine="(254, 1)" clone_start="56" clone_end="69">
			<code function_name="RawStream::init(const std::string&amp; cfg_file)">bool RawStream::init(const std::string&amp; cfg_file) {
   if (!_stream_status) {
        ROS_ERROR_STREAM("New stream status failed.");
        return false;
    }
    _stream_status-&gt;mutable_header()-&gt;set_timestamp_sec(ros::Time::now().toSec());
    _stream_status-&gt;set_ins_stream_type(apollo::common::gnss_status::StreamStatus::DISCONNECTED);
    _stream_status-&gt;set_rtk_stream_in_type(apollo::common::gnss_status::StreamStatus::DISCONNECTED);
    _stream_status-&gt;set_rtk_stream_out_type(apollo::common::gnss_status::StreamStatus::DISCONNECTED);
    _stream_status_publisher.publish(_stream_status);
    if (!parse_config_text(cfg_file, &amp;_config)) {
        ROS_INFO("Parse config context failed.");
        return false;
    }
    ROS_INFO_STREAM("Loaded config:\n" &lt;&lt; _config.DebugString());

    // Creates streams.
    Stream* s = nullptr;
    if (!_config.has_data()) {
        ROS_INFO("Error: Config file must provide the data stream.");
        return false;
    }
    s = create_stream(_config.data());
    if (s == nullptr) {
        ROS_ERROR("Failed to create data stream.");
        return false;
    }
    _data_stream.reset(s);

    Status *status = new Status();
    if (!status) {
        ROS_ERROR("Failed to create data stream status.");
        return false;
    }
    _data_stream_status.reset(status);

    if (_config.has_command()) {
        s = create_stream(_config.command());
        if (s == nullptr) {
            ROS_ERROR("Failed to create command stream.");
            return false;
        }
        _command_stream.reset(s);

        status = new Status();
        if (!status) {
            ROS_ERROR("Failed to create command stream status.");
            return false;
        }
        _command_stream_status.reset(status);
    } else {
        _command_stream = _data_stream;
        _command_stream_status = _data_stream_status;
    }

    if (_config.has_rtk_from()) {
        s = create_stream(_config.rtk_from());
        if (s == nullptr) {
            ROS_ERROR("Failed to create rtk_from stream.");
            return false;
        }
        _in_rtk_stream.reset(s);

        status = new Status();
        if (!status) {
            ROS_ERROR("Failed to create rtk_from stream status.");
            return false;
        }
        _in_rtk_stream_status.reset(status);

        if (_config.has_rtk_to()) {
            s = create_stream(_config.rtk_to());
            if (s == nullptr) {
                ROS_ERROR("Failed to create rtk_to stream.");
                return false;
            }
            _out_rtk_stream.reset(s);

            status = new Status();
            if (!status) {
                ROS_ERROR("Failed to create rtk_to stream status.");
                return false;
            }
            _out_rtk_stream_status.reset(status);
        } else {
            _out_rtk_stream = _data_stream;
            _out_rtk_stream_status = _data_stream_status;
        }

        if (_config.has_rtk_solution_type()) {
            if (_config.rtk_solution_type() == config::Config::RTK_SOFTWARE_SOLUTION) {
                _rtk_software_solution = true;
            }
        }
    }

    if (_config.login_commands_size() == 0) {
        ROS_WARN("No login_commands in config file.");
    }

    if (_config.logout_commands_size() == 0) {
        ROS_WARN("No logout_commands in config file.");
    }

    // connect and login
    if (!connect()) {
        ROS_ERROR("gnss driver connect failed.");
        return false;
    }

    if (!login()) {
        ROS_ERROR("gnss driver login failed.");
        return false;
    }

    _data_thread_ptr.reset(new std::thread(&amp;RawStream::data_spin, this));
    _ntrip_thread_ptr.reset(new std::thread(&amp;RawStream::ntrip_spin, this));

    return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(135, 0)" endLine="(254, 1)" clone_start="37" clone_end="50">
			<code function_name="RawStream::init(const std::string&amp; cfg_file)">bool RawStream::init(const std::string&amp; cfg_file) {
   if (!_stream_status) {
        ROS_ERROR_STREAM("New stream status failed.");
        return false;
    }
    _stream_status-&gt;mutable_header()-&gt;set_timestamp_sec(ros::Time::now().toSec());
    _stream_status-&gt;set_ins_stream_type(apollo::common::gnss_status::StreamStatus::DISCONNECTED);
    _stream_status-&gt;set_rtk_stream_in_type(apollo::common::gnss_status::StreamStatus::DISCONNECTED);
    _stream_status-&gt;set_rtk_stream_out_type(apollo::common::gnss_status::StreamStatus::DISCONNECTED);
    _stream_status_publisher.publish(_stream_status);
    if (!parse_config_text(cfg_file, &amp;_config)) {
        ROS_INFO("Parse config context failed.");
        return false;
    }
    ROS_INFO_STREAM("Loaded config:\n" &lt;&lt; _config.DebugString());

    // Creates streams.
    Stream* s = nullptr;
    if (!_config.has_data()) {
        ROS_INFO("Error: Config file must provide the data stream.");
        return false;
    }
    s = create_stream(_config.data());
    if (s == nullptr) {
        ROS_ERROR("Failed to create data stream.");
        return false;
    }
    _data_stream.reset(s);

    Status *status = new Status();
    if (!status) {
        ROS_ERROR("Failed to create data stream status.");
        return false;
    }
    _data_stream_status.reset(status);

    if (_config.has_command()) {
        s = create_stream(_config.command());
        if (s == nullptr) {
            ROS_ERROR("Failed to create command stream.");
            return false;
        }
        _command_stream.reset(s);

        status = new Status();
        if (!status) {
            ROS_ERROR("Failed to create command stream status.");
            return false;
        }
        _command_stream_status.reset(status);
    } else {
        _command_stream = _data_stream;
        _command_stream_status = _data_stream_status;
    }

    if (_config.has_rtk_from()) {
        s = create_stream(_config.rtk_from());
        if (s == nullptr) {
            ROS_ERROR("Failed to create rtk_from stream.");
            return false;
        }
        _in_rtk_stream.reset(s);

        status = new Status();
        if (!status) {
            ROS_ERROR("Failed to create rtk_from stream status.");
            return false;
        }
        _in_rtk_stream_status.reset(status);

        if (_config.has_rtk_to()) {
            s = create_stream(_config.rtk_to());
            if (s == nullptr) {
                ROS_ERROR("Failed to create rtk_to stream.");
                return false;
            }
            _out_rtk_stream.reset(s);

            status = new Status();
            if (!status) {
                ROS_ERROR("Failed to create rtk_to stream status.");
                return false;
            }
            _out_rtk_stream_status.reset(status);
        } else {
            _out_rtk_stream = _data_stream;
            _out_rtk_stream_status = _data_stream_status;
        }

        if (_config.has_rtk_solution_type()) {
            if (_config.rtk_solution_type() == config::Config::RTK_SOFTWARE_SOLUTION) {
                _rtk_software_solution = true;
            }
        }
    }

    if (_config.login_commands_size() == 0) {
        ROS_WARN("No login_commands in config file.");
    }

    if (_config.logout_commands_size() == 0) {
        ROS_WARN("No logout_commands in config file.");
    }

    // connect and login
    if (!connect()) {
        ROS_ERROR("gnss driver connect failed.");
        return false;
    }

    if (!login()) {
        ROS_ERROR("gnss driver login failed.");
        return false;
    }

    _data_thread_ptr.reset(new std::thread(&amp;RawStream::data_spin, this));
    _ntrip_thread_ptr.reset(new std::thread(&amp;RawStream::ntrip_spin, this));

    return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(135, 0)" endLine="(254, 1)" clone_start="71" clone_end="84">
			<code function_name="RawStream::init(const std::string&amp; cfg_file)">bool RawStream::init(const std::string&amp; cfg_file) {
   if (!_stream_status) {
        ROS_ERROR_STREAM("New stream status failed.");
        return false;
    }
    _stream_status-&gt;mutable_header()-&gt;set_timestamp_sec(ros::Time::now().toSec());
    _stream_status-&gt;set_ins_stream_type(apollo::common::gnss_status::StreamStatus::DISCONNECTED);
    _stream_status-&gt;set_rtk_stream_in_type(apollo::common::gnss_status::StreamStatus::DISCONNECTED);
    _stream_status-&gt;set_rtk_stream_out_type(apollo::common::gnss_status::StreamStatus::DISCONNECTED);
    _stream_status_publisher.publish(_stream_status);
    if (!parse_config_text(cfg_file, &amp;_config)) {
        ROS_INFO("Parse config context failed.");
        return false;
    }
    ROS_INFO_STREAM("Loaded config:\n" &lt;&lt; _config.DebugString());

    // Creates streams.
    Stream* s = nullptr;
    if (!_config.has_data()) {
        ROS_INFO("Error: Config file must provide the data stream.");
        return false;
    }
    s = create_stream(_config.data());
    if (s == nullptr) {
        ROS_ERROR("Failed to create data stream.");
        return false;
    }
    _data_stream.reset(s);

    Status *status = new Status();
    if (!status) {
        ROS_ERROR("Failed to create data stream status.");
        return false;
    }
    _data_stream_status.reset(status);

    if (_config.has_command()) {
        s = create_stream(_config.command());
        if (s == nullptr) {
            ROS_ERROR("Failed to create command stream.");
            return false;
        }
        _command_stream.reset(s);

        status = new Status();
        if (!status) {
            ROS_ERROR("Failed to create command stream status.");
            return false;
        }
        _command_stream_status.reset(status);
    } else {
        _command_stream = _data_stream;
        _command_stream_status = _data_stream_status;
    }

    if (_config.has_rtk_from()) {
        s = create_stream(_config.rtk_from());
        if (s == nullptr) {
            ROS_ERROR("Failed to create rtk_from stream.");
            return false;
        }
        _in_rtk_stream.reset(s);

        status = new Status();
        if (!status) {
            ROS_ERROR("Failed to create rtk_from stream status.");
            return false;
        }
        _in_rtk_stream_status.reset(status);

        if (_config.has_rtk_to()) {
            s = create_stream(_config.rtk_to());
            if (s == nullptr) {
                ROS_ERROR("Failed to create rtk_to stream.");
                return false;
            }
            _out_rtk_stream.reset(s);

            status = new Status();
            if (!status) {
                ROS_ERROR("Failed to create rtk_to stream status.");
                return false;
            }
            _out_rtk_stream_status.reset(status);
        } else {
            _out_rtk_stream = _data_stream;
            _out_rtk_stream_status = _data_stream_status;
        }

        if (_config.has_rtk_solution_type()) {
            if (_config.rtk_solution_type() == config::Config::RTK_SOFTWARE_SOLUTION) {
                _rtk_software_solution = true;
            }
        }
    }

    if (_config.login_commands_size() == 0) {
        ROS_WARN("No login_commands in config file.");
    }

    if (_config.logout_commands_size() == 0) {
        ROS_WARN("No logout_commands in config file.");
    }

    // connect and login
    if (!connect()) {
        ROS_ERROR("gnss driver connect failed.");
        return false;
    }

    if (!login()) {
        ROS_ERROR("gnss driver login failed.");
        return false;
    }

    _data_thread_ptr.reset(new std::thread(&amp;RawStream::data_spin, this));
    _ntrip_thread_ptr.reset(new std::thread(&amp;RawStream::ntrip_spin, this));

    return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\tests\unit_test_stream.cpp" startLine="(244, 0)" endLine="(298, 1)" clone_start="3" clone_end="25">
			<code function_name="TEST(Stream, TcpUdp)">TEST(Stream, TcpUdp) {
    bool result = false;
    boost::thread thread_tcpserver(&amp;tcp_server);

    while (s_server_ready == 0) {
        ;
    }

    ::apollo::drivers::gnss::Stream *tcp_stream =
                       ::apollo::drivers::gnss::Stream::create_tcp("127.0.0.1", TCP_PORT, 1000);

    result = stream_comm_test(tcp_stream);
    EXPECT_EQ(result, true);

    // reconnect test
    result = stream_comm_test(tcp_stream);
    EXPECT_EQ(result, true);

    // timeout test
    // socket error test
    // connect shutdown test
    thread_tcpserver.join();
    delete tcp_stream;

    s_server_ready = 0;
    boost::thread thread_udpserver(&amp;udp_server);

    while (s_server_ready == 0) {
        ;
    }

    ::apollo::drivers::gnss::Stream *udp_stream =
                       ::apollo::drivers::gnss::Stream::create_udp("127.0.0.1", UDP_PORT, 1000);
    result = stream_comm_test(udp_stream);
    EXPECT_EQ(result, true);

    // reconnect test
    result = stream_comm_test(udp_stream);
    EXPECT_EQ(result, true);
    thread_udpserver.join();
    delete udp_stream;

    s_server_ready = 0;
    ::apollo::drivers::gnss::Stream *searial_stream =
                       ::apollo::drivers::gnss::Stream::create_serial(
                           FLAGS_serial_port.c_str(), ::apollo::drivers::gnss::BAUDRATE_9600, 1000);
    result = stream_comm_test(searial_stream);
    EXPECT_EQ(result, true);

    // reconnect test
    result = stream_comm_test(searial_stream);
    EXPECT_EQ(result, true);
    delete searial_stream;

}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\tests\unit_test_stream.cpp" startLine="(244, 0)" endLine="(298, 1)" clone_start="26" clone_end="43">
			<code function_name="TEST(Stream, TcpUdp)">TEST(Stream, TcpUdp) {
    bool result = false;
    boost::thread thread_tcpserver(&amp;tcp_server);

    while (s_server_ready == 0) {
        ;
    }

    ::apollo::drivers::gnss::Stream *tcp_stream =
                       ::apollo::drivers::gnss::Stream::create_tcp("127.0.0.1", TCP_PORT, 1000);

    result = stream_comm_test(tcp_stream);
    EXPECT_EQ(result, true);

    // reconnect test
    result = stream_comm_test(tcp_stream);
    EXPECT_EQ(result, true);

    // timeout test
    // socket error test
    // connect shutdown test
    thread_tcpserver.join();
    delete tcp_stream;

    s_server_ready = 0;
    boost::thread thread_udpserver(&amp;udp_server);

    while (s_server_ready == 0) {
        ;
    }

    ::apollo::drivers::gnss::Stream *udp_stream =
                       ::apollo::drivers::gnss::Stream::create_udp("127.0.0.1", UDP_PORT, 1000);
    result = stream_comm_test(udp_stream);
    EXPECT_EQ(result, true);

    // reconnect test
    result = stream_comm_test(udp_stream);
    EXPECT_EQ(result, true);
    thread_udpserver.join();
    delete udp_stream;

    s_server_ready = 0;
    ::apollo::drivers::gnss::Stream *searial_stream =
                       ::apollo::drivers::gnss::Stream::create_serial(
                           FLAGS_serial_port.c_str(), ::apollo::drivers::gnss::BAUDRATE_9600, 1000);
    result = stream_comm_test(searial_stream);
    EXPECT_EQ(result, true);

    // reconnect test
    result = stream_comm_test(searial_stream);
    EXPECT_EQ(result, true);
    delete searial_stream;

}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\control.cc" startLine="(230, 0)" endLine="(256, 1)" clone_start="11" clone_end="24">
			<code function_name="Control::CheckInput()">Status Control::CheckInput() {
  AdapterManager::Observe();
  auto localization_adapter = AdapterManager::GetLocalization();
  if (localization_adapter-&gt;Empty()) {
    AINFO &lt;&lt; "No Localization msg yet. ";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "No localization msg");
  }
  localization_ = localization_adapter-&gt;GetLatestObserved();
  ADEBUG &lt;&lt; "Received localization:" &lt;&lt; localization_.ShortDebugString();

  auto chassis_adapter = AdapterManager::GetChassis();
  if (chassis_adapter-&gt;Empty()) {
    AINFO &lt;&lt; "No Chassis msg yet. ";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "No chassis msg");
  }
  chassis_ = chassis_adapter-&gt;GetLatestObserved();
  ADEBUG &lt;&lt; "Received chassis:" &lt;&lt; chassis_.ShortDebugString();

  auto trajectory_adapter = AdapterManager::GetPlanningTrajectory();
  if (trajectory_adapter-&gt;Empty()) {
    AINFO &lt;&lt; "No planning msg yet. ";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "No planning msg");
  }
  trajectory_ = trajectory_adapter-&gt;GetLatestObserved();

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\control.cc" startLine="(230, 0)" endLine="(256, 1)" clone_start="3" clone_end="16">
			<code function_name="Control::CheckInput()">Status Control::CheckInput() {
  AdapterManager::Observe();
  auto localization_adapter = AdapterManager::GetLocalization();
  if (localization_adapter-&gt;Empty()) {
    AINFO &lt;&lt; "No Localization msg yet. ";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "No localization msg");
  }
  localization_ = localization_adapter-&gt;GetLatestObserved();
  ADEBUG &lt;&lt; "Received localization:" &lt;&lt; localization_.ShortDebugString();

  auto chassis_adapter = AdapterManager::GetChassis();
  if (chassis_adapter-&gt;Empty()) {
    AINFO &lt;&lt; "No Chassis msg yet. ";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "No chassis msg");
  }
  chassis_ = chassis_adapter-&gt;GetLatestObserved();
  ADEBUG &lt;&lt; "Received chassis:" &lt;&lt; chassis_.ShortDebugString();

  auto trajectory_adapter = AdapterManager::GetPlanningTrajectory();
  if (trajectory_adapter-&gt;Empty()) {
    AINFO &lt;&lt; "No planning msg yet. ";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "No planning msg");
  }
  trajectory_ = trajectory_adapter-&gt;GetLatestObserved();

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(487, 0)" endLine="(586, 1)" clone_start="8" clone_end="19">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR &lt;&lt; "Steering fault detected: "
           &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR &lt;&lt; "Brake fault detected: "
           &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR &lt;&lt; "Throttle fault detected: "
           &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR &lt;&lt; "Gear fault detected: " &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(487, 0)" endLine="(586, 1)" clone_start="26" clone_end="37">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR &lt;&lt; "Steering fault detected: "
           &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR &lt;&lt; "Brake fault detected: "
           &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR &lt;&lt; "Throttle fault detected: "
           &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR &lt;&lt; "Gear fault detected: " &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(26, 0)" endLine="(40, 1)" clone_start="5" clone_end="15">
			<code function_name="Gps6e::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Gps6e::Parse(const std::uint8_t* bytes, int32_t length,
                  ChassisDetail* car_status) const {
  car_status-&gt;mutable_basic()-&gt;set_year(year(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_month(month(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_day(day(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_hours(hours(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_minutes(minutes(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_seconds(seconds(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_compass_direction(
      compass_direction(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_pdop(pdop(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_is_gps_fault(is_gps_fault(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_is_inferred(
      is_inferred_position(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="153" clone_end="177">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="68" clone_end="84">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length,
                        ChassisDetail* chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(42, 0)" endLine="(46, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6e::year(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::year(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 7);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(204, 0)" endLine="(209, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::turn_signal_status(const std::uint8_t* bytes, int32_t length) const">int32_t Misc69::turn_signal_status(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(111, 0)" endLine="(119, 1)" clone_start="1" clone_end="4">
			<code function_name="Brakeinfo74::braking_torque_request(const std::uint8_t* bytes, int32_t length) const">double Brakeinfo74::braking_torque_request(const std::uint8_t* bytes,
                                           int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 4);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 4.000000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(63, 4)" endLine="(63, 21)" clone_start="1" clone_end="1">
			<code function_name="SerialStream()">    SerialStream() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(45, 4)" endLine="(45, 18)" clone_start="1" clone_end="1">
			<code function_name="UdpStream()">    UdpStream() {}</code>
		</source>
	</dup>
	<dup count="8">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(146, 0)" endLine="(152, 1)" clone_start="1" clone_end="7">
			<code function_name="Brakeinfo74::hill_start_assist_mode(const std::uint8_t* bytes, int32_t length) const">int32_t Brakeinfo74::hill_start_assist_mode(const std::uint8_t* bytes,
                                            int32_t length) const {
  // see table for status code
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(4, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(66, 0)" endLine="(70, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::minutes(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::minutes(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(60, 0)" endLine="(64, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::hours(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::hours(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(54, 0)" endLine="(58, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::day(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::day(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 2);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(48, 0)" endLine="(52, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::month(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::month(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(42, 0)" endLine="(46, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::year(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::year(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 7);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(211, 0)" endLine="(216, 1)" clone_start="1" clone_end="6">
			<code function_name="Misc69::high_beam_status(const std::uint8_t* bytes, int32_t length) const">int32_t Misc69::high_beam_status(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(2, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(204, 0)" endLine="(209, 1)" clone_start="1" clone_end="6">
			<code function_name="Misc69::turn_signal_status(const std::uint8_t* bytes, int32_t length) const">int32_t Misc69::turn_signal_status(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 2);
  return x;
}</code>
		</source>
	</dup>
	<dup count="8">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(154, 0)" endLine="(160, 1)" clone_start="1" clone_end="7">
			<code function_name="Brakeinfo74::parking_brake_status(const std::uint8_t* bytes, int32_t length) const">int32_t Brakeinfo74::parking_brake_status(const std::uint8_t* bytes,
                                          int32_t length) const {
  // see table for status code
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(6, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(72, 0)" endLine="(76, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::seconds(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::seconds(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 5);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(66, 0)" endLine="(70, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::minutes(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::minutes(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(60, 0)" endLine="(64, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::hours(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::hours(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(54, 0)" endLine="(58, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::day(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::day(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 2);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(48, 0)" endLine="(52, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::month(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::month(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(218, 0)" endLine="(222, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::wiper_status(const std::uint8_t* bytes, int32_t length) const">int32_t Misc69::wiper_status(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(211, 0)" endLine="(216, 1)" clone_start="1" clone_end="6">
			<code function_name="Misc69::high_beam_status(const std::uint8_t* bytes, int32_t length) const">int32_t Misc69::high_beam_status(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(2, 2);
  return x;
}</code>
		</source>
	</dup>
	<dup count="8">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(162, 0)" endLine="(173, 1)" clone_start="1" clone_end="4">
			<code function_name="Brakeinfo74::wheel_torque_actual(const std::uint8_t* bytes, int32_t length) const">double Brakeinfo74::wheel_torque_actual(const std::uint8_t* bytes,
                                        int32_t length) const {
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 6);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FFF) {
    value -= 0x4000;
  }
  return value * 4.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(78, 0)" endLine="(83, 1)" clone_start="1" clone_end="4">
			<code function_name="Gps6e::compass_direction(const std::uint8_t* bytes, int32_t length) const">double Gps6e::compass_direction(const std::uint8_t* bytes,
                                int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 4);
  return x * 45.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(72, 0)" endLine="(76, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6e::seconds(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::seconds(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 5);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(66, 0)" endLine="(70, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6e::minutes(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::minutes(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(60, 0)" endLine="(64, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6e::hours(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::hours(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(54, 0)" endLine="(58, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6e::day(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::day(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 2);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(224, 0)" endLine="(229, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::ambient_light_status(const std::uint8_t* bytes, int32_t length) const">int32_t Misc69::ambient_light_status(const std::uint8_t* bytes,
                                     int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(218, 0)" endLine="(222, 1)" clone_start="1" clone_end="3">
			<code function_name="Misc69::wiper_status(const std::uint8_t* bytes, int32_t length) const">int32_t Misc69::wiper_status(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(487, 0)" endLine="(586, 1)" clone_start="10" clone_end="21">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR &lt;&lt; "Steering fault detected: "
           &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR &lt;&lt; "Brake fault detected: "
           &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR &lt;&lt; "Throttle fault detected: "
           &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR &lt;&lt; "Gear fault detected: " &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(487, 0)" endLine="(586, 1)" clone_start="44" clone_end="55">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR &lt;&lt; "Steering fault detected: "
           &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR &lt;&lt; "Brake fault detected: "
           &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR &lt;&lt; "Throttle fault detected: "
           &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR &lt;&lt; "Gear fault detected: " &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(33, 0)" endLine="(41, 1)" clone_start="4" clone_end="9">
			<code function_name="Steering64::UpdateData(uint8_t* data)">void Steering64::UpdateData(uint8_t* data) {
  set_steering_angle_p(data, steering_angle_);
  set_enable_p(data, steering_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_ignore_driver_override_p(data, ignore_driver_override_);
  set_steering_angle_speed_p(data, steering_angle_speed_);
  set_watchdog_counter_p(data, watchdog_counter_);
  set_disable_audible_warning_p(data, disable_audible_warning_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(33, 0)" endLine="(39, 1)" clone_start="2" clone_end="7">
			<code function_name="Throttle62::UpdateData(uint8_t* data)">void Throttle62::UpdateData(uint8_t* data) {
  set_pedal_p(data, pedal_cmd_);
  set_enable_p(data, pedal_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_ignore_driver_override_p(data, ignore_driver_override_);
  set_watchdog_counter_p(data, watchdog_counter_);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(43, 0)" endLine="(51, 1)" clone_start="1" clone_end="6">
			<code function_name="Steering64::Reset()">void Steering64::Reset() {
  steering_angle_ = 0.0;
  steering_enable_ = false;
  clear_driver_override_flag_ = false;
  ignore_driver_override_ = false;
  steering_angle_speed_ = 0.0;
  watchdog_counter_ = 0;
  disable_audible_warning_ = false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(41, 0)" endLine="(47, 1)" clone_start="1" clone_end="6">
			<code function_name="Throttle62::Reset()">void Throttle62::Reset() {
  pedal_cmd_ = 0.0;
  pedal_enable_ = false;
  clear_driver_override_flag_ = false;
  ignore_driver_override_ = false;
  watchdog_counter_ = 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\message_manager.h" startLine="(131, 0)" endLine="(144, 1)" clone_start="1" clone_end="12">
			<code function_name="MessageManager::AddSendProtocolData()">void MessageManager::AddSendProtocolData() {
  send_protocol_data_.emplace_back(new T());
  auto* dt = send_protocol_data_.back().get();
  if (dt == nullptr) {
    return;
  }
  protocol_data_map_[T::ID] = dt;
  if (need_check) {
    check_ids_[T::ID].period = dt-&gt;GetPeriod();
    check_ids_[T::ID].real_period = 0;
    check_ids_[T::ID].last_time = 0;
    check_ids_[T::ID].error_count = 0;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\message_manager.h" startLine="(115, 0)" endLine="(128, 1)" clone_start="1" clone_end="12">
			<code function_name="MessageManager::AddRecvProtocolData()">void MessageManager::AddRecvProtocolData() {
  recv_protocol_data_.emplace_back(new T());
  auto* dt = recv_protocol_data_.back().get();
  if (dt == nullptr) {
    return;
  }
  protocol_data_map_[T::ID] = dt;
  if (need_check) {
    check_ids_[T::ID].period = dt-&gt;GetPeriod();
    check_ids_[T::ID].real_period = 0;
    check_ids_[T::ID].last_time = 0;
    check_ids_[T::ID].error_count = 0;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(52, 0)" endLine="(115, 1)" clone_start="38" clone_end="52">
			<code function_name="create_stream(const config::Stream&amp; sd)">Stream* create_stream(const config::Stream&amp; sd) {
    switch (sd.type_case()) {
    case config::Stream::kSerial:
        if (!sd.serial().has_device()) {
            ROS_ERROR("Serial def has no device field.");
            return nullptr;
        }
        if (!sd.serial().has_baud_rate()) {
            ROS_ERROR_STREAM("Serial def has no baud_rate field. Use default baud rate "
                         &lt;&lt; sd.serial().baud_rate());
            return nullptr;
        }
        return Stream::create_serial(sd.serial().device().c_str(), sd.serial().baud_rate());

    case config::Stream::kTcp:
        if (!sd.tcp().has_address()) {
            ROS_ERROR("tcp def has no address field.");
            return nullptr;
        }
        if (!sd.tcp().has_port()) {
            ROS_ERROR("tcp def has no port field.");
            return nullptr;
        }
        return Stream::create_tcp(sd.tcp().address().c_str(), sd.tcp().port());

    case config::Stream::kUdp:
        if (!sd.udp().has_address()) {
            ROS_ERROR("tcp def has no address field.");
            return nullptr;
        }
        if (!sd.udp().has_port()) {
            ROS_ERROR("tcp def has no port field.");
            return nullptr;
        }
        return Stream::create_udp(sd.udp().address().c_str(), sd.udp().port());

    case config::Stream::kNtrip:
        if (!sd.ntrip().has_address()) {
            ROS_ERROR("ntrip def has no address field.");
            return nullptr;
        }
        if (!sd.ntrip().has_port()) {
            ROS_ERROR("ntrip def has no port field.");
            return nullptr;
        }
        if (!sd.ntrip().has_mount_point()) {
            ROS_ERROR("ntrip def has no mount point field.");
            return nullptr;
        }
        if (!sd.ntrip().has_user()) {
            ROS_ERROR("ntrip def has no user field.");
            return nullptr;
        }
        if (!sd.ntrip().has_password()) {
            ROS_ERROR("ntrip def has no passwd field.");
            return nullptr;
        }
        return Stream::create_ntrip(sd.ntrip().address(), sd.ntrip().port(),
                                    sd.ntrip().mount_point(), sd.ntrip().user(),
                                    sd.ntrip().password(), sd.ntrip().timeout_s());
    default:
        return nullptr;
    }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(52, 0)" endLine="(115, 1)" clone_start="42" clone_end="56">
			<code function_name="create_stream(const config::Stream&amp; sd)">Stream* create_stream(const config::Stream&amp; sd) {
    switch (sd.type_case()) {
    case config::Stream::kSerial:
        if (!sd.serial().has_device()) {
            ROS_ERROR("Serial def has no device field.");
            return nullptr;
        }
        if (!sd.serial().has_baud_rate()) {
            ROS_ERROR_STREAM("Serial def has no baud_rate field. Use default baud rate "
                         &lt;&lt; sd.serial().baud_rate());
            return nullptr;
        }
        return Stream::create_serial(sd.serial().device().c_str(), sd.serial().baud_rate());

    case config::Stream::kTcp:
        if (!sd.tcp().has_address()) {
            ROS_ERROR("tcp def has no address field.");
            return nullptr;
        }
        if (!sd.tcp().has_port()) {
            ROS_ERROR("tcp def has no port field.");
            return nullptr;
        }
        return Stream::create_tcp(sd.tcp().address().c_str(), sd.tcp().port());

    case config::Stream::kUdp:
        if (!sd.udp().has_address()) {
            ROS_ERROR("tcp def has no address field.");
            return nullptr;
        }
        if (!sd.udp().has_port()) {
            ROS_ERROR("tcp def has no port field.");
            return nullptr;
        }
        return Stream::create_udp(sd.udp().address().c_str(), sd.udp().port());

    case config::Stream::kNtrip:
        if (!sd.ntrip().has_address()) {
            ROS_ERROR("ntrip def has no address field.");
            return nullptr;
        }
        if (!sd.ntrip().has_port()) {
            ROS_ERROR("ntrip def has no port field.");
            return nullptr;
        }
        if (!sd.ntrip().has_mount_point()) {
            ROS_ERROR("ntrip def has no mount point field.");
            return nullptr;
        }
        if (!sd.ntrip().has_user()) {
            ROS_ERROR("ntrip def has no user field.");
            return nullptr;
        }
        if (!sd.ntrip().has_password()) {
            ROS_ERROR("ntrip def has no passwd field.");
            return nullptr;
        }
        return Stream::create_ntrip(sd.ntrip().address(), sd.ntrip().port(),
                                    sd.ntrip().mount_point(), sd.ntrip().user(),
                                    sd.ntrip().password(), sd.ntrip().timeout_s());
    default:
        return nullptr;
    }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(26, 0)" endLine="(50, 1)" clone_start="7" clone_end="18">
			<code function_name="Gps6f::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Gps6f::Parse(const std::uint8_t* bytes, int32_t length,
                  ChassisDetail* car_status) const {
  car_status-&gt;mutable_basic()-&gt;set_altitude(altitude(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_heading(heading(bytes, length));
  // speed mph -&gt; mps
  car_status-&gt;mutable_basic()-&gt;set_gps_speed(speed(bytes, length) * 0.44704);
  car_status-&gt;mutable_basic()-&gt;set_hdop(hdop(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_vdop(vdop(bytes, length));
  switch (fix_quality(bytes, length)) {
    case 0:
      car_status-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_NO);
      break;
    case 1:
      car_status-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_2D);
      break;
    case 2:
      car_status-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_3D);
      break;
    default:
      car_status-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_INVALID);
      break;
  }
  car_status-&gt;mutable_basic()-&gt;set_num_satellites(
      num_satellites(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="34" clone_end="47">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length,
                        ChassisDetail* chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="20" clone_end="32">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="92" clone_end="103">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="39" clone_end="50">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="3" clone_end="14">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="6">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="120" clone_end="142">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(26, 0)" endLine="(55, 1)" clone_start="7" clone_end="26">
			<code function_name="Brake61::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Brake61::Parse(const std::uint8_t* bytes, int32_t length,
                    ChassisDetail* car_status) const {
  car_status-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_output(pedal_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  car_status-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(26, 0)" endLine="(55, 1)" clone_start="6" clone_end="24">
			<code function_name="Brake61::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Brake61::Parse(const std::uint8_t* bytes, int32_t length,
                    ChassisDetail* car_status) const {
  car_status-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_output(pedal_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  car_status-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(26, 0)" endLine="(55, 1)" clone_start="5" clone_end="22">
			<code function_name="Brake61::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Brake61::Parse(const std::uint8_t* bytes, int32_t length,
                    ChassisDetail* car_status) const {
  car_status-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_output(pedal_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  car_status-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(26, 0)" endLine="(55, 1)" clone_start="4" clone_end="20">
			<code function_name="Brake61::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Brake61::Parse(const std::uint8_t* bytes, int32_t length,
                    ChassisDetail* car_status) const {
  car_status-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_output(pedal_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  car_status-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(26, 0)" endLine="(55, 1)" clone_start="3" clone_end="18">
			<code function_name="Brake61::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Brake61::Parse(const std::uint8_t* bytes, int32_t length,
                    ChassisDetail* car_status) const {
  car_status-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_output(pedal_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  car_status-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\common\trajectory_analyzer.cc" startLine="(174, 0)" endLine="(194, 1)" clone_start="1" clone_end="17">
			<code function_name="TrajectoryAnalyzer::QueryNearestPointByPosition( const double x, const double y) const">TrajectoryPoint TrajectoryAnalyzer::QueryNearestPointByPosition(
    const double x, const double y) const {
  auto func_distance_square = [](const PathPoint&amp; point, const double x,
                                 const double y) {
    double dx = point.x - x;
    double dy = point.y - y;
    return dx * dx + dy * dy;
  };

  double d_min = func_distance_square(trajectory_points_.front(), x, y);
  size_t index_min = 0;

  for (size_t i = 1; i &lt; trajectory_points_.size(); ++i) {
    double d_temp = func_distance_square(trajectory_points_[i], x, y);
    if (d_temp &lt; d_min) {
      d_min = d_temp;
      index_min = i;
    }
  }
  return trajectory_points_[index_min];
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\common\trajectory_analyzer.cc" startLine="(58, 0)" endLine="(90, 1)" clone_start="1" clone_end="17">
			<code function_name="TrajectoryAnalyzer::QueryMatchedPathPoint(const double x, const double y) const">PathPoint TrajectoryAnalyzer::QueryMatchedPathPoint(const double x,
                                                    const double y) const {
  auto func_distance_square = [](const PathPoint&amp; point, const double x,
                                 const double y) {
    double dx = point.x - x;
    double dy = point.y - y;
    return dx * dx + dy * dy;
  };

  double d_min = func_distance_square(trajectory_points_.front(), x, y);
  size_t index_min = 0;

  for (size_t i = 1; i &lt; trajectory_points_.size(); ++i) {
    double d_temp = func_distance_square(trajectory_points_[i], x, y);
    if (d_temp &lt; d_min) {
      d_min = d_temp;
      index_min = i;
    }
  }

  size_t index_start = index_min == 0 ? index_min : index_min - 1;
  size_t index_end =
      index_min + 1 == trajectory_points_.size() ? index_min : index_min + 1;

  if (index_start == index_end ||
      common::math::double_compare(trajectory_points_[index_start].s,
                                   trajectory_points_[index_end].s) == 0) {
    return trajectory_points_[index_start];
  }

  return FindMinDistancePoint(trajectory_points_[index_start],
                              trajectory_points_[index_end], x, y);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(286, 0)" endLine="(322, 1)" clone_start="31" clone_end="37">
			<code function_name="TcpStream::write(const uint8_t* buffer, size_t length)">size_t TcpStream::write(const uint8_t* buffer, size_t length) {
    ssize_t  nsent = 0;
    size_t total_nsent = 0;

    if (_status != Stream::Status::CONNECTED) {
        disconnect();
        connect();
        if (_status != Stream::Status::CONNECTED) {
            return 0;
        }
    }

    while (length &gt; 0) {
        nsent = ::send(_sockfd, buffer, length, 0);
        if (nsent &lt; 0) {
            if (errno == EINTR) {
                continue;
            } else {
                // error
                if (errno == EPIPE || errno == ECONNRESET) {
                    _status = Stream::Status::DISCONNECTED;
                    _errno = errno;
                } else if (errno != EAGAIN) {
                    _status = Stream::Status::ERROR;
                    _errno = errno;
                }
                return total_nsent;
            }
        }

        total_nsent += nsent;
        length -= nsent;
        buffer += nsent;
    }

    return total_nsent;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(326, 0)" endLine="(378, 1)" clone_start="47" clone_end="53">
			<code function_name="SerialStream::write(const uint8_t* data, size_t length)">size_t SerialStream::write(const uint8_t* data, size_t length) {
    if (!_is_open) {
        if (!connect()) {
            return 0;
        }
        ROS_INFO_STREAM("Connect " &lt;&lt; _device_name &lt;&lt; " success.");
    }

    size_t total_nsent = 0;
    size_t delay_times = 0;

    while ((length &gt; 0) &amp;&amp; (delay_times &lt; 5)) {
        ssize_t nsent = ::write(_fd, data, length);
        if (nsent &lt; 0) {
            ROS_ERROR_STREAM("Serial stream write data failed, error: "
                             &lt;&lt; strerror(errno));
            switch (errno) {
            case EAGAIN:
            case EINVAL:
                nsent = 0;
                break;

            case EBADF:
            case EIO:
                disconnect();
                if (connect()) {
                    ROS_INFO_STREAM("Reconnect " &lt;&lt; _device_name &lt;&lt; "success.");
                    nsent = 0;
                    break; //has recoverable
                }

            default:
                _status = Stream::Status::ERROR;
                _errno = errno;
                return total_nsent;
            }
        }

        if (nsent == 0) {
            if (!wait_writable(_byte_time_us)) {
                break;
            }
            ++delay_times;
            continue;
        }

        total_nsent += nsent;
        length -= nsent;
        data += nsent;
    }

    return total_nsent;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(324, 0)" endLine="(344, 1)" clone_start="1" clone_end="10">
			<code function_name="TcpStream::readable(uint32_t timeout_us)">bool TcpStream::readable(uint32_t timeout_us) {
    // Setup a select call to block for serial data or a timeout
    timespec timeout_ts;
    fd_set readfds;
    FD_ZERO(&amp;readfds);
    FD_SET(_sockfd, &amp;readfds);

    timeout_ts.tv_sec = timeout_us / 1000000;
    timeout_ts.tv_nsec = (timeout_us % 1000000) * 1000;
    int r = pselect(_sockfd + 1, &amp;readfds, NULL, NULL, &amp;timeout_ts, NULL);
    if (r &lt; 0) {
        _status = Stream::Status::ERROR;
        _errno = errno;
        ROS_ERROR("Failed to wait tcp data: %d, %s", errno, strerror(errno));
        return false;
    } else if (r == 0 || !FD_ISSET(_sockfd, &amp;readfds)) {
        return false;
    }
    // Data available to read.
    return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(380, 0)" endLine="(400, 1)" clone_start="1" clone_end="10">
			<code function_name="SerialStream::wait_readable (uint32_t timeout_us)">bool SerialStream::wait_readable (uint32_t timeout_us) {
    // Setup a select call to block for serial data or a timeout
    timespec timeout_ts;
    fd_set readfds;
    FD_ZERO(&amp;readfds);
    FD_SET(_fd, &amp;readfds);

    timeout_ts.tv_sec = timeout_us / 1000000;
    timeout_ts.tv_nsec = (timeout_us % 1000000) * 1000;
    int r = pselect(_fd + 1, &amp;readfds, NULL, NULL, &amp;timeout_ts, NULL);
    if (r &lt;= 0) {
        return false;
    }

    // This shouldn't happen, if r &gt; 0 our fd has to be in the list!
    if (!FD_ISSET(_fd, &amp;readfds)) {
        return false;
    }
    // Data available to read.
    return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(487, 0)" endLine="(586, 1)" clone_start="65" clone_end="78">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR &lt;&lt; "Steering fault detected: "
           &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR &lt;&lt; "Brake fault detected: "
           &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR &lt;&lt; "Throttle fault detected: "
           &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR &lt;&lt; "Gear fault detected: " &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(487, 0)" endLine="(586, 1)" clone_start="74" clone_end="87">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR &lt;&lt; "Steering fault detected: "
           &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR &lt;&lt; "Brake fault detected: "
           &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR &lt;&lt; "Throttle fault detected: "
           &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
           &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR &lt;&lt; "Gear fault detected: " &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\tools\teleop.cc" startLine="(254, 2)" endLine="(273, 3)" clone_start="5" clone_end="16">
			<code function_name="GetGear(int32_t gear)">  Chassis::GearPosition GetGear(int32_t gear) {
    switch (gear) {
      case 0:
        return Chassis::GEAR_NEUTRAL;
      case 1:
        return Chassis::GEAR_DRIVE;
      case 2:
        return Chassis::GEAR_REVERSE;
      case 3:
        return Chassis::GEAR_PARKING;
      case 4:
        return Chassis::GEAR_LOW;
      case 5:
        return Chassis::GEAR_INVALID;
      case 6:
        return Chassis::GEAR_NONE;
      default:
        return Chassis::GEAR_INVALID;
    }
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\tools\teleop.cc" startLine="(254, 2)" endLine="(273, 3)" clone_start="3" clone_end="14">
			<code function_name="GetGear(int32_t gear)">  Chassis::GearPosition GetGear(int32_t gear) {
    switch (gear) {
      case 0:
        return Chassis::GEAR_NEUTRAL;
      case 1:
        return Chassis::GEAR_DRIVE;
      case 2:
        return Chassis::GEAR_REVERSE;
      case 3:
        return Chassis::GEAR_PARKING;
      case 4:
        return Chassis::GEAR_LOW;
      case 5:
        return Chassis::GEAR_INVALID;
      case 6:
        return Chassis::GEAR_NONE;
      default:
        return Chassis::GEAR_INVALID;
    }
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(139, 0)" endLine="(145, 1)" clone_start="1" clone_end="7">
			<code function_name="UdpStream::close()">void UdpStream::close() {
    if (_sockfd &gt; 0) {
        ::close(_sockfd);
        _sockfd = -1;
        _status = Stream::Status::DISCONNECTED;
    }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(131, 0)" endLine="(137, 1)" clone_start="1" clone_end="7">
			<code function_name="TcpStream::close()">void TcpStream::close() {
    if (_sockfd &gt; 0) {
        ::close(_sockfd);
        _sockfd = -1;
        _status = Stream::Status::DISCONNECTED;
    }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(147, 0)" endLine="(163, 1)" clone_start="1" clone_end="10">
			<code function_name="UdpStream::connect()">bool UdpStream::connect() {
    if (_sockfd &lt; 0) {
        this-&gt;open();
        if (_sockfd &lt; 0) {
            return false;
        }
    }

    if (_status == Stream::Status::CONNECTED) {
        return true;
    }

    // upper layer support ping method ??
    login();
    _status = Stream::Status::CONNECTED;
    return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(139, 0)" endLine="(231, 1)" clone_start="1" clone_end="11">
			<code function_name="TcpStream::connect()">bool TcpStream::connect() {
    if (_sockfd &lt; 0) {
        this-&gt;open();
        if (_sockfd  &lt; 0) {
            // error
            return false;
        }
    }

    if (_status == Stream::Status::CONNECTED) {
        return true;
    }

    fd_set fds;
    timeval timeo = {10, 0};
    int ret = 0;
    sockaddr_in peer_addr;

    bzero(&amp;peer_addr, sizeof(peer_addr));
    peer_addr.sin_family = AF_INET;
    peer_addr.sin_port = _peer_port;
    peer_addr.sin_addr.s_addr = _peer_addr;

    int fd_flags = fcntl(_sockfd, F_GETFL);
    if (fd_flags &lt; 0 || fcntl(_sockfd, F_SETFL, fd_flags | O_NONBLOCK) &lt; 0) {
        ROS_ERROR_STREAM("Failed to set noblock, error: " &lt;&lt; strerror(errno));
        return false;
    }

    while ((ret = ::connect(_sockfd, reinterpret_cast&lt;sockaddr*&gt;(&amp;peer_addr), sizeof(peer_addr)))
                &lt; 0) {
        if (errno == EINTR) {
            ROS_INFO("Tcp connect return EINTR.");
            continue;
        } else {
            if ((errno != EISCONN) &amp;&amp; (errno != EINPROGRESS) &amp;&amp; (errno != EALREADY)) {
                _status = Stream::Status::ERROR;
                _errno = errno;
                ROS_ERROR_STREAM("Connect failed, error: " &lt;&lt;  strerror(errno));
                return false;
            }

            FD_ZERO(&amp;fds);
            FD_SET(_sockfd, &amp;fds);
            ret = select(_sockfd + 1, NULL, &amp;fds, NULL, &amp;timeo);
            if (ret &lt; 0) {
                _status = Stream::Status::ERROR;
                _errno = errno;
                ROS_ERROR_STREAM("Wait connect failed, error: " &lt;&lt; strerror(errno));
                return false;
            } else if (ret == 0) {
                ROS_INFO("Tcp connect timeout.");
                return false;
            } else if (FD_ISSET(_sockfd, &amp;fds)) {
                int error = 0;
                socklen_t len = sizeof(int);

                if (getsockopt(_sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len) &lt; 0) {
                    _status = Stream::Status::ERROR;
                    _errno = errno;
                    ROS_ERROR_STREAM("Getsockopt failed, error: " &lt;&lt; strerror(errno));
                    return false;
                }
                if (error != 0) {
                    _status = Stream::Status::ERROR;
                    _errno = errno;
                    ROS_ERROR_STREAM("Socket error: " &lt;&lt;  strerror(errno));
                    return false;
                }

                // connect successfully
                break;
            } else {
                _status = Stream::Status::ERROR;
                _errno = errno;
                ROS_ERROR("Should not be here.");
                return false;
            }
        }
    }

    if (!init_socket()) {
        close();
        _status = Stream::Status::ERROR;
        _errno = errno;
        ROS_ERROR("Failed to init socket.");
        return false;
    }
    ROS_INFO("Tcp connect success.");
    _status = Stream::Status::CONNECTED;
    login();
    return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(227, 0)" endLine="(344, 1)" clone_start="43" clone_end="59">
			<code function_name="NovatelParser::prepare_message(MessagePtr&amp; message_ptr)">Parser::MessageType NovatelParser::prepare_message(MessagePtr&amp; message_ptr) {
    if (!check_crc()) {
        ROS_ERROR("CRC check failed.");
        return MessageType::NONE;
    }

    uint8_t* message = nullptr;
    novatel::MessageId message_id;
    uint16_t message_length;
    uint16_t gps_week;
    uint32_t gps_millisecs;
    if (_buffer[2] == novatel::SYNC_2_LONG_HEADER) {
        auto header = reinterpret_cast&lt;const novatel::LongHeader*&gt;(_buffer.data());
        message = _buffer.data() + sizeof(novatel::LongHeader);
        gps_week = header-&gt;gps_week;
        gps_millisecs = header-&gt;gps_millisecs;
        message_id = header-&gt;message_id;
        message_length = header-&gt;message_length;
    } else {
        auto header = reinterpret_cast&lt;const novatel::ShortHeader*&gt;(_buffer.data());
        message = _buffer.data() + sizeof(novatel::ShortHeader);
        gps_week = header-&gt;gps_week;
        gps_millisecs = header-&gt;gps_millisecs;
        message_id = header-&gt;message_id;
        message_length = header-&gt;message_length;
    }
    switch (message_id) {
    case novatel::BESTGNSSPOS:
    case novatel::BESTPOS:
    case novatel::PSRPOS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::BestPos), "Incorrect message_length");
        if (message_length != sizeof(novatel::BestPos)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }
        if (handle_best_pos(reinterpret_cast&lt;novatel::BestPos*&gt;(message), gps_week,
                            gps_millisecs)) {
            message_ptr = &amp;_gnss;
            return MessageType::GNSS;
        }
        break;

    case novatel::BESTGNSSVEL:
    case novatel::BESTVEL:
    case novatel::PSRVEL:
        //ROS_ERROR_COND(message_length != sizeof(novatel::BestVel), "Incorrect message_length");
        if (message_length != sizeof(novatel::BestVel)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }
        if (handle_best_vel(reinterpret_cast&lt;novatel::BestVel*&gt;(message), gps_week,
                            gps_millisecs)) {
            message_ptr = &amp;_gnss;
            return MessageType::GNSS;
        }
        break;

    case novatel::CORRIMUDATA:
    case novatel::CORRIMUDATAS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::CorrImuData), "Incorrect message_length");
        if (message_length != sizeof(novatel::CorrImuData)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_corr_imu_data(reinterpret_cast&lt;novatel::CorrImuData*&gt;(message))) {
            message_ptr = &amp;_ins;
            return MessageType::INS;
        }
        break;

    case novatel::INSCOV:
    case novatel::INSCOVS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::InsCov), "Incorrect message_length");
        if (message_length != sizeof(novatel::InsCov)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_ins_cov(reinterpret_cast&lt;novatel::InsCov*&gt;(message))) {
            message_ptr = &amp;_ins;
            return MessageType::INS;
        }
        break;

    case novatel::INSPVA:
    case novatel::INSPVAS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::InsPva), "Incorrect message_length");
        if (message_length != sizeof(novatel::InsPva)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_ins_pva(reinterpret_cast&lt;novatel::InsPva*&gt;(message))) {
            message_ptr = &amp;_ins;
            return MessageType::INS;
        }
        break;

    case novatel::RAWIMUX:
    case novatel::RAWIMUSX:
        //ROS_ERROR_COND(message_length != sizeof(novatel::RawImuX), "Incorrect message_length");
        if (message_length != sizeof(novatel::RawImuX)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_raw_imu_x(reinterpret_cast&lt;novatel::RawImuX*&gt;(message))) {
            message_ptr = &amp;_imu;
            return MessageType::IMU;
        }
        break;

    default:
        break;
    }
    return MessageType::NONE;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(227, 0)" endLine="(344, 1)" clone_start="28" clone_end="44">
			<code function_name="NovatelParser::prepare_message(MessagePtr&amp; message_ptr)">Parser::MessageType NovatelParser::prepare_message(MessagePtr&amp; message_ptr) {
    if (!check_crc()) {
        ROS_ERROR("CRC check failed.");
        return MessageType::NONE;
    }

    uint8_t* message = nullptr;
    novatel::MessageId message_id;
    uint16_t message_length;
    uint16_t gps_week;
    uint32_t gps_millisecs;
    if (_buffer[2] == novatel::SYNC_2_LONG_HEADER) {
        auto header = reinterpret_cast&lt;const novatel::LongHeader*&gt;(_buffer.data());
        message = _buffer.data() + sizeof(novatel::LongHeader);
        gps_week = header-&gt;gps_week;
        gps_millisecs = header-&gt;gps_millisecs;
        message_id = header-&gt;message_id;
        message_length = header-&gt;message_length;
    } else {
        auto header = reinterpret_cast&lt;const novatel::ShortHeader*&gt;(_buffer.data());
        message = _buffer.data() + sizeof(novatel::ShortHeader);
        gps_week = header-&gt;gps_week;
        gps_millisecs = header-&gt;gps_millisecs;
        message_id = header-&gt;message_id;
        message_length = header-&gt;message_length;
    }
    switch (message_id) {
    case novatel::BESTGNSSPOS:
    case novatel::BESTPOS:
    case novatel::PSRPOS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::BestPos), "Incorrect message_length");
        if (message_length != sizeof(novatel::BestPos)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }
        if (handle_best_pos(reinterpret_cast&lt;novatel::BestPos*&gt;(message), gps_week,
                            gps_millisecs)) {
            message_ptr = &amp;_gnss;
            return MessageType::GNSS;
        }
        break;

    case novatel::BESTGNSSVEL:
    case novatel::BESTVEL:
    case novatel::PSRVEL:
        //ROS_ERROR_COND(message_length != sizeof(novatel::BestVel), "Incorrect message_length");
        if (message_length != sizeof(novatel::BestVel)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }
        if (handle_best_vel(reinterpret_cast&lt;novatel::BestVel*&gt;(message), gps_week,
                            gps_millisecs)) {
            message_ptr = &amp;_gnss;
            return MessageType::GNSS;
        }
        break;

    case novatel::CORRIMUDATA:
    case novatel::CORRIMUDATAS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::CorrImuData), "Incorrect message_length");
        if (message_length != sizeof(novatel::CorrImuData)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_corr_imu_data(reinterpret_cast&lt;novatel::CorrImuData*&gt;(message))) {
            message_ptr = &amp;_ins;
            return MessageType::INS;
        }
        break;

    case novatel::INSCOV:
    case novatel::INSCOVS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::InsCov), "Incorrect message_length");
        if (message_length != sizeof(novatel::InsCov)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_ins_cov(reinterpret_cast&lt;novatel::InsCov*&gt;(message))) {
            message_ptr = &amp;_ins;
            return MessageType::INS;
        }
        break;

    case novatel::INSPVA:
    case novatel::INSPVAS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::InsPva), "Incorrect message_length");
        if (message_length != sizeof(novatel::InsPva)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_ins_pva(reinterpret_cast&lt;novatel::InsPva*&gt;(message))) {
            message_ptr = &amp;_ins;
            return MessageType::INS;
        }
        break;

    case novatel::RAWIMUX:
    case novatel::RAWIMUSX:
        //ROS_ERROR_COND(message_length != sizeof(novatel::RawImuX), "Incorrect message_length");
        if (message_length != sizeof(novatel::RawImuX)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_raw_imu_x(reinterpret_cast&lt;novatel::RawImuX*&gt;(message))) {
            message_ptr = &amp;_imu;
            return MessageType::IMU;
        }
        break;

    default:
        break;
    }
    return MessageType::NONE;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(26, 0)" endLine="(48, 1)" clone_start="1" clone_end="17">
			<code function_name="Throttle63::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Throttle63::Parse(const std::uint8_t* bytes, int32_t length,
                       ChassisDetail* car_status) const {
  car_status-&gt;mutable_gas()-&gt;set_throttle_input(pedal_input(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_throttle_cmd(pedal_cmd(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_throttle_output(pedal_output(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_throttle_enabled(is_enabled(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  car_status-&gt;mutable_check_response()-&gt;set_is_vcu_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(26, 0)" endLine="(40, 1)" clone_start="1" clone_end="13">
			<code function_name="Gps6e::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Gps6e::Parse(const std::uint8_t* bytes, int32_t length,
                  ChassisDetail* car_status) const {
  car_status-&gt;mutable_basic()-&gt;set_year(year(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_month(month(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_day(day(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_hours(hours(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_minutes(minutes(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_seconds(seconds(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_compass_direction(
      compass_direction(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_pdop(pdop(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_is_gps_fault(is_gps_fault(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_is_inferred(
      is_inferred_position(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(26, 0)" endLine="(55, 1)" clone_start="1" clone_end="14">
			<code function_name="Brake61::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Brake61::Parse(const std::uint8_t* bytes, int32_t length,
                    ChassisDetail* car_status) const {
  car_status-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_output(pedal_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  car_status-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(26, 0)" endLine="(50, 1)" clone_start="10" clone_end="23">
			<code function_name="Gps6f::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Gps6f::Parse(const std::uint8_t* bytes, int32_t length,
                  ChassisDetail* car_status) const {
  car_status-&gt;mutable_basic()-&gt;set_altitude(altitude(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_heading(heading(bytes, length));
  // speed mph -&gt; mps
  car_status-&gt;mutable_basic()-&gt;set_gps_speed(speed(bytes, length) * 0.44704);
  car_status-&gt;mutable_basic()-&gt;set_hdop(hdop(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_vdop(vdop(bytes, length));
  switch (fix_quality(bytes, length)) {
    case 0:
      car_status-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_NO);
      break;
    case 1:
      car_status-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_2D);
      break;
    case 2:
      car_status-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_3D);
      break;
    default:
      car_status-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_INVALID);
      break;
  }
  car_status-&gt;mutable_basic()-&gt;set_num_satellites(
      num_satellites(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="103" clone_end="120">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(26, 0)" endLine="(55, 1)" clone_start="1" clone_end="16">
			<code function_name="Brake61::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Brake61::Parse(const std::uint8_t* bytes, int32_t length,
                    ChassisDetail* car_status) const {
  car_status-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_output(pedal_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  car_status-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(26, 0)" endLine="(48, 1)" clone_start="1" clone_end="19">
			<code function_name="Throttle63::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Throttle63::Parse(const std::uint8_t* bytes, int32_t length,
                       ChassisDetail* car_status) const {
  car_status-&gt;mutable_gas()-&gt;set_throttle_input(pedal_input(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_throttle_cmd(pedal_cmd(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_throttle_output(pedal_output(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_throttle_enabled(is_enabled(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  car_status-&gt;mutable_check_response()-&gt;set_is_vcu_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="52" clone_end="66">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length,
                        ChassisDetail* chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="38" clone_end="50">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length,
                        ChassisDetail* chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="5" clone_end="20">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length,
                        ChassisDetail* chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\can_client\can_client_tool.cc" startLine="(250, 0)" endLine="(336, 1)" clone_start="18" clone_end="34">
			<code function_name="main(int32_t argc, char** argv)">int main(int32_t argc, char** argv) {
  google::InitGoogleLogging(argv[0]);
  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);

  using ::apollo::canbus::CANCardParameter;
  using ::apollo::canbus::CanClient;
  using ::apollo::canbus::CanClientFactory;
  using ::apollo::canbus::TestCanParam;
  using ::apollo::canbus::CanAgent;
  using ::apollo::common::ErrorCode;
  CANCardParameter can_client_conf_a;
  std::shared_ptr&lt;TestCanParam&gt; param_ptr_a(new TestCanParam());
  std::shared_ptr&lt;TestCanParam&gt; param_ptr_b(new TestCanParam());

  auto* can_client_factory = CanClientFactory::instance();
  can_client_factory-&gt;RegisterCanClients();

  if (!::apollo::common::util::GetProtoFromFile(FLAGS_can_client_conf_file_a,
                                                &amp;can_client_conf_a)) {
    AERROR &lt;&lt; "Unable to load canbus conf file: "
           &lt;&lt; FLAGS_can_client_conf_file_a;
    return 1;
  } else {
    AINFO &lt;&lt; "Conf file is loaded: " &lt;&lt; FLAGS_can_client_conf_file_a;
  }
  AINFO &lt;&lt; can_client_conf_a.ShortDebugString();
  auto client_a = can_client_factory-&gt;CreateObject(can_client_conf_a.brand());
  if (!client_a || !client_a-&gt;Init(can_client_conf_a) ||
      client_a-&gt;Start() != ErrorCode::OK) {
    AERROR &lt;&lt; "Create can client a failed.";
    return 1;
  }
  param_ptr_a-&gt;can_client = client_a.get();
  param_ptr_a-&gt;is_first_agent = true;
  param_ptr_a-&gt;conf = can_client_conf_a;

  CANCardParameter can_client_conf_b;
  std::unique_ptr&lt;CanClient&gt; client_b;
  if (!FLAGS_only_one_send) {
    if (!::apollo::common::util::GetProtoFromFile(FLAGS_can_client_conf_file_b,
                                                  &amp;can_client_conf_b)) {
      AERROR &lt;&lt; "Unable to load canbus conf file: "
             &lt;&lt; FLAGS_can_client_conf_file_b;
      return 1;
    } else {
      AINFO &lt;&lt; "Conf file is loaded: " &lt;&lt; FLAGS_can_client_conf_file_b;
    }
    AINFO &lt;&lt; can_client_conf_b.ShortDebugString();
    client_b = can_client_factory-&gt;CreateObject(can_client_conf_b.brand());
    if (!client_b || !client_b-&gt;Init(can_client_conf_b) ||
        client_b-&gt;Start() != ErrorCode::OK) {
      AERROR &lt;&lt; "Create can client b failed.";
      return 1;
    }
    param_ptr_b-&gt;can_client = client_b.get();
    param_ptr_b-&gt;conf = can_client_conf_b;
  }

  CanAgent agent_a(param_ptr_a.get());
  CanAgent agent_b(param_ptr_b.get());
  agent_a.AddOtherAgent(&amp;agent_b);
  agent_b.AddOtherAgent(&amp;agent_a);
  if (!agent_a.Start()) {
    AERROR &lt;&lt; "Agent a start failed.";
    return -1;
  }
  if (FLAGS_only_one_send) {
    agent_b.is_receiving(true);
    agent_b.is_sending_finish(true);
  } else {
    if (!agent_b.Start()) {
      AERROR &lt;&lt; "Agent b start failed.";
      return -1;
    }
  }

  agent_a.WaitForFinish();
  if (!FLAGS_only_one_send) {
    agent_b.WaitForFinish();
  }
  param_ptr_a-&gt;print();
  if (!FLAGS_only_one_send) {
    param_ptr_b-&gt;print();
  }

  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\can_client\can_client_tool.cc" startLine="(250, 0)" endLine="(336, 1)" clone_start="40" clone_end="56">
			<code function_name="main(int32_t argc, char** argv)">int main(int32_t argc, char** argv) {
  google::InitGoogleLogging(argv[0]);
  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);

  using ::apollo::canbus::CANCardParameter;
  using ::apollo::canbus::CanClient;
  using ::apollo::canbus::CanClientFactory;
  using ::apollo::canbus::TestCanParam;
  using ::apollo::canbus::CanAgent;
  using ::apollo::common::ErrorCode;
  CANCardParameter can_client_conf_a;
  std::shared_ptr&lt;TestCanParam&gt; param_ptr_a(new TestCanParam());
  std::shared_ptr&lt;TestCanParam&gt; param_ptr_b(new TestCanParam());

  auto* can_client_factory = CanClientFactory::instance();
  can_client_factory-&gt;RegisterCanClients();

  if (!::apollo::common::util::GetProtoFromFile(FLAGS_can_client_conf_file_a,
                                                &amp;can_client_conf_a)) {
    AERROR &lt;&lt; "Unable to load canbus conf file: "
           &lt;&lt; FLAGS_can_client_conf_file_a;
    return 1;
  } else {
    AINFO &lt;&lt; "Conf file is loaded: " &lt;&lt; FLAGS_can_client_conf_file_a;
  }
  AINFO &lt;&lt; can_client_conf_a.ShortDebugString();
  auto client_a = can_client_factory-&gt;CreateObject(can_client_conf_a.brand());
  if (!client_a || !client_a-&gt;Init(can_client_conf_a) ||
      client_a-&gt;Start() != ErrorCode::OK) {
    AERROR &lt;&lt; "Create can client a failed.";
    return 1;
  }
  param_ptr_a-&gt;can_client = client_a.get();
  param_ptr_a-&gt;is_first_agent = true;
  param_ptr_a-&gt;conf = can_client_conf_a;

  CANCardParameter can_client_conf_b;
  std::unique_ptr&lt;CanClient&gt; client_b;
  if (!FLAGS_only_one_send) {
    if (!::apollo::common::util::GetProtoFromFile(FLAGS_can_client_conf_file_b,
                                                  &amp;can_client_conf_b)) {
      AERROR &lt;&lt; "Unable to load canbus conf file: "
             &lt;&lt; FLAGS_can_client_conf_file_b;
      return 1;
    } else {
      AINFO &lt;&lt; "Conf file is loaded: " &lt;&lt; FLAGS_can_client_conf_file_b;
    }
    AINFO &lt;&lt; can_client_conf_b.ShortDebugString();
    client_b = can_client_factory-&gt;CreateObject(can_client_conf_b.brand());
    if (!client_b || !client_b-&gt;Init(can_client_conf_b) ||
        client_b-&gt;Start() != ErrorCode::OK) {
      AERROR &lt;&lt; "Create can client b failed.";
      return 1;
    }
    param_ptr_b-&gt;can_client = client_b.get();
    param_ptr_b-&gt;conf = can_client_conf_b;
  }

  CanAgent agent_a(param_ptr_a.get());
  CanAgent agent_b(param_ptr_b.get());
  agent_a.AddOtherAgent(&amp;agent_b);
  agent_b.AddOtherAgent(&amp;agent_a);
  if (!agent_a.Start()) {
    AERROR &lt;&lt; "Agent a start failed.";
    return -1;
  }
  if (FLAGS_only_one_send) {
    agent_b.is_receiving(true);
    agent_b.is_sending_finish(true);
  } else {
    if (!agent_b.Start()) {
      AERROR &lt;&lt; "Agent b start failed.";
      return -1;
    }
  }

  agent_a.WaitForFinish();
  if (!FLAGS_only_one_send) {
    agent_b.WaitForFinish();
  }
  param_ptr_a-&gt;print();
  if (!FLAGS_only_one_send) {
    param_ptr_b-&gt;print();
  }

  return 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="78" clone_end="84">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length,
                        ChassisDetail* chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(26, 0)" endLine="(33, 1)" clone_start="3" clone_end="8">
			<code function_name="Throttleinfo75::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Throttleinfo75::Parse(const std::uint8_t* bytes, int32_t length,
                           ChassisDetail* car_status) const {
  car_status-&gt;mutable_ems()-&gt;set_engine_rpm(engine_rpm(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_accelerator_pedal(
      acc_pedal_percent(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_accelerator_pedal_rate(
      acc_pedal_rate(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(111, 0)" endLine="(119, 1)" clone_start="1" clone_end="9">
			<code function_name="Brakeinfo74::braking_torque_request(const std::uint8_t* bytes, int32_t length) const">double Brakeinfo74::braking_torque_request(const std::uint8_t* bytes,
                                           int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 4);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 4.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(35, 0)" endLine="(43, 1)" clone_start="1" clone_end="9">
			<code function_name="Throttleinfo75::engine_rpm(const std::uint8_t* bytes, int32_t length) const">double Throttleinfo75::engine_rpm(const std::uint8_t* bytes,
                                  int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.25;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(121, 0)" endLine="(127, 1)" clone_start="1" clone_end="5">
			<code function_name="Brakeinfo74::hill_start_assist_status(const std::uint8_t* bytes, int32_t length) const">int32_t Brakeinfo74::hill_start_assist_status(const std::uint8_t* bytes,
                                              int32_t length) const {
  // see table for status code
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(4, 3);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(45, 0)" endLine="(53, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttleinfo75::acc_pedal_percent(const std::uint8_t* bytes, int32_t length) const">double Throttleinfo75::acc_pedal_percent(const std::uint8_t* bytes,
                                         int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 2);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.1;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\parser_nodelet.cpp" startLine="(30, 4)" endLine="(30, 22)" clone_start="1" clone_end="1">
			<code function_name="ParserNodelet()">    ParserNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\stream_nodelet.cpp" startLine="(40, 4)" endLine="(40, 22)" clone_start="1" clone_end="1">
			<code function_name="StreamNodelet()">    StreamNodelet() {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\parser_nodelet.cpp" startLine="(31, 4)" endLine="(31, 23)" clone_start="1" clone_end="1">
			<code function_name="~ParserNodelet()">    ~ParserNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\stream_nodelet.cpp" startLine="(41, 4)" endLine="(41, 23)" clone_start="1" clone_end="1">
			<code function_name="~StreamNodelet()">    ~StreamNodelet() {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\parser_nodelet.cpp" startLine="(39, 0)" endLine="(71, 1)" clone_start="1" clone_end="6">
			<code function_name="ParserNodelet::onInit()">void ParserNodelet::onInit() {
    ros::NodeHandle&amp; nh = getPrivateNodeHandle();
    std::string gnss_conf;
    std::string raw_data_topic;
    std::string gpgga_topic;
    std::string corr_imu_topic;
    std::string odometry_topic;
    std::string gnss_status_topic;
    std::string ins_status_topic;

    nh.param("gnss_conf", gnss_conf, std::string("./conf/gnss_conf.txt"));
    nh.param("raw_data_topic", raw_data_topic, std::string("/apollo/sensor/gnss/raw_data"));
    nh.param("gpgga_topic", gpgga_topic, std::string("/apollo/sensor/gnss/gpgga"));
    nh.param("corr_imu_topic", corr_imu_topic, std::string("/apollo/sensor/gnss/corrected_imu"));
    nh.param("odometry_topic", odometry_topic, std::string("/apollo/sensor/gnss/odometry"));
    nh.param("gnss_status_topic", gnss_status_topic, std::string("/apollo/sensor/gnss/gnss_status"));
    nh.param("ins_status_topic", ins_status_topic, std::string("/apollo/sensor/gnss/ins_status"));

    _data_parser.reset(new DataParser(
                                nh,
                                raw_data_topic,
                                gpgga_topic,
                                corr_imu_topic,
                                odometry_topic,
                                gnss_status_topic,
                                ins_status_topic));
    if (!_data_parser-&gt;init(gnss_conf)) {
        ROS_ERROR("Init parser nodelet failed.");
        ROS_ERROR_STREAM("Init parser nodelet failed.");
        return;
    }
    ROS_INFO("Init parser nodelet success.");
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\stream_nodelet.cpp" startLine="(49, 0)" endLine="(73, 1)" clone_start="1" clone_end="6">
			<code function_name="StreamNodelet::onInit()">void StreamNodelet::onInit() {
    ros::NodeHandle&amp; nh = getPrivateNodeHandle();
    std::string gnss_conf;
    std::string raw_data_topic;
    std::string rtcm_data_topic;
    std::string stream_status_topic;


    nh.param("gnss_conf", gnss_conf, std::string("./conf/gnss_conf.txt"));
    nh.param("raw_data_topic", raw_data_topic, std::string("/apollo/sensor/gnss/raw_data"));
    nh.param("rtcm_data_topic", rtcm_data_topic, std::string("/apollo/sensor/gnss/rtcm_data"));
    nh.param("stream_status_topic", stream_status_topic, std::string("/apollo/sensor/gnss/stream_status"));

    ROS_INFO_STREAM("gnss conf: " &lt;&lt; gnss_conf);
    ROS_INFO_STREAM("raw data topic: " &lt;&lt; raw_data_topic);

    init_signal();
    _raw_stream.reset(new RawStream(nh, getName(), raw_data_topic, rtcm_data_topic, stream_status_topic));
    if (!_raw_stream-&gt;init(gnss_conf)) {
        ROS_ERROR("Init stream nodelet failed.");
        ROS_ERROR_STREAM("Init stream nodelet failed.");
        return;
    }
    ROS_INFO("Init stream nodelet success.");
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\controller\lat_controller.cc" startLine="(52, 0)" endLine="(69, 1)" clone_start="4" clone_end="16">
			<code function_name="WriteHeaders(std::ofstream&amp; file_stream)">void WriteHeaders(std::ofstream&amp; file_stream) {
  file_stream &lt;&lt; "current_lateral_error,"
              &lt;&lt; "current_ref_heading,"
              &lt;&lt; "current_heading,"
              &lt;&lt; "current_heading_error,"
              &lt;&lt; "heading_error_rate,"
              &lt;&lt; "lateral_error_rate,"
              &lt;&lt; "current_curvature,"
              &lt;&lt; "steer_angle,"
              &lt;&lt; "steer_angle_feedforward,"
              &lt;&lt; "steer_angle_lateral_contribution,"
              &lt;&lt; "steer_angle_lateral_rate_contribution,"
              &lt;&lt; "steer_angle_heading_contribution,"
              &lt;&lt; "steer_angle_heading_rate_contribution,"
              &lt;&lt; "steer_angle_feedback,"
              &lt;&lt; "steering_position,"
              &lt;&lt; "v" &lt;&lt; std::endl;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\control\controller\lat_controller.cc" startLine="(52, 0)" endLine="(69, 1)" clone_start="3" clone_end="15">
			<code function_name="WriteHeaders(std::ofstream&amp; file_stream)">void WriteHeaders(std::ofstream&amp; file_stream) {
  file_stream &lt;&lt; "current_lateral_error,"
              &lt;&lt; "current_ref_heading,"
              &lt;&lt; "current_heading,"
              &lt;&lt; "current_heading_error,"
              &lt;&lt; "heading_error_rate,"
              &lt;&lt; "lateral_error_rate,"
              &lt;&lt; "current_curvature,"
              &lt;&lt; "steer_angle,"
              &lt;&lt; "steer_angle_feedforward,"
              &lt;&lt; "steer_angle_lateral_contribution,"
              &lt;&lt; "steer_angle_lateral_rate_contribution,"
              &lt;&lt; "steer_angle_heading_contribution,"
              &lt;&lt; "steer_angle_heading_rate_contribution,"
              &lt;&lt; "steer_angle_feedback,"
              &lt;&lt; "steering_position,"
              &lt;&lt; "v" &lt;&lt; std::endl;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\localization\camera\camera_localization.cc" startLine="(82, 0)" endLine="(135, 1)" clone_start="13" clone_end="32">
			<code function_name="CameraLocalization::OnTimer(const ros::TimerEvent &amp;event)">void CameraLocalization::OnTimer(const ros::TimerEvent &amp;event) {
  double time_delay = apollo::common::time::ToSecond(Clock::Now()) -
                      last_received_timestamp_sec_;
  MonitorBuffer buffer(&amp;monitor_);
  if (FLAGS_enable_gps_timestamp &amp;&amp;
      time_delay &gt; FLAGS_gps_time_delay_tolerance) {
    buffer.ERROR() &lt;&lt; "GPS message time delay: " &lt;&lt; time_delay;
    buffer.PrintLog();
  }
  if (FLAGS_enable_camera_timestamp &amp;&amp;
      time_delay &gt; FLAGS_camera_time_delay_tolerance) {
    AERROR &lt;&lt; "Camera message time delay: " &lt;&lt; time_delay;
    buffer.ERROR() &lt;&lt; "Camera message time delay: " &lt;&lt; time_delay;
    buffer.PrintLog();
  }

  // Take a snapshot of the current received messages.
  AdapterManager::Observe();

  if (AdapterManager::GetGps()-&gt;Empty()) {
    AERROR &lt;&lt; "GPS message buffer is empty.";
    if (service_started_) {
      buffer.ERROR("GPS message buffer is empty.");
    }
    return;
  }
  if (AdapterManager::GetCamera()-&gt;Empty()) {
    AERROR &lt;&lt; "Camera message buffer is empty.";
    if (service_started_) {
      buffer.ERROR("Camera message buffer is empty.");
    }
    return;
  }
  if (use_imu_ &amp;&amp; AdapterManager::GetImu()-&gt;Empty()) {
    AERROR &lt;&lt; "Imu message buffer is empty.";
    if (service_started_) {
      buffer.ERROR("Imu message buffer is empty.");
    }
    return;
  }

  // publish localization messages
  if (!PublishLocalization()) {
    buffer.ERROR("Publish localization failed");
    buffer.PrintLog();
    return;
  }
  service_started_ = true;

  // watch dog
  RunWatchDog();

  last_received_timestamp_sec_ = apollo::common::time::ToSecond(Clock::Now());
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\localization\rtk\rtk_localization.cc" startLine="(64, 0)" endLine="(100, 1)" clone_start="7" clone_end="26">
			<code function_name="RTKLocalization::OnTimer(const ros::TimerEvent &amp;event)">void RTKLocalization::OnTimer(const ros::TimerEvent &amp;event) {
  double time_delay = apollo::common::time::ToSecond(Clock::Now()) -
                      last_received_timestamp_sec_;
  apollo::common::monitor::MonitorBuffer buffer(&amp;monitor_);
  if (FLAGS_enable_gps_timestamp &amp;&amp;
      time_delay &gt; FLAGS_gps_time_delay_tolerance) {
    buffer.ERROR() &lt;&lt; "GPS message time delay: " &lt;&lt; time_delay;
    buffer.PrintLog();
  }

  // Take a snapshot of the current received messages.
  AdapterManager::Observe();

  if (AdapterManager::GetGps()-&gt;Empty()) {
    AERROR &lt;&lt; "GPS message buffer is empty.";
    if (service_started_) {
      buffer.ERROR("GPS message buffer is empty.");
    }
    return;
  }
  if (AdapterManager::GetImu()-&gt;Empty()) {
    AERROR &lt;&lt; "IMU message buffer is empty.";
    if (service_started_) {
      buffer.ERROR("IMU message buffer is empty.");
    }
    return;
  }

  // publish localization messages
  PublishLocalization();
  service_started_ = true;

  // watch dog
  RunWatchDog();

  last_received_timestamp_sec_ = apollo::common::time::ToSecond(Clock::Now());
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(64, 0)" endLine="(71, 1)" clone_start="1" clone_end="8">
			<code function_name="Gps6f::heading(const std::uint8_t* bytes, int32_t length) const">double Gps6f::heading(const std::uint8_t* bytes, int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(111, 0)" endLine="(119, 1)" clone_start="1" clone_end="9">
			<code function_name="Brakeinfo74::braking_torque_request(const std::uint8_t* bytes, int32_t length) const">double Brakeinfo74::braking_torque_request(const std::uint8_t* bytes,
                                           int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 4);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 4.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(136, 0)" endLine="(144, 1)" clone_start="1" clone_end="9">
			<code function_name="Brakeinfo74::braking_torque_actual(const std::uint8_t* bytes, int32_t length) const">double Brakeinfo74::braking_torque_actual(const std::uint8_t* bytes,
                                          int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 4);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 4.000000;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(73, 0)" endLine="(77, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6f::speed(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6f::speed(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 8);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(121, 0)" endLine="(127, 1)" clone_start="1" clone_end="7">
			<code function_name="Brakeinfo74::hill_start_assist_status(const std::uint8_t* bytes, int32_t length) const">int32_t Brakeinfo74::hill_start_assist_status(const std::uint8_t* bytes,
                                              int32_t length) const {
  // see table for status code
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(4, 3);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(146, 0)" endLine="(152, 1)" clone_start="1" clone_end="7">
			<code function_name="Brakeinfo74::hill_start_assist_mode(const std::uint8_t* bytes, int32_t length) const">int32_t Brakeinfo74::hill_start_assist_mode(const std::uint8_t* bytes,
                                            int32_t length) const {
  // see table for status code
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(4, 2);
  return x;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(79, 0)" endLine="(83, 1)" clone_start="1" clone_end="2">
			<code function_name="Gps6f::hdop(const std::uint8_t* bytes, int32_t length) const">double Gps6f::hdop(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 5);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(129, 0)" endLine="(134, 1)" clone_start="1" clone_end="4">
			<code function_name="Brakeinfo74::is_vehicle_stationary(const std::uint8_t* bytes, int32_t length) const">bool Brakeinfo74::is_vehicle_stationary(const std::uint8_t* bytes,
                                        int32_t length) const {
  // false for moving, true for stationary
  Byte frame(bytes + 1);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(154, 0)" endLine="(160, 1)" clone_start="1" clone_end="4">
			<code function_name="Brakeinfo74::parking_brake_status(const std::uint8_t* bytes, int32_t length) const">int32_t Brakeinfo74::parking_brake_status(const std::uint8_t* bytes,
                                          int32_t length) const {
  // see table for status code
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(6, 2);
  return x;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="17" clone_end="32">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="35" clone_end="50">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="89" clone_end="103">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(58, 0)" endLine="(61, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_neutral()">Gear66* Gear66::set_gear_neutral() {
  gear_ = 0x03;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\turnsignal_68.cc" startLine="(41, 0)" endLine="(44, 1)" clone_start="1" clone_end="4">
			<code function_name="Turnsignal68::set_turn_none()">Turnsignal68* Turnsignal68::set_turn_none() {
  turn_cmd_ = 0x00;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(63, 0)" endLine="(66, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_drive()">Gear66* Gear66::set_gear_drive() {
  gear_ = 0x04;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\turnsignal_68.cc" startLine="(46, 0)" endLine="(49, 1)" clone_start="1" clone_end="4">
			<code function_name="Turnsignal68::set_turn_left()">Turnsignal68* Turnsignal68::set_turn_left() {
  turn_cmd_ = 0x01;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(68, 0)" endLine="(71, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_low()">Gear66* Gear66::set_gear_low() {
  gear_ = 0x05;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\turnsignal_68.cc" startLine="(51, 0)" endLine="(54, 1)" clone_start="1" clone_end="4">
			<code function_name="Turnsignal68::set_turn_right()">Turnsignal68* Turnsignal68::set_turn_right() {
  turn_cmd_ = 0x02;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(74, 0)" endLine="(78, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_p(uint8_t* data, int32_t gear)">void Gear66::set_gear_p(uint8_t* data, int32_t gear) {
  gear = ProtocolData::BoundedValue(0, 5, gear);
  Byte frame(data + 0);
  frame.set_value(gear, 0, 3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\turnsignal_68.cc" startLine="(58, 0)" endLine="(62, 1)" clone_start="1" clone_end="4">
			<code function_name="Turnsignal68::set_turn_cmd_p(uint8_t* data, int32_t turn_cmd)">void Turnsignal68::set_turn_cmd_p(uint8_t* data, int32_t turn_cmd) {
  turn_cmd = ProtocolData::BoundedValue(0, 3, turn_cmd);
  Byte frame(data + 0);
  frame.set_value(turn_cmd, 0, 2);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\tests\test_monitor.cpp" startLine="(38, 0)" endLine="(65, 1)" clone_start="2" clone_end="17">
			<code function_name="stream_status_callback(const apollo::common::gnss_status::StreamStatus &amp;stream_status)">void stream_status_callback(const apollo::common::gnss_status::StreamStatus &amp;stream_status) {
    switch (stream_status.ins_stream_type()) {
    case apollo::common::gnss_status::StreamStatus::CONNECTED:
        fprintf(stdout, "INS stream is CONNECTED.\r\n");
        break;
    case apollo::common::gnss_status::StreamStatus::DISCONNECTED:
        fprintf(stdout, "INS stream is DISCONNECTED.\r\n");
        break;
    }

    switch (stream_status.rtk_stream_in_type()) {
    case apollo::common::gnss_status::StreamStatus::CONNECTED:
        fprintf(stdout, "rtk stream in is CONNECTED.\r\n");
        break;
    case apollo::common::gnss_status::StreamStatus::DISCONNECTED:
        fprintf(stdout, "rtk stream in is DISCONNECTED.\r\n");
        break;
    }

    switch (stream_status.rtk_stream_out_type()) {
    case apollo::common::gnss_status::StreamStatus::CONNECTED:
        fprintf(stdout, "rtk stream out CONNECTED.\r\n");
        break;
    case apollo::common::gnss_status::StreamStatus::DISCONNECTED:
        fprintf(stdout, "rtk stream out DISCONNECTED.\r\n");
        break;
    }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\tests\test_monitor.cpp" startLine="(38, 0)" endLine="(65, 1)" clone_start="11" clone_end="26">
			<code function_name="stream_status_callback(const apollo::common::gnss_status::StreamStatus &amp;stream_status)">void stream_status_callback(const apollo::common::gnss_status::StreamStatus &amp;stream_status) {
    switch (stream_status.ins_stream_type()) {
    case apollo::common::gnss_status::StreamStatus::CONNECTED:
        fprintf(stdout, "INS stream is CONNECTED.\r\n");
        break;
    case apollo::common::gnss_status::StreamStatus::DISCONNECTED:
        fprintf(stdout, "INS stream is DISCONNECTED.\r\n");
        break;
    }

    switch (stream_status.rtk_stream_in_type()) {
    case apollo::common::gnss_status::StreamStatus::CONNECTED:
        fprintf(stdout, "rtk stream in is CONNECTED.\r\n");
        break;
    case apollo::common::gnss_status::StreamStatus::DISCONNECTED:
        fprintf(stdout, "rtk stream in is DISCONNECTED.\r\n");
        break;
    }

    switch (stream_status.rtk_stream_out_type()) {
    case apollo::common::gnss_status::StreamStatus::CONNECTED:
        fprintf(stdout, "rtk stream out CONNECTED.\r\n");
        break;
    case apollo::common::gnss_status::StreamStatus::DISCONNECTED:
        fprintf(stdout, "rtk stream out DISCONNECTED.\r\n");
        break;
    }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(87, 0)" endLine="(99, 1)" clone_start="12" clone_end="13">
			<code function_name="Steering65::reported_steering_angle_cmd(const std::uint8_t* bytes, int32_t length) const">double Steering65::reported_steering_angle_cmd(const std::uint8_t* bytes,
                                               int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x8000) {
    value = value - 0x10000;
  }

  return value * 0.100000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(35, 0)" endLine="(43, 1)" clone_start="8" clone_end="9">
			<code function_name="Throttleinfo75::engine_rpm(const std::uint8_t* bytes, int32_t length) const">double Throttleinfo75::engine_rpm(const std::uint8_t* bytes,
                                  int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.25;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(101, 0)" endLine="(109, 1)" clone_start="1" clone_end="9">
			<code function_name="Steering65::vehicle_speed(const std::uint8_t* bytes, int32_t length) const">double Steering65::vehicle_speed(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(45, 0)" endLine="(53, 1)" clone_start="1" clone_end="9">
			<code function_name="Throttleinfo75::acc_pedal_percent(const std::uint8_t* bytes, int32_t length) const">double Throttleinfo75::acc_pedal_percent(const std::uint8_t* bytes,
                                         int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 2);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.1;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(111, 0)" endLine="(119, 1)" clone_start="1" clone_end="8">
			<code function_name="Steering65::epas_torque(const std::uint8_t* bytes, int32_t length) const">double Steering65::epas_torque(const std::uint8_t* bytes,
                               int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 8);
  if (x &gt; 0x7F) {
    x -= 0x100;
  }
  return x * 0.062500;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(55, 0)" endLine="(63, 1)" clone_start="1" clone_end="8">
			<code function_name="Throttleinfo75::acc_pedal_rate(const std::uint8_t* bytes, int32_t length) const">double Throttleinfo75::acc_pedal_rate(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 8);
  if (x &gt; 0x3F) {
    x -= 0x100;
  }
  return x * 0.04;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(61, 0)" endLine="(71, 1)" clone_start="1" clone_end="11">
			<code function_name="UdpStream::UdpStream(const char* address,uint16_t port, uint32_t timeout_usec)">UdpStream::UdpStream(const char* address,
                     uint16_t port,
                     uint32_t timeout_usec) :
    _sockfd(-1),
    _errno(0) {
    _peer_addr = inet_addr(address);
    _peer_port = htons(port);
    _timeout_usec = timeout_usec;
    // call open or call open in connect later

}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(37, 0)" endLine="(46, 1)" clone_start="1" clone_end="10">
			<code function_name="TcpStream::TcpStream(const char* address,uint16_t port, uint32_t timeout_usec)">TcpStream::TcpStream(const char* address,
                     uint16_t port,
                     uint32_t timeout_usec) :
    _sockfd(-1),
    _errno(0) {
    _peer_addr = inet_addr(address);
    _peer_port = htons(port);
    _timeout_usec = timeout_usec;

}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(73, 0)" endLine="(75, 1)" clone_start="1" clone_end="3">
			<code function_name="UdpStream::~UdpStream()">UdpStream::~UdpStream() {
    this-&gt;close();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(48, 0)" endLine="(50, 1)" clone_start="1" clone_end="3">
			<code function_name="TcpStream::~TcpStream()">TcpStream::~TcpStream() {
    this-&gt;close();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(77, 0)" endLine="(137, 1)" clone_start="1" clone_end="8">
			<code function_name="UdpStream::open()">void UdpStream::open() {
    int fd = -1;

    fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (fd &lt; 0) {
        // error
        ROS_ERROR_STREAM("Create socket failed, errno: " &lt;&lt; errno &lt;&lt; ", " &lt;&lt; strerror(errno));
        return ;
    }

    // block or not block
    if (_timeout_usec != 0) {
        int flags  = fcntl(fd, F_GETFL, 0);
        if (flags == -1) {
            ::close(fd);
            ROS_ERROR_STREAM("fcntl get flag failed, errno: " &lt;&lt; errno &lt;&lt; ", " &lt;&lt; strerror(errno));
            return ;
        }

        if (fcntl(fd, F_SETFL, flags &amp; ~O_NONBLOCK) == -1) {
            ::close(fd);
            ROS_ERROR_STREAM("fcntl set block failed, errno: " &lt;&lt; errno &lt;&lt; ", " &lt;&lt; strerror(errno));
            return ;
        }

        struct timeval block_to = {_timeout_usec / 1000000,
                                                     _timeout_usec % 1000000};
        if (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO,
                       (char *)&amp;block_to, sizeof(block_to)) &lt; 0) {
            ::close(fd);
            ROS_ERROR_STREAM("setsockopt set rcv timeout failed, errno: "
                       &lt;&lt; errno &lt;&lt; ", " &lt;&lt; strerror(errno));
            return ;
        }

        if (setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO,
                            (char *)&amp;block_to, sizeof(block_to)) &lt; 0) {
            ::close(fd);
            ROS_ERROR_STREAM("setsockopt set snd timeout failed, errno: "
                       &lt;&lt; errno &lt;&lt; ", " &lt;&lt; strerror(errno));
            return ;
        }
    } else {
        int flags  = fcntl(fd, F_GETFL, 0);
        if (flags == -1) {
            ::close(fd);
            ROS_ERROR_STREAM("fcntl get flag failed, errno: " &lt;&lt; errno &lt;&lt; ", " &lt;&lt; strerror(errno));
            return ;
        }

        if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {
            ::close(fd);
            ROS_ERROR_STREAM("fcntl set non block failed, errno: "
                             &lt;&lt; errno &lt;&lt; ", " &lt;&lt; strerror(errno));
            return ;
        }
    }

    _sockfd = fd;
    return ;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(52, 0)" endLine="(63, 1)" clone_start="1" clone_end="8">
			<code function_name="TcpStream::open()">void TcpStream::open() {
    int fd = -1;

    fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (fd &lt; 0) {
        // error
        ROS_ERROR_STREAM("create socket failed, errno: " &lt;&lt; errno &lt;&lt; ", " &lt;&lt; strerror(errno));
        return ;
    }

    _sockfd = fd;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="3" clone_end="20">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length,
                        ChassisDetail* chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="36" clone_end="50">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length,
                        ChassisDetail* chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(72, 0)" endLine="(76, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::seconds(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::seconds(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 5);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(73, 0)" endLine="(77, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6f::speed(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6f::speed(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 8);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(78, 0)" endLine="(83, 1)" clone_start="1" clone_end="6">
			<code function_name="Gps6e::compass_direction(const std::uint8_t* bytes, int32_t length) const">double Gps6e::compass_direction(const std::uint8_t* bytes,
                                int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 4);
  return x * 45.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(79, 0)" endLine="(83, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6f::hdop(const std::uint8_t* bytes, int32_t length) const">double Gps6f::hdop(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 5);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(85, 0)" endLine="(89, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::pdop(const std::uint8_t* bytes, int32_t length) const">double Gps6e::pdop(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 7);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(85, 0)" endLine="(89, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6f::vdop(const std::uint8_t* bytes, int32_t length) const">double Gps6f::vdop(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(91, 0)" endLine="(94, 1)" clone_start="1" clone_end="2">
			<code function_name="Gps6e::is_gps_fault(const std::uint8_t* bytes, int32_t length) const">bool Gps6e::is_gps_fault(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(91, 0)" endLine="(95, 1)" clone_start="1" clone_end="2">
			<code function_name="Gps6f::fix_quality(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6f::fix_quality(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 7);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\localization\rtk\rtk_localization.h" startLine="(54, 2)" endLine="(54, 39)" clone_start="1" clone_end="1">
			<code function_name="~RTKLocalization()">  virtual ~RTKLocalization() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\localization\camera\camera_localization.h" startLine="(56, 2)" endLine="(56, 42)" clone_start="1" clone_end="1">
			<code function_name="~CameraLocalization()">  virtual ~CameraLocalization() = default;</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="21" clone_end="36">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length,
                        ChassisDetail* chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="53" clone_end="70">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length,
                        ChassisDetail* chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\localization\rtk\rtk_localization.cc" startLine="(249, 0)" endLine="(352, 1)" clone_start="78" clone_end="99">
			<code function_name="RTKLocalization::ComposeLocalizationMsg(const ::apollo::localization::Gps &amp;gps_msg, const ::apollo::localization::Imu &amp;imu_msg, LocalizationEstimate *localization)">void RTKLocalization::ComposeLocalizationMsg(
    const ::apollo::localization::Gps &amp;gps_msg,
    const ::apollo::localization::Imu &amp;imu_msg,
    LocalizationEstimate *localization) {
  localization-&gt;Clear();

  // header
  AdapterManager::FillLocalizationHeader(FLAGS_localization_module_name,
                                         localization-&gt;mutable_header());
  if (FLAGS_enable_gps_timestamp) {
    // copy time stamp, do NOT use Clock::Now()
    localization-&gt;mutable_header()-&gt;set_timestamp_sec(
        gps_msg.header().timestamp_sec());
  }

  // combine gps and imu
  auto mutable_pose = localization-&gt;mutable_pose();
  if (gps_msg.has_localization()) {
    const auto &amp;pose = gps_msg.localization();

    if (pose.has_position()) {
      // position
      // world frame -&gt; map frame
      mutable_pose-&gt;mutable_position()-&gt;set_x(pose.position().x() -
                                              map_offset_[0]);
      mutable_pose-&gt;mutable_position()-&gt;set_y(pose.position().y() -
                                              map_offset_[1]);
      mutable_pose-&gt;mutable_position()-&gt;set_z(pose.position().z() -
                                              map_offset_[2]);
    }

    // orientation
    if (pose.has_orientation()) {
      mutable_pose-&gt;mutable_orientation()-&gt;CopyFrom(pose.orientation());
      double heading = ::apollo::common::math::QuaternionToHeading(
          pose.orientation().qw(), pose.orientation().qx(),
          pose.orientation().qy(), pose.orientation().qz());
      mutable_pose-&gt;set_heading(heading);
    }
    // linear velocity
    if (pose.has_linear_velocity()) {
      mutable_pose-&gt;mutable_linear_velocity()-&gt;CopyFrom(pose.linear_velocity());
    }
  }

  if (imu_msg.has_imu()) {
    const auto &amp;imu = imu_msg.imu();
    // linear acceleration
    if (imu.has_linear_acceleration()) {
      if (FLAGS_enable_map_reference_unify) {
        if (localization-&gt;pose().has_orientation()) {
          // linear_acceleration:
          // convert from vehicle reference to map reference
          Vector3d orig(imu.linear_acceleration().x(),
                        imu.linear_acceleration().y(),
                        imu.linear_acceleration().z());
          Vector3d vec = ::apollo::common::math::QuaternionRotate(
              localization-&gt;pose().orientation(), orig);
          mutable_pose-&gt;mutable_linear_acceleration()-&gt;set_x(vec[0]);
          mutable_pose-&gt;mutable_linear_acceleration()-&gt;set_y(vec[1]);
          mutable_pose-&gt;mutable_linear_acceleration()-&gt;set_z(vec[2]);

          // linear_acceleration_vfr
          mutable_pose-&gt;mutable_linear_acceleration_vrf()-&gt;CopyFrom(
              imu.linear_acceleration());

        } else {
          AERROR &lt;&lt; "[PrepareLocalizationMsg]: "
                 &lt;&lt; "fail to convert linear_acceleration";
        }
      } else {
        mutable_pose-&gt;mutable_linear_acceleration()-&gt;CopyFrom(
            imu.linear_acceleration());
      }
    }

    // angular velocity
    if (imu.has_angular_velocity()) {
      if (FLAGS_enable_map_reference_unify) {
        if (localization-&gt;pose().has_orientation()) {
          // angular_velocity:
          // convert from vehicle reference to map reference
          Vector3d orig(imu.angular_velocity().x(), imu.angular_velocity().y(),
                        imu.angular_velocity().z());
          Vector3d vec = ::apollo::common::math::QuaternionRotate(
              localization-&gt;pose().orientation(), orig);
          mutable_pose-&gt;mutable_angular_velocity()-&gt;set_x(vec[0]);
          mutable_pose-&gt;mutable_angular_velocity()-&gt;set_y(vec[1]);
          mutable_pose-&gt;mutable_angular_velocity()-&gt;set_z(vec[2]);

          // angular_velocity_vf
          mutable_pose-&gt;mutable_angular_velocity_vrf()-&gt;CopyFrom(
              imu.angular_velocity());
        } else {
          AERROR &lt;&lt; "[PrepareLocalizationMsg]: "
                 &lt;&lt; "fail to convert angular_velocity";
        }
      } else {
        mutable_pose-&gt;mutable_angular_velocity()-&gt;CopyFrom(
            imu.angular_velocity());
      }
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\localization\rtk\rtk_localization.cc" startLine="(249, 0)" endLine="(352, 1)" clone_start="49" clone_end="72">
			<code function_name="RTKLocalization::ComposeLocalizationMsg(const ::apollo::localization::Gps &amp;gps_msg, const ::apollo::localization::Imu &amp;imu_msg, LocalizationEstimate *localization)">void RTKLocalization::ComposeLocalizationMsg(
    const ::apollo::localization::Gps &amp;gps_msg,
    const ::apollo::localization::Imu &amp;imu_msg,
    LocalizationEstimate *localization) {
  localization-&gt;Clear();

  // header
  AdapterManager::FillLocalizationHeader(FLAGS_localization_module_name,
                                         localization-&gt;mutable_header());
  if (FLAGS_enable_gps_timestamp) {
    // copy time stamp, do NOT use Clock::Now()
    localization-&gt;mutable_header()-&gt;set_timestamp_sec(
        gps_msg.header().timestamp_sec());
  }

  // combine gps and imu
  auto mutable_pose = localization-&gt;mutable_pose();
  if (gps_msg.has_localization()) {
    const auto &amp;pose = gps_msg.localization();

    if (pose.has_position()) {
      // position
      // world frame -&gt; map frame
      mutable_pose-&gt;mutable_position()-&gt;set_x(pose.position().x() -
                                              map_offset_[0]);
      mutable_pose-&gt;mutable_position()-&gt;set_y(pose.position().y() -
                                              map_offset_[1]);
      mutable_pose-&gt;mutable_position()-&gt;set_z(pose.position().z() -
                                              map_offset_[2]);
    }

    // orientation
    if (pose.has_orientation()) {
      mutable_pose-&gt;mutable_orientation()-&gt;CopyFrom(pose.orientation());
      double heading = ::apollo::common::math::QuaternionToHeading(
          pose.orientation().qw(), pose.orientation().qx(),
          pose.orientation().qy(), pose.orientation().qz());
      mutable_pose-&gt;set_heading(heading);
    }
    // linear velocity
    if (pose.has_linear_velocity()) {
      mutable_pose-&gt;mutable_linear_velocity()-&gt;CopyFrom(pose.linear_velocity());
    }
  }

  if (imu_msg.has_imu()) {
    const auto &amp;imu = imu_msg.imu();
    // linear acceleration
    if (imu.has_linear_acceleration()) {
      if (FLAGS_enable_map_reference_unify) {
        if (localization-&gt;pose().has_orientation()) {
          // linear_acceleration:
          // convert from vehicle reference to map reference
          Vector3d orig(imu.linear_acceleration().x(),
                        imu.linear_acceleration().y(),
                        imu.linear_acceleration().z());
          Vector3d vec = ::apollo::common::math::QuaternionRotate(
              localization-&gt;pose().orientation(), orig);
          mutable_pose-&gt;mutable_linear_acceleration()-&gt;set_x(vec[0]);
          mutable_pose-&gt;mutable_linear_acceleration()-&gt;set_y(vec[1]);
          mutable_pose-&gt;mutable_linear_acceleration()-&gt;set_z(vec[2]);

          // linear_acceleration_vfr
          mutable_pose-&gt;mutable_linear_acceleration_vrf()-&gt;CopyFrom(
              imu.linear_acceleration());

        } else {
          AERROR &lt;&lt; "[PrepareLocalizationMsg]: "
                 &lt;&lt; "fail to convert linear_acceleration";
        }
      } else {
        mutable_pose-&gt;mutable_linear_acceleration()-&gt;CopyFrom(
            imu.linear_acceleration());
      }
    }

    // angular velocity
    if (imu.has_angular_velocity()) {
      if (FLAGS_enable_map_reference_unify) {
        if (localization-&gt;pose().has_orientation()) {
          // angular_velocity:
          // convert from vehicle reference to map reference
          Vector3d orig(imu.angular_velocity().x(), imu.angular_velocity().y(),
                        imu.angular_velocity().z());
          Vector3d vec = ::apollo::common::math::QuaternionRotate(
              localization-&gt;pose().orientation(), orig);
          mutable_pose-&gt;mutable_angular_velocity()-&gt;set_x(vec[0]);
          mutable_pose-&gt;mutable_angular_velocity()-&gt;set_y(vec[1]);
          mutable_pose-&gt;mutable_angular_velocity()-&gt;set_z(vec[2]);

          // angular_velocity_vf
          mutable_pose-&gt;mutable_angular_velocity_vrf()-&gt;CopyFrom(
              imu.angular_velocity());
        } else {
          AERROR &lt;&lt; "[PrepareLocalizationMsg]: "
                 &lt;&lt; "fail to convert angular_velocity";
        }
      } else {
        mutable_pose-&gt;mutable_angular_velocity()-&gt;CopyFrom(
            imu.angular_velocity());
      }
    }
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\can_client\esd\esd_can_client.cc" startLine="(173, 0)" endLine="(282, 1)" clone_start="11" clone_end="24">
			<code function_name="EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus)">std::string EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus) {
  struct ERR2STR {
    NTCAN_RESULT ntstatus;
    const char *str;
  };

  int8_t str_buf[ERROR_BUF_SIZE];

  static const struct ERR2STR err2str[] = {
      {NTCAN_SUCCESS, "NTCAN_SUCCESS"},
      {NTCAN_RX_TIMEOUT, "NTCAN_RX_TIMEOUT"},
      {NTCAN_TX_TIMEOUT, "NTCAN_TX_TIMEOUT"},
      {NTCAN_TX_ERROR, "NTCAN_TX_ERROR"},
      {NTCAN_CONTR_OFF_BUS, "NTCAN_CONTR_OFF_BUS"},
      {NTCAN_CONTR_BUSY, "NTCAN_CONTR_BUSY"},
      {NTCAN_CONTR_WARN, "NTCAN_CONTR_WARN"},
      {NTCAN_NO_ID_ENABLED, "NTCAN_NO_ID_ENABLED"},
      {NTCAN_ID_ALREADY_ENABLED, "NTCAN_ID_ALREADY_ENABLED"},
      {NTCAN_ID_NOT_ENABLED, "NTCAN_ID_NOT_ENABLED"},
      {NTCAN_INVALID_FIRMWARE, "NTCAN_INVALID_FIRMWARE"},
      {NTCAN_MESSAGE_LOST, "NTCAN_MESSAGE_LOST"},
      {NTCAN_INVALID_PARAMETER, "NTCAN_INVALID_PARAMETER"},
      {NTCAN_INVALID_HANDLE, "NTCAN_INVALID_HANDLE"},
      {NTCAN_NET_NOT_FOUND, "NTCAN_NET_NOT_FOUND"},
#ifdef NTCAN_IO_INCOMPLETE
      {NTCAN_IO_INCOMPLETE, "NTCAN_IO_INCOMPLETE"},
#endif
#ifdef NTCAN_IO_PENDING
      {NTCAN_IO_PENDING, "NTCAN_IO_PENDING"},
#endif
#ifdef NTCAN_INVALID_HARDWARE
      {NTCAN_INVALID_HARDWARE, "NTCAN_INVALID_HARDWARE"},
#endif
#ifdef NTCAN_PENDING_WRITE
      {NTCAN_PENDING_WRITE, "NTCAN_PENDING_WRITE"},
#endif
#ifdef NTCAN_PENDING_READ
      {NTCAN_PENDING_READ, "NTCAN_PENDING_READ"},
#endif
#ifdef NTCAN_INVALID_DRIVER
      {NTCAN_INVALID_DRIVER, "NTCAN_INVALID_DRIVER"},
#endif
#ifdef NTCAN_OPERATION_ABORTED
      {NTCAN_OPERATION_ABORTED, "NTCAN_OPERATION_ABORTED"},
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
      {NTCAN_WRONG_DEVICE_STATE, "NTCAN_WRONG_DEVICE_STATE"},
#endif
      {NTCAN_INSUFFICIENT_RESOURCES, "NTCAN_INSUFFICIENT_RESOURCES"},
#ifdef NTCAN_HANDLE_FORCED_CLOSE
      {NTCAN_HANDLE_FORCED_CLOSE, "NTCAN_HANDLE_FORCED_CLOSE"},
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
      {NTCAN_NOT_IMPLEMENTED, "NTCAN_NOT_IMPLEMENTED"},
#endif
#ifdef NTCAN_NOT_SUPPORTED
      {NTCAN_NOT_SUPPORTED, "NTCAN_NOT_SUPPORTED"},
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
      {NTCAN_SOCK_CONN_TIMEOUT, "NTCAN_SOCK_CONN_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
      {NTCAN_SOCK_CMD_TIMEOUT, "NTCAN_SOCK_CMD_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
      {NTCAN_SOCK_HOST_NOT_FOUND, "NTCAN_SOCK_HOST_NOT_FOUND"},
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
      {NTCAN_CONTR_ERR_PASSIVE, "NTCAN_CONTR_ERR_PASSIVE"},
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
      {NTCAN_ERROR_NO_BAUDRATE, "NTCAN_ERROR_NO_BAUDRATE"},
#endif
#ifdef NTCAN_ERROR_LOM
      {NTCAN_ERROR_LOM, "NTCAN_ERROR_LOM"},
#endif
      {(NTCAN_RESULT)0xffffffff, "NTCAN_UNKNOWN"} /* stop-mark */
  };

  const struct ERR2STR *es = err2str;

  do {
    if (es-&gt;ntstatus == ntstatus) {
      break;
    }
    es++;
  } while ((uint32_t)es-&gt;ntstatus != 0xffffffff);

#ifdef NTCAN_ERROR_FORMAT_LONG
  {
    NTCAN_RESULT res;
    char sz_error_text[60];

    res = canFormatError(ntstatus, NTCAN_ERROR_FORMAT_LONG, sz_error_text,
                         sizeof(sz_error_text) - 1);
    if (NTCAN_SUCCESS == res) {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s - %s",
               es-&gt;str, sz_error_text);
    } else {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
               es-&gt;str, ntstatus);
    }
  }
#else
  snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
           es-&gt;str, ntstatus);
#endif /* of NTCAN_ERROR_FORMAT_LONG */

  return std::string((const char *)(str_buf));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\can_client\esd\esd_can_client.cc" startLine="(173, 0)" endLine="(282, 1)" clone_start="10" clone_end="23">
			<code function_name="EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus)">std::string EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus) {
  struct ERR2STR {
    NTCAN_RESULT ntstatus;
    const char *str;
  };

  int8_t str_buf[ERROR_BUF_SIZE];

  static const struct ERR2STR err2str[] = {
      {NTCAN_SUCCESS, "NTCAN_SUCCESS"},
      {NTCAN_RX_TIMEOUT, "NTCAN_RX_TIMEOUT"},
      {NTCAN_TX_TIMEOUT, "NTCAN_TX_TIMEOUT"},
      {NTCAN_TX_ERROR, "NTCAN_TX_ERROR"},
      {NTCAN_CONTR_OFF_BUS, "NTCAN_CONTR_OFF_BUS"},
      {NTCAN_CONTR_BUSY, "NTCAN_CONTR_BUSY"},
      {NTCAN_CONTR_WARN, "NTCAN_CONTR_WARN"},
      {NTCAN_NO_ID_ENABLED, "NTCAN_NO_ID_ENABLED"},
      {NTCAN_ID_ALREADY_ENABLED, "NTCAN_ID_ALREADY_ENABLED"},
      {NTCAN_ID_NOT_ENABLED, "NTCAN_ID_NOT_ENABLED"},
      {NTCAN_INVALID_FIRMWARE, "NTCAN_INVALID_FIRMWARE"},
      {NTCAN_MESSAGE_LOST, "NTCAN_MESSAGE_LOST"},
      {NTCAN_INVALID_PARAMETER, "NTCAN_INVALID_PARAMETER"},
      {NTCAN_INVALID_HANDLE, "NTCAN_INVALID_HANDLE"},
      {NTCAN_NET_NOT_FOUND, "NTCAN_NET_NOT_FOUND"},
#ifdef NTCAN_IO_INCOMPLETE
      {NTCAN_IO_INCOMPLETE, "NTCAN_IO_INCOMPLETE"},
#endif
#ifdef NTCAN_IO_PENDING
      {NTCAN_IO_PENDING, "NTCAN_IO_PENDING"},
#endif
#ifdef NTCAN_INVALID_HARDWARE
      {NTCAN_INVALID_HARDWARE, "NTCAN_INVALID_HARDWARE"},
#endif
#ifdef NTCAN_PENDING_WRITE
      {NTCAN_PENDING_WRITE, "NTCAN_PENDING_WRITE"},
#endif
#ifdef NTCAN_PENDING_READ
      {NTCAN_PENDING_READ, "NTCAN_PENDING_READ"},
#endif
#ifdef NTCAN_INVALID_DRIVER
      {NTCAN_INVALID_DRIVER, "NTCAN_INVALID_DRIVER"},
#endif
#ifdef NTCAN_OPERATION_ABORTED
      {NTCAN_OPERATION_ABORTED, "NTCAN_OPERATION_ABORTED"},
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
      {NTCAN_WRONG_DEVICE_STATE, "NTCAN_WRONG_DEVICE_STATE"},
#endif
      {NTCAN_INSUFFICIENT_RESOURCES, "NTCAN_INSUFFICIENT_RESOURCES"},
#ifdef NTCAN_HANDLE_FORCED_CLOSE
      {NTCAN_HANDLE_FORCED_CLOSE, "NTCAN_HANDLE_FORCED_CLOSE"},
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
      {NTCAN_NOT_IMPLEMENTED, "NTCAN_NOT_IMPLEMENTED"},
#endif
#ifdef NTCAN_NOT_SUPPORTED
      {NTCAN_NOT_SUPPORTED, "NTCAN_NOT_SUPPORTED"},
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
      {NTCAN_SOCK_CONN_TIMEOUT, "NTCAN_SOCK_CONN_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
      {NTCAN_SOCK_CMD_TIMEOUT, "NTCAN_SOCK_CMD_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
      {NTCAN_SOCK_HOST_NOT_FOUND, "NTCAN_SOCK_HOST_NOT_FOUND"},
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
      {NTCAN_CONTR_ERR_PASSIVE, "NTCAN_CONTR_ERR_PASSIVE"},
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
      {NTCAN_ERROR_NO_BAUDRATE, "NTCAN_ERROR_NO_BAUDRATE"},
#endif
#ifdef NTCAN_ERROR_LOM
      {NTCAN_ERROR_LOM, "NTCAN_ERROR_LOM"},
#endif
      {(NTCAN_RESULT)0xffffffff, "NTCAN_UNKNOWN"} /* stop-mark */
  };

  const struct ERR2STR *es = err2str;

  do {
    if (es-&gt;ntstatus == ntstatus) {
      break;
    }
    es++;
  } while ((uint32_t)es-&gt;ntstatus != 0xffffffff);

#ifdef NTCAN_ERROR_FORMAT_LONG
  {
    NTCAN_RESULT res;
    char sz_error_text[60];

    res = canFormatError(ntstatus, NTCAN_ERROR_FORMAT_LONG, sz_error_text,
                         sizeof(sz_error_text) - 1);
    if (NTCAN_SUCCESS == res) {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s - %s",
               es-&gt;str, sz_error_text);
    } else {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
               es-&gt;str, ntstatus);
    }
  }
#else
  snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
           es-&gt;str, ntstatus);
#endif /* of NTCAN_ERROR_FORMAT_LONG */

  return std::string((const char *)(str_buf));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(136, 0)" endLine="(144, 1)" clone_start="1" clone_end="9">
			<code function_name="Brakeinfo74::braking_torque_actual(const std::uint8_t* bytes, int32_t length) const">double Brakeinfo74::braking_torque_actual(const std::uint8_t* bytes,
                                          int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 4);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 4.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(64, 0)" endLine="(71, 1)" clone_start="1" clone_end="8">
			<code function_name="Gps6f::heading(const std::uint8_t* bytes, int32_t length) const">double Gps6f::heading(const std::uint8_t* bytes, int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(146, 0)" endLine="(152, 1)" clone_start="1" clone_end="7">
			<code function_name="Brakeinfo74::hill_start_assist_mode(const std::uint8_t* bytes, int32_t length) const">int32_t Brakeinfo74::hill_start_assist_mode(const std::uint8_t* bytes,
                                            int32_t length) const {
  // see table for status code
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(4, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(73, 0)" endLine="(77, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6f::speed(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6f::speed(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 8);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(154, 0)" endLine="(160, 1)" clone_start="1" clone_end="5">
			<code function_name="Brakeinfo74::parking_brake_status(const std::uint8_t* bytes, int32_t length) const">int32_t Brakeinfo74::parking_brake_status(const std::uint8_t* bytes,
                                          int32_t length) const {
  // see table for status code
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(6, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(79, 0)" endLine="(83, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6f::hdop(const std::uint8_t* bytes, int32_t length) const">double Gps6f::hdop(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 5);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(26, 0)" endLine="(55, 1)" clone_start="4" clone_end="26">
			<code function_name="Brake61::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Brake61::Parse(const std::uint8_t* bytes, int32_t length,
                    ChassisDetail* car_status) const {
  car_status-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_output(pedal_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  car_status-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(26, 0)" endLine="(55, 1)" clone_start="3" clone_end="24">
			<code function_name="Brake61::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Brake61::Parse(const std::uint8_t* bytes, int32_t length,
                    ChassisDetail* car_status) const {
  car_status-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_output(pedal_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  car_status-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(27, 0)" endLine="(30, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake60::GetPeriod() const">uint32_t Brake60::GetPeriod() const {
  static const uint32_t PERIOD = 20 * 1000;
  return PERIOD;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(28, 0)" endLine="(31, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle62::GetPeriod() const">uint32_t Throttle62::GetPeriod() const {
  static const uint32_t PERIOD = 20 * 1000;
  return PERIOD;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(32, 0)" endLine="(38, 1)" clone_start="1" clone_end="7">
			<code function_name="Brake60::UpdateData(uint8_t* data)">void Brake60::UpdateData(uint8_t* data) {
  set_pedal_p(data, pedal_cmd_);
  set_boo_cmd_p(data, boo_cmd_);
  set_enable_p(data, pedal_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_watchdog_counter_p(data, watchdog_counter_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(33, 0)" endLine="(39, 1)" clone_start="1" clone_end="7">
			<code function_name="Throttle62::UpdateData(uint8_t* data)">void Throttle62::UpdateData(uint8_t* data) {
  set_pedal_p(data, pedal_cmd_);
  set_enable_p(data, pedal_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_ignore_driver_override_p(data, ignore_driver_override_);
  set_watchdog_counter_p(data, watchdog_counter_);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(40, 0)" endLine="(47, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake60::Reset()">void Brake60::Reset() {
  pedal_cmd_ = 0.0;
  boo_cmd_ = false;
  pedal_enable_ = false;
  clear_driver_override_flag_ = false;
  ignore_driver_override_ = false;
  watchdog_counter_ = 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(41, 0)" endLine="(47, 1)" clone_start="1" clone_end="5">
			<code function_name="Throttle62::Reset()">void Throttle62::Reset() {
  pedal_cmd_ = 0.0;
  pedal_enable_ = false;
  clear_driver_override_flag_ = false;
  ignore_driver_override_ = false;
  watchdog_counter_ = 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\version_7f.cc" startLine="(56, 0)" endLine="(61, 1)" clone_start="5" clone_end="6">
			<code function_name="Version7f::module_name(const std::uint8_t* bytes, int32_t length) const">int32_t Version7f::module_name(const std::uint8_t* bytes,
                               int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 8);
  return x;  // 0x03 means Steering/Shifter, otherwise ignore
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\version_7f.cc" startLine="(63, 0)" endLine="(71, 1)" clone_start="8" clone_end="9">
			<code function_name="Version7f::major_version(const std::uint8_t* bytes, int32_t length) const">int32_t Version7f::major_version(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\version_7f.cc" startLine="(63, 0)" endLine="(71, 1)" clone_start="1" clone_end="9">
			<code function_name="Version7f::major_version(const std::uint8_t* bytes, int32_t length) const">int32_t Version7f::major_version(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\version_7f.cc" startLine="(73, 0)" endLine="(81, 1)" clone_start="1" clone_end="9">
			<code function_name="Version7f::minor_version(const std::uint8_t* bytes, int32_t length) const">int32_t Version7f::minor_version(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\version_7f.cc" startLine="(73, 0)" endLine="(81, 1)" clone_start="1" clone_end="8">
			<code function_name="Version7f::minor_version(const std::uint8_t* bytes, int32_t length) const">int32_t Version7f::minor_version(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\version_7f.cc" startLine="(83, 0)" endLine="(91, 1)" clone_start="1" clone_end="8">
			<code function_name="Version7f::build_number(const std::uint8_t* bytes, int32_t length) const">int32_t Version7f::build_number(const std::uint8_t* bytes,
                                int32_t length) const {
  Byte frame_high(bytes + 7);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 6);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value;
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(83, 0)" endLine="(94, 1)" clone_start="11" clone_end="12">
			<code function_name="Brake61::pedal_output(const std::uint8_t* bytes, int32_t length) const">double Brake61::pedal_output(const std::uint8_t* bytes, int32_t length) const {
  // Pedal Output is the maximum of PI and PC
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(119, 0)" endLine="(125, 1)" clone_start="6" clone_end="7">
			<code function_name="Brake61::watchdog_counter_source(const std::uint8_t* bytes, int32_t length) const">int32_t Brake61::watchdog_counter_source(const std::uint8_t* bytes,
                                         int32_t length) const {
  // see table for status code
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(224, 0)" endLine="(229, 1)" clone_start="5" clone_end="6">
			<code function_name="Misc69::ambient_light_status(const std::uint8_t* bytes, int32_t length) const">int32_t Misc69::ambient_light_status(const std::uint8_t* bytes,
                                     int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(91, 0)" endLine="(96, 1)" clone_start="5" clone_end="6">
			<code function_name="Throttle63::watchdog_counter_source(const std::uint8_t* bytes, int32_t length) const">int32_t Throttle63::watchdog_counter_source(const std::uint8_t* bytes,
                                            int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(96, 0)" endLine="(100, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::boo_input(const std::uint8_t* bytes, int32_t length) const">bool Brake61::boo_input(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 6);
  // seems typo here
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(127, 0)" endLine="(130, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake61::is_enabled(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_enabled(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(231, 0)" endLine="(235, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_on_pressed(const std::uint8_t* bytes,
                               int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(98, 0)" endLine="(101, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle63::is_enabled(const std::uint8_t* bytes, int32_t length) const">bool Throttle63::is_enabled(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(0);
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(102, 0)" endLine="(105, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake61::boo_cmd(const std::uint8_t* bytes, int32_t length) const">bool Brake61::boo_cmd(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 6);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(132, 0)" endLine="(136, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_driver_override(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_driver_override(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(237, 0)" endLine="(241, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_off_pressed(const std::uint8_t* bytes,
                                int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(103, 0)" endLine="(107, 1)" clone_start="1" clone_end="5">
			<code function_name="Throttle63::is_driver_override(const std::uint8_t* bytes, int32_t length) const">bool Throttle63::is_driver_override(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(1);
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(107, 0)" endLine="(111, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::boo_output(const std::uint8_t* bytes, int32_t length) const">bool Brake61::boo_output(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 6);
  // seems typo here
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(138, 0)" endLine="(142, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_driver_activity(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_driver_activity(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(243, 0)" endLine="(247, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_resume_pressed(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(109, 0)" endLine="(113, 1)" clone_start="1" clone_end="5">
			<code function_name="Throttle63::is_driver_activity(const std::uint8_t* bytes, int32_t length) const">bool Throttle63::is_driver_activity(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(2);
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(113, 0)" endLine="(117, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_watchdog_counter_applying_brakes(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_watchdog_counter_applying_brakes(const std::uint8_t* bytes,
                                                  int32_t length) const {
  Byte frame(bytes + 6);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(144, 0)" endLine="(148, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_watchdog_counter_fault(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_watchdog_counter_fault(const std::uint8_t* bytes,
                                        int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(249, 0)" endLine="(253, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_cancel_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_cancel_pressed(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(115, 0)" endLine="(119, 1)" clone_start="1" clone_end="5">
			<code function_name="Throttle63::is_watchdog_counter_fault(const std::uint8_t* bytes, int32_t length) const">bool Throttle63::is_watchdog_counter_fault(const std::uint8_t* bytes,
                                           int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(119, 0)" endLine="(125, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake61::watchdog_counter_source(const std::uint8_t* bytes, int32_t length) const">int32_t Brake61::watchdog_counter_source(const std::uint8_t* bytes,
                                         int32_t length) const {
  // see table for status code
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(150, 0)" endLine="(154, 1)" clone_start="1" clone_end="3">
			<code function_name="Brake61::is_channel_1_fault(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_channel_1_fault(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(255, 0)" endLine="(259, 1)" clone_start="1" clone_end="3">
			<code function_name="Misc69::is_acc_on_or_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_on_or_off_pressed(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(121, 0)" endLine="(125, 1)" clone_start="1" clone_end="3">
			<code function_name="Throttle63::is_channel_1_fault(const std::uint8_t* bytes, int32_t length) const">bool Throttle63::is_channel_1_fault(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(4);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\vehicle_controller.cc" startLine="(37, 0)" endLine="(91, 1)" clone_start="23" clone_end="42">
			<code function_name="VehicleController::SetDrivingMode( const Chassis::DrivingMode&amp; driving_mode)">ErrorCode VehicleController::SetDrivingMode(
    const Chassis::DrivingMode&amp; driving_mode) {
  if (driving_mode == Chassis::EMERGENCY_MODE) {
    AINFO &lt;&lt; "Can't set vehicle to EMERGENCY_MODE driving mode.";
    return ErrorCode::CANBUS_ERROR;
  }

  // vehicle in emergency mode only response to manual mode to reset.
  if (driving_mode_ == Chassis::EMERGENCY_MODE &amp;&amp;
      driving_mode != Chassis::COMPLETE_MANUAL) {
    AINFO
        &lt;&lt; "Vehicle in EMERGENCY_MODE, only response to COMPLETE_MANUAL mode.";
    AINFO &lt;&lt; "Only response to RESET ACTION.";
    return ErrorCode::CANBUS_ERROR;
  }

  // if current mode is same as previous, no need to set.
  if (driving_mode_ == driving_mode) {
    return ErrorCode::OK;
  }

  switch (driving_mode) {
    case Chassis::COMPLETE_AUTO_DRIVE: {
      if (EnableAutoMode() != ErrorCode::OK) {
        AERROR &lt;&lt; "Fail to EnableAutoMode.";
        return ErrorCode::CANBUS_ERROR;
      }
      break;
    }
    case Chassis::COMPLETE_MANUAL: {
      if (DisableAutoMode() != ErrorCode::OK) {
        AERROR &lt;&lt; "Fail to DisableAutoMode.";
        return ErrorCode::CANBUS_ERROR;
      }
      break;
    }
    case Chassis::AUTO_STEER_ONLY: {
      if (EnableSteeringOnlyMode() != ErrorCode::OK) {
        AERROR &lt;&lt; "Fail to EnableSpeedOnlyMode.";
        return ErrorCode::CANBUS_ERROR;
      }
      break;
    }
    case Chassis::AUTO_SPEED_ONLY: {
      if (EnableSpeedOnlyMode() != ErrorCode::OK) {
        AERROR &lt;&lt; "Fail to EnableSpeedOnlyMode";
        return ErrorCode::CANBUS_ERROR;
      }
      break;
    }
    default:
      break;
  }
  return ErrorCode::OK;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\vehicle_controller.cc" startLine="(37, 0)" endLine="(91, 1)" clone_start="30" clone_end="49">
			<code function_name="VehicleController::SetDrivingMode( const Chassis::DrivingMode&amp; driving_mode)">ErrorCode VehicleController::SetDrivingMode(
    const Chassis::DrivingMode&amp; driving_mode) {
  if (driving_mode == Chassis::EMERGENCY_MODE) {
    AINFO &lt;&lt; "Can't set vehicle to EMERGENCY_MODE driving mode.";
    return ErrorCode::CANBUS_ERROR;
  }

  // vehicle in emergency mode only response to manual mode to reset.
  if (driving_mode_ == Chassis::EMERGENCY_MODE &amp;&amp;
      driving_mode != Chassis::COMPLETE_MANUAL) {
    AINFO
        &lt;&lt; "Vehicle in EMERGENCY_MODE, only response to COMPLETE_MANUAL mode.";
    AINFO &lt;&lt; "Only response to RESET ACTION.";
    return ErrorCode::CANBUS_ERROR;
  }

  // if current mode is same as previous, no need to set.
  if (driving_mode_ == driving_mode) {
    return ErrorCode::OK;
  }

  switch (driving_mode) {
    case Chassis::COMPLETE_AUTO_DRIVE: {
      if (EnableAutoMode() != ErrorCode::OK) {
        AERROR &lt;&lt; "Fail to EnableAutoMode.";
        return ErrorCode::CANBUS_ERROR;
      }
      break;
    }
    case Chassis::COMPLETE_MANUAL: {
      if (DisableAutoMode() != ErrorCode::OK) {
        AERROR &lt;&lt; "Fail to DisableAutoMode.";
        return ErrorCode::CANBUS_ERROR;
      }
      break;
    }
    case Chassis::AUTO_STEER_ONLY: {
      if (EnableSteeringOnlyMode() != ErrorCode::OK) {
        AERROR &lt;&lt; "Fail to EnableSpeedOnlyMode.";
        return ErrorCode::CANBUS_ERROR;
      }
      break;
    }
    case Chassis::AUTO_SPEED_ONLY: {
      if (EnableSpeedOnlyMode() != ErrorCode::OK) {
        AERROR &lt;&lt; "Fail to EnableSpeedOnlyMode";
        return ErrorCode::CANBUS_ERROR;
      }
      break;
    }
    default:
      break;
  }
  return ErrorCode::OK;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(43, 0)" endLine="(46, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_none()">Gear66* Gear66::set_gear_none() {
  gear_ = 0x00;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(48, 0)" endLine="(51, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_park()">Gear66* Gear66::set_gear_park() {
  gear_ = 0x01;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(48, 0)" endLine="(51, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_park()">Gear66* Gear66::set_gear_park() {
  gear_ = 0x01;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(53, 0)" endLine="(56, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_reverse()">Gear66* Gear66::set_gear_reverse() {
  gear_ = 0x02;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(53, 0)" endLine="(56, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_reverse()">Gear66* Gear66::set_gear_reverse() {
  gear_ = 0x02;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(58, 0)" endLine="(61, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_neutral()">Gear66* Gear66::set_gear_neutral() {
  gear_ = 0x03;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(58, 0)" endLine="(61, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_neutral()">Gear66* Gear66::set_gear_neutral() {
  gear_ = 0x03;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(63, 0)" endLine="(66, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_drive()">Gear66* Gear66::set_gear_drive() {
  gear_ = 0x04;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(63, 0)" endLine="(66, 1)" clone_start="1" clone_end="3">
			<code function_name="Gear66::set_gear_drive()">Gear66* Gear66::set_gear_drive() {
  gear_ = 0x04;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(68, 0)" endLine="(71, 1)" clone_start="1" clone_end="3">
			<code function_name="Gear66::set_gear_low()">Gear66* Gear66::set_gear_low() {
  gear_ = 0x05;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\tools\teleop.cc" startLine="(108, 2)" endLine="(250, 3)" clone_start="34" clone_end="50">
			<code function_name="KeyboardLoopThreadFunc()">  void KeyboardLoopThreadFunc() {
    char c = 0;
    int32_t level = 0;
    double brake = 0;
    double throttle = 0;
    double steering = 0;
    struct termios _cooked;
    struct termios _raw;
    int32_t _kfd = 0;
    bool parking_brake = false;
    Chassis::GearPosition gear = Chassis::GEAR_INVALID;
    PadMessage pad_msg;
    ControlCommand&amp; control_command_ = control_command();

    // get the console in raw mode
    tcgetattr(_kfd, &amp;_cooked);
    std::memcpy(&amp;_raw, &amp;_cooked, sizeof(struct termios));
    _raw.c_lflag &amp;= ~(ICANON | ECHO);
    // Setting a new line, then end of file
    _raw.c_cc[VEOL] = 1;
    _raw.c_cc[VEOF] = 2;
    tcsetattr(_kfd, TCSANOW, &amp;_raw);
    puts("Teleop:\nReading from keyboard now.");
    puts("---------------------------");
    puts("Use arrow keys to drive the car.");
    while (IsRunning()) {
      // get the next event from the keyboard
      if (read(_kfd, &amp;c, 1) &lt; 0) {
        perror("read():");
        exit(-1);
      }

      switch (c) {
        case KEYCODE_UP1:  // accelerate
        case KEYCODE_UP2:
          brake = control_command_.brake();
          throttle = control_command_.throttle();
          if (brake &gt; 1e-6) {
            brake = GetCommand(brake, -FLAGS_brake_inc_delta);
            control_command_.set_brake(brake);
          } else {
            throttle = GetCommand(throttle, FLAGS_throttle_inc_delta);
            control_command_.set_throttle(throttle);
          }
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_DN1:  // decelerate
        case KEYCODE_DN2:
          brake = control_command_.brake();
          throttle = control_command_.throttle();
          if (throttle &gt; 1e-6) {
            throttle = GetCommand(throttle, -FLAGS_throttle_inc_delta);
            control_command_.set_throttle(throttle);
          } else {
            brake = GetCommand(brake, FLAGS_brake_inc_delta);
            control_command_.set_brake(brake);
          }
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_LF1:  // left
        case KEYCODE_LF2:
          steering = control_command_.steering_target();
          steering = GetCommand(steering, FLAGS_steer_inc_delta);
          control_command_.set_steering_target(steering);
          printf("Steering Target = %.2f\n", steering);
          break;
        case KEYCODE_RT1:  // right
        case KEYCODE_RT2:
          steering = control_command_.steering_target();
          steering = GetCommand(steering, -FLAGS_steer_inc_delta);
          control_command_.set_steering_target(steering);
          printf("Steering Target = %.2f\n", steering);
          break;
        case KEYCODE_PKBK:  // hand brake
          parking_brake = !control_command_.parking_brake();
          control_command_.set_parking_brake(parking_brake);
          printf("Parking Brake Toggled:%d\n", parking_brake);
          break;
        case KEYCODE_ESTOP:
          control_command_.set_brake(50.0);
          printf("Estop Brake:%.2f\n", control_command_.brake());
          break;
        case KEYCODE_SETT1:  // set throttle
        case KEYCODE_SETT2:
          // read keyboard again
          if (read(_kfd, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          control_command_.set_throttle(level * 10.0);
          control_command_.set_brake(0.0);
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_SETG1:
        case KEYCODE_SETG2:
          // read keyboard again
          if (read(_kfd, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          gear = GetGear(level);
          control_command_.set_gear_location(gear);
          printf("Gear set to %d.\n", level);
          break;
        case KEYCODE_SETB1:
        case KEYCODE_SETB2:
          // read keyboard again
          if (read(_kfd, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          control_command_.set_throttle(0.0);
          control_command_.set_brake(level * 10.0);
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_MODE:
          // read keyboard again
          if (read(_kfd, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          GetPadMessage(pad_msg, level);
          control_command_.mutable_pad_msg()-&gt;CopyFrom(pad_msg);
          sleep(1);
          control_command_.mutable_pad_msg()-&gt;Clear();
          break;
        case KEYCODE_HELP:
        case KEYCODE_HELP2:
          PrintKeycode();
          break;
        default:
          // printf("%X\n", c);
          break;
      }
    }  // keyboard_loop big while
    tcsetattr(_kfd, TCSANOW, &amp;_cooked);
    printf("keyboard_loop thread quited.\n");
    return;
  }  // end of keyboard loop thread</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\tools\teleop.cc" startLine="(108, 2)" endLine="(250, 3)" clone_start="48" clone_end="64">
			<code function_name="KeyboardLoopThreadFunc()">  void KeyboardLoopThreadFunc() {
    char c = 0;
    int32_t level = 0;
    double brake = 0;
    double throttle = 0;
    double steering = 0;
    struct termios _cooked;
    struct termios _raw;
    int32_t _kfd = 0;
    bool parking_brake = false;
    Chassis::GearPosition gear = Chassis::GEAR_INVALID;
    PadMessage pad_msg;
    ControlCommand&amp; control_command_ = control_command();

    // get the console in raw mode
    tcgetattr(_kfd, &amp;_cooked);
    std::memcpy(&amp;_raw, &amp;_cooked, sizeof(struct termios));
    _raw.c_lflag &amp;= ~(ICANON | ECHO);
    // Setting a new line, then end of file
    _raw.c_cc[VEOL] = 1;
    _raw.c_cc[VEOF] = 2;
    tcsetattr(_kfd, TCSANOW, &amp;_raw);
    puts("Teleop:\nReading from keyboard now.");
    puts("---------------------------");
    puts("Use arrow keys to drive the car.");
    while (IsRunning()) {
      // get the next event from the keyboard
      if (read(_kfd, &amp;c, 1) &lt; 0) {
        perror("read():");
        exit(-1);
      }

      switch (c) {
        case KEYCODE_UP1:  // accelerate
        case KEYCODE_UP2:
          brake = control_command_.brake();
          throttle = control_command_.throttle();
          if (brake &gt; 1e-6) {
            brake = GetCommand(brake, -FLAGS_brake_inc_delta);
            control_command_.set_brake(brake);
          } else {
            throttle = GetCommand(throttle, FLAGS_throttle_inc_delta);
            control_command_.set_throttle(throttle);
          }
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_DN1:  // decelerate
        case KEYCODE_DN2:
          brake = control_command_.brake();
          throttle = control_command_.throttle();
          if (throttle &gt; 1e-6) {
            throttle = GetCommand(throttle, -FLAGS_throttle_inc_delta);
            control_command_.set_throttle(throttle);
          } else {
            brake = GetCommand(brake, FLAGS_brake_inc_delta);
            control_command_.set_brake(brake);
          }
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_LF1:  // left
        case KEYCODE_LF2:
          steering = control_command_.steering_target();
          steering = GetCommand(steering, FLAGS_steer_inc_delta);
          control_command_.set_steering_target(steering);
          printf("Steering Target = %.2f\n", steering);
          break;
        case KEYCODE_RT1:  // right
        case KEYCODE_RT2:
          steering = control_command_.steering_target();
          steering = GetCommand(steering, -FLAGS_steer_inc_delta);
          control_command_.set_steering_target(steering);
          printf("Steering Target = %.2f\n", steering);
          break;
        case KEYCODE_PKBK:  // hand brake
          parking_brake = !control_command_.parking_brake();
          control_command_.set_parking_brake(parking_brake);
          printf("Parking Brake Toggled:%d\n", parking_brake);
          break;
        case KEYCODE_ESTOP:
          control_command_.set_brake(50.0);
          printf("Estop Brake:%.2f\n", control_command_.brake());
          break;
        case KEYCODE_SETT1:  // set throttle
        case KEYCODE_SETT2:
          // read keyboard again
          if (read(_kfd, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          control_command_.set_throttle(level * 10.0);
          control_command_.set_brake(0.0);
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_SETG1:
        case KEYCODE_SETG2:
          // read keyboard again
          if (read(_kfd, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          gear = GetGear(level);
          control_command_.set_gear_location(gear);
          printf("Gear set to %d.\n", level);
          break;
        case KEYCODE_SETB1:
        case KEYCODE_SETB2:
          // read keyboard again
          if (read(_kfd, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          control_command_.set_throttle(0.0);
          control_command_.set_brake(level * 10.0);
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_MODE:
          // read keyboard again
          if (read(_kfd, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          GetPadMessage(pad_msg, level);
          control_command_.mutable_pad_msg()-&gt;CopyFrom(pad_msg);
          sleep(1);
          control_command_.mutable_pad_msg()-&gt;Clear();
          break;
        case KEYCODE_HELP:
        case KEYCODE_HELP2:
          PrintKeycode();
          break;
        default:
          // printf("%X\n", c);
          break;
      }
    }  // keyboard_loop big while
    tcsetattr(_kfd, TCSANOW, &amp;_cooked);
    printf("keyboard_loop thread quited.\n");
    return;
  }  // end of keyboard loop thread</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(286, 0)" endLine="(322, 1)" clone_start="15" clone_end="36">
			<code function_name="TcpStream::write(const uint8_t* buffer, size_t length)">size_t TcpStream::write(const uint8_t* buffer, size_t length) {
    ssize_t  nsent = 0;
    size_t total_nsent = 0;

    if (_status != Stream::Status::CONNECTED) {
        disconnect();
        connect();
        if (_status != Stream::Status::CONNECTED) {
            return 0;
        }
    }

    while (length &gt; 0) {
        nsent = ::send(_sockfd, buffer, length, 0);
        if (nsent &lt; 0) {
            if (errno == EINTR) {
                continue;
            } else {
                // error
                if (errno == EPIPE || errno == ECONNRESET) {
                    _status = Stream::Status::DISCONNECTED;
                    _errno = errno;
                } else if (errno != EAGAIN) {
                    _status = Stream::Status::ERROR;
                    _errno = errno;
                }
                return total_nsent;
            }
        }

        total_nsent += nsent;
        length -= nsent;
        buffer += nsent;
    }

    return total_nsent;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(206, 0)" endLine="(241, 1)" clone_start="14" clone_end="35">
			<code function_name="UdpStream::write(const uint8_t* data, size_t length)">size_t UdpStream::write(const uint8_t* data, size_t length) {
    ssize_t nsent = 0;
    size_t total_nsent = 0;
    struct sockaddr_in peer_sockaddr;
    bzero(&amp;peer_sockaddr, sizeof(peer_sockaddr));
    peer_sockaddr.sin_family = AF_INET;
    peer_sockaddr.sin_port = _peer_port;
    peer_sockaddr.sin_addr.s_addr = _peer_addr;

    while (length &gt; 0) {
        nsent = ::sendto(_sockfd, data, length, 0,
                                 (struct sockaddr*)&amp;peer_sockaddr, 
                                 (socklen_t) sizeof(peer_sockaddr));
        if (nsent &lt; 0) { // error
            if (errno == EINTR) {
                continue;
            } else {
                // error
                if (errno == EPIPE || errno == ECONNRESET) {
                    _status = Stream::Status::DISCONNECTED;
                    _errno = errno;
                } else if (errno != EAGAIN) {
                    _status = Stream::Status::ERROR;
                    _errno = errno;
                }
                return total_nsent;
            }
        }

        total_nsent += nsent;
        length -= nsent;
        data += nsent;
    }

    return total_nsent;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(87, 0)" endLine="(99, 1)" clone_start="1" clone_end="13">
			<code function_name="Steering65::reported_steering_angle_cmd(const std::uint8_t* bytes, int32_t length) const">double Steering65::reported_steering_angle_cmd(const std::uint8_t* bytes,
                                               int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x8000) {
    value = value - 0x10000;
  }

  return value * 0.100000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(73, 0)" endLine="(85, 1)" clone_start="1" clone_end="13">
			<code function_name="Steering65::steering_angle(const std::uint8_t* bytes, int32_t length) const">double Steering65::steering_angle(const std::uint8_t* bytes,
                                  int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x8000) {
    value = value - 0x10000;
  }

  return value * 0.100000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(101, 0)" endLine="(109, 1)" clone_start="1" clone_end="7">
			<code function_name="Steering65::vehicle_speed(const std::uint8_t* bytes, int32_t length) const">double Steering65::vehicle_speed(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(87, 0)" endLine="(99, 1)" clone_start="1" clone_end="7">
			<code function_name="Steering65::reported_steering_angle_cmd(const std::uint8_t* bytes, int32_t length) const">double Steering65::reported_steering_angle_cmd(const std::uint8_t* bytes,
                                               int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x8000) {
    value = value - 0x10000;
  }

  return value * 0.100000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(306, 0)" endLine="(342, 1)" clone_start="2" clone_end="23">
			<code function_name="RawStream::disconnect()">bool RawStream::disconnect() {
    if (_data_stream) {
        if (_data_stream-&gt;get_status() == Stream::Status::CONNECTED) {
            if (!_data_stream-&gt;disconnect()) {
                ROS_ERROR("data stream disconnect failed.");
                return false;
            }
        }
    }

    if (_command_stream) {
        if (_command_stream-&gt;get_status() == Stream::Status::CONNECTED) {
            if (!_data_stream-&gt;disconnect()) {
                ROS_ERROR("command stream disconnect failed.");
                return false;
            }
        }
    }
    if (_in_rtk_stream) {
        if (_in_rtk_stream-&gt;get_status() == Stream::Status::CONNECTED) {
            if (!_in_rtk_stream-&gt;disconnect()) {
                ROS_ERROR("in rtk stream disconnect failed.");
                return false;
            }
        }
    }
    if (_out_rtk_stream) {
        if (_out_rtk_stream-&gt;get_status() == Stream::Status::CONNECTED) {
            if (!_out_rtk_stream-&gt;disconnect()) {
                ROS_ERROR("out rtk stream disconnect failed.");
                return false;
            }
        }
    }

    return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(306, 0)" endLine="(342, 1)" clone_start="11" clone_end="31">
			<code function_name="RawStream::disconnect()">bool RawStream::disconnect() {
    if (_data_stream) {
        if (_data_stream-&gt;get_status() == Stream::Status::CONNECTED) {
            if (!_data_stream-&gt;disconnect()) {
                ROS_ERROR("data stream disconnect failed.");
                return false;
            }
        }
    }

    if (_command_stream) {
        if (_command_stream-&gt;get_status() == Stream::Status::CONNECTED) {
            if (!_data_stream-&gt;disconnect()) {
                ROS_ERROR("command stream disconnect failed.");
                return false;
            }
        }
    }
    if (_in_rtk_stream) {
        if (_in_rtk_stream-&gt;get_status() == Stream::Status::CONNECTED) {
            if (!_in_rtk_stream-&gt;disconnect()) {
                ROS_ERROR("in rtk stream disconnect failed.");
                return false;
            }
        }
    }
    if (_out_rtk_stream) {
        if (_out_rtk_stream-&gt;get_status() == Stream::Status::CONNECTED) {
            if (!_out_rtk_stream-&gt;disconnect()) {
                ROS_ERROR("out rtk stream disconnect failed.");
                return false;
            }
        }
    }

    return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(26, 0)" endLine="(34, 1)" clone_start="7" clone_end="9">
			<code function_name="Accel6b::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* chassis_detail) const">void Accel6b::Parse(const std::uint8_t* bytes, int32_t length,
                    ChassisDetail* chassis_detail) const {
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_lat_acc(
      lateral_acceleration(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_long_acc(
      longitudinal_acceleration(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_vert_acc(
      vertical_acceleration(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(26, 0)" endLine="(50, 1)" clone_start="23" clone_end="25">
			<code function_name="Gps6f::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Gps6f::Parse(const std::uint8_t* bytes, int32_t length,
                  ChassisDetail* car_status) const {
  car_status-&gt;mutable_basic()-&gt;set_altitude(altitude(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_heading(heading(bytes, length));
  // speed mph -&gt; mps
  car_status-&gt;mutable_basic()-&gt;set_gps_speed(speed(bytes, length) * 0.44704);
  car_status-&gt;mutable_basic()-&gt;set_hdop(hdop(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_vdop(vdop(bytes, length));
  switch (fix_quality(bytes, length)) {
    case 0:
      car_status-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_NO);
      break;
    case 1:
      car_status-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_2D);
      break;
    case 2:
      car_status-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_3D);
      break;
    default:
      car_status-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_INVALID);
      break;
  }
  car_status-&gt;mutable_basic()-&gt;set_num_satellites(
      num_satellites(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(36, 0)" endLine="(47, 1)" clone_start="1" clone_end="12">
			<code function_name="Accel6b::lateral_acceleration(const std::uint8_t* bytes, int32_t length) const">double Accel6b::lateral_acceleration(const std::uint8_t* bytes,
                                     int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(52, 0)" endLine="(62, 1)" clone_start="1" clone_end="11">
			<code function_name="Gps6f::altitude(const std::uint8_t* bytes, int32_t length) const">double Gps6f::altitude(const std::uint8_t* bytes, int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.250000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(49, 0)" endLine="(60, 1)" clone_start="1" clone_end="7">
			<code function_name="Accel6b::longitudinal_acceleration(const std::uint8_t* bytes, int32_t length) const">double Accel6b::longitudinal_acceleration(const std::uint8_t* bytes,
                                          int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(64, 0)" endLine="(71, 1)" clone_start="1" clone_end="6">
			<code function_name="Gps6f::heading(const std::uint8_t* bytes, int32_t length) const">double Gps6f::heading(const std::uint8_t* bytes, int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(44, 0)" endLine="(115, 1)" clone_start="34" clone_end="58">
			<code function_name="LincolnController::Init(const VehicleParameter&amp; params,CanSender* const can_sender, MessageManager* const message_manager)">ErrorCode LincolnController::Init(const VehicleParameter&amp; params,
                                  CanSender* const can_sender,
                                  MessageManager* const message_manager) {
  if (is_initialized_) {
    AINFO &lt;&lt; "LincolnController has already been initiated.";
    return ErrorCode::CANBUS_ERROR;
  }

  params_.CopyFrom(params);
  if (!params_.has_driving_mode()) {
    AERROR &lt;&lt; "Vehicle conf pb not set driving_mode.";
    return ErrorCode::CANBUS_ERROR;
  }

  if (can_sender == nullptr) {
    return ErrorCode::CANBUS_ERROR;
  }
  can_sender_ = can_sender;

  if (message_manager == nullptr) {
    AERROR &lt;&lt; "protocol manager is null.";
    return ErrorCode::CANBUS_ERROR;
  }
  message_manager_ = message_manager;

  // sender part
  brake_60_ = dynamic_cast&lt;Brake60*&gt;(
      message_manager_-&gt;GetMutableProtocolDataById(Brake60::ID));
  if (brake_60_ == nullptr) {
    AERROR &lt;&lt; "Brake60 does not exist in the LincolnMessageManager!";
    return ErrorCode::CANBUS_ERROR;
  }

  throttle_62_ = dynamic_cast&lt;Throttle62*&gt;(
      message_manager_-&gt;GetMutableProtocolDataById(Throttle62::ID));
  if (throttle_62_ == nullptr) {
    AERROR &lt;&lt; "Throttle62 does not exist in the LincolnMessageManager!";
    return ErrorCode::CANBUS_ERROR;
  }

  steering_64_ = dynamic_cast&lt;Steering64*&gt;(
      message_manager_-&gt;GetMutableProtocolDataById(Steering64::ID));
  if (steering_64_ == nullptr) {
    AERROR &lt;&lt; "Steering64 does not exist in the LincolnMessageManager!";
    return ErrorCode::CANBUS_ERROR;
  }

  gear_66_ = dynamic_cast&lt;Gear66*&gt;(
      message_manager_-&gt;GetMutableProtocolDataById(Gear66::ID));
  if (gear_66_ == nullptr) {
    AERROR &lt;&lt; "Gear66 does not exist in the LincolnMessageManager!";
    return ErrorCode::CANBUS_ERROR;
  }
  turnsignal_68_ = dynamic_cast&lt;Turnsignal68*&gt;(
      message_manager_-&gt;GetMutableProtocolDataById(Turnsignal68::ID));
  if (turnsignal_68_ == nullptr) {
    AERROR &lt;&lt; "Turnsignal68 does not exist in the LincolnMessageManager!";
    return ErrorCode::CANBUS_ERROR;
  }

  can_sender_-&gt;AddMessage(Brake60::ID, brake_60_, false);
  can_sender_-&gt;AddMessage(Throttle62::ID, throttle_62_, false);
  can_sender_-&gt;AddMessage(Steering64::ID, steering_64_, false);
  can_sender_-&gt;AddMessage(Gear66::ID, gear_66_, false);
  can_sender_-&gt;AddMessage(Turnsignal68::ID, turnsignal_68_, false);

  // need sleep to ensure all messages received
  AINFO &lt;&lt; "Controller is initialized.";

  is_initialized_ = true;
  return ErrorCode::OK;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(44, 0)" endLine="(115, 1)" clone_start="27" clone_end="52">
			<code function_name="LincolnController::Init(const VehicleParameter&amp; params,CanSender* const can_sender, MessageManager* const message_manager)">ErrorCode LincolnController::Init(const VehicleParameter&amp; params,
                                  CanSender* const can_sender,
                                  MessageManager* const message_manager) {
  if (is_initialized_) {
    AINFO &lt;&lt; "LincolnController has already been initiated.";
    return ErrorCode::CANBUS_ERROR;
  }

  params_.CopyFrom(params);
  if (!params_.has_driving_mode()) {
    AERROR &lt;&lt; "Vehicle conf pb not set driving_mode.";
    return ErrorCode::CANBUS_ERROR;
  }

  if (can_sender == nullptr) {
    return ErrorCode::CANBUS_ERROR;
  }
  can_sender_ = can_sender;

  if (message_manager == nullptr) {
    AERROR &lt;&lt; "protocol manager is null.";
    return ErrorCode::CANBUS_ERROR;
  }
  message_manager_ = message_manager;

  // sender part
  brake_60_ = dynamic_cast&lt;Brake60*&gt;(
      message_manager_-&gt;GetMutableProtocolDataById(Brake60::ID));
  if (brake_60_ == nullptr) {
    AERROR &lt;&lt; "Brake60 does not exist in the LincolnMessageManager!";
    return ErrorCode::CANBUS_ERROR;
  }

  throttle_62_ = dynamic_cast&lt;Throttle62*&gt;(
      message_manager_-&gt;GetMutableProtocolDataById(Throttle62::ID));
  if (throttle_62_ == nullptr) {
    AERROR &lt;&lt; "Throttle62 does not exist in the LincolnMessageManager!";
    return ErrorCode::CANBUS_ERROR;
  }

  steering_64_ = dynamic_cast&lt;Steering64*&gt;(
      message_manager_-&gt;GetMutableProtocolDataById(Steering64::ID));
  if (steering_64_ == nullptr) {
    AERROR &lt;&lt; "Steering64 does not exist in the LincolnMessageManager!";
    return ErrorCode::CANBUS_ERROR;
  }

  gear_66_ = dynamic_cast&lt;Gear66*&gt;(
      message_manager_-&gt;GetMutableProtocolDataById(Gear66::ID));
  if (gear_66_ == nullptr) {
    AERROR &lt;&lt; "Gear66 does not exist in the LincolnMessageManager!";
    return ErrorCode::CANBUS_ERROR;
  }
  turnsignal_68_ = dynamic_cast&lt;Turnsignal68*&gt;(
      message_manager_-&gt;GetMutableProtocolDataById(Turnsignal68::ID));
  if (turnsignal_68_ == nullptr) {
    AERROR &lt;&lt; "Turnsignal68 does not exist in the LincolnMessageManager!";
    return ErrorCode::CANBUS_ERROR;
  }

  can_sender_-&gt;AddMessage(Brake60::ID, brake_60_, false);
  can_sender_-&gt;AddMessage(Throttle62::ID, throttle_62_, false);
  can_sender_-&gt;AddMessage(Steering64::ID, steering_64_, false);
  can_sender_-&gt;AddMessage(Gear66::ID, gear_66_, false);
  can_sender_-&gt;AddMessage(Turnsignal68::ID, turnsignal_68_, false);

  // need sleep to ensure all messages received
  AINFO &lt;&lt; "Controller is initialized.";

  is_initialized_ = true;
  return ErrorCode::OK;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(336, 0)" endLine="(384, 1)" clone_start="15" clone_end="35">
			<code function_name="LincolnController::Gear(Chassis::GearPosition gear_position)">void LincolnController::Gear(Chassis::GearPosition gear_position) {
  if (!(driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
        driving_mode() == Chassis::AUTO_SPEED_ONLY)) {
    AINFO &lt;&lt; "this drive mode no need to set gear.";
    return;
  }
  // enable steering to enable shifting
  // actually, if we wanna shift from parking
  // to some other state
  // we need to apply a brake
  // which needs to be done by human or
  // some canbus cmd
  // TODO
  switch (gear_position) {
    case Chassis::GEAR_NEUTRAL: {
      gear_66_-&gt;set_gear_neutral();
      break;
    }
    case Chassis::GEAR_REVERSE: {
      gear_66_-&gt;set_gear_reverse();
      break;
    }
    case Chassis::GEAR_DRIVE: {
      gear_66_-&gt;set_gear_drive();
      break;
    }
    case Chassis::GEAR_PARKING: {
      gear_66_-&gt;set_gear_park();
      break;
    }
    case Chassis::GEAR_LOW: {
      gear_66_-&gt;set_gear_low();
      break;
    }
    case Chassis::GEAR_NONE: {
      gear_66_-&gt;set_gear_none();
      break;
    }
    case Chassis::GEAR_INVALID: {
      AERROR &lt;&lt; "Gear command is invalid!";
      gear_66_-&gt;set_gear_none();
      break;
    }
    default: {
      gear_66_-&gt;set_gear_none();
      break;
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(336, 0)" endLine="(384, 1)" clone_start="19" clone_end="39">
			<code function_name="LincolnController::Gear(Chassis::GearPosition gear_position)">void LincolnController::Gear(Chassis::GearPosition gear_position) {
  if (!(driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
        driving_mode() == Chassis::AUTO_SPEED_ONLY)) {
    AINFO &lt;&lt; "this drive mode no need to set gear.";
    return;
  }
  // enable steering to enable shifting
  // actually, if we wanna shift from parking
  // to some other state
  // we need to apply a brake
  // which needs to be done by human or
  // some canbus cmd
  // TODO
  switch (gear_position) {
    case Chassis::GEAR_NEUTRAL: {
      gear_66_-&gt;set_gear_neutral();
      break;
    }
    case Chassis::GEAR_REVERSE: {
      gear_66_-&gt;set_gear_reverse();
      break;
    }
    case Chassis::GEAR_DRIVE: {
      gear_66_-&gt;set_gear_drive();
      break;
    }
    case Chassis::GEAR_PARKING: {
      gear_66_-&gt;set_gear_park();
      break;
    }
    case Chassis::GEAR_LOW: {
      gear_66_-&gt;set_gear_low();
      break;
    }
    case Chassis::GEAR_NONE: {
      gear_66_-&gt;set_gear_none();
      break;
    }
    case Chassis::GEAR_INVALID: {
      AERROR &lt;&lt; "Gear command is invalid!";
      gear_66_-&gt;set_gear_none();
      break;
    }
    default: {
      gear_66_-&gt;set_gear_none();
      break;
    }
  }
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\adapters\adapter_manager.cc" startLine="(45, 0)" endLine="(110, 1)" clone_start="8" clone_end="30">
			<code function_name="AdapterManager::Init(const AdapterManagerConfig&amp; configs)">void AdapterManager::Init(const AdapterManagerConfig&amp; configs) {
  if (configs.is_ros()) {
    instance()-&gt;node_handle_.reset(new ros::NodeHandle());
  }

  for (const auto&amp; config : configs.config()) {
    switch (config.type()) {
      case AdapterConfig::GPS:
        EnableGps(FLAGS_gps_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::IMU:
        EnableImu(FLAGS_imu_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS:
        EnableChassis(FLAGS_chassis_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::LOCALIZATION:
        EnableLocalization(FLAGS_localization_topic, config.mode(),
                           config.message_history_limit());
        break;
      case AdapterConfig::PERCEPTION_OBSTACLES:
        EnablePerceptionObstacles(FLAGS_perception_obstacle_topic,
                                  config.mode(),
                                  config.message_history_limit());
        break;
      case AdapterConfig::TRAFFIC_LIGHT_DETECTION:
        EnableTrafficLightDetection(FLAGS_traffic_light_detection_topic,
                                    config.mode(),
                                    config.message_history_limit());
      case AdapterConfig::PAD:
        EnablePad(FLAGS_pad_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CONTROL_COMMAND:
        EnableControlCommand(FLAGS_control_command_topic, config.mode(),
                             config.message_history_limit());
        break;
      case AdapterConfig::PLANNING_TRAJECTORY:
        EnablePlanningTrajectory(FLAGS_planning_trajectory_topic, config.mode(),
                                 config.message_history_limit());
        break;
      case AdapterConfig::PREDICTION:
        EnablePrediction(FLAGS_prediction_topic, config.mode(),
                         config.message_history_limit());
        break;
      case AdapterConfig::MONITOR:
        EnableMonitor(FLAGS_monitor_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS_DETAIL:
        EnableChassisDetail(FLAGS_chassis_detail_topic, config.mode(),
                            config.message_history_limit());
        break;
      case AdapterConfig::DECISION:
        EnableDecision(FLAGS_decision_topic, config.mode(),
                       config.message_history_limit());
        break;
      default:
        AERROR &lt;&lt; "Unknown adapter config type!";
        break;
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\adapters\adapter_manager.cc" startLine="(45, 0)" endLine="(110, 1)" clone_start="37" clone_end="58">
			<code function_name="AdapterManager::Init(const AdapterManagerConfig&amp; configs)">void AdapterManager::Init(const AdapterManagerConfig&amp; configs) {
  if (configs.is_ros()) {
    instance()-&gt;node_handle_.reset(new ros::NodeHandle());
  }

  for (const auto&amp; config : configs.config()) {
    switch (config.type()) {
      case AdapterConfig::GPS:
        EnableGps(FLAGS_gps_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::IMU:
        EnableImu(FLAGS_imu_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS:
        EnableChassis(FLAGS_chassis_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::LOCALIZATION:
        EnableLocalization(FLAGS_localization_topic, config.mode(),
                           config.message_history_limit());
        break;
      case AdapterConfig::PERCEPTION_OBSTACLES:
        EnablePerceptionObstacles(FLAGS_perception_obstacle_topic,
                                  config.mode(),
                                  config.message_history_limit());
        break;
      case AdapterConfig::TRAFFIC_LIGHT_DETECTION:
        EnableTrafficLightDetection(FLAGS_traffic_light_detection_topic,
                                    config.mode(),
                                    config.message_history_limit());
      case AdapterConfig::PAD:
        EnablePad(FLAGS_pad_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CONTROL_COMMAND:
        EnableControlCommand(FLAGS_control_command_topic, config.mode(),
                             config.message_history_limit());
        break;
      case AdapterConfig::PLANNING_TRAJECTORY:
        EnablePlanningTrajectory(FLAGS_planning_trajectory_topic, config.mode(),
                                 config.message_history_limit());
        break;
      case AdapterConfig::PREDICTION:
        EnablePrediction(FLAGS_prediction_topic, config.mode(),
                         config.message_history_limit());
        break;
      case AdapterConfig::MONITOR:
        EnableMonitor(FLAGS_monitor_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS_DETAIL:
        EnableChassisDetail(FLAGS_chassis_detail_topic, config.mode(),
                            config.message_history_limit());
        break;
      case AdapterConfig::DECISION:
        EnableDecision(FLAGS_decision_topic, config.mode(),
                       config.message_history_limit());
        break;
      default:
        AERROR &lt;&lt; "Unknown adapter config type!";
        break;
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\adapters\adapter_manager.cc" startLine="(45, 0)" endLine="(110, 1)" clone_start="33" clone_end="54">
			<code function_name="AdapterManager::Init(const AdapterManagerConfig&amp; configs)">void AdapterManager::Init(const AdapterManagerConfig&amp; configs) {
  if (configs.is_ros()) {
    instance()-&gt;node_handle_.reset(new ros::NodeHandle());
  }

  for (const auto&amp; config : configs.config()) {
    switch (config.type()) {
      case AdapterConfig::GPS:
        EnableGps(FLAGS_gps_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::IMU:
        EnableImu(FLAGS_imu_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS:
        EnableChassis(FLAGS_chassis_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::LOCALIZATION:
        EnableLocalization(FLAGS_localization_topic, config.mode(),
                           config.message_history_limit());
        break;
      case AdapterConfig::PERCEPTION_OBSTACLES:
        EnablePerceptionObstacles(FLAGS_perception_obstacle_topic,
                                  config.mode(),
                                  config.message_history_limit());
        break;
      case AdapterConfig::TRAFFIC_LIGHT_DETECTION:
        EnableTrafficLightDetection(FLAGS_traffic_light_detection_topic,
                                    config.mode(),
                                    config.message_history_limit());
      case AdapterConfig::PAD:
        EnablePad(FLAGS_pad_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CONTROL_COMMAND:
        EnableControlCommand(FLAGS_control_command_topic, config.mode(),
                             config.message_history_limit());
        break;
      case AdapterConfig::PLANNING_TRAJECTORY:
        EnablePlanningTrajectory(FLAGS_planning_trajectory_topic, config.mode(),
                                 config.message_history_limit());
        break;
      case AdapterConfig::PREDICTION:
        EnablePrediction(FLAGS_prediction_topic, config.mode(),
                         config.message_history_limit());
        break;
      case AdapterConfig::MONITOR:
        EnableMonitor(FLAGS_monitor_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS_DETAIL:
        EnableChassisDetail(FLAGS_chassis_detail_topic, config.mode(),
                            config.message_history_limit());
        break;
      case AdapterConfig::DECISION:
        EnableDecision(FLAGS_decision_topic, config.mode(),
                       config.message_history_limit());
        break;
      default:
        AERROR &lt;&lt; "Unknown adapter config type!";
        break;
    }
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(52, 0)" endLine="(115, 1)" clone_start="22" clone_end="44">
			<code function_name="create_stream(const config::Stream&amp; sd)">Stream* create_stream(const config::Stream&amp; sd) {
    switch (sd.type_case()) {
    case config::Stream::kSerial:
        if (!sd.serial().has_device()) {
            ROS_ERROR("Serial def has no device field.");
            return nullptr;
        }
        if (!sd.serial().has_baud_rate()) {
            ROS_ERROR_STREAM("Serial def has no baud_rate field. Use default baud rate "
                         &lt;&lt; sd.serial().baud_rate());
            return nullptr;
        }
        return Stream::create_serial(sd.serial().device().c_str(), sd.serial().baud_rate());

    case config::Stream::kTcp:
        if (!sd.tcp().has_address()) {
            ROS_ERROR("tcp def has no address field.");
            return nullptr;
        }
        if (!sd.tcp().has_port()) {
            ROS_ERROR("tcp def has no port field.");
            return nullptr;
        }
        return Stream::create_tcp(sd.tcp().address().c_str(), sd.tcp().port());

    case config::Stream::kUdp:
        if (!sd.udp().has_address()) {
            ROS_ERROR("tcp def has no address field.");
            return nullptr;
        }
        if (!sd.udp().has_port()) {
            ROS_ERROR("tcp def has no port field.");
            return nullptr;
        }
        return Stream::create_udp(sd.udp().address().c_str(), sd.udp().port());

    case config::Stream::kNtrip:
        if (!sd.ntrip().has_address()) {
            ROS_ERROR("ntrip def has no address field.");
            return nullptr;
        }
        if (!sd.ntrip().has_port()) {
            ROS_ERROR("ntrip def has no port field.");
            return nullptr;
        }
        if (!sd.ntrip().has_mount_point()) {
            ROS_ERROR("ntrip def has no mount point field.");
            return nullptr;
        }
        if (!sd.ntrip().has_user()) {
            ROS_ERROR("ntrip def has no user field.");
            return nullptr;
        }
        if (!sd.ntrip().has_password()) {
            ROS_ERROR("ntrip def has no passwd field.");
            return nullptr;
        }
        return Stream::create_ntrip(sd.ntrip().address(), sd.ntrip().port(),
                                    sd.ntrip().mount_point(), sd.ntrip().user(),
                                    sd.ntrip().password(), sd.ntrip().timeout_s());
    default:
        return nullptr;
    }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(52, 0)" endLine="(115, 1)" clone_start="11" clone_end="33">
			<code function_name="create_stream(const config::Stream&amp; sd)">Stream* create_stream(const config::Stream&amp; sd) {
    switch (sd.type_case()) {
    case config::Stream::kSerial:
        if (!sd.serial().has_device()) {
            ROS_ERROR("Serial def has no device field.");
            return nullptr;
        }
        if (!sd.serial().has_baud_rate()) {
            ROS_ERROR_STREAM("Serial def has no baud_rate field. Use default baud rate "
                         &lt;&lt; sd.serial().baud_rate());
            return nullptr;
        }
        return Stream::create_serial(sd.serial().device().c_str(), sd.serial().baud_rate());

    case config::Stream::kTcp:
        if (!sd.tcp().has_address()) {
            ROS_ERROR("tcp def has no address field.");
            return nullptr;
        }
        if (!sd.tcp().has_port()) {
            ROS_ERROR("tcp def has no port field.");
            return nullptr;
        }
        return Stream::create_tcp(sd.tcp().address().c_str(), sd.tcp().port());

    case config::Stream::kUdp:
        if (!sd.udp().has_address()) {
            ROS_ERROR("tcp def has no address field.");
            return nullptr;
        }
        if (!sd.udp().has_port()) {
            ROS_ERROR("tcp def has no port field.");
            return nullptr;
        }
        return Stream::create_udp(sd.udp().address().c_str(), sd.udp().port());

    case config::Stream::kNtrip:
        if (!sd.ntrip().has_address()) {
            ROS_ERROR("ntrip def has no address field.");
            return nullptr;
        }
        if (!sd.ntrip().has_port()) {
            ROS_ERROR("ntrip def has no port field.");
            return nullptr;
        }
        if (!sd.ntrip().has_mount_point()) {
            ROS_ERROR("ntrip def has no mount point field.");
            return nullptr;
        }
        if (!sd.ntrip().has_user()) {
            ROS_ERROR("ntrip def has no user field.");
            return nullptr;
        }
        if (!sd.ntrip().has_password()) {
            ROS_ERROR("ntrip def has no passwd field.");
            return nullptr;
        }
        return Stream::create_ntrip(sd.ntrip().address(), sd.ntrip().port(),
                                    sd.ntrip().mount_point(), sd.ntrip().user(),
                                    sd.ntrip().password(), sd.ntrip().timeout_s());
    default:
        return nullptr;
    }
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(35, 0)" endLine="(43, 1)" clone_start="1" clone_end="9">
			<code function_name="Throttleinfo75::engine_rpm(const std::uint8_t* bytes, int32_t length) const">double Throttleinfo75::engine_rpm(const std::uint8_t* bytes,
                                  int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.25;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(63, 0)" endLine="(71, 1)" clone_start="1" clone_end="9">
			<code function_name="Wheelspeed6a::front_left_wheel_speed(const std::uint8_t* bytes, int32_t length) const">double Wheelspeed6a::front_left_wheel_speed(const std::uint8_t* bytes,
                                            int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(73, 0)" endLine="(81, 1)" clone_start="1" clone_end="9">
			<code function_name="Wheelspeed6a::front_right_wheel_speed(const std::uint8_t* bytes, int32_t length) const">double Wheelspeed6a::front_right_wheel_speed(const std::uint8_t* bytes,
                                             int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(45, 0)" endLine="(53, 1)" clone_start="1" clone_end="9">
			<code function_name="Throttleinfo75::acc_pedal_percent(const std::uint8_t* bytes, int32_t length) const">double Throttleinfo75::acc_pedal_percent(const std::uint8_t* bytes,
                                         int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 2);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.1;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(73, 0)" endLine="(81, 1)" clone_start="1" clone_end="9">
			<code function_name="Wheelspeed6a::front_right_wheel_speed(const std::uint8_t* bytes, int32_t length) const">double Wheelspeed6a::front_right_wheel_speed(const std::uint8_t* bytes,
                                             int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(83, 0)" endLine="(91, 1)" clone_start="1" clone_end="9">
			<code function_name="Wheelspeed6a::rear_left_wheel_speed(const std::uint8_t* bytes, int32_t length) const">double Wheelspeed6a::rear_left_wheel_speed(const std::uint8_t* bytes,
                                           int32_t length) const {
  Byte high_frame(bytes + 5);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 4);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(55, 0)" endLine="(63, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttleinfo75::acc_pedal_rate(const std::uint8_t* bytes, int32_t length) const">double Throttleinfo75::acc_pedal_rate(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 8);
  if (x &gt; 0x3F) {
    x -= 0x100;
  }
  return x * 0.04;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(83, 0)" endLine="(91, 1)" clone_start="1" clone_end="4">
			<code function_name="Wheelspeed6a::rear_left_wheel_speed(const std::uint8_t* bytes, int32_t length) const">double Wheelspeed6a::rear_left_wheel_speed(const std::uint8_t* bytes,
                                           int32_t length) const {
  Byte high_frame(bytes + 5);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 4);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(93, 0)" endLine="(101, 1)" clone_start="1" clone_end="4">
			<code function_name="Wheelspeed6a::rear_right_wheel_speed(const std::uint8_t* bytes, int32_t length) const">double Wheelspeed6a::rear_right_wheel_speed(const std::uint8_t* bytes,
                                            int32_t length) const {
  Byte high_frame(bytes + 7);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 6);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\tirepressure_71.cc" startLine="(47, 0)" endLine="(54, 1)" clone_start="1" clone_end="8">
			<code function_name="Tirepressure71::front_right_tire(const std::uint8_t* bytes, int32_t length) const">int32_t Tirepressure71::front_right_tire(const std::uint8_t* bytes,
                                         int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  return (high &lt;&lt; 8) | low;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\tirepressure_71.cc" startLine="(38, 0)" endLine="(45, 1)" clone_start="1" clone_end="8">
			<code function_name="Tirepressure71::front_left_tire(const std::uint8_t* bytes, int32_t length) const">int32_t Tirepressure71::front_left_tire(const std::uint8_t* bytes,
                                        int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  return (high &lt;&lt; 8) | low;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\tirepressure_71.cc" startLine="(56, 0)" endLine="(63, 1)" clone_start="1" clone_end="8">
			<code function_name="Tirepressure71::rear_left_tire(const std::uint8_t* bytes, int32_t length) const">int32_t Tirepressure71::rear_left_tire(const std::uint8_t* bytes,
                                       int32_t length) const {
  Byte high_frame(bytes + 5);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 4);
  int32_t low = low_frame.get_byte(0, 8);
  return (high &lt;&lt; 8) | low;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\tirepressure_71.cc" startLine="(47, 0)" endLine="(54, 1)" clone_start="1" clone_end="8">
			<code function_name="Tirepressure71::front_right_tire(const std::uint8_t* bytes, int32_t length) const">int32_t Tirepressure71::front_right_tire(const std::uint8_t* bytes,
                                         int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  return (high &lt;&lt; 8) | low;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\tirepressure_71.cc" startLine="(65, 0)" endLine="(72, 1)" clone_start="1" clone_end="7">
			<code function_name="Tirepressure71::rear_right_tire(const std::uint8_t* bytes, int32_t length) const">int32_t Tirepressure71::rear_right_tire(const std::uint8_t* bytes,
                                        int32_t length) const {
  Byte high_frame(bytes + 7);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 6);
  int32_t low = low_frame.get_byte(0, 8);
  return (high &lt;&lt; 8) | low;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\tirepressure_71.cc" startLine="(56, 0)" endLine="(63, 1)" clone_start="1" clone_end="7">
			<code function_name="Tirepressure71::rear_left_tire(const std::uint8_t* bytes, int32_t length) const">int32_t Tirepressure71::rear_left_tire(const std::uint8_t* bytes,
                                       int32_t length) const {
  Byte high_frame(bytes + 5);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 4);
  int32_t low = low_frame.get_byte(0, 8);
  return (high &lt;&lt; 8) | low;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\adapters\adapter_manager.cc" startLine="(45, 0)" endLine="(110, 1)" clone_start="33" clone_end="56">
			<code function_name="AdapterManager::Init(const AdapterManagerConfig&amp; configs)">void AdapterManager::Init(const AdapterManagerConfig&amp; configs) {
  if (configs.is_ros()) {
    instance()-&gt;node_handle_.reset(new ros::NodeHandle());
  }

  for (const auto&amp; config : configs.config()) {
    switch (config.type()) {
      case AdapterConfig::GPS:
        EnableGps(FLAGS_gps_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::IMU:
        EnableImu(FLAGS_imu_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS:
        EnableChassis(FLAGS_chassis_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::LOCALIZATION:
        EnableLocalization(FLAGS_localization_topic, config.mode(),
                           config.message_history_limit());
        break;
      case AdapterConfig::PERCEPTION_OBSTACLES:
        EnablePerceptionObstacles(FLAGS_perception_obstacle_topic,
                                  config.mode(),
                                  config.message_history_limit());
        break;
      case AdapterConfig::TRAFFIC_LIGHT_DETECTION:
        EnableTrafficLightDetection(FLAGS_traffic_light_detection_topic,
                                    config.mode(),
                                    config.message_history_limit());
      case AdapterConfig::PAD:
        EnablePad(FLAGS_pad_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CONTROL_COMMAND:
        EnableControlCommand(FLAGS_control_command_topic, config.mode(),
                             config.message_history_limit());
        break;
      case AdapterConfig::PLANNING_TRAJECTORY:
        EnablePlanningTrajectory(FLAGS_planning_trajectory_topic, config.mode(),
                                 config.message_history_limit());
        break;
      case AdapterConfig::PREDICTION:
        EnablePrediction(FLAGS_prediction_topic, config.mode(),
                         config.message_history_limit());
        break;
      case AdapterConfig::MONITOR:
        EnableMonitor(FLAGS_monitor_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS_DETAIL:
        EnableChassisDetail(FLAGS_chassis_detail_topic, config.mode(),
                            config.message_history_limit());
        break;
      case AdapterConfig::DECISION:
        EnableDecision(FLAGS_decision_topic, config.mode(),
                       config.message_history_limit());
        break;
      default:
        AERROR &lt;&lt; "Unknown adapter config type!";
        break;
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\common\adapters\adapter_manager.cc" startLine="(45, 0)" endLine="(110, 1)" clone_start="37" clone_end="60">
			<code function_name="AdapterManager::Init(const AdapterManagerConfig&amp; configs)">void AdapterManager::Init(const AdapterManagerConfig&amp; configs) {
  if (configs.is_ros()) {
    instance()-&gt;node_handle_.reset(new ros::NodeHandle());
  }

  for (const auto&amp; config : configs.config()) {
    switch (config.type()) {
      case AdapterConfig::GPS:
        EnableGps(FLAGS_gps_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::IMU:
        EnableImu(FLAGS_imu_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS:
        EnableChassis(FLAGS_chassis_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::LOCALIZATION:
        EnableLocalization(FLAGS_localization_topic, config.mode(),
                           config.message_history_limit());
        break;
      case AdapterConfig::PERCEPTION_OBSTACLES:
        EnablePerceptionObstacles(FLAGS_perception_obstacle_topic,
                                  config.mode(),
                                  config.message_history_limit());
        break;
      case AdapterConfig::TRAFFIC_LIGHT_DETECTION:
        EnableTrafficLightDetection(FLAGS_traffic_light_detection_topic,
                                    config.mode(),
                                    config.message_history_limit());
      case AdapterConfig::PAD:
        EnablePad(FLAGS_pad_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CONTROL_COMMAND:
        EnableControlCommand(FLAGS_control_command_topic, config.mode(),
                             config.message_history_limit());
        break;
      case AdapterConfig::PLANNING_TRAJECTORY:
        EnablePlanningTrajectory(FLAGS_planning_trajectory_topic, config.mode(),
                                 config.message_history_limit());
        break;
      case AdapterConfig::PREDICTION:
        EnablePrediction(FLAGS_prediction_topic, config.mode(),
                         config.message_history_limit());
        break;
      case AdapterConfig::MONITOR:
        EnableMonitor(FLAGS_monitor_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS_DETAIL:
        EnableChassisDetail(FLAGS_chassis_detail_topic, config.mode(),
                            config.message_history_limit());
        break;
      case AdapterConfig::DECISION:
        EnableDecision(FLAGS_decision_topic, config.mode(),
                       config.message_history_limit());
        break;
      default:
        AERROR &lt;&lt; "Unknown adapter config type!";
        break;
    }
  }
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(36, 0)" endLine="(47, 1)" clone_start="1" clone_end="12">
			<code function_name="Accel6b::lateral_acceleration(const std::uint8_t* bytes, int32_t length) const">double Accel6b::lateral_acceleration(const std::uint8_t* bytes,
                                     int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gyro_6c.cc" startLine="(35, 0)" endLine="(45, 1)" clone_start="1" clone_end="11">
			<code function_name="Gyro6c::roll_rate(const std::uint8_t* bytes, int32_t length) const">double Gyro6c::roll_rate(const std::uint8_t* bytes, int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.000200;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(162, 0)" endLine="(173, 1)" clone_start="1" clone_end="12">
			<code function_name="Brakeinfo74::wheel_torque_actual(const std::uint8_t* bytes, int32_t length) const">double Brakeinfo74::wheel_torque_actual(const std::uint8_t* bytes,
                                        int32_t length) const {
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 6);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FFF) {
    value -= 0x4000;
  }
  return value * 4.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(49, 0)" endLine="(60, 1)" clone_start="1" clone_end="12">
			<code function_name="Accel6b::longitudinal_acceleration(const std::uint8_t* bytes, int32_t length) const">double Accel6b::longitudinal_acceleration(const std::uint8_t* bytes,
                                          int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.010000;
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(49, 0)" endLine="(60, 1)" clone_start="1" clone_end="11">
			<code function_name="Accel6b::longitudinal_acceleration(const std::uint8_t* bytes, int32_t length) const">double Accel6b::longitudinal_acceleration(const std::uint8_t* bytes,
                                          int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gyro_6c.cc" startLine="(47, 0)" endLine="(57, 1)" clone_start="1" clone_end="10">
			<code function_name="Gyro6c::yaw_rate(const std::uint8_t* bytes, int32_t length) const">double Gyro6c::yaw_rate(const std::uint8_t* bytes, int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.000200;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(175, 0)" endLine="(187, 1)" clone_start="1" clone_end="12">
			<code function_name="Brakeinfo74::acceleration_over_ground(const std::uint8_t* bytes, int32_t length) const">double Brakeinfo74::acceleration_over_ground(const std::uint8_t* bytes,
                                             int32_t length) const {
  // vehicle acceleration over ground estimate
  Byte frame_high(bytes + 7);
  int32_t high = frame_high.get_byte(0, 2);
  Byte frame_low(bytes + 6);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FF) {
    value -= 0x400;
  }
  return value * 0.035000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(62, 0)" endLine="(73, 1)" clone_start="1" clone_end="11">
			<code function_name="Accel6b::vertical_acceleration(const std::uint8_t* bytes, int32_t length) const">double Accel6b::vertical_acceleration(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte high_frame(bytes + 5);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 4);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.010000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(346, 0)" endLine="(423, 1)" clone_start="33" clone_end="51">
			<code function_name="NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs)">bool NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs) {
    _gnss.mutable_position()-&gt;set_lon(pos-&gt;longitude);
    _gnss.mutable_position()-&gt;set_lat(pos-&gt;latitude);
    _gnss.mutable_position()-&gt;set_height(pos-&gt;height_msl + pos-&gt;undulation);
    _gnss.mutable_position_std_dev()-&gt;set_x(pos-&gt;longitude_std_dev);
    _gnss.mutable_position_std_dev()-&gt;set_y(pos-&gt;latitude_std_dev);
    _gnss.mutable_position_std_dev()-&gt;set_z(pos-&gt;height_std_dev);
    _gnss.set_num_sats(pos-&gt;num_sats_in_solution);
    if (_solution_status != pos-&gt;solution_status) {
        _solution_status = pos-&gt;solution_status;
        ROS_INFO_STREAM("Solution status: " &lt;&lt; static_cast&lt;int&gt;(_solution_status));
    }
    if (_position_type != pos-&gt;position_type) {
        _position_type = pos-&gt;position_type;
        ROS_INFO_STREAM("Position type: " &lt;&lt; static_cast&lt;int&gt;(_position_type));
    }
    _gnss.set_solution_status(static_cast&lt;uint32_t&gt;(pos-&gt;solution_status));
    if (pos-&gt;solution_status == novatel::SolutionStatus::SOL_COMPUTED) {
        _gnss.set_position_type(static_cast&lt;uint32_t&gt;(pos-&gt;position_type));
        switch (pos-&gt;position_type) {
        case novatel::SolutionType::SINGLE:
        case novatel::SolutionType::INS_PSRSP:
            _gnss.set_type(apollo::drivers::gnss::Gnss::SINGLE);
            break;
        case novatel::SolutionType::PSRDIFF:
        case novatel::SolutionType::WAAS:
        case novatel::SolutionType::INS_SBAS:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PSRDIFF);
            break;
        case novatel::SolutionType::FLOATCONV:
        case novatel::SolutionType::L1_FLOAT:
        case novatel::SolutionType::IONOFREE_FLOAT:
        case novatel::SolutionType::NARROW_FLOAT:
        case novatel::SolutionType::RTK_DIRECT_INS:
        case novatel::SolutionType::INS_RTKFLOAT:
            _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_FLOAT);
            break;
        case novatel::SolutionType::WIDELANE:
        case novatel::SolutionType::NARROWLANE:
        case novatel::SolutionType::L1_INT:
        case novatel::SolutionType::WIDE_INT:
        case novatel::SolutionType::NARROW_INT:
        case novatel::SolutionType::INS_RTKFIXED:
            _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_INTEGER);
            break;
        case novatel::SolutionType::OMNISTAR:
        case novatel::SolutionType::INS_OMNISTAR:
        case novatel::SolutionType::INS_OMNISTAR_HP:
        case novatel::SolutionType::INS_OMNISTAR_XP:
        case novatel::SolutionType::OMNISTAR_HP:
        case novatel::SolutionType::OMNISTAR_XP:
        case novatel::SolutionType::PPP_CONVERGING:
        case novatel::SolutionType::PPP:
        case novatel::SolutionType::INS_PPP_CONVERGING:
        case novatel::SolutionType::INS_PPP:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PPP);
            break;
        case novatel::SolutionType::PROPOGATED:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PROPAGATED);
            break;
        default:
            _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
        }
    } else {
        _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
        _gnss.set_position_type(0);
    }
    if (pos-&gt;datum_id != novatel::DatumId::WGS84) {
        ROS_ERROR_STREAM_THROTTLE(5, "Unexpected Datum Id: " &lt;&lt; static_cast&lt;int&gt;(pos-&gt;datum_id));
    }

    double seconds = gps_week * SECONDS_PER_WEEK + gps_millisecs * 1e-3;
    if (_gnss.measurement_time() != seconds) {
        _gnss.set_measurement_time(seconds);
        return false;
    }
    return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(346, 0)" endLine="(423, 1)" clone_start="25" clone_end="43">
			<code function_name="NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs)">bool NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs) {
    _gnss.mutable_position()-&gt;set_lon(pos-&gt;longitude);
    _gnss.mutable_position()-&gt;set_lat(pos-&gt;latitude);
    _gnss.mutable_position()-&gt;set_height(pos-&gt;height_msl + pos-&gt;undulation);
    _gnss.mutable_position_std_dev()-&gt;set_x(pos-&gt;longitude_std_dev);
    _gnss.mutable_position_std_dev()-&gt;set_y(pos-&gt;latitude_std_dev);
    _gnss.mutable_position_std_dev()-&gt;set_z(pos-&gt;height_std_dev);
    _gnss.set_num_sats(pos-&gt;num_sats_in_solution);
    if (_solution_status != pos-&gt;solution_status) {
        _solution_status = pos-&gt;solution_status;
        ROS_INFO_STREAM("Solution status: " &lt;&lt; static_cast&lt;int&gt;(_solution_status));
    }
    if (_position_type != pos-&gt;position_type) {
        _position_type = pos-&gt;position_type;
        ROS_INFO_STREAM("Position type: " &lt;&lt; static_cast&lt;int&gt;(_position_type));
    }
    _gnss.set_solution_status(static_cast&lt;uint32_t&gt;(pos-&gt;solution_status));
    if (pos-&gt;solution_status == novatel::SolutionStatus::SOL_COMPUTED) {
        _gnss.set_position_type(static_cast&lt;uint32_t&gt;(pos-&gt;position_type));
        switch (pos-&gt;position_type) {
        case novatel::SolutionType::SINGLE:
        case novatel::SolutionType::INS_PSRSP:
            _gnss.set_type(apollo::drivers::gnss::Gnss::SINGLE);
            break;
        case novatel::SolutionType::PSRDIFF:
        case novatel::SolutionType::WAAS:
        case novatel::SolutionType::INS_SBAS:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PSRDIFF);
            break;
        case novatel::SolutionType::FLOATCONV:
        case novatel::SolutionType::L1_FLOAT:
        case novatel::SolutionType::IONOFREE_FLOAT:
        case novatel::SolutionType::NARROW_FLOAT:
        case novatel::SolutionType::RTK_DIRECT_INS:
        case novatel::SolutionType::INS_RTKFLOAT:
            _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_FLOAT);
            break;
        case novatel::SolutionType::WIDELANE:
        case novatel::SolutionType::NARROWLANE:
        case novatel::SolutionType::L1_INT:
        case novatel::SolutionType::WIDE_INT:
        case novatel::SolutionType::NARROW_INT:
        case novatel::SolutionType::INS_RTKFIXED:
            _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_INTEGER);
            break;
        case novatel::SolutionType::OMNISTAR:
        case novatel::SolutionType::INS_OMNISTAR:
        case novatel::SolutionType::INS_OMNISTAR_HP:
        case novatel::SolutionType::INS_OMNISTAR_XP:
        case novatel::SolutionType::OMNISTAR_HP:
        case novatel::SolutionType::OMNISTAR_XP:
        case novatel::SolutionType::PPP_CONVERGING:
        case novatel::SolutionType::PPP:
        case novatel::SolutionType::INS_PPP_CONVERGING:
        case novatel::SolutionType::INS_PPP:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PPP);
            break;
        case novatel::SolutionType::PROPOGATED:
            _gnss.set_type(apollo::drivers::gnss::Gnss::PROPAGATED);
            break;
        default:
            _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
        }
    } else {
        _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
        _gnss.set_position_type(0);
    }
    if (pos-&gt;datum_id != novatel::DatumId::WGS84) {
        ROS_ERROR_STREAM_THROTTLE(5, "Unexpected Datum Id: " &lt;&lt; static_cast&lt;int&gt;(pos-&gt;datum_id));
    }

    double seconds = gps_week * SECONDS_PER_WEEK + gps_millisecs * 1e-3;
    if (_gnss.measurement_time() != seconds) {
        _gnss.set_measurement_time(seconds);
        return false;
    }
    return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(135, 0)" endLine="(254, 1)" clone_start="31" clone_end="56">
			<code function_name="RawStream::init(const std::string&amp; cfg_file)">bool RawStream::init(const std::string&amp; cfg_file) {
   if (!_stream_status) {
        ROS_ERROR_STREAM("New stream status failed.");
        return false;
    }
    _stream_status-&gt;mutable_header()-&gt;set_timestamp_sec(ros::Time::now().toSec());
    _stream_status-&gt;set_ins_stream_type(apollo::common::gnss_status::StreamStatus::DISCONNECTED);
    _stream_status-&gt;set_rtk_stream_in_type(apollo::common::gnss_status::StreamStatus::DISCONNECTED);
    _stream_status-&gt;set_rtk_stream_out_type(apollo::common::gnss_status::StreamStatus::DISCONNECTED);
    _stream_status_publisher.publish(_stream_status);
    if (!parse_config_text(cfg_file, &amp;_config)) {
        ROS_INFO("Parse config context failed.");
        return false;
    }
    ROS_INFO_STREAM("Loaded config:\n" &lt;&lt; _config.DebugString());

    // Creates streams.
    Stream* s = nullptr;
    if (!_config.has_data()) {
        ROS_INFO("Error: Config file must provide the data stream.");
        return false;
    }
    s = create_stream(_config.data());
    if (s == nullptr) {
        ROS_ERROR("Failed to create data stream.");
        return false;
    }
    _data_stream.reset(s);

    Status *status = new Status();
    if (!status) {
        ROS_ERROR("Failed to create data stream status.");
        return false;
    }
    _data_stream_status.reset(status);

    if (_config.has_command()) {
        s = create_stream(_config.command());
        if (s == nullptr) {
            ROS_ERROR("Failed to create command stream.");
            return false;
        }
        _command_stream.reset(s);

        status = new Status();
        if (!status) {
            ROS_ERROR("Failed to create command stream status.");
            return false;
        }
        _command_stream_status.reset(status);
    } else {
        _command_stream = _data_stream;
        _command_stream_status = _data_stream_status;
    }

    if (_config.has_rtk_from()) {
        s = create_stream(_config.rtk_from());
        if (s == nullptr) {
            ROS_ERROR("Failed to create rtk_from stream.");
            return false;
        }
        _in_rtk_stream.reset(s);

        status = new Status();
        if (!status) {
            ROS_ERROR("Failed to create rtk_from stream status.");
            return false;
        }
        _in_rtk_stream_status.reset(status);

        if (_config.has_rtk_to()) {
            s = create_stream(_config.rtk_to());
            if (s == nullptr) {
                ROS_ERROR("Failed to create rtk_to stream.");
                return false;
            }
            _out_rtk_stream.reset(s);

            status = new Status();
            if (!status) {
                ROS_ERROR("Failed to create rtk_to stream status.");
                return false;
            }
            _out_rtk_stream_status.reset(status);
        } else {
            _out_rtk_stream = _data_stream;
            _out_rtk_stream_status = _data_stream_status;
        }

        if (_config.has_rtk_solution_type()) {
            if (_config.rtk_solution_type() == config::Config::RTK_SOFTWARE_SOLUTION) {
                _rtk_software_solution = true;
            }
        }
    }

    if (_config.login_commands_size() == 0) {
        ROS_WARN("No login_commands in config file.");
    }

    if (_config.logout_commands_size() == 0) {
        ROS_WARN("No logout_commands in config file.");
    }

    // connect and login
    if (!connect()) {
        ROS_ERROR("gnss driver connect failed.");
        return false;
    }

    if (!login()) {
        ROS_ERROR("gnss driver login failed.");
        return false;
    }

    _data_thread_ptr.reset(new std::thread(&amp;RawStream::data_spin, this));
    _ntrip_thread_ptr.reset(new std::thread(&amp;RawStream::ntrip_spin, this));

    return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(135, 0)" endLine="(254, 1)" clone_start="65" clone_end="90">
			<code function_name="RawStream::init(const std::string&amp; cfg_file)">bool RawStream::init(const std::string&amp; cfg_file) {
   if (!_stream_status) {
        ROS_ERROR_STREAM("New stream status failed.");
        return false;
    }
    _stream_status-&gt;mutable_header()-&gt;set_timestamp_sec(ros::Time::now().toSec());
    _stream_status-&gt;set_ins_stream_type(apollo::common::gnss_status::StreamStatus::DISCONNECTED);
    _stream_status-&gt;set_rtk_stream_in_type(apollo::common::gnss_status::StreamStatus::DISCONNECTED);
    _stream_status-&gt;set_rtk_stream_out_type(apollo::common::gnss_status::StreamStatus::DISCONNECTED);
    _stream_status_publisher.publish(_stream_status);
    if (!parse_config_text(cfg_file, &amp;_config)) {
        ROS_INFO("Parse config context failed.");
        return false;
    }
    ROS_INFO_STREAM("Loaded config:\n" &lt;&lt; _config.DebugString());

    // Creates streams.
    Stream* s = nullptr;
    if (!_config.has_data()) {
        ROS_INFO("Error: Config file must provide the data stream.");
        return false;
    }
    s = create_stream(_config.data());
    if (s == nullptr) {
        ROS_ERROR("Failed to create data stream.");
        return false;
    }
    _data_stream.reset(s);

    Status *status = new Status();
    if (!status) {
        ROS_ERROR("Failed to create data stream status.");
        return false;
    }
    _data_stream_status.reset(status);

    if (_config.has_command()) {
        s = create_stream(_config.command());
        if (s == nullptr) {
            ROS_ERROR("Failed to create command stream.");
            return false;
        }
        _command_stream.reset(s);

        status = new Status();
        if (!status) {
            ROS_ERROR("Failed to create command stream status.");
            return false;
        }
        _command_stream_status.reset(status);
    } else {
        _command_stream = _data_stream;
        _command_stream_status = _data_stream_status;
    }

    if (_config.has_rtk_from()) {
        s = create_stream(_config.rtk_from());
        if (s == nullptr) {
            ROS_ERROR("Failed to create rtk_from stream.");
            return false;
        }
        _in_rtk_stream.reset(s);

        status = new Status();
        if (!status) {
            ROS_ERROR("Failed to create rtk_from stream status.");
            return false;
        }
        _in_rtk_stream_status.reset(status);

        if (_config.has_rtk_to()) {
            s = create_stream(_config.rtk_to());
            if (s == nullptr) {
                ROS_ERROR("Failed to create rtk_to stream.");
                return false;
            }
            _out_rtk_stream.reset(s);

            status = new Status();
            if (!status) {
                ROS_ERROR("Failed to create rtk_to stream status.");
                return false;
            }
            _out_rtk_stream_status.reset(status);
        } else {
            _out_rtk_stream = _data_stream;
            _out_rtk_stream_status = _data_stream_status;
        }

        if (_config.has_rtk_solution_type()) {
            if (_config.rtk_solution_type() == config::Config::RTK_SOFTWARE_SOLUTION) {
                _rtk_software_solution = true;
            }
        }
    }

    if (_config.login_commands_size() == 0) {
        ROS_WARN("No login_commands in config file.");
    }

    if (_config.logout_commands_size() == 0) {
        ROS_WARN("No logout_commands in config file.");
    }

    // connect and login
    if (!connect()) {
        ROS_ERROR("gnss driver connect failed.");
        return false;
    }

    if (!login()) {
        ROS_ERROR("gnss driver login failed.");
        return false;
    }

    _data_thread_ptr.reset(new std::thread(&amp;RawStream::data_spin, this));
    _ntrip_thread_ptr.reset(new std::thread(&amp;RawStream::ntrip_spin, this));

    return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(36, 0)" endLine="(47, 1)" clone_start="1" clone_end="12">
			<code function_name="Accel6b::lateral_acceleration(const std::uint8_t* bytes, int32_t length) const">double Accel6b::lateral_acceleration(const std::uint8_t* bytes,
                                     int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(162, 0)" endLine="(173, 1)" clone_start="1" clone_end="12">
			<code function_name="Brakeinfo74::wheel_torque_actual(const std::uint8_t* bytes, int32_t length) const">double Brakeinfo74::wheel_torque_actual(const std::uint8_t* bytes,
                                        int32_t length) const {
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 6);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FFF) {
    value -= 0x4000;
  }
  return value * 4.000000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(49, 0)" endLine="(60, 1)" clone_start="1" clone_end="12">
			<code function_name="Accel6b::longitudinal_acceleration(const std::uint8_t* bytes, int32_t length) const">double Accel6b::longitudinal_acceleration(const std::uint8_t* bytes,
                                          int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(175, 0)" endLine="(187, 1)" clone_start="1" clone_end="13">
			<code function_name="Brakeinfo74::acceleration_over_ground(const std::uint8_t* bytes, int32_t length) const">double Brakeinfo74::acceleration_over_ground(const std::uint8_t* bytes,
                                             int32_t length) const {
  // vehicle acceleration over ground estimate
  Byte frame_high(bytes + 7);
  int32_t high = frame_high.get_byte(0, 2);
  Byte frame_low(bytes + 6);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FF) {
    value -= 0x400;
  }
  return value * 0.035000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(62, 0)" endLine="(73, 1)" clone_start="1" clone_end="3">
			<code function_name="Accel6b::vertical_acceleration(const std::uint8_t* bytes, int32_t length) const">double Accel6b::vertical_acceleration(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte high_frame(bytes + 5);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 4);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(189, 0)" endLine="(193, 1)" clone_start="1" clone_end="3">
			<code function_name="Brakeinfo74::is_abs_active(const std::uint8_t* bytes, int32_t length) const">bool Brakeinfo74::is_abs_active(const std::uint8_t* bytes,
                                int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(2);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(289, 0)" endLine="(310, 1)" clone_start="18" clone_end="22">
			<code function_name="LincolnController::EnableSteeringOnlyMode()">ErrorCode LincolnController::EnableSteeringOnlyMode() {
  if (driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
      driving_mode() == Chassis::AUTO_STEER_ONLY) {
    set_driving_mode(Chassis::AUTO_STEER_ONLY);
    AINFO &lt;&lt; "Already in AUTO_STEER_ONLY mode";
    return ErrorCode::OK;
  }
  brake_60_-&gt;set_disable();
  throttle_62_-&gt;set_disable();
  steering_64_-&gt;set_enable();

  can_sender_-&gt;Update();
  if (CheckResponse(CHECK_RESPONSE_STEER_UNIT_FLAG, true) == false) {
    AERROR &lt;&lt; "Failed to switch to AUTO_STEER_ONLY mode.";
    Emergency();
    return ErrorCode::CANBUS_ERROR;
  } else {
    set_driving_mode(Chassis::AUTO_STEER_ONLY);
    AINFO &lt;&lt; "Switch to AUTO_STEER_ONLY mode ok.";
    return ErrorCode::OK;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(280, 0)" endLine="(287, 1)" clone_start="5" clone_end="8">
			<code function_name="LincolnController::DisableAutoMode()">ErrorCode LincolnController::DisableAutoMode() {
  ResetProtocol();
  can_sender_-&gt;Update();
  set_driving_mode(Chassis::COMPLETE_MANUAL);
  set_chassis_error_code(Chassis::NO_ERROR);
  AINFO &lt;&lt; "Switch to COMPLETE_MANUAL ok.";
  return ErrorCode::OK;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(312, 0)" endLine="(333, 1)" clone_start="1" clone_end="20">
			<code function_name="LincolnController::EnableSpeedOnlyMode()">ErrorCode LincolnController::EnableSpeedOnlyMode() {
  if (driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
      driving_mode() == Chassis::AUTO_SPEED_ONLY) {
    set_driving_mode(Chassis::AUTO_SPEED_ONLY);
    AINFO &lt;&lt; "Already in AUTO_SPEED_ONLY mode";
    return ErrorCode::OK;
  }
  brake_60_-&gt;set_enable();
  throttle_62_-&gt;set_enable();
  steering_64_-&gt;set_disable();

  can_sender_-&gt;Update();
  if (CheckResponse(CHECK_RESPONSE_SPEED_UNIT_FLAG, true) == false) {
    AERROR &lt;&lt; "Failed to switch to AUTO_STEER_ONLY mode.";
    Emergency();
    return ErrorCode::CANBUS_ERROR;
  } else {
    set_driving_mode(Chassis::AUTO_SPEED_ONLY);
    AINFO &lt;&lt; "Switch to AUTO_SPEED_ONLY mode ok.";
    return ErrorCode::OK;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(289, 0)" endLine="(310, 1)" clone_start="1" clone_end="20">
			<code function_name="LincolnController::EnableSteeringOnlyMode()">ErrorCode LincolnController::EnableSteeringOnlyMode() {
  if (driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
      driving_mode() == Chassis::AUTO_STEER_ONLY) {
    set_driving_mode(Chassis::AUTO_STEER_ONLY);
    AINFO &lt;&lt; "Already in AUTO_STEER_ONLY mode";
    return ErrorCode::OK;
  }
  brake_60_-&gt;set_disable();
  throttle_62_-&gt;set_disable();
  steering_64_-&gt;set_enable();

  can_sender_-&gt;Update();
  if (CheckResponse(CHECK_RESPONSE_STEER_UNIT_FLAG, true) == false) {
    AERROR &lt;&lt; "Failed to switch to AUTO_STEER_ONLY mode.";
    Emergency();
    return ErrorCode::CANBUS_ERROR;
  } else {
    set_driving_mode(Chassis::AUTO_STEER_ONLY);
    AINFO &lt;&lt; "Switch to AUTO_STEER_ONLY mode ok.";
    return ErrorCode::OK;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6d.cc" startLine="(33, 0)" endLine="(57, 1)" clone_start="1" clone_end="25">
			<code function_name="Gps6d::latitude(const std::uint8_t* bytes, int32_t length) const">double Gps6d::latitude(const std::uint8_t* bytes, int32_t length) const {
  Byte frame_0(bytes + 3);
  int32_t value = frame_0.get_byte(0, 7);

  Byte frame_1(bytes + 2);
  int32_t t = frame_1.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_2(bytes + 1);
  t = frame_2.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_3(bytes + 0);
  t = frame_3.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  if (value &gt; 0x3FFFFFFF) {
    value -= 0x80000000;
  }

  return value * (1.000000 / 3.000000) * 1e-6;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6d.cc" startLine="(59, 0)" endLine="(83, 1)" clone_start="1" clone_end="25">
			<code function_name="Gps6d::longitude(const std::uint8_t* bytes, int32_t length) const">double Gps6d::longitude(const std::uint8_t* bytes, int32_t length) const {
  Byte frame_0(bytes + 7);
  int32_t value = frame_0.get_byte(0, 7);

  Byte frame_1(bytes + 6);
  int32_t t = frame_1.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_2(bytes + 5);
  t = frame_2.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_3(bytes + 4);
  t = frame_3.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  if (value &gt; 0x3FFFFFFF) {
    value -= 0x80000000;
  }

  return value * (1.000000 / 3.000000) * 1e-6;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6d.cc" startLine="(59, 0)" endLine="(83, 1)" clone_start="1" clone_end="2">
			<code function_name="Gps6d::longitude(const std::uint8_t* bytes, int32_t length) const">double Gps6d::longitude(const std::uint8_t* bytes, int32_t length) const {
  Byte frame_0(bytes + 7);
  int32_t value = frame_0.get_byte(0, 7);

  Byte frame_1(bytes + 6);
  int32_t t = frame_1.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_2(bytes + 5);
  t = frame_2.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_3(bytes + 4);
  t = frame_3.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  if (value &gt; 0x3FFFFFFF) {
    value -= 0x80000000;
  }

  return value * (1.000000 / 3.000000) * 1e-6;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6d.cc" startLine="(85, 0)" endLine="(88, 1)" clone_start="1" clone_end="2">
			<code function_name="Gps6d::is_valid(const std::uint8_t* bytes, int32_t length) const">bool Gps6d::is_valid(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(7);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(111, 0)" endLine="(119, 1)" clone_start="5" clone_end="9">
			<code function_name="Steering65::epas_torque(const std::uint8_t* bytes, int32_t length) const">double Steering65::epas_torque(const std::uint8_t* bytes,
                               int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 8);
  if (x &gt; 0x7F) {
    x -= 0x100;
  }
  return x * 0.062500;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(175, 0)" endLine="(187, 1)" clone_start="9" clone_end="13">
			<code function_name="Brakeinfo74::acceleration_over_ground(const std::uint8_t* bytes, int32_t length) const">double Brakeinfo74::acceleration_over_ground(const std::uint8_t* bytes,
                                             int32_t length) const {
  // vehicle acceleration over ground estimate
  Byte frame_high(bytes + 7);
  int32_t high = frame_high.get_byte(0, 2);
  Byte frame_low(bytes + 6);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FF) {
    value -= 0x400;
  }
  return value * 0.035000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(121, 0)" endLine="(124, 1)" clone_start="1" clone_end="4">
			<code function_name="Steering65::is_enabled(const std::uint8_t* bytes, int32_t length) const">bool Steering65::is_enabled(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(189, 0)" endLine="(193, 1)" clone_start="1" clone_end="5">
			<code function_name="Brakeinfo74::is_abs_active(const std::uint8_t* bytes, int32_t length) const">bool Brakeinfo74::is_abs_active(const std::uint8_t* bytes,
                                int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(2);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(126, 0)" endLine="(131, 1)" clone_start="1" clone_end="6">
			<code function_name="Steering65::is_driver_override(const std::uint8_t* bytes, int32_t length) const">bool Steering65::is_driver_override(const std::uint8_t* bytes,
                                    int32_t length) const {
  // Cleared on rising edge of EN bit in command message
  Byte frame(bytes + 7);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(195, 0)" endLine="(199, 1)" clone_start="1" clone_end="5">
			<code function_name="Brakeinfo74::is_abs_enabled(const std::uint8_t* bytes, int32_t length) const">bool Brakeinfo74::is_abs_enabled(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(133, 0)" endLine="(137, 1)" clone_start="1" clone_end="5">
			<code function_name="Steering65::is_driver_activity(const std::uint8_t* bytes, int32_t length) const">bool Steering65::is_driver_activity(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(201, 0)" endLine="(205, 1)" clone_start="1" clone_end="5">
			<code function_name="Brakeinfo74::is_stability_control_active(const std::uint8_t* bytes, int32_t length) const">bool Brakeinfo74::is_stability_control_active(const std::uint8_t* bytes,
                                              int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(4);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(139, 0)" endLine="(143, 1)" clone_start="1" clone_end="5">
			<code function_name="Steering65::is_watchdog_counter_fault(const std::uint8_t* bytes, int32_t length) const">bool Steering65::is_watchdog_counter_fault(const std::uint8_t* bytes,
                                           int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(207, 0)" endLine="(211, 1)" clone_start="1" clone_end="5">
			<code function_name="Brakeinfo74::is_stability_control_enabled(const std::uint8_t* bytes, int32_t length) const">bool Brakeinfo74::is_stability_control_enabled(const std::uint8_t* bytes,
                                               int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(5);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(145, 0)" endLine="(149, 1)" clone_start="1" clone_end="5">
			<code function_name="Steering65::is_channel_1_fault(const std::uint8_t* bytes, int32_t length) const">bool Steering65::is_channel_1_fault(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(213, 0)" endLine="(217, 1)" clone_start="1" clone_end="5">
			<code function_name="Brakeinfo74::is_traction_control_active(const std::uint8_t* bytes, int32_t length) const">bool Brakeinfo74::is_traction_control_active(const std::uint8_t* bytes,
                                             int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(6);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(151, 0)" endLine="(155, 1)" clone_start="1" clone_end="4">
			<code function_name="Steering65::is_channel_2_fault(const std::uint8_t* bytes, int32_t length) const">bool Steering65::is_channel_2_fault(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(219, 0)" endLine="(223, 1)" clone_start="1" clone_end="4">
			<code function_name="Brakeinfo74::is_traction_control_enabled(const std::uint8_t* bytes, int32_t length) const">bool Brakeinfo74::is_traction_control_enabled(const std::uint8_t* bytes,
                                              int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(7);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(57, 0)" endLine="(68, 1)" clone_start="1" clone_end="12">
			<code function_name="Brake61::pedal_input(const std::uint8_t* bytes, int32_t length) const">double Brake61::pedal_input(const std::uint8_t* bytes, int32_t length) const {
  // Pedal Input from the physical pedal
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(64, 0)" endLine="(75, 1)" clone_start="1" clone_end="12">
			<code function_name="Throttle63::pedal_cmd(const std::uint8_t* bytes, int32_t length) const">double Throttle63::pedal_cmd(const std::uint8_t* bytes, int32_t length) const {
  // Pedal Command from the command message
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(50, 0)" endLine="(62, 1)" clone_start="1" clone_end="13">
			<code function_name="Throttle63::pedal_input(const std::uint8_t* bytes, int32_t length) const">double Throttle63::pedal_input(const std::uint8_t* bytes,
                               int32_t length) const {
  // Pedal Input from the physical pedal
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(70, 0)" endLine="(81, 1)" clone_start="1" clone_end="12">
			<code function_name="Brake61::pedal_cmd(const std::uint8_t* bytes, int32_t length) const">double Brake61::pedal_cmd(const std::uint8_t* bytes, int32_t length) const {
  // Pedal Command from the command message
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(77, 0)" endLine="(89, 1)" clone_start="1" clone_end="13">
			<code function_name="Throttle63::pedal_output(const std::uint8_t* bytes, int32_t length) const">double Throttle63::pedal_output(const std::uint8_t* bytes,
                                int32_t length) const {
  // Pedal Output is the maximum of PI and PC
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(64, 0)" endLine="(75, 1)" clone_start="1" clone_end="12">
			<code function_name="Throttle63::pedal_cmd(const std::uint8_t* bytes, int32_t length) const">double Throttle63::pedal_cmd(const std::uint8_t* bytes, int32_t length) const {
  // Pedal Command from the command message
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(83, 0)" endLine="(94, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake61::pedal_output(const std::uint8_t* bytes, int32_t length) const">double Brake61::pedal_output(const std::uint8_t* bytes, int32_t length) const {
  // Pedal Output is the maximum of PI and PC
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(91, 0)" endLine="(96, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle63::watchdog_counter_source(const std::uint8_t* bytes, int32_t length) const">int32_t Throttle63::watchdog_counter_source(const std::uint8_t* bytes,
                                            int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(77, 0)" endLine="(89, 1)" clone_start="1" clone_end="5">
			<code function_name="Throttle63::pedal_output(const std::uint8_t* bytes, int32_t length) const">double Throttle63::pedal_output(const std::uint8_t* bytes,
                                int32_t length) const {
  // Pedal Output is the maximum of PI and PC
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(63, 0)" endLine="(71, 1)" clone_start="1" clone_end="9">
			<code function_name="Wheelspeed6a::front_left_wheel_speed(const std::uint8_t* bytes, int32_t length) const">double Wheelspeed6a::front_left_wheel_speed(const std::uint8_t* bytes,
                                            int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(73, 0)" endLine="(81, 1)" clone_start="1" clone_end="9">
			<code function_name="Wheelspeed6a::front_right_wheel_speed(const std::uint8_t* bytes, int32_t length) const">double Wheelspeed6a::front_right_wheel_speed(const std::uint8_t* bytes,
                                             int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(73, 0)" endLine="(81, 1)" clone_start="1" clone_end="9">
			<code function_name="Wheelspeed6a::front_right_wheel_speed(const std::uint8_t* bytes, int32_t length) const">double Wheelspeed6a::front_right_wheel_speed(const std::uint8_t* bytes,
                                             int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(83, 0)" endLine="(91, 1)" clone_start="1" clone_end="9">
			<code function_name="Wheelspeed6a::rear_left_wheel_speed(const std::uint8_t* bytes, int32_t length) const">double Wheelspeed6a::rear_left_wheel_speed(const std::uint8_t* bytes,
                                           int32_t length) const {
  Byte high_frame(bytes + 5);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 4);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(83, 0)" endLine="(91, 1)" clone_start="1" clone_end="8">
			<code function_name="Wheelspeed6a::rear_left_wheel_speed(const std::uint8_t* bytes, int32_t length) const">double Wheelspeed6a::rear_left_wheel_speed(const std::uint8_t* bytes,
                                           int32_t length) const {
  Byte high_frame(bytes + 5);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 4);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(93, 0)" endLine="(101, 1)" clone_start="1" clone_end="8">
			<code function_name="Wheelspeed6a::rear_right_wheel_speed(const std::uint8_t* bytes, int32_t length) const">double Wheelspeed6a::rear_right_wheel_speed(const std::uint8_t* bytes,
                                            int32_t length) const {
  Byte high_frame(bytes + 7);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 6);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="88" clone_end="113">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="34" clone_end="58">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(48, 0)" endLine="(52, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::month(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::month(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(42, 0)" endLine="(46, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::year(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::year(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 7);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(54, 0)" endLine="(58, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::day(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::day(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 2);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(48, 0)" endLine="(52, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::month(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::month(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 4);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(60, 0)" endLine="(64, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::hours(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::hours(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(54, 0)" endLine="(58, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::day(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::day(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 2);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(66, 0)" endLine="(70, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::minutes(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::minutes(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(60, 0)" endLine="(64, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::hours(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::hours(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(72, 0)" endLine="(76, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::seconds(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::seconds(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 5);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(66, 0)" endLine="(70, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::minutes(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::minutes(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(78, 0)" endLine="(83, 1)" clone_start="1" clone_end="4">
			<code function_name="Gps6e::compass_direction(const std::uint8_t* bytes, int32_t length) const">double Gps6e::compass_direction(const std::uint8_t* bytes,
                                int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 4);
  return x * 45.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(72, 0)" endLine="(76, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6e::seconds(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::seconds(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 5);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(26, 0)" endLine="(89, 1)" clone_start="3" clone_end="25">
			<code function_name="Gear67::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Gear67::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t gear = gear_state(bytes, length);
  switch (gear) {
    case 0x01:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_PARKING);
      break;
    case 0x02:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_REVERSE);
      break;
    case 0x03:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_NEUTRAL);
      break;
    case 0x04:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_DRIVE);
      break;
    case 0x05:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_LOW);
      break;
    case 0x00:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_NONE);
      break;
    default:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_INVALID);
      break;
  }

  if (is_driver_override(bytes, length)) {
    // last shift requested by driver
    car_status-&gt;mutable_gear()-&gt;set_is_shift_position_valid(false);
  } else {
    // last shift requested by-wire
    car_status-&gt;mutable_gear()-&gt;set_is_shift_position_valid(true);
  }
  car_status-&gt;mutable_gear()-&gt;set_driver_override(
      is_driver_override(bytes, length));

  int32_t gear_cmd = reported_gear_cmd(bytes, length);
  switch (gear_cmd) {
    case 0x01:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_PARKING);
      break;
    case 0x02:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_REVERSE);
      break;
    case 0x03:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_NEUTRAL);
      break;
    case 0x04:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_DRIVE);
      break;
    case 0x05:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_LOW);
      break;
    case 0x00:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_NONE);
      break;
    default:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_INVALID);
      break;
  }

  car_status-&gt;mutable_gear()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(26, 0)" endLine="(89, 1)" clone_start="38" clone_end="60">
			<code function_name="Gear67::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Gear67::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t gear = gear_state(bytes, length);
  switch (gear) {
    case 0x01:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_PARKING);
      break;
    case 0x02:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_REVERSE);
      break;
    case 0x03:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_NEUTRAL);
      break;
    case 0x04:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_DRIVE);
      break;
    case 0x05:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_LOW);
      break;
    case 0x00:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_NONE);
      break;
    default:
      car_status-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_INVALID);
      break;
  }

  if (is_driver_override(bytes, length)) {
    // last shift requested by driver
    car_status-&gt;mutable_gear()-&gt;set_is_shift_position_valid(false);
  } else {
    // last shift requested by-wire
    car_status-&gt;mutable_gear()-&gt;set_is_shift_position_valid(true);
  }
  car_status-&gt;mutable_gear()-&gt;set_driver_override(
      is_driver_override(bytes, length));

  int32_t gear_cmd = reported_gear_cmd(bytes, length);
  switch (gear_cmd) {
    case 0x01:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_PARKING);
      break;
    case 0x02:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_REVERSE);
      break;
    case 0x03:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_NEUTRAL);
      break;
    case 0x04:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_DRIVE);
      break;
    case 0x05:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_LOW);
      break;
    case 0x00:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_NONE);
      break;
    default:
      car_status-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_INVALID);
      break;
  }

  car_status-&gt;mutable_gear()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="10">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="65" clone_end="89">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="62" clone_end="86">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="59" clone_end="83">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="56" clone_end="80">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="53" clone_end="77">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="50" clone_end="73">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="47" clone_end="70">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="44" clone_end="67">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="41" clone_end="64">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="6" clone_end="32">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t* bytes, int32_t length,
                        ChassisDetail* chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\can_client\esd\esd_can_client.cc" startLine="(173, 0)" endLine="(282, 1)" clone_start="53" clone_end="76">
			<code function_name="EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus)">std::string EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus) {
  struct ERR2STR {
    NTCAN_RESULT ntstatus;
    const char *str;
  };

  int8_t str_buf[ERROR_BUF_SIZE];

  static const struct ERR2STR err2str[] = {
      {NTCAN_SUCCESS, "NTCAN_SUCCESS"},
      {NTCAN_RX_TIMEOUT, "NTCAN_RX_TIMEOUT"},
      {NTCAN_TX_TIMEOUT, "NTCAN_TX_TIMEOUT"},
      {NTCAN_TX_ERROR, "NTCAN_TX_ERROR"},
      {NTCAN_CONTR_OFF_BUS, "NTCAN_CONTR_OFF_BUS"},
      {NTCAN_CONTR_BUSY, "NTCAN_CONTR_BUSY"},
      {NTCAN_CONTR_WARN, "NTCAN_CONTR_WARN"},
      {NTCAN_NO_ID_ENABLED, "NTCAN_NO_ID_ENABLED"},
      {NTCAN_ID_ALREADY_ENABLED, "NTCAN_ID_ALREADY_ENABLED"},
      {NTCAN_ID_NOT_ENABLED, "NTCAN_ID_NOT_ENABLED"},
      {NTCAN_INVALID_FIRMWARE, "NTCAN_INVALID_FIRMWARE"},
      {NTCAN_MESSAGE_LOST, "NTCAN_MESSAGE_LOST"},
      {NTCAN_INVALID_PARAMETER, "NTCAN_INVALID_PARAMETER"},
      {NTCAN_INVALID_HANDLE, "NTCAN_INVALID_HANDLE"},
      {NTCAN_NET_NOT_FOUND, "NTCAN_NET_NOT_FOUND"},
#ifdef NTCAN_IO_INCOMPLETE
      {NTCAN_IO_INCOMPLETE, "NTCAN_IO_INCOMPLETE"},
#endif
#ifdef NTCAN_IO_PENDING
      {NTCAN_IO_PENDING, "NTCAN_IO_PENDING"},
#endif
#ifdef NTCAN_INVALID_HARDWARE
      {NTCAN_INVALID_HARDWARE, "NTCAN_INVALID_HARDWARE"},
#endif
#ifdef NTCAN_PENDING_WRITE
      {NTCAN_PENDING_WRITE, "NTCAN_PENDING_WRITE"},
#endif
#ifdef NTCAN_PENDING_READ
      {NTCAN_PENDING_READ, "NTCAN_PENDING_READ"},
#endif
#ifdef NTCAN_INVALID_DRIVER
      {NTCAN_INVALID_DRIVER, "NTCAN_INVALID_DRIVER"},
#endif
#ifdef NTCAN_OPERATION_ABORTED
      {NTCAN_OPERATION_ABORTED, "NTCAN_OPERATION_ABORTED"},
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
      {NTCAN_WRONG_DEVICE_STATE, "NTCAN_WRONG_DEVICE_STATE"},
#endif
      {NTCAN_INSUFFICIENT_RESOURCES, "NTCAN_INSUFFICIENT_RESOURCES"},
#ifdef NTCAN_HANDLE_FORCED_CLOSE
      {NTCAN_HANDLE_FORCED_CLOSE, "NTCAN_HANDLE_FORCED_CLOSE"},
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
      {NTCAN_NOT_IMPLEMENTED, "NTCAN_NOT_IMPLEMENTED"},
#endif
#ifdef NTCAN_NOT_SUPPORTED
      {NTCAN_NOT_SUPPORTED, "NTCAN_NOT_SUPPORTED"},
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
      {NTCAN_SOCK_CONN_TIMEOUT, "NTCAN_SOCK_CONN_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
      {NTCAN_SOCK_CMD_TIMEOUT, "NTCAN_SOCK_CMD_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
      {NTCAN_SOCK_HOST_NOT_FOUND, "NTCAN_SOCK_HOST_NOT_FOUND"},
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
      {NTCAN_CONTR_ERR_PASSIVE, "NTCAN_CONTR_ERR_PASSIVE"},
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
      {NTCAN_ERROR_NO_BAUDRATE, "NTCAN_ERROR_NO_BAUDRATE"},
#endif
#ifdef NTCAN_ERROR_LOM
      {NTCAN_ERROR_LOM, "NTCAN_ERROR_LOM"},
#endif
      {(NTCAN_RESULT)0xffffffff, "NTCAN_UNKNOWN"} /* stop-mark */
  };

  const struct ERR2STR *es = err2str;

  do {
    if (es-&gt;ntstatus == ntstatus) {
      break;
    }
    es++;
  } while ((uint32_t)es-&gt;ntstatus != 0xffffffff);

#ifdef NTCAN_ERROR_FORMAT_LONG
  {
    NTCAN_RESULT res;
    char sz_error_text[60];

    res = canFormatError(ntstatus, NTCAN_ERROR_FORMAT_LONG, sz_error_text,
                         sizeof(sz_error_text) - 1);
    if (NTCAN_SUCCESS == res) {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s - %s",
               es-&gt;str, sz_error_text);
    } else {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
               es-&gt;str, ntstatus);
    }
  }
#else
  snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
           es-&gt;str, ntstatus);
#endif /* of NTCAN_ERROR_FORMAT_LONG */

  return std::string((const char *)(str_buf));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\can_client\esd\esd_can_client.cc" startLine="(173, 0)" endLine="(282, 1)" clone_start="50" clone_end="73">
			<code function_name="EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus)">std::string EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus) {
  struct ERR2STR {
    NTCAN_RESULT ntstatus;
    const char *str;
  };

  int8_t str_buf[ERROR_BUF_SIZE];

  static const struct ERR2STR err2str[] = {
      {NTCAN_SUCCESS, "NTCAN_SUCCESS"},
      {NTCAN_RX_TIMEOUT, "NTCAN_RX_TIMEOUT"},
      {NTCAN_TX_TIMEOUT, "NTCAN_TX_TIMEOUT"},
      {NTCAN_TX_ERROR, "NTCAN_TX_ERROR"},
      {NTCAN_CONTR_OFF_BUS, "NTCAN_CONTR_OFF_BUS"},
      {NTCAN_CONTR_BUSY, "NTCAN_CONTR_BUSY"},
      {NTCAN_CONTR_WARN, "NTCAN_CONTR_WARN"},
      {NTCAN_NO_ID_ENABLED, "NTCAN_NO_ID_ENABLED"},
      {NTCAN_ID_ALREADY_ENABLED, "NTCAN_ID_ALREADY_ENABLED"},
      {NTCAN_ID_NOT_ENABLED, "NTCAN_ID_NOT_ENABLED"},
      {NTCAN_INVALID_FIRMWARE, "NTCAN_INVALID_FIRMWARE"},
      {NTCAN_MESSAGE_LOST, "NTCAN_MESSAGE_LOST"},
      {NTCAN_INVALID_PARAMETER, "NTCAN_INVALID_PARAMETER"},
      {NTCAN_INVALID_HANDLE, "NTCAN_INVALID_HANDLE"},
      {NTCAN_NET_NOT_FOUND, "NTCAN_NET_NOT_FOUND"},
#ifdef NTCAN_IO_INCOMPLETE
      {NTCAN_IO_INCOMPLETE, "NTCAN_IO_INCOMPLETE"},
#endif
#ifdef NTCAN_IO_PENDING
      {NTCAN_IO_PENDING, "NTCAN_IO_PENDING"},
#endif
#ifdef NTCAN_INVALID_HARDWARE
      {NTCAN_INVALID_HARDWARE, "NTCAN_INVALID_HARDWARE"},
#endif
#ifdef NTCAN_PENDING_WRITE
      {NTCAN_PENDING_WRITE, "NTCAN_PENDING_WRITE"},
#endif
#ifdef NTCAN_PENDING_READ
      {NTCAN_PENDING_READ, "NTCAN_PENDING_READ"},
#endif
#ifdef NTCAN_INVALID_DRIVER
      {NTCAN_INVALID_DRIVER, "NTCAN_INVALID_DRIVER"},
#endif
#ifdef NTCAN_OPERATION_ABORTED
      {NTCAN_OPERATION_ABORTED, "NTCAN_OPERATION_ABORTED"},
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
      {NTCAN_WRONG_DEVICE_STATE, "NTCAN_WRONG_DEVICE_STATE"},
#endif
      {NTCAN_INSUFFICIENT_RESOURCES, "NTCAN_INSUFFICIENT_RESOURCES"},
#ifdef NTCAN_HANDLE_FORCED_CLOSE
      {NTCAN_HANDLE_FORCED_CLOSE, "NTCAN_HANDLE_FORCED_CLOSE"},
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
      {NTCAN_NOT_IMPLEMENTED, "NTCAN_NOT_IMPLEMENTED"},
#endif
#ifdef NTCAN_NOT_SUPPORTED
      {NTCAN_NOT_SUPPORTED, "NTCAN_NOT_SUPPORTED"},
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
      {NTCAN_SOCK_CONN_TIMEOUT, "NTCAN_SOCK_CONN_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
      {NTCAN_SOCK_CMD_TIMEOUT, "NTCAN_SOCK_CMD_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
      {NTCAN_SOCK_HOST_NOT_FOUND, "NTCAN_SOCK_HOST_NOT_FOUND"},
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
      {NTCAN_CONTR_ERR_PASSIVE, "NTCAN_CONTR_ERR_PASSIVE"},
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
      {NTCAN_ERROR_NO_BAUDRATE, "NTCAN_ERROR_NO_BAUDRATE"},
#endif
#ifdef NTCAN_ERROR_LOM
      {NTCAN_ERROR_LOM, "NTCAN_ERROR_LOM"},
#endif
      {(NTCAN_RESULT)0xffffffff, "NTCAN_UNKNOWN"} /* stop-mark */
  };

  const struct ERR2STR *es = err2str;

  do {
    if (es-&gt;ntstatus == ntstatus) {
      break;
    }
    es++;
  } while ((uint32_t)es-&gt;ntstatus != 0xffffffff);

#ifdef NTCAN_ERROR_FORMAT_LONG
  {
    NTCAN_RESULT res;
    char sz_error_text[60];

    res = canFormatError(ntstatus, NTCAN_ERROR_FORMAT_LONG, sz_error_text,
                         sizeof(sz_error_text) - 1);
    if (NTCAN_SUCCESS == res) {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s - %s",
               es-&gt;str, sz_error_text);
    } else {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
               es-&gt;str, ntstatus);
    }
  }
#else
  snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
           es-&gt;str, ntstatus);
#endif /* of NTCAN_ERROR_FORMAT_LONG */

  return std::string((const char *)(str_buf));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\can_client\esd\esd_can_client.cc" startLine="(173, 0)" endLine="(282, 1)" clone_start="25" clone_end="48">
			<code function_name="EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus)">std::string EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus) {
  struct ERR2STR {
    NTCAN_RESULT ntstatus;
    const char *str;
  };

  int8_t str_buf[ERROR_BUF_SIZE];

  static const struct ERR2STR err2str[] = {
      {NTCAN_SUCCESS, "NTCAN_SUCCESS"},
      {NTCAN_RX_TIMEOUT, "NTCAN_RX_TIMEOUT"},
      {NTCAN_TX_TIMEOUT, "NTCAN_TX_TIMEOUT"},
      {NTCAN_TX_ERROR, "NTCAN_TX_ERROR"},
      {NTCAN_CONTR_OFF_BUS, "NTCAN_CONTR_OFF_BUS"},
      {NTCAN_CONTR_BUSY, "NTCAN_CONTR_BUSY"},
      {NTCAN_CONTR_WARN, "NTCAN_CONTR_WARN"},
      {NTCAN_NO_ID_ENABLED, "NTCAN_NO_ID_ENABLED"},
      {NTCAN_ID_ALREADY_ENABLED, "NTCAN_ID_ALREADY_ENABLED"},
      {NTCAN_ID_NOT_ENABLED, "NTCAN_ID_NOT_ENABLED"},
      {NTCAN_INVALID_FIRMWARE, "NTCAN_INVALID_FIRMWARE"},
      {NTCAN_MESSAGE_LOST, "NTCAN_MESSAGE_LOST"},
      {NTCAN_INVALID_PARAMETER, "NTCAN_INVALID_PARAMETER"},
      {NTCAN_INVALID_HANDLE, "NTCAN_INVALID_HANDLE"},
      {NTCAN_NET_NOT_FOUND, "NTCAN_NET_NOT_FOUND"},
#ifdef NTCAN_IO_INCOMPLETE
      {NTCAN_IO_INCOMPLETE, "NTCAN_IO_INCOMPLETE"},
#endif
#ifdef NTCAN_IO_PENDING
      {NTCAN_IO_PENDING, "NTCAN_IO_PENDING"},
#endif
#ifdef NTCAN_INVALID_HARDWARE
      {NTCAN_INVALID_HARDWARE, "NTCAN_INVALID_HARDWARE"},
#endif
#ifdef NTCAN_PENDING_WRITE
      {NTCAN_PENDING_WRITE, "NTCAN_PENDING_WRITE"},
#endif
#ifdef NTCAN_PENDING_READ
      {NTCAN_PENDING_READ, "NTCAN_PENDING_READ"},
#endif
#ifdef NTCAN_INVALID_DRIVER
      {NTCAN_INVALID_DRIVER, "NTCAN_INVALID_DRIVER"},
#endif
#ifdef NTCAN_OPERATION_ABORTED
      {NTCAN_OPERATION_ABORTED, "NTCAN_OPERATION_ABORTED"},
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
      {NTCAN_WRONG_DEVICE_STATE, "NTCAN_WRONG_DEVICE_STATE"},
#endif
      {NTCAN_INSUFFICIENT_RESOURCES, "NTCAN_INSUFFICIENT_RESOURCES"},
#ifdef NTCAN_HANDLE_FORCED_CLOSE
      {NTCAN_HANDLE_FORCED_CLOSE, "NTCAN_HANDLE_FORCED_CLOSE"},
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
      {NTCAN_NOT_IMPLEMENTED, "NTCAN_NOT_IMPLEMENTED"},
#endif
#ifdef NTCAN_NOT_SUPPORTED
      {NTCAN_NOT_SUPPORTED, "NTCAN_NOT_SUPPORTED"},
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
      {NTCAN_SOCK_CONN_TIMEOUT, "NTCAN_SOCK_CONN_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
      {NTCAN_SOCK_CMD_TIMEOUT, "NTCAN_SOCK_CMD_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
      {NTCAN_SOCK_HOST_NOT_FOUND, "NTCAN_SOCK_HOST_NOT_FOUND"},
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
      {NTCAN_CONTR_ERR_PASSIVE, "NTCAN_CONTR_ERR_PASSIVE"},
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
      {NTCAN_ERROR_NO_BAUDRATE, "NTCAN_ERROR_NO_BAUDRATE"},
#endif
#ifdef NTCAN_ERROR_LOM
      {NTCAN_ERROR_LOM, "NTCAN_ERROR_LOM"},
#endif
      {(NTCAN_RESULT)0xffffffff, "NTCAN_UNKNOWN"} /* stop-mark */
  };

  const struct ERR2STR *es = err2str;

  do {
    if (es-&gt;ntstatus == ntstatus) {
      break;
    }
    es++;
  } while ((uint32_t)es-&gt;ntstatus != 0xffffffff);

#ifdef NTCAN_ERROR_FORMAT_LONG
  {
    NTCAN_RESULT res;
    char sz_error_text[60];

    res = canFormatError(ntstatus, NTCAN_ERROR_FORMAT_LONG, sz_error_text,
                         sizeof(sz_error_text) - 1);
    if (NTCAN_SUCCESS == res) {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s - %s",
               es-&gt;str, sz_error_text);
    } else {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
               es-&gt;str, ntstatus);
    }
  }
#else
  snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
           es-&gt;str, ntstatus);
#endif /* of NTCAN_ERROR_FORMAT_LONG */

  return std::string((const char *)(str_buf));
}</code>
		</source>
	</dup>
	<dup count="17">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(314, 0)" endLine="(318, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_left_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_rear_left_door_open(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(308, 0)" endLine="(312, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_door_open(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(302, 0)" endLine="(306, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_driver_door_open(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(297, 0)" endLine="(300, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(291, 0)" endLine="(295, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_lka_on_or_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_lka_on_or_off_pressed(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(285, 0)" endLine="(289, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t* bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(279, 0)" endLine="(283, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t* bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(273, 0)" endLine="(277, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(267, 0)" endLine="(271, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(261, 0)" endLine="(265, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t* bytes,
                                             int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(255, 0)" endLine="(259, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_or_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_on_or_off_pressed(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(249, 0)" endLine="(253, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_cancel_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_cancel_pressed(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(243, 0)" endLine="(247, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_resume_pressed(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(237, 0)" endLine="(241, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_off_pressed(const std::uint8_t* bytes,
                                int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(231, 0)" endLine="(235, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_on_pressed(const std::uint8_t* bytes,
                               int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(127, 0)" endLine="(130, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake61::is_enabled(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_enabled(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(121, 0)" endLine="(124, 1)" clone_start="1" clone_end="4">
			<code function_name="Steering65::is_enabled(const std::uint8_t* bytes, int32_t length) const">bool Steering65::is_enabled(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(0);
}</code>
		</source>
	</dup>
	<dup count="17">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(320, 0)" endLine="(324, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_right_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_rear_right_door_open(const std::uint8_t* bytes,
                                     int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(314, 0)" endLine="(318, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_left_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_rear_left_door_open(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(308, 0)" endLine="(312, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_door_open(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(302, 0)" endLine="(306, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_driver_door_open(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(297, 0)" endLine="(300, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(291, 0)" endLine="(295, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_lka_on_or_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_lka_on_or_off_pressed(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(285, 0)" endLine="(289, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t* bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(279, 0)" endLine="(283, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t* bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(273, 0)" endLine="(277, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(267, 0)" endLine="(271, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(261, 0)" endLine="(265, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t* bytes,
                                             int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(255, 0)" endLine="(259, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_or_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_on_or_off_pressed(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(249, 0)" endLine="(253, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_cancel_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_cancel_pressed(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(243, 0)" endLine="(247, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_resume_pressed(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(237, 0)" endLine="(241, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_off_pressed(const std::uint8_t* bytes,
                                int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(132, 0)" endLine="(136, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_driver_override(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_driver_override(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(126, 0)" endLine="(131, 1)" clone_start="1" clone_end="6">
			<code function_name="Steering65::is_driver_override(const std::uint8_t* bytes, int32_t length) const">bool Steering65::is_driver_override(const std::uint8_t* bytes,
                                    int32_t length) const {
  // Cleared on rising edge of EN bit in command message
  Byte frame(bytes + 7);
  return frame.is_bit_1(1);
}</code>
		</source>
	</dup>
	<dup count="17">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(326, 0)" endLine="(329, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_hood_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_hood_open(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(320, 0)" endLine="(324, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_right_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_rear_right_door_open(const std::uint8_t* bytes,
                                     int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(314, 0)" endLine="(318, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_left_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_rear_left_door_open(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(308, 0)" endLine="(312, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_door_open(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(302, 0)" endLine="(306, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_driver_door_open(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(297, 0)" endLine="(300, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(291, 0)" endLine="(295, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_lka_on_or_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_lka_on_or_off_pressed(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(285, 0)" endLine="(289, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t* bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(279, 0)" endLine="(283, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t* bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(273, 0)" endLine="(277, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(267, 0)" endLine="(271, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(261, 0)" endLine="(265, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t* bytes,
                                             int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(255, 0)" endLine="(259, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_or_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_on_or_off_pressed(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(249, 0)" endLine="(253, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_cancel_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_cancel_pressed(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(243, 0)" endLine="(247, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_resume_pressed(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(138, 0)" endLine="(142, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_driver_activity(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_driver_activity(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(133, 0)" endLine="(137, 1)" clone_start="1" clone_end="5">
			<code function_name="Steering65::is_driver_activity(const std::uint8_t* bytes, int32_t length) const">bool Steering65::is_driver_activity(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(2);
}</code>
		</source>
	</dup>
	<dup count="17">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(331, 0)" endLine="(334, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_trunk_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_trunk_open(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(326, 0)" endLine="(329, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_hood_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_hood_open(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(320, 0)" endLine="(324, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_right_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_rear_right_door_open(const std::uint8_t* bytes,
                                     int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(314, 0)" endLine="(318, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_left_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_rear_left_door_open(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(308, 0)" endLine="(312, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_door_open(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(302, 0)" endLine="(306, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_driver_door_open(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(297, 0)" endLine="(300, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(291, 0)" endLine="(295, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_lka_on_or_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_lka_on_or_off_pressed(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(285, 0)" endLine="(289, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t* bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(279, 0)" endLine="(283, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t* bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(273, 0)" endLine="(277, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(267, 0)" endLine="(271, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(261, 0)" endLine="(265, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t* bytes,
                                             int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(255, 0)" endLine="(259, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_or_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_on_or_off_pressed(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(249, 0)" endLine="(253, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_cancel_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_cancel_pressed(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(144, 0)" endLine="(148, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_watchdog_counter_fault(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_watchdog_counter_fault(const std::uint8_t* bytes,
                                        int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(139, 0)" endLine="(143, 1)" clone_start="1" clone_end="5">
			<code function_name="Steering65::is_watchdog_counter_fault(const std::uint8_t* bytes, int32_t length) const">bool Steering65::is_watchdog_counter_fault(const std::uint8_t* bytes,
                                           int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="17">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(336, 0)" endLine="(340, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_detected(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_detected(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(331, 0)" endLine="(334, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_trunk_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_trunk_open(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(326, 0)" endLine="(329, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_hood_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_hood_open(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(320, 0)" endLine="(324, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_right_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_rear_right_door_open(const std::uint8_t* bytes,
                                     int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(314, 0)" endLine="(318, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_left_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_rear_left_door_open(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(308, 0)" endLine="(312, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_door_open(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(302, 0)" endLine="(306, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_driver_door_open(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(297, 0)" endLine="(300, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(291, 0)" endLine="(295, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_lka_on_or_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_lka_on_or_off_pressed(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(285, 0)" endLine="(289, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t* bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(279, 0)" endLine="(283, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t* bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(273, 0)" endLine="(277, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(267, 0)" endLine="(271, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(261, 0)" endLine="(265, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t* bytes,
                                             int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(255, 0)" endLine="(259, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_or_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_on_or_off_pressed(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(150, 0)" endLine="(154, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_channel_1_fault(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_channel_1_fault(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(145, 0)" endLine="(149, 1)" clone_start="1" clone_end="5">
			<code function_name="Steering65::is_channel_1_fault(const std::uint8_t* bytes, int32_t length) const">bool Steering65::is_channel_1_fault(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(4);
}</code>
		</source>
	</dup>
	<dup count="17">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(342, 0)" endLine="(346, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_airbag_enabled(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_airbag_enabled(const std::uint8_t* bytes,
                                         int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(336, 0)" endLine="(340, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_detected(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_detected(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(331, 0)" endLine="(334, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_trunk_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_trunk_open(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(326, 0)" endLine="(329, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_hood_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_hood_open(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(320, 0)" endLine="(324, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_right_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_rear_right_door_open(const std::uint8_t* bytes,
                                     int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(314, 0)" endLine="(318, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_left_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_rear_left_door_open(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(308, 0)" endLine="(312, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_door_open(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(302, 0)" endLine="(306, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_driver_door_open(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(297, 0)" endLine="(300, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(291, 0)" endLine="(295, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_lka_on_or_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_lka_on_or_off_pressed(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(285, 0)" endLine="(289, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t* bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(279, 0)" endLine="(283, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t* bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(273, 0)" endLine="(277, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(267, 0)" endLine="(271, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(261, 0)" endLine="(265, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t* bytes,
                                             int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(156, 0)" endLine="(160, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_channel_2_fault(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_channel_2_fault(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(151, 0)" endLine="(155, 1)" clone_start="1" clone_end="5">
			<code function_name="Steering65::is_channel_2_fault(const std::uint8_t* bytes, int32_t length) const">bool Steering65::is_channel_2_fault(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(5);
}</code>
		</source>
	</dup>
	<dup count="17">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(348, 0)" endLine="(352, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_belt_buckled(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_driver_belt_buckled(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 4);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(342, 0)" endLine="(346, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_airbag_enabled(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_airbag_enabled(const std::uint8_t* bytes,
                                         int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(336, 0)" endLine="(340, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_detected(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_detected(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(331, 0)" endLine="(334, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_trunk_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_trunk_open(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(326, 0)" endLine="(329, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_hood_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_hood_open(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(320, 0)" endLine="(324, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_right_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_rear_right_door_open(const std::uint8_t* bytes,
                                     int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(314, 0)" endLine="(318, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_left_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_rear_left_door_open(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(308, 0)" endLine="(312, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_door_open(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(302, 0)" endLine="(306, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_driver_door_open(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(297, 0)" endLine="(300, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(291, 0)" endLine="(295, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_lka_on_or_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_lka_on_or_off_pressed(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(285, 0)" endLine="(289, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t* bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(279, 0)" endLine="(283, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t* bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(273, 0)" endLine="(277, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(267, 0)" endLine="(271, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(162, 0)" endLine="(166, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_boo_switch_fault(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_boo_switch_fault(const std::uint8_t* bytes,
                                  int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(157, 0)" endLine="(161, 1)" clone_start="1" clone_end="5">
			<code function_name="Steering65::is_calibration_fault(const std::uint8_t* bytes, int32_t length) const">bool Steering65::is_calibration_fault(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(6);
}</code>
		</source>
	</dup>
	<dup count="17">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(354, 0)" endLine="(358, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_passenger_belt_buckled(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_belt_buckled(const std::uint8_t* bytes,
                                       int32_t length) const {
  Byte frame(bytes + 4);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(348, 0)" endLine="(352, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_driver_belt_buckled(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_driver_belt_buckled(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 4);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(342, 0)" endLine="(346, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_passenger_airbag_enabled(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_airbag_enabled(const std::uint8_t* bytes,
                                         int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(336, 0)" endLine="(340, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_passenger_detected(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_detected(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(331, 0)" endLine="(334, 1)" clone_start="1" clone_end="3">
			<code function_name="Misc69::is_trunk_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_trunk_open(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(326, 0)" endLine="(329, 1)" clone_start="1" clone_end="3">
			<code function_name="Misc69::is_hood_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_hood_open(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(320, 0)" endLine="(324, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_rear_right_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_rear_right_door_open(const std::uint8_t* bytes,
                                     int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(314, 0)" endLine="(318, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_rear_left_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_rear_left_door_open(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(308, 0)" endLine="(312, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_passenger_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_door_open(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(302, 0)" endLine="(306, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_driver_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_driver_door_open(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(297, 0)" endLine="(300, 1)" clone_start="1" clone_end="3">
			<code function_name="Misc69::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(291, 0)" endLine="(295, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_lka_on_or_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_lka_on_or_off_pressed(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(285, 0)" endLine="(289, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t* bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(279, 0)" endLine="(283, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t* bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(273, 0)" endLine="(277, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(168, 0)" endLine="(172, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake61::is_connector_fault(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_connector_fault(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(163, 0)" endLine="(167, 1)" clone_start="1" clone_end="4">
			<code function_name="Steering65::is_connector_fault(const std::uint8_t* bytes, int32_t length) const">bool Steering65::is_connector_fault(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(7);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\can_client\esd\esd_can_client.cc" startLine="(173, 0)" endLine="(282, 1)" clone_start="24" clone_end="48">
			<code function_name="EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus)">std::string EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus) {
  struct ERR2STR {
    NTCAN_RESULT ntstatus;
    const char *str;
  };

  int8_t str_buf[ERROR_BUF_SIZE];

  static const struct ERR2STR err2str[] = {
      {NTCAN_SUCCESS, "NTCAN_SUCCESS"},
      {NTCAN_RX_TIMEOUT, "NTCAN_RX_TIMEOUT"},
      {NTCAN_TX_TIMEOUT, "NTCAN_TX_TIMEOUT"},
      {NTCAN_TX_ERROR, "NTCAN_TX_ERROR"},
      {NTCAN_CONTR_OFF_BUS, "NTCAN_CONTR_OFF_BUS"},
      {NTCAN_CONTR_BUSY, "NTCAN_CONTR_BUSY"},
      {NTCAN_CONTR_WARN, "NTCAN_CONTR_WARN"},
      {NTCAN_NO_ID_ENABLED, "NTCAN_NO_ID_ENABLED"},
      {NTCAN_ID_ALREADY_ENABLED, "NTCAN_ID_ALREADY_ENABLED"},
      {NTCAN_ID_NOT_ENABLED, "NTCAN_ID_NOT_ENABLED"},
      {NTCAN_INVALID_FIRMWARE, "NTCAN_INVALID_FIRMWARE"},
      {NTCAN_MESSAGE_LOST, "NTCAN_MESSAGE_LOST"},
      {NTCAN_INVALID_PARAMETER, "NTCAN_INVALID_PARAMETER"},
      {NTCAN_INVALID_HANDLE, "NTCAN_INVALID_HANDLE"},
      {NTCAN_NET_NOT_FOUND, "NTCAN_NET_NOT_FOUND"},
#ifdef NTCAN_IO_INCOMPLETE
      {NTCAN_IO_INCOMPLETE, "NTCAN_IO_INCOMPLETE"},
#endif
#ifdef NTCAN_IO_PENDING
      {NTCAN_IO_PENDING, "NTCAN_IO_PENDING"},
#endif
#ifdef NTCAN_INVALID_HARDWARE
      {NTCAN_INVALID_HARDWARE, "NTCAN_INVALID_HARDWARE"},
#endif
#ifdef NTCAN_PENDING_WRITE
      {NTCAN_PENDING_WRITE, "NTCAN_PENDING_WRITE"},
#endif
#ifdef NTCAN_PENDING_READ
      {NTCAN_PENDING_READ, "NTCAN_PENDING_READ"},
#endif
#ifdef NTCAN_INVALID_DRIVER
      {NTCAN_INVALID_DRIVER, "NTCAN_INVALID_DRIVER"},
#endif
#ifdef NTCAN_OPERATION_ABORTED
      {NTCAN_OPERATION_ABORTED, "NTCAN_OPERATION_ABORTED"},
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
      {NTCAN_WRONG_DEVICE_STATE, "NTCAN_WRONG_DEVICE_STATE"},
#endif
      {NTCAN_INSUFFICIENT_RESOURCES, "NTCAN_INSUFFICIENT_RESOURCES"},
#ifdef NTCAN_HANDLE_FORCED_CLOSE
      {NTCAN_HANDLE_FORCED_CLOSE, "NTCAN_HANDLE_FORCED_CLOSE"},
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
      {NTCAN_NOT_IMPLEMENTED, "NTCAN_NOT_IMPLEMENTED"},
#endif
#ifdef NTCAN_NOT_SUPPORTED
      {NTCAN_NOT_SUPPORTED, "NTCAN_NOT_SUPPORTED"},
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
      {NTCAN_SOCK_CONN_TIMEOUT, "NTCAN_SOCK_CONN_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
      {NTCAN_SOCK_CMD_TIMEOUT, "NTCAN_SOCK_CMD_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
      {NTCAN_SOCK_HOST_NOT_FOUND, "NTCAN_SOCK_HOST_NOT_FOUND"},
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
      {NTCAN_CONTR_ERR_PASSIVE, "NTCAN_CONTR_ERR_PASSIVE"},
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
      {NTCAN_ERROR_NO_BAUDRATE, "NTCAN_ERROR_NO_BAUDRATE"},
#endif
#ifdef NTCAN_ERROR_LOM
      {NTCAN_ERROR_LOM, "NTCAN_ERROR_LOM"},
#endif
      {(NTCAN_RESULT)0xffffffff, "NTCAN_UNKNOWN"} /* stop-mark */
  };

  const struct ERR2STR *es = err2str;

  do {
    if (es-&gt;ntstatus == ntstatus) {
      break;
    }
    es++;
  } while ((uint32_t)es-&gt;ntstatus != 0xffffffff);

#ifdef NTCAN_ERROR_FORMAT_LONG
  {
    NTCAN_RESULT res;
    char sz_error_text[60];

    res = canFormatError(ntstatus, NTCAN_ERROR_FORMAT_LONG, sz_error_text,
                         sizeof(sz_error_text) - 1);
    if (NTCAN_SUCCESS == res) {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s - %s",
               es-&gt;str, sz_error_text);
    } else {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
               es-&gt;str, ntstatus);
    }
  }
#else
  snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
           es-&gt;str, ntstatus);
#endif /* of NTCAN_ERROR_FORMAT_LONG */

  return std::string((const char *)(str_buf));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\can_client\esd\esd_can_client.cc" startLine="(173, 0)" endLine="(282, 1)" clone_start="49" clone_end="73">
			<code function_name="EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus)">std::string EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus) {
  struct ERR2STR {
    NTCAN_RESULT ntstatus;
    const char *str;
  };

  int8_t str_buf[ERROR_BUF_SIZE];

  static const struct ERR2STR err2str[] = {
      {NTCAN_SUCCESS, "NTCAN_SUCCESS"},
      {NTCAN_RX_TIMEOUT, "NTCAN_RX_TIMEOUT"},
      {NTCAN_TX_TIMEOUT, "NTCAN_TX_TIMEOUT"},
      {NTCAN_TX_ERROR, "NTCAN_TX_ERROR"},
      {NTCAN_CONTR_OFF_BUS, "NTCAN_CONTR_OFF_BUS"},
      {NTCAN_CONTR_BUSY, "NTCAN_CONTR_BUSY"},
      {NTCAN_CONTR_WARN, "NTCAN_CONTR_WARN"},
      {NTCAN_NO_ID_ENABLED, "NTCAN_NO_ID_ENABLED"},
      {NTCAN_ID_ALREADY_ENABLED, "NTCAN_ID_ALREADY_ENABLED"},
      {NTCAN_ID_NOT_ENABLED, "NTCAN_ID_NOT_ENABLED"},
      {NTCAN_INVALID_FIRMWARE, "NTCAN_INVALID_FIRMWARE"},
      {NTCAN_MESSAGE_LOST, "NTCAN_MESSAGE_LOST"},
      {NTCAN_INVALID_PARAMETER, "NTCAN_INVALID_PARAMETER"},
      {NTCAN_INVALID_HANDLE, "NTCAN_INVALID_HANDLE"},
      {NTCAN_NET_NOT_FOUND, "NTCAN_NET_NOT_FOUND"},
#ifdef NTCAN_IO_INCOMPLETE
      {NTCAN_IO_INCOMPLETE, "NTCAN_IO_INCOMPLETE"},
#endif
#ifdef NTCAN_IO_PENDING
      {NTCAN_IO_PENDING, "NTCAN_IO_PENDING"},
#endif
#ifdef NTCAN_INVALID_HARDWARE
      {NTCAN_INVALID_HARDWARE, "NTCAN_INVALID_HARDWARE"},
#endif
#ifdef NTCAN_PENDING_WRITE
      {NTCAN_PENDING_WRITE, "NTCAN_PENDING_WRITE"},
#endif
#ifdef NTCAN_PENDING_READ
      {NTCAN_PENDING_READ, "NTCAN_PENDING_READ"},
#endif
#ifdef NTCAN_INVALID_DRIVER
      {NTCAN_INVALID_DRIVER, "NTCAN_INVALID_DRIVER"},
#endif
#ifdef NTCAN_OPERATION_ABORTED
      {NTCAN_OPERATION_ABORTED, "NTCAN_OPERATION_ABORTED"},
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
      {NTCAN_WRONG_DEVICE_STATE, "NTCAN_WRONG_DEVICE_STATE"},
#endif
      {NTCAN_INSUFFICIENT_RESOURCES, "NTCAN_INSUFFICIENT_RESOURCES"},
#ifdef NTCAN_HANDLE_FORCED_CLOSE
      {NTCAN_HANDLE_FORCED_CLOSE, "NTCAN_HANDLE_FORCED_CLOSE"},
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
      {NTCAN_NOT_IMPLEMENTED, "NTCAN_NOT_IMPLEMENTED"},
#endif
#ifdef NTCAN_NOT_SUPPORTED
      {NTCAN_NOT_SUPPORTED, "NTCAN_NOT_SUPPORTED"},
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
      {NTCAN_SOCK_CONN_TIMEOUT, "NTCAN_SOCK_CONN_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
      {NTCAN_SOCK_CMD_TIMEOUT, "NTCAN_SOCK_CMD_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
      {NTCAN_SOCK_HOST_NOT_FOUND, "NTCAN_SOCK_HOST_NOT_FOUND"},
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
      {NTCAN_CONTR_ERR_PASSIVE, "NTCAN_CONTR_ERR_PASSIVE"},
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
      {NTCAN_ERROR_NO_BAUDRATE, "NTCAN_ERROR_NO_BAUDRATE"},
#endif
#ifdef NTCAN_ERROR_LOM
      {NTCAN_ERROR_LOM, "NTCAN_ERROR_LOM"},
#endif
      {(NTCAN_RESULT)0xffffffff, "NTCAN_UNKNOWN"} /* stop-mark */
  };

  const struct ERR2STR *es = err2str;

  do {
    if (es-&gt;ntstatus == ntstatus) {
      break;
    }
    es++;
  } while ((uint32_t)es-&gt;ntstatus != 0xffffffff);

#ifdef NTCAN_ERROR_FORMAT_LONG
  {
    NTCAN_RESULT res;
    char sz_error_text[60];

    res = canFormatError(ntstatus, NTCAN_ERROR_FORMAT_LONG, sz_error_text,
                         sizeof(sz_error_text) - 1);
    if (NTCAN_SUCCESS == res) {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s - %s",
               es-&gt;str, sz_error_text);
    } else {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
               es-&gt;str, ntstatus);
    }
  }
#else
  snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
           es-&gt;str, ntstatus);
#endif /* of NTCAN_ERROR_FORMAT_LONG */

  return std::string((const char *)(str_buf));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\localization\camera\camera_localization.cc" startLine="(195, 0)" endLine="(243, 1)" clone_start="11" clone_end="47">
			<code function_name="CameraLocalization::RunWatchDog()">void CameraLocalization::RunWatchDog() {
  if (!FLAGS_enable_watchdog) {
    return;
  }

  bool msg_lost = false;

  MonitorBuffer buffer(&amp;monitor_);

  // check GPS time stamp against ROS timer
  double gps_delay_sec =
      apollo::common::time::ToSecond(Clock::Now()) -
      AdapterManager::GetGps()-&gt;GetLatestObserved().header().timestamp_sec();
  int64_t gps_delay_cycle_cnt =
      static_cast&lt;int64_t&gt;(gps_delay_sec * FLAGS_localization_publish_freq);
  if (FLAGS_enable_gps_timestamp &amp;&amp;
      (gps_delay_cycle_cnt &gt; FLAGS_report_threshold_err_num)) {
    msg_lost = true;

    buffer.ERROR() &lt;&lt; "Raw GPS Message Lost. GPS message is "
                   &lt;&lt; gps_delay_cycle_cnt &lt;&lt; " cycle " &lt;&lt; gps_delay_sec
                   &lt;&lt; " sec behind current time.";
    buffer.PrintLog();
  }

  // check Camera time stamp against ROS timer
  double camera_delay_sec =
      apollo::common::time::ToSecond(Clock::Now()) -
      AdapterManager::GetCamera()-&gt;GetLatestObserved().header().timestamp_sec();
  int64_t camera_delay_cycle_cnt =
      static_cast&lt;int64_t&gt;(camera_delay_sec * FLAGS_localization_publish_freq);
  if (FLAGS_enable_gps_timestamp &amp;&amp;
      camera_delay_cycle_cnt &gt; FLAGS_report_threshold_err_num) {
    msg_lost = true;

    buffer.ERROR() &lt;&lt; "Raw Camera Message Lost. IMU message is "
                   &lt;&lt; camera_delay_cycle_cnt &lt;&lt; " cycle " &lt;&lt; camera_delay_sec
                   &lt;&lt; " sec behind current time.";
    buffer.PrintLog();
  }

  // to prevent it from beeping continuously
  if (msg_lost &amp;&amp; (last_reported_timestamp_sec_ &lt; 1. ||
                   apollo::common::time::ToSecond(Clock::Now()) &gt;
                       last_reported_timestamp_sec_ + 1.)) {
    AERROR &lt;&lt; "gps/camera frame lost!";
    last_reported_timestamp_sec_ = apollo::common::time::ToSecond(Clock::Now());
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\localization\rtk\rtk_localization.cc" startLine="(363, 0)" endLine="(411, 1)" clone_start="11" clone_end="47">
			<code function_name="RTKLocalization::RunWatchDog()">void RTKLocalization::RunWatchDog() {
  if (!FLAGS_enable_watchdog) {
    return;
  }

  bool msg_lost = false;

  apollo::common::monitor::MonitorBuffer buffer(&amp;monitor_);

  // check GPS time stamp against ROS timer
  double gps_delay_sec =
      apollo::common::time::ToSecond(Clock::Now()) -
      AdapterManager::GetGps()-&gt;GetLatestObserved().header().timestamp_sec();
  int64_t gps_delay_cycle_cnt =
      static_cast&lt;int64_t&gt;(gps_delay_sec * FLAGS_localization_publish_freq);
  if (FLAGS_enable_gps_timestamp &amp;&amp;
      (gps_delay_cycle_cnt &gt; FLAGS_report_threshold_err_num)) {
    msg_lost = true;

    buffer.ERROR() &lt;&lt; "Raw GPS Message Lost. GPS message is "
                   &lt;&lt; gps_delay_cycle_cnt &lt;&lt; " cycle " &lt;&lt; gps_delay_sec
                   &lt;&lt; " sec behind current time.";
    buffer.PrintLog();
  }

  // check IMU time stamp against ROS timer
  double imu_delay_sec =
      apollo::common::time::ToSecond(Clock::Now()) -
      AdapterManager::GetImu()-&gt;GetLatestObserved().header().timestamp_sec();
  int64_t imu_delay_cycle_cnt =
      static_cast&lt;int64_t&gt;(imu_delay_sec * FLAGS_localization_publish_freq);
  if (FLAGS_enable_gps_timestamp &amp;&amp;
      imu_delay_cycle_cnt &gt; FLAGS_report_threshold_err_num) {
    msg_lost = true;

    buffer.ERROR() &lt;&lt; "Raw GPS Message Lost. IMU message is "
                   &lt;&lt; imu_delay_cycle_cnt &lt;&lt; " cycle " &lt;&lt; imu_delay_sec
                   &lt;&lt; " sec behind current time.";
    buffer.PrintLog();
  }

  // to prevent it from beeping continuously
  if (msg_lost &amp;&amp; (last_reported_timestamp_sec_ &lt; 1. ||
                   apollo::common::time::ToSecond(Clock::Now()) &gt;
                       last_reported_timestamp_sec_ + 1.)) {
    AERROR &lt;&lt; "gps/imu frame lost!";
    last_reported_timestamp_sec_ = apollo::common::time::ToSecond(Clock::Now());
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(77, 0)" endLine="(89, 1)" clone_start="12" clone_end="13">
			<code function_name="Throttle63::pedal_output(const std::uint8_t* bytes, int32_t length) const">double Throttle63::pedal_output(const std::uint8_t* bytes,
                                int32_t length) const {
  // Pedal Output is the maximum of PI and PC
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(218, 0)" endLine="(222, 1)" clone_start="4" clone_end="5">
			<code function_name="Misc69::wiper_status(const std::uint8_t* bytes, int32_t length) const">int32_t Misc69::wiper_status(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(91, 0)" endLine="(96, 1)" clone_start="1" clone_end="6">
			<code function_name="Throttle63::watchdog_counter_source(const std::uint8_t* bytes, int32_t length) const">int32_t Throttle63::watchdog_counter_source(const std::uint8_t* bytes,
                                            int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(224, 0)" endLine="(229, 1)" clone_start="1" clone_end="6">
			<code function_name="Misc69::ambient_light_status(const std::uint8_t* bytes, int32_t length) const">int32_t Misc69::ambient_light_status(const std::uint8_t* bytes,
                                     int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(98, 0)" endLine="(101, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle63::is_enabled(const std::uint8_t* bytes, int32_t length) const">bool Throttle63::is_enabled(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(231, 0)" endLine="(235, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_on_pressed(const std::uint8_t* bytes,
                               int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(103, 0)" endLine="(107, 1)" clone_start="1" clone_end="5">
			<code function_name="Throttle63::is_driver_override(const std::uint8_t* bytes, int32_t length) const">bool Throttle63::is_driver_override(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(237, 0)" endLine="(241, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_off_pressed(const std::uint8_t* bytes,
                                int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(4);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(109, 0)" endLine="(113, 1)" clone_start="1" clone_end="5">
			<code function_name="Throttle63::is_driver_activity(const std::uint8_t* bytes, int32_t length) const">bool Throttle63::is_driver_activity(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(243, 0)" endLine="(247, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_resume_pressed(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(5);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(115, 0)" endLine="(119, 1)" clone_start="1" clone_end="5">
			<code function_name="Throttle63::is_watchdog_counter_fault(const std::uint8_t* bytes, int32_t length) const">bool Throttle63::is_watchdog_counter_fault(const std::uint8_t* bytes,
                                           int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(249, 0)" endLine="(253, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_cancel_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_cancel_pressed(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(6);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(121, 0)" endLine="(125, 1)" clone_start="1" clone_end="5">
			<code function_name="Throttle63::is_channel_1_fault(const std::uint8_t* bytes, int32_t length) const">bool Throttle63::is_channel_1_fault(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(255, 0)" endLine="(259, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_or_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_on_or_off_pressed(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(0);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(127, 0)" endLine="(131, 1)" clone_start="1" clone_end="5">
			<code function_name="Throttle63::is_channel_2_fault(const std::uint8_t* bytes, int32_t length) const">bool Throttle63::is_channel_2_fault(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(261, 0)" endLine="(265, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t* bytes,
                                             int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(1);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(133, 0)" endLine="(137, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle63::is_connector_fault(const std::uint8_t* bytes, int32_t length) const">bool Throttle63::is_connector_fault(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(267, 0)" endLine="(271, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(26, 0)" endLine="(40, 1)" clone_start="4" clone_end="15">
			<code function_name="Gps6e::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Gps6e::Parse(const std::uint8_t* bytes, int32_t length,
                  ChassisDetail* car_status) const {
  car_status-&gt;mutable_basic()-&gt;set_year(year(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_month(month(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_day(day(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_hours(hours(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_minutes(minutes(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_seconds(seconds(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_compass_direction(
      compass_direction(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_pdop(pdop(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_is_gps_fault(is_gps_fault(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_is_inferred(
      is_inferred_position(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="151" clone_end="177">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(42, 0)" endLine="(46, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::year(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::year(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 7);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(204, 0)" endLine="(209, 1)" clone_start="1" clone_end="6">
			<code function_name="Misc69::turn_signal_status(const std::uint8_t* bytes, int32_t length) const">int32_t Misc69::turn_signal_status(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 2);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(48, 0)" endLine="(52, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::month(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::month(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(211, 0)" endLine="(216, 1)" clone_start="1" clone_end="6">
			<code function_name="Misc69::high_beam_status(const std::uint8_t* bytes, int32_t length) const">int32_t Misc69::high_beam_status(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(2, 2);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(54, 0)" endLine="(58, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::day(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::day(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 2);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(218, 0)" endLine="(222, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::wiper_status(const std::uint8_t* bytes, int32_t length) const">int32_t Misc69::wiper_status(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(60, 0)" endLine="(64, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::hours(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::hours(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(224, 0)" endLine="(229, 1)" clone_start="1" clone_end="6">
			<code function_name="Misc69::ambient_light_status(const std::uint8_t* bytes, int32_t length) const">int32_t Misc69::ambient_light_status(const std::uint8_t* bytes,
                                     int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(66, 0)" endLine="(70, 1)" clone_start="1" clone_end="2">
			<code function_name="Gps6e::minutes(const std::uint8_t* bytes, int32_t length) const">int32_t Gps6e::minutes(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(231, 0)" endLine="(235, 1)" clone_start="1" clone_end="3">
			<code function_name="Misc69::is_acc_on_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_on_pressed(const std::uint8_t* bytes,
                               int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(76, 0)" endLine="(94, 1)" clone_start="10" clone_end="19">
			<code function_name="Steering64::set_steering_angle_p(uint8_t* data, double angle)">void Steering64::set_steering_angle_p(uint8_t* data, double angle) {
  angle = ProtocolData::BoundedValue(-470.0, 470.0, angle);
  int32_t x = angle / 0.100000;

  // add offset
  if (x &lt; 0) {
    x += 0x10000;
  }

  std::uint8_t t = 0;
  t = x &amp; 0xFF;  // low
  Byte frame_low(data + 0);
  frame_low.set_value(t, 0, 8);

  x &gt;&gt;= 8;  // high
  t = x &amp; 0xFF;
  Byte frame_high(data + 1);
  frame_high.set_value(t, 0, 8);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(66, 0)" endLine="(82, 1)" clone_start="7" clone_end="17">
			<code function_name="Throttle62::set_pedal_p(uint8_t* data, double pedal)">void Throttle62::set_pedal_p(uint8_t* data, double pedal) {
  // change from [0-100] to [0.00-1.00]
  // and a rough mapping
  pedal /= 100.0;
  pedal = ProtocolData::BoundedValue(0.0, 1.0, pedal);
  int32_t x = pedal / 1.52590218966964e-05;
  std::uint8_t t = 0;

  t = x &amp; 0xFF;
  Byte frame_low(data + 0);
  frame_low.set_value(t, 0, 8);

  x &gt;&gt;= 8;
  t = x &amp; 0xFF;
  Byte frame_high(data + 1);
  frame_high.set_value(t, 0, 8);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(79, 0)" endLine="(95, 1)" clone_start="7" clone_end="17">
			<code function_name="Brake60::set_pedal_p(uint8_t* data, double pedal)">void Brake60::set_pedal_p(uint8_t* data, double pedal) {
  // change from [0-100] to [0.00-1.00]
  // and a rough mapping
  pedal /= 100.;
  pedal = ProtocolData::BoundedValue(0.0, 1.0, pedal);
  int32_t x = pedal / 1.52590218966964e-05;
  std::uint8_t t = 0;

  t = x &amp; 0xFF;
  Byte frame_low(data + 0);
  frame_low.set_value(t, 0, 8);

  x &gt;&gt;= 8;
  t = x &amp; 0xFF;
  Byte frame_high(data + 1);
  frame_high.set_value(t, 0, 8);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(96, 0)" endLine="(103, 1)" clone_start="1" clone_end="8">
			<code function_name="Steering64::set_enable_p(uint8_t* bytes, bool enable)">void Steering64::set_enable_p(uint8_t* bytes, bool enable) {
  Byte frame(bytes + 2);
  if (enable) {
    frame.set_bit_1(0);
  } else {
    frame.set_bit_0(0);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(84, 0)" endLine="(91, 1)" clone_start="1" clone_end="8">
			<code function_name="Throttle62::set_enable_p(uint8_t* bytes, bool enable)">void Throttle62::set_enable_p(uint8_t* bytes, bool enable) {
  Byte frame(bytes + 3);
  if (enable) {
    frame.set_bit_1(0);
  } else {
    frame.set_bit_0(0);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(97, 0)" endLine="(104, 1)" clone_start="1" clone_end="8">
			<code function_name="Brake60::set_boo_cmd_p(uint8_t* bytes, bool boo_cmd)">void Brake60::set_boo_cmd_p(uint8_t* bytes, bool boo_cmd) {
  Byte frame(bytes + 2);
  if (boo_cmd) {
    frame.set_bit_1(0);
  } else {
    frame.set_bit_0(0);
  }
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(105, 0)" endLine="(112, 1)" clone_start="1" clone_end="8">
			<code function_name="Steering64::set_clear_driver_override_flag_p(uint8_t* bytes, bool clear)">void Steering64::set_clear_driver_override_flag_p(uint8_t* bytes, bool clear) {
  Byte frame(bytes + 2);
  if (clear) {
    frame.set_bit_1(1);
  } else {
    frame.set_bit_0(1);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(93, 0)" endLine="(100, 1)" clone_start="1" clone_end="8">
			<code function_name="Throttle62::set_clear_driver_override_flag_p(uint8_t* bytes, bool clear)">void Throttle62::set_clear_driver_override_flag_p(uint8_t* bytes, bool clear) {
  Byte frame(bytes + 3);
  if (clear) {
    frame.set_bit_1(1);
  } else {
    frame.set_bit_0(1);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(106, 0)" endLine="(113, 1)" clone_start="1" clone_end="8">
			<code function_name="Brake60::set_enable_p(uint8_t* bytes, bool enable)">void Brake60::set_enable_p(uint8_t* bytes, bool enable) {
  Byte frame(bytes + 3);
  if (enable) {
    frame.set_bit_1(0);
  } else {
    frame.set_bit_0(0);
  }
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(114, 0)" endLine="(121, 1)" clone_start="1" clone_end="8">
			<code function_name="Steering64::set_ignore_driver_override_p(uint8_t* bytes, bool ignore)">void Steering64::set_ignore_driver_override_p(uint8_t* bytes, bool ignore) {
  Byte frame(bytes + 2);
  if (ignore) {
    frame.set_bit_1(2);
  } else {
    frame.set_bit_0(2);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(102, 0)" endLine="(109, 1)" clone_start="1" clone_end="8">
			<code function_name="Throttle62::set_ignore_driver_override_p(uint8_t* bytes, bool ignore)">void Throttle62::set_ignore_driver_override_p(uint8_t* bytes, bool ignore) {
  Byte frame(bytes + 3);
  if (ignore) {
    frame.set_bit_1(2);
  } else {
    frame.set_bit_0(2);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(115, 0)" endLine="(122, 1)" clone_start="1" clone_end="8">
			<code function_name="Brake60::set_clear_driver_override_flag_p(uint8_t* bytes, bool clear)">void Brake60::set_clear_driver_override_flag_p(uint8_t* bytes, bool clear) {
  Byte frame(bytes + 3);
  if (clear) {
    frame.set_bit_1(1);
  } else {
    frame.set_bit_0(1);
  }
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(123, 0)" endLine="(129, 1)" clone_start="1" clone_end="2">
			<code function_name="Steering64::set_steering_angle_speed_p(uint8_t* data, double angle_speed)">void Steering64::set_steering_angle_speed_p(uint8_t* data, double angle_speed) {
  angle_speed = ProtocolData::BoundedValue(0.0, 500.0, angle_speed);
  int32_t x = angle_speed / 2.000000;

  Byte frame(data + 3);
  frame.set_value(x, 0, 8);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(111, 0)" endLine="(115, 1)" clone_start="1" clone_end="2">
			<code function_name="Throttle62::set_watchdog_counter_p(uint8_t* data, int32_t count)">void Throttle62::set_watchdog_counter_p(uint8_t* data, int32_t count) {
  count = ProtocolData::BoundedValue(0, 255, count);
  Byte frame(data + 7);
  frame.set_value(count, 0, 8);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(124, 0)" endLine="(128, 1)" clone_start="1" clone_end="2">
			<code function_name="Brake60::set_watchdog_counter_p(uint8_t* data, int32_t count)">void Brake60::set_watchdog_counter_p(uint8_t* data, int32_t count) {
  count = ProtocolData::BoundedValue(0, 255, count);
  Byte frame(data + 7);
  frame.set_value(count, 0, 8);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(119, 0)" endLine="(125, 1)" clone_start="1" clone_end="7">
			<code function_name="Brake61::watchdog_counter_source(const std::uint8_t* bytes, int32_t length) const">int32_t Brake61::watchdog_counter_source(const std::uint8_t* bytes,
                                         int32_t length) const {
  // see table for status code
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(224, 0)" endLine="(229, 1)" clone_start="1" clone_end="6">
			<code function_name="Misc69::ambient_light_status(const std::uint8_t* bytes, int32_t length) const">int32_t Misc69::ambient_light_status(const std::uint8_t* bytes,
                                     int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(127, 0)" endLine="(130, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake61::is_enabled(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_enabled(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(231, 0)" endLine="(235, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_on_pressed(const std::uint8_t* bytes,
                               int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(132, 0)" endLine="(136, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_driver_override(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_driver_override(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(237, 0)" endLine="(241, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_off_pressed(const std::uint8_t* bytes,
                                int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(4);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(138, 0)" endLine="(142, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_driver_activity(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_driver_activity(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(243, 0)" endLine="(247, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_resume_pressed(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(5);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(144, 0)" endLine="(148, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_watchdog_counter_fault(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_watchdog_counter_fault(const std::uint8_t* bytes,
                                        int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(249, 0)" endLine="(253, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_cancel_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_cancel_pressed(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(6);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(150, 0)" endLine="(154, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_channel_1_fault(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_channel_1_fault(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(255, 0)" endLine="(259, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_or_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_on_or_off_pressed(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(0);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(156, 0)" endLine="(160, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_channel_2_fault(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_channel_2_fault(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(261, 0)" endLine="(265, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t* bytes,
                                             int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(1);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(162, 0)" endLine="(166, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_boo_switch_fault(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_boo_switch_fault(const std::uint8_t* bytes,
                                  int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(267, 0)" endLine="(271, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(168, 0)" endLine="(172, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake61::is_connector_fault(const std::uint8_t* bytes, int32_t length) const">bool Brake61::is_connector_fault(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(273, 0)" endLine="(277, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\monitor\hwmonitor\hw\esdcan\esdcan_err_str.cc" startLine="(22, 0)" endLine="(127, 1)" clone_start="5" clone_end="32">
			<code function_name="esdcan_err_to_str(NTCAN_RESULT ntstatus)">const char *esdcan_err_to_str(NTCAN_RESULT ntstatus) {
  switch (ntstatus) {
    case NTCAN_SUCCESS:
      return "NTCAN_SUCCESS";
    case NTCAN_RX_TIMEOUT:
      return "NTCAN_RX_TIMEOUT";
    case NTCAN_TX_TIMEOUT:
      return "NTCAN_TX_TIMEOUT";
    case NTCAN_TX_ERROR:
      return "NTCAN_TX_ERROR";
    case NTCAN_CONTR_OFF_BUS:
      return "NTCAN_CONTR_OFF_BUS";
    case NTCAN_CONTR_BUSY:
      return "NTCAN_CONTR_BUSY";
    case NTCAN_CONTR_WARN:
      return "NTCAN_CONTR_WARN";
    case NTCAN_NO_ID_ENABLED:
      return "NTCAN_NO_ID_ENABLED";
    case NTCAN_ID_ALREADY_ENABLED:
      return "NTCAN_ID_ALREADY_ENABLED";
    case NTCAN_ID_NOT_ENABLED:
      return "NTCAN_ID_NOT_ENABLED";
    case NTCAN_INVALID_FIRMWARE:
      return "NTCAN_INVALID_FIRMWARE";
    case NTCAN_MESSAGE_LOST:
      return "NTCAN_MESSAGE_LOST";
    case NTCAN_INVALID_PARAMETER:
      return "NTCAN_INVALID_PARAMETER";
    case NTCAN_INVALID_HANDLE:
      return "NTCAN_INVALID_HANDLE";
    case NTCAN_NET_NOT_FOUND:
      return "NTCAN_NET_NOT_FOUND";
#ifdef NTCAN_IO_INCOMPLETE
    case NTCAN_IO_INCOMPLETE:
      return "NTCAN_IO_INCOMPLETE";
#endif
#ifdef NTCAN_IO_PENDING
    case NTCAN_IO_PENDING:
      return "NTCAN_IO_PENDING";
#endif
#ifdef NTCAN_INVALID_HARDWARE
    case NTCAN_INVALID_HARDWARE:
      return "NTCAN_INVALID_HARDWARE";
#endif
#ifdef NTCAN_PENDING_WRITE
    case NTCAN_PENDING_WRITE:
      return "NTCAN_PENDING_WRITE";
#endif
#ifdef NTCAN_PENDING_READ
    case NTCAN_PENDING_READ:
      return "NTCAN_PENDING_READ";
#endif
#ifdef NTCAN_INVALID_DRIVER
    case NTCAN_INVALID_DRIVER:
      return "NTCAN_INVALID_DRIVER";
#endif
#ifdef NTCAN_OPERATION_ABORTED
    case NTCAN_OPERATION_ABORTED:
      return "NTCAN_OPERATION_ABORTED";
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
    case NTCAN_WRONG_DEVICE_STATE:
      return "NTCAN_WRONG_DEVICE_STATE";
#endif
    case NTCAN_INSUFFICIENT_RESOURCES:
      return "NTCAN_INSUFFICIENT_RESOURCES";
#ifdef NTCAN_HANDLE_FORCED_CLOSE
    case NTCAN_HANDLE_FORCED_CLOSE:
      return "NTCAN_HANDLE_FORCED_CLOSE";
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
    case NTCAN_NOT_IMPLEMENTED:
      return "NTCAN_NOT_IMPLEMENTED";
#endif
#ifdef NTCAN_NOT_SUPPORTED
    case NTCAN_NOT_SUPPORTED:
      return "NTCAN_NOT_SUPPORTED";
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
    case NTCAN_SOCK_CONN_TIMEOUT:
      return "NTCAN_SOCK_CONN_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
    case NTCAN_SOCK_CMD_TIMEOUT:
      return "NTCAN_SOCK_CMD_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
    case NTCAN_SOCK_HOST_NOT_FOUND:
      return "NTCAN_SOCK_HOST_NOT_FOUND";
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
    case NTCAN_CONTR_ERR_PASSIVE:
      return "NTCAN_CONTR_ERR_PASSIVE";
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
    case NTCAN_ERROR_NO_BAUDRATE:
      return "NTCAN_ERROR_NO_BAUDRATE";
#endif
#ifdef NTCAN_ERROR_LOM
    case NTCAN_ERROR_LOM:
      return "NTCAN_ERROR_LOM";
#endif
    default:
      return "NTCAN_UNKNOWN";
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\monitor\hwmonitor\hw\esdcan\esdcan_err_str.cc" startLine="(22, 0)" endLine="(127, 1)" clone_start="3" clone_end="30">
			<code function_name="esdcan_err_to_str(NTCAN_RESULT ntstatus)">const char *esdcan_err_to_str(NTCAN_RESULT ntstatus) {
  switch (ntstatus) {
    case NTCAN_SUCCESS:
      return "NTCAN_SUCCESS";
    case NTCAN_RX_TIMEOUT:
      return "NTCAN_RX_TIMEOUT";
    case NTCAN_TX_TIMEOUT:
      return "NTCAN_TX_TIMEOUT";
    case NTCAN_TX_ERROR:
      return "NTCAN_TX_ERROR";
    case NTCAN_CONTR_OFF_BUS:
      return "NTCAN_CONTR_OFF_BUS";
    case NTCAN_CONTR_BUSY:
      return "NTCAN_CONTR_BUSY";
    case NTCAN_CONTR_WARN:
      return "NTCAN_CONTR_WARN";
    case NTCAN_NO_ID_ENABLED:
      return "NTCAN_NO_ID_ENABLED";
    case NTCAN_ID_ALREADY_ENABLED:
      return "NTCAN_ID_ALREADY_ENABLED";
    case NTCAN_ID_NOT_ENABLED:
      return "NTCAN_ID_NOT_ENABLED";
    case NTCAN_INVALID_FIRMWARE:
      return "NTCAN_INVALID_FIRMWARE";
    case NTCAN_MESSAGE_LOST:
      return "NTCAN_MESSAGE_LOST";
    case NTCAN_INVALID_PARAMETER:
      return "NTCAN_INVALID_PARAMETER";
    case NTCAN_INVALID_HANDLE:
      return "NTCAN_INVALID_HANDLE";
    case NTCAN_NET_NOT_FOUND:
      return "NTCAN_NET_NOT_FOUND";
#ifdef NTCAN_IO_INCOMPLETE
    case NTCAN_IO_INCOMPLETE:
      return "NTCAN_IO_INCOMPLETE";
#endif
#ifdef NTCAN_IO_PENDING
    case NTCAN_IO_PENDING:
      return "NTCAN_IO_PENDING";
#endif
#ifdef NTCAN_INVALID_HARDWARE
    case NTCAN_INVALID_HARDWARE:
      return "NTCAN_INVALID_HARDWARE";
#endif
#ifdef NTCAN_PENDING_WRITE
    case NTCAN_PENDING_WRITE:
      return "NTCAN_PENDING_WRITE";
#endif
#ifdef NTCAN_PENDING_READ
    case NTCAN_PENDING_READ:
      return "NTCAN_PENDING_READ";
#endif
#ifdef NTCAN_INVALID_DRIVER
    case NTCAN_INVALID_DRIVER:
      return "NTCAN_INVALID_DRIVER";
#endif
#ifdef NTCAN_OPERATION_ABORTED
    case NTCAN_OPERATION_ABORTED:
      return "NTCAN_OPERATION_ABORTED";
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
    case NTCAN_WRONG_DEVICE_STATE:
      return "NTCAN_WRONG_DEVICE_STATE";
#endif
    case NTCAN_INSUFFICIENT_RESOURCES:
      return "NTCAN_INSUFFICIENT_RESOURCES";
#ifdef NTCAN_HANDLE_FORCED_CLOSE
    case NTCAN_HANDLE_FORCED_CLOSE:
      return "NTCAN_HANDLE_FORCED_CLOSE";
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
    case NTCAN_NOT_IMPLEMENTED:
      return "NTCAN_NOT_IMPLEMENTED";
#endif
#ifdef NTCAN_NOT_SUPPORTED
    case NTCAN_NOT_SUPPORTED:
      return "NTCAN_NOT_SUPPORTED";
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
    case NTCAN_SOCK_CONN_TIMEOUT:
      return "NTCAN_SOCK_CONN_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
    case NTCAN_SOCK_CMD_TIMEOUT:
      return "NTCAN_SOCK_CMD_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
    case NTCAN_SOCK_HOST_NOT_FOUND:
      return "NTCAN_SOCK_HOST_NOT_FOUND";
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
    case NTCAN_CONTR_ERR_PASSIVE:
      return "NTCAN_CONTR_ERR_PASSIVE";
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
    case NTCAN_ERROR_NO_BAUDRATE:
      return "NTCAN_ERROR_NO_BAUDRATE";
#endif
#ifdef NTCAN_ERROR_LOM
    case NTCAN_ERROR_LOM:
      return "NTCAN_ERROR_LOM";
#endif
    default:
      return "NTCAN_UNKNOWN";
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(227, 0)" endLine="(344, 1)" clone_start="53" clone_end="98">
			<code function_name="NovatelParser::prepare_message(MessagePtr&amp; message_ptr)">Parser::MessageType NovatelParser::prepare_message(MessagePtr&amp; message_ptr) {
    if (!check_crc()) {
        ROS_ERROR("CRC check failed.");
        return MessageType::NONE;
    }

    uint8_t* message = nullptr;
    novatel::MessageId message_id;
    uint16_t message_length;
    uint16_t gps_week;
    uint32_t gps_millisecs;
    if (_buffer[2] == novatel::SYNC_2_LONG_HEADER) {
        auto header = reinterpret_cast&lt;const novatel::LongHeader*&gt;(_buffer.data());
        message = _buffer.data() + sizeof(novatel::LongHeader);
        gps_week = header-&gt;gps_week;
        gps_millisecs = header-&gt;gps_millisecs;
        message_id = header-&gt;message_id;
        message_length = header-&gt;message_length;
    } else {
        auto header = reinterpret_cast&lt;const novatel::ShortHeader*&gt;(_buffer.data());
        message = _buffer.data() + sizeof(novatel::ShortHeader);
        gps_week = header-&gt;gps_week;
        gps_millisecs = header-&gt;gps_millisecs;
        message_id = header-&gt;message_id;
        message_length = header-&gt;message_length;
    }
    switch (message_id) {
    case novatel::BESTGNSSPOS:
    case novatel::BESTPOS:
    case novatel::PSRPOS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::BestPos), "Incorrect message_length");
        if (message_length != sizeof(novatel::BestPos)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }
        if (handle_best_pos(reinterpret_cast&lt;novatel::BestPos*&gt;(message), gps_week,
                            gps_millisecs)) {
            message_ptr = &amp;_gnss;
            return MessageType::GNSS;
        }
        break;

    case novatel::BESTGNSSVEL:
    case novatel::BESTVEL:
    case novatel::PSRVEL:
        //ROS_ERROR_COND(message_length != sizeof(novatel::BestVel), "Incorrect message_length");
        if (message_length != sizeof(novatel::BestVel)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }
        if (handle_best_vel(reinterpret_cast&lt;novatel::BestVel*&gt;(message), gps_week,
                            gps_millisecs)) {
            message_ptr = &amp;_gnss;
            return MessageType::GNSS;
        }
        break;

    case novatel::CORRIMUDATA:
    case novatel::CORRIMUDATAS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::CorrImuData), "Incorrect message_length");
        if (message_length != sizeof(novatel::CorrImuData)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_corr_imu_data(reinterpret_cast&lt;novatel::CorrImuData*&gt;(message))) {
            message_ptr = &amp;_ins;
            return MessageType::INS;
        }
        break;

    case novatel::INSCOV:
    case novatel::INSCOVS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::InsCov), "Incorrect message_length");
        if (message_length != sizeof(novatel::InsCov)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_ins_cov(reinterpret_cast&lt;novatel::InsCov*&gt;(message))) {
            message_ptr = &amp;_ins;
            return MessageType::INS;
        }
        break;

    case novatel::INSPVA:
    case novatel::INSPVAS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::InsPva), "Incorrect message_length");
        if (message_length != sizeof(novatel::InsPva)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_ins_pva(reinterpret_cast&lt;novatel::InsPva*&gt;(message))) {
            message_ptr = &amp;_ins;
            return MessageType::INS;
        }
        break;

    case novatel::RAWIMUX:
    case novatel::RAWIMUSX:
        //ROS_ERROR_COND(message_length != sizeof(novatel::RawImuX), "Incorrect message_length");
        if (message_length != sizeof(novatel::RawImuX)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_raw_imu_x(reinterpret_cast&lt;novatel::RawImuX*&gt;(message))) {
            message_ptr = &amp;_imu;
            return MessageType::IMU;
        }
        break;

    default:
        break;
    }
    return MessageType::NONE;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(227, 0)" endLine="(344, 1)" clone_start="67" clone_end="112">
			<code function_name="NovatelParser::prepare_message(MessagePtr&amp; message_ptr)">Parser::MessageType NovatelParser::prepare_message(MessagePtr&amp; message_ptr) {
    if (!check_crc()) {
        ROS_ERROR("CRC check failed.");
        return MessageType::NONE;
    }

    uint8_t* message = nullptr;
    novatel::MessageId message_id;
    uint16_t message_length;
    uint16_t gps_week;
    uint32_t gps_millisecs;
    if (_buffer[2] == novatel::SYNC_2_LONG_HEADER) {
        auto header = reinterpret_cast&lt;const novatel::LongHeader*&gt;(_buffer.data());
        message = _buffer.data() + sizeof(novatel::LongHeader);
        gps_week = header-&gt;gps_week;
        gps_millisecs = header-&gt;gps_millisecs;
        message_id = header-&gt;message_id;
        message_length = header-&gt;message_length;
    } else {
        auto header = reinterpret_cast&lt;const novatel::ShortHeader*&gt;(_buffer.data());
        message = _buffer.data() + sizeof(novatel::ShortHeader);
        gps_week = header-&gt;gps_week;
        gps_millisecs = header-&gt;gps_millisecs;
        message_id = header-&gt;message_id;
        message_length = header-&gt;message_length;
    }
    switch (message_id) {
    case novatel::BESTGNSSPOS:
    case novatel::BESTPOS:
    case novatel::PSRPOS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::BestPos), "Incorrect message_length");
        if (message_length != sizeof(novatel::BestPos)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }
        if (handle_best_pos(reinterpret_cast&lt;novatel::BestPos*&gt;(message), gps_week,
                            gps_millisecs)) {
            message_ptr = &amp;_gnss;
            return MessageType::GNSS;
        }
        break;

    case novatel::BESTGNSSVEL:
    case novatel::BESTVEL:
    case novatel::PSRVEL:
        //ROS_ERROR_COND(message_length != sizeof(novatel::BestVel), "Incorrect message_length");
        if (message_length != sizeof(novatel::BestVel)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }
        if (handle_best_vel(reinterpret_cast&lt;novatel::BestVel*&gt;(message), gps_week,
                            gps_millisecs)) {
            message_ptr = &amp;_gnss;
            return MessageType::GNSS;
        }
        break;

    case novatel::CORRIMUDATA:
    case novatel::CORRIMUDATAS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::CorrImuData), "Incorrect message_length");
        if (message_length != sizeof(novatel::CorrImuData)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_corr_imu_data(reinterpret_cast&lt;novatel::CorrImuData*&gt;(message))) {
            message_ptr = &amp;_ins;
            return MessageType::INS;
        }
        break;

    case novatel::INSCOV:
    case novatel::INSCOVS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::InsCov), "Incorrect message_length");
        if (message_length != sizeof(novatel::InsCov)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_ins_cov(reinterpret_cast&lt;novatel::InsCov*&gt;(message))) {
            message_ptr = &amp;_ins;
            return MessageType::INS;
        }
        break;

    case novatel::INSPVA:
    case novatel::INSPVAS:
        //ROS_ERROR_COND(message_length != sizeof(novatel::InsPva), "Incorrect message_length");
        if (message_length != sizeof(novatel::InsPva)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_ins_pva(reinterpret_cast&lt;novatel::InsPva*&gt;(message))) {
            message_ptr = &amp;_ins;
            return MessageType::INS;
        }
        break;

    case novatel::RAWIMUX:
    case novatel::RAWIMUSX:
        //ROS_ERROR_COND(message_length != sizeof(novatel::RawImuX), "Incorrect message_length");
        if (message_length != sizeof(novatel::RawImuX)) {
            ROS_ERROR("Incorrect message_length");
            break;
        }

        if (handle_raw_imu_x(reinterpret_cast&lt;novatel::RawImuX*&gt;(message))) {
            message_ptr = &amp;_imu;
            return MessageType::IMU;
        }
        break;

    default:
        break;
    }
    return MessageType::NONE;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\monitor\hwmonitor\hw\esdcan\esdcan_err_str.cc" startLine="(22, 0)" endLine="(127, 1)" clone_start="71" clone_end="102">
			<code function_name="esdcan_err_to_str(NTCAN_RESULT ntstatus)">const char *esdcan_err_to_str(NTCAN_RESULT ntstatus) {
  switch (ntstatus) {
    case NTCAN_SUCCESS:
      return "NTCAN_SUCCESS";
    case NTCAN_RX_TIMEOUT:
      return "NTCAN_RX_TIMEOUT";
    case NTCAN_TX_TIMEOUT:
      return "NTCAN_TX_TIMEOUT";
    case NTCAN_TX_ERROR:
      return "NTCAN_TX_ERROR";
    case NTCAN_CONTR_OFF_BUS:
      return "NTCAN_CONTR_OFF_BUS";
    case NTCAN_CONTR_BUSY:
      return "NTCAN_CONTR_BUSY";
    case NTCAN_CONTR_WARN:
      return "NTCAN_CONTR_WARN";
    case NTCAN_NO_ID_ENABLED:
      return "NTCAN_NO_ID_ENABLED";
    case NTCAN_ID_ALREADY_ENABLED:
      return "NTCAN_ID_ALREADY_ENABLED";
    case NTCAN_ID_NOT_ENABLED:
      return "NTCAN_ID_NOT_ENABLED";
    case NTCAN_INVALID_FIRMWARE:
      return "NTCAN_INVALID_FIRMWARE";
    case NTCAN_MESSAGE_LOST:
      return "NTCAN_MESSAGE_LOST";
    case NTCAN_INVALID_PARAMETER:
      return "NTCAN_INVALID_PARAMETER";
    case NTCAN_INVALID_HANDLE:
      return "NTCAN_INVALID_HANDLE";
    case NTCAN_NET_NOT_FOUND:
      return "NTCAN_NET_NOT_FOUND";
#ifdef NTCAN_IO_INCOMPLETE
    case NTCAN_IO_INCOMPLETE:
      return "NTCAN_IO_INCOMPLETE";
#endif
#ifdef NTCAN_IO_PENDING
    case NTCAN_IO_PENDING:
      return "NTCAN_IO_PENDING";
#endif
#ifdef NTCAN_INVALID_HARDWARE
    case NTCAN_INVALID_HARDWARE:
      return "NTCAN_INVALID_HARDWARE";
#endif
#ifdef NTCAN_PENDING_WRITE
    case NTCAN_PENDING_WRITE:
      return "NTCAN_PENDING_WRITE";
#endif
#ifdef NTCAN_PENDING_READ
    case NTCAN_PENDING_READ:
      return "NTCAN_PENDING_READ";
#endif
#ifdef NTCAN_INVALID_DRIVER
    case NTCAN_INVALID_DRIVER:
      return "NTCAN_INVALID_DRIVER";
#endif
#ifdef NTCAN_OPERATION_ABORTED
    case NTCAN_OPERATION_ABORTED:
      return "NTCAN_OPERATION_ABORTED";
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
    case NTCAN_WRONG_DEVICE_STATE:
      return "NTCAN_WRONG_DEVICE_STATE";
#endif
    case NTCAN_INSUFFICIENT_RESOURCES:
      return "NTCAN_INSUFFICIENT_RESOURCES";
#ifdef NTCAN_HANDLE_FORCED_CLOSE
    case NTCAN_HANDLE_FORCED_CLOSE:
      return "NTCAN_HANDLE_FORCED_CLOSE";
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
    case NTCAN_NOT_IMPLEMENTED:
      return "NTCAN_NOT_IMPLEMENTED";
#endif
#ifdef NTCAN_NOT_SUPPORTED
    case NTCAN_NOT_SUPPORTED:
      return "NTCAN_NOT_SUPPORTED";
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
    case NTCAN_SOCK_CONN_TIMEOUT:
      return "NTCAN_SOCK_CONN_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
    case NTCAN_SOCK_CMD_TIMEOUT:
      return "NTCAN_SOCK_CMD_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
    case NTCAN_SOCK_HOST_NOT_FOUND:
      return "NTCAN_SOCK_HOST_NOT_FOUND";
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
    case NTCAN_CONTR_ERR_PASSIVE:
      return "NTCAN_CONTR_ERR_PASSIVE";
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
    case NTCAN_ERROR_NO_BAUDRATE:
      return "NTCAN_ERROR_NO_BAUDRATE";
#endif
#ifdef NTCAN_ERROR_LOM
    case NTCAN_ERROR_LOM:
      return "NTCAN_ERROR_LOM";
#endif
    default:
      return "NTCAN_UNKNOWN";
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\monitor\hwmonitor\hw\esdcan\esdcan_err_str.cc" startLine="(22, 0)" endLine="(127, 1)" clone_start="67" clone_end="98">
			<code function_name="esdcan_err_to_str(NTCAN_RESULT ntstatus)">const char *esdcan_err_to_str(NTCAN_RESULT ntstatus) {
  switch (ntstatus) {
    case NTCAN_SUCCESS:
      return "NTCAN_SUCCESS";
    case NTCAN_RX_TIMEOUT:
      return "NTCAN_RX_TIMEOUT";
    case NTCAN_TX_TIMEOUT:
      return "NTCAN_TX_TIMEOUT";
    case NTCAN_TX_ERROR:
      return "NTCAN_TX_ERROR";
    case NTCAN_CONTR_OFF_BUS:
      return "NTCAN_CONTR_OFF_BUS";
    case NTCAN_CONTR_BUSY:
      return "NTCAN_CONTR_BUSY";
    case NTCAN_CONTR_WARN:
      return "NTCAN_CONTR_WARN";
    case NTCAN_NO_ID_ENABLED:
      return "NTCAN_NO_ID_ENABLED";
    case NTCAN_ID_ALREADY_ENABLED:
      return "NTCAN_ID_ALREADY_ENABLED";
    case NTCAN_ID_NOT_ENABLED:
      return "NTCAN_ID_NOT_ENABLED";
    case NTCAN_INVALID_FIRMWARE:
      return "NTCAN_INVALID_FIRMWARE";
    case NTCAN_MESSAGE_LOST:
      return "NTCAN_MESSAGE_LOST";
    case NTCAN_INVALID_PARAMETER:
      return "NTCAN_INVALID_PARAMETER";
    case NTCAN_INVALID_HANDLE:
      return "NTCAN_INVALID_HANDLE";
    case NTCAN_NET_NOT_FOUND:
      return "NTCAN_NET_NOT_FOUND";
#ifdef NTCAN_IO_INCOMPLETE
    case NTCAN_IO_INCOMPLETE:
      return "NTCAN_IO_INCOMPLETE";
#endif
#ifdef NTCAN_IO_PENDING
    case NTCAN_IO_PENDING:
      return "NTCAN_IO_PENDING";
#endif
#ifdef NTCAN_INVALID_HARDWARE
    case NTCAN_INVALID_HARDWARE:
      return "NTCAN_INVALID_HARDWARE";
#endif
#ifdef NTCAN_PENDING_WRITE
    case NTCAN_PENDING_WRITE:
      return "NTCAN_PENDING_WRITE";
#endif
#ifdef NTCAN_PENDING_READ
    case NTCAN_PENDING_READ:
      return "NTCAN_PENDING_READ";
#endif
#ifdef NTCAN_INVALID_DRIVER
    case NTCAN_INVALID_DRIVER:
      return "NTCAN_INVALID_DRIVER";
#endif
#ifdef NTCAN_OPERATION_ABORTED
    case NTCAN_OPERATION_ABORTED:
      return "NTCAN_OPERATION_ABORTED";
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
    case NTCAN_WRONG_DEVICE_STATE:
      return "NTCAN_WRONG_DEVICE_STATE";
#endif
    case NTCAN_INSUFFICIENT_RESOURCES:
      return "NTCAN_INSUFFICIENT_RESOURCES";
#ifdef NTCAN_HANDLE_FORCED_CLOSE
    case NTCAN_HANDLE_FORCED_CLOSE:
      return "NTCAN_HANDLE_FORCED_CLOSE";
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
    case NTCAN_NOT_IMPLEMENTED:
      return "NTCAN_NOT_IMPLEMENTED";
#endif
#ifdef NTCAN_NOT_SUPPORTED
    case NTCAN_NOT_SUPPORTED:
      return "NTCAN_NOT_SUPPORTED";
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
    case NTCAN_SOCK_CONN_TIMEOUT:
      return "NTCAN_SOCK_CONN_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
    case NTCAN_SOCK_CMD_TIMEOUT:
      return "NTCAN_SOCK_CMD_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
    case NTCAN_SOCK_HOST_NOT_FOUND:
      return "NTCAN_SOCK_HOST_NOT_FOUND";
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
    case NTCAN_CONTR_ERR_PASSIVE:
      return "NTCAN_CONTR_ERR_PASSIVE";
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
    case NTCAN_ERROR_NO_BAUDRATE:
      return "NTCAN_ERROR_NO_BAUDRATE";
#endif
#ifdef NTCAN_ERROR_LOM
    case NTCAN_ERROR_LOM:
      return "NTCAN_ERROR_LOM";
#endif
    default:
      return "NTCAN_UNKNOWN";
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\monitor\hwmonitor\hw\esdcan\esdcan_err_str.cc" startLine="(22, 0)" endLine="(127, 1)" clone_start="33" clone_end="64">
			<code function_name="esdcan_err_to_str(NTCAN_RESULT ntstatus)">const char *esdcan_err_to_str(NTCAN_RESULT ntstatus) {
  switch (ntstatus) {
    case NTCAN_SUCCESS:
      return "NTCAN_SUCCESS";
    case NTCAN_RX_TIMEOUT:
      return "NTCAN_RX_TIMEOUT";
    case NTCAN_TX_TIMEOUT:
      return "NTCAN_TX_TIMEOUT";
    case NTCAN_TX_ERROR:
      return "NTCAN_TX_ERROR";
    case NTCAN_CONTR_OFF_BUS:
      return "NTCAN_CONTR_OFF_BUS";
    case NTCAN_CONTR_BUSY:
      return "NTCAN_CONTR_BUSY";
    case NTCAN_CONTR_WARN:
      return "NTCAN_CONTR_WARN";
    case NTCAN_NO_ID_ENABLED:
      return "NTCAN_NO_ID_ENABLED";
    case NTCAN_ID_ALREADY_ENABLED:
      return "NTCAN_ID_ALREADY_ENABLED";
    case NTCAN_ID_NOT_ENABLED:
      return "NTCAN_ID_NOT_ENABLED";
    case NTCAN_INVALID_FIRMWARE:
      return "NTCAN_INVALID_FIRMWARE";
    case NTCAN_MESSAGE_LOST:
      return "NTCAN_MESSAGE_LOST";
    case NTCAN_INVALID_PARAMETER:
      return "NTCAN_INVALID_PARAMETER";
    case NTCAN_INVALID_HANDLE:
      return "NTCAN_INVALID_HANDLE";
    case NTCAN_NET_NOT_FOUND:
      return "NTCAN_NET_NOT_FOUND";
#ifdef NTCAN_IO_INCOMPLETE
    case NTCAN_IO_INCOMPLETE:
      return "NTCAN_IO_INCOMPLETE";
#endif
#ifdef NTCAN_IO_PENDING
    case NTCAN_IO_PENDING:
      return "NTCAN_IO_PENDING";
#endif
#ifdef NTCAN_INVALID_HARDWARE
    case NTCAN_INVALID_HARDWARE:
      return "NTCAN_INVALID_HARDWARE";
#endif
#ifdef NTCAN_PENDING_WRITE
    case NTCAN_PENDING_WRITE:
      return "NTCAN_PENDING_WRITE";
#endif
#ifdef NTCAN_PENDING_READ
    case NTCAN_PENDING_READ:
      return "NTCAN_PENDING_READ";
#endif
#ifdef NTCAN_INVALID_DRIVER
    case NTCAN_INVALID_DRIVER:
      return "NTCAN_INVALID_DRIVER";
#endif
#ifdef NTCAN_OPERATION_ABORTED
    case NTCAN_OPERATION_ABORTED:
      return "NTCAN_OPERATION_ABORTED";
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
    case NTCAN_WRONG_DEVICE_STATE:
      return "NTCAN_WRONG_DEVICE_STATE";
#endif
    case NTCAN_INSUFFICIENT_RESOURCES:
      return "NTCAN_INSUFFICIENT_RESOURCES";
#ifdef NTCAN_HANDLE_FORCED_CLOSE
    case NTCAN_HANDLE_FORCED_CLOSE:
      return "NTCAN_HANDLE_FORCED_CLOSE";
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
    case NTCAN_NOT_IMPLEMENTED:
      return "NTCAN_NOT_IMPLEMENTED";
#endif
#ifdef NTCAN_NOT_SUPPORTED
    case NTCAN_NOT_SUPPORTED:
      return "NTCAN_NOT_SUPPORTED";
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
    case NTCAN_SOCK_CONN_TIMEOUT:
      return "NTCAN_SOCK_CONN_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
    case NTCAN_SOCK_CMD_TIMEOUT:
      return "NTCAN_SOCK_CMD_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
    case NTCAN_SOCK_HOST_NOT_FOUND:
      return "NTCAN_SOCK_HOST_NOT_FOUND";
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
    case NTCAN_CONTR_ERR_PASSIVE:
      return "NTCAN_CONTR_ERR_PASSIVE";
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
    case NTCAN_ERROR_NO_BAUDRATE:
      return "NTCAN_ERROR_NO_BAUDRATE";
#endif
#ifdef NTCAN_ERROR_LOM
    case NTCAN_ERROR_LOM:
      return "NTCAN_ERROR_LOM";
#endif
    default:
      return "NTCAN_UNKNOWN";
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\monitor\hwmonitor\hw\esdcan\esdcan_err_str.cc" startLine="(22, 0)" endLine="(127, 1)" clone_start="65" clone_end="98">
			<code function_name="esdcan_err_to_str(NTCAN_RESULT ntstatus)">const char *esdcan_err_to_str(NTCAN_RESULT ntstatus) {
  switch (ntstatus) {
    case NTCAN_SUCCESS:
      return "NTCAN_SUCCESS";
    case NTCAN_RX_TIMEOUT:
      return "NTCAN_RX_TIMEOUT";
    case NTCAN_TX_TIMEOUT:
      return "NTCAN_TX_TIMEOUT";
    case NTCAN_TX_ERROR:
      return "NTCAN_TX_ERROR";
    case NTCAN_CONTR_OFF_BUS:
      return "NTCAN_CONTR_OFF_BUS";
    case NTCAN_CONTR_BUSY:
      return "NTCAN_CONTR_BUSY";
    case NTCAN_CONTR_WARN:
      return "NTCAN_CONTR_WARN";
    case NTCAN_NO_ID_ENABLED:
      return "NTCAN_NO_ID_ENABLED";
    case NTCAN_ID_ALREADY_ENABLED:
      return "NTCAN_ID_ALREADY_ENABLED";
    case NTCAN_ID_NOT_ENABLED:
      return "NTCAN_ID_NOT_ENABLED";
    case NTCAN_INVALID_FIRMWARE:
      return "NTCAN_INVALID_FIRMWARE";
    case NTCAN_MESSAGE_LOST:
      return "NTCAN_MESSAGE_LOST";
    case NTCAN_INVALID_PARAMETER:
      return "NTCAN_INVALID_PARAMETER";
    case NTCAN_INVALID_HANDLE:
      return "NTCAN_INVALID_HANDLE";
    case NTCAN_NET_NOT_FOUND:
      return "NTCAN_NET_NOT_FOUND";
#ifdef NTCAN_IO_INCOMPLETE
    case NTCAN_IO_INCOMPLETE:
      return "NTCAN_IO_INCOMPLETE";
#endif
#ifdef NTCAN_IO_PENDING
    case NTCAN_IO_PENDING:
      return "NTCAN_IO_PENDING";
#endif
#ifdef NTCAN_INVALID_HARDWARE
    case NTCAN_INVALID_HARDWARE:
      return "NTCAN_INVALID_HARDWARE";
#endif
#ifdef NTCAN_PENDING_WRITE
    case NTCAN_PENDING_WRITE:
      return "NTCAN_PENDING_WRITE";
#endif
#ifdef NTCAN_PENDING_READ
    case NTCAN_PENDING_READ:
      return "NTCAN_PENDING_READ";
#endif
#ifdef NTCAN_INVALID_DRIVER
    case NTCAN_INVALID_DRIVER:
      return "NTCAN_INVALID_DRIVER";
#endif
#ifdef NTCAN_OPERATION_ABORTED
    case NTCAN_OPERATION_ABORTED:
      return "NTCAN_OPERATION_ABORTED";
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
    case NTCAN_WRONG_DEVICE_STATE:
      return "NTCAN_WRONG_DEVICE_STATE";
#endif
    case NTCAN_INSUFFICIENT_RESOURCES:
      return "NTCAN_INSUFFICIENT_RESOURCES";
#ifdef NTCAN_HANDLE_FORCED_CLOSE
    case NTCAN_HANDLE_FORCED_CLOSE:
      return "NTCAN_HANDLE_FORCED_CLOSE";
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
    case NTCAN_NOT_IMPLEMENTED:
      return "NTCAN_NOT_IMPLEMENTED";
#endif
#ifdef NTCAN_NOT_SUPPORTED
    case NTCAN_NOT_SUPPORTED:
      return "NTCAN_NOT_SUPPORTED";
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
    case NTCAN_SOCK_CONN_TIMEOUT:
      return "NTCAN_SOCK_CONN_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
    case NTCAN_SOCK_CMD_TIMEOUT:
      return "NTCAN_SOCK_CMD_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
    case NTCAN_SOCK_HOST_NOT_FOUND:
      return "NTCAN_SOCK_HOST_NOT_FOUND";
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
    case NTCAN_CONTR_ERR_PASSIVE:
      return "NTCAN_CONTR_ERR_PASSIVE";
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
    case NTCAN_ERROR_NO_BAUDRATE:
      return "NTCAN_ERROR_NO_BAUDRATE";
#endif
#ifdef NTCAN_ERROR_LOM
    case NTCAN_ERROR_LOM:
      return "NTCAN_ERROR_LOM";
#endif
    default:
      return "NTCAN_UNKNOWN";
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\monitor\hwmonitor\hw\esdcan\esdcan_err_str.cc" startLine="(22, 0)" endLine="(127, 1)" clone_start="31" clone_end="64">
			<code function_name="esdcan_err_to_str(NTCAN_RESULT ntstatus)">const char *esdcan_err_to_str(NTCAN_RESULT ntstatus) {
  switch (ntstatus) {
    case NTCAN_SUCCESS:
      return "NTCAN_SUCCESS";
    case NTCAN_RX_TIMEOUT:
      return "NTCAN_RX_TIMEOUT";
    case NTCAN_TX_TIMEOUT:
      return "NTCAN_TX_TIMEOUT";
    case NTCAN_TX_ERROR:
      return "NTCAN_TX_ERROR";
    case NTCAN_CONTR_OFF_BUS:
      return "NTCAN_CONTR_OFF_BUS";
    case NTCAN_CONTR_BUSY:
      return "NTCAN_CONTR_BUSY";
    case NTCAN_CONTR_WARN:
      return "NTCAN_CONTR_WARN";
    case NTCAN_NO_ID_ENABLED:
      return "NTCAN_NO_ID_ENABLED";
    case NTCAN_ID_ALREADY_ENABLED:
      return "NTCAN_ID_ALREADY_ENABLED";
    case NTCAN_ID_NOT_ENABLED:
      return "NTCAN_ID_NOT_ENABLED";
    case NTCAN_INVALID_FIRMWARE:
      return "NTCAN_INVALID_FIRMWARE";
    case NTCAN_MESSAGE_LOST:
      return "NTCAN_MESSAGE_LOST";
    case NTCAN_INVALID_PARAMETER:
      return "NTCAN_INVALID_PARAMETER";
    case NTCAN_INVALID_HANDLE:
      return "NTCAN_INVALID_HANDLE";
    case NTCAN_NET_NOT_FOUND:
      return "NTCAN_NET_NOT_FOUND";
#ifdef NTCAN_IO_INCOMPLETE
    case NTCAN_IO_INCOMPLETE:
      return "NTCAN_IO_INCOMPLETE";
#endif
#ifdef NTCAN_IO_PENDING
    case NTCAN_IO_PENDING:
      return "NTCAN_IO_PENDING";
#endif
#ifdef NTCAN_INVALID_HARDWARE
    case NTCAN_INVALID_HARDWARE:
      return "NTCAN_INVALID_HARDWARE";
#endif
#ifdef NTCAN_PENDING_WRITE
    case NTCAN_PENDING_WRITE:
      return "NTCAN_PENDING_WRITE";
#endif
#ifdef NTCAN_PENDING_READ
    case NTCAN_PENDING_READ:
      return "NTCAN_PENDING_READ";
#endif
#ifdef NTCAN_INVALID_DRIVER
    case NTCAN_INVALID_DRIVER:
      return "NTCAN_INVALID_DRIVER";
#endif
#ifdef NTCAN_OPERATION_ABORTED
    case NTCAN_OPERATION_ABORTED:
      return "NTCAN_OPERATION_ABORTED";
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
    case NTCAN_WRONG_DEVICE_STATE:
      return "NTCAN_WRONG_DEVICE_STATE";
#endif
    case NTCAN_INSUFFICIENT_RESOURCES:
      return "NTCAN_INSUFFICIENT_RESOURCES";
#ifdef NTCAN_HANDLE_FORCED_CLOSE
    case NTCAN_HANDLE_FORCED_CLOSE:
      return "NTCAN_HANDLE_FORCED_CLOSE";
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
    case NTCAN_NOT_IMPLEMENTED:
      return "NTCAN_NOT_IMPLEMENTED";
#endif
#ifdef NTCAN_NOT_SUPPORTED
    case NTCAN_NOT_SUPPORTED:
      return "NTCAN_NOT_SUPPORTED";
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
    case NTCAN_SOCK_CONN_TIMEOUT:
      return "NTCAN_SOCK_CONN_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
    case NTCAN_SOCK_CMD_TIMEOUT:
      return "NTCAN_SOCK_CMD_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
    case NTCAN_SOCK_HOST_NOT_FOUND:
      return "NTCAN_SOCK_HOST_NOT_FOUND";
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
    case NTCAN_CONTR_ERR_PASSIVE:
      return "NTCAN_CONTR_ERR_PASSIVE";
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
    case NTCAN_ERROR_NO_BAUDRATE:
      return "NTCAN_ERROR_NO_BAUDRATE";
#endif
#ifdef NTCAN_ERROR_LOM
    case NTCAN_ERROR_LOM:
      return "NTCAN_ERROR_LOM";
#endif
    default:
      return "NTCAN_UNKNOWN";
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(26, 0)" endLine="(55, 1)" clone_start="8" clone_end="30">
			<code function_name="Brake61::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Brake61::Parse(const std::uint8_t* bytes, int32_t length,
                    ChassisDetail* car_status) const {
  car_status-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_output(pedal_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  car_status-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  car_status-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(26, 0)" endLine="(48, 1)" clone_start="3" clone_end="23">
			<code function_name="Throttle63::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Throttle63::Parse(const std::uint8_t* bytes, int32_t length,
                       ChassisDetail* car_status) const {
  car_status-&gt;mutable_gas()-&gt;set_throttle_input(pedal_input(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_throttle_cmd(pedal_cmd(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_throttle_output(pedal_output(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_throttle_enabled(is_enabled(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  car_status-&gt;mutable_gas()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  car_status-&gt;mutable_check_response()-&gt;set_is_vcu_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(57, 0)" endLine="(68, 1)" clone_start="1" clone_end="12">
			<code function_name="Brake61::pedal_input(const std::uint8_t* bytes, int32_t length) const">double Brake61::pedal_input(const std::uint8_t* bytes, int32_t length) const {
  // Pedal Input from the physical pedal
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(50, 0)" endLine="(62, 1)" clone_start="1" clone_end="13">
			<code function_name="Throttle63::pedal_input(const std::uint8_t* bytes, int32_t length) const">double Throttle63::pedal_input(const std::uint8_t* bytes,
                               int32_t length) const {
  // Pedal Input from the physical pedal
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(70, 0)" endLine="(81, 1)" clone_start="1" clone_end="12">
			<code function_name="Brake61::pedal_cmd(const std::uint8_t* bytes, int32_t length) const">double Brake61::pedal_cmd(const std::uint8_t* bytes, int32_t length) const {
  // Pedal Command from the command message
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(64, 0)" endLine="(75, 1)" clone_start="1" clone_end="12">
			<code function_name="Throttle63::pedal_cmd(const std::uint8_t* bytes, int32_t length) const">double Throttle63::pedal_cmd(const std::uint8_t* bytes, int32_t length) const {
  // Pedal Command from the command message
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(83, 0)" endLine="(94, 1)" clone_start="1" clone_end="12">
			<code function_name="Brake61::pedal_output(const std::uint8_t* bytes, int32_t length) const">double Brake61::pedal_output(const std::uint8_t* bytes, int32_t length) const {
  // Pedal Output is the maximum of PI and PC
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(77, 0)" endLine="(89, 1)" clone_start="1" clone_end="13">
			<code function_name="Throttle63::pedal_output(const std::uint8_t* bytes, int32_t length) const">double Throttle63::pedal_output(const std::uint8_t* bytes,
                                int32_t length) const {
  // Pedal Output is the maximum of PI and PC
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(96, 0)" endLine="(100, 1)" clone_start="1" clone_end="2">
			<code function_name="Brake61::boo_input(const std::uint8_t* bytes, int32_t length) const">bool Brake61::boo_input(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 6);
  // seems typo here
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(91, 0)" endLine="(96, 1)" clone_start="1" clone_end="3">
			<code function_name="Throttle63::watchdog_counter_source(const std::uint8_t* bytes, int32_t length) const">int32_t Throttle63::watchdog_counter_source(const std::uint8_t* bytes,
                                            int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(49, 0)" endLine="(52, 1)" clone_start="2" clone_end="4">
			<code function_name="Throttle62::set_pedal(double pedal)">Throttle62* Throttle62::set_pedal(double pedal) {
  pedal_cmd_ = pedal;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(64, 0)" endLine="(67, 1)" clone_start="2" clone_end="4">
			<code function_name="Brake60::disable_boo_cmd()">Brake60* Brake60::disable_boo_cmd() {
  boo_cmd_ = false;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(54, 0)" endLine="(57, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle62::set_enable()">Throttle62* Throttle62::set_enable() {
  pedal_enable_ = true;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(69, 0)" endLine="(72, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake60::set_enable()">Brake60* Brake60::set_enable() {
  pedal_enable_ = true;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(59, 0)" endLine="(62, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle62::set_disable()">Throttle62* Throttle62::set_disable() {
  pedal_enable_ = false;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(74, 0)" endLine="(77, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake60::set_disable()">Brake60* Brake60::set_disable() {
  pedal_enable_ = false;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(66, 0)" endLine="(82, 1)" clone_start="1" clone_end="17">
			<code function_name="Throttle62::set_pedal_p(uint8_t* data, double pedal)">void Throttle62::set_pedal_p(uint8_t* data, double pedal) {
  // change from [0-100] to [0.00-1.00]
  // and a rough mapping
  pedal /= 100.0;
  pedal = ProtocolData::BoundedValue(0.0, 1.0, pedal);
  int32_t x = pedal / 1.52590218966964e-05;
  std::uint8_t t = 0;

  t = x &amp; 0xFF;
  Byte frame_low(data + 0);
  frame_low.set_value(t, 0, 8);

  x &gt;&gt;= 8;
  t = x &amp; 0xFF;
  Byte frame_high(data + 1);
  frame_high.set_value(t, 0, 8);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(79, 0)" endLine="(95, 1)" clone_start="1" clone_end="17">
			<code function_name="Brake60::set_pedal_p(uint8_t* data, double pedal)">void Brake60::set_pedal_p(uint8_t* data, double pedal) {
  // change from [0-100] to [0.00-1.00]
  // and a rough mapping
  pedal /= 100.;
  pedal = ProtocolData::BoundedValue(0.0, 1.0, pedal);
  int32_t x = pedal / 1.52590218966964e-05;
  std::uint8_t t = 0;

  t = x &amp; 0xFF;
  Byte frame_low(data + 0);
  frame_low.set_value(t, 0, 8);

  x &gt;&gt;= 8;
  t = x &amp; 0xFF;
  Byte frame_high(data + 1);
  frame_high.set_value(t, 0, 8);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(84, 0)" endLine="(91, 1)" clone_start="1" clone_end="8">
			<code function_name="Throttle62::set_enable_p(uint8_t* bytes, bool enable)">void Throttle62::set_enable_p(uint8_t* bytes, bool enable) {
  Byte frame(bytes + 3);
  if (enable) {
    frame.set_bit_1(0);
  } else {
    frame.set_bit_0(0);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(97, 0)" endLine="(104, 1)" clone_start="1" clone_end="8">
			<code function_name="Brake60::set_boo_cmd_p(uint8_t* bytes, bool boo_cmd)">void Brake60::set_boo_cmd_p(uint8_t* bytes, bool boo_cmd) {
  Byte frame(bytes + 2);
  if (boo_cmd) {
    frame.set_bit_1(0);
  } else {
    frame.set_bit_0(0);
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(93, 0)" endLine="(100, 1)" clone_start="1" clone_end="8">
			<code function_name="Throttle62::set_clear_driver_override_flag_p(uint8_t* bytes, bool clear)">void Throttle62::set_clear_driver_override_flag_p(uint8_t* bytes, bool clear) {
  Byte frame(bytes + 3);
  if (clear) {
    frame.set_bit_1(1);
  } else {
    frame.set_bit_0(1);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(106, 0)" endLine="(113, 1)" clone_start="1" clone_end="8">
			<code function_name="Brake60::set_enable_p(uint8_t* bytes, bool enable)">void Brake60::set_enable_p(uint8_t* bytes, bool enable) {
  Byte frame(bytes + 3);
  if (enable) {
    frame.set_bit_1(0);
  } else {
    frame.set_bit_0(0);
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(102, 0)" endLine="(109, 1)" clone_start="1" clone_end="8">
			<code function_name="Throttle62::set_ignore_driver_override_p(uint8_t* bytes, bool ignore)">void Throttle62::set_ignore_driver_override_p(uint8_t* bytes, bool ignore) {
  Byte frame(bytes + 3);
  if (ignore) {
    frame.set_bit_1(2);
  } else {
    frame.set_bit_0(2);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(115, 0)" endLine="(122, 1)" clone_start="1" clone_end="8">
			<code function_name="Brake60::set_clear_driver_override_flag_p(uint8_t* bytes, bool clear)">void Brake60::set_clear_driver_override_flag_p(uint8_t* bytes, bool clear) {
  Byte frame(bytes + 3);
  if (clear) {
    frame.set_bit_1(1);
  } else {
    frame.set_bit_0(1);
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(111, 0)" endLine="(115, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle62::set_watchdog_counter_p(uint8_t* data, int32_t count)">void Throttle62::set_watchdog_counter_p(uint8_t* data, int32_t count) {
  count = ProtocolData::BoundedValue(0, 255, count);
  Byte frame(data + 7);
  frame.set_value(count, 0, 8);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(124, 0)" endLine="(128, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake60::set_watchdog_counter_p(uint8_t* data, int32_t count)">void Brake60::set_watchdog_counter_p(uint8_t* data, int32_t count) {
  count = ProtocolData::BoundedValue(0, 255, count);
  Byte frame(data + 7);
  frame.set_value(count, 0, 8);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="41" clone_end="86">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(202, 1)" clone_start="44" clone_end="89">
			<code function_name="Misc69::Parse(const std::uint8_t* bytes, int32_t length, ChassisDetail* car_status) const">void Misc69::Parse(const std::uint8_t* bytes, int32_t length,
                   ChassisDetail* car_status) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LIGHT_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF_MOVING);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_ON);
      break;
    case 5:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_MIST_FLICK);
      break;
    case 8:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      car_status-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_LIGHT);
      break;
    case 2:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_NO_DATA);
      break;
    default:
      car_status-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  car_status-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  car_status-&gt;mutable_basic()-&gt;set_canbus_fault(is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    car_status-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  car_status-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_hood_open(is_hood_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_trunk_open(is_trunk_open(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // car_status-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  car_status-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  car_status-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // car_status-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(231, 0)" endLine="(235, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_on_pressed(const std::uint8_t* bytes,
                               int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(237, 0)" endLine="(241, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_off_pressed(const std::uint8_t* bytes,
                                int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(4);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(237, 0)" endLine="(241, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_off_pressed(const std::uint8_t* bytes,
                                int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(243, 0)" endLine="(247, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_resume_pressed(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(5);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(243, 0)" endLine="(247, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_resume_pressed(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(249, 0)" endLine="(253, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_cancel_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_cancel_pressed(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(6);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(249, 0)" endLine="(253, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_cancel_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_cancel_pressed(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(255, 0)" endLine="(259, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_or_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_on_or_off_pressed(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(0);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(255, 0)" endLine="(259, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_or_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_on_or_off_pressed(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(261, 0)" endLine="(265, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t* bytes,
                                             int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(1);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(261, 0)" endLine="(265, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t* bytes,
                                             int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(267, 0)" endLine="(271, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(267, 0)" endLine="(271, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(273, 0)" endLine="(277, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(273, 0)" endLine="(277, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t* bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(279, 0)" endLine="(283, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t* bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(4);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(279, 0)" endLine="(283, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t* bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(285, 0)" endLine="(289, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t* bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(5);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(285, 0)" endLine="(289, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t* bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(291, 0)" endLine="(295, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_lka_on_or_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_lka_on_or_off_pressed(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(6);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(291, 0)" endLine="(295, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_lka_on_or_off_pressed(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_lka_on_or_off_pressed(const std::uint8_t* bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(297, 0)" endLine="(300, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(7);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(297, 0)" endLine="(300, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_canbus_fault(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(302, 0)" endLine="(306, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_driver_door_open(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(0);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(302, 0)" endLine="(306, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_driver_door_open(const std::uint8_t* bytes,
                                 int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(308, 0)" endLine="(312, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_door_open(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(1);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(308, 0)" endLine="(312, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_door_open(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(314, 0)" endLine="(318, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_left_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_rear_left_door_open(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(2);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(314, 0)" endLine="(318, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_left_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_rear_left_door_open(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(320, 0)" endLine="(324, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_right_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_rear_right_door_open(const std::uint8_t* bytes,
                                     int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(320, 0)" endLine="(324, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_right_door_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_rear_right_door_open(const std::uint8_t* bytes,
                                     int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(326, 0)" endLine="(329, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_hood_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_hood_open(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(4);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(326, 0)" endLine="(329, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_hood_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_hood_open(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(331, 0)" endLine="(334, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_trunk_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_trunk_open(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(5);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(331, 0)" endLine="(334, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_trunk_open(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_trunk_open(const std::uint8_t* bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(336, 0)" endLine="(340, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_detected(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_detected(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(6);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(336, 0)" endLine="(340, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_detected(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_detected(const std::uint8_t* bytes,
                                   int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(342, 0)" endLine="(346, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_airbag_enabled(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_airbag_enabled(const std::uint8_t* bytes,
                                         int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(7);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(342, 0)" endLine="(346, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_airbag_enabled(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_airbag_enabled(const std::uint8_t* bytes,
                                         int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(348, 0)" endLine="(352, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_belt_buckled(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_driver_belt_buckled(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 4);
  return frame.is_bit_1(0);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(348, 0)" endLine="(352, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_driver_belt_buckled(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_driver_belt_buckled(const std::uint8_t* bytes,
                                    int32_t length) const {
  Byte frame(bytes + 4);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.0.0\apollo-1.0.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(354, 0)" endLine="(358, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_passenger_belt_buckled(const std::uint8_t* bytes, int32_t length) const">bool Misc69::is_passenger_belt_buckled(const std::uint8_t* bytes,
                                       int32_t length) const {
  Byte frame(bytes + 4);
  return frame.is_bit_1(1);
}</code>
		</source>
	</dup>
	<summary count="384"/>
</Func_Clone>
