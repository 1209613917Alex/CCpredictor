<?xml version="1.0" encoding="utf-8"?>
<Func_Clone>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\rtk\rtk_localization.cc" startLine="(37, 0)" endLine="(57, 1)" clone_start="9" clone_end="15">
			<code function_name="RTKLocalization::Start()">Status RTKLocalization::Start() {
  AdapterManager::Init(FLAGS_rtk_adapter_config_file);

  // start ROS timer, one-shot = false, auto-start = true
  const double duration = 1.0 / FLAGS_localization_publish_freq;
  timer_ = AdapterManager::CreateTimer(ros::Duration(duration),
                                       &amp;RTKLocalization::OnTimer, this);
  common::monitor::MonitorBuffer buffer(&amp;monitor_);
  if (!AdapterManager::GetGps()) {
    buffer.ERROR() &lt;&lt; "GPS input not initialized. Check file "
                   &lt;&lt; FLAGS_rtk_adapter_config_file;
    buffer.PrintLog();
    return Status(common::LOCALIZATION_ERROR, "no GPS adapter");
  }
  if (!AdapterManager::GetImu()) {
    buffer.ERROR("IMU input not initialized. Check your adapter.conf file!");
    buffer.PrintLog();
    return Status(common::LOCALIZATION_ERROR, "no IMU adapter");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\camera\camera_localization.cc" startLine="(36, 0)" endLine="(73, 1)" clone_start="23" clone_end="30">
			<code function_name="CameraLocalization::Start()">Status CameraLocalization::Start() {
  MonitorBuffer buffer(&amp;monitor_);
  if (!common::util::GetProtoFromFile(FLAGS_camera_parameter_config_file,
                                      &amp;camera_parameter_)) {
    buffer.ERROR() &lt;&lt; "Camera parameter is not initialized. Check "
                   &lt;&lt; FLAGS_camera_parameter_config_file;
    buffer.PrintLog();
    return Status(common::LOCALIZATION_ERROR,
                  "failed to load camera parameter");
  }

  AdapterManager::Init(FLAGS_camera_adapter_config_file);
  // start ROS timer, one-shot = false, auto-start = true
  const double duration = 1.0 / FLAGS_localization_publish_freq;
  timer_ = AdapterManager::CreateTimer(ros::Duration(duration),
                                       &amp;CameraLocalization::OnTimer, this);
  if (!AdapterManager::GetGps()) {
    buffer.ERROR() &lt;&lt; "GPS input not initialized. Check "
                   &lt;&lt; FLAGS_camera_adapter_config_file;
    buffer.PrintLog();
    return Status(common::LOCALIZATION_ERROR, "no GPS adapter");
  }
  if (!AdapterManager::GetCamera()) {
    buffer.ERROR() &lt;&lt; "Camera input not initialized. Check "
                   &lt;&lt; FLAGS_camera_adapter_config_file;
    buffer.PrintLog();
    return Status(common::LOCALIZATION_ERROR, "no Camera adapter");
  }
  // IMU is optional
  if (!AdapterManager::GetImu()) {
    buffer.INFO("IMU input not initialized. Check your adapter.conf file!");
    buffer.PrintLog();
    use_imu_ = false;
  } else {
    use_imu_ = true;
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\camera\camera_localization.cc" startLine="(36, 0)" endLine="(73, 1)" clone_start="17" clone_end="23">
			<code function_name="CameraLocalization::Start()">Status CameraLocalization::Start() {
  MonitorBuffer buffer(&amp;monitor_);
  if (!common::util::GetProtoFromFile(FLAGS_camera_parameter_config_file,
                                      &amp;camera_parameter_)) {
    buffer.ERROR() &lt;&lt; "Camera parameter is not initialized. Check "
                   &lt;&lt; FLAGS_camera_parameter_config_file;
    buffer.PrintLog();
    return Status(common::LOCALIZATION_ERROR,
                  "failed to load camera parameter");
  }

  AdapterManager::Init(FLAGS_camera_adapter_config_file);
  // start ROS timer, one-shot = false, auto-start = true
  const double duration = 1.0 / FLAGS_localization_publish_freq;
  timer_ = AdapterManager::CreateTimer(ros::Duration(duration),
                                       &amp;CameraLocalization::OnTimer, this);
  if (!AdapterManager::GetGps()) {
    buffer.ERROR() &lt;&lt; "GPS input not initialized. Check "
                   &lt;&lt; FLAGS_camera_adapter_config_file;
    buffer.PrintLog();
    return Status(common::LOCALIZATION_ERROR, "no GPS adapter");
  }
  if (!AdapterManager::GetCamera()) {
    buffer.ERROR() &lt;&lt; "Camera input not initialized. Check "
                   &lt;&lt; FLAGS_camera_adapter_config_file;
    buffer.PrintLog();
    return Status(common::LOCALIZATION_ERROR, "no Camera adapter");
  }
  // IMU is optional
  if (!AdapterManager::GetImu()) {
    buffer.INFO("IMU input not initialized. Check your adapter.conf file!");
    buffer.PrintLog();
    use_imu_ = false;
  } else {
    use_imu_ = true;
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(636, 0)" endLine="(677, 1)" clone_start="36" clone_end="42">
			<code function_name="Obstacle::InitKFPedestrianTracker(Feature* feature)">void Obstacle::InitKFPedestrianTracker(Feature* feature) {
  // Set transition matrix F
  Eigen::Matrix&lt;double, 2, 2&gt; F;
  F.setIdentity();
  kf_pedestrian_tracker_.SetTransitionMatrix(F);

  // Set observation matrix H
  Eigen::Matrix&lt;double, 2, 2&gt; H;
  H.setIdentity();
  kf_pedestrian_tracker_.SetObservationMatrix(H);

  // Set control matrix
  Eigen::Matrix&lt;double, 2, 4&gt; B;
  B.setZero();
  kf_pedestrian_tracker_.SetControlMatrix(B);

  // Set covariance of transition noise matrix Q
  Eigen::Matrix&lt;double, 2, 2&gt; Q;
  Q.setIdentity();
  Q *= FLAGS_q_var;
  kf_pedestrian_tracker_.SetTransitionNoise(Q);

  // Set observation noise matrix R
  Eigen::Matrix&lt;double, 2, 2&gt; R;
  R.setIdentity();
  R *= FLAGS_r_var;
  kf_pedestrian_tracker_.SetObservationNoise(R);

  // Set current state covariance matrix P
  Eigen::Matrix&lt;double, 2, 2&gt; P;
  P.setIdentity();
  P *= FLAGS_p_var;

  // Set initial state
  Eigen::Matrix&lt;double, 2, 1&gt; x;
  x(0, 0) = feature-&gt;position().x();
  x(1, 0) = feature-&gt;position().y();

  kf_pedestrian_tracker_.SetStateEstimate(x, P);

  kf_pedestrian_tracker_enabled_ = true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(364, 0)" endLine="(406, 1)" clone_start="37" clone_end="43">
			<code function_name="Obstacle::InitKFMotionTracker(Feature* feature)">void Obstacle::InitKFMotionTracker(Feature* feature) {
  // Set transition matrix F
  Eigen::Matrix&lt;double, 6, 6&gt; F;
  F.setIdentity();
  kf_motion_tracker_.SetTransitionMatrix(F);

  // Set observation matrix H
  Eigen::Matrix&lt;double, 2, 6&gt; H;
  H.setZero();
  H(0, 0) = 1.0;
  H(1, 1) = 1.0;
  kf_motion_tracker_.SetObservationMatrix(H);

  // Set covariance of transition noise matrix Q
  Eigen::Matrix&lt;double, 6, 6&gt; Q;
  Q.setIdentity();
  Q *= FLAGS_q_var;
  kf_motion_tracker_.SetTransitionNoise(Q);

  // Set observation noise matrix R
  Eigen::Matrix&lt;double, 2, 2&gt; R;
  R.setIdentity();
  R *= FLAGS_r_var;
  kf_motion_tracker_.SetObservationNoise(R);

  // Set current state covariance matrix P
  Eigen::Matrix&lt;double, 6, 6&gt; P;
  P.setIdentity();
  P *= FLAGS_p_var;

  // Set initial state
  Eigen::Matrix&lt;double, 6, 1&gt; x;
  x(0, 0) = feature-&gt;position().x();
  x(1, 0) = feature-&gt;position().y();
  x(2, 0) = feature-&gt;velocity().x();
  x(3, 0) = feature-&gt;velocity().y();
  x(4, 0) = feature-&gt;acceleration().x();
  x(5, 0) = feature-&gt;acceleration().y();

  kf_motion_tracker_.SetStateEstimate(x, P);

  kf_motion_tracker_enabled_ = true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(679, 0)" endLine="(715, 1)" clone_start="1" clone_end="2">
			<code function_name="Obstacle::UpdateKFPedestrianTracker(Feature* feature)">void Obstacle::UpdateKFPedestrianTracker(Feature* feature) {
  double delta_ts = 0.0;
  if (!feature_history_.empty()) {
    delta_ts = feature-&gt;timestamp() - feature_history_.front().timestamp();
  }
  if (delta_ts &gt; std::numeric_limits&lt;double&gt;::epsilon()) {
    Eigen::Matrix&lt;double, 2, 4&gt; B = kf_pedestrian_tracker_.GetControlMatrix();
    B(0, 0) = delta_ts;
    B(0, 2) = 0.5 * delta_ts * delta_ts;
    B(1, 1) = delta_ts;
    B(1, 3) = 0.5 * delta_ts * delta_ts;
    kf_pedestrian_tracker_.SetControlMatrix(B);

    // Set control vector
    Eigen::Matrix&lt;double, 4, 1&gt; u;
    u(0, 0) = feature-&gt;t_velocity().x();
    u(1, 0) = feature-&gt;t_velocity().y();
    if (FLAGS_enable_pedestrian_acc) {
      u(2, 0) = feature-&gt;t_acceleration().x();
      u(3, 0) = feature-&gt;t_acceleration().y();
    }

    kf_pedestrian_tracker_.Predict(u);

    // Set observation vector
    Eigen::Matrix&lt;double, 2, 1&gt; z;
    z(0, 0) = feature-&gt;position().x();
    z(1, 0) = feature-&gt;position().y();
    kf_pedestrian_tracker_.Correct(z);
  }

  // Update feature by Kalman filter
  feature-&gt;mutable_t_position()-&gt;set_x(
      kf_pedestrian_tracker_.GetStateEstimate()(0, 0));
  feature-&gt;mutable_t_position()-&gt;set_y(
      kf_pedestrian_tracker_.GetStateEstimate()(1, 0));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(408, 0)" endLine="(433, 1)" clone_start="1" clone_end="2">
			<code function_name="Obstacle::UpdateKFMotionTracker(Feature* feature)">void Obstacle::UpdateKFMotionTracker(Feature* feature) {
  double delta_ts = 0.0;
  if (feature_history_.size() &gt; 0) {
    delta_ts = feature-&gt;timestamp() - feature_history_.front().timestamp();
  }
  if (delta_ts &gt; FLAGS_double_precision) {
    // Set tansition matrix and predict
    auto F = kf_motion_tracker_.GetTransitionMatrix();
    F(0, 2) = delta_ts;
    F(0, 4) = delta_ts;
    F(1, 3) = 0.5 * delta_ts * delta_ts;
    F(1, 5) = 0.5 * delta_ts * delta_ts;
    F(2, 4) = delta_ts;
    F(3, 5) = delta_ts;
    kf_motion_tracker_.SetTransitionMatrix(F);
    kf_motion_tracker_.Predict();

    // Set observation and correct
    Eigen::Matrix&lt;double, 2, 1&gt; z;
    z(0, 0) = feature-&gt;position().x();
    z(1, 0) = feature-&gt;position().y();
    kf_motion_tracker_.Correct(z);
  }

  UpdateMotionBelief(feature);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_generator.h" startLine="(41, 2)" endLine="(41, 48)" clone_start="1" clone_end="1">
			<code function_name="~PiecewiseLinearGenerator()">  virtual ~PiecewiseLinearGenerator() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_constraint.h" startLine="(35, 2)" endLine="(35, 49)" clone_start="1" clone_end="1">
			<code function_name="~PiecewiseLinearConstraint()">  virtual ~PiecewiseLinearConstraint() = default;</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\kalman_filter.h" startLine="(30, 2)" endLine="(30, 20)" clone_start="1" clone_end="1">
			<code function_name="~KalmanFilter()">  ~KalmanFilter() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hungarian_matcher.h" startLine="(29, 2)" endLine="(29, 23)" clone_start="1" clone_end="1">
			<code function_name="HungarianMatcher()">  HungarianMatcher() {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_seg_kernel.cc" startLine="(78, 0)" endLine="(125, 1)" clone_start="30" clone_end="37">
			<code function_name="SplineSegKernel::integrated_term_matrix(const std::uint32_t order, const double x, const std::string&amp; type, Eigen::MatrixXd* term_matrix) const">void SplineSegKernel::integrated_term_matrix(
    const std::uint32_t order, const double x, const std::string&amp; type,
    Eigen::MatrixXd* term_matrix) const {
  if (term_matrix-&gt;rows() != term_matrix-&gt;cols() ||
      term_matrix-&gt;rows() != static_cast&lt;int&gt;(order)) {
    term_matrix-&gt;resize(order, order);
  }

  std::vector&lt;double&gt; x_pow(2 * order + 1, 1.0);
  for (std::uint32_t i = 1; i &lt; 2 * order + 1; ++i) {
    x_pow[i] = x_pow[i - 1] * x;
  }

  if (type == "fx") {
    for (std::uint32_t r = 0; r &lt; order; ++r) {
      for (std::uint32_t c = 0; c &lt; order; ++c) {
        (*term_matrix)(r, c) = x_pow[r + c + 1];
      }
    }

  } else if (type == "derivative") {
    for (std::uint32_t r = 1; r &lt; order; ++r) {
      for (std::uint32_t c = 1; c &lt; order; ++c) {
        (*term_matrix)(r, c) = x_pow[r + c - 1];
      }
    }
    (*term_matrix).block(0, 0, order, 1) = Eigen::MatrixXd::Zero(order, 1);
    (*term_matrix).block(0, 0, 1, order) = Eigen::MatrixXd::Zero(1, order);

  } else if (type == "second_order") {
    for (std::uint32_t r = 2; r &lt; order; ++r) {
      for (std::uint32_t c = 2; c &lt; order; ++c) {
        (*term_matrix)(r, c) = x_pow[r + c - 3];
      }
    }
    (*term_matrix).block(0, 0, order, 2) = Eigen::MatrixXd::Zero(order, 2);
    (*term_matrix).block(0, 0, 2, order) = Eigen::MatrixXd::Zero(2, order);

  } else {
    for (std::uint32_t r = 3; r &lt; order; ++r) {
      for (std::uint32_t c = 3; c &lt; order; ++c) {
        (*term_matrix)(r, c) = x_pow[r + c - 5];
      }
    }
    (*term_matrix).block(0, 0, order, 3) = Eigen::MatrixXd::Zero(order, 3);
    (*term_matrix).block(0, 0, 3, order) = Eigen::MatrixXd::Zero(3, order);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_seg_kernel.cc" startLine="(78, 0)" endLine="(125, 1)" clone_start="21" clone_end="28">
			<code function_name="SplineSegKernel::integrated_term_matrix(const std::uint32_t order, const double x, const std::string&amp; type, Eigen::MatrixXd* term_matrix) const">void SplineSegKernel::integrated_term_matrix(
    const std::uint32_t order, const double x, const std::string&amp; type,
    Eigen::MatrixXd* term_matrix) const {
  if (term_matrix-&gt;rows() != term_matrix-&gt;cols() ||
      term_matrix-&gt;rows() != static_cast&lt;int&gt;(order)) {
    term_matrix-&gt;resize(order, order);
  }

  std::vector&lt;double&gt; x_pow(2 * order + 1, 1.0);
  for (std::uint32_t i = 1; i &lt; 2 * order + 1; ++i) {
    x_pow[i] = x_pow[i - 1] * x;
  }

  if (type == "fx") {
    for (std::uint32_t r = 0; r &lt; order; ++r) {
      for (std::uint32_t c = 0; c &lt; order; ++c) {
        (*term_matrix)(r, c) = x_pow[r + c + 1];
      }
    }

  } else if (type == "derivative") {
    for (std::uint32_t r = 1; r &lt; order; ++r) {
      for (std::uint32_t c = 1; c &lt; order; ++c) {
        (*term_matrix)(r, c) = x_pow[r + c - 1];
      }
    }
    (*term_matrix).block(0, 0, order, 1) = Eigen::MatrixXd::Zero(order, 1);
    (*term_matrix).block(0, 0, 1, order) = Eigen::MatrixXd::Zero(1, order);

  } else if (type == "second_order") {
    for (std::uint32_t r = 2; r &lt; order; ++r) {
      for (std::uint32_t c = 2; c &lt; order; ++c) {
        (*term_matrix)(r, c) = x_pow[r + c - 3];
      }
    }
    (*term_matrix).block(0, 0, order, 2) = Eigen::MatrixXd::Zero(order, 2);
    (*term_matrix).block(0, 0, 2, order) = Eigen::MatrixXd::Zero(2, order);

  } else {
    for (std::uint32_t r = 3; r &lt; order; ++r) {
      for (std::uint32_t c = 3; c &lt; order; ++c) {
        (*term_matrix)(r, c) = x_pow[r + c - 5];
      }
    }
    (*term_matrix).block(0, 0, order, 3) = Eigen::MatrixXd::Zero(order, 3);
    (*term_matrix).block(0, 0, 3, order) = Eigen::MatrixXd::Zero(3, order);
  }
}</code>
		</source>
	</dup>
	<dup count="5">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(280, 0)" endLine="(309, 1)" clone_start="6" clone_end="12">
			<code function_name="ProtoOrganizer::GetJunctionObjectOverlapElements( const std::vector&lt;JunctionInternal&gt;&amp; junctions)">void ProtoOrganizer::GetJunctionObjectOverlapElements(
    const std::vector&lt;JunctionInternal&gt;&amp; junctions) {
  for (auto&amp; junction_internal : junctions) {
    std::string junction_id = junction_internal.junction.id().id();
    for (auto&amp; overlap_junction : junction_internal.overlap_with_junctions) {
      PbOverlap overlap;
      std::string overlap_id = CreateOverlapId();
      proto_data_.pb_junctions[junction_id].add_overlap_id()-&gt;set_id(
          overlap_id);
      overlap.mutable_id()-&gt;set_id(overlap_id);
      PbObjectOverlapInfo* object_overlap = overlap.add_object();
      object_overlap-&gt;mutable_id()-&gt;set_id(junction_id);
      std::string object_id = overlap_junction.object_id;
      object_overlap = overlap.add_object();
      object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
      if (proto_data_.pb_crosswalks.count(object_id) &gt; 0) {
        object_overlap-&gt;mutable_crosswalk_overlap_info();
        proto_data_.pb_crosswalks[object_id].add_overlap_id()-&gt;set_id(
            overlap_id);
      } else if (proto_data_.pb_clear_areas.count(object_id) &gt; 0) {
        object_overlap-&gt;mutable_clear_area_overlap_info();
        proto_data_.pb_clear_areas[object_id].add_overlap_id()-&gt;set_id(
            overlap_id);
      } else {
        continue;
      }
      proto_data_.pb_overlaps[overlap_id] = overlap;
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(228, 0)" endLine="(278, 1)" clone_start="18" clone_end="23">
			<code function_name="ProtoOrganizer::GetLaneLaneOverlapElements(const std::unordered_map&lt;std::pair&lt;std::string, std::string&gt;, OverlapWithLane, HashFunc&gt;&amp; lane_lane_overlaps)">void ProtoOrganizer::GetLaneLaneOverlapElements(
    const std::unordered_map&lt;std::pair&lt;std::string, std::string&gt;,
                             OverlapWithLane, HashFunc&gt;&amp; lane_lane_overlaps) {
  std::unordered_set&lt;std::string&gt; close_set;
  for (auto&amp; overlap_lane_pair : lane_lane_overlaps) {
    auto&amp; lane_id = overlap_lane_pair.first.first;
    auto&amp; overlap_lane = overlap_lane_pair.second;
    std::string object_id = overlap_lane.object_id;
    std::string unique_object_id = lane_id + "_" + object_id;
    if (close_set.count(unique_object_id) &gt; 0) {
      continue;
    }
    unique_object_id = object_id + "_" + lane_id;
    if (close_set.count(unique_object_id) &gt; 0) {
      continue;
    }
    close_set.insert(unique_object_id);
    PbOverlap overlap;
    std::string overlap_id = CreateOverlapId();
    proto_data_.pb_lanes[lane_id].add_overlap_id()-&gt;set_id(overlap_id);
    overlap.mutable_id()-&gt;set_id(overlap_id);
    PbObjectOverlapInfo* object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(lane_id);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_start_s(
        overlap_lane.start_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_end_s(overlap_lane.end_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_is_merge(
        overlap_lane.is_merge);
    object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
    if (proto_data_.pb_lanes.count(object_id) &lt;= 0) {
      AERROR &lt;&lt; "unknown overlap lane, id:" &lt;&lt; object_id;
      continue;
    }

    if (lane_lane_overlaps.count(make_pair(object_id, lane_id)) &lt;= 0) {
      AERROR &lt;&lt; "lane overlap is not symmetrical " &lt;&lt; overlap_id;
      continue;
    }
    auto&amp; lane_lane_overlap =
        lane_lane_overlaps.at(make_pair(object_id, lane_id));
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_start_s(
        lane_lane_overlap.start_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_end_s(
        lane_lane_overlap.end_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_is_merge(
        lane_lane_overlap.is_merge);
    proto_data_.pb_lanes[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    proto_data_.pb_overlaps[overlap_id] = overlap;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(195, 0)" endLine="(226, 1)" clone_start="10" clone_end="15">
			<code function_name="ProtoOrganizer::GetLaneJunctionOverlapElements(    const std::string&amp; lane_id, const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes)">void ProtoOrganizer::GetLaneJunctionOverlapElements(
    const std::string&amp; lane_id,
    const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes) {
  for (auto&amp; overlap_junction : overlap_with_lanes) {
    std::string object_id = overlap_junction.object_id;
    if (proto_data_.pb_junctions.count(object_id) &lt;= 0) {
      AINFO &lt;&lt; "cannot find junction object " &lt;&lt; object_id;
      continue;
    }
    PbOverlap overlap;
    std::string overlap_id = CreateOverlapId();
    proto_data_.pb_lanes[lane_id].add_overlap_id()-&gt;set_id(overlap_id);
    overlap.mutable_id()-&gt;set_id(overlap_id);
    PbObjectOverlapInfo* object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(lane_id);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_start_s(
        overlap_junction.start_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_end_s(
        overlap_junction.end_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_is_merge(
        overlap_junction.is_merge);
    object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
    if (proto_data_.pb_junctions.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_junction_overlap_info();
      proto_data_.pb_junctions[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    } else {
      AERROR &lt;&lt; "unknown junction overlap, id:" &lt;&lt; object_id;
    }
    proto_data_.pb_overlaps[overlap_id] = overlap;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(153, 0)" endLine="(193, 1)" clone_start="12" clone_end="17">
			<code function_name="ProtoOrganizer::GetLaneSignalOverlapElements(    const std::string&amp; lane_id, const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes)">void ProtoOrganizer::GetLaneSignalOverlapElements(
    const std::string&amp; lane_id,
    const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes) {
  for (auto&amp; overlap_signal : overlap_with_lanes) {
    std::string object_id = overlap_signal.object_id;
    if (proto_data_.pb_signals.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_stop_signs.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_yield_signs.count(object_id) &lt;= 0) {
      AINFO &lt;&lt; "cannot find signal object_id:" &lt;&lt; object_id;
      continue;
    }
    PbOverlap overlap;
    std::string overlap_id = CreateOverlapId();
    proto_data_.pb_lanes[lane_id].add_overlap_id()-&gt;set_id(overlap_id);
    overlap.mutable_id()-&gt;set_id(overlap_id);
    PbObjectOverlapInfo* object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(lane_id);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_start_s(
        overlap_signal.start_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_end_s(
        overlap_signal.end_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_is_merge(
        overlap_signal.is_merge);
    object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
    if (proto_data_.pb_signals.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_signal_overlap_info();
      proto_data_.pb_signals[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    } else if (proto_data_.pb_stop_signs.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_stop_sign_overlap_info();
      proto_data_.pb_stop_signs[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    } else if (proto_data_.pb_yield_signs.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_yield_sign_overlap_info();
      proto_data_.pb_yield_signs[object_id].add_overlap_id()-&gt;set_id(
          overlap_id);
    } else {
      AERROR &lt;&lt; "unknown signal, signal id:" &lt;&lt; object_id;
    }
    proto_data_.pb_overlaps[overlap_id] = overlap;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(111, 0)" endLine="(151, 1)" clone_start="11" clone_end="16">
			<code function_name="ProtoOrganizer::GetLaneObjectOverlapElements(const std::string&amp; lane_id, const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes)">void ProtoOrganizer::GetLaneObjectOverlapElements(
    const std::string&amp; lane_id,
    const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes) {
  for (auto&amp; overlap_object : overlap_with_lanes) {
    std::string object_id = overlap_object.object_id;
    if (proto_data_.pb_crosswalks.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_clear_areas.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_speed_bumps.count(object_id) &lt;= 0) {
      continue;
    }
    PbOverlap overlap;
    std::string overlap_id = CreateOverlapId();
    proto_data_.pb_lanes[lane_id].add_overlap_id()-&gt;set_id(overlap_id);
    overlap.mutable_id()-&gt;set_id(overlap_id);
    PbObjectOverlapInfo* object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(lane_id);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_start_s(
        overlap_object.start_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_end_s(
        overlap_object.end_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_is_merge(
        overlap_object.is_merge);
    object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
    if (proto_data_.pb_crosswalks.count(object_id) &gt; 0) {
      proto_data_.pb_crosswalks[object_id].add_overlap_id()-&gt;set_id(overlap_id);
      object_overlap-&gt;mutable_crosswalk_overlap_info();
    } else if (proto_data_.pb_clear_areas.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_clear_area_overlap_info();
      proto_data_.pb_clear_areas[object_id].add_overlap_id()-&gt;set_id(
          overlap_id);
    } else if (proto_data_.pb_speed_bumps.count(object_id)) {
      object_overlap-&gt;mutable_speed_bump_overlap_info();
      proto_data_.pb_speed_bumps[object_id].add_overlap_id()-&gt;set_id(
          overlap_id);
    } else {
      AERROR &lt;&lt; "unknown object, object id:" &lt;&lt; object_id;
    }
    proto_data_.pb_overlaps[overlap_id] = overlap;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\planning_util.cc" startLine="(169, 0)" endLine="(196, 1)" clone_start="16" clone_end="25">
			<code function_name="InterpolateUsingLinearApproximation(const TrajectoryPoint &amp;tp0,const TrajectoryPoint &amp;tp1, const double t)">TrajectoryPoint InterpolateUsingLinearApproximation(const TrajectoryPoint &amp;tp0,
                                                    const TrajectoryPoint &amp;tp1,
                                                    const double t) {
  const PathPoint &amp;pp0 = tp0.path_point();
  const PathPoint &amp;pp1 = tp1.path_point();
  double t0 = tp0.relative_time();
  double t1 = tp1.relative_time();

  TrajectoryPoint tp;
  tp.set_v(common::math::lerp(tp0.v(), t0, tp1.v(), t1, t));
  tp.set_a(common::math::lerp(tp0.a(), t0, tp1.a(), t1, t));
  tp.set_relative_time(t);

  PathPoint *path_point = tp.mutable_path_point();
  path_point-&gt;set_x(common::math::lerp(pp0.x(), t0, pp1.x(), t1, t));
  path_point-&gt;set_y(common::math::lerp(pp0.y(), t0, pp1.y(), t1, t));
  path_point-&gt;set_theta(
      common::math::lerp(pp0.theta(), t0, pp1.theta(), t1, t));
  path_point-&gt;set_kappa(
      common::math::lerp(pp0.kappa(), t0, pp1.kappa(), t1, t));
  path_point-&gt;set_dkappa(
      common::math::lerp(pp0.dkappa(), t0, pp1.dkappa(), t1, t));
  path_point-&gt;set_ddkappa(
      common::math::lerp(pp0.ddkappa(), t0, pp1.ddkappa(), t1, t));
  path_point-&gt;set_s(common::math::lerp(pp0.s(), t0, pp1.s(), t1, t));

  return tp;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\planning_util.cc" startLine="(169, 0)" endLine="(196, 1)" clone_start="15" clone_end="23">
			<code function_name="InterpolateUsingLinearApproximation(const TrajectoryPoint &amp;tp0,const TrajectoryPoint &amp;tp1, const double t)">TrajectoryPoint InterpolateUsingLinearApproximation(const TrajectoryPoint &amp;tp0,
                                                    const TrajectoryPoint &amp;tp1,
                                                    const double t) {
  const PathPoint &amp;pp0 = tp0.path_point();
  const PathPoint &amp;pp1 = tp1.path_point();
  double t0 = tp0.relative_time();
  double t1 = tp1.relative_time();

  TrajectoryPoint tp;
  tp.set_v(common::math::lerp(tp0.v(), t0, tp1.v(), t1, t));
  tp.set_a(common::math::lerp(tp0.a(), t0, tp1.a(), t1, t));
  tp.set_relative_time(t);

  PathPoint *path_point = tp.mutable_path_point();
  path_point-&gt;set_x(common::math::lerp(pp0.x(), t0, pp1.x(), t1, t));
  path_point-&gt;set_y(common::math::lerp(pp0.y(), t0, pp1.y(), t1, t));
  path_point-&gt;set_theta(
      common::math::lerp(pp0.theta(), t0, pp1.theta(), t1, t));
  path_point-&gt;set_kappa(
      common::math::lerp(pp0.kappa(), t0, pp1.kappa(), t1, t));
  path_point-&gt;set_dkappa(
      common::math::lerp(pp0.dkappa(), t0, pp1.dkappa(), t1, t));
  path_point-&gt;set_ddkappa(
      common::math::lerp(pp0.ddkappa(), t0, pp1.ddkappa(), t1, t));
  path_point-&gt;set_s(common::math::lerp(pp0.s(), t0, pp1.s(), t1, t));

  return tp;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\vehicle_controller.cc" startLine="(26, 0)" endLine="(29, 1)" clone_start="1" clone_end="4">
			<code function_name="VehicleController::driving_mode()">Chassis::DrivingMode VehicleController::driving_mode() {
  std::lock_guard&lt;std::mutex&gt; lock(mode_mutex_);
  return driving_mode_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(744, 0)" endLine="(747, 1)" clone_start="1" clone_end="4">
			<code function_name="LincolnController::chassis_error_code()">Chassis::ErrorCode LincolnController::chassis_error_code() {
  std::lock_guard&lt;std::mutex&gt; lock(chassis_error_code_mutex_);
  return chassis_error_code_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\vehicle_controller.cc" startLine="(31, 0)" endLine="(35, 1)" clone_start="1" clone_end="4">
			<code function_name="VehicleController::set_driving_mode( const Chassis::DrivingMode &amp;driving_mode)">void VehicleController::set_driving_mode(
    const Chassis::DrivingMode &amp;driving_mode) {
  std::lock_guard&lt;std::mutex&gt; lock(mode_mutex_);
  driving_mode_ = driving_mode;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(749, 0)" endLine="(753, 1)" clone_start="1" clone_end="4">
			<code function_name="LincolnController::set_chassis_error_code( const Chassis::ErrorCode &amp;error_code)">void LincolnController::set_chassis_error_code(
    const Chassis::ErrorCode &amp;error_code) {
  std::lock_guard&lt;std::mutex&gt; lock(chassis_error_code_mutex_);
  chassis_error_code_ = error_code;
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(28, 0)" endLine="(31, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle62::GetPeriod() const">uint32_t Throttle62::GetPeriod() const {
  static const uint32_t PERIOD = 20 * 1000;
  return PERIOD;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(26, 0)" endLine="(31, 1)" clone_start="1" clone_end="6">
			<code function_name="Steering64::GetPeriod() const">uint32_t Steering64::GetPeriod() const {
  // receive rate??
  // receive timeout would trigger fault, letting en=0 and etc.
  static const uint32_t PERIOD = 20 * 1000;
  return PERIOD;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(27, 0)" endLine="(31, 1)" clone_start="1" clone_end="5">
			<code function_name="Gear66::GetPeriod() const">uint32_t Gear66::GetPeriod() const {
  // on event, so value nonsense
  static const uint32_t PERIOD = 20 * 1000;
  return PERIOD;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(27, 0)" endLine="(30, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake60::GetPeriod() const">uint32_t Brake60::GetPeriod() const {
  static const uint32_t PERIOD = 20 * 1000;
  return PERIOD;
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(33, 0)" endLine="(39, 1)" clone_start="1" clone_end="2">
			<code function_name="Throttle62::UpdateData(uint8_t *data)">void Throttle62::UpdateData(uint8_t *data) {
  set_pedal_p(data, pedal_cmd_);
  set_enable_p(data, pedal_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_ignore_driver_override_p(data, ignore_driver_override_);
  set_watchdog_counter_p(data, watchdog_counter_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(33, 0)" endLine="(41, 1)" clone_start="1" clone_end="2">
			<code function_name="Steering64::UpdateData(uint8_t *data)">void Steering64::UpdateData(uint8_t *data) {
  set_steering_angle_p(data, steering_angle_);
  set_enable_p(data, steering_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_ignore_driver_override_p(data, ignore_driver_override_);
  set_steering_angle_speed_p(data, steering_angle_speed_);
  set_watchdog_counter_p(data, watchdog_counter_);
  set_disable_audible_warning_p(data, disable_audible_warning_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(33, 0)" endLine="(36, 1)" clone_start="1" clone_end="2">
			<code function_name="Gear66::UpdateData(uint8_t *data)">void Gear66::UpdateData(uint8_t *data) {
  set_gear_p(data, gear_);
  set_clear_driver_override_flag_p(data);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(32, 0)" endLine="(38, 1)" clone_start="1" clone_end="2">
			<code function_name="Brake60::UpdateData(uint8_t *data)">void Brake60::UpdateData(uint8_t *data) {
  set_pedal_p(data, pedal_cmd_);
  set_boo_cmd_p(data, boo_cmd_);
  set_enable_p(data, pedal_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_watchdog_counter_p(data, watchdog_counter_);
}</code>
		</source>
	</dup>
	<dup count="10">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="226" clone_end="233">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="184" clone_end="193">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="173" clone_end="182">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="162" clone_end="171">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="151" clone_end="160">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="140" clone_end="149">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="111" clone_end="118">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="78" clone_end="86">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="67" clone_end="76">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="56" clone_end="65">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\indexed_queue.h" startLine="(37, 2)" endLine="(44, 3)" clone_start="1" clone_end="6">
			<code function_name="Find(const I id) const">  const T *Find(const I id) const {
    auto iter = map_.find(id);
    if (iter == map_.end()) {
      return nullptr;
    } else {
      return iter-&gt;second.get();
    }
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\indexed_list.h" startLine="(74, 2)" endLine="(81, 3)" clone_start="1" clone_end="6">
			<code function_name="Find(const I id)">  T* Find(const I id) {
    auto iter = object_dict_.find(id);
    if (iter == object_dict_.end()) {
      return nullptr;
    } else {
      return iter-&gt;second.get();
    }
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\calibration\republish_msg\republish_msg.cc" startLine="(52, 0)" endLine="(87, 1)" clone_start="25" clone_end="30">
			<code function_name="RepublishMsg::OnGps(const localization::Gps&amp; msg)">void RepublishMsg::OnGps(const localization::Gps&amp; msg) {
  if (msg.has_localization()) {
    const auto pose_msg = msg.localization();

    Eigen::Quaterniond rotation(
        pose_msg.orientation().qw(), pose_msg.orientation().qx(),
        pose_msg.orientation().qy(), pose_msg.orientation().qz());
    Eigen::Translation3d translation(pose_msg.position().x(),
                                     pose_msg.position().y(),
                                     pose_msg.position().z());
    Eigen::Affine3d pose = translation * rotation;

    if (is_first_gps_msg_) {
      is_first_gps_msg_ = false;
      offset_ = pose.inverse();
    }

    Eigen::Affine3d pub_pose = offset_ * pose;
    Eigen::Quaterniond pub_rot(pub_pose.rotation());
    Eigen::Translation3d pub_trans(pub_pose.translation());

    calibration::republish_msg::RelativeOdometry pub_msg;
    pub_msg.mutable_header()-&gt;set_timestamp_sec(msg.header().timestamp_sec());
    pub_msg.mutable_orientation()-&gt;set_qw(pub_rot.w());
    pub_msg.mutable_orientation()-&gt;set_qx(pub_rot.x());
    pub_msg.mutable_orientation()-&gt;set_qy(pub_rot.y());
    pub_msg.mutable_orientation()-&gt;set_qz(pub_rot.z());
    pub_msg.mutable_position()-&gt;set_x(pub_trans.x());
    pub_msg.mutable_position()-&gt;set_y(pub_trans.y());
    pub_msg.mutable_position()-&gt;set_z(pub_trans.z());

    pub_msg.set_position_type(position_type_);

    AdapterManager::PublishRelativeOdometry(pub_msg);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\calibration\republish_msg\republish_msg.cc" startLine="(52, 0)" endLine="(87, 1)" clone_start="24" clone_end="29">
			<code function_name="RepublishMsg::OnGps(const localization::Gps&amp; msg)">void RepublishMsg::OnGps(const localization::Gps&amp; msg) {
  if (msg.has_localization()) {
    const auto pose_msg = msg.localization();

    Eigen::Quaterniond rotation(
        pose_msg.orientation().qw(), pose_msg.orientation().qx(),
        pose_msg.orientation().qy(), pose_msg.orientation().qz());
    Eigen::Translation3d translation(pose_msg.position().x(),
                                     pose_msg.position().y(),
                                     pose_msg.position().z());
    Eigen::Affine3d pose = translation * rotation;

    if (is_first_gps_msg_) {
      is_first_gps_msg_ = false;
      offset_ = pose.inverse();
    }

    Eigen::Affine3d pub_pose = offset_ * pose;
    Eigen::Quaterniond pub_rot(pub_pose.rotation());
    Eigen::Translation3d pub_trans(pub_pose.translation());

    calibration::republish_msg::RelativeOdometry pub_msg;
    pub_msg.mutable_header()-&gt;set_timestamp_sec(msg.header().timestamp_sec());
    pub_msg.mutable_orientation()-&gt;set_qw(pub_rot.w());
    pub_msg.mutable_orientation()-&gt;set_qx(pub_rot.x());
    pub_msg.mutable_orientation()-&gt;set_qy(pub_rot.y());
    pub_msg.mutable_orientation()-&gt;set_qz(pub_rot.z());
    pub_msg.mutable_position()-&gt;set_x(pub_trans.x());
    pub_msg.mutable_position()-&gt;set_y(pub_trans.y());
    pub_msg.mutable_position()-&gt;set_z(pub_trans.z());

    pub_msg.set_position_type(position_type_);

    AdapterManager::PublishRelativeOdometry(pub_msg);
  }
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(216, 0)" endLine="(259, 1)" clone_start="32" clone_end="43">
			<code function_name="SignalsXmlParser::ParseYieldSigns(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;YieldSignInternal&gt;* yield_signs)">Status SignalsXmlParser::ParseYieldSigns(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;YieldSignInternal&gt;* yield_signs) {
  CHECK_NOTNULL(yield_signs);

  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "yieldSign") {
      PbYieldSign yield_sign;
      yield_sign.mutable_id()-&gt;set_id(object_id);
      YieldSignInternal yield_sign_internal;
      yield_sign_internal.id = object_id;
      yield_sign_internal.yield_sign = yield_sign;
      auto sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                            &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          yield_sign_internal.stop_line_ids.insert(stop_line_id);

          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      yield_signs-&gt;emplace_back(yield_sign_internal);
    }

    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(171, 0)" endLine="(214, 1)" clone_start="32" clone_end="43">
			<code function_name="SignalsXmlParser::ParseStopSigns(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;StopSignInternal&gt;* stop_signs)">Status SignalsXmlParser::ParseStopSigns(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;StopSignInternal&gt;* stop_signs) {
  CHECK_NOTNULL(stop_signs);

  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "stopSign") {
      PbStopSign stop_sign;
      stop_sign.mutable_id()-&gt;set_id(object_id);

      StopSignInternal stop_sign_internal;
      stop_sign_internal.stop_sign = stop_sign;

      auto sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          stop_sign_internal.stop_line_ids.insert(stop_line_id);

          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      stop_signs-&gt;emplace_back(stop_sign_internal);
    }

    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(26, 0)" endLine="(114, 1)" clone_start="79" clone_end="88">
			<code function_name="SignalsXmlParser::ParseTrafficLights(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;TrafficLightInternal&gt;* traffic_lights)">Status SignalsXmlParser::ParseTrafficLights(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;TrafficLightInternal&gt;* traffic_lights) {
  CHECK_NOTNULL(traffic_lights);
  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "trafficLight") {
      PbSignal traffic_light;
      traffic_light.mutable_id()-&gt;set_id(object_id);
      std::string layout_type;
      int checker = UtilXmlParser::QueryStringAttribute(
          *signal_node, "layoutType", &amp;layout_type);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse signal layout type.";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      PbSignalType signal_layout_type;
      ToPbSignalType(layout_type, &amp;signal_layout_type);
      traffic_light.set_type(signal_layout_type);

      PbPolygon* polygon = traffic_light.mutable_boundary();
      auto outline_node = signal_node-&gt;FirstChildElement("outline");
      if (outline_node == nullptr) {
        std::string err_msg = "Error parse signal outline";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseOutline(*outline_node, polygon));
      auto sub_node = signal_node-&gt;FirstChildElement("subSignal");
      if (sub_node == nullptr) {
        std::string err_msg = "Error parse sub signal.";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      while (sub_node) {
        std::string sub_signal_id;
        std::string sub_signal_xml_type;
        checker = UtilXmlParser::QueryStringAttribute(*sub_node, "type",
                                                      &amp;sub_signal_xml_type);
        checker += UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                       &amp;sub_signal_id);
        if (checker != tinyxml2::XML_SUCCESS) {
          std::string err_msg = "Error parse sub signal layout type.";
          return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
        }

        PbSubSignal* sub_signal = traffic_light.add_subsignal();
        PbSubSignalType sub_signal_type;
        ToPbSubSignalType(sub_signal_xml_type, &amp;sub_signal_type);
        sub_signal-&gt;mutable_id()-&gt;set_id(sub_signal_id);
        sub_signal-&gt;set_type(sub_signal_type);
        PbPoint3D* pt = sub_signal-&gt;mutable_location();
        RETURN_IF_ERROR(UtilXmlParser::ParsePoint(*sub_node, pt));

        sub_node = sub_node-&gt;NextSiblingElement("subSignal");
      }

      TrafficLightInternal trafficlight_internal;
      trafficlight_internal.id = object_id;
      trafficlight_internal.traffic_light = traffic_light;

      sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                            &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          trafficlight_internal.stop_line_ids.insert(stop_line_id);
          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      traffic_lights-&gt;emplace_back(trafficlight_internal);
    }
    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\integral.cc" startLine="(50, 0)" endLine="(76, 1)" clone_start="14" clone_end="19">
			<code function_name="IntegrateByGaussLegendre(const std::function&lt;double(double)&gt;&amp; func,const double lower_bound, const double upper_bound)">double IntegrateByGaussLegendre(const std::function&lt;double(double)&gt;&amp; func,
                                const double lower_bound,
                                const double upper_bound) {
  const double t = (upper_bound - lower_bound) * 0.5;
  const double m = (upper_bound + lower_bound) * 0.5;

  std::array&lt;double, 5&gt; w;
  w[0] = 0.5688888889;
  w[1] = 0.4786286705;
  w[2] = 0.4786286705;
  w[3] = 0.2369268851;
  w[4] = 0.2369268851;

  std::array&lt;double, 5&gt; x;
  x[0] = 0.0;
  x[1] = 0.5384693101;
  x[2] = -0.5384693101;
  x[3] = 0.9061798459;
  x[4] = -0.9061798459;

  double integral = 0.0;
  for (size_t i = 0; i &lt; 5; ++i) {
    integral += w[i] * func(t * x[i] + m);
  }

  return integral * t;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\integral.cc" startLine="(50, 0)" endLine="(76, 1)" clone_start="7" clone_end="12">
			<code function_name="IntegrateByGaussLegendre(const std::function&lt;double(double)&gt;&amp; func,const double lower_bound, const double upper_bound)">double IntegrateByGaussLegendre(const std::function&lt;double(double)&gt;&amp; func,
                                const double lower_bound,
                                const double upper_bound) {
  const double t = (upper_bound - lower_bound) * 0.5;
  const double m = (upper_bound + lower_bound) * 0.5;

  std::array&lt;double, 5&gt; w;
  w[0] = 0.5688888889;
  w[1] = 0.4786286705;
  w[2] = 0.4786286705;
  w[3] = 0.2369268851;
  w[4] = 0.2369268851;

  std::array&lt;double, 5&gt; x;
  x[0] = 0.0;
  x[1] = 0.5384693101;
  x[2] = -0.5384693101;
  x[3] = 0.9061798459;
  x[4] = -0.9061798459;

  double integral = 0.0;
  for (size_t i = 0; i &lt; 5; ++i) {
    integral += w[i] * func(t * x[i] + m);
  }

  return integral * t;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(338, 0)" endLine="(362, 1)" clone_start="18" clone_end="24">
			<code function_name="Obstacle::SetLengthWidthHeight( const PerceptionObstacle&amp; perception_obstacle, Feature* feature)">void Obstacle::SetLengthWidthHeight(
    const PerceptionObstacle&amp; perception_obstacle, Feature* feature) {
  double length = 0.0;
  double width = 0.0;
  double height = 0.0;

  if (perception_obstacle.has_length()) {
    length = perception_obstacle.length();
  }
  if (perception_obstacle.has_width()) {
    width = perception_obstacle.width();
  }
  if (perception_obstacle.has_height()) {
    height = perception_obstacle.height();
  }

  feature-&gt;set_length(length);
  feature-&gt;set_width(width);
  feature-&gt;set_height(height);

  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has dimension [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; length &lt;&lt; ", " &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; width &lt;&lt; ", " &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; height &lt;&lt; "].";
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(245, 0)" endLine="(280, 1)" clone_start="25" clone_end="31">
			<code function_name="Obstacle::SetVelocity(const PerceptionObstacle&amp; perception_obstacle, Feature* feature)">void Obstacle::SetVelocity(const PerceptionObstacle&amp; perception_obstacle,
                           Feature* feature) {
  double velocity_x = 0.0;
  double velocity_y = 0.0;
  double velocity_z = 0.0;

  if (perception_obstacle.has_velocity()) {
    if (perception_obstacle.velocity().has_x()) {
      velocity_x = perception_obstacle.velocity().x();
    }
    if (perception_obstacle.velocity().has_y()) {
      velocity_y = perception_obstacle.velocity().y();
    }
    if (perception_obstacle.velocity().has_z()) {
      velocity_z = perception_obstacle.velocity().z();
    }
  }

  feature-&gt;mutable_velocity()-&gt;set_x(velocity_x);
  feature-&gt;mutable_velocity()-&gt;set_y(velocity_y);
  feature-&gt;mutable_velocity()-&gt;set_z(velocity_z);

  double speed = std::hypot(std::hypot(velocity_x, velocity_y), velocity_z);
  double velocity_heading = std::atan2(velocity_y, velocity_x);
  feature-&gt;set_velocity_heading(velocity_heading);
  feature-&gt;set_speed(speed);

  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has velocity [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; velocity_x &lt;&lt; ", " &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; velocity_y &lt;&lt; ", " &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; velocity_z &lt;&lt; "]";
  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has velocity heading [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; velocity_heading &lt;&lt; "] ";
  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has speed [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; speed &lt;&lt; "].";
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\lib\calibration.cpp" startLine="(72, 0)" endLine="(108, 1)" clone_start="5" clone_end="10">
			<code function_name="operator&gt;&gt;(const YAML::Node&amp; node, std::pair&lt;int, LaserCorrection&gt;&amp; correction)">void operator&gt;&gt;(const YAML::Node&amp; node,
                std::pair&lt;int, LaserCorrection&gt;&amp; correction) {
  node[LASER_ID] &gt;&gt; correction.first;
  node[ROT_CORRECTION] &gt;&gt; correction.second.rot_correction;
  node[VERT_CORRECTION] &gt;&gt; correction.second.vert_correction;
  node[DIST_CORRECTION] &gt;&gt; correction.second.dist_correction;
  node[DIST_CORRECTION_X] &gt;&gt; correction.second.dist_correction_x;
  node[DIST_CORRECTION_Y] &gt;&gt; correction.second.dist_correction_y;
  node[VERT_OFFSET_CORRECTION] &gt;&gt; correction.second.vert_offset_correction;
  node[HORIZ_OFFSET_CORRECTION] &gt;&gt; correction.second.horiz_offset_correction;

  if (node[MAX_INTENSITY]) {
    node[MAX_INTENSITY] &gt;&gt; correction.second.max_intensity;
  } else {
    correction.second.max_intensity = 255;
  }

  if (node[MIN_INTENSITY]) {
    node[MIN_INTENSITY] &gt;&gt; correction.second.min_intensity;
  } else {
    correction.second.min_intensity = 0;
  }

  node[FOCAL_DISTANCE] &gt;&gt; correction.second.focal_distance;
  node[FOCAL_SLOPE] &gt;&gt; correction.second.focal_slope;

  // Calculate cached values
  correction.second.cos_rot_correction = cosf(correction.second.rot_correction);
  correction.second.sin_rot_correction = sinf(correction.second.rot_correction);
  correction.second.cos_vert_correction =
      cosf(correction.second.vert_correction);
  correction.second.sin_vert_correction =
      sinf(correction.second.vert_correction);
  correction.second.focal_offset =
      256 * pow(1 - correction.second.focal_distance / 13100, 2);
  correction.second.laser_ring = 0;  // clear initially (set later)
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\lib\calibration.cpp" startLine="(72, 0)" endLine="(108, 1)" clone_start="4" clone_end="9">
			<code function_name="operator&gt;&gt;(const YAML::Node&amp; node, std::pair&lt;int, LaserCorrection&gt;&amp; correction)">void operator&gt;&gt;(const YAML::Node&amp; node,
                std::pair&lt;int, LaserCorrection&gt;&amp; correction) {
  node[LASER_ID] &gt;&gt; correction.first;
  node[ROT_CORRECTION] &gt;&gt; correction.second.rot_correction;
  node[VERT_CORRECTION] &gt;&gt; correction.second.vert_correction;
  node[DIST_CORRECTION] &gt;&gt; correction.second.dist_correction;
  node[DIST_CORRECTION_X] &gt;&gt; correction.second.dist_correction_x;
  node[DIST_CORRECTION_Y] &gt;&gt; correction.second.dist_correction_y;
  node[VERT_OFFSET_CORRECTION] &gt;&gt; correction.second.vert_offset_correction;
  node[HORIZ_OFFSET_CORRECTION] &gt;&gt; correction.second.horiz_offset_correction;

  if (node[MAX_INTENSITY]) {
    node[MAX_INTENSITY] &gt;&gt; correction.second.max_intensity;
  } else {
    correction.second.max_intensity = 255;
  }

  if (node[MIN_INTENSITY]) {
    node[MIN_INTENSITY] &gt;&gt; correction.second.min_intensity;
  } else {
    correction.second.min_intensity = 0;
  }

  node[FOCAL_DISTANCE] &gt;&gt; correction.second.focal_distance;
  node[FOCAL_SLOPE] &gt;&gt; correction.second.focal_slope;

  // Calculate cached values
  correction.second.cos_rot_correction = cosf(correction.second.rot_correction);
  correction.second.sin_rot_correction = sinf(correction.second.rot_correction);
  correction.second.cos_vert_correction =
      cosf(correction.second.vert_correction);
  correction.second.sin_vert_correction =
      sinf(correction.second.vert_correction);
  correction.second.focal_offset =
      256 * pow(1 - correction.second.focal_distance / 13100, 2);
  correction.second.laser_ring = 0;  // clear initially (set later)
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(41, 0)" endLine="(47, 1)" clone_start="3" clone_end="7">
			<code function_name="Throttle62::Reset()">void Throttle62::Reset() {
  pedal_cmd_ = 0.0;
  pedal_enable_ = false;
  clear_driver_override_flag_ = false;
  ignore_driver_override_ = false;
  watchdog_counter_ = 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(40, 0)" endLine="(47, 1)" clone_start="4" clone_end="8">
			<code function_name="Brake60::Reset()">void Brake60::Reset() {
  pedal_cmd_ = 0.0;
  boo_cmd_ = false;
  pedal_enable_ = false;
  clear_driver_override_flag_ = false;
  ignore_driver_override_ = false;
  watchdog_counter_ = 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(49, 0)" endLine="(52, 1)" clone_start="1" clone_end="2">
			<code function_name="Throttle62::set_pedal(double pedal)">Throttle62 *Throttle62::set_pedal(double pedal) {
  pedal_cmd_ = pedal;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(49, 0)" endLine="(57, 1)" clone_start="1" clone_end="2">
			<code function_name="Brake60::set_pedal(double pedal)">Brake60 *Brake60::set_pedal(double pedal) {
  pedal_cmd_ = pedal;
  if (pedal_cmd_ &lt; 1e-3) {
    disable_boo_cmd();
  } else {
    enable_boo_cmd();
  }
  return this;
}</code>
		</source>
	</dup>
	<dup count="5">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.cc" startLine="(137, 0)" endLine="(171, 1)" clone_start="5" clone_end="10">
			<code function_name="Path::InitPoints()">void Path::InitPoints() {
  num_points_ = static_cast&lt;int&gt;(path_points_.size());
  CHECK_GE(num_points_, 2);

  accumulated_s_.clear();
  accumulated_s_.reserve(num_points_);
  segments_.clear();
  segments_.reserve(num_points_);
  unit_directions_.clear();
  unit_directions_.reserve(num_points_);
  double s = 0.0;
  for (int i = 0; i &lt; num_points_; ++i) {
    accumulated_s_.push_back(s);
    Vec2d heading;
    if (i + 1 &gt;= num_points_) {
      heading = path_points_[i] - path_points_[i - 1];
    } else {
      segments_.emplace_back(path_points_[i], path_points_[i + 1]);
      heading = path_points_[i + 1] - path_points_[i];
      // TODO(lianglia_apollo):
      // use heading.length when all adjacent lanes are guarantee to be
      // connected.
      s += heading.Length();
    }
    heading.Normalize();
    unit_directions_.push_back(heading);
  }
  length_ = s;
  num_sample_points_ = static_cast&lt;int&gt;(length_ / kSampleDistance) + 1;
  num_segments_ = num_points_ - 1;

  CHECK_EQ(accumulated_s_.size(), num_points_);
  CHECK_EQ(unit_directions_.size(), num_points_);
  CHECK_EQ(segments_.size(), num_segments_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(587, 0)" endLine="(608, 1)" clone_start="16" clone_end="21">
			<code function_name="HDMapImpl::Clear()">void HDMapImpl::Clear() {
  map_.Clear();
  lane_table_.clear();
  junction_table_.clear();
  signal_table_.clear();
  crosswalk_table_.clear();
  stop_sign_table_.clear();
  yield_sign_table_.clear();
  overlap_table_.clear();
  lane_segment_boxes_.clear();
  lane_segment_kdtree_.reset(nullptr);
  junction_polygon_boxes_.clear();
  junction_polygon_kdtree_.reset(nullptr);
  crosswalk_polygon_boxes_.clear();
  crosswalk_polygon_kdtree_.reset(nullptr);
  signal_segment_boxes_.clear();
  signal_segment_kdtree_.reset(nullptr);
  stop_sign_segment_boxes_.clear();
  stop_sign_segment_kdtree_.reset(nullptr);
  yield_sign_segment_boxes_.clear();
  yield_sign_segment_kdtree_.reset(nullptr);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(587, 0)" endLine="(608, 1)" clone_start="14" clone_end="19">
			<code function_name="HDMapImpl::Clear()">void HDMapImpl::Clear() {
  map_.Clear();
  lane_table_.clear();
  junction_table_.clear();
  signal_table_.clear();
  crosswalk_table_.clear();
  stop_sign_table_.clear();
  yield_sign_table_.clear();
  overlap_table_.clear();
  lane_segment_boxes_.clear();
  lane_segment_kdtree_.reset(nullptr);
  junction_polygon_boxes_.clear();
  junction_polygon_kdtree_.reset(nullptr);
  crosswalk_polygon_boxes_.clear();
  crosswalk_polygon_kdtree_.reset(nullptr);
  signal_segment_boxes_.clear();
  signal_segment_kdtree_.reset(nullptr);
  stop_sign_segment_boxes_.clear();
  stop_sign_segment_kdtree_.reset(nullptr);
  yield_sign_segment_boxes_.clear();
  yield_sign_segment_kdtree_.reset(nullptr);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(587, 0)" endLine="(608, 1)" clone_start="12" clone_end="17">
			<code function_name="HDMapImpl::Clear()">void HDMapImpl::Clear() {
  map_.Clear();
  lane_table_.clear();
  junction_table_.clear();
  signal_table_.clear();
  crosswalk_table_.clear();
  stop_sign_table_.clear();
  yield_sign_table_.clear();
  overlap_table_.clear();
  lane_segment_boxes_.clear();
  lane_segment_kdtree_.reset(nullptr);
  junction_polygon_boxes_.clear();
  junction_polygon_kdtree_.reset(nullptr);
  crosswalk_polygon_boxes_.clear();
  crosswalk_polygon_kdtree_.reset(nullptr);
  signal_segment_boxes_.clear();
  signal_segment_kdtree_.reset(nullptr);
  stop_sign_segment_boxes_.clear();
  stop_sign_segment_kdtree_.reset(nullptr);
  yield_sign_segment_boxes_.clear();
  yield_sign_segment_kdtree_.reset(nullptr);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(587, 0)" endLine="(608, 1)" clone_start="10" clone_end="15">
			<code function_name="HDMapImpl::Clear()">void HDMapImpl::Clear() {
  map_.Clear();
  lane_table_.clear();
  junction_table_.clear();
  signal_table_.clear();
  crosswalk_table_.clear();
  stop_sign_table_.clear();
  yield_sign_table_.clear();
  overlap_table_.clear();
  lane_segment_boxes_.clear();
  lane_segment_kdtree_.reset(nullptr);
  junction_polygon_boxes_.clear();
  junction_polygon_kdtree_.reset(nullptr);
  crosswalk_polygon_boxes_.clear();
  crosswalk_polygon_kdtree_.reset(nullptr);
  signal_segment_boxes_.clear();
  signal_segment_kdtree_.reset(nullptr);
  stop_sign_segment_boxes_.clear();
  stop_sign_segment_kdtree_.reset(nullptr);
  yield_sign_segment_boxes_.clear();
  yield_sign_segment_kdtree_.reset(nullptr);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.h" startLine="(32, 4)" endLine="(35, 5)" clone_start="1" clone_end="4">
			<code function_name="Init() override">    bool Init() override {
        // Do something.
        return true;
    }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(137, 2)" endLine="(139, 3)" clone_start="1" clone_end="3">
			<code function_name="Init() override">  bool Init() override {
    return result_init_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(111, 2)" endLine="(113, 3)" clone_start="1" clone_end="3">
			<code function_name="Init() override">  bool Init() override {
    return result_init_;
  }</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.h" startLine="(41, 4)" endLine="(43, 5)" clone_start="1" clone_end="3">
			<code function_name="name() const override">    std::string name() const override {
        return "MinBoxObjectBuilder";
    }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(144, 2)" endLine="(146, 3)" clone_start="1" clone_end="3">
			<code function_name="name() const override">  std::string name() const override {
    return "DummyObjectFilter";
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(118, 2)" endLine="(120, 3)" clone_start="1" clone_end="3">
			<code function_name="name() const override">  std::string name() const override {
    return "DummyObjectBuilder";
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\qp_spline_path\qp_spline_path_generator.cc" startLine="(40, 0)" endLine="(53, 1)" clone_start="8" clone_end="13">
			<code function_name="QpSplinePathGenerator::QpSplinePathGenerator(const ReferenceLine&amp; reference_line, const QpSplinePathConfig&amp; qp_spline_path_config)">QpSplinePathGenerator::QpSplinePathGenerator(
    const ReferenceLine&amp; reference_line,
    const QpSplinePathConfig&amp; qp_spline_path_config)
    : reference_line_(reference_line),
      qp_spline_path_config_(qp_spline_path_config) {
  CHECK_GE(qp_spline_path_config_.regularization_weight(), 0.0)
      &lt;&lt; "regularization_weight should NOT be negative.";
  CHECK_GE(qp_spline_path_config_.derivative_weight(), 0.0)
      &lt;&lt; "derivative_weight should NOT be negative.";
  CHECK_GE(qp_spline_path_config_.second_derivative_weight(), 0.0)
      &lt;&lt; "second_derivative_weight should NOT be negative.";
  CHECK_GE(qp_spline_path_config_.third_derivative_weight(), 0.0)
      &lt;&lt; "third_derivative_weight should NOT be negative.";
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\qp_spline_path\qp_spline_path_generator.cc" startLine="(40, 0)" endLine="(53, 1)" clone_start="6" clone_end="11">
			<code function_name="QpSplinePathGenerator::QpSplinePathGenerator(const ReferenceLine&amp; reference_line, const QpSplinePathConfig&amp; qp_spline_path_config)">QpSplinePathGenerator::QpSplinePathGenerator(
    const ReferenceLine&amp; reference_line,
    const QpSplinePathConfig&amp; qp_spline_path_config)
    : reference_line_(reference_line),
      qp_spline_path_config_(qp_spline_path_config) {
  CHECK_GE(qp_spline_path_config_.regularization_weight(), 0.0)
      &lt;&lt; "regularization_weight should NOT be negative.";
  CHECK_GE(qp_spline_path_config_.derivative_weight(), 0.0)
      &lt;&lt; "derivative_weight should NOT be negative.";
  CHECK_GE(qp_spline_path_config_.second_derivative_weight(), 0.0)
      &lt;&lt; "second_derivative_weight should NOT be negative.";
  CHECK_GE(qp_spline_path_config_.third_derivative_weight(), 0.0)
      &lt;&lt; "third_derivative_weight should NOT be negative.";
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6d.cc" startLine="(59, 0)" endLine="(83, 1)" clone_start="12" clone_end="18">
			<code function_name="Gps6d::longitude(const std::uint8_t *bytes, int32_t length) const">double Gps6d::longitude(const std::uint8_t *bytes, int32_t length) const {
  Byte frame_0(bytes + 7);
  int32_t value = frame_0.get_byte(0, 7);

  Byte frame_1(bytes + 6);
  int32_t t = frame_1.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_2(bytes + 5);
  t = frame_2.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_3(bytes + 4);
  t = frame_3.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  if (value &gt; 0x3FFFFFFF) {
    value -= 0x80000000;
  }

  return value * (1.000000 / 3.000000) * 1e-6;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6d.cc" startLine="(59, 0)" endLine="(83, 1)" clone_start="7" clone_end="13">
			<code function_name="Gps6d::longitude(const std::uint8_t *bytes, int32_t length) const">double Gps6d::longitude(const std::uint8_t *bytes, int32_t length) const {
  Byte frame_0(bytes + 7);
  int32_t value = frame_0.get_byte(0, 7);

  Byte frame_1(bytes + 6);
  int32_t t = frame_1.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_2(bytes + 5);
  t = frame_2.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_3(bytes + 4);
  t = frame_3.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  if (value &gt; 0x3FFFFFFF) {
    value -= 0x80000000;
  }

  return value * (1.000000 / 3.000000) * 1e-6;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6d.cc" startLine="(33, 0)" endLine="(57, 1)" clone_start="7" clone_end="13">
			<code function_name="Gps6d::latitude(const std::uint8_t *bytes, int32_t length) const">double Gps6d::latitude(const std::uint8_t *bytes, int32_t length) const {
  Byte frame_0(bytes + 3);
  int32_t value = frame_0.get_byte(0, 7);

  Byte frame_1(bytes + 2);
  int32_t t = frame_1.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_2(bytes + 1);
  t = frame_2.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_3(bytes);
  t = frame_3.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  if (value &gt; 0x3FFFFFFF) {
    value -= 0x80000000;
  }

  return value * (1.000000 / 3.000000) * 1e-6;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(320, 0)" endLine="(341, 1)" clone_start="5" clone_end="12">
			<code function_name="LincolnController::EnableSpeedOnlyMode()">ErrorCode LincolnController::EnableSpeedOnlyMode() {
  if (driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
      driving_mode() == Chassis::AUTO_SPEED_ONLY) {
    set_driving_mode(Chassis::AUTO_SPEED_ONLY);
    AINFO &lt;&lt; "Already in AUTO_SPEED_ONLY mode";
    return ErrorCode::OK;
  }
  brake_60_-&gt;set_enable();
  throttle_62_-&gt;set_enable();
  steering_64_-&gt;set_disable();

  can_sender_-&gt;Update();
  if (CheckResponse(CHECK_RESPONSE_SPEED_UNIT_FLAG, true) == false) {
    AERROR &lt;&lt; "Failed to switch to AUTO_STEER_ONLY mode.";
    Emergency();
    return ErrorCode::CANBUS_ERROR;
  } else {
    set_driving_mode(Chassis::AUTO_SPEED_ONLY);
    AINFO &lt;&lt; "Switch to AUTO_SPEED_ONLY mode ok.";
    return ErrorCode::OK;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(297, 0)" endLine="(318, 1)" clone_start="5" clone_end="12">
			<code function_name="LincolnController::EnableSteeringOnlyMode()">ErrorCode LincolnController::EnableSteeringOnlyMode() {
  if (driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
      driving_mode() == Chassis::AUTO_STEER_ONLY) {
    set_driving_mode(Chassis::AUTO_STEER_ONLY);
    AINFO &lt;&lt; "Already in AUTO_STEER_ONLY mode";
    return ErrorCode::OK;
  }
  brake_60_-&gt;set_disable();
  throttle_62_-&gt;set_disable();
  steering_64_-&gt;set_enable();

  can_sender_-&gt;Update();
  if (CheckResponse(CHECK_RESPONSE_STEER_UNIT_FLAG, true) == false) {
    AERROR &lt;&lt; "Failed to switch to AUTO_STEER_ONLY mode.";
    Emergency();
    return ErrorCode::CANBUS_ERROR;
  } else {
    set_driving_mode(Chassis::AUTO_STEER_ONLY);
    AINFO &lt;&lt; "Switch to AUTO_STEER_ONLY mode ok.";
    return ErrorCode::OK;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(265, 0)" endLine="(286, 1)" clone_start="3" clone_end="10">
			<code function_name="LincolnController::EnableAutoMode()">ErrorCode LincolnController::EnableAutoMode() {
  if (driving_mode() == Chassis::COMPLETE_AUTO_DRIVE) {
    AINFO &lt;&lt; "already in COMPLETE_AUTO_DRIVE mode";
    return ErrorCode::OK;
  }
  brake_60_-&gt;set_enable();
  throttle_62_-&gt;set_enable();
  steering_64_-&gt;set_enable();

  can_sender_-&gt;Update();
  const int32_t flag =
      CHECK_RESPONSE_STEER_UNIT_FLAG | CHECK_RESPONSE_SPEED_UNIT_FLAG;
  if (!CheckResponse(flag, true)) {
    AERROR &lt;&lt; "Failed to switch to COMPLETE_AUTO_DRIVE mode.";
    Emergency();
    return ErrorCode::CANBUS_ERROR;
  } else {
    set_driving_mode(Chassis::COMPLETE_AUTO_DRIVE);
    AINFO &lt;&lt; "Switch to COMPLETE_AUTO_DRIVE mode ok.";
    return ErrorCode::OK;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(717, 0)" endLine="(783, 1)" clone_start="45" clone_end="50">
			<code function_name="Obstacle::SetCurrentLanes(Feature* feature)">void Obstacle::SetCurrentLanes(Feature* feature) {
  PredictionMap* map = PredictionMap::instance();

  Eigen::Vector2d point(feature-&gt;position().x(), feature-&gt;position().y());
  double heading = feature-&gt;theta();
  if (FLAGS_enable_kf_tracking) {
    point[0] = feature-&gt;t_position().x();
    point[1] = feature-&gt;t_position().y();
    heading = feature-&gt;t_velocity_heading();
  }
  std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt; current_lanes;
  map-&gt;OnLane(current_lanes_, point, heading, FLAGS_search_radius, true,
              &amp;current_lanes);
  current_lanes_ = current_lanes;
  if (current_lanes_.empty()) {
    ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has no current lanes.";
    kf_lane_trackers_.clear();
    return;
  }
  Lane lane;
  if (feature-&gt;has_lane()) {
    lane = feature-&gt;lane();
  }
  double min_heading_diff = std::numeric_limits&lt;double&gt;::infinity();
  for (std::shared_ptr&lt;const LaneInfo&gt; current_lane : current_lanes) {
    int turn_type = map-&gt;LaneTurnType(current_lane-&gt;id().id());
    std::string lane_id = current_lane-&gt;id().id();
    double s = 0.0;
    double l = 0.0;
    map-&gt;GetProjection(point, current_lane, &amp;s, &amp;l);
    if (s &lt; 0.0) {
      continue;
    }

    common::math::Vec2d vec_point(point[0], point[1]);
    double distance = 0.0;
    common::PointENU nearest_point =
        current_lane-&gt;GetNearestPoint(vec_point, &amp;distance);
    double nearest_point_heading =
        map-&gt;PathHeading(current_lane, nearest_point);
    double angle_diff = common::math::AngleDiff(heading, nearest_point_heading);
    double left = 0.0;
    double right = 0.0;
    current_lane-&gt;GetWidth(s, &amp;left, &amp;right);
    LaneFeature* lane_feature = lane.add_current_lane_feature();
    lane_feature-&gt;set_lane_turn_type(turn_type);
    lane_feature-&gt;set_lane_id(lane_id);
    lane_feature-&gt;set_lane_s(s);
    lane_feature-&gt;set_lane_l(l);
    lane_feature-&gt;set_angle_diff(angle_diff);
    lane_feature-&gt;set_dist_to_left_boundary(left - l);
    lane_feature-&gt;set_dist_to_right_boundary(right + l);
    if (std::fabs(angle_diff) &lt; min_heading_diff) {
      lane.mutable_lane_feature()-&gt;CopyFrom(*lane_feature);
      min_heading_diff = std::fabs(angle_diff);
    }
    ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has current lanes ["
           &lt;&lt; lane_feature-&gt;ShortDebugString() &lt;&lt; "].";
  }

  if (lane.has_lane_feature()) {
    ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has one current lane ["
           &lt;&lt; lane.lane_feature().ShortDebugString() &lt;&lt; "].";
  }

  feature-&gt;mutable_lane()-&gt;CopyFrom(lane);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\planning_util.cc" startLine="(102, 0)" endLine="(167, 1)" clone_start="55" clone_end="60">
			<code function_name="interpolate(const TrajectoryPoint &amp;tp0, const TrajectoryPoint &amp;tp1, const double t)">TrajectoryPoint interpolate(const TrajectoryPoint &amp;tp0,
                            const TrajectoryPoint &amp;tp1, const double t) {
  if (std::abs(tp0.path_point().s() - tp0.path_point().s()) &lt; 1.0e-4) {
    return tp1;
  }

  const PathPoint &amp;pp0 = tp0.path_point();
  const PathPoint &amp;pp1 = tp1.path_point();
  double t0 = tp0.relative_time();
  double t1 = tp1.relative_time();

  std::array&lt;double, 2&gt; dx0{{tp0.v(), tp0.a()}};
  std::array&lt;double, 2&gt; dx1{{tp1.v(), tp1.a()}};
  HermiteSpline&lt;double, 3&gt; dynamic_spline(dx0, dx1, t0, t1);

  double s0 = 0.0;
  auto func_v = [&amp;dynamic_spline](const double t) {
    return dynamic_spline.Evaluate(0, t);
  };
  double s1 = common::math::IntegrateByGaussLegendre(func_v, t0, t1);
  double s = common::math::IntegrateByGaussLegendre(func_v, t0, t);

  if (std::abs(tp0.path_point().s() - s1) &lt; 1.0e-4) {
    return tp1;
  }

  double v = dynamic_spline.Evaluate(0, t);
  double a = dynamic_spline.Evaluate(1, t);

  std::array&lt;double, 2&gt; gx0{{pp0.theta(), pp0.kappa()}};
  std::array&lt;double, 2&gt; gx1{{pp1.theta(), pp1.kappa()}};
  HermiteSpline&lt;double, 3&gt; geometry_spline(gx0, gx1, s0, s1);
  auto func_cos_theta = [&amp;geometry_spline](const double s) {
    auto theta = geometry_spline.Evaluate(0, s);
    return std::cos(theta);
  };
  auto func_sin_theta = [&amp;geometry_spline](const double s) {
    auto theta = geometry_spline.Evaluate(0, s);
    return std::sin(theta);
  };

  double x =
      pp0.x() + common::math::IntegrateByGaussLegendre(func_cos_theta, s0, s);
  double y =
      pp0.y() + common::math::IntegrateByGaussLegendre(func_sin_theta, s0, s);
  double theta = geometry_spline.Evaluate(0, s);
  double kappa = geometry_spline.Evaluate(1, s);
  double dkappa = geometry_spline.Evaluate(2, s);
  double d2kappa = geometry_spline.Evaluate(3, s);

  TrajectoryPoint tp;
  tp.set_v(v);
  tp.set_a(a);

  PathPoint *path_point = tp.mutable_path_point();
  path_point-&gt;set_x(x);
  path_point-&gt;set_y(y);
  path_point-&gt;set_theta(theta);
  path_point-&gt;set_kappa(kappa);
  path_point-&gt;set_dkappa(dkappa);
  path_point-&gt;set_ddkappa(d2kappa);
  path_point-&gt;set_s(s);

  // check the diff of computed s1 and p1.s()?
  return tp;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\reference_line\reference_point.cc" startLine="(63, 0)" endLine="(76, 1)" clone_start="2" clone_end="8">
			<code function_name="ReferencePoint::RemoveDuplicates(std::vector&lt;ReferencePoint&gt;* points)">void ReferencePoint::RemoveDuplicates(std::vector&lt;ReferencePoint&gt;* points) {
  CHECK_NOTNULL(points);
  int count = 0;
  const double limit = kDuplicatedPointsEpsilon * kDuplicatedPointsEpsilon;
  for (size_t i = 0; i &lt; points-&gt;size(); ++i) {
    if (count == 0 ||
        (*points)[i].DistanceSquareTo((*points)[count - 1]) &gt; limit) {
      (*points)[count++] = (*points)[i];
    } else {
      (*points)[count - 1].add_lane_waypoints((*points)[i].lane_waypoints());
    }
  }
  points-&gt;resize(count);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\pnc_map.cc" startLine="(64, 0)" endLine="(77, 1)" clone_start="2" clone_end="8">
			<code function_name="RemoveDuplicates(std::vector&lt;MapPathPoint&gt; *points)">void RemoveDuplicates(std::vector&lt;MapPathPoint&gt; *points) {
  CHECK_NOTNULL(points);
  int count = 0;
  const double limit = kDuplicatedPointsEpsilon * kDuplicatedPointsEpsilon;
  for (size_t i = 0; i &lt; points-&gt;size(); ++i) {
    if (count == 0 ||
        (*points)[i].DistanceSquareTo((*points)[count - 1]) &gt; limit) {
      (*points)[count++] = (*points)[i];
    } else {
      (*points)[count - 1].add_lane_waypoints((*points)[i].lane_waypoints());
    }
  }
  points-&gt;resize(count);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\pnc_map.cc" startLine="(51, 0)" endLine="(62, 1)" clone_start="2" clone_end="8">
			<code function_name="RemoveDuplicates(std::vector&lt;common::math::Vec2d&gt; *points)">void RemoveDuplicates(std::vector&lt;common::math::Vec2d&gt; *points) {
  CHECK_NOTNULL(points);
  int count = 0;
  const double limit = kDuplicatedPointsEpsilon * kDuplicatedPointsEpsilon;
  for (size_t i = 0; i &lt; points-&gt;size(); ++i) {
    if (count == 0 ||
        (*points)[i].DistanceSquareTo((*points)[count - 1]) &gt; limit) {
      (*points)[count++] = (*points)[i];
    }
  }
  points-&gt;resize(count);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\predictor_manager.cc" startLine="(141, 0)" endLine="(160, 1)" clone_start="1" clone_end="7">
			<code function_name="PredictorManager::CreatePredictor( const ObstacleConf::PredictorType&amp; type)">std::unique_ptr&lt;Predictor&gt; PredictorManager::CreatePredictor(
    const ObstacleConf::PredictorType&amp; type) {
  std::unique_ptr&lt;Predictor&gt; predictor_ptr(nullptr);
  switch (type) {
    case ObstacleConf::LANE_SEQUENCE_PREDICTOR: {
      predictor_ptr.reset(new LaneSequencePredictor());
      break;
    }
    case ObstacleConf::FREE_MOVE_PREDICTOR: {
      predictor_ptr.reset(new FreeMovePredictor());
      break;
    }
    case ObstacleConf::REGIONAL_PREDICTOR: {
      predictor_ptr.reset(new RegionalPredictor());
      break;
    }
    default: { break; }
  }
  return predictor_ptr;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\evaluator\evaluator_manager.cc" startLine="(106, 0)" endLine="(117, 1)" clone_start="1" clone_end="7">
			<code function_name="EvaluatorManager::CreateEvaluator( const ObstacleConf::EvaluatorType&amp; type)">std::unique_ptr&lt;Evaluator&gt; EvaluatorManager::CreateEvaluator(
    const ObstacleConf::EvaluatorType&amp; type) {
  std::unique_ptr&lt;Evaluator&gt; evaluator_ptr(nullptr);
  switch (type) {
    case ObstacleConf::MLP_EVALUATOR: {
      evaluator_ptr.reset(new MLPEvaluator());
      break;
    }
    default: { break; }
  }
  return evaluator_ptr;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(171, 0)" endLine="(197, 1)" clone_start="13" clone_end="19">
			<code function_name="UdpStream::read(uint8_t* buffer, size_t max_length)">size_t UdpStream::read(uint8_t* buffer, size_t max_length) {
  ssize_t ret = 0;
  struct sockaddr_in peer_sockaddr;
  socklen_t socklenth = sizeof(peer_sockaddr);
  bzero(&amp;peer_sockaddr, sizeof(peer_sockaddr));
  peer_sockaddr.sin_family = AF_INET;
  peer_sockaddr.sin_port = _peer_port;
  peer_sockaddr.sin_addr.s_addr = _peer_addr;

  while ((ret = ::recvfrom(_sockfd, buffer, max_length, 0,
                           (struct sockaddr*)&amp;peer_sockaddr,
                           (socklen_t*)&amp;socklenth)) &lt; 0) {
    if (errno == EINTR) {
      continue;
    } else {
      // error
      if (errno != EAGAIN) {
        _status = Stream::Status::ERROR;
        _errno = errno;
      }
    }

    return 0;
  }

  return ret;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(240, 0)" endLine="(281, 1)" clone_start="17" clone_end="23">
			<code function_name="TcpStream::read(uint8_t* buffer, size_t max_length)">size_t TcpStream::read(uint8_t* buffer, size_t max_length) {
  ssize_t ret = 0;

  if (_status != Stream::Status::CONNECTED) {
    disconnect();
    connect();
    if (_status != Stream::Status::CONNECTED) {
      return 0;
    }
  }

  if (!readable(10000)) {
    return 0;
  }

  while ((ret = ::recv(_sockfd, buffer, max_length, 0)) &lt; 0) {
    if (errno == EINTR) {
      continue;
    } else {
      // error
      if (errno != EAGAIN) {
        _status = Stream::Status::ERROR;
        _errno = errno;
        ROS_ERROR("Read errno %d, error %s.", errno, strerror(errno));
      }
    }

    return 0;
  }

  if (ret == 0) {
    _status = Stream::Status::ERROR;
    _errno = errno;
    ROS_ERROR("Remote closed.");
    disconnect();
    if (connect()) {
      ROS_INFO("Reconnect tcp success.");
    }
  }

  return ret;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_generator.cc" startLine="(49, 0)" endLine="(73, 1)" clone_start="7" clone_end="13">
			<code function_name="PiecewiseLinearGenerator::Solve()">bool PiecewiseLinearGenerator::Solve() {
  const Eigen::MatrixXd&amp; kernel_matrix = kernel_.kernel_matrix();
  const Eigen::MatrixXd&amp; offset = kernel_.offset_matrix();

  const Eigen::MatrixXd&amp; inequality_constraint_matrix =
      constraint_.inequality_constraint_matrix();
  const Eigen::MatrixXd&amp; inequality_constraint_boundary =
      constraint_.inequality_constraint_boundary();

  const Eigen::MatrixXd&amp; equality_constraint_matrix =
      constraint_.equality_constraint_matrix();
  const Eigen::MatrixXd&amp; equality_constraint_boundary =
      constraint_.equality_constraint_boundary();

  qp_solver_.reset(new apollo::common::math::ActiveSetQpSolver(
      kernel_matrix, offset, inequality_constraint_matrix,
      inequality_constraint_boundary, equality_constraint_matrix,
      equality_constraint_boundary));

  if (!qp_solver_-&gt;Solve()) {
    return false;
  }
  const Eigen::MatrixXd solved_params = qp_solver_-&gt;params();
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_generator.cc" startLine="(49, 0)" endLine="(73, 1)" clone_start="5" clone_end="11">
			<code function_name="PiecewiseLinearGenerator::Solve()">bool PiecewiseLinearGenerator::Solve() {
  const Eigen::MatrixXd&amp; kernel_matrix = kernel_.kernel_matrix();
  const Eigen::MatrixXd&amp; offset = kernel_.offset_matrix();

  const Eigen::MatrixXd&amp; inequality_constraint_matrix =
      constraint_.inequality_constraint_matrix();
  const Eigen::MatrixXd&amp; inequality_constraint_boundary =
      constraint_.inequality_constraint_boundary();

  const Eigen::MatrixXd&amp; equality_constraint_matrix =
      constraint_.equality_constraint_matrix();
  const Eigen::MatrixXd&amp; equality_constraint_boundary =
      constraint_.equality_constraint_boundary();

  qp_solver_.reset(new apollo::common::math::ActiveSetQpSolver(
      kernel_matrix, offset, inequality_constraint_matrix,
      inequality_constraint_boundary, equality_constraint_matrix,
      equality_constraint_boundary));

  if (!qp_solver_-&gt;Solve()) {
    return false;
  }
  const Eigen::MatrixXd solved_params = qp_solver_-&gt;params();
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\map\map_service.cc" startLine="(82, 0)" endLine="(91, 1)" clone_start="4" clone_end="9">
			<code function_name="MapElementIds::MapElementIds(const nlohmann::json &amp;json_object)">MapElementIds::MapElementIds(const nlohmann::json &amp;json_object)
    : MapElementIds() {
  ExtractStringVectorFromJson(json_object, "lane", &amp;lane);
  ExtractStringVectorFromJson(json_object, "crosswalk", &amp;crosswalk);
  ExtractStringVectorFromJson(json_object, "junction", &amp;junction);
  ExtractStringVectorFromJson(json_object, "signal", &amp;signal);
  ExtractStringVectorFromJson(json_object, "stopSign", &amp;stop_sign);
  ExtractStringVectorFromJson(json_object, "yield", &amp;yield);
  ExtractStringVectorFromJson(json_object, "overlap", &amp;overlap);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\map\map_service.cc" startLine="(82, 0)" endLine="(91, 1)" clone_start="3" clone_end="8">
			<code function_name="MapElementIds::MapElementIds(const nlohmann::json &amp;json_object)">MapElementIds::MapElementIds(const nlohmann::json &amp;json_object)
    : MapElementIds() {
  ExtractStringVectorFromJson(json_object, "lane", &amp;lane);
  ExtractStringVectorFromJson(json_object, "crosswalk", &amp;crosswalk);
  ExtractStringVectorFromJson(json_object, "junction", &amp;junction);
  ExtractStringVectorFromJson(json_object, "signal", &amp;signal);
  ExtractStringVectorFromJson(json_object, "stopSign", &amp;stop_sign);
  ExtractStringVectorFromJson(json_object, "yield", &amp;yield);
  ExtractStringVectorFromJson(json_object, "overlap", &amp;overlap);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\lib\online_calibration.cpp" startLine="(118, 0)" endLine="(145, 1)" clone_start="17" clone_end="22">
			<code function_name="OnlineCalibration::dump(const std::string&amp; file_path)">void OnlineCalibration::dump(const std::string&amp; file_path) {
  if (!_inited) {
    ROS_ERROR("Please decode calibraion info first");
    return;
  }
  std::ofstream ofs(file_path.c_str(), std::ios::out);
  ofs &lt;&lt; "lasers:" &lt;&lt; std::endl;
  for (auto&amp; correction : _calibration._laser_corrections) {
    ofs &lt;&lt; "- {";
    ofs &lt;&lt; "dist_correction: " &lt;&lt; correction.second.dist_correction &lt;&lt; ", ";
    ofs &lt;&lt; "dist_correction_x: " &lt;&lt; correction.second.dist_correction_x &lt;&lt; ", ";
    ofs &lt;&lt; "dist_correction_y: " &lt;&lt; correction.second.dist_correction_y &lt;&lt; ", ";
    ofs &lt;&lt; "focal_distance: " &lt;&lt; correction.second.focal_distance &lt;&lt; ", ";
    ofs &lt;&lt; "focal_slope: " &lt;&lt; correction.second.focal_slope &lt;&lt; ", ";
    ofs &lt;&lt; "horiz_offset_correction: "
        &lt;&lt; correction.second.horiz_offset_correction &lt;&lt; ", ";
    ofs &lt;&lt; "laser_id: " &lt;&lt; correction.second.laser_ring &lt;&lt; ", ";
    ofs &lt;&lt; "max_intensity: " &lt;&lt; correction.second.max_intensity &lt;&lt; ", ";
    ofs &lt;&lt; "min_intensity: " &lt;&lt; correction.second.min_intensity &lt;&lt; ", ";
    ofs &lt;&lt; "rot_correction: " &lt;&lt; correction.second.rot_correction &lt;&lt; ", ";
    ofs &lt;&lt; "vert_correction: " &lt;&lt; correction.second.vert_correction &lt;&lt; ", ";
    ofs &lt;&lt; "vert_offset_correction: "
        &lt;&lt; correction.second.vert_offset_correction;
    ofs &lt;&lt; "}" &lt;&lt; std::endl;
  }
  ofs &lt;&lt; "num_lasers: " &lt;&lt; _calibration._num_lasers &lt;&lt; std::endl;
  ofs.close();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\lib\online_calibration.cpp" startLine="(118, 0)" endLine="(145, 1)" clone_start="10" clone_end="15">
			<code function_name="OnlineCalibration::dump(const std::string&amp; file_path)">void OnlineCalibration::dump(const std::string&amp; file_path) {
  if (!_inited) {
    ROS_ERROR("Please decode calibraion info first");
    return;
  }
  std::ofstream ofs(file_path.c_str(), std::ios::out);
  ofs &lt;&lt; "lasers:" &lt;&lt; std::endl;
  for (auto&amp; correction : _calibration._laser_corrections) {
    ofs &lt;&lt; "- {";
    ofs &lt;&lt; "dist_correction: " &lt;&lt; correction.second.dist_correction &lt;&lt; ", ";
    ofs &lt;&lt; "dist_correction_x: " &lt;&lt; correction.second.dist_correction_x &lt;&lt; ", ";
    ofs &lt;&lt; "dist_correction_y: " &lt;&lt; correction.second.dist_correction_y &lt;&lt; ", ";
    ofs &lt;&lt; "focal_distance: " &lt;&lt; correction.second.focal_distance &lt;&lt; ", ";
    ofs &lt;&lt; "focal_slope: " &lt;&lt; correction.second.focal_slope &lt;&lt; ", ";
    ofs &lt;&lt; "horiz_offset_correction: "
        &lt;&lt; correction.second.horiz_offset_correction &lt;&lt; ", ";
    ofs &lt;&lt; "laser_id: " &lt;&lt; correction.second.laser_ring &lt;&lt; ", ";
    ofs &lt;&lt; "max_intensity: " &lt;&lt; correction.second.max_intensity &lt;&lt; ", ";
    ofs &lt;&lt; "min_intensity: " &lt;&lt; correction.second.min_intensity &lt;&lt; ", ";
    ofs &lt;&lt; "rot_correction: " &lt;&lt; correction.second.rot_correction &lt;&lt; ", ";
    ofs &lt;&lt; "vert_correction: " &lt;&lt; correction.second.vert_correction &lt;&lt; ", ";
    ofs &lt;&lt; "vert_offset_correction: "
        &lt;&lt; correction.second.vert_offset_correction;
    ofs &lt;&lt; "}" &lt;&lt; std::endl;
  }
  ofs &lt;&lt; "num_lasers: " &lt;&lt; _calibration._num_lasers &lt;&lt; std::endl;
  ofs.close();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\opengl_visualizer.h" startLine="(33, 2)" endLine="(33, 40)" clone_start="1" clone_end="1">
			<code function_name="~OpenglVisualizer()">  virtual ~OpenglVisualizer() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\camera.h" startLine="(27, 2)" endLine="(27, 22)" clone_start="1" clone_end="1">
			<code function_name="~Camera()">  ~Camera() = default;</code>
		</source>
	</dup>
	<dup count="8">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(155, 0)" endLine="(155, 53)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::kappa() const">double VehicleState::kappa() const { return kappa_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(153, 0)" endLine="(153, 57)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::heading() const">double VehicleState::heading() const { return heading_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(151, 0)" endLine="(151, 49)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::yaw() const">double VehicleState::yaw() const { return yaw_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(149, 0)" endLine="(149, 53)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::pitch() const">double VehicleState::pitch() const { return pitch_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(147, 0)" endLine="(147, 51)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::roll() const">double VehicleState::roll() const { return roll_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(145, 0)" endLine="(145, 45)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::z() const">double VehicleState::z() const { return z_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(143, 0)" endLine="(143, 45)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::y() const">double VehicleState::y() const { return y_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(174, 0)" endLine="(174, 68)" clone_start="1" clone_end="1">
			<code function_name="ActiveSetQpSolver::qp_eps_den() const">double ActiveSetQpSolver::qp_eps_den() const { return qp_eps_den_; }</code>
		</source>
	</dup>
	<dup count="8">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(157, 0)" endLine="(157, 66)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::linear_velocity() const">double VehicleState::linear_velocity() const { return linear_v_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(155, 0)" endLine="(155, 53)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::kappa() const">double VehicleState::kappa() const { return kappa_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(153, 0)" endLine="(153, 57)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::heading() const">double VehicleState::heading() const { return heading_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(151, 0)" endLine="(151, 49)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::yaw() const">double VehicleState::yaw() const { return yaw_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(149, 0)" endLine="(149, 53)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::pitch() const">double VehicleState::pitch() const { return pitch_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(147, 0)" endLine="(147, 51)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::roll() const">double VehicleState::roll() const { return roll_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(145, 0)" endLine="(145, 45)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::z() const">double VehicleState::z() const { return z_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(176, 0)" endLine="(176, 78)" clone_start="1" clone_end="1">
			<code function_name="ActiveSetQpSolver::qp_eps_iter_ref() const">double ActiveSetQpSolver::qp_eps_iter_ref() const { return qp_eps_iter_ref_; }</code>
		</source>
	</dup>
	<dup count="8">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(159, 0)" endLine="(159, 68)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::angular_velocity() const">double VehicleState::angular_velocity() const { return angular_v_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(157, 0)" endLine="(157, 66)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::linear_velocity() const">double VehicleState::linear_velocity() const { return linear_v_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(155, 0)" endLine="(155, 53)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::kappa() const">double VehicleState::kappa() const { return kappa_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(153, 0)" endLine="(153, 57)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::heading() const">double VehicleState::heading() const { return heading_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(151, 0)" endLine="(151, 49)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::yaw() const">double VehicleState::yaw() const { return yaw_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(149, 0)" endLine="(149, 53)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::pitch() const">double VehicleState::pitch() const { return pitch_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(147, 0)" endLine="(147, 51)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::roll() const">double VehicleState::roll() const { return roll_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(178, 0)" endLine="(178, 66)" clone_start="1" clone_end="1">
			<code function_name="ActiveSetQpSolver::debug_info() const">bool ActiveSetQpSolver::debug_info() const { return debug_info_; }</code>
		</source>
	</dup>
	<dup count="8">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(161, 0)" endLine="(161, 72)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::linear_acceleration() const">double VehicleState::linear_acceleration() const { return linear_a_y_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(159, 0)" endLine="(159, 68)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::angular_velocity() const">double VehicleState::angular_velocity() const { return angular_v_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(157, 0)" endLine="(157, 66)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::linear_velocity() const">double VehicleState::linear_velocity() const { return linear_v_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(155, 0)" endLine="(155, 53)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::kappa() const">double VehicleState::kappa() const { return kappa_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(153, 0)" endLine="(153, 57)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::heading() const">double VehicleState::heading() const { return heading_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(151, 0)" endLine="(151, 49)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::yaw() const">double VehicleState::yaw() const { return yaw_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(149, 0)" endLine="(149, 53)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::pitch() const">double VehicleState::pitch() const { return pitch_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(180, 0)" endLine="(180, 74)" clone_start="1" clone_end="1">
			<code function_name="ActiveSetQpSolver::l_lower_bound() const">double ActiveSetQpSolver::l_lower_bound() const { return l_lower_bound_; }</code>
		</source>
	</dup>
	<dup count="8">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(163, 0)" endLine="(163, 51)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::gear() const">double VehicleState::gear() const { return gear_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(161, 0)" endLine="(161, 72)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::linear_acceleration() const">double VehicleState::linear_acceleration() const { return linear_a_y_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(159, 0)" endLine="(159, 68)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::angular_velocity() const">double VehicleState::angular_velocity() const { return angular_v_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(157, 0)" endLine="(157, 66)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::linear_velocity() const">double VehicleState::linear_velocity() const { return linear_v_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(155, 0)" endLine="(155, 53)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::kappa() const">double VehicleState::kappa() const { return kappa_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(153, 0)" endLine="(153, 57)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::heading() const">double VehicleState::heading() const { return heading_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(151, 0)" endLine="(151, 49)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::yaw() const">double VehicleState::yaw() const { return yaw_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(182, 0)" endLine="(182, 74)" clone_start="1" clone_end="1">
			<code function_name="ActiveSetQpSolver::l_upper_bound() const">double ActiveSetQpSolver::l_upper_bound() const { return l_upper_bound_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\kalman_filter.cc" startLine="(250, 0)" endLine="(329, 1)" clone_start="9" clone_end="14">
			<code function_name="KalmanFilter::ComputeMeasuredBboxCornerVelocity(  const TrackedObjectPtr&amp; new_object,   const TrackedObjectPtr&amp; old_object, const double&amp; time_diff)">Eigen::VectorXf KalmanFilter::ComputeMeasuredBboxCornerVelocity(
  const TrackedObjectPtr&amp; new_object,
  const TrackedObjectPtr&amp; old_object,
  const double&amp; time_diff) {
  // Compute 2D bbox corner velocity measurment
  Eigen::Vector3f project_dir = new_object-&gt;anchor_point -
    old_object-&gt;anchor_point;
  project_dir.normalize();
  Eigen::Vector3d old_dir = old_object-&gt;direction.cast&lt;double&gt;();
  Eigen::Vector3d old_size = old_object-&gt;size.cast&lt;double&gt;();
  Eigen::Vector3d old_center = old_object-&gt;center.cast&lt;double&gt;();
  Eigen::Vector3d new_size = old_size;
  Eigen::Vector3d new_center = old_center;
  ComputeBboxSizeCenter&lt;pcl_util::Point&gt;(
    new_object-&gt;object_ptr-&gt;cloud, old_dir, &amp;new_size, &amp;new_center);
  Eigen::Vector3d ortho_old_dir(-old_dir(1), old_dir(0), 0.0);

  Eigen::Vector3d old_bbox_corner_list[4];
  Eigen::Vector3d new_bbox_corner_list[4];
  Eigen::Vector3d old_bbox_corner = old_center +
    old_dir * old_size(0) * 0.5 + ortho_old_dir * old_size(1) * 0.5;
  Eigen::Vector3d new_bbox_corner = new_center +
    old_dir * new_size(0) * 0.5 + ortho_old_dir * new_size(1) * 0.5;
  old_bbox_corner_list[0] = old_bbox_corner;
  new_bbox_corner_list[0] = new_bbox_corner;
  old_bbox_corner = old_center -
    old_dir * old_size(0) * 0.5 + ortho_old_dir * old_size(1) * 0.5;
  new_bbox_corner = new_center -
    old_dir * new_size(0) * 0.5 + ortho_old_dir * new_size(1) * 0.5;
  old_bbox_corner_list[1] = old_bbox_corner;
  new_bbox_corner_list[1] = new_bbox_corner;
  old_bbox_corner = old_center +
    old_dir * old_size(0) * 0.5 - ortho_old_dir * old_size(1) * 0.5;
  new_bbox_corner = new_center +
    old_dir * new_size(0) * 0.5 - ortho_old_dir * new_size(1) * 0.5;
  old_bbox_corner_list[2] = old_bbox_corner;
  new_bbox_corner_list[2] = new_bbox_corner;
  old_bbox_corner = old_center -
    old_dir * old_size(0) * 0.5 - ortho_old_dir * old_size(1) * 0.5;
  new_bbox_corner = new_center -
    old_dir * new_size(0) * 0.5 - ortho_old_dir * new_size(1) * 0.5;
  old_bbox_corner_list[3] = old_bbox_corner;
  new_bbox_corner_list[3] = new_bbox_corner;

  Eigen::Vector3f min_bbox_corner_velocity_on_project_dir =
    Eigen::Vector3f(100, 100, 0);
  float min_bbox_corner_velocity_on_project_dir_gain_norm =
    min_bbox_corner_velocity_on_project_dir.norm();
  for (size_t i = 0; i &lt; 4; ++i) {
    old_bbox_corner = old_bbox_corner_list[i];
    new_bbox_corner = new_bbox_corner_list[i];
    Eigen::Vector3f bbox_corner_velocity =
      ((new_bbox_corner - old_bbox_corner) / time_diff).cast&lt;float&gt;();
    float bbox_corner_velocity_project_dir_inner_product =
      bbox_corner_velocity(0) * project_dir(0) +
      bbox_corner_velocity(1) * project_dir(1);
    float bbox_corner_velocity_project_dir_angle_cos =
      bbox_corner_velocity_project_dir_inner_product /
      (bbox_corner_velocity.head(2).norm() * project_dir.head(2).norm());
    float bbox_corner_velocity_norm_on_project_dir =
      bbox_corner_velocity.head(2).norm() *
      bbox_corner_velocity_project_dir_angle_cos;
    Eigen::Vector3f bbox_corner_velocity_on_project_dir = project_dir *
      bbox_corner_velocity_norm_on_project_dir;
    bbox_corner_velocity_on_project_dir(2) = 0.0;
    if (bbox_corner_velocity_on_project_dir(0) * project_dir(0) &lt;= 0) {
      bbox_corner_velocity_on_project_dir = Eigen::Vector3f::Zero();
    }
    Eigen::Vector3f bbox_corner_velocity_on_project_dir_gain =
      bbox_corner_velocity_on_project_dir - belief_velocity_.cast&lt;float&gt;();
    if (bbox_corner_velocity_on_project_dir_gain.norm() &lt;
      min_bbox_corner_velocity_on_project_dir_gain_norm) {
      min_bbox_corner_velocity_on_project_dir =
        bbox_corner_velocity_on_project_dir;
      min_bbox_corner_velocity_on_project_dir_gain_norm =
        bbox_corner_velocity_on_project_dir_gain.norm();
    }
  }
  return min_bbox_corner_velocity_on_project_dir;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\kalman_filter.cc" startLine="(224, 0)" endLine="(248, 1)" clone_start="6" clone_end="11">
			<code function_name="KalmanFilter::ComputeMeasuredBboxCenterVelocity(  const TrackedObjectPtr&amp; new_object,   const TrackedObjectPtr&amp; old_object, const double&amp; time_diff)">Eigen::VectorXf KalmanFilter::ComputeMeasuredBboxCenterVelocity(
  const TrackedObjectPtr&amp; new_object,
  const TrackedObjectPtr&amp; old_object,
  const double&amp; time_diff) {
  // Compute 2D bbox center velocity measurment
  Eigen::Vector3d old_dir = old_object-&gt;direction.cast&lt;double&gt;();
  Eigen::Vector3d old_size = old_object-&gt;size.cast&lt;double&gt;();
  Eigen::Vector3d old_center = old_object-&gt;center.cast&lt;double&gt;();
  Eigen::Vector3d new_size = old_size;
  Eigen::Vector3d new_center = old_center;
  ComputeBboxSizeCenter&lt;pcl_util::Point&gt;(
    new_object-&gt;object_ptr-&gt;cloud, old_dir, &amp;new_size, &amp;new_center);
  Eigen::Vector3f measured_bbox_center_velocity_with_old_dir =
    (new_center - old_center).cast&lt;float&gt;();
  measured_bbox_center_velocity_with_old_dir /= time_diff;
  measured_bbox_center_velocity_with_old_dir(2) = 0.0;
  Eigen::Vector3f measured_bbox_center_velocity =
    measured_bbox_center_velocity_with_old_dir;
  Eigen::Vector3f project_dir = new_object-&gt;anchor_point -
                                old_object-&gt;anchor_point;
  if (measured_bbox_center_velocity.dot(project_dir) &lt;= 0) {
    measured_bbox_center_velocity = Eigen::Vector3f::Zero();
  }
  return measured_bbox_center_velocity;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(106, 0)" endLine="(106, 79)" clone_start="1" clone_end="1">
			<code function_name="Spline2dSeg::third_derivative_y(const double t) const">const PolynomialXd&amp; Spline2dSeg::derivative_y() const { return derivative_y_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_seg.cc" startLine="(63, 0)" endLine="(63, 75)" clone_start="1" clone_end="1">
			<code function_name="Spline1dSeg::ThirdOrderDerivative(const double x) const">const PolynomialXd&amp; Spline1dSeg::Derivative() const { return derivative_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(108, 0)" endLine="(110, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline2dSeg::third_derivative_y(const double t) const">const PolynomialXd&amp; Spline2dSeg::SecondDerivativeX() const {
  return second_derivative_x_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_seg.cc" startLine="(65, 0)" endLine="(67, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline1dSeg::ThirdOrderDerivative(const double x) const">const PolynomialXd&amp; Spline1dSeg::SecondOrderDerivative() const {
  return second_order_derivative_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(112, 0)" endLine="(114, 1)" clone_start="1" clone_end="2">
			<code function_name="Spline2dSeg::third_derivative_y(const double t) const">const PolynomialXd&amp; Spline2dSeg::second_derivative_y() const {
  return second_derivative_y_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_seg.cc" startLine="(69, 0)" endLine="(71, 1)" clone_start="1" clone_end="2">
			<code function_name="Spline1dSeg::ThirdOrderDerivative(const double x) const">const PolynomialXd&amp; Spline1dSeg::ThirdOrderDerivative() const {
  return third_order_derivative_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\map\map_service.h" startLine="(47, 2)" endLine="(55, 3)" clone_start="3" clone_end="8">
			<code function_name="LogDebugInfo() const">  void LogDebugInfo() const {
    AINFO &lt;&lt; "Lanes: " &lt;&lt; lane.size();
    AINFO &lt;&lt; "Crosswalks: " &lt;&lt; crosswalk.size();
    AINFO &lt;&lt; "Junctions: " &lt;&lt; junction.size();
    AINFO &lt;&lt; "Signals: " &lt;&lt; signal.size();
    AINFO &lt;&lt; "StopSigns: " &lt;&lt; stop_sign.size();
    AINFO &lt;&lt; "YieldSigns: " &lt;&lt; yield.size();
    AINFO &lt;&lt; "Overlaps: " &lt;&lt; overlap.size();
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\map\map_service.h" startLine="(47, 2)" endLine="(55, 3)" clone_start="2" clone_end="7">
			<code function_name="LogDebugInfo() const">  void LogDebugInfo() const {
    AINFO &lt;&lt; "Lanes: " &lt;&lt; lane.size();
    AINFO &lt;&lt; "Crosswalks: " &lt;&lt; crosswalk.size();
    AINFO &lt;&lt; "Junctions: " &lt;&lt; junction.size();
    AINFO &lt;&lt; "Signals: " &lt;&lt; signal.size();
    AINFO &lt;&lt; "StopSigns: " &lt;&lt; stop_sign.size();
    AINFO &lt;&lt; "YieldSigns: " &lt;&lt; yield.size();
    AINFO &lt;&lt; "Overlaps: " &lt;&lt; overlap.size();
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(352, 0)" endLine="(362, 1)" clone_start="4" clone_end="10">
			<code function_name="HmObjectTracker::SetHistogramBinSize( const int&amp; histogram_bin_size)">bool HmObjectTracker::SetHistogramBinSize(
  const int&amp; histogram_bin_size) {
  if (histogram_bin_size &gt; 0) {
    histogram_bin_size_ = histogram_bin_size;
    AINFO &lt;&lt; "histogram bin size of " &lt;&lt; name() &lt;&lt; " is "
          &lt;&lt; histogram_bin_size_;
    return true;
  }
  AERROR &lt;&lt; "invalid histogram bin size of " &lt;&lt; name();
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(340, 0)" endLine="(350, 1)" clone_start="4" clone_end="10">
			<code function_name="HmObjectTracker::SetCollectAgeMinimum( const int&amp; collect_age_minimum)">bool HmObjectTracker::SetCollectAgeMinimum(
  const int&amp; collect_age_minimum) {
  if (collect_age_minimum &gt;= 0) {
    collect_age_minimum_ = collect_age_minimum;
    AINFO &lt;&lt; "collect age minimum of " &lt;&lt; name() &lt;&lt; " is "
          &lt;&lt; collect_age_minimum_;
    return true;
  }
  AERROR &lt;&lt; "invalid collect age minimum of " &lt;&lt; name();
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\polygon2d.cc" startLine="(52, 0)" endLine="(63, 1)" clone_start="1" clone_end="7">
			<code function_name="Polygon2d::DistanceSquareTo(const Vec2d &amp;point) const">double Polygon2d::DistanceSquareTo(const Vec2d &amp;point) const {
  CHECK_GE(points_.size(), 3);
  if (IsPointIn(point)) {
    return 0.0;
  }
  double distance_sqr = std::numeric_limits&lt;double&gt;::infinity();
  for (int i = 0; i &lt; num_points_; ++i) {
    distance_sqr =
        std::min(distance_sqr, line_segments_[i].DistanceSquareTo(point));
  }
  return distance_sqr;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\polygon2d.cc" startLine="(40, 0)" endLine="(50, 1)" clone_start="1" clone_end="7">
			<code function_name="Polygon2d::DistanceTo(const Vec2d &amp;point) const">double Polygon2d::DistanceTo(const Vec2d &amp;point) const {
  CHECK_GE(points_.size(), 3);
  if (IsPointIn(point)) {
    return 0.0;
  }
  double distance = std::numeric_limits&lt;double&gt;::infinity();
  for (int i = 0; i &lt; num_points_; ++i) {
    distance = std::min(distance, line_segments_[i].DistanceTo(point));
  }
  return distance;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(26, 0)" endLine="(114, 1)" clone_start="21" clone_end="28">
			<code function_name="SignalsXmlParser::ParseTrafficLights(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;TrafficLightInternal&gt;* traffic_lights)">Status SignalsXmlParser::ParseTrafficLights(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;TrafficLightInternal&gt;* traffic_lights) {
  CHECK_NOTNULL(traffic_lights);
  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "trafficLight") {
      PbSignal traffic_light;
      traffic_light.mutable_id()-&gt;set_id(object_id);
      std::string layout_type;
      int checker = UtilXmlParser::QueryStringAttribute(
          *signal_node, "layoutType", &amp;layout_type);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse signal layout type.";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      PbSignalType signal_layout_type;
      ToPbSignalType(layout_type, &amp;signal_layout_type);
      traffic_light.set_type(signal_layout_type);

      PbPolygon* polygon = traffic_light.mutable_boundary();
      auto outline_node = signal_node-&gt;FirstChildElement("outline");
      if (outline_node == nullptr) {
        std::string err_msg = "Error parse signal outline";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseOutline(*outline_node, polygon));
      auto sub_node = signal_node-&gt;FirstChildElement("subSignal");
      if (sub_node == nullptr) {
        std::string err_msg = "Error parse sub signal.";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      while (sub_node) {
        std::string sub_signal_id;
        std::string sub_signal_xml_type;
        checker = UtilXmlParser::QueryStringAttribute(*sub_node, "type",
                                                      &amp;sub_signal_xml_type);
        checker += UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                       &amp;sub_signal_id);
        if (checker != tinyxml2::XML_SUCCESS) {
          std::string err_msg = "Error parse sub signal layout type.";
          return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
        }

        PbSubSignal* sub_signal = traffic_light.add_subsignal();
        PbSubSignalType sub_signal_type;
        ToPbSubSignalType(sub_signal_xml_type, &amp;sub_signal_type);
        sub_signal-&gt;mutable_id()-&gt;set_id(sub_signal_id);
        sub_signal-&gt;set_type(sub_signal_type);
        PbPoint3D* pt = sub_signal-&gt;mutable_location();
        RETURN_IF_ERROR(UtilXmlParser::ParsePoint(*sub_node, pt));

        sub_node = sub_node-&gt;NextSiblingElement("subSignal");
      }

      TrafficLightInternal trafficlight_internal;
      trafficlight_internal.id = object_id;
      trafficlight_internal.traffic_light = traffic_light;

      sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                            &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          trafficlight_internal.stop_line_ids.insert(stop_line_id);
          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      traffic_lights-&gt;emplace_back(trafficlight_internal);
    }
    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(62, 0)" endLine="(91, 1)" clone_start="16" clone_end="22">
			<code function_name="LanesXmlParser::ParseSectionBoundary( const tinyxml2::XMLElement&amp; xml_node, PbBoundaryPolygon* boundary)">Status LanesXmlParser::ParseSectionBoundary(
    const tinyxml2::XMLElement&amp; xml_node, PbBoundaryPolygon* boundary) {
  CHECK_NOTNULL(boundary);

  auto boundaries_node = xml_node.FirstChildElement("boundaries");
  if (boundaries_node == nullptr) {
    std::string err_msg = "Error parse boundaries";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  auto sub_node = boundaries_node-&gt;FirstChildElement("boundary");
  while (sub_node) {
    PbBoundaryEdge* boundary_edge = boundary-&gt;add_edge();
    RETURN_IF_ERROR(
        UtilXmlParser::ParseCurve(*sub_node, boundary_edge-&gt;mutable_curve()));
    std::string type;
    int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "type", &amp;type);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse boundary type";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }
    PbBoundaryEdgeType boundary_type;
    RETURN_IF_ERROR(ToPbBoundaryType(type, &amp;boundary_type));
    boundary_edge-&gt;set_type(boundary_type);

    sub_node = sub_node-&gt;NextSiblingElement("boundary");
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.cc" startLine="(133, 0)" endLine="(318, 1)" clone_start="79" clone_end="84">
			<code function_name="MinBoxObjectBuilder::ReconstructPolygon(const Eigen::Vector3d &amp;ref_ct, ObjectPtr obj)">void  MinBoxObjectBuilder::ReconstructPolygon(
        const Eigen::Vector3d &amp;ref_ct,
        ObjectPtr obj) {
    if (obj-&gt;polygon.points.size() &lt;= 0) {
        return;
    }
    size_t max_point_index = 0;
    size_t min_point_index = 0;
    Eigen::Vector3d p;
    p[0] = obj-&gt;polygon.points[0].x;
    p[1] = obj-&gt;polygon.points[0].y;
    p[2] = obj-&gt;polygon.points[0].z;
    Eigen::Vector3d max_point = p - ref_ct;
    Eigen::Vector3d min_point = p - ref_ct;
    for (size_t i = 1; i &lt; obj-&gt;polygon.points.size(); ++i) {
        Eigen::Vector3d p;
        p[0] = obj-&gt;polygon.points[i].x;
        p[1] = obj-&gt;polygon.points[i].y;
        p[2] = obj-&gt;polygon.points[i].z;
        Eigen::Vector3d ray = p - ref_ct;
        // clock direction
        if (max_point[0] * ray[1] - ray[0] * max_point[1] &lt; EPSILON) {
            max_point = ray;
            max_point_index = i;
        }
        // unclock direction
        if (min_point[0] * ray[1] - ray[0] * min_point[1] &gt; EPSILON) {
            min_point = ray;
            min_point_index = i;
        }
    }
    Eigen::Vector3d line = max_point - min_point;
    double total_len = 0;
    double max_dis = 0;
    bool has_out = false;
    for (size_t i = min_point_index, count = 0;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist = sqrt((p[0] - p_x[0]) * (p[0] - p_x[0])
                        + (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist - max_dis &gt; EPSILON) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                   || (i == max_point_index &amp;&amp; j == min_point_index)) {
            size_t k = (j + 1) % obj-&gt;polygon.points.size();
            Eigen::Vector3d p_k;
            p_k[0] = obj-&gt;polygon.points[k].x;
            p_k[1] = obj-&gt;polygon.points[k].y;
            p_k[2] = obj-&gt;polygon.points[k].z;
            Eigen::Vector3d p_j;
            p_j[0] = obj-&gt;polygon.points[j].x;
            p_j[1] = obj-&gt;polygon.points[j].y;
            p_j[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
            } else {
                // outline
                has_out = true;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p_x - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist =
                        sqrt((p[0] - p_x[0]) * (p[0] - p_x[0]) +
                            (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist &gt; max_dis) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        }
    }
    size_t count = 0;
    double min_area = std::numeric_limits&lt;double&gt;::max();
    for (size_t i = min_point_index;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        Eigen::Vector3d p_j;
        p_j[0] = obj-&gt;polygon.points[j].x;
        p_j[1] = obj-&gt;polygon.points[j].y;
        p_j[2] = obj-&gt;polygon.points[j].z;
        double dist = sqrt((p_x[0] - p_j[0]) * (p_x[0] - p_j[0])
                + (p_x[1] - p_j[1])* (p_x[1] - p_j[1]));
        if (dist &lt; max_dis &amp;&amp; (dist / total_len) &lt; 0.5) {
            continue;
        }
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0;
                double width = 0;
                Eigen::Vector3d dir;
                double area =
                    ComputeAreaAlongOneEdge(obj, i,
                                        &amp;center, &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                    || (i == max_point_index &amp;&amp; j == min_point_index)) {
            if (!has_out) {
                continue;
            }
            Eigen::Vector3d center;
            double length = 0;
            double width = 0;
            Eigen::Vector3d dir;
            double area =
               ComputeAreaAlongOneEdge(obj, i, &amp;center, &amp;length, &amp;width, &amp;dir);
            if (area &lt; min_area) {
                obj-&gt;center = center;
                obj-&gt;length = length;
                obj-&gt;width = width;
                obj-&gt;direction = dir;
                min_area = area;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[i].x;
            p[1] = obj-&gt;polygon.points[i].y;
            p[2] = obj-&gt;polygon.points[i].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0.0;
                double width = 0.0;
                Eigen::Vector3d dir;
                double area =
                   ComputeAreaAlongOneEdge(obj, i, &amp;center,
                                           &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        }
    }
    obj-&gt;direction.normalize();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.cc" startLine="(133, 0)" endLine="(318, 1)" clone_start="45" clone_end="50">
			<code function_name="MinBoxObjectBuilder::ReconstructPolygon(const Eigen::Vector3d &amp;ref_ct, ObjectPtr obj)">void  MinBoxObjectBuilder::ReconstructPolygon(
        const Eigen::Vector3d &amp;ref_ct,
        ObjectPtr obj) {
    if (obj-&gt;polygon.points.size() &lt;= 0) {
        return;
    }
    size_t max_point_index = 0;
    size_t min_point_index = 0;
    Eigen::Vector3d p;
    p[0] = obj-&gt;polygon.points[0].x;
    p[1] = obj-&gt;polygon.points[0].y;
    p[2] = obj-&gt;polygon.points[0].z;
    Eigen::Vector3d max_point = p - ref_ct;
    Eigen::Vector3d min_point = p - ref_ct;
    for (size_t i = 1; i &lt; obj-&gt;polygon.points.size(); ++i) {
        Eigen::Vector3d p;
        p[0] = obj-&gt;polygon.points[i].x;
        p[1] = obj-&gt;polygon.points[i].y;
        p[2] = obj-&gt;polygon.points[i].z;
        Eigen::Vector3d ray = p - ref_ct;
        // clock direction
        if (max_point[0] * ray[1] - ray[0] * max_point[1] &lt; EPSILON) {
            max_point = ray;
            max_point_index = i;
        }
        // unclock direction
        if (min_point[0] * ray[1] - ray[0] * min_point[1] &gt; EPSILON) {
            min_point = ray;
            min_point_index = i;
        }
    }
    Eigen::Vector3d line = max_point - min_point;
    double total_len = 0;
    double max_dis = 0;
    bool has_out = false;
    for (size_t i = min_point_index, count = 0;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist = sqrt((p[0] - p_x[0]) * (p[0] - p_x[0])
                        + (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist - max_dis &gt; EPSILON) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                   || (i == max_point_index &amp;&amp; j == min_point_index)) {
            size_t k = (j + 1) % obj-&gt;polygon.points.size();
            Eigen::Vector3d p_k;
            p_k[0] = obj-&gt;polygon.points[k].x;
            p_k[1] = obj-&gt;polygon.points[k].y;
            p_k[2] = obj-&gt;polygon.points[k].z;
            Eigen::Vector3d p_j;
            p_j[0] = obj-&gt;polygon.points[j].x;
            p_j[1] = obj-&gt;polygon.points[j].y;
            p_j[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
            } else {
                // outline
                has_out = true;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p_x - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist =
                        sqrt((p[0] - p_x[0]) * (p[0] - p_x[0]) +
                            (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist &gt; max_dis) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        }
    }
    size_t count = 0;
    double min_area = std::numeric_limits&lt;double&gt;::max();
    for (size_t i = min_point_index;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        Eigen::Vector3d p_j;
        p_j[0] = obj-&gt;polygon.points[j].x;
        p_j[1] = obj-&gt;polygon.points[j].y;
        p_j[2] = obj-&gt;polygon.points[j].z;
        double dist = sqrt((p_x[0] - p_j[0]) * (p_x[0] - p_j[0])
                + (p_x[1] - p_j[1])* (p_x[1] - p_j[1]));
        if (dist &lt; max_dis &amp;&amp; (dist / total_len) &lt; 0.5) {
            continue;
        }
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0;
                double width = 0;
                Eigen::Vector3d dir;
                double area =
                    ComputeAreaAlongOneEdge(obj, i,
                                        &amp;center, &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                    || (i == max_point_index &amp;&amp; j == min_point_index)) {
            if (!has_out) {
                continue;
            }
            Eigen::Vector3d center;
            double length = 0;
            double width = 0;
            Eigen::Vector3d dir;
            double area =
               ComputeAreaAlongOneEdge(obj, i, &amp;center, &amp;length, &amp;width, &amp;dir);
            if (area &lt; min_area) {
                obj-&gt;center = center;
                obj-&gt;length = length;
                obj-&gt;width = width;
                obj-&gt;direction = dir;
                min_area = area;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[i].x;
            p[1] = obj-&gt;polygon.points[i].y;
            p[2] = obj-&gt;polygon.points[i].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0.0;
                double width = 0.0;
                Eigen::Vector3d dir;
                double area =
                   ComputeAreaAlongOneEdge(obj, i, &amp;center,
                                           &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        }
    }
    obj-&gt;direction.normalize();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.cc" startLine="(133, 0)" endLine="(318, 1)" clone_start="16" clone_end="22">
			<code function_name="MinBoxObjectBuilder::ReconstructPolygon(const Eigen::Vector3d &amp;ref_ct, ObjectPtr obj)">void  MinBoxObjectBuilder::ReconstructPolygon(
        const Eigen::Vector3d &amp;ref_ct,
        ObjectPtr obj) {
    if (obj-&gt;polygon.points.size() &lt;= 0) {
        return;
    }
    size_t max_point_index = 0;
    size_t min_point_index = 0;
    Eigen::Vector3d p;
    p[0] = obj-&gt;polygon.points[0].x;
    p[1] = obj-&gt;polygon.points[0].y;
    p[2] = obj-&gt;polygon.points[0].z;
    Eigen::Vector3d max_point = p - ref_ct;
    Eigen::Vector3d min_point = p - ref_ct;
    for (size_t i = 1; i &lt; obj-&gt;polygon.points.size(); ++i) {
        Eigen::Vector3d p;
        p[0] = obj-&gt;polygon.points[i].x;
        p[1] = obj-&gt;polygon.points[i].y;
        p[2] = obj-&gt;polygon.points[i].z;
        Eigen::Vector3d ray = p - ref_ct;
        // clock direction
        if (max_point[0] * ray[1] - ray[0] * max_point[1] &lt; EPSILON) {
            max_point = ray;
            max_point_index = i;
        }
        // unclock direction
        if (min_point[0] * ray[1] - ray[0] * min_point[1] &gt; EPSILON) {
            min_point = ray;
            min_point_index = i;
        }
    }
    Eigen::Vector3d line = max_point - min_point;
    double total_len = 0;
    double max_dis = 0;
    bool has_out = false;
    for (size_t i = min_point_index, count = 0;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist = sqrt((p[0] - p_x[0]) * (p[0] - p_x[0])
                        + (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist - max_dis &gt; EPSILON) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                   || (i == max_point_index &amp;&amp; j == min_point_index)) {
            size_t k = (j + 1) % obj-&gt;polygon.points.size();
            Eigen::Vector3d p_k;
            p_k[0] = obj-&gt;polygon.points[k].x;
            p_k[1] = obj-&gt;polygon.points[k].y;
            p_k[2] = obj-&gt;polygon.points[k].z;
            Eigen::Vector3d p_j;
            p_j[0] = obj-&gt;polygon.points[j].x;
            p_j[1] = obj-&gt;polygon.points[j].y;
            p_j[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
            } else {
                // outline
                has_out = true;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p_x - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist =
                        sqrt((p[0] - p_x[0]) * (p[0] - p_x[0]) +
                            (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist &gt; max_dis) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        }
    }
    size_t count = 0;
    double min_area = std::numeric_limits&lt;double&gt;::max();
    for (size_t i = min_point_index;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        Eigen::Vector3d p_j;
        p_j[0] = obj-&gt;polygon.points[j].x;
        p_j[1] = obj-&gt;polygon.points[j].y;
        p_j[2] = obj-&gt;polygon.points[j].z;
        double dist = sqrt((p_x[0] - p_j[0]) * (p_x[0] - p_j[0])
                + (p_x[1] - p_j[1])* (p_x[1] - p_j[1]));
        if (dist &lt; max_dis &amp;&amp; (dist / total_len) &lt; 0.5) {
            continue;
        }
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0;
                double width = 0;
                Eigen::Vector3d dir;
                double area =
                    ComputeAreaAlongOneEdge(obj, i,
                                        &amp;center, &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                    || (i == max_point_index &amp;&amp; j == min_point_index)) {
            if (!has_out) {
                continue;
            }
            Eigen::Vector3d center;
            double length = 0;
            double width = 0;
            Eigen::Vector3d dir;
            double area =
               ComputeAreaAlongOneEdge(obj, i, &amp;center, &amp;length, &amp;width, &amp;dir);
            if (area &lt; min_area) {
                obj-&gt;center = center;
                obj-&gt;length = length;
                obj-&gt;width = width;
                obj-&gt;direction = dir;
                min_area = area;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[i].x;
            p[1] = obj-&gt;polygon.points[i].y;
            p[2] = obj-&gt;polygon.points[i].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0.0;
                double width = 0.0;
                Eigen::Vector3d dir;
                double area =
                   ComputeAreaAlongOneEdge(obj, i, &amp;center,
                                           &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        }
    }
    obj-&gt;direction.normalize();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\curve1d\quintic_polynomial_curve1d.h" startLine="(47, 2)" endLine="(47, 48)" clone_start="1" clone_end="1">
			<code function_name="~QuinticPolynomialCurve1d()">  virtual ~QuinticPolynomialCurve1d() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\curve1d\quartic_polynomial_curve1d.h" startLine="(46, 2)" endLine="(46, 48)" clone_start="1" clone_end="1">
			<code function_name="~QuarticPolynomialCurve1d()">  virtual ~QuarticPolynomialCurve1d() = default;</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.cc" startLine="(133, 0)" endLine="(318, 1)" clone_start="160" clone_end="165">
			<code function_name="MinBoxObjectBuilder::ReconstructPolygon(const Eigen::Vector3d &amp;ref_ct, ObjectPtr obj)">void  MinBoxObjectBuilder::ReconstructPolygon(
        const Eigen::Vector3d &amp;ref_ct,
        ObjectPtr obj) {
    if (obj-&gt;polygon.points.size() &lt;= 0) {
        return;
    }
    size_t max_point_index = 0;
    size_t min_point_index = 0;
    Eigen::Vector3d p;
    p[0] = obj-&gt;polygon.points[0].x;
    p[1] = obj-&gt;polygon.points[0].y;
    p[2] = obj-&gt;polygon.points[0].z;
    Eigen::Vector3d max_point = p - ref_ct;
    Eigen::Vector3d min_point = p - ref_ct;
    for (size_t i = 1; i &lt; obj-&gt;polygon.points.size(); ++i) {
        Eigen::Vector3d p;
        p[0] = obj-&gt;polygon.points[i].x;
        p[1] = obj-&gt;polygon.points[i].y;
        p[2] = obj-&gt;polygon.points[i].z;
        Eigen::Vector3d ray = p - ref_ct;
        // clock direction
        if (max_point[0] * ray[1] - ray[0] * max_point[1] &lt; EPSILON) {
            max_point = ray;
            max_point_index = i;
        }
        // unclock direction
        if (min_point[0] * ray[1] - ray[0] * min_point[1] &gt; EPSILON) {
            min_point = ray;
            min_point_index = i;
        }
    }
    Eigen::Vector3d line = max_point - min_point;
    double total_len = 0;
    double max_dis = 0;
    bool has_out = false;
    for (size_t i = min_point_index, count = 0;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist = sqrt((p[0] - p_x[0]) * (p[0] - p_x[0])
                        + (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist - max_dis &gt; EPSILON) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                   || (i == max_point_index &amp;&amp; j == min_point_index)) {
            size_t k = (j + 1) % obj-&gt;polygon.points.size();
            Eigen::Vector3d p_k;
            p_k[0] = obj-&gt;polygon.points[k].x;
            p_k[1] = obj-&gt;polygon.points[k].y;
            p_k[2] = obj-&gt;polygon.points[k].z;
            Eigen::Vector3d p_j;
            p_j[0] = obj-&gt;polygon.points[j].x;
            p_j[1] = obj-&gt;polygon.points[j].y;
            p_j[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
            } else {
                // outline
                has_out = true;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p_x - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist =
                        sqrt((p[0] - p_x[0]) * (p[0] - p_x[0]) +
                            (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist &gt; max_dis) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        }
    }
    size_t count = 0;
    double min_area = std::numeric_limits&lt;double&gt;::max();
    for (size_t i = min_point_index;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        Eigen::Vector3d p_j;
        p_j[0] = obj-&gt;polygon.points[j].x;
        p_j[1] = obj-&gt;polygon.points[j].y;
        p_j[2] = obj-&gt;polygon.points[j].z;
        double dist = sqrt((p_x[0] - p_j[0]) * (p_x[0] - p_j[0])
                + (p_x[1] - p_j[1])* (p_x[1] - p_j[1]));
        if (dist &lt; max_dis &amp;&amp; (dist / total_len) &lt; 0.5) {
            continue;
        }
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0;
                double width = 0;
                Eigen::Vector3d dir;
                double area =
                    ComputeAreaAlongOneEdge(obj, i,
                                        &amp;center, &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                    || (i == max_point_index &amp;&amp; j == min_point_index)) {
            if (!has_out) {
                continue;
            }
            Eigen::Vector3d center;
            double length = 0;
            double width = 0;
            Eigen::Vector3d dir;
            double area =
               ComputeAreaAlongOneEdge(obj, i, &amp;center, &amp;length, &amp;width, &amp;dir);
            if (area &lt; min_area) {
                obj-&gt;center = center;
                obj-&gt;length = length;
                obj-&gt;width = width;
                obj-&gt;direction = dir;
                min_area = area;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[i].x;
            p[1] = obj-&gt;polygon.points[i].y;
            p[2] = obj-&gt;polygon.points[i].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0.0;
                double width = 0.0;
                Eigen::Vector3d dir;
                double area =
                   ComputeAreaAlongOneEdge(obj, i, &amp;center,
                                           &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        }
    }
    obj-&gt;direction.normalize();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.cc" startLine="(133, 0)" endLine="(318, 1)" clone_start="118" clone_end="123">
			<code function_name="MinBoxObjectBuilder::ReconstructPolygon(const Eigen::Vector3d &amp;ref_ct, ObjectPtr obj)">void  MinBoxObjectBuilder::ReconstructPolygon(
        const Eigen::Vector3d &amp;ref_ct,
        ObjectPtr obj) {
    if (obj-&gt;polygon.points.size() &lt;= 0) {
        return;
    }
    size_t max_point_index = 0;
    size_t min_point_index = 0;
    Eigen::Vector3d p;
    p[0] = obj-&gt;polygon.points[0].x;
    p[1] = obj-&gt;polygon.points[0].y;
    p[2] = obj-&gt;polygon.points[0].z;
    Eigen::Vector3d max_point = p - ref_ct;
    Eigen::Vector3d min_point = p - ref_ct;
    for (size_t i = 1; i &lt; obj-&gt;polygon.points.size(); ++i) {
        Eigen::Vector3d p;
        p[0] = obj-&gt;polygon.points[i].x;
        p[1] = obj-&gt;polygon.points[i].y;
        p[2] = obj-&gt;polygon.points[i].z;
        Eigen::Vector3d ray = p - ref_ct;
        // clock direction
        if (max_point[0] * ray[1] - ray[0] * max_point[1] &lt; EPSILON) {
            max_point = ray;
            max_point_index = i;
        }
        // unclock direction
        if (min_point[0] * ray[1] - ray[0] * min_point[1] &gt; EPSILON) {
            min_point = ray;
            min_point_index = i;
        }
    }
    Eigen::Vector3d line = max_point - min_point;
    double total_len = 0;
    double max_dis = 0;
    bool has_out = false;
    for (size_t i = min_point_index, count = 0;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist = sqrt((p[0] - p_x[0]) * (p[0] - p_x[0])
                        + (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist - max_dis &gt; EPSILON) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                   || (i == max_point_index &amp;&amp; j == min_point_index)) {
            size_t k = (j + 1) % obj-&gt;polygon.points.size();
            Eigen::Vector3d p_k;
            p_k[0] = obj-&gt;polygon.points[k].x;
            p_k[1] = obj-&gt;polygon.points[k].y;
            p_k[2] = obj-&gt;polygon.points[k].z;
            Eigen::Vector3d p_j;
            p_j[0] = obj-&gt;polygon.points[j].x;
            p_j[1] = obj-&gt;polygon.points[j].y;
            p_j[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
            } else {
                // outline
                has_out = true;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p_x - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist =
                        sqrt((p[0] - p_x[0]) * (p[0] - p_x[0]) +
                            (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist &gt; max_dis) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        }
    }
    size_t count = 0;
    double min_area = std::numeric_limits&lt;double&gt;::max();
    for (size_t i = min_point_index;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        Eigen::Vector3d p_j;
        p_j[0] = obj-&gt;polygon.points[j].x;
        p_j[1] = obj-&gt;polygon.points[j].y;
        p_j[2] = obj-&gt;polygon.points[j].z;
        double dist = sqrt((p_x[0] - p_j[0]) * (p_x[0] - p_j[0])
                + (p_x[1] - p_j[1])* (p_x[1] - p_j[1]));
        if (dist &lt; max_dis &amp;&amp; (dist / total_len) &lt; 0.5) {
            continue;
        }
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0;
                double width = 0;
                Eigen::Vector3d dir;
                double area =
                    ComputeAreaAlongOneEdge(obj, i,
                                        &amp;center, &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                    || (i == max_point_index &amp;&amp; j == min_point_index)) {
            if (!has_out) {
                continue;
            }
            Eigen::Vector3d center;
            double length = 0;
            double width = 0;
            Eigen::Vector3d dir;
            double area =
               ComputeAreaAlongOneEdge(obj, i, &amp;center, &amp;length, &amp;width, &amp;dir);
            if (area &lt; min_area) {
                obj-&gt;center = center;
                obj-&gt;length = length;
                obj-&gt;width = width;
                obj-&gt;direction = dir;
                min_area = area;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[i].x;
            p[1] = obj-&gt;polygon.points[i].y;
            p[2] = obj-&gt;polygon.points[i].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0.0;
                double width = 0.0;
                Eigen::Vector3d dir;
                double area =
                   ComputeAreaAlongOneEdge(obj, i, &amp;center,
                                           &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        }
    }
    obj-&gt;direction.normalize();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.cc" startLine="(133, 0)" endLine="(318, 1)" clone_start="68" clone_end="73">
			<code function_name="MinBoxObjectBuilder::ReconstructPolygon(const Eigen::Vector3d &amp;ref_ct, ObjectPtr obj)">void  MinBoxObjectBuilder::ReconstructPolygon(
        const Eigen::Vector3d &amp;ref_ct,
        ObjectPtr obj) {
    if (obj-&gt;polygon.points.size() &lt;= 0) {
        return;
    }
    size_t max_point_index = 0;
    size_t min_point_index = 0;
    Eigen::Vector3d p;
    p[0] = obj-&gt;polygon.points[0].x;
    p[1] = obj-&gt;polygon.points[0].y;
    p[2] = obj-&gt;polygon.points[0].z;
    Eigen::Vector3d max_point = p - ref_ct;
    Eigen::Vector3d min_point = p - ref_ct;
    for (size_t i = 1; i &lt; obj-&gt;polygon.points.size(); ++i) {
        Eigen::Vector3d p;
        p[0] = obj-&gt;polygon.points[i].x;
        p[1] = obj-&gt;polygon.points[i].y;
        p[2] = obj-&gt;polygon.points[i].z;
        Eigen::Vector3d ray = p - ref_ct;
        // clock direction
        if (max_point[0] * ray[1] - ray[0] * max_point[1] &lt; EPSILON) {
            max_point = ray;
            max_point_index = i;
        }
        // unclock direction
        if (min_point[0] * ray[1] - ray[0] * min_point[1] &gt; EPSILON) {
            min_point = ray;
            min_point_index = i;
        }
    }
    Eigen::Vector3d line = max_point - min_point;
    double total_len = 0;
    double max_dis = 0;
    bool has_out = false;
    for (size_t i = min_point_index, count = 0;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist = sqrt((p[0] - p_x[0]) * (p[0] - p_x[0])
                        + (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist - max_dis &gt; EPSILON) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                   || (i == max_point_index &amp;&amp; j == min_point_index)) {
            size_t k = (j + 1) % obj-&gt;polygon.points.size();
            Eigen::Vector3d p_k;
            p_k[0] = obj-&gt;polygon.points[k].x;
            p_k[1] = obj-&gt;polygon.points[k].y;
            p_k[2] = obj-&gt;polygon.points[k].z;
            Eigen::Vector3d p_j;
            p_j[0] = obj-&gt;polygon.points[j].x;
            p_j[1] = obj-&gt;polygon.points[j].y;
            p_j[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
            } else {
                // outline
                has_out = true;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p_x - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist =
                        sqrt((p[0] - p_x[0]) * (p[0] - p_x[0]) +
                            (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist &gt; max_dis) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        }
    }
    size_t count = 0;
    double min_area = std::numeric_limits&lt;double&gt;::max();
    for (size_t i = min_point_index;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        Eigen::Vector3d p_j;
        p_j[0] = obj-&gt;polygon.points[j].x;
        p_j[1] = obj-&gt;polygon.points[j].y;
        p_j[2] = obj-&gt;polygon.points[j].z;
        double dist = sqrt((p_x[0] - p_j[0]) * (p_x[0] - p_j[0])
                + (p_x[1] - p_j[1])* (p_x[1] - p_j[1]));
        if (dist &lt; max_dis &amp;&amp; (dist / total_len) &lt; 0.5) {
            continue;
        }
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0;
                double width = 0;
                Eigen::Vector3d dir;
                double area =
                    ComputeAreaAlongOneEdge(obj, i,
                                        &amp;center, &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                    || (i == max_point_index &amp;&amp; j == min_point_index)) {
            if (!has_out) {
                continue;
            }
            Eigen::Vector3d center;
            double length = 0;
            double width = 0;
            Eigen::Vector3d dir;
            double area =
               ComputeAreaAlongOneEdge(obj, i, &amp;center, &amp;length, &amp;width, &amp;dir);
            if (area &lt; min_area) {
                obj-&gt;center = center;
                obj-&gt;length = length;
                obj-&gt;width = width;
                obj-&gt;direction = dir;
                min_area = area;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[i].x;
            p[1] = obj-&gt;polygon.points[i].y;
            p[2] = obj-&gt;polygon.points[i].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0.0;
                double width = 0.0;
                Eigen::Vector3d dir;
                double area =
                   ComputeAreaAlongOneEdge(obj, i, &amp;center,
                                           &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        }
    }
    obj-&gt;direction.normalize();
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(26, 0)" endLine="(33, 1)" clone_start="1" clone_end="8">
			<code function_name="Throttleinfo75::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Throttleinfo75::Parse(const std::uint8_t *bytes, int32_t length,
                           ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_ems()-&gt;set_engine_rpm(engine_rpm(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_accelerator_pedal(
      acc_pedal_percent(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_accelerator_pedal_rate(
      acc_pedal_rate(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6d.cc" startLine="(26, 0)" endLine="(31, 1)" clone_start="1" clone_end="6">
			<code function_name="Gps6d::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Gps6d::Parse(const std::uint8_t *bytes, int32_t length,
                  ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_basic()-&gt;set_latitude(latitude(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_longitude(longitude(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_gps_valid(is_valid(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(29, 0)" endLine="(37, 1)" clone_start="1" clone_end="9">
			<code function_name="Accel6b::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Accel6b::Parse(const std::uint8_t *bytes, int32_t length,
                    ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_lat_acc(
      lateral_acceleration(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_long_acc(
      longitudinal_acceleration(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_vert_acc(
      vertical_acceleration(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(35, 0)" endLine="(43, 1)" clone_start="1" clone_end="1">
			<code function_name="Throttleinfo75::engine_rpm(const std::uint8_t *bytes, int32_t length) const">double Throttleinfo75::engine_rpm(const std::uint8_t *bytes,
                                  int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.25;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6d.cc" startLine="(33, 0)" endLine="(57, 1)" clone_start="1" clone_end="1">
			<code function_name="Gps6d::latitude(const std::uint8_t *bytes, int32_t length) const">double Gps6d::latitude(const std::uint8_t *bytes, int32_t length) const {
  Byte frame_0(bytes + 3);
  int32_t value = frame_0.get_byte(0, 7);

  Byte frame_1(bytes + 2);
  int32_t t = frame_1.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_2(bytes + 1);
  t = frame_2.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_3(bytes);
  t = frame_3.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  if (value &gt; 0x3FFFFFFF) {
    value -= 0x80000000;
  }

  return value * (1.000000 / 3.000000) * 1e-6;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(39, 0)" endLine="(43, 1)" clone_start="1" clone_end="1">
			<code function_name="Accel6b::lateral_acceleration(const std::uint8_t *bytes, const int32_t length) const">double Accel6b::lateral_acceleration(const std::uint8_t *bytes,
                                     const int32_t length) const {
  DCHECK_GE(length, 2);
  return parse_two_frames(bytes[0], bytes[1]);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\polygon2d.cc" startLine="(110, 0)" endLine="(116, 1)" clone_start="2" clone_end="7">
			<code function_name="Polygon2d::DistanceToBoundary(const Vec2d &amp;point) const">double Polygon2d::DistanceToBoundary(const Vec2d &amp;point) const {
  double distance = std::numeric_limits&lt;double&gt;::infinity();
  for (int i = 0; i &lt; num_points_; ++i) {
    distance = std::min(distance, line_segments_[i].DistanceTo(point));
  }
  return distance;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\polygon2d.cc" startLine="(40, 0)" endLine="(50, 1)" clone_start="6" clone_end="11">
			<code function_name="Polygon2d::DistanceTo(const Vec2d &amp;point) const">double Polygon2d::DistanceTo(const Vec2d &amp;point) const {
  CHECK_GE(points_.size(), 3);
  if (IsPointIn(point)) {
    return 0.0;
  }
  double distance = std::numeric_limits&lt;double&gt;::infinity();
  for (int i = 0; i &lt; num_points_; ++i) {
    distance = std::min(distance, line_segments_[i].DistanceTo(point));
  }
  return distance;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\polygon2d.cc" startLine="(118, 0)" endLine="(123, 1)" clone_start="1" clone_end="2">
			<code function_name="Polygon2d::IsPointOnBoundary(const Vec2d &amp;point) const">bool Polygon2d::IsPointOnBoundary(const Vec2d &amp;point) const {
  CHECK_GE(points_.size(), 3);
  return std::any_of(
      line_segments_.begin(), line_segments_.end(),
      [&amp;](const LineSegment2d &amp;poly_seg) { return poly_seg.IsPointIn(point); });
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\polygon2d.cc" startLine="(52, 0)" endLine="(63, 1)" clone_start="1" clone_end="2">
			<code function_name="Polygon2d::DistanceSquareTo(const Vec2d &amp;point) const">double Polygon2d::DistanceSquareTo(const Vec2d &amp;point) const {
  CHECK_GE(points_.size(), 3);
  if (IsPointIn(point)) {
    return 0.0;
  }
  double distance_sqr = std::numeric_limits&lt;double&gt;::infinity();
  for (int i = 0; i &lt; num_points_; ++i) {
    distance_sqr =
        std::min(distance_sqr, line_segments_[i].DistanceSquareTo(point));
  }
  return distance_sqr;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(280, 0)" endLine="(309, 1)" clone_start="17" clone_end="24">
			<code function_name="ProtoOrganizer::GetJunctionObjectOverlapElements( const std::vector&lt;JunctionInternal&gt;&amp; junctions)">void ProtoOrganizer::GetJunctionObjectOverlapElements(
    const std::vector&lt;JunctionInternal&gt;&amp; junctions) {
  for (auto&amp; junction_internal : junctions) {
    std::string junction_id = junction_internal.junction.id().id();
    for (auto&amp; overlap_junction : junction_internal.overlap_with_junctions) {
      PbOverlap overlap;
      std::string overlap_id = CreateOverlapId();
      proto_data_.pb_junctions[junction_id].add_overlap_id()-&gt;set_id(
          overlap_id);
      overlap.mutable_id()-&gt;set_id(overlap_id);
      PbObjectOverlapInfo* object_overlap = overlap.add_object();
      object_overlap-&gt;mutable_id()-&gt;set_id(junction_id);
      std::string object_id = overlap_junction.object_id;
      object_overlap = overlap.add_object();
      object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
      if (proto_data_.pb_crosswalks.count(object_id) &gt; 0) {
        object_overlap-&gt;mutable_crosswalk_overlap_info();
        proto_data_.pb_crosswalks[object_id].add_overlap_id()-&gt;set_id(
            overlap_id);
      } else if (proto_data_.pb_clear_areas.count(object_id) &gt; 0) {
        object_overlap-&gt;mutable_clear_area_overlap_info();
        proto_data_.pb_clear_areas[object_id].add_overlap_id()-&gt;set_id(
            overlap_id);
      } else {
        continue;
      }
      proto_data_.pb_overlaps[overlap_id] = overlap;
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(153, 0)" endLine="(193, 1)" clone_start="30" clone_end="36">
			<code function_name="ProtoOrganizer::GetLaneSignalOverlapElements(    const std::string&amp; lane_id, const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes)">void ProtoOrganizer::GetLaneSignalOverlapElements(
    const std::string&amp; lane_id,
    const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes) {
  for (auto&amp; overlap_signal : overlap_with_lanes) {
    std::string object_id = overlap_signal.object_id;
    if (proto_data_.pb_signals.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_stop_signs.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_yield_signs.count(object_id) &lt;= 0) {
      AINFO &lt;&lt; "cannot find signal object_id:" &lt;&lt; object_id;
      continue;
    }
    PbOverlap overlap;
    std::string overlap_id = CreateOverlapId();
    proto_data_.pb_lanes[lane_id].add_overlap_id()-&gt;set_id(overlap_id);
    overlap.mutable_id()-&gt;set_id(overlap_id);
    PbObjectOverlapInfo* object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(lane_id);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_start_s(
        overlap_signal.start_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_end_s(
        overlap_signal.end_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_is_merge(
        overlap_signal.is_merge);
    object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
    if (proto_data_.pb_signals.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_signal_overlap_info();
      proto_data_.pb_signals[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    } else if (proto_data_.pb_stop_signs.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_stop_sign_overlap_info();
      proto_data_.pb_stop_signs[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    } else if (proto_data_.pb_yield_signs.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_yield_sign_overlap_info();
      proto_data_.pb_yield_signs[object_id].add_overlap_id()-&gt;set_id(
          overlap_id);
    } else {
      AERROR &lt;&lt; "unknown signal, signal id:" &lt;&lt; object_id;
    }
    proto_data_.pb_overlaps[overlap_id] = overlap;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\predictor_manager.cc" startLine="(141, 0)" endLine="(160, 1)" clone_start="9" clone_end="15">
			<code function_name="PredictorManager::CreatePredictor( const ObstacleConf::PredictorType&amp; type)">std::unique_ptr&lt;Predictor&gt; PredictorManager::CreatePredictor(
    const ObstacleConf::PredictorType&amp; type) {
  std::unique_ptr&lt;Predictor&gt; predictor_ptr(nullptr);
  switch (type) {
    case ObstacleConf::LANE_SEQUENCE_PREDICTOR: {
      predictor_ptr.reset(new LaneSequencePredictor());
      break;
    }
    case ObstacleConf::FREE_MOVE_PREDICTOR: {
      predictor_ptr.reset(new FreeMovePredictor());
      break;
    }
    case ObstacleConf::REGIONAL_PREDICTOR: {
      predictor_ptr.reset(new RegionalPredictor());
      break;
    }
    default: { break; }
  }
  return predictor_ptr;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\predictor_manager.cc" startLine="(141, 0)" endLine="(160, 1)" clone_start="5" clone_end="11">
			<code function_name="PredictorManager::CreatePredictor( const ObstacleConf::PredictorType&amp; type)">std::unique_ptr&lt;Predictor&gt; PredictorManager::CreatePredictor(
    const ObstacleConf::PredictorType&amp; type) {
  std::unique_ptr&lt;Predictor&gt; predictor_ptr(nullptr);
  switch (type) {
    case ObstacleConf::LANE_SEQUENCE_PREDICTOR: {
      predictor_ptr.reset(new LaneSequencePredictor());
      break;
    }
    case ObstacleConf::FREE_MOVE_PREDICTOR: {
      predictor_ptr.reset(new FreeMovePredictor());
      break;
    }
    case ObstacleConf::REGIONAL_PREDICTOR: {
      predictor_ptr.reset(new RegionalPredictor());
      break;
    }
    default: { break; }
  }
  return predictor_ptr;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\parser_nodelet.cpp" startLine="(39, 0)" endLine="(72, 1)" clone_start="12" clone_end="22">
			<code function_name="ParserNodelet::onInit()">void ParserNodelet::onInit() {
  ros::NodeHandle&amp; nh = getPrivateNodeHandle();
  std::string gnss_conf;
  std::string raw_data_topic;
  std::string ins_stat_topic;
  std::string corr_imu_topic;
  std::string odometry_topic;
  std::string gnss_status_topic;
  std::string ins_status_topic;

  nh.param("gnss_conf", gnss_conf, std::string("./conf/gnss_conf.txt"));
  nh.param("raw_data_topic", raw_data_topic,
           std::string("/apollo/sensor/gnss/raw_data"));
  nh.param("ins_stat_topic", ins_stat_topic,
           std::string("/apollo/sensor/gnss/ins_stat"));
  nh.param("corr_imu_topic", corr_imu_topic,
           std::string("/apollo/sensor/gnss/corrected_imu"));
  nh.param("odometry_topic", odometry_topic,
           std::string("/apollo/sensor/gnss/odometry"));
  nh.param("gnss_status_topic", gnss_status_topic,
           std::string("/apollo/sensor/gnss/gnss_status"));
  nh.param("ins_status_topic", ins_status_topic,
           std::string("/apollo/sensor/gnss/ins_status"));

  _data_parser.reset(new DataParser(nh, raw_data_topic, ins_stat_topic,
                                    corr_imu_topic, odometry_topic,
                                    gnss_status_topic, ins_status_topic));
  if (!_data_parser-&gt;init(gnss_conf)) {
    ROS_ERROR("Init parser nodelet failed.");
    ROS_ERROR_STREAM("Init parser nodelet failed.");
    return;
  }
  ROS_INFO("Init parser nodelet success.");
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\parser_nodelet.cpp" startLine="(39, 0)" endLine="(72, 1)" clone_start="11" clone_end="20">
			<code function_name="ParserNodelet::onInit()">void ParserNodelet::onInit() {
  ros::NodeHandle&amp; nh = getPrivateNodeHandle();
  std::string gnss_conf;
  std::string raw_data_topic;
  std::string ins_stat_topic;
  std::string corr_imu_topic;
  std::string odometry_topic;
  std::string gnss_status_topic;
  std::string ins_status_topic;

  nh.param("gnss_conf", gnss_conf, std::string("./conf/gnss_conf.txt"));
  nh.param("raw_data_topic", raw_data_topic,
           std::string("/apollo/sensor/gnss/raw_data"));
  nh.param("ins_stat_topic", ins_stat_topic,
           std::string("/apollo/sensor/gnss/ins_stat"));
  nh.param("corr_imu_topic", corr_imu_topic,
           std::string("/apollo/sensor/gnss/corrected_imu"));
  nh.param("odometry_topic", odometry_topic,
           std::string("/apollo/sensor/gnss/odometry"));
  nh.param("gnss_status_topic", gnss_status_topic,
           std::string("/apollo/sensor/gnss/gnss_status"));
  nh.param("ins_status_topic", ins_status_topic,
           std::string("/apollo/sensor/gnss/ins_status"));

  _data_parser.reset(new DataParser(nh, raw_data_topic, ins_stat_topic,
                                    corr_imu_topic, odometry_topic,
                                    gnss_status_topic, ins_status_topic));
  if (!_data_parser-&gt;init(gnss_conf)) {
    ROS_ERROR("Init parser nodelet failed.");
    ROS_ERROR_STREAM("Init parser nodelet failed.");
    return;
  }
  ROS_INFO("Init parser nodelet success.");
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\tools\terminal.cc" startLine="(129, 0)" endLine="(170, 1)" clone_start="23" clone_end="31">
			<code function_name="main(int argc, char **argv)">int main(int argc, char **argv) {
  google::InitGoogleLogging(argv[0]);
  FLAGS_alsologtostderr = true;
  FLAGS_v = 3;

  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);

  using apollo::common::adapter::AdapterManagerConfig;
  using apollo::common::adapter::AdapterManager;
  using apollo::common::adapter::AdapterConfig;

  ros::init(argc, argv, "terminal");

  AdapterManagerConfig config;
  config.set_is_ros(true);
  {
    auto *sub_config = config.add_config();
    sub_config-&gt;set_mode(AdapterConfig::PUBLISH_ONLY);
    sub_config-&gt;set_type(AdapterConfig::PAD);
  }

  {
    auto *sub_config = config.add_config();
    sub_config-&gt;set_mode(AdapterConfig::RECEIVE_ONLY);
    sub_config-&gt;set_type(AdapterConfig::CHASSIS);
  }

  {
    auto *sub_config = config.add_config();
    sub_config-&gt;set_mode(AdapterConfig::RECEIVE_ONLY);
    sub_config-&gt;set_type(AdapterConfig::LOCALIZATION);
  }

  AdapterManager::Init(config);
  AdapterManager::AddChassisCallback(on_chassis);

  help();
  std::thread terminal_thread(terminal_thread_func);
  ros::spin();
  terminal_thread.join();
  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\tools\terminal.cc" startLine="(129, 0)" endLine="(170, 1)" clone_start="17" clone_end="25">
			<code function_name="main(int argc, char **argv)">int main(int argc, char **argv) {
  google::InitGoogleLogging(argv[0]);
  FLAGS_alsologtostderr = true;
  FLAGS_v = 3;

  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);

  using apollo::common::adapter::AdapterManagerConfig;
  using apollo::common::adapter::AdapterManager;
  using apollo::common::adapter::AdapterConfig;

  ros::init(argc, argv, "terminal");

  AdapterManagerConfig config;
  config.set_is_ros(true);
  {
    auto *sub_config = config.add_config();
    sub_config-&gt;set_mode(AdapterConfig::PUBLISH_ONLY);
    sub_config-&gt;set_type(AdapterConfig::PAD);
  }

  {
    auto *sub_config = config.add_config();
    sub_config-&gt;set_mode(AdapterConfig::RECEIVE_ONLY);
    sub_config-&gt;set_type(AdapterConfig::CHASSIS);
  }

  {
    auto *sub_config = config.add_config();
    sub_config-&gt;set_mode(AdapterConfig::RECEIVE_ONLY);
    sub_config-&gt;set_type(AdapterConfig::LOCALIZATION);
  }

  AdapterManager::Init(config);
  AdapterManager::AddChassisCallback(on_chassis);

  help();
  std::thread terminal_thread(terminal_thread_func);
  ros::spin();
  terminal_thread.join();
  return 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\reference_line\reference_line_smoother.cc" startLine="(239, 0)" endLine="(257, 1)" clone_start="10" clone_end="15">
			<code function_name="ReferenceLineSmoother::ExtractEvaluatedPoints(const ReferenceLine&amp; raw_reference_line, const std::vector&lt;double&gt;&amp; vec_t, std::vector&lt;common::PathPoint&gt;* const path_points) const">bool ReferenceLineSmoother::ExtractEvaluatedPoints(
    const ReferenceLine&amp; raw_reference_line, const std::vector&lt;double&gt;&amp; vec_t,
    std::vector&lt;common::PathPoint&gt;* const path_points) const {
  for (const auto t : vec_t) {
    double s = 0.0;
    if (!GetSFromParamT(t, &amp;s)) {
      AERROR &lt;&lt; "get s from " &lt;&lt; t &lt;&lt; " failed";
      return false;
    }
    const ReferencePoint rlp = raw_reference_line.GetReferencePoint(s);
    common::PathPoint path_point;
    path_point.set_x(rlp.x());
    path_point.set_y(rlp.y());
    path_point.set_theta(rlp.heading());
    path_point.set_s(s);
    path_points-&gt;push_back(std::move(path_point));
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\reference_line\reference_line_smoother.cc" startLine="(133, 0)" endLine="(151, 1)" clone_start="7" clone_end="12">
			<code function_name="ReferenceLineSmoother::Sampling(const ReferenceLine&amp; raw_reference_line)">bool ReferenceLineSmoother::Sampling(const ReferenceLine&amp; raw_reference_line) {
  const double length = raw_reference_line.Length();
  const double resolution = length / smoother_config_.num_spline();
  double accumulated_s = 0.0;
  for (std::uint32_t i = 0; i &lt;= smoother_config_.num_spline();
       ++i, accumulated_s = std::min(accumulated_s + resolution, length)) {
    ReferencePoint rlp = raw_reference_line.GetReferencePoint(accumulated_s);
    common::PathPoint path_point;
    path_point.set_x(rlp.x());
    path_point.set_y(rlp.y());
    path_point.set_theta(rlp.heading());
    path_point.set_s(accumulated_s);
    ref_points_.push_back(std::move(path_point));

    // use t_knots_: 0.0, 1.0, 2.0, 3.0 ...
    t_knots_.push_back(i * 1.0);
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\stream_nodelet.cpp" startLine="(47, 0)" endLine="(74, 1)" clone_start="22" clone_end="28">
			<code function_name="StreamNodelet::onInit()">void StreamNodelet::onInit() {
  ros::NodeHandle&amp; nh = getPrivateNodeHandle();
  std::string gnss_conf;
  std::string raw_data_topic;
  std::string rtcm_data_topic;
  std::string stream_status_topic;

  nh.param("gnss_conf", gnss_conf, std::string("./conf/gnss_conf.txt"));
  nh.param("raw_data_topic", raw_data_topic,
           std::string("/apollo/sensor/gnss/raw_data"));
  nh.param("rtcm_data_topic", rtcm_data_topic,
           std::string("/apollo/sensor/gnss/rtcm_data"));
  nh.param("stream_status_topic", stream_status_topic,
           std::string("/apollo/sensor/gnss/stream_status"));

  ROS_INFO_STREAM("gnss conf: " &lt;&lt; gnss_conf);
  ROS_INFO_STREAM("raw data topic: " &lt;&lt; raw_data_topic);

  init_signal();
  _raw_stream.reset(new RawStream(nh, getName(), raw_data_topic,
                                  rtcm_data_topic, stream_status_topic));
  if (!_raw_stream-&gt;init(gnss_conf)) {
    ROS_ERROR("Init stream nodelet failed.");
    ROS_ERROR_STREAM("Init stream nodelet failed.");
    return;
  }
  ROS_INFO("Init stream nodelet success.");
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\parser_nodelet.cpp" startLine="(39, 0)" endLine="(72, 1)" clone_start="28" clone_end="34">
			<code function_name="ParserNodelet::onInit()">void ParserNodelet::onInit() {
  ros::NodeHandle&amp; nh = getPrivateNodeHandle();
  std::string gnss_conf;
  std::string raw_data_topic;
  std::string ins_stat_topic;
  std::string corr_imu_topic;
  std::string odometry_topic;
  std::string gnss_status_topic;
  std::string ins_status_topic;

  nh.param("gnss_conf", gnss_conf, std::string("./conf/gnss_conf.txt"));
  nh.param("raw_data_topic", raw_data_topic,
           std::string("/apollo/sensor/gnss/raw_data"));
  nh.param("ins_stat_topic", ins_stat_topic,
           std::string("/apollo/sensor/gnss/ins_stat"));
  nh.param("corr_imu_topic", corr_imu_topic,
           std::string("/apollo/sensor/gnss/corrected_imu"));
  nh.param("odometry_topic", odometry_topic,
           std::string("/apollo/sensor/gnss/odometry"));
  nh.param("gnss_status_topic", gnss_status_topic,
           std::string("/apollo/sensor/gnss/gnss_status"));
  nh.param("ins_status_topic", ins_status_topic,
           std::string("/apollo/sensor/gnss/ins_status"));

  _data_parser.reset(new DataParser(nh, raw_data_topic, ins_stat_topic,
                                    corr_imu_topic, odometry_topic,
                                    gnss_status_topic, ins_status_topic));
  if (!_data_parser-&gt;init(gnss_conf)) {
    ROS_ERROR("Init parser nodelet failed.");
    ROS_ERROR_STREAM("Init parser nodelet failed.");
    return;
  }
  ROS_INFO("Init parser nodelet success.");
}</code>
		</source>
	</dup>
	<dup count="17">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_range_manager.h" startLine="(30, 2)" endLine="(30, 31)" clone_start="1" clone_end="1">
			<code function_name="TopoRangeManager()">  TopoRangeManager() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_graph.h" startLine="(34, 2)" endLine="(34, 24)" clone_start="1" clone_end="1">
			<code function_name="TopoGraph()">  TopoGraph() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\core\result_generator.h" startLine="(32, 2)" endLine="(32, 30)" clone_start="1" clone_end="1">
			<code function_name="ResultGenerator()">  ResultGenerator() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\core\black_list_range_generator.h" startLine="(32, 2)" endLine="(32, 38)" clone_start="1" clone_end="1">
			<code function_name="BlackListRangeGenerator()">  BlackListRangeGenerator() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\predictor.h" startLine="(43, 2)" endLine="(43, 24)" clone_start="1" clone_end="1">
			<code function_name="Predictor()">  Predictor() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\evaluator\evaluator.h" startLine="(41, 2)" endLine="(41, 24)" clone_start="1" clone_end="1">
			<code function_name="Evaluator()">  Evaluator() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.h" startLine="(54, 2)" endLine="(54, 23)" clone_start="1" clone_end="1">
			<code function_name="Obstacle()">  Obstacle() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\container.h" startLine="(38, 2)" endLine="(38, 24)" clone_start="1" clone_end="1">
			<code function_name="Container()">  Container() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\planner\planner.h" startLine="(48, 2)" endLine="(48, 22)" clone_start="1" clone_end="1">
			<code function_name="Planner()">  Planner() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\curve1d\curve1d.h" startLine="(32, 2)" endLine="(32, 22)" clone_start="1" clone_end="1">
			<code function_name="Curve1d()">  Curve1d() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\trajectory\trajectory.h" startLine="(30, 2)" endLine="(30, 25)" clone_start="1" clone_end="1">
			<code function_name="Trajectory()">  Trajectory() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\onboard\lidar_process.h" startLine="(43, 2)" endLine="(43, 27)" clone_start="1" clone_end="1">
			<code function_name="LidarProcess()">  LidarProcess() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\arc_ball.h" startLine="(26, 2)" endLine="(26, 22)" clone_start="1" clone_end="1">
			<code function_name="ArcBall()">  ArcBall() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\pnc_map.h" startLine="(40, 2)" endLine="(40, 21)" clone_start="1" clone_end="1">
			<code function_name="PncMap()">  PncMap() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\controller\controller.h" startLine="(50, 2)" endLine="(50, 25)" clone_start="1" clone_end="1">
			<code function_name="Controller()">  Controller() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\can_comm\can_sender.h" startLine="(129, 2)" endLine="(129, 24)" clone_start="1" clone_end="1">
			<code function_name="CanSender()">  CanSender() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\can_comm\can_receiver.h" startLine="(48, 2)" endLine="(48, 26)" clone_start="1" clone_end="1">
			<code function_name="CanReceiver()">  CanReceiver() = default;</code>
		</source>
	</dup>
	<dup count="17">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_range_manager.h" startLine="(31, 2)" endLine="(31, 32)" clone_start="1" clone_end="1">
			<code function_name="~TopoRangeManager()">  ~TopoRangeManager() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_graph.h" startLine="(35, 2)" endLine="(35, 25)" clone_start="1" clone_end="1">
			<code function_name="~TopoGraph()">  ~TopoGraph() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\core\result_generator.h" startLine="(33, 2)" endLine="(33, 31)" clone_start="1" clone_end="1">
			<code function_name="~ResultGenerator()">  ~ResultGenerator() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\core\black_list_range_generator.h" startLine="(33, 2)" endLine="(33, 39)" clone_start="1" clone_end="1">
			<code function_name="~BlackListRangeGenerator()">  ~BlackListRangeGenerator() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\predictor.h" startLine="(48, 2)" endLine="(48, 33)" clone_start="1" clone_end="1">
			<code function_name="~Predictor()">  virtual ~Predictor() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\evaluator\evaluator.h" startLine="(46, 2)" endLine="(46, 33)" clone_start="1" clone_end="1">
			<code function_name="~Evaluator()">  virtual ~Evaluator() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.h" startLine="(59, 2)" endLine="(59, 32)" clone_start="1" clone_end="1">
			<code function_name="~Obstacle()">  virtual ~Obstacle() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\container.h" startLine="(43, 2)" endLine="(43, 33)" clone_start="1" clone_end="1">
			<code function_name="~Container()">  virtual ~Container() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\planner\planner.h" startLine="(53, 2)" endLine="(53, 31)" clone_start="1" clone_end="1">
			<code function_name="~Planner()">  virtual ~Planner() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\curve1d\curve1d.h" startLine="(34, 2)" endLine="(34, 31)" clone_start="1" clone_end="1">
			<code function_name="~Curve1d()">  virtual ~Curve1d() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\trajectory\trajectory.h" startLine="(32, 2)" endLine="(32, 34)" clone_start="1" clone_end="1">
			<code function_name="~Trajectory()">  virtual ~Trajectory() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\onboard\lidar_process.h" startLine="(44, 2)" endLine="(44, 28)" clone_start="1" clone_end="1">
			<code function_name="~LidarProcess()">  ~LidarProcess() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\arc_ball.h" startLine="(27, 2)" endLine="(27, 23)" clone_start="1" clone_end="1">
			<code function_name="~ArcBall()">  ~ArcBall() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\pnc_map.h" startLine="(41, 2)" endLine="(41, 30)" clone_start="1" clone_end="1">
			<code function_name="~PncMap()">  virtual ~PncMap() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\controller\controller.h" startLine="(55, 2)" endLine="(55, 34)" clone_start="1" clone_end="1">
			<code function_name="~Controller()">  virtual ~Controller() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\can_comm\can_sender.h" startLine="(134, 2)" endLine="(134, 33)" clone_start="1" clone_end="1">
			<code function_name="~CanSender()">  virtual ~CanSender() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\can_comm\can_receiver.h" startLine="(53, 2)" endLine="(53, 35)" clone_start="1" clone_end="1">
			<code function_name="~CanReceiver()">  virtual ~CanReceiver() = default;</code>
		</source>
	</dup>
	<dup count="12">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="256" clone_end="264">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="190" clone_end="198">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="179" clone_end="187">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="168" clone_end="176">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="157" clone_end="165">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="146" clone_end="154">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="116" clone_end="122">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="106" clone_end="113">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="73" clone_end="81">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="62" clone_end="70">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="51" clone_end="59">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="40" clone_end="46">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\tirepressure_71.cc" startLine="(26, 0)" endLine="(36, 1)" clone_start="1" clone_end="9">
			<code function_name="Tirepressure71::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Tirepressure71::Parse(const std::uint8_t *bytes, int32_t length,
                           ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_safety()-&gt;set_front_left_tire_press(
      front_left_tire(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_front_right_tire_press(
      front_right_tire(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_rear_left_tire_press(
      rear_left_tire(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_rear_right_tire_press(
      rear_right_tire(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(26, 0)" endLine="(50, 1)" clone_start="1" clone_end="7">
			<code function_name="Throttle63::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Throttle63::Parse(const std::uint8_t *bytes, int32_t length,
                       ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_gas()-&gt;set_throttle_input(pedal_input(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_throttle_cmd(pedal_cmd(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_throttle_output(
      pedal_output(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_throttle_enabled(
      is_enabled(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  chassis_detail-&gt;mutable_check_response()-&gt;set_is_vcu_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(26, 0)" endLine="(41, 1)" clone_start="1" clone_end="6">
			<code function_name="Gps6e::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Gps6e::Parse(const std::uint8_t *bytes, int32_t length,
                  ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_basic()-&gt;set_year(year(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_month(month(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_day(day(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_hours(hours(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_minutes(minutes(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_seconds(seconds(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_compass_direction(
      compass_direction(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_pdop(pdop(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_is_gps_fault(
      is_gps_fault(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_is_inferred(
      is_inferred_position(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(29, 0)" endLine="(59, 1)" clone_start="1" clone_end="7">
			<code function_name="Brake61::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brake61::Parse(const std::uint8_t *bytes, int32_t length,
                    ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_output(
      pedal_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  chassis_detail-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(169, 0)" endLine="(169, 52)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::set_z(const double z)">void VehicleState::set_z(const double z) { z_ = z; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(167, 0)" endLine="(167, 52)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::set_y(const double y)">void VehicleState::set_y(const double y) { y_ = y; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(171, 0)" endLine="(171, 64)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::set_roll(const double roll)">void VehicleState::set_roll(const double roll) { roll_ = roll; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(169, 0)" endLine="(169, 52)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::set_z(const double z)">void VehicleState::set_z(const double z) { z_ = z; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(173, 0)" endLine="(173, 68)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::set_pitch(const double pitch)">void VehicleState::set_pitch(const double pitch) { pitch_ = pitch; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(171, 0)" endLine="(171, 64)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::set_roll(const double roll)">void VehicleState::set_roll(const double roll) { roll_ = roll; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(176, 0)" endLine="(176, 60)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::set_yaw(const double yaw)">void VehicleState::set_yaw(const double yaw) { yaw_ = yaw; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(173, 0)" endLine="(173, 68)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::set_pitch(const double pitch)">void VehicleState::set_pitch(const double pitch) { pitch_ = pitch; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(178, 0)" endLine="(178, 76)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::set_heading(const double heading)">void VehicleState::set_heading(const double heading) { heading_ = heading; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(176, 0)" endLine="(176, 60)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::set_yaw(const double yaw)">void VehicleState::set_yaw(const double yaw) { yaw_ = yaw; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(433, 0)" endLine="(461, 1)" clone_start="9" clone_end="16">
			<code function_name="RawStream::ntrip_spin()">void RawStream::ntrip_spin() {
  if (_in_rtk_stream == nullptr) {
    return;
  }
  while (ros::ok()) {
    size_t length = _in_rtk_stream-&gt;read(_buffer_ntrip, BUFFER_SIZE);
    if (length &gt; 0) {
      if (_rtk_software_solution) {
        std_msgs::StringPtr rtkmsg_pub(new std_msgs::String);
        if (!rtkmsg_pub) {
          ROS_ERROR("New rtkmsg failed.");
          continue;
        }
        rtkmsg_pub-&gt;data.assign(reinterpret_cast&lt;const char *&gt;(_buffer_ntrip),
                                length);
        _rtcm_data_publisher.publish(rtkmsg_pub);
      } else {
        if (_out_rtk_stream == nullptr) {
          continue;
        }
        size_t ret = _out_rtk_stream-&gt;write(_buffer_ntrip, length);
        if (ret != length) {
          ROS_ERROR_STREAM("Expect write out rtk stream bytes "
                           &lt;&lt; length &lt;&lt; " but got " &lt;&lt; ret);
        }
      }
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(415, 0)" endLine="(431, 1)" clone_start="7" clone_end="13">
			<code function_name="RawStream::data_spin()">void RawStream::data_spin() {
  _stream_status-&gt;mutable_header()-&gt;set_timestamp_sec(ros::Time::now().toSec());
  _stream_status_publisher.publish(_stream_status);
  while (ros::ok()) {
    size_t length = _data_stream-&gt;read(_buffer, BUFFER_SIZE);
    if (length &gt; 0) {
      std_msgs::StringPtr msg_pub(new std_msgs::String);
      if (!msg_pub) {
        ROS_ERROR("New data sting msg failed.");
        continue;
      }
      msg_pub-&gt;data.assign(reinterpret_cast&lt;const char *&gt;(_buffer), length);
      _raw_data_publisher.publish(msg_pub);
    }
    stream_status_check();
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\angle.cc" startLine="(52, 0)" endLine="(55, 1)" clone_start="1" clone_end="4">
			<code function_name="cos(Angle8 a)">float cos(Angle8 a) {
  Angle16 b(a.raw() &lt;&lt; 8);
  return cos(b);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\angle.cc" startLine="(47, 0)" endLine="(50, 1)" clone_start="1" clone_end="4">
			<code function_name="sin(Angle8 a)">float sin(Angle8 a) {
  Angle16 b(a.raw() &lt;&lt; 8);
  return sin(b);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\angle.cc" startLine="(57, 0)" endLine="(60, 1)" clone_start="1" clone_end="3">
			<code function_name="tan(Angle8 a)">float tan(Angle8 a) {
  Angle16 b(a.raw() &lt;&lt; 8);
  return tan(b);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\angle.cc" startLine="(52, 0)" endLine="(55, 1)" clone_start="1" clone_end="3">
			<code function_name="cos(Angle8 a)">float cos(Angle8 a) {
  Angle16 b(a.raw() &lt;&lt; 8);
  return cos(b);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\tools\terminal.cc" startLine="(129, 0)" endLine="(170, 1)" clone_start="1" clone_end="12">
			<code function_name="main(int argc, char **argv)">int main(int argc, char **argv) {
  google::InitGoogleLogging(argv[0]);
  FLAGS_alsologtostderr = true;
  FLAGS_v = 3;

  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);

  using apollo::common::adapter::AdapterManagerConfig;
  using apollo::common::adapter::AdapterManager;
  using apollo::common::adapter::AdapterConfig;

  ros::init(argc, argv, "terminal");

  AdapterManagerConfig config;
  config.set_is_ros(true);
  {
    auto *sub_config = config.add_config();
    sub_config-&gt;set_mode(AdapterConfig::PUBLISH_ONLY);
    sub_config-&gt;set_type(AdapterConfig::PAD);
  }

  {
    auto *sub_config = config.add_config();
    sub_config-&gt;set_mode(AdapterConfig::RECEIVE_ONLY);
    sub_config-&gt;set_type(AdapterConfig::CHASSIS);
  }

  {
    auto *sub_config = config.add_config();
    sub_config-&gt;set_mode(AdapterConfig::RECEIVE_ONLY);
    sub_config-&gt;set_type(AdapterConfig::LOCALIZATION);
  }

  AdapterManager::Init(config);
  AdapterManager::AddChassisCallback(on_chassis);

  help();
  std::thread terminal_thread(terminal_thread_func);
  ros::spin();
  terminal_thread.join();
  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\tools\teleop.cc" startLine="(384, 0)" endLine="(423, 1)" clone_start="1" clone_end="8">
			<code function_name="main(int32_t argc, char **argv)">int main(int32_t argc, char **argv) {
  google::InitGoogleLogging(argv[0]);
  FLAGS_alsologtostderr = true;
  FLAGS_v = 3;

  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);

  ros::init(argc, argv, "teleop");
  signal(SIGINT, signal_handler);

  apollo::common::adapter::AdapterManagerConfig config;
  config.set_is_ros(true);
  {
    auto *sub_config = config.add_config();
    sub_config-&gt;set_mode(apollo::common::adapter::AdapterConfig::PUBLISH_ONLY);
    sub_config-&gt;set_type(
        apollo::common::adapter::AdapterConfig::CONTROL_COMMAND);
  }

  {
    auto *sub_config = config.add_config();
    sub_config-&gt;set_mode(apollo::common::adapter::AdapterConfig::RECEIVE_ONLY);
    sub_config-&gt;set_type(apollo::common::adapter::AdapterConfig::CHASSIS);
  }

  apollo::common::adapter::AdapterManager::Init(config);

  Teleop teleop;

  if (teleop.Start() != 0) {
    AERROR &lt;&lt; "Teleop start failed.";
    return -1;
  }
  Teleop::PrintKeycode();

  ros::spin();
  teleop.Stop();
  AINFO &lt;&lt; "Teleop exit done.";
  return 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\map\map_service.cc" startLine="(106, 0)" endLine="(116, 1)" clone_start="4" clone_end="9">
			<code function_name="MapElementIds::Json() const">nlohmann::json MapElementIds::Json() const {
  nlohmann::json result;
  result["lane"] = lane;
  result["crosswalk"] = crosswalk;
  result["junction"] = junction;
  result["signal"] = signal;
  result["stopSign"] = stop_sign;
  result["yield"] = yield;
  result["overlap"] = overlap;
  return result;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\map\map_service.cc" startLine="(106, 0)" endLine="(116, 1)" clone_start="3" clone_end="8">
			<code function_name="MapElementIds::Json() const">nlohmann::json MapElementIds::Json() const {
  nlohmann::json result;
  result["lane"] = lane;
  result["crosswalk"] = crosswalk;
  result["junction"] = junction;
  result["signal"] = signal;
  result["stopSign"] = stop_sign;
  result["yield"] = yield;
  result["overlap"] = overlap;
  return result;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(199, 0)" endLine="(233, 1)" clone_start="2" clone_end="7">
			<code function_name="UdpStream::write(const uint8_t* data, size_t length)">size_t UdpStream::write(const uint8_t* data, size_t length) {
  size_t total_nsent = 0;
  struct sockaddr_in peer_sockaddr;
  bzero(&amp;peer_sockaddr, sizeof(peer_sockaddr));
  peer_sockaddr.sin_family = AF_INET;
  peer_sockaddr.sin_port = _peer_port;
  peer_sockaddr.sin_addr.s_addr = _peer_addr;

  while (length &gt; 0) {
    ssize_t nsent =
        ::sendto(_sockfd, data, length, 0, (struct sockaddr*)&amp;peer_sockaddr,
                 (socklen_t)sizeof(peer_sockaddr));
    if (nsent &lt; 0) {  // error
      if (errno == EINTR) {
        continue;
      } else {
        // error
        if (errno == EPIPE || errno == ECONNRESET) {
          _status = Stream::Status::DISCONNECTED;
          _errno = errno;
        } else if (errno != EAGAIN) {
          _status = Stream::Status::ERROR;
          _errno = errno;
        }
        return total_nsent;
      }
    }

    total_nsent += nsent;
    length -= nsent;
    data += nsent;
  }

  return total_nsent;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(136, 0)" endLine="(228, 1)" clone_start="16" clone_end="22">
			<code function_name="TcpStream::connect()">bool TcpStream::connect() {
  if (_sockfd &lt; 0) {
    this-&gt;open();
    if (_sockfd &lt; 0) {
      // error
      return false;
    }
  }

  if (_status == Stream::Status::CONNECTED) {
    return true;
  }

  fd_set fds;
  timeval timeo = {10, 0};
  int ret = 0;
  sockaddr_in peer_addr;

  bzero(&amp;peer_addr, sizeof(peer_addr));
  peer_addr.sin_family = AF_INET;
  peer_addr.sin_port = _peer_port;
  peer_addr.sin_addr.s_addr = _peer_addr;

  int fd_flags = fcntl(_sockfd, F_GETFL);
  if (fd_flags &lt; 0 || fcntl(_sockfd, F_SETFL, fd_flags | O_NONBLOCK) &lt; 0) {
    ROS_ERROR_STREAM("Failed to set noblock, error: " &lt;&lt; strerror(errno));
    return false;
  }

  while ((ret = ::connect(_sockfd, reinterpret_cast&lt;sockaddr*&gt;(&amp;peer_addr),
                          sizeof(peer_addr))) &lt; 0) {
    if (errno == EINTR) {
      ROS_INFO("Tcp connect return EINTR.");
      continue;
    } else {
      if ((errno != EISCONN) &amp;&amp; (errno != EINPROGRESS) &amp;&amp; (errno != EALREADY)) {
        _status = Stream::Status::ERROR;
        _errno = errno;
        ROS_ERROR_STREAM("Connect failed, error: " &lt;&lt; strerror(errno));
        return false;
      }

      FD_ZERO(&amp;fds);
      FD_SET(_sockfd, &amp;fds);
      ret = select(_sockfd + 1, NULL, &amp;fds, NULL, &amp;timeo);
      if (ret &lt; 0) {
        _status = Stream::Status::ERROR;
        _errno = errno;
        ROS_ERROR_STREAM("Wait connect failed, error: " &lt;&lt; strerror(errno));
        return false;
      } else if (ret == 0) {
        ROS_INFO("Tcp connect timeout.");
        return false;
      } else if (FD_ISSET(_sockfd, &amp;fds)) {
        int error = 0;
        socklen_t len = sizeof(int);

        if (getsockopt(_sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len) &lt; 0) {
          _status = Stream::Status::ERROR;
          _errno = errno;
          ROS_ERROR_STREAM("Getsockopt failed, error: " &lt;&lt; strerror(errno));
          return false;
        }
        if (error != 0) {
          _status = Stream::Status::ERROR;
          _errno = errno;
          ROS_ERROR_STREAM("Socket error: " &lt;&lt; strerror(errno));
          return false;
        }

        // connect successfully
        break;
      } else {
        _status = Stream::Status::ERROR;
        _errno = errno;
        ROS_ERROR("Should not be here.");
        return false;
      }
    }
  }

  if (!init_socket()) {
    close();
    _status = Stream::Status::ERROR;
    _errno = errno;
    ROS_ERROR("Failed to init socket.");
    return false;
  }
  ROS_INFO("Tcp connect success.");
  _status = Stream::Status::CONNECTED;
  login();
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(112, 0)" endLine="(114, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline2dSeg::third_derivative_y(const double t) const">const PolynomialXd&amp; Spline2dSeg::second_derivative_y() const {
  return second_derivative_y_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(108, 0)" endLine="(110, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline2dSeg::third_derivative_y(const double t) const">const PolynomialXd&amp; Spline2dSeg::SecondDerivativeX() const {
  return second_derivative_x_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(116, 0)" endLine="(118, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline2dSeg::third_derivative_y(const double t) const">const PolynomialXd&amp; Spline2dSeg::ThirdDerivativeX() const {
  return third_derivative_x_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(112, 0)" endLine="(114, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline2dSeg::third_derivative_y(const double t) const">const PolynomialXd&amp; Spline2dSeg::second_derivative_y() const {
  return second_derivative_y_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(120, 0)" endLine="(122, 1)" clone_start="1" clone_end="2">
			<code function_name="Spline2dSeg::third_derivative_y(const double t) const">const PolynomialXd&amp; Spline2dSeg::third_derivative_y() const {
  return third_derivative_y_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(116, 0)" endLine="(118, 1)" clone_start="1" clone_end="2">
			<code function_name="Spline2dSeg::third_derivative_y(const double t) const">const PolynomialXd&amp; Spline2dSeg::ThirdDerivativeX() const {
  return third_derivative_x_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(266, 0)" endLine="(319, 1)" clone_start="14" clone_end="20">
			<code function_name="RawStream::connect()">bool RawStream::connect() {
  if (_data_stream) {
    if (_data_stream-&gt;get_status() != Stream::Status::CONNECTED) {
      if (!_data_stream-&gt;connect()) {
        ROS_ERROR("data stream connect failed.");
        return false;
      }
      _data_stream_status-&gt;status = Stream::Status::CONNECTED;
      _stream_status-&gt;set_ins_stream_type(
          apollo::common::gnss_status::StreamStatus::CONNECTED);
    }
  }

  if (_command_stream) {
    if (_command_stream-&gt;get_status() != Stream::Status::CONNECTED) {
      if (!_data_stream-&gt;connect()) {
        ROS_ERROR("command stream connect failed.");
        return false;
      }
      _command_stream_status-&gt;status = Stream::Status::CONNECTED;
    }
  }

  if (_in_rtk_stream) {
    if (_in_rtk_stream-&gt;get_status() != Stream::Status::CONNECTED) {
      if (!_in_rtk_stream-&gt;connect()) {
        ROS_ERROR("in rtk stream connect failed.");
      } else {
        _in_rtk_stream_status-&gt;status = Stream::Status::CONNECTED;
        _stream_status-&gt;set_rtk_stream_in_type(
            apollo::common::gnss_status::StreamStatus::CONNECTED);
      }
    }
  } else {
    _stream_status-&gt;set_rtk_stream_in_type(
        apollo::common::gnss_status::StreamStatus::CONNECTED);
  }

  if (_out_rtk_stream) {
    if (_out_rtk_stream-&gt;get_status() != Stream::Status::CONNECTED) {
      if (!_out_rtk_stream-&gt;connect()) {
        ROS_ERROR("out rtk stream connect failed.");
      } else {
        _out_rtk_stream_status-&gt;status = Stream::Status::CONNECTED;
        _stream_status-&gt;set_rtk_stream_out_type(
            apollo::common::gnss_status::StreamStatus::CONNECTED);
      }
    }
  } else {
    _stream_status-&gt;set_rtk_stream_out_type(
        apollo::common::gnss_status::StreamStatus::CONNECTED);
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(266, 0)" endLine="(319, 1)" clone_start="2" clone_end="8">
			<code function_name="RawStream::connect()">bool RawStream::connect() {
  if (_data_stream) {
    if (_data_stream-&gt;get_status() != Stream::Status::CONNECTED) {
      if (!_data_stream-&gt;connect()) {
        ROS_ERROR("data stream connect failed.");
        return false;
      }
      _data_stream_status-&gt;status = Stream::Status::CONNECTED;
      _stream_status-&gt;set_ins_stream_type(
          apollo::common::gnss_status::StreamStatus::CONNECTED);
    }
  }

  if (_command_stream) {
    if (_command_stream-&gt;get_status() != Stream::Status::CONNECTED) {
      if (!_data_stream-&gt;connect()) {
        ROS_ERROR("command stream connect failed.");
        return false;
      }
      _command_stream_status-&gt;status = Stream::Status::CONNECTED;
    }
  }

  if (_in_rtk_stream) {
    if (_in_rtk_stream-&gt;get_status() != Stream::Status::CONNECTED) {
      if (!_in_rtk_stream-&gt;connect()) {
        ROS_ERROR("in rtk stream connect failed.");
      } else {
        _in_rtk_stream_status-&gt;status = Stream::Status::CONNECTED;
        _stream_status-&gt;set_rtk_stream_in_type(
            apollo::common::gnss_status::StreamStatus::CONNECTED);
      }
    }
  } else {
    _stream_status-&gt;set_rtk_stream_in_type(
        apollo::common::gnss_status::StreamStatus::CONNECTED);
  }

  if (_out_rtk_stream) {
    if (_out_rtk_stream-&gt;get_status() != Stream::Status::CONNECTED) {
      if (!_out_rtk_stream-&gt;connect()) {
        ROS_ERROR("out rtk stream connect failed.");
      } else {
        _out_rtk_stream_status-&gt;status = Stream::Status::CONNECTED;
        _stream_status-&gt;set_rtk_stream_out_type(
            apollo::common::gnss_status::StreamStatus::CONNECTED);
      }
    }
  } else {
    _stream_status-&gt;set_rtk_stream_out_type(
        apollo::common::gnss_status::StreamStatus::CONNECTED);
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(492, 0)" endLine="(612, 1)" clone_start="105" clone_end="112">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  if (!chassis_detail.has_eps()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO eps."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_brake()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO brake."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gas()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gas."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gear()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gear."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR_EVERY(100) &lt;&lt; "Steering fault detected: "
                      &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR_EVERY(100) &lt;&lt; "Brake fault detected: "
                      &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR_EVERY(100) &lt;&lt; "Throttle fault detected: "
                      &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR_EVERY(100) &lt;&lt; "Gear fault detected: "
                      &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(492, 0)" endLine="(612, 1)" clone_start="97" clone_end="104">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  if (!chassis_detail.has_eps()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO eps."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_brake()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO brake."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gas()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gas."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gear()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gear."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR_EVERY(100) &lt;&lt; "Steering fault detected: "
                      &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR_EVERY(100) &lt;&lt; "Brake fault detected: "
                      &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR_EVERY(100) &lt;&lt; "Throttle fault detected: "
                      &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR_EVERY(100) &lt;&lt; "Gear fault detected: "
                      &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(492, 0)" endLine="(612, 1)" clone_start="88" clone_end="95">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  if (!chassis_detail.has_eps()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO eps."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_brake()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO brake."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gas()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gas."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gear()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gear."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR_EVERY(100) &lt;&lt; "Steering fault detected: "
                      &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR_EVERY(100) &lt;&lt; "Brake fault detected: "
                      &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR_EVERY(100) &lt;&lt; "Throttle fault detected: "
                      &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR_EVERY(100) &lt;&lt; "Gear fault detected: "
                      &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\aaboxkdtree2d.h" startLine="(259, 2)" endLine="(323, 3)" clone_start="41" clone_end="47">
			<code function_name="GetNearestObjectInternal(const Vec2d &amp;point,double *const min_distance_sqr, ObjectPtr *const nearest_object) const">  void GetNearestObjectInternal(const Vec2d &amp;point,
                                double *const min_distance_sqr,
                                ObjectPtr *const nearest_object) const {
    if (LowerDistanceSquareToPoint(point) &gt;= *min_distance_sqr - kMathEpsilon) {
      return;
    }
    const double pvalue = (partition_ == PARTITION_X ? point.x() : point.y());
    const bool search_left_first = (pvalue &lt; partition_position_);
    if (search_left_first) {
      if (left_subnode_ != nullptr) {
        left_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                nearest_object);
      }
    } else {
      if (right_subnode_ != nullptr) {
        right_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                 nearest_object);
      }
    }
    if (*min_distance_sqr &lt;= kMathEpsilon) {
      return;
    }

    if (search_left_first) {
      for (int i = 0; i &lt; num_objects_; ++i) {
        const double bound = objects_sorted_by_min_bound_[i];
        if (bound &gt; pvalue &amp;&amp; Square(bound - pvalue) &gt; *min_distance_sqr) {
          break;
        }
        ObjectPtr object = objects_sorted_by_min_[i];
        const double distance_sqr = object-&gt;DistanceSquareTo(point);
        if (distance_sqr &lt; *min_distance_sqr) {
          *min_distance_sqr = distance_sqr;
          *nearest_object = object;
        }
      }
    } else {
      for (int i = 0; i &lt; num_objects_; ++i) {
        const double bound = objects_sorted_by_max_bound_[i];
        if (bound &lt; pvalue &amp;&amp; Square(bound - pvalue) &gt; *min_distance_sqr) {
          break;
        }
        ObjectPtr object = objects_sorted_by_max_[i];
        const double distance_sqr = object-&gt;DistanceSquareTo(point);
        if (distance_sqr &lt; *min_distance_sqr) {
          *min_distance_sqr = distance_sqr;
          *nearest_object = object;
        }
      }
    }
    if (*min_distance_sqr &lt;= kMathEpsilon) {
      return;
    }
    if (search_left_first) {
      if (right_subnode_ != nullptr) {
        right_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                 nearest_object);
      }
    } else {
      if (left_subnode_ != nullptr) {
        left_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                nearest_object);
      }
    }
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\aaboxkdtree2d.h" startLine="(259, 2)" endLine="(323, 3)" clone_start="28" clone_end="34">
			<code function_name="GetNearestObjectInternal(const Vec2d &amp;point,double *const min_distance_sqr, ObjectPtr *const nearest_object) const">  void GetNearestObjectInternal(const Vec2d &amp;point,
                                double *const min_distance_sqr,
                                ObjectPtr *const nearest_object) const {
    if (LowerDistanceSquareToPoint(point) &gt;= *min_distance_sqr - kMathEpsilon) {
      return;
    }
    const double pvalue = (partition_ == PARTITION_X ? point.x() : point.y());
    const bool search_left_first = (pvalue &lt; partition_position_);
    if (search_left_first) {
      if (left_subnode_ != nullptr) {
        left_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                nearest_object);
      }
    } else {
      if (right_subnode_ != nullptr) {
        right_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                 nearest_object);
      }
    }
    if (*min_distance_sqr &lt;= kMathEpsilon) {
      return;
    }

    if (search_left_first) {
      for (int i = 0; i &lt; num_objects_; ++i) {
        const double bound = objects_sorted_by_min_bound_[i];
        if (bound &gt; pvalue &amp;&amp; Square(bound - pvalue) &gt; *min_distance_sqr) {
          break;
        }
        ObjectPtr object = objects_sorted_by_min_[i];
        const double distance_sqr = object-&gt;DistanceSquareTo(point);
        if (distance_sqr &lt; *min_distance_sqr) {
          *min_distance_sqr = distance_sqr;
          *nearest_object = object;
        }
      }
    } else {
      for (int i = 0; i &lt; num_objects_; ++i) {
        const double bound = objects_sorted_by_max_bound_[i];
        if (bound &lt; pvalue &amp;&amp; Square(bound - pvalue) &gt; *min_distance_sqr) {
          break;
        }
        ObjectPtr object = objects_sorted_by_max_[i];
        const double distance_sqr = object-&gt;DistanceSquareTo(point);
        if (distance_sqr &lt; *min_distance_sqr) {
          *min_distance_sqr = distance_sqr;
          *nearest_object = object;
        }
      }
    }
    if (*min_distance_sqr &lt;= kMathEpsilon) {
      return;
    }
    if (search_left_first) {
      if (right_subnode_ != nullptr) {
        right_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                 nearest_object);
      }
    } else {
      if (left_subnode_ != nullptr) {
        left_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                nearest_object);
      }
    }
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\lib\config_manager\config_manager.cc" startLine="(43, 0)" endLine="(115, 1)" clone_start="35" clone_end="43">
			<code function_name="ConfigManager::InitInternal()">bool ConfigManager::InitInternal() {
  if (inited_) {
    return true;
  }
  ModelConfigMapIterator iter = model_config_map_.begin();
  for (; iter != model_config_map_.end(); ++iter) {
    delete iter-&gt;second;
  }
  model_config_map_.clear();

  std::string path =
      FileUtil::GetAbsolutePath(work_root_, FLAGS_config_manager_path);

  AINFO &lt;&lt; "WORK_ROOT: " &lt;&lt; work_root_ &lt;&lt; " config_manager_path: " &lt;&lt; path;

  std::string content;
  if (!FileUtil::GetFileContent(path, &amp;content)) {
    AERROR &lt;&lt; "failed to get ConfigManager config path: " &lt;&lt; path;
    return false;
  }

  ModelConfigFileListProto file_list_proto;

  if (!TextFormat::ParseFromString(content, &amp;file_list_proto)) {
    AERROR &lt;&lt; "invalid ModelConfigFileListProto file: "
           &lt;&lt; FLAGS_config_manager_path;
    return false;
  }

  for (const std::string&amp; model_config_file :
       file_list_proto.model_config_path()) {
    std::string abs_path =
        FileUtil::GetAbsolutePath(work_root_, model_config_file);

    std::string config_content;
    if (!FileUtil::GetFileContent(abs_path, &amp;config_content)) {
      AERROR &lt;&lt; "failed to get_file_content: " &lt;&lt; abs_path;
      return false;
    }

    MultiModelConfigProto multi_model_config_proto;

    if (!TextFormat::ParseFromString(config_content,
                                     &amp;multi_model_config_proto)) {
      AERROR &lt;&lt; "invalid MultiModelConfigProto file: " &lt;&lt; abs_path;
      return false;
    }

    for (const ModelConfigProto&amp; model_config_proto :
         multi_model_config_proto.model_configs()) {
      ModelConfig* model_config = new ModelConfig();
      if (!model_config-&gt;Reset(model_config_proto)) {
        return false;
      }

      AINFO &lt;&lt; "load ModelConfig succ. name: " &lt;&lt; model_config-&gt;name();

      std::pair&lt;ModelConfigMapIterator, bool&gt; result =
          model_config_map_.emplace(model_config-&gt;name(), model_config);
      if (!result.second) {
        AWARN &lt;&lt; "duplicate ModelConfig, name: " &lt;&lt; model_config-&gt;name();
        return false;
      }
    }
  }

  AINFO &lt;&lt; "finish to load ModelConfigs. num_models: "
        &lt;&lt; model_config_map_.size();

  inited_ = true;

  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\lib\config_manager\config_manager.cc" startLine="(43, 0)" endLine="(115, 1)" clone_start="16" clone_end="24">
			<code function_name="ConfigManager::InitInternal()">bool ConfigManager::InitInternal() {
  if (inited_) {
    return true;
  }
  ModelConfigMapIterator iter = model_config_map_.begin();
  for (; iter != model_config_map_.end(); ++iter) {
    delete iter-&gt;second;
  }
  model_config_map_.clear();

  std::string path =
      FileUtil::GetAbsolutePath(work_root_, FLAGS_config_manager_path);

  AINFO &lt;&lt; "WORK_ROOT: " &lt;&lt; work_root_ &lt;&lt; " config_manager_path: " &lt;&lt; path;

  std::string content;
  if (!FileUtil::GetFileContent(path, &amp;content)) {
    AERROR &lt;&lt; "failed to get ConfigManager config path: " &lt;&lt; path;
    return false;
  }

  ModelConfigFileListProto file_list_proto;

  if (!TextFormat::ParseFromString(content, &amp;file_list_proto)) {
    AERROR &lt;&lt; "invalid ModelConfigFileListProto file: "
           &lt;&lt; FLAGS_config_manager_path;
    return false;
  }

  for (const std::string&amp; model_config_file :
       file_list_proto.model_config_path()) {
    std::string abs_path =
        FileUtil::GetAbsolutePath(work_root_, model_config_file);

    std::string config_content;
    if (!FileUtil::GetFileContent(abs_path, &amp;config_content)) {
      AERROR &lt;&lt; "failed to get_file_content: " &lt;&lt; abs_path;
      return false;
    }

    MultiModelConfigProto multi_model_config_proto;

    if (!TextFormat::ParseFromString(config_content,
                                     &amp;multi_model_config_proto)) {
      AERROR &lt;&lt; "invalid MultiModelConfigProto file: " &lt;&lt; abs_path;
      return false;
    }

    for (const ModelConfigProto&amp; model_config_proto :
         multi_model_config_proto.model_configs()) {
      ModelConfig* model_config = new ModelConfig();
      if (!model_config-&gt;Reset(model_config_proto)) {
        return false;
      }

      AINFO &lt;&lt; "load ModelConfig succ. name: " &lt;&lt; model_config-&gt;name();

      std::pair&lt;ModelConfigMapIterator, bool&gt; result =
          model_config_map_.emplace(model_config-&gt;name(), model_config);
      if (!result.second) {
        AWARN &lt;&lt; "duplicate ModelConfig, name: " &lt;&lt; model_config-&gt;name();
        return false;
      }
    }
  }

  AINFO &lt;&lt; "finish to load ModelConfigs. num_models: "
        &lt;&lt; model_config_map_.size();

  inited_ = true;

  return true;
}</code>
		</source>
	</dup>
	<dup count="5">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(168, 2)" endLine="(170, 3)" clone_start="1" clone_end="3">
			<code function_name="name() const override">  std::string name() const override {
    return "DummyTracker";
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(144, 2)" endLine="(146, 3)" clone_start="1" clone_end="3">
			<code function_name="name() const override">  std::string name() const override {
    return "DummyObjectFilter";
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(95, 2)" endLine="(97, 3)" clone_start="1" clone_end="3">
			<code function_name="name() const override">  std::string name() const override {
    return "DummySegmentation";
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(69, 2)" endLine="(71, 3)" clone_start="1" clone_end="3">
			<code function_name="name() const override">  std::string name() const override {
    return "DummyGroundDetector";
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(44, 2)" endLine="(46, 3)" clone_start="1" clone_end="3">
			<code function_name="name() const override">  std::string name() const override {
    return "DummyROIFilter";
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_constraint.cc" startLine="(57, 0)" endLine="(60, 1)" clone_start="1" clone_end="4">
			<code function_name="PiecewiseLinearConstraint::inequality_constraint_boundary() const">Eigen::MatrixXd PiecewiseLinearConstraint::inequality_constraint_boundary()
    const {
  return MergeMaxtrices(inequality_boundaries_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_constraint.cc" startLine="(52, 0)" endLine="(55, 1)" clone_start="1" clone_end="4">
			<code function_name="PiecewiseLinearConstraint::inequality_constraint_matrix() const">Eigen::MatrixXd PiecewiseLinearConstraint::inequality_constraint_matrix()
    const {
  return MergeMaxtrices(inequality_matrices_);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_constraint.cc" startLine="(62, 0)" endLine="(64, 1)" clone_start="1" clone_end="3">
			<code function_name="PiecewiseLinearConstraint::equality_constraint_matrix() const">Eigen::MatrixXd PiecewiseLinearConstraint::equality_constraint_matrix() const {
  return MergeMaxtrices(equality_matrices_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_constraint.cc" startLine="(57, 0)" endLine="(60, 1)" clone_start="1" clone_end="4">
			<code function_name="PiecewiseLinearConstraint::inequality_constraint_boundary() const">Eigen::MatrixXd PiecewiseLinearConstraint::inequality_constraint_boundary()
    const {
  return MergeMaxtrices(inequality_boundaries_);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_constraint.cc" startLine="(66, 0)" endLine="(69, 1)" clone_start="1" clone_end="3">
			<code function_name="PiecewiseLinearConstraint::equality_constraint_boundary() const">Eigen::MatrixXd PiecewiseLinearConstraint::equality_constraint_boundary()
    const {
  return MergeMaxtrices(equality_boundaries_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_constraint.cc" startLine="(62, 0)" endLine="(64, 1)" clone_start="1" clone_end="2">
			<code function_name="PiecewiseLinearConstraint::equality_constraint_matrix() const">Eigen::MatrixXd PiecewiseLinearConstraint::equality_constraint_matrix() const {
  return MergeMaxtrices(equality_matrices_);
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\onboard\lidar_process.cc" startLine="(193, 0)" endLine="(203, 1)" clone_start="4" clone_end="10">
			<code function_name="LidarProcess::RegistAllAlgorithm()">void LidarProcess::RegistAllAlgorithm() {
  RegisterFactoryDummyROIFilter();
  RegisterFactoryDummySegmentation();
  RegisterFactoryDummyObjectBuilder();
  RegisterFactoryDummyTracker();

  RegisterFactoryHdmapROIFilter();
  RegisterFactoryCNNSegmentation();
  RegisterFactoryMinBoxObjectBuilder();
  RegisterFactoryHmObjectTracker();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\onboard\lidar_process.cc" startLine="(193, 0)" endLine="(203, 1)" clone_start="3" clone_end="9">
			<code function_name="LidarProcess::RegistAllAlgorithm()">void LidarProcess::RegistAllAlgorithm() {
  RegisterFactoryDummyROIFilter();
  RegisterFactoryDummySegmentation();
  RegisterFactoryDummyObjectBuilder();
  RegisterFactoryDummyTracker();

  RegisterFactoryHdmapROIFilter();
  RegisterFactoryCNNSegmentation();
  RegisterFactoryMinBoxObjectBuilder();
  RegisterFactoryHmObjectTracker();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\onboard\lidar_process.cc" startLine="(193, 0)" endLine="(203, 1)" clone_start="2" clone_end="8">
			<code function_name="LidarProcess::RegistAllAlgorithm()">void LidarProcess::RegistAllAlgorithm() {
  RegisterFactoryDummyROIFilter();
  RegisterFactoryDummySegmentation();
  RegisterFactoryDummyObjectBuilder();
  RegisterFactoryDummyTracker();

  RegisterFactoryHdmapROIFilter();
  RegisterFactoryCNNSegmentation();
  RegisterFactoryMinBoxObjectBuilder();
  RegisterFactoryHmObjectTracker();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(40, 0)" endLine="(100, 1)" clone_start="53" clone_end="58">
			<code function_name="HDMapImpl::LoadMapFromFile(const std::string&amp; map_filename)">int HDMapImpl::LoadMapFromFile(const std::string&amp; map_filename) {
  Clear();

  if (apollo::common::util::EndWith(map_filename, ".xml")) {
    if (!adapter::OpendriveAdapter::LoadData(map_filename, &amp;map_)) {
      return -1;
    }
  } else if (!apollo::common::util::GetProtoFromFile(map_filename, &amp;map_)) {
    return -1;
  }

  for (const auto&amp; lane : map_.lane()) {
    lane_table_[lane.id().id()].reset(new LaneInfo(lane));
  }
  for (const auto&amp; junction : map_.junction()) {
    junction_table_[junction.id().id()].reset(new JunctionInfo(junction));
  }
  for (const auto&amp; signal : map_.signal()) {
    signal_table_[signal.id().id()].reset(new SignalInfo(signal));
  }
  for (const auto&amp; crosswalk : map_.crosswalk()) {
    crosswalk_table_[crosswalk.id().id()].reset(new CrosswalkInfo(crosswalk));
  }
  for (const auto&amp; stop_sign : map_.stop_sign()) {
    stop_sign_table_[stop_sign.id().id()].reset(new StopSignInfo(stop_sign));
  }
  for (const auto&amp; yield_sign : map_.yield()) {
    yield_sign_table_[yield_sign.id().id()].reset(
        new YieldSignInfo(yield_sign));
  }
  for (const auto&amp; overlap : map_.overlap()) {
    overlap_table_[overlap.id().id()].reset(new OverlapInfo(overlap));
  }

  for (const auto&amp; road : map_.road()) {
    road_table_[road.id().id()].reset(new RoadInfo(road));
  }

  for (const auto&amp; road_ptr_pair : road_table_) {
    const auto&amp; road_id = road_ptr_pair.second-&gt;id();
    for (const auto&amp; road_section : road_ptr_pair.second-&gt;sections()) {
      const auto&amp; section_id = road_section.id();
      for (const auto&amp; lane_id : road_section.lane_id()) {
        lane_table_[lane_id.id()]-&gt;set_road_id(road_id);
        lane_table_[lane_id.id()]-&gt;set_section_id(section_id);
      }
    }
  }
  for (const auto&amp; lane_ptr_pair : lane_table_) {
    lane_ptr_pair.second-&gt;PostProcess(*this);
  }

  BuildLaneSegmentKDTree();
  BuildJunctionPolygonKDTree();
  BuildSignalSegmentKDTree();
  BuildCrosswalkPolygonKDTree();
  BuildStopSignSegmentKDTree();
  BuildYieldSignSegmentKDTree();

  return 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_solver.cc" startLine="(26, 0)" endLine="(30, 36)" clone_start="1" clone_end="5">
			<code function_name="Spline2dSolver::Spline2dSolver(const std::vector&lt;double&gt;&amp; t_knots, const std::uint32_t order)">Spline2dSolver::Spline2dSolver(const std::vector&lt;double&gt;&amp; t_knots,
                               const std::uint32_t order)
    : spline_(t_knots, order),
      kernel_(t_knots, order),
      constraint_(t_knots, order) {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_generator.cc" startLine="(30, 0)" endLine="(34, 46)" clone_start="1" clone_end="5">
			<code function_name="Spline1dGenerator::Spline1dGenerator(const std::vector&lt;double&gt;&amp; x_knots, const std::uint32_t spline_order)">Spline1dGenerator::Spline1dGenerator(const std::vector&lt;double&gt;&amp; x_knots,
                                     const std::uint32_t spline_order)
    : spline_(x_knots, spline_order),
      spline_constraint_(x_knots, spline_order),
      spline_kernel_(x_knots, spline_order) {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_solver.cc" startLine="(33, 0)" endLine="(35, 1)" clone_start="1" clone_end="2">
			<code function_name="Spline2dSolver::mutable_constraint()">Spline2dConstraint* Spline2dSolver::mutable_constraint() {
  return &amp;constraint_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_generator.cc" startLine="(36, 0)" endLine="(38, 1)" clone_start="1" clone_end="2">
			<code function_name="Spline1dGenerator::mutable_spline_constraint()">Spline1dConstraint* Spline1dGenerator::mutable_spline_constraint() {
  return &amp;spline_constraint_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\speed\speed_data.h" startLine="(32, 2)" endLine="(32, 24)" clone_start="1" clone_end="1">
			<code function_name="SpeedData()">  SpeedData() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\path\discretized_path.h" startLine="(32, 2)" endLine="(32, 30)" clone_start="1" clone_end="1">
			<code function_name="DiscretizedPath()">  DiscretizedPath() = default;</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="202" clone_end="208">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="84" clone_end="90">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="23" clone_end="30">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\control.cc" startLine="(259, 0)" endLine="(291, 1)" clone_start="24" clone_end="30">
			<code function_name="Control::CheckTimestamp()">Status Control::CheckTimestamp() {
  if (!FLAGS_enable_input_timestamp_check || FLAGS_is_control_test_mode) {
    ADEBUG &lt;&lt; "Skip input timestamp check by gflags.";
    return Status::OK();
  }
  double current_timestamp = Clock::NowInSecond();
  double localization_diff =
      current_timestamp - localization_.header().timestamp_sec();
  if (localization_diff &gt;
      (FLAGS_max_localization_miss_num * control_conf_.localization_period())) {
    AERROR &lt;&lt; "Localization msg lost for " &lt;&lt; std::setprecision(6)
           &lt;&lt; localization_diff &lt;&lt; "s";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "Localization msg timeout");
  }

  double chassis_diff = current_timestamp - chassis_.header().timestamp_sec();
  if (chassis_diff &gt;
      (FLAGS_max_chassis_miss_num * control_conf_.chassis_period())) {
    AERROR &lt;&lt; "Chassis msg lost for " &lt;&lt; std::setprecision(6) &lt;&lt; chassis_diff
           &lt;&lt; "s";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "Chassis msg timeout");
  }

  double trajectory_diff =
      current_timestamp - trajectory_.header().timestamp_sec();
  if (trajectory_diff &gt;
      (FLAGS_max_planning_miss_num * control_conf_.trajectory_period())) {
    AERROR &lt;&lt; "Trajectory msg lost for " &lt;&lt; std::setprecision(6)
           &lt;&lt; trajectory_diff &lt;&lt; "s";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "Trajectory msg timeout");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\control.cc" startLine="(259, 0)" endLine="(291, 1)" clone_start="7" clone_end="13">
			<code function_name="Control::CheckTimestamp()">Status Control::CheckTimestamp() {
  if (!FLAGS_enable_input_timestamp_check || FLAGS_is_control_test_mode) {
    ADEBUG &lt;&lt; "Skip input timestamp check by gflags.";
    return Status::OK();
  }
  double current_timestamp = Clock::NowInSecond();
  double localization_diff =
      current_timestamp - localization_.header().timestamp_sec();
  if (localization_diff &gt;
      (FLAGS_max_localization_miss_num * control_conf_.localization_period())) {
    AERROR &lt;&lt; "Localization msg lost for " &lt;&lt; std::setprecision(6)
           &lt;&lt; localization_diff &lt;&lt; "s";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "Localization msg timeout");
  }

  double chassis_diff = current_timestamp - chassis_.header().timestamp_sec();
  if (chassis_diff &gt;
      (FLAGS_max_chassis_miss_num * control_conf_.chassis_period())) {
    AERROR &lt;&lt; "Chassis msg lost for " &lt;&lt; std::setprecision(6) &lt;&lt; chassis_diff
           &lt;&lt; "s";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "Chassis msg timeout");
  }

  double trajectory_diff =
      current_timestamp - trajectory_.header().timestamp_sec();
  if (trajectory_diff &gt;
      (FLAGS_max_planning_miss_num * control_conf_.trajectory_period())) {
    AERROR &lt;&lt; "Trajectory msg lost for " &lt;&lt; std::setprecision(6)
           &lt;&lt; trajectory_diff &lt;&lt; "s";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "Trajectory msg timeout");
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.cc" startLine="(133, 0)" endLine="(318, 1)" clone_start="117" clone_end="122">
			<code function_name="MinBoxObjectBuilder::ReconstructPolygon(const Eigen::Vector3d &amp;ref_ct, ObjectPtr obj)">void  MinBoxObjectBuilder::ReconstructPolygon(
        const Eigen::Vector3d &amp;ref_ct,
        ObjectPtr obj) {
    if (obj-&gt;polygon.points.size() &lt;= 0) {
        return;
    }
    size_t max_point_index = 0;
    size_t min_point_index = 0;
    Eigen::Vector3d p;
    p[0] = obj-&gt;polygon.points[0].x;
    p[1] = obj-&gt;polygon.points[0].y;
    p[2] = obj-&gt;polygon.points[0].z;
    Eigen::Vector3d max_point = p - ref_ct;
    Eigen::Vector3d min_point = p - ref_ct;
    for (size_t i = 1; i &lt; obj-&gt;polygon.points.size(); ++i) {
        Eigen::Vector3d p;
        p[0] = obj-&gt;polygon.points[i].x;
        p[1] = obj-&gt;polygon.points[i].y;
        p[2] = obj-&gt;polygon.points[i].z;
        Eigen::Vector3d ray = p - ref_ct;
        // clock direction
        if (max_point[0] * ray[1] - ray[0] * max_point[1] &lt; EPSILON) {
            max_point = ray;
            max_point_index = i;
        }
        // unclock direction
        if (min_point[0] * ray[1] - ray[0] * min_point[1] &gt; EPSILON) {
            min_point = ray;
            min_point_index = i;
        }
    }
    Eigen::Vector3d line = max_point - min_point;
    double total_len = 0;
    double max_dis = 0;
    bool has_out = false;
    for (size_t i = min_point_index, count = 0;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist = sqrt((p[0] - p_x[0]) * (p[0] - p_x[0])
                        + (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist - max_dis &gt; EPSILON) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                   || (i == max_point_index &amp;&amp; j == min_point_index)) {
            size_t k = (j + 1) % obj-&gt;polygon.points.size();
            Eigen::Vector3d p_k;
            p_k[0] = obj-&gt;polygon.points[k].x;
            p_k[1] = obj-&gt;polygon.points[k].y;
            p_k[2] = obj-&gt;polygon.points[k].z;
            Eigen::Vector3d p_j;
            p_j[0] = obj-&gt;polygon.points[j].x;
            p_j[1] = obj-&gt;polygon.points[j].y;
            p_j[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
            } else {
                // outline
                has_out = true;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p_x - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist =
                        sqrt((p[0] - p_x[0]) * (p[0] - p_x[0]) +
                            (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist &gt; max_dis) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        }
    }
    size_t count = 0;
    double min_area = std::numeric_limits&lt;double&gt;::max();
    for (size_t i = min_point_index;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        Eigen::Vector3d p_j;
        p_j[0] = obj-&gt;polygon.points[j].x;
        p_j[1] = obj-&gt;polygon.points[j].y;
        p_j[2] = obj-&gt;polygon.points[j].z;
        double dist = sqrt((p_x[0] - p_j[0]) * (p_x[0] - p_j[0])
                + (p_x[1] - p_j[1])* (p_x[1] - p_j[1]));
        if (dist &lt; max_dis &amp;&amp; (dist / total_len) &lt; 0.5) {
            continue;
        }
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0;
                double width = 0;
                Eigen::Vector3d dir;
                double area =
                    ComputeAreaAlongOneEdge(obj, i,
                                        &amp;center, &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                    || (i == max_point_index &amp;&amp; j == min_point_index)) {
            if (!has_out) {
                continue;
            }
            Eigen::Vector3d center;
            double length = 0;
            double width = 0;
            Eigen::Vector3d dir;
            double area =
               ComputeAreaAlongOneEdge(obj, i, &amp;center, &amp;length, &amp;width, &amp;dir);
            if (area &lt; min_area) {
                obj-&gt;center = center;
                obj-&gt;length = length;
                obj-&gt;width = width;
                obj-&gt;direction = dir;
                min_area = area;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[i].x;
            p[1] = obj-&gt;polygon.points[i].y;
            p[2] = obj-&gt;polygon.points[i].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0.0;
                double width = 0.0;
                Eigen::Vector3d dir;
                double area =
                   ComputeAreaAlongOneEdge(obj, i, &amp;center,
                                           &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        }
    }
    obj-&gt;direction.normalize();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.cc" startLine="(133, 0)" endLine="(318, 1)" clone_start="44" clone_end="49">
			<code function_name="MinBoxObjectBuilder::ReconstructPolygon(const Eigen::Vector3d &amp;ref_ct, ObjectPtr obj)">void  MinBoxObjectBuilder::ReconstructPolygon(
        const Eigen::Vector3d &amp;ref_ct,
        ObjectPtr obj) {
    if (obj-&gt;polygon.points.size() &lt;= 0) {
        return;
    }
    size_t max_point_index = 0;
    size_t min_point_index = 0;
    Eigen::Vector3d p;
    p[0] = obj-&gt;polygon.points[0].x;
    p[1] = obj-&gt;polygon.points[0].y;
    p[2] = obj-&gt;polygon.points[0].z;
    Eigen::Vector3d max_point = p - ref_ct;
    Eigen::Vector3d min_point = p - ref_ct;
    for (size_t i = 1; i &lt; obj-&gt;polygon.points.size(); ++i) {
        Eigen::Vector3d p;
        p[0] = obj-&gt;polygon.points[i].x;
        p[1] = obj-&gt;polygon.points[i].y;
        p[2] = obj-&gt;polygon.points[i].z;
        Eigen::Vector3d ray = p - ref_ct;
        // clock direction
        if (max_point[0] * ray[1] - ray[0] * max_point[1] &lt; EPSILON) {
            max_point = ray;
            max_point_index = i;
        }
        // unclock direction
        if (min_point[0] * ray[1] - ray[0] * min_point[1] &gt; EPSILON) {
            min_point = ray;
            min_point_index = i;
        }
    }
    Eigen::Vector3d line = max_point - min_point;
    double total_len = 0;
    double max_dis = 0;
    bool has_out = false;
    for (size_t i = min_point_index, count = 0;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist = sqrt((p[0] - p_x[0]) * (p[0] - p_x[0])
                        + (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist - max_dis &gt; EPSILON) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                   || (i == max_point_index &amp;&amp; j == min_point_index)) {
            size_t k = (j + 1) % obj-&gt;polygon.points.size();
            Eigen::Vector3d p_k;
            p_k[0] = obj-&gt;polygon.points[k].x;
            p_k[1] = obj-&gt;polygon.points[k].y;
            p_k[2] = obj-&gt;polygon.points[k].z;
            Eigen::Vector3d p_j;
            p_j[0] = obj-&gt;polygon.points[j].x;
            p_j[1] = obj-&gt;polygon.points[j].y;
            p_j[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
            } else {
                // outline
                has_out = true;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p_x - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist =
                        sqrt((p[0] - p_x[0]) * (p[0] - p_x[0]) +
                            (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist &gt; max_dis) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        }
    }
    size_t count = 0;
    double min_area = std::numeric_limits&lt;double&gt;::max();
    for (size_t i = min_point_index;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        Eigen::Vector3d p_j;
        p_j[0] = obj-&gt;polygon.points[j].x;
        p_j[1] = obj-&gt;polygon.points[j].y;
        p_j[2] = obj-&gt;polygon.points[j].z;
        double dist = sqrt((p_x[0] - p_j[0]) * (p_x[0] - p_j[0])
                + (p_x[1] - p_j[1])* (p_x[1] - p_j[1]));
        if (dist &lt; max_dis &amp;&amp; (dist / total_len) &lt; 0.5) {
            continue;
        }
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0;
                double width = 0;
                Eigen::Vector3d dir;
                double area =
                    ComputeAreaAlongOneEdge(obj, i,
                                        &amp;center, &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                    || (i == max_point_index &amp;&amp; j == min_point_index)) {
            if (!has_out) {
                continue;
            }
            Eigen::Vector3d center;
            double length = 0;
            double width = 0;
            Eigen::Vector3d dir;
            double area =
               ComputeAreaAlongOneEdge(obj, i, &amp;center, &amp;length, &amp;width, &amp;dir);
            if (area &lt; min_area) {
                obj-&gt;center = center;
                obj-&gt;length = length;
                obj-&gt;width = width;
                obj-&gt;direction = dir;
                min_area = area;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[i].x;
            p[1] = obj-&gt;polygon.points[i].y;
            p[2] = obj-&gt;polygon.points[i].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0.0;
                double width = 0.0;
                Eigen::Vector3d dir;
                double area =
                   ComputeAreaAlongOneEdge(obj, i, &amp;center,
                                           &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        }
    }
    obj-&gt;direction.normalize();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\qp_solver.cc" startLine="(50, 0)" endLine="(52, 1)" clone_start="1" clone_end="3">
			<code function_name="QpSolver::QpSolver(const Eigen::MatrixXd&amp; kernel_matrix,const Eigen::MatrixXd&amp; offset, const Eigen::MatrixXd&amp; affine_inequality_matrix, const Eigen::MatrixXd&amp; affine_inequality_boundary, const Eigen::MatrixXd&amp; affine_equality_matrix, const Eigen::MatrixXd&amp; affine_equality_boundary)">const Eigen::MatrixXd&amp; QpSolver::affine_equality_boundary() const {
  return affine_equality_boundary_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\qp_solver.cc" startLine="(46, 0)" endLine="(48, 1)" clone_start="1" clone_end="3">
			<code function_name="QpSolver::QpSolver(const Eigen::MatrixXd&amp; kernel_matrix,const Eigen::MatrixXd&amp; offset, const Eigen::MatrixXd&amp; affine_inequality_matrix, const Eigen::MatrixXd&amp; affine_inequality_boundary, const Eigen::MatrixXd&amp; affine_equality_matrix, const Eigen::MatrixXd&amp; affine_equality_boundary)">const Eigen::MatrixXd&amp; QpSolver::affine_equality_matrix() const {
  return affine_equality_matrix_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\qp_solver.cc" startLine="(54, 0)" endLine="(56, 1)" clone_start="1" clone_end="3">
			<code function_name="QpSolver::QpSolver(const Eigen::MatrixXd&amp; kernel_matrix,const Eigen::MatrixXd&amp; offset, const Eigen::MatrixXd&amp; affine_inequality_matrix, const Eigen::MatrixXd&amp; affine_inequality_boundary, const Eigen::MatrixXd&amp; affine_equality_matrix, const Eigen::MatrixXd&amp; affine_equality_boundary)">const Eigen::MatrixXd&amp; QpSolver::affine_inequality_matrix() const {
  return affine_inequality_matrix_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\qp_solver.cc" startLine="(50, 0)" endLine="(52, 1)" clone_start="1" clone_end="3">
			<code function_name="QpSolver::QpSolver(const Eigen::MatrixXd&amp; kernel_matrix,const Eigen::MatrixXd&amp; offset, const Eigen::MatrixXd&amp; affine_inequality_matrix, const Eigen::MatrixXd&amp; affine_inequality_boundary, const Eigen::MatrixXd&amp; affine_equality_matrix, const Eigen::MatrixXd&amp; affine_equality_boundary)">const Eigen::MatrixXd&amp; QpSolver::affine_equality_boundary() const {
  return affine_equality_boundary_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\qp_solver.cc" startLine="(58, 0)" endLine="(60, 1)" clone_start="1" clone_end="2">
			<code function_name="QpSolver::QpSolver(const Eigen::MatrixXd&amp; kernel_matrix,const Eigen::MatrixXd&amp; offset, const Eigen::MatrixXd&amp; affine_inequality_matrix, const Eigen::MatrixXd&amp; affine_inequality_boundary, const Eigen::MatrixXd&amp; affine_equality_matrix, const Eigen::MatrixXd&amp; affine_equality_boundary)">const Eigen::MatrixXd&amp; QpSolver::affine_inequality_boundary() const {
  return affine_inequality_boundary_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\qp_solver.cc" startLine="(54, 0)" endLine="(56, 1)" clone_start="1" clone_end="2">
			<code function_name="QpSolver::QpSolver(const Eigen::MatrixXd&amp; kernel_matrix,const Eigen::MatrixXd&amp; offset, const Eigen::MatrixXd&amp; affine_inequality_matrix, const Eigen::MatrixXd&amp; affine_inequality_boundary, const Eigen::MatrixXd&amp; affine_equality_matrix, const Eigen::MatrixXd&amp; affine_equality_boundary)">const Eigen::MatrixXd&amp; QpSolver::affine_inequality_matrix() const {
  return affine_inequality_matrix_;
}</code>
		</source>
	</dup>
	<dup count="8">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\interface\base_ground_detector.h" startLine="(64, 2)" endLine="(71, 3)" clone_start="2" clone_end="7">
			<code function_name="GroundDetectorOptions()">  GroundDetectorOptions() {
    velodyne_position.x = 0.0;
    velodyne_position.y = 0.0;
    velodyne_position.z = 0.0;
    velodyne_ground_position.x = 0.0;
    velodyne_ground_position.y = 0.0;
    velodyne_ground_position.z = 0.0;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\opengl_visualizer.cc" startLine="(74, 0)" endLine="(87, 1)" clone_start="8" clone_end="13">
			<code function_name="OpenglVisualizer::SetCameraPosition()">void OpenglVisualizer::SetCameraPosition() {
  up_velodyne_.x = 0;
  up_velodyne_.y = 1;
  up_velodyne_.z = 0;
  forward_velodyne_.x = 1;
  forward_velodyne_.y = 0;
  forward_velodyne_.z = 0;
  view_point_velodyne_.x = 0;
  view_point_velodyne_.y = 0;
  view_point_velodyne_.z = 0;
  camera_center_velodyne_.x = 0;
  camera_center_velodyne_.y = 0;
  camera_center_velodyne_.z = 100;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\opengl_visualizer.cc" startLine="(74, 0)" endLine="(87, 1)" clone_start="7" clone_end="12">
			<code function_name="OpenglVisualizer::SetCameraPosition()">void OpenglVisualizer::SetCameraPosition() {
  up_velodyne_.x = 0;
  up_velodyne_.y = 1;
  up_velodyne_.z = 0;
  forward_velodyne_.x = 1;
  forward_velodyne_.y = 0;
  forward_velodyne_.z = 0;
  view_point_velodyne_.x = 0;
  view_point_velodyne_.y = 0;
  view_point_velodyne_.z = 0;
  camera_center_velodyne_.x = 0;
  camera_center_velodyne_.y = 0;
  camera_center_velodyne_.z = 100;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\opengl_visualizer.cc" startLine="(74, 0)" endLine="(87, 1)" clone_start="6" clone_end="11">
			<code function_name="OpenglVisualizer::SetCameraPosition()">void OpenglVisualizer::SetCameraPosition() {
  up_velodyne_.x = 0;
  up_velodyne_.y = 1;
  up_velodyne_.z = 0;
  forward_velodyne_.x = 1;
  forward_velodyne_.y = 0;
  forward_velodyne_.z = 0;
  view_point_velodyne_.x = 0;
  view_point_velodyne_.y = 0;
  view_point_velodyne_.z = 0;
  camera_center_velodyne_.x = 0;
  camera_center_velodyne_.y = 0;
  camera_center_velodyne_.z = 100;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\opengl_visualizer.cc" startLine="(74, 0)" endLine="(87, 1)" clone_start="5" clone_end="10">
			<code function_name="OpenglVisualizer::SetCameraPosition()">void OpenglVisualizer::SetCameraPosition() {
  up_velodyne_.x = 0;
  up_velodyne_.y = 1;
  up_velodyne_.z = 0;
  forward_velodyne_.x = 1;
  forward_velodyne_.y = 0;
  forward_velodyne_.z = 0;
  view_point_velodyne_.x = 0;
  view_point_velodyne_.y = 0;
  view_point_velodyne_.z = 0;
  camera_center_velodyne_.x = 0;
  camera_center_velodyne_.y = 0;
  camera_center_velodyne_.z = 100;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\opengl_visualizer.cc" startLine="(74, 0)" endLine="(87, 1)" clone_start="4" clone_end="9">
			<code function_name="OpenglVisualizer::SetCameraPosition()">void OpenglVisualizer::SetCameraPosition() {
  up_velodyne_.x = 0;
  up_velodyne_.y = 1;
  up_velodyne_.z = 0;
  forward_velodyne_.x = 1;
  forward_velodyne_.y = 0;
  forward_velodyne_.z = 0;
  view_point_velodyne_.x = 0;
  view_point_velodyne_.y = 0;
  view_point_velodyne_.z = 0;
  camera_center_velodyne_.x = 0;
  camera_center_velodyne_.y = 0;
  camera_center_velodyne_.z = 100;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\opengl_visualizer.cc" startLine="(74, 0)" endLine="(87, 1)" clone_start="3" clone_end="8">
			<code function_name="OpenglVisualizer::SetCameraPosition()">void OpenglVisualizer::SetCameraPosition() {
  up_velodyne_.x = 0;
  up_velodyne_.y = 1;
  up_velodyne_.z = 0;
  forward_velodyne_.x = 1;
  forward_velodyne_.y = 0;
  forward_velodyne_.z = 0;
  view_point_velodyne_.x = 0;
  view_point_velodyne_.y = 0;
  view_point_velodyne_.z = 0;
  camera_center_velodyne_.x = 0;
  camera_center_velodyne_.y = 0;
  camera_center_velodyne_.z = 100;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\opengl_visualizer.cc" startLine="(74, 0)" endLine="(87, 1)" clone_start="2" clone_end="7">
			<code function_name="OpenglVisualizer::SetCameraPosition()">void OpenglVisualizer::SetCameraPosition() {
  up_velodyne_.x = 0;
  up_velodyne_.y = 1;
  up_velodyne_.z = 0;
  forward_velodyne_.x = 1;
  forward_velodyne_.y = 0;
  forward_velodyne_.z = 0;
  view_point_velodyne_.x = 0;
  view_point_velodyne_.y = 0;
  view_point_velodyne_.z = 0;
  camera_center_velodyne_.x = 0;
  camera_center_velodyne_.y = 0;
  camera_center_velodyne_.z = 100;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\qp_spline_path\qp_spline_path_generator.cc" startLine="(326, 0)" endLine="(356, 1)" clone_start="17" clone_end="28">
			<code function_name="QpSplinePathGenerator::AddKernel()">void QpSplinePathGenerator::AddKernel() {
  Spline1dKernel* spline_kernel = spline_generator_-&gt;mutable_spline_kernel();

  if (qp_spline_path_config_.reference_line_weight() &gt; 0.0) {
    std::vector&lt;double&gt; ref_l(evaluated_s_.size(), 0.0);

    DCHECK_EQ(evaluated_s_.size(), ref_l.size());
    spline_kernel-&gt;AddReferenceLineKernelMatrix(
        evaluated_s_, ref_l, qp_spline_path_config_.reference_line_weight());
  }

  if (qp_spline_path_config_.regularization_weight() &gt; 0.0) {
    spline_kernel-&gt;AddRegularization(
        qp_spline_path_config_.regularization_weight());
  }

  if (qp_spline_path_config_.derivative_weight() &gt; 0.0) {
    spline_kernel-&gt;AddDerivativeKernelMatrix(
        qp_spline_path_config_.derivative_weight());
  }

  if (qp_spline_path_config_.second_derivative_weight() &gt; 0.0) {
    spline_kernel-&gt;AddSecondOrderDerivativeMatrix(
        qp_spline_path_config_.second_derivative_weight());
  }

  if (qp_spline_path_config_.third_derivative_weight() &gt; 0.0) {
    spline_kernel-&gt;AddThirdOrderDerivativeMatrix(
        qp_spline_path_config_.third_derivative_weight());
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\qp_spline_path\qp_spline_path_generator.cc" startLine="(326, 0)" endLine="(356, 1)" clone_start="12" clone_end="23">
			<code function_name="QpSplinePathGenerator::AddKernel()">void QpSplinePathGenerator::AddKernel() {
  Spline1dKernel* spline_kernel = spline_generator_-&gt;mutable_spline_kernel();

  if (qp_spline_path_config_.reference_line_weight() &gt; 0.0) {
    std::vector&lt;double&gt; ref_l(evaluated_s_.size(), 0.0);

    DCHECK_EQ(evaluated_s_.size(), ref_l.size());
    spline_kernel-&gt;AddReferenceLineKernelMatrix(
        evaluated_s_, ref_l, qp_spline_path_config_.reference_line_weight());
  }

  if (qp_spline_path_config_.regularization_weight() &gt; 0.0) {
    spline_kernel-&gt;AddRegularization(
        qp_spline_path_config_.regularization_weight());
  }

  if (qp_spline_path_config_.derivative_weight() &gt; 0.0) {
    spline_kernel-&gt;AddDerivativeKernelMatrix(
        qp_spline_path_config_.derivative_weight());
  }

  if (qp_spline_path_config_.second_derivative_weight() &gt; 0.0) {
    spline_kernel-&gt;AddSecondOrderDerivativeMatrix(
        qp_spline_path_config_.second_derivative_weight());
  }

  if (qp_spline_path_config_.third_derivative_weight() &gt; 0.0) {
    spline_kernel-&gt;AddThirdOrderDerivativeMatrix(
        qp_spline_path_config_.third_derivative_weight());
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\reference_line\reference_line_smoother.cc" startLine="(214, 0)" endLine="(235, 1)" clone_start="5" clone_end="15">
			<code function_name="ReferenceLineSmoother::ApplyKernel()">bool ReferenceLineSmoother::ApplyKernel() {
  Spline2dKernel* kernel = spline_solver_-&gt;mutable_kernel();

  // add spline kernel
  if (smoother_config_.derivative_weight() &gt; 0.0) {
    kernel-&gt;AddDerivativeKernelMatrix(smoother_config_.derivative_weight());
  }

  if (smoother_config_.second_derivative_weight() &gt; 0.0) {
    kernel-&gt;AddSecondOrderDerivativeMatrix(
        smoother_config_.second_derivative_weight());
  }

  if (smoother_config_.third_derivative_weight() &gt; 0.0) {
    kernel-&gt;AddThirdOrderDerivativeMatrix(
        smoother_config_.third_derivative_weight());
  }

  constexpr double kReferenceLineSmootherKernelWeight = 0.01;
  kernel-&gt;AddRegularization(kReferenceLineSmootherKernelWeight);
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(636, 0)" endLine="(677, 1)" clone_start="1" clone_end="9">
			<code function_name="Obstacle::InitKFPedestrianTracker(Feature* feature)">void Obstacle::InitKFPedestrianTracker(Feature* feature) {
  // Set transition matrix F
  Eigen::Matrix&lt;double, 2, 2&gt; F;
  F.setIdentity();
  kf_pedestrian_tracker_.SetTransitionMatrix(F);

  // Set observation matrix H
  Eigen::Matrix&lt;double, 2, 2&gt; H;
  H.setIdentity();
  kf_pedestrian_tracker_.SetObservationMatrix(H);

  // Set control matrix
  Eigen::Matrix&lt;double, 2, 4&gt; B;
  B.setZero();
  kf_pedestrian_tracker_.SetControlMatrix(B);

  // Set covariance of transition noise matrix Q
  Eigen::Matrix&lt;double, 2, 2&gt; Q;
  Q.setIdentity();
  Q *= FLAGS_q_var;
  kf_pedestrian_tracker_.SetTransitionNoise(Q);

  // Set observation noise matrix R
  Eigen::Matrix&lt;double, 2, 2&gt; R;
  R.setIdentity();
  R *= FLAGS_r_var;
  kf_pedestrian_tracker_.SetObservationNoise(R);

  // Set current state covariance matrix P
  Eigen::Matrix&lt;double, 2, 2&gt; P;
  P.setIdentity();
  P *= FLAGS_p_var;

  // Set initial state
  Eigen::Matrix&lt;double, 2, 1&gt; x;
  x(0, 0) = feature-&gt;position().x();
  x(1, 0) = feature-&gt;position().y();

  kf_pedestrian_tracker_.SetStateEstimate(x, P);

  kf_pedestrian_tracker_enabled_ = true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(364, 0)" endLine="(406, 1)" clone_start="1" clone_end="9">
			<code function_name="Obstacle::InitKFMotionTracker(Feature* feature)">void Obstacle::InitKFMotionTracker(Feature* feature) {
  // Set transition matrix F
  Eigen::Matrix&lt;double, 6, 6&gt; F;
  F.setIdentity();
  kf_motion_tracker_.SetTransitionMatrix(F);

  // Set observation matrix H
  Eigen::Matrix&lt;double, 2, 6&gt; H;
  H.setZero();
  H(0, 0) = 1.0;
  H(1, 1) = 1.0;
  kf_motion_tracker_.SetObservationMatrix(H);

  // Set covariance of transition noise matrix Q
  Eigen::Matrix&lt;double, 6, 6&gt; Q;
  Q.setIdentity();
  Q *= FLAGS_q_var;
  kf_motion_tracker_.SetTransitionNoise(Q);

  // Set observation noise matrix R
  Eigen::Matrix&lt;double, 2, 2&gt; R;
  R.setIdentity();
  R *= FLAGS_r_var;
  kf_motion_tracker_.SetObservationNoise(R);

  // Set current state covariance matrix P
  Eigen::Matrix&lt;double, 6, 6&gt; P;
  P.setIdentity();
  P *= FLAGS_p_var;

  // Set initial state
  Eigen::Matrix&lt;double, 6, 1&gt; x;
  x(0, 0) = feature-&gt;position().x();
  x(1, 0) = feature-&gt;position().y();
  x(2, 0) = feature-&gt;velocity().x();
  x(3, 0) = feature-&gt;velocity().y();
  x(4, 0) = feature-&gt;acceleration().x();
  x(5, 0) = feature-&gt;acceleration().y();

  kf_motion_tracker_.SetStateEstimate(x, P);

  kf_motion_tracker_enabled_ = true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(143, 0)" endLine="(159, 1)" clone_start="5" clone_end="16">
			<code function_name="UdpStream::connect()">bool UdpStream::connect() {
  if (_sockfd &lt; 0) {
    this-&gt;open();
    if (_sockfd &lt; 0) {
      return false;
    }
  }

  if (_status == Stream::Status::CONNECTED) {
    return true;
  }

  // upper layer support ping method ??
  login();
  _status = Stream::Status::CONNECTED;
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(221, 0)" endLine="(238, 1)" clone_start="7" clone_end="17">
			<code function_name="SerialStream::connect()">bool SerialStream::connect() {
  if (!_is_open) {
    this-&gt;open();
    if (!_is_open) {
      _status = Stream::Status::ERROR;
      _errno = errno;
      return false;
    }
  }

  if (_status == Stream::Status::CONNECTED) {
    return true;
  }

  login();
  _status = Stream::Status::CONNECTED;
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\common\geometry_util.cc" startLine="(68, 0)" endLine="(85, 1)" clone_start="5" clone_end="11">
			<code function_name="TransAffineToMatrix4(const Eigen::Vector3d&amp; translation,const Eigen::Vector4d&amp; rotation, Eigen::Matrix4d* trans_matrix)">void TransAffineToMatrix4(const Eigen::Vector3d&amp; translation,
                          const Eigen::Vector4d&amp; rotation,
                          Eigen::Matrix4d* trans_matrix) {
  const double t_x = translation(0);
  const double t_y = translation(1);
  const double t_z = translation(2);

  const double qx = rotation(0);
  const double qy = rotation(1);
  const double qz = rotation(2);
  const double qw = rotation(3);

  (*trans_matrix) &lt;&lt; 1 - 2 * (qy * qy + qz * qz), 2 * (qx * qy - qz * qw),
      2 * (qx * qz + qy * qw), t_x, 2 * (qx * qy + qz * qw),
      1 - 2 * (qx * qx + qz * qz), 2 * (qy * qz - qx * qw), t_y,
      2 * (qx * qz - qy * qw), 2 * (qy * qz + qx * qw),
      1 - 2 * (qx * qx + qy * qy), t_z, 0, 0, 0, 1;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\common\geometry_util.cc" startLine="(68, 0)" endLine="(85, 1)" clone_start="4" clone_end="10">
			<code function_name="TransAffineToMatrix4(const Eigen::Vector3d&amp; translation,const Eigen::Vector4d&amp; rotation, Eigen::Matrix4d* trans_matrix)">void TransAffineToMatrix4(const Eigen::Vector3d&amp; translation,
                          const Eigen::Vector4d&amp; rotation,
                          Eigen::Matrix4d* trans_matrix) {
  const double t_x = translation(0);
  const double t_y = translation(1);
  const double t_z = translation(2);

  const double qx = rotation(0);
  const double qy = rotation(1);
  const double qz = rotation(2);
  const double qw = rotation(3);

  (*trans_matrix) &lt;&lt; 1 - 2 * (qy * qy + qz * qz), 2 * (qx * qy - qz * qw),
      2 * (qx * qz + qy * qw), t_x, 2 * (qx * qy + qz * qw),
      1 - 2 * (qx * qx + qz * qz), 2 * (qy * qz - qx * qw), t_y,
      2 * (qx * qz - qy * qw), 2 * (qy * qz + qx * qw),
      1 - 2 * (qx * qx + qy * qy), t_z, 0, 0, 0, 1;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\core\navigator.cc" startLine="(80, 0)" endLine="(109, 1)" clone_start="22" clone_end="28">
			<code function_name="GetWayNodes(const RoutingRequest&amp; request, const TopoGraph* graph,std::vector&lt;const TopoNode*&gt;* const way_nodes, std::vector&lt;double&gt;* const way_s)">bool GetWayNodes(const RoutingRequest&amp; request, const TopoGraph* graph,
                 std::vector&lt;const TopoNode*&gt;* const way_nodes,
                 std::vector&lt;double&gt;* const way_s) {
  const auto* start_node = graph-&gt;GetNode(request.start().id());
  if (start_node == nullptr) {
    AERROR &lt;&lt; "Can't find start point in graph! Id: " &lt;&lt; request.start().id();
    return false;
  }
  way_nodes-&gt;push_back(start_node);
  way_s-&gt;push_back(request.start().s());

  for (const auto&amp; point : request.waypoint()) {
    const auto* cur_node = graph-&gt;GetNode(point.id());
    if (cur_node == nullptr) {
      AERROR &lt;&lt; "Can't find way point in graph! Id: " &lt;&lt; point.id();
      return false;
    }
    way_nodes-&gt;push_back(cur_node);
    way_s-&gt;push_back(point.s());
  }

  const auto* end_node = graph-&gt;GetNode(request.end().id());
  if (end_node == nullptr) {
    AERROR &lt;&lt; "Can't find end point in graph! Id: " &lt;&lt; request.end().id();
    return false;
  }
  way_nodes-&gt;push_back(end_node);
  way_s-&gt;push_back(request.end().s());
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\core\navigator.cc" startLine="(80, 0)" endLine="(109, 1)" clone_start="4" clone_end="10">
			<code function_name="GetWayNodes(const RoutingRequest&amp; request, const TopoGraph* graph,std::vector&lt;const TopoNode*&gt;* const way_nodes, std::vector&lt;double&gt;* const way_s)">bool GetWayNodes(const RoutingRequest&amp; request, const TopoGraph* graph,
                 std::vector&lt;const TopoNode*&gt;* const way_nodes,
                 std::vector&lt;double&gt;* const way_s) {
  const auto* start_node = graph-&gt;GetNode(request.start().id());
  if (start_node == nullptr) {
    AERROR &lt;&lt; "Can't find start point in graph! Id: " &lt;&lt; request.start().id();
    return false;
  }
  way_nodes-&gt;push_back(start_node);
  way_s-&gt;push_back(request.start().s());

  for (const auto&amp; point : request.waypoint()) {
    const auto* cur_node = graph-&gt;GetNode(point.id());
    if (cur_node == nullptr) {
      AERROR &lt;&lt; "Can't find way point in graph! Id: " &lt;&lt; point.id();
      return false;
    }
    way_nodes-&gt;push_back(cur_node);
    way_s-&gt;push_back(point.s());
  }

  const auto* end_node = graph-&gt;GetNode(request.end().id());
  if (end_node == nullptr) {
    AERROR &lt;&lt; "Can't find end point in graph! Id: " &lt;&lt; request.end().id();
    return false;
  }
  way_nodes-&gt;push_back(end_node);
  way_s-&gt;push_back(request.end().s());
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(236, 2)" endLine="(236, 50)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const Id &amp;id() const { return crosswalk_.id(); }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(192, 2)" endLine="(192, 49)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const Id &amp;id() const { return junction_.id(); }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(237, 2)" endLine="(237, 59)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const Crosswalk &amp;crosswalk() const { return crosswalk_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(193, 2)" endLine="(193, 56)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const Junction &amp;junction() const { return junction_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(238, 2)" endLine="(238, 77)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const apollo::common::math::Polygon2d &amp;polygon() const { return polygon_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(194, 2)" endLine="(194, 77)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const apollo::common::math::Polygon2d &amp;polygon() const { return polygon_; }</code>
		</source>
	</dup>
	<dup count="8">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\track_object_distance.cc" startLine="(68, 0)" endLine="(78, 1)" clone_start="5" clone_end="11">
			<code function_name="TrackObjectDistance::SetPointNumDistanceWeight( const float&amp; point_num_distance_weight)">bool TrackObjectDistance::SetPointNumDistanceWeight(
  const float&amp; point_num_distance_weight) {
  if (point_num_distance_weight &gt;= 0) {
    s_point_num_distance_weight_ = point_num_distance_weight;
    AINFO &lt;&lt; "point num distance weight of TrackObjectDistance is "
          &lt;&lt; s_point_num_distance_weight_;
    return true;
  }
  AERROR &lt;&lt; "invalid point num distance weight of TrackObjectDistance!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\track_object_distance.cc" startLine="(56, 0)" endLine="(66, 1)" clone_start="5" clone_end="11">
			<code function_name="TrackObjectDistance::SetBboxSizeDistanceWeight( const float&amp; bbox_size_distance_weight)">bool TrackObjectDistance::SetBboxSizeDistanceWeight(
  const float&amp; bbox_size_distance_weight) {
  if (bbox_size_distance_weight &gt;= 0) {
    s_bbox_size_distance_weight_ = bbox_size_distance_weight;
    AINFO &lt;&lt; "bbox size distance weight of TrackObjectDistance is "
          &lt;&lt; s_bbox_size_distance_weight_;
    return true;
  }
  AERROR &lt;&lt; "invalid bbox size distance weight of TrackObjectDistance!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\track_object_distance.cc" startLine="(44, 0)" endLine="(54, 1)" clone_start="5" clone_end="11">
			<code function_name="TrackObjectDistance::SetDirectionDistanceWeight( const float&amp; direction_distance_weight)">bool TrackObjectDistance::SetDirectionDistanceWeight(
  const float&amp; direction_distance_weight) {
  if (direction_distance_weight &gt;= 0) {
    s_direction_distance_weight_ = direction_distance_weight;
    AINFO &lt;&lt; "direction distance weight of TrackObjectDistance is "
          &lt;&lt; s_direction_distance_weight_;
    return true;
  }
  AERROR &lt;&lt; "invalid direction distance weight of TrackObjectDistance!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\track_object_distance.cc" startLine="(32, 0)" endLine="(42, 1)" clone_start="5" clone_end="11">
			<code function_name="TrackObjectDistance::SetLocationDistanceWeight( const float&amp; location_distance_weight)">bool TrackObjectDistance::SetLocationDistanceWeight(
  const float&amp; location_distance_weight) {
  if (location_distance_weight &gt;= 0) {
    s_location_distance_weight_ = location_distance_weight;
    AINFO &lt;&lt; "location distance weight of TrackObjectDistance is "
          &lt;&lt; s_location_distance_weight_;
    return true;
  }
  AERROR &lt;&lt; "invalid location distance weight of TrackeObjectDistance!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(377, 0)" endLine="(388, 1)" clone_start="6" clone_end="12">
			<code function_name="ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum( const int&amp; track_consecutive_invisible_maximum)">bool ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    const int&amp; track_consecutive_invisible_maximum) {
  if (track_consecutive_invisible_maximum &gt;= 0) {
    s_track_consecutive_invisible_maximum_ =
        track_consecutive_invisible_maximum;
    AINFO &lt;&lt; "track consecutive invisible maximum of object track set is "
          &lt;&lt; s_track_consecutive_invisible_maximum_;
    return true;
  }
  AERROR &lt;&lt; "invalid track consecutive invisible maximum of object track! ";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(60, 0)" endLine="(69, 1)" clone_start="4" clone_end="10">
			<code function_name="ObjectTrack::SetSpeedNoiseMaximum(const double&amp; speed_noise_maximum)">bool ObjectTrack::SetSpeedNoiseMaximum(const double&amp; speed_noise_maximum) {
  if (speed_noise_maximum &gt; 0) {
    s_speed_noise_maximum_ = speed_noise_maximum;
    AINFO &lt;&lt; "speed noise maximum of object track is "
          &lt;&lt; s_speed_noise_maximum_;
    return true;
  }
  AERROR &lt;&lt; "invalid speed noise maximum of object track!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(48, 0)" endLine="(58, 1)" clone_start="5" clone_end="11">
			<code function_name="ObjectTrack::SetTrackCachedHistorySizeMaximum( const int&amp; track_cached_history_size_maximum)">bool ObjectTrack::SetTrackCachedHistorySizeMaximum(
    const int&amp; track_cached_history_size_maximum) {
  if (track_cached_history_size_maximum &gt; 0) {
    s_track_cached_history_size_maximum_ = track_cached_history_size_maximum;
    AINFO &lt;&lt; "track cached history size maximum of object track is "
          &lt;&lt; s_track_cached_history_size_maximum_;
    return true;
  }
  AERROR &lt;&lt; "invalid track cached history size maximum of object track!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\kalman_filter.cc" startLine="(38, 0)" endLine="(48, 1)" clone_start="5" clone_end="11">
			<code function_name="KalmanFilter::SetAssociationScoreMaximum( const double&amp; association_score_maximum)">bool KalmanFilter::SetAssociationScoreMaximum(
  const double&amp; association_score_maximum) {
  if (association_score_maximum &gt; 0) {
    s_association_score_maximum_ = association_score_maximum;
    AINFO &lt;&lt; "association score maximum of KalmanFilter is "
          &lt;&lt; s_association_score_maximum_;
    return true;
  }
  AERROR &lt;&lt; "invalid association score maximum of KalmanFilter!";
  return false;
}</code>
		</source>
	</dup>
	<dup count="8">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\track_object_distance.cc" startLine="(80, 0)" endLine="(90, 1)" clone_start="1" clone_end="1">
			<code function_name="TrackObjectDistance::SetHistogramDistanceWeight( const float&amp; histogram_distance_weight)">bool TrackObjectDistance::SetHistogramDistanceWeight(
  const float&amp; histogram_distance_weight) {
  if (histogram_distance_weight &gt;= 0) {
    s_histogram_distance_weight_ = histogram_distance_weight;
    AINFO &lt;&lt; "histogram distance weight of TrackObjectDistance is "
          &lt;&lt; s_histogram_distance_weight_;
    return true;
  }
  AERROR &lt;&lt; "invalid histogram distance weight of TrackObjectDistance!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\track_object_distance.cc" startLine="(68, 0)" endLine="(78, 1)" clone_start="1" clone_end="1">
			<code function_name="TrackObjectDistance::SetPointNumDistanceWeight( const float&amp; point_num_distance_weight)">bool TrackObjectDistance::SetPointNumDistanceWeight(
  const float&amp; point_num_distance_weight) {
  if (point_num_distance_weight &gt;= 0) {
    s_point_num_distance_weight_ = point_num_distance_weight;
    AINFO &lt;&lt; "point num distance weight of TrackObjectDistance is "
          &lt;&lt; s_point_num_distance_weight_;
    return true;
  }
  AERROR &lt;&lt; "invalid point num distance weight of TrackObjectDistance!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\track_object_distance.cc" startLine="(56, 0)" endLine="(66, 1)" clone_start="1" clone_end="1">
			<code function_name="TrackObjectDistance::SetBboxSizeDistanceWeight( const float&amp; bbox_size_distance_weight)">bool TrackObjectDistance::SetBboxSizeDistanceWeight(
  const float&amp; bbox_size_distance_weight) {
  if (bbox_size_distance_weight &gt;= 0) {
    s_bbox_size_distance_weight_ = bbox_size_distance_weight;
    AINFO &lt;&lt; "bbox size distance weight of TrackObjectDistance is "
          &lt;&lt; s_bbox_size_distance_weight_;
    return true;
  }
  AERROR &lt;&lt; "invalid bbox size distance weight of TrackObjectDistance!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\track_object_distance.cc" startLine="(44, 0)" endLine="(54, 1)" clone_start="1" clone_end="1">
			<code function_name="TrackObjectDistance::SetDirectionDistanceWeight( const float&amp; direction_distance_weight)">bool TrackObjectDistance::SetDirectionDistanceWeight(
  const float&amp; direction_distance_weight) {
  if (direction_distance_weight &gt;= 0) {
    s_direction_distance_weight_ = direction_distance_weight;
    AINFO &lt;&lt; "direction distance weight of TrackObjectDistance is "
          &lt;&lt; s_direction_distance_weight_;
    return true;
  }
  AERROR &lt;&lt; "invalid direction distance weight of TrackObjectDistance!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(390, 0)" endLine="(400, 1)" clone_start="1" clone_end="1">
			<code function_name="ObjectTrackSet::SetTrackVisibleRatioMinimum( const float&amp; track_visible_ratio_minimum)">bool ObjectTrackSet::SetTrackVisibleRatioMinimum(
    const float&amp; track_visible_ratio_minimum) {
  if (track_visible_ratio_minimum &gt;= 0 &amp;&amp; track_visible_ratio_minimum &lt;= 1) {
    s_track_visible_ratio_minimum_ = track_visible_ratio_minimum;
    AINFO &lt;&lt; "track visible ratio minimum of object track set is "
          &lt;&lt; s_track_visible_ratio_minimum_;
    return true;
  }
  AERROR &lt;&lt; "invalid track visible ratio minimum of object track! ";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(71, 0)" endLine="(81, 1)" clone_start="1" clone_end="1">
			<code function_name="ObjectTrack::SetAccelerationNoiseMaximum( const double&amp; acceleration_noise_maximum)">bool ObjectTrack::SetAccelerationNoiseMaximum(
    const double&amp; acceleration_noise_maximum) {
  if (acceleration_noise_maximum &gt; 0) {
    s_acceleration_noise_maximum_ = acceleration_noise_maximum;
    AINFO &lt;&lt; "acceleration noise maximum of object track is "
          &lt;&lt; s_acceleration_noise_maximum_;
    return true;
  }
  AERROR &lt;&lt; "invalid acceleration noise maximum of object track!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(60, 0)" endLine="(69, 1)" clone_start="1" clone_end="1">
			<code function_name="ObjectTrack::SetSpeedNoiseMaximum(const double&amp; speed_noise_maximum)">bool ObjectTrack::SetSpeedNoiseMaximum(const double&amp; speed_noise_maximum) {
  if (speed_noise_maximum &gt; 0) {
    s_speed_noise_maximum_ = speed_noise_maximum;
    AINFO &lt;&lt; "speed noise maximum of object track is "
          &lt;&lt; s_speed_noise_maximum_;
    return true;
  }
  AERROR &lt;&lt; "invalid speed noise maximum of object track!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\kalman_filter.cc" startLine="(50, 0)" endLine="(60, 1)" clone_start="1" clone_end="1">
			<code function_name="KalmanFilter::SetBreakdownThresholdMaximum( const double&amp; breakdown_threshold_maximum)">bool KalmanFilter::SetBreakdownThresholdMaximum(
  const double&amp; breakdown_threshold_maximum) {
  if (breakdown_threshold_maximum &gt; 0) {
    s_breakdown_threshold_maximum_ = breakdown_threshold_maximum;
    AINFO &lt;&lt; "breakdown threshold maximum of KalmanFilter is "
          &lt;&lt; s_breakdown_threshold_maximum_;
    return true;
  }
  AERROR &lt;&lt; "invalid breakdown threshold maximum of KalmanFilter!";
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\box2d.h" startLine="(120, 2)" endLine="(120, 53)" clone_start="1" clone_end="1">
			<code function_name="half_length() const">  double half_length() const { return half_length_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\box2d.h" startLine="(114, 2)" endLine="(114, 41)" clone_start="1" clone_end="1">
			<code function_name="width() const">  double width() const { return width_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\box2d.h" startLine="(126, 2)" endLine="(126, 51)" clone_start="1" clone_end="1">
			<code function_name="half_width() const">  double half_width() const { return half_width_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\box2d.h" startLine="(120, 2)" endLine="(120, 53)" clone_start="1" clone_end="1">
			<code function_name="half_length() const">  double half_length() const { return half_length_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\box2d.h" startLine="(132, 2)" endLine="(132, 45)" clone_start="1" clone_end="1">
			<code function_name="heading() const">  double heading() const { return heading_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\box2d.h" startLine="(126, 2)" endLine="(126, 51)" clone_start="1" clone_end="1">
			<code function_name="half_width() const">  double half_width() const { return half_width_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\box2d.h" startLine="(138, 2)" endLine="(138, 53)" clone_start="1" clone_end="1">
			<code function_name="cos_heading() const">  double cos_heading() const { return cos_heading_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\box2d.h" startLine="(132, 2)" endLine="(132, 45)" clone_start="1" clone_end="1">
			<code function_name="heading() const">  double heading() const { return heading_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\box2d.h" startLine="(144, 2)" endLine="(144, 53)" clone_start="1" clone_end="1">
			<code function_name="sin_heading() const">  double sin_heading() const { return sin_heading_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\box2d.h" startLine="(138, 2)" endLine="(138, 53)" clone_start="1" clone_end="1">
			<code function_name="cos_heading() const">  double cos_heading() const { return cos_heading_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(349, 0)" endLine="(387, 1)" clone_start="22" clone_end="29">
			<code function_name="LanesXmlParser::ParseSampleAssociates( const tinyxml2::XMLElement&amp; xml_node, PbLane* lane)">Status LanesXmlParser::ParseSampleAssociates(
    const tinyxml2::XMLElement&amp; xml_node, PbLane* lane) {
  CHECK_NOTNULL(lane);
  auto sub_node = xml_node.FirstChildElement("sampleAssociates");
  if (sub_node == nullptr) {
    std::string err_msg = "Error parse sample associates";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  sub_node = sub_node-&gt;FirstChildElement("sampleAssociate");
  if (sub_node == nullptr) {
    std::string err_msg = "Error parse sample associate";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  while (sub_node) {
    double left_width = 0.0;
    double right_width = 0.0;
    double s = 0.0;
    int checker = sub_node-&gt;QueryDoubleAttribute("sOffset", &amp;s);
    checker += sub_node-&gt;QueryDoubleAttribute("leftWidth", &amp;left_width);
    checker += sub_node-&gt;QueryDoubleAttribute("rightWidth", &amp;right_width);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse lane sample associate attribute";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    auto left_sample = lane-&gt;add_left_sample();
    left_sample-&gt;set_s(s);
    left_sample-&gt;set_width(left_width);

    auto right_sample = lane-&gt;add_right_sample();
    right_sample-&gt;set_s(s);
    right_sample-&gt;set_width(right_width);

    sub_node = sub_node-&gt;NextSiblingElement("sampleAssociate");
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(168, 0)" endLine="(289, 1)" clone_start="65" clone_end="71">
			<code function_name="LanesXmlParser::ParseLane(const tinyxml2::XMLElement&amp; xml_node, LaneInternal* lane_internal)">Status LanesXmlParser::ParseLane(const tinyxml2::XMLElement&amp; xml_node,
                                 LaneInternal* lane_internal) {
  CHECK_NOTNULL(lane_internal);

  PbLane* lane = &amp;lane_internal-&gt;lane;
  // lane id
  int id = 0;
  int checker = xml_node.QueryIntAttribute("id", &amp;id);
  if (checker != tinyxml2::XML_SUCCESS) {
    std::string err_msg = "Error parse lane id";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  std::string lane_id;
  checker = UtilXmlParser::QueryStringAttribute(xml_node, "uid", &amp;lane_id);
  if (checker != tinyxml2::XML_SUCCESS) {
    std::string err_msg = "Error parse lane uid";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  lane-&gt;mutable_id()-&gt;set_id(lane_id);

  // lane type
  std::string lane_type;
  checker = UtilXmlParser::QueryStringAttribute(xml_node, "type", &amp;lane_type);
  if (checker != tinyxml2::XML_SUCCESS) {
    std::string err_msg = "Error parse lane type.";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  PbLaneType pb_lane_type;
  Status success = ToPbLaneType(lane_type, &amp;pb_lane_type);
  if (!success.ok()) {
    std::string err_msg = "Error convert lane type to pb lane type.";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  lane-&gt;set_type(pb_lane_type);

  // border
  const tinyxml2::XMLElement* sub_node = xml_node.FirstChildElement("border");
  if (sub_node) {
    PbLaneBoundary* lane_boundary = lane-&gt;mutable_right_boundary();
    CHECK(lane_boundary != nullptr);
    success =
        UtilXmlParser::ParseCurve(*sub_node, lane_boundary-&gt;mutable_curve());
    if (!success.ok()) {
      std::string err_msg = "Error parse lane border";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }
    lane_boundary-&gt;set_length(
        UtilXmlParser::CurveLength(*lane_boundary-&gt;mutable_curve()));
  }

  // road mark
  if (sub_node) {
    sub_node = sub_node-&gt;FirstChildElement("borderType");
  }
  while (sub_node) {
    PbLaneBoundary* lane_boundary = lane-&gt;mutable_right_boundary();
    PbLaneBoundaryTypeType boundary_type;
    success = ParseLaneBorderMark(*sub_node, &amp;boundary_type);
    if (!success.ok()) {
      std::string err_msg = "Error parse lane border type";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }
    double s_offset = 0.0;
    checker = sub_node-&gt;QueryDoubleAttribute("sOffset", &amp;s_offset);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse lane boundary type offset.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }
    auto lane_boundary_type = lane_boundary-&gt;add_boundary_type();
    lane_boundary_type-&gt;set_s(s_offset);
    lane_boundary_type-&gt;add_types(boundary_type);
    sub_node = sub_node-&gt;NextSiblingElement("borderType");
  }

  // reference line
  if (IsReferenceLane(id)) {
    return Status::OK();
  }

  // turn type
  std::string turn_type;
  checker =
      UtilXmlParser::QueryStringAttribute(xml_node, "turnType", &amp;turn_type);
  if (checker != tinyxml2::XML_SUCCESS) {
    std::string err_msg = "Error parse lane turn type.";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  PbTurnType pb_turn_type;
  success = ToPbTurnType(turn_type, &amp;pb_turn_type);
  if (!success.ok()) {
    std::string err_msg = "Error convert turn type to pb turn type.";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  lane-&gt;set_turn(pb_turn_type);

  // direction
  RETURN_IF_ERROR(ParseDirection(xml_node, lane));

  // link
  sub_node = xml_node.FirstChildElement("link");
  if (sub_node) {
    ParseLaneLink(*sub_node, lane);
  }

  // center curve
  RETURN_IF_ERROR(ParseCenterCurve(xml_node, lane));
  // speed
  RETURN_IF_ERROR(ParseSpeed(xml_node, lane));
  // sample association
  RETURN_IF_ERROR(ParseSampleAssociates(xml_node, lane));

  // overlap object
  ParseObjectOverlapGroup(xml_node, &amp;lane_internal-&gt;overlap_objects);
  // overlap signal
  ParseSignalOverlapGroup(xml_node, &amp;lane_internal-&gt;overlap_signals);
  // overlap junction
  ParseJunctionOverlapGroup(xml_node, &amp;lane_internal-&gt;overlap_junctions);
  // overlap lane
  ParseLaneOverlapGroup(xml_node, &amp;lane_internal-&gt;overlap_lanes);

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="5">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(47, 0)" endLine="(62, 1)" clone_start="10" clone_end="15">
			<code function_name="Spline2dSeg::SetParams(const std::vector&lt;double&gt;&amp; x_param, const std::vector&lt;double&gt;&amp; y_param)">bool Spline2dSeg::SetParams(const std::vector&lt;double&gt;&amp; x_param,
                            const std::vector&lt;double&gt;&amp; y_param) {
  if (x_param.size() != y_param.size()) {
    return false;
  }

  spline_func_x_ = PolynomialXd(x_param);
  spline_func_y_ = PolynomialXd(y_param);
  derivative_x_.DerivedFrom(spline_func_x_);
  derivative_y_.DerivedFrom(spline_func_y_);
  second_derivative_x_.DerivedFrom(derivative_x_);
  second_derivative_y_.DerivedFrom(derivative_y_);
  third_derivative_x_.DerivedFrom(second_derivative_x_);
  third_derivative_y_.DerivedFrom(second_derivative_y_);
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\planning_util.cc" startLine="(73, 0)" endLine="(100, 1)" clone_start="22" clone_end="27">
			<code function_name="InterpolateUsingLinearApproximation(const PathPoint &amp;p0,const PathPoint &amp;p1, const double s)">PathPoint InterpolateUsingLinearApproximation(const PathPoint &amp;p0,
                                              const PathPoint &amp;p1,
                                              const double s) {
  double s0 = p0.s();
  double s1 = p1.s();
  CHECK(s0 &lt; s1);

  PathPoint path_point;
  double weight = (s - s0) / (s1 - s0);
  double x = (1 - weight) * p0.x() + weight * p1.x();
  double y = (1 - weight) * p0.y() + weight * p1.y();
  double cos_heading =
      (1 - weight) * std::cos(p0.theta()) + weight * std::cos(p1.theta());
  double sin_heading =
      (1 - weight) * std::sin(p0.theta()) + weight * std::sin(p1.theta());
  double theta = std::atan2(sin_heading, cos_heading);
  double kappa = (1 - weight) * p0.kappa() + weight * p1.kappa();
  double dkappa = (1 - weight) * p0.dkappa() + weight * p1.dkappa();
  double ddkappa = (1 - weight) * p0.ddkappa() + weight * p1.ddkappa();
  path_point.set_x(x);
  path_point.set_y(y);
  path_point.set_theta(theta);
  path_point.set_kappa(kappa);
  path_point.set_dkappa(dkappa);
  path_point.set_ddkappa(ddkappa);
  path_point.set_s(s);
  return path_point;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\planning_util.cc" startLine="(35, 0)" endLine="(71, 1)" clone_start="31" clone_end="36">
			<code function_name="interpolate(const PathPoint &amp;p0, const PathPoint &amp;p1, const double s)">PathPoint interpolate(const PathPoint &amp;p0, const PathPoint &amp;p1,
                      const double s) {
  double s0 = p0.s();
  double s1 = p1.s();
  CHECK(s0 &lt;= s &amp;&amp; s &lt;= s1);

  std::array&lt;double, 2&gt; gx0{{p0.theta(), p0.kappa()}};
  std::array&lt;double, 2&gt; gx1{{p1.theta(), p1.kappa()}};
  HermiteSpline&lt;double, 3&gt; geometry_spline(gx0, gx1, s0, s1);
  auto func_cos_theta = [&amp;geometry_spline](const double s) {
    auto theta = geometry_spline.Evaluate(0, s);
    return std::cos(theta);
  };
  auto func_sin_theta = [&amp;geometry_spline](const double s) {
    auto theta = geometry_spline.Evaluate(0, s);
    return std::sin(theta);
  };

  double x =
      p0.x() + common::math::IntegrateByGaussLegendre(func_cos_theta, s0, s);
  double y =
      p0.y() + common::math::IntegrateByGaussLegendre(func_sin_theta, s0, s);
  double theta = geometry_spline.Evaluate(0, s);
  double kappa = geometry_spline.Evaluate(1, s);
  double dkappa = geometry_spline.Evaluate(2, s);
  double d2kappa = geometry_spline.Evaluate(3, s);

  PathPoint p;
  p.set_x(x);
  p.set_y(y);
  p.set_theta(theta);
  p.set_kappa(kappa);
  p.set_dkappa(dkappa);
  p.set_ddkappa(d2kappa);
  p.set_s(s);
  return p;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\util\util.cc" startLine="(67, 0)" endLine="(79, 1)" clone_start="7" clone_end="12">
			<code function_name="MakePathPoint(const double x, const double y, const double z,const double theta, const double kappa, const double dkappa, const double ddkappa)">PathPoint MakePathPoint(const double x, const double y, const double z,
                        const double theta, const double kappa,
                        const double dkappa, const double ddkappa) {
  PathPoint path_point;
  path_point.set_x(x);
  path_point.set_y(y);
  path_point.set_z(z);
  path_point.set_theta(theta);
  path_point.set_kappa(kappa);
  path_point.set_dkappa(dkappa);
  path_point.set_ddkappa(ddkappa);
  return path_point;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\util\util.cc" startLine="(56, 0)" endLine="(65, 1)" clone_start="4" clone_end="9">
			<code function_name="MakeSpeedPoint(const double s, const double t, const double v, const double a, const double da)">SpeedPoint MakeSpeedPoint(const double s, const double t, const double v,
                          const double a, const double da) {
  SpeedPoint speed_point;
  speed_point.set_s(s);
  speed_point.set_t(t);
  speed_point.set_v(v);
  speed_point.set_a(a);
  speed_point.set_da(da);
  return speed_point;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\constraint_checker\constraint_checker.h" startLine="(30, 2)" endLine="(30, 31)" clone_start="1" clone_end="1">
			<code function_name="ConstraintChecker()">  ConstraintChecker() = delete;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\path\path_data.h" startLine="(36, 2)" endLine="(36, 23)" clone_start="1" clone_end="1">
			<code function_name="PathData()">  PathData() = default;</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\tools\teleop.cc" startLine="(111, 2)" endLine="(253, 3)" clone_start="107" clone_end="114">
			<code function_name="KeyboardLoopThreadFunc()">  void KeyboardLoopThreadFunc() {
    char c = 0;
    int32_t level = 0;
    double brake = 0;
    double throttle = 0;
    double steering = 0;
    struct termios cooked_;
    struct termios raw_;
    int32_t kfd_ = 0;
    bool parking_brake = false;
    Chassis::GearPosition gear = Chassis::GEAR_INVALID;
    PadMessage pad_msg;
    ControlCommand &amp;control_command_ = control_command();

    // get the console in raw mode
    tcgetattr(kfd_, &amp;cooked_);
    std::memcpy(&amp;raw_, &amp;cooked_, sizeof(struct termios));
    raw_.c_lflag &amp;= ~(ICANON | ECHO);
    // Setting a new line, then end of file
    raw_.c_cc[VEOL] = 1;
    raw_.c_cc[VEOF] = 2;
    tcsetattr(kfd_, TCSANOW, &amp;raw_);
    puts("Teleop:\nReading from keyboard now.");
    puts("---------------------------");
    puts("Use arrow keys to drive the car.");
    while (IsRunning()) {
      // get the next event from the keyboard
      if (read(kfd_, &amp;c, 1) &lt; 0) {
        perror("read():");
        exit(-1);
      }

      switch (c) {
        case KEYCODE_UP1:  // accelerate
        case KEYCODE_UP2:
          brake = control_command_.brake();
          throttle = control_command_.throttle();
          if (brake &gt; 1e-6) {
            brake = GetCommand(brake, -FLAGS_brake_inc_delta);
            control_command_.set_brake(brake);
          } else {
            throttle = GetCommand(throttle, FLAGS_throttle_inc_delta);
            control_command_.set_throttle(throttle);
          }
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_DN1:  // decelerate
        case KEYCODE_DN2:
          brake = control_command_.brake();
          throttle = control_command_.throttle();
          if (throttle &gt; 1e-6) {
            throttle = GetCommand(throttle, -FLAGS_throttle_inc_delta);
            control_command_.set_throttle(throttle);
          } else {
            brake = GetCommand(brake, FLAGS_brake_inc_delta);
            control_command_.set_brake(brake);
          }
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_LF1:  // left
        case KEYCODE_LF2:
          steering = control_command_.steering_target();
          steering = GetCommand(steering, FLAGS_steer_inc_delta);
          control_command_.set_steering_target(steering);
          printf("Steering Target = %.2f\n", steering);
          break;
        case KEYCODE_RT1:  // right
        case KEYCODE_RT2:
          steering = control_command_.steering_target();
          steering = GetCommand(steering, -FLAGS_steer_inc_delta);
          control_command_.set_steering_target(steering);
          printf("Steering Target = %.2f\n", steering);
          break;
        case KEYCODE_PKBK:  // hand brake
          parking_brake = !control_command_.parking_brake();
          control_command_.set_parking_brake(parking_brake);
          printf("Parking Brake Toggled:%d\n", parking_brake);
          break;
        case KEYCODE_ESTOP:
          control_command_.set_brake(50.0);
          printf("Estop Brake:%.2f\n", control_command_.brake());
          break;
        case KEYCODE_SETT1:  // set throttle
        case KEYCODE_SETT2:
          // read keyboard again
          if (read(kfd_, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          control_command_.set_throttle(level * 10.0);
          control_command_.set_brake(0.0);
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_SETG1:
        case KEYCODE_SETG2:
          // read keyboard again
          if (read(kfd_, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          gear = GetGear(level);
          control_command_.set_gear_location(gear);
          printf("Gear set to %d.\n", level);
          break;
        case KEYCODE_SETB1:
        case KEYCODE_SETB2:
          // read keyboard again
          if (read(kfd_, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          control_command_.set_throttle(0.0);
          control_command_.set_brake(level * 10.0);
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_MODE:
          // read keyboard again
          if (read(kfd_, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          GetPadMessage(&amp;pad_msg, level);
          control_command_.mutable_pad_msg()-&gt;CopyFrom(pad_msg);
          sleep(1);
          control_command_.mutable_pad_msg()-&gt;Clear();
          break;
        case KEYCODE_HELP:
        case KEYCODE_HELP2:
          PrintKeycode();
          break;
        default:
          // printf("%X\n", c);
          break;
      }
    }  // keyboard_loop big while
    tcsetattr(kfd_, TCSANOW, &amp;cooked_);
    printf("keyboard_loop thread quited.\n");
    return;
  }  // end of keyboard loop thread</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\tools\teleop.cc" startLine="(111, 2)" endLine="(253, 3)" clone_start="96" clone_end="103">
			<code function_name="KeyboardLoopThreadFunc()">  void KeyboardLoopThreadFunc() {
    char c = 0;
    int32_t level = 0;
    double brake = 0;
    double throttle = 0;
    double steering = 0;
    struct termios cooked_;
    struct termios raw_;
    int32_t kfd_ = 0;
    bool parking_brake = false;
    Chassis::GearPosition gear = Chassis::GEAR_INVALID;
    PadMessage pad_msg;
    ControlCommand &amp;control_command_ = control_command();

    // get the console in raw mode
    tcgetattr(kfd_, &amp;cooked_);
    std::memcpy(&amp;raw_, &amp;cooked_, sizeof(struct termios));
    raw_.c_lflag &amp;= ~(ICANON | ECHO);
    // Setting a new line, then end of file
    raw_.c_cc[VEOL] = 1;
    raw_.c_cc[VEOF] = 2;
    tcsetattr(kfd_, TCSANOW, &amp;raw_);
    puts("Teleop:\nReading from keyboard now.");
    puts("---------------------------");
    puts("Use arrow keys to drive the car.");
    while (IsRunning()) {
      // get the next event from the keyboard
      if (read(kfd_, &amp;c, 1) &lt; 0) {
        perror("read():");
        exit(-1);
      }

      switch (c) {
        case KEYCODE_UP1:  // accelerate
        case KEYCODE_UP2:
          brake = control_command_.brake();
          throttle = control_command_.throttle();
          if (brake &gt; 1e-6) {
            brake = GetCommand(brake, -FLAGS_brake_inc_delta);
            control_command_.set_brake(brake);
          } else {
            throttle = GetCommand(throttle, FLAGS_throttle_inc_delta);
            control_command_.set_throttle(throttle);
          }
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_DN1:  // decelerate
        case KEYCODE_DN2:
          brake = control_command_.brake();
          throttle = control_command_.throttle();
          if (throttle &gt; 1e-6) {
            throttle = GetCommand(throttle, -FLAGS_throttle_inc_delta);
            control_command_.set_throttle(throttle);
          } else {
            brake = GetCommand(brake, FLAGS_brake_inc_delta);
            control_command_.set_brake(brake);
          }
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_LF1:  // left
        case KEYCODE_LF2:
          steering = control_command_.steering_target();
          steering = GetCommand(steering, FLAGS_steer_inc_delta);
          control_command_.set_steering_target(steering);
          printf("Steering Target = %.2f\n", steering);
          break;
        case KEYCODE_RT1:  // right
        case KEYCODE_RT2:
          steering = control_command_.steering_target();
          steering = GetCommand(steering, -FLAGS_steer_inc_delta);
          control_command_.set_steering_target(steering);
          printf("Steering Target = %.2f\n", steering);
          break;
        case KEYCODE_PKBK:  // hand brake
          parking_brake = !control_command_.parking_brake();
          control_command_.set_parking_brake(parking_brake);
          printf("Parking Brake Toggled:%d\n", parking_brake);
          break;
        case KEYCODE_ESTOP:
          control_command_.set_brake(50.0);
          printf("Estop Brake:%.2f\n", control_command_.brake());
          break;
        case KEYCODE_SETT1:  // set throttle
        case KEYCODE_SETT2:
          // read keyboard again
          if (read(kfd_, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          control_command_.set_throttle(level * 10.0);
          control_command_.set_brake(0.0);
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_SETG1:
        case KEYCODE_SETG2:
          // read keyboard again
          if (read(kfd_, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          gear = GetGear(level);
          control_command_.set_gear_location(gear);
          printf("Gear set to %d.\n", level);
          break;
        case KEYCODE_SETB1:
        case KEYCODE_SETB2:
          // read keyboard again
          if (read(kfd_, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          control_command_.set_throttle(0.0);
          control_command_.set_brake(level * 10.0);
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_MODE:
          // read keyboard again
          if (read(kfd_, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          GetPadMessage(&amp;pad_msg, level);
          control_command_.mutable_pad_msg()-&gt;CopyFrom(pad_msg);
          sleep(1);
          control_command_.mutable_pad_msg()-&gt;Clear();
          break;
        case KEYCODE_HELP:
        case KEYCODE_HELP2:
          PrintKeycode();
          break;
        default:
          // printf("%X\n", c);
          break;
      }
    }  // keyboard_loop big while
    tcsetattr(kfd_, TCSANOW, &amp;cooked_);
    printf("keyboard_loop thread quited.\n");
    return;
  }  // end of keyboard loop thread</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\tools\teleop.cc" startLine="(111, 2)" endLine="(253, 3)" clone_start="84" clone_end="91">
			<code function_name="KeyboardLoopThreadFunc()">  void KeyboardLoopThreadFunc() {
    char c = 0;
    int32_t level = 0;
    double brake = 0;
    double throttle = 0;
    double steering = 0;
    struct termios cooked_;
    struct termios raw_;
    int32_t kfd_ = 0;
    bool parking_brake = false;
    Chassis::GearPosition gear = Chassis::GEAR_INVALID;
    PadMessage pad_msg;
    ControlCommand &amp;control_command_ = control_command();

    // get the console in raw mode
    tcgetattr(kfd_, &amp;cooked_);
    std::memcpy(&amp;raw_, &amp;cooked_, sizeof(struct termios));
    raw_.c_lflag &amp;= ~(ICANON | ECHO);
    // Setting a new line, then end of file
    raw_.c_cc[VEOL] = 1;
    raw_.c_cc[VEOF] = 2;
    tcsetattr(kfd_, TCSANOW, &amp;raw_);
    puts("Teleop:\nReading from keyboard now.");
    puts("---------------------------");
    puts("Use arrow keys to drive the car.");
    while (IsRunning()) {
      // get the next event from the keyboard
      if (read(kfd_, &amp;c, 1) &lt; 0) {
        perror("read():");
        exit(-1);
      }

      switch (c) {
        case KEYCODE_UP1:  // accelerate
        case KEYCODE_UP2:
          brake = control_command_.brake();
          throttle = control_command_.throttle();
          if (brake &gt; 1e-6) {
            brake = GetCommand(brake, -FLAGS_brake_inc_delta);
            control_command_.set_brake(brake);
          } else {
            throttle = GetCommand(throttle, FLAGS_throttle_inc_delta);
            control_command_.set_throttle(throttle);
          }
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_DN1:  // decelerate
        case KEYCODE_DN2:
          brake = control_command_.brake();
          throttle = control_command_.throttle();
          if (throttle &gt; 1e-6) {
            throttle = GetCommand(throttle, -FLAGS_throttle_inc_delta);
            control_command_.set_throttle(throttle);
          } else {
            brake = GetCommand(brake, FLAGS_brake_inc_delta);
            control_command_.set_brake(brake);
          }
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_LF1:  // left
        case KEYCODE_LF2:
          steering = control_command_.steering_target();
          steering = GetCommand(steering, FLAGS_steer_inc_delta);
          control_command_.set_steering_target(steering);
          printf("Steering Target = %.2f\n", steering);
          break;
        case KEYCODE_RT1:  // right
        case KEYCODE_RT2:
          steering = control_command_.steering_target();
          steering = GetCommand(steering, -FLAGS_steer_inc_delta);
          control_command_.set_steering_target(steering);
          printf("Steering Target = %.2f\n", steering);
          break;
        case KEYCODE_PKBK:  // hand brake
          parking_brake = !control_command_.parking_brake();
          control_command_.set_parking_brake(parking_brake);
          printf("Parking Brake Toggled:%d\n", parking_brake);
          break;
        case KEYCODE_ESTOP:
          control_command_.set_brake(50.0);
          printf("Estop Brake:%.2f\n", control_command_.brake());
          break;
        case KEYCODE_SETT1:  // set throttle
        case KEYCODE_SETT2:
          // read keyboard again
          if (read(kfd_, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          control_command_.set_throttle(level * 10.0);
          control_command_.set_brake(0.0);
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_SETG1:
        case KEYCODE_SETG2:
          // read keyboard again
          if (read(kfd_, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          gear = GetGear(level);
          control_command_.set_gear_location(gear);
          printf("Gear set to %d.\n", level);
          break;
        case KEYCODE_SETB1:
        case KEYCODE_SETB2:
          // read keyboard again
          if (read(kfd_, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          control_command_.set_throttle(0.0);
          control_command_.set_brake(level * 10.0);
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_MODE:
          // read keyboard again
          if (read(kfd_, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          GetPadMessage(&amp;pad_msg, level);
          control_command_.mutable_pad_msg()-&gt;CopyFrom(pad_msg);
          sleep(1);
          control_command_.mutable_pad_msg()-&gt;Clear();
          break;
        case KEYCODE_HELP:
        case KEYCODE_HELP2:
          PrintKeycode();
          break;
        default:
          // printf("%X\n", c);
          break;
      }
    }  // keyboard_loop big while
    tcsetattr(kfd_, TCSANOW, &amp;cooked_);
    printf("keyboard_loop thread quited.\n");
    return;
  }  // end of keyboard loop thread</code>
		</source>
	</dup>
	<dup count="5">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(157, 2)" endLine="(157, 35)" clone_start="1" clone_end="1">
			<code function_name="DummyTracker()">  DummyTracker() : BaseTracker() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(108, 2)" endLine="(108, 47)" clone_start="1" clone_end="1">
			<code function_name="DummyObjectBuilder()">  DummyObjectBuilder() : BaseObjectBuilder() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(83, 2)" endLine="(83, 45)" clone_start="1" clone_end="1">
			<code function_name="DummySegmentation()">  DummySegmentation() : BaseSegmentation() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(58, 2)" endLine="(58, 49)" clone_start="1" clone_end="1">
			<code function_name="DummyGroundDetector()">  DummyGroundDetector() : BaseGroundDetector() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(33, 2)" endLine="(33, 39)" clone_start="1" clone_end="1">
			<code function_name="DummyROIFilter()">  DummyROIFilter() : BaseROIFilter() {}</code>
		</source>
	</dup>
	<dup count="5">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(158, 2)" endLine="(158, 28)" clone_start="1" clone_end="1">
			<code function_name="~DummyTracker()">  ~DummyTracker() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(109, 2)" endLine="(109, 34)" clone_start="1" clone_end="1">
			<code function_name="~DummyObjectBuilder()">  ~DummyObjectBuilder() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(84, 2)" endLine="(84, 33)" clone_start="1" clone_end="1">
			<code function_name="~DummySegmentation()">  ~DummySegmentation() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(59, 2)" endLine="(59, 35)" clone_start="1" clone_end="1">
			<code function_name="~DummyGroundDetector()">  ~DummyGroundDetector() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(34, 2)" endLine="(34, 30)" clone_start="1" clone_end="1">
			<code function_name="~DummyROIFilter()">  ~DummyROIFilter() = default;</code>
		</source>
	</dup>
	<dup count="5">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(160, 2)" endLine="(162, 3)" clone_start="1" clone_end="2">
			<code function_name="Init() override">  bool Init() override {
    return result_init_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(111, 2)" endLine="(113, 3)" clone_start="1" clone_end="2">
			<code function_name="Init() override">  bool Init() override {
    return result_init_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(86, 2)" endLine="(88, 3)" clone_start="1" clone_end="2">
			<code function_name="Init() override">  bool Init() override {
    return result_init_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(61, 2)" endLine="(63, 3)" clone_start="1" clone_end="2">
			<code function_name="Init() override">  bool Init() override {
    return result_init_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(36, 2)" endLine="(38, 3)" clone_start="1" clone_end="2">
			<code function_name="Init() override">  bool Init() override {
    return result_init_;
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\controller\lat_controller.cc" startLine="(435, 0)" endLine="(473, 1)" clone_start="16" clone_end="23">
			<code function_name="LatController::UpdateStateAnalyticalMatching(SimpleLateralDebug *debug)">void LatController::UpdateStateAnalyticalMatching(SimpleLateralDebug *debug) {
  const auto &amp;com = VehicleState::instance()-&gt;ComputeCOMPosition(lr_);
  ComputeLateralErrors(com.x(), com.y(), VehicleState::instance()-&gt;heading(),
                       VehicleState::instance()-&gt;linear_velocity(),
                       VehicleState::instance()-&gt;angular_velocity(),
                       trajectory_analyzer_, debug);

  // Reverse heading error if vehicle is going in reverse
  if (VehicleState::instance()-&gt;gear() ==
      canbus::Chassis::GEAR_REVERSE) {
    debug-&gt;set_heading_error(-debug-&gt;heading_error());
  }

  // State matrix update;
  // First four elements are fixed;
  matrix_state_(0, 0) = debug-&gt;lateral_error();
  matrix_state_(1, 0) = debug-&gt;lateral_error_rate();
  matrix_state_(2, 0) = debug-&gt;heading_error();
  matrix_state_(3, 0) = debug-&gt;heading_error_rate();

  // Next elements are depending on preview window size;
  for (int i = 0; i &lt; preview_window_; ++i) {
    double preview_time = ts_ * (i + 1);
    auto preview_point =
        trajectory_analyzer_.QueryNearestPointByRelativeTime(preview_time);

    auto matched_point = trajectory_analyzer_.QueryNearestPointByPosition(
        preview_point.path_point().x(), preview_point.path_point().y());

    double dx = preview_point.path_point().x() - matched_point.path_point().x();
    double dy = preview_point.path_point().y() - matched_point.path_point().y();

    double cos_matched_theta = std::cos(matched_point.path_point().theta());
    double sin_matched_theta = std::sin(matched_point.path_point().theta());
    double preview_d_error = cos_matched_theta * dy - sin_matched_theta * dx;

    matrix_state_(basic_state_size_ + i, 0) = preview_d_error;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\controller\lat_controller.cc" startLine="(380, 0)" endLine="(433, 1)" clone_start="40" clone_end="47">
			<code function_name="LatController::UpdateState(SimpleLateralDebug *debug)">void LatController::UpdateState(SimpleLateralDebug *debug) {
  TrajectoryPoint traj_point;
  const auto &amp;position = VehicleState::instance()-&gt;ComputeCOMPosition(lr_);
  double raw_lateral_error = GetLateralError(position, &amp;traj_point);

  // lateral_error_ = lateral_rate_filter_.Filter(raw_lateral_error);
  debug-&gt;set_lateral_error(lateral_error_filter_.Update(raw_lateral_error));

  // ref_curvature_ = traj_point.kappa();
  debug-&gt;set_curvature(traj_point.path_point().kappa());

  // ref_heading_ = traj_point.theta;
  debug-&gt;set_ref_heading(traj_point.path_point().theta());

  // heading_error_ =
  //    common::math::NormalizeAngle(VehicleState::instance()-&gt;heading() -
  //    ref_heading_);
  debug-&gt;set_heading_error(common::math::NormalizeAngle(
      VehicleState::instance()-&gt;heading() - traj_point.path_point().theta()));

  // Reverse heading error if vehicle is going in reverse
  if (VehicleState::instance()-&gt;gear() ==
      canbus::Chassis::GEAR_REVERSE) {
    debug-&gt;set_heading_error(-debug-&gt;heading_error());
  }

  // heading_error_rate_ = (heading_error_ - previous_heading_error_) / ts_;
  debug-&gt;set_heading_error_rate(
      (debug-&gt;heading_error() - previous_heading_error_) / ts_);
  // lateral_error_rate_ = (lateral_error_ - previous_lateral_error_) / ts_;
  debug-&gt;set_lateral_error_rate(
      (debug-&gt;lateral_error() - previous_lateral_error_) / ts_);

  // Prepare for next iteration.
  previous_heading_error_ = debug-&gt;heading_error();
  previous_lateral_error_ = debug-&gt;lateral_error();

  // State matrix update;
  // First four elements are fixed;
  matrix_state_(0, 0) = debug-&gt;lateral_error();
  matrix_state_(1, 0) = debug-&gt;lateral_error_rate();
  matrix_state_(2, 0) = debug-&gt;heading_error();
  matrix_state_(3, 0) = debug-&gt;heading_error_rate();

  // Next elements are depending on preview window size;
  for (int i = 0; i &lt; preview_window_; ++i) {
    double preview_time = ts_ * (i + 1);
    const auto &amp;future_position_estimate =
        VehicleState::instance()-&gt;EstimateFuturePosition(preview_time);
    double preview_lateral = GetLateralError(future_position_estimate, nullptr);
    matrix_state_(basic_state_size_ + i, 0) = preview_lateral;
  }
  // preview matrix update;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\aaboxkdtree2d.h" startLine="(259, 2)" endLine="(323, 3)" clone_start="54" clone_end="61">
			<code function_name="GetNearestObjectInternal(const Vec2d &amp;point,double *const min_distance_sqr, ObjectPtr *const nearest_object) const">  void GetNearestObjectInternal(const Vec2d &amp;point,
                                double *const min_distance_sqr,
                                ObjectPtr *const nearest_object) const {
    if (LowerDistanceSquareToPoint(point) &gt;= *min_distance_sqr - kMathEpsilon) {
      return;
    }
    const double pvalue = (partition_ == PARTITION_X ? point.x() : point.y());
    const bool search_left_first = (pvalue &lt; partition_position_);
    if (search_left_first) {
      if (left_subnode_ != nullptr) {
        left_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                nearest_object);
      }
    } else {
      if (right_subnode_ != nullptr) {
        right_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                 nearest_object);
      }
    }
    if (*min_distance_sqr &lt;= kMathEpsilon) {
      return;
    }

    if (search_left_first) {
      for (int i = 0; i &lt; num_objects_; ++i) {
        const double bound = objects_sorted_by_min_bound_[i];
        if (bound &gt; pvalue &amp;&amp; Square(bound - pvalue) &gt; *min_distance_sqr) {
          break;
        }
        ObjectPtr object = objects_sorted_by_min_[i];
        const double distance_sqr = object-&gt;DistanceSquareTo(point);
        if (distance_sqr &lt; *min_distance_sqr) {
          *min_distance_sqr = distance_sqr;
          *nearest_object = object;
        }
      }
    } else {
      for (int i = 0; i &lt; num_objects_; ++i) {
        const double bound = objects_sorted_by_max_bound_[i];
        if (bound &lt; pvalue &amp;&amp; Square(bound - pvalue) &gt; *min_distance_sqr) {
          break;
        }
        ObjectPtr object = objects_sorted_by_max_[i];
        const double distance_sqr = object-&gt;DistanceSquareTo(point);
        if (distance_sqr &lt; *min_distance_sqr) {
          *min_distance_sqr = distance_sqr;
          *nearest_object = object;
        }
      }
    }
    if (*min_distance_sqr &lt;= kMathEpsilon) {
      return;
    }
    if (search_left_first) {
      if (right_subnode_ != nullptr) {
        right_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                 nearest_object);
      }
    } else {
      if (left_subnode_ != nullptr) {
        left_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                nearest_object);
      }
    }
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\aaboxkdtree2d.h" startLine="(259, 2)" endLine="(323, 3)" clone_start="9" clone_end="16">
			<code function_name="GetNearestObjectInternal(const Vec2d &amp;point,double *const min_distance_sqr, ObjectPtr *const nearest_object) const">  void GetNearestObjectInternal(const Vec2d &amp;point,
                                double *const min_distance_sqr,
                                ObjectPtr *const nearest_object) const {
    if (LowerDistanceSquareToPoint(point) &gt;= *min_distance_sqr - kMathEpsilon) {
      return;
    }
    const double pvalue = (partition_ == PARTITION_X ? point.x() : point.y());
    const bool search_left_first = (pvalue &lt; partition_position_);
    if (search_left_first) {
      if (left_subnode_ != nullptr) {
        left_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                nearest_object);
      }
    } else {
      if (right_subnode_ != nullptr) {
        right_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                 nearest_object);
      }
    }
    if (*min_distance_sqr &lt;= kMathEpsilon) {
      return;
    }

    if (search_left_first) {
      for (int i = 0; i &lt; num_objects_; ++i) {
        const double bound = objects_sorted_by_min_bound_[i];
        if (bound &gt; pvalue &amp;&amp; Square(bound - pvalue) &gt; *min_distance_sqr) {
          break;
        }
        ObjectPtr object = objects_sorted_by_min_[i];
        const double distance_sqr = object-&gt;DistanceSquareTo(point);
        if (distance_sqr &lt; *min_distance_sqr) {
          *min_distance_sqr = distance_sqr;
          *nearest_object = object;
        }
      }
    } else {
      for (int i = 0; i &lt; num_objects_; ++i) {
        const double bound = objects_sorted_by_max_bound_[i];
        if (bound &lt; pvalue &amp;&amp; Square(bound - pvalue) &gt; *min_distance_sqr) {
          break;
        }
        ObjectPtr object = objects_sorted_by_max_[i];
        const double distance_sqr = object-&gt;DistanceSquareTo(point);
        if (distance_sqr &lt; *min_distance_sqr) {
          *min_distance_sqr = distance_sqr;
          *nearest_object = object;
        }
      }
    }
    if (*min_distance_sqr &lt;= kMathEpsilon) {
      return;
    }
    if (search_left_first) {
      if (right_subnode_ != nullptr) {
        right_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                 nearest_object);
      }
    } else {
      if (left_subnode_ != nullptr) {
        left_subnode_-&gt;GetNearestObjectInternal(point, min_distance_sqr,
                                                nearest_object);
      }
    }
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\can_comm\can_sender.cc" startLine="(137, 0)" endLine="(150, 1)" clone_start="3" clone_end="10">
			<code function_name="CanSender::Init(CanClient *can_client, bool enable_log)">ErrorCode CanSender::Init(CanClient *can_client, bool enable_log) {
  if (is_init_) {
    AERROR &lt;&lt; "Duplicated Init request.";
    return ErrorCode::CANBUS_ERROR;
  }
  if (can_client == nullptr) {
    AERROR &lt;&lt; "Invalid can client.";
    return ErrorCode::CANBUS_ERROR;
  }
  is_init_ = true;
  can_client_ = can_client;
  enable_log_ = enable_log;
  return ErrorCode::OK;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\can_comm\can_receiver.cc" startLine="(31, 0)" endLine="(46, 1)" clone_start="7" clone_end="14">
			<code function_name="CanReceiver::Init(CanClient *can_client, MessageManager *pt_manager, bool enable_log)">ErrorCode CanReceiver::Init(CanClient *can_client, MessageManager *pt_manager,
                            bool enable_log) {
  can_client_ = can_client;
  pt_manager_ = pt_manager;
  enable_log_ = enable_log;
  if (can_client_ == nullptr) {
    AERROR &lt;&lt; "Invalid can client.";
    return ErrorCode::CANBUS_ERROR;
  }
  if (pt_manager_ == nullptr) {
    AERROR &lt;&lt; "Invalid protocol manager.";
    return ErrorCode::CANBUS_ERROR;
  }
  is_init_ = true;
  return ErrorCode::OK;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\vehicle\free_move_predictor.cc" startLine="(36, 0)" endLine="(72, 1)" clone_start="18" clone_end="23">
			<code function_name="FreeMovePredictor::Predict(Obstacle* obstacle)">void FreeMovePredictor::Predict(Obstacle* obstacle) {
  trajectories_.clear();
  CHECK_NOTNULL(obstacle);
  CHECK_GT(obstacle-&gt;history_size(), 0);

  const Feature&amp; feature = obstacle-&gt;latest_feature();
  if (!feature.has_position() || !feature.has_velocity() ||
      !feature.position().has_x() || !feature.position().has_y()) {
    AERROR &lt;&lt; "Obstacle [" &lt;&lt; obstacle-&gt;id()
           &lt;&lt; " is missing position or velocity";
    return;
  }

  Eigen::Vector2d position(feature.position().x(), feature.position().y());
  Eigen::Vector2d velocity(feature.velocity().x(), feature.velocity().y());
  Eigen::Vector2d acc(feature.acceleration().x(), feature.acceleration().y());
  if (FLAGS_enable_kf_tracking) {
    position(0) = feature.t_position().x();
    position(1) = feature.t_position().y();
    velocity(0) = feature.t_velocity().x();
    velocity(1) = feature.t_velocity().y();
    acc(0) = feature.t_acceleration().x();
    acc(1) = feature.t_acceleration().y();
  }

  std::vector&lt;TrajectoryPoint&gt; points(0);
  DrawFreeMoveTrajectoryPoints(
      position, velocity, acc, obstacle-&gt;kf_motion_tracker(),
      FLAGS_prediction_duration, FLAGS_prediction_freq, &amp;points);

  Trajectory trajectory = GenerateTrajectory(points);
  int start_index = 0;
  trajectories_.push_back(std::move(trajectory));
  SetEqualProbability(1.0, start_index);
  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; obstacle-&gt;id() &lt;&lt; "] has " &lt;&lt; trajectories_.size()
         &lt;&lt; " trajectories.";
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\base\object.cc" startLine="(103, 0)" endLine="(134, 1)" clone_start="5" clone_end="11">
			<code function_name="Object::Deserialize(const PerceptionObstacle&amp; pb_obs)">bool Object::Deserialize(const PerceptionObstacle&amp; pb_obs) {
  track_id = pb_obs.id();
  theta = pb_obs.theta();

  center(0) = pb_obs.position().x();
  center(1) = pb_obs.position().y();
  center(2) = pb_obs.position().z();

  velocity(0) = pb_obs.velocity().x();
  velocity(1) = pb_obs.velocity().y();
  velocity(2) = pb_obs.velocity().z();

  length = pb_obs.length();
  width = pb_obs.width();
  height = pb_obs.height();

  polygon.clear();
  for (int idx = 0; idx &lt; pb_obs.polygon_point_size(); ++idx) {
    const auto&amp; p = pb_obs.polygon_point(idx);
    pcl_util::PointD point;
    point.x = p.x();
    point.y = p.y();
    point.z = p.z();
    polygon.push_back(point);
  }

  tracking_time = pb_obs.tracking_time();
  latest_tracked_time = pb_obs.timestamp();
  type = static_cast&lt;ObjectType&gt;(pb_obs.type());

  return true;
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(216, 0)" endLine="(259, 1)" clone_start="1" clone_end="9">
			<code function_name="SignalsXmlParser::ParseYieldSigns(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;YieldSignInternal&gt;* yield_signs)">Status SignalsXmlParser::ParseYieldSigns(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;YieldSignInternal&gt;* yield_signs) {
  CHECK_NOTNULL(yield_signs);

  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "yieldSign") {
      PbYieldSign yield_sign;
      yield_sign.mutable_id()-&gt;set_id(object_id);
      YieldSignInternal yield_sign_internal;
      yield_sign_internal.id = object_id;
      yield_sign_internal.yield_sign = yield_sign;
      auto sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                            &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          yield_sign_internal.stop_line_ids.insert(stop_line_id);

          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      yield_signs-&gt;emplace_back(yield_sign_internal);
    }

    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(171, 0)" endLine="(214, 1)" clone_start="1" clone_end="9">
			<code function_name="SignalsXmlParser::ParseStopSigns(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;StopSignInternal&gt;* stop_signs)">Status SignalsXmlParser::ParseStopSigns(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;StopSignInternal&gt;* stop_signs) {
  CHECK_NOTNULL(stop_signs);

  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "stopSign") {
      PbStopSign stop_sign;
      stop_sign.mutable_id()-&gt;set_id(object_id);

      StopSignInternal stop_sign_internal;
      stop_sign_internal.stop_sign = stop_sign;

      auto sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          stop_sign_internal.stop_line_ids.insert(stop_line_id);

          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      stop_signs-&gt;emplace_back(stop_sign_internal);
    }

    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(26, 0)" endLine="(114, 1)" clone_start="1" clone_end="8">
			<code function_name="SignalsXmlParser::ParseTrafficLights(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;TrafficLightInternal&gt;* traffic_lights)">Status SignalsXmlParser::ParseTrafficLights(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;TrafficLightInternal&gt;* traffic_lights) {
  CHECK_NOTNULL(traffic_lights);
  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "trafficLight") {
      PbSignal traffic_light;
      traffic_light.mutable_id()-&gt;set_id(object_id);
      std::string layout_type;
      int checker = UtilXmlParser::QueryStringAttribute(
          *signal_node, "layoutType", &amp;layout_type);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse signal layout type.";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      PbSignalType signal_layout_type;
      ToPbSignalType(layout_type, &amp;signal_layout_type);
      traffic_light.set_type(signal_layout_type);

      PbPolygon* polygon = traffic_light.mutable_boundary();
      auto outline_node = signal_node-&gt;FirstChildElement("outline");
      if (outline_node == nullptr) {
        std::string err_msg = "Error parse signal outline";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseOutline(*outline_node, polygon));
      auto sub_node = signal_node-&gt;FirstChildElement("subSignal");
      if (sub_node == nullptr) {
        std::string err_msg = "Error parse sub signal.";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      while (sub_node) {
        std::string sub_signal_id;
        std::string sub_signal_xml_type;
        checker = UtilXmlParser::QueryStringAttribute(*sub_node, "type",
                                                      &amp;sub_signal_xml_type);
        checker += UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                       &amp;sub_signal_id);
        if (checker != tinyxml2::XML_SUCCESS) {
          std::string err_msg = "Error parse sub signal layout type.";
          return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
        }

        PbSubSignal* sub_signal = traffic_light.add_subsignal();
        PbSubSignalType sub_signal_type;
        ToPbSubSignalType(sub_signal_xml_type, &amp;sub_signal_type);
        sub_signal-&gt;mutable_id()-&gt;set_id(sub_signal_id);
        sub_signal-&gt;set_type(sub_signal_type);
        PbPoint3D* pt = sub_signal-&gt;mutable_location();
        RETURN_IF_ERROR(UtilXmlParser::ParsePoint(*sub_node, pt));

        sub_node = sub_node-&gt;NextSiblingElement("subSignal");
      }

      TrafficLightInternal trafficlight_internal;
      trafficlight_internal.id = object_id;
      trafficlight_internal.traffic_light = traffic_light;

      sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                            &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          trafficlight_internal.stop_line_ids.insert(stop_line_id);
          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      traffic_lights-&gt;emplace_back(trafficlight_internal);
    }
    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\roads_xml_parser.cc" startLine="(34, 0)" endLine="(90, 1)" clone_start="1" clone_end="9">
			<code function_name="RoadsXmlParser::Parse(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;RoadInternal&gt;* roads)">Status RoadsXmlParser::Parse(const tinyxml2::XMLElement&amp; xml_node,
                             std::vector&lt;RoadInternal&gt;* roads) {
  CHECK_NOTNULL(roads);

  auto road_node = xml_node.FirstChildElement("road");
  while (road_node) {
    // road attributes
    std::string id;
    std::string junction_id;
    int checker = UtilXmlParser::QueryStringAttribute(*road_node, "id", &amp;id);
    checker += UtilXmlParser::QueryStringAttribute(*road_node, "junction",
                                                   &amp;junction_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parsing road attributes";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }
    RoadInternal road_internal;
    road_internal.id = id;
    road_internal.road.mutable_id()-&gt;set_id(id);
    if (IsRoadBelongToJunction(junction_id)) {
      road_internal.road.mutable_junction_id()-&gt;set_id(junction_id);
    }
    // lanes
    RETURN_IF_ERROR(LanesXmlParser::Parse(*road_node, road_internal.id,
                                          &amp;road_internal.sections));

    // objects
    auto sub_node = road_node-&gt;FirstChildElement("objects");
    if (sub_node != nullptr) {
      // stop line
      ObjectsXmlParser::ParseStopLines(*sub_node, &amp;road_internal.stop_lines);
      // crosswalks
      ObjectsXmlParser::ParseCrosswalks(*sub_node, &amp;road_internal.crosswalks);
      // clearareas
      ObjectsXmlParser::ParseClearAreas(*sub_node, &amp;road_internal.clear_areas);
      // speed_bumps
      ObjectsXmlParser::ParseSpeedBumps(*sub_node, &amp;road_internal.speed_bumps);
    }

    // signals
    sub_node = road_node-&gt;FirstChildElement("signals");
    if (sub_node != nullptr) {
      // traffic lights
      SignalsXmlParser::ParseTrafficLights(*sub_node,
                                           &amp;road_internal.traffic_lights);
      // stop signs
      SignalsXmlParser::ParseStopSigns(*sub_node, &amp;road_internal.stop_signs);
      // yield signs
      SignalsXmlParser::ParseYieldSigns(*sub_node, &amp;road_internal.yield_signs);
    }

    roads-&gt;push_back(road_internal);
    road_node = road_node-&gt;NextSiblingElement("road");
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\coordinate_convert_tool.cc" startLine="(42, 0)" endLine="(69, 1)" clone_start="5" clone_end="12">
			<code function_name="CoordinateConvertTool::SetConvertParam(const std::string &amp;source_param, const std::string &amp;dst_param)">Status CoordinateConvertTool::SetConvertParam(const std::string &amp;source_param,
                                             const std::string &amp;dst_param) {
  source_convert_param_ = source_param;
  dst_convert_param_ = dst_param;
  if (pj_from_) {
      pj_free(pj_from_);
      pj_from_ = NULL;
  }

  if (pj_to_) {
    pj_free(pj_to_);
    pj_to_ = NULL;
  }

  if (!(pj_from_ = pj_init_plus(source_convert_param_.c_str()))) {
    std::string err_msg = "Fail to pj_init_plus " + source_convert_param_;
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  if (!(pj_to_ = pj_init_plus(dst_convert_param_.c_str()))) {
    std::string err_msg = "Fail to pj_init_plus " + dst_convert_param_;
    pj_free(pj_from_);
    pj_from_ = NULL;
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\coordinate_convert_tool.cc" startLine="(25, 0)" endLine="(35, 1)" clone_start="2" clone_end="9">
			<code function_name="CoordinateConvertTool::~CoordinateConvertTool()">CoordinateConvertTool::~CoordinateConvertTool() {
  if (pj_from_) {
    pj_free(pj_from_);
    pj_from_ = NULL;
  }

  if (pj_to_) {
    pj_free(pj_to_);
    pj_to_ = NULL;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(340, 0)" endLine="(350, 1)" clone_start="5" clone_end="11">
			<code function_name="HmObjectTracker::SetCollectAgeMinimum( const int&amp; collect_age_minimum)">bool HmObjectTracker::SetCollectAgeMinimum(
  const int&amp; collect_age_minimum) {
  if (collect_age_minimum &gt;= 0) {
    collect_age_minimum_ = collect_age_minimum;
    AINFO &lt;&lt; "collect age minimum of " &lt;&lt; name() &lt;&lt; " is "
          &lt;&lt; collect_age_minimum_;
    return true;
  }
  AERROR &lt;&lt; "invalid collect age minimum of " &lt;&lt; name();
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(327, 0)" endLine="(338, 1)" clone_start="6" clone_end="12">
			<code function_name="HmObjectTracker::SetCollectConsecutiveInvisibleMaximum( const int&amp; collect_consecutive_invisible_maximum)">bool HmObjectTracker::SetCollectConsecutiveInvisibleMaximum(
  const int&amp; collect_consecutive_invisible_maximum) {
  if (collect_consecutive_invisible_maximum &gt;= 0) {
    collect_consecutive_invisible_maximum_ =
      collect_consecutive_invisible_maximum;
    AINFO &lt;&lt; "collect consecutive invisible maximum of " &lt;&lt; name() &lt;&lt; " is "
           &lt;&lt; collect_consecutive_invisible_maximum_;
    return true;
  }
  AERROR &lt;&lt; "invalid collect consecutive invisible maximum of " &lt;&lt; name();
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(352, 0)" endLine="(362, 1)" clone_start="1" clone_end="1">
			<code function_name="HmObjectTracker::SetHistogramBinSize( const int&amp; histogram_bin_size)">bool HmObjectTracker::SetHistogramBinSize(
  const int&amp; histogram_bin_size) {
  if (histogram_bin_size &gt; 0) {
    histogram_bin_size_ = histogram_bin_size;
    AINFO &lt;&lt; "histogram bin size of " &lt;&lt; name() &lt;&lt; " is "
          &lt;&lt; histogram_bin_size_;
    return true;
  }
  AERROR &lt;&lt; "invalid histogram bin size of " &lt;&lt; name();
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(340, 0)" endLine="(350, 1)" clone_start="1" clone_end="1">
			<code function_name="HmObjectTracker::SetCollectAgeMinimum( const int&amp; collect_age_minimum)">bool HmObjectTracker::SetCollectAgeMinimum(
  const int&amp; collect_age_minimum) {
  if (collect_age_minimum &gt;= 0) {
    collect_age_minimum_ = collect_age_minimum;
    AINFO &lt;&lt; "collect age minimum of " &lt;&lt; name() &lt;&lt; " is "
          &lt;&lt; collect_age_minimum_;
    return true;
  }
  AERROR &lt;&lt; "invalid collect age minimum of " &lt;&lt; name();
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_kernel.cc" startLine="(123, 0)" endLine="(166, 1)" clone_start="1" clone_end="10">
			<code function_name="Spline2dKernel::AddReferenceLineKernelMatrix(const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;Vec2d&gt;&amp; ref_points, const double weight)">bool Spline2dKernel::AddReferenceLineKernelMatrix(
    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;Vec2d&gt;&amp; ref_points,
    const double weight) {
  if (ref_points.size() != t_coord.size()) {
    return false;
  }

  for (std::uint32_t i = 0; i &lt; t_coord.size(); ++i) {
    double cur_index = find_index(t_coord[i]);
    double cur_rel_t = t_coord[i] - t_knots_[cur_index];
    // update offset
    double offset_coef_x = -ref_points[i].x() * weight;
    double offset_coef_y = -ref_points[i].y() * weight;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      offset_(j + (2 * cur_index) * spline_order_, 0) = offset_coef_x;
      offset_(j + (2 * cur_index + 1) * spline_order_, 0) = offset_coef_y;
      offset_coef_x *= cur_rel_t;
      offset_coef_y *= cur_rel_t;
    }

    // update kernel matrix
    Eigen::MatrixXd ref_kernel(spline_order_, spline_order_);

    double cur_t = 1.0;
    std::vector&lt;double&gt; power_t;
    for (std::uint32_t n = 0; n + 1 &lt; 2 * spline_order_; ++n) {
      power_t.emplace_back(cur_t);
      cur_t *= cur_rel_t;
    }

    for (std::uint32_t r = 0; r &lt; spline_order_; ++r) {
      for (std::uint32_t c = 0; c &lt; spline_order_; ++c) {
        ref_kernel(r, c) = power_t[r + c];
      }
    }
    kernel_matrix_.block((2 * cur_index) * spline_order_,
                         (2 * cur_index) * spline_order_, spline_order_,
                         spline_order_) += weight * ref_kernel;
    kernel_matrix_.block((2 * cur_index + 1) * spline_order_,
                         (2 * cur_index + 1) * spline_order_, spline_order_,
                         spline_order_) += weight * ref_kernel;
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_kernel.cc" startLine="(119, 0)" endLine="(155, 1)" clone_start="1" clone_end="10">
			<code function_name="Spline1dKernel::AddReferenceLineKernelMatrix(const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; ref_x, const double weight)">bool Spline1dKernel::AddReferenceLineKernelMatrix(
    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; ref_x,
    const double weight) {
  if (ref_x.size() != x_coord.size()) {
    return false;
  }

  for (std::uint32_t i = 0; i &lt; x_coord.size(); ++i) {
    double cur_index = find_index(x_coord[i]);
    double cur_rel_x = x_coord[i] - x_knots_[cur_index];
    // update offset
    double offset_coef = -2.0 * ref_x[i] * weight;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      offset_(j + cur_index * spline_order_, 0) += offset_coef;
      offset_coef *= cur_rel_x;
    }
    // update kernel matrix
    Eigen::MatrixXd ref_kernel(spline_order_, spline_order_);

    double cur_x = 1.0;
    std::vector&lt;double&gt; power_x;
    for (std::uint32_t n = 0; n + 1 &lt; 2 * spline_order_; ++n) {
      power_x.emplace_back(cur_x);
      cur_x *= cur_rel_x;
    }

    for (std::uint32_t r = 0; r &lt; spline_order_; ++r) {
      for (std::uint32_t c = 0; c &lt; spline_order_; ++c) {
        ref_kernel(r, c) = power_x[r + c];
      }
    }

    kernel_matrix_.block(cur_index * spline_order_, cur_index * spline_order_,
                         spline_order_, spline_order_) += weight * ref_kernel;
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\topo_creator\graph_creator.cc" startLine="(56, 0)" endLine="(151, 1)" clone_start="54" clone_end="59">
			<code function_name="GraphCreator::Create()">bool GraphCreator::Create() {
  if (common::util::EndWith(base_map_file_path_, ".xml")) {
    if (!hdmap::adapter::OpendriveAdapter::LoadData(base_map_file_path_,
                                                    &amp;pbmap_)) {
      AERROR &lt;&lt; "Failed to load base map file from " &lt;&lt; base_map_file_path_;
      return false;
    }
  } else {
    if (!common::util::GetProtoFromFile(base_map_file_path_, &amp;pbmap_)) {
      AERROR &lt;&lt; "Failed to load base map file from " &lt;&lt; base_map_file_path_;
      return false;
    }
  }

  AINFO &lt;&lt; "Number of lanes: " &lt;&lt; pbmap_.lane_size();

  graph_.set_hdmap_version(pbmap_.header().version());
  graph_.set_hdmap_district(pbmap_.header().district());

  node_index_map_.clear();
  road_id_map_.clear();
  showed_edge_id_set_.clear();

  for (const auto&amp; road : pbmap_.road()) {
    for (const auto&amp; section : road.section()) {
      for (const auto&amp; lane_id : section.lane_id()) {
        road_id_map_[lane_id.id()] = road.id().id();
      }
    }
  }

  InitForbiddenLanes();

  for (const auto&amp; lane : pbmap_.lane()) {
    const auto&amp; lane_id = lane.id().id();
    if (forbidden_lane_id_set_.find(lane_id) != forbidden_lane_id_set_.end()) {
      ADEBUG &lt;&lt; "Ignored lane id: " &lt;&lt; lane_id
             &lt;&lt; " because its type is NOT CITY_DRIVING.";
      continue;
    }
    AINFO &lt;&lt; "Current lane id: " &lt;&lt; lane_id;
    node_index_map_[lane_id] = graph_.node_size();
    const auto iter = road_id_map_.find(lane_id);
    if (iter != road_id_map_.end()) {
      NodeCreator::GetPbNode(lane, iter-&gt;second, graph_.add_node(),
                             routing_conf_);
    } else {
      LOG(WARNING) &lt;&lt; "Failed to find road id of lane " &lt;&lt; lane_id;
      NodeCreator::GetPbNode(lane, "", graph_.add_node(), routing_conf_);
    }
  }

  std::string edge_id = "";
  for (const auto&amp; lane : pbmap_.lane()) {
    const auto&amp; lane_id = lane.id().id();
    if (forbidden_lane_id_set_.find(lane_id) != forbidden_lane_id_set_.end()) {
      ADEBUG &lt;&lt; "Ignored lane id: " &lt;&lt; lane_id
             &lt;&lt; " because its type is NOT CITY_DRIVING.";
      continue;
    }
    const auto&amp; from_node = graph_.node(node_index_map_[lane_id]);

    AddEdge(from_node, lane.successor_id(), Edge::FORWARD);
    if (lane.length() &lt; routing_conf_-&gt;min_length_for_lane_change()) {
      continue;
    }
    if (lane.has_left_boundary() &amp;&amp; IsAllowedToCross(lane.left_boundary())) {
      AddEdge(from_node, lane.left_neighbor_forward_lane_id(), Edge::LEFT);
    }

    if (lane.has_right_boundary() &amp;&amp; IsAllowedToCross(lane.right_boundary())) {
      AddEdge(from_node, lane.right_neighbor_forward_lane_id(), Edge::RIGHT);
    }
  }

  if (!EndWith(dump_topo_file_path_, ".bin") &amp;&amp;
      !EndWith(dump_topo_file_path_, ".txt")) {
    AERROR &lt;&lt; "Failed to dump topo data into file, incorrect file type "
           &lt;&lt; dump_topo_file_path_;
    return false;
  }
  int type_pos = dump_topo_file_path_.find_last_of(".") + 1;
  std::string bin_file = dump_topo_file_path_.replace(type_pos, 3, "bin");
  std::string txt_file = dump_topo_file_path_.replace(type_pos, 3, "txt");
  if (!common::util::SetProtoToASCIIFile(graph_, txt_file)) {
    AERROR &lt;&lt; "Failed to dump topo data into file " &lt;&lt; txt_file;
    return false;
  }
  AINFO &lt;&lt; "Txt file is dumped successfully. Path: " &lt;&lt; txt_file;
  if (!common::util::SetProtoToBinaryFile(graph_, bin_file)) {
    AERROR &lt;&lt; "Failed to dump topo data into file " &lt;&lt; bin_file;
    return false;
  }
  AINFO &lt;&lt; "Bin file is dumped successfully. Path: " &lt;&lt; bin_file;
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\topo_creator\graph_creator.cc" startLine="(56, 0)" endLine="(151, 1)" clone_start="34" clone_end="39">
			<code function_name="GraphCreator::Create()">bool GraphCreator::Create() {
  if (common::util::EndWith(base_map_file_path_, ".xml")) {
    if (!hdmap::adapter::OpendriveAdapter::LoadData(base_map_file_path_,
                                                    &amp;pbmap_)) {
      AERROR &lt;&lt; "Failed to load base map file from " &lt;&lt; base_map_file_path_;
      return false;
    }
  } else {
    if (!common::util::GetProtoFromFile(base_map_file_path_, &amp;pbmap_)) {
      AERROR &lt;&lt; "Failed to load base map file from " &lt;&lt; base_map_file_path_;
      return false;
    }
  }

  AINFO &lt;&lt; "Number of lanes: " &lt;&lt; pbmap_.lane_size();

  graph_.set_hdmap_version(pbmap_.header().version());
  graph_.set_hdmap_district(pbmap_.header().district());

  node_index_map_.clear();
  road_id_map_.clear();
  showed_edge_id_set_.clear();

  for (const auto&amp; road : pbmap_.road()) {
    for (const auto&amp; section : road.section()) {
      for (const auto&amp; lane_id : section.lane_id()) {
        road_id_map_[lane_id.id()] = road.id().id();
      }
    }
  }

  InitForbiddenLanes();

  for (const auto&amp; lane : pbmap_.lane()) {
    const auto&amp; lane_id = lane.id().id();
    if (forbidden_lane_id_set_.find(lane_id) != forbidden_lane_id_set_.end()) {
      ADEBUG &lt;&lt; "Ignored lane id: " &lt;&lt; lane_id
             &lt;&lt; " because its type is NOT CITY_DRIVING.";
      continue;
    }
    AINFO &lt;&lt; "Current lane id: " &lt;&lt; lane_id;
    node_index_map_[lane_id] = graph_.node_size();
    const auto iter = road_id_map_.find(lane_id);
    if (iter != road_id_map_.end()) {
      NodeCreator::GetPbNode(lane, iter-&gt;second, graph_.add_node(),
                             routing_conf_);
    } else {
      LOG(WARNING) &lt;&lt; "Failed to find road id of lane " &lt;&lt; lane_id;
      NodeCreator::GetPbNode(lane, "", graph_.add_node(), routing_conf_);
    }
  }

  std::string edge_id = "";
  for (const auto&amp; lane : pbmap_.lane()) {
    const auto&amp; lane_id = lane.id().id();
    if (forbidden_lane_id_set_.find(lane_id) != forbidden_lane_id_set_.end()) {
      ADEBUG &lt;&lt; "Ignored lane id: " &lt;&lt; lane_id
             &lt;&lt; " because its type is NOT CITY_DRIVING.";
      continue;
    }
    const auto&amp; from_node = graph_.node(node_index_map_[lane_id]);

    AddEdge(from_node, lane.successor_id(), Edge::FORWARD);
    if (lane.length() &lt; routing_conf_-&gt;min_length_for_lane_change()) {
      continue;
    }
    if (lane.has_left_boundary() &amp;&amp; IsAllowedToCross(lane.left_boundary())) {
      AddEdge(from_node, lane.left_neighbor_forward_lane_id(), Edge::LEFT);
    }

    if (lane.has_right_boundary() &amp;&amp; IsAllowedToCross(lane.right_boundary())) {
      AddEdge(from_node, lane.right_neighbor_forward_lane_id(), Edge::RIGHT);
    }
  }

  if (!EndWith(dump_topo_file_path_, ".bin") &amp;&amp;
      !EndWith(dump_topo_file_path_, ".txt")) {
    AERROR &lt;&lt; "Failed to dump topo data into file, incorrect file type "
           &lt;&lt; dump_topo_file_path_;
    return false;
  }
  int type_pos = dump_topo_file_path_.find_last_of(".") + 1;
  std::string bin_file = dump_topo_file_path_.replace(type_pos, 3, "bin");
  std::string txt_file = dump_topo_file_path_.replace(type_pos, 3, "txt");
  if (!common::util::SetProtoToASCIIFile(graph_, txt_file)) {
    AERROR &lt;&lt; "Failed to dump topo data into file " &lt;&lt; txt_file;
    return false;
  }
  AINFO &lt;&lt; "Txt file is dumped successfully. Path: " &lt;&lt; txt_file;
  if (!common::util::SetProtoToBinaryFile(graph_, bin_file)) {
    AERROR &lt;&lt; "Failed to dump topo data into file " &lt;&lt; bin_file;
    return false;
  }
  AINFO &lt;&lt; "Bin file is dumped successfully. Path: " &lt;&lt; bin_file;
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\rtk\rtk_localization.cc" startLine="(175, 0)" endLine="(225, 1)" clone_start="35" clone_end="46">
			<code function_name="RTKLocalization::InterpolateIMU(const Imu &amp;imu1, const Imu &amp;imu2, const double timestamp_sec, Imu *imu_msg)">void RTKLocalization::InterpolateIMU(const Imu &amp;imu1, const Imu &amp;imu2,
                                     const double timestamp_sec, Imu *imu_msg) {
  DCHECK_NOTNULL(imu_msg);
  if (timestamp_sec - imu1.header().timestamp_sec() &lt;
      FLAGS_timestamp_sec_tolerance) {
    AERROR &lt;&lt; "[InterpolateIMU]: the given time stamp[" &lt;&lt; timestamp_sec
           &lt;&lt; "] is older than the 1st message["
           &lt;&lt; imu1.header().timestamp_sec() &lt;&lt; "]";
    *imu_msg = imu1;
  } else if (timestamp_sec - imu2.header().timestamp_sec() &gt;
             FLAGS_timestamp_sec_tolerance) {
    AERROR &lt;&lt; "[InterpolateIMU]: the given time stamp[" &lt;&lt; timestamp_sec
           &lt;&lt; "] is newer than the 2nd message["
           &lt;&lt; imu2.header().timestamp_sec() &lt;&lt; "]";
    *imu_msg = imu1;
  } else {
    *imu_msg = imu1;
    imu_msg-&gt;mutable_header()-&gt;set_timestamp_sec(timestamp_sec);

    if (imu1.has_header() &amp;&amp; imu1.header().has_timestamp_sec() &amp;&amp;
        imu2.has_header() &amp;&amp; imu2.header().has_timestamp_sec()) {
      double time_diff =
          imu2.header().timestamp_sec() - imu1.header().timestamp_sec();
      if (fabs(time_diff) &gt;= 0.001) {
        double frac1 =
            (timestamp_sec - imu1.header().timestamp_sec()) / time_diff;

        if (imu1.has_imu() &amp;&amp; imu1.imu().has_angular_velocity() &amp;&amp;
            imu2.has_imu() &amp;&amp; imu2.imu().has_angular_velocity()) {
          auto val = InterpolateXYZ(imu1.imu().angular_velocity(),
                                    imu2.imu().angular_velocity(), frac1);
          imu_msg-&gt;mutable_imu()-&gt;mutable_angular_velocity()-&gt;CopyFrom(val);
        }

        if (imu1.has_imu() &amp;&amp; imu1.imu().has_linear_acceleration() &amp;&amp;
            imu2.has_imu() &amp;&amp; imu2.imu().has_linear_acceleration()) {
          auto val = InterpolateXYZ(imu1.imu().linear_acceleration(),
                                    imu2.imu().linear_acceleration(), frac1);
          imu_msg-&gt;mutable_imu()-&gt;mutable_linear_acceleration()-&gt;CopyFrom(val);
        }

        if (imu1.has_imu() &amp;&amp; imu1.imu().has_euler_angles() &amp;&amp; imu2.has_imu() &amp;&amp;
            imu2.imu().has_euler_angles()) {
          auto val = InterpolateXYZ(imu1.imu().euler_angles(),
                                    imu2.imu().euler_angles(), frac1);
          imu_msg-&gt;mutable_imu()-&gt;mutable_euler_angles()-&gt;CopyFrom(val);
        }
      }
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\rtk\rtk_localization.cc" startLine="(175, 0)" endLine="(225, 1)" clone_start="28" clone_end="39">
			<code function_name="RTKLocalization::InterpolateIMU(const Imu &amp;imu1, const Imu &amp;imu2, const double timestamp_sec, Imu *imu_msg)">void RTKLocalization::InterpolateIMU(const Imu &amp;imu1, const Imu &amp;imu2,
                                     const double timestamp_sec, Imu *imu_msg) {
  DCHECK_NOTNULL(imu_msg);
  if (timestamp_sec - imu1.header().timestamp_sec() &lt;
      FLAGS_timestamp_sec_tolerance) {
    AERROR &lt;&lt; "[InterpolateIMU]: the given time stamp[" &lt;&lt; timestamp_sec
           &lt;&lt; "] is older than the 1st message["
           &lt;&lt; imu1.header().timestamp_sec() &lt;&lt; "]";
    *imu_msg = imu1;
  } else if (timestamp_sec - imu2.header().timestamp_sec() &gt;
             FLAGS_timestamp_sec_tolerance) {
    AERROR &lt;&lt; "[InterpolateIMU]: the given time stamp[" &lt;&lt; timestamp_sec
           &lt;&lt; "] is newer than the 2nd message["
           &lt;&lt; imu2.header().timestamp_sec() &lt;&lt; "]";
    *imu_msg = imu1;
  } else {
    *imu_msg = imu1;
    imu_msg-&gt;mutable_header()-&gt;set_timestamp_sec(timestamp_sec);

    if (imu1.has_header() &amp;&amp; imu1.header().has_timestamp_sec() &amp;&amp;
        imu2.has_header() &amp;&amp; imu2.header().has_timestamp_sec()) {
      double time_diff =
          imu2.header().timestamp_sec() - imu1.header().timestamp_sec();
      if (fabs(time_diff) &gt;= 0.001) {
        double frac1 =
            (timestamp_sec - imu1.header().timestamp_sec()) / time_diff;

        if (imu1.has_imu() &amp;&amp; imu1.imu().has_angular_velocity() &amp;&amp;
            imu2.has_imu() &amp;&amp; imu2.imu().has_angular_velocity()) {
          auto val = InterpolateXYZ(imu1.imu().angular_velocity(),
                                    imu2.imu().angular_velocity(), frac1);
          imu_msg-&gt;mutable_imu()-&gt;mutable_angular_velocity()-&gt;CopyFrom(val);
        }

        if (imu1.has_imu() &amp;&amp; imu1.imu().has_linear_acceleration() &amp;&amp;
            imu2.has_imu() &amp;&amp; imu2.imu().has_linear_acceleration()) {
          auto val = InterpolateXYZ(imu1.imu().linear_acceleration(),
                                    imu2.imu().linear_acceleration(), frac1);
          imu_msg-&gt;mutable_imu()-&gt;mutable_linear_acceleration()-&gt;CopyFrom(val);
        }

        if (imu1.has_imu() &amp;&amp; imu1.imu().has_euler_angles() &amp;&amp; imu2.has_imu() &amp;&amp;
            imu2.imu().has_euler_angles()) {
          auto val = InterpolateXYZ(imu1.imu().euler_angles(),
                                    imu2.imu().euler_angles(), frac1);
          imu_msg-&gt;mutable_imu()-&gt;mutable_euler_angles()-&gt;CopyFrom(val);
        }
      }
    }
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(239, 0)" endLine="(374, 1)" clone_start="20" clone_end="25">
			<code function_name="NovatelParser::prepare_message(MessagePtr&amp; message_ptr)">Parser::MessageType NovatelParser::prepare_message(MessagePtr&amp; message_ptr) {
  if (!check_crc()) {
    ROS_ERROR("CRC check failed.");
    return MessageType::NONE;
  }

  uint8_t* message = nullptr;
  novatel::MessageId message_id;
  uint16_t message_length;
  uint16_t gps_week;
  uint32_t gps_millisecs;
  if (_buffer[2] == novatel::SYNC_2_LONG_HEADER) {
    auto header = reinterpret_cast&lt;const novatel::LongHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::LongHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  } else {
    auto header = reinterpret_cast&lt;const novatel::ShortHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::ShortHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  }
  switch (message_id) {
    case novatel::BESTGNSSPOS:
    case novatel::BESTPOS:
    case novatel::PSRPOS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestPos), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestPos)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_pos(reinterpret_cast&lt;novatel::BestPos*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::BESTGNSSVEL:
    case novatel::BESTVEL:
    case novatel::PSRVEL:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestVel), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestVel)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_vel(reinterpret_cast&lt;novatel::BestVel*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::CORRIMUDATA:
    case novatel::CORRIMUDATAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::CorrImuData),
      // "Incorrect message_length");
      if (message_length != sizeof(novatel::CorrImuData)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_corr_imu_data(
              reinterpret_cast&lt;novatel::CorrImuData*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSCOV:
    case novatel::INSCOVS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsCov), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsCov)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_cov(reinterpret_cast&lt;novatel::InsCov*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSPVA:
    case novatel::INSPVAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsPva), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsPva)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_pva(reinterpret_cast&lt;novatel::InsPva*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::RAWIMUX:
    case novatel::RAWIMUSX:
      // ROS_ERROR_COND(message_length != sizeof(novatel::RawImuX), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::RawImuX)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_raw_imu_x(reinterpret_cast&lt;novatel::RawImuX*&gt;(message))) {
        message_ptr = &amp;_imu;
        return MessageType::IMU;
      }
      break;

    case novatel::INSPVAX:
        if (message_length != sizeof(novatel::InsPvaX)) {
          ROS_ERROR("Incorrect message_length");
          break;
        }

        if (handle_ins_pvax(reinterpret_cast&lt;novatel::InsPvaX*&gt;(message))) {
          message_ptr = &amp;_ins_stat;
          return MessageType::INS_STAT;
        }
        break;
    default:
      break;
  }
  return MessageType::NONE;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(239, 0)" endLine="(374, 1)" clone_start="13" clone_end="18">
			<code function_name="NovatelParser::prepare_message(MessagePtr&amp; message_ptr)">Parser::MessageType NovatelParser::prepare_message(MessagePtr&amp; message_ptr) {
  if (!check_crc()) {
    ROS_ERROR("CRC check failed.");
    return MessageType::NONE;
  }

  uint8_t* message = nullptr;
  novatel::MessageId message_id;
  uint16_t message_length;
  uint16_t gps_week;
  uint32_t gps_millisecs;
  if (_buffer[2] == novatel::SYNC_2_LONG_HEADER) {
    auto header = reinterpret_cast&lt;const novatel::LongHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::LongHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  } else {
    auto header = reinterpret_cast&lt;const novatel::ShortHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::ShortHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  }
  switch (message_id) {
    case novatel::BESTGNSSPOS:
    case novatel::BESTPOS:
    case novatel::PSRPOS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestPos), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestPos)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_pos(reinterpret_cast&lt;novatel::BestPos*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::BESTGNSSVEL:
    case novatel::BESTVEL:
    case novatel::PSRVEL:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestVel), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestVel)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_vel(reinterpret_cast&lt;novatel::BestVel*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::CORRIMUDATA:
    case novatel::CORRIMUDATAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::CorrImuData),
      // "Incorrect message_length");
      if (message_length != sizeof(novatel::CorrImuData)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_corr_imu_data(
              reinterpret_cast&lt;novatel::CorrImuData*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSCOV:
    case novatel::INSCOVS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsCov), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsCov)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_cov(reinterpret_cast&lt;novatel::InsCov*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSPVA:
    case novatel::INSPVAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsPva), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsPva)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_pva(reinterpret_cast&lt;novatel::InsPva*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::RAWIMUX:
    case novatel::RAWIMUSX:
      // ROS_ERROR_COND(message_length != sizeof(novatel::RawImuX), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::RawImuX)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_raw_imu_x(reinterpret_cast&lt;novatel::RawImuX*&gt;(message))) {
        message_ptr = &amp;_imu;
        return MessageType::IMU;
      }
      break;

    case novatel::INSPVAX:
        if (message_length != sizeof(novatel::InsPvaX)) {
          ROS_ERROR("Incorrect message_length");
          break;
        }

        if (handle_ins_pvax(reinterpret_cast&lt;novatel::InsPvaX*&gt;(message))) {
          message_ptr = &amp;_ins_stat;
          return MessageType::INS_STAT;
        }
        break;
    default:
      break;
  }
  return MessageType::NONE;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\prediction.cc" startLine="(42, 0)" endLine="(80, 1)" clone_start="13" clone_end="20">
			<code function_name="Prediction::Init()">Status Prediction::Init() {
  // Load prediction conf
  prediction_conf_.Clear();
  if (!common::util::GetProtoFromFile(FLAGS_prediction_conf_file,
                                      &amp;prediction_conf_)) {
    return OnError("Unable to load prediction conf file: " +
                   FLAGS_prediction_conf_file);
  } else {
    ADEBUG &lt;&lt; "Prediction config file is loaded into: "
           &lt;&lt; prediction_conf_.ShortDebugString();
  }

  adapter_conf_.Clear();
  if (!common::util::GetProtoFromFile(FLAGS_adapter_config_filename,
                                      &amp;adapter_conf_)) {
    return OnError("Unable to load adapter conf file: " +
                   FLAGS_adapter_config_filename);
  } else {
    ADEBUG &lt;&lt; "Adapter config file is loaded into: "
           &lt;&lt; adapter_conf_.ShortDebugString();
  }

  // Initialization of all managers
  AdapterManager::instance()-&gt;Init(adapter_conf_);
  ContainerManager::instance()-&gt;Init(adapter_conf_);
  EvaluatorManager::instance()-&gt;Init(prediction_conf_);
  PredictorManager::instance()-&gt;Init(prediction_conf_);

  CHECK(AdapterManager::GetLocalization()) &lt;&lt; "Localization is not ready.";
  CHECK(AdapterManager::GetPerceptionObstacles()) &lt;&lt; "Perception is not ready.";

  // Set perception obstacle callback function
  AdapterManager::AddPerceptionObstaclesCallback(&amp;Prediction::OnPerception,
                                                 this);
  // Set localization callback function
  AdapterManager::AddLocalizationCallback(&amp;Prediction::OnLocalization, this);

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\prediction.cc" startLine="(42, 0)" endLine="(80, 1)" clone_start="3" clone_end="10">
			<code function_name="Prediction::Init()">Status Prediction::Init() {
  // Load prediction conf
  prediction_conf_.Clear();
  if (!common::util::GetProtoFromFile(FLAGS_prediction_conf_file,
                                      &amp;prediction_conf_)) {
    return OnError("Unable to load prediction conf file: " +
                   FLAGS_prediction_conf_file);
  } else {
    ADEBUG &lt;&lt; "Prediction config file is loaded into: "
           &lt;&lt; prediction_conf_.ShortDebugString();
  }

  adapter_conf_.Clear();
  if (!common::util::GetProtoFromFile(FLAGS_adapter_config_filename,
                                      &amp;adapter_conf_)) {
    return OnError("Unable to load adapter conf file: " +
                   FLAGS_adapter_config_filename);
  } else {
    ADEBUG &lt;&lt; "Adapter config file is loaded into: "
           &lt;&lt; adapter_conf_.ShortDebugString();
  }

  // Initialization of all managers
  AdapterManager::instance()-&gt;Init(adapter_conf_);
  ContainerManager::instance()-&gt;Init(adapter_conf_);
  EvaluatorManager::instance()-&gt;Init(prediction_conf_);
  PredictorManager::instance()-&gt;Init(prediction_conf_);

  CHECK(AdapterManager::GetLocalization()) &lt;&lt; "Localization is not ready.";
  CHECK(AdapterManager::GetPerceptionObstacles()) &lt;&lt; "Perception is not ready.";

  // Set perception obstacle callback function
  AdapterManager::AddPerceptionObstaclesCallback(&amp;Prediction::OnPerception,
                                                 this);
  // Set localization callback function
  AdapterManager::AddLocalizationCallback(&amp;Prediction::OnLocalization, this);

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\control.cc" startLine="(44, 0)" endLine="(81, 1)" clone_start="27" clone_end="35">
			<code function_name="Control::Init()">Status Control::Init() {
  AINFO &lt;&lt; "Control init, starting ...";
  CHECK(common::util::GetProtoFromFile(FLAGS_control_conf_file,
                                                 &amp;control_conf_))
      &lt;&lt; "Unable to load control conf file: " + FLAGS_control_conf_file;

  AINFO &lt;&lt; "Conf file: " &lt;&lt; FLAGS_control_conf_file &lt;&lt; " is loaded.";

  AdapterManager::Init(FLAGS_adapter_config_filename);

  apollo::common::monitor::MonitorBuffer buffer(&amp;monitor_);

  // set controller
  if (!controller_agent_.Init(&amp;control_conf_).ok()) {
    std::string error_msg = "Control init controller failed! Stopping...";
    buffer.ERROR(error_msg);
    return Status(ErrorCode::CONTROL_INIT_ERROR, error_msg);
  }

  // lock it in case for after sub, init_vehicle not ready, but msg trigger
  // come
  CHECK(AdapterManager::GetLocalization())
      &lt;&lt; "Localization is not initialized.";

  CHECK(AdapterManager::GetChassis()) &lt;&lt; "Chassis is not initialized.";

  CHECK(AdapterManager::GetPlanning()) &lt;&lt; "Planning is not initialized.";

  CHECK(AdapterManager::GetPad()) &lt;&lt; "Pad is not initialized.";

  CHECK(AdapterManager::GetControlCommand())
      &lt;&lt; "ControlCommand publisher is not initialized.";

  AdapterManager::AddPadCallback(&amp;Control::OnPad, this);
  AdapterManager::AddMonitorCallback(&amp;Control::OnMonitor, this);

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\calibration\republish_msg\republish_msg.cc" startLine="(31, 0)" endLine="(46, 1)" clone_start="4" clone_end="10">
			<code function_name="RepublishMsg::Init()">Status RepublishMsg::Init() {
  AdapterManager::Init(FLAGS_adapter_config_filename);

  CHECK(AdapterManager::GetInsStat()) &lt;&lt; "INS status is not initialized.";
  CHECK(AdapterManager::GetGps()) &lt;&lt; "Gps is not initialized.";
  CHECK(AdapterManager::GetRelativeOdometry())
      &lt;&lt; "Relative odometry is not initialized.";

  AdapterManager::AddGpsCallback(&amp;RepublishMsg::OnGps, this);
  AdapterManager::AddInsStatCallback(&amp;RepublishMsg::OnInsStat, this);

  is_first_gps_msg_ = true;
  position_type_ = 0;

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="6">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\vehicle\lane_sequence_predictor.h" startLine="(41, 2)" endLine="(41, 36)" clone_start="1" clone_end="1">
			<code function_name="LaneSequencePredictor()">  LaneSequencePredictor() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\vehicle\free_move_predictor.h" startLine="(38, 2)" endLine="(38, 32)" clone_start="1" clone_end="1">
			<code function_name="FreeMovePredictor()">  FreeMovePredictor() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\pedestrian\regional_predictor.h" startLine="(40, 2)" endLine="(40, 32)" clone_start="1" clone_end="1">
			<code function_name="RegionalPredictor()">  RegionalPredictor() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\pose\pose_container.h" startLine="(40, 2)" endLine="(40, 28)" clone_start="1" clone_end="1">
			<code function_name="PoseContainer()">  PoseContainer() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\planner\em\em_planner.h" startLine="(52, 2)" endLine="(52, 24)" clone_start="1" clone_end="1">
			<code function_name="EMPlanner()">  EMPlanner() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\curve1d\polynomial_curve1d.h" startLine="(30, 2)" endLine="(30, 32)" clone_start="1" clone_end="1">
			<code function_name="PolynomialCurve1d()">  PolynomialCurve1d() = default;</code>
		</source>
	</dup>
	<dup count="6">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\vehicle\lane_sequence_predictor.h" startLine="(46, 2)" endLine="(46, 45)" clone_start="1" clone_end="1">
			<code function_name="~LaneSequencePredictor()">  virtual ~LaneSequencePredictor() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\vehicle\free_move_predictor.h" startLine="(43, 2)" endLine="(43, 41)" clone_start="1" clone_end="1">
			<code function_name="~FreeMovePredictor()">  virtual ~FreeMovePredictor() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\pedestrian\regional_predictor.h" startLine="(45, 2)" endLine="(45, 41)" clone_start="1" clone_end="1">
			<code function_name="~RegionalPredictor()">  virtual ~RegionalPredictor() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\pose\pose_container.h" startLine="(45, 2)" endLine="(45, 37)" clone_start="1" clone_end="1">
			<code function_name="~PoseContainer()">  virtual ~PoseContainer() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\planner\em\em_planner.h" startLine="(57, 2)" endLine="(57, 33)" clone_start="1" clone_end="1">
			<code function_name="~EMPlanner()">  virtual ~EMPlanner() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\curve1d\polynomial_curve1d.h" startLine="(32, 2)" endLine="(32, 41)" clone_start="1" clone_end="1">
			<code function_name="~PolynomialCurve1d()">  virtual ~PolynomialCurve1d() = default;</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\planning_util.cc" startLine="(35, 0)" endLine="(71, 1)" clone_start="28" clone_end="33">
			<code function_name="interpolate(const PathPoint &amp;p0, const PathPoint &amp;p1, const double s)">PathPoint interpolate(const PathPoint &amp;p0, const PathPoint &amp;p1,
                      const double s) {
  double s0 = p0.s();
  double s1 = p1.s();
  CHECK(s0 &lt;= s &amp;&amp; s &lt;= s1);

  std::array&lt;double, 2&gt; gx0{{p0.theta(), p0.kappa()}};
  std::array&lt;double, 2&gt; gx1{{p1.theta(), p1.kappa()}};
  HermiteSpline&lt;double, 3&gt; geometry_spline(gx0, gx1, s0, s1);
  auto func_cos_theta = [&amp;geometry_spline](const double s) {
    auto theta = geometry_spline.Evaluate(0, s);
    return std::cos(theta);
  };
  auto func_sin_theta = [&amp;geometry_spline](const double s) {
    auto theta = geometry_spline.Evaluate(0, s);
    return std::sin(theta);
  };

  double x =
      p0.x() + common::math::IntegrateByGaussLegendre(func_cos_theta, s0, s);
  double y =
      p0.y() + common::math::IntegrateByGaussLegendre(func_sin_theta, s0, s);
  double theta = geometry_spline.Evaluate(0, s);
  double kappa = geometry_spline.Evaluate(1, s);
  double dkappa = geometry_spline.Evaluate(2, s);
  double d2kappa = geometry_spline.Evaluate(3, s);

  PathPoint p;
  p.set_x(x);
  p.set_y(y);
  p.set_theta(theta);
  p.set_kappa(kappa);
  p.set_dkappa(dkappa);
  p.set_ddkappa(d2kappa);
  p.set_s(s);
  return p;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\util\util.cc" startLine="(67, 0)" endLine="(79, 1)" clone_start="4" clone_end="9">
			<code function_name="MakePathPoint(const double x, const double y, const double z,const double theta, const double kappa, const double dkappa, const double ddkappa)">PathPoint MakePathPoint(const double x, const double y, const double z,
                        const double theta, const double kappa,
                        const double dkappa, const double ddkappa) {
  PathPoint path_point;
  path_point.set_x(x);
  path_point.set_y(y);
  path_point.set_z(z);
  path_point.set_theta(theta);
  path_point.set_kappa(kappa);
  path_point.set_dkappa(dkappa);
  path_point.set_ddkappa(ddkappa);
  return path_point;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\util\util.cc" startLine="(56, 0)" endLine="(65, 1)" clone_start="3" clone_end="8">
			<code function_name="MakeSpeedPoint(const double s, const double t, const double v, const double a, const double da)">SpeedPoint MakeSpeedPoint(const double s, const double t, const double v,
                          const double a, const double da) {
  SpeedPoint speed_point;
  speed_point.set_s(s);
  speed_point.set_t(t);
  speed_point.set_v(v);
  speed_point.set_a(a);
  speed_point.set_da(da);
  return speed_point;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\common\geometry_util.h" startLine="(90, 0)" endLine="(120, 1)" clone_start="23" clone_end="28">
			<code function_name="GetCloudMinMax3D(typename pcl::PointCloud&lt;PointT&gt;::Ptr cloud, Eigen::Vector4f* min_point, Eigen::Vector4f* max_point)">void GetCloudMinMax3D(typename pcl::PointCloud&lt;PointT&gt;::Ptr cloud,
                      Eigen::Vector4f* min_point, Eigen::Vector4f* max_point) {
  Eigen::Vector4f&amp; min_pt = *min_point;
  Eigen::Vector4f&amp; max_pt = *max_point;
  min_pt[0] = min_pt[1] = min_pt[2] = FLT_MAX;
  max_pt[0] = max_pt[1] = max_pt[2] = -FLT_MAX;
  if (cloud-&gt;is_dense) {
    for (size_t i = 0; i &lt; cloud-&gt;points.size(); ++i) {
      min_pt[0] = std::min(min_pt[0], cloud-&gt;points[i].x);
      max_pt[0] = std::max(max_pt[0], cloud-&gt;points[i].x);
      min_pt[1] = std::min(min_pt[1], cloud-&gt;points[i].y);
      max_pt[1] = std::max(max_pt[1], cloud-&gt;points[i].y);
      min_pt[2] = std::min(min_pt[2], cloud-&gt;points[i].z);
      max_pt[2] = std::max(max_pt[2], cloud-&gt;points[i].z);
    }
  } else {
    for (size_t i = 0; i &lt; cloud-&gt;points.size(); ++i) {
      if (!pcl_isfinite(cloud-&gt;points[i].x) ||
          !pcl_isfinite(cloud-&gt;points[i].y) ||
          !pcl_isfinite(cloud-&gt;points[i].z)) {
        continue;
      }
      min_pt[0] = std::min(min_pt[0], cloud-&gt;points[i].x);
      max_pt[0] = std::max(max_pt[0], cloud-&gt;points[i].x);
      min_pt[1] = std::min(min_pt[1], cloud-&gt;points[i].y);
      max_pt[1] = std::max(max_pt[1], cloud-&gt;points[i].y);
      min_pt[2] = std::min(min_pt[2], cloud-&gt;points[i].z);
      max_pt[2] = std::max(max_pt[2], cloud-&gt;points[i].z);
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\common\geometry_util.h" startLine="(90, 0)" endLine="(120, 1)" clone_start="9" clone_end="14">
			<code function_name="GetCloudMinMax3D(typename pcl::PointCloud&lt;PointT&gt;::Ptr cloud, Eigen::Vector4f* min_point, Eigen::Vector4f* max_point)">void GetCloudMinMax3D(typename pcl::PointCloud&lt;PointT&gt;::Ptr cloud,
                      Eigen::Vector4f* min_point, Eigen::Vector4f* max_point) {
  Eigen::Vector4f&amp; min_pt = *min_point;
  Eigen::Vector4f&amp; max_pt = *max_point;
  min_pt[0] = min_pt[1] = min_pt[2] = FLT_MAX;
  max_pt[0] = max_pt[1] = max_pt[2] = -FLT_MAX;
  if (cloud-&gt;is_dense) {
    for (size_t i = 0; i &lt; cloud-&gt;points.size(); ++i) {
      min_pt[0] = std::min(min_pt[0], cloud-&gt;points[i].x);
      max_pt[0] = std::max(max_pt[0], cloud-&gt;points[i].x);
      min_pt[1] = std::min(min_pt[1], cloud-&gt;points[i].y);
      max_pt[1] = std::max(max_pt[1], cloud-&gt;points[i].y);
      min_pt[2] = std::min(min_pt[2], cloud-&gt;points[i].z);
      max_pt[2] = std::max(max_pt[2], cloud-&gt;points[i].z);
    }
  } else {
    for (size_t i = 0; i &lt; cloud-&gt;points.size(); ++i) {
      if (!pcl_isfinite(cloud-&gt;points[i].x) ||
          !pcl_isfinite(cloud-&gt;points[i].y) ||
          !pcl_isfinite(cloud-&gt;points[i].z)) {
        continue;
      }
      min_pt[0] = std::min(min_pt[0], cloud-&gt;points[i].x);
      max_pt[0] = std::max(max_pt[0], cloud-&gt;points[i].x);
      min_pt[1] = std::min(min_pt[1], cloud-&gt;points[i].y);
      max_pt[1] = std::max(max_pt[1], cloud-&gt;points[i].y);
      min_pt[2] = std::min(min_pt[2], cloud-&gt;points[i].z);
      max_pt[2] = std::max(max_pt[2], cloud-&gt;points[i].z);
    }
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(428, 0)" endLine="(463, 1)" clone_start="6" clone_end="11">
			<code function_name="HmObjectTracker::Initialize(const std::vector&lt;ObjectPtr&gt;&amp; objects,const double&amp; timestamp,   const TrackerOptions&amp; options, std::vector&lt;ObjectPtr&gt;* tracked_objects)">bool HmObjectTracker::Initialize(const std::vector&lt;ObjectPtr&gt;&amp; objects,
  const double&amp; timestamp,
  const TrackerOptions&amp; options,
  std::vector&lt;ObjectPtr&gt;* tracked_objects) {
  // A. track setup
  Eigen::Matrix4d velo2world_pose = Eigen::Matrix4d::Identity();
  if (options.velodyne_trans != nullptr) {
    velo2world_pose = *(options.velodyne_trans);
  } else {
    AERROR &lt;&lt; "Input velodyne_trans is null";
    return false;
  }
  global_to_local_offset_ = Eigen::Vector3d(-velo2world_pose(0, 3),
                                            -velo2world_pose(1, 3),
                                            -velo2world_pose(2, 3));

  // B. preprocessing
  // B.1 coordinate transformation
  TransformPoseGlobal2Local(&amp;velo2world_pose);
  ADEBUG &lt;&lt; "velo2local_pose\n" &lt;&lt; velo2world_pose;
  // B.2 construct tracked objects
  std::vector&lt;TrackedObjectPtr&gt; transformed_objects;
  ConstructTrackedObjects(objects, &amp;transformed_objects, velo2world_pose,
                          options);

  // C. create tracks
  std::vector&lt;int&gt; unassigned_objects;
  unassigned_objects.resize(transformed_objects.size());
  std::iota(unassigned_objects.begin(), unassigned_objects.end(), 0);
  CreateNewTracks(transformed_objects, unassigned_objects);
  time_stamp_ = timestamp;

  // D. collect tracked results
  CollectTrackedResults(tracked_objects);
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(368, 0)" endLine="(426, 1)" clone_start="12" clone_end="17">
			<code function_name="HmObjectTracker::Track(const std::vector&lt;ObjectPtr&gt;&amp; objects,double timestamp, const TrackerOptions&amp; options, std::vector&lt;ObjectPtr&gt;* tracked_objects)">bool HmObjectTracker::Track(const std::vector&lt;ObjectPtr&gt;&amp; objects,
  double timestamp,
  const TrackerOptions&amp; options,
  std::vector&lt;ObjectPtr&gt;* tracked_objects) {
  // A. track setup
  if (tracked_objects == nullptr)
    return false;
  if (!valid_) {
    valid_ = true;
    return Initialize(objects, timestamp, options, tracked_objects);
  }
  Eigen::Matrix4d velo2world_pose = Eigen::Matrix4d::Identity();
  if (options.velodyne_trans != nullptr) {
    velo2world_pose = *(options.velodyne_trans);
  } else {
    AERROR &lt;&lt; "Input velodyne_trans is null";
    return false;
  }
  double time_diff = timestamp - time_stamp_;
  time_stamp_ = timestamp;

  // B. preprocessing
  // B.1 transform given pose to local one
  TransformPoseGlobal2Local(&amp;velo2world_pose);
  ADEBUG &lt;&lt; "velo2local_pose\n" &lt;&lt; velo2world_pose;
  // B.2 construct objects for tracking
  std::vector&lt;TrackedObjectPtr&gt; transformed_objects;
  ConstructTrackedObjects(objects, &amp;transformed_objects, velo2world_pose,
                          options);

  // C. prediction
  std::vector&lt;Eigen::VectorXf&gt; tracks_predict;
  ComputeTracksPredict(&amp;tracks_predict, time_diff);

  // D. match objects to tracks
  std::vector&lt;TrackObjectPair&gt; assignments;
  std::vector&lt;int&gt; unassigned_objects;
  std::vector&lt;int&gt; unassigned_tracks;
  std::vector&lt;ObjectTrackPtr&gt;&amp; tracks = object_tracks_.GetTracks();
  matcher_-&gt;Match(&amp;transformed_objects, tracks, tracks_predict,
                  &amp;assignments, &amp;unassigned_tracks, &amp;unassigned_objects);
  ADEBUG &lt;&lt; "multi-object-tracking: " &lt;&lt; tracks.size() &lt;&lt; "  "
        &lt;&lt; assignments.size() &lt;&lt; "  " &lt;&lt; transformed_objects.size() &lt;&lt; "  "
        &lt;&lt; unassigned_objects.size() &lt;&lt; "  " &lt;&lt; time_diff;

  // E. update tracks
  // E.1 update tracks with associated objects
  UpdateAssignedTracks(&amp;tracks_predict, &amp;transformed_objects, assignments,
                       time_diff);
  // E.2 update tracks without associated objects
  UpdateUnassignedTracks(tracks_predict, unassigned_tracks, time_diff);
  DeleteLostTracks();
  // E.3 create new tracks for objects without associated tracks
  CreateNewTracks(transformed_objects, unassigned_objects);

  // F. collect tracked results
  CollectTrackedResults(tracked_objects);
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\tf_broadcaster.cpp" startLine="(32, 0)" endLine="(45, 1)" clone_start="8" clone_end="13">
			<code function_name="TFBroadcaster::gps_to_transform_stamped(const ::apollo::localization::Gps&amp; gps, geometry_msgs::TransformStamped* transform)">void TFBroadcaster::gps_to_transform_stamped(const ::apollo::localization::Gps&amp; gps,
                                          geometry_msgs::TransformStamped* transform) {
  ros::Time time;
  transform-&gt;header.stamp = time.fromSec(gps.header().timestamp_sec());
  transform-&gt;header.frame_id = _frame_id;
  transform-&gt;child_frame_id = _child_frame_id;
  transform-&gt;transform.translation.x = gps.localization().position().x();
  transform-&gt;transform.translation.y = gps.localization().position().y();
  transform-&gt;transform.translation.z = gps.localization().position().z();
  transform-&gt;transform.rotation.x = gps.localization().orientation().qx();
  transform-&gt;transform.rotation.y = gps.localization().orientation().qy();
  transform-&gt;transform.rotation.z = gps.localization().orientation().qz();
  transform-&gt;transform.rotation.w = gps.localization().orientation().qw();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\tf_broadcaster.cpp" startLine="(32, 0)" endLine="(45, 1)" clone_start="7" clone_end="12">
			<code function_name="TFBroadcaster::gps_to_transform_stamped(const ::apollo::localization::Gps&amp; gps, geometry_msgs::TransformStamped* transform)">void TFBroadcaster::gps_to_transform_stamped(const ::apollo::localization::Gps&amp; gps,
                                          geometry_msgs::TransformStamped* transform) {
  ros::Time time;
  transform-&gt;header.stamp = time.fromSec(gps.header().timestamp_sec());
  transform-&gt;header.frame_id = _frame_id;
  transform-&gt;child_frame_id = _child_frame_id;
  transform-&gt;transform.translation.x = gps.localization().position().x();
  transform-&gt;transform.translation.y = gps.localization().position().y();
  transform-&gt;transform.translation.z = gps.localization().position().z();
  transform-&gt;transform.rotation.x = gps.localization().orientation().qx();
  transform-&gt;transform.rotation.y = gps.localization().orientation().qy();
  transform-&gt;transform.rotation.z = gps.localization().orientation().qz();
  transform-&gt;transform.rotation.w = gps.localization().orientation().qw();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(334, 0)" endLine="(386, 1)" clone_start="25" clone_end="32">
			<code function_name="SerialStream::write(const uint8_t* data, size_t length)">size_t SerialStream::write(const uint8_t* data, size_t length) {
  if (!_is_open) {
    if (!connect()) {
      return 0;
    }
    ROS_INFO_STREAM("Connect " &lt;&lt; _device_name &lt;&lt; " success.");
  }

  size_t total_nsent = 0;
  size_t delay_times = 0;

  while ((length &gt; 0) &amp;&amp; (delay_times &lt; 5)) {
    ssize_t nsent = ::write(_fd, data, length);
    if (nsent &lt; 0) {
      ROS_ERROR_STREAM(
          "Serial stream write data failed, error: " &lt;&lt; strerror(errno));
      switch (errno) {
        case EAGAIN:
        case EINVAL:
          nsent = 0;
          break;

        case EBADF:
        case EIO:
          disconnect();
          if (connect()) {
            ROS_INFO_STREAM("Reconnect " &lt;&lt; _device_name &lt;&lt; "success.");
            nsent = 0;
            break;  // has recoverable
          }

        default:
          _status = Stream::Status::ERROR;
          _errno = errno;
          return total_nsent;
      }
    }

    if (nsent == 0) {
      if (!wait_writable(_byte_time_us)) {
        break;
      }
      ++delay_times;
      continue;
    }

    total_nsent += nsent;
    length -= nsent;
    data += nsent;
  }

  return total_nsent;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(276, 0)" endLine="(332, 1)" clone_start="27" clone_end="34">
			<code function_name="SerialStream::read(uint8_t* buffer, size_t max_length)">size_t SerialStream::read(uint8_t* buffer, size_t max_length) {
  if (!_is_open) {
    if (!connect()) {
      return 0;
    }
    ROS_INFO_STREAM("Connect " &lt;&lt; _device_name &lt;&lt; " success.");
  }

  ssize_t bytes_read = 0;
  ssize_t bytes_current_read = 0;

  wait_readable(100000);  // wait 10ms

  while (max_length &gt; 0) {
    bytes_current_read = ::read(_fd, buffer, max_length);
    if (bytes_current_read &lt; 0) {
      switch (errno) {
        case EAGAIN:
        case EINVAL:
          bytes_current_read = 0;
          break;

        case EBADF:
        case EIO:
          ROS_ERROR_STREAM(
              "Serial stream read data failed, error: " &lt;&lt; strerror(errno));
          disconnect();
          if (connect()) {
            ROS_INFO_STREAM("Reconnect " &lt;&lt; _device_name &lt;&lt; "success.");
            bytes_current_read = 0;
            break;  // has recoverable
          }

        default:
          ROS_ERROR_STREAM_THROTTLE(1, "Serial stream read data failed, error: "
                                           &lt;&lt; strerror(errno)
                                           &lt;&lt; ", errno: " &lt;&lt; errno);
          _status = Stream::Status::ERROR;
          _errno = errno;
          return bytes_read;
      }
    }

    if (bytes_current_read == 0) {
      if (!bytes_read) {
        check_remove();
        return 0;
      }
      return bytes_read;
    }
    max_length -= bytes_current_read;
    buffer += bytes_current_read;
    bytes_read += bytes_current_read;
  }

  return bytes_read;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\apollo_app.cc" startLine="(38, 0)" endLine="(60, 1)" clone_start="10" clone_end="16">
			<code function_name="ApolloApp::Spin()">int ApolloApp::Spin() {
  ros::AsyncSpinner spinner(1);
  auto status = Init();
  if (!status.ok()) {
    AERROR &lt;&lt; Name() &lt;&lt; " Init failed: " &lt;&lt; status;
    ReportModuleStatus(apollo::hmi::ModuleStatus::UNINITIALIZED);
    return -1;
  }
  ReportModuleStatus(apollo::hmi::ModuleStatus::INITIALIZED);
  status = Start();
  if (!status.ok()) {
    AERROR &lt;&lt; Name() &lt;&lt; " Start failed: " &lt;&lt; status;
    ReportModuleStatus(apollo::hmi::ModuleStatus::STOPPED);
    return -2;
  }
  ReportModuleStatus(apollo::hmi::ModuleStatus::STARTED);
  spinner.start();
  ros::waitForShutdown();
  Stop();
  ReportModuleStatus(apollo::hmi::ModuleStatus::STOPPED);
  AINFO &lt;&lt; Name() &lt;&lt; " exited.";
  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\apollo_app.cc" startLine="(38, 0)" endLine="(60, 1)" clone_start="3" clone_end="9">
			<code function_name="ApolloApp::Spin()">int ApolloApp::Spin() {
  ros::AsyncSpinner spinner(1);
  auto status = Init();
  if (!status.ok()) {
    AERROR &lt;&lt; Name() &lt;&lt; " Init failed: " &lt;&lt; status;
    ReportModuleStatus(apollo::hmi::ModuleStatus::UNINITIALIZED);
    return -1;
  }
  ReportModuleStatus(apollo::hmi::ModuleStatus::INITIALIZED);
  status = Start();
  if (!status.ok()) {
    AERROR &lt;&lt; Name() &lt;&lt; " Start failed: " &lt;&lt; status;
    ReportModuleStatus(apollo::hmi::ModuleStatus::STOPPED);
    return -2;
  }
  ReportModuleStatus(apollo::hmi::ModuleStatus::STARTED);
  spinner.start();
  ros::waitForShutdown();
  Stop();
  ReportModuleStatus(apollo::hmi::ModuleStatus::STOPPED);
  AINFO &lt;&lt; Name() &lt;&lt; " exited.";
  return 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_kernel.cc" startLine="(79, 0)" endLine="(127, 1)" clone_start="32" clone_end="38">
			<code function_name="PiecewiseLinearKernel::AddThirdOrderDerivativeMatrix(const double weight)">void PiecewiseLinearKernel::AddThirdOrderDerivativeMatrix(const double weight) {
  Eigen::MatrixXd jerk_matrix = Eigen::MatrixXd::Zero(dimension_, dimension_);
  for (std::size_t i = 0; i &lt; dimension_; ++i) {
    if (i == 1) {
      jerk_matrix(i, i) += 1.0;
    } else if (i == 2) {
      jerk_matrix(i - 1, i - 1) += 9.0;
      jerk_matrix(i, i) += 1.0;

      jerk_matrix(i - 1, i) += -3.0;
      jerk_matrix(i, i - 1) += -3.0;
    } else if (i == 3) {
      jerk_matrix(i - 2, i - 2) += 9.0;
      jerk_matrix(i - 1, i - 1) += 9.0;
      jerk_matrix(i, i) += 1.0;

      jerk_matrix(i - 1, i) += -3.0;
      jerk_matrix(i, i - 1) += -3.0;
      jerk_matrix(i - 2, i) += 3.0;
      jerk_matrix(i, i - 2) += 3.0;

      jerk_matrix(i - 2, i - 1) += -9.0;
      jerk_matrix(i - 1, i - 2) += -9.0;
    } else {
      jerk_matrix(i - 3, i - 3) += 1.0;
      jerk_matrix(i - 2, i - 2) += 9.0;
      jerk_matrix(i - 1, i - 1) += 9.0;
      jerk_matrix(i, i) += 1.0;

      jerk_matrix(i - 1, i) += -3.0;
      jerk_matrix(i, i - 1) += -3.0;
      jerk_matrix(i - 2, i) += 3.0;
      jerk_matrix(i, i - 2) += 3.0;
      jerk_matrix(i - 3, i) += -1.0;
      jerk_matrix(i, i - 3) += -1.0;

      jerk_matrix(i - 2, i - 1) += -9.0;
      jerk_matrix(i - 1, i - 2) += -9.0;
      jerk_matrix(i - 3, i - 1) += 3.0;
      jerk_matrix(i - 1, i - 3) += 3.0;

      jerk_matrix(i - 3, i - 2) += -3.0;
      jerk_matrix(i - 2, i - 3) += -3.0;
    }
  }

  jerk_matrix *= 2.0 * weight / std::pow(unit_segment_, 4);
  kernel_matrix_ += jerk_matrix;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_kernel.cc" startLine="(79, 0)" endLine="(127, 1)" clone_start="17" clone_end="23">
			<code function_name="PiecewiseLinearKernel::AddThirdOrderDerivativeMatrix(const double weight)">void PiecewiseLinearKernel::AddThirdOrderDerivativeMatrix(const double weight) {
  Eigen::MatrixXd jerk_matrix = Eigen::MatrixXd::Zero(dimension_, dimension_);
  for (std::size_t i = 0; i &lt; dimension_; ++i) {
    if (i == 1) {
      jerk_matrix(i, i) += 1.0;
    } else if (i == 2) {
      jerk_matrix(i - 1, i - 1) += 9.0;
      jerk_matrix(i, i) += 1.0;

      jerk_matrix(i - 1, i) += -3.0;
      jerk_matrix(i, i - 1) += -3.0;
    } else if (i == 3) {
      jerk_matrix(i - 2, i - 2) += 9.0;
      jerk_matrix(i - 1, i - 1) += 9.0;
      jerk_matrix(i, i) += 1.0;

      jerk_matrix(i - 1, i) += -3.0;
      jerk_matrix(i, i - 1) += -3.0;
      jerk_matrix(i - 2, i) += 3.0;
      jerk_matrix(i, i - 2) += 3.0;

      jerk_matrix(i - 2, i - 1) += -9.0;
      jerk_matrix(i - 1, i - 2) += -9.0;
    } else {
      jerk_matrix(i - 3, i - 3) += 1.0;
      jerk_matrix(i - 2, i - 2) += 9.0;
      jerk_matrix(i - 1, i - 1) += 9.0;
      jerk_matrix(i, i) += 1.0;

      jerk_matrix(i - 1, i) += -3.0;
      jerk_matrix(i, i - 1) += -3.0;
      jerk_matrix(i - 2, i) += 3.0;
      jerk_matrix(i, i - 2) += 3.0;
      jerk_matrix(i - 3, i) += -1.0;
      jerk_matrix(i, i - 3) += -1.0;

      jerk_matrix(i - 2, i - 1) += -9.0;
      jerk_matrix(i - 1, i - 2) += -9.0;
      jerk_matrix(i - 3, i - 1) += 3.0;
      jerk_matrix(i - 1, i - 3) += 3.0;

      jerk_matrix(i - 3, i - 2) += -3.0;
      jerk_matrix(i - 2, i - 3) += -3.0;
    }
  }

  jerk_matrix *= 2.0 * weight / std::pow(unit_segment_, 4);
  kernel_matrix_ += jerk_matrix;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\strategy\a_star_strategy.cc" startLine="(174, 0)" endLine="(187, 1)" clone_start="5" clone_end="11">
			<code function_name="AdjustLaneChange(std::vector&lt;const TopoNode*&gt;* const result_node_vec)">bool AdjustLaneChange(std::vector&lt;const TopoNode*&gt;* const result_node_vec) {
  if (result_node_vec-&gt;size() &lt; 3) {
    return true;
  }
  if (!AdjustLaneChangeBackward(result_node_vec)) {
    AERROR &lt;&lt; "Failed to adjust lane change backward";
    return false;
  }
  if (!AdjustLaneChangeForward(result_node_vec)) {
    AERROR &lt;&lt; "Failed to adjust lane change backward";
    return false;
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_graph.cc" startLine="(71, 0)" endLine="(87, 1)" clone_start="7" clone_end="13">
			<code function_name="TopoGraph::LoadGraph(const Graph&amp; graph)">bool TopoGraph::LoadGraph(const Graph&amp; graph) {
  Clear();

  map_version_ = graph.hdmap_version();
  map_district_ = graph.hdmap_district();

  if (!LoadNodes(graph)) {
    AERROR &lt;&lt; "Failed to load nodes from topology graph.";
    return false;
  }
  if (!LoadEdges(graph)) {
    AERROR &lt;&lt; "Failed to load edges from topology graph.";
    return false;
  }
  AINFO &lt;&lt; "Load Topo data succesful.";
  return true;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\routing.h" startLine="(63, 2)" endLine="(63, 31)" clone_start="1" clone_end="1">
			<code function_name="~Routing()">  virtual ~Routing() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\dreamview.h" startLine="(44, 2)" endLine="(44, 33)" clone_start="1" clone_end="1">
			<code function_name="~Dreamview()">  virtual ~Dreamview() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\control.h" startLine="(80, 2)" endLine="(80, 31)" clone_start="1" clone_end="1">
			<code function_name="~Control()">  virtual ~Control() = default;</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.cc" startLine="(414, 0)" endLine="(461, 1)" clone_start="38" clone_end="47">
			<code function_name="Path::GetProjection(const Vec2d&amp; point, double* accumulate_s, double* lateral, double* min_distance) const">bool Path::GetProjection(const Vec2d&amp; point, double* accumulate_s,
                         double* lateral, double* min_distance) const {
  if (segments_.empty()) {
    return false;
  }
  if (accumulate_s == nullptr || lateral == nullptr ||
      min_distance == nullptr) {
    return false;
  }
  if (use_path_approximation_) {
    return approximation_.GetProjection(*this, point, accumulate_s, lateral,
                                        min_distance);
  }
  CHECK_GE(num_points_, 2);
  *min_distance = std::numeric_limits&lt;double&gt;::infinity();

  for (int i = 0; i &lt; num_segments_; ++i) {
    const auto&amp; segment = segments_[i];
    const double distance = segment.DistanceTo(point);
    if (distance &lt; *min_distance) {
      const double proj = segment.ProjectOntoUnit(point);
      if (proj &lt; 0.0 &amp;&amp; i &gt; 0) {
        continue;
      }
      if (proj &gt; segment.length() &amp;&amp; i + 1 &lt; num_segments_) {
        const auto&amp; next_segment = segments_[i + 1];
        if ((point - next_segment.start())
                .InnerProd(next_segment.unit_direction()) &gt;= 0.0) {
          continue;
        }
      }
      *min_distance = distance;
      if (i + 1 &gt;= num_segments_) {
        *accumulate_s = accumulated_s_[i] + proj;
      } else {
        *accumulate_s = accumulated_s_[i] + std::min(proj, segment.length());
      }
      const double prod = segment.ProductOntoUnit(point);
      if ((i == 0 &amp;&amp; proj &lt; 0.0) ||
          (i + 1 == num_segments_ &amp;&amp; proj &gt; segment.length())) {
        *lateral = prod;
      } else {
        *lateral = (prod &gt; 0.0 ? distance : -distance);
      }
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.cc" startLine="(332, 0)" endLine="(381, 1)" clone_start="41" clone_end="49">
			<code function_name="LaneInfo::GetProjection(const Vec2d &amp;point, double *accumulate_s, double *lateral) const">bool LaneInfo::GetProjection(const Vec2d &amp;point, double *accumulate_s,
                             double *lateral) const {
  CHECK_NOTNULL(accumulate_s);
  CHECK_NOTNULL(lateral);

  if (segments_.empty()) {
    return false;
  }
  double min_distance = std::numeric_limits&lt;double&gt;::infinity();
  std::size_t min_index = 0;
  double min_proj = 0.0;
  std::size_t num_segments = segments_.size();
  for (std::size_t i = 0; i &lt; num_segments; ++i) {
    const auto &amp;segment = segments_[i];
    const double distance = segment.DistanceTo(point);
    if (distance &lt; min_distance) {
      const double proj = segment.ProjectOntoUnit(point);
      if (proj &lt; 0.0 &amp;&amp; i &gt; 0) {
        continue;
      }
      if (proj &gt; segment.length() &amp;&amp; i + 1 &lt; num_segments) {
        const auto &amp;next_segment = segments_[i + 1];
        if ((point - next_segment.start())
                .InnerProd(next_segment.unit_direction()) &gt;= 0.0) {
          continue;
        }
      }
      min_distance = distance;
      min_index = i;
      min_proj = proj;
    }
  }

  const auto &amp;segment = segments_[min_index];
  if (min_index + 1 &gt;= num_segments) {
    *accumulate_s = accumulated_s_[min_index] + min_proj;
  } else {
    *accumulate_s =
        accumulated_s_[min_index] + std::min(min_proj, segment.length());
  }
  const double prod = segment.ProductOntoUnit(point);
  if ((min_index == 0 &amp;&amp; min_proj &lt; 0.0) ||
      (min_index + 1 == num_segments &amp;&amp; min_proj &gt; segment.length())) {
    *lateral = prod;
  } else {
    *lateral = (prod &gt; 0.0 ? min_distance : -min_distance);
  }

  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\curve1d\quintic_polynomial_curve1d.h" startLine="(35, 2)" endLine="(35, 39)" clone_start="1" clone_end="1">
			<code function_name="QuinticPolynomialCurve1d()">  QuinticPolynomialCurve1d() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\curve1d\quartic_polynomial_curve1d.h" startLine="(34, 2)" endLine="(34, 39)" clone_start="1" clone_end="1">
			<code function_name="QuarticPolynomialCurve1d()">  QuarticPolynomialCurve1d() = default;</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\roi_filter\hdmap_roi_filter\hdmap_roi_filter.cc" startLine="(155, 0)" endLine="(177, 1)" clone_start="13" clone_end="19">
			<code function_name="HdmapROIFilter::Init()">bool HdmapROIFilter::Init() {
  // load model config
  std::string model_name = name();
  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(model_name, &amp;model_config)) {
    AERROR &lt;&lt; "Failed to get model: " &lt;&lt; model_name;
    return false;
  } else {
    if (!model_config-&gt;GetValue("range", &amp;range_)) {
      AERROR &lt;&lt; "Can not find range in model: " &lt;&lt; model_name;
      return false;
    }
    if (!model_config-&gt;GetValue("cell_size", &amp;cell_size_)) {
      AERROR &lt;&lt; "Can not find cell_size in model: " &lt;&lt; model_name;
      return false;
    }
    if (!model_config-&gt;GetValue("extend_dist", &amp;extend_dist_)) {
      AERROR &lt;&lt; "Can not find extend_dist_ in model: " &lt;&lt; model_name;
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\roi_filter\hdmap_roi_filter\hdmap_roi_filter.cc" startLine="(155, 0)" endLine="(177, 1)" clone_start="9" clone_end="15">
			<code function_name="HdmapROIFilter::Init()">bool HdmapROIFilter::Init() {
  // load model config
  std::string model_name = name();
  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(model_name, &amp;model_config)) {
    AERROR &lt;&lt; "Failed to get model: " &lt;&lt; model_name;
    return false;
  } else {
    if (!model_config-&gt;GetValue("range", &amp;range_)) {
      AERROR &lt;&lt; "Can not find range in model: " &lt;&lt; model_name;
      return false;
    }
    if (!model_config-&gt;GetValue("cell_size", &amp;cell_size_)) {
      AERROR &lt;&lt; "Can not find cell_size in model: " &lt;&lt; model_name;
      return false;
    }
    if (!model_config-&gt;GetValue("extend_dist", &amp;extend_dist_)) {
      AERROR &lt;&lt; "Can not find extend_dist_ in model: " &lt;&lt; model_name;
      return false;
    }
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(146, 0)" endLine="(146, 70)" clone_start="1" clone_end="1">
			<code function_name="Spline2d::spline_order() const">std::uint32_t Spline2d::spline_order() const { return spline_order_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d.cc" startLine="(101, 0)" endLine="(101, 70)" clone_start="1" clone_end="1">
			<code function_name="Spline1d::spline_order() const">std::uint32_t Spline1d::spline_order() const { return spline_order_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(148, 0)" endLine="(153, 1)" clone_start="1" clone_end="5">
			<code function_name="Spline2d::find_index(const double t) const">std::uint32_t Spline2d::find_index(const double t) const {
  auto upper_bound = std::upper_bound(t_knots_.begin() + 1, t_knots_.end(), t);
  return std::min(static_cast&lt;std::uint32_t&gt;(t_knots_.size() - 1),
                  static_cast&lt;std::uint32_t&gt;(upper_bound - t_knots_.begin())) -
         1;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d.cc" startLine="(103, 0)" endLine="(108, 1)" clone_start="1" clone_end="5">
			<code function_name="Spline1d::FindIndex(const double x) const">std::uint32_t Spline1d::FindIndex(const double x) const {
  auto upper_bound = std::upper_bound(x_knots_.begin() + 1, x_knots_.end(), x);
  return std::min(static_cast&lt;std::uint32_t&gt;(x_knots_.size() - 1),
                  static_cast&lt;std::uint32_t&gt;(upper_bound - x_knots_.begin())) -
         1;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(28, 0)" endLine="(53, 1)" clone_start="10" clone_end="20">
			<code function_name="Wheelspeed6a::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Wheelspeed6a::Parse(const std::uint8_t *bytes, int32_t length,
                         ChassisDetail *chassis_detail) const {
  // how to set direction
  // what is "valid"
  // front left
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_fl(
      front_left_wheel_speed(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_fl_valid(true);
  // front right
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_fr(
      front_right_wheel_speed(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_fr_valid(true);
  // rear left
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_rl(
      rear_left_wheel_speed(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_rl_valid(true);
  // rear right
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_rr(
      rear_right_wheel_speed(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_rr_valid(true);
  /*
  -?(rr(bytes, length));
  -?(rl(bytes, length));
  -?(fr(bytes, length));
  -?(fl(bytes, length));*/
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(28, 0)" endLine="(53, 1)" clone_start="6" clone_end="16">
			<code function_name="Wheelspeed6a::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Wheelspeed6a::Parse(const std::uint8_t *bytes, int32_t length,
                         ChassisDetail *chassis_detail) const {
  // how to set direction
  // what is "valid"
  // front left
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_fl(
      front_left_wheel_speed(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_fl_valid(true);
  // front right
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_fr(
      front_right_wheel_speed(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_fr_valid(true);
  // rear left
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_rl(
      rear_left_wheel_speed(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_rl_valid(true);
  // rear right
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_rr(
      rear_right_wheel_speed(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_rr_valid(true);
  /*
  -?(rr(bytes, length));
  -?(rl(bytes, length));
  -?(fr(bytes, length));
  -?(fl(bytes, length));*/
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\util_xml_parser.cc" startLine="(150, 0)" endLine="(178, 1)" clone_start="20" clone_end="25">
			<code function_name="UtilXmlParser::ParsePoint(const tinyxml2::XMLElement&amp; xml_node, PbPoint3D* pt)">Status UtilXmlParser::ParsePoint(const tinyxml2::XMLElement&amp; xml_node,
                                 PbPoint3D* pt) {
  CHECK_NOTNULL(pt);

  const auto sub_node = xml_node.FirstChildElement("centerPoint");
  CHECK(sub_node != nullptr);
  int checker = tinyxml2::XML_SUCCESS;
  double ptx = 0.0;
  double pty = 0.0;
  double ptz = 0.0;
  checker += sub_node-&gt;QueryDoubleAttribute("x", &amp;ptx);
  checker += sub_node-&gt;QueryDoubleAttribute("y", &amp;pty);
  checker += sub_node-&gt;QueryDoubleAttribute("z", &amp;ptz);

  if (checker != tinyxml2::XML_SUCCESS) {
    std::string err_msg = "Error parse point attributes";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  double output_x = 0.0;
  double output_y = 0.0;
  double output_z = 0.0;
  WGS84ToUTM(ptx, pty, ptz, &amp;output_x, &amp;output_y, &amp;output_z);
  pt-&gt;set_x(output_x);
  pt-&gt;set_y(output_y);
  pt-&gt;set_z(output_z);

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\util_xml_parser.cc" startLine="(117, 0)" endLine="(148, 1)" clone_start="20" clone_end="25">
			<code function_name="UtilXmlParser::ParseOutline(const tinyxml2::XMLElement&amp; xml_node, PbPolygon* polygon)">Status UtilXmlParser::ParseOutline(const tinyxml2::XMLElement&amp; xml_node,
                                   PbPolygon* polygon) {
  const tinyxml2::XMLElement* sub_node =
      xml_node.FirstChildElement("cornerGlobal");
  while (sub_node) {
    double ptx = 0.0;
    double pty = 0.0;
    double ptz = 0.0;
    int checker = tinyxml2::XML_SUCCESS;
    checker += sub_node-&gt;QueryDoubleAttribute("x", &amp;ptx);
    checker += sub_node-&gt;QueryDoubleAttribute("y", &amp;pty);
    checker += sub_node-&gt;QueryDoubleAttribute("z", &amp;ptz);

    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parsing cornerGlobal point attributes";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    PbPoint3D* pt = polygon-&gt;add_point();
    double output_x = 0.0;
    double output_y = 0.0;
    double output_z = 0.0;
    WGS84ToUTM(ptx, pty, ptz, &amp;output_x, &amp;output_y, &amp;output_z);
    pt-&gt;set_x(output_x);
    pt-&gt;set_y(output_y);
    // pt-&gt;set_z(output_z);

    sub_node = sub_node-&gt;NextSiblingElement("cornerGlobal");
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\util_xml_parser.cc" startLine="(87, 0)" endLine="(115, 1)" clone_start="18" clone_end="23">
			<code function_name="UtilXmlParser::ParsePointSet(const tinyxml2::XMLElement&amp; xml_node, PbLineSegment* line_segment)">Status UtilXmlParser::ParsePointSet(const tinyxml2::XMLElement&amp; xml_node,
                                    PbLineSegment* line_segment) {
  const tinyxml2::XMLElement* sub_node = xml_node.FirstChildElement("point");
  while (sub_node) {
    double ptx = 0.0;
    double pty = 0.0;
    double ptz = 0.0;
    int checker = tinyxml2::XML_SUCCESS;
    checker += sub_node-&gt;QueryDoubleAttribute("x", &amp;ptx);
    checker += sub_node-&gt;QueryDoubleAttribute("y", &amp;pty);

    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parsing geometry point attributes";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    PbPoint3D* pt = line_segment-&gt;add_point();
    double output_x = 0.0;
    double output_y = 0.0;
    double output_z = 0.0;
    WGS84ToUTM(ptx, pty, ptz, &amp;output_x, &amp;output_y, &amp;output_z);
    pt-&gt;set_x(output_x);
    pt-&gt;set_y(output_y);

    sub_node = sub_node-&gt;NextSiblingElement("point");
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\box2d.cc" startLine="(136, 0)" endLine="(150, 1)" clone_start="8" clone_end="15">
			<code function_name="Box2d::DistanceTo(const Vec2d &amp;point) const">double Box2d::DistanceTo(const Vec2d &amp;point) const {
  const double x0 = point.x() - center_.x();
  const double y0 = point.y() - center_.y();
  const double dx =
      std::abs(x0 * cos_heading_ + y0 * sin_heading_) - half_length_;
  const double dy =
      std::abs(x0 * sin_heading_ - y0 * cos_heading_) - half_width_;
  if (dx &lt;= 0.0) {
    return std::max(0.0, dy);
  }
  if (dy &lt;= 0.0) {
    return dx;
  }
  return hypot(dx, dy);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\aabox2d.cc" startLine="(100, 0)" endLine="(112, 1)" clone_start="6" clone_end="13">
			<code function_name="AABox2d::DistanceTo(const AABox2d &amp;box) const">double AABox2d::DistanceTo(const AABox2d &amp;box) const {
  const double dx =
      std::abs(box.center_x() - center_.x()) - box.half_length() - half_length_;
  const double dy =
      std::abs(box.center_y() - center_.y()) - box.half_width() - half_width_;
  if (dx &lt;= 0.0) {
    return std::max(0.0, dy);
  }
  if (dy &lt;= 0.0) {
    return dx;
  }
  return hypot(dx, dy);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\aabox2d.cc" startLine="(88, 0)" endLine="(98, 1)" clone_start="4" clone_end="11">
			<code function_name="AABox2d::DistanceTo(const Vec2d &amp;point) const">double AABox2d::DistanceTo(const Vec2d &amp;point) const {
  const double dx = std::abs(point.x() - center_.x()) - half_length_;
  const double dy = std::abs(point.y() - center_.y()) - half_width_;
  if (dx &lt;= 0.0) {
    return std::max(0.0, dy);
  }
  if (dy &lt;= 0.0) {
    return dx;
  }
  return hypot(dx, dy);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\box2d.cc" startLine="(152, 0)" endLine="(157, 1)" clone_start="1" clone_end="1">
			<code function_name="Box2d::HasOverlap(const LineSegment2d &amp;line_segment) const">bool Box2d::HasOverlap(const LineSegment2d &amp;line_segment) const {
  if (line_segment.length() &lt;= kMathEpsilon) {
    return IsPointIn(line_segment.start());
  }
  return DistanceTo(line_segment) &lt;= kMathEpsilon;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\aabox2d.cc" startLine="(114, 0)" endLine="(119, 1)" clone_start="1" clone_end="1">
			<code function_name="AABox2d::HasOverlap(const AABox2d &amp;box) const">bool AABox2d::HasOverlap(const AABox2d &amp;box) const {
  return std::abs(box.center_x() - center_.x()) &lt;=
             box.half_length() + half_length_ &amp;&amp;
         std::abs(box.center_y() - center_.y()) &lt;=
             box.half_width() + half_width_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\aabox2d.cc" startLine="(100, 0)" endLine="(112, 1)" clone_start="1" clone_end="1">
			<code function_name="AABox2d::DistanceTo(const AABox2d &amp;box) const">double AABox2d::DistanceTo(const AABox2d &amp;box) const {
  const double dx =
      std::abs(box.center_x() - center_.x()) - box.half_length() - half_length_;
  const double dy =
      std::abs(box.center_y() - center_.y()) - box.half_width() - half_width_;
  if (dx &lt;= 0.0) {
    return std::max(0.0, dy);
  }
  if (dy &lt;= 0.0) {
    return dx;
  }
  return hypot(dx, dy);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.cc" startLine="(49, 0)" endLine="(131, 1)" clone_start="22" clone_end="27">
			<code function_name="MinBoxObjectBuilder::ComputeAreaAlongOneEdge(ObjectPtr obj, size_t first_in_point, Eigen::Vector3d* center, double* lenth, double* width, Eigen::Vector3d* dir)">double MinBoxObjectBuilder::ComputeAreaAlongOneEdge(
        ObjectPtr obj,
        size_t first_in_point,
        Eigen::Vector3d* center,
        double* lenth, double* width, Eigen::Vector3d* dir) {
    std::vector&lt;Eigen::Vector3d&gt; ns;
    Eigen::Vector3d v(0.0, 0.0, 0.0);
    Eigen::Vector3d vn(0.0, 0.0, 0.0);
    Eigen::Vector3d n(0.0, 0.0, 0.0);
    double len = 0;
    double wid = 0;
    size_t index = (first_in_point + 1) % obj-&gt;polygon.points.size();
    for (size_t i = 0; i &lt; obj-&gt;polygon.points.size(); ++i) {
        if (i != first_in_point &amp;&amp; i != index) {
            // compute v
            Eigen::Vector3d o(0.0, 0.0, 0.0);
            Eigen::Vector3d a(0.0, 0.0, 0.0);
            Eigen::Vector3d b(0.0, 0.0, 0.0);
            o[0] = obj-&gt;polygon.points[i].x;
            o[1] = obj-&gt;polygon.points[i].y;
            o[2] = 0;
            b[0] = obj-&gt;polygon.points[first_in_point].x;
            b[1] = obj-&gt;polygon.points[first_in_point].y;
            b[2] = 0;
            a[0] = obj-&gt;polygon.points[index].x;
            a[1] = obj-&gt;polygon.points[index].y;
            a[2] = 0;
            double k = ((a[0] - o[0]) * (b[0] - a[0]) +
                         (a[1] - o[1]) * (b[1] - a[1]));
            k = k / ((b[0] - a[0]) * (b[0] - a[0]) +
                    (b[1] - a[1]) * (b[1] - a[1]));
            k = k * -1;
            // n is pedal of src
            n[0] = (b[0] - a[0]) * k + a[0];
            n[1] = (b[1] - a[1]) * k + a[1];
            n[2] = 0;
            // compute height from src to line
            Eigen::Vector3d edge1 = o - b;
            Eigen::Vector3d edge2 = a - b;
            // cross product
            double height = fabs(edge1[0] * edge2[1] - edge2[0] * edge1[1]);
            height = height / sqrt(edge2[0] * edge2[0] + edge2[1] * edge2[1]);
            if (height &gt; wid) {
                wid = height;
                v = o;
                vn = n;
            }
        } else {
            n[0] = obj-&gt;polygon.points[i].x;
            n[1] = obj-&gt;polygon.points[i].y;
            n[2] = 0;
        }
        ns.push_back(n);
    }
    size_t point_num1 = 0;
    size_t point_num2 = 0;
    for (size_t i = 0; i &lt; ns.size() - 1; ++i) {
        Eigen::Vector3d p1 = ns[i];
        for (size_t j = i + 1; j &lt; ns.size(); ++j) {
            Eigen::Vector3d p2 = ns[j];
            double dist =
                    sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) +
                         (p1[1] - p2[1]) * (p1[1] - p2[1]));
            if (dist &gt; len) {
                len = dist;
                point_num1 = i;
                point_num2 = j;
            }
        }
    }
    Eigen::Vector3d vp1 = v + ns[point_num1] - vn;
    Eigen::Vector3d vp2 = v + ns[point_num2] - vn;
    (*center) = (vp1 + vp2 + ns[point_num1] + ns[point_num2]) / 4;
    (*center)[2] = obj-&gt;polygon.points[0].z;
    if (len &gt; wid) {
        *dir = ns[point_num2] - ns[point_num1];
    } else {
        *dir = vp1 - ns[point_num1];
    }
    *lenth = len &gt; wid ? len : wid;
    *width = len &gt; wid ? wid : len;
    return (*lenth) * (*width);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.cc" startLine="(49, 0)" endLine="(131, 1)" clone_start="19" clone_end="24">
			<code function_name="MinBoxObjectBuilder::ComputeAreaAlongOneEdge(ObjectPtr obj, size_t first_in_point, Eigen::Vector3d* center, double* lenth, double* width, Eigen::Vector3d* dir)">double MinBoxObjectBuilder::ComputeAreaAlongOneEdge(
        ObjectPtr obj,
        size_t first_in_point,
        Eigen::Vector3d* center,
        double* lenth, double* width, Eigen::Vector3d* dir) {
    std::vector&lt;Eigen::Vector3d&gt; ns;
    Eigen::Vector3d v(0.0, 0.0, 0.0);
    Eigen::Vector3d vn(0.0, 0.0, 0.0);
    Eigen::Vector3d n(0.0, 0.0, 0.0);
    double len = 0;
    double wid = 0;
    size_t index = (first_in_point + 1) % obj-&gt;polygon.points.size();
    for (size_t i = 0; i &lt; obj-&gt;polygon.points.size(); ++i) {
        if (i != first_in_point &amp;&amp; i != index) {
            // compute v
            Eigen::Vector3d o(0.0, 0.0, 0.0);
            Eigen::Vector3d a(0.0, 0.0, 0.0);
            Eigen::Vector3d b(0.0, 0.0, 0.0);
            o[0] = obj-&gt;polygon.points[i].x;
            o[1] = obj-&gt;polygon.points[i].y;
            o[2] = 0;
            b[0] = obj-&gt;polygon.points[first_in_point].x;
            b[1] = obj-&gt;polygon.points[first_in_point].y;
            b[2] = 0;
            a[0] = obj-&gt;polygon.points[index].x;
            a[1] = obj-&gt;polygon.points[index].y;
            a[2] = 0;
            double k = ((a[0] - o[0]) * (b[0] - a[0]) +
                         (a[1] - o[1]) * (b[1] - a[1]));
            k = k / ((b[0] - a[0]) * (b[0] - a[0]) +
                    (b[1] - a[1]) * (b[1] - a[1]));
            k = k * -1;
            // n is pedal of src
            n[0] = (b[0] - a[0]) * k + a[0];
            n[1] = (b[1] - a[1]) * k + a[1];
            n[2] = 0;
            // compute height from src to line
            Eigen::Vector3d edge1 = o - b;
            Eigen::Vector3d edge2 = a - b;
            // cross product
            double height = fabs(edge1[0] * edge2[1] - edge2[0] * edge1[1]);
            height = height / sqrt(edge2[0] * edge2[0] + edge2[1] * edge2[1]);
            if (height &gt; wid) {
                wid = height;
                v = o;
                vn = n;
            }
        } else {
            n[0] = obj-&gt;polygon.points[i].x;
            n[1] = obj-&gt;polygon.points[i].y;
            n[2] = 0;
        }
        ns.push_back(n);
    }
    size_t point_num1 = 0;
    size_t point_num2 = 0;
    for (size_t i = 0; i &lt; ns.size() - 1; ++i) {
        Eigen::Vector3d p1 = ns[i];
        for (size_t j = i + 1; j &lt; ns.size(); ++j) {
            Eigen::Vector3d p2 = ns[j];
            double dist =
                    sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) +
                         (p1[1] - p2[1]) * (p1[1] - p2[1]));
            if (dist &gt; len) {
                len = dist;
                point_num1 = i;
                point_num2 = j;
            }
        }
    }
    Eigen::Vector3d vp1 = v + ns[point_num1] - vn;
    Eigen::Vector3d vp2 = v + ns[point_num2] - vn;
    (*center) = (vp1 + vp2 + ns[point_num1] + ns[point_num2]) / 4;
    (*center)[2] = obj-&gt;polygon.points[0].z;
    if (len &gt; wid) {
        *dir = ns[point_num2] - ns[point_num1];
    } else {
        *dir = vp1 - ns[point_num1];
    }
    *lenth = len &gt; wid ? len : wid;
    *width = len &gt; wid ? wid : len;
    return (*lenth) * (*width);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\interface\base_segmentation.h" startLine="(78, 2)" endLine="(78, 23)" clone_start="1" clone_end="1">
			<code function_name="BaseSegmentation()">  BaseSegmentation() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\interface\base_object_builder.h" startLine="(71, 2)" endLine="(71, 24)" clone_start="1" clone_end="1">
			<code function_name="BaseObjectBuilder()">  BaseObjectBuilder() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\interface\base_ground_detector.h" startLine="(80, 2)" endLine="(80, 25)" clone_start="1" clone_end="1">
			<code function_name="BaseGroundDetector()">  BaseGroundDetector() {}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\interface\base_segmentation.h" startLine="(79, 2)" endLine="(79, 32)" clone_start="1" clone_end="1">
			<code function_name="~BaseSegmentation()">  virtual ~BaseSegmentation() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\interface\base_object_builder.h" startLine="(72, 2)" endLine="(72, 33)" clone_start="1" clone_end="1">
			<code function_name="~BaseObjectBuilder()">  virtual ~BaseObjectBuilder() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\interface\base_ground_detector.h" startLine="(81, 2)" endLine="(81, 34)" clone_start="1" clone_end="1">
			<code function_name="~BaseGroundDetector()">  virtual ~BaseGroundDetector() {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\path_obstacle.cc" startLine="(337, 0)" endLine="(349, 1)" clone_start="7" clone_end="12">
			<code function_name="PathObstacle::AddLateralDecision(const std::string&amp; decider_tag, const ObjectDecisionType&amp; decision)">void PathObstacle::AddLateralDecision(const std::string&amp; decider_tag,
                                      const ObjectDecisionType&amp; decision) {
  DCHECK(IsLateralDecision(decision))
      &lt;&lt; "Decision: " &lt;&lt; decision.ShortDebugString()
      &lt;&lt; " is not a lateral decision";
  lateral_decision_ = MergeLateralDecision(lateral_decision_, decision);
  ADEBUG &lt;&lt; decider_tag &lt;&lt; " added obstacle " &lt;&lt; Id()
         &lt;&lt; " a lateral decision: " &lt;&lt; decision.ShortDebugString()
         &lt;&lt; ". The merged decision is: "
         &lt;&lt; lateral_decision_.ShortDebugString();
  decisions_.push_back(decision);
  decider_tags_.push_back(decider_tag);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\path_obstacle.cc" startLine="(322, 0)" endLine="(335, 1)" clone_start="8" clone_end="13">
			<code function_name="PathObstacle::AddLongitudinalDecision(const std::string&amp; decider_tag, const ObjectDecisionType&amp; decision)">void PathObstacle::AddLongitudinalDecision(const std::string&amp; decider_tag,
                                           const ObjectDecisionType&amp; decision) {
  DCHECK(IsLongitudinalDecision(decision))
      &lt;&lt; "Decision: " &lt;&lt; decision.ShortDebugString()
      &lt;&lt; " is not a longitudinal decision";
  longitudinal_decision_ =
      MergeLongitudinalDecision(longitudinal_decision_, decision);
  ADEBUG &lt;&lt; decider_tag &lt;&lt; " added obstacle " &lt;&lt; Id()
         &lt;&lt; " a longitudinal decision: " &lt;&lt; decision.ShortDebugString()
         &lt;&lt; ". The merged decision is: "
         &lt;&lt; longitudinal_decision_.ShortDebugString();
  decisions_.push_back(decision);
  decider_tags_.push_back(decider_tag);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\strategy\a_star_strategy.cc" startLine="(218, 0)" endLine="(224, 1)" clone_start="1" clone_end="6">
			<code function_name="AStarStrategy::Clear()">void AStarStrategy::Clear() {
  closed_set_.clear();
  open_set_.clear();
  came_from_.clear();
  enter_s_.clear();
  g_score_.clear();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(587, 0)" endLine="(608, 1)" clone_start="1" clone_end="6">
			<code function_name="HDMapImpl::Clear()">void HDMapImpl::Clear() {
  map_.Clear();
  lane_table_.clear();
  junction_table_.clear();
  signal_table_.clear();
  crosswalk_table_.clear();
  stop_sign_table_.clear();
  yield_sign_table_.clear();
  overlap_table_.clear();
  lane_segment_boxes_.clear();
  lane_segment_kdtree_.reset(nullptr);
  junction_polygon_boxes_.clear();
  junction_polygon_kdtree_.reset(nullptr);
  crosswalk_polygon_boxes_.clear();
  crosswalk_polygon_kdtree_.reset(nullptr);
  signal_segment_boxes_.clear();
  signal_segment_kdtree_.reset(nullptr);
  stop_sign_segment_boxes_.clear();
  stop_sign_segment_kdtree_.reset(nullptr);
  yield_sign_segment_boxes_.clear();
  yield_sign_segment_kdtree_.reset(nullptr);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\control.h" startLine="(53, 2)" endLine="(53, 79)" clone_start="1" clone_end="1">
			<code function_name="Control()">  Control() : monitor_(apollo::common::monitor::MonitorMessageItem::CONTROL) {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\canbus.h" startLine="(57, 2)" endLine="(57, 77)" clone_start="1" clone_end="1">
			<code function_name="Canbus()">  Canbus() : monitor_(apollo::common::monitor::MonitorMessageItem::CANBUS) {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(338, 0)" endLine="(380, 1)" clone_start="36" clone_end="41">
			<code function_name="ProtoOrganizer::OutputData(apollo::hdmap::Map* pb_map)">void ProtoOrganizer::OutputData(apollo::hdmap::Map* pb_map) {
  for (auto&amp; road_pair : proto_data_.pb_roads) {
    *(pb_map-&gt;add_road()) = road_pair.second;
  }
  for (auto&amp; lane_pair : proto_data_.pb_lanes) {
    *(pb_map-&gt;add_lane()) = lane_pair.second;
  }
  for (auto&amp; crosswalk_pair : proto_data_.pb_crosswalks) {
    *(pb_map-&gt;add_crosswalk()) = crosswalk_pair.second;
  }
  for (auto&amp; clear_area_pair : proto_data_.pb_clear_areas) {
    *(pb_map-&gt;add_clear_area()) = clear_area_pair.second;
  }
  for (auto&amp; speed_bump_pair : proto_data_.pb_speed_bumps) {
    *(pb_map-&gt;add_speed_bump()) = speed_bump_pair.second;
  }
  for (auto&amp; signal_pair : proto_data_.pb_signals) {
    *(pb_map-&gt;add_signal()) = signal_pair.second;
  }
  for (auto&amp; stop_sign_pair : proto_data_.pb_stop_signs) {
    *(pb_map-&gt;add_stop_sign()) = stop_sign_pair.second;
  }
  for (auto&amp; yield_sign_pair : proto_data_.pb_yield_signs) {
    *(pb_map-&gt;add_yield()) = yield_sign_pair.second;
  }
  for (auto&amp; junction_pair : proto_data_.pb_junctions) {
    *(pb_map-&gt;add_junction()) = junction_pair.second;
  }
  for (auto&amp; overlap_pair : proto_data_.pb_overlaps) {
    *(pb_map-&gt;add_overlap()) = overlap_pair.second;
  }

  AINFO &lt;&lt; "hdmap statistics: roads-" &lt;&lt; proto_data_.pb_roads.size()
        &lt;&lt; ",lanes-" &lt;&lt; proto_data_.pb_lanes.size() &lt;&lt; ",crosswalks-"
        &lt;&lt; proto_data_.pb_crosswalks.size() &lt;&lt; ",clear areas-"
        &lt;&lt; proto_data_.pb_clear_areas.size() &lt;&lt; ",speed bumps-"
        &lt;&lt; proto_data_.pb_speed_bumps.size() &lt;&lt; ",signals-"
        &lt;&lt; proto_data_.pb_signals.size() &lt;&lt; ",stop signs-"
        &lt;&lt; proto_data_.pb_stop_signs.size() &lt;&lt; ",yield signs-"
        &lt;&lt; proto_data_.pb_yield_signs.size() &lt;&lt; ",junctions-"
        &lt;&lt; proto_data_.pb_junctions.size() &lt;&lt; ",overlaps-"
        &lt;&lt; proto_data_.pb_overlaps.size();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(338, 0)" endLine="(380, 1)" clone_start="35" clone_end="40">
			<code function_name="ProtoOrganizer::OutputData(apollo::hdmap::Map* pb_map)">void ProtoOrganizer::OutputData(apollo::hdmap::Map* pb_map) {
  for (auto&amp; road_pair : proto_data_.pb_roads) {
    *(pb_map-&gt;add_road()) = road_pair.second;
  }
  for (auto&amp; lane_pair : proto_data_.pb_lanes) {
    *(pb_map-&gt;add_lane()) = lane_pair.second;
  }
  for (auto&amp; crosswalk_pair : proto_data_.pb_crosswalks) {
    *(pb_map-&gt;add_crosswalk()) = crosswalk_pair.second;
  }
  for (auto&amp; clear_area_pair : proto_data_.pb_clear_areas) {
    *(pb_map-&gt;add_clear_area()) = clear_area_pair.second;
  }
  for (auto&amp; speed_bump_pair : proto_data_.pb_speed_bumps) {
    *(pb_map-&gt;add_speed_bump()) = speed_bump_pair.second;
  }
  for (auto&amp; signal_pair : proto_data_.pb_signals) {
    *(pb_map-&gt;add_signal()) = signal_pair.second;
  }
  for (auto&amp; stop_sign_pair : proto_data_.pb_stop_signs) {
    *(pb_map-&gt;add_stop_sign()) = stop_sign_pair.second;
  }
  for (auto&amp; yield_sign_pair : proto_data_.pb_yield_signs) {
    *(pb_map-&gt;add_yield()) = yield_sign_pair.second;
  }
  for (auto&amp; junction_pair : proto_data_.pb_junctions) {
    *(pb_map-&gt;add_junction()) = junction_pair.second;
  }
  for (auto&amp; overlap_pair : proto_data_.pb_overlaps) {
    *(pb_map-&gt;add_overlap()) = overlap_pair.second;
  }

  AINFO &lt;&lt; "hdmap statistics: roads-" &lt;&lt; proto_data_.pb_roads.size()
        &lt;&lt; ",lanes-" &lt;&lt; proto_data_.pb_lanes.size() &lt;&lt; ",crosswalks-"
        &lt;&lt; proto_data_.pb_crosswalks.size() &lt;&lt; ",clear areas-"
        &lt;&lt; proto_data_.pb_clear_areas.size() &lt;&lt; ",speed bumps-"
        &lt;&lt; proto_data_.pb_speed_bumps.size() &lt;&lt; ",signals-"
        &lt;&lt; proto_data_.pb_signals.size() &lt;&lt; ",stop signs-"
        &lt;&lt; proto_data_.pb_stop_signs.size() &lt;&lt; ",yield signs-"
        &lt;&lt; proto_data_.pb_yield_signs.size() &lt;&lt; ",junctions-"
        &lt;&lt; proto_data_.pb_junctions.size() &lt;&lt; ",overlaps-"
        &lt;&lt; proto_data_.pb_overlaps.size();
}</code>
		</source>
	</dup>
	<dup count="7">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\evaluator\vehicle\mlp_evaluator.h" startLine="(43, 2)" endLine="(43, 36)" clone_start="1" clone_end="1">
			<code function_name="~MLPEvaluator()">  virtual ~MLPEvaluator() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacles_container.h" startLine="(44, 2)" endLine="(44, 42)" clone_start="1" clone_end="1">
			<code function_name="~ObstaclesContainer()">  virtual ~ObstaclesContainer() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\traffic_decider\back_side_vehicles.h" startLine="(33, 2)" endLine="(33, 40)" clone_start="1" clone_end="1">
			<code function_name="~BackSideVehicles()">  virtual ~BackSideVehicles() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\path_decider\path_decider.h" startLine="(33, 2)" endLine="(33, 27)" clone_start="1" clone_end="1">
			<code function_name="~PathDecider()">  ~PathDecider() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\planner\rtk\rtk_replay_planner.h" startLine="(51, 2)" endLine="(51, 40)" clone_start="1" clone_end="1">
			<code function_name="~RTKReplayPlanner()">  virtual ~RTKReplayPlanner() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\rtk\rtk_localization.h" startLine="(56, 2)" endLine="(56, 39)" clone_start="1" clone_end="1">
			<code function_name="~RTKLocalization()">  virtual ~RTKLocalization() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\camera\camera_localization.h" startLine="(58, 2)" endLine="(58, 42)" clone_start="1" clone_end="1">
			<code function_name="~CameraLocalization()">  virtual ~CameraLocalization() = default;</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(178, 0)" endLine="(178, 76)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::set_heading(const double heading)">void VehicleState::set_heading(const double heading) { heading_ = heading; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(145, 0)" endLine="(145, 79)" clone_start="1" clone_end="1">
			<code function_name="ActiveSetQpSolver::set_qp_eps_den(const double eps)">void ActiveSetQpSolver::set_qp_eps_den(const double eps) { qp_eps_den_ = eps; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(180, 0)" endLine="(182, 1)" clone_start="1" clone_end="3">
			<code function_name="VehicleState::set_linear_velocity(const double linear_velocity)">void VehicleState::set_linear_velocity(const double linear_velocity) {
  linear_v_ = linear_velocity;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(147, 0)" endLine="(149, 1)" clone_start="1" clone_end="3">
			<code function_name="ActiveSetQpSolver::set_qp_eps_iter_ref(const double eps)">void ActiveSetQpSolver::set_qp_eps_iter_ref(const double eps) {
  qp_eps_iter_ref_ = eps;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(184, 0)" endLine="(186, 1)" clone_start="1" clone_end="2">
			<code function_name="VehicleState::set_angular_velocity(const double angular_velocity)">void VehicleState::set_angular_velocity(const double angular_velocity) {
  angular_v_ = angular_velocity;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(151, 0)" endLine="(153, 1)" clone_start="1" clone_end="2">
			<code function_name="ActiveSetQpSolver::set_debug_info(const bool enable)">void ActiveSetQpSolver::set_debug_info(const bool enable) {
  debug_info_ = enable;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.cc" startLine="(199, 0)" endLine="(225, 1)" clone_start="2" clone_end="8">
			<code function_name="Path::InitWidth()">void Path::InitWidth() {
  left_width_.clear();
  left_width_.reserve(num_sample_points_);
  right_width_.clear();
  right_width_.reserve(num_sample_points_);

  double s = 0;
  for (int i = 0; i &lt; num_sample_points_; ++i) {
    const MapPathPoint point = GetSmoothPoint(s);
    if (point.lane_waypoints().empty()) {
      left_width_.push_back(0.0);
      right_width_.push_back(0.0);
      AERROR &lt;&lt; "path point:" &lt;&lt; point.DebugString() &lt;&lt; " has invalid width.";
    } else {
      const LaneWaypoint waypoint = point.lane_waypoints()[0];
      CHECK_NOTNULL(waypoint.lane);
      double left_width = 0.0;
      double right_width = 0.0;
      waypoint.lane-&gt;GetWidth(waypoint.s, &amp;left_width, &amp;right_width);
      left_width_.push_back(left_width);
      right_width_.push_back(right_width);
    }
    s += kSampleDistance;
  }
  CHECK_EQ(left_width_.size(), num_sample_points_);
  CHECK_EQ(right_width_.size(), num_sample_points_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.cc" startLine="(137, 0)" endLine="(171, 1)" clone_start="7" clone_end="12">
			<code function_name="Path::InitPoints()">void Path::InitPoints() {
  num_points_ = static_cast&lt;int&gt;(path_points_.size());
  CHECK_GE(num_points_, 2);

  accumulated_s_.clear();
  accumulated_s_.reserve(num_points_);
  segments_.clear();
  segments_.reserve(num_points_);
  unit_directions_.clear();
  unit_directions_.reserve(num_points_);
  double s = 0.0;
  for (int i = 0; i &lt; num_points_; ++i) {
    accumulated_s_.push_back(s);
    Vec2d heading;
    if (i + 1 &gt;= num_points_) {
      heading = path_points_[i] - path_points_[i - 1];
    } else {
      segments_.emplace_back(path_points_[i], path_points_[i + 1]);
      heading = path_points_[i + 1] - path_points_[i];
      // TODO(lianglia_apollo):
      // use heading.length when all adjacent lanes are guarantee to be
      // connected.
      s += heading.Length();
    }
    heading.Normalize();
    unit_directions_.push_back(heading);
  }
  length_ = s;
  num_sample_points_ = static_cast&lt;int&gt;(length_ / kSampleDistance) + 1;
  num_segments_ = num_points_ - 1;

  CHECK_EQ(accumulated_s_.size(), num_points_);
  CHECK_EQ(unit_directions_.size(), num_points_);
  CHECK_EQ(segments_.size(), num_segments_);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\util_xml_parser.cc" startLine="(150, 0)" endLine="(178, 1)" clone_start="11" clone_end="17">
			<code function_name="UtilXmlParser::ParsePoint(const tinyxml2::XMLElement&amp; xml_node, PbPoint3D* pt)">Status UtilXmlParser::ParsePoint(const tinyxml2::XMLElement&amp; xml_node,
                                 PbPoint3D* pt) {
  CHECK_NOTNULL(pt);

  const auto sub_node = xml_node.FirstChildElement("centerPoint");
  CHECK(sub_node != nullptr);
  int checker = tinyxml2::XML_SUCCESS;
  double ptx = 0.0;
  double pty = 0.0;
  double ptz = 0.0;
  checker += sub_node-&gt;QueryDoubleAttribute("x", &amp;ptx);
  checker += sub_node-&gt;QueryDoubleAttribute("y", &amp;pty);
  checker += sub_node-&gt;QueryDoubleAttribute("z", &amp;ptz);

  if (checker != tinyxml2::XML_SUCCESS) {
    std::string err_msg = "Error parse point attributes";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  double output_x = 0.0;
  double output_y = 0.0;
  double output_z = 0.0;
  WGS84ToUTM(ptx, pty, ptz, &amp;output_x, &amp;output_y, &amp;output_z);
  pt-&gt;set_x(output_x);
  pt-&gt;set_y(output_y);
  pt-&gt;set_z(output_z);

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\util_xml_parser.cc" startLine="(117, 0)" endLine="(148, 1)" clone_start="10" clone_end="16">
			<code function_name="UtilXmlParser::ParseOutline(const tinyxml2::XMLElement&amp; xml_node, PbPolygon* polygon)">Status UtilXmlParser::ParseOutline(const tinyxml2::XMLElement&amp; xml_node,
                                   PbPolygon* polygon) {
  const tinyxml2::XMLElement* sub_node =
      xml_node.FirstChildElement("cornerGlobal");
  while (sub_node) {
    double ptx = 0.0;
    double pty = 0.0;
    double ptz = 0.0;
    int checker = tinyxml2::XML_SUCCESS;
    checker += sub_node-&gt;QueryDoubleAttribute("x", &amp;ptx);
    checker += sub_node-&gt;QueryDoubleAttribute("y", &amp;pty);
    checker += sub_node-&gt;QueryDoubleAttribute("z", &amp;ptz);

    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parsing cornerGlobal point attributes";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    PbPoint3D* pt = polygon-&gt;add_point();
    double output_x = 0.0;
    double output_y = 0.0;
    double output_z = 0.0;
    WGS84ToUTM(ptx, pty, ptz, &amp;output_x, &amp;output_y, &amp;output_z);
    pt-&gt;set_x(output_x);
    pt-&gt;set_y(output_y);
    // pt-&gt;set_z(output_z);

    sub_node = sub_node-&gt;NextSiblingElement("cornerGlobal");
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\util\string_util.h" startLine="(77, 0)" endLine="(80, 1)" clone_start="1" clone_end="4">
			<code function_name="PrintIter(const Container&amp; container, const std::string&amp; delimiter = &quot; &quot;)">internal::IterPrinter&lt;Iter&gt; PrintIter(const Container&amp; container,
                                      const std::string&amp; delimiter = " ") {
  return {container.begin(), container.end(), delimiter};
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\util\string_util.h" startLine="(106, 0)" endLine="(109, 1)" clone_start="1" clone_end="4">
			<code function_name="PrintDebugStringIter( const Container&amp; container, const std::string&amp; delimiter = &quot; &quot;)">internal::DebugStringIterPrinter&lt;Iter&gt; PrintDebugStringIter(
    const Container&amp; container, const std::string&amp; delimiter = " ") {
  return {container.begin(), container.end(), delimiter};
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\util\string_util.h" startLine="(83, 0)" endLine="(86, 1)" clone_start="1" clone_end="3">
			<code function_name="PrintIter(const Iter&amp; begin, const Iter&amp; end, const std::string&amp; delimiter = &quot; &quot;)">internal::IterPrinter&lt;Iter&gt; PrintIter(const Iter&amp; begin, const Iter&amp; end,
                                      const std::string&amp; delimiter = " ") {
  return {begin, end, delimiter};
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\util\string_util.h" startLine="(112, 0)" endLine="(115, 1)" clone_start="1" clone_end="3">
			<code function_name="PrintDebugStringIter( const Iter&amp; begin, const Iter&amp; end, const std::string&amp; delimiter = &quot; &quot;)">internal::DebugStringIterPrinter&lt;Iter&gt; PrintDebugStringIter(
    const Iter&amp; begin, const Iter&amp; end, const std::string&amp; delimiter = " ") {
  return {begin, end, delimiter};
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\tools\map_tool.cc" startLine="(74, 0)" endLine="(88, 1)" clone_start="1" clone_end="9">
			<code function_name="main(int32_t argc, char** argv)">int main(int32_t argc, char** argv) {
  google::InitGoogleLogging(argv[0]);
  FLAGS_alsologtostderr = true;
  FLAGS_v = 3;

  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);

  Map map_pb;
  const auto map_file = apollo::hdmap::BaseMapFile();
  CHECK(apollo::common::util::GetProtoFromFile(map_file, &amp;map_pb))
      &lt;&lt; "Fail to open:" &lt;&lt; map_file;
  ShiftMap(&amp;map_pb);
  OutputMap(map_pb);
  AINFO &lt;&lt; "modified map at:" &lt;&lt; FLAGS_output_dir;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\tools\sim_map_generator.cc" startLine="(103, 0)" endLine="(123, 1)" clone_start="1" clone_end="9">
			<code function_name="main(int32_t argc, char** argv)">int main(int32_t argc, char** argv) {
  google::InitGoogleLogging(argv[0]);
  FLAGS_alsologtostderr = true;
  FLAGS_v = 3;

  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);

  Map map_pb;
  const auto map_file = apollo::hdmap::BaseMapFile();
  if (apollo::common::util::EndWith(map_file, ".xml")) {
    CHECK(OpendriveAdapter::LoadData(map_file, &amp;map_pb));
  } else {
    CHECK(GetProtoFromFile(map_file, &amp;map_pb)) &lt;&lt; "Fail to open: " &lt;&lt; map_file;
  }

  DownsampleMap(&amp;map_pb);
  OutputMap(map_pb);
  AINFO &lt;&lt; "sim_map generated at:" &lt;&lt; FLAGS_output_dir;

  return 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_kernel.cc" startLine="(79, 0)" endLine="(127, 1)" clone_start="13" clone_end="20">
			<code function_name="PiecewiseLinearKernel::AddThirdOrderDerivativeMatrix(const double weight)">void PiecewiseLinearKernel::AddThirdOrderDerivativeMatrix(const double weight) {
  Eigen::MatrixXd jerk_matrix = Eigen::MatrixXd::Zero(dimension_, dimension_);
  for (std::size_t i = 0; i &lt; dimension_; ++i) {
    if (i == 1) {
      jerk_matrix(i, i) += 1.0;
    } else if (i == 2) {
      jerk_matrix(i - 1, i - 1) += 9.0;
      jerk_matrix(i, i) += 1.0;

      jerk_matrix(i - 1, i) += -3.0;
      jerk_matrix(i, i - 1) += -3.0;
    } else if (i == 3) {
      jerk_matrix(i - 2, i - 2) += 9.0;
      jerk_matrix(i - 1, i - 1) += 9.0;
      jerk_matrix(i, i) += 1.0;

      jerk_matrix(i - 1, i) += -3.0;
      jerk_matrix(i, i - 1) += -3.0;
      jerk_matrix(i - 2, i) += 3.0;
      jerk_matrix(i, i - 2) += 3.0;

      jerk_matrix(i - 2, i - 1) += -9.0;
      jerk_matrix(i - 1, i - 2) += -9.0;
    } else {
      jerk_matrix(i - 3, i - 3) += 1.0;
      jerk_matrix(i - 2, i - 2) += 9.0;
      jerk_matrix(i - 1, i - 1) += 9.0;
      jerk_matrix(i, i) += 1.0;

      jerk_matrix(i - 1, i) += -3.0;
      jerk_matrix(i, i - 1) += -3.0;
      jerk_matrix(i - 2, i) += 3.0;
      jerk_matrix(i, i - 2) += 3.0;
      jerk_matrix(i - 3, i) += -1.0;
      jerk_matrix(i, i - 3) += -1.0;

      jerk_matrix(i - 2, i - 1) += -9.0;
      jerk_matrix(i - 1, i - 2) += -9.0;
      jerk_matrix(i - 3, i - 1) += 3.0;
      jerk_matrix(i - 1, i - 3) += 3.0;

      jerk_matrix(i - 3, i - 2) += -3.0;
      jerk_matrix(i - 2, i - 3) += -3.0;
    }
  }

  jerk_matrix *= 2.0 * weight / std::pow(unit_segment_, 4);
  kernel_matrix_ += jerk_matrix;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_kernel.cc" startLine="(79, 0)" endLine="(127, 1)" clone_start="26" clone_end="33">
			<code function_name="PiecewiseLinearKernel::AddThirdOrderDerivativeMatrix(const double weight)">void PiecewiseLinearKernel::AddThirdOrderDerivativeMatrix(const double weight) {
  Eigen::MatrixXd jerk_matrix = Eigen::MatrixXd::Zero(dimension_, dimension_);
  for (std::size_t i = 0; i &lt; dimension_; ++i) {
    if (i == 1) {
      jerk_matrix(i, i) += 1.0;
    } else if (i == 2) {
      jerk_matrix(i - 1, i - 1) += 9.0;
      jerk_matrix(i, i) += 1.0;

      jerk_matrix(i - 1, i) += -3.0;
      jerk_matrix(i, i - 1) += -3.0;
    } else if (i == 3) {
      jerk_matrix(i - 2, i - 2) += 9.0;
      jerk_matrix(i - 1, i - 1) += 9.0;
      jerk_matrix(i, i) += 1.0;

      jerk_matrix(i - 1, i) += -3.0;
      jerk_matrix(i, i - 1) += -3.0;
      jerk_matrix(i - 2, i) += 3.0;
      jerk_matrix(i, i - 2) += 3.0;

      jerk_matrix(i - 2, i - 1) += -9.0;
      jerk_matrix(i - 1, i - 2) += -9.0;
    } else {
      jerk_matrix(i - 3, i - 3) += 1.0;
      jerk_matrix(i - 2, i - 2) += 9.0;
      jerk_matrix(i - 1, i - 1) += 9.0;
      jerk_matrix(i, i) += 1.0;

      jerk_matrix(i - 1, i) += -3.0;
      jerk_matrix(i, i - 1) += -3.0;
      jerk_matrix(i - 2, i) += 3.0;
      jerk_matrix(i, i - 2) += 3.0;
      jerk_matrix(i - 3, i) += -1.0;
      jerk_matrix(i, i - 3) += -1.0;

      jerk_matrix(i - 2, i - 1) += -9.0;
      jerk_matrix(i - 1, i - 2) += -9.0;
      jerk_matrix(i - 3, i - 1) += 3.0;
      jerk_matrix(i - 1, i - 3) += 3.0;

      jerk_matrix(i - 3, i - 2) += -3.0;
      jerk_matrix(i - 2, i - 3) += -3.0;
    }
  }

  jerk_matrix *= 2.0 * weight / std::pow(unit_segment_, 4);
  kernel_matrix_ += jerk_matrix;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\polygon2d.cc" startLine="(489, 0)" endLine="(546, 1)" clone_start="28" clone_end="37">
			<code function_name="Polygon2d::MinAreaBoundingBox() const">Box2d Polygon2d::MinAreaBoundingBox() const {
  CHECK_GE(points_.size(), 3);
  if (!is_convex_) {
    Polygon2d convex_polygon;
    ComputeConvexHull(points_, &amp;convex_polygon);
    CHECK(convex_polygon.is_convex());
    return convex_polygon.MinAreaBoundingBox();
  }
  double min_area = std::numeric_limits&lt;double&gt;::infinity();
  double min_area_at_heading = 0.0;
  int left_most = 0;
  int right_most = 0;
  int top_most = 0;
  for (int i = 0; i &lt; num_points_; ++i) {
    const auto &amp;line_segment = line_segments_[i];
    double proj = 0.0;
    double min_proj = line_segment.ProjectOntoUnit(points_[left_most]);
    while ((proj = line_segment.ProjectOntoUnit(points_[Prev(left_most)])) &lt;
           min_proj) {
      min_proj = proj;
      left_most = Prev(left_most);
    }
    while ((proj = line_segment.ProjectOntoUnit(points_[Next(left_most)])) &lt;
           min_proj) {
      min_proj = proj;
      left_most = Next(left_most);
    }
    double max_proj = line_segment.ProjectOntoUnit(points_[right_most]);
    while ((proj = line_segment.ProjectOntoUnit(points_[Prev(right_most)])) &gt;
           max_proj) {
      max_proj = proj;
      right_most = Prev(right_most);
    }
    while ((proj = line_segment.ProjectOntoUnit(points_[Next(right_most)])) &gt;
           max_proj) {
      max_proj = proj;
      right_most = Next(right_most);
    }
    double prod = 0.0;
    double max_prod = line_segment.ProductOntoUnit(points_[top_most]);
    while ((prod = line_segment.ProductOntoUnit(points_[Prev(top_most)])) &gt;
           max_prod) {
      max_prod = prod;
      top_most = Prev(top_most);
    }
    while ((prod = line_segment.ProductOntoUnit(points_[Next(top_most)])) &gt;
           max_prod) {
      max_prod = prod;
      top_most = Next(top_most);
    }
    const double area = max_prod * (max_proj - min_proj);
    if (area &lt; min_area) {
      min_area = area;
      min_area_at_heading = line_segment.heading();
    }
  }
  return BoundingBoxWithHeading(min_area_at_heading);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\polygon2d.cc" startLine="(489, 0)" endLine="(546, 1)" clone_start="40" clone_end="49">
			<code function_name="Polygon2d::MinAreaBoundingBox() const">Box2d Polygon2d::MinAreaBoundingBox() const {
  CHECK_GE(points_.size(), 3);
  if (!is_convex_) {
    Polygon2d convex_polygon;
    ComputeConvexHull(points_, &amp;convex_polygon);
    CHECK(convex_polygon.is_convex());
    return convex_polygon.MinAreaBoundingBox();
  }
  double min_area = std::numeric_limits&lt;double&gt;::infinity();
  double min_area_at_heading = 0.0;
  int left_most = 0;
  int right_most = 0;
  int top_most = 0;
  for (int i = 0; i &lt; num_points_; ++i) {
    const auto &amp;line_segment = line_segments_[i];
    double proj = 0.0;
    double min_proj = line_segment.ProjectOntoUnit(points_[left_most]);
    while ((proj = line_segment.ProjectOntoUnit(points_[Prev(left_most)])) &lt;
           min_proj) {
      min_proj = proj;
      left_most = Prev(left_most);
    }
    while ((proj = line_segment.ProjectOntoUnit(points_[Next(left_most)])) &lt;
           min_proj) {
      min_proj = proj;
      left_most = Next(left_most);
    }
    double max_proj = line_segment.ProjectOntoUnit(points_[right_most]);
    while ((proj = line_segment.ProjectOntoUnit(points_[Prev(right_most)])) &gt;
           max_proj) {
      max_proj = proj;
      right_most = Prev(right_most);
    }
    while ((proj = line_segment.ProjectOntoUnit(points_[Next(right_most)])) &gt;
           max_proj) {
      max_proj = proj;
      right_most = Next(right_most);
    }
    double prod = 0.0;
    double max_prod = line_segment.ProductOntoUnit(points_[top_most]);
    while ((prod = line_segment.ProductOntoUnit(points_[Prev(top_most)])) &gt;
           max_prod) {
      max_prod = prod;
      top_most = Prev(top_most);
    }
    while ((prod = line_segment.ProductOntoUnit(points_[Next(top_most)])) &gt;
           max_prod) {
      max_prod = prod;
      top_most = Next(top_most);
    }
    const double area = max_prod * (max_proj - min_proj);
    if (area &lt; min_area) {
      min_area = area;
      min_area_at_heading = line_segment.heading();
    }
  }
  return BoundingBoxWithHeading(min_area_at_heading);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(495, 0)" endLine="(501, 1)" clone_start="3" clone_end="7">
			<code function_name="Spline2dConstraint::PolyCoef(const double t) const">std::vector&lt;double&gt; Spline2dConstraint::PolyCoef(const double t) const {
  std::vector&lt;double&gt; result(spline_order_, 1.0);
  for (std::uint32_t i = 1; i &lt; result.size(); ++i) {
    result[i] = result[i - 1] * t;
  }
  return result;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(503, 0)" endLine="(510, 1)" clone_start="4" clone_end="8">
			<code function_name="Spline2dConstraint::DerivativeCoef(const double t) const">std::vector&lt;double&gt; Spline2dConstraint::DerivativeCoef(const double t) const {
  std::vector&lt;double&gt; result(spline_order_, 0.0);
  std::vector&lt;double&gt; power_t = PolyCoef(t);
  for (std::uint32_t i = 1; i &lt; result.size(); ++i) {
    result[i] = power_t[i - 1] * i;
  }
  return result;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(503, 0)" endLine="(510, 1)" clone_start="1" clone_end="4">
			<code function_name="Spline2dConstraint::DerivativeCoef(const double t) const">std::vector&lt;double&gt; Spline2dConstraint::DerivativeCoef(const double t) const {
  std::vector&lt;double&gt; result(spline_order_, 0.0);
  std::vector&lt;double&gt; power_t = PolyCoef(t);
  for (std::uint32_t i = 1; i &lt; result.size(); ++i) {
    result[i] = power_t[i - 1] * i;
  }
  return result;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(512, 0)" endLine="(520, 1)" clone_start="1" clone_end="5">
			<code function_name="Spline2dConstraint::SecondDerivativeCoef( const double t) const">std::vector&lt;double&gt; Spline2dConstraint::SecondDerivativeCoef(
    const double t) const {
  std::vector&lt;double&gt; result(spline_order_, 0.0);
  std::vector&lt;double&gt; power_t = PolyCoef(t);
  for (std::uint32_t i = 2; i &lt; result.size(); ++i) {
    result[i] = power_t[i - 2] * i * (i - 1);
  }
  return result;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\evaluator\vehicle\mlp_evaluator.cc" startLine="(124, 0)" endLine="(259, 1)" clone_start="109" clone_end="116">
			<code function_name="MLPEvaluator::SetObstacleFeatureValues( Obstacle* obstacle_ptr, std::vector&lt;double&gt;* feature_values)">void MLPEvaluator::SetObstacleFeatureValues(
    Obstacle* obstacle_ptr, std::vector&lt;double&gt;* feature_values) {
  feature_values-&gt;clear();
  feature_values-&gt;reserve(OBSTACLE_FEATURE_SIZE);

  std::vector&lt;double&gt; thetas;
  std::vector&lt;double&gt; lane_ls;
  std::vector&lt;double&gt; dist_lbs;
  std::vector&lt;double&gt; dist_rbs;
  std::vector&lt;int&gt; lane_types;
  std::vector&lt;double&gt; speeds;
  std::vector&lt;double&gt; timestamps;

  double duration = obstacle_ptr-&gt;timestamp() - FLAGS_prediction_duration;
  int count = 0;
  for (std::size_t i = 0; i &lt; obstacle_ptr-&gt;history_size(); ++i) {
    const Feature&amp; feature = obstacle_ptr-&gt;feature(i);
    if (!feature.IsInitialized()) {
      continue;
    }
    if (apollo::common::math::DoubleCompare(feature.timestamp(), duration) &lt;
        0) {
      break;
    }
    if (feature.has_lane() &amp;&amp; feature.lane().has_lane_feature()) {
      thetas.push_back(feature.lane().lane_feature().angle_diff());
      lane_ls.push_back(feature.lane().lane_feature().lane_l());
      dist_lbs.push_back(feature.lane().lane_feature().dist_to_left_boundary());
      dist_rbs.push_back(
          feature.lane().lane_feature().dist_to_right_boundary());
      lane_types.push_back(feature.lane().lane_feature().lane_turn_type());
      timestamps.push_back(feature.timestamp());
      if (FLAGS_enable_kf_tracking) {
        speeds.push_back(feature.t_speed());
      } else {
        speeds.push_back(feature.speed());
      }
      ++count;
    }
  }
  if (count &lt;= 0) {
    return;
  }
  int curr_size = 5;
  int hist_size = obstacle_ptr-&gt;history_size();
  double theta_mean = ComputeMean(thetas, 0, hist_size - 1);
  double theta_filtered = ComputeMean(thetas, 0, curr_size - 1);
  double lane_l_mean = ComputeMean(lane_ls, 0, hist_size - 1);
  double lane_l_filtered = ComputeMean(lane_ls, 0, curr_size - 1);
  double speed_mean = ComputeMean(speeds, 0, hist_size - 1);

  double time_diff = timestamps.front() - timestamps.back();
  double dist_lb_rate = (timestamps.size() &gt; 1)
                            ? (dist_lbs.front() - dist_lbs.back()) / time_diff
                            : 0.0;
  double dist_rb_rate = (timestamps.size() &gt; 1)
                            ? (dist_rbs.front() - dist_rbs.back()) / time_diff
                            : 0.0;

  double delta_t = 0.0;
  if (timestamps.size() &gt; 1) {
    delta_t =
        (timestamps.front() - timestamps.back()) / (timestamps.size() - 1);
  }
  double angle_curr = ComputeMean(thetas, 0, curr_size - 1);
  double angle_prev = ComputeMean(thetas, curr_size, 2 * curr_size - 1);
  double angle_diff =
      (hist_size &gt;= 2 * curr_size) ? angle_curr - angle_prev : 0.0;

  double lane_l_curr = ComputeMean(lane_ls, 0, curr_size - 1);
  double lane_l_prev = ComputeMean(lane_ls, curr_size, 2 * curr_size - 1);
  double lane_l_diff =
      (hist_size &gt;= 2 * curr_size) ? lane_l_curr - lane_l_prev : 0.0;

  double angle_diff_rate = 0.0;
  double lane_l_diff_rate = 0.0;
  if (delta_t &gt; std::numeric_limits&lt;double&gt;::epsilon()) {
    angle_diff_rate = angle_diff / (delta_t * curr_size);
    lane_l_diff_rate = lane_l_diff / (delta_t * curr_size);
  }

  double acc = 0.0;
  if (static_cast&lt;int&gt;(speeds.size()) &gt;= 3 * curr_size &amp;&amp;
      delta_t &gt; std::numeric_limits&lt;double&gt;::epsilon()) {
    double speed_1 = ComputeMean(speeds, 0, curr_size - 1);
    double speed_2 = ComputeMean(speeds, curr_size, 2 * curr_size - 1);
    double speed_3 = ComputeMean(speeds, 2 * curr_size, 3 * curr_size - 1);
    acc = (speed_1 - 2 * speed_2 + speed_3) /
          (curr_size * curr_size * delta_t * delta_t);
  }

  double dist_lb_rate_curr = 0.0;
  if (hist_size &gt;= 2 * curr_size &amp;&amp;
      delta_t &gt; std::numeric_limits&lt;double&gt;::epsilon()) {
    double dist_lb_curr = ComputeMean(dist_lbs, 0, curr_size - 1);
    double dist_lb_prev = ComputeMean(dist_lbs, curr_size, 2 * curr_size - 1);
    dist_lb_rate_curr = (dist_lb_curr - dist_lb_prev) / (curr_size * delta_t);
  }

  double dist_rb_rate_curr = 0.0;
  if (hist_size &gt;= 2 * curr_size &amp;&amp;
      delta_t &gt; std::numeric_limits&lt;double&gt;::epsilon()) {
    double dist_rb_curr = ComputeMean(dist_rbs, 0, curr_size - 1);
    double dist_rb_prev = ComputeMean(dist_rbs, curr_size, 2 * curr_size - 1);
    dist_rb_rate_curr = (dist_rb_curr - dist_rb_prev) / (curr_size * delta_t);
  }

  // setup obstacle feature values
  feature_values-&gt;push_back(theta_filtered);
  feature_values-&gt;push_back(theta_mean);
  feature_values-&gt;push_back(theta_filtered - theta_mean);
  feature_values-&gt;push_back(angle_diff);
  feature_values-&gt;push_back(angle_diff_rate);

  feature_values-&gt;push_back(lane_l_filtered);
  feature_values-&gt;push_back(lane_l_mean);
  feature_values-&gt;push_back(lane_l_filtered - lane_l_mean);
  feature_values-&gt;push_back(lane_l_diff);
  feature_values-&gt;push_back(lane_l_diff_rate);

  feature_values-&gt;push_back(speed_mean);
  feature_values-&gt;push_back(acc);

  feature_values-&gt;push_back(dist_lbs.front());
  feature_values-&gt;push_back(dist_lb_rate);
  feature_values-&gt;push_back(dist_lb_rate_curr);

  feature_values-&gt;push_back(dist_rbs.front());
  feature_values-&gt;push_back(dist_rb_rate);
  feature_values-&gt;push_back(dist_rb_rate_curr);

  feature_values-&gt;push_back(lane_types.front() == 0 ? 1.0 : 0.0);
  feature_values-&gt;push_back(lane_types.front() == 1 ? 1.0 : 0.0);
  feature_values-&gt;push_back(lane_types.front() == 2 ? 1.0 : 0.0);
  feature_values-&gt;push_back(lane_types.front() == 3 ? 1.0 : 0.0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\evaluator\vehicle\mlp_evaluator.cc" startLine="(124, 0)" endLine="(259, 1)" clone_start="115" clone_end="122">
			<code function_name="MLPEvaluator::SetObstacleFeatureValues( Obstacle* obstacle_ptr, std::vector&lt;double&gt;* feature_values)">void MLPEvaluator::SetObstacleFeatureValues(
    Obstacle* obstacle_ptr, std::vector&lt;double&gt;* feature_values) {
  feature_values-&gt;clear();
  feature_values-&gt;reserve(OBSTACLE_FEATURE_SIZE);

  std::vector&lt;double&gt; thetas;
  std::vector&lt;double&gt; lane_ls;
  std::vector&lt;double&gt; dist_lbs;
  std::vector&lt;double&gt; dist_rbs;
  std::vector&lt;int&gt; lane_types;
  std::vector&lt;double&gt; speeds;
  std::vector&lt;double&gt; timestamps;

  double duration = obstacle_ptr-&gt;timestamp() - FLAGS_prediction_duration;
  int count = 0;
  for (std::size_t i = 0; i &lt; obstacle_ptr-&gt;history_size(); ++i) {
    const Feature&amp; feature = obstacle_ptr-&gt;feature(i);
    if (!feature.IsInitialized()) {
      continue;
    }
    if (apollo::common::math::DoubleCompare(feature.timestamp(), duration) &lt;
        0) {
      break;
    }
    if (feature.has_lane() &amp;&amp; feature.lane().has_lane_feature()) {
      thetas.push_back(feature.lane().lane_feature().angle_diff());
      lane_ls.push_back(feature.lane().lane_feature().lane_l());
      dist_lbs.push_back(feature.lane().lane_feature().dist_to_left_boundary());
      dist_rbs.push_back(
          feature.lane().lane_feature().dist_to_right_boundary());
      lane_types.push_back(feature.lane().lane_feature().lane_turn_type());
      timestamps.push_back(feature.timestamp());
      if (FLAGS_enable_kf_tracking) {
        speeds.push_back(feature.t_speed());
      } else {
        speeds.push_back(feature.speed());
      }
      ++count;
    }
  }
  if (count &lt;= 0) {
    return;
  }
  int curr_size = 5;
  int hist_size = obstacle_ptr-&gt;history_size();
  double theta_mean = ComputeMean(thetas, 0, hist_size - 1);
  double theta_filtered = ComputeMean(thetas, 0, curr_size - 1);
  double lane_l_mean = ComputeMean(lane_ls, 0, hist_size - 1);
  double lane_l_filtered = ComputeMean(lane_ls, 0, curr_size - 1);
  double speed_mean = ComputeMean(speeds, 0, hist_size - 1);

  double time_diff = timestamps.front() - timestamps.back();
  double dist_lb_rate = (timestamps.size() &gt; 1)
                            ? (dist_lbs.front() - dist_lbs.back()) / time_diff
                            : 0.0;
  double dist_rb_rate = (timestamps.size() &gt; 1)
                            ? (dist_rbs.front() - dist_rbs.back()) / time_diff
                            : 0.0;

  double delta_t = 0.0;
  if (timestamps.size() &gt; 1) {
    delta_t =
        (timestamps.front() - timestamps.back()) / (timestamps.size() - 1);
  }
  double angle_curr = ComputeMean(thetas, 0, curr_size - 1);
  double angle_prev = ComputeMean(thetas, curr_size, 2 * curr_size - 1);
  double angle_diff =
      (hist_size &gt;= 2 * curr_size) ? angle_curr - angle_prev : 0.0;

  double lane_l_curr = ComputeMean(lane_ls, 0, curr_size - 1);
  double lane_l_prev = ComputeMean(lane_ls, curr_size, 2 * curr_size - 1);
  double lane_l_diff =
      (hist_size &gt;= 2 * curr_size) ? lane_l_curr - lane_l_prev : 0.0;

  double angle_diff_rate = 0.0;
  double lane_l_diff_rate = 0.0;
  if (delta_t &gt; std::numeric_limits&lt;double&gt;::epsilon()) {
    angle_diff_rate = angle_diff / (delta_t * curr_size);
    lane_l_diff_rate = lane_l_diff / (delta_t * curr_size);
  }

  double acc = 0.0;
  if (static_cast&lt;int&gt;(speeds.size()) &gt;= 3 * curr_size &amp;&amp;
      delta_t &gt; std::numeric_limits&lt;double&gt;::epsilon()) {
    double speed_1 = ComputeMean(speeds, 0, curr_size - 1);
    double speed_2 = ComputeMean(speeds, curr_size, 2 * curr_size - 1);
    double speed_3 = ComputeMean(speeds, 2 * curr_size, 3 * curr_size - 1);
    acc = (speed_1 - 2 * speed_2 + speed_3) /
          (curr_size * curr_size * delta_t * delta_t);
  }

  double dist_lb_rate_curr = 0.0;
  if (hist_size &gt;= 2 * curr_size &amp;&amp;
      delta_t &gt; std::numeric_limits&lt;double&gt;::epsilon()) {
    double dist_lb_curr = ComputeMean(dist_lbs, 0, curr_size - 1);
    double dist_lb_prev = ComputeMean(dist_lbs, curr_size, 2 * curr_size - 1);
    dist_lb_rate_curr = (dist_lb_curr - dist_lb_prev) / (curr_size * delta_t);
  }

  double dist_rb_rate_curr = 0.0;
  if (hist_size &gt;= 2 * curr_size &amp;&amp;
      delta_t &gt; std::numeric_limits&lt;double&gt;::epsilon()) {
    double dist_rb_curr = ComputeMean(dist_rbs, 0, curr_size - 1);
    double dist_rb_prev = ComputeMean(dist_rbs, curr_size, 2 * curr_size - 1);
    dist_rb_rate_curr = (dist_rb_curr - dist_rb_prev) / (curr_size * delta_t);
  }

  // setup obstacle feature values
  feature_values-&gt;push_back(theta_filtered);
  feature_values-&gt;push_back(theta_mean);
  feature_values-&gt;push_back(theta_filtered - theta_mean);
  feature_values-&gt;push_back(angle_diff);
  feature_values-&gt;push_back(angle_diff_rate);

  feature_values-&gt;push_back(lane_l_filtered);
  feature_values-&gt;push_back(lane_l_mean);
  feature_values-&gt;push_back(lane_l_filtered - lane_l_mean);
  feature_values-&gt;push_back(lane_l_diff);
  feature_values-&gt;push_back(lane_l_diff_rate);

  feature_values-&gt;push_back(speed_mean);
  feature_values-&gt;push_back(acc);

  feature_values-&gt;push_back(dist_lbs.front());
  feature_values-&gt;push_back(dist_lb_rate);
  feature_values-&gt;push_back(dist_lb_rate_curr);

  feature_values-&gt;push_back(dist_rbs.front());
  feature_values-&gt;push_back(dist_rb_rate);
  feature_values-&gt;push_back(dist_rb_rate_curr);

  feature_values-&gt;push_back(lane_types.front() == 0 ? 1.0 : 0.0);
  feature_values-&gt;push_back(lane_types.front() == 1 ? 1.0 : 0.0);
  feature_values-&gt;push_back(lane_types.front() == 2 ? 1.0 : 0.0);
  feature_values-&gt;push_back(lane_types.front() == 3 ? 1.0 : 0.0);
}</code>
		</source>
	</dup>
	<dup count="5">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\common\prediction_map.cc" startLine="(314, 0)" endLine="(326, 1)" clone_start="1" clone_end="12">
			<code function_name="PredictionMap::IsPredecessorLane(    std::shared_ptr&lt;const LaneInfo&gt; pred_lane, const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes)">bool PredictionMap::IsPredecessorLane(
    std::shared_ptr&lt;const LaneInfo&gt; pred_lane,
    const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes) {
  if (lanes.size() == 0) {
    return true;
  }
  for (auto&amp; lane : lanes) {
    if (IsPredecessorLane(pred_lane, lane)) {
      return true;
    }
  }
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\common\prediction_map.cc" startLine="(283, 0)" endLine="(295, 1)" clone_start="1" clone_end="12">
			<code function_name="PredictionMap::IsSuccessorLane(std::shared_ptr&lt;const LaneInfo&gt; succ_lane, const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes)">bool PredictionMap::IsSuccessorLane(
    std::shared_ptr&lt;const LaneInfo&gt; succ_lane,
    const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes) {
  if (lanes.size() == 0) {
    return true;
  }
  for (auto&amp; lane : lanes) {
    if (IsSuccessorLane(succ_lane, lane)) {
      return true;
    }
  }
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\common\prediction_map.cc" startLine="(253, 0)" endLine="(265, 1)" clone_start="1" clone_end="12">
			<code function_name="PredictionMap::IsRightNeighborLane(    std::shared_ptr&lt;const LaneInfo&gt; right_lane, const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes)">bool PredictionMap::IsRightNeighborLane(
    std::shared_ptr&lt;const LaneInfo&gt; right_lane,
    const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes) {
  if (lanes.size() == 0) {
    return true;
  }
  for (const auto&amp; lane : lanes) {
    if (IsRightNeighborLane(right_lane, lane)) {
      return true;
    }
  }
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\common\prediction_map.cc" startLine="(221, 0)" endLine="(233, 1)" clone_start="1" clone_end="12">
			<code function_name="PredictionMap::IsLeftNeighborLane(    std::shared_ptr&lt;const LaneInfo&gt; left_lane, const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes)">bool PredictionMap::IsLeftNeighborLane(
    std::shared_ptr&lt;const LaneInfo&gt; left_lane,
    const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes) {
  if (lanes.size() == 0) {
    return true;
  }
  for (auto&amp; lane : lanes) {
    if (IsLeftNeighborLane(left_lane, lane)) {
      return true;
    }
  }
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\common\prediction_map.cc" startLine="(336, 0)" endLine="(348, 1)" clone_start="1" clone_end="12">
			<code function_name="PredictionMap::IsIdenticalLane(std::shared_ptr&lt;const LaneInfo&gt; other_lane, const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes)">bool PredictionMap::IsIdenticalLane(
    std::shared_ptr&lt;const LaneInfo&gt; other_lane,
    const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes) {
  if (lanes.size() == 0) {
    return true;
  }
  for (auto&amp; lane : lanes) {
    if (IsIdenticalLane(other_lane, lane)) {
      return true;
    }
  }
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\core\black_list_range_generator.cc" startLine="(53, 0)" endLine="(63, 1)" clone_start="1" clone_end="9">
			<code function_name="GetOutParallelLane(const TopoNode* node, std::unordered_set&lt;const TopoNode*&gt;* const node_set)">void GetOutParallelLane(const TopoNode* node,
                        std::unordered_set&lt;const TopoNode*&gt;* const node_set) {
  for (const auto* edge : node-&gt;OutToLeftOrRightEdge()) {
    const auto* to_node = edge-&gt;ToNode();
    if (node_set-&gt;find(to_node) != node_set-&gt;end()) {
      continue;
    }
    node_set-&gt;emplace(to_node);
    GetOutParallelLane(to_node, node_set);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\core\black_list_range_generator.cc" startLine="(65, 0)" endLine="(75, 1)" clone_start="1" clone_end="9">
			<code function_name="GetInParallelLane(const TopoNode* node, std::unordered_set&lt;const TopoNode*&gt;* const node_set)">void GetInParallelLane(const TopoNode* node,
                       std::unordered_set&lt;const TopoNode*&gt;* const node_set) {
  for (const auto* edge : node-&gt;InFromLeftOrRightEdge()) {
    const auto* from_node = edge-&gt;FromNode();
    if (node_set-&gt;find(from_node) != node_set-&gt;end()) {
      continue;
    }
    node_set-&gt;emplace(from_node);
    GetInParallelLane(from_node, node_set);
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_range_manager.cc" startLine="(68, 0)" endLine="(76, 1)" clone_start="1" clone_end="8">
			<code function_name="TopoRangeManager::RangeStart(const TopoNode* node) const">double TopoRangeManager::RangeStart(const TopoNode* node) const {
  const auto iter = range_map_.find(node);
  if (iter == range_map_.end()) {
    AERROR &lt;&lt; "Error occured when getting range "
           &lt;&lt; "start of non-existent node in map.";
    exit(-1);
  }
  return iter-&gt;second.front().StartS();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_range_manager.cc" startLine="(78, 0)" endLine="(86, 1)" clone_start="1" clone_end="8">
			<code function_name="TopoRangeManager::RangeEnd(const TopoNode* node) const">double TopoRangeManager::RangeEnd(const TopoNode* node) const {
  const auto iter = range_map_.find(node);
  if (iter == range_map_.end()) {
    AERROR &lt;&lt; "Error occured when getting range "
           &lt;&lt; "end of non-existent node in map.";
    exit(-1);
  }
  return iter-&gt;second.back().EndS();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\onboard\lidar_process.cc" startLine="(193, 0)" endLine="(203, 1)" clone_start="3" clone_end="10">
			<code function_name="LidarProcess::RegistAllAlgorithm()">void LidarProcess::RegistAllAlgorithm() {
  RegisterFactoryDummyROIFilter();
  RegisterFactoryDummySegmentation();
  RegisterFactoryDummyObjectBuilder();
  RegisterFactoryDummyTracker();

  RegisterFactoryHdmapROIFilter();
  RegisterFactoryCNNSegmentation();
  RegisterFactoryMinBoxObjectBuilder();
  RegisterFactoryHmObjectTracker();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\onboard\lidar_process.cc" startLine="(193, 0)" endLine="(203, 1)" clone_start="2" clone_end="9">
			<code function_name="LidarProcess::RegistAllAlgorithm()">void LidarProcess::RegistAllAlgorithm() {
  RegisterFactoryDummyROIFilter();
  RegisterFactoryDummySegmentation();
  RegisterFactoryDummyObjectBuilder();
  RegisterFactoryDummyTracker();

  RegisterFactoryHdmapROIFilter();
  RegisterFactoryCNNSegmentation();
  RegisterFactoryMinBoxObjectBuilder();
  RegisterFactoryHmObjectTracker();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(342, 0)" endLine="(375, 1)" clone_start="18" clone_end="24">
			<code function_name="Spline2dConstraint::AddSecondDerivativeSmoothConstraint()">bool Spline2dConstraint::AddSecondDerivativeSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(6 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(6 * (t_knots_.size() - 2), 1);

  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);
    std::vector&lt;double&gt; derivative_t = DerivativeCoef(rel_t);
    std::vector&lt;double&gt; second_derivative_t = SecondDerivativeCoef(rel_t);
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(6 * i, j + index_offset) = power_t[j];
      affine_equality(6 * i + 1, j + index_offset) = derivative_t[j];
      affine_equality(6 * i + 2, j + index_offset) = second_derivative_t[j];
      affine_equality(6 * i + 3, j + index_offset + spline_order_) = power_t[j];
      affine_equality(6 * i + 4, j + index_offset + spline_order_) =
          derivative_t[j];
      affine_equality(6 * i + 5, j + index_offset + spline_order_) =
          second_derivative_t[j];
    }
    affine_equality(6 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(6 * i + 1, index_offset + 2 * spline_order_ + 1) = -1.0;
    affine_equality(6 * i + 2, index_offset + 2 * spline_order_ + 2) = -2.0;
    affine_equality(6 * i + 3, index_offset + 3 * spline_order_) = -1.0;
    affine_equality(6 * i + 4, index_offset + 3 * spline_order_ + 1) = -1.0;
    affine_equality(6 * i + 5, index_offset + 3 * spline_order_ + 2) = -2.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(378, 0)" endLine="(417, 1)" clone_start="20" clone_end="26">
			<code function_name="Spline2dConstraint::AddThirdDerivativeSmoothConstraint()">bool Spline2dConstraint::AddThirdDerivativeSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(8 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(8 * (t_knots_.size() - 2), 1);

  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);
    std::vector&lt;double&gt; derivative_t = DerivativeCoef(rel_t);
    std::vector&lt;double&gt; second_derivative_t = SecondDerivativeCoef(rel_t);
    std::vector&lt;double&gt; third_derivative_t = ThirdDerivativeCoef(rel_t);
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(8 * i, j + index_offset) = power_t[j];
      affine_equality(8 * i + 1, j + index_offset) = derivative_t[j];
      affine_equality(8 * i + 2, j + index_offset) = second_derivative_t[j];
      affine_equality(8 * i + 3, j + index_offset) = third_derivative_t[j];
      affine_equality(8 * i + 4, j + index_offset + spline_order_) = power_t[j];
      affine_equality(8 * i + 5, j + index_offset + spline_order_) =
          derivative_t[j];
      affine_equality(8 * i + 6, j + index_offset + spline_order_) =
          second_derivative_t[j];
      affine_equality(8 * i + 7, j + index_offset + spline_order_) =
          third_derivative_t[j];
    }
    affine_equality(8 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(8 * i + 1, index_offset + 2 * spline_order_ + 1) = -1.0;
    affine_equality(8 * i + 2, index_offset + 2 * spline_order_ + 2) = -2.0;
    affine_equality(8 * i + 3, index_offset + 2 * spline_order_ + 3) = -6.0;
    affine_equality(8 * i + 4, index_offset + 3 * spline_order_) = -1.0;
    affine_equality(8 * i + 5, index_offset + 3 * spline_order_ + 1) = -1.0;
    affine_equality(8 * i + 6, index_offset + 3 * spline_order_ + 2) = -2.0;
    affine_equality(8 * i + 7, index_offset + 3 * spline_order_ + 3) = -6.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\reference_line\reference_line.cc" startLine="(70, 0)" endLine="(107, 1)" clone_start="4" clone_end="11">
			<code function_name="ReferenceLine::GetReferencePoint(const double s) const">ReferencePoint ReferenceLine::GetReferencePoint(const double s) const {
  const auto&amp; accumulated_s = map_path_.accumulated_s();
  if (s &lt; accumulated_s.front()) {
    AWARN &lt;&lt; "The requested s is before the start point of the reference "
             "line; reference line starts at "
          &lt;&lt; accumulated_s.front() &lt;&lt; ", requested " &lt;&lt; s &lt;&lt; ".";
    ReferencePoint ref_point(map_path_.GetSmoothPoint(s), 0.0, 0.0, 0.0, 0.0);
    if (ref_point.lane_waypoints().empty()) {
      ref_point.add_lane_waypoints(reference_points_.front().lane_waypoints());
    }
    return ref_point;
  }
  if (s &gt; accumulated_s.back()) {
    AWARN &lt;&lt; "The requested s exceeds the reference line; reference line "
             "ends at "
          &lt;&lt; accumulated_s.back() &lt;&lt; "requested " &lt;&lt; s &lt;&lt; " .";
    ReferencePoint ref_point(map_path_.GetSmoothPoint(s), 0.0, 0.0, 0.0, 0.0);
    if (ref_point.lane_waypoints().empty()) {
      ref_point.add_lane_waypoints(reference_points_.back().lane_waypoints());
    }
    return ref_point;
  }

  auto it_lower =
      std::lower_bound(accumulated_s.begin(), accumulated_s.end(), s);
  if (it_lower == accumulated_s.begin()) {
    return reference_points_.front();
  } else {
    auto index = std::distance(accumulated_s.begin(), it_lower);
    const auto&amp; p0 = reference_points_[index - 1];
    const auto&amp; p1 = reference_points_[index];

    const double s0 = accumulated_s[index - 1];
    const double s1 = accumulated_s[index];

    return Interpolate(p0, s0, p1, s1, s);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\reference_line\reference_line.cc" startLine="(70, 0)" endLine="(107, 1)" clone_start="14" clone_end="21">
			<code function_name="ReferenceLine::GetReferencePoint(const double s) const">ReferencePoint ReferenceLine::GetReferencePoint(const double s) const {
  const auto&amp; accumulated_s = map_path_.accumulated_s();
  if (s &lt; accumulated_s.front()) {
    AWARN &lt;&lt; "The requested s is before the start point of the reference "
             "line; reference line starts at "
          &lt;&lt; accumulated_s.front() &lt;&lt; ", requested " &lt;&lt; s &lt;&lt; ".";
    ReferencePoint ref_point(map_path_.GetSmoothPoint(s), 0.0, 0.0, 0.0, 0.0);
    if (ref_point.lane_waypoints().empty()) {
      ref_point.add_lane_waypoints(reference_points_.front().lane_waypoints());
    }
    return ref_point;
  }
  if (s &gt; accumulated_s.back()) {
    AWARN &lt;&lt; "The requested s exceeds the reference line; reference line "
             "ends at "
          &lt;&lt; accumulated_s.back() &lt;&lt; "requested " &lt;&lt; s &lt;&lt; " .";
    ReferencePoint ref_point(map_path_.GetSmoothPoint(s), 0.0, 0.0, 0.0, 0.0);
    if (ref_point.lane_waypoints().empty()) {
      ref_point.add_lane_waypoints(reference_points_.back().lane_waypoints());
    }
    return ref_point;
  }

  auto it_lower =
      std::lower_bound(accumulated_s.begin(), accumulated_s.end(), s);
  if (it_lower == accumulated_s.begin()) {
    return reference_points_.front();
  } else {
    auto index = std::distance(accumulated_s.begin(), it_lower);
    const auto&amp; p0 = reference_points_[index - 1];
    const auto&amp; p1 = reference_points_[index];

    const double s0 = accumulated_s[index - 1];
    const double s1 = accumulated_s[index];

    return Interpolate(p0, s0, p1, s1, s);
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\aaboxkdtree2d.h" startLine="(350, 2)" endLine="(378, 3)" clone_start="8" clone_end="14">
			<code function_name="PartitionObjects(const std::vector&lt;ObjectPtr&gt; &amp;objects,std::vector&lt;ObjectPtr&gt; *const left_subnode_objects, std::vector&lt;ObjectPtr&gt; *const right_subnode_objects)">  void PartitionObjects(const std::vector&lt;ObjectPtr&gt; &amp;objects,
                        std::vector&lt;ObjectPtr&gt; *const left_subnode_objects,
                        std::vector&lt;ObjectPtr&gt; *const right_subnode_objects) {
    left_subnode_objects-&gt;clear();
    right_subnode_objects-&gt;clear();
    std::vector&lt;ObjectPtr&gt; other_objects;
    if (partition_ == PARTITION_X) {
      for (ObjectPtr object : objects) {
        if (object-&gt;aabox().max_x() &lt;= partition_position_) {
          left_subnode_objects-&gt;push_back(object);
        } else if (object-&gt;aabox().min_x() &gt;= partition_position_) {
          right_subnode_objects-&gt;push_back(object);
        } else {
          other_objects.push_back(object);
        }
      }
    } else {
      for (ObjectPtr object : objects) {
        if (object-&gt;aabox().max_y() &lt;= partition_position_) {
          left_subnode_objects-&gt;push_back(object);
        } else if (object-&gt;aabox().min_y() &gt;= partition_position_) {
          right_subnode_objects-&gt;push_back(object);
        } else {
          other_objects.push_back(object);
        }
      }
    }
    InitObjects(other_objects);
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\aaboxkdtree2d.h" startLine="(350, 2)" endLine="(378, 3)" clone_start="18" clone_end="24">
			<code function_name="PartitionObjects(const std::vector&lt;ObjectPtr&gt; &amp;objects,std::vector&lt;ObjectPtr&gt; *const left_subnode_objects, std::vector&lt;ObjectPtr&gt; *const right_subnode_objects)">  void PartitionObjects(const std::vector&lt;ObjectPtr&gt; &amp;objects,
                        std::vector&lt;ObjectPtr&gt; *const left_subnode_objects,
                        std::vector&lt;ObjectPtr&gt; *const right_subnode_objects) {
    left_subnode_objects-&gt;clear();
    right_subnode_objects-&gt;clear();
    std::vector&lt;ObjectPtr&gt; other_objects;
    if (partition_ == PARTITION_X) {
      for (ObjectPtr object : objects) {
        if (object-&gt;aabox().max_x() &lt;= partition_position_) {
          left_subnode_objects-&gt;push_back(object);
        } else if (object-&gt;aabox().min_x() &gt;= partition_position_) {
          right_subnode_objects-&gt;push_back(object);
        } else {
          other_objects.push_back(object);
        }
      }
    } else {
      for (ObjectPtr object : objects) {
        if (object-&gt;aabox().max_y() &lt;= partition_position_) {
          left_subnode_objects-&gt;push_back(object);
        } else if (object-&gt;aabox().min_y() &gt;= partition_position_) {
          right_subnode_objects-&gt;push_back(object);
        } else {
          other_objects.push_back(object);
        }
      }
    }
    InitObjects(other_objects);
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(142, 0)" endLine="(257, 1)" clone_start="39" clone_end="49">
			<code function_name="LincolnController::chassis()">Chassis LincolnController::chassis() {
  chassis_.Clear();

  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  // 21, 22, previously 1, 2
  if (driving_mode() == Chassis::EMERGENCY_MODE) {
    set_chassis_error_code(Chassis::NO_ERROR);
  }

  chassis_.set_driving_mode(driving_mode());
  chassis_.set_error_code(chassis_error_code());

  // 3
  chassis_.set_engine_started(true);
  // 4
  if (chassis_detail.has_ems() &amp;&amp; chassis_detail.ems().has_engine_rpm()) {
    chassis_.set_engine_rpm(chassis_detail.ems().engine_rpm());
  } else {
    chassis_.set_engine_rpm(0);
  }
  // 5
  if (chassis_detail.has_vehicle_spd() &amp;&amp;
      chassis_detail.vehicle_spd().has_vehicle_spd()) {
    chassis_.set_speed_mps(chassis_detail.vehicle_spd().vehicle_spd());
  } else {
    chassis_.set_speed_mps(0);
  }
  // 6
  chassis_.set_odometer_m(0);
  // 7
  // lincoln only has fuel percentage
  // to avoid confusing, just don't set
  chassis_.set_fuel_range_m(0);
  // 8
  if (chassis_detail.has_gas() &amp;&amp; chassis_detail.gas().has_throttle_output()) {
    chassis_.set_throttle_percentage(chassis_detail.gas().throttle_output());
  } else {
    chassis_.set_throttle_percentage(0);
  }
  // 9
  if (chassis_detail.has_brake() &amp;&amp; chassis_detail.brake().has_brake_output()) {
    chassis_.set_brake_percentage(chassis_detail.brake().brake_output());
  } else {
    chassis_.set_brake_percentage(0);
  }
  // 23, previously 10
  if (chassis_detail.has_gear() &amp;&amp; chassis_detail.gear().has_gear_state()) {
    chassis_.set_gear_location(chassis_detail.gear().gear_state());
  } else {
    chassis_.set_gear_location(Chassis::GEAR_NONE);
  }
  // 11
  if (chassis_detail.has_eps() &amp;&amp; chassis_detail.eps().has_steering_angle()) {
    chassis_.set_steering_percentage(chassis_detail.eps().steering_angle() *
                                     100.0 / params_.max_steer_angle());
  } else {
    chassis_.set_steering_percentage(0);
  }
  // 12
  if (chassis_detail.has_eps() &amp;&amp; chassis_detail.eps().has_epas_torque()) {
    chassis_.set_steering_torque_nm(chassis_detail.eps().epas_torque());
  } else {
    chassis_.set_steering_torque_nm(0);
  }
  // 13
  if (chassis_detail.has_eps() &amp;&amp;
      chassis_detail.epb().has_parking_brake_status()) {
    chassis_.set_parking_brake(chassis_detail.epb().parking_brake_status() ==
                               Epb::PBRAKE_ON);
  } else {
    chassis_.set_parking_brake(false);
  }
  // TODO(Authors): lincoln beam
  // 14, 15

  // 16, 17
  if (chassis_detail.has_light() &amp;&amp;
      chassis_detail.light().has_turn_light_type() &amp;&amp;
      chassis_detail.light().turn_light_type() != Light::TURN_LIGHT_OFF) {
    if (chassis_detail.light().turn_light_type() == Light::TURN_LEFT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(
          common::VehicleSignal::TURN_LEFT);
    } else if (chassis_detail.light().turn_light_type() ==
               Light::TURN_RIGHT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(
          common::VehicleSignal::TURN_RIGHT);
    } else {
      chassis_.mutable_signal()-&gt;set_turn_signal(
          common::VehicleSignal::TURN_NONE);
    }
  } else {
    chassis_.mutable_signal()-&gt;set_turn_signal(
        common::VehicleSignal::TURN_NONE);
  }
  // 18
  if (chassis_detail.has_light() &amp;&amp; chassis_detail.light().has_is_horn_on() &amp;&amp;
      chassis_detail.light().is_horn_on()) {
    chassis_.mutable_signal()-&gt;set_horn(true);
  } else {
    chassis_.mutable_signal()-&gt;set_horn(false);
  }

  // 19, lincoln wiper is too complicated
  // 24
  if (chassis_detail.has_eps() &amp;&amp; chassis_detail.eps().has_timestamp_65()) {
    chassis_.set_steering_timestamp(chassis_detail.eps().timestamp_65());
  }
  // 26
  if (chassis_error_mask_) {
    chassis_.set_chassis_error_mask(chassis_error_mask_);
  }

  return chassis_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(142, 0)" endLine="(257, 1)" clone_start="58" clone_end="68">
			<code function_name="LincolnController::chassis()">Chassis LincolnController::chassis() {
  chassis_.Clear();

  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  // 21, 22, previously 1, 2
  if (driving_mode() == Chassis::EMERGENCY_MODE) {
    set_chassis_error_code(Chassis::NO_ERROR);
  }

  chassis_.set_driving_mode(driving_mode());
  chassis_.set_error_code(chassis_error_code());

  // 3
  chassis_.set_engine_started(true);
  // 4
  if (chassis_detail.has_ems() &amp;&amp; chassis_detail.ems().has_engine_rpm()) {
    chassis_.set_engine_rpm(chassis_detail.ems().engine_rpm());
  } else {
    chassis_.set_engine_rpm(0);
  }
  // 5
  if (chassis_detail.has_vehicle_spd() &amp;&amp;
      chassis_detail.vehicle_spd().has_vehicle_spd()) {
    chassis_.set_speed_mps(chassis_detail.vehicle_spd().vehicle_spd());
  } else {
    chassis_.set_speed_mps(0);
  }
  // 6
  chassis_.set_odometer_m(0);
  // 7
  // lincoln only has fuel percentage
  // to avoid confusing, just don't set
  chassis_.set_fuel_range_m(0);
  // 8
  if (chassis_detail.has_gas() &amp;&amp; chassis_detail.gas().has_throttle_output()) {
    chassis_.set_throttle_percentage(chassis_detail.gas().throttle_output());
  } else {
    chassis_.set_throttle_percentage(0);
  }
  // 9
  if (chassis_detail.has_brake() &amp;&amp; chassis_detail.brake().has_brake_output()) {
    chassis_.set_brake_percentage(chassis_detail.brake().brake_output());
  } else {
    chassis_.set_brake_percentage(0);
  }
  // 23, previously 10
  if (chassis_detail.has_gear() &amp;&amp; chassis_detail.gear().has_gear_state()) {
    chassis_.set_gear_location(chassis_detail.gear().gear_state());
  } else {
    chassis_.set_gear_location(Chassis::GEAR_NONE);
  }
  // 11
  if (chassis_detail.has_eps() &amp;&amp; chassis_detail.eps().has_steering_angle()) {
    chassis_.set_steering_percentage(chassis_detail.eps().steering_angle() *
                                     100.0 / params_.max_steer_angle());
  } else {
    chassis_.set_steering_percentage(0);
  }
  // 12
  if (chassis_detail.has_eps() &amp;&amp; chassis_detail.eps().has_epas_torque()) {
    chassis_.set_steering_torque_nm(chassis_detail.eps().epas_torque());
  } else {
    chassis_.set_steering_torque_nm(0);
  }
  // 13
  if (chassis_detail.has_eps() &amp;&amp;
      chassis_detail.epb().has_parking_brake_status()) {
    chassis_.set_parking_brake(chassis_detail.epb().parking_brake_status() ==
                               Epb::PBRAKE_ON);
  } else {
    chassis_.set_parking_brake(false);
  }
  // TODO(Authors): lincoln beam
  // 14, 15

  // 16, 17
  if (chassis_detail.has_light() &amp;&amp;
      chassis_detail.light().has_turn_light_type() &amp;&amp;
      chassis_detail.light().turn_light_type() != Light::TURN_LIGHT_OFF) {
    if (chassis_detail.light().turn_light_type() == Light::TURN_LEFT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(
          common::VehicleSignal::TURN_LEFT);
    } else if (chassis_detail.light().turn_light_type() ==
               Light::TURN_RIGHT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(
          common::VehicleSignal::TURN_RIGHT);
    } else {
      chassis_.mutable_signal()-&gt;set_turn_signal(
          common::VehicleSignal::TURN_NONE);
    }
  } else {
    chassis_.mutable_signal()-&gt;set_turn_signal(
        common::VehicleSignal::TURN_NONE);
  }
  // 18
  if (chassis_detail.has_light() &amp;&amp; chassis_detail.light().has_is_horn_on() &amp;&amp;
      chassis_detail.light().is_horn_on()) {
    chassis_.mutable_signal()-&gt;set_horn(true);
  } else {
    chassis_.mutable_signal()-&gt;set_horn(false);
  }

  // 19, lincoln wiper is too complicated
  // 24
  if (chassis_detail.has_eps() &amp;&amp; chassis_detail.eps().has_timestamp_65()) {
    chassis_.set_steering_timestamp(chassis_detail.eps().timestamp_65());
  }
  // 26
  if (chassis_error_mask_) {
    chassis_.set_chassis_error_mask(chassis_error_mask_);
  }

  return chassis_;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\reference_line\reference_line.cc" startLine="(125, 0)" endLine="(164, 1)" clone_start="12" clone_end="19">
			<code function_name="ReferenceLine::GetReferencePoint(const double x, const double y) const">ReferencePoint ReferenceLine::GetReferencePoint(const double x,
                                                const double y) const {
  CHECK_GE(reference_points_.size(), 0);

  auto func_distance_square = [](const ReferencePoint&amp; point, const double x,
                                 const double y) {
    double dx = point.x() - x;
    double dy = point.y() - y;
    return dx * dx + dy * dy;
  };

  double d_min = func_distance_square(reference_points_.front(), x, y);
  double index_min = 0;

  for (uint32_t i = 1; i &lt; reference_points_.size(); ++i) {
    double d_temp = func_distance_square(reference_points_[i], x, y);
    if (d_temp &lt; d_min) {
      d_min = d_temp;
      index_min = i;
    }
  }

  uint32_t index_start = (index_min == 0 ? index_min : index_min - 1);
  uint32_t index_end =
      (index_min + 1 == reference_points_.size() ? index_min : index_min + 1);

  if (index_start == index_end) {
    return reference_points_[index_start];
  }

  double s0 = map_path_.accumulated_s()[index_start];
  double s1 = map_path_.accumulated_s()[index_end];

  double s = ReferenceLine::FindMinDistancePoint(
      reference_points_[index_start], s0, reference_points_[index_end], s1, x,
      y);

  return Interpolate(reference_points_[index_start], s0,
                     reference_points_[index_end], s1, s);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\common\trajectory_analyzer.cc" startLine="(65, 0)" endLine="(91, 1)" clone_start="3" clone_end="10">
			<code function_name="TrajectoryAnalyzer::QueryMatchedPathPoint(const double x, const double y) const">PathPoint TrajectoryAnalyzer::QueryMatchedPathPoint(const double x,
                                                    const double y) const {
  double d_min = PointDistanceSquare(trajectory_points_.front(), x, y);
  size_t index_min = 0;

  for (size_t i = 1; i &lt; trajectory_points_.size(); ++i) {
    double d_temp = PointDistanceSquare(trajectory_points_[i], x, y);
    if (d_temp &lt; d_min) {
      d_min = d_temp;
      index_min = i;
    }
  }

  size_t index_start = index_min == 0 ? index_min : index_min - 1;
  size_t index_end =
      index_min + 1 == trajectory_points_.size() ? index_min : index_min + 1;

  if (index_start == index_end ||
      math::DoubleCompare(trajectory_points_[index_start].path_point().s(),
                          trajectory_points_[index_end].path_point().s()) ==
          0) {
    return TrajectoryPointToPathPoint(trajectory_points_[index_start]);
  }

  return FindMinDistancePoint(trajectory_points_[index_start],
                              trajectory_points_[index_end], x, y);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\common\trajectory_analyzer.cc" startLine="(175, 0)" endLine="(188, 1)" clone_start="3" clone_end="10">
			<code function_name="TrajectoryAnalyzer::QueryNearestPointByPosition( const double x, const double y) const">TrajectoryPoint TrajectoryAnalyzer::QueryNearestPointByPosition(
    const double x, const double y) const {
  double d_min = PointDistanceSquare(trajectory_points_.front(), x, y);
  size_t index_min = 0;

  for (size_t i = 1; i &lt; trajectory_points_.size(); ++i) {
    double d_temp = PointDistanceSquare(trajectory_points_[i], x, y);
    if (d_temp &lt; d_min) {
      d_min = d_temp;
      index_min = i;
    }
  }
  return trajectory_points_[index_min];
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(614, 0)" endLine="(683, 1)" clone_start="24" clone_end="33">
			<code function_name="LincolnController::SecurityDogThreadFunc()">void LincolnController::SecurityDogThreadFunc() {
  if (can_sender_ == nullptr) {
    AERROR &lt;&lt; "Fail to run SecurityDogThreadFunc() because can_sender_ is "
              "nullptr.";
    return;
  }
  while (!can_sender_-&gt;IsRunning()) {
    std::this_thread::yield();
  }

  std::chrono::duration&lt;double, std::micro&gt; default_period{50000};
  int64_t start =
      common::time::AsInt64&lt;common::time::micros&gt;(
          common::time::Clock::Now());

  int32_t speed_ctrl_fail = 0;
  int32_t steer_ctrl_fail = 0;

  while (can_sender_-&gt;IsRunning()) {
    const Chassis::DrivingMode mode = driving_mode();
    bool emergency_mode = false;

    // 1. steer control check
    if ((mode == Chassis::COMPLETE_AUTO_DRIVE ||
         mode == Chassis::AUTO_STEER_ONLY) &amp;&amp;
        CheckResponse(CHECK_RESPONSE_STEER_UNIT_FLAG, false) == false) {
      ++steer_ctrl_fail;
      if (steer_ctrl_fail &gt;= kMaxFailAttempt) {
        emergency_mode = true;
        set_chassis_error_code(Chassis::MANUAL_INTERVENTION);
      }
    } else {
      steer_ctrl_fail = 0;
    }

    // 2. speed control check
    if ((mode == Chassis::COMPLETE_AUTO_DRIVE ||
         mode == Chassis::AUTO_SPEED_ONLY) &amp;&amp;
        CheckResponse(CHECK_RESPONSE_SPEED_UNIT_FLAG, false) == false) {
      ++speed_ctrl_fail;
      if (speed_ctrl_fail &gt;= kMaxFailAttempt) {
        emergency_mode = true;
        set_chassis_error_code(Chassis::MANUAL_INTERVENTION);
      }
    } else {
      speed_ctrl_fail = 0;
    }
    if (CheckChassisError()) {
      set_chassis_error_code(Chassis::CHASSIS_ERROR);
      emergency_mode = true;
    }

    if (emergency_mode &amp;&amp; mode != Chassis::EMERGENCY_MODE) {
      Emergency();
    }
    int64_t end =
        common::time::AsInt64&lt;common::time::micros&gt;(
            common::time::Clock::Now());
    std::chrono::duration&lt;double, std::micro&gt; elapsed{end - start};
    if (elapsed &lt; default_period) {
      std::this_thread::sleep_for(default_period - elapsed);
      start += (default_period - elapsed).count();
    } else {
      AERROR_EVERY(100)
          &lt;&lt; "Too much time consumption in LincolnController looping process:"
          &lt;&lt; elapsed.count();
      start = end;
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(614, 0)" endLine="(683, 1)" clone_start="37" clone_end="46">
			<code function_name="LincolnController::SecurityDogThreadFunc()">void LincolnController::SecurityDogThreadFunc() {
  if (can_sender_ == nullptr) {
    AERROR &lt;&lt; "Fail to run SecurityDogThreadFunc() because can_sender_ is "
              "nullptr.";
    return;
  }
  while (!can_sender_-&gt;IsRunning()) {
    std::this_thread::yield();
  }

  std::chrono::duration&lt;double, std::micro&gt; default_period{50000};
  int64_t start =
      common::time::AsInt64&lt;common::time::micros&gt;(
          common::time::Clock::Now());

  int32_t speed_ctrl_fail = 0;
  int32_t steer_ctrl_fail = 0;

  while (can_sender_-&gt;IsRunning()) {
    const Chassis::DrivingMode mode = driving_mode();
    bool emergency_mode = false;

    // 1. steer control check
    if ((mode == Chassis::COMPLETE_AUTO_DRIVE ||
         mode == Chassis::AUTO_STEER_ONLY) &amp;&amp;
        CheckResponse(CHECK_RESPONSE_STEER_UNIT_FLAG, false) == false) {
      ++steer_ctrl_fail;
      if (steer_ctrl_fail &gt;= kMaxFailAttempt) {
        emergency_mode = true;
        set_chassis_error_code(Chassis::MANUAL_INTERVENTION);
      }
    } else {
      steer_ctrl_fail = 0;
    }

    // 2. speed control check
    if ((mode == Chassis::COMPLETE_AUTO_DRIVE ||
         mode == Chassis::AUTO_SPEED_ONLY) &amp;&amp;
        CheckResponse(CHECK_RESPONSE_SPEED_UNIT_FLAG, false) == false) {
      ++speed_ctrl_fail;
      if (speed_ctrl_fail &gt;= kMaxFailAttempt) {
        emergency_mode = true;
        set_chassis_error_code(Chassis::MANUAL_INTERVENTION);
      }
    } else {
      speed_ctrl_fail = 0;
    }
    if (CheckChassisError()) {
      set_chassis_error_code(Chassis::CHASSIS_ERROR);
      emergency_mode = true;
    }

    if (emergency_mode &amp;&amp; mode != Chassis::EMERGENCY_MODE) {
      Emergency();
    }
    int64_t end =
        common::time::AsInt64&lt;common::time::micros&gt;(
            common::time::Clock::Now());
    std::chrono::duration&lt;double, std::micro&gt; elapsed{end - start};
    if (elapsed &lt; default_period) {
      std::this_thread::sleep_for(default_period - elapsed);
      start += (default_period - elapsed).count();
    } else {
      AERROR_EVERY(100)
          &lt;&lt; "Too much time consumption in LincolnController looping process:"
          &lt;&lt; elapsed.count();
      start = end;
    }
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.cc" startLine="(133, 0)" endLine="(318, 1)" clone_start="76" clone_end="83">
			<code function_name="MinBoxObjectBuilder::ReconstructPolygon(const Eigen::Vector3d &amp;ref_ct, ObjectPtr obj)">void  MinBoxObjectBuilder::ReconstructPolygon(
        const Eigen::Vector3d &amp;ref_ct,
        ObjectPtr obj) {
    if (obj-&gt;polygon.points.size() &lt;= 0) {
        return;
    }
    size_t max_point_index = 0;
    size_t min_point_index = 0;
    Eigen::Vector3d p;
    p[0] = obj-&gt;polygon.points[0].x;
    p[1] = obj-&gt;polygon.points[0].y;
    p[2] = obj-&gt;polygon.points[0].z;
    Eigen::Vector3d max_point = p - ref_ct;
    Eigen::Vector3d min_point = p - ref_ct;
    for (size_t i = 1; i &lt; obj-&gt;polygon.points.size(); ++i) {
        Eigen::Vector3d p;
        p[0] = obj-&gt;polygon.points[i].x;
        p[1] = obj-&gt;polygon.points[i].y;
        p[2] = obj-&gt;polygon.points[i].z;
        Eigen::Vector3d ray = p - ref_ct;
        // clock direction
        if (max_point[0] * ray[1] - ray[0] * max_point[1] &lt; EPSILON) {
            max_point = ray;
            max_point_index = i;
        }
        // unclock direction
        if (min_point[0] * ray[1] - ray[0] * min_point[1] &gt; EPSILON) {
            min_point = ray;
            min_point_index = i;
        }
    }
    Eigen::Vector3d line = max_point - min_point;
    double total_len = 0;
    double max_dis = 0;
    bool has_out = false;
    for (size_t i = min_point_index, count = 0;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist = sqrt((p[0] - p_x[0]) * (p[0] - p_x[0])
                        + (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist - max_dis &gt; EPSILON) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                   || (i == max_point_index &amp;&amp; j == min_point_index)) {
            size_t k = (j + 1) % obj-&gt;polygon.points.size();
            Eigen::Vector3d p_k;
            p_k[0] = obj-&gt;polygon.points[k].x;
            p_k[1] = obj-&gt;polygon.points[k].y;
            p_k[2] = obj-&gt;polygon.points[k].z;
            Eigen::Vector3d p_j;
            p_j[0] = obj-&gt;polygon.points[j].x;
            p_j[1] = obj-&gt;polygon.points[j].y;
            p_j[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
            } else {
                // outline
                has_out = true;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p_x - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist =
                        sqrt((p[0] - p_x[0]) * (p[0] - p_x[0]) +
                            (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist &gt; max_dis) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        }
    }
    size_t count = 0;
    double min_area = std::numeric_limits&lt;double&gt;::max();
    for (size_t i = min_point_index;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        Eigen::Vector3d p_j;
        p_j[0] = obj-&gt;polygon.points[j].x;
        p_j[1] = obj-&gt;polygon.points[j].y;
        p_j[2] = obj-&gt;polygon.points[j].z;
        double dist = sqrt((p_x[0] - p_j[0]) * (p_x[0] - p_j[0])
                + (p_x[1] - p_j[1])* (p_x[1] - p_j[1]));
        if (dist &lt; max_dis &amp;&amp; (dist / total_len) &lt; 0.5) {
            continue;
        }
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0;
                double width = 0;
                Eigen::Vector3d dir;
                double area =
                    ComputeAreaAlongOneEdge(obj, i,
                                        &amp;center, &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                    || (i == max_point_index &amp;&amp; j == min_point_index)) {
            if (!has_out) {
                continue;
            }
            Eigen::Vector3d center;
            double length = 0;
            double width = 0;
            Eigen::Vector3d dir;
            double area =
               ComputeAreaAlongOneEdge(obj, i, &amp;center, &amp;length, &amp;width, &amp;dir);
            if (area &lt; min_area) {
                obj-&gt;center = center;
                obj-&gt;length = length;
                obj-&gt;width = width;
                obj-&gt;direction = dir;
                min_area = area;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[i].x;
            p[1] = obj-&gt;polygon.points[i].y;
            p[2] = obj-&gt;polygon.points[i].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0.0;
                double width = 0.0;
                Eigen::Vector3d dir;
                double area =
                   ComputeAreaAlongOneEdge(obj, i, &amp;center,
                                           &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        }
    }
    obj-&gt;direction.normalize();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.cc" startLine="(133, 0)" endLine="(318, 1)" clone_start="157" clone_end="164">
			<code function_name="MinBoxObjectBuilder::ReconstructPolygon(const Eigen::Vector3d &amp;ref_ct, ObjectPtr obj)">void  MinBoxObjectBuilder::ReconstructPolygon(
        const Eigen::Vector3d &amp;ref_ct,
        ObjectPtr obj) {
    if (obj-&gt;polygon.points.size() &lt;= 0) {
        return;
    }
    size_t max_point_index = 0;
    size_t min_point_index = 0;
    Eigen::Vector3d p;
    p[0] = obj-&gt;polygon.points[0].x;
    p[1] = obj-&gt;polygon.points[0].y;
    p[2] = obj-&gt;polygon.points[0].z;
    Eigen::Vector3d max_point = p - ref_ct;
    Eigen::Vector3d min_point = p - ref_ct;
    for (size_t i = 1; i &lt; obj-&gt;polygon.points.size(); ++i) {
        Eigen::Vector3d p;
        p[0] = obj-&gt;polygon.points[i].x;
        p[1] = obj-&gt;polygon.points[i].y;
        p[2] = obj-&gt;polygon.points[i].z;
        Eigen::Vector3d ray = p - ref_ct;
        // clock direction
        if (max_point[0] * ray[1] - ray[0] * max_point[1] &lt; EPSILON) {
            max_point = ray;
            max_point_index = i;
        }
        // unclock direction
        if (min_point[0] * ray[1] - ray[0] * min_point[1] &gt; EPSILON) {
            min_point = ray;
            min_point_index = i;
        }
    }
    Eigen::Vector3d line = max_point - min_point;
    double total_len = 0;
    double max_dis = 0;
    bool has_out = false;
    for (size_t i = min_point_index, count = 0;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist = sqrt((p[0] - p_x[0]) * (p[0] - p_x[0])
                        + (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist - max_dis &gt; EPSILON) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                   || (i == max_point_index &amp;&amp; j == min_point_index)) {
            size_t k = (j + 1) % obj-&gt;polygon.points.size();
            Eigen::Vector3d p_k;
            p_k[0] = obj-&gt;polygon.points[k].x;
            p_k[1] = obj-&gt;polygon.points[k].y;
            p_k[2] = obj-&gt;polygon.points[k].z;
            Eigen::Vector3d p_j;
            p_j[0] = obj-&gt;polygon.points[j].x;
            p_j[1] = obj-&gt;polygon.points[j].y;
            p_j[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
            } else {
                // outline
                has_out = true;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p_x - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist =
                        sqrt((p[0] - p_x[0]) * (p[0] - p_x[0]) +
                            (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist &gt; max_dis) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        }
    }
    size_t count = 0;
    double min_area = std::numeric_limits&lt;double&gt;::max();
    for (size_t i = min_point_index;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        Eigen::Vector3d p_j;
        p_j[0] = obj-&gt;polygon.points[j].x;
        p_j[1] = obj-&gt;polygon.points[j].y;
        p_j[2] = obj-&gt;polygon.points[j].z;
        double dist = sqrt((p_x[0] - p_j[0]) * (p_x[0] - p_j[0])
                + (p_x[1] - p_j[1])* (p_x[1] - p_j[1]));
        if (dist &lt; max_dis &amp;&amp; (dist / total_len) &lt; 0.5) {
            continue;
        }
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0;
                double width = 0;
                Eigen::Vector3d dir;
                double area =
                    ComputeAreaAlongOneEdge(obj, i,
                                        &amp;center, &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                    || (i == max_point_index &amp;&amp; j == min_point_index)) {
            if (!has_out) {
                continue;
            }
            Eigen::Vector3d center;
            double length = 0;
            double width = 0;
            Eigen::Vector3d dir;
            double area =
               ComputeAreaAlongOneEdge(obj, i, &amp;center, &amp;length, &amp;width, &amp;dir);
            if (area &lt; min_area) {
                obj-&gt;center = center;
                obj-&gt;length = length;
                obj-&gt;width = width;
                obj-&gt;direction = dir;
                min_area = area;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[i].x;
            p[1] = obj-&gt;polygon.points[i].y;
            p[2] = obj-&gt;polygon.points[i].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0.0;
                double width = 0.0;
                Eigen::Vector3d dir;
                double area =
                   ComputeAreaAlongOneEdge(obj, i, &amp;center,
                                           &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        }
    }
    obj-&gt;direction.normalize();
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(437, 0)" endLine="(449, 1)" clone_start="12" clone_end="13">
			<code function_name="Spline2dConstraint::AffineCoef(const double angle, const double t) const">std::vector&lt;double&gt; Spline2dConstraint::AffineCoef(const double angle,
                                                   const double t) const {
  std::vector&lt;double&gt; result(spline_order_ * 2, 0.0);
  double x_coef = -std::sin(angle);
  double y_coef = std::cos(angle);
  for (std::uint32_t i = 0; i &lt; spline_order_; ++i) {
    result[i] = x_coef;
    result[i + spline_order_] = y_coef;
    x_coef *= t;
    y_coef *= t;
  }
  return result;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(451, 0)" endLine="(462, 1)" clone_start="11" clone_end="12">
			<code function_name="Spline2dConstraint::AffineDerivativeCoef( const double angle, const double t) const">std::vector&lt;double&gt; Spline2dConstraint::AffineDerivativeCoef(
    const double angle, const double t) const {
  std::vector&lt;double&gt; result(spline_order_ * 2, 0.0);
  double x_coef = -std::sin(angle);
  double y_coef = std::cos(angle);
  std::vector&lt;double&gt; power_t = PolyCoef(t);
  for (std::uint32_t i = 1; i &lt; spline_order_; ++i) {
    result[i] = x_coef * power_t[i - 1] * i;
    result[i + spline_order_] = y_coef * power_t[i - 1] * i;
  }
  return result;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(464, 0)" endLine="(475, 1)" clone_start="11" clone_end="12">
			<code function_name="Spline2dConstraint::AffineSecondDerivativeCoef( const double angle, const double t) const">std::vector&lt;double&gt; Spline2dConstraint::AffineSecondDerivativeCoef(
    const double angle, const double t) const {
  std::vector&lt;double&gt; result(spline_order_ * 2, 0.0);
  double x_coef = -std::sin(angle);
  double y_coef = std::cos(angle);
  std::vector&lt;double&gt; power_t = PolyCoef(t);
  for (std::uint32_t i = 2; i &lt; spline_order_; ++i) {
    result[i] = x_coef * power_t[i - 2] * i * (i - 1);
    result[i + spline_order_] = y_coef * power_t[i - 2] * i * (i - 1);
  }
  return result;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(451, 0)" endLine="(462, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline2dConstraint::AffineDerivativeCoef( const double angle, const double t) const">std::vector&lt;double&gt; Spline2dConstraint::AffineDerivativeCoef(
    const double angle, const double t) const {
  std::vector&lt;double&gt; result(spline_order_ * 2, 0.0);
  double x_coef = -std::sin(angle);
  double y_coef = std::cos(angle);
  std::vector&lt;double&gt; power_t = PolyCoef(t);
  for (std::uint32_t i = 1; i &lt; spline_order_; ++i) {
    result[i] = x_coef * power_t[i - 1] * i;
    result[i + spline_order_] = y_coef * power_t[i - 1] * i;
  }
  return result;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(464, 0)" endLine="(475, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline2dConstraint::AffineSecondDerivativeCoef( const double angle, const double t) const">std::vector&lt;double&gt; Spline2dConstraint::AffineSecondDerivativeCoef(
    const double angle, const double t) const {
  std::vector&lt;double&gt; result(spline_order_ * 2, 0.0);
  double x_coef = -std::sin(angle);
  double y_coef = std::cos(angle);
  std::vector&lt;double&gt; power_t = PolyCoef(t);
  for (std::uint32_t i = 2; i &lt; spline_order_; ++i) {
    result[i] = x_coef * power_t[i - 2] * i * (i - 1);
    result[i + spline_order_] = y_coef * power_t[i - 2] * i * (i - 1);
  }
  return result;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(477, 0)" endLine="(488, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline2dConstraint::AffineThirdDerivativeCoef( const double angle, const double t) const">std::vector&lt;double&gt; Spline2dConstraint::AffineThirdDerivativeCoef(
    const double angle, const double t) const {
  std::vector&lt;double&gt; result(spline_order_ * 2, 0.0);
  double x_coef = -std::sin(angle);
  double y_coef = std::cos(angle);
  std::vector&lt;double&gt; power_t = PolyCoef(t);
  for (std::uint32_t i = 3; i &lt; spline_order_; ++i) {
    result[i] = x_coef * power_t[i - 3] * i * (i - 1) * (i - 2);
    result[i + spline_order_] = y_coef * power_t[i - 3] * i * (i - 1) * (i - 2);
  }
  return result;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(506, 0)" endLine="(558, 1)" clone_start="32" clone_end="39">
			<code function_name="Obstacle::UpdateKFLaneTrackers(Feature* feature)">void Obstacle::UpdateKFLaneTrackers(Feature* feature) {
  if (!feature-&gt;has_lane()) {
    return;
  }
  std::unordered_set&lt;std::string&gt; lane_ids;
  for (auto&amp; lane_feature : feature-&gt;lane().current_lane_feature()) {
    if (!lane_feature.lane_id().empty()) {
      lane_ids.insert(lane_feature.lane_id());
    }
  }
  for (auto&amp; lane_feature : feature-&gt;lane().nearby_lane_feature()) {
    if (!lane_feature.lane_id().empty()) {
      lane_ids.insert(lane_feature.lane_id());
    }
  }
  if (lane_ids.empty()) {
    return;
  }

  auto iter = kf_lane_trackers_.begin();
  while (iter != kf_lane_trackers_.end()) {
    if (lane_ids.find(iter-&gt;first) == lane_ids.end()) {
      iter = kf_lane_trackers_.erase(iter);
    } else {
      ++iter;
    }
  }

  double ts = feature-&gt;timestamp();
  double speed = feature-&gt;speed();
  double acc = feature-&gt;acc();
  for (auto&amp; lane_feature : feature-&gt;lane().current_lane_feature()) {
    std::string lane_id = lane_feature.lane_id();
    if (lane_id.empty()) {
      continue;
    }
    double s = lane_feature.lane_s();
    double l = lane_feature.lane_l();
    UpdateKFLaneTracker(lane_id, s, l, speed, acc, ts, FLAGS_go_approach_rate);
  }
  for (auto&amp; nearby_lane_feature : feature-&gt;lane().nearby_lane_feature()) {
    std::string lane_id = nearby_lane_feature.lane_id();
    if (lane_id.empty()) {
      continue;
    }
    double s = nearby_lane_feature.lane_s();
    double l = nearby_lane_feature.lane_l();
    UpdateKFLaneTracker(lane_id, s, l, speed, acc, ts,
                        FLAGS_cutin_approach_rate);
  }

  UpdateLaneBelief(feature);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(506, 0)" endLine="(558, 1)" clone_start="41" clone_end="48">
			<code function_name="Obstacle::UpdateKFLaneTrackers(Feature* feature)">void Obstacle::UpdateKFLaneTrackers(Feature* feature) {
  if (!feature-&gt;has_lane()) {
    return;
  }
  std::unordered_set&lt;std::string&gt; lane_ids;
  for (auto&amp; lane_feature : feature-&gt;lane().current_lane_feature()) {
    if (!lane_feature.lane_id().empty()) {
      lane_ids.insert(lane_feature.lane_id());
    }
  }
  for (auto&amp; lane_feature : feature-&gt;lane().nearby_lane_feature()) {
    if (!lane_feature.lane_id().empty()) {
      lane_ids.insert(lane_feature.lane_id());
    }
  }
  if (lane_ids.empty()) {
    return;
  }

  auto iter = kf_lane_trackers_.begin();
  while (iter != kf_lane_trackers_.end()) {
    if (lane_ids.find(iter-&gt;first) == lane_ids.end()) {
      iter = kf_lane_trackers_.erase(iter);
    } else {
      ++iter;
    }
  }

  double ts = feature-&gt;timestamp();
  double speed = feature-&gt;speed();
  double acc = feature-&gt;acc();
  for (auto&amp; lane_feature : feature-&gt;lane().current_lane_feature()) {
    std::string lane_id = lane_feature.lane_id();
    if (lane_id.empty()) {
      continue;
    }
    double s = lane_feature.lane_s();
    double l = lane_feature.lane_l();
    UpdateKFLaneTracker(lane_id, s, l, speed, acc, ts, FLAGS_go_approach_rate);
  }
  for (auto&amp; nearby_lane_feature : feature-&gt;lane().nearby_lane_feature()) {
    std::string lane_id = nearby_lane_feature.lane_id();
    if (lane_id.empty()) {
      continue;
    }
    double s = nearby_lane_feature.lane_s();
    double l = nearby_lane_feature.lane_l();
    UpdateKFLaneTracker(lane_id, s, l, speed, acc, ts,
                        FLAGS_cutin_approach_rate);
  }

  UpdateLaneBelief(feature);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\polygon2d.cc" startLine="(348, 0)" endLine="(388, 1)" clone_start="29" clone_end="36">
			<code function_name="Polygon2d::GetOverlap(const LineSegment2d &amp;line_segment, Vec2d *const first, Vec2d *const last) const">bool Polygon2d::GetOverlap(const LineSegment2d &amp;line_segment,
                           Vec2d *const first, Vec2d *const last) const {
  CHECK_GE(points_.size(), 3);
  CHECK_NOTNULL(first);
  CHECK_NOTNULL(last);

  if (line_segment.length() &lt;= kMathEpsilon) {
    if (!IsPointIn(line_segment.start())) {
      return false;
    }
    *first = line_segment.start();
    *last = line_segment.start();
    return true;
  }

  double min_proj = line_segment.length();
  double max_proj = 0;
  if (IsPointIn(line_segment.start())) {
    *first = line_segment.start();
    min_proj = 0.0;
  }
  if (IsPointIn(line_segment.end())) {
    *last = line_segment.end();
    max_proj = line_segment.length();
  }
  for (const auto &amp;poly_seg : line_segments_) {
    Vec2d pt;
    if (poly_seg.GetIntersect(line_segment, &amp;pt)) {
      const double proj = line_segment.ProjectOntoUnit(pt);
      if (proj &lt; min_proj) {
        min_proj = proj;
        *first = pt;
      }
      if (proj &gt; max_proj) {
        max_proj = proj;
        *last = pt;
      }
    }
  }
  return min_proj &lt;= max_proj + kMathEpsilon;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\polygon2d.cc" startLine="(444, 0)" endLine="(464, 1)" clone_start="11" clone_end="18">
			<code function_name="Polygon2d::ExtremePoints(const double heading, Vec2d *const first, Vec2d *const last) const">void Polygon2d::ExtremePoints(const double heading, Vec2d *const first,
                              Vec2d *const last) const {
  CHECK_GE(points_.size(), 3);
  CHECK_NOTNULL(first);
  CHECK_NOTNULL(last);

  const Vec2d direction_vec = Vec2d::CreateUnitVec2d(heading);
  double min_proj = std::numeric_limits&lt;double&gt;::infinity();
  double max_proj = -std::numeric_limits&lt;double&gt;::infinity();
  for (const auto &amp;pt : points_) {
    const double proj = pt.InnerProd(direction_vec);
    if (proj &lt; min_proj) {
      min_proj = proj;
      *first = pt;
    }
    if (proj &gt; max_proj) {
      max_proj = proj;
      *last = pt;
    }
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hungarian_matcher.cc" startLine="(218, 0)" endLine="(284, 1)" clone_start="50" clone_end="58">
			<code function_name="HungarianMatcher::AssignObjectsToTracks(  const Eigen::MatrixXf&amp; association_mat, const double&amp; assign_distance_maximum,   std::vector&lt;TrackObjectPair&gt;* assignments,   std::vector&lt;int&gt;* unassigned_tracks, std::vector&lt;int&gt;* unassigned_objects)">void HungarianMatcher::AssignObjectsToTracks(
  const Eigen::MatrixXf&amp; association_mat,
  const double&amp; assign_distance_maximum,
  std::vector&lt;TrackObjectPair&gt;* assignments,
  std::vector&lt;int&gt;* unassigned_tracks,
  std::vector&lt;int&gt;* unassigned_objects) {
  // Assign objects to tracks with null tracks setup
  std::vector&lt;int&gt; tracks_idx;
  std::vector&lt;int&gt; objects_idx;
  int no_track = association_mat.rows();
  int no_object = association_mat.cols();
  // build cost
  std::vector&lt; std::vector&lt;double&gt; &gt; cost(no_track + no_object);
  for (int i = 0; i &lt; no_track; ++i) {
    cost[i].resize(association_mat.cols());
    for (int j = 0; j &lt; association_mat.cols(); ++j) {
      cost[i][j] = association_mat(i, j);
    }
  }
  for (int i = 0; i &lt; no_object; ++i) {
    cost[i + no_track].resize(no_object);
    for (int j = 0; j &lt; no_object; ++j) {
      if (j == i) {
        cost[i + no_track][j] = assign_distance_maximum * 1.2f;
      } else {
        cost[i + no_track][j] = 999999.0f;
      }
    }
  }

  HungarianOptimizer hungarian_optimizer(cost);
  hungarian_optimizer.minimize(&amp;tracks_idx, &amp;objects_idx);

  int assignments_num = 0;
  std::vector&lt;bool&gt; tracks_used(no_track + no_object, false);
  std::vector&lt;bool&gt; objects_used(no_object, false);
  for (size_t i = 0; i &lt; tracks_idx.size(); ++i) {
    if (tracks_idx[i] &lt; 0 || tracks_idx[i] &gt;= no_track ||
      objects_idx[i] &lt; 0 || objects_idx[i] &gt;= no_object) {
      continue;
    }
    if (association_mat(tracks_idx[i], objects_idx[i]) &lt;
        assign_distance_maximum) {
      (*assignments)[assignments_num++] =
        std::make_pair(tracks_idx[i], objects_idx[i]);
      tracks_used[tracks_idx[i]] = true;
      objects_used[objects_idx[i]] = true;
    }
  }
  assignments-&gt;resize(assignments_num);
  unassigned_tracks-&gt;resize(association_mat.rows());
  int unassigned_tracks_num = 0;
  for (int i = 0; i &lt; association_mat.rows(); ++i) {
    if (tracks_used[i] == false) {
      (*unassigned_tracks)[unassigned_tracks_num++] = i;
    }
  }
  unassigned_tracks-&gt;resize(unassigned_tracks_num);
  unassigned_objects-&gt;resize(association_mat.cols());
  int unassigned_objects_num = 0;
  for (int i = 0; i &lt; association_mat.cols(); ++i) {
    if (objects_used[i] == false) {
      (*unassigned_objects)[unassigned_objects_num++] = i;
    }
  }
  unassigned_objects-&gt;resize(unassigned_objects_num);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hungarian_matcher.cc" startLine="(218, 0)" endLine="(284, 1)" clone_start="58" clone_end="66">
			<code function_name="HungarianMatcher::AssignObjectsToTracks(  const Eigen::MatrixXf&amp; association_mat, const double&amp; assign_distance_maximum,   std::vector&lt;TrackObjectPair&gt;* assignments,   std::vector&lt;int&gt;* unassigned_tracks, std::vector&lt;int&gt;* unassigned_objects)">void HungarianMatcher::AssignObjectsToTracks(
  const Eigen::MatrixXf&amp; association_mat,
  const double&amp; assign_distance_maximum,
  std::vector&lt;TrackObjectPair&gt;* assignments,
  std::vector&lt;int&gt;* unassigned_tracks,
  std::vector&lt;int&gt;* unassigned_objects) {
  // Assign objects to tracks with null tracks setup
  std::vector&lt;int&gt; tracks_idx;
  std::vector&lt;int&gt; objects_idx;
  int no_track = association_mat.rows();
  int no_object = association_mat.cols();
  // build cost
  std::vector&lt; std::vector&lt;double&gt; &gt; cost(no_track + no_object);
  for (int i = 0; i &lt; no_track; ++i) {
    cost[i].resize(association_mat.cols());
    for (int j = 0; j &lt; association_mat.cols(); ++j) {
      cost[i][j] = association_mat(i, j);
    }
  }
  for (int i = 0; i &lt; no_object; ++i) {
    cost[i + no_track].resize(no_object);
    for (int j = 0; j &lt; no_object; ++j) {
      if (j == i) {
        cost[i + no_track][j] = assign_distance_maximum * 1.2f;
      } else {
        cost[i + no_track][j] = 999999.0f;
      }
    }
  }

  HungarianOptimizer hungarian_optimizer(cost);
  hungarian_optimizer.minimize(&amp;tracks_idx, &amp;objects_idx);

  int assignments_num = 0;
  std::vector&lt;bool&gt; tracks_used(no_track + no_object, false);
  std::vector&lt;bool&gt; objects_used(no_object, false);
  for (size_t i = 0; i &lt; tracks_idx.size(); ++i) {
    if (tracks_idx[i] &lt; 0 || tracks_idx[i] &gt;= no_track ||
      objects_idx[i] &lt; 0 || objects_idx[i] &gt;= no_object) {
      continue;
    }
    if (association_mat(tracks_idx[i], objects_idx[i]) &lt;
        assign_distance_maximum) {
      (*assignments)[assignments_num++] =
        std::make_pair(tracks_idx[i], objects_idx[i]);
      tracks_used[tracks_idx[i]] = true;
      objects_used[objects_idx[i]] = true;
    }
  }
  assignments-&gt;resize(assignments_num);
  unassigned_tracks-&gt;resize(association_mat.rows());
  int unassigned_tracks_num = 0;
  for (int i = 0; i &lt; association_mat.rows(); ++i) {
    if (tracks_used[i] == false) {
      (*unassigned_tracks)[unassigned_tracks_num++] = i;
    }
  }
  unassigned_tracks-&gt;resize(unassigned_tracks_num);
  unassigned_objects-&gt;resize(association_mat.cols());
  int unassigned_objects_num = 0;
  for (int i = 0; i &lt; association_mat.cols(); ++i) {
    if (objects_used[i] == false) {
      (*unassigned_objects)[unassigned_objects_num++] = i;
    }
  }
  unassigned_objects-&gt;resize(unassigned_objects_num);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="82" clone_end="84">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length,
                        ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(26, 0)" endLine="(51, 1)" clone_start="24" clone_end="26">
			<code function_name="Gps6f::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Gps6f::Parse(const std::uint8_t *bytes, int32_t length,
                  ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_basic()-&gt;set_altitude(altitude(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_heading(heading(bytes, length));
  // speed mph -&gt; mps
  chassis_detail-&gt;mutable_basic()-&gt;set_gps_speed(speed(bytes, length) *
                                                 0.44704);
  chassis_detail-&gt;mutable_basic()-&gt;set_hdop(hdop(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_vdop(vdop(bytes, length));
  switch (fix_quality(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_NO);
      break;
    case 1:
      chassis_detail-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_2D);
      break;
    case 2:
      chassis_detail-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_3D);
      break;
    default:
      chassis_detail-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_INVALID);
      break;
  }
  chassis_detail-&gt;mutable_basic()-&gt;set_num_satellites(
      num_satellites(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(26, 0)" endLine="(33, 1)" clone_start="6" clone_end="8">
			<code function_name="Throttleinfo75::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Throttleinfo75::Parse(const std::uint8_t *bytes, int32_t length,
                           ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_ems()-&gt;set_engine_rpm(engine_rpm(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_accelerator_pedal(
      acc_pedal_percent(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_accelerator_pedal_rate(
      acc_pedal_rate(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(111, 0)" endLine="(119, 1)" clone_start="1" clone_end="7">
			<code function_name="Brakeinfo74::braking_torque_request(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::braking_torque_request(const std::uint8_t *bytes,
                                           int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 4);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 4.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(53, 0)" endLine="(63, 1)" clone_start="1" clone_end="6">
			<code function_name="Gps6f::altitude(const std::uint8_t *bytes, int32_t length) const">double Gps6f::altitude(const std::uint8_t *bytes, int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.250000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(35, 0)" endLine="(43, 1)" clone_start="1" clone_end="7">
			<code function_name="Throttleinfo75::engine_rpm(const std::uint8_t *bytes, int32_t length) const">double Throttleinfo75::engine_rpm(const std::uint8_t *bytes,
                                  int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.25;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(276, 0)" endLine="(332, 1)" clone_start="1" clone_end="10">
			<code function_name="SerialStream::read(uint8_t* buffer, size_t max_length)">size_t SerialStream::read(uint8_t* buffer, size_t max_length) {
  if (!_is_open) {
    if (!connect()) {
      return 0;
    }
    ROS_INFO_STREAM("Connect " &lt;&lt; _device_name &lt;&lt; " success.");
  }

  ssize_t bytes_read = 0;
  ssize_t bytes_current_read = 0;

  wait_readable(100000);  // wait 10ms

  while (max_length &gt; 0) {
    bytes_current_read = ::read(_fd, buffer, max_length);
    if (bytes_current_read &lt; 0) {
      switch (errno) {
        case EAGAIN:
        case EINVAL:
          bytes_current_read = 0;
          break;

        case EBADF:
        case EIO:
          ROS_ERROR_STREAM(
              "Serial stream read data failed, error: " &lt;&lt; strerror(errno));
          disconnect();
          if (connect()) {
            ROS_INFO_STREAM("Reconnect " &lt;&lt; _device_name &lt;&lt; "success.");
            bytes_current_read = 0;
            break;  // has recoverable
          }

        default:
          ROS_ERROR_STREAM_THROTTLE(1, "Serial stream read data failed, error: "
                                           &lt;&lt; strerror(errno)
                                           &lt;&lt; ", errno: " &lt;&lt; errno);
          _status = Stream::Status::ERROR;
          _errno = errno;
          return bytes_read;
      }
    }

    if (bytes_current_read == 0) {
      if (!bytes_read) {
        check_remove();
        return 0;
      }
      return bytes_read;
    }
    max_length -= bytes_current_read;
    buffer += bytes_current_read;
    bytes_read += bytes_current_read;
  }

  return bytes_read;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(334, 0)" endLine="(386, 1)" clone_start="1" clone_end="10">
			<code function_name="SerialStream::write(const uint8_t* data, size_t length)">size_t SerialStream::write(const uint8_t* data, size_t length) {
  if (!_is_open) {
    if (!connect()) {
      return 0;
    }
    ROS_INFO_STREAM("Connect " &lt;&lt; _device_name &lt;&lt; " success.");
  }

  size_t total_nsent = 0;
  size_t delay_times = 0;

  while ((length &gt; 0) &amp;&amp; (delay_times &lt; 5)) {
    ssize_t nsent = ::write(_fd, data, length);
    if (nsent &lt; 0) {
      ROS_ERROR_STREAM(
          "Serial stream write data failed, error: " &lt;&lt; strerror(errno));
      switch (errno) {
        case EAGAIN:
        case EINVAL:
          nsent = 0;
          break;

        case EBADF:
        case EIO:
          disconnect();
          if (connect()) {
            ROS_INFO_STREAM("Reconnect " &lt;&lt; _device_name &lt;&lt; "success.");
            nsent = 0;
            break;  // has recoverable
          }

        default:
          _status = Stream::Status::ERROR;
          _errno = errno;
          return total_nsent;
      }
    }

    if (nsent == 0) {
      if (!wait_writable(_byte_time_us)) {
        break;
      }
      ++delay_times;
      continue;
    }

    total_nsent += nsent;
    length -= nsent;
    data += nsent;
  }

  return total_nsent;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_constraint.cc" startLine="(183, 0)" endLine="(187, 1)" clone_start="4" clone_end="5">
			<code function_name="PiecewiseLinearConstraint::AddPointConstraint(const double x, const double fx)">bool PiecewiseLinearConstraint::AddPointConstraint(const double x,
                                                   const double fx) {
  // TODO(Liangliang): implement this function
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_constraint.cc" startLine="(133, 0)" endLine="(181, 1)" clone_start="48" clone_end="49">
			<code function_name="PiecewiseLinearConstraint::AddSecondDerivativeBoundary(const double init_derivative, const std::vector&lt;uint32_t&gt;&amp; index_list,     const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool PiecewiseLinearConstraint::AddSecondDerivativeBoundary(
    const double init_derivative, const std::vector&lt;uint32_t&gt;&amp; index_list,
    const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  // TODO(Liangliang): implement this function
  if (index_list.size() != lower_bound.size() ||
      index_list.size() != upper_bound.size()) {
    AERROR &lt;&lt; "The sizes of index list, lower_bound, upper_bound are not "
              "identical.";
    return false;
  }
  Eigen::MatrixXd inequality_matrix =
      Eigen::MatrixXd::Zero(2 * index_list.size(), dimension_);
  Eigen::MatrixXd inequality_boundary =
      Eigen::MatrixXd::Zero(2 * index_list.size(), 1);

  for (uint32_t i = 0; i &lt; index_list.size(); ++i) {
    uint32_t index = index_list[i];
    if (index == 0) {
      AERROR &lt;&lt; "Index should NOT be 0.";
      return false;
    }

    const double upper = upper_bound[i];
    const double lower = lower_bound[i];
    if (index == 1) {
      inequality_matrix(2 * i, 1) = -1.0;
      inequality_boundary(2 * i, 1) = -(upper * unit_segment_ * unit_segment_ +
                                        init_derivative * unit_segment_);
      inequality_matrix(2 * i + 1, 1) = 1.0;
      inequality_boundary(2 * i + 1, 1) =
          lower * unit_segment_ * unit_segment_ +
          init_derivative * unit_segment_;
    } else {
      inequality_matrix(2 * i, index - 2) = -1.0;
      inequality_matrix(2 * i, index - 1) = 2.0;
      inequality_matrix(2 * i, index) = -1.0;
      inequality_boundary(2 * i, 0) = -upper * unit_segment_ * unit_segment_;

      inequality_matrix(2 * i + 1, index - 2) = 1.0;
      inequality_matrix(2 * i + 1, index - 1) = -2.0;
      inequality_matrix(2 * i + 1, index) = 1.0;
      inequality_boundary(2 * i + 1, 0) = lower * unit_segment_ * unit_segment_;
    }
  }
  inequality_matrices_.push_back(inequality_matrix);
  inequality_boundaries_.push_back(inequality_boundary);
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_constraint.cc" startLine="(189, 0)" endLine="(193, 1)" clone_start="1" clone_end="5">
			<code function_name="PiecewiseLinearConstraint::AddPointDerivativeConstraint(const double x, const double dfx)">bool PiecewiseLinearConstraint::AddPointDerivativeConstraint(const double x,
                                                             const double dfx) {
  // TODO(Liangliang): implement this function
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_constraint.cc" startLine="(183, 0)" endLine="(187, 1)" clone_start="1" clone_end="5">
			<code function_name="PiecewiseLinearConstraint::AddPointConstraint(const double x, const double fx)">bool PiecewiseLinearConstraint::AddPointConstraint(const double x,
                                                   const double fx) {
  // TODO(Liangliang): implement this function
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_constraint.cc" startLine="(195, 0)" endLine="(199, 1)" clone_start="1" clone_end="5">
			<code function_name="PiecewiseLinearConstraint::AddPointSecondDerivativeConstraint( const double x, const double ddfx)">bool PiecewiseLinearConstraint::AddPointSecondDerivativeConstraint(
    const double x, const double ddfx) {
  // TODO(Liangliang): implement this function
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_constraint.cc" startLine="(189, 0)" endLine="(193, 1)" clone_start="1" clone_end="5">
			<code function_name="PiecewiseLinearConstraint::AddPointDerivativeConstraint(const double x, const double dfx)">bool PiecewiseLinearConstraint::AddPointDerivativeConstraint(const double x,
                                                             const double dfx) {
  // TODO(Liangliang): implement this function
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_constraint.cc" startLine="(201, 0)" endLine="(205, 1)" clone_start="1" clone_end="4">
			<code function_name="PiecewiseLinearConstraint::AddPointThirdDerivativeConstraint( const double x, const double dddfx)">bool PiecewiseLinearConstraint::AddPointThirdDerivativeConstraint(
    const double x, const double dddfx) {
  // TODO(Liangliang): implement this function
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_constraint.cc" startLine="(195, 0)" endLine="(199, 1)" clone_start="1" clone_end="4">
			<code function_name="PiecewiseLinearConstraint::AddPointSecondDerivativeConstraint( const double x, const double ddfx)">bool PiecewiseLinearConstraint::AddPointSecondDerivativeConstraint(
    const double x, const double ddfx) {
  // TODO(Liangliang): implement this function
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\tools\map_tool.cc" startLine="(32, 0)" endLine="(65, 1)" clone_start="4" clone_end="13">
			<code function_name="ShiftMap(Map* map_pb)">void ShiftMap(Map* map_pb) {
  for (auto&amp; lane : *(map_pb-&gt;mutable_lane())) {
    for (auto&amp; segment : *(lane.mutable_central_curve()-&gt;mutable_segment())) {
      for (auto&amp; point : *(segment.mutable_line_segment()-&gt;mutable_point())) {
        point.set_x(point.x() + FLAGS_x_offset);
        point.set_y(point.y() + FLAGS_y_offset);
      }
    }
    for (auto&amp; segment :
        *(lane.mutable_left_boundary()-&gt;mutable_curve()-&gt;mutable_segment())) {
      for (auto&amp; point : *(segment.mutable_line_segment()-&gt;mutable_point())) {
        point.set_x(point.x() + FLAGS_x_offset);
        point.set_y(point.y() + FLAGS_y_offset);
      }
    }
    for (auto&amp; segment :
        *(lane.mutable_right_boundary()-&gt;mutable_curve()-&gt;mutable_segment())) {
      for (auto&amp; point : *(segment.mutable_line_segment()-&gt;mutable_point())) {
        point.set_x(point.x() + FLAGS_x_offset);
        point.set_y(point.y() + FLAGS_y_offset);
      }
    }
  }
  for (auto&amp; stop_sign : *(map_pb-&gt;mutable_stop_sign())) {
    for (auto&amp; stop_line : *(stop_sign.mutable_stop_line())) {
      for (auto&amp; segment : *(stop_line.mutable_segment())) {
        for (auto&amp; point : *(segment.mutable_line_segment()-&gt;mutable_point())) {
          point.set_x(point.x() + FLAGS_x_offset);
          point.set_y(point.y() + FLAGS_y_offset);
        }
      }
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\tools\map_tool.cc" startLine="(32, 0)" endLine="(65, 1)" clone_start="11" clone_end="20">
			<code function_name="ShiftMap(Map* map_pb)">void ShiftMap(Map* map_pb) {
  for (auto&amp; lane : *(map_pb-&gt;mutable_lane())) {
    for (auto&amp; segment : *(lane.mutable_central_curve()-&gt;mutable_segment())) {
      for (auto&amp; point : *(segment.mutable_line_segment()-&gt;mutable_point())) {
        point.set_x(point.x() + FLAGS_x_offset);
        point.set_y(point.y() + FLAGS_y_offset);
      }
    }
    for (auto&amp; segment :
        *(lane.mutable_left_boundary()-&gt;mutable_curve()-&gt;mutable_segment())) {
      for (auto&amp; point : *(segment.mutable_line_segment()-&gt;mutable_point())) {
        point.set_x(point.x() + FLAGS_x_offset);
        point.set_y(point.y() + FLAGS_y_offset);
      }
    }
    for (auto&amp; segment :
        *(lane.mutable_right_boundary()-&gt;mutable_curve()-&gt;mutable_segment())) {
      for (auto&amp; point : *(segment.mutable_line_segment()-&gt;mutable_point())) {
        point.set_x(point.x() + FLAGS_x_offset);
        point.set_y(point.y() + FLAGS_y_offset);
      }
    }
  }
  for (auto&amp; stop_sign : *(map_pb-&gt;mutable_stop_sign())) {
    for (auto&amp; stop_line : *(stop_sign.mutable_stop_line())) {
      for (auto&amp; segment : *(stop_line.mutable_segment())) {
        for (auto&amp; point : *(segment.mutable_line_segment()-&gt;mutable_point())) {
          point.set_x(point.x() + FLAGS_x_offset);
          point.set_y(point.y() + FLAGS_y_offset);
        }
      }
    }
  }
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(79, 0)" endLine="(90, 1)" clone_start="6" clone_end="12">
			<code function_name="Brake61::parse_two_frames(const std::uint8_t low_byte, const std::uint8_t high_byte) const">double Brake61::parse_two_frames(const std::uint8_t low_byte,
                                 const std::uint8_t high_byte) const {
  Byte frame_high(&amp;high_byte);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(&amp;low_byte);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(79, 0)" endLine="(91, 1)" clone_start="7" clone_end="13">
			<code function_name="Throttle63::pedal_output(const std::uint8_t *bytes, int32_t length) const">double Throttle63::pedal_output(const std::uint8_t *bytes,
                                int32_t length) const {
  // Pedal Output is the maximum of PI and PC
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(66, 0)" endLine="(77, 1)" clone_start="6" clone_end="12">
			<code function_name="Throttle63::pedal_cmd(const std::uint8_t *bytes, int32_t length) const">double Throttle63::pedal_cmd(const std::uint8_t *bytes, int32_t length) const {
  // Pedal Command from the command message
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(52, 0)" endLine="(64, 1)" clone_start="7" clone_end="13">
			<code function_name="Throttle63::pedal_input(const std::uint8_t *bytes, int32_t length) const">double Throttle63::pedal_input(const std::uint8_t *bytes,
                               int32_t length) const {
  // Pedal Input from the physical pedal
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(92, 0)" endLine="(96, 1)" clone_start="1" clone_end="2">
			<code function_name="Brake61::boo_input(const std::uint8_t *bytes, int32_t length) const">bool Brake61::boo_input(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 6);
  // seems typo here
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(93, 0)" endLine="(98, 1)" clone_start="1" clone_end="3">
			<code function_name="Throttle63::watchdog_counter_source(const std::uint8_t *bytes, int32_t length) const">int32_t Throttle63::watchdog_counter_source(const std::uint8_t *bytes,
                                            int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(79, 0)" endLine="(91, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle63::pedal_output(const std::uint8_t *bytes, int32_t length) const">double Throttle63::pedal_output(const std::uint8_t *bytes,
                                int32_t length) const {
  // Pedal Output is the maximum of PI and PC
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(66, 0)" endLine="(77, 1)" clone_start="1" clone_end="3">
			<code function_name="Throttle63::pedal_cmd(const std::uint8_t *bytes, int32_t length) const">double Throttle63::pedal_cmd(const std::uint8_t *bytes, int32_t length) const {
  // Pedal Command from the command message
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\controller\lat_controller.cc" startLine="(265, 0)" endLine="(370, 1)" clone_start="93" clone_end="101">
			<code function_name="LatController::ComputeControlCommand(const localization::LocalizationEstimate *localization, const canbus::Chassis *chassis, const planning::ADCTrajectory *planning_published_trajectory, ControlCommand *cmd)">Status LatController::ComputeControlCommand(
    const localization::LocalizationEstimate *localization,
    const canbus::Chassis *chassis,
    const planning::ADCTrajectory *planning_published_trajectory,
    ControlCommand *cmd) {
  VehicleState::instance()-&gt;set_linear_velocity(
      std::max(VehicleState::instance()-&gt;linear_velocity(), 1.0));

  trajectory_analyzer_ =
      std::move(TrajectoryAnalyzer(planning_published_trajectory));

  SimpleLateralDebug *debug = cmd-&gt;mutable_debug()-&gt;mutable_simple_lat_debug();
  debug-&gt;Clear();

  // Update state = [Lateral Error, Lateral Error Rate, Heading Error, Heading
  // Error Rate, preview lateral error1 , preview lateral error2, ...]
  UpdateStateAnalyticalMatching(debug);

  UpdateMatrix();

  // Compound discrete matrix with road preview model
  UpdateMatrixCompound();

  // Add gain sheduler for higher speed steering
  if (FLAGS_enable_gain_scheduler) {
    matrix_q_updated_(0, 0) =
        matrix_q_(0, 0) * lat_err_interpolation_-&gt;Interpolate(
                              VehicleState::instance()-&gt;linear_velocity());
    matrix_q_updated_(2, 2) =
        matrix_q_(2, 2) * heading_err_interpolation_-&gt;Interpolate(
                              VehicleState::instance()-&gt;linear_velocity());
    common::math::SolveLQRProblem(matrix_adc_, matrix_bdc_, matrix_q_updated_,
                                  matrix_r_, lqr_eps_, lqr_max_iteration_,
                                  &amp;matrix_k_);
  } else {
    common::math::SolveLQRProblem(matrix_adc_, matrix_bdc_, matrix_q_,
                                  matrix_r_, lqr_eps_, lqr_max_iteration_,
                                  &amp;matrix_k_);
  }

  // feedback = - K * state
  // Convert vehicle steer angle from rad to degree and then to steer degree
  // then to 100% ratio
  double steer_angle_feedback = -(matrix_k_ * matrix_state_)(0, 0) * 180 /
                                M_PI * steer_transmission_ratio_ /
                                steer_single_direction_max_degree_ * 100;

  double steer_angle_feedforward = ComputeFeedForward(debug-&gt;curvature());
  double steer_angle = steer_angle_feedback + steer_angle_feedforward;

  // Clamp the steer angle to -100.0 to 100.0
  steer_angle = apollo::common::math::Clamp(steer_angle, -100.0, 100.0);

  if (FLAGS_set_steer_limit) {
    double steer_limit =
        std::atan(max_lat_acc_ * wheelbase_ /
                  (VehicleState::instance()-&gt;linear_velocity() *
                   VehicleState::instance()-&gt;linear_velocity())) *
        steer_transmission_ratio_ * 180 / M_PI /
        steer_single_direction_max_degree_ * 100;

    // Clamp the steer angle
    double steer_angle_limited =
        apollo::common::math::Clamp(steer_angle, -steer_limit, steer_limit);
    steer_angle_limited = digital_filter_.Filter(steer_angle_limited);
    cmd-&gt;set_steering_target(steer_angle_limited);
    debug-&gt;set_steer_angle_limited(steer_angle_limited);
  } else {
    steer_angle = digital_filter_.Filter(steer_angle);
    cmd-&gt;set_steering_target(steer_angle);
  }

  cmd-&gt;set_steering_rate(FLAGS_steer_angle_rate);
  // compute extra information for logging and debugging
  double steer_angle_lateral_contribution =
      -matrix_k_(0, 0) * matrix_state_(0, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_lateral_rate_contribution =
      -matrix_k_(0, 1) * matrix_state_(1, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_heading_contribution =
      -matrix_k_(0, 2) * matrix_state_(2, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_heading_rate_contribution =
      -matrix_k_(0, 3) * matrix_state_(3, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  debug-&gt;set_heading(VehicleState::instance()-&gt;heading());
  debug-&gt;set_steer_angle(steer_angle);
  debug-&gt;set_steer_angle_feedforward(steer_angle_feedforward);
  debug-&gt;set_steer_angle_lateral_contribution(steer_angle_lateral_contribution);
  debug-&gt;set_steer_angle_lateral_rate_contribution(
      steer_angle_lateral_rate_contribution);
  debug-&gt;set_steer_angle_heading_contribution(steer_angle_heading_contribution);
  debug-&gt;set_steer_angle_heading_rate_contribution(
      steer_angle_heading_rate_contribution);
  debug-&gt;set_steer_angle_feedback(steer_angle_feedback);
  debug-&gt;set_steering_position(chassis-&gt;steering_percentage());
  debug-&gt;set_ref_speed(VehicleState::instance()-&gt;linear_velocity());

  ProcessLogs(debug, chassis);
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\controller\lon_controller.cc" startLine="(138, 0)" endLine="(288, 1)" clone_start="113" clone_end="119">
			<code function_name="LonController::ComputeControlCommand(const localization::LocalizationEstimate *localization, const canbus::Chassis *chassis, const planning::ADCTrajectory *planning_published_trajectory, control::ControlCommand *cmd)">Status LonController::ComputeControlCommand(
    const localization::LocalizationEstimate *localization,
    const canbus::Chassis *chassis,
    const planning::ADCTrajectory *planning_published_trajectory,
    control::ControlCommand *cmd) {
  localization_ = localization;
  chassis_ = chassis;

  trajectory_message_ = planning_published_trajectory;
  if (!control_interpolation_) {
    AERROR &lt;&lt; "Fail to initialize calibration table.";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR,
                  "Fail to initialize calibration table.");
  }

  if (trajectory_analyzer_ == nullptr ||
      trajectory_analyzer_-&gt;seq_num() !=
          trajectory_message_-&gt;header().sequence_num()) {
    trajectory_analyzer_.reset(new TrajectoryAnalyzer(trajectory_message_));
  }
  const LonControllerConf &amp;lon_controller_conf =
      control_conf_-&gt;lon_controller_conf();

  auto debug = cmd-&gt;mutable_debug()-&gt;mutable_simple_lon_debug();
  debug-&gt;Clear();

  double brake_cmd = 0.0;
  double throttle_cmd = 0.0;
  double ts = lon_controller_conf.ts();
  double preview_time = lon_controller_conf.preview_window() * ts;

  if (preview_time &lt; 0.0) {
    const auto error_msg = apollo::common::util::StrCat(
        "Preview time set as: ", preview_time, " less than 0");
    AERROR &lt;&lt; error_msg;
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, error_msg);
  }
  ComputeLongitudinalErrors(trajectory_analyzer_.get(), preview_time, debug);

  double station_error_limit = lon_controller_conf.station_error_limit();
  double station_error_limited = 0.0;
  if (FLAGS_enable_speed_station_preview) {
    station_error_limited =
        apollo::common::math::Clamp(debug-&gt;preview_station_error(),
                                    -station_error_limit, station_error_limit);
  } else {
    station_error_limited = apollo::common::math::Clamp(
        debug-&gt;station_error(), -station_error_limit, station_error_limit);
  }
  double speed_offset =
      station_pid_controller_.Control(station_error_limited, ts);

  double speed_controller_input = 0.0;
  double speed_controller_input_limit =
      lon_controller_conf.speed_controller_input_limit();
  double speed_controller_input_limited = 0.0;
  if (FLAGS_enable_speed_station_preview) {
    speed_controller_input = speed_offset + debug-&gt;preview_speed_error();
  } else {
    speed_controller_input = speed_offset + debug-&gt;speed_error();
  }
  speed_controller_input_limited = apollo::common::math::Clamp(
      speed_controller_input, -speed_controller_input_limit,
      speed_controller_input_limit);

  double acceleration_cmd_closeloop = 0.0;
  if (VehicleState::instance()-&gt;linear_velocity() &lt;=
      lon_controller_conf.switch_speed()) {
    speed_pid_controller_.SetPID(lon_controller_conf.low_speed_pid_conf());
    acceleration_cmd_closeloop =
        speed_pid_controller_.Control(speed_controller_input_limited, ts);
  } else {
    speed_pid_controller_.SetPID(lon_controller_conf.high_speed_pid_conf());
    acceleration_cmd_closeloop =
        speed_pid_controller_.Control(speed_controller_input_limited, ts);
  }

  double acceleration_cmd =
      acceleration_cmd_closeloop + debug-&gt;preview_acceleration_reference() +
      digital_filter_pitch_angle_.Filter(
          GRA_ACC * std::sin(VehicleState::instance()-&gt;pitch()));
  debug-&gt;set_is_full_stop(false);
  if (std::abs(debug-&gt;preview_acceleration_reference()) &lt;=
          FLAGS_max_acceleration_when_stopped &amp;&amp;
      std::abs(debug-&gt;preview_speed_reference()) &lt;=
          FLAGS_max_abs_speed_when_stopped) {
    acceleration_cmd = lon_controller_conf.standstill_acceleration();
    AINFO &lt;&lt; "Stop location reached";
    debug-&gt;set_is_full_stop(true);
  }

  double throttle_deadzone = lon_controller_conf.throttle_deadzone();
  double brake_deadzone = lon_controller_conf.brake_deadzone();
  double calibration_value = 0.0;
  if (FLAGS_use_preview_speed_for_table) {
    calibration_value = control_interpolation_-&gt;Interpolate(
        std::make_pair(debug-&gt;preview_speed_reference(), acceleration_cmd));
  } else {
    calibration_value = control_interpolation_-&gt;Interpolate(
        std::make_pair(chassis_-&gt;speed_mps(), acceleration_cmd));
  }

  if (calibration_value &gt;= 0) {
    throttle_cmd = calibration_value &gt; throttle_deadzone ? calibration_value
                                                         : throttle_deadzone;
    brake_cmd = 0.0;
  } else {
    throttle_cmd = 0.0;
    brake_cmd = -calibration_value &gt; brake_deadzone ? -calibration_value
                                                    : brake_deadzone;
  }

  debug-&gt;set_station_error_limited(station_error_limited);
  debug-&gt;set_speed_controller_input_limited(speed_controller_input_limited);
  debug-&gt;set_acceleration_cmd(acceleration_cmd);
  debug-&gt;set_throttle_cmd(throttle_cmd);
  debug-&gt;set_brake_cmd(brake_cmd);
  debug-&gt;set_acceleration_lookup(acceleration_cmd);
  debug-&gt;set_speed_lookup(chassis_-&gt;speed_mps());
  debug-&gt;set_calibration_value(calibration_value);
  debug-&gt;set_acceleration_cmd_closeloop(acceleration_cmd_closeloop);

  if (FLAGS_enable_csv_debug &amp;&amp; speed_log_file_ != nullptr) {
    fprintf(speed_log_file_,
            "%.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f,"
            "%.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %d,\r\n",
            debug-&gt;station_reference(), debug-&gt;station_error(),
            station_error_limited, debug-&gt;preview_station_error(),
            debug-&gt;speed_reference(), debug-&gt;speed_error(),
            speed_controller_input_limited, debug-&gt;preview_speed_reference(),
            debug-&gt;preview_speed_error(),
            debug-&gt;preview_acceleration_reference(), acceleration_cmd_closeloop,
            acceleration_cmd, debug-&gt;acceleration_lookup(),
            debug-&gt;speed_lookup(), calibration_value, throttle_cmd, brake_cmd,
            debug-&gt;is_full_stop());
  }

  cmd-&gt;set_throttle(throttle_cmd);
  cmd-&gt;set_brake(brake_cmd);

  if (std::abs(VehicleState::instance()-&gt;linear_velocity()) &lt;=
          FLAGS_max_abs_speed_when_stopped ||
      chassis-&gt;gear_location() == trajectory_message_-&gt;gear() ||
      chassis-&gt;gear_location() == canbus::Chassis::GEAR_NEUTRAL) {
    cmd-&gt;set_gear_location(trajectory_message_-&gt;gear());
  } else {
    cmd-&gt;set_gear_location(chassis-&gt;gear_location());
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(86, 0)" endLine="(90, 1)" clone_start="4" clone_end="5">
			<code function_name="Gps6e::pdop(const std::uint8_t *bytes, int32_t length) const">double Gps6e::pdop(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 7);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(113, 0)" endLine="(121, 1)" clone_start="8" clone_end="9">
			<code function_name="Steering65::epas_torque(const std::uint8_t *bytes, int32_t length) const">double Steering65::epas_torque(const std::uint8_t *bytes,
                               int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 8);
  if (x &gt; 0x7F) {
    x -= 0x100;
  }
  return x * 0.062500;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(175, 0)" endLine="(187, 1)" clone_start="12" clone_end="13">
			<code function_name="Brakeinfo74::acceleration_over_ground(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::acceleration_over_ground(const std::uint8_t *bytes,
                                             int32_t length) const {
  // vehicle acceleration over ground estimate
  Byte frame_high(bytes + 7);
  int32_t high = frame_high.get_byte(0, 2);
  Byte frame_low(bytes + 6);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FF) {
    value -= 0x400;
  }
  return value * 0.035000;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(92, 0)" endLine="(95, 1)" clone_start="1" clone_end="4">
			<code function_name="Gps6e::is_gps_fault(const std::uint8_t *bytes, int32_t length) const">bool Gps6e::is_gps_fault(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(123, 0)" endLine="(126, 1)" clone_start="1" clone_end="4">
			<code function_name="Steering65::is_enabled(const std::uint8_t *bytes, int32_t length) const">bool Steering65::is_enabled(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(189, 0)" endLine="(193, 1)" clone_start="1" clone_end="5">
			<code function_name="Brakeinfo74::is_abs_active(const std::uint8_t *bytes, int32_t length) const">bool Brakeinfo74::is_abs_active(const std::uint8_t *bytes,
                                int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(2);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(97, 0)" endLine="(101, 1)" clone_start="1" clone_end="4">
			<code function_name="Gps6e::is_inferred_position(const std::uint8_t *bytes, int32_t length) const">bool Gps6e::is_inferred_position(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(128, 0)" endLine="(133, 1)" clone_start="1" clone_end="5">
			<code function_name="Steering65::is_driver_override(const std::uint8_t *bytes, int32_t length) const">bool Steering65::is_driver_override(const std::uint8_t *bytes,
                                    int32_t length) const {
  // Cleared on rising edge of EN bit in command message
  Byte frame(bytes + 7);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(195, 0)" endLine="(199, 1)" clone_start="1" clone_end="4">
			<code function_name="Brakeinfo74::is_abs_enabled(const std::uint8_t *bytes, int32_t length) const">bool Brakeinfo74::is_abs_enabled(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\tools\teleop.cc" startLine="(81, 2)" endLine="(109, 3)" clone_start="11" clone_end="17">
			<code function_name="PrintKeycode()">  static void PrintKeycode() {
    system("clear");
    printf("=====================    KEYBOARD MAP   ===================\n");
    printf("HELP:               [%c]     |\n", KEYCODE_HELP);
    printf("Set Action      :   [%c]+Num\n", KEYCODE_MODE);
    printf("                     0 RESET ACTION\n");
    printf("                     1 START ACTION\n");
    printf("\n-----------------------------------------------------------\n");
    printf("Set Gear:           [%c]+Num\n", KEYCODE_SETG1);
    printf("                     0 GEAR_NEUTRAL\n");
    printf("                     1 GEAR_DRIVE\n");
    printf("                     2 GEAR_REVERSE\n");
    printf("                     3 GEAR_PARKING\n");
    printf("                     4 GEAR_LOW\n");
    printf("                     5 GEAR_INVALID\n");
    printf("                     6 GEAR_NONE\n");
    printf("\n-----------------------------------------------------------\n");
    printf("Throttle/Speed up:  [%c]     |  Set Throttle:       [%c]+Num\n",
           KEYCODE_UP1, KEYCODE_SETT1);
    printf("Brake/Speed down:   [%c]     |  Set Brake:          [%c]+Num\n",
           KEYCODE_DN1, KEYCODE_SETB1);
    printf("Steer LEFT:         [%c]     |  Steer RIGHT:        [%c]\n",
           KEYCODE_LF1, KEYCODE_RT1);
    printf("Parkinig Brake:     [%c]     |  Emergency Stop      [%c]\n",
           KEYCODE_PKBK, KEYCODE_ESTOP);
    printf("\n-----------------------------------------------------------\n");
    printf("Exit: Ctrl + C, then press enter to normal terminal\n");
    printf("===========================================================\n");
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\tools\teleop.cc" startLine="(81, 2)" endLine="(109, 3)" clone_start="10" clone_end="16">
			<code function_name="PrintKeycode()">  static void PrintKeycode() {
    system("clear");
    printf("=====================    KEYBOARD MAP   ===================\n");
    printf("HELP:               [%c]     |\n", KEYCODE_HELP);
    printf("Set Action      :   [%c]+Num\n", KEYCODE_MODE);
    printf("                     0 RESET ACTION\n");
    printf("                     1 START ACTION\n");
    printf("\n-----------------------------------------------------------\n");
    printf("Set Gear:           [%c]+Num\n", KEYCODE_SETG1);
    printf("                     0 GEAR_NEUTRAL\n");
    printf("                     1 GEAR_DRIVE\n");
    printf("                     2 GEAR_REVERSE\n");
    printf("                     3 GEAR_PARKING\n");
    printf("                     4 GEAR_LOW\n");
    printf("                     5 GEAR_INVALID\n");
    printf("                     6 GEAR_NONE\n");
    printf("\n-----------------------------------------------------------\n");
    printf("Throttle/Speed up:  [%c]     |  Set Throttle:       [%c]+Num\n",
           KEYCODE_UP1, KEYCODE_SETT1);
    printf("Brake/Speed down:   [%c]     |  Set Brake:          [%c]+Num\n",
           KEYCODE_DN1, KEYCODE_SETB1);
    printf("Steer LEFT:         [%c]     |  Steer RIGHT:        [%c]\n",
           KEYCODE_LF1, KEYCODE_RT1);
    printf("Parkinig Brake:     [%c]     |  Emergency Stop      [%c]\n",
           KEYCODE_PKBK, KEYCODE_ESTOP);
    printf("\n-----------------------------------------------------------\n");
    printf("Exit: Ctrl + C, then press enter to normal terminal\n");
    printf("===========================================================\n");
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(481, 0)" endLine="(498, 1)" clone_start="11" clone_end="18">
			<code function_name="NovatelParser::handle_corr_imu_data(const novatel::CorrImuData* imu)">bool NovatelParser::handle_corr_imu_data(const novatel::CorrImuData* imu) {
  rfu_to_flu(imu-&gt;x_velocity_change * _imu_measurement_hz,
             imu-&gt;y_velocity_change * _imu_measurement_hz,
             imu-&gt;z_velocity_change * _imu_measurement_hz,
             _ins.mutable_linear_acceleration());
  rfu_to_flu(imu-&gt;x_angle_change * _imu_measurement_hz,
             imu-&gt;y_angle_change * _imu_measurement_hz,
             imu-&gt;z_angle_change * _imu_measurement_hz,
             _ins.mutable_angular_velocity());

  double seconds = imu-&gt;gps_week * SECONDS_PER_WEEK + imu-&gt;gps_seconds;
  if (_ins.measurement_time() != seconds) {
    _ins.set_measurement_time(seconds);
    return false;
  }
  _ins.mutable_header()-&gt;set_timestamp_sec(ros::Time::now().toSec());
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(510, 0)" endLine="(547, 1)" clone_start="30" clone_end="38">
			<code function_name="NovatelParser::handle_ins_pva(const novatel::InsPva* pva)">bool NovatelParser::handle_ins_pva(const novatel::InsPva* pva) {
  if (_ins_status != pva-&gt;status) {
    _ins_status = pva-&gt;status;
    ROS_INFO_STREAM("INS status: " &lt;&lt; static_cast&lt;int&gt;(_ins_status));
  }
  _ins.mutable_position()-&gt;set_lon(pva-&gt;longitude);
  _ins.mutable_position()-&gt;set_lat(pva-&gt;latitude);
  _ins.mutable_position()-&gt;set_height(pva-&gt;height);
  _ins.mutable_euler_angles()-&gt;set_x(pva-&gt;roll * DEG_TO_RAD);
  _ins.mutable_euler_angles()-&gt;set_y(-pva-&gt;pitch * DEG_TO_RAD);
  _ins.mutable_euler_angles()-&gt;set_z(azimuth_deg_to_yaw_rad(pva-&gt;azimuth));
  _ins.mutable_linear_velocity()-&gt;set_x(pva-&gt;east_velocity);
  _ins.mutable_linear_velocity()-&gt;set_y(pva-&gt;north_velocity);
  _ins.mutable_linear_velocity()-&gt;set_z(pva-&gt;up_velocity);

  switch (pva-&gt;status) {
    case novatel::InsStatus::ALIGNMENT_COMPLETE:
    case novatel::InsStatus::SOLUTION_GOOD:
      _ins.set_type(apollo::drivers::gnss::Ins::GOOD);
      break;
    case novatel::InsStatus::ALIGNING:
    case novatel::InsStatus::HIGH_VARIANCE:
    case novatel::InsStatus::SOLUTION_FREE:
      _ins.set_type(apollo::drivers::gnss::Ins::CONVERGING);
      break;
    default:
      _ins.set_type(apollo::drivers::gnss::Ins::INVALID);
  }

  double seconds = pva-&gt;gps_week * SECONDS_PER_WEEK + pva-&gt;gps_seconds;
  if (_ins.measurement_time() != seconds) {
    _ins.set_measurement_time(seconds);
    return false;
  }

  _ins.mutable_header()-&gt;set_timestamp_sec(ros::Time::now().toSec());
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(500, 0)" endLine="(508, 1)" clone_start="1" clone_end="1">
			<code function_name="NovatelParser::handle_ins_cov(const novatel::InsCov* cov)">bool NovatelParser::handle_ins_cov(const novatel::InsCov* cov) {
  for (int i = 0; i &lt; 9; ++i) {
    _ins.set_position_covariance(i, cov-&gt;position_covariance[i]);
    _ins.set_euler_angles_covariance(
        INDEX[i], (DEG_TO_RAD * DEG_TO_RAD) * cov-&gt;attitude_covariance[i]);
    _ins.set_linear_velocity_covariance(i, cov-&gt;velocity_covariance[i]);
  }
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(549, 0)" endLine="(553, 1)" clone_start="1" clone_end="1">
			<code function_name="NovatelParser::handle_ins_pvax(const novatel::InsPvaX* pvax)">bool NovatelParser::handle_ins_pvax(const novatel::InsPvaX* pvax) {
  _ins_stat.set_ins_status(pvax-&gt;ins_status); 
  _ins_stat.set_pos_type(pvax-&gt;pos_type); 
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\segmentation\cnnseg\feature_generator.cc" startLine="(30, 0)" endLine="(93, 1)" clone_start="34" clone_end="40">
			<code function_name="FeatureGenerator&lt;Dtype&gt;::Init(const FeatureParam&amp; feature_param, caffe::Blob&lt;Dtype&gt;* out_blob)">bool FeatureGenerator&lt;Dtype&gt;::Init(const FeatureParam&amp; feature_param,
                                   caffe::Blob&lt;Dtype&gt;* out_blob) {
  out_blob_ = out_blob;

  // raw feature parameters
  range_ = feature_param.has_point_cloud_range()
               ? static_cast&lt;int&gt;(feature_param.point_cloud_range())
               : 60;
  width_ =
      feature_param.has_width() ? static_cast&lt;int&gt;(feature_param.width()) : 512;
  height_ = feature_param.has_height()
                ? static_cast&lt;int&gt;(feature_param.height())
                : 512;
  min_height_ =
      feature_param.has_min_height() ? feature_param.min_height() : -5.0;
  max_height_ =
      feature_param.has_max_height() ? feature_param.max_height() : 5.0;
  CHECK_EQ(width_, height_)
      &lt;&lt; "Current implementation version requires input_width == input_height.";

  // set output blob and log lookup table
  out_blob_-&gt;Reshape(1, 8, height_, width_);

  log_table_.resize(256);
  for (size_t i = 0; i &lt; log_table_.size(); ++i) {
    log_table_[i] = std::log(static_cast&lt;Dtype&gt;(1 + i));
  }

  Dtype* out_blob_data = nullptr;
  out_blob_data = out_blob_-&gt;mutable_cpu_data();

  int channel_index = 0;
  max_height_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
  mean_height_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
  count_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
  direction_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
  top_intensity_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
  mean_intensity_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
  distance_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
  nonempty_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
  CHECK_EQ(out_blob_-&gt;offset(0, channel_index), out_blob_-&gt;count());

  // compute direction and distance features
  int siz = height_ * width_;
  vector&lt;Dtype&gt; direction_data(siz);
  vector&lt;Dtype&gt; distance_data(siz);

  for (int row = 0; row &lt; height_; ++row) {
    for (int col = 0; col &lt; width_; ++col) {
      int idx = row * width_ + col;
      // * row &lt;-&gt; x, column &lt;-&gt; y
      float center_x = Pixel2Pc(row, height_, range_);
      float center_y = Pixel2Pc(col, width_, range_);
      direction_data[idx] =
          static_cast&lt;Dtype&gt;(std::atan2(center_y, center_x) / (2.0 * CV_PI));
      distance_data[idx] =
          static_cast&lt;Dtype&gt;(std::hypot(center_x, center_y) / 60.0 - 0.5);
    }
  }
  caffe::caffe_copy(siz, direction_data.data(), direction_data_);
  caffe::caffe_copy(siz, distance_data.data(), distance_data_);

  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\segmentation\cnnseg\feature_generator.cc" startLine="(30, 0)" endLine="(93, 1)" clone_start="33" clone_end="39">
			<code function_name="FeatureGenerator&lt;Dtype&gt;::Init(const FeatureParam&amp; feature_param, caffe::Blob&lt;Dtype&gt;* out_blob)">bool FeatureGenerator&lt;Dtype&gt;::Init(const FeatureParam&amp; feature_param,
                                   caffe::Blob&lt;Dtype&gt;* out_blob) {
  out_blob_ = out_blob;

  // raw feature parameters
  range_ = feature_param.has_point_cloud_range()
               ? static_cast&lt;int&gt;(feature_param.point_cloud_range())
               : 60;
  width_ =
      feature_param.has_width() ? static_cast&lt;int&gt;(feature_param.width()) : 512;
  height_ = feature_param.has_height()
                ? static_cast&lt;int&gt;(feature_param.height())
                : 512;
  min_height_ =
      feature_param.has_min_height() ? feature_param.min_height() : -5.0;
  max_height_ =
      feature_param.has_max_height() ? feature_param.max_height() : 5.0;
  CHECK_EQ(width_, height_)
      &lt;&lt; "Current implementation version requires input_width == input_height.";

  // set output blob and log lookup table
  out_blob_-&gt;Reshape(1, 8, height_, width_);

  log_table_.resize(256);
  for (size_t i = 0; i &lt; log_table_.size(); ++i) {
    log_table_[i] = std::log(static_cast&lt;Dtype&gt;(1 + i));
  }

  Dtype* out_blob_data = nullptr;
  out_blob_data = out_blob_-&gt;mutable_cpu_data();

  int channel_index = 0;
  max_height_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
  mean_height_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
  count_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
  direction_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
  top_intensity_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
  mean_intensity_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
  distance_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
  nonempty_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
  CHECK_EQ(out_blob_-&gt;offset(0, channel_index), out_blob_-&gt;count());

  // compute direction and distance features
  int siz = height_ * width_;
  vector&lt;Dtype&gt; direction_data(siz);
  vector&lt;Dtype&gt; distance_data(siz);

  for (int row = 0; row &lt; height_; ++row) {
    for (int col = 0; col &lt; width_; ++col) {
      int idx = row * width_ + col;
      // * row &lt;-&gt; x, column &lt;-&gt; y
      float center_x = Pixel2Pc(row, height_, range_);
      float center_y = Pixel2Pc(col, width_, range_);
      direction_data[idx] =
          static_cast&lt;Dtype&gt;(std::atan2(center_y, center_x) / (2.0 * CV_PI));
      distance_data[idx] =
          static_cast&lt;Dtype&gt;(std::hypot(center_x, center_y) / 60.0 - 0.5);
    }
  }
  caffe::caffe_copy(siz, direction_data.data(), direction_data_);
  caffe::caffe_copy(siz, distance_data.data(), distance_data_);

  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\double.cc" startLine="(31, 0)" endLine="(42, 1)" clone_start="3" clone_end="10">
			<code function_name="Double::Compare(const double d1, const double d2, const double epsilon)">int Double::Compare(const double d1, const double d2, const double epsilon) {
  CHECK(!std::isnan(d1));
  CHECK(!std::isnan(d2));

  if (DefinitelyGreaterThan(d1, d2, epsilon)) {
    return 1;
  } else if (DefinitelyLessThan(d1, d2, epsilon)) {
    return -1;
  } else {
    return 0;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\double.cc" startLine="(56, 0)" endLine="(65, 1)" clone_start="2" clone_end="8">
			<code function_name="Double::CompareTo(const double d1, const double epsilon) const">int Double::CompareTo(const double d1, const double epsilon) const {
  CHECK(!std::isnan(d1));
  if (DefinitelyGreaterThan(value_, d1, epsilon)) {
    return 1;
  } else if (DefinitelyLessThan(value_, d1, epsilon)) {
    return -1;
  } else {
    return 0;
  }
}</code>
		</source>
	</dup>
	<dup count="5">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(134, 2)" endLine="(134, 45)" clone_start="1" clone_end="1">
			<code function_name="DummyObjectFilter()">  DummyObjectFilter() : BaseObjectFilter() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(58, 2)" endLine="(58, 49)" clone_start="1" clone_end="1">
			<code function_name="DummyGroundDetector()">  DummyGroundDetector() : BaseGroundDetector() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(83, 2)" endLine="(83, 45)" clone_start="1" clone_end="1">
			<code function_name="DummySegmentation()">  DummySegmentation() : BaseSegmentation() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(108, 2)" endLine="(108, 47)" clone_start="1" clone_end="1">
			<code function_name="DummyObjectBuilder()">  DummyObjectBuilder() : BaseObjectBuilder() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(157, 2)" endLine="(157, 35)" clone_start="1" clone_end="1">
			<code function_name="DummyTracker()">  DummyTracker() : BaseTracker() {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(282, 0)" endLine="(324, 1)" clone_start="35" clone_end="42">
			<code function_name="Obstacle::SetAcceleration(Feature* feature)">void Obstacle::SetAcceleration(Feature* feature) {
  double acc_x = 0.0;
  double acc_y = 0.0;
  double acc_z = 0.0;

  if (feature_history_.size() &gt; 0) {
    double curr_ts = feature-&gt;timestamp();
    double prev_ts = feature_history_.front().timestamp();

    const Point3D&amp; curr_velocity = feature-&gt;velocity();
    const Point3D&amp; prev_velocity = feature_history_.front().velocity();

    if (common::math::DoubleCompare(curr_ts, prev_ts) == 1) {
      double damping_x = Damp(curr_velocity.x(), 0.001);
      double damping_y = Damp(curr_velocity.y(), 0.001);
      double damping_z = Damp(curr_velocity.z(), 0.001);

      acc_x = (curr_velocity.x() - prev_velocity.x()) / (curr_ts - prev_ts);
      acc_y = (curr_velocity.y() - prev_velocity.y()) / (curr_ts - prev_ts);
      acc_z = (curr_velocity.z() - prev_velocity.z()) / (curr_ts - prev_ts);

      acc_x =
          common::math::Clamp(acc_x * damping_x, FLAGS_min_acc, FLAGS_max_acc);
      acc_y =
          common::math::Clamp(acc_y * damping_y, FLAGS_min_acc, FLAGS_max_acc);
      acc_z =
          common::math::Clamp(acc_z * damping_z, FLAGS_min_acc, FLAGS_max_acc);
    }
  }

  feature-&gt;mutable_acceleration()-&gt;set_x(acc_x);
  feature-&gt;mutable_acceleration()-&gt;set_y(acc_y);
  feature-&gt;mutable_acceleration()-&gt;set_z(acc_z);
  double acc = std::hypot(std::hypot(acc_x, acc_y), acc_z);
  feature-&gt;set_acc(acc);

  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has acceleration [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; acc_x &lt;&lt; ", " &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; acc_y &lt;&lt; ", " &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; acc_z &lt;&lt; "]";
  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has acceleration value [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; acc &lt;&lt; "].";
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(245, 0)" endLine="(280, 1)" clone_start="26" clone_end="33">
			<code function_name="Obstacle::SetVelocity(const PerceptionObstacle&amp; perception_obstacle, Feature* feature)">void Obstacle::SetVelocity(const PerceptionObstacle&amp; perception_obstacle,
                           Feature* feature) {
  double velocity_x = 0.0;
  double velocity_y = 0.0;
  double velocity_z = 0.0;

  if (perception_obstacle.has_velocity()) {
    if (perception_obstacle.velocity().has_x()) {
      velocity_x = perception_obstacle.velocity().x();
    }
    if (perception_obstacle.velocity().has_y()) {
      velocity_y = perception_obstacle.velocity().y();
    }
    if (perception_obstacle.velocity().has_z()) {
      velocity_z = perception_obstacle.velocity().z();
    }
  }

  feature-&gt;mutable_velocity()-&gt;set_x(velocity_x);
  feature-&gt;mutable_velocity()-&gt;set_y(velocity_y);
  feature-&gt;mutable_velocity()-&gt;set_z(velocity_z);

  double speed = std::hypot(std::hypot(velocity_x, velocity_y), velocity_z);
  double velocity_heading = std::atan2(velocity_y, velocity_x);
  feature-&gt;set_velocity_heading(velocity_heading);
  feature-&gt;set_speed(speed);

  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has velocity [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; velocity_x &lt;&lt; ", " &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; velocity_y &lt;&lt; ", " &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; velocity_z &lt;&lt; "]";
  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has velocity heading [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; velocity_heading &lt;&lt; "] ";
  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has speed [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; speed &lt;&lt; "].";
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(276, 0)" endLine="(332, 1)" clone_start="17" clone_end="24">
			<code function_name="SerialStream::read(uint8_t* buffer, size_t max_length)">size_t SerialStream::read(uint8_t* buffer, size_t max_length) {
  if (!_is_open) {
    if (!connect()) {
      return 0;
    }
    ROS_INFO_STREAM("Connect " &lt;&lt; _device_name &lt;&lt; " success.");
  }

  ssize_t bytes_read = 0;
  ssize_t bytes_current_read = 0;

  wait_readable(100000);  // wait 10ms

  while (max_length &gt; 0) {
    bytes_current_read = ::read(_fd, buffer, max_length);
    if (bytes_current_read &lt; 0) {
      switch (errno) {
        case EAGAIN:
        case EINVAL:
          bytes_current_read = 0;
          break;

        case EBADF:
        case EIO:
          ROS_ERROR_STREAM(
              "Serial stream read data failed, error: " &lt;&lt; strerror(errno));
          disconnect();
          if (connect()) {
            ROS_INFO_STREAM("Reconnect " &lt;&lt; _device_name &lt;&lt; "success.");
            bytes_current_read = 0;
            break;  // has recoverable
          }

        default:
          ROS_ERROR_STREAM_THROTTLE(1, "Serial stream read data failed, error: "
                                           &lt;&lt; strerror(errno)
                                           &lt;&lt; ", errno: " &lt;&lt; errno);
          _status = Stream::Status::ERROR;
          _errno = errno;
          return bytes_read;
      }
    }

    if (bytes_current_read == 0) {
      if (!bytes_read) {
        check_remove();
        return 0;
      }
      return bytes_read;
    }
    max_length -= bytes_current_read;
    buffer += bytes_current_read;
    bytes_read += bytes_current_read;
  }

  return bytes_read;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(334, 0)" endLine="(386, 1)" clone_start="17" clone_end="24">
			<code function_name="SerialStream::write(const uint8_t* data, size_t length)">size_t SerialStream::write(const uint8_t* data, size_t length) {
  if (!_is_open) {
    if (!connect()) {
      return 0;
    }
    ROS_INFO_STREAM("Connect " &lt;&lt; _device_name &lt;&lt; " success.");
  }

  size_t total_nsent = 0;
  size_t delay_times = 0;

  while ((length &gt; 0) &amp;&amp; (delay_times &lt; 5)) {
    ssize_t nsent = ::write(_fd, data, length);
    if (nsent &lt; 0) {
      ROS_ERROR_STREAM(
          "Serial stream write data failed, error: " &lt;&lt; strerror(errno));
      switch (errno) {
        case EAGAIN:
        case EINVAL:
          nsent = 0;
          break;

        case EBADF:
        case EIO:
          disconnect();
          if (connect()) {
            ROS_INFO_STREAM("Reconnect " &lt;&lt; _device_name &lt;&lt; "success.");
            nsent = 0;
            break;  // has recoverable
          }

        default:
          _status = Stream::Status::ERROR;
          _errno = errno;
          return total_nsent;
      }
    }

    if (nsent == 0) {
      if (!wait_writable(_byte_time_us)) {
        break;
      }
      ++delay_times;
      continue;
    }

    total_nsent += nsent;
    length -= nsent;
    data += nsent;
  }

  return total_nsent;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hungarian_matcher.h" startLine="(29, 2)" endLine="(29, 23)" clone_start="1" clone_end="1">
			<code function_name="HungarianMatcher()">  HungarianMatcher() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\kalman_filter.h" startLine="(30, 2)" endLine="(30, 20)" clone_start="1" clone_end="1">
			<code function_name="~KalmanFilter()">  ~KalmanFilter() {}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\pedestrian\regional_predictor.h" startLine="(40, 2)" endLine="(40, 32)" clone_start="1" clone_end="1">
			<code function_name="RegionalPredictor()">  RegionalPredictor() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\vehicle\free_move_predictor.h" startLine="(38, 2)" endLine="(38, 32)" clone_start="1" clone_end="1">
			<code function_name="FreeMovePredictor()">  FreeMovePredictor() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\vehicle\lane_sequence_predictor.h" startLine="(41, 2)" endLine="(41, 36)" clone_start="1" clone_end="1">
			<code function_name="LaneSequencePredictor()">  LaneSequencePredictor() = default;</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\pedestrian\regional_predictor.h" startLine="(45, 2)" endLine="(45, 41)" clone_start="1" clone_end="1">
			<code function_name="~RegionalPredictor()">  virtual ~RegionalPredictor() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\vehicle\free_move_predictor.h" startLine="(43, 2)" endLine="(43, 41)" clone_start="1" clone_end="1">
			<code function_name="~FreeMovePredictor()">  virtual ~FreeMovePredictor() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\vehicle\lane_sequence_predictor.h" startLine="(46, 2)" endLine="(46, 45)" clone_start="1" clone_end="1">
			<code function_name="~LaneSequencePredictor()">  virtual ~LaneSequencePredictor() = default;</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\util\util.cc" startLine="(67, 0)" endLine="(79, 1)" clone_start="6" clone_end="12">
			<code function_name="MakePathPoint(const double x, const double y, const double z,const double theta, const double kappa, const double dkappa, const double ddkappa)">PathPoint MakePathPoint(const double x, const double y, const double z,
                        const double theta, const double kappa,
                        const double dkappa, const double ddkappa) {
  PathPoint path_point;
  path_point.set_x(x);
  path_point.set_y(y);
  path_point.set_z(z);
  path_point.set_theta(theta);
  path_point.set_kappa(kappa);
  path_point.set_dkappa(dkappa);
  path_point.set_ddkappa(ddkappa);
  return path_point;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\planning_util.cc" startLine="(35, 0)" endLine="(71, 1)" clone_start="30" clone_end="36">
			<code function_name="interpolate(const PathPoint &amp;p0, const PathPoint &amp;p1, const double s)">PathPoint interpolate(const PathPoint &amp;p0, const PathPoint &amp;p1,
                      const double s) {
  double s0 = p0.s();
  double s1 = p1.s();
  CHECK(s0 &lt;= s &amp;&amp; s &lt;= s1);

  std::array&lt;double, 2&gt; gx0{{p0.theta(), p0.kappa()}};
  std::array&lt;double, 2&gt; gx1{{p1.theta(), p1.kappa()}};
  HermiteSpline&lt;double, 3&gt; geometry_spline(gx0, gx1, s0, s1);
  auto func_cos_theta = [&amp;geometry_spline](const double s) {
    auto theta = geometry_spline.Evaluate(0, s);
    return std::cos(theta);
  };
  auto func_sin_theta = [&amp;geometry_spline](const double s) {
    auto theta = geometry_spline.Evaluate(0, s);
    return std::sin(theta);
  };

  double x =
      p0.x() + common::math::IntegrateByGaussLegendre(func_cos_theta, s0, s);
  double y =
      p0.y() + common::math::IntegrateByGaussLegendre(func_sin_theta, s0, s);
  double theta = geometry_spline.Evaluate(0, s);
  double kappa = geometry_spline.Evaluate(1, s);
  double dkappa = geometry_spline.Evaluate(2, s);
  double d2kappa = geometry_spline.Evaluate(3, s);

  PathPoint p;
  p.set_x(x);
  p.set_y(y);
  p.set_theta(theta);
  p.set_kappa(kappa);
  p.set_dkappa(dkappa);
  p.set_ddkappa(d2kappa);
  p.set_s(s);
  return p;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\planning_util.cc" startLine="(73, 0)" endLine="(100, 1)" clone_start="21" clone_end="27">
			<code function_name="InterpolateUsingLinearApproximation(const PathPoint &amp;p0,const PathPoint &amp;p1, const double s)">PathPoint InterpolateUsingLinearApproximation(const PathPoint &amp;p0,
                                              const PathPoint &amp;p1,
                                              const double s) {
  double s0 = p0.s();
  double s1 = p1.s();
  CHECK(s0 &lt; s1);

  PathPoint path_point;
  double weight = (s - s0) / (s1 - s0);
  double x = (1 - weight) * p0.x() + weight * p1.x();
  double y = (1 - weight) * p0.y() + weight * p1.y();
  double cos_heading =
      (1 - weight) * std::cos(p0.theta()) + weight * std::cos(p1.theta());
  double sin_heading =
      (1 - weight) * std::sin(p0.theta()) + weight * std::sin(p1.theta());
  double theta = std::atan2(sin_heading, cos_heading);
  double kappa = (1 - weight) * p0.kappa() + weight * p1.kappa();
  double dkappa = (1 - weight) * p0.dkappa() + weight * p1.dkappa();
  double ddkappa = (1 - weight) * p0.ddkappa() + weight * p1.ddkappa();
  path_point.set_x(x);
  path_point.set_y(y);
  path_point.set_theta(theta);
  path_point.set_kappa(kappa);
  path_point.set_dkappa(dkappa);
  path_point.set_ddkappa(ddkappa);
  path_point.set_s(s);
  return path_point;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(47, 0)" endLine="(62, 1)" clone_start="9" clone_end="15">
			<code function_name="Spline2dSeg::SetParams(const std::vector&lt;double&gt;&amp; x_param, const std::vector&lt;double&gt;&amp; y_param)">bool Spline2dSeg::SetParams(const std::vector&lt;double&gt;&amp; x_param,
                            const std::vector&lt;double&gt;&amp; y_param) {
  if (x_param.size() != y_param.size()) {
    return false;
  }

  spline_func_x_ = PolynomialXd(x_param);
  spline_func_y_ = PolynomialXd(y_param);
  derivative_x_.DerivedFrom(spline_func_x_);
  derivative_y_.DerivedFrom(spline_func_y_);
  second_derivative_x_.DerivedFrom(derivative_x_);
  second_derivative_y_.DerivedFrom(derivative_y_);
  third_derivative_x_.DerivedFrom(second_derivative_x_);
  third_derivative_y_.DerivedFrom(second_derivative_y_);
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(342, 0)" endLine="(375, 1)" clone_start="13" clone_end="19">
			<code function_name="Spline2dConstraint::AddSecondDerivativeSmoothConstraint()">bool Spline2dConstraint::AddSecondDerivativeSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(6 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(6 * (t_knots_.size() - 2), 1);

  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);
    std::vector&lt;double&gt; derivative_t = DerivativeCoef(rel_t);
    std::vector&lt;double&gt; second_derivative_t = SecondDerivativeCoef(rel_t);
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(6 * i, j + index_offset) = power_t[j];
      affine_equality(6 * i + 1, j + index_offset) = derivative_t[j];
      affine_equality(6 * i + 2, j + index_offset) = second_derivative_t[j];
      affine_equality(6 * i + 3, j + index_offset + spline_order_) = power_t[j];
      affine_equality(6 * i + 4, j + index_offset + spline_order_) =
          derivative_t[j];
      affine_equality(6 * i + 5, j + index_offset + spline_order_) =
          second_derivative_t[j];
    }
    affine_equality(6 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(6 * i + 1, index_offset + 2 * spline_order_ + 1) = -1.0;
    affine_equality(6 * i + 2, index_offset + 2 * spline_order_ + 2) = -2.0;
    affine_equality(6 * i + 3, index_offset + 3 * spline_order_) = -1.0;
    affine_equality(6 * i + 4, index_offset + 3 * spline_order_ + 1) = -1.0;
    affine_equality(6 * i + 5, index_offset + 3 * spline_order_ + 2) = -2.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(378, 0)" endLine="(417, 1)" clone_start="14" clone_end="20">
			<code function_name="Spline2dConstraint::AddThirdDerivativeSmoothConstraint()">bool Spline2dConstraint::AddThirdDerivativeSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(8 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(8 * (t_knots_.size() - 2), 1);

  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);
    std::vector&lt;double&gt; derivative_t = DerivativeCoef(rel_t);
    std::vector&lt;double&gt; second_derivative_t = SecondDerivativeCoef(rel_t);
    std::vector&lt;double&gt; third_derivative_t = ThirdDerivativeCoef(rel_t);
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(8 * i, j + index_offset) = power_t[j];
      affine_equality(8 * i + 1, j + index_offset) = derivative_t[j];
      affine_equality(8 * i + 2, j + index_offset) = second_derivative_t[j];
      affine_equality(8 * i + 3, j + index_offset) = third_derivative_t[j];
      affine_equality(8 * i + 4, j + index_offset + spline_order_) = power_t[j];
      affine_equality(8 * i + 5, j + index_offset + spline_order_) =
          derivative_t[j];
      affine_equality(8 * i + 6, j + index_offset + spline_order_) =
          second_derivative_t[j];
      affine_equality(8 * i + 7, j + index_offset + spline_order_) =
          third_derivative_t[j];
    }
    affine_equality(8 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(8 * i + 1, index_offset + 2 * spline_order_ + 1) = -1.0;
    affine_equality(8 * i + 2, index_offset + 2 * spline_order_ + 2) = -2.0;
    affine_equality(8 * i + 3, index_offset + 2 * spline_order_ + 3) = -6.0;
    affine_equality(8 * i + 4, index_offset + 3 * spline_order_) = -1.0;
    affine_equality(8 * i + 5, index_offset + 3 * spline_order_ + 1) = -1.0;
    affine_equality(8 * i + 6, index_offset + 3 * spline_order_ + 2) = -2.0;
    affine_equality(8 * i + 7, index_offset + 3 * spline_order_ + 3) = -6.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(71, 0)" endLine="(81, 1)" clone_start="4" clone_end="11">
			<code function_name="ObjectTrack::SetAccelerationNoiseMaximum( const double&amp; acceleration_noise_maximum)">bool ObjectTrack::SetAccelerationNoiseMaximum(
    const double&amp; acceleration_noise_maximum) {
  if (acceleration_noise_maximum &gt; 0) {
    s_acceleration_noise_maximum_ = acceleration_noise_maximum;
    AINFO &lt;&lt; "acceleration noise maximum of object track is "
          &lt;&lt; s_acceleration_noise_maximum_;
    return true;
  }
  AERROR &lt;&lt; "invalid acceleration noise maximum of object track!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(390, 0)" endLine="(400, 1)" clone_start="4" clone_end="11">
			<code function_name="ObjectTrackSet::SetTrackVisibleRatioMinimum( const float&amp; track_visible_ratio_minimum)">bool ObjectTrackSet::SetTrackVisibleRatioMinimum(
    const float&amp; track_visible_ratio_minimum) {
  if (track_visible_ratio_minimum &gt;= 0 &amp;&amp; track_visible_ratio_minimum &lt;= 1) {
    s_track_visible_ratio_minimum_ = track_visible_ratio_minimum;
    AINFO &lt;&lt; "track visible ratio minimum of object track set is "
          &lt;&lt; s_track_visible_ratio_minimum_;
    return true;
  }
  AERROR &lt;&lt; "invalid track visible ratio minimum of object track! ";
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(83, 0)" endLine="(92, 1)" clone_start="1" clone_end="1">
			<code function_name="ObjectTrack::GetNextTrackId()">int ObjectTrack::GetNextTrackId() {
  // Get next avaiable track id
  int ret_track_id = s_track_idx_;
  if (s_track_idx_ == INT_MAX) {
    s_track_idx_ = 0;
  } else {
    s_track_idx_++;
  }
  return ret_track_id;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(402, 0)" endLine="(410, 1)" clone_start="1" clone_end="1">
			<code function_name="ObjectTrackSet::Clear()">void ObjectTrackSet::Clear() {
  for (size_t i = 0; i &lt; tracks_.size(); i++) {
    if (tracks_[i]) {
      delete (tracks_[i]);
      tracks_[i] = nullptr;
    }
  }
  tracks_.clear();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.cc" startLine="(332, 0)" endLine="(381, 1)" clone_start="17" clone_end="25">
			<code function_name="LaneInfo::GetProjection(const Vec2d &amp;point, double *accumulate_s, double *lateral) const">bool LaneInfo::GetProjection(const Vec2d &amp;point, double *accumulate_s,
                             double *lateral) const {
  CHECK_NOTNULL(accumulate_s);
  CHECK_NOTNULL(lateral);

  if (segments_.empty()) {
    return false;
  }
  double min_distance = std::numeric_limits&lt;double&gt;::infinity();
  std::size_t min_index = 0;
  double min_proj = 0.0;
  std::size_t num_segments = segments_.size();
  for (std::size_t i = 0; i &lt; num_segments; ++i) {
    const auto &amp;segment = segments_[i];
    const double distance = segment.DistanceTo(point);
    if (distance &lt; min_distance) {
      const double proj = segment.ProjectOntoUnit(point);
      if (proj &lt; 0.0 &amp;&amp; i &gt; 0) {
        continue;
      }
      if (proj &gt; segment.length() &amp;&amp; i + 1 &lt; num_segments) {
        const auto &amp;next_segment = segments_[i + 1];
        if ((point - next_segment.start())
                .InnerProd(next_segment.unit_direction()) &gt;= 0.0) {
          continue;
        }
      }
      min_distance = distance;
      min_index = i;
      min_proj = proj;
    }
  }

  const auto &amp;segment = segments_[min_index];
  if (min_index + 1 &gt;= num_segments) {
    *accumulate_s = accumulated_s_[min_index] + min_proj;
  } else {
    *accumulate_s =
        accumulated_s_[min_index] + std::min(min_proj, segment.length());
  }
  const double prod = segment.ProductOntoUnit(point);
  if ((min_index == 0 &amp;&amp; min_proj &lt; 0.0) ||
      (min_index + 1 == num_segments &amp;&amp; min_proj &gt; segment.length())) {
    *lateral = prod;
  } else {
    *lateral = (prod &gt; 0.0 ? min_distance : -min_distance);
  }

  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.cc" startLine="(414, 0)" endLine="(461, 1)" clone_start="21" clone_end="29">
			<code function_name="Path::GetProjection(const Vec2d&amp; point, double* accumulate_s, double* lateral, double* min_distance) const">bool Path::GetProjection(const Vec2d&amp; point, double* accumulate_s,
                         double* lateral, double* min_distance) const {
  if (segments_.empty()) {
    return false;
  }
  if (accumulate_s == nullptr || lateral == nullptr ||
      min_distance == nullptr) {
    return false;
  }
  if (use_path_approximation_) {
    return approximation_.GetProjection(*this, point, accumulate_s, lateral,
                                        min_distance);
  }
  CHECK_GE(num_points_, 2);
  *min_distance = std::numeric_limits&lt;double&gt;::infinity();

  for (int i = 0; i &lt; num_segments_; ++i) {
    const auto&amp; segment = segments_[i];
    const double distance = segment.DistanceTo(point);
    if (distance &lt; *min_distance) {
      const double proj = segment.ProjectOntoUnit(point);
      if (proj &lt; 0.0 &amp;&amp; i &gt; 0) {
        continue;
      }
      if (proj &gt; segment.length() &amp;&amp; i + 1 &lt; num_segments_) {
        const auto&amp; next_segment = segments_[i + 1];
        if ((point - next_segment.start())
                .InnerProd(next_segment.unit_direction()) &gt;= 0.0) {
          continue;
        }
      }
      *min_distance = distance;
      if (i + 1 &gt;= num_segments_) {
        *accumulate_s = accumulated_s_[i] + proj;
      } else {
        *accumulate_s = accumulated_s_[i] + std::min(proj, segment.length());
      }
      const double prod = segment.ProductOntoUnit(point);
      if ((i == 0 &amp;&amp; proj &lt; 0.0) ||
          (i + 1 == num_segments_ &amp;&amp; proj &gt; segment.length())) {
        *lateral = prod;
      } else {
        *lateral = (prod &gt; 0.0 ? distance : -distance);
      }
    }
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(342, 0)" endLine="(375, 1)" clone_start="21" clone_end="28">
			<code function_name="Spline2dConstraint::AddSecondDerivativeSmoothConstraint()">bool Spline2dConstraint::AddSecondDerivativeSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(6 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(6 * (t_knots_.size() - 2), 1);

  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);
    std::vector&lt;double&gt; derivative_t = DerivativeCoef(rel_t);
    std::vector&lt;double&gt; second_derivative_t = SecondDerivativeCoef(rel_t);
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(6 * i, j + index_offset) = power_t[j];
      affine_equality(6 * i + 1, j + index_offset) = derivative_t[j];
      affine_equality(6 * i + 2, j + index_offset) = second_derivative_t[j];
      affine_equality(6 * i + 3, j + index_offset + spline_order_) = power_t[j];
      affine_equality(6 * i + 4, j + index_offset + spline_order_) =
          derivative_t[j];
      affine_equality(6 * i + 5, j + index_offset + spline_order_) =
          second_derivative_t[j];
    }
    affine_equality(6 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(6 * i + 1, index_offset + 2 * spline_order_ + 1) = -1.0;
    affine_equality(6 * i + 2, index_offset + 2 * spline_order_ + 2) = -2.0;
    affine_equality(6 * i + 3, index_offset + 3 * spline_order_) = -1.0;
    affine_equality(6 * i + 4, index_offset + 3 * spline_order_ + 1) = -1.0;
    affine_equality(6 * i + 5, index_offset + 3 * spline_order_ + 2) = -2.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(378, 0)" endLine="(417, 1)" clone_start="25" clone_end="32">
			<code function_name="Spline2dConstraint::AddThirdDerivativeSmoothConstraint()">bool Spline2dConstraint::AddThirdDerivativeSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(8 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(8 * (t_knots_.size() - 2), 1);

  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);
    std::vector&lt;double&gt; derivative_t = DerivativeCoef(rel_t);
    std::vector&lt;double&gt; second_derivative_t = SecondDerivativeCoef(rel_t);
    std::vector&lt;double&gt; third_derivative_t = ThirdDerivativeCoef(rel_t);
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(8 * i, j + index_offset) = power_t[j];
      affine_equality(8 * i + 1, j + index_offset) = derivative_t[j];
      affine_equality(8 * i + 2, j + index_offset) = second_derivative_t[j];
      affine_equality(8 * i + 3, j + index_offset) = third_derivative_t[j];
      affine_equality(8 * i + 4, j + index_offset + spline_order_) = power_t[j];
      affine_equality(8 * i + 5, j + index_offset + spline_order_) =
          derivative_t[j];
      affine_equality(8 * i + 6, j + index_offset + spline_order_) =
          second_derivative_t[j];
      affine_equality(8 * i + 7, j + index_offset + spline_order_) =
          third_derivative_t[j];
    }
    affine_equality(8 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(8 * i + 1, index_offset + 2 * spline_order_ + 1) = -1.0;
    affine_equality(8 * i + 2, index_offset + 2 * spline_order_ + 2) = -2.0;
    affine_equality(8 * i + 3, index_offset + 2 * spline_order_ + 3) = -6.0;
    affine_equality(8 * i + 4, index_offset + 3 * spline_order_) = -1.0;
    affine_equality(8 * i + 5, index_offset + 3 * spline_order_ + 1) = -1.0;
    affine_equality(8 * i + 6, index_offset + 3 * spline_order_ + 2) = -2.0;
    affine_equality(8 * i + 7, index_offset + 3 * spline_order_ + 3) = -6.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\qp_spline_st_speed\qp_spline_st_graph.cc" startLine="(134, 0)" endLine="(275, 1)" clone_start="23" clone_end="32">
			<code function_name="QpSplineStGraph::ApplyConstraint(const common::TrajectoryPoint&amp; init_point, const SpeedLimit&amp; speed_limit, const std::vector&lt;StBoundary&gt;&amp; boundaries, const std::pair&lt;double, double&gt;&amp; accel_bound)">Status QpSplineStGraph::ApplyConstraint(
    const common::TrajectoryPoint&amp; init_point, const SpeedLimit&amp; speed_limit,
    const std::vector&lt;StBoundary&gt;&amp; boundaries,
    const std::pair&lt;double, double&gt;&amp; accel_bound) {
  Spline1dConstraint* constraint =
      spline_generator_-&gt;mutable_spline_constraint();
  // position, velocity, acceleration

  if (!constraint-&gt;AddPointConstraint(0.0, 0.0)) {
    const std::string msg = "add st start point constraint failed";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }
  ADEBUG &lt;&lt; "init point constraint:" &lt;&lt; init_point.DebugString();
  if (!constraint-&gt;AddPointDerivativeConstraint(0.0, init_point_.v())) {
    const std::string msg = "add st start point velocity constraint failed!";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  if (!constraint-&gt;AddPointSecondDerivativeConstraint(
          spline_generator_-&gt;spline().x_knots().back(), 0.0)) {
    const std::string msg = "add st end point acceleration constraint failed!";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  // monotone constraint
  if (!constraint-&gt;AddMonotoneInequalityConstraintAtKnots()) {
    const std::string msg = "add monotone inequality constraint failed!";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  // smoothness constraint
  if (!constraint-&gt;AddSecondDerivativeSmoothConstraint()) {
    const std::string msg = "add smoothness joint constraint failed!";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  // boundary constraint
  std::vector&lt;double&gt; s_upper_bound;
  std::vector&lt;double&gt; s_lower_bound;

  for (const double curr_t : t_evaluated_) {
    double lower_s = 0.0;
    double upper_s = 0.0;
    GetSConstraintByTime(boundaries, curr_t,
                         qp_spline_st_speed_config_.total_path_length(),
                         &amp;upper_s, &amp;lower_s);
    s_upper_bound.push_back(upper_s);
    s_lower_bound.push_back(lower_s);
    ADEBUG &lt;&lt; "Add constraint by time: " &lt;&lt; curr_t &lt;&lt; " upper_s: " &lt;&lt; upper_s
           &lt;&lt; " lower_s: " &lt;&lt; lower_s;
  }

  DCHECK_EQ(t_evaluated_.size(), s_lower_bound.size());
  DCHECK_EQ(t_evaluated_.size(), s_upper_bound.size());
  if (!constraint-&gt;AddBoundary(t_evaluated_, s_lower_bound, s_upper_bound)) {
    const std::string msg = "Fail to apply distance constraints.";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  // speed constraint
  std::vector&lt;double&gt; speed_upper_bound;
  if (!EstimateSpeedUpperBound(init_point, speed_limit, &amp;speed_upper_bound)
           .ok()) {
    std::string msg = "Fail to estimate speed upper constraints.";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  std::vector&lt;double&gt; speed_lower_bound(t_evaluated_.size(), 0.0);

  DCHECK_EQ(t_evaluated_.size(), speed_upper_bound.size());
  DCHECK_EQ(t_evaluated_.size(), speed_lower_bound.size());

  if (st_graph_debug_) {
    for (size_t i = 0; i &lt; t_evaluated_.size(); ++i) {
      auto speed_constraint =
          st_graph_debug_-&gt;mutable_speed_constraint()-&gt;Add();
      speed_constraint-&gt;add_t(t_evaluated_[i]);
      speed_constraint-&gt;add_lower_bound(speed_lower_bound[i]);
      speed_constraint-&gt;add_upper_bound(speed_upper_bound[i]);
    }
  }

  if (!constraint-&gt;AddDerivativeBoundary(t_evaluated_, speed_lower_bound,
                                         speed_upper_bound)) {
    const std::string msg = "Fail to apply speed constraints.";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }
  for (size_t i = 0; i &lt; t_evaluated_.size(); ++i) {
    ADEBUG &lt;&lt; "t_evaluated_: " &lt;&lt; t_evaluated_[i]
           &lt;&lt; "; speed_lower_bound: " &lt;&lt; speed_lower_bound[i]
           &lt;&lt; "; speed_upper_bound: " &lt;&lt; speed_upper_bound[i];
  }

  // acceleration constraint
  std::vector&lt;double&gt; accel_lower_bound(t_evaluated_.size(), accel_bound.first);
  std::vector&lt;double&gt; accel_upper_bound(t_evaluated_.size(),
                                        accel_bound.second);

  bool has_follow = false;
  double delta_s = 1.0;
  for (const auto&amp; boundary : boundaries) {
    if (boundary.boundary_type() == StBoundary::BoundaryType::FOLLOW) {
      has_follow = true;
      delta_s = std::fmin(
          delta_s, boundary.min_s() - fabs(boundary.characteristic_length()));
    }
  }
  if (FLAGS_enable_follow_accel_constraint &amp;&amp; has_follow &amp;&amp; delta_s &lt; 0.0) {
    accel_upper_bound.front() = 0.0;
  } else {
    constexpr double kInitPointAccelRelaxedSpeed = 1.0;

    if (init_point_.v() &gt; kInitPointAccelRelaxedSpeed) {
      constexpr double kInitPointAccelRelaxedRange = 0.25;
      accel_lower_bound.front() = init_point_.a() - kInitPointAccelRelaxedRange;
      accel_upper_bound.front() = init_point_.a() + kInitPointAccelRelaxedRange;
    }
  }

  DCHECK_EQ(t_evaluated_.size(), accel_lower_bound.size());
  DCHECK_EQ(t_evaluated_.size(), accel_upper_bound.size());
  if (!constraint-&gt;AddSecondDerivativeBoundary(t_evaluated_, accel_lower_bound,
                                               accel_upper_bound)) {
    const std::string msg = "Fail to apply acceleration constraints.";
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }
  for (size_t i = 0; i &lt; t_evaluated_.size(); ++i) {
    ADEBUG &lt;&lt; "t_evaluated_: " &lt;&lt; t_evaluated_[i]
           &lt;&lt; "; accel_lower_bound: " &lt;&lt; accel_lower_bound[i]
           &lt;&lt; "; accel_upper_bound: " &lt;&lt; accel_upper_bound[i];
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\qp_spline_st_speed\qp_spline_st_graph.cc" startLine="(134, 0)" endLine="(275, 1)" clone_start="30" clone_end="39">
			<code function_name="QpSplineStGraph::ApplyConstraint(const common::TrajectoryPoint&amp; init_point, const SpeedLimit&amp; speed_limit, const std::vector&lt;StBoundary&gt;&amp; boundaries, const std::pair&lt;double, double&gt;&amp; accel_bound)">Status QpSplineStGraph::ApplyConstraint(
    const common::TrajectoryPoint&amp; init_point, const SpeedLimit&amp; speed_limit,
    const std::vector&lt;StBoundary&gt;&amp; boundaries,
    const std::pair&lt;double, double&gt;&amp; accel_bound) {
  Spline1dConstraint* constraint =
      spline_generator_-&gt;mutable_spline_constraint();
  // position, velocity, acceleration

  if (!constraint-&gt;AddPointConstraint(0.0, 0.0)) {
    const std::string msg = "add st start point constraint failed";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }
  ADEBUG &lt;&lt; "init point constraint:" &lt;&lt; init_point.DebugString();
  if (!constraint-&gt;AddPointDerivativeConstraint(0.0, init_point_.v())) {
    const std::string msg = "add st start point velocity constraint failed!";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  if (!constraint-&gt;AddPointSecondDerivativeConstraint(
          spline_generator_-&gt;spline().x_knots().back(), 0.0)) {
    const std::string msg = "add st end point acceleration constraint failed!";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  // monotone constraint
  if (!constraint-&gt;AddMonotoneInequalityConstraintAtKnots()) {
    const std::string msg = "add monotone inequality constraint failed!";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  // smoothness constraint
  if (!constraint-&gt;AddSecondDerivativeSmoothConstraint()) {
    const std::string msg = "add smoothness joint constraint failed!";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  // boundary constraint
  std::vector&lt;double&gt; s_upper_bound;
  std::vector&lt;double&gt; s_lower_bound;

  for (const double curr_t : t_evaluated_) {
    double lower_s = 0.0;
    double upper_s = 0.0;
    GetSConstraintByTime(boundaries, curr_t,
                         qp_spline_st_speed_config_.total_path_length(),
                         &amp;upper_s, &amp;lower_s);
    s_upper_bound.push_back(upper_s);
    s_lower_bound.push_back(lower_s);
    ADEBUG &lt;&lt; "Add constraint by time: " &lt;&lt; curr_t &lt;&lt; " upper_s: " &lt;&lt; upper_s
           &lt;&lt; " lower_s: " &lt;&lt; lower_s;
  }

  DCHECK_EQ(t_evaluated_.size(), s_lower_bound.size());
  DCHECK_EQ(t_evaluated_.size(), s_upper_bound.size());
  if (!constraint-&gt;AddBoundary(t_evaluated_, s_lower_bound, s_upper_bound)) {
    const std::string msg = "Fail to apply distance constraints.";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  // speed constraint
  std::vector&lt;double&gt; speed_upper_bound;
  if (!EstimateSpeedUpperBound(init_point, speed_limit, &amp;speed_upper_bound)
           .ok()) {
    std::string msg = "Fail to estimate speed upper constraints.";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  std::vector&lt;double&gt; speed_lower_bound(t_evaluated_.size(), 0.0);

  DCHECK_EQ(t_evaluated_.size(), speed_upper_bound.size());
  DCHECK_EQ(t_evaluated_.size(), speed_lower_bound.size());

  if (st_graph_debug_) {
    for (size_t i = 0; i &lt; t_evaluated_.size(); ++i) {
      auto speed_constraint =
          st_graph_debug_-&gt;mutable_speed_constraint()-&gt;Add();
      speed_constraint-&gt;add_t(t_evaluated_[i]);
      speed_constraint-&gt;add_lower_bound(speed_lower_bound[i]);
      speed_constraint-&gt;add_upper_bound(speed_upper_bound[i]);
    }
  }

  if (!constraint-&gt;AddDerivativeBoundary(t_evaluated_, speed_lower_bound,
                                         speed_upper_bound)) {
    const std::string msg = "Fail to apply speed constraints.";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }
  for (size_t i = 0; i &lt; t_evaluated_.size(); ++i) {
    ADEBUG &lt;&lt; "t_evaluated_: " &lt;&lt; t_evaluated_[i]
           &lt;&lt; "; speed_lower_bound: " &lt;&lt; speed_lower_bound[i]
           &lt;&lt; "; speed_upper_bound: " &lt;&lt; speed_upper_bound[i];
  }

  // acceleration constraint
  std::vector&lt;double&gt; accel_lower_bound(t_evaluated_.size(), accel_bound.first);
  std::vector&lt;double&gt; accel_upper_bound(t_evaluated_.size(),
                                        accel_bound.second);

  bool has_follow = false;
  double delta_s = 1.0;
  for (const auto&amp; boundary : boundaries) {
    if (boundary.boundary_type() == StBoundary::BoundaryType::FOLLOW) {
      has_follow = true;
      delta_s = std::fmin(
          delta_s, boundary.min_s() - fabs(boundary.characteristic_length()));
    }
  }
  if (FLAGS_enable_follow_accel_constraint &amp;&amp; has_follow &amp;&amp; delta_s &lt; 0.0) {
    accel_upper_bound.front() = 0.0;
  } else {
    constexpr double kInitPointAccelRelaxedSpeed = 1.0;

    if (init_point_.v() &gt; kInitPointAccelRelaxedSpeed) {
      constexpr double kInitPointAccelRelaxedRange = 0.25;
      accel_lower_bound.front() = init_point_.a() - kInitPointAccelRelaxedRange;
      accel_upper_bound.front() = init_point_.a() + kInitPointAccelRelaxedRange;
    }
  }

  DCHECK_EQ(t_evaluated_.size(), accel_lower_bound.size());
  DCHECK_EQ(t_evaluated_.size(), accel_upper_bound.size());
  if (!constraint-&gt;AddSecondDerivativeBoundary(t_evaluated_, accel_lower_bound,
                                               accel_upper_bound)) {
    const std::string msg = "Fail to apply acceleration constraints.";
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }
  for (size_t i = 0; i &lt; t_evaluated_.size(); ++i) {
    ADEBUG &lt;&lt; "t_evaluated_: " &lt;&lt; t_evaluated_[i]
           &lt;&lt; "; accel_lower_bound: " &lt;&lt; accel_lower_bound[i]
           &lt;&lt; "; accel_upper_bound: " &lt;&lt; accel_upper_bound[i];
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(26, 0)" endLine="(90, 1)" clone_start="63" clone_end="65">
			<code function_name="Gear67::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Gear67::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t gear = gear_state(bytes, length);
  switch (gear) {
    case 0x01:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_PARKING);
      break;
    case 0x02:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_REVERSE);
      break;
    case 0x03:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_NEUTRAL);
      break;
    case 0x04:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_DRIVE);
      break;
    case 0x05:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_LOW);
      break;
    case 0x00:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_NONE);
      break;
    default:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_INVALID);
      break;
  }

  if (is_driver_override(bytes, length)) {
    // last shift requested by driver
    chassis_detail-&gt;mutable_gear()-&gt;set_is_shift_position_valid(false);
  } else {
    // last shift requested by-wire
    chassis_detail-&gt;mutable_gear()-&gt;set_is_shift_position_valid(true);
  }
  chassis_detail-&gt;mutable_gear()-&gt;set_driver_override(
      is_driver_override(bytes, length));

  int32_t gear_cmd = reported_gear_cmd(bytes, length);
  switch (gear_cmd) {
    case 0x01:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_PARKING);
      break;
    case 0x02:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_REVERSE);
      break;
    case 0x03:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_NEUTRAL);
      break;
    case 0x04:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_DRIVE);
      break;
    case 0x05:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_LOW);
      break;
    case 0x00:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_NONE);
      break;
    default:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_INVALID);
      break;
  }

  chassis_detail-&gt;mutable_gear()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="189" clone_end="195">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(26, 0)" endLine="(41, 1)" clone_start="14" clone_end="16">
			<code function_name="Gps6e::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Gps6e::Parse(const std::uint8_t *bytes, int32_t length,
                  ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_basic()-&gt;set_year(year(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_month(month(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_day(day(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_hours(hours(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_minutes(minutes(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_seconds(seconds(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_compass_direction(
      compass_direction(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_pdop(pdop(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_is_gps_fault(
      is_gps_fault(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_is_inferred(
      is_inferred_position(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(92, 0)" endLine="(96, 1)" clone_start="1" clone_end="5">
			<code function_name="Gear67::gear_state(const std::uint8_t *bytes, int32_t length) const">int32_t Gear67::gear_state(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(222, 0)" endLine="(227, 1)" clone_start="1" clone_end="6">
			<code function_name="Misc69::turn_signal_status(const std::uint8_t *bytes, int32_t length) const">int32_t Misc69::turn_signal_status(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(43, 0)" endLine="(47, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::year(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::year(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 7);
  return x;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(98, 0)" endLine="(102, 1)" clone_start="1" clone_end="3">
			<code function_name="Gear67::is_driver_override(const std::uint8_t *bytes, int32_t length) const">bool Gear67::is_driver_override(const std::uint8_t *bytes,
                                int32_t length) const {
  Byte frame(bytes + 0);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(229, 0)" endLine="(234, 1)" clone_start="1" clone_end="3">
			<code function_name="Misc69::high_beam_status(const std::uint8_t *bytes, int32_t length) const">int32_t Misc69::high_beam_status(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(2, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(49, 0)" endLine="(53, 1)" clone_start="1" clone_end="2">
			<code function_name="Gps6e::month(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::month(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 4);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\controller\lat_controller.cc" startLine="(265, 0)" endLine="(370, 1)" clone_start="92" clone_end="100">
			<code function_name="LatController::ComputeControlCommand(const localization::LocalizationEstimate *localization, const canbus::Chassis *chassis, const planning::ADCTrajectory *planning_published_trajectory, ControlCommand *cmd)">Status LatController::ComputeControlCommand(
    const localization::LocalizationEstimate *localization,
    const canbus::Chassis *chassis,
    const planning::ADCTrajectory *planning_published_trajectory,
    ControlCommand *cmd) {
  VehicleState::instance()-&gt;set_linear_velocity(
      std::max(VehicleState::instance()-&gt;linear_velocity(), 1.0));

  trajectory_analyzer_ =
      std::move(TrajectoryAnalyzer(planning_published_trajectory));

  SimpleLateralDebug *debug = cmd-&gt;mutable_debug()-&gt;mutable_simple_lat_debug();
  debug-&gt;Clear();

  // Update state = [Lateral Error, Lateral Error Rate, Heading Error, Heading
  // Error Rate, preview lateral error1 , preview lateral error2, ...]
  UpdateStateAnalyticalMatching(debug);

  UpdateMatrix();

  // Compound discrete matrix with road preview model
  UpdateMatrixCompound();

  // Add gain sheduler for higher speed steering
  if (FLAGS_enable_gain_scheduler) {
    matrix_q_updated_(0, 0) =
        matrix_q_(0, 0) * lat_err_interpolation_-&gt;Interpolate(
                              VehicleState::instance()-&gt;linear_velocity());
    matrix_q_updated_(2, 2) =
        matrix_q_(2, 2) * heading_err_interpolation_-&gt;Interpolate(
                              VehicleState::instance()-&gt;linear_velocity());
    common::math::SolveLQRProblem(matrix_adc_, matrix_bdc_, matrix_q_updated_,
                                  matrix_r_, lqr_eps_, lqr_max_iteration_,
                                  &amp;matrix_k_);
  } else {
    common::math::SolveLQRProblem(matrix_adc_, matrix_bdc_, matrix_q_,
                                  matrix_r_, lqr_eps_, lqr_max_iteration_,
                                  &amp;matrix_k_);
  }

  // feedback = - K * state
  // Convert vehicle steer angle from rad to degree and then to steer degree
  // then to 100% ratio
  double steer_angle_feedback = -(matrix_k_ * matrix_state_)(0, 0) * 180 /
                                M_PI * steer_transmission_ratio_ /
                                steer_single_direction_max_degree_ * 100;

  double steer_angle_feedforward = ComputeFeedForward(debug-&gt;curvature());
  double steer_angle = steer_angle_feedback + steer_angle_feedforward;

  // Clamp the steer angle to -100.0 to 100.0
  steer_angle = apollo::common::math::Clamp(steer_angle, -100.0, 100.0);

  if (FLAGS_set_steer_limit) {
    double steer_limit =
        std::atan(max_lat_acc_ * wheelbase_ /
                  (VehicleState::instance()-&gt;linear_velocity() *
                   VehicleState::instance()-&gt;linear_velocity())) *
        steer_transmission_ratio_ * 180 / M_PI /
        steer_single_direction_max_degree_ * 100;

    // Clamp the steer angle
    double steer_angle_limited =
        apollo::common::math::Clamp(steer_angle, -steer_limit, steer_limit);
    steer_angle_limited = digital_filter_.Filter(steer_angle_limited);
    cmd-&gt;set_steering_target(steer_angle_limited);
    debug-&gt;set_steer_angle_limited(steer_angle_limited);
  } else {
    steer_angle = digital_filter_.Filter(steer_angle);
    cmd-&gt;set_steering_target(steer_angle);
  }

  cmd-&gt;set_steering_rate(FLAGS_steer_angle_rate);
  // compute extra information for logging and debugging
  double steer_angle_lateral_contribution =
      -matrix_k_(0, 0) * matrix_state_(0, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_lateral_rate_contribution =
      -matrix_k_(0, 1) * matrix_state_(1, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_heading_contribution =
      -matrix_k_(0, 2) * matrix_state_(2, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_heading_rate_contribution =
      -matrix_k_(0, 3) * matrix_state_(3, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  debug-&gt;set_heading(VehicleState::instance()-&gt;heading());
  debug-&gt;set_steer_angle(steer_angle);
  debug-&gt;set_steer_angle_feedforward(steer_angle_feedforward);
  debug-&gt;set_steer_angle_lateral_contribution(steer_angle_lateral_contribution);
  debug-&gt;set_steer_angle_lateral_rate_contribution(
      steer_angle_lateral_rate_contribution);
  debug-&gt;set_steer_angle_heading_contribution(steer_angle_heading_contribution);
  debug-&gt;set_steer_angle_heading_rate_contribution(
      steer_angle_heading_rate_contribution);
  debug-&gt;set_steer_angle_feedback(steer_angle_feedback);
  debug-&gt;set_steering_position(chassis-&gt;steering_percentage());
  debug-&gt;set_ref_speed(VehicleState::instance()-&gt;linear_velocity());

  ProcessLogs(debug, chassis);
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\planning_util.cc" startLine="(102, 0)" endLine="(167, 1)" clone_start="56" clone_end="62">
			<code function_name="interpolate(const TrajectoryPoint &amp;tp0, const TrajectoryPoint &amp;tp1, const double t)">TrajectoryPoint interpolate(const TrajectoryPoint &amp;tp0,
                            const TrajectoryPoint &amp;tp1, const double t) {
  if (std::abs(tp0.path_point().s() - tp0.path_point().s()) &lt; 1.0e-4) {
    return tp1;
  }

  const PathPoint &amp;pp0 = tp0.path_point();
  const PathPoint &amp;pp1 = tp1.path_point();
  double t0 = tp0.relative_time();
  double t1 = tp1.relative_time();

  std::array&lt;double, 2&gt; dx0{{tp0.v(), tp0.a()}};
  std::array&lt;double, 2&gt; dx1{{tp1.v(), tp1.a()}};
  HermiteSpline&lt;double, 3&gt; dynamic_spline(dx0, dx1, t0, t1);

  double s0 = 0.0;
  auto func_v = [&amp;dynamic_spline](const double t) {
    return dynamic_spline.Evaluate(0, t);
  };
  double s1 = common::math::IntegrateByGaussLegendre(func_v, t0, t1);
  double s = common::math::IntegrateByGaussLegendre(func_v, t0, t);

  if (std::abs(tp0.path_point().s() - s1) &lt; 1.0e-4) {
    return tp1;
  }

  double v = dynamic_spline.Evaluate(0, t);
  double a = dynamic_spline.Evaluate(1, t);

  std::array&lt;double, 2&gt; gx0{{pp0.theta(), pp0.kappa()}};
  std::array&lt;double, 2&gt; gx1{{pp1.theta(), pp1.kappa()}};
  HermiteSpline&lt;double, 3&gt; geometry_spline(gx0, gx1, s0, s1);
  auto func_cos_theta = [&amp;geometry_spline](const double s) {
    auto theta = geometry_spline.Evaluate(0, s);
    return std::cos(theta);
  };
  auto func_sin_theta = [&amp;geometry_spline](const double s) {
    auto theta = geometry_spline.Evaluate(0, s);
    return std::sin(theta);
  };

  double x =
      pp0.x() + common::math::IntegrateByGaussLegendre(func_cos_theta, s0, s);
  double y =
      pp0.y() + common::math::IntegrateByGaussLegendre(func_sin_theta, s0, s);
  double theta = geometry_spline.Evaluate(0, s);
  double kappa = geometry_spline.Evaluate(1, s);
  double dkappa = geometry_spline.Evaluate(2, s);
  double d2kappa = geometry_spline.Evaluate(3, s);

  TrajectoryPoint tp;
  tp.set_v(v);
  tp.set_a(a);

  PathPoint *path_point = tp.mutable_path_point();
  path_point-&gt;set_x(x);
  path_point-&gt;set_y(y);
  path_point-&gt;set_theta(theta);
  path_point-&gt;set_kappa(kappa);
  path_point-&gt;set_dkappa(dkappa);
  path_point-&gt;set_ddkappa(d2kappa);
  path_point-&gt;set_s(s);

  // check the diff of computed s1 and p1.s()?
  return tp;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\core\navigator.cc" startLine="(35, 0)" endLine="(78, 1)" clone_start="14" clone_end="21">
			<code function_name="ShowRequestInfo(const RoutingRequest&amp; request, const TopoGraph* graph)">bool ShowRequestInfo(const RoutingRequest&amp; request, const TopoGraph* graph) {
  const auto&amp; start = request.start();
  const auto&amp; end = request.end();
  const auto* node = graph-&gt;GetNode(start.id());
  if (node == nullptr) {
    AERROR &lt;&lt; "Start node is not found in topo graph! ID: " &lt;&lt; start.id();
    return false;
  }
  AINFO &lt;&lt; "Start point:\tlane id: " &lt;&lt; start.id() &lt;&lt; " s: " &lt;&lt; start.s()
        &lt;&lt; " x: " &lt;&lt; start.pose().x() &lt;&lt; " y: " &lt;&lt; start.pose().y()
        &lt;&lt; " length: " &lt;&lt; node-&gt;Length();

  for (const auto&amp; wp : request.waypoint()) {
    node = graph-&gt;GetNode(wp.id());
    if (node == nullptr) {
      AERROR &lt;&lt; "Way node is not found in topo graph! ID: " &lt;&lt; wp.id();
      return false;
    }
    AINFO &lt;&lt; "Way point:\tlane id: " &lt;&lt; wp.id() &lt;&lt; " s: " &lt;&lt; wp.s()
          &lt;&lt; " x: " &lt;&lt; wp.pose().x() &lt;&lt; " y: " &lt;&lt; wp.pose().y()
          &lt;&lt; " length: " &lt;&lt; node-&gt;Length();
  }

  for (const auto&amp; bl : request.blacklisted_lane()) {
    node = graph-&gt;GetNode(bl.id());
    if (node == nullptr) {
      AERROR &lt;&lt; "Black list node is not found in topo graph! ID: " &lt;&lt; bl.id();
      return false;
    }
    AINFO &lt;&lt; "Black point:\tlane id: " &lt;&lt; bl.id()
          &lt;&lt; " start_s: " &lt;&lt; bl.start_s() &lt;&lt; " end_s: " &lt;&lt; bl.end_s()
          &lt;&lt; " length: " &lt;&lt; node-&gt;Length();
  }

  node = graph-&gt;GetNode(end.id());
  if (node == nullptr) {
    AERROR &lt;&lt; "End node is not found in topo graph! ID: " &lt;&lt; end.id();
    return false;
  }
  AINFO &lt;&lt; "End point:\tlane id: " &lt;&lt; end.id() &lt;&lt; " s: " &lt;&lt; end.s()
        &lt;&lt; " x: " &lt;&lt; end.pose().x() &lt;&lt; " y: " &lt;&lt; end.pose().y()
        &lt;&lt; " length: " &lt;&lt; node-&gt;Length();
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\core\navigator.cc" startLine="(35, 0)" endLine="(78, 1)" clone_start="35" clone_end="42">
			<code function_name="ShowRequestInfo(const RoutingRequest&amp; request, const TopoGraph* graph)">bool ShowRequestInfo(const RoutingRequest&amp; request, const TopoGraph* graph) {
  const auto&amp; start = request.start();
  const auto&amp; end = request.end();
  const auto* node = graph-&gt;GetNode(start.id());
  if (node == nullptr) {
    AERROR &lt;&lt; "Start node is not found in topo graph! ID: " &lt;&lt; start.id();
    return false;
  }
  AINFO &lt;&lt; "Start point:\tlane id: " &lt;&lt; start.id() &lt;&lt; " s: " &lt;&lt; start.s()
        &lt;&lt; " x: " &lt;&lt; start.pose().x() &lt;&lt; " y: " &lt;&lt; start.pose().y()
        &lt;&lt; " length: " &lt;&lt; node-&gt;Length();

  for (const auto&amp; wp : request.waypoint()) {
    node = graph-&gt;GetNode(wp.id());
    if (node == nullptr) {
      AERROR &lt;&lt; "Way node is not found in topo graph! ID: " &lt;&lt; wp.id();
      return false;
    }
    AINFO &lt;&lt; "Way point:\tlane id: " &lt;&lt; wp.id() &lt;&lt; " s: " &lt;&lt; wp.s()
          &lt;&lt; " x: " &lt;&lt; wp.pose().x() &lt;&lt; " y: " &lt;&lt; wp.pose().y()
          &lt;&lt; " length: " &lt;&lt; node-&gt;Length();
  }

  for (const auto&amp; bl : request.blacklisted_lane()) {
    node = graph-&gt;GetNode(bl.id());
    if (node == nullptr) {
      AERROR &lt;&lt; "Black list node is not found in topo graph! ID: " &lt;&lt; bl.id();
      return false;
    }
    AINFO &lt;&lt; "Black point:\tlane id: " &lt;&lt; bl.id()
          &lt;&lt; " start_s: " &lt;&lt; bl.start_s() &lt;&lt; " end_s: " &lt;&lt; bl.end_s()
          &lt;&lt; " length: " &lt;&lt; node-&gt;Length();
  }

  node = graph-&gt;GetNode(end.id());
  if (node == nullptr) {
    AERROR &lt;&lt; "End node is not found in topo graph! ID: " &lt;&lt; end.id();
    return false;
  }
  AINFO &lt;&lt; "End point:\tlane id: " &lt;&lt; end.id() &lt;&lt; " s: " &lt;&lt; end.s()
        &lt;&lt; " x: " &lt;&lt; end.pose().x() &lt;&lt; " y: " &lt;&lt; end.pose().y()
        &lt;&lt; " length: " &lt;&lt; node-&gt;Length();
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\aabox2d.h" startLine="(81, 2)" endLine="(81, 49)" clone_start="1" clone_end="1">
			<code function_name="center_x() const">  double center_x() const { return center_.x(); }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\box2d.h" startLine="(96, 2)" endLine="(96, 49)" clone_start="1" clone_end="1">
			<code function_name="center_x() const">  double center_x() const { return center_.x(); }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\aabox2d.h" startLine="(87, 2)" endLine="(87, 49)" clone_start="1" clone_end="1">
			<code function_name="center_y() const">  double center_y() const { return center_.y(); }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\box2d.h" startLine="(102, 2)" endLine="(102, 49)" clone_start="1" clone_end="1">
			<code function_name="center_y() const">  double center_y() const { return center_.y(); }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\aabox2d.h" startLine="(93, 2)" endLine="(93, 43)" clone_start="1" clone_end="1">
			<code function_name="length() const">  double length() const { return length_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\box2d.h" startLine="(108, 2)" endLine="(108, 43)" clone_start="1" clone_end="1">
			<code function_name="length() const">  double length() const { return length_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\aabox2d.h" startLine="(99, 2)" endLine="(99, 41)" clone_start="1" clone_end="1">
			<code function_name="width() const">  double width() const { return width_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\box2d.h" startLine="(114, 2)" endLine="(114, 41)" clone_start="1" clone_end="1">
			<code function_name="width() const">  double width() const { return width_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\aabox2d.h" startLine="(105, 2)" endLine="(105, 53)" clone_start="1" clone_end="1">
			<code function_name="half_length() const">  double half_length() const { return half_length_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\box2d.h" startLine="(120, 2)" endLine="(120, 53)" clone_start="1" clone_end="1">
			<code function_name="half_length() const">  double half_length() const { return half_length_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\aabox2d.h" startLine="(111, 2)" endLine="(111, 51)" clone_start="1" clone_end="1">
			<code function_name="half_width() const">  double half_width() const { return half_width_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\box2d.h" startLine="(126, 2)" endLine="(126, 51)" clone_start="1" clone_end="1">
			<code function_name="half_width() const">  double half_width() const { return half_width_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(441, 0)" endLine="(499, 1)" clone_start="13" clone_end="19">
			<code function_name="Spline1dConstraint::AddThirdDerivativeSmoothConstraint()">bool Spline1dConstraint::AddThirdDerivativeSmoothConstraint() {
  if (x_knots_.size() &lt; 3) {
    return false;
  }

  const std::uint32_t n_constraint = (x_knots_.size() - 2) * 4;
  Eigen::MatrixXd equality_constraint = Eigen::MatrixXd::Zero(
      n_constraint, (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd equality_boundary = Eigen::MatrixXd::Zero(n_constraint, 1);

  for (std::uint32_t i = 0; i &lt; n_constraint; i += 4) {
    double left_coef = 1.0;
    double right_coef = -1.0;
    double left_dcoef = 1.0;
    double right_dcoef = -1.0;
    double left_ddcoef = 1.0;
    double right_ddcoef = -1.0;
    double left_dddcoef = 1.0;
    double right_dddcoef = -1.0;

    const double x_left = x_knots_[i / 4 + 1] - x_knots_[i / 4];
    const double x_right = 0.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      equality_constraint(i, spline_order_ * i / 4 + j) = left_coef;
      equality_constraint(i, spline_order_ * (i / 4 + 1) + j) = right_coef;

      if (j &gt;= 3) {
        equality_constraint(i + 3, spline_order_ * i / 4 + j) =
            left_dddcoef * j * (j - 1) * (j - 2);
        equality_constraint(i + 3, spline_order_ * (i / 4 + 1) + j) =
            right_dddcoef * j * (j - 1) * (j - 2);
        left_dddcoef = left_ddcoef;
        right_dddcoef = right_ddcoef;
      }

      if (j &gt;= 2) {
        equality_constraint(i + 2, spline_order_ * i / 4 + j) =
            left_ddcoef * j * (j - 1);
        equality_constraint(i + 2, spline_order_ * (i / 4 + 1) + j) =
            right_ddcoef * j * (j - 1);
        left_ddcoef = left_dcoef;
        right_ddcoef = right_dcoef;
      }

      if (j &gt;= 1) {
        equality_constraint(i + 1, spline_order_ * i / 4 + j) = left_dcoef * j;
        equality_constraint(i + 1, spline_order_ * (i / 4 + 1) + j) =
            right_dcoef * j;
        left_dcoef = left_coef;
        right_dcoef = right_coef;
      }

      left_coef *= x_left;
      right_coef *= x_right;
    }
  }
  return equality_constraint_.AddConstraint(equality_constraint,
                                            equality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(441, 0)" endLine="(499, 1)" clone_start="12" clone_end="18">
			<code function_name="Spline1dConstraint::AddThirdDerivativeSmoothConstraint()">bool Spline1dConstraint::AddThirdDerivativeSmoothConstraint() {
  if (x_knots_.size() &lt; 3) {
    return false;
  }

  const std::uint32_t n_constraint = (x_knots_.size() - 2) * 4;
  Eigen::MatrixXd equality_constraint = Eigen::MatrixXd::Zero(
      n_constraint, (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd equality_boundary = Eigen::MatrixXd::Zero(n_constraint, 1);

  for (std::uint32_t i = 0; i &lt; n_constraint; i += 4) {
    double left_coef = 1.0;
    double right_coef = -1.0;
    double left_dcoef = 1.0;
    double right_dcoef = -1.0;
    double left_ddcoef = 1.0;
    double right_ddcoef = -1.0;
    double left_dddcoef = 1.0;
    double right_dddcoef = -1.0;

    const double x_left = x_knots_[i / 4 + 1] - x_knots_[i / 4];
    const double x_right = 0.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      equality_constraint(i, spline_order_ * i / 4 + j) = left_coef;
      equality_constraint(i, spline_order_ * (i / 4 + 1) + j) = right_coef;

      if (j &gt;= 3) {
        equality_constraint(i + 3, spline_order_ * i / 4 + j) =
            left_dddcoef * j * (j - 1) * (j - 2);
        equality_constraint(i + 3, spline_order_ * (i / 4 + 1) + j) =
            right_dddcoef * j * (j - 1) * (j - 2);
        left_dddcoef = left_ddcoef;
        right_dddcoef = right_ddcoef;
      }

      if (j &gt;= 2) {
        equality_constraint(i + 2, spline_order_ * i / 4 + j) =
            left_ddcoef * j * (j - 1);
        equality_constraint(i + 2, spline_order_ * (i / 4 + 1) + j) =
            right_ddcoef * j * (j - 1);
        left_ddcoef = left_dcoef;
        right_ddcoef = right_dcoef;
      }

      if (j &gt;= 1) {
        equality_constraint(i + 1, spline_order_ * i / 4 + j) = left_dcoef * j;
        equality_constraint(i + 1, spline_order_ * (i / 4 + 1) + j) =
            right_dcoef * j;
        left_dcoef = left_coef;
        right_dcoef = right_coef;
      }

      left_coef *= x_left;
      right_coef *= x_right;
    }
  }
  return equality_constraint_.AddConstraint(equality_constraint,
                                            equality_boundary);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(86, 0)" endLine="(90, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6f::vdop(const std::uint8_t *bytes, int32_t length) const">double Gps6f::vdop(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(80, 0)" endLine="(84, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6f::hdop(const std::uint8_t *bytes, int32_t length) const">double Gps6f::hdop(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 5);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(79, 0)" endLine="(84, 1)" clone_start="1" clone_end="6">
			<code function_name="Gps6e::compass_direction(const std::uint8_t *bytes, int32_t length) const">double Gps6e::compass_direction(const std::uint8_t *bytes,
                                int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 4);
  return x * 45.000000;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(92, 0)" endLine="(96, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6f::fix_quality(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6f::fix_quality(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 7);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(86, 0)" endLine="(90, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6f::vdop(const std::uint8_t *bytes, int32_t length) const">double Gps6f::vdop(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(86, 0)" endLine="(90, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6e::pdop(const std::uint8_t *bytes, int32_t length) const">double Gps6e::pdop(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 7);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\planner\em\decider.cc" startLine="(121, 0)" endLine="(144, 1)" clone_start="2" clone_end="10">
			<code function_name="Decider::SetObjectDecisions(const PathDecision&amp; path_decision)">void Decider::SetObjectDecisions(const PathDecision&amp; path_decision) {
  ObjectDecisions* object_decisions =
      decision_result_.mutable_object_decision();

  for (const auto path_obstacle : path_decision.path_obstacles().Items()) {
    auto* object_decision = object_decisions-&gt;add_decision();

    const auto&amp; obstacle = path_obstacle-&gt;obstacle();
    object_decision-&gt;set_id(obstacle-&gt;Id());
    object_decision-&gt;set_perception_id(obstacle-&gt;PerceptionId());
    if (path_obstacle-&gt;IsIgnore()) {
      object_decision-&gt;add_object_decision()-&gt;mutable_ignore();
      continue;
    }
    if (path_obstacle-&gt;HasLateralDecision()) {
      object_decision-&gt;add_object_decision()-&gt;CopyFrom(
          path_obstacle-&gt;LateralDecision());
    }
    if (path_obstacle-&gt;HasLongitudinalDecision()) {
      object_decision-&gt;add_object_decision()-&gt;CopyFrom(
          path_obstacle-&gt;LongitudinalDecision());
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\planner\em\decider.cc" startLine="(146, 0)" endLine="(165, 1)" clone_start="11" clone_end="17">
			<code function_name="Decider::MakeEStopDecision(const PathDecision&amp; path_decision)">void Decider::MakeEStopDecision(const PathDecision&amp; path_decision) {
  decision_result_.Clear();

  MainEmergencyStop* main_estop =
      decision_result_.mutable_main_decision()-&gt;mutable_estop();
  main_estop-&gt;set_reason_code(MainEmergencyStop::ESTOP_REASON_INTERNAL_ERR);
  main_estop-&gt;set_reason("estop reason to be added");
  main_estop-&gt;mutable_cruise_to_stop();

  // set object decisions
  ObjectDecisions* object_decisions =
      decision_result_.mutable_object_decision();
  for (const auto path_obstacle : path_decision.path_obstacles().Items()) {
    auto* object_decision = object_decisions-&gt;add_decision();
    const auto&amp; obstacle = path_obstacle-&gt;obstacle();
    object_decision-&gt;set_id(obstacle-&gt;Id());
    object_decision-&gt;set_perception_id(obstacle-&gt;PerceptionId());
    object_decision-&gt;add_object_decision()-&gt;mutable_avoid();
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\camera\camera_localization.cc" startLine="(36, 0)" endLine="(73, 1)" clone_start="37" clone_end="38">
			<code function_name="CameraLocalization::Start()">Status CameraLocalization::Start() {
  MonitorBuffer buffer(&amp;monitor_);
  if (!common::util::GetProtoFromFile(FLAGS_camera_parameter_config_file,
                                      &amp;camera_parameter_)) {
    buffer.ERROR() &lt;&lt; "Camera parameter is not initialized. Check "
                   &lt;&lt; FLAGS_camera_parameter_config_file;
    buffer.PrintLog();
    return Status(common::LOCALIZATION_ERROR,
                  "failed to load camera parameter");
  }

  AdapterManager::Init(FLAGS_camera_adapter_config_file);
  // start ROS timer, one-shot = false, auto-start = true
  const double duration = 1.0 / FLAGS_localization_publish_freq;
  timer_ = AdapterManager::CreateTimer(ros::Duration(duration),
                                       &amp;CameraLocalization::OnTimer, this);
  if (!AdapterManager::GetGps()) {
    buffer.ERROR() &lt;&lt; "GPS input not initialized. Check "
                   &lt;&lt; FLAGS_camera_adapter_config_file;
    buffer.PrintLog();
    return Status(common::LOCALIZATION_ERROR, "no GPS adapter");
  }
  if (!AdapterManager::GetCamera()) {
    buffer.ERROR() &lt;&lt; "Camera input not initialized. Check "
                   &lt;&lt; FLAGS_camera_adapter_config_file;
    buffer.PrintLog();
    return Status(common::LOCALIZATION_ERROR, "no Camera adapter");
  }
  // IMU is optional
  if (!AdapterManager::GetImu()) {
    buffer.INFO("IMU input not initialized. Check your adapter.conf file!");
    buffer.PrintLog();
    use_imu_ = false;
  } else {
    use_imu_ = true;
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\rtk\rtk_localization.cc" startLine="(37, 0)" endLine="(57, 1)" clone_start="20" clone_end="21">
			<code function_name="RTKLocalization::Start()">Status RTKLocalization::Start() {
  AdapterManager::Init(FLAGS_rtk_adapter_config_file);

  // start ROS timer, one-shot = false, auto-start = true
  const double duration = 1.0 / FLAGS_localization_publish_freq;
  timer_ = AdapterManager::CreateTimer(ros::Duration(duration),
                                       &amp;RTKLocalization::OnTimer, this);
  common::monitor::MonitorBuffer buffer(&amp;monitor_);
  if (!AdapterManager::GetGps()) {
    buffer.ERROR() &lt;&lt; "GPS input not initialized. Check file "
                   &lt;&lt; FLAGS_rtk_adapter_config_file;
    buffer.PrintLog();
    return Status(common::LOCALIZATION_ERROR, "no GPS adapter");
  }
  if (!AdapterManager::GetImu()) {
    buffer.ERROR("IMU input not initialized. Check your adapter.conf file!");
    buffer.PrintLog();
    return Status(common::LOCALIZATION_ERROR, "no IMU adapter");
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\camera\camera_localization.cc" startLine="(75, 0)" endLine="(78, 1)" clone_start="1" clone_end="4">
			<code function_name="CameraLocalization::Stop()">Status CameraLocalization::Stop() {
  timer_.stop();
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\rtk\rtk_localization.cc" startLine="(59, 0)" endLine="(62, 1)" clone_start="1" clone_end="4">
			<code function_name="RTKLocalization::Stop()">Status RTKLocalization::Stop() {
  timer_.stop();
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\camera\camera_localization.cc" startLine="(80, 0)" endLine="(133, 1)" clone_start="1" clone_end="3">
			<code function_name="CameraLocalization::OnTimer(const ros::TimerEvent &amp;event)">void CameraLocalization::OnTimer(const ros::TimerEvent &amp;event) {
  double time_delay =
      common::time::ToSecond(Clock::Now()) - last_received_timestamp_sec_;
  MonitorBuffer buffer(&amp;monitor_);
  if (FLAGS_enable_gps_timestamp &amp;&amp;
      time_delay &gt; FLAGS_gps_time_delay_tolerance) {
    buffer.ERROR() &lt;&lt; "GPS message time delay: " &lt;&lt; time_delay;
    buffer.PrintLog();
  }
  if (FLAGS_enable_camera_timestamp &amp;&amp;
      time_delay &gt; FLAGS_camera_time_delay_tolerance) {
    AERROR &lt;&lt; "Camera message time delay: " &lt;&lt; time_delay;
    buffer.ERROR() &lt;&lt; "Camera message time delay: " &lt;&lt; time_delay;
    buffer.PrintLog();
  }

  // Take a snapshot of the current received messages.
  AdapterManager::Observe();

  if (AdapterManager::GetGps()-&gt;Empty()) {
    AERROR &lt;&lt; "GPS message buffer is empty.";
    if (service_started_) {
      buffer.ERROR("GPS message buffer is empty.");
    }
    return;
  }
  if (AdapterManager::GetCamera()-&gt;Empty()) {
    AERROR &lt;&lt; "Camera message buffer is empty.";
    if (service_started_) {
      buffer.ERROR("Camera message buffer is empty.");
    }
    return;
  }
  if (use_imu_ &amp;&amp; AdapterManager::GetImu()-&gt;Empty()) {
    AERROR &lt;&lt; "Imu message buffer is empty.";
    if (service_started_) {
      buffer.ERROR("Imu message buffer is empty.");
    }
    return;
  }

  // publish localization messages
  if (!PublishLocalization()) {
    buffer.ERROR("Publish localization failed");
    buffer.PrintLog();
    return;
  }
  service_started_ = true;

  // watch dog
  RunWatchDog();

  last_received_timestamp_sec_ = common::time::ToSecond(Clock::Now());
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\rtk\rtk_localization.cc" startLine="(64, 0)" endLine="(100, 1)" clone_start="1" clone_end="3">
			<code function_name="RTKLocalization::OnTimer(const ros::TimerEvent &amp;event)">void RTKLocalization::OnTimer(const ros::TimerEvent &amp;event) {
  double time_delay =
      common::time::ToSecond(Clock::Now()) - last_received_timestamp_sec_;
  common::monitor::MonitorBuffer buffer(&amp;monitor_);
  if (FLAGS_enable_gps_timestamp &amp;&amp;
      time_delay &gt; FLAGS_gps_time_delay_tolerance) {
    buffer.ERROR() &lt;&lt; "GPS message time delay: " &lt;&lt; time_delay;
    buffer.PrintLog();
  }

  // Take a snapshot of the current received messages.
  AdapterManager::Observe();

  if (AdapterManager::GetGps()-&gt;Empty()) {
    AERROR &lt;&lt; "GPS message buffer is empty.";
    if (service_started_) {
      buffer.ERROR("GPS message buffer is empty.");
    }
    return;
  }
  if (AdapterManager::GetImu()-&gt;Empty()) {
    AERROR &lt;&lt; "IMU message buffer is empty.";
    if (service_started_) {
      buffer.ERROR("IMU message buffer is empty.");
    }
    return;
  }

  // publish localization messages
  PublishLocalization();
  service_started_ = true;

  // watch dog
  RunWatchDog();

  last_received_timestamp_sec_ = common::time::ToSecond(Clock::Now());
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\trajectory\discretized_trajectory.cc" startLine="(41, 0)" endLine="(60, 1)" clone_start="8" clone_end="19">
			<code function_name="DiscretizedTrajectory::Evaluate( const double relative_time) const">TrajectoryPoint DiscretizedTrajectory::Evaluate(
    const double relative_time) const {
  CHECK(!trajectory_points_.empty());
  CHECK(trajectory_points_.front().relative_time() &lt;= relative_time &amp;&amp;
        trajectory_points_.back().relative_time() &lt;= relative_time)
      &lt;&lt; "Invalid relative time input!";

  auto comp = [](const TrajectoryPoint&amp; p, const double relative_time) {
    return p.relative_time() &lt; relative_time;
  };

  auto it_lower =
      std::lower_bound(trajectory_points_.begin(), trajectory_points_.end(),
                       relative_time, comp);

  if (it_lower == trajectory_points_.begin()) {
    return trajectory_points_.front();
  }
  return util::interpolate(*(it_lower - 1), *it_lower, relative_time);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\trajectory\discretized_trajectory.cc" startLine="(62, 0)" endLine="(77, 1)" clone_start="3" clone_end="14">
			<code function_name="DiscretizedTrajectory::EvaluateUsingLinearApproximation( const double relative_time) const">TrajectoryPoint DiscretizedTrajectory::EvaluateUsingLinearApproximation(
    const double relative_time) const {
  auto comp = [](const TrajectoryPoint&amp; p, const double relative_time) {
    return p.relative_time() &lt; relative_time;
  };

  auto it_lower =
      std::lower_bound(trajectory_points_.begin(), trajectory_points_.end(),
                       relative_time, comp);

  if (it_lower == trajectory_points_.begin()) {
    return trajectory_points_.front();
  }
  return util::InterpolateUsingLinearApproximation(*(it_lower - 1), *it_lower,
                                                   relative_time);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.h" startLine="(29, 4)" endLine="(29, 50)" clone_start="1" clone_end="1">
			<code function_name="MinBoxObjectBuilder()">    MinBoxObjectBuilder() : BaseObjectBuilder() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\segmentation\cnnseg\cnn_segmentation.h" startLine="(40, 2)" endLine="(40, 43)" clone_start="1" clone_end="1">
			<code function_name="CNNSegmentation()">  CNNSegmentation() : BaseSegmentation() {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.h" startLine="(30, 4)" endLine="(30, 37)" clone_start="1" clone_end="1">
			<code function_name="~MinBoxObjectBuilder()">    virtual ~MinBoxObjectBuilder() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\segmentation\cnnseg\cnn_segmentation.h" startLine="(41, 2)" endLine="(41, 23)" clone_start="1" clone_end="1">
			<code function_name="~CNNSegmentation()">  ~CNNSegmentation() {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\spiral_curve\cubic_spiral_curve.h" startLine="(45, 2)" endLine="(45, 32)" clone_start="1" clone_end="1">
			<code function_name="~CubicSpiralCurve()">  ~CubicSpiralCurve() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\spiral_curve\quintic_spiral_curve.h" startLine="(47, 2)" endLine="(47, 34)" clone_start="1" clone_end="1">
			<code function_name="~QuinticSpiralCurve()">  ~QuinticSpiralCurve() = default;</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.cc" startLine="(107, 0)" endLine="(173, 1)" clone_start="41" clone_end="47">
			<code function_name="LaneInfo::Init()">void LaneInfo::Init() {
  PointsFromCurve(lane_.central_curve(), &amp;points_);
  CHECK_GE(points_.size(), 2);
  segments_.clear();
  accumulated_s_.clear();
  unit_directions_.clear();
  headings_.clear();

  double s = 0;
  for (size_t i = 0; i + 1 &lt; points_.size(); ++i) {
    segments_.emplace_back(points_[i], points_[i + 1]);
    accumulated_s_.push_back(s);
    unit_directions_.push_back(segments_.back().unit_direction());
    s += segments_.back().length();
  }

  accumulated_s_.push_back(s);
  total_length_ = s;
  CHECK(!unit_directions_.empty());
  unit_directions_.push_back(unit_directions_.back());
  for (const auto &amp;direction : unit_directions_) {
    headings_.push_back(direction.Angle());
  }
  for (const auto &amp;overlap_id : lane_.overlap_id()) {
    overlap_ids_.emplace_back(overlap_id.id());
  }
  CHECK(!segments_.empty());

  sampled_left_width_.clear();
  sampled_right_width_.clear();
  for (const auto &amp;sample : lane_.left_sample()) {
    sampled_left_width_.emplace_back(sample.s(), sample.width());
  }
  for (const auto &amp;sample : lane_.right_sample()) {
    sampled_right_width_.emplace_back(sample.s(), sample.width());
  }

  if (lane_.has_type()) {
    if (lane_.type() == Lane::CITY_DRIVING) {
      const double kMinHalfWidth = 1.05;
      for (const auto &amp;p : sampled_left_width_) {
        if (p.second &lt; kMinHalfWidth) {
          AERROR
              &lt;&lt; "lane[id = " &lt;&lt; lane_.id().DebugString()
              &lt;&lt; "]. sampled_left_width_[" &lt;&lt; p.second
              &lt;&lt; "] is too small. It should be larger than half vehicle width["
              &lt;&lt; kMinHalfWidth &lt;&lt; "].";
        }
      }
      for (const auto &amp;p : sampled_right_width_) {
        if (p.second &lt; kMinHalfWidth) {
          AERROR
              &lt;&lt; "lane[id = " &lt;&lt; lane_.id().DebugString()
              &lt;&lt; "]. sampled_right_width_[" &lt;&lt; p.second
              &lt;&lt; "] is too small. It should be larger than half vehicle width["
              &lt;&lt; kMinHalfWidth &lt;&lt; "].";
        }
      }
    } else if (lane_.type() == Lane::NONE) {
      AERROR &lt;&lt; "lane_[id = " &lt;&lt; lane_.id().DebugString() &lt;&lt; " type is NONE.";
    }
  } else {
    AERROR &lt;&lt; "lane_[id = " &lt;&lt; lane_.id().DebugString() &lt;&lt; "has NO type.";
  }

  CreateKDTree();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.cc" startLine="(107, 0)" endLine="(173, 1)" clone_start="50" clone_end="56">
			<code function_name="LaneInfo::Init()">void LaneInfo::Init() {
  PointsFromCurve(lane_.central_curve(), &amp;points_);
  CHECK_GE(points_.size(), 2);
  segments_.clear();
  accumulated_s_.clear();
  unit_directions_.clear();
  headings_.clear();

  double s = 0;
  for (size_t i = 0; i + 1 &lt; points_.size(); ++i) {
    segments_.emplace_back(points_[i], points_[i + 1]);
    accumulated_s_.push_back(s);
    unit_directions_.push_back(segments_.back().unit_direction());
    s += segments_.back().length();
  }

  accumulated_s_.push_back(s);
  total_length_ = s;
  CHECK(!unit_directions_.empty());
  unit_directions_.push_back(unit_directions_.back());
  for (const auto &amp;direction : unit_directions_) {
    headings_.push_back(direction.Angle());
  }
  for (const auto &amp;overlap_id : lane_.overlap_id()) {
    overlap_ids_.emplace_back(overlap_id.id());
  }
  CHECK(!segments_.empty());

  sampled_left_width_.clear();
  sampled_right_width_.clear();
  for (const auto &amp;sample : lane_.left_sample()) {
    sampled_left_width_.emplace_back(sample.s(), sample.width());
  }
  for (const auto &amp;sample : lane_.right_sample()) {
    sampled_right_width_.emplace_back(sample.s(), sample.width());
  }

  if (lane_.has_type()) {
    if (lane_.type() == Lane::CITY_DRIVING) {
      const double kMinHalfWidth = 1.05;
      for (const auto &amp;p : sampled_left_width_) {
        if (p.second &lt; kMinHalfWidth) {
          AERROR
              &lt;&lt; "lane[id = " &lt;&lt; lane_.id().DebugString()
              &lt;&lt; "]. sampled_left_width_[" &lt;&lt; p.second
              &lt;&lt; "] is too small. It should be larger than half vehicle width["
              &lt;&lt; kMinHalfWidth &lt;&lt; "].";
        }
      }
      for (const auto &amp;p : sampled_right_width_) {
        if (p.second &lt; kMinHalfWidth) {
          AERROR
              &lt;&lt; "lane[id = " &lt;&lt; lane_.id().DebugString()
              &lt;&lt; "]. sampled_right_width_[" &lt;&lt; p.second
              &lt;&lt; "] is too small. It should be larger than half vehicle width["
              &lt;&lt; kMinHalfWidth &lt;&lt; "].";
        }
      }
    } else if (lane_.type() == Lane::NONE) {
      AERROR &lt;&lt; "lane_[id = " &lt;&lt; lane_.id().DebugString() &lt;&lt; " type is NONE.";
    }
  } else {
    AERROR &lt;&lt; "lane_[id = " &lt;&lt; lane_.id().DebugString() &lt;&lt; "has NO type.";
  }

  CreateKDTree();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\common\hungarian_bigraph_matcher.cc" startLine="(197, 0)" endLine="(218, 1)" clone_start="3" clone_end="11">
			<code function_name="HungarianOptimizer::find_smallest_uncovered()">double HungarianOptimizer::find_smallest_uncovered() {
  double minval = std::numeric_limits&lt;double&gt;::max();
  uncov_col_.clear();
  uncov_row_.clear();

  for (int i = 0; i &lt; matrix_size_; ++i) {
    if (!row_covered(i)) {
      uncov_row_.push_back(i);
    }
    if (!col_covered(i)) {
      uncov_col_.push_back(i);
    }
  }

  for (size_t row = 0; row &lt; uncov_row_.size(); ++row) {
    for (size_t col = 0; col &lt; uncov_col_.size(); ++col) {
      minval = std::min(minval, costs_[uncov_row_[row]][uncov_col_[col]]);
    }
  }

  return minval;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\common\hungarian_bigraph_matcher.cc" startLine="(222, 0)" endLine="(248, 1)" clone_start="2" clone_end="10">
			<code function_name="HungarianOptimizer::find_zero(int* zero_row, int* zero_col)">bool HungarianOptimizer::find_zero(int* zero_row, int* zero_col) {
  uncov_col_.clear();
  uncov_row_.clear();

  for (int i = 0; i &lt; matrix_size_; ++i) {
    if (!row_covered(i)) {
      uncov_row_.push_back(i);
    }
    if (!col_covered(i)) {
      uncov_col_.push_back(i);
    }
  }
  if (uncov_row_.empty() || uncov_col_.empty()) {
    return false;
  }

  for (size_t i = 0; i &lt; uncov_row_.size(); ++i) {
    for (size_t j = 0; j &lt; uncov_col_.size(); ++j) {
      if (costs_[uncov_row_[i]][uncov_col_[j]] == 0) {
        *zero_row = uncov_row_[i];
        *zero_col = uncov_col_[j];
        return true;
      }
    }
  }
  return false;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\objects_xml_parser.cc" startLine="(26, 0)" endLine="(57, 1)" clone_start="22" clone_end="31">
			<code function_name="ObjectsXmlParser::ParseCrosswalks(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;PbCrosswalk&gt;* crosswalks)">Status ObjectsXmlParser::ParseCrosswalks(const tinyxml2::XMLElement&amp; xml_node,
                                         std::vector&lt;PbCrosswalk&gt;* crosswalks) {
  CHECK_NOTNULL(crosswalks);
  const tinyxml2::XMLElement* sub_node = xml_node.FirstChildElement("object");
  while (sub_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*sub_node, "type", &amp;object_type);
    checker += UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse object type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "crosswalk") {
      PbCrosswalk crosswalk;
      crosswalk.mutable_id()-&gt;set_id(object_id);
      PbPolygon* polygon = crosswalk.mutable_polygon();
      const tinyxml2::XMLElement* outline_node =
          sub_node-&gt;FirstChildElement("outline");
      if (outline_node == nullptr) {
        std::string err_msg = "Error parse crosswalk outline";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseOutline(*outline_node, polygon));
      crosswalks-&gt;emplace_back(crosswalk);
    }
    sub_node = sub_node-&gt;NextSiblingElement("object");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\objects_xml_parser.cc" startLine="(59, 0)" endLine="(94, 1)" clone_start="25" clone_end="35">
			<code function_name="ObjectsXmlParser::ParseClearAreas(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;PbClearArea&gt;* clear_areas)">Status ObjectsXmlParser::ParseClearAreas(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;PbClearArea&gt;* clear_areas) {
  CHECK_NOTNULL(clear_areas);
  const tinyxml2::XMLElement* sub_node = xml_node.FirstChildElement("object");
  while (sub_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
    checker +=
        UtilXmlParser::QueryStringAttribute(*sub_node, "type", &amp;object_type);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse object type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "clearArea") {
      PbClearArea clear_area;
      clear_area.mutable_id()-&gt;set_id(object_id);
      PbPolygon* polygon = clear_area.mutable_polygon();
      CHECK(polygon != nullptr);
      const tinyxml2::XMLElement* outline_node =
          sub_node-&gt;FirstChildElement("outline");
      if (outline_node == nullptr) {
        std::string err_msg = "Error parse cleararea outline";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseOutline(*outline_node, polygon));
      clear_areas-&gt;emplace_back(clear_area);
    }
    sub_node = sub_node-&gt;NextSiblingElement("object");
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\objects_xml_parser.cc" startLine="(136, 0)" endLine="(170, 1)" clone_start="25" clone_end="34">
			<code function_name="ObjectsXmlParser::ParseStopLines(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;StopLineInternal&gt;* stop_lines)">Status ObjectsXmlParser::ParseStopLines(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;StopLineInternal&gt;* stop_lines) {
  CHECK_NOTNULL(stop_lines);
  const tinyxml2::XMLElement* object_node =
      xml_node.FirstChildElement("object");
  while (object_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*object_node, "id", &amp;object_id);
    checker +=
        UtilXmlParser::QueryStringAttribute(*object_node, "type", &amp;object_type);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse object type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "stopline") {
      StopLineInternal stop_line;
      stop_line.id = object_id;
      PbCurveSegment* curve_segment = stop_line.curve.add_segment();
      CHECK(curve_segment != nullptr);
      const auto sub_node = object_node-&gt;FirstChildElement("geometry");
      if (sub_node == nullptr) {
        std::string err_msg = "Error parse stopline geometry";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseGeometry(*sub_node, curve_segment));
      stop_lines-&gt;emplace_back(stop_line);
    }
    object_node = object_node-&gt;NextSiblingElement("object");
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\util_xml_parser.cc" startLine="(87, 0)" endLine="(115, 1)" clone_start="4" clone_end="10">
			<code function_name="UtilXmlParser::ParsePointSet(const tinyxml2::XMLElement&amp; xml_node, PbLineSegment* line_segment)">Status UtilXmlParser::ParsePointSet(const tinyxml2::XMLElement&amp; xml_node,
                                    PbLineSegment* line_segment) {
  const tinyxml2::XMLElement* sub_node = xml_node.FirstChildElement("point");
  while (sub_node) {
    double ptx = 0.0;
    double pty = 0.0;
    double ptz = 0.0;
    int checker = tinyxml2::XML_SUCCESS;
    checker += sub_node-&gt;QueryDoubleAttribute("x", &amp;ptx);
    checker += sub_node-&gt;QueryDoubleAttribute("y", &amp;pty);

    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parsing geometry point attributes";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    PbPoint3D* pt = line_segment-&gt;add_point();
    double output_x = 0.0;
    double output_y = 0.0;
    double output_z = 0.0;
    WGS84ToUTM(ptx, pty, ptz, &amp;output_x, &amp;output_y, &amp;output_z);
    pt-&gt;set_x(output_x);
    pt-&gt;set_y(output_y);

    sub_node = sub_node-&gt;NextSiblingElement("point");
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\util_xml_parser.cc" startLine="(117, 0)" endLine="(148, 1)" clone_start="5" clone_end="11">
			<code function_name="UtilXmlParser::ParseOutline(const tinyxml2::XMLElement&amp; xml_node, PbPolygon* polygon)">Status UtilXmlParser::ParseOutline(const tinyxml2::XMLElement&amp; xml_node,
                                   PbPolygon* polygon) {
  const tinyxml2::XMLElement* sub_node =
      xml_node.FirstChildElement("cornerGlobal");
  while (sub_node) {
    double ptx = 0.0;
    double pty = 0.0;
    double ptz = 0.0;
    int checker = tinyxml2::XML_SUCCESS;
    checker += sub_node-&gt;QueryDoubleAttribute("x", &amp;ptx);
    checker += sub_node-&gt;QueryDoubleAttribute("y", &amp;pty);
    checker += sub_node-&gt;QueryDoubleAttribute("z", &amp;ptz);

    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parsing cornerGlobal point attributes";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    PbPoint3D* pt = polygon-&gt;add_point();
    double output_x = 0.0;
    double output_y = 0.0;
    double output_z = 0.0;
    WGS84ToUTM(ptx, pty, ptz, &amp;output_x, &amp;output_y, &amp;output_z);
    pt-&gt;set_x(output_x);
    pt-&gt;set_y(output_y);
    // pt-&gt;set_z(output_z);

    sub_node = sub_node-&gt;NextSiblingElement("cornerGlobal");
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\junctions_xml_parser.cc" startLine="(29, 0)" endLine="(85, 1)" clone_start="28" clone_end="36">
			<code function_name="JunctionsXmlParser::Parse(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;JunctionInternal&gt;* junctions)">Status JunctionsXmlParser::Parse(const tinyxml2::XMLElement&amp; xml_node,
                                 std::vector&lt;JunctionInternal&gt;* junctions) {
  const tinyxml2::XMLElement* junction_node =
      xml_node.FirstChildElement("junction");
  while (junction_node) {
    // id
    std::string junction_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*junction_node, "id", &amp;junction_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse junction id";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    // outline
    const tinyxml2::XMLElement* sub_node =
        junction_node-&gt;FirstChildElement("outline");
    if (!sub_node) {
      std::string err_msg = "Error parse junction outline";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    PbJunction junction;
    junction.mutable_id()-&gt;set_id(junction_id);
    PbPolygon* polygon = junction.mutable_polygon();
    RETURN_IF_ERROR(UtilXmlParser::ParseOutline(*sub_node, polygon));

    JunctionInternal junction_internal;
    junction_internal.junction = junction;

    // overlap
    sub_node = junction_node-&gt;FirstChildElement("objectOverlapGroup");
    if (sub_node) {
      sub_node = sub_node-&gt;FirstChildElement("objectReference");
      while (sub_node) {
        std::string object_id;
        checker =
            UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
        if (checker != tinyxml2::XML_SUCCESS) {
          std::string err_msg = "Error parse junction overlap id";
          return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
        }

        OverlapWithJunction overlap_with_juntion;
        overlap_with_juntion.object_id = object_id;
        junction_internal.overlap_with_junctions.push_back(
            overlap_with_juntion);

        sub_node = sub_node-&gt;NextSiblingElement("objectReference");
      }
    }

    junctions-&gt;push_back(junction_internal);
    junction_node = junction_node-&gt;NextSiblingElement("junction");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(171, 0)" endLine="(214, 1)" clone_start="23" clone_end="30">
			<code function_name="SignalsXmlParser::ParseStopSigns(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;StopSignInternal&gt;* stop_signs)">Status SignalsXmlParser::ParseStopSigns(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;StopSignInternal&gt;* stop_signs) {
  CHECK_NOTNULL(stop_signs);

  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "stopSign") {
      PbStopSign stop_sign;
      stop_sign.mutable_id()-&gt;set_id(object_id);

      StopSignInternal stop_sign_internal;
      stop_sign_internal.stop_sign = stop_sign;

      auto sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          stop_sign_internal.stop_line_ids.insert(stop_line_id);

          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      stop_signs-&gt;emplace_back(stop_sign_internal);
    }

    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(56, 0)" endLine="(107, 1)" clone_start="32" clone_end="41">
			<code function_name="Spline1dConstraint::AddBoundary(const std::vector&lt;double&gt;&amp; x_coord,const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddBoundary(const std::vector&lt;double&gt;&amp; x_coord,
                                     const std::vector&lt;double&gt;&amp; lower_bound,
                                     const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }
  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);

    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) = coef;
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) = coef;
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }

  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(109, 0)" endLine="(159, 1)" clone_start="32" clone_end="41">
			<code function_name="Spline1dConstraint::AddDerivativeBoundary(const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }

  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);
    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 1; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) = coef * j;
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 1; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) = coef * j;
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }
  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(161, 0)" endLine="(211, 1)" clone_start="32" clone_end="41">
			<code function_name="Spline1dConstraint::AddSecondDerivativeBoundary(    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddSecondDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }

  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);
    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 2; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) = coef * j * (j - 1);
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 2; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) = coef * j * (j - 1);
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }
  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(213, 0)" endLine="(265, 1)" clone_start="33" clone_end="42">
			<code function_name="Spline1dConstraint::AddThirdDerivativeBoundary(    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddThirdDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);
    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 3; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) =
          coef * j * (j - 1) * (j - 2);
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 3; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) =
          coef * j * (j - 1) * (j - 2);
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }
  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\path_decision.cc" startLine="(46, 0)" endLine="(56, 1)" clone_start="1" clone_end="10">
			<code function_name="PathDecision::AddLateralDecision(const std::string &amp;tag,const std::string &amp;object_id, const ObjectDecisionType &amp;decision)">bool PathDecision::AddLateralDecision(const std::string &amp;tag,
                                      const std::string &amp;object_id,
                                      const ObjectDecisionType &amp;decision) {
  auto *path_obstacle = path_obstacles_.Find(object_id);
  if (!path_obstacle) {
    AERROR &lt;&lt; "failed to find obstacle";
    return false;
  }
  path_obstacle-&gt;AddLateralDecision(tag, decision);
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\path_decision.cc" startLine="(58, 0)" endLine="(68, 1)" clone_start="1" clone_end="10">
			<code function_name="PathDecision::AddLongitudinalDecision(const std::string &amp;tag,const std::string &amp;object_id, const ObjectDecisionType &amp;decision)">bool PathDecision::AddLongitudinalDecision(const std::string &amp;tag,
                                           const std::string &amp;object_id,
                                           const ObjectDecisionType &amp;decision) {
  auto *path_obstacle = path_obstacles_.Find(object_id);
  if (!path_obstacle) {
    AERROR &lt;&lt; "failed to find obstacle";
    return false;
  }
  path_obstacle-&gt;AddLongitudinalDecision(tag, decision);
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\core\result_generator.cc" startLine="(202, 0)" endLine="(266, 1)" clone_start="19" clone_end="29">
			<code function_name="ExtendBackward(bool enable_use_road_id,const std::vector&lt;NodeWithRange&gt;&amp; nodes_of_prev_passage, const TopoRangeManager&amp; range_manager, std::vector&lt;NodeWithRange&gt;* const nodes_of_curr_passage)">void ExtendBackward(bool enable_use_road_id,
                    const std::vector&lt;NodeWithRange&gt;&amp; nodes_of_prev_passage,
                    const TopoRangeManager&amp; range_manager,
                    std::vector&lt;NodeWithRange&gt;* const nodes_of_curr_passage) {
  std::unordered_set&lt;const TopoNode*&gt; node_set_of_curr_passage;
  NodeVecToSet(*nodes_of_curr_passage, &amp;node_set_of_curr_passage);
  auto&amp; front_node = nodes_of_curr_passage-&gt;front();
  // if front node starts at middle
  if (!IsCloseEnough(front_node.StartS(), 0.0)) {
    if (!range_manager.Find(front_node.GetTopoNode())) {
      if (IsCloseEnough(nodes_of_prev_passage.front().StartS(), 0.0)) {
        front_node.SetStartS(0.0);
      } else {
        double temp_s = nodes_of_prev_passage.front().StartS() /
                        nodes_of_prev_passage.front().FullLength() *
                        front_node.FullLength();
        front_node.SetStartS(temp_s);
      }
    } else {
      return;
    }
  }

  bool allowed_to_explore = true;
  while (allowed_to_explore) {
    std::vector&lt;NodeWithRange&gt; pred_set;
    for (const auto&amp; edge :
         nodes_of_curr_passage-&gt;front().GetTopoNode()-&gt;InFromPreEdge()) {
      const auto&amp; pred_node = edge-&gt;FromNode();
      // if pred node is not in the same road
      if (pred_node-&gt;RoadId() != nodes_of_curr_passage-&gt;front().RoadId()) {
        continue;
      }
      // if pred node has been inserted
      if (enable_use_road_id &amp;&amp;
          node_set_of_curr_passage.find(pred_node) !=
              node_set_of_curr_passage.end()) {
        continue;
      }
      // if pred node is reachable from prev passage
      const NodeWithRange* reachable_node = nullptr;
      if (IsReachableTo(pred_node, nodes_of_prev_passage, &amp;reachable_node)) {
        if (range_manager.Find(pred_node)) {
          double black_s_end = range_manager.RangeEnd(pred_node);
          if (!IsCloseEnough(black_s_end, pred_node-&gt;Length())) {
            pred_set.push_back(
                BuildNodeRange(pred_node, black_s_end, pred_node-&gt;Length()));
          }
        } else {
          pred_set.push_back(
              BuildNodeRange(pred_node, 0.0, pred_node-&gt;Length()));
        }
      }
    }
    if (pred_set.empty()) {
      allowed_to_explore = false;
    } else {
      allowed_to_explore = true;
      const auto&amp; node_to_insert = GetLargestRange(pred_set);
      nodes_of_curr_passage-&gt;insert(nodes_of_curr_passage-&gt;begin(),
                                    node_to_insert);
      node_set_of_curr_passage.emplace(node_to_insert.GetTopoNode());
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\core\result_generator.cc" startLine="(268, 0)" endLine="(338, 1)" clone_start="19" clone_end="29">
			<code function_name="ExtendForward(bool enable_use_road_id,const std::vector&lt;NodeWithRange&gt;&amp; nodes_of_next_passage, const TopoRangeManager&amp; range_manager, std::vector&lt;NodeWithRange&gt;* const nodes_of_curr_passage)">void ExtendForward(bool enable_use_road_id,
                   const std::vector&lt;NodeWithRange&gt;&amp; nodes_of_next_passage,
                   const TopoRangeManager&amp; range_manager,
                   std::vector&lt;NodeWithRange&gt;* const nodes_of_curr_passage) {
  std::unordered_set&lt;const TopoNode*&gt; node_set_of_curr_passage;
  NodeVecToSet(*nodes_of_curr_passage, &amp;node_set_of_curr_passage);
  auto&amp; back_node = nodes_of_curr_passage-&gt;back();
  if (!IsCloseEnough(back_node.EndS(), back_node.FullLength())) {
    if (!range_manager.Find(back_node.GetTopoNode())) {
      if (IsCloseEnough(nodes_of_next_passage.back().EndS(),
                        nodes_of_next_passage.back().FullLength())) {
        back_node.SetEndS(back_node.FullLength());
      } else {
        double temp_s = nodes_of_next_passage.back().EndS() /
                        nodes_of_next_passage.back().FullLength() *
                        back_node.FullLength();
        back_node.SetEndS(std::min(temp_s, back_node.FullLength()));
      }
    } else {
      return;
    }
  }

  bool allowed_to_explore = true;
  while (allowed_to_explore) {
    std::vector&lt;NodeWithRange&gt; succ_set;
    for (const auto&amp; edge :
         nodes_of_curr_passage-&gt;back().GetTopoNode()-&gt;OutToSucEdge()) {
      const auto&amp; succ_node = edge-&gt;ToNode();
      // if succ node is not in the same road
      if (enable_use_road_id &amp;&amp;
          succ_node-&gt;RoadId() != nodes_of_curr_passage-&gt;back().RoadId()) {
        continue;
      }
      // if succ node has been inserted
      if (node_set_of_curr_passage.find(succ_node) !=
          node_set_of_curr_passage.end()) {
        continue;
      }
      // if next passage is reachable from succ node
      const NodeWithRange* reachable_node = nullptr;
      if (IsReachableFrom(succ_node, nodes_of_next_passage, &amp;reachable_node)) {
        if (range_manager.Find(succ_node)) {
          double black_s_start = range_manager.RangeStart(succ_node);
          if (!IsCloseEnough(black_s_start, 0.0)) {
            succ_set.push_back(BuildNodeRange(succ_node, 0.0, black_s_start));
          }
        } else {
          if (IsCloseEnough(reachable_node-&gt;EndS(),
                            reachable_node-&gt;FullLength())) {
            succ_set.push_back(
                BuildNodeRange(succ_node, 0.0, succ_node-&gt;Length()));
          } else {
            double push_end_s = reachable_node-&gt;EndS() /
                                reachable_node-&gt;FullLength() *
                                succ_node-&gt;Length();
            succ_set.push_back(BuildNodeRange(succ_node, 0.0, push_end_s));
          }
        }
      }
    }
    if (succ_set.empty()) {
      allowed_to_explore = false;
    } else {
      allowed_to_explore = true;
      const auto&amp; node_to_insert = GetLargestRange(succ_set);
      nodes_of_curr_passage-&gt;push_back(node_to_insert);
      node_set_of_curr_passage.emplace(node_to_insert.GetTopoNode());
    }
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\line_segment2d.cc" startLine="(58, 0)" endLine="(72, 1)" clone_start="1" clone_end="8">
			<code function_name="LineSegment2d::DistanceTo(const Vec2d &amp;point) const">double LineSegment2d::DistanceTo(const Vec2d &amp;point) const {
  if (length_ &lt;= kMathEpsilon) {
    return point.DistanceTo(start_);
  }
  const double x0 = point.x() - start_.x();
  const double y0 = point.y() - start_.y();
  const double proj = x0 * unit_direction_.x() + y0 * unit_direction_.y();
  if (proj &lt;= 0.0) {
    return hypot(x0, y0);
  }
  if (proj &gt;= length_) {
    return point.DistanceTo(end_);
  }
  return std::abs(x0 * unit_direction_.y() - y0 * unit_direction_.x());
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\line_segment2d.cc" startLine="(96, 0)" endLine="(110, 1)" clone_start="1" clone_end="8">
			<code function_name="LineSegment2d::DistanceSquareTo(const Vec2d &amp;point) const">double LineSegment2d::DistanceSquareTo(const Vec2d &amp;point) const {
  if (length_ &lt;= kMathEpsilon) {
    return point.DistanceSquareTo(start_);
  }
  const double x0 = point.x() - start_.x();
  const double y0 = point.y() - start_.y();
  const double proj = x0 * unit_direction_.x() + y0 * unit_direction_.y();
  if (proj &lt;= 0.0) {
    return Square(x0) + Square(y0);
  }
  if (proj &gt;= length_) {
    return point.DistanceSquareTo(end_);
  }
  return Square(x0 * unit_direction_.y() - y0 * unit_direction_.x());
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(392, 0)" endLine="(439, 1)" clone_start="37" clone_end="46">
			<code function_name="Spline1dConstraint::AddSecondDerivativeSmoothConstraint()">bool Spline1dConstraint::AddSecondDerivativeSmoothConstraint() {
  if (x_knots_.size() &lt; 3) {
    return false;
  }

  const std::uint32_t n_constraint = (x_knots_.size() - 2) * 3;
  Eigen::MatrixXd equality_constraint = Eigen::MatrixXd::Zero(
      n_constraint, (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd equality_boundary = Eigen::MatrixXd::Zero(n_constraint, 1);

  for (std::uint32_t i = 0; i &lt; n_constraint; i += 3) {
    double left_coef = 1.0;
    double right_coef = -1.0;
    double left_dcoef = 1.0;
    double right_dcoef = -1.0;
    double left_ddcoef = 1.0;
    double right_ddcoef = -1.0;

    const double x_left = x_knots_[i / 3 + 1] - x_knots_[i / 3];
    const double x_right = 0.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      equality_constraint(i, spline_order_ * (i / 3) + j) = left_coef;
      equality_constraint(i, spline_order_ * (i / 3 + 1) + j) = right_coef;

      if (j &gt;= 2) {
        equality_constraint(i + 2, spline_order_ * i / 3 + j) =
            left_ddcoef * j * (j - 1);
        equality_constraint(i + 2, spline_order_ * (i / 3 + 1) + j) =
            right_ddcoef * j * (j - 1);
        left_ddcoef = left_dcoef;
        right_ddcoef = right_dcoef;
      }

      if (j &gt;= 1) {
        equality_constraint(i + 1, spline_order_ * (i / 3) + j) =
            left_dcoef * j;
        equality_constraint(i + 1, spline_order_ * (i / 3 + 1) + j) =
            right_dcoef * j;
        left_dcoef = left_coef;
        right_dcoef = right_coef;
      }
      left_coef *= x_left;
      right_coef *= x_right;
    }
  }
  return equality_constraint_.AddConstraint(equality_constraint,
                                            equality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(441, 0)" endLine="(499, 1)" clone_start="47" clone_end="57">
			<code function_name="Spline1dConstraint::AddThirdDerivativeSmoothConstraint()">bool Spline1dConstraint::AddThirdDerivativeSmoothConstraint() {
  if (x_knots_.size() &lt; 3) {
    return false;
  }

  const std::uint32_t n_constraint = (x_knots_.size() - 2) * 4;
  Eigen::MatrixXd equality_constraint = Eigen::MatrixXd::Zero(
      n_constraint, (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd equality_boundary = Eigen::MatrixXd::Zero(n_constraint, 1);

  for (std::uint32_t i = 0; i &lt; n_constraint; i += 4) {
    double left_coef = 1.0;
    double right_coef = -1.0;
    double left_dcoef = 1.0;
    double right_dcoef = -1.0;
    double left_ddcoef = 1.0;
    double right_ddcoef = -1.0;
    double left_dddcoef = 1.0;
    double right_dddcoef = -1.0;

    const double x_left = x_knots_[i / 4 + 1] - x_knots_[i / 4];
    const double x_right = 0.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      equality_constraint(i, spline_order_ * i / 4 + j) = left_coef;
      equality_constraint(i, spline_order_ * (i / 4 + 1) + j) = right_coef;

      if (j &gt;= 3) {
        equality_constraint(i + 3, spline_order_ * i / 4 + j) =
            left_dddcoef * j * (j - 1) * (j - 2);
        equality_constraint(i + 3, spline_order_ * (i / 4 + 1) + j) =
            right_dddcoef * j * (j - 1) * (j - 2);
        left_dddcoef = left_ddcoef;
        right_dddcoef = right_ddcoef;
      }

      if (j &gt;= 2) {
        equality_constraint(i + 2, spline_order_ * i / 4 + j) =
            left_ddcoef * j * (j - 1);
        equality_constraint(i + 2, spline_order_ * (i / 4 + 1) + j) =
            right_ddcoef * j * (j - 1);
        left_ddcoef = left_dcoef;
        right_ddcoef = right_dcoef;
      }

      if (j &gt;= 1) {
        equality_constraint(i + 1, spline_order_ * i / 4 + j) = left_dcoef * j;
        equality_constraint(i + 1, spline_order_ * (i / 4 + 1) + j) =
            right_dcoef * j;
        left_dcoef = left_coef;
        right_dcoef = right_coef;
      }

      left_coef *= x_left;
      right_coef *= x_right;
    }
  }
  return equality_constraint_.AddConstraint(equality_constraint,
                                            equality_boundary);
}</code>
		</source>
	</dup>
	<dup count="5">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(470, 0)" endLine="(509, 1)" clone_start="34" clone_end="40">
			<code function_name="LanesXmlParser::ParseJunctionOverlapGroup(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;OverlapWithLane&gt;* junction_overlaps)">Status LanesXmlParser::ParseJunctionOverlapGroup(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;OverlapWithLane&gt;* junction_overlaps) {
  CHECK_NOTNULL(junction_overlaps);

  auto overlap_group = xml_node.FirstChildElement("junctionOverlapGroup");
  if (overlap_group) {
    auto sub_node = overlap_group-&gt;FirstChildElement("junctionReference");
    while (sub_node) {
      std::string object_id;
      double start_s = 0.0;
      double end_s = 0.0;
      int checker =
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
      checker += sub_node-&gt;QueryDoubleAttribute("startOffset", &amp;start_s);
      checker += sub_node-&gt;QueryDoubleAttribute("endOffset", &amp;end_s);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse lane junction overlap";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      bool is_merge = false;
      checker = sub_node-&gt;QueryBoolAttribute("isMerge", &amp;is_merge);
      if (checker != tinyxml2::XML_SUCCESS) {
        is_merge = false;
      }

      OverlapWithLane overlap_with_lane;
      overlap_with_lane.object_id = object_id;
      overlap_with_lane.start_s = start_s;
      overlap_with_lane.end_s = end_s;
      overlap_with_lane.is_merge = is_merge;

      junction_overlaps-&gt;push_back(overlap_with_lane);

      sub_node = sub_node-&gt;NextSiblingElement("junctionReference");
    }
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(429, 0)" endLine="(468, 1)" clone_start="34" clone_end="40">
			<code function_name="LanesXmlParser::ParseSignalOverlapGroup(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;OverlapWithLane&gt;* signal_overlaps)">Status LanesXmlParser::ParseSignalOverlapGroup(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;OverlapWithLane&gt;* signal_overlaps) {
  CHECK_NOTNULL(signal_overlaps);

  auto signal_overlap = xml_node.FirstChildElement("signalOverlapGroup");
  if (signal_overlap) {
    auto sub_node = signal_overlap-&gt;FirstChildElement("signalReference");
    while (sub_node) {
      std::string object_id;
      double start_s = 0.0;
      double end_s = 0.0;
      int checker =
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
      checker += sub_node-&gt;QueryDoubleAttribute("startOffset", &amp;start_s);
      checker += sub_node-&gt;QueryDoubleAttribute("endOffset", &amp;end_s);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse lane signal overlap";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      bool is_merge = false;
      checker = sub_node-&gt;QueryBoolAttribute("isMerge", &amp;is_merge);
      if (checker != tinyxml2::XML_SUCCESS) {
        is_merge = false;
      }

      OverlapWithLane overlap_with_lane;
      overlap_with_lane.object_id = object_id;
      overlap_with_lane.start_s = start_s;
      overlap_with_lane.end_s = end_s;
      overlap_with_lane.is_merge = is_merge;

      signal_overlaps-&gt;push_back(overlap_with_lane);

      sub_node = sub_node-&gt;NextSiblingElement("signalReference");
    }
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(389, 0)" endLine="(427, 1)" clone_start="33" clone_end="39">
			<code function_name="LanesXmlParser::ParseObjectOverlapGroup(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;OverlapWithLane&gt;* object_overlaps)">Status LanesXmlParser::ParseObjectOverlapGroup(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;OverlapWithLane&gt;* object_overlaps) {
  CHECK_NOTNULL(object_overlaps);

  auto object_overlap = xml_node.FirstChildElement("objectOverlapGroup");
  if (object_overlap) {
    auto sub_node = object_overlap-&gt;FirstChildElement("objectReference");
    while (sub_node) {
      std::string object_id;
      double start_s = 0.0;
      double end_s = 0.0;
      int checker =
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
      checker += sub_node-&gt;QueryDoubleAttribute("startOffset", &amp;start_s);
      checker += sub_node-&gt;QueryDoubleAttribute("endOffset", &amp;end_s);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse lane object overlap";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      bool is_merge = false;
      checker = sub_node-&gt;QueryBoolAttribute("isMerge", &amp;is_merge);
      if (checker != tinyxml2::XML_SUCCESS) {
        is_merge = false;
      }

      OverlapWithLane overlap_with_lane;
      overlap_with_lane.object_id = object_id;
      overlap_with_lane.start_s = start_s;
      overlap_with_lane.end_s = end_s;
      overlap_with_lane.is_merge = is_merge;
      object_overlaps-&gt;push_back(overlap_with_lane);

      sub_node = sub_node-&gt;NextSiblingElement("objectReference");
    }
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(349, 0)" endLine="(387, 1)" clone_start="33" clone_end="39">
			<code function_name="LanesXmlParser::ParseSampleAssociates( const tinyxml2::XMLElement&amp; xml_node, PbLane* lane)">Status LanesXmlParser::ParseSampleAssociates(
    const tinyxml2::XMLElement&amp; xml_node, PbLane* lane) {
  CHECK_NOTNULL(lane);
  auto sub_node = xml_node.FirstChildElement("sampleAssociates");
  if (sub_node == nullptr) {
    std::string err_msg = "Error parse sample associates";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  sub_node = sub_node-&gt;FirstChildElement("sampleAssociate");
  if (sub_node == nullptr) {
    std::string err_msg = "Error parse sample associate";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  while (sub_node) {
    double left_width = 0.0;
    double right_width = 0.0;
    double s = 0.0;
    int checker = sub_node-&gt;QueryDoubleAttribute("sOffset", &amp;s);
    checker += sub_node-&gt;QueryDoubleAttribute("leftWidth", &amp;left_width);
    checker += sub_node-&gt;QueryDoubleAttribute("rightWidth", &amp;right_width);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse lane sample associate attribute";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    auto left_sample = lane-&gt;add_left_sample();
    left_sample-&gt;set_s(s);
    left_sample-&gt;set_width(left_width);

    auto right_sample = lane-&gt;add_right_sample();
    right_sample-&gt;set_s(s);
    right_sample-&gt;set_width(right_width);

    sub_node = sub_node-&gt;NextSiblingElement("sampleAssociate");
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(171, 0)" endLine="(214, 1)" clone_start="38" clone_end="44">
			<code function_name="SignalsXmlParser::ParseStopSigns(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;StopSignInternal&gt;* stop_signs)">Status SignalsXmlParser::ParseStopSigns(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;StopSignInternal&gt;* stop_signs) {
  CHECK_NOTNULL(stop_signs);

  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "stopSign") {
      PbStopSign stop_sign;
      stop_sign.mutable_id()-&gt;set_id(object_id);

      StopSignInternal stop_sign_internal;
      stop_sign_internal.stop_sign = stop_sign;

      auto sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          stop_sign_internal.stop_line_ids.insert(stop_line_id);

          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      stop_signs-&gt;emplace_back(stop_sign_internal);
    }

    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="5">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(511, 0)" endLine="(551, 1)" clone_start="1" clone_end="7">
			<code function_name="LanesXmlParser::ParseLaneOverlapGroup(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;OverlapWithLane&gt;* lane_overlaps)">Status LanesXmlParser::ParseLaneOverlapGroup(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;OverlapWithLane&gt;* lane_overlaps) {
  CHECK_NOTNULL(lane_overlaps);

  auto overlap_node = xml_node.FirstChildElement("laneOverlapGroup");
  if (overlap_node) {
    auto sub_node = overlap_node-&gt;FirstChildElement("laneReference");
    while (sub_node) {
      std::string lane_id;
      double start_s = 0.0;
      double end_s = 0.0;
      int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                   &amp;lane_id);
      checker += sub_node-&gt;QueryDoubleAttribute("startOffset", &amp;start_s);
      checker += sub_node-&gt;QueryDoubleAttribute("endOffset", &amp;end_s);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse lane lane overlap";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      bool is_merge = false;
      checker = sub_node-&gt;QueryBoolAttribute("isMerge", &amp;is_merge);
      if (checker != tinyxml2::XML_SUCCESS) {
        is_merge = false;
      }

      OverlapWithLane overlap_with_lane;
      overlap_with_lane.object_id = lane_id;
      overlap_with_lane.start_s = start_s;
      overlap_with_lane.end_s = end_s;
      overlap_with_lane.is_merge = is_merge;

      lane_overlaps-&gt;push_back(overlap_with_lane);

      sub_node = sub_node-&gt;NextSiblingElement("laneReference");
    }
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(470, 0)" endLine="(509, 1)" clone_start="1" clone_end="7">
			<code function_name="LanesXmlParser::ParseJunctionOverlapGroup(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;OverlapWithLane&gt;* junction_overlaps)">Status LanesXmlParser::ParseJunctionOverlapGroup(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;OverlapWithLane&gt;* junction_overlaps) {
  CHECK_NOTNULL(junction_overlaps);

  auto overlap_group = xml_node.FirstChildElement("junctionOverlapGroup");
  if (overlap_group) {
    auto sub_node = overlap_group-&gt;FirstChildElement("junctionReference");
    while (sub_node) {
      std::string object_id;
      double start_s = 0.0;
      double end_s = 0.0;
      int checker =
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
      checker += sub_node-&gt;QueryDoubleAttribute("startOffset", &amp;start_s);
      checker += sub_node-&gt;QueryDoubleAttribute("endOffset", &amp;end_s);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse lane junction overlap";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      bool is_merge = false;
      checker = sub_node-&gt;QueryBoolAttribute("isMerge", &amp;is_merge);
      if (checker != tinyxml2::XML_SUCCESS) {
        is_merge = false;
      }

      OverlapWithLane overlap_with_lane;
      overlap_with_lane.object_id = object_id;
      overlap_with_lane.start_s = start_s;
      overlap_with_lane.end_s = end_s;
      overlap_with_lane.is_merge = is_merge;

      junction_overlaps-&gt;push_back(overlap_with_lane);

      sub_node = sub_node-&gt;NextSiblingElement("junctionReference");
    }
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(429, 0)" endLine="(468, 1)" clone_start="1" clone_end="7">
			<code function_name="LanesXmlParser::ParseSignalOverlapGroup(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;OverlapWithLane&gt;* signal_overlaps)">Status LanesXmlParser::ParseSignalOverlapGroup(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;OverlapWithLane&gt;* signal_overlaps) {
  CHECK_NOTNULL(signal_overlaps);

  auto signal_overlap = xml_node.FirstChildElement("signalOverlapGroup");
  if (signal_overlap) {
    auto sub_node = signal_overlap-&gt;FirstChildElement("signalReference");
    while (sub_node) {
      std::string object_id;
      double start_s = 0.0;
      double end_s = 0.0;
      int checker =
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
      checker += sub_node-&gt;QueryDoubleAttribute("startOffset", &amp;start_s);
      checker += sub_node-&gt;QueryDoubleAttribute("endOffset", &amp;end_s);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse lane signal overlap";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      bool is_merge = false;
      checker = sub_node-&gt;QueryBoolAttribute("isMerge", &amp;is_merge);
      if (checker != tinyxml2::XML_SUCCESS) {
        is_merge = false;
      }

      OverlapWithLane overlap_with_lane;
      overlap_with_lane.object_id = object_id;
      overlap_with_lane.start_s = start_s;
      overlap_with_lane.end_s = end_s;
      overlap_with_lane.is_merge = is_merge;

      signal_overlaps-&gt;push_back(overlap_with_lane);

      sub_node = sub_node-&gt;NextSiblingElement("signalReference");
    }
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(389, 0)" endLine="(427, 1)" clone_start="1" clone_end="7">
			<code function_name="LanesXmlParser::ParseObjectOverlapGroup(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;OverlapWithLane&gt;* object_overlaps)">Status LanesXmlParser::ParseObjectOverlapGroup(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;OverlapWithLane&gt;* object_overlaps) {
  CHECK_NOTNULL(object_overlaps);

  auto object_overlap = xml_node.FirstChildElement("objectOverlapGroup");
  if (object_overlap) {
    auto sub_node = object_overlap-&gt;FirstChildElement("objectReference");
    while (sub_node) {
      std::string object_id;
      double start_s = 0.0;
      double end_s = 0.0;
      int checker =
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
      checker += sub_node-&gt;QueryDoubleAttribute("startOffset", &amp;start_s);
      checker += sub_node-&gt;QueryDoubleAttribute("endOffset", &amp;end_s);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse lane object overlap";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      bool is_merge = false;
      checker = sub_node-&gt;QueryBoolAttribute("isMerge", &amp;is_merge);
      if (checker != tinyxml2::XML_SUCCESS) {
        is_merge = false;
      }

      OverlapWithLane overlap_with_lane;
      overlap_with_lane.object_id = object_id;
      overlap_with_lane.start_s = start_s;
      overlap_with_lane.end_s = end_s;
      overlap_with_lane.is_merge = is_merge;
      object_overlaps-&gt;push_back(overlap_with_lane);

      sub_node = sub_node-&gt;NextSiblingElement("objectReference");
    }
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(216, 0)" endLine="(259, 1)" clone_start="1" clone_end="7">
			<code function_name="SignalsXmlParser::ParseYieldSigns(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;YieldSignInternal&gt;* yield_signs)">Status SignalsXmlParser::ParseYieldSigns(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;YieldSignInternal&gt;* yield_signs) {
  CHECK_NOTNULL(yield_signs);

  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "yieldSign") {
      PbYieldSign yield_sign;
      yield_sign.mutable_id()-&gt;set_id(object_id);
      YieldSignInternal yield_sign_internal;
      yield_sign_internal.id = object_id;
      yield_sign_internal.yield_sign = yield_sign;
      auto sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                            &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          yield_sign_internal.stop_line_ids.insert(stop_line_id);

          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      yield_signs-&gt;emplace_back(yield_sign_internal);
    }

    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(26, 0)" endLine="(34, 1)" clone_start="2" clone_end="8">
			<code function_name="Spline2dSeg::Spline2dSeg(const std::uint32_t order)">Spline2dSeg::Spline2dSeg(const std::uint32_t order)
    : spline_func_x_(order), spline_func_y_(order) {
  derivative_x_.DerivedFrom(spline_func_x_);
  derivative_y_.DerivedFrom(spline_func_y_);
  second_derivative_x_.DerivedFrom(derivative_x_);
  second_derivative_y_.DerivedFrom(derivative_y_);
  third_derivative_x_.DerivedFrom(second_derivative_x_);
  third_derivative_y_.DerivedFrom(second_derivative_y_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(36, 0)" endLine="(45, 1)" clone_start="3" clone_end="9">
			<code function_name="Spline2dSeg::Spline2dSeg(const std::vector&lt;double&gt;&amp; x_param, const std::vector&lt;double&gt;&amp; y_param)">Spline2dSeg::Spline2dSeg(const std::vector&lt;double&gt;&amp; x_param,
                         const std::vector&lt;double&gt;&amp; y_param)
    : spline_func_x_(x_param), spline_func_y_(y_param) {
  derivative_x_.DerivedFrom(spline_func_x_);
  derivative_y_.DerivedFrom(spline_func_y_);
  second_derivative_x_.DerivedFrom(derivative_x_);
  second_derivative_y_.DerivedFrom(derivative_y_);
  third_derivative_x_.DerivedFrom(second_derivative_x_);
  third_derivative_y_.DerivedFrom(second_derivative_y_);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(690, 0)" endLine="(732, 1)" clone_start="20" clone_end="26">
			<code function_name="LanesXmlParser::ToPbLaneMarkType(const std::string&amp; type,const std::string&amp; color, PbLaneBoundaryTypeType* boundary_type)">Status LanesXmlParser::ToPbLaneMarkType(const std::string&amp; type,
                                        const std::string&amp; color,
                                        PbLaneBoundaryTypeType* boundary_type) {
  CHECK_NOTNULL(boundary_type);

  std::string upper_type = UtilXmlParser::ToUpper(type);
  std::string upper_color = UtilXmlParser::ToUpper(color);

  if (upper_type == "CURB") {
    *boundary_type = hdmap::LaneBoundaryType::CURB;
    return Status::OK();
  }

  if (upper_type == "NONE") {
    *boundary_type = hdmap::LaneBoundaryType::UNKNOWN;
    return Status::OK();
  }

  if (upper_color == "YELLOW") {
    if (upper_type == "SOLID") {
      *boundary_type = hdmap::LaneBoundaryType::SOLID_YELLOW;
    } else if (upper_type == "BROKEN") {
      *boundary_type = hdmap::LaneBoundaryType::DOTTED_YELLOW;
    } else {
      std::string err_msg = "Error or unsupport lane boundary type";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }
  } else if (upper_color == "WHITE") {
    if (upper_type == "SOLID") {
      *boundary_type = hdmap::LaneBoundaryType::SOLID_WHITE;
    } else if (upper_type == "BROKEN") {
      *boundary_type = hdmap::LaneBoundaryType::DOTTED_WHITE;
    } else {
      std::string err_msg = "Error or unsupport lane boundary type";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }
  } else {
    std::string err_msg = "Error or unsupport lane boundary color.";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(690, 0)" endLine="(732, 1)" clone_start="29" clone_end="35">
			<code function_name="LanesXmlParser::ToPbLaneMarkType(const std::string&amp; type,const std::string&amp; color, PbLaneBoundaryTypeType* boundary_type)">Status LanesXmlParser::ToPbLaneMarkType(const std::string&amp; type,
                                        const std::string&amp; color,
                                        PbLaneBoundaryTypeType* boundary_type) {
  CHECK_NOTNULL(boundary_type);

  std::string upper_type = UtilXmlParser::ToUpper(type);
  std::string upper_color = UtilXmlParser::ToUpper(color);

  if (upper_type == "CURB") {
    *boundary_type = hdmap::LaneBoundaryType::CURB;
    return Status::OK();
  }

  if (upper_type == "NONE") {
    *boundary_type = hdmap::LaneBoundaryType::UNKNOWN;
    return Status::OK();
  }

  if (upper_color == "YELLOW") {
    if (upper_type == "SOLID") {
      *boundary_type = hdmap::LaneBoundaryType::SOLID_YELLOW;
    } else if (upper_type == "BROKEN") {
      *boundary_type = hdmap::LaneBoundaryType::DOTTED_YELLOW;
    } else {
      std::string err_msg = "Error or unsupport lane boundary type";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }
  } else if (upper_color == "WHITE") {
    if (upper_type == "SOLID") {
      *boundary_type = hdmap::LaneBoundaryType::SOLID_WHITE;
    } else if (upper_type == "BROKEN") {
      *boundary_type = hdmap::LaneBoundaryType::DOTTED_WHITE;
    } else {
      std::string err_msg = "Error or unsupport lane boundary type";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }
  } else {
    std::string err_msg = "Error or unsupport lane boundary color.";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\objects_xml_parser.cc" startLine="(26, 0)" endLine="(57, 1)" clone_start="11" clone_end="19">
			<code function_name="ObjectsXmlParser::ParseCrosswalks(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;PbCrosswalk&gt;* crosswalks)">Status ObjectsXmlParser::ParseCrosswalks(const tinyxml2::XMLElement&amp; xml_node,
                                         std::vector&lt;PbCrosswalk&gt;* crosswalks) {
  CHECK_NOTNULL(crosswalks);
  const tinyxml2::XMLElement* sub_node = xml_node.FirstChildElement("object");
  while (sub_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*sub_node, "type", &amp;object_type);
    checker += UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse object type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "crosswalk") {
      PbCrosswalk crosswalk;
      crosswalk.mutable_id()-&gt;set_id(object_id);
      PbPolygon* polygon = crosswalk.mutable_polygon();
      const tinyxml2::XMLElement* outline_node =
          sub_node-&gt;FirstChildElement("outline");
      if (outline_node == nullptr) {
        std::string err_msg = "Error parse crosswalk outline";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseOutline(*outline_node, polygon));
      crosswalks-&gt;emplace_back(crosswalk);
    }
    sub_node = sub_node-&gt;NextSiblingElement("object");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\objects_xml_parser.cc" startLine="(59, 0)" endLine="(94, 1)" clone_start="13" clone_end="21">
			<code function_name="ObjectsXmlParser::ParseClearAreas(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;PbClearArea&gt;* clear_areas)">Status ObjectsXmlParser::ParseClearAreas(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;PbClearArea&gt;* clear_areas) {
  CHECK_NOTNULL(clear_areas);
  const tinyxml2::XMLElement* sub_node = xml_node.FirstChildElement("object");
  while (sub_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
    checker +=
        UtilXmlParser::QueryStringAttribute(*sub_node, "type", &amp;object_type);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse object type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "clearArea") {
      PbClearArea clear_area;
      clear_area.mutable_id()-&gt;set_id(object_id);
      PbPolygon* polygon = clear_area.mutable_polygon();
      CHECK(polygon != nullptr);
      const tinyxml2::XMLElement* outline_node =
          sub_node-&gt;FirstChildElement("outline");
      if (outline_node == nullptr) {
        std::string err_msg = "Error parse cleararea outline";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseOutline(*outline_node, polygon));
      clear_areas-&gt;emplace_back(clear_area);
    }
    sub_node = sub_node-&gt;NextSiblingElement("object");
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(155, 0)" endLine="(157, 1)" clone_start="2" clone_end="3">
			<code function_name="ActiveSetQpSolver::set_l_lower_bound(const double l_lower_bound)">void ActiveSetQpSolver::set_l_lower_bound(const double l_lower_bound) {
  l_lower_bound_ = l_lower_bound;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(151, 0)" endLine="(153, 1)" clone_start="2" clone_end="3">
			<code function_name="ActiveSetQpSolver::set_debug_info(const bool enable)">void ActiveSetQpSolver::set_debug_info(const bool enable) {
  debug_info_ = enable;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(147, 0)" endLine="(149, 1)" clone_start="2" clone_end="3">
			<code function_name="ActiveSetQpSolver::set_qp_eps_iter_ref(const double eps)">void ActiveSetQpSolver::set_qp_eps_iter_ref(const double eps) {
  qp_eps_iter_ref_ = eps;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\dp_st_speed\st_graph_point.cc" startLine="(41, 0)" endLine="(46, 1)" clone_start="5" clone_end="6">
			<code function_name="StGraphPoint::Init(const std::uint32_t index_t, const std::uint32_t index_s, const STPoint&amp; st_point)">void StGraphPoint::Init(const std::uint32_t index_t,
                        const std::uint32_t index_s, const STPoint&amp; st_point) {
  index_t_ = index_t;
  index_s_ = index_s;
  point_ = st_point;
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(159, 0)" endLine="(161, 1)" clone_start="1" clone_end="3">
			<code function_name="ActiveSetQpSolver::set_l_upper_bound(const double l_upper_bound)">void ActiveSetQpSolver::set_l_upper_bound(const double l_upper_bound) {
  l_upper_bound_ = l_upper_bound;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(155, 0)" endLine="(157, 1)" clone_start="1" clone_end="3">
			<code function_name="ActiveSetQpSolver::set_l_lower_bound(const double l_lower_bound)">void ActiveSetQpSolver::set_l_lower_bound(const double l_lower_bound) {
  l_lower_bound_ = l_lower_bound;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(151, 0)" endLine="(153, 1)" clone_start="1" clone_end="3">
			<code function_name="ActiveSetQpSolver::set_debug_info(const bool enable)">void ActiveSetQpSolver::set_debug_info(const bool enable) {
  debug_info_ = enable;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\dp_st_speed\st_graph_point.cc" startLine="(48, 0)" endLine="(50, 1)" clone_start="1" clone_end="3">
			<code function_name="StGraphPoint::SetReferenceCost(const double reference_cost)">void StGraphPoint::SetReferenceCost(const double reference_cost) {
  reference_cost_ = reference_cost;
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(163, 0)" endLine="(166, 1)" clone_start="1" clone_end="4">
			<code function_name="ActiveSetQpSolver::set_constraint_upper_bound( const double la_upper_bound)">void ActiveSetQpSolver::set_constraint_upper_bound(
    const double la_upper_bound) {
  constraint_upper_bound_ = la_upper_bound;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(159, 0)" endLine="(161, 1)" clone_start="1" clone_end="3">
			<code function_name="ActiveSetQpSolver::set_l_upper_bound(const double l_upper_bound)">void ActiveSetQpSolver::set_l_upper_bound(const double l_upper_bound) {
  l_upper_bound_ = l_upper_bound;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(155, 0)" endLine="(157, 1)" clone_start="1" clone_end="3">
			<code function_name="ActiveSetQpSolver::set_l_lower_bound(const double l_lower_bound)">void ActiveSetQpSolver::set_l_lower_bound(const double l_lower_bound) {
  l_lower_bound_ = l_lower_bound;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\dp_st_speed\st_graph_point.cc" startLine="(52, 0)" endLine="(54, 1)" clone_start="1" clone_end="3">
			<code function_name="StGraphPoint::SetObstacleCost(const double obs_cost)">void StGraphPoint::SetObstacleCost(const double obs_cost) {
  obstacle_cost_ = obs_cost;
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(168, 0)" endLine="(170, 1)" clone_start="1" clone_end="2">
			<code function_name="ActiveSetQpSolver::set_max_iteration(const int max_iter)">void ActiveSetQpSolver::set_max_iteration(const int max_iter) {
  max_iteration_ = max_iter;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(163, 0)" endLine="(166, 1)" clone_start="1" clone_end="3">
			<code function_name="ActiveSetQpSolver::set_constraint_upper_bound( const double la_upper_bound)">void ActiveSetQpSolver::set_constraint_upper_bound(
    const double la_upper_bound) {
  constraint_upper_bound_ = la_upper_bound;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(159, 0)" endLine="(161, 1)" clone_start="1" clone_end="2">
			<code function_name="ActiveSetQpSolver::set_l_upper_bound(const double l_upper_bound)">void ActiveSetQpSolver::set_l_upper_bound(const double l_upper_bound) {
  l_upper_bound_ = l_upper_bound;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\dp_st_speed\st_graph_point.cc" startLine="(56, 0)" endLine="(58, 1)" clone_start="1" clone_end="2">
			<code function_name="StGraphPoint::SetTotalCost(const double total_cost)">void StGraphPoint::SetTotalCost(const double total_cost) {
  total_cost_ = total_cost;
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(161, 0)" endLine="(211, 1)" clone_start="16" clone_end="30">
			<code function_name="Spline1dConstraint::AddSecondDerivativeBoundary(    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddSecondDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }

  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);
    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 2; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) = coef * j * (j - 1);
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 2; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) = coef * j * (j - 1);
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }
  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(109, 0)" endLine="(159, 1)" clone_start="16" clone_end="30">
			<code function_name="Spline1dConstraint::AddDerivativeBoundary(const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }

  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);
    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 1; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) = coef * j;
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 1; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) = coef * j;
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }
  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(213, 0)" endLine="(265, 1)" clone_start="16" clone_end="30">
			<code function_name="Spline1dConstraint::AddThirdDerivativeBoundary(    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddThirdDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);
    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 3; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) =
          coef * j * (j - 1) * (j - 2);
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 3; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) =
          coef * j * (j - 1) * (j - 2);
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }
  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(56, 0)" endLine="(107, 1)" clone_start="16" clone_end="30">
			<code function_name="Spline1dConstraint::AddBoundary(const std::vector&lt;double&gt;&amp; x_coord,const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddBoundary(const std::vector&lt;double&gt;&amp; x_coord,
                                     const std::vector&lt;double&gt;&amp; lower_bound,
                                     const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }
  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);

    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) = coef;
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) = coef;
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }

  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\opendrive_adapter.cc" startLine="(26, 0)" endLine="(70, 1)" clone_start="25" clone_end="35">
			<code function_name="OpendriveAdapter::LoadData(const std::string&amp; filename, apollo::hdmap::Map* pb_map)">bool OpendriveAdapter::LoadData(const std::string&amp; filename,
                                apollo::hdmap::Map* pb_map) {
  CHECK_NOTNULL(pb_map);

  tinyxml2::XMLDocument document;
  if (document.LoadFile(filename.c_str()) != tinyxml2::XML_SUCCESS) {
    AERROR &lt;&lt; "fail to load file " &lt;&lt; filename;
    return false;
  }

  // root node
  const tinyxml2::XMLElement* root_node = document.RootElement();
  CHECK(root_node != nullptr);
  // header
  PbHeader* map_header = pb_map-&gt;mutable_header();
  Status status = HeaderXmlParser::Parse(*root_node, map_header);
  if (!status.ok()) {
    AERROR &lt;&lt; "fail to parse opendrive header, " &lt;&lt; status.error_message();
    return false;
  }

  // roads
  std::vector&lt;RoadInternal&gt; roads;
  status = RoadsXmlParser::Parse(*root_node, &amp;roads);
  if (!status.ok()) {
    AERROR &lt;&lt; "fail to parse opendrive road, " &lt;&lt; status.error_message();
    return false;
  }

  // junction
  std::vector&lt;JunctionInternal&gt; junctions;
  status = JunctionsXmlParser::Parse(*root_node, &amp;junctions);
  if (!status.ok()) {
    AERROR &lt;&lt; "fail to parse opendrive junction, " &lt;&lt; status.error_message();
    return false;
  }

  ProtoOrganizer proto_organizer;
  proto_organizer.GetRoadElements(&amp;roads);
  proto_organizer.GetJunctionElements(junctions);
  proto_organizer.GetOverlapElements(roads, junctions);
  proto_organizer.OutputData(pb_map);

  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\opendrive_adapter.cc" startLine="(26, 0)" endLine="(70, 1)" clone_start="17" clone_end="27">
			<code function_name="OpendriveAdapter::LoadData(const std::string&amp; filename, apollo::hdmap::Map* pb_map)">bool OpendriveAdapter::LoadData(const std::string&amp; filename,
                                apollo::hdmap::Map* pb_map) {
  CHECK_NOTNULL(pb_map);

  tinyxml2::XMLDocument document;
  if (document.LoadFile(filename.c_str()) != tinyxml2::XML_SUCCESS) {
    AERROR &lt;&lt; "fail to load file " &lt;&lt; filename;
    return false;
  }

  // root node
  const tinyxml2::XMLElement* root_node = document.RootElement();
  CHECK(root_node != nullptr);
  // header
  PbHeader* map_header = pb_map-&gt;mutable_header();
  Status status = HeaderXmlParser::Parse(*root_node, map_header);
  if (!status.ok()) {
    AERROR &lt;&lt; "fail to parse opendrive header, " &lt;&lt; status.error_message();
    return false;
  }

  // roads
  std::vector&lt;RoadInternal&gt; roads;
  status = RoadsXmlParser::Parse(*root_node, &amp;roads);
  if (!status.ok()) {
    AERROR &lt;&lt; "fail to parse opendrive road, " &lt;&lt; status.error_message();
    return false;
  }

  // junction
  std::vector&lt;JunctionInternal&gt; junctions;
  status = JunctionsXmlParser::Parse(*root_node, &amp;junctions);
  if (!status.ok()) {
    AERROR &lt;&lt; "fail to parse opendrive junction, " &lt;&lt; status.error_message();
    return false;
  }

  ProtoOrganizer proto_organizer;
  proto_organizer.GetRoadElements(&amp;roads);
  proto_organizer.GetJunctionElements(junctions);
  proto_organizer.GetOverlapElements(roads, junctions);
  proto_organizer.OutputData(pb_map);

  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\predictor_manager.cc" startLine="(141, 0)" endLine="(160, 1)" clone_start="13" clone_end="20">
			<code function_name="PredictorManager::CreatePredictor( const ObstacleConf::PredictorType&amp; type)">std::unique_ptr&lt;Predictor&gt; PredictorManager::CreatePredictor(
    const ObstacleConf::PredictorType&amp; type) {
  std::unique_ptr&lt;Predictor&gt; predictor_ptr(nullptr);
  switch (type) {
    case ObstacleConf::LANE_SEQUENCE_PREDICTOR: {
      predictor_ptr.reset(new LaneSequencePredictor());
      break;
    }
    case ObstacleConf::FREE_MOVE_PREDICTOR: {
      predictor_ptr.reset(new FreeMovePredictor());
      break;
    }
    case ObstacleConf::REGIONAL_PREDICTOR: {
      predictor_ptr.reset(new RegionalPredictor());
      break;
    }
    default: { break; }
  }
  return predictor_ptr;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\evaluator\evaluator_manager.cc" startLine="(106, 0)" endLine="(117, 1)" clone_start="5" clone_end="12">
			<code function_name="EvaluatorManager::CreateEvaluator( const ObstacleConf::EvaluatorType&amp; type)">std::unique_ptr&lt;Evaluator&gt; EvaluatorManager::CreateEvaluator(
    const ObstacleConf::EvaluatorType&amp; type) {
  std::unique_ptr&lt;Evaluator&gt; evaluator_ptr(nullptr);
  switch (type) {
    case ObstacleConf::MLP_EVALUATOR: {
      evaluator_ptr.reset(new MLPEvaluator());
      break;
    }
    default: { break; }
  }
  return evaluator_ptr;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\predictor_manager.cc" startLine="(162, 0)" endLine="(166, 1)" clone_start="1" clone_end="4">
			<code function_name="PredictorManager::RegisterPredictor( const ObstacleConf::PredictorType&amp; type)">void PredictorManager::RegisterPredictor(
    const ObstacleConf::PredictorType&amp; type) {
  predictors_[type] = CreatePredictor(type);
  AINFO &lt;&lt; "Predictor [" &lt;&lt; type &lt;&lt; "] is registered.";
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\evaluator\evaluator_manager.cc" startLine="(119, 0)" endLine="(123, 1)" clone_start="1" clone_end="4">
			<code function_name="EvaluatorManager::RegisterEvaluator( const ObstacleConf::EvaluatorType&amp; type)">void EvaluatorManager::RegisterEvaluator(
    const ObstacleConf::EvaluatorType&amp; type) {
  evaluators_[type] = CreateEvaluator(type);
  AINFO &lt;&lt; "Evaluator [" &lt;&lt; type &lt;&lt; "] is registered.";
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\glfw_viewer.cc" startLine="(62, 0)" endLine="(90, 1)" clone_start="4" clone_end="15">
			<code function_name="GLFWViewer::Initialize()">bool GLFWViewer::Initialize() {
  AINFO &lt;&lt; "GLFWViewer::initialize()" &lt;&lt; std::endl;
  if (init_) {
    AINFO &lt;&lt; " GLFWViewer is already initialized !" &lt;&lt; std::endl;
    return false;
  }

  if (!WindowInit()) {
    AINFO &lt;&lt; " Failed to initialize the window !" &lt;&lt; std::endl;
    return false;
  }

  if (!CameraInit()) {
    AINFO &lt;&lt; " Failed to initialize the camera !" &lt;&lt; std::endl;
    return false;
  }

  if (!OpenglInit()) {
    AINFO &lt;&lt; " Failed to initialize opengl !" &lt;&lt; std::endl;
    return false;
  }

  init_ = true;

  show_cloud_ = 1;
  show_velocity_ = 1;
  show_polygon_ = 0;
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\glfw_viewer.cc" startLine="(62, 0)" endLine="(90, 1)" clone_start="9" clone_end="20">
			<code function_name="GLFWViewer::Initialize()">bool GLFWViewer::Initialize() {
  AINFO &lt;&lt; "GLFWViewer::initialize()" &lt;&lt; std::endl;
  if (init_) {
    AINFO &lt;&lt; " GLFWViewer is already initialized !" &lt;&lt; std::endl;
    return false;
  }

  if (!WindowInit()) {
    AINFO &lt;&lt; " Failed to initialize the window !" &lt;&lt; std::endl;
    return false;
  }

  if (!CameraInit()) {
    AINFO &lt;&lt; " Failed to initialize the camera !" &lt;&lt; std::endl;
    return false;
  }

  if (!OpenglInit()) {
    AINFO &lt;&lt; " Failed to initialize opengl !" &lt;&lt; std::endl;
    return false;
  }

  init_ = true;

  show_cloud_ = 1;
  show_velocity_ = 1;
  show_polygon_ = 0;
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\glfw_viewer.cc" startLine="(663, 0)" endLine="(681, 1)" clone_start="5" clone_end="12">
			<code function_name="GLFWViewer::Keyboard(int key)">void GLFWViewer::Keyboard(int key) {
  switch (key) {
    case GLFW_KEY_R:  // 'R'
      Reset();
      break;
    case GLFW_KEY_P:  // 'P'
      show_polygon_ = !show_polygon_;
      break;
    case GLFW_KEY_V:  // 'V'
      show_velocity_ = !show_velocity_;
      break;
    case GLFW_KEY_D:  // d
      show_direction_ = !show_direction_;
      break;
    case GLFW_KEY_S:  // 'S'
      show_cloud_state_ = (show_cloud_state_ + 1) % 3;
      break;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\glfw_viewer.cc" startLine="(663, 0)" endLine="(681, 1)" clone_start="8" clone_end="15">
			<code function_name="GLFWViewer::Keyboard(int key)">void GLFWViewer::Keyboard(int key) {
  switch (key) {
    case GLFW_KEY_R:  // 'R'
      Reset();
      break;
    case GLFW_KEY_P:  // 'P'
      show_polygon_ = !show_polygon_;
      break;
    case GLFW_KEY_V:  // 'V'
      show_velocity_ = !show_velocity_;
      break;
    case GLFW_KEY_D:  // d
      show_direction_ = !show_direction_;
      break;
    case GLFW_KEY_S:  // 'S'
      show_cloud_state_ = (show_cloud_state_ + 1) % 3;
      break;
  }
}</code>
		</source>
	</dup>
	<dup count="5">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(239, 0)" endLine="(374, 1)" clone_start="121" clone_end="131">
			<code function_name="NovatelParser::prepare_message(MessagePtr&amp; message_ptr)">Parser::MessageType NovatelParser::prepare_message(MessagePtr&amp; message_ptr) {
  if (!check_crc()) {
    ROS_ERROR("CRC check failed.");
    return MessageType::NONE;
  }

  uint8_t* message = nullptr;
  novatel::MessageId message_id;
  uint16_t message_length;
  uint16_t gps_week;
  uint32_t gps_millisecs;
  if (_buffer[2] == novatel::SYNC_2_LONG_HEADER) {
    auto header = reinterpret_cast&lt;const novatel::LongHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::LongHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  } else {
    auto header = reinterpret_cast&lt;const novatel::ShortHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::ShortHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  }
  switch (message_id) {
    case novatel::BESTGNSSPOS:
    case novatel::BESTPOS:
    case novatel::PSRPOS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestPos), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestPos)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_pos(reinterpret_cast&lt;novatel::BestPos*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::BESTGNSSVEL:
    case novatel::BESTVEL:
    case novatel::PSRVEL:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestVel), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestVel)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_vel(reinterpret_cast&lt;novatel::BestVel*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::CORRIMUDATA:
    case novatel::CORRIMUDATAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::CorrImuData),
      // "Incorrect message_length");
      if (message_length != sizeof(novatel::CorrImuData)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_corr_imu_data(
              reinterpret_cast&lt;novatel::CorrImuData*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSCOV:
    case novatel::INSCOVS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsCov), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsCov)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_cov(reinterpret_cast&lt;novatel::InsCov*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSPVA:
    case novatel::INSPVAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsPva), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsPva)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_pva(reinterpret_cast&lt;novatel::InsPva*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::RAWIMUX:
    case novatel::RAWIMUSX:
      // ROS_ERROR_COND(message_length != sizeof(novatel::RawImuX), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::RawImuX)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_raw_imu_x(reinterpret_cast&lt;novatel::RawImuX*&gt;(message))) {
        message_ptr = &amp;_imu;
        return MessageType::IMU;
      }
      break;

    case novatel::INSPVAX:
        if (message_length != sizeof(novatel::InsPvaX)) {
          ROS_ERROR("Incorrect message_length");
          break;
        }

        if (handle_ins_pvax(reinterpret_cast&lt;novatel::InsPvaX*&gt;(message))) {
          message_ptr = &amp;_ins_stat;
          return MessageType::INS_STAT;
        }
        break;
    default:
      break;
  }
  return MessageType::NONE;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(239, 0)" endLine="(374, 1)" clone_start="107" clone_end="119">
			<code function_name="NovatelParser::prepare_message(MessagePtr&amp; message_ptr)">Parser::MessageType NovatelParser::prepare_message(MessagePtr&amp; message_ptr) {
  if (!check_crc()) {
    ROS_ERROR("CRC check failed.");
    return MessageType::NONE;
  }

  uint8_t* message = nullptr;
  novatel::MessageId message_id;
  uint16_t message_length;
  uint16_t gps_week;
  uint32_t gps_millisecs;
  if (_buffer[2] == novatel::SYNC_2_LONG_HEADER) {
    auto header = reinterpret_cast&lt;const novatel::LongHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::LongHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  } else {
    auto header = reinterpret_cast&lt;const novatel::ShortHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::ShortHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  }
  switch (message_id) {
    case novatel::BESTGNSSPOS:
    case novatel::BESTPOS:
    case novatel::PSRPOS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestPos), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestPos)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_pos(reinterpret_cast&lt;novatel::BestPos*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::BESTGNSSVEL:
    case novatel::BESTVEL:
    case novatel::PSRVEL:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestVel), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestVel)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_vel(reinterpret_cast&lt;novatel::BestVel*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::CORRIMUDATA:
    case novatel::CORRIMUDATAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::CorrImuData),
      // "Incorrect message_length");
      if (message_length != sizeof(novatel::CorrImuData)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_corr_imu_data(
              reinterpret_cast&lt;novatel::CorrImuData*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSCOV:
    case novatel::INSCOVS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsCov), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsCov)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_cov(reinterpret_cast&lt;novatel::InsCov*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSPVA:
    case novatel::INSPVAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsPva), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsPva)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_pva(reinterpret_cast&lt;novatel::InsPva*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::RAWIMUX:
    case novatel::RAWIMUSX:
      // ROS_ERROR_COND(message_length != sizeof(novatel::RawImuX), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::RawImuX)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_raw_imu_x(reinterpret_cast&lt;novatel::RawImuX*&gt;(message))) {
        message_ptr = &amp;_imu;
        return MessageType::IMU;
      }
      break;

    case novatel::INSPVAX:
        if (message_length != sizeof(novatel::InsPvaX)) {
          ROS_ERROR("Incorrect message_length");
          break;
        }

        if (handle_ins_pvax(reinterpret_cast&lt;novatel::InsPvaX*&gt;(message))) {
          message_ptr = &amp;_ins_stat;
          return MessageType::INS_STAT;
        }
        break;
    default:
      break;
  }
  return MessageType::NONE;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(239, 0)" endLine="(374, 1)" clone_start="92" clone_end="104">
			<code function_name="NovatelParser::prepare_message(MessagePtr&amp; message_ptr)">Parser::MessageType NovatelParser::prepare_message(MessagePtr&amp; message_ptr) {
  if (!check_crc()) {
    ROS_ERROR("CRC check failed.");
    return MessageType::NONE;
  }

  uint8_t* message = nullptr;
  novatel::MessageId message_id;
  uint16_t message_length;
  uint16_t gps_week;
  uint32_t gps_millisecs;
  if (_buffer[2] == novatel::SYNC_2_LONG_HEADER) {
    auto header = reinterpret_cast&lt;const novatel::LongHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::LongHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  } else {
    auto header = reinterpret_cast&lt;const novatel::ShortHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::ShortHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  }
  switch (message_id) {
    case novatel::BESTGNSSPOS:
    case novatel::BESTPOS:
    case novatel::PSRPOS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestPos), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestPos)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_pos(reinterpret_cast&lt;novatel::BestPos*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::BESTGNSSVEL:
    case novatel::BESTVEL:
    case novatel::PSRVEL:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestVel), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestVel)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_vel(reinterpret_cast&lt;novatel::BestVel*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::CORRIMUDATA:
    case novatel::CORRIMUDATAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::CorrImuData),
      // "Incorrect message_length");
      if (message_length != sizeof(novatel::CorrImuData)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_corr_imu_data(
              reinterpret_cast&lt;novatel::CorrImuData*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSCOV:
    case novatel::INSCOVS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsCov), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsCov)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_cov(reinterpret_cast&lt;novatel::InsCov*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSPVA:
    case novatel::INSPVAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsPva), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsPva)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_pva(reinterpret_cast&lt;novatel::InsPva*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::RAWIMUX:
    case novatel::RAWIMUSX:
      // ROS_ERROR_COND(message_length != sizeof(novatel::RawImuX), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::RawImuX)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_raw_imu_x(reinterpret_cast&lt;novatel::RawImuX*&gt;(message))) {
        message_ptr = &amp;_imu;
        return MessageType::IMU;
      }
      break;

    case novatel::INSPVAX:
        if (message_length != sizeof(novatel::InsPvaX)) {
          ROS_ERROR("Incorrect message_length");
          break;
        }

        if (handle_ins_pvax(reinterpret_cast&lt;novatel::InsPvaX*&gt;(message))) {
          message_ptr = &amp;_ins_stat;
          return MessageType::INS_STAT;
        }
        break;
    default:
      break;
  }
  return MessageType::NONE;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(239, 0)" endLine="(374, 1)" clone_start="77" clone_end="89">
			<code function_name="NovatelParser::prepare_message(MessagePtr&amp; message_ptr)">Parser::MessageType NovatelParser::prepare_message(MessagePtr&amp; message_ptr) {
  if (!check_crc()) {
    ROS_ERROR("CRC check failed.");
    return MessageType::NONE;
  }

  uint8_t* message = nullptr;
  novatel::MessageId message_id;
  uint16_t message_length;
  uint16_t gps_week;
  uint32_t gps_millisecs;
  if (_buffer[2] == novatel::SYNC_2_LONG_HEADER) {
    auto header = reinterpret_cast&lt;const novatel::LongHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::LongHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  } else {
    auto header = reinterpret_cast&lt;const novatel::ShortHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::ShortHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  }
  switch (message_id) {
    case novatel::BESTGNSSPOS:
    case novatel::BESTPOS:
    case novatel::PSRPOS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestPos), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestPos)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_pos(reinterpret_cast&lt;novatel::BestPos*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::BESTGNSSVEL:
    case novatel::BESTVEL:
    case novatel::PSRVEL:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestVel), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestVel)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_vel(reinterpret_cast&lt;novatel::BestVel*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::CORRIMUDATA:
    case novatel::CORRIMUDATAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::CorrImuData),
      // "Incorrect message_length");
      if (message_length != sizeof(novatel::CorrImuData)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_corr_imu_data(
              reinterpret_cast&lt;novatel::CorrImuData*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSCOV:
    case novatel::INSCOVS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsCov), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsCov)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_cov(reinterpret_cast&lt;novatel::InsCov*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSPVA:
    case novatel::INSPVAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsPva), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsPva)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_pva(reinterpret_cast&lt;novatel::InsPva*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::RAWIMUX:
    case novatel::RAWIMUSX:
      // ROS_ERROR_COND(message_length != sizeof(novatel::RawImuX), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::RawImuX)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_raw_imu_x(reinterpret_cast&lt;novatel::RawImuX*&gt;(message))) {
        message_ptr = &amp;_imu;
        return MessageType::IMU;
      }
      break;

    case novatel::INSPVAX:
        if (message_length != sizeof(novatel::InsPvaX)) {
          ROS_ERROR("Incorrect message_length");
          break;
        }

        if (handle_ins_pvax(reinterpret_cast&lt;novatel::InsPvaX*&gt;(message))) {
          message_ptr = &amp;_ins_stat;
          return MessageType::INS_STAT;
        }
        break;
    default:
      break;
  }
  return MessageType::NONE;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(239, 0)" endLine="(374, 1)" clone_start="61" clone_end="74">
			<code function_name="NovatelParser::prepare_message(MessagePtr&amp; message_ptr)">Parser::MessageType NovatelParser::prepare_message(MessagePtr&amp; message_ptr) {
  if (!check_crc()) {
    ROS_ERROR("CRC check failed.");
    return MessageType::NONE;
  }

  uint8_t* message = nullptr;
  novatel::MessageId message_id;
  uint16_t message_length;
  uint16_t gps_week;
  uint32_t gps_millisecs;
  if (_buffer[2] == novatel::SYNC_2_LONG_HEADER) {
    auto header = reinterpret_cast&lt;const novatel::LongHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::LongHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  } else {
    auto header = reinterpret_cast&lt;const novatel::ShortHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::ShortHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  }
  switch (message_id) {
    case novatel::BESTGNSSPOS:
    case novatel::BESTPOS:
    case novatel::PSRPOS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestPos), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestPos)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_pos(reinterpret_cast&lt;novatel::BestPos*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::BESTGNSSVEL:
    case novatel::BESTVEL:
    case novatel::PSRVEL:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestVel), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestVel)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_vel(reinterpret_cast&lt;novatel::BestVel*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::CORRIMUDATA:
    case novatel::CORRIMUDATAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::CorrImuData),
      // "Incorrect message_length");
      if (message_length != sizeof(novatel::CorrImuData)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_corr_imu_data(
              reinterpret_cast&lt;novatel::CorrImuData*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSCOV:
    case novatel::INSCOVS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsCov), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsCov)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_cov(reinterpret_cast&lt;novatel::InsCov*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSPVA:
    case novatel::INSPVAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsPva), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsPva)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_pva(reinterpret_cast&lt;novatel::InsPva*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::RAWIMUX:
    case novatel::RAWIMUSX:
      // ROS_ERROR_COND(message_length != sizeof(novatel::RawImuX), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::RawImuX)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_raw_imu_x(reinterpret_cast&lt;novatel::RawImuX*&gt;(message))) {
        message_ptr = &amp;_imu;
        return MessageType::IMU;
      }
      break;

    case novatel::INSPVAX:
        if (message_length != sizeof(novatel::InsPvaX)) {
          ROS_ERROR("Incorrect message_length");
          break;
        }

        if (handle_ins_pvax(reinterpret_cast&lt;novatel::InsPvaX*&gt;(message))) {
          message_ptr = &amp;_ins_stat;
          return MessageType::INS_STAT;
        }
        break;
    default:
      break;
  }
  return MessageType::NONE;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\curve1d\quintic_polynomial_curve1d.cc" startLine="(54, 0)" endLine="(86, 1)" clone_start="21" clone_end="31">
			<code function_name="QuinticPolynomialCurve1d::Evaluate(const uint32_t order, const double p) const">double QuinticPolynomialCurve1d::Evaluate(const uint32_t order,
                                          const double p) const {
  switch (order) {
    case 0: {
      return ((((coef_[0] * p + coef_[1]) * p + coef_[2]) * p + coef_[3]) * p +
              coef_[4]) *
                 p +
             coef_[5];
    }
    case 1: {
      return (((5.0 * coef_[0] * p + 4.0 * coef_[1]) * p + 3.0 * coef_[2]) * p +
              2.0 * coef_[3]) *
                 p +
             coef_[4];
    }
    case 2: {
      return (((20.0 * coef_[0] * p + 12.0 * coef_[1]) * p) + 6.0 * coef_[2]) *
                 p +
             2.0 * coef_[3];
    }
    case 3: {
      return (60.0 * coef_[0] * p + 24.0 * coef_[1]) * p + 6.0 * coef_[2];
    }
    case 4: {
      return 120.0 * coef_[0] * p + 24.0 * coef_[1];
    }
    case 5: {
      return 120.0 * coef_[0];
    }
    default:
      return 0.0;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\curve1d\quartic_polynomial_curve1d.cc" startLine="(53, 0)" endLine="(76, 1)" clone_start="12" clone_end="22">
			<code function_name="QuarticPolynomialCurve1d::Evaluate(const std::uint32_t order, const double p) const">double QuarticPolynomialCurve1d::Evaluate(const std::uint32_t order,
                                          const double p) const {
  switch (order) {
    case 0: {
      return (((coef_[0] * p + coef_[1]) * p + coef_[2]) * p + coef_[3]) * p +
             coef_[4];
    }
    case 1: {
      return ((4.0 * coef_[0] * p + 3.0 * coef_[1]) * p + 2.0 * coef_[2]) * p +
             coef_[3];
    }
    case 2: {
      return (12.0 * coef_[0] * p + 6.0 * coef_[1]) * p + 2.0 * coef_[2];
    }
    case 3: {
      return 24.0 * coef_[0] * p + 6.0 * coef_[1];
    }
    case 4: {
      return 24.0 * coef_[0];
    }
    default:
      return 0.0;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\speed\st_boundary.cc" startLine="(304, 0)" endLine="(329, 1)" clone_start="5" clone_end="15">
			<code function_name="StBoundary::GetBoundarySRange(const double curr_time, double* s_upper, double* s_lower) const">bool StBoundary::GetBoundarySRange(const double curr_time, double* s_upper,
                                   double* s_lower) const {
  CHECK_NOTNULL(s_upper);
  CHECK_NOTNULL(s_lower);
  if (curr_time &lt; min_t_ || curr_time &gt; max_t_) {
    return false;
  }

  size_t left = 0;
  size_t right = 0;
  if (!GetIndexRange(lower_points_, curr_time, &amp;left, &amp;right)) {
    AERROR &lt;&lt; "Fail to get index range.";
    return false;
  }
  const double r = (curr_time - upper_points_[left].t()) /
                   (upper_points_[right].t() - upper_points_[left].t());

  *s_upper = upper_points_[left].s() +
             r * (upper_points_[right].s() - upper_points_[left].s());
  *s_lower = lower_points_[left].s() +
             r * (lower_points_[right].s() - lower_points_[left].s());

  *s_upper = std::fmin(*s_upper, s_high_limit_);
  *s_lower = std::fmax(*s_lower, 0.0);
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\speed\st_boundary.cc" startLine="(263, 0)" endLine="(302, 1)" clone_start="8" clone_end="18">
			<code function_name="StBoundary::GetUnblockSRange(const double curr_time, double* s_upper, double* s_lower) const">bool StBoundary::GetUnblockSRange(const double curr_time, double* s_upper,
                                  double* s_lower) const {
  CHECK_NOTNULL(s_upper);
  CHECK_NOTNULL(s_lower);

  *s_upper = s_high_limit_;
  *s_lower = 0.0;
  if (curr_time &lt; min_t_ || curr_time &gt; max_t_) {
    return true;
  }

  size_t left = 0;
  size_t right = 0;
  if (!GetIndexRange(lower_points_, curr_time, &amp;left, &amp;right)) {
    AERROR &lt;&lt; "Fail to get index range.";
    return false;
  }
  const double r = (curr_time - upper_points_[left].t()) /
                   (upper_points_.at(right).t() - upper_points_.at(left).t());

  double upper_cross_s =
      upper_points_[left].s() +
      r * (upper_points_[right].s() - upper_points_[left].s());
  double lower_cross_s =
      lower_points_[left].s() +
      r * (lower_points_[right].s() - lower_points_[left].s());

  if (boundary_type_ == BoundaryType::STOP ||
      boundary_type_ == BoundaryType::YIELD ||
      boundary_type_ == BoundaryType::FOLLOW) {
    *s_upper = std::fmin(*s_upper, lower_cross_s);
  } else if (boundary_type_ == BoundaryType::OVERTAKE) {
    *s_lower = std::fmax(*s_lower, upper_cross_s);
  } else {
    AERROR &lt;&lt; "boundary_type is not supported. boundary_type: "
           &lt;&lt; static_cast&lt;int&gt;(boundary_type_);
    return false;
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\compensator.cpp" startLine="(96, 0)" endLine="(151, 1)" clone_start="28" clone_end="37">
			<code function_name="Compensator::check_message( const sensor_msgs::PointCloud2ConstPtr&amp; msg)">inline bool Compensator::check_message(
    const sensor_msgs::PointCloud2ConstPtr&amp; msg) {
  // check msg width and height
  if (msg-&gt;width == 0 || msg-&gt;height == 0) {
    return false;
  }

  int x_data_type = 0;
  int y_data_type = 0;
  int z_data_type = 0;

  // TODO: will use a new datastruct with interface to get offset,
  // datatype,datasize...
  for (size_t i = 0; i &lt; msg-&gt;fields.size(); ++i) {
    const sensor_msgs::PointField&amp; f = msg-&gt;fields[i];

    if (f.name == "x") {
      _x_offset = f.offset;
      x_data_type = f.datatype;
      if ((x_data_type != 7 &amp;&amp; x_data_type != 8) || f.count != 1 ||
          _x_offset == -1) {
        return false;
      }
    } else if (f.name == "y") {
      _y_offset = f.offset;
      y_data_type = f.datatype;
      if (f.count != 1 || _y_offset == -1) {
        return false;
      }
    } else if (f.name == "z") {
      _z_offset = f.offset;
      z_data_type = f.datatype;
      if (f.count != 1 || _z_offset == -1) {
        return false;
      }
    } else if (f.name == "timestamp") {
      _timestamp_offset = f.offset;
      _timestamp_data_size = f.count * get_field_size(f.datatype);
      if (_timestamp_offset == -1 || _timestamp_data_size == -1) {
        return false;
      }
    } else {
      ROS_DEBUG_STREAM("get a unused field name:" &lt;&lt; f.name);
    }
  }

  // check offset if valid
  if (_x_offset == -1 || _y_offset == -1 || _z_offset == -1 ||
      _timestamp_offset == -1 || _timestamp_data_size == -1) {
    return false;
  }
  if (!(x_data_type == y_data_type &amp;&amp; y_data_type == z_data_type)) {
    return false;
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\compensator.cpp" startLine="(96, 0)" endLine="(151, 1)" clone_start="22" clone_end="31">
			<code function_name="Compensator::check_message( const sensor_msgs::PointCloud2ConstPtr&amp; msg)">inline bool Compensator::check_message(
    const sensor_msgs::PointCloud2ConstPtr&amp; msg) {
  // check msg width and height
  if (msg-&gt;width == 0 || msg-&gt;height == 0) {
    return false;
  }

  int x_data_type = 0;
  int y_data_type = 0;
  int z_data_type = 0;

  // TODO: will use a new datastruct with interface to get offset,
  // datatype,datasize...
  for (size_t i = 0; i &lt; msg-&gt;fields.size(); ++i) {
    const sensor_msgs::PointField&amp; f = msg-&gt;fields[i];

    if (f.name == "x") {
      _x_offset = f.offset;
      x_data_type = f.datatype;
      if ((x_data_type != 7 &amp;&amp; x_data_type != 8) || f.count != 1 ||
          _x_offset == -1) {
        return false;
      }
    } else if (f.name == "y") {
      _y_offset = f.offset;
      y_data_type = f.datatype;
      if (f.count != 1 || _y_offset == -1) {
        return false;
      }
    } else if (f.name == "z") {
      _z_offset = f.offset;
      z_data_type = f.datatype;
      if (f.count != 1 || _z_offset == -1) {
        return false;
      }
    } else if (f.name == "timestamp") {
      _timestamp_offset = f.offset;
      _timestamp_data_size = f.count * get_field_size(f.datatype);
      if (_timestamp_offset == -1 || _timestamp_data_size == -1) {
        return false;
      }
    } else {
      ROS_DEBUG_STREAM("get a unused field name:" &lt;&lt; f.name);
    }
  }

  // check offset if valid
  if (_x_offset == -1 || _y_offset == -1 || _z_offset == -1 ||
      _timestamp_offset == -1 || _timestamp_data_size == -1) {
    return false;
  }
  if (!(x_data_type == y_data_type &amp;&amp; y_data_type == z_data_type)) {
    return false;
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\util\string_util_internal.h" startLine="(69, 2)" endLine="(71, 58)" clone_start="1" clone_end="3">
			<code function_name="DebugStringIterPrinter(const Iter&amp; begin, const Iter&amp; end, const std::string&amp; delimiter)">  DebugStringIterPrinter(const Iter&amp; begin, const Iter&amp; end,
                         const std::string&amp; delimiter)
      : begin_(begin), end_(end), delimiter_(delimiter) {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\util\string_util_internal.h" startLine="(42, 2)" endLine="(43, 58)" clone_start="1" clone_end="2">
			<code function_name="IterPrinter(const Iter&amp; begin, const Iter&amp; end, const std::string&amp; delimiter)">  IterPrinter(const Iter&amp; begin, const Iter&amp; end, const std::string&amp; delimiter)
      : begin_(begin), end_(end), delimiter_(delimiter) {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\util\string_util_internal.h" startLine="(73, 2)" endLine="(83, 3)" clone_start="1" clone_end="4">
			<code function_name="DebugStringIterPrinter(const Iter&amp; begin, const Iter&amp; end, const std::string&amp; delimiter)">  std::ostream&amp; Print(std::ostream&amp; os) const {
    for (Iter it = begin_; it != end_; ++it) {
      // Print first item without delimiter.
      if (it == begin_) {
        os &lt;&lt; it-&gt;DebugString();
      } else {
        os &lt;&lt; delimiter_ &lt;&lt; it-&gt;DebugString();
      }
    }
    return os;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\util\string_util_internal.h" startLine="(45, 2)" endLine="(55, 3)" clone_start="1" clone_end="4">
			<code function_name="IterPrinter(const Iter&amp; begin, const Iter&amp; end, const std::string&amp; delimiter)">  std::ostream&amp; Print(std::ostream&amp; os) const {
    for (Iter it = begin_; it != end_; ++it) {
      // Print first item without delimiter.
      if (it == begin_) {
        os &lt;&lt; *it;
      } else {
        os &lt;&lt; delimiter_ &lt;&lt; *it;
      }
    }
    return os;
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(441, 0)" endLine="(499, 1)" clone_start="36" clone_end="45">
			<code function_name="Spline1dConstraint::AddThirdDerivativeSmoothConstraint()">bool Spline1dConstraint::AddThirdDerivativeSmoothConstraint() {
  if (x_knots_.size() &lt; 3) {
    return false;
  }

  const std::uint32_t n_constraint = (x_knots_.size() - 2) * 4;
  Eigen::MatrixXd equality_constraint = Eigen::MatrixXd::Zero(
      n_constraint, (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd equality_boundary = Eigen::MatrixXd::Zero(n_constraint, 1);

  for (std::uint32_t i = 0; i &lt; n_constraint; i += 4) {
    double left_coef = 1.0;
    double right_coef = -1.0;
    double left_dcoef = 1.0;
    double right_dcoef = -1.0;
    double left_ddcoef = 1.0;
    double right_ddcoef = -1.0;
    double left_dddcoef = 1.0;
    double right_dddcoef = -1.0;

    const double x_left = x_knots_[i / 4 + 1] - x_knots_[i / 4];
    const double x_right = 0.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      equality_constraint(i, spline_order_ * i / 4 + j) = left_coef;
      equality_constraint(i, spline_order_ * (i / 4 + 1) + j) = right_coef;

      if (j &gt;= 3) {
        equality_constraint(i + 3, spline_order_ * i / 4 + j) =
            left_dddcoef * j * (j - 1) * (j - 2);
        equality_constraint(i + 3, spline_order_ * (i / 4 + 1) + j) =
            right_dddcoef * j * (j - 1) * (j - 2);
        left_dddcoef = left_ddcoef;
        right_dddcoef = right_ddcoef;
      }

      if (j &gt;= 2) {
        equality_constraint(i + 2, spline_order_ * i / 4 + j) =
            left_ddcoef * j * (j - 1);
        equality_constraint(i + 2, spline_order_ * (i / 4 + 1) + j) =
            right_ddcoef * j * (j - 1);
        left_ddcoef = left_dcoef;
        right_ddcoef = right_dcoef;
      }

      if (j &gt;= 1) {
        equality_constraint(i + 1, spline_order_ * i / 4 + j) = left_dcoef * j;
        equality_constraint(i + 1, spline_order_ * (i / 4 + 1) + j) =
            right_dcoef * j;
        left_dcoef = left_coef;
        right_dcoef = right_coef;
      }

      left_coef *= x_left;
      right_coef *= x_right;
    }
  }
  return equality_constraint_.AddConstraint(equality_constraint,
                                            equality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(392, 0)" endLine="(439, 1)" clone_start="25" clone_end="34">
			<code function_name="Spline1dConstraint::AddSecondDerivativeSmoothConstraint()">bool Spline1dConstraint::AddSecondDerivativeSmoothConstraint() {
  if (x_knots_.size() &lt; 3) {
    return false;
  }

  const std::uint32_t n_constraint = (x_knots_.size() - 2) * 3;
  Eigen::MatrixXd equality_constraint = Eigen::MatrixXd::Zero(
      n_constraint, (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd equality_boundary = Eigen::MatrixXd::Zero(n_constraint, 1);

  for (std::uint32_t i = 0; i &lt; n_constraint; i += 3) {
    double left_coef = 1.0;
    double right_coef = -1.0;
    double left_dcoef = 1.0;
    double right_dcoef = -1.0;
    double left_ddcoef = 1.0;
    double right_ddcoef = -1.0;

    const double x_left = x_knots_[i / 3 + 1] - x_knots_[i / 3];
    const double x_right = 0.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      equality_constraint(i, spline_order_ * (i / 3) + j) = left_coef;
      equality_constraint(i, spline_order_ * (i / 3 + 1) + j) = right_coef;

      if (j &gt;= 2) {
        equality_constraint(i + 2, spline_order_ * i / 3 + j) =
            left_ddcoef * j * (j - 1);
        equality_constraint(i + 2, spline_order_ * (i / 3 + 1) + j) =
            right_ddcoef * j * (j - 1);
        left_ddcoef = left_dcoef;
        right_ddcoef = right_dcoef;
      }

      if (j &gt;= 1) {
        equality_constraint(i + 1, spline_order_ * (i / 3) + j) =
            left_dcoef * j;
        equality_constraint(i + 1, spline_order_ * (i / 3 + 1) + j) =
            right_dcoef * j;
        left_dcoef = left_coef;
        right_dcoef = right_coef;
      }
      left_coef *= x_left;
      right_coef *= x_right;
    }
  }
  return equality_constraint_.AddConstraint(equality_constraint,
                                            equality_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\tools\map_xysl.cc" startLine="(131, 0)" endLine="(287, 1)" clone_start="147" clone_end="154">
			<code function_name="main(int argc, char *argv[])">int main(int argc, char *argv[]) {
  google::InitGoogleLogging(argv[0]);
  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);
  const std::string map_file = apollo::hdmap::BaseMapFile();
  apollo::hdmap::MapUtil map_util;

  if (FLAGS_xy_to_sl) {
    double x = FLAGS_x;
    double y = FLAGS_y;
    PointENU point;
    point.set_x(x);
    point.set_y(y);
    point.set_z(0);
    std::string lane_id;
    double s = 0.0;
    double l = 0.0;
    map_util.point_to_sl(point, &amp;lane_id, &amp;s, &amp;l);
    double heading = 0.0;
    map_util.sl_to_point(lane_id, s, l, &amp;point, &amp;heading);
    printf("lane_id[%s], s[%f], l[%f], heading[%f]\n", lane_id.c_str(), s, l,
           heading);
  }
  if (FLAGS_sl_to_xy) {
    PointENU point;
    double heading = 0.0;
    map_util.sl_to_point(FLAGS_lane, FLAGS_s, FLAGS_l, &amp;point, &amp;heading);
    printf("x[%f] y[%f], heading[%f]\n", point.x(), point.y(), heading);
  }
  if (FLAGS_xy_to_lane) {
    double s = 0.0;
    double l = 0.0;
    int ret = map_util.lane_projection({FLAGS_x, FLAGS_y}, FLAGS_lane, &amp;s, &amp;l);
    if (ret != 0) {
      printf("lane_projection for x[%f], y[%f], lane_id[%s] failed\n", FLAGS_x,
             FLAGS_y, FLAGS_lane.c_str());
      return -1;
    }
    printf("lane[%s] s[%f], l[%f]\n", FLAGS_lane.c_str(), s, l);
  }
  if (FLAGS_lane_to_lane) {
    PointENU point;
    double heading = 0.0;
    map_util.sl_to_point(FLAGS_from_lane, FLAGS_s, 0.0, &amp;point, &amp;heading);
    double target_s = 0.0;
    double target_l = 0.0;
    int ret = map_util.lane_projection({point.x(), point.y()}, FLAGS_to_lane,
                                       &amp;target_s, &amp;target_l);
    if (ret != 0) {
      printf("lane_projection for lane[%s], s[%f] to lane_id[%s] failed\n",
             FLAGS_from_lane.c_str(), FLAGS_s, FLAGS_to_lane.c_str());
      return -1;
    }
    printf("lane[%s] s[%f], l[%f]\n", FLAGS_to_lane.c_str(), target_s,
           target_l);
  }
  if (!FLAGS_lane.empty()) {
    const auto *lane_ptr = map_util.get_lane(FLAGS_lane);
    const auto &amp;lane = lane_ptr-&gt;lane();

    PointENU start_point;
    double start_heading = 0.0;
    map_util.sl_to_point(FLAGS_lane, 0, 0, &amp;start_point, &amp;start_heading);

    PointENU end_point;
    double end_heading = 0.0;
    map_util.sl_to_point(FLAGS_lane, lane_ptr-&gt;total_length(), 0, &amp;end_point,
                         &amp;end_heading);

    double left_width = 0.0;
    double right_width = 0.0;
    lane_ptr-&gt;GetWidth(FLAGS_s, &amp;left_width, &amp;right_width);

    std::cout &lt;&lt; "lane[" &lt;&lt; FLAGS_lane &lt;&lt; std::fixed &lt;&lt; "] length["
              &lt;&lt; lane_ptr-&gt;total_length() &lt;&lt; "] type["
              &lt;&lt; Lane_LaneType_Name(lane.type()) &lt;&lt; "] turn["
              &lt;&lt; Lane_LaneTurn_Name(lane.turn()) &lt;&lt; "] speed_limit["
              &lt;&lt; lane.speed_limit() &lt;&lt; "] predecessor[" &lt;&lt; lane.predecessor_id()
              &lt;&lt; "] successor[" &lt;&lt; lane.successor_id() &lt;&lt; "] left_forward["
              &lt;&lt; lane.left_neighbor_forward_lane_id() &lt;&lt; "] right_forward["
              &lt;&lt; lane.right_neighbor_forward_lane_id() &lt;&lt; "] left_reverse["
              &lt;&lt; lane.left_neighbor_reverse_lane_id() &lt;&lt; "] right_reverse["
              &lt;&lt; lane.right_neighbor_reverse_lane_id() &lt;&lt; "] overlap["
              &lt;&lt; lane.overlap_id() &lt;&lt; "] stop_sign num:["
              &lt;&lt; lane_ptr-&gt;stop_signs().size() &lt;&lt; "]"
              &lt;&lt; " start point(x,y,heading):" &lt;&lt; start_point.x() &lt;&lt; ","
              &lt;&lt; start_point.y() &lt;&lt; "," &lt;&lt; start_heading
              &lt;&lt; " end point(x,y,heading):" &lt;&lt; end_point.x() &lt;&lt; ","
              &lt;&lt; end_point.y() &lt;&lt; "," &lt;&lt; end_heading
              &lt;&lt; " left_width:" &lt;&lt; left_width &lt;&lt; " right_width:" &lt;&lt; right_width
              &lt;&lt; std::endl;
    std::cout.unsetf(std::ios_base::fixed);

    if (FLAGS_dump_lane_width) {
      const auto sample_left_widthes = lane_ptr-&gt;sampled_left_width();
      std::cout &lt;&lt; "left width num: " &lt;&lt; sample_left_widthes.size()
                &lt;&lt; std::endl;
      int num = 0;
      for (auto w : sample_left_widthes) {
        std::cout &lt;&lt; " " &lt;&lt; w.second;
        if (++num % 10 == 0) {
          std::cout &lt;&lt; std::endl;
        }
      }
      std::cout &lt;&lt; std::endl;
      num = 0;
      const auto sample_right_widthes = lane_ptr-&gt;sampled_right_width();
      std::cout &lt;&lt; "right width num: " &lt;&lt; sample_right_widthes.size()
                &lt;&lt; std::endl;
      for (auto w : sample_right_widthes) {
        std::cout &lt;&lt; " " &lt;&lt; w.second;
        if (++num % 10 == 0) {
          std::cout &lt;&lt; std::endl;
        }
      }
      std::cout &lt;&lt; std::endl;
    }
  }
  if (!FLAGS_overlap.empty()) {
    const auto *overlap_ptr = map_util.get_overlap(FLAGS_overlap);
    if (overlap_ptr != nullptr) {
      std::cout &lt;&lt; "overlap[" &lt;&lt; overlap_ptr-&gt;id().id() &lt;&lt; "] info["
                &lt;&lt; overlap_ptr-&gt;overlap().DebugString() &lt;&lt; "]" &lt;&lt; std::endl;
    }
  }
  if (!FLAGS_signal_info.empty()) {
    const auto *signal_ptr = map_util.get_signal(FLAGS_signal_info);
    if (signal_ptr) {
      std::cout &lt;&lt; "signal[" &lt;&lt; FLAGS_signal_info &lt;&lt; "] info["
                &lt;&lt; signal_ptr-&gt;signal().DebugString() &lt;&lt; "]" &lt;&lt; std::endl;
    }
  }
  if (!FLAGS_dump_txt_map.empty()) {
    apollo::hdmap::Map map;
    CHECK(apollo::common::util::GetProtoFromFile(map_file, &amp;map));
    CHECK(apollo::common::util::SetProtoToASCIIFile(map, FLAGS_dump_txt_map));
  }
  if (!FLAGS_dump_bin_map.empty()) {
    apollo::hdmap::Map map;
    CHECK(apollo::common::util::GetProtoFromFile(map_file, &amp;map));
    CHECK(apollo::common::util::SetProtoToBinaryFile(map, FLAGS_dump_bin_map));
  }
  if (!FLAGS_sl_to_xy &amp;&amp; !FLAGS_xy_to_sl &amp;&amp; !FLAGS_xy_to_lane &amp;&amp;
      !FLAGS_lane_to_lane &amp;&amp; FLAGS_lane.empty() &amp;&amp; FLAGS_dump_txt_map.empty() &amp;&amp;
      FLAGS_dump_bin_map.empty() &amp;&amp; FLAGS_signal_info.empty() &amp;&amp;
      FLAGS_overlap.empty()) {
    std::cout &lt;&lt; "usage: --dump_txt_map" &lt;&lt; std::endl;
    std::cout &lt;&lt; "usage: --dump_bin_map" &lt;&lt; std::endl;
    std::cout &lt;&lt; "usage: --xy_to_sl --x --y" &lt;&lt; std::endl;
    std::cout &lt;&lt; "usage: --sl_to_xy --lane --s --l" &lt;&lt; std::endl;
    std::cout &lt;&lt; "usage: --xy_to_lane --x --y --lane" &lt;&lt; std::endl;
    std::cout &lt;&lt; "usage: --lane_to_lane --from_lane --s --to_lane" &lt;&lt; std::endl;
    std::cout &lt;&lt; "usage: --lane" &lt;&lt; std::endl;
    std::cout &lt;&lt; "usage: --signal_info" &lt;&lt; std::endl;
    std::cout &lt;&lt; "usage: --overlap" &lt;&lt; std::endl;
  }
  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\tools\map_xysl.cc" startLine="(131, 0)" endLine="(287, 1)" clone_start="146" clone_end="153">
			<code function_name="main(int argc, char *argv[])">int main(int argc, char *argv[]) {
  google::InitGoogleLogging(argv[0]);
  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);
  const std::string map_file = apollo::hdmap::BaseMapFile();
  apollo::hdmap::MapUtil map_util;

  if (FLAGS_xy_to_sl) {
    double x = FLAGS_x;
    double y = FLAGS_y;
    PointENU point;
    point.set_x(x);
    point.set_y(y);
    point.set_z(0);
    std::string lane_id;
    double s = 0.0;
    double l = 0.0;
    map_util.point_to_sl(point, &amp;lane_id, &amp;s, &amp;l);
    double heading = 0.0;
    map_util.sl_to_point(lane_id, s, l, &amp;point, &amp;heading);
    printf("lane_id[%s], s[%f], l[%f], heading[%f]\n", lane_id.c_str(), s, l,
           heading);
  }
  if (FLAGS_sl_to_xy) {
    PointENU point;
    double heading = 0.0;
    map_util.sl_to_point(FLAGS_lane, FLAGS_s, FLAGS_l, &amp;point, &amp;heading);
    printf("x[%f] y[%f], heading[%f]\n", point.x(), point.y(), heading);
  }
  if (FLAGS_xy_to_lane) {
    double s = 0.0;
    double l = 0.0;
    int ret = map_util.lane_projection({FLAGS_x, FLAGS_y}, FLAGS_lane, &amp;s, &amp;l);
    if (ret != 0) {
      printf("lane_projection for x[%f], y[%f], lane_id[%s] failed\n", FLAGS_x,
             FLAGS_y, FLAGS_lane.c_str());
      return -1;
    }
    printf("lane[%s] s[%f], l[%f]\n", FLAGS_lane.c_str(), s, l);
  }
  if (FLAGS_lane_to_lane) {
    PointENU point;
    double heading = 0.0;
    map_util.sl_to_point(FLAGS_from_lane, FLAGS_s, 0.0, &amp;point, &amp;heading);
    double target_s = 0.0;
    double target_l = 0.0;
    int ret = map_util.lane_projection({point.x(), point.y()}, FLAGS_to_lane,
                                       &amp;target_s, &amp;target_l);
    if (ret != 0) {
      printf("lane_projection for lane[%s], s[%f] to lane_id[%s] failed\n",
             FLAGS_from_lane.c_str(), FLAGS_s, FLAGS_to_lane.c_str());
      return -1;
    }
    printf("lane[%s] s[%f], l[%f]\n", FLAGS_to_lane.c_str(), target_s,
           target_l);
  }
  if (!FLAGS_lane.empty()) {
    const auto *lane_ptr = map_util.get_lane(FLAGS_lane);
    const auto &amp;lane = lane_ptr-&gt;lane();

    PointENU start_point;
    double start_heading = 0.0;
    map_util.sl_to_point(FLAGS_lane, 0, 0, &amp;start_point, &amp;start_heading);

    PointENU end_point;
    double end_heading = 0.0;
    map_util.sl_to_point(FLAGS_lane, lane_ptr-&gt;total_length(), 0, &amp;end_point,
                         &amp;end_heading);

    double left_width = 0.0;
    double right_width = 0.0;
    lane_ptr-&gt;GetWidth(FLAGS_s, &amp;left_width, &amp;right_width);

    std::cout &lt;&lt; "lane[" &lt;&lt; FLAGS_lane &lt;&lt; std::fixed &lt;&lt; "] length["
              &lt;&lt; lane_ptr-&gt;total_length() &lt;&lt; "] type["
              &lt;&lt; Lane_LaneType_Name(lane.type()) &lt;&lt; "] turn["
              &lt;&lt; Lane_LaneTurn_Name(lane.turn()) &lt;&lt; "] speed_limit["
              &lt;&lt; lane.speed_limit() &lt;&lt; "] predecessor[" &lt;&lt; lane.predecessor_id()
              &lt;&lt; "] successor[" &lt;&lt; lane.successor_id() &lt;&lt; "] left_forward["
              &lt;&lt; lane.left_neighbor_forward_lane_id() &lt;&lt; "] right_forward["
              &lt;&lt; lane.right_neighbor_forward_lane_id() &lt;&lt; "] left_reverse["
              &lt;&lt; lane.left_neighbor_reverse_lane_id() &lt;&lt; "] right_reverse["
              &lt;&lt; lane.right_neighbor_reverse_lane_id() &lt;&lt; "] overlap["
              &lt;&lt; lane.overlap_id() &lt;&lt; "] stop_sign num:["
              &lt;&lt; lane_ptr-&gt;stop_signs().size() &lt;&lt; "]"
              &lt;&lt; " start point(x,y,heading):" &lt;&lt; start_point.x() &lt;&lt; ","
              &lt;&lt; start_point.y() &lt;&lt; "," &lt;&lt; start_heading
              &lt;&lt; " end point(x,y,heading):" &lt;&lt; end_point.x() &lt;&lt; ","
              &lt;&lt; end_point.y() &lt;&lt; "," &lt;&lt; end_heading
              &lt;&lt; " left_width:" &lt;&lt; left_width &lt;&lt; " right_width:" &lt;&lt; right_width
              &lt;&lt; std::endl;
    std::cout.unsetf(std::ios_base::fixed);

    if (FLAGS_dump_lane_width) {
      const auto sample_left_widthes = lane_ptr-&gt;sampled_left_width();
      std::cout &lt;&lt; "left width num: " &lt;&lt; sample_left_widthes.size()
                &lt;&lt; std::endl;
      int num = 0;
      for (auto w : sample_left_widthes) {
        std::cout &lt;&lt; " " &lt;&lt; w.second;
        if (++num % 10 == 0) {
          std::cout &lt;&lt; std::endl;
        }
      }
      std::cout &lt;&lt; std::endl;
      num = 0;
      const auto sample_right_widthes = lane_ptr-&gt;sampled_right_width();
      std::cout &lt;&lt; "right width num: " &lt;&lt; sample_right_widthes.size()
                &lt;&lt; std::endl;
      for (auto w : sample_right_widthes) {
        std::cout &lt;&lt; " " &lt;&lt; w.second;
        if (++num % 10 == 0) {
          std::cout &lt;&lt; std::endl;
        }
      }
      std::cout &lt;&lt; std::endl;
    }
  }
  if (!FLAGS_overlap.empty()) {
    const auto *overlap_ptr = map_util.get_overlap(FLAGS_overlap);
    if (overlap_ptr != nullptr) {
      std::cout &lt;&lt; "overlap[" &lt;&lt; overlap_ptr-&gt;id().id() &lt;&lt; "] info["
                &lt;&lt; overlap_ptr-&gt;overlap().DebugString() &lt;&lt; "]" &lt;&lt; std::endl;
    }
  }
  if (!FLAGS_signal_info.empty()) {
    const auto *signal_ptr = map_util.get_signal(FLAGS_signal_info);
    if (signal_ptr) {
      std::cout &lt;&lt; "signal[" &lt;&lt; FLAGS_signal_info &lt;&lt; "] info["
                &lt;&lt; signal_ptr-&gt;signal().DebugString() &lt;&lt; "]" &lt;&lt; std::endl;
    }
  }
  if (!FLAGS_dump_txt_map.empty()) {
    apollo::hdmap::Map map;
    CHECK(apollo::common::util::GetProtoFromFile(map_file, &amp;map));
    CHECK(apollo::common::util::SetProtoToASCIIFile(map, FLAGS_dump_txt_map));
  }
  if (!FLAGS_dump_bin_map.empty()) {
    apollo::hdmap::Map map;
    CHECK(apollo::common::util::GetProtoFromFile(map_file, &amp;map));
    CHECK(apollo::common::util::SetProtoToBinaryFile(map, FLAGS_dump_bin_map));
  }
  if (!FLAGS_sl_to_xy &amp;&amp; !FLAGS_xy_to_sl &amp;&amp; !FLAGS_xy_to_lane &amp;&amp;
      !FLAGS_lane_to_lane &amp;&amp; FLAGS_lane.empty() &amp;&amp; FLAGS_dump_txt_map.empty() &amp;&amp;
      FLAGS_dump_bin_map.empty() &amp;&amp; FLAGS_signal_info.empty() &amp;&amp;
      FLAGS_overlap.empty()) {
    std::cout &lt;&lt; "usage: --dump_txt_map" &lt;&lt; std::endl;
    std::cout &lt;&lt; "usage: --dump_bin_map" &lt;&lt; std::endl;
    std::cout &lt;&lt; "usage: --xy_to_sl --x --y" &lt;&lt; std::endl;
    std::cout &lt;&lt; "usage: --sl_to_xy --lane --s --l" &lt;&lt; std::endl;
    std::cout &lt;&lt; "usage: --xy_to_lane --x --y --lane" &lt;&lt; std::endl;
    std::cout &lt;&lt; "usage: --lane_to_lane --from_lane --s --to_lane" &lt;&lt; std::endl;
    std::cout &lt;&lt; "usage: --lane" &lt;&lt; std::endl;
    std::cout &lt;&lt; "usage: --signal_info" &lt;&lt; std::endl;
    std::cout &lt;&lt; "usage: --overlap" &lt;&lt; std::endl;
  }
  return 0;
}</code>
		</source>
	</dup>
	<dup count="7">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\pointcloud_dump_nodelet.cpp" startLine="(28, 2)" endLine="(28, 28)" clone_start="1" clone_end="1">
			<code function_name="PointCloudDumpNodelet()">  PointCloudDumpNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\pcd_exporter_nodelet.cpp" startLine="(28, 2)" endLine="(28, 25)" clone_start="1" clone_end="1">
			<code function_name="PCDExporterNodelet()">  PCDExporterNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\convert_nodelet.cpp" startLine="(28, 2)" endLine="(28, 21)" clone_start="1" clone_end="1">
			<code function_name="ConvertNodelet()">  ConvertNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\compensator_nodelet.cpp" startLine="(28, 2)" endLine="(28, 25)" clone_start="1" clone_end="1">
			<code function_name="CompensatorNodelet()">  CompensatorNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\tf_broadcaster_nodelet.cpp" startLine="(31, 2)" endLine="(31, 27)" clone_start="1" clone_end="1">
			<code function_name="TFBroadcasterNodelet()">  TFBroadcasterNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\stream_nodelet.cpp" startLine="(39, 2)" endLine="(39, 20)" clone_start="1" clone_end="1">
			<code function_name="StreamNodelet()">  StreamNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\parser_nodelet.cpp" startLine="(30, 2)" endLine="(30, 20)" clone_start="1" clone_end="1">
			<code function_name="ParserNodelet()">  ParserNodelet() {}</code>
		</source>
	</dup>
	<dup count="7">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\pointcloud_dump_nodelet.cpp" startLine="(29, 2)" endLine="(29, 29)" clone_start="1" clone_end="1">
			<code function_name="~PointCloudDumpNodelet()">  ~PointCloudDumpNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\pcd_exporter_nodelet.cpp" startLine="(29, 2)" endLine="(29, 26)" clone_start="1" clone_end="1">
			<code function_name="~PCDExporterNodelet()">  ~PCDExporterNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\convert_nodelet.cpp" startLine="(29, 2)" endLine="(29, 22)" clone_start="1" clone_end="1">
			<code function_name="~ConvertNodelet()">  ~ConvertNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\compensator_nodelet.cpp" startLine="(29, 2)" endLine="(29, 26)" clone_start="1" clone_end="1">
			<code function_name="~CompensatorNodelet()">  ~CompensatorNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\tf_broadcaster_nodelet.cpp" startLine="(32, 2)" endLine="(32, 28)" clone_start="1" clone_end="1">
			<code function_name="~TFBroadcasterNodelet()">  ~TFBroadcasterNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\stream_nodelet.cpp" startLine="(40, 2)" endLine="(40, 21)" clone_start="1" clone_end="1">
			<code function_name="~StreamNodelet()">  ~StreamNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\parser_nodelet.cpp" startLine="(31, 2)" endLine="(31, 21)" clone_start="1" clone_end="1">
			<code function_name="~ParserNodelet()">  ~ParserNodelet() {}</code>
		</source>
	</dup>
	<dup count="7">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\pointcloud_dump_nodelet.cpp" startLine="(37, 0)" endLine="(39, 1)" clone_start="1" clone_end="1">
			<code function_name="PointCloudDumpNodelet::onInit()">void PointCloudDumpNodelet::onInit() {
  _pc_dump.reset(new PointCloudDump(getNodeHandle(), getPrivateNodeHandle()));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\pcd_exporter_nodelet.cpp" startLine="(37, 0)" endLine="(41, 1)" clone_start="1" clone_end="1">
			<code function_name="PCDExporterNodelet::onInit()">void PCDExporterNodelet::onInit() {
  ROS_INFO("Pcd exporter nodelet init");
  _instance.reset(new PCDExporter(getNodeHandle(), getPrivateNodeHandle()));
  _instance-&gt;init();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\convert_nodelet.cpp" startLine="(37, 0)" endLine="(41, 1)" clone_start="1" clone_end="1">
			<code function_name="ConvertNodelet::onInit()">void ConvertNodelet::onInit() {
  ROS_INFO("Point cloud nodelet init");
  _conv.reset(new Convert());
  _conv-&gt;init(getNodeHandle(), getPrivateNodeHandle());
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\compensator_nodelet.cpp" startLine="(37, 0)" endLine="(40, 1)" clone_start="1" clone_end="1">
			<code function_name="CompensatorNodelet::onInit()">void CompensatorNodelet::onInit() {
  ROS_INFO("Compensator nodelet init");
  _compensator.reset(new Compensator(getNodeHandle(), getPrivateNodeHandle()));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\tf_broadcaster_nodelet.cpp" startLine="(40, 0)" endLine="(46, 1)" clone_start="1" clone_end="1">
			<code function_name="TFBroadcasterNodelet::onInit()">void TFBroadcasterNodelet::onInit() {
  ros::NodeHandle&amp; nh = getPrivateNodeHandle();

  _tf_broadcaster.reset(new TFBroadcaster(nh));
  _tf_broadcaster-&gt;init();
  ROS_INFO("Init tf broadcaster nodelet success.");
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\stream_nodelet.cpp" startLine="(47, 0)" endLine="(74, 1)" clone_start="1" clone_end="1">
			<code function_name="StreamNodelet::onInit()">void StreamNodelet::onInit() {
  ros::NodeHandle&amp; nh = getPrivateNodeHandle();
  std::string gnss_conf;
  std::string raw_data_topic;
  std::string rtcm_data_topic;
  std::string stream_status_topic;

  nh.param("gnss_conf", gnss_conf, std::string("./conf/gnss_conf.txt"));
  nh.param("raw_data_topic", raw_data_topic,
           std::string("/apollo/sensor/gnss/raw_data"));
  nh.param("rtcm_data_topic", rtcm_data_topic,
           std::string("/apollo/sensor/gnss/rtcm_data"));
  nh.param("stream_status_topic", stream_status_topic,
           std::string("/apollo/sensor/gnss/stream_status"));

  ROS_INFO_STREAM("gnss conf: " &lt;&lt; gnss_conf);
  ROS_INFO_STREAM("raw data topic: " &lt;&lt; raw_data_topic);

  init_signal();
  _raw_stream.reset(new RawStream(nh, getName(), raw_data_topic,
                                  rtcm_data_topic, stream_status_topic));
  if (!_raw_stream-&gt;init(gnss_conf)) {
    ROS_ERROR("Init stream nodelet failed.");
    ROS_ERROR_STREAM("Init stream nodelet failed.");
    return;
  }
  ROS_INFO("Init stream nodelet success.");
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\parser_nodelet.cpp" startLine="(39, 0)" endLine="(72, 1)" clone_start="1" clone_end="1">
			<code function_name="ParserNodelet::onInit()">void ParserNodelet::onInit() {
  ros::NodeHandle&amp; nh = getPrivateNodeHandle();
  std::string gnss_conf;
  std::string raw_data_topic;
  std::string ins_stat_topic;
  std::string corr_imu_topic;
  std::string odometry_topic;
  std::string gnss_status_topic;
  std::string ins_status_topic;

  nh.param("gnss_conf", gnss_conf, std::string("./conf/gnss_conf.txt"));
  nh.param("raw_data_topic", raw_data_topic,
           std::string("/apollo/sensor/gnss/raw_data"));
  nh.param("ins_stat_topic", ins_stat_topic,
           std::string("/apollo/sensor/gnss/ins_stat"));
  nh.param("corr_imu_topic", corr_imu_topic,
           std::string("/apollo/sensor/gnss/corrected_imu"));
  nh.param("odometry_topic", odometry_topic,
           std::string("/apollo/sensor/gnss/odometry"));
  nh.param("gnss_status_topic", gnss_status_topic,
           std::string("/apollo/sensor/gnss/gnss_status"));
  nh.param("ins_status_topic", ins_status_topic,
           std::string("/apollo/sensor/gnss/ins_status"));

  _data_parser.reset(new DataParser(nh, raw_data_topic, ins_stat_topic,
                                    corr_imu_topic, odometry_topic,
                                    gnss_status_topic, ins_status_topic));
  if (!_data_parser-&gt;init(gnss_conf)) {
    ROS_ERROR("Init parser nodelet failed.");
    ROS_ERROR_STREAM("Init parser nodelet failed.");
    return;
  }
  ROS_INFO("Init parser nodelet success.");
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\vehicle\lane_sequence_predictor.h" startLine="(41, 2)" endLine="(41, 36)" clone_start="1" clone_end="1">
			<code function_name="LaneSequencePredictor()">  LaneSequencePredictor() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\vehicle\free_move_predictor.h" startLine="(38, 2)" endLine="(38, 32)" clone_start="1" clone_end="1">
			<code function_name="FreeMovePredictor()">  FreeMovePredictor() = default;</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\vehicle\lane_sequence_predictor.h" startLine="(46, 2)" endLine="(46, 45)" clone_start="1" clone_end="1">
			<code function_name="~LaneSequencePredictor()">  virtual ~LaneSequencePredictor() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\vehicle\free_move_predictor.h" startLine="(43, 2)" endLine="(43, 41)" clone_start="1" clone_end="1">
			<code function_name="~FreeMovePredictor()">  virtual ~FreeMovePredictor() = default;</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\can_comm\can_sender.cc" startLine="(180, 0)" endLine="(193, 1)" clone_start="3" clone_end="13">
			<code function_name="CanSender::Stop()">void CanSender::Stop() {
  if (is_running_) {
    AINFO &lt;&lt; "Stopping can sender ...";
    is_running_ = false;
    if (thread_ != nullptr &amp;&amp; thread_-&gt;joinable()) {
      thread_-&gt;join();
    }
    thread_.reset();
  } else {
    AERROR &lt;&lt; "CanSender is not running.";
  }

  AINFO &lt;&lt; "Can client sender stopped [ok].";
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\can_comm\can_receiver.cc" startLine="(118, 0)" endLine="(130, 1)" clone_start="3" clone_end="12">
			<code function_name="CanReceiver::Stop()">void CanReceiver::Stop() {
  if (IsRunning()) {
    AINFO &lt;&lt; "Stopping can client receiver ...";
    is_running_ = false;
    if (thread_ != nullptr &amp;&amp; thread_-&gt;joinable()) {
      thread_-&gt;join();
    }
    thread_.reset();
  } else {
    AINFO &lt;&lt; "Can client receiver is not running.";
  }
  AINFO &lt;&lt; "Can client receiver stopped [ok].";
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\stream_nodelet.cpp" startLine="(47, 0)" endLine="(74, 1)" clone_start="3" clone_end="13">
			<code function_name="StreamNodelet::onInit()">void StreamNodelet::onInit() {
  ros::NodeHandle&amp; nh = getPrivateNodeHandle();
  std::string gnss_conf;
  std::string raw_data_topic;
  std::string rtcm_data_topic;
  std::string stream_status_topic;

  nh.param("gnss_conf", gnss_conf, std::string("./conf/gnss_conf.txt"));
  nh.param("raw_data_topic", raw_data_topic,
           std::string("/apollo/sensor/gnss/raw_data"));
  nh.param("rtcm_data_topic", rtcm_data_topic,
           std::string("/apollo/sensor/gnss/rtcm_data"));
  nh.param("stream_status_topic", stream_status_topic,
           std::string("/apollo/sensor/gnss/stream_status"));

  ROS_INFO_STREAM("gnss conf: " &lt;&lt; gnss_conf);
  ROS_INFO_STREAM("raw data topic: " &lt;&lt; raw_data_topic);

  init_signal();
  _raw_stream.reset(new RawStream(nh, getName(), raw_data_topic,
                                  rtcm_data_topic, stream_status_topic));
  if (!_raw_stream-&gt;init(gnss_conf)) {
    ROS_ERROR("Init stream nodelet failed.");
    ROS_ERROR_STREAM("Init stream nodelet failed.");
    return;
  }
  ROS_INFO("Init stream nodelet success.");
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\parser_nodelet.cpp" startLine="(39, 0)" endLine="(72, 1)" clone_start="6" clone_end="16">
			<code function_name="ParserNodelet::onInit()">void ParserNodelet::onInit() {
  ros::NodeHandle&amp; nh = getPrivateNodeHandle();
  std::string gnss_conf;
  std::string raw_data_topic;
  std::string ins_stat_topic;
  std::string corr_imu_topic;
  std::string odometry_topic;
  std::string gnss_status_topic;
  std::string ins_status_topic;

  nh.param("gnss_conf", gnss_conf, std::string("./conf/gnss_conf.txt"));
  nh.param("raw_data_topic", raw_data_topic,
           std::string("/apollo/sensor/gnss/raw_data"));
  nh.param("ins_stat_topic", ins_stat_topic,
           std::string("/apollo/sensor/gnss/ins_stat"));
  nh.param("corr_imu_topic", corr_imu_topic,
           std::string("/apollo/sensor/gnss/corrected_imu"));
  nh.param("odometry_topic", odometry_topic,
           std::string("/apollo/sensor/gnss/odometry"));
  nh.param("gnss_status_topic", gnss_status_topic,
           std::string("/apollo/sensor/gnss/gnss_status"));
  nh.param("ins_status_topic", ins_status_topic,
           std::string("/apollo/sensor/gnss/ins_status"));

  _data_parser.reset(new DataParser(nh, raw_data_topic, ins_stat_topic,
                                    corr_imu_topic, odometry_topic,
                                    gnss_status_topic, ins_status_topic));
  if (!_data_parser-&gt;init(gnss_conf)) {
    ROS_ERROR("Init parser nodelet failed.");
    ROS_ERROR_STREAM("Init parser nodelet failed.");
    return;
  }
  ROS_INFO("Init parser nodelet success.");
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(153, 0)" endLine="(193, 1)" clone_start="33" clone_end="41">
			<code function_name="ProtoOrganizer::GetLaneSignalOverlapElements(    const std::string&amp; lane_id, const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes)">void ProtoOrganizer::GetLaneSignalOverlapElements(
    const std::string&amp; lane_id,
    const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes) {
  for (auto&amp; overlap_signal : overlap_with_lanes) {
    std::string object_id = overlap_signal.object_id;
    if (proto_data_.pb_signals.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_stop_signs.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_yield_signs.count(object_id) &lt;= 0) {
      AINFO &lt;&lt; "cannot find signal object_id:" &lt;&lt; object_id;
      continue;
    }
    PbOverlap overlap;
    std::string overlap_id = CreateOverlapId();
    proto_data_.pb_lanes[lane_id].add_overlap_id()-&gt;set_id(overlap_id);
    overlap.mutable_id()-&gt;set_id(overlap_id);
    PbObjectOverlapInfo* object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(lane_id);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_start_s(
        overlap_signal.start_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_end_s(
        overlap_signal.end_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_is_merge(
        overlap_signal.is_merge);
    object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
    if (proto_data_.pb_signals.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_signal_overlap_info();
      proto_data_.pb_signals[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    } else if (proto_data_.pb_stop_signs.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_stop_sign_overlap_info();
      proto_data_.pb_stop_signs[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    } else if (proto_data_.pb_yield_signs.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_yield_sign_overlap_info();
      proto_data_.pb_yield_signs[object_id].add_overlap_id()-&gt;set_id(
          overlap_id);
    } else {
      AERROR &lt;&lt; "unknown signal, signal id:" &lt;&lt; object_id;
    }
    proto_data_.pb_overlaps[overlap_id] = overlap;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(111, 0)" endLine="(151, 1)" clone_start="33" clone_end="41">
			<code function_name="ProtoOrganizer::GetLaneObjectOverlapElements(const std::string&amp; lane_id, const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes)">void ProtoOrganizer::GetLaneObjectOverlapElements(
    const std::string&amp; lane_id,
    const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes) {
  for (auto&amp; overlap_object : overlap_with_lanes) {
    std::string object_id = overlap_object.object_id;
    if (proto_data_.pb_crosswalks.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_clear_areas.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_speed_bumps.count(object_id) &lt;= 0) {
      continue;
    }
    PbOverlap overlap;
    std::string overlap_id = CreateOverlapId();
    proto_data_.pb_lanes[lane_id].add_overlap_id()-&gt;set_id(overlap_id);
    overlap.mutable_id()-&gt;set_id(overlap_id);
    PbObjectOverlapInfo* object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(lane_id);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_start_s(
        overlap_object.start_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_end_s(
        overlap_object.end_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_is_merge(
        overlap_object.is_merge);
    object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
    if (proto_data_.pb_crosswalks.count(object_id) &gt; 0) {
      proto_data_.pb_crosswalks[object_id].add_overlap_id()-&gt;set_id(overlap_id);
      object_overlap-&gt;mutable_crosswalk_overlap_info();
    } else if (proto_data_.pb_clear_areas.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_clear_area_overlap_info();
      proto_data_.pb_clear_areas[object_id].add_overlap_id()-&gt;set_id(
          overlap_id);
    } else if (proto_data_.pb_speed_bumps.count(object_id)) {
      object_overlap-&gt;mutable_speed_bump_overlap_info();
      proto_data_.pb_speed_bumps[object_id].add_overlap_id()-&gt;set_id(
          overlap_id);
    } else {
      AERROR &lt;&lt; "unknown object, object id:" &lt;&lt; object_id;
    }
    proto_data_.pb_overlaps[overlap_id] = overlap;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(195, 0)" endLine="(226, 1)" clone_start="1" clone_end="5">
			<code function_name="ProtoOrganizer::GetLaneJunctionOverlapElements(    const std::string&amp; lane_id, const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes)">void ProtoOrganizer::GetLaneJunctionOverlapElements(
    const std::string&amp; lane_id,
    const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes) {
  for (auto&amp; overlap_junction : overlap_with_lanes) {
    std::string object_id = overlap_junction.object_id;
    if (proto_data_.pb_junctions.count(object_id) &lt;= 0) {
      AINFO &lt;&lt; "cannot find junction object " &lt;&lt; object_id;
      continue;
    }
    PbOverlap overlap;
    std::string overlap_id = CreateOverlapId();
    proto_data_.pb_lanes[lane_id].add_overlap_id()-&gt;set_id(overlap_id);
    overlap.mutable_id()-&gt;set_id(overlap_id);
    PbObjectOverlapInfo* object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(lane_id);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_start_s(
        overlap_junction.start_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_end_s(
        overlap_junction.end_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_is_merge(
        overlap_junction.is_merge);
    object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
    if (proto_data_.pb_junctions.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_junction_overlap_info();
      proto_data_.pb_junctions[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    } else {
      AERROR &lt;&lt; "unknown junction overlap, id:" &lt;&lt; object_id;
    }
    proto_data_.pb_overlaps[overlap_id] = overlap;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(153, 0)" endLine="(193, 1)" clone_start="1" clone_end="5">
			<code function_name="ProtoOrganizer::GetLaneSignalOverlapElements(    const std::string&amp; lane_id, const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes)">void ProtoOrganizer::GetLaneSignalOverlapElements(
    const std::string&amp; lane_id,
    const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes) {
  for (auto&amp; overlap_signal : overlap_with_lanes) {
    std::string object_id = overlap_signal.object_id;
    if (proto_data_.pb_signals.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_stop_signs.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_yield_signs.count(object_id) &lt;= 0) {
      AINFO &lt;&lt; "cannot find signal object_id:" &lt;&lt; object_id;
      continue;
    }
    PbOverlap overlap;
    std::string overlap_id = CreateOverlapId();
    proto_data_.pb_lanes[lane_id].add_overlap_id()-&gt;set_id(overlap_id);
    overlap.mutable_id()-&gt;set_id(overlap_id);
    PbObjectOverlapInfo* object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(lane_id);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_start_s(
        overlap_signal.start_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_end_s(
        overlap_signal.end_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_is_merge(
        overlap_signal.is_merge);
    object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
    if (proto_data_.pb_signals.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_signal_overlap_info();
      proto_data_.pb_signals[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    } else if (proto_data_.pb_stop_signs.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_stop_sign_overlap_info();
      proto_data_.pb_stop_signs[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    } else if (proto_data_.pb_yield_signs.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_yield_sign_overlap_info();
      proto_data_.pb_yield_signs[object_id].add_overlap_id()-&gt;set_id(
          overlap_id);
    } else {
      AERROR &lt;&lt; "unknown signal, signal id:" &lt;&lt; object_id;
    }
    proto_data_.pb_overlaps[overlap_id] = overlap;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\dp_st_speed\dp_st_graph.cc" startLine="(381, 0)" endLine="(489, 1)" clone_start="84" clone_end="95">
			<code function_name="DpStGraph::MakeObjectDecision(const SpeedData&amp; speed_profile, PathDecision* const path_decision) const">Status DpStGraph::MakeObjectDecision(const SpeedData&amp; speed_profile,
                                     PathDecision* const path_decision) const {
  if (speed_profile.speed_vector().size() &lt; 2) {
    const std::string msg = "dp_st_graph failed to get speed profile.";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  for (const auto&amp; boundary : st_graph_data_.st_boundaries()) {
    if (boundary.max_s() &lt; 0.0 || boundary.max_t() &lt; 0.0) {
      continue;
    }

    auto* path_obstacle = path_decision-&gt;Find(boundary.id());
    CHECK(path_obstacle) &lt;&lt; "Failed to find obstacle " &lt;&lt; boundary.id();
    if (path_obstacle-&gt;HasLongitudinalDecision()) {
      continue;
    }

    double start_t = boundary.min_t();
    double end_t = boundary.max_t();

    bool go_down = true;
    for (const auto&amp; speed_point : speed_profile.speed_vector()) {
      if (speed_point.t() &lt; start_t) {
        continue;
      }
      if (speed_point.t() &gt; end_t) {
        break;
      }

      STPoint st_point(speed_point.s(), speed_point.t());
      if (boundary.IsPointInBoundary(st_point)) {
        const std::string msg =
            "dp_st_graph failed: speed profile cross st_boundaries.";
        AERROR &lt;&lt; msg;
        return Status(ErrorCode::PLANNING_ERROR, msg);
      }

      double s_upper = dp_st_speed_config_.total_path_length();
      double s_lower = 0.0;
      if (boundary.GetBoundarySRange(speed_point.t(), &amp;s_upper, &amp;s_lower)) {
        if (s_lower &gt; speed_point.s()) {
          go_down = true;
        } else if (s_upper &lt; speed_point.s()) {
          go_down = false;
        }
      }
    }
    if (go_down) {
      if (CheckIsFollowByT(boundary)) {
        // FOLLOW decision
        ObjectDecisionType follow_decision;
        if (!CreateFollowDecision(*path_obstacle, boundary, &amp;follow_decision)) {
          AERROR &lt;&lt; "Failed to create follow decision for boundary with id "
                 &lt;&lt; boundary.id();
          return Status(ErrorCode::PLANNING_ERROR,
                        "faind to create follow decision");
        }
        if (!path_decision-&gt;AddLongitudinalDecision(
                "dp_st_graph", boundary.id(), follow_decision)) {
          AERROR &lt;&lt; "Failed to add follow decision to object " &lt;&lt; boundary.id();
          return Status(ErrorCode::PLANNING_ERROR,
                        "faind to add follow decision");
        }
      } else {
        // YIELD decision
        ObjectDecisionType yield_decision;
        if (!CreateYieldDecision(boundary, &amp;yield_decision)) {
          AERROR &lt;&lt; "Failed to create yield decision for boundary with id "
                 &lt;&lt; boundary.id();
          return Status(ErrorCode::PLANNING_ERROR,
                        "faind to create yield decision");
        }
        if (!path_decision-&gt;AddLongitudinalDecision(
                "dp_st_graph", boundary.id(), yield_decision)) {
          AERROR &lt;&lt; "Failed to add yield decision to object " &lt;&lt; boundary.id();
          return Status(ErrorCode::PLANNING_ERROR,
                        "faind to add yield decision");
        }
      }
    } else {
      // OVERTAKE decision
      ObjectDecisionType overtake_decision;
      if (!CreateOvertakeDecision(*path_obstacle, boundary,
                                  &amp;overtake_decision)) {
        AERROR &lt;&lt; "Failed to create overtake decision for boundary with id "
               &lt;&lt; boundary.id();
        return Status(ErrorCode::PLANNING_ERROR,
                      "faind to create overtake decision");
      }
      if (!path_decision-&gt;AddLongitudinalDecision("dp_st_graph", boundary.id(),
                                                  overtake_decision)) {
        AERROR &lt;&lt; "Failed to add overtake decision to object " &lt;&lt; boundary.id();
        return Status(ErrorCode::PLANNING_ERROR,
                      "faind to add overtake decision");
      }
    }
  }
  for (const auto* path_obstacle : path_decision-&gt;path_obstacles().Items()) {
    if (!path_obstacle-&gt;HasLongitudinalDecision()) {
      ObjectDecisionType ignore_decision;
      ignore_decision.mutable_ignore();
      path_decision-&gt;AddLongitudinalDecision("dp_st_graph", path_obstacle-&gt;Id(),
                                             ignore_decision);
    }
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\dp_st_speed\dp_st_graph.cc" startLine="(381, 0)" endLine="(489, 1)" clone_start="53" clone_end="63">
			<code function_name="DpStGraph::MakeObjectDecision(const SpeedData&amp; speed_profile, PathDecision* const path_decision) const">Status DpStGraph::MakeObjectDecision(const SpeedData&amp; speed_profile,
                                     PathDecision* const path_decision) const {
  if (speed_profile.speed_vector().size() &lt; 2) {
    const std::string msg = "dp_st_graph failed to get speed profile.";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  for (const auto&amp; boundary : st_graph_data_.st_boundaries()) {
    if (boundary.max_s() &lt; 0.0 || boundary.max_t() &lt; 0.0) {
      continue;
    }

    auto* path_obstacle = path_decision-&gt;Find(boundary.id());
    CHECK(path_obstacle) &lt;&lt; "Failed to find obstacle " &lt;&lt; boundary.id();
    if (path_obstacle-&gt;HasLongitudinalDecision()) {
      continue;
    }

    double start_t = boundary.min_t();
    double end_t = boundary.max_t();

    bool go_down = true;
    for (const auto&amp; speed_point : speed_profile.speed_vector()) {
      if (speed_point.t() &lt; start_t) {
        continue;
      }
      if (speed_point.t() &gt; end_t) {
        break;
      }

      STPoint st_point(speed_point.s(), speed_point.t());
      if (boundary.IsPointInBoundary(st_point)) {
        const std::string msg =
            "dp_st_graph failed: speed profile cross st_boundaries.";
        AERROR &lt;&lt; msg;
        return Status(ErrorCode::PLANNING_ERROR, msg);
      }

      double s_upper = dp_st_speed_config_.total_path_length();
      double s_lower = 0.0;
      if (boundary.GetBoundarySRange(speed_point.t(), &amp;s_upper, &amp;s_lower)) {
        if (s_lower &gt; speed_point.s()) {
          go_down = true;
        } else if (s_upper &lt; speed_point.s()) {
          go_down = false;
        }
      }
    }
    if (go_down) {
      if (CheckIsFollowByT(boundary)) {
        // FOLLOW decision
        ObjectDecisionType follow_decision;
        if (!CreateFollowDecision(*path_obstacle, boundary, &amp;follow_decision)) {
          AERROR &lt;&lt; "Failed to create follow decision for boundary with id "
                 &lt;&lt; boundary.id();
          return Status(ErrorCode::PLANNING_ERROR,
                        "faind to create follow decision");
        }
        if (!path_decision-&gt;AddLongitudinalDecision(
                "dp_st_graph", boundary.id(), follow_decision)) {
          AERROR &lt;&lt; "Failed to add follow decision to object " &lt;&lt; boundary.id();
          return Status(ErrorCode::PLANNING_ERROR,
                        "faind to add follow decision");
        }
      } else {
        // YIELD decision
        ObjectDecisionType yield_decision;
        if (!CreateYieldDecision(boundary, &amp;yield_decision)) {
          AERROR &lt;&lt; "Failed to create yield decision for boundary with id "
                 &lt;&lt; boundary.id();
          return Status(ErrorCode::PLANNING_ERROR,
                        "faind to create yield decision");
        }
        if (!path_decision-&gt;AddLongitudinalDecision(
                "dp_st_graph", boundary.id(), yield_decision)) {
          AERROR &lt;&lt; "Failed to add yield decision to object " &lt;&lt; boundary.id();
          return Status(ErrorCode::PLANNING_ERROR,
                        "faind to add yield decision");
        }
      }
    } else {
      // OVERTAKE decision
      ObjectDecisionType overtake_decision;
      if (!CreateOvertakeDecision(*path_obstacle, boundary,
                                  &amp;overtake_decision)) {
        AERROR &lt;&lt; "Failed to create overtake decision for boundary with id "
               &lt;&lt; boundary.id();
        return Status(ErrorCode::PLANNING_ERROR,
                      "faind to create overtake decision");
      }
      if (!path_decision-&gt;AddLongitudinalDecision("dp_st_graph", boundary.id(),
                                                  overtake_decision)) {
        AERROR &lt;&lt; "Failed to add overtake decision to object " &lt;&lt; boundary.id();
        return Status(ErrorCode::PLANNING_ERROR,
                      "faind to add overtake decision");
      }
    }
  }
  for (const auto* path_obstacle : path_decision-&gt;path_obstacles().Items()) {
    if (!path_obstacle-&gt;HasLongitudinalDecision()) {
      ObjectDecisionType ignore_decision;
      ignore_decision.mutable_ignore();
      path_decision-&gt;AddLongitudinalDecision("dp_st_graph", path_obstacle-&gt;Id(),
                                             ignore_decision);
    }
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(267, 0)" endLine="(280, 1)" clone_start="1" clone_end="8">
			<code function_name="Spline1dConstraint::AddPointConstraint(const double x, const double fx)">bool Spline1dConstraint::AddPointConstraint(const double x, const double fx) {
  std::uint32_t index = FindIndex(x);
  std::vector&lt;double&gt; power_x;
  GeneratePowerX(x - x_knots_[index], spline_order_, &amp;power_x);
  Eigen::MatrixXd equality_constraint =
      Eigen::MatrixXd::Zero(1, (x_knots_.size() - 1) * spline_order_);
  std::uint32_t index_offset = index * spline_order_;
  for (std::uint32_t i = 0; i &lt; spline_order_; ++i) {
    equality_constraint(0, index_offset + i) = power_x[i];
  }
  Eigen::MatrixXd equality_boundary(1, 1);
  equality_boundary(0, 0) = fx;
  return AddEqualityConstraint(equality_constraint, equality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(314, 0)" endLine="(329, 1)" clone_start="1" clone_end="9">
			<code function_name="Spline1dConstraint::AddPointThirdDerivativeConstraint(const double x, const double dddfx)">bool Spline1dConstraint::AddPointThirdDerivativeConstraint(const double x,
                                                           const double dddfx) {
  std::uint32_t index = FindIndex(x);
  std::vector&lt;double&gt; power_x;
  GeneratePowerX(x - x_knots_[index], spline_order_, &amp;power_x);
  Eigen::MatrixXd equality_constraint =
      Eigen::MatrixXd::Zero(1, (x_knots_.size() - 1) * spline_order_);
  std::uint32_t index_offset = index * spline_order_;
  for (std::uint32_t i = 3; i &lt; spline_order_; ++i) {
    equality_constraint(0, index_offset + i) =
        power_x[i - 3] * i * (i - 1) * (i - 2);
  }
  Eigen::MatrixXd equality_boundary(1, 1);
  equality_boundary(0, 0) = dddfx;
  return AddEqualityConstraint(equality_constraint, equality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(298, 0)" endLine="(312, 1)" clone_start="1" clone_end="9">
			<code function_name="Spline1dConstraint::AddPointSecondDerivativeConstraint(const double x, const double ddfx)">bool Spline1dConstraint::AddPointSecondDerivativeConstraint(const double x,
                                                            const double ddfx) {
  std::uint32_t index = FindIndex(x);
  std::vector&lt;double&gt; power_x;
  GeneratePowerX(x - x_knots_[index], spline_order_, &amp;power_x);
  Eigen::MatrixXd equality_constraint =
      Eigen::MatrixXd::Zero(1, (x_knots_.size() - 1) * spline_order_);
  std::uint32_t index_offset = index * spline_order_;
  for (std::uint32_t i = 2; i &lt; spline_order_; ++i) {
    equality_constraint(0, index_offset + i) = power_x[i - 2] * i * (i - 1);
  }
  Eigen::MatrixXd equality_boundary(1, 1);
  equality_boundary(0, 0) = ddfx;
  return AddEqualityConstraint(equality_constraint, equality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(282, 0)" endLine="(296, 1)" clone_start="1" clone_end="9">
			<code function_name="Spline1dConstraint::AddPointDerivativeConstraint(const double x, const double dfx)">bool Spline1dConstraint::AddPointDerivativeConstraint(const double x,
                                                      const double dfx) {
  std::uint32_t index = FindIndex(x);
  std::vector&lt;double&gt; power_x;
  GeneratePowerX(x - x_knots_[index], spline_order_, &amp;power_x);
  Eigen::MatrixXd equality_constraint =
      Eigen::MatrixXd::Zero(1, (x_knots_.size() - 1) * spline_order_);
  std::uint32_t index_offset = index * spline_order_;
  for (std::uint32_t i = 1; i &lt; spline_order_; ++i) {
    equality_constraint(0, index_offset + i) = power_x[i - 1] * i;
  }
  Eigen::MatrixXd equality_boundary(1, 1);
  equality_boundary(0, 0) = dfx;
  return AddEqualityConstraint(equality_constraint, equality_boundary);
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(131, 0)" endLine="(135, 1)" clone_start="3" clone_end="5">
			<code function_name="Steering64::set_watchdog_counter_p(uint8_t *data, int32_t count)">void Steering64::set_watchdog_counter_p(uint8_t *data, int32_t count) {
  count = ProtocolData::BoundedValue(0, 255, count);
  Byte frame(data + 7);
  frame.set_value(count, 0, 8);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(76, 0)" endLine="(94, 1)" clone_start="17" clone_end="19">
			<code function_name="Steering64::set_steering_angle_p(uint8_t *data, double angle)">void Steering64::set_steering_angle_p(uint8_t *data, double angle) {
  angle = ProtocolData::BoundedValue(-470.0, 470.0, angle);
  int32_t x = angle / 0.100000;

  // add offset
  if (x &lt; 0) {
    x += 0x10000;
  }

  std::uint8_t t = 0;
  t = x &amp; 0xFF;  // low
  Byte frame_low(data + 0);
  frame_low.set_value(t, 0, 8);

  x &gt;&gt;= 8;  // high
  t = x &amp; 0xFF;
  Byte frame_high(data + 1);
  frame_high.set_value(t, 0, 8);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(66, 0)" endLine="(82, 1)" clone_start="15" clone_end="17">
			<code function_name="Throttle62::set_pedal_p(uint8_t *data, double pedal)">void Throttle62::set_pedal_p(uint8_t *data, double pedal) {
  // change from [0-100] to [0.00-1.00]
  // and a rough mapping
  pedal /= 100.0;
  pedal = ProtocolData::BoundedValue(0.0, 1.0, pedal);
  int32_t x = pedal / 1.52590218966964e-05;
  std::uint8_t t = 0;

  t = x &amp; 0xFF;
  Byte frame_low(data + 0);
  frame_low.set_value(t, 0, 8);

  x &gt;&gt;= 8;
  t = x &amp; 0xFF;
  Byte frame_high(data + 1);
  frame_high.set_value(t, 0, 8);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(79, 0)" endLine="(95, 1)" clone_start="15" clone_end="17">
			<code function_name="Brake60::set_pedal_p(uint8_t *data, double pedal)">void Brake60::set_pedal_p(uint8_t *data, double pedal) {
  // change from [0-100] to [0.00-1.00]
  // and a rough mapping
  pedal /= 100.;
  pedal = ProtocolData::BoundedValue(0.0, 1.0, pedal);
  int32_t x = pedal / 1.52590218966964e-05;
  std::uint8_t t = 0;

  t = x &amp; 0xFF;
  Byte frame_low(data + 0);
  frame_low.set_value(t, 0, 8);

  x &gt;&gt;= 8;
  t = x &amp; 0xFF;
  Byte frame_high(data + 1);
  frame_high.set_value(t, 0, 8);
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(137, 0)" endLine="(144, 1)" clone_start="1" clone_end="6">
			<code function_name="Steering64::set_disable_audible_warning_p(uint8_t *data, bool disable)">void Steering64::set_disable_audible_warning_p(uint8_t *data, bool disable) {
  Byte frame(data + 2);
  if (disable) {
    frame.set_bit_1(4);
  } else {
    frame.set_bit_0(4);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(96, 0)" endLine="(103, 1)" clone_start="1" clone_end="6">
			<code function_name="Steering64::set_enable_p(uint8_t *bytes, bool enable)">void Steering64::set_enable_p(uint8_t *bytes, bool enable) {
  Byte frame(bytes + 2);
  if (enable) {
    frame.set_bit_1(0);
  } else {
    frame.set_bit_0(0);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(84, 0)" endLine="(91, 1)" clone_start="1" clone_end="6">
			<code function_name="Throttle62::set_enable_p(uint8_t *bytes, bool enable)">void Throttle62::set_enable_p(uint8_t *bytes, bool enable) {
  Byte frame(bytes + 3);
  if (enable) {
    frame.set_bit_1(0);
  } else {
    frame.set_bit_0(0);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(97, 0)" endLine="(104, 1)" clone_start="1" clone_end="6">
			<code function_name="Brake60::set_boo_cmd_p(uint8_t *bytes, bool boo_cmd)">void Brake60::set_boo_cmd_p(uint8_t *bytes, bool boo_cmd) {
  Byte frame(bytes + 2);
  if (boo_cmd) {
    frame.set_bit_1(0);
  } else {
    frame.set_bit_0(0);
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\dp_st_speed\dp_st_graph.cc" startLine="(381, 0)" endLine="(489, 1)" clone_start="55" clone_end="68">
			<code function_name="DpStGraph::MakeObjectDecision(const SpeedData&amp; speed_profile, PathDecision* const path_decision) const">Status DpStGraph::MakeObjectDecision(const SpeedData&amp; speed_profile,
                                     PathDecision* const path_decision) const {
  if (speed_profile.speed_vector().size() &lt; 2) {
    const std::string msg = "dp_st_graph failed to get speed profile.";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  for (const auto&amp; boundary : st_graph_data_.st_boundaries()) {
    if (boundary.max_s() &lt; 0.0 || boundary.max_t() &lt; 0.0) {
      continue;
    }

    auto* path_obstacle = path_decision-&gt;Find(boundary.id());
    CHECK(path_obstacle) &lt;&lt; "Failed to find obstacle " &lt;&lt; boundary.id();
    if (path_obstacle-&gt;HasLongitudinalDecision()) {
      continue;
    }

    double start_t = boundary.min_t();
    double end_t = boundary.max_t();

    bool go_down = true;
    for (const auto&amp; speed_point : speed_profile.speed_vector()) {
      if (speed_point.t() &lt; start_t) {
        continue;
      }
      if (speed_point.t() &gt; end_t) {
        break;
      }

      STPoint st_point(speed_point.s(), speed_point.t());
      if (boundary.IsPointInBoundary(st_point)) {
        const std::string msg =
            "dp_st_graph failed: speed profile cross st_boundaries.";
        AERROR &lt;&lt; msg;
        return Status(ErrorCode::PLANNING_ERROR, msg);
      }

      double s_upper = dp_st_speed_config_.total_path_length();
      double s_lower = 0.0;
      if (boundary.GetBoundarySRange(speed_point.t(), &amp;s_upper, &amp;s_lower)) {
        if (s_lower &gt; speed_point.s()) {
          go_down = true;
        } else if (s_upper &lt; speed_point.s()) {
          go_down = false;
        }
      }
    }
    if (go_down) {
      if (CheckIsFollowByT(boundary)) {
        // FOLLOW decision
        ObjectDecisionType follow_decision;
        if (!CreateFollowDecision(*path_obstacle, boundary, &amp;follow_decision)) {
          AERROR &lt;&lt; "Failed to create follow decision for boundary with id "
                 &lt;&lt; boundary.id();
          return Status(ErrorCode::PLANNING_ERROR,
                        "faind to create follow decision");
        }
        if (!path_decision-&gt;AddLongitudinalDecision(
                "dp_st_graph", boundary.id(), follow_decision)) {
          AERROR &lt;&lt; "Failed to add follow decision to object " &lt;&lt; boundary.id();
          return Status(ErrorCode::PLANNING_ERROR,
                        "faind to add follow decision");
        }
      } else {
        // YIELD decision
        ObjectDecisionType yield_decision;
        if (!CreateYieldDecision(boundary, &amp;yield_decision)) {
          AERROR &lt;&lt; "Failed to create yield decision for boundary with id "
                 &lt;&lt; boundary.id();
          return Status(ErrorCode::PLANNING_ERROR,
                        "faind to create yield decision");
        }
        if (!path_decision-&gt;AddLongitudinalDecision(
                "dp_st_graph", boundary.id(), yield_decision)) {
          AERROR &lt;&lt; "Failed to add yield decision to object " &lt;&lt; boundary.id();
          return Status(ErrorCode::PLANNING_ERROR,
                        "faind to add yield decision");
        }
      }
    } else {
      // OVERTAKE decision
      ObjectDecisionType overtake_decision;
      if (!CreateOvertakeDecision(*path_obstacle, boundary,
                                  &amp;overtake_decision)) {
        AERROR &lt;&lt; "Failed to create overtake decision for boundary with id "
               &lt;&lt; boundary.id();
        return Status(ErrorCode::PLANNING_ERROR,
                      "faind to create overtake decision");
      }
      if (!path_decision-&gt;AddLongitudinalDecision("dp_st_graph", boundary.id(),
                                                  overtake_decision)) {
        AERROR &lt;&lt; "Failed to add overtake decision to object " &lt;&lt; boundary.id();
        return Status(ErrorCode::PLANNING_ERROR,
                      "faind to add overtake decision");
      }
    }
  }
  for (const auto* path_obstacle : path_decision-&gt;path_obstacles().Items()) {
    if (!path_obstacle-&gt;HasLongitudinalDecision()) {
      ObjectDecisionType ignore_decision;
      ignore_decision.mutable_ignore();
      path_decision-&gt;AddLongitudinalDecision("dp_st_graph", path_obstacle-&gt;Id(),
                                             ignore_decision);
    }
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\dp_st_speed\dp_st_graph.cc" startLine="(381, 0)" endLine="(489, 1)" clone_start="70" clone_end="84">
			<code function_name="DpStGraph::MakeObjectDecision(const SpeedData&amp; speed_profile, PathDecision* const path_decision) const">Status DpStGraph::MakeObjectDecision(const SpeedData&amp; speed_profile,
                                     PathDecision* const path_decision) const {
  if (speed_profile.speed_vector().size() &lt; 2) {
    const std::string msg = "dp_st_graph failed to get speed profile.";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  for (const auto&amp; boundary : st_graph_data_.st_boundaries()) {
    if (boundary.max_s() &lt; 0.0 || boundary.max_t() &lt; 0.0) {
      continue;
    }

    auto* path_obstacle = path_decision-&gt;Find(boundary.id());
    CHECK(path_obstacle) &lt;&lt; "Failed to find obstacle " &lt;&lt; boundary.id();
    if (path_obstacle-&gt;HasLongitudinalDecision()) {
      continue;
    }

    double start_t = boundary.min_t();
    double end_t = boundary.max_t();

    bool go_down = true;
    for (const auto&amp; speed_point : speed_profile.speed_vector()) {
      if (speed_point.t() &lt; start_t) {
        continue;
      }
      if (speed_point.t() &gt; end_t) {
        break;
      }

      STPoint st_point(speed_point.s(), speed_point.t());
      if (boundary.IsPointInBoundary(st_point)) {
        const std::string msg =
            "dp_st_graph failed: speed profile cross st_boundaries.";
        AERROR &lt;&lt; msg;
        return Status(ErrorCode::PLANNING_ERROR, msg);
      }

      double s_upper = dp_st_speed_config_.total_path_length();
      double s_lower = 0.0;
      if (boundary.GetBoundarySRange(speed_point.t(), &amp;s_upper, &amp;s_lower)) {
        if (s_lower &gt; speed_point.s()) {
          go_down = true;
        } else if (s_upper &lt; speed_point.s()) {
          go_down = false;
        }
      }
    }
    if (go_down) {
      if (CheckIsFollowByT(boundary)) {
        // FOLLOW decision
        ObjectDecisionType follow_decision;
        if (!CreateFollowDecision(*path_obstacle, boundary, &amp;follow_decision)) {
          AERROR &lt;&lt; "Failed to create follow decision for boundary with id "
                 &lt;&lt; boundary.id();
          return Status(ErrorCode::PLANNING_ERROR,
                        "faind to create follow decision");
        }
        if (!path_decision-&gt;AddLongitudinalDecision(
                "dp_st_graph", boundary.id(), follow_decision)) {
          AERROR &lt;&lt; "Failed to add follow decision to object " &lt;&lt; boundary.id();
          return Status(ErrorCode::PLANNING_ERROR,
                        "faind to add follow decision");
        }
      } else {
        // YIELD decision
        ObjectDecisionType yield_decision;
        if (!CreateYieldDecision(boundary, &amp;yield_decision)) {
          AERROR &lt;&lt; "Failed to create yield decision for boundary with id "
                 &lt;&lt; boundary.id();
          return Status(ErrorCode::PLANNING_ERROR,
                        "faind to create yield decision");
        }
        if (!path_decision-&gt;AddLongitudinalDecision(
                "dp_st_graph", boundary.id(), yield_decision)) {
          AERROR &lt;&lt; "Failed to add yield decision to object " &lt;&lt; boundary.id();
          return Status(ErrorCode::PLANNING_ERROR,
                        "faind to add yield decision");
        }
      }
    } else {
      // OVERTAKE decision
      ObjectDecisionType overtake_decision;
      if (!CreateOvertakeDecision(*path_obstacle, boundary,
                                  &amp;overtake_decision)) {
        AERROR &lt;&lt; "Failed to create overtake decision for boundary with id "
               &lt;&lt; boundary.id();
        return Status(ErrorCode::PLANNING_ERROR,
                      "faind to create overtake decision");
      }
      if (!path_decision-&gt;AddLongitudinalDecision("dp_st_graph", boundary.id(),
                                                  overtake_decision)) {
        AERROR &lt;&lt; "Failed to add overtake decision to object " &lt;&lt; boundary.id();
        return Status(ErrorCode::PLANNING_ERROR,
                      "faind to add overtake decision");
      }
    }
  }
  for (const auto* path_obstacle : path_decision-&gt;path_obstacles().Items()) {
    if (!path_obstacle-&gt;HasLongitudinalDecision()) {
      ObjectDecisionType ignore_decision;
      ignore_decision.mutable_ignore();
      path_decision-&gt;AddLongitudinalDecision("dp_st_graph", path_obstacle-&gt;Id(),
                                             ignore_decision);
    }
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\core\black_list_range_generator.cc" startLine="(114, 0)" endLine="(125, 1)" clone_start="1" clone_end="10">
			<code function_name="AddBlackMapFromInParallel(const TopoNode* node, double cut_ratio, TopoRangeManager* const range_manager)">void AddBlackMapFromInParallel(const TopoNode* node, double cut_ratio,
                               TopoRangeManager* const range_manager) {
  std::unordered_set&lt;const TopoNode*&gt; par_node_set;
  GetInParallelLane(node, &amp;par_node_set);
  if (par_node_set.find(node) != par_node_set.end()) {
    par_node_set.erase(node);
  }
  for (const auto* par_node : par_node_set) {
    double par_cut_s = cut_ratio * par_node-&gt;Length();
    range_manager-&gt;Add(par_node, par_cut_s, par_cut_s);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\core\black_list_range_generator.cc" startLine="(101, 0)" endLine="(112, 1)" clone_start="1" clone_end="10">
			<code function_name="AddBlackMapFromOutParallel(const TopoNode* node, double cut_ratio, TopoRangeManager* const range_manager)">void AddBlackMapFromOutParallel(const TopoNode* node, double cut_ratio,
                                TopoRangeManager* const range_manager) {
  std::unordered_set&lt;const TopoNode*&gt; par_node_set;
  GetOutParallelLane(node, &amp;par_node_set);
  if (par_node_set.find(node) != par_node_set.end()) {
    par_node_set.erase(node);
  }
  for (const auto* par_node : par_node_set) {
    double par_cut_s = cut_ratio * par_node-&gt;Length();
    range_manager-&gt;Add(par_node, par_cut_s, par_cut_s);
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\reference_line\reference_line_provider.cc" startLine="(52, 0)" endLine="(60, 1)" clone_start="1" clone_end="9">
			<code function_name="ReferenceLineProvider::Start()">bool ReferenceLineProvider::Start() {
  if (!is_initialized_) {
    AERROR &lt;&lt; "ReferenceLineProvider has NOT been initiated.";
    return false;
  }
  const auto &amp;func = [this] { Generate(); };
  thread_.reset(new std::thread(func));
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(118, 0)" endLine="(127, 1)" clone_start="1" clone_end="10">
			<code function_name="LincolnController::Start()">bool LincolnController::Start() {
  if (!is_initialized_) {
    AERROR &lt;&lt; "LincolnController has NOT been initiated.";
    return false;
  }
  const auto &amp;update_func = [this] { SecurityDogThreadFunc(); };
  thread_.reset(new std::thread(update_func));

  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\reference_line\reference_line_provider.cc" startLine="(62, 0)" endLine="(67, 1)" clone_start="1" clone_end="1">
			<code function_name="ReferenceLineProvider::Stop()">void ReferenceLineProvider::Stop() {
  is_stop_ = true;
  if (thread_ &amp;&amp; thread_-&gt;joinable()) {
    thread_-&gt;join();
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(129, 0)" endLine="(140, 1)" clone_start="1" clone_end="1">
			<code function_name="LincolnController::Stop()">void LincolnController::Stop() {
  if (!is_initialized_) {
    AERROR &lt;&lt; "LincolnController stops or starts improperly!";
    return;
  }

  if (thread_ != nullptr &amp;&amp; thread_-&gt;joinable()) {
    thread_-&gt;join();
    thread_.reset();
    AINFO &lt;&lt; "LincolnController stopped.";
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(297, 0)" endLine="(318, 1)" clone_start="14" clone_end="22">
			<code function_name="LincolnController::EnableSteeringOnlyMode()">ErrorCode LincolnController::EnableSteeringOnlyMode() {
  if (driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
      driving_mode() == Chassis::AUTO_STEER_ONLY) {
    set_driving_mode(Chassis::AUTO_STEER_ONLY);
    AINFO &lt;&lt; "Already in AUTO_STEER_ONLY mode";
    return ErrorCode::OK;
  }
  brake_60_-&gt;set_disable();
  throttle_62_-&gt;set_disable();
  steering_64_-&gt;set_enable();

  can_sender_-&gt;Update();
  if (CheckResponse(CHECK_RESPONSE_STEER_UNIT_FLAG, true) == false) {
    AERROR &lt;&lt; "Failed to switch to AUTO_STEER_ONLY mode.";
    Emergency();
    return ErrorCode::CANBUS_ERROR;
  } else {
    set_driving_mode(Chassis::AUTO_STEER_ONLY);
    AINFO &lt;&lt; "Switch to AUTO_STEER_ONLY mode ok.";
    return ErrorCode::OK;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(265, 0)" endLine="(286, 1)" clone_start="14" clone_end="22">
			<code function_name="LincolnController::EnableAutoMode()">ErrorCode LincolnController::EnableAutoMode() {
  if (driving_mode() == Chassis::COMPLETE_AUTO_DRIVE) {
    AINFO &lt;&lt; "already in COMPLETE_AUTO_DRIVE mode";
    return ErrorCode::OK;
  }
  brake_60_-&gt;set_enable();
  throttle_62_-&gt;set_enable();
  steering_64_-&gt;set_enable();

  can_sender_-&gt;Update();
  const int32_t flag =
      CHECK_RESPONSE_STEER_UNIT_FLAG | CHECK_RESPONSE_SPEED_UNIT_FLAG;
  if (!CheckResponse(flag, true)) {
    AERROR &lt;&lt; "Failed to switch to COMPLETE_AUTO_DRIVE mode.";
    Emergency();
    return ErrorCode::CANBUS_ERROR;
  } else {
    set_driving_mode(Chassis::COMPLETE_AUTO_DRIVE);
    AINFO &lt;&lt; "Switch to COMPLETE_AUTO_DRIVE mode ok.";
    return ErrorCode::OK;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(320, 0)" endLine="(341, 1)" clone_start="1" clone_end="1">
			<code function_name="LincolnController::EnableSpeedOnlyMode()">ErrorCode LincolnController::EnableSpeedOnlyMode() {
  if (driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
      driving_mode() == Chassis::AUTO_SPEED_ONLY) {
    set_driving_mode(Chassis::AUTO_SPEED_ONLY);
    AINFO &lt;&lt; "Already in AUTO_SPEED_ONLY mode";
    return ErrorCode::OK;
  }
  brake_60_-&gt;set_enable();
  throttle_62_-&gt;set_enable();
  steering_64_-&gt;set_disable();

  can_sender_-&gt;Update();
  if (CheckResponse(CHECK_RESPONSE_SPEED_UNIT_FLAG, true) == false) {
    AERROR &lt;&lt; "Failed to switch to AUTO_STEER_ONLY mode.";
    Emergency();
    return ErrorCode::CANBUS_ERROR;
  } else {
    set_driving_mode(Chassis::AUTO_SPEED_ONLY);
    AINFO &lt;&lt; "Switch to AUTO_SPEED_ONLY mode ok.";
    return ErrorCode::OK;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(288, 0)" endLine="(295, 1)" clone_start="1" clone_end="1">
			<code function_name="LincolnController::DisableAutoMode()">ErrorCode LincolnController::DisableAutoMode() {
  ResetProtocol();
  can_sender_-&gt;Update();
  set_driving_mode(Chassis::COMPLETE_MANUAL);
  set_chassis_error_code(Chassis::NO_ERROR);
  AINFO &lt;&lt; "Switch to COMPLETE_MANUAL ok.";
  return ErrorCode::OK;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\curve1d\quintic_polynomial_curve1d.cc" startLine="(34, 0)" endLine="(45, 1)" clone_start="7" clone_end="12">
			<code function_name="QuinticPolynomialCurve1d::QuinticPolynomialCurve1d(const double x0, const double dx0, const double ddx0, const double x1, const double dx1, const double ddx1, const double param)">QuinticPolynomialCurve1d::QuinticPolynomialCurve1d(
    const double x0, const double dx0, const double ddx0, const double x1,
    const double dx1, const double ddx1, const double param)
    : param_(param) {
  compute_coefficients(x0, dx0, ddx0, x1, dx1, ddx1, param);
  start_condition_[0] = x0;
  start_condition_[1] = dx0;
  start_condition_[2] = ddx0;
  end_condition_[0] = x1;
  end_condition_[1] = dx1;
  end_condition_[2] = ddx1;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\curve1d\quartic_polynomial_curve1d.cc" startLine="(36, 0)" endLine="(45, 1)" clone_start="5" clone_end="10">
			<code function_name="QuarticPolynomialCurve1d::QuarticPolynomialCurve1d(const double x0, const double dx0, const double ddx0, const double dx1, const double ddx1, const double param)">QuarticPolynomialCurve1d::QuarticPolynomialCurve1d(
    const double x0, const double dx0, const double ddx0, const double dx1,
    const double ddx1, const double param) {
  compute_coefficients(x0, dx0, ddx0, dx1, ddx1, param);
  start_condition_[0] = x0;
  start_condition_[1] = dx0;
  start_condition_[2] = ddx0;
  end_condition_[0] = dx1;
  end_condition_[1] = ddx1;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\curve1d\quintic_polynomial_curve1d.cc" startLine="(47, 0)" endLine="(52, 1)" clone_start="1" clone_end="4">
			<code function_name="QuinticPolynomialCurve1d::QuinticPolynomialCurve1d( const QuinticPolynomialCurve1d&amp; other)">QuinticPolynomialCurve1d::QuinticPolynomialCurve1d(
    const QuinticPolynomialCurve1d&amp; other) {
  param_ = other.param_;
  coef_ = other.coef_;
  return;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\curve1d\quartic_polynomial_curve1d.cc" startLine="(47, 0)" endLine="(51, 1)" clone_start="1" clone_end="4">
			<code function_name="QuarticPolynomialCurve1d::QuarticPolynomialCurve1d( const QuarticPolynomialCurve1d&amp; other)">QuarticPolynomialCurve1d::QuarticPolynomialCurve1d(
    const QuarticPolynomialCurve1d&amp; other) {
  param_ = other.param_;
  coef_ = other.coef_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\tools\map_xysl.cc" startLine="(67, 2)" endLine="(71, 3)" clone_start="1" clone_end="5">
			<code function_name="get_signal(const std::string &amp;signal_id)">  const SignalInfo *get_signal(const std::string &amp;signal_id) {
    auto ret = HDMapUtil::BaseMap().GetSignalById(MakeMapId(signal_id));
    AERROR_IF(ret == nullptr) &lt;&lt; "failed to find overlap[" &lt;&lt; signal_id &lt;&lt; "]";
    return ret.get();
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\tools\map_xysl.cc" startLine="(61, 2)" endLine="(65, 3)" clone_start="1" clone_end="5">
			<code function_name="get_overlap(const std::string &amp;overlap_id)">  const OverlapInfo *get_overlap(const std::string &amp;overlap_id) {
    auto ret = HDMapUtil::BaseMap().GetOverlapById(MakeMapId(overlap_id));
    AERROR_IF(ret == nullptr) &lt;&lt; "failed to find overlap[" &lt;&lt; overlap_id &lt;&lt; "]";
    return ret.get();
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\tools\map_xysl.cc" startLine="(73, 2)" endLine="(77, 3)" clone_start="1" clone_end="4">
			<code function_name="get_lane(const std::string &amp;lane_id)">  const LaneInfo *get_lane(const std::string &amp;lane_id) {
    auto ret = HDMapUtil::BaseMap().GetLaneById(MakeMapId(lane_id));
    AERROR_IF(ret == nullptr) &lt;&lt; "failed to find lane[" &lt;&lt; lane_id &lt;&lt; "]";
    return ret.get();
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\tools\map_xysl.cc" startLine="(67, 2)" endLine="(71, 3)" clone_start="1" clone_end="4">
			<code function_name="get_signal(const std::string &amp;signal_id)">  const SignalInfo *get_signal(const std::string &amp;signal_id) {
    auto ret = HDMapUtil::BaseMap().GetSignalById(MakeMapId(signal_id));
    AERROR_IF(ret == nullptr) &lt;&lt; "failed to find overlap[" &lt;&lt; signal_id &lt;&lt; "]";
    return ret.get();
  }</code>
		</source>
	</dup>
	<dup count="6">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(243, 2)" endLine="(245, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; crosswalk_overlaps() const {
    return crosswalk_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(240, 2)" endLine="(242, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; stop_sign_overlaps() const {
    return stop_sign_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(237, 2)" endLine="(239, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; yield_sign_overlaps() const {
    return yield_sign_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(234, 2)" endLine="(236, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; signal_overlaps() const {
    return signal_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(231, 2)" endLine="(233, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; lane_overlaps() const {
    return lane_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(112, 2)" endLine="(114, 3)" clone_start="1" clone_end="3">
			<code function_name="id() const">  const std::vector&lt;OverlapInfoConstPtr&gt; &amp;yield_signs() const {
    return yield_signs_;
  }</code>
		</source>
	</dup>
	<dup count="6">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(246, 2)" endLine="(248, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; parking_space_overlaps() const {
    return parking_space_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(243, 2)" endLine="(245, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; crosswalk_overlaps() const {
    return crosswalk_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(240, 2)" endLine="(242, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; stop_sign_overlaps() const {
    return stop_sign_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(237, 2)" endLine="(239, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; yield_sign_overlaps() const {
    return yield_sign_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(234, 2)" endLine="(236, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; signal_overlaps() const {
    return signal_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(115, 2)" endLine="(117, 3)" clone_start="1" clone_end="3">
			<code function_name="id() const">  const std::vector&lt;OverlapInfoConstPtr&gt; &amp;stop_signs() const {
    return stop_signs_;
  }</code>
		</source>
	</dup>
	<dup count="6">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(249, 2)" endLine="(251, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; junction_overlaps() const {
    return junction_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(246, 2)" endLine="(248, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; parking_space_overlaps() const {
    return parking_space_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(243, 2)" endLine="(245, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; crosswalk_overlaps() const {
    return crosswalk_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(240, 2)" endLine="(242, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; stop_sign_overlaps() const {
    return stop_sign_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(237, 2)" endLine="(239, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; yield_sign_overlaps() const {
    return yield_sign_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(118, 2)" endLine="(120, 3)" clone_start="1" clone_end="3">
			<code function_name="id() const">  const std::vector&lt;OverlapInfoConstPtr&gt; &amp;crosswalks() const {
    return crosswalks_;
  }</code>
		</source>
	</dup>
	<dup count="6">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(252, 2)" endLine="(254, 3)" clone_start="1" clone_end="2">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; speed_bump_overlaps() const {
    return speed_bump_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(249, 2)" endLine="(251, 3)" clone_start="1" clone_end="2">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; junction_overlaps() const {
    return junction_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(246, 2)" endLine="(248, 3)" clone_start="1" clone_end="2">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; parking_space_overlaps() const {
    return parking_space_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(243, 2)" endLine="(245, 3)" clone_start="1" clone_end="2">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; crosswalk_overlaps() const {
    return crosswalk_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(240, 2)" endLine="(242, 3)" clone_start="1" clone_end="2">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; stop_sign_overlaps() const {
    return stop_sign_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(121, 2)" endLine="(123, 3)" clone_start="1" clone_end="2">
			<code function_name="id() const">  const std::vector&lt;OverlapInfoConstPtr&gt; &amp;junctions() const {
    return junctions_;
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\speed_optimizer.h" startLine="(38, 2)" endLine="(38, 38)" clone_start="1" clone_end="1">
			<code function_name="~SpeedOptimizer()">  virtual ~SpeedOptimizer() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\path_optimizer.h" startLine="(37, 2)" endLine="(37, 37)" clone_start="1" clone_end="1">
			<code function_name="~PathOptimizer()">  virtual ~PathOptimizer() = default;</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\qp_spline_path\qp_frenet_frame.cc" startLine="(227, 0)" endLine="(249, 1)" clone_start="4" clone_end="13">
			<code function_name="QpFrenetFrame::MapStaticObstacleWithDecision( const PathObstacle&amp; path_obstacle)">bool QpFrenetFrame::MapStaticObstacleWithDecision(
    const PathObstacle&amp; path_obstacle) {
  const auto ptr_obstacle = path_obstacle.obstacle();
  if (!path_obstacle.HasLateralDecision()) {
    ADEBUG &lt;&lt; "obstacle has no lateral decision";
    return false;
  }
  const auto&amp; decision = path_obstacle.LateralDecision();
  if (!decision.has_nudge()) {
    AWARN &lt;&lt; "only support nudge decision now";
    return true;
  }
  const auto&amp; nudge = decision.nudge();
  const auto&amp; box = ptr_obstacle-&gt;PerceptionBoundingBox();
  std::vector&lt;common::math::Vec2d&gt; corners;
  box.GetAllCorners(&amp;corners);
  if (!MapPolygon(corners, nudge, &amp;static_obstacle_bound_)) {
    AERROR &lt;&lt; "fail to map polygon with id " &lt;&lt; path_obstacle.Id()
           &lt;&lt; " in qp frenet frame";
    return false;
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\qp_spline_path\qp_frenet_frame.cc" startLine="(154, 0)" endLine="(225, 1)" clone_start="4" clone_end="13">
			<code function_name="QpFrenetFrame::MapDynamicObstacleWithDecision( const PathObstacle&amp; path_obstacle)">bool QpFrenetFrame::MapDynamicObstacleWithDecision(
    const PathObstacle&amp; path_obstacle) {
  const Obstacle* ptr_obstacle = path_obstacle.obstacle();
  if (!path_obstacle.HasLateralDecision()) {
    ADEBUG &lt;&lt; "object has no lateral decision";
    return false;
  }
  const auto&amp; decision = path_obstacle.LateralDecision();
  if (!decision.has_nudge()) {
    AWARN &lt;&lt; "only support nudge now";
    return true;
  }
  const auto&amp; nudge = decision.nudge();
  for (const SpeedPoint&amp; veh_point : discretized_vehicle_location_) {
    double time = veh_point.t();
    common::TrajectoryPoint trajectory_point =
        ptr_obstacle-&gt;GetPointAtTime(time);
    common::math::Box2d obs_box =
        ptr_obstacle-&gt;GetBoundingBox(trajectory_point);
    // project obs_box on reference line
    std::vector&lt;common::math::Vec2d&gt; corners;
    obs_box.GetAllCorners(&amp;corners);
    std::vector&lt;common::SLPoint&gt; sl_corners;

    for (const auto&amp; corner_xy : corners) {
      common::SLPoint cur_point;
      if (!reference_line_.XYToSL(corner_xy, &amp;cur_point)) {
        AERROR &lt;&lt; "Fail to map xy point " &lt;&lt; corner_xy.DebugString() &lt;&lt; " to "
               &lt;&lt; cur_point.ShortDebugString();
        return false;
      }
      // shift box base on buffer
      cur_point.set_l(cur_point.l() + nudge.distance_l());
      sl_corners.push_back(std::move(cur_point));
    }

    for (uint32_t i = 0; i &lt; sl_corners.size(); ++i) {
      common::SLPoint sl_first = sl_corners[i % sl_corners.size()];
      common::SLPoint sl_second = sl_corners[(i + 1) % sl_corners.size()];
      if (sl_first.s() &lt; sl_second.s()) {
        std::swap(sl_first, sl_second);
      }

      std::pair&lt;double, double&gt; bound = MapLateralConstraint(
          sl_first, sl_second, nudge.type(),
          veh_point.s() - vehicle_param_.back_edge_to_center(),
          veh_point.s() + vehicle_param_.front_edge_to_center());

      // update bound map
      double s_resolution = std::fabs(veh_point.v() * time_resolution_);
      double updated_start_s =
          init_frenet_point_.s() + veh_point.s() - s_resolution;
      double updated_end_s =
          init_frenet_point_.s() + veh_point.s() + s_resolution;
      if (updated_end_s &gt; evaluated_knots_.back() ||
          updated_start_s &lt; evaluated_knots_.front()) {
        continue;
      }
      std::pair&lt;uint32_t, uint32_t&gt; update_index_range =
          FindInterval(updated_start_s, updated_end_s);

      for (uint32_t j = update_index_range.first;
           j &lt;= update_index_range.second; ++j) {
        dynamic_obstacle_bound_[j].first =
            std::max(bound.first, dynamic_obstacle_bound_[j].first);
        dynamic_obstacle_bound_[j].second =
            std::min(bound.second, dynamic_obstacle_bound_[j].second);
      }
    }
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(388, 0)" endLine="(408, 1)" clone_start="20" clone_end="21">
			<code function_name="SerialStream::wait_readable(uint32_t timeout_us)">bool SerialStream::wait_readable(uint32_t timeout_us) {
  // Setup a select call to block for serial data or a timeout
  timespec timeout_ts;
  fd_set readfds;
  FD_ZERO(&amp;readfds);
  FD_SET(_fd, &amp;readfds);

  timeout_ts.tv_sec = timeout_us / 1000000;
  timeout_ts.tv_nsec = (timeout_us % 1000000) * 1000;
  int r = pselect(_fd + 1, &amp;readfds, NULL, NULL, &amp;timeout_ts, NULL);
  if (r &lt;= 0) {
    return false;
  }

  // This shouldn't happen, if r &gt; 0 our fd has to be in the list!
  if (!FD_ISSET(_fd, &amp;readfds)) {
    return false;
  }
  // Data available to read.
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(283, 0)" endLine="(318, 1)" clone_start="35" clone_end="36">
			<code function_name="TcpStream::write(const uint8_t* buffer, size_t length)">size_t TcpStream::write(const uint8_t* buffer, size_t length) {
  size_t total_nsent = 0;

  if (_status != Stream::Status::CONNECTED) {
    disconnect();
    connect();
    if (_status != Stream::Status::CONNECTED) {
      return 0;
    }
  }

  while (length &gt; 0) {
    ssize_t nsent = ::send(_sockfd, buffer, length, 0);
    if (nsent &lt; 0) {
      if (errno == EINTR) {
        continue;
      } else {
        // error
        if (errno == EPIPE || errno == ECONNRESET) {
          _status = Stream::Status::DISCONNECTED;
          _errno = errno;
        } else if (errno != EAGAIN) {
          _status = Stream::Status::ERROR;
          _errno = errno;
        }
        return total_nsent;
      }
    }

    total_nsent += nsent;
    length -= nsent;
    buffer += nsent;
  }

  return total_nsent;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(334, 0)" endLine="(386, 1)" clone_start="52" clone_end="53">
			<code function_name="SerialStream::write(const uint8_t* data, size_t length)">size_t SerialStream::write(const uint8_t* data, size_t length) {
  if (!_is_open) {
    if (!connect()) {
      return 0;
    }
    ROS_INFO_STREAM("Connect " &lt;&lt; _device_name &lt;&lt; " success.");
  }

  size_t total_nsent = 0;
  size_t delay_times = 0;

  while ((length &gt; 0) &amp;&amp; (delay_times &lt; 5)) {
    ssize_t nsent = ::write(_fd, data, length);
    if (nsent &lt; 0) {
      ROS_ERROR_STREAM(
          "Serial stream write data failed, error: " &lt;&lt; strerror(errno));
      switch (errno) {
        case EAGAIN:
        case EINVAL:
          nsent = 0;
          break;

        case EBADF:
        case EIO:
          disconnect();
          if (connect()) {
            ROS_INFO_STREAM("Reconnect " &lt;&lt; _device_name &lt;&lt; "success.");
            nsent = 0;
            break;  // has recoverable
          }

        default:
          _status = Stream::Status::ERROR;
          _errno = errno;
          return total_nsent;
      }
    }

    if (nsent == 0) {
      if (!wait_writable(_byte_time_us)) {
        break;
      }
      ++delay_times;
      continue;
    }

    total_nsent += nsent;
    length -= nsent;
    data += nsent;
  }

  return total_nsent;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(410, 0)" endLine="(430, 1)" clone_start="1" clone_end="9">
			<code function_name="SerialStream::wait_writable(uint32_t timeout_us)">bool SerialStream::wait_writable(uint32_t timeout_us) {
  // Setup a select call to block for serial data or a timeout
  timespec timeout_ts;
  fd_set writefds;
  FD_ZERO(&amp;writefds);
  FD_SET(_fd, &amp;writefds);

  timeout_ts.tv_sec = timeout_us / 1000000;
  timeout_ts.tv_nsec = (timeout_us % 1000000) * 1000;
  int r = pselect(_fd + 1, NULL, &amp;writefds, NULL, &amp;timeout_ts, NULL);
  if (r &lt;= 0) {
    return false;
  }

  // This shouldn't happen, if r &gt; 0 our fd has to be in the list!
  if (!FD_ISSET(_fd, &amp;writefds)) {
    return false;
  }
  // Data available to write.
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(320, 0)" endLine="(340, 1)" clone_start="1" clone_end="9">
			<code function_name="TcpStream::readable(uint32_t timeout_us)">bool TcpStream::readable(uint32_t timeout_us) {
  // Setup a select call to block for serial data or a timeout
  timespec timeout_ts;
  fd_set readfds;
  FD_ZERO(&amp;readfds);
  FD_SET(_sockfd, &amp;readfds);

  timeout_ts.tv_sec = timeout_us / 1000000;
  timeout_ts.tv_nsec = (timeout_us % 1000000) * 1000;
  int r = pselect(_sockfd + 1, &amp;readfds, NULL, NULL, &amp;timeout_ts, NULL);
  if (r &lt; 0) {
    _status = Stream::Status::ERROR;
    _errno = errno;
    ROS_ERROR("Failed to wait tcp data: %d, %s", errno, strerror(errno));
    return false;
  } else if (r == 0 || !FD_ISSET(_sockfd, &amp;readfds)) {
    return false;
  }
  // Data available to read.
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(388, 0)" endLine="(408, 1)" clone_start="1" clone_end="9">
			<code function_name="SerialStream::wait_readable(uint32_t timeout_us)">bool SerialStream::wait_readable(uint32_t timeout_us) {
  // Setup a select call to block for serial data or a timeout
  timespec timeout_ts;
  fd_set readfds;
  FD_ZERO(&amp;readfds);
  FD_SET(_fd, &amp;readfds);

  timeout_ts.tv_sec = timeout_us / 1000000;
  timeout_ts.tv_nsec = (timeout_us % 1000000) * 1000;
  int r = pselect(_fd + 1, &amp;readfds, NULL, NULL, &amp;timeout_ts, NULL);
  if (r &lt;= 0) {
    return false;
  }

  // This shouldn't happen, if r &gt; 0 our fd has to be in the list!
  if (!FD_ISSET(_fd, &amp;readfds)) {
    return false;
  }
  // Data available to read.
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(356, 0)" endLine="(390, 1)" clone_start="12" clone_end="19">
			<code function_name="Spline1dConstraint::AddDerivativeSmoothConstraint()">bool Spline1dConstraint::AddDerivativeSmoothConstraint() {
  if (x_knots_.size() &lt; 3) {
    return false;
  }

  const std::uint32_t n_constraint = (x_knots_.size() - 2) * 2;
  Eigen::MatrixXd equality_constraint = Eigen::MatrixXd::Zero(
      n_constraint, (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd equality_boundary = Eigen::MatrixXd::Zero(n_constraint, 1);

  for (std::uint32_t i = 0; i &lt; n_constraint; i += 2) {
    double left_coef = 1.0;
    double right_coef = -1.0;
    double left_dcoef = 1.0;
    double right_dcoef = -1.0;
    const double x_left = x_knots_[i / 2 + 1] - x_knots_[i / 2];
    const double x_right = 0.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      equality_constraint(i, spline_order_ * (i / 2) + j) = left_coef;
      equality_constraint(i, spline_order_ * ((i / 2) + 1) + j) = right_coef;
      if (j &gt;= 1) {
        equality_constraint(i + 1, spline_order_ * (i / 2) + j) =
            left_dcoef * j;
        equality_constraint(i + 1, spline_order_ * ((i / 2) + 1) + j) =
            right_dcoef * j;
        left_dcoef = left_coef;
        right_dcoef = right_coef;
      }
      left_coef *= x_left;
      right_coef *= x_right;
    }
  }
  return equality_constraint_.AddConstraint(equality_constraint,
                                            equality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(392, 0)" endLine="(439, 1)" clone_start="14" clone_end="22">
			<code function_name="Spline1dConstraint::AddSecondDerivativeSmoothConstraint()">bool Spline1dConstraint::AddSecondDerivativeSmoothConstraint() {
  if (x_knots_.size() &lt; 3) {
    return false;
  }

  const std::uint32_t n_constraint = (x_knots_.size() - 2) * 3;
  Eigen::MatrixXd equality_constraint = Eigen::MatrixXd::Zero(
      n_constraint, (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd equality_boundary = Eigen::MatrixXd::Zero(n_constraint, 1);

  for (std::uint32_t i = 0; i &lt; n_constraint; i += 3) {
    double left_coef = 1.0;
    double right_coef = -1.0;
    double left_dcoef = 1.0;
    double right_dcoef = -1.0;
    double left_ddcoef = 1.0;
    double right_ddcoef = -1.0;

    const double x_left = x_knots_[i / 3 + 1] - x_knots_[i / 3];
    const double x_right = 0.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      equality_constraint(i, spline_order_ * (i / 3) + j) = left_coef;
      equality_constraint(i, spline_order_ * (i / 3 + 1) + j) = right_coef;

      if (j &gt;= 2) {
        equality_constraint(i + 2, spline_order_ * i / 3 + j) =
            left_ddcoef * j * (j - 1);
        equality_constraint(i + 2, spline_order_ * (i / 3 + 1) + j) =
            right_ddcoef * j * (j - 1);
        left_ddcoef = left_dcoef;
        right_ddcoef = right_dcoef;
      }

      if (j &gt;= 1) {
        equality_constraint(i + 1, spline_order_ * (i / 3) + j) =
            left_dcoef * j;
        equality_constraint(i + 1, spline_order_ * (i / 3 + 1) + j) =
            right_dcoef * j;
        left_dcoef = left_coef;
        right_dcoef = right_coef;
      }
      left_coef *= x_left;
      right_coef *= x_right;
    }
  }
  return equality_constraint_.AddConstraint(equality_constraint,
                                            equality_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(142, 0)" endLine="(257, 1)" clone_start="40" clone_end="51">
			<code function_name="LincolnController::chassis()">Chassis LincolnController::chassis() {
  chassis_.Clear();

  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  // 21, 22, previously 1, 2
  if (driving_mode() == Chassis::EMERGENCY_MODE) {
    set_chassis_error_code(Chassis::NO_ERROR);
  }

  chassis_.set_driving_mode(driving_mode());
  chassis_.set_error_code(chassis_error_code());

  // 3
  chassis_.set_engine_started(true);
  // 4
  if (chassis_detail.has_ems() &amp;&amp; chassis_detail.ems().has_engine_rpm()) {
    chassis_.set_engine_rpm(chassis_detail.ems().engine_rpm());
  } else {
    chassis_.set_engine_rpm(0);
  }
  // 5
  if (chassis_detail.has_vehicle_spd() &amp;&amp;
      chassis_detail.vehicle_spd().has_vehicle_spd()) {
    chassis_.set_speed_mps(chassis_detail.vehicle_spd().vehicle_spd());
  } else {
    chassis_.set_speed_mps(0);
  }
  // 6
  chassis_.set_odometer_m(0);
  // 7
  // lincoln only has fuel percentage
  // to avoid confusing, just don't set
  chassis_.set_fuel_range_m(0);
  // 8
  if (chassis_detail.has_gas() &amp;&amp; chassis_detail.gas().has_throttle_output()) {
    chassis_.set_throttle_percentage(chassis_detail.gas().throttle_output());
  } else {
    chassis_.set_throttle_percentage(0);
  }
  // 9
  if (chassis_detail.has_brake() &amp;&amp; chassis_detail.brake().has_brake_output()) {
    chassis_.set_brake_percentage(chassis_detail.brake().brake_output());
  } else {
    chassis_.set_brake_percentage(0);
  }
  // 23, previously 10
  if (chassis_detail.has_gear() &amp;&amp; chassis_detail.gear().has_gear_state()) {
    chassis_.set_gear_location(chassis_detail.gear().gear_state());
  } else {
    chassis_.set_gear_location(Chassis::GEAR_NONE);
  }
  // 11
  if (chassis_detail.has_eps() &amp;&amp; chassis_detail.eps().has_steering_angle()) {
    chassis_.set_steering_percentage(chassis_detail.eps().steering_angle() *
                                     100.0 / params_.max_steer_angle());
  } else {
    chassis_.set_steering_percentage(0);
  }
  // 12
  if (chassis_detail.has_eps() &amp;&amp; chassis_detail.eps().has_epas_torque()) {
    chassis_.set_steering_torque_nm(chassis_detail.eps().epas_torque());
  } else {
    chassis_.set_steering_torque_nm(0);
  }
  // 13
  if (chassis_detail.has_eps() &amp;&amp;
      chassis_detail.epb().has_parking_brake_status()) {
    chassis_.set_parking_brake(chassis_detail.epb().parking_brake_status() ==
                               Epb::PBRAKE_ON);
  } else {
    chassis_.set_parking_brake(false);
  }
  // TODO(Authors): lincoln beam
  // 14, 15

  // 16, 17
  if (chassis_detail.has_light() &amp;&amp;
      chassis_detail.light().has_turn_light_type() &amp;&amp;
      chassis_detail.light().turn_light_type() != Light::TURN_LIGHT_OFF) {
    if (chassis_detail.light().turn_light_type() == Light::TURN_LEFT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(
          common::VehicleSignal::TURN_LEFT);
    } else if (chassis_detail.light().turn_light_type() ==
               Light::TURN_RIGHT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(
          common::VehicleSignal::TURN_RIGHT);
    } else {
      chassis_.mutable_signal()-&gt;set_turn_signal(
          common::VehicleSignal::TURN_NONE);
    }
  } else {
    chassis_.mutable_signal()-&gt;set_turn_signal(
        common::VehicleSignal::TURN_NONE);
  }
  // 18
  if (chassis_detail.has_light() &amp;&amp; chassis_detail.light().has_is_horn_on() &amp;&amp;
      chassis_detail.light().is_horn_on()) {
    chassis_.mutable_signal()-&gt;set_horn(true);
  } else {
    chassis_.mutable_signal()-&gt;set_horn(false);
  }

  // 19, lincoln wiper is too complicated
  // 24
  if (chassis_detail.has_eps() &amp;&amp; chassis_detail.eps().has_timestamp_65()) {
    chassis_.set_steering_timestamp(chassis_detail.eps().timestamp_65());
  }
  // 26
  if (chassis_error_mask_) {
    chassis_.set_chassis_error_mask(chassis_error_mask_);
  }

  return chassis_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(142, 0)" endLine="(257, 1)" clone_start="35" clone_end="45">
			<code function_name="LincolnController::chassis()">Chassis LincolnController::chassis() {
  chassis_.Clear();

  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  // 21, 22, previously 1, 2
  if (driving_mode() == Chassis::EMERGENCY_MODE) {
    set_chassis_error_code(Chassis::NO_ERROR);
  }

  chassis_.set_driving_mode(driving_mode());
  chassis_.set_error_code(chassis_error_code());

  // 3
  chassis_.set_engine_started(true);
  // 4
  if (chassis_detail.has_ems() &amp;&amp; chassis_detail.ems().has_engine_rpm()) {
    chassis_.set_engine_rpm(chassis_detail.ems().engine_rpm());
  } else {
    chassis_.set_engine_rpm(0);
  }
  // 5
  if (chassis_detail.has_vehicle_spd() &amp;&amp;
      chassis_detail.vehicle_spd().has_vehicle_spd()) {
    chassis_.set_speed_mps(chassis_detail.vehicle_spd().vehicle_spd());
  } else {
    chassis_.set_speed_mps(0);
  }
  // 6
  chassis_.set_odometer_m(0);
  // 7
  // lincoln only has fuel percentage
  // to avoid confusing, just don't set
  chassis_.set_fuel_range_m(0);
  // 8
  if (chassis_detail.has_gas() &amp;&amp; chassis_detail.gas().has_throttle_output()) {
    chassis_.set_throttle_percentage(chassis_detail.gas().throttle_output());
  } else {
    chassis_.set_throttle_percentage(0);
  }
  // 9
  if (chassis_detail.has_brake() &amp;&amp; chassis_detail.brake().has_brake_output()) {
    chassis_.set_brake_percentage(chassis_detail.brake().brake_output());
  } else {
    chassis_.set_brake_percentage(0);
  }
  // 23, previously 10
  if (chassis_detail.has_gear() &amp;&amp; chassis_detail.gear().has_gear_state()) {
    chassis_.set_gear_location(chassis_detail.gear().gear_state());
  } else {
    chassis_.set_gear_location(Chassis::GEAR_NONE);
  }
  // 11
  if (chassis_detail.has_eps() &amp;&amp; chassis_detail.eps().has_steering_angle()) {
    chassis_.set_steering_percentage(chassis_detail.eps().steering_angle() *
                                     100.0 / params_.max_steer_angle());
  } else {
    chassis_.set_steering_percentage(0);
  }
  // 12
  if (chassis_detail.has_eps() &amp;&amp; chassis_detail.eps().has_epas_torque()) {
    chassis_.set_steering_torque_nm(chassis_detail.eps().epas_torque());
  } else {
    chassis_.set_steering_torque_nm(0);
  }
  // 13
  if (chassis_detail.has_eps() &amp;&amp;
      chassis_detail.epb().has_parking_brake_status()) {
    chassis_.set_parking_brake(chassis_detail.epb().parking_brake_status() ==
                               Epb::PBRAKE_ON);
  } else {
    chassis_.set_parking_brake(false);
  }
  // TODO(Authors): lincoln beam
  // 14, 15

  // 16, 17
  if (chassis_detail.has_light() &amp;&amp;
      chassis_detail.light().has_turn_light_type() &amp;&amp;
      chassis_detail.light().turn_light_type() != Light::TURN_LIGHT_OFF) {
    if (chassis_detail.light().turn_light_type() == Light::TURN_LEFT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(
          common::VehicleSignal::TURN_LEFT);
    } else if (chassis_detail.light().turn_light_type() ==
               Light::TURN_RIGHT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(
          common::VehicleSignal::TURN_RIGHT);
    } else {
      chassis_.mutable_signal()-&gt;set_turn_signal(
          common::VehicleSignal::TURN_NONE);
    }
  } else {
    chassis_.mutable_signal()-&gt;set_turn_signal(
        common::VehicleSignal::TURN_NONE);
  }
  // 18
  if (chassis_detail.has_light() &amp;&amp; chassis_detail.light().has_is_horn_on() &amp;&amp;
      chassis_detail.light().is_horn_on()) {
    chassis_.mutable_signal()-&gt;set_horn(true);
  } else {
    chassis_.mutable_signal()-&gt;set_horn(false);
  }

  // 19, lincoln wiper is too complicated
  // 24
  if (chassis_detail.has_eps() &amp;&amp; chassis_detail.eps().has_timestamp_65()) {
    chassis_.set_steering_timestamp(chassis_detail.eps().timestamp_65());
  }
  // 26
  if (chassis_error_mask_) {
    chassis_.set_chassis_error_mask(chassis_error_mask_);
  }

  return chassis_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(143, 0)" endLine="(159, 1)" clone_start="16" clone_end="17">
			<code function_name="UdpStream::connect()">bool UdpStream::connect() {
  if (_sockfd &lt; 0) {
    this-&gt;open();
    if (_sockfd &lt; 0) {
      return false;
    }
  }

  if (_status == Stream::Status::CONNECTED) {
    return true;
  }

  // upper layer support ping method ??
  login();
  _status = Stream::Status::CONNECTED;
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(136, 0)" endLine="(228, 1)" clone_start="92" clone_end="93">
			<code function_name="TcpStream::connect()">bool TcpStream::connect() {
  if (_sockfd &lt; 0) {
    this-&gt;open();
    if (_sockfd &lt; 0) {
      // error
      return false;
    }
  }

  if (_status == Stream::Status::CONNECTED) {
    return true;
  }

  fd_set fds;
  timeval timeo = {10, 0};
  int ret = 0;
  sockaddr_in peer_addr;

  bzero(&amp;peer_addr, sizeof(peer_addr));
  peer_addr.sin_family = AF_INET;
  peer_addr.sin_port = _peer_port;
  peer_addr.sin_addr.s_addr = _peer_addr;

  int fd_flags = fcntl(_sockfd, F_GETFL);
  if (fd_flags &lt; 0 || fcntl(_sockfd, F_SETFL, fd_flags | O_NONBLOCK) &lt; 0) {
    ROS_ERROR_STREAM("Failed to set noblock, error: " &lt;&lt; strerror(errno));
    return false;
  }

  while ((ret = ::connect(_sockfd, reinterpret_cast&lt;sockaddr*&gt;(&amp;peer_addr),
                          sizeof(peer_addr))) &lt; 0) {
    if (errno == EINTR) {
      ROS_INFO("Tcp connect return EINTR.");
      continue;
    } else {
      if ((errno != EISCONN) &amp;&amp; (errno != EINPROGRESS) &amp;&amp; (errno != EALREADY)) {
        _status = Stream::Status::ERROR;
        _errno = errno;
        ROS_ERROR_STREAM("Connect failed, error: " &lt;&lt; strerror(errno));
        return false;
      }

      FD_ZERO(&amp;fds);
      FD_SET(_sockfd, &amp;fds);
      ret = select(_sockfd + 1, NULL, &amp;fds, NULL, &amp;timeo);
      if (ret &lt; 0) {
        _status = Stream::Status::ERROR;
        _errno = errno;
        ROS_ERROR_STREAM("Wait connect failed, error: " &lt;&lt; strerror(errno));
        return false;
      } else if (ret == 0) {
        ROS_INFO("Tcp connect timeout.");
        return false;
      } else if (FD_ISSET(_sockfd, &amp;fds)) {
        int error = 0;
        socklen_t len = sizeof(int);

        if (getsockopt(_sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len) &lt; 0) {
          _status = Stream::Status::ERROR;
          _errno = errno;
          ROS_ERROR_STREAM("Getsockopt failed, error: " &lt;&lt; strerror(errno));
          return false;
        }
        if (error != 0) {
          _status = Stream::Status::ERROR;
          _errno = errno;
          ROS_ERROR_STREAM("Socket error: " &lt;&lt; strerror(errno));
          return false;
        }

        // connect successfully
        break;
      } else {
        _status = Stream::Status::ERROR;
        _errno = errno;
        ROS_ERROR("Should not be here.");
        return false;
      }
    }
  }

  if (!init_socket()) {
    close();
    _status = Stream::Status::ERROR;
    _errno = errno;
    ROS_ERROR("Failed to init socket.");
    return false;
  }
  ROS_INFO("Tcp connect success.");
  _status = Stream::Status::CONNECTED;
  login();
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(161, 0)" endLine="(169, 1)" clone_start="1" clone_end="9">
			<code function_name="UdpStream::disconnect()">bool UdpStream::disconnect() {
  if (_sockfd &lt; 0) {
    // not open
    return false;
  }

  this-&gt;close();
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(230, 0)" endLine="(238, 1)" clone_start="1" clone_end="9">
			<code function_name="TcpStream::disconnect()">bool TcpStream::disconnect() {
  if (_sockfd &lt; 0) {
    // not open
    return false;
  }

  this-&gt;close();
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(171, 0)" endLine="(197, 1)" clone_start="1" clone_end="2">
			<code function_name="UdpStream::read(uint8_t* buffer, size_t max_length)">size_t UdpStream::read(uint8_t* buffer, size_t max_length) {
  ssize_t ret = 0;
  struct sockaddr_in peer_sockaddr;
  socklen_t socklenth = sizeof(peer_sockaddr);
  bzero(&amp;peer_sockaddr, sizeof(peer_sockaddr));
  peer_sockaddr.sin_family = AF_INET;
  peer_sockaddr.sin_port = _peer_port;
  peer_sockaddr.sin_addr.s_addr = _peer_addr;

  while ((ret = ::recvfrom(_sockfd, buffer, max_length, 0,
                           (struct sockaddr*)&amp;peer_sockaddr,
                           (socklen_t*)&amp;socklenth)) &lt; 0) {
    if (errno == EINTR) {
      continue;
    } else {
      // error
      if (errno != EAGAIN) {
        _status = Stream::Status::ERROR;
        _errno = errno;
      }
    }

    return 0;
  }

  return ret;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(240, 0)" endLine="(281, 1)" clone_start="1" clone_end="2">
			<code function_name="TcpStream::read(uint8_t* buffer, size_t max_length)">size_t TcpStream::read(uint8_t* buffer, size_t max_length) {
  ssize_t ret = 0;

  if (_status != Stream::Status::CONNECTED) {
    disconnect();
    connect();
    if (_status != Stream::Status::CONNECTED) {
      return 0;
    }
  }

  if (!readable(10000)) {
    return 0;
  }

  while ((ret = ::recv(_sockfd, buffer, max_length, 0)) &lt; 0) {
    if (errno == EINTR) {
      continue;
    } else {
      // error
      if (errno != EAGAIN) {
        _status = Stream::Status::ERROR;
        _errno = errno;
        ROS_ERROR("Read errno %d, error %s.", errno, strerror(errno));
      }
    }

    return 0;
  }

  if (ret == 0) {
    _status = Stream::Status::ERROR;
    _errno = errno;
    ROS_ERROR("Remote closed.");
    disconnect();
    if (connect()) {
      ROS_INFO("Reconnect tcp success.");
    }
  }

  return ret;
}</code>
		</source>
	</dup>
	<dup count="6">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\track_object_distance.cc" startLine="(80, 0)" endLine="(90, 1)" clone_start="1" clone_end="10">
			<code function_name="TrackObjectDistance::SetHistogramDistanceWeight( const float&amp; histogram_distance_weight)">bool TrackObjectDistance::SetHistogramDistanceWeight(
  const float&amp; histogram_distance_weight) {
  if (histogram_distance_weight &gt;= 0) {
    s_histogram_distance_weight_ = histogram_distance_weight;
    AINFO &lt;&lt; "histogram distance weight of TrackObjectDistance is "
          &lt;&lt; s_histogram_distance_weight_;
    return true;
  }
  AERROR &lt;&lt; "invalid histogram distance weight of TrackObjectDistance!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\track_object_distance.cc" startLine="(68, 0)" endLine="(78, 1)" clone_start="1" clone_end="10">
			<code function_name="TrackObjectDistance::SetPointNumDistanceWeight( const float&amp; point_num_distance_weight)">bool TrackObjectDistance::SetPointNumDistanceWeight(
  const float&amp; point_num_distance_weight) {
  if (point_num_distance_weight &gt;= 0) {
    s_point_num_distance_weight_ = point_num_distance_weight;
    AINFO &lt;&lt; "point num distance weight of TrackObjectDistance is "
          &lt;&lt; s_point_num_distance_weight_;
    return true;
  }
  AERROR &lt;&lt; "invalid point num distance weight of TrackObjectDistance!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\track_object_distance.cc" startLine="(56, 0)" endLine="(66, 1)" clone_start="1" clone_end="10">
			<code function_name="TrackObjectDistance::SetBboxSizeDistanceWeight( const float&amp; bbox_size_distance_weight)">bool TrackObjectDistance::SetBboxSizeDistanceWeight(
  const float&amp; bbox_size_distance_weight) {
  if (bbox_size_distance_weight &gt;= 0) {
    s_bbox_size_distance_weight_ = bbox_size_distance_weight;
    AINFO &lt;&lt; "bbox size distance weight of TrackObjectDistance is "
          &lt;&lt; s_bbox_size_distance_weight_;
    return true;
  }
  AERROR &lt;&lt; "invalid bbox size distance weight of TrackObjectDistance!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\track_object_distance.cc" startLine="(44, 0)" endLine="(54, 1)" clone_start="1" clone_end="10">
			<code function_name="TrackObjectDistance::SetDirectionDistanceWeight( const float&amp; direction_distance_weight)">bool TrackObjectDistance::SetDirectionDistanceWeight(
  const float&amp; direction_distance_weight) {
  if (direction_distance_weight &gt;= 0) {
    s_direction_distance_weight_ = direction_distance_weight;
    AINFO &lt;&lt; "direction distance weight of TrackObjectDistance is "
          &lt;&lt; s_direction_distance_weight_;
    return true;
  }
  AERROR &lt;&lt; "invalid direction distance weight of TrackObjectDistance!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\track_object_distance.cc" startLine="(32, 0)" endLine="(42, 1)" clone_start="1" clone_end="10">
			<code function_name="TrackObjectDistance::SetLocationDistanceWeight( const float&amp; location_distance_weight)">bool TrackObjectDistance::SetLocationDistanceWeight(
  const float&amp; location_distance_weight) {
  if (location_distance_weight &gt;= 0) {
    s_location_distance_weight_ = location_distance_weight;
    AINFO &lt;&lt; "location distance weight of TrackObjectDistance is "
          &lt;&lt; s_location_distance_weight_;
    return true;
  }
  AERROR &lt;&lt; "invalid location distance weight of TrackeObjectDistance!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hungarian_matcher.cc" startLine="(31, 0)" endLine="(41, 1)" clone_start="1" clone_end="10">
			<code function_name="HungarianMatcher::SetMatchDistanceMaximum( const float&amp; match_distance_maximum)">bool HungarianMatcher::SetMatchDistanceMaximum(
  const float&amp; match_distance_maximum) {
  if (match_distance_maximum &gt;= 0) {
    s_match_distance_maximum_ = match_distance_maximum;
    AINFO &lt;&lt; "match distance maximum of HungarianMatcher is "
          &lt;&lt; s_match_distance_maximum_;
    return true;
  }
  AERROR &lt;&lt; "invalid match distance maximum of HungarianMatcher!";
  return false;
}</code>
		</source>
	</dup>
	<dup count="9">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="186" clone_end="198">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="175" clone_end="187">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="164" clone_end="176">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="153" clone_end="165">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="141" clone_end="154">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="69" clone_end="81">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="58" clone_end="70">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="253" clone_end="264">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="112" clone_end="122">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(636, 0)" endLine="(677, 1)" clone_start="3" clone_end="14">
			<code function_name="Obstacle::InitKFPedestrianTracker(Feature* feature)">void Obstacle::InitKFPedestrianTracker(Feature* feature) {
  // Set transition matrix F
  Eigen::Matrix&lt;double, 2, 2&gt; F;
  F.setIdentity();
  kf_pedestrian_tracker_.SetTransitionMatrix(F);

  // Set observation matrix H
  Eigen::Matrix&lt;double, 2, 2&gt; H;
  H.setIdentity();
  kf_pedestrian_tracker_.SetObservationMatrix(H);

  // Set control matrix
  Eigen::Matrix&lt;double, 2, 4&gt; B;
  B.setZero();
  kf_pedestrian_tracker_.SetControlMatrix(B);

  // Set covariance of transition noise matrix Q
  Eigen::Matrix&lt;double, 2, 2&gt; Q;
  Q.setIdentity();
  Q *= FLAGS_q_var;
  kf_pedestrian_tracker_.SetTransitionNoise(Q);

  // Set observation noise matrix R
  Eigen::Matrix&lt;double, 2, 2&gt; R;
  R.setIdentity();
  R *= FLAGS_r_var;
  kf_pedestrian_tracker_.SetObservationNoise(R);

  // Set current state covariance matrix P
  Eigen::Matrix&lt;double, 2, 2&gt; P;
  P.setIdentity();
  P *= FLAGS_p_var;

  // Set initial state
  Eigen::Matrix&lt;double, 2, 1&gt; x;
  x(0, 0) = feature-&gt;position().x();
  x(1, 0) = feature-&gt;position().y();

  kf_pedestrian_tracker_.SetStateEstimate(x, P);

  kf_pedestrian_tracker_enabled_ = true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(636, 0)" endLine="(677, 1)" clone_start="8" clone_end="19">
			<code function_name="Obstacle::InitKFPedestrianTracker(Feature* feature)">void Obstacle::InitKFPedestrianTracker(Feature* feature) {
  // Set transition matrix F
  Eigen::Matrix&lt;double, 2, 2&gt; F;
  F.setIdentity();
  kf_pedestrian_tracker_.SetTransitionMatrix(F);

  // Set observation matrix H
  Eigen::Matrix&lt;double, 2, 2&gt; H;
  H.setIdentity();
  kf_pedestrian_tracker_.SetObservationMatrix(H);

  // Set control matrix
  Eigen::Matrix&lt;double, 2, 4&gt; B;
  B.setZero();
  kf_pedestrian_tracker_.SetControlMatrix(B);

  // Set covariance of transition noise matrix Q
  Eigen::Matrix&lt;double, 2, 2&gt; Q;
  Q.setIdentity();
  Q *= FLAGS_q_var;
  kf_pedestrian_tracker_.SetTransitionNoise(Q);

  // Set observation noise matrix R
  Eigen::Matrix&lt;double, 2, 2&gt; R;
  R.setIdentity();
  R *= FLAGS_r_var;
  kf_pedestrian_tracker_.SetObservationNoise(R);

  // Set current state covariance matrix P
  Eigen::Matrix&lt;double, 2, 2&gt; P;
  P.setIdentity();
  P *= FLAGS_p_var;

  // Set initial state
  Eigen::Matrix&lt;double, 2, 1&gt; x;
  x(0, 0) = feature-&gt;position().x();
  x(1, 0) = feature-&gt;position().y();

  kf_pedestrian_tracker_.SetStateEstimate(x, P);

  kf_pedestrian_tracker_enabled_ = true;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\line_segment2d.cc" startLine="(201, 0)" endLine="(213, 1)" clone_start="1" clone_end="10">
			<code function_name="LineSegment2d::GetPerpendicularFoot(const Vec2d &amp;point, Vec2d *const foot_point) const">double LineSegment2d::GetPerpendicularFoot(const Vec2d &amp;point,
                                           Vec2d *const foot_point) const {
  CHECK_NOTNULL(foot_point);
  if (length_ &lt;= kMathEpsilon) {
    *foot_point = start_;
    return point.DistanceTo(start_);
  }
  const double x0 = point.x() - start_.x();
  const double y0 = point.y() - start_.y();
  const double proj = x0 * unit_direction_.x() + y0 * unit_direction_.y();
  *foot_point = start_ + unit_direction_ * proj;
  return std::abs(x0 * unit_direction_.y() - y0 * unit_direction_.x());
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\line_segment2d.cc" startLine="(112, 0)" endLine="(132, 1)" clone_start="1" clone_end="10">
			<code function_name="LineSegment2d::DistanceSquareTo(const Vec2d &amp;point, Vec2d *const nearest_pt) const">double LineSegment2d::DistanceSquareTo(const Vec2d &amp;point,
                                       Vec2d *const nearest_pt) const {
  CHECK_NOTNULL(nearest_pt);
  if (length_ &lt;= kMathEpsilon) {
    *nearest_pt = start_;
    return point.DistanceSquareTo(start_);
  }
  const double x0 = point.x() - start_.x();
  const double y0 = point.y() - start_.y();
  const double proj = x0 * unit_direction_.x() + y0 * unit_direction_.y();
  if (proj &lt;= 0.0) {
    *nearest_pt = start_;
    return Square(x0) + Square(y0);
  }
  if (proj &gt;= length_) {
    *nearest_pt = end_;
    return point.DistanceSquareTo(end_);
  }
  *nearest_pt = start_ + unit_direction_ * proj;
  return Square(x0 * unit_direction_.y() - y0 * unit_direction_.x());
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\line_segment2d.cc" startLine="(74, 0)" endLine="(94, 1)" clone_start="1" clone_end="10">
			<code function_name="LineSegment2d::DistanceTo(const Vec2d &amp;point, Vec2d *const nearest_pt) const">double LineSegment2d::DistanceTo(const Vec2d &amp;point,
                                 Vec2d *const nearest_pt) const {
  CHECK_NOTNULL(nearest_pt);
  if (length_ &lt;= kMathEpsilon) {
    *nearest_pt = start_;
    return point.DistanceTo(start_);
  }
  const double x0 = point.x() - start_.x();
  const double y0 = point.y() - start_.y();
  const double proj = x0 * unit_direction_.x() + y0 * unit_direction_.y();
  if (proj &lt; 0.0) {
    *nearest_pt = start_;
    return hypot(x0, y0);
  }
  if (proj &gt; length_) {
    *nearest_pt = end_;
    return point.DistanceTo(end_);
  }
  *nearest_pt = start_ + unit_direction_ * proj;
  return std::abs(x0 * unit_direction_.y() - y0 * unit_direction_.x());
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\predictor_manager.h" startLine="(46, 2)" endLine="(46, 40)" clone_start="1" clone_end="1">
			<code function_name="~PredictorManager()">  virtual ~PredictorManager() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\evaluator\evaluator_manager.h" startLine="(45, 2)" endLine="(45, 40)" clone_start="1" clone_end="1">
			<code function_name="~EvaluatorManager()">  virtual ~EvaluatorManager() = default;</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\interface\base_object_filter.h" startLine="(78, 2)" endLine="(78, 23)" clone_start="1" clone_end="1">
			<code function_name="BaseObjectFilter()">  BaseObjectFilter() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\interface\base_object_builder.h" startLine="(71, 2)" endLine="(71, 24)" clone_start="1" clone_end="1">
			<code function_name="BaseObjectBuilder()">  BaseObjectBuilder() {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\interface\base_object_filter.h" startLine="(79, 2)" endLine="(79, 32)" clone_start="1" clone_end="1">
			<code function_name="~BaseObjectFilter()">  virtual ~BaseObjectFilter() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\interface\base_object_builder.h" startLine="(72, 2)" endLine="(72, 33)" clone_start="1" clone_end="1">
			<code function_name="~BaseObjectBuilder()">  virtual ~BaseObjectBuilder() {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(333, 0)" endLine="(347, 1)" clone_start="14" clone_end="15">
			<code function_name="LanesXmlParser::ParseSpeed(const tinyxml2::XMLElement&amp; xml_node, PbLane* lane)">Status LanesXmlParser::ParseSpeed(const tinyxml2::XMLElement&amp; xml_node,
                                  PbLane* lane) {
  double max_speed = 0.0;
  auto sub_node = xml_node.FirstChildElement("speed");
  if (sub_node) {
    int checker = sub_node-&gt;QueryDoubleAttribute("max", &amp;max_speed);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse lane speed attribute";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }
    lane-&gt;set_speed_limit(ToMPS(max_speed));
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(31, 0)" endLine="(60, 1)" clone_start="29" clone_end="30">
			<code function_name="LanesXmlParser::Parse(const tinyxml2::XMLElement&amp; xml_node,const std::string&amp; road_id, std::vector&lt;RoadSectionInternal&gt;* sections)">Status LanesXmlParser::Parse(const tinyxml2::XMLElement&amp; xml_node,
                             const std::string&amp; road_id,
                             std::vector&lt;RoadSectionInternal&gt;* sections) {
  CHECK_NOTNULL(sections);
  const auto lanes_node = xml_node.FirstChildElement("lanes");
  CHECK_NOTNULL(lanes_node);
  const tinyxml2::XMLElement* sub_node =
      lanes_node-&gt;FirstChildElement("laneSection");
  CHECK_NOTNULL(sub_node);

  size_t section_cnt = 0;
  while (sub_node) {
    RoadSectionInternal section_internal;
    std::string section_id = std::to_string(++section_cnt);
    section_internal.id = section_id;
    section_internal.section.mutable_id()-&gt;set_id(section_id);
    RETURN_IF_ERROR(ParseLaneSection(*sub_node,
                                     &amp;section_internal.lanes));
    RETURN_IF_ERROR(ParseSectionBoundary(
        *sub_node,
        section_internal.section.mutable_boundary()-&gt;mutable_outer_polygon()));
    sections-&gt;push_back(section_internal);

    sub_node = sub_node-&gt;NextSiblingElement("laneSection");
  }

  CHECK_GT(sections-&gt;size(), 0);

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(349, 0)" endLine="(387, 1)" clone_start="1" clone_end="9">
			<code function_name="LanesXmlParser::ParseSampleAssociates( const tinyxml2::XMLElement&amp; xml_node, PbLane* lane)">Status LanesXmlParser::ParseSampleAssociates(
    const tinyxml2::XMLElement&amp; xml_node, PbLane* lane) {
  CHECK_NOTNULL(lane);
  auto sub_node = xml_node.FirstChildElement("sampleAssociates");
  if (sub_node == nullptr) {
    std::string err_msg = "Error parse sample associates";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  sub_node = sub_node-&gt;FirstChildElement("sampleAssociate");
  if (sub_node == nullptr) {
    std::string err_msg = "Error parse sample associate";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  while (sub_node) {
    double left_width = 0.0;
    double right_width = 0.0;
    double s = 0.0;
    int checker = sub_node-&gt;QueryDoubleAttribute("sOffset", &amp;s);
    checker += sub_node-&gt;QueryDoubleAttribute("leftWidth", &amp;left_width);
    checker += sub_node-&gt;QueryDoubleAttribute("rightWidth", &amp;right_width);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse lane sample associate attribute";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    auto left_sample = lane-&gt;add_left_sample();
    left_sample-&gt;set_s(s);
    left_sample-&gt;set_width(left_width);

    auto right_sample = lane-&gt;add_right_sample();
    right_sample-&gt;set_s(s);
    right_sample-&gt;set_width(right_width);

    sub_node = sub_node-&gt;NextSiblingElement("sampleAssociate");
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(62, 0)" endLine="(91, 1)" clone_start="1" clone_end="11">
			<code function_name="LanesXmlParser::ParseSectionBoundary( const tinyxml2::XMLElement&amp; xml_node, PbBoundaryPolygon* boundary)">Status LanesXmlParser::ParseSectionBoundary(
    const tinyxml2::XMLElement&amp; xml_node, PbBoundaryPolygon* boundary) {
  CHECK_NOTNULL(boundary);

  auto boundaries_node = xml_node.FirstChildElement("boundaries");
  if (boundaries_node == nullptr) {
    std::string err_msg = "Error parse boundaries";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  auto sub_node = boundaries_node-&gt;FirstChildElement("boundary");
  while (sub_node) {
    PbBoundaryEdge* boundary_edge = boundary-&gt;add_edge();
    RETURN_IF_ERROR(
        UtilXmlParser::ParseCurve(*sub_node, boundary_edge-&gt;mutable_curve()));
    std::string type;
    int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "type", &amp;type);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse boundary type";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }
    PbBoundaryEdgeType boundary_type;
    RETURN_IF_ERROR(ToPbBoundaryType(type, &amp;boundary_type));
    boundary_edge-&gt;set_type(boundary_type);

    sub_node = sub_node-&gt;NextSiblingElement("boundary");
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\can_client\fake\fake_can_client.h" startLine="(59, 2)" endLine="(59, 37)" clone_start="1" clone_end="1">
			<code function_name="~FakeCanClient()">  virtual ~FakeCanClient() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\can_client\esd\esd_can_client.h" startLine="(57, 2)" endLine="(57, 36)" clone_start="1" clone_end="1">
			<code function_name="~EsdCanClient()">  virtual ~EsdCanClient() = default;</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\common\trajectory_analyzer.cc" startLine="(175, 0)" endLine="(188, 1)" clone_start="1" clone_end="10">
			<code function_name="TrajectoryAnalyzer::QueryNearestPointByPosition( const double x, const double y) const">TrajectoryPoint TrajectoryAnalyzer::QueryNearestPointByPosition(
    const double x, const double y) const {
  double d_min = PointDistanceSquare(trajectory_points_.front(), x, y);
  size_t index_min = 0;

  for (size_t i = 1; i &lt; trajectory_points_.size(); ++i) {
    double d_temp = PointDistanceSquare(trajectory_points_[i], x, y);
    if (d_temp &lt; d_min) {
      d_min = d_temp;
      index_min = i;
    }
  }
  return trajectory_points_[index_min];
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\common\trajectory_analyzer.cc" startLine="(65, 0)" endLine="(91, 1)" clone_start="1" clone_end="10">
			<code function_name="TrajectoryAnalyzer::QueryMatchedPathPoint(const double x, const double y) const">PathPoint TrajectoryAnalyzer::QueryMatchedPathPoint(const double x,
                                                    const double y) const {
  double d_min = PointDistanceSquare(trajectory_points_.front(), x, y);
  size_t index_min = 0;

  for (size_t i = 1; i &lt; trajectory_points_.size(); ++i) {
    double d_temp = PointDistanceSquare(trajectory_points_[i], x, y);
    if (d_temp &lt; d_min) {
      d_min = d_temp;
      index_min = i;
    }
  }

  size_t index_start = index_min == 0 ? index_min : index_min - 1;
  size_t index_end =
      index_min + 1 == trajectory_points_.size() ? index_min : index_min + 1;

  if (index_start == index_end ||
      math::DoubleCompare(trajectory_points_[index_start].path_point().s(),
                          trajectory_points_[index_end].path_point().s()) ==
          0) {
    return TrajectoryPointToPathPoint(trajectory_points_[index_start]);
  }

  return FindMinDistancePoint(trajectory_points_[index_start],
                              trajectory_points_[index_end], x, y);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\qp_spline_st_speed\qp_spline_st_speed_optimizer.cc" startLine="(54, 0)" endLine="(132, 1)" clone_start="7" clone_end="18">
			<code function_name="QpSplineStSpeedOptimizer::Process(const SLBoundary&amp; adc_sl_boundary,const PathData&amp; path_data, const TrajectoryPoint&amp; init_point, const ReferenceLine&amp; reference_line, PathDecision* const path_decision, SpeedData* const speed_data)">Status QpSplineStSpeedOptimizer::Process(const SLBoundary&amp; adc_sl_boundary,
                                         const PathData&amp; path_data,
                                         const TrajectoryPoint&amp; init_point,
                                         const ReferenceLine&amp; reference_line,
                                         PathDecision* const path_decision,
                                         SpeedData* const speed_data) {
  if (!is_init_) {
    AERROR &lt;&lt; "Please call Init() before Process.";
    return Status(ErrorCode::PLANNING_ERROR, "Not init.");
  }

  if (path_data.discretized_path().NumOfPoints() == 0) {
    std::string msg("Empty path data");
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  StBoundaryMapper boundary_mapper(
      reference_line_info_-&gt;pnc_map(), adc_sl_boundary, st_boundary_config_,
      reference_line, path_data, qp_spline_st_speed_config_.total_path_length(),
      qp_spline_st_speed_config_.total_time());

  for (const auto* path_obstacle : path_decision-&gt;path_obstacles().Items()) {
    DCHECK(path_obstacle-&gt;HasLongitudinalDecision());
  }
  // step 1 get boundaries
  std::vector&lt;StBoundary&gt; boundaries;
  if (boundary_mapper.GetGraphBoundary(*path_decision, &amp;boundaries).code() ==
      ErrorCode::PLANNING_ERROR) {
    return Status(ErrorCode::PLANNING_ERROR,
                  "Mapping obstacle for qp st speed optimizer failed!");
  }

  for (const auto&amp; boundary : boundaries) {
    ADEBUG &lt;&lt; "QPST mapped boundary: " &lt;&lt; boundary.DebugString() &lt;&lt; std::endl;
    DCHECK(boundary.boundary_type() != StBoundary::BoundaryType::UNKNOWN);
  }

  SpeedLimit speed_limits;
  if (boundary_mapper.GetSpeedLimits(&amp;speed_limits) != Status::OK()) {
    return Status(ErrorCode::PLANNING_ERROR,
                  "GetSpeedLimits for dp st speed optimizer failed!");
  }

  // step 2 perform graph search
  const auto&amp; veh_param =
      common::VehicleConfigHelper::GetConfig().vehicle_param();
  QpSplineStGraph st_graph(qp_spline_st_speed_config_, veh_param);

  StGraphData st_graph_data(boundaries, init_point, speed_limits,
                            path_data.discretized_path().Length());

  STGraphDebug* st_graph_debug =
      frame_-&gt;DebugLogger()-&gt;mutable_planning_data()-&gt;add_st_graph();

  std::pair&lt;double, double&gt; accel_bound = {
      qp_spline_st_speed_config_.preferred_min_deceleration(),
      qp_spline_st_speed_config_.preferred_max_acceleration()};
  st_graph.SetDebugLogger(st_graph_debug);
  auto ret = st_graph.Search(st_graph_data, speed_data, accel_bound);
  if (ret != Status::OK()) {
    AERROR &lt;&lt; "Failed to solve with ideal acceleration conditions. Use "
              "secondary choice instead.";

    accel_bound.first = qp_spline_st_speed_config_.min_deceleration();
    accel_bound.second = qp_spline_st_speed_config_.max_acceleration();
    ret = st_graph.Search(st_graph_data, speed_data, accel_bound);

    if (ret != Status::OK()) {
      std::string msg = common::util::StrCat(
          Name(), ":Failed to search graph with quadratic programming!");
      RecordSTGraphDebug(boundaries, speed_limits, *speed_data, st_graph_debug);
      return Status(ErrorCode::PLANNING_ERROR, msg);
    }
  }
  // record debug info
  RecordSTGraphDebug(boundaries, speed_limits, *speed_data, st_graph_debug);
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\dp_st_speed\dp_st_speed_optimizer.cc" startLine="(54, 0)" endLine="(114, 1)" clone_start="7" clone_end="18">
			<code function_name="DpStSpeedOptimizer::Process(const SLBoundary&amp; adc_sl_boundary,const PathData&amp; path_data, const common::TrajectoryPoint&amp; init_point, const ReferenceLine&amp; reference_line, PathDecision* const path_decision, SpeedData* const speed_data)">Status DpStSpeedOptimizer::Process(const SLBoundary&amp; adc_sl_boundary,
                                   const PathData&amp; path_data,
                                   const common::TrajectoryPoint&amp; init_point,
                                   const ReferenceLine&amp; reference_line,
                                   PathDecision* const path_decision,
                                   SpeedData* const speed_data) {
  if (!is_init_) {
    AERROR &lt;&lt; "Please call Init() before process DpStSpeedOptimizer.";
    return Status(ErrorCode::PLANNING_ERROR, "Not inited.");
  }

  if (path_data.discretized_path().NumOfPoints() == 0) {
    std::string msg("Empty path data");
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  StBoundaryMapper boundary_mapper(
      reference_line_info_-&gt;pnc_map(), adc_sl_boundary, st_boundary_config_,
      reference_line, path_data, dp_st_speed_config_.total_path_length(),
      dp_st_speed_config_.total_time());

  // step 1 get boundaries
  std::vector&lt;StBoundary&gt; boundaries;
  if (boundary_mapper.GetGraphBoundary(*path_decision, &amp;boundaries).code() ==
      ErrorCode::PLANNING_ERROR) {
    const std::string msg =
        "Mapping obstacle for dp st speed optimizer failed.";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  // step 2 perform graph search
  SpeedLimit speed_limit;
  if (!boundary_mapper.GetSpeedLimits(&amp;speed_limit).ok()) {
    const std::string msg =
        "Getting speed limits for dp st speed optimizer failed!";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  const double path_length = path_data.discretized_path().Length();
  StGraphData st_graph_data(boundaries, init_point, speed_limit, path_length);

  DpStGraph st_graph(reference_line, st_graph_data, dp_st_speed_config_,
                     path_data, adc_sl_boundary);
  auto* debug = frame_-&gt;DebugLogger();
  STGraphDebug* st_graph_debug = debug-&gt;mutable_planning_data()-&gt;add_st_graph();

  if (!st_graph.Search(path_decision, speed_data).ok()) {
    const std::string msg(Name() +
                          ":Failed to search graph with dynamic programming.");
    AERROR &lt;&lt; msg;
    RecordSTGraphDebug(boundaries, speed_limit, *speed_data, st_graph_debug);
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  RecordSTGraphDebug(boundaries, speed_limit, *speed_data, st_graph_debug);

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(142, 0)" endLine="(257, 1)" clone_start="18" clone_end="28">
			<code function_name="LincolnController::chassis()">Chassis LincolnController::chassis() {
  chassis_.Clear();

  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  // 21, 22, previously 1, 2
  if (driving_mode() == Chassis::EMERGENCY_MODE) {
    set_chassis_error_code(Chassis::NO_ERROR);
  }

  chassis_.set_driving_mode(driving_mode());
  chassis_.set_error_code(chassis_error_code());

  // 3
  chassis_.set_engine_started(true);
  // 4
  if (chassis_detail.has_ems() &amp;&amp; chassis_detail.ems().has_engine_rpm()) {
    chassis_.set_engine_rpm(chassis_detail.ems().engine_rpm());
  } else {
    chassis_.set_engine_rpm(0);
  }
  // 5
  if (chassis_detail.has_vehicle_spd() &amp;&amp;
      chassis_detail.vehicle_spd().has_vehicle_spd()) {
    chassis_.set_speed_mps(chassis_detail.vehicle_spd().vehicle_spd());
  } else {
    chassis_.set_speed_mps(0);
  }
  // 6
  chassis_.set_odometer_m(0);
  // 7
  // lincoln only has fuel percentage
  // to avoid confusing, just don't set
  chassis_.set_fuel_range_m(0);
  // 8
  if (chassis_detail.has_gas() &amp;&amp; chassis_detail.gas().has_throttle_output()) {
    chassis_.set_throttle_percentage(chassis_detail.gas().throttle_output());
  } else {
    chassis_.set_throttle_percentage(0);
  }
  // 9
  if (chassis_detail.has_brake() &amp;&amp; chassis_detail.brake().has_brake_output()) {
    chassis_.set_brake_percentage(chassis_detail.brake().brake_output());
  } else {
    chassis_.set_brake_percentage(0);
  }
  // 23, previously 10
  if (chassis_detail.has_gear() &amp;&amp; chassis_detail.gear().has_gear_state()) {
    chassis_.set_gear_location(chassis_detail.gear().gear_state());
  } else {
    chassis_.set_gear_location(Chassis::GEAR_NONE);
  }
  // 11
  if (chassis_detail.has_eps() &amp;&amp; chassis_detail.eps().has_steering_angle()) {
    chassis_.set_steering_percentage(chassis_detail.eps().steering_angle() *
                                     100.0 / params_.max_steer_angle());
  } else {
    chassis_.set_steering_percentage(0);
  }
  // 12
  if (chassis_detail.has_eps() &amp;&amp; chassis_detail.eps().has_epas_torque()) {
    chassis_.set_steering_torque_nm(chassis_detail.eps().epas_torque());
  } else {
    chassis_.set_steering_torque_nm(0);
  }
  // 13
  if (chassis_detail.has_eps() &amp;&amp;
      chassis_detail.epb().has_parking_brake_status()) {
    chassis_.set_parking_brake(chassis_detail.epb().parking_brake_status() ==
                               Epb::PBRAKE_ON);
  } else {
    chassis_.set_parking_brake(false);
  }
  // TODO(Authors): lincoln beam
  // 14, 15

  // 16, 17
  if (chassis_detail.has_light() &amp;&amp;
      chassis_detail.light().has_turn_light_type() &amp;&amp;
      chassis_detail.light().turn_light_type() != Light::TURN_LIGHT_OFF) {
    if (chassis_detail.light().turn_light_type() == Light::TURN_LEFT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(
          common::VehicleSignal::TURN_LEFT);
    } else if (chassis_detail.light().turn_light_type() ==
               Light::TURN_RIGHT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(
          common::VehicleSignal::TURN_RIGHT);
    } else {
      chassis_.mutable_signal()-&gt;set_turn_signal(
          common::VehicleSignal::TURN_NONE);
    }
  } else {
    chassis_.mutable_signal()-&gt;set_turn_signal(
        common::VehicleSignal::TURN_NONE);
  }
  // 18
  if (chassis_detail.has_light() &amp;&amp; chassis_detail.light().has_is_horn_on() &amp;&amp;
      chassis_detail.light().is_horn_on()) {
    chassis_.mutable_signal()-&gt;set_horn(true);
  } else {
    chassis_.mutable_signal()-&gt;set_horn(false);
  }

  // 19, lincoln wiper is too complicated
  // 24
  if (chassis_detail.has_eps() &amp;&amp; chassis_detail.eps().has_timestamp_65()) {
    chassis_.set_steering_timestamp(chassis_detail.eps().timestamp_65());
  }
  // 26
  if (chassis_error_mask_) {
    chassis_.set_chassis_error_mask(chassis_error_mask_);
  }

  return chassis_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(142, 0)" endLine="(257, 1)" clone_start="37" clone_end="46">
			<code function_name="LincolnController::chassis()">Chassis LincolnController::chassis() {
  chassis_.Clear();

  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  // 21, 22, previously 1, 2
  if (driving_mode() == Chassis::EMERGENCY_MODE) {
    set_chassis_error_code(Chassis::NO_ERROR);
  }

  chassis_.set_driving_mode(driving_mode());
  chassis_.set_error_code(chassis_error_code());

  // 3
  chassis_.set_engine_started(true);
  // 4
  if (chassis_detail.has_ems() &amp;&amp; chassis_detail.ems().has_engine_rpm()) {
    chassis_.set_engine_rpm(chassis_detail.ems().engine_rpm());
  } else {
    chassis_.set_engine_rpm(0);
  }
  // 5
  if (chassis_detail.has_vehicle_spd() &amp;&amp;
      chassis_detail.vehicle_spd().has_vehicle_spd()) {
    chassis_.set_speed_mps(chassis_detail.vehicle_spd().vehicle_spd());
  } else {
    chassis_.set_speed_mps(0);
  }
  // 6
  chassis_.set_odometer_m(0);
  // 7
  // lincoln only has fuel percentage
  // to avoid confusing, just don't set
  chassis_.set_fuel_range_m(0);
  // 8
  if (chassis_detail.has_gas() &amp;&amp; chassis_detail.gas().has_throttle_output()) {
    chassis_.set_throttle_percentage(chassis_detail.gas().throttle_output());
  } else {
    chassis_.set_throttle_percentage(0);
  }
  // 9
  if (chassis_detail.has_brake() &amp;&amp; chassis_detail.brake().has_brake_output()) {
    chassis_.set_brake_percentage(chassis_detail.brake().brake_output());
  } else {
    chassis_.set_brake_percentage(0);
  }
  // 23, previously 10
  if (chassis_detail.has_gear() &amp;&amp; chassis_detail.gear().has_gear_state()) {
    chassis_.set_gear_location(chassis_detail.gear().gear_state());
  } else {
    chassis_.set_gear_location(Chassis::GEAR_NONE);
  }
  // 11
  if (chassis_detail.has_eps() &amp;&amp; chassis_detail.eps().has_steering_angle()) {
    chassis_.set_steering_percentage(chassis_detail.eps().steering_angle() *
                                     100.0 / params_.max_steer_angle());
  } else {
    chassis_.set_steering_percentage(0);
  }
  // 12
  if (chassis_detail.has_eps() &amp;&amp; chassis_detail.eps().has_epas_torque()) {
    chassis_.set_steering_torque_nm(chassis_detail.eps().epas_torque());
  } else {
    chassis_.set_steering_torque_nm(0);
  }
  // 13
  if (chassis_detail.has_eps() &amp;&amp;
      chassis_detail.epb().has_parking_brake_status()) {
    chassis_.set_parking_brake(chassis_detail.epb().parking_brake_status() ==
                               Epb::PBRAKE_ON);
  } else {
    chassis_.set_parking_brake(false);
  }
  // TODO(Authors): lincoln beam
  // 14, 15

  // 16, 17
  if (chassis_detail.has_light() &amp;&amp;
      chassis_detail.light().has_turn_light_type() &amp;&amp;
      chassis_detail.light().turn_light_type() != Light::TURN_LIGHT_OFF) {
    if (chassis_detail.light().turn_light_type() == Light::TURN_LEFT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(
          common::VehicleSignal::TURN_LEFT);
    } else if (chassis_detail.light().turn_light_type() ==
               Light::TURN_RIGHT_ON) {
      chassis_.mutable_signal()-&gt;set_turn_signal(
          common::VehicleSignal::TURN_RIGHT);
    } else {
      chassis_.mutable_signal()-&gt;set_turn_signal(
          common::VehicleSignal::TURN_NONE);
    }
  } else {
    chassis_.mutable_signal()-&gt;set_turn_signal(
        common::VehicleSignal::TURN_NONE);
  }
  // 18
  if (chassis_detail.has_light() &amp;&amp; chassis_detail.light().has_is_horn_on() &amp;&amp;
      chassis_detail.light().is_horn_on()) {
    chassis_.mutable_signal()-&gt;set_horn(true);
  } else {
    chassis_.mutable_signal()-&gt;set_horn(false);
  }

  // 19, lincoln wiper is too complicated
  // 24
  if (chassis_detail.has_eps() &amp;&amp; chassis_detail.eps().has_timestamp_65()) {
    chassis_.set_steering_timestamp(chassis_detail.eps().timestamp_65());
  }
  // 26
  if (chassis_error_mask_) {
    chassis_.set_chassis_error_mask(chassis_error_mask_);
  }

  return chassis_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\include\velodyne_pointcloud\pointcloud_dump.h" startLine="(34, 2)" endLine="(34, 22)" clone_start="1" clone_end="1">
			<code function_name="~PointCloudDump()">  ~PointCloudDump() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\include\velodyne_pointcloud\compensator.h" startLine="(36, 2)" endLine="(36, 27)" clone_start="1" clone_end="1">
			<code function_name="~Compensator()">  virtual ~Compensator() {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(153, 0)" endLine="(193, 1)" clone_start="24" clone_end="31">
			<code function_name="ProtoOrganizer::GetLaneSignalOverlapElements(    const std::string&amp; lane_id, const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes)">void ProtoOrganizer::GetLaneSignalOverlapElements(
    const std::string&amp; lane_id,
    const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes) {
  for (auto&amp; overlap_signal : overlap_with_lanes) {
    std::string object_id = overlap_signal.object_id;
    if (proto_data_.pb_signals.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_stop_signs.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_yield_signs.count(object_id) &lt;= 0) {
      AINFO &lt;&lt; "cannot find signal object_id:" &lt;&lt; object_id;
      continue;
    }
    PbOverlap overlap;
    std::string overlap_id = CreateOverlapId();
    proto_data_.pb_lanes[lane_id].add_overlap_id()-&gt;set_id(overlap_id);
    overlap.mutable_id()-&gt;set_id(overlap_id);
    PbObjectOverlapInfo* object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(lane_id);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_start_s(
        overlap_signal.start_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_end_s(
        overlap_signal.end_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_is_merge(
        overlap_signal.is_merge);
    object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
    if (proto_data_.pb_signals.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_signal_overlap_info();
      proto_data_.pb_signals[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    } else if (proto_data_.pb_stop_signs.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_stop_sign_overlap_info();
      proto_data_.pb_stop_signs[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    } else if (proto_data_.pb_yield_signs.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_yield_sign_overlap_info();
      proto_data_.pb_yield_signs[object_id].add_overlap_id()-&gt;set_id(
          overlap_id);
    } else {
      AERROR &lt;&lt; "unknown signal, signal id:" &lt;&lt; object_id;
    }
    proto_data_.pb_overlaps[overlap_id] = overlap;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(280, 0)" endLine="(309, 1)" clone_start="14" clone_end="22">
			<code function_name="ProtoOrganizer::GetJunctionObjectOverlapElements( const std::vector&lt;JunctionInternal&gt;&amp; junctions)">void ProtoOrganizer::GetJunctionObjectOverlapElements(
    const std::vector&lt;JunctionInternal&gt;&amp; junctions) {
  for (auto&amp; junction_internal : junctions) {
    std::string junction_id = junction_internal.junction.id().id();
    for (auto&amp; overlap_junction : junction_internal.overlap_with_junctions) {
      PbOverlap overlap;
      std::string overlap_id = CreateOverlapId();
      proto_data_.pb_junctions[junction_id].add_overlap_id()-&gt;set_id(
          overlap_id);
      overlap.mutable_id()-&gt;set_id(overlap_id);
      PbObjectOverlapInfo* object_overlap = overlap.add_object();
      object_overlap-&gt;mutable_id()-&gt;set_id(junction_id);
      std::string object_id = overlap_junction.object_id;
      object_overlap = overlap.add_object();
      object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
      if (proto_data_.pb_crosswalks.count(object_id) &gt; 0) {
        object_overlap-&gt;mutable_crosswalk_overlap_info();
        proto_data_.pb_crosswalks[object_id].add_overlap_id()-&gt;set_id(
            overlap_id);
      } else if (proto_data_.pb_clear_areas.count(object_id) &gt; 0) {
        object_overlap-&gt;mutable_clear_area_overlap_info();
        proto_data_.pb_clear_areas[object_id].add_overlap_id()-&gt;set_id(
            overlap_id);
      } else {
        continue;
      }
      proto_data_.pb_overlaps[overlap_id] = overlap;
    }
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\tests\test_monitor.cpp" startLine="(43, 0)" endLine="(70, 1)" clone_start="1" clone_end="8">
			<code function_name="stream_status_callback(const apollo::common::gnss_status::StreamStatus &amp;stream_status)">void stream_status_callback(const apollo::common::gnss_status::StreamStatus &amp;stream_status) {
    switch (stream_status.ins_stream_type()) {
    case apollo::common::gnss_status::StreamStatus::CONNECTED:
        fprintf(stdout, "INS stream is CONNECTED.\r\n");
        break;
    case apollo::common::gnss_status::StreamStatus::DISCONNECTED:
        fprintf(stdout, "INS stream is DISCONNECTED.\r\n");
        break;
    }

    switch (stream_status.rtk_stream_in_type()) {
    case apollo::common::gnss_status::StreamStatus::CONNECTED:
        fprintf(stdout, "rtk stream in is CONNECTED.\r\n");
        break;
    case apollo::common::gnss_status::StreamStatus::DISCONNECTED:
        fprintf(stdout, "rtk stream in is DISCONNECTED.\r\n");
        break;
    }

    switch (stream_status.rtk_stream_out_type()) {
    case apollo::common::gnss_status::StreamStatus::CONNECTED:
        fprintf(stdout, "rtk stream out CONNECTED.\r\n");
        break;
    case apollo::common::gnss_status::StreamStatus::DISCONNECTED:
        fprintf(stdout, "rtk stream out DISCONNECTED.\r\n");
        break;
    }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\tests\test_monitor.cpp" startLine="(24, 0)" endLine="(37, 1)" clone_start="1" clone_end="8">
			<code function_name="ins_status_callback(const apollo::common::gnss_status::InsStatus &amp;ins_status)">void ins_status_callback(const apollo::common::gnss_status::InsStatus &amp;ins_status) {
    switch (ins_status.type()) {
    case apollo::common::gnss_status::InsStatus::GOOD:
        fprintf(stdout, "INS status is GOOD.\r\n");
        break;
    case apollo::common::gnss_status::InsStatus::CONVERGING:
        fprintf(stdout, "INS status is CONVERGING.\r\n");
        break;
    case apollo::common::gnss_status::InsStatus::INVALID:
    default:    
        fprintf(stdout, "INS status is INVALID.\r\n");
        break;
    }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\interface\base_segmentation.h" startLine="(78, 2)" endLine="(78, 23)" clone_start="1" clone_end="1">
			<code function_name="BaseSegmentation()">  BaseSegmentation() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\interface\base_ground_detector.h" startLine="(80, 2)" endLine="(80, 25)" clone_start="1" clone_end="1">
			<code function_name="BaseGroundDetector()">  BaseGroundDetector() {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\interface\base_segmentation.h" startLine="(79, 2)" endLine="(79, 32)" clone_start="1" clone_end="1">
			<code function_name="~BaseSegmentation()">  virtual ~BaseSegmentation() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\interface\base_ground_detector.h" startLine="(81, 2)" endLine="(81, 34)" clone_start="1" clone_end="1">
			<code function_name="~BaseGroundDetector()">  virtual ~BaseGroundDetector() {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\segmentation\cnnseg\cnn_segmentation.cc" startLine="(196, 0)" endLine="(226, 1)" clone_start="18" clone_end="28">
			<code function_name="CNNSegmentation::GetConfigs(string* config_file, string* proto_file, string* weight_file)">bool CNNSegmentation::GetConfigs(string* config_file, string* proto_file,
                                 string* weight_file) {
  ConfigManager* config_manager = ConfigManager::instance();

  const ModelConfig* model_config = nullptr;
  if (!config_manager-&gt;GetModelConfig("CNNSegmentation", &amp;model_config)) {
    AERROR &lt;&lt; "Failed to get model config for CNNSegmentation";
    return false;
  }
  const string&amp; work_root = config_manager-&gt;work_root();

  if (!model_config-&gt;GetValue("config_file", config_file)) {
    AERROR &lt;&lt; "Failed to get value of config_file.";
    return false;
  }
  config_file-&gt;assign(FileUtil::GetAbsolutePath(work_root, *config_file));

  if (!model_config-&gt;GetValue("proto_file", proto_file)) {
    AERROR &lt;&lt; "Failed to get value of proto_file.";
    return false;
  }
  proto_file-&gt;assign(FileUtil::GetAbsolutePath(work_root, *proto_file));

  if (!model_config-&gt;GetValue("weight_file", weight_file)) {
    AERROR &lt;&lt; "Failed to get value of weight_file.";
    return false;
  }
  weight_file-&gt;assign(FileUtil::GetAbsolutePath(work_root, *weight_file));

  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\segmentation\cnnseg\cnn_segmentation.cc" startLine="(196, 0)" endLine="(226, 1)" clone_start="12" clone_end="22">
			<code function_name="CNNSegmentation::GetConfigs(string* config_file, string* proto_file, string* weight_file)">bool CNNSegmentation::GetConfigs(string* config_file, string* proto_file,
                                 string* weight_file) {
  ConfigManager* config_manager = ConfigManager::instance();

  const ModelConfig* model_config = nullptr;
  if (!config_manager-&gt;GetModelConfig("CNNSegmentation", &amp;model_config)) {
    AERROR &lt;&lt; "Failed to get model config for CNNSegmentation";
    return false;
  }
  const string&amp; work_root = config_manager-&gt;work_root();

  if (!model_config-&gt;GetValue("config_file", config_file)) {
    AERROR &lt;&lt; "Failed to get value of config_file.";
    return false;
  }
  config_file-&gt;assign(FileUtil::GetAbsolutePath(work_root, *config_file));

  if (!model_config-&gt;GetValue("proto_file", proto_file)) {
    AERROR &lt;&lt; "Failed to get value of proto_file.";
    return false;
  }
  proto_file-&gt;assign(FileUtil::GetAbsolutePath(work_root, *proto_file));

  if (!model_config-&gt;GetValue("weight_file", weight_file)) {
    AERROR &lt;&lt; "Failed to get value of weight_file.";
    return false;
  }
  weight_file-&gt;assign(FileUtil::GetAbsolutePath(work_root, *weight_file));

  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\simulation_world\simulation_world_service.cc" startLine="(84, 0)" endLine="(103, 1)" clone_start="9" clone_end="16">
			<code function_name="DeduceDisengageType(const Chassis &amp;chassis)">Object::DisengageType DeduceDisengageType(const Chassis &amp;chassis) {
  if (chassis.error_code() != Chassis::NO_ERROR) {
    return Object::DISENGAGE_CHASSIS_ERROR;
  }

  switch (chassis.driving_mode()) {
    case Chassis::COMPLETE_AUTO_DRIVE:
      return Object::DISENGAGE_NONE;
    case Chassis::COMPLETE_MANUAL:
      return Object::DISENGAGE_MANUAL;
    case Chassis::AUTO_STEER_ONLY:
      return Object::DISENGAGE_AUTO_STEER_ONLY;
    case Chassis::AUTO_SPEED_ONLY:
      return Object::DISENGAGE_AUTO_SPEED_ONLY;
    case Chassis::EMERGENCY_MODE:
      return Object::DISENGAGE_EMERGENCY;
    default:
      return Object::DISENGAGE_UNKNOWN;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\simulation_world\simulation_world_service.cc" startLine="(84, 0)" endLine="(103, 1)" clone_start="7" clone_end="14">
			<code function_name="DeduceDisengageType(const Chassis &amp;chassis)">Object::DisengageType DeduceDisengageType(const Chassis &amp;chassis) {
  if (chassis.error_code() != Chassis::NO_ERROR) {
    return Object::DISENGAGE_CHASSIS_ERROR;
  }

  switch (chassis.driving_mode()) {
    case Chassis::COMPLETE_AUTO_DRIVE:
      return Object::DISENGAGE_NONE;
    case Chassis::COMPLETE_MANUAL:
      return Object::DISENGAGE_MANUAL;
    case Chassis::AUTO_STEER_ONLY:
      return Object::DISENGAGE_AUTO_STEER_ONLY;
    case Chassis::AUTO_SPEED_ONLY:
      return Object::DISENGAGE_AUTO_SPEED_ONLY;
    case Chassis::EMERGENCY_MODE:
      return Object::DISENGAGE_EMERGENCY;
    default:
      return Object::DISENGAGE_UNKNOWN;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(422, 0)" endLine="(424, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline2dConstraint::AddThirdDerivativeSmoothConstraint()">const AffineConstraint&amp; Spline2dConstraint::inequality_constraint() const {
  return inequality_constraint_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(548, 0)" endLine="(550, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline1dConstraint::AddMonotoneInequalityConstraintAtKnots()">const AffineConstraint&amp; Spline1dConstraint::inequality_constraint() const {
  return inequality_constraint_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(426, 0)" endLine="(428, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline2dConstraint::AddThirdDerivativeSmoothConstraint()">const AffineConstraint&amp; Spline2dConstraint::equality_constraint() const {
  return equality_constraint_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(552, 0)" endLine="(554, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline1dConstraint::AddMonotoneInequalityConstraintAtKnots()">const AffineConstraint&amp; Spline1dConstraint::equality_constraint() const {
  return equality_constraint_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(430, 0)" endLine="(435, 1)" clone_start="1" clone_end="5">
			<code function_name="Spline2dConstraint::FindIndex(const double t) const">std::uint32_t Spline2dConstraint::FindIndex(const double t) const {
  auto upper_bound = std::upper_bound(t_knots_.begin() + 1, t_knots_.end(), t);
  return std::min(static_cast&lt;std::uint32_t&gt;(t_knots_.size() - 1),
                  static_cast&lt;std::uint32_t&gt;(upper_bound - t_knots_.begin())) -
         1;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(556, 0)" endLine="(561, 1)" clone_start="1" clone_end="5">
			<code function_name="Spline1dConstraint::FindIndex(const double x) const">std::uint32_t Spline1dConstraint::FindIndex(const double x) const {
  auto upper_bound = std::upper_bound(x_knots_.begin() + 1, x_knots_.end(), x);
  return std::min(static_cast&lt;std::uint32_t&gt;(x_knots_.size() - 1),
                  static_cast&lt;std::uint32_t&gt;(upper_bound - x_knots_.begin())) -
         1;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\pcd_exporter.cpp" startLine="(51, 0)" endLine="(90, 1)" clone_start="28" clone_end="38">
			<code function_name="PCDExporter::init()">void PCDExporter::init() {
  _tf_buffer_ptr = boost::shared_ptr&lt;tf2_ros::Buffer&gt;(new tf2_ros::Buffer());
  _tf_listener_ptr = boost::shared_ptr&lt;tf2_ros::TransformListener&gt;(
      new tf2_ros::TransformListener(*_tf_buffer_ptr));
  if (_pcd_folder == "") {
    ROS_ERROR_STREAM("No pcd_folder input");
    ROS_BREAK();
  }

  ROS_INFO_STREAM("pcd_folder :" &lt;&lt; _pcd_folder);
  // check output directory, if not exist create it
  if (!boost::filesystem::exists(_pcd_folder)) {
    ROS_INFO_STREAM("The directory " &lt;&lt; _pcd_folder
                                     &lt;&lt; " is not exists, create now");
    if (boost::filesystem::create_directory(_pcd_folder)) {
      ROS_INFO("Create directory success.");
    } else {
      ROS_ERROR("Create directory failed! ");
      ROS_BREAK();
    }
  }

  if (boost::filesystem::exists(_pose_file)) {
    boost::filesystem::remove(_pose_file);
    ROS_INFO_STREAM("Remove the legacy pose file in pcd folder");
  }
  if ((_pose_file_handle = fopen(_pose_file.c_str(), "a")) == NULL) {
    ROS_ERROR_STREAM("Cannot open pose file!");
    ROS_BREAK();
  }

  if (boost::filesystem::exists(_stamp_file)) {
    boost::filesystem::remove(_stamp_file);
    ROS_INFO("Remove the legacy stamp file in pcd folder");
  }
  if ((_stamp_file_handle = fopen(_stamp_file.c_str(), "a")) == NULL) {
    ROS_ERROR_STREAM("Cannot open stamp file!");
    ROS_BREAK();
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\pcd_exporter.cpp" startLine="(51, 0)" endLine="(90, 1)" clone_start="18" clone_end="29">
			<code function_name="PCDExporter::init()">void PCDExporter::init() {
  _tf_buffer_ptr = boost::shared_ptr&lt;tf2_ros::Buffer&gt;(new tf2_ros::Buffer());
  _tf_listener_ptr = boost::shared_ptr&lt;tf2_ros::TransformListener&gt;(
      new tf2_ros::TransformListener(*_tf_buffer_ptr));
  if (_pcd_folder == "") {
    ROS_ERROR_STREAM("No pcd_folder input");
    ROS_BREAK();
  }

  ROS_INFO_STREAM("pcd_folder :" &lt;&lt; _pcd_folder);
  // check output directory, if not exist create it
  if (!boost::filesystem::exists(_pcd_folder)) {
    ROS_INFO_STREAM("The directory " &lt;&lt; _pcd_folder
                                     &lt;&lt; " is not exists, create now");
    if (boost::filesystem::create_directory(_pcd_folder)) {
      ROS_INFO("Create directory success.");
    } else {
      ROS_ERROR("Create directory failed! ");
      ROS_BREAK();
    }
  }

  if (boost::filesystem::exists(_pose_file)) {
    boost::filesystem::remove(_pose_file);
    ROS_INFO_STREAM("Remove the legacy pose file in pcd folder");
  }
  if ((_pose_file_handle = fopen(_pose_file.c_str(), "a")) == NULL) {
    ROS_ERROR_STREAM("Cannot open pose file!");
    ROS_BREAK();
  }

  if (boost::filesystem::exists(_stamp_file)) {
    boost::filesystem::remove(_stamp_file);
    ROS_INFO("Remove the legacy stamp file in pcd folder");
  }
  if ((_stamp_file_handle = fopen(_stamp_file.c_str(), "a")) == NULL) {
    ROS_ERROR_STREAM("Cannot open stamp file!");
    ROS_BREAK();
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\planning.cc" startLine="(85, 0)" endLine="(130, 1)" clone_start="16" clone_end="24">
			<code function_name="Planning::Init()">Status Planning::Init() {
  pnc_map_.reset(new hdmap::PncMap(apollo::hdmap::BaseMapFile()));
  Frame::SetMap(pnc_map_.get());

  CHECK(apollo::common::util::GetProtoFromFile(FLAGS_planning_config_file,
                                               &amp;config_))
      &lt;&lt; "failed to load planning config file " &lt;&lt; FLAGS_planning_config_file;
  if (!AdapterManager::Initialized()) {
    AdapterManager::Init(FLAGS_adapter_config_filename);
  }
  if (AdapterManager::GetLocalization() == nullptr) {
    std::string error_msg("Localization is not registered");
    AERROR &lt;&lt; error_msg;
    return Status(ErrorCode::PLANNING_ERROR, error_msg);
  }
  if (AdapterManager::GetChassis() == nullptr) {
    std::string error_msg("Chassis is not registered");
    AERROR &lt;&lt; error_msg;
    return Status(ErrorCode::PLANNING_ERROR, error_msg);
  }
  if (AdapterManager::GetRoutingResponse() == nullptr) {
    std::string error_msg("RoutingResponse is not registered");
    AERROR &lt;&lt; error_msg;
    return Status(ErrorCode::PLANNING_ERROR, error_msg);
  }
  if (FLAGS_enable_prediction &amp;&amp; AdapterManager::GetPrediction() == nullptr) {
    std::string error_msg("Prediction is not registered");
    AERROR &lt;&lt; error_msg;
    return Status(ErrorCode::PLANNING_ERROR, error_msg);
  }

  if (FLAGS_enable_reference_line_provider_thread) {
    ReferenceLineProvider::instance()-&gt;Init(
        pnc_map_.get(), config_.reference_line_smoother_config());
  }

  RegisterPlanners();
  planner_ = planner_factory_.CreateObject(config_.planner_type());
  if (!planner_) {
    return Status(
        ErrorCode::PLANNING_ERROR,
        "planning is not initialized with config : " + config_.DebugString());
  }

  return planner_-&gt;Init(config_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\planning.cc" startLine="(85, 0)" endLine="(130, 1)" clone_start="11" clone_end="19">
			<code function_name="Planning::Init()">Status Planning::Init() {
  pnc_map_.reset(new hdmap::PncMap(apollo::hdmap::BaseMapFile()));
  Frame::SetMap(pnc_map_.get());

  CHECK(apollo::common::util::GetProtoFromFile(FLAGS_planning_config_file,
                                               &amp;config_))
      &lt;&lt; "failed to load planning config file " &lt;&lt; FLAGS_planning_config_file;
  if (!AdapterManager::Initialized()) {
    AdapterManager::Init(FLAGS_adapter_config_filename);
  }
  if (AdapterManager::GetLocalization() == nullptr) {
    std::string error_msg("Localization is not registered");
    AERROR &lt;&lt; error_msg;
    return Status(ErrorCode::PLANNING_ERROR, error_msg);
  }
  if (AdapterManager::GetChassis() == nullptr) {
    std::string error_msg("Chassis is not registered");
    AERROR &lt;&lt; error_msg;
    return Status(ErrorCode::PLANNING_ERROR, error_msg);
  }
  if (AdapterManager::GetRoutingResponse() == nullptr) {
    std::string error_msg("RoutingResponse is not registered");
    AERROR &lt;&lt; error_msg;
    return Status(ErrorCode::PLANNING_ERROR, error_msg);
  }
  if (FLAGS_enable_prediction &amp;&amp; AdapterManager::GetPrediction() == nullptr) {
    std::string error_msg("Prediction is not registered");
    AERROR &lt;&lt; error_msg;
    return Status(ErrorCode::PLANNING_ERROR, error_msg);
  }

  if (FLAGS_enable_reference_line_provider_thread) {
    ReferenceLineProvider::instance()-&gt;Init(
        pnc_map_.get(), config_.reference_line_smoother_config());
  }

  RegisterPlanners();
  planner_ = planner_factory_.CreateObject(config_.planner_type());
  if (!planner_) {
    return Status(
        ErrorCode::PLANNING_ERROR,
        "planning is not initialized with config : " + config_.DebugString());
  }

  return planner_-&gt;Init(config_);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\objects_xml_parser.cc" startLine="(59, 0)" endLine="(94, 1)" clone_start="1" clone_end="10">
			<code function_name="ObjectsXmlParser::ParseClearAreas(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;PbClearArea&gt;* clear_areas)">Status ObjectsXmlParser::ParseClearAreas(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;PbClearArea&gt;* clear_areas) {
  CHECK_NOTNULL(clear_areas);
  const tinyxml2::XMLElement* sub_node = xml_node.FirstChildElement("object");
  while (sub_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
    checker +=
        UtilXmlParser::QueryStringAttribute(*sub_node, "type", &amp;object_type);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse object type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "clearArea") {
      PbClearArea clear_area;
      clear_area.mutable_id()-&gt;set_id(object_id);
      PbPolygon* polygon = clear_area.mutable_polygon();
      CHECK(polygon != nullptr);
      const tinyxml2::XMLElement* outline_node =
          sub_node-&gt;FirstChildElement("outline");
      if (outline_node == nullptr) {
        std::string err_msg = "Error parse cleararea outline";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseOutline(*outline_node, polygon));
      clear_areas-&gt;emplace_back(clear_area);
    }
    sub_node = sub_node-&gt;NextSiblingElement("object");
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\objects_xml_parser.cc" startLine="(26, 0)" endLine="(57, 1)" clone_start="1" clone_end="9">
			<code function_name="ObjectsXmlParser::ParseCrosswalks(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;PbCrosswalk&gt;* crosswalks)">Status ObjectsXmlParser::ParseCrosswalks(const tinyxml2::XMLElement&amp; xml_node,
                                         std::vector&lt;PbCrosswalk&gt;* crosswalks) {
  CHECK_NOTNULL(crosswalks);
  const tinyxml2::XMLElement* sub_node = xml_node.FirstChildElement("object");
  while (sub_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*sub_node, "type", &amp;object_type);
    checker += UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse object type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "crosswalk") {
      PbCrosswalk crosswalk;
      crosswalk.mutable_id()-&gt;set_id(object_id);
      PbPolygon* polygon = crosswalk.mutable_polygon();
      const tinyxml2::XMLElement* outline_node =
          sub_node-&gt;FirstChildElement("outline");
      if (outline_node == nullptr) {
        std::string err_msg = "Error parse crosswalk outline";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseOutline(*outline_node, polygon));
      crosswalks-&gt;emplace_back(crosswalk);
    }
    sub_node = sub_node-&gt;NextSiblingElement("object");
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(240, 0)" endLine="(281, 1)" clone_start="41" clone_end="42">
			<code function_name="TcpStream::read(uint8_t* buffer, size_t max_length)">size_t TcpStream::read(uint8_t* buffer, size_t max_length) {
  ssize_t ret = 0;

  if (_status != Stream::Status::CONNECTED) {
    disconnect();
    connect();
    if (_status != Stream::Status::CONNECTED) {
      return 0;
    }
  }

  if (!readable(10000)) {
    return 0;
  }

  while ((ret = ::recv(_sockfd, buffer, max_length, 0)) &lt; 0) {
    if (errno == EINTR) {
      continue;
    } else {
      // error
      if (errno != EAGAIN) {
        _status = Stream::Status::ERROR;
        _errno = errno;
        ROS_ERROR("Read errno %d, error %s.", errno, strerror(errno));
      }
    }

    return 0;
  }

  if (ret == 0) {
    _status = Stream::Status::ERROR;
    _errno = errno;
    ROS_ERROR("Remote closed.");
    disconnect();
    if (connect()) {
      ROS_INFO("Reconnect tcp success.");
    }
  }

  return ret;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(230, 0)" endLine="(238, 1)" clone_start="8" clone_end="9">
			<code function_name="TcpStream::disconnect()">bool TcpStream::disconnect() {
  if (_sockfd &lt; 0) {
    // not open
    return false;
  }

  this-&gt;close();
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(283, 0)" endLine="(318, 1)" clone_start="1" clone_end="8">
			<code function_name="TcpStream::write(const uint8_t* buffer, size_t length)">size_t TcpStream::write(const uint8_t* buffer, size_t length) {
  size_t total_nsent = 0;

  if (_status != Stream::Status::CONNECTED) {
    disconnect();
    connect();
    if (_status != Stream::Status::CONNECTED) {
      return 0;
    }
  }

  while (length &gt; 0) {
    ssize_t nsent = ::send(_sockfd, buffer, length, 0);
    if (nsent &lt; 0) {
      if (errno == EINTR) {
        continue;
      } else {
        // error
        if (errno == EPIPE || errno == ECONNRESET) {
          _status = Stream::Status::DISCONNECTED;
          _errno = errno;
        } else if (errno != EAGAIN) {
          _status = Stream::Status::ERROR;
          _errno = errno;
        }
        return total_nsent;
      }
    }

    total_nsent += nsent;
    length -= nsent;
    buffer += nsent;
  }

  return total_nsent;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(240, 0)" endLine="(281, 1)" clone_start="1" clone_end="8">
			<code function_name="TcpStream::read(uint8_t* buffer, size_t max_length)">size_t TcpStream::read(uint8_t* buffer, size_t max_length) {
  ssize_t ret = 0;

  if (_status != Stream::Status::CONNECTED) {
    disconnect();
    connect();
    if (_status != Stream::Status::CONNECTED) {
      return 0;
    }
  }

  if (!readable(10000)) {
    return 0;
  }

  while ((ret = ::recv(_sockfd, buffer, max_length, 0)) &lt; 0) {
    if (errno == EINTR) {
      continue;
    } else {
      // error
      if (errno != EAGAIN) {
        _status = Stream::Status::ERROR;
        _errno = errno;
        ROS_ERROR("Read errno %d, error %s.", errno, strerror(errno));
      }
    }

    return 0;
  }

  if (ret == 0) {
    _status = Stream::Status::ERROR;
    _errno = errno;
    ROS_ERROR("Remote closed.");
    disconnect();
    if (connect()) {
      ROS_INFO("Reconnect tcp success.");
    }
  }

  return ret;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(162, 0)" endLine="(173, 1)" clone_start="11" clone_end="12">
			<code function_name="Brakeinfo74::wheel_torque_actual(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::wheel_torque_actual(const std::uint8_t *bytes,
                                        int32_t length) const {
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 6);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FFF) {
    value -= 0x4000;
  }
  return value * 4.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(75, 0)" endLine="(87, 1)" clone_start="12" clone_end="13">
			<code function_name="Steering65::steering_angle(const std::uint8_t *bytes, int32_t length) const">double Steering65::steering_angle(const std::uint8_t *bytes,
                                  int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x8000) {
    value = value - 0x10000;
  }

  return value * 0.100000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gyro_6c.cc" startLine="(35, 0)" endLine="(45, 1)" clone_start="10" clone_end="11">
			<code function_name="Gyro6c::roll_rate(const std::uint8_t *bytes, int32_t length) const">double Gyro6c::roll_rate(const std::uint8_t *bytes, int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.000200;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(175, 0)" endLine="(187, 1)" clone_start="1" clone_end="9">
			<code function_name="Brakeinfo74::acceleration_over_ground(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::acceleration_over_ground(const std::uint8_t *bytes,
                                             int32_t length) const {
  // vehicle acceleration over ground estimate
  Byte frame_high(bytes + 7);
  int32_t high = frame_high.get_byte(0, 2);
  Byte frame_low(bytes + 6);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FF) {
    value -= 0x400;
  }
  return value * 0.035000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(89, 0)" endLine="(101, 1)" clone_start="1" clone_end="8">
			<code function_name="Steering65::reported_steering_angle_cmd(const std::uint8_t *bytes, int32_t length) const">double Steering65::reported_steering_angle_cmd(const std::uint8_t *bytes,
                                               int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x8000) {
    value = value - 0x10000;
  }

  return value * 0.100000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gyro_6c.cc" startLine="(47, 0)" endLine="(57, 1)" clone_start="1" clone_end="7">
			<code function_name="Gyro6c::yaw_rate(const std::uint8_t *bytes, int32_t length) const">double Gyro6c::yaw_rate(const std::uint8_t *bytes, int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.000200;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\calibration\republish_msg\republish_msg.cc" startLine="(52, 0)" endLine="(87, 1)" clone_start="1" clone_end="14">
			<code function_name="RepublishMsg::OnGps(const localization::Gps&amp; msg)">void RepublishMsg::OnGps(const localization::Gps&amp; msg) {
  if (msg.has_localization()) {
    const auto pose_msg = msg.localization();

    Eigen::Quaterniond rotation(
        pose_msg.orientation().qw(), pose_msg.orientation().qx(),
        pose_msg.orientation().qy(), pose_msg.orientation().qz());
    Eigen::Translation3d translation(pose_msg.position().x(),
                                     pose_msg.position().y(),
                                     pose_msg.position().z());
    Eigen::Affine3d pose = translation * rotation;

    if (is_first_gps_msg_) {
      is_first_gps_msg_ = false;
      offset_ = pose.inverse();
    }

    Eigen::Affine3d pub_pose = offset_ * pose;
    Eigen::Quaterniond pub_rot(pub_pose.rotation());
    Eigen::Translation3d pub_trans(pub_pose.translation());

    calibration::republish_msg::RelativeOdometry pub_msg;
    pub_msg.mutable_header()-&gt;set_timestamp_sec(msg.header().timestamp_sec());
    pub_msg.mutable_orientation()-&gt;set_qw(pub_rot.w());
    pub_msg.mutable_orientation()-&gt;set_qx(pub_rot.x());
    pub_msg.mutable_orientation()-&gt;set_qy(pub_rot.y());
    pub_msg.mutable_orientation()-&gt;set_qz(pub_rot.z());
    pub_msg.mutable_position()-&gt;set_x(pub_trans.x());
    pub_msg.mutable_position()-&gt;set_y(pub_trans.y());
    pub_msg.mutable_position()-&gt;set_z(pub_trans.z());

    pub_msg.set_position_type(position_type_);

    AdapterManager::PublishRelativeOdometry(pub_msg);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\calibration\lidar_ex_checker\lidar_ex_checker.cc" startLine="(170, 0)" endLine="(195, 1)" clone_start="1" clone_end="13">
			<code function_name="LidarExChecker::OnGps(const localization::Gps&amp; message)">void LidarExChecker::OnGps(const localization::Gps&amp; message) {
  if (message.has_localization()) {
    const auto pose_msg = message.localization();
    Eigen::Quaterniond rotation(
        pose_msg.orientation().qw(), pose_msg.orientation().qx(),
        pose_msg.orientation().qy(), pose_msg.orientation().qz());
    Eigen::Translation3d translation(pose_msg.position().x(),
                                     pose_msg.position().y(),
                                     pose_msg.position().z());
    Eigen::Affine3d pose = translation * rotation;

    if (is_first_gps_msg_) {
      is_first_gps_msg_ = false;
      last_position_[0] = translation.x();
      last_position_[1] = translation.y();
      last_position_[2] = translation.z();
      offset_ = pose.inverse();
    }
    Eigen::Affine3d new_pose = offset_ * pose;

    double timestamp = message.header().timestamp_sec();
    timestamp = round(timestamp * 100) / 100.0;

    gps_poses_.insert(std::make_pair(timestamp, new_pose));
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6d.cc" startLine="(59, 0)" endLine="(83, 1)" clone_start="16" clone_end="25">
			<code function_name="Gps6d::longitude(const std::uint8_t *bytes, int32_t length) const">double Gps6d::longitude(const std::uint8_t *bytes, int32_t length) const {
  Byte frame_0(bytes + 7);
  int32_t value = frame_0.get_byte(0, 7);

  Byte frame_1(bytes + 6);
  int32_t t = frame_1.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_2(bytes + 5);
  t = frame_2.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_3(bytes + 4);
  t = frame_3.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  if (value &gt; 0x3FFFFFFF) {
    value -= 0x80000000;
  }

  return value * (1.000000 / 3.000000) * 1e-6;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6d.cc" startLine="(33, 0)" endLine="(57, 1)" clone_start="16" clone_end="25">
			<code function_name="Gps6d::latitude(const std::uint8_t *bytes, int32_t length) const">double Gps6d::latitude(const std::uint8_t *bytes, int32_t length) const {
  Byte frame_0(bytes + 3);
  int32_t value = frame_0.get_byte(0, 7);

  Byte frame_1(bytes + 2);
  int32_t t = frame_1.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_2(bytes + 1);
  t = frame_2.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_3(bytes);
  t = frame_3.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  if (value &gt; 0x3FFFFFFF) {
    value -= 0x80000000;
  }

  return value * (1.000000 / 3.000000) * 1e-6;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6d.cc" startLine="(85, 0)" endLine="(88, 1)" clone_start="1" clone_end="2">
			<code function_name="Gps6d::is_valid(const std::uint8_t *bytes, int32_t length) const">bool Gps6d::is_valid(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6d.cc" startLine="(59, 0)" endLine="(83, 1)" clone_start="1" clone_end="2">
			<code function_name="Gps6d::longitude(const std::uint8_t *bytes, int32_t length) const">double Gps6d::longitude(const std::uint8_t *bytes, int32_t length) const {
  Byte frame_0(bytes + 7);
  int32_t value = frame_0.get_byte(0, 7);

  Byte frame_1(bytes + 6);
  int32_t t = frame_1.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_2(bytes + 5);
  t = frame_2.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_3(bytes + 4);
  t = frame_3.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  if (value &gt; 0x3FFFFFFF) {
    value -= 0x80000000;
  }

  return value * (1.000000 / 3.000000) * 1e-6;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\rtk\rtk_localization.cc" startLine="(37, 0)" endLine="(57, 1)" clone_start="9" clone_end="17">
			<code function_name="RTKLocalization::Start()">Status RTKLocalization::Start() {
  AdapterManager::Init(FLAGS_rtk_adapter_config_file);

  // start ROS timer, one-shot = false, auto-start = true
  const double duration = 1.0 / FLAGS_localization_publish_freq;
  timer_ = AdapterManager::CreateTimer(ros::Duration(duration),
                                       &amp;RTKLocalization::OnTimer, this);
  common::monitor::MonitorBuffer buffer(&amp;monitor_);
  if (!AdapterManager::GetGps()) {
    buffer.ERROR() &lt;&lt; "GPS input not initialized. Check file "
                   &lt;&lt; FLAGS_rtk_adapter_config_file;
    buffer.PrintLog();
    return Status(common::LOCALIZATION_ERROR, "no GPS adapter");
  }
  if (!AdapterManager::GetImu()) {
    buffer.ERROR("IMU input not initialized. Check your adapter.conf file!");
    buffer.PrintLog();
    return Status(common::LOCALIZATION_ERROR, "no IMU adapter");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\camera\camera_localization.cc" startLine="(36, 0)" endLine="(73, 1)" clone_start="23" clone_end="32">
			<code function_name="CameraLocalization::Start()">Status CameraLocalization::Start() {
  MonitorBuffer buffer(&amp;monitor_);
  if (!common::util::GetProtoFromFile(FLAGS_camera_parameter_config_file,
                                      &amp;camera_parameter_)) {
    buffer.ERROR() &lt;&lt; "Camera parameter is not initialized. Check "
                   &lt;&lt; FLAGS_camera_parameter_config_file;
    buffer.PrintLog();
    return Status(common::LOCALIZATION_ERROR,
                  "failed to load camera parameter");
  }

  AdapterManager::Init(FLAGS_camera_adapter_config_file);
  // start ROS timer, one-shot = false, auto-start = true
  const double duration = 1.0 / FLAGS_localization_publish_freq;
  timer_ = AdapterManager::CreateTimer(ros::Duration(duration),
                                       &amp;CameraLocalization::OnTimer, this);
  if (!AdapterManager::GetGps()) {
    buffer.ERROR() &lt;&lt; "GPS input not initialized. Check "
                   &lt;&lt; FLAGS_camera_adapter_config_file;
    buffer.PrintLog();
    return Status(common::LOCALIZATION_ERROR, "no GPS adapter");
  }
  if (!AdapterManager::GetCamera()) {
    buffer.ERROR() &lt;&lt; "Camera input not initialized. Check "
                   &lt;&lt; FLAGS_camera_adapter_config_file;
    buffer.PrintLog();
    return Status(common::LOCALIZATION_ERROR, "no Camera adapter");
  }
  // IMU is optional
  if (!AdapterManager::GetImu()) {
    buffer.INFO("IMU input not initialized. Check your adapter.conf file!");
    buffer.PrintLog();
    use_imu_ = false;
  } else {
    use_imu_ = true;
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\segmentation\cnnseg\cnn_segmentation.cc" startLine="(28, 0)" endLine="(132, 1)" clone_start="25" clone_end="33">
			<code function_name="CNNSegmentation::Init()">bool CNNSegmentation::Init() {
  string config_file;
  string proto_file;
  string weight_file;
  if (!GetConfigs(&amp;config_file, &amp;proto_file, &amp;weight_file)) {
    return false;
  }
  AINFO &lt;&lt; "--    config_file: " &lt;&lt; config_file;
  AINFO &lt;&lt; "--     proto_file: " &lt;&lt; proto_file;
  AINFO &lt;&lt; "--    weight_file: " &lt;&lt; weight_file;

  if (!apollo::common::util::GetProtoFromFile(config_file, &amp;cnnseg_param_)) {
    AERROR &lt;&lt; "Failed to load config file of CNNSegmentation.";
  }

  /// set parameters
  auto network_param = cnnseg_param_.network_param();
  auto feature_param = cnnseg_param_.feature_param();

  if (feature_param.has_point_cloud_range()) {
    range_ = static_cast&lt;float&gt;(feature_param.point_cloud_range());
  } else {
    range_ = 60.0;
  }
  if (feature_param.has_width()) {
    width_ = static_cast&lt;int&gt;(feature_param.width());
  } else {
    width_ = 512;
  }
  if (feature_param.has_height()) {
    height_ = static_cast&lt;int&gt;(feature_param.height());
  } else {
    height_ = 512;
  }

/// Instantiate Caffe net
#ifndef USE_CAFFE_GPU
  caffe::Caffe::set_mode(caffe::Caffe::CPU);
#else
  int gpu_id =
      cnnseg_param_.has_gpu_id() ? static_cast&lt;int&gt;(cnnseg_param_.gpu_id()) : 0;
  CHECK_GE(gpu_id, 0);
  caffe::Caffe::SetDevice(gpu_id);
  caffe::Caffe::set_mode(caffe::Caffe::GPU);
  caffe::Caffe::DeviceQuery();
#endif

  caffe_net_.reset(new caffe::Net&lt;float&gt;(proto_file, caffe::TEST));
  caffe_net_-&gt;CopyTrainedLayersFrom(weight_file);

#ifndef USE_CAFFE_GPU
  AINFO &lt;&lt; "using Caffe CPU mode";
#else
  AINFO &lt;&lt; "using Caffe GPU mode";
#endif

  /// set related Caffe blobs
  // center offset prediction
  string instance_pt_blob_name = network_param.has_instance_pt_blob()
                                     ? network_param.instance_pt_blob()
                                     : "instance_pt";
  instance_pt_blob_ = caffe_net_-&gt;blob_by_name(instance_pt_blob_name);
  CHECK(instance_pt_blob_ != nullptr) &lt;&lt; "`" &lt;&lt; instance_pt_blob_name
                                      &lt;&lt; "` not exists!";
  // objectness prediction
  string category_pt_blob_name = network_param.has_category_pt_blob()
                                     ? network_param.category_pt_blob()
                                     : "category_score";
  category_pt_blob_ = caffe_net_-&gt;blob_by_name(category_pt_blob_name);
  CHECK(category_pt_blob_ != nullptr) &lt;&lt; "`" &lt;&lt; category_pt_blob_name
                                      &lt;&lt; "` not exists!";
  // positiveness (foreground object probability) prediction
  string confidence_pt_blob_name = network_param.has_confidence_pt_blob()
                                       ? network_param.confidence_pt_blob()
                                       : "confidence_score";
  confidence_pt_blob_ = caffe_net_-&gt;blob_by_name(confidence_pt_blob_name);
  CHECK(confidence_pt_blob_ != nullptr) &lt;&lt; "`" &lt;&lt; confidence_pt_blob_name
                                        &lt;&lt; "` not exists!";
  // object height prediction
  string height_pt_blob_name = network_param.has_height_pt_blob()
                                   ? network_param.height_pt_blob()
                                   : "height_pt";
  height_pt_blob_ = caffe_net_-&gt;blob_by_name(height_pt_blob_name);
  CHECK(height_pt_blob_ != nullptr) &lt;&lt; "`" &lt;&lt; height_pt_blob_name
                                    &lt;&lt; "` not exists!";
  // raw feature data
  string feature_blob_name =
      network_param.has_feature_blob() ? network_param.feature_blob() : "data";
  feature_blob_ = caffe_net_-&gt;blob_by_name(feature_blob_name);
  CHECK(feature_blob_ != nullptr) &lt;&lt; "`" &lt;&lt; feature_blob_name
                                  &lt;&lt; "` not exists!";

  cluster2d_.reset(new cnnseg::Cluster2D());
  if (!cluster2d_-&gt;Init(height_, width_, range_)) {
    AERROR &lt;&lt; "Fail to init cluster2d for CNNSegmentation";
  }

  feature_generator_.reset(new cnnseg::FeatureGenerator&lt;float&gt;());
  if (!feature_generator_-&gt;Init(feature_param, feature_blob_.get())) {
    AERROR &lt;&lt; "Fail to init feature generator for CNNSegmentation";
    return false;
  }

  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\segmentation\cnnseg\cnn_segmentation.cc" startLine="(28, 0)" endLine="(132, 1)" clone_start="20" clone_end="28">
			<code function_name="CNNSegmentation::Init()">bool CNNSegmentation::Init() {
  string config_file;
  string proto_file;
  string weight_file;
  if (!GetConfigs(&amp;config_file, &amp;proto_file, &amp;weight_file)) {
    return false;
  }
  AINFO &lt;&lt; "--    config_file: " &lt;&lt; config_file;
  AINFO &lt;&lt; "--     proto_file: " &lt;&lt; proto_file;
  AINFO &lt;&lt; "--    weight_file: " &lt;&lt; weight_file;

  if (!apollo::common::util::GetProtoFromFile(config_file, &amp;cnnseg_param_)) {
    AERROR &lt;&lt; "Failed to load config file of CNNSegmentation.";
  }

  /// set parameters
  auto network_param = cnnseg_param_.network_param();
  auto feature_param = cnnseg_param_.feature_param();

  if (feature_param.has_point_cloud_range()) {
    range_ = static_cast&lt;float&gt;(feature_param.point_cloud_range());
  } else {
    range_ = 60.0;
  }
  if (feature_param.has_width()) {
    width_ = static_cast&lt;int&gt;(feature_param.width());
  } else {
    width_ = 512;
  }
  if (feature_param.has_height()) {
    height_ = static_cast&lt;int&gt;(feature_param.height());
  } else {
    height_ = 512;
  }

/// Instantiate Caffe net
#ifndef USE_CAFFE_GPU
  caffe::Caffe::set_mode(caffe::Caffe::CPU);
#else
  int gpu_id =
      cnnseg_param_.has_gpu_id() ? static_cast&lt;int&gt;(cnnseg_param_.gpu_id()) : 0;
  CHECK_GE(gpu_id, 0);
  caffe::Caffe::SetDevice(gpu_id);
  caffe::Caffe::set_mode(caffe::Caffe::GPU);
  caffe::Caffe::DeviceQuery();
#endif

  caffe_net_.reset(new caffe::Net&lt;float&gt;(proto_file, caffe::TEST));
  caffe_net_-&gt;CopyTrainedLayersFrom(weight_file);

#ifndef USE_CAFFE_GPU
  AINFO &lt;&lt; "using Caffe CPU mode";
#else
  AINFO &lt;&lt; "using Caffe GPU mode";
#endif

  /// set related Caffe blobs
  // center offset prediction
  string instance_pt_blob_name = network_param.has_instance_pt_blob()
                                     ? network_param.instance_pt_blob()
                                     : "instance_pt";
  instance_pt_blob_ = caffe_net_-&gt;blob_by_name(instance_pt_blob_name);
  CHECK(instance_pt_blob_ != nullptr) &lt;&lt; "`" &lt;&lt; instance_pt_blob_name
                                      &lt;&lt; "` not exists!";
  // objectness prediction
  string category_pt_blob_name = network_param.has_category_pt_blob()
                                     ? network_param.category_pt_blob()
                                     : "category_score";
  category_pt_blob_ = caffe_net_-&gt;blob_by_name(category_pt_blob_name);
  CHECK(category_pt_blob_ != nullptr) &lt;&lt; "`" &lt;&lt; category_pt_blob_name
                                      &lt;&lt; "` not exists!";
  // positiveness (foreground object probability) prediction
  string confidence_pt_blob_name = network_param.has_confidence_pt_blob()
                                       ? network_param.confidence_pt_blob()
                                       : "confidence_score";
  confidence_pt_blob_ = caffe_net_-&gt;blob_by_name(confidence_pt_blob_name);
  CHECK(confidence_pt_blob_ != nullptr) &lt;&lt; "`" &lt;&lt; confidence_pt_blob_name
                                        &lt;&lt; "` not exists!";
  // object height prediction
  string height_pt_blob_name = network_param.has_height_pt_blob()
                                   ? network_param.height_pt_blob()
                                   : "height_pt";
  height_pt_blob_ = caffe_net_-&gt;blob_by_name(height_pt_blob_name);
  CHECK(height_pt_blob_ != nullptr) &lt;&lt; "`" &lt;&lt; height_pt_blob_name
                                    &lt;&lt; "` not exists!";
  // raw feature data
  string feature_blob_name =
      network_param.has_feature_blob() ? network_param.feature_blob() : "data";
  feature_blob_ = caffe_net_-&gt;blob_by_name(feature_blob_name);
  CHECK(feature_blob_ != nullptr) &lt;&lt; "`" &lt;&lt; feature_blob_name
                                  &lt;&lt; "` not exists!";

  cluster2d_.reset(new cnnseg::Cluster2D());
  if (!cluster2d_-&gt;Init(height_, width_, range_)) {
    AERROR &lt;&lt; "Fail to init cluster2d for CNNSegmentation";
  }

  feature_generator_.reset(new cnnseg::FeatureGenerator&lt;float&gt;());
  if (!feature_generator_-&gt;Init(feature_param, feature_blob_.get())) {
    AERROR &lt;&lt; "Fail to init feature generator for CNNSegmentation";
    return false;
  }

  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(392, 0)" endLine="(439, 1)" clone_start="12" clone_end="21">
			<code function_name="Spline1dConstraint::AddSecondDerivativeSmoothConstraint()">bool Spline1dConstraint::AddSecondDerivativeSmoothConstraint() {
  if (x_knots_.size() &lt; 3) {
    return false;
  }

  const std::uint32_t n_constraint = (x_knots_.size() - 2) * 3;
  Eigen::MatrixXd equality_constraint = Eigen::MatrixXd::Zero(
      n_constraint, (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd equality_boundary = Eigen::MatrixXd::Zero(n_constraint, 1);

  for (std::uint32_t i = 0; i &lt; n_constraint; i += 3) {
    double left_coef = 1.0;
    double right_coef = -1.0;
    double left_dcoef = 1.0;
    double right_dcoef = -1.0;
    double left_ddcoef = 1.0;
    double right_ddcoef = -1.0;

    const double x_left = x_knots_[i / 3 + 1] - x_knots_[i / 3];
    const double x_right = 0.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      equality_constraint(i, spline_order_ * (i / 3) + j) = left_coef;
      equality_constraint(i, spline_order_ * (i / 3 + 1) + j) = right_coef;

      if (j &gt;= 2) {
        equality_constraint(i + 2, spline_order_ * i / 3 + j) =
            left_ddcoef * j * (j - 1);
        equality_constraint(i + 2, spline_order_ * (i / 3 + 1) + j) =
            right_ddcoef * j * (j - 1);
        left_ddcoef = left_dcoef;
        right_ddcoef = right_dcoef;
      }

      if (j &gt;= 1) {
        equality_constraint(i + 1, spline_order_ * (i / 3) + j) =
            left_dcoef * j;
        equality_constraint(i + 1, spline_order_ * (i / 3 + 1) + j) =
            right_dcoef * j;
        left_dcoef = left_coef;
        right_dcoef = right_coef;
      }
      left_coef *= x_left;
      right_coef *= x_right;
    }
  }
  return equality_constraint_.AddConstraint(equality_constraint,
                                            equality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(441, 0)" endLine="(499, 1)" clone_start="14" clone_end="23">
			<code function_name="Spline1dConstraint::AddThirdDerivativeSmoothConstraint()">bool Spline1dConstraint::AddThirdDerivativeSmoothConstraint() {
  if (x_knots_.size() &lt; 3) {
    return false;
  }

  const std::uint32_t n_constraint = (x_knots_.size() - 2) * 4;
  Eigen::MatrixXd equality_constraint = Eigen::MatrixXd::Zero(
      n_constraint, (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd equality_boundary = Eigen::MatrixXd::Zero(n_constraint, 1);

  for (std::uint32_t i = 0; i &lt; n_constraint; i += 4) {
    double left_coef = 1.0;
    double right_coef = -1.0;
    double left_dcoef = 1.0;
    double right_dcoef = -1.0;
    double left_ddcoef = 1.0;
    double right_ddcoef = -1.0;
    double left_dddcoef = 1.0;
    double right_dddcoef = -1.0;

    const double x_left = x_knots_[i / 4 + 1] - x_knots_[i / 4];
    const double x_right = 0.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      equality_constraint(i, spline_order_ * i / 4 + j) = left_coef;
      equality_constraint(i, spline_order_ * (i / 4 + 1) + j) = right_coef;

      if (j &gt;= 3) {
        equality_constraint(i + 3, spline_order_ * i / 4 + j) =
            left_dddcoef * j * (j - 1) * (j - 2);
        equality_constraint(i + 3, spline_order_ * (i / 4 + 1) + j) =
            right_dddcoef * j * (j - 1) * (j - 2);
        left_dddcoef = left_ddcoef;
        right_dddcoef = right_ddcoef;
      }

      if (j &gt;= 2) {
        equality_constraint(i + 2, spline_order_ * i / 4 + j) =
            left_ddcoef * j * (j - 1);
        equality_constraint(i + 2, spline_order_ * (i / 4 + 1) + j) =
            right_ddcoef * j * (j - 1);
        left_ddcoef = left_dcoef;
        right_ddcoef = right_dcoef;
      }

      if (j &gt;= 1) {
        equality_constraint(i + 1, spline_order_ * i / 4 + j) = left_dcoef * j;
        equality_constraint(i + 1, spline_order_ * (i / 4 + 1) + j) =
            right_dcoef * j;
        left_dcoef = left_coef;
        right_dcoef = right_coef;
      }

      left_coef *= x_left;
      right_coef *= x_right;
    }
  }
  return equality_constraint_.AddConstraint(equality_constraint,
                                            equality_boundary);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\parser_nodelet.cpp" startLine="(30, 2)" endLine="(30, 20)" clone_start="1" clone_end="1">
			<code function_name="ParserNodelet()">  ParserNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\stream_nodelet.cpp" startLine="(39, 2)" endLine="(39, 20)" clone_start="1" clone_end="1">
			<code function_name="StreamNodelet()">  StreamNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\tf_broadcaster_nodelet.cpp" startLine="(31, 2)" endLine="(31, 27)" clone_start="1" clone_end="1">
			<code function_name="TFBroadcasterNodelet()">  TFBroadcasterNodelet() {}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\parser_nodelet.cpp" startLine="(31, 2)" endLine="(31, 21)" clone_start="1" clone_end="1">
			<code function_name="~ParserNodelet()">  ~ParserNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\stream_nodelet.cpp" startLine="(40, 2)" endLine="(40, 21)" clone_start="1" clone_end="1">
			<code function_name="~StreamNodelet()">  ~StreamNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\tf_broadcaster_nodelet.cpp" startLine="(32, 2)" endLine="(32, 28)" clone_start="1" clone_end="1">
			<code function_name="~TFBroadcasterNodelet()">  ~TFBroadcasterNodelet() {}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\parser_nodelet.cpp" startLine="(39, 0)" endLine="(72, 1)" clone_start="1" clone_end="2">
			<code function_name="ParserNodelet::onInit()">void ParserNodelet::onInit() {
  ros::NodeHandle&amp; nh = getPrivateNodeHandle();
  std::string gnss_conf;
  std::string raw_data_topic;
  std::string ins_stat_topic;
  std::string corr_imu_topic;
  std::string odometry_topic;
  std::string gnss_status_topic;
  std::string ins_status_topic;

  nh.param("gnss_conf", gnss_conf, std::string("./conf/gnss_conf.txt"));
  nh.param("raw_data_topic", raw_data_topic,
           std::string("/apollo/sensor/gnss/raw_data"));
  nh.param("ins_stat_topic", ins_stat_topic,
           std::string("/apollo/sensor/gnss/ins_stat"));
  nh.param("corr_imu_topic", corr_imu_topic,
           std::string("/apollo/sensor/gnss/corrected_imu"));
  nh.param("odometry_topic", odometry_topic,
           std::string("/apollo/sensor/gnss/odometry"));
  nh.param("gnss_status_topic", gnss_status_topic,
           std::string("/apollo/sensor/gnss/gnss_status"));
  nh.param("ins_status_topic", ins_status_topic,
           std::string("/apollo/sensor/gnss/ins_status"));

  _data_parser.reset(new DataParser(nh, raw_data_topic, ins_stat_topic,
                                    corr_imu_topic, odometry_topic,
                                    gnss_status_topic, ins_status_topic));
  if (!_data_parser-&gt;init(gnss_conf)) {
    ROS_ERROR("Init parser nodelet failed.");
    ROS_ERROR_STREAM("Init parser nodelet failed.");
    return;
  }
  ROS_INFO("Init parser nodelet success.");
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\stream_nodelet.cpp" startLine="(47, 0)" endLine="(74, 1)" clone_start="1" clone_end="2">
			<code function_name="StreamNodelet::onInit()">void StreamNodelet::onInit() {
  ros::NodeHandle&amp; nh = getPrivateNodeHandle();
  std::string gnss_conf;
  std::string raw_data_topic;
  std::string rtcm_data_topic;
  std::string stream_status_topic;

  nh.param("gnss_conf", gnss_conf, std::string("./conf/gnss_conf.txt"));
  nh.param("raw_data_topic", raw_data_topic,
           std::string("/apollo/sensor/gnss/raw_data"));
  nh.param("rtcm_data_topic", rtcm_data_topic,
           std::string("/apollo/sensor/gnss/rtcm_data"));
  nh.param("stream_status_topic", stream_status_topic,
           std::string("/apollo/sensor/gnss/stream_status"));

  ROS_INFO_STREAM("gnss conf: " &lt;&lt; gnss_conf);
  ROS_INFO_STREAM("raw data topic: " &lt;&lt; raw_data_topic);

  init_signal();
  _raw_stream.reset(new RawStream(nh, getName(), raw_data_topic,
                                  rtcm_data_topic, stream_status_topic));
  if (!_raw_stream-&gt;init(gnss_conf)) {
    ROS_ERROR("Init stream nodelet failed.");
    ROS_ERROR_STREAM("Init stream nodelet failed.");
    return;
  }
  ROS_INFO("Init stream nodelet success.");
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\tf_broadcaster_nodelet.cpp" startLine="(40, 0)" endLine="(46, 1)" clone_start="1" clone_end="2">
			<code function_name="TFBroadcasterNodelet::onInit()">void TFBroadcasterNodelet::onInit() {
  ros::NodeHandle&amp; nh = getPrivateNodeHandle();

  _tf_broadcaster.reset(new TFBroadcaster(nh));
  _tf_broadcaster-&gt;init();
  ROS_INFO("Init tf broadcaster nodelet success.");
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\dp_st_speed\dp_st_graph.cc" startLine="(516, 0)" endLine="(537, 1)" clone_start="10" clone_end="21">
			<code function_name="DpStGraph::CreateYieldDecision(const StBoundary&amp; boundary, ObjectDecisionType* const yield_decision) const">bool DpStGraph::CreateYieldDecision(
    const StBoundary&amp; boundary,
    ObjectDecisionType* const yield_decision) const {
  auto* yield = yield_decision-&gt;mutable_yield();

  // in meters
  constexpr double kMinYieldDistance = 10.0;
  const double yield_distance_s =
      std::max(-boundary.min_s(), -1.0 * kMinYieldDistance);
  yield-&gt;set_distance_s(yield_distance_s);

  const double reference_line_fence_s =
      adc_sl_boundary_.end_s() + boundary.min_s() + yield_distance_s;
  auto ref_point = reference_line_.GetReferencePoint(reference_line_fence_s);

  yield-&gt;mutable_fence_point()-&gt;set_x(ref_point.x());
  yield-&gt;mutable_fence_point()-&gt;set_y(ref_point.y());
  yield-&gt;mutable_fence_point()-&gt;set_z(0.0);
  yield-&gt;set_fence_heading(ref_point.heading());

  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\dp_st_speed\dp_st_graph.cc" startLine="(539, 0)" endLine="(571, 1)" clone_start="21" clone_end="32">
			<code function_name="DpStGraph::CreateOvertakeDecision(    const PathObstacle&amp; path_obstacle, const StBoundary&amp; boundary, ObjectDecisionType* const overtake_decision) const">bool DpStGraph::CreateOvertakeDecision(
    const PathObstacle&amp; path_obstacle, const StBoundary&amp; boundary,
    ObjectDecisionType* const overtake_decision) const {
  DCHECK_NOTNULL(overtake_decision);

  auto* overtake = overtake_decision-&gt;mutable_overtake();

  // in seconds
  constexpr double kOvertakeTimeBuffer = 3.0;
  // in meters
  constexpr double kMinOvertakeDistance = 10.0;

  const auto&amp; velocity = path_obstacle.obstacle()-&gt;Perception().velocity();
  const double obstacle_speed =
      Vec2d::CreateUnitVec2d(init_point_.path_point().theta())
          .InnerProd(Vec2d(velocity.x(), velocity.y()));

  const double overtake_distance_s = std::fmax(
      std::fmax(init_point_.v(), obstacle_speed) * kOvertakeTimeBuffer,
      kMinOvertakeDistance);
  overtake-&gt;set_distance_s(overtake_distance_s);

  const double reference_line_fence_s =
      adc_sl_boundary_.end_s() + boundary.min_s() + overtake_distance_s;

  auto ref_point = reference_line_.GetReferencePoint(reference_line_fence_s);
  overtake-&gt;mutable_fence_point()-&gt;set_x(ref_point.x());
  overtake-&gt;mutable_fence_point()-&gt;set_y(ref_point.y());
  overtake-&gt;mutable_fence_point()-&gt;set_z(0.0);
  overtake-&gt;set_fence_heading(ref_point.heading());

  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\pedestrian\regional_predictor.cc" startLine="(341, 0)" endLine="(374, 1)" clone_start="12" clone_end="21">
			<code function_name="RegionalPredictor::InsertTrajectoryPoint(const TrajectoryPoint&amp; prev_middle_point, const Eigen::Vector2d&amp; middle_direction, const TrajectoryPoint&amp; boundary_point, const double speed, const double delta_ts, int* left_i, int* right_i, double* left_heading, double* right_heading, std::vector&lt;TrajectoryPoint&gt;* left_points, std::vector&lt;TrajectoryPoint&gt;* right_points)">void RegionalPredictor::InsertTrajectoryPoint(
    const TrajectoryPoint&amp; prev_middle_point,
    const Eigen::Vector2d&amp; middle_direction,
    const TrajectoryPoint&amp; boundary_point, const double speed,
    const double delta_ts, int* left_i, int* right_i, double* left_heading,
    double* right_heading, std::vector&lt;TrajectoryPoint&gt;* left_points,
    std::vector&lt;TrajectoryPoint&gt;* right_points) {
  Eigen::Vector2d boundary_direction =
      GetUnitVector2d(prev_middle_point, boundary_point);
  double cross_product = CrossProduct(boundary_direction, middle_direction);
  if (cross_product &lt; 0.0) {
    if (!left_points-&gt;empty()) {
      TrajectoryPoint&amp; prev_point = left_points-&gt;back();
      Eigen::Vector2d dir = GetUnitVector2d(prev_point, boundary_point);
      *left_heading = std::atan2(dir[1], dir[0]);
      prev_point.mutable_path_point()-&gt;set_theta(*left_heading);
      prev_point.set_v(speed);
      prev_point.set_relative_time((*left_i) * delta_ts);
      ++(*left_i);
    }
    left_points-&gt;push_back(boundary_point);
  } else {
    if (!right_points-&gt;empty()) {
      TrajectoryPoint&amp; prev_point = right_points-&gt;back();
      Eigen::Vector2d dir = GetUnitVector2d(prev_point, boundary_point);
      *right_heading = std::atan2(dir[1], dir[0]);
      prev_point.mutable_path_point()-&gt;set_theta(*right_heading);
      prev_point.set_v(speed);
      prev_point.set_relative_time((*right_i) * delta_ts);
      ++(*right_i);
    }
    right_points-&gt;push_back(boundary_point);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\pedestrian\regional_predictor.cc" startLine="(341, 0)" endLine="(374, 1)" clone_start="23" clone_end="32">
			<code function_name="RegionalPredictor::InsertTrajectoryPoint(const TrajectoryPoint&amp; prev_middle_point, const Eigen::Vector2d&amp; middle_direction, const TrajectoryPoint&amp; boundary_point, const double speed, const double delta_ts, int* left_i, int* right_i, double* left_heading, double* right_heading, std::vector&lt;TrajectoryPoint&gt;* left_points, std::vector&lt;TrajectoryPoint&gt;* right_points)">void RegionalPredictor::InsertTrajectoryPoint(
    const TrajectoryPoint&amp; prev_middle_point,
    const Eigen::Vector2d&amp; middle_direction,
    const TrajectoryPoint&amp; boundary_point, const double speed,
    const double delta_ts, int* left_i, int* right_i, double* left_heading,
    double* right_heading, std::vector&lt;TrajectoryPoint&gt;* left_points,
    std::vector&lt;TrajectoryPoint&gt;* right_points) {
  Eigen::Vector2d boundary_direction =
      GetUnitVector2d(prev_middle_point, boundary_point);
  double cross_product = CrossProduct(boundary_direction, middle_direction);
  if (cross_product &lt; 0.0) {
    if (!left_points-&gt;empty()) {
      TrajectoryPoint&amp; prev_point = left_points-&gt;back();
      Eigen::Vector2d dir = GetUnitVector2d(prev_point, boundary_point);
      *left_heading = std::atan2(dir[1], dir[0]);
      prev_point.mutable_path_point()-&gt;set_theta(*left_heading);
      prev_point.set_v(speed);
      prev_point.set_relative_time((*left_i) * delta_ts);
      ++(*left_i);
    }
    left_points-&gt;push_back(boundary_point);
  } else {
    if (!right_points-&gt;empty()) {
      TrajectoryPoint&amp; prev_point = right_points-&gt;back();
      Eigen::Vector2d dir = GetUnitVector2d(prev_point, boundary_point);
      *right_heading = std::atan2(dir[1], dir[0]);
      prev_point.mutable_path_point()-&gt;set_theta(*right_heading);
      prev_point.set_v(speed);
      prev_point.set_relative_time((*right_i) * delta_ts);
      ++(*right_i);
    }
    right_points-&gt;push_back(boundary_point);
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\util\util.cc" startLine="(67, 0)" endLine="(79, 1)" clone_start="4" clone_end="12">
			<code function_name="MakePathPoint(const double x, const double y, const double z,const double theta, const double kappa, const double dkappa, const double ddkappa)">PathPoint MakePathPoint(const double x, const double y, const double z,
                        const double theta, const double kappa,
                        const double dkappa, const double ddkappa) {
  PathPoint path_point;
  path_point.set_x(x);
  path_point.set_y(y);
  path_point.set_z(z);
  path_point.set_theta(theta);
  path_point.set_kappa(kappa);
  path_point.set_dkappa(dkappa);
  path_point.set_ddkappa(ddkappa);
  return path_point;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\planning_util.cc" startLine="(35, 0)" endLine="(71, 1)" clone_start="28" clone_end="36">
			<code function_name="interpolate(const PathPoint &amp;p0, const PathPoint &amp;p1, const double s)">PathPoint interpolate(const PathPoint &amp;p0, const PathPoint &amp;p1,
                      const double s) {
  double s0 = p0.s();
  double s1 = p1.s();
  CHECK(s0 &lt;= s &amp;&amp; s &lt;= s1);

  std::array&lt;double, 2&gt; gx0{{p0.theta(), p0.kappa()}};
  std::array&lt;double, 2&gt; gx1{{p1.theta(), p1.kappa()}};
  HermiteSpline&lt;double, 3&gt; geometry_spline(gx0, gx1, s0, s1);
  auto func_cos_theta = [&amp;geometry_spline](const double s) {
    auto theta = geometry_spline.Evaluate(0, s);
    return std::cos(theta);
  };
  auto func_sin_theta = [&amp;geometry_spline](const double s) {
    auto theta = geometry_spline.Evaluate(0, s);
    return std::sin(theta);
  };

  double x =
      p0.x() + common::math::IntegrateByGaussLegendre(func_cos_theta, s0, s);
  double y =
      p0.y() + common::math::IntegrateByGaussLegendre(func_sin_theta, s0, s);
  double theta = geometry_spline.Evaluate(0, s);
  double kappa = geometry_spline.Evaluate(1, s);
  double dkappa = geometry_spline.Evaluate(2, s);
  double d2kappa = geometry_spline.Evaluate(3, s);

  PathPoint p;
  p.set_x(x);
  p.set_y(y);
  p.set_theta(theta);
  p.set_kappa(kappa);
  p.set_dkappa(dkappa);
  p.set_ddkappa(d2kappa);
  p.set_s(s);
  return p;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(56, 0)" endLine="(107, 1)" clone_start="44" clone_end="52">
			<code function_name="Spline1dConstraint::AddBoundary(const std::vector&lt;double&gt;&amp; x_coord,const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddBoundary(const std::vector&lt;double&gt;&amp; x_coord,
                                     const std::vector&lt;double&gt;&amp; lower_bound,
                                     const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }
  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);

    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) = coef;
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) = coef;
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }

  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(109, 0)" endLine="(159, 1)" clone_start="44" clone_end="51">
			<code function_name="Spline1dConstraint::AddDerivativeBoundary(const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }

  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);
    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 1; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) = coef * j;
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 1; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) = coef * j;
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }
  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(161, 0)" endLine="(211, 1)" clone_start="44" clone_end="51">
			<code function_name="Spline1dConstraint::AddSecondDerivativeBoundary(    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddSecondDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }

  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);
    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 2; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) = coef * j * (j - 1);
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 2; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) = coef * j * (j - 1);
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }
  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(109, 0)" endLine="(159, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline1dConstraint::AddDerivativeBoundary(const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }

  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);
    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 1; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) = coef * j;
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 1; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) = coef * j;
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }
  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(161, 0)" endLine="(211, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline1dConstraint::AddSecondDerivativeBoundary(    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddSecondDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }

  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);
    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 2; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) = coef * j * (j - 1);
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 2; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) = coef * j * (j - 1);
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }
  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(213, 0)" endLine="(265, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline1dConstraint::AddThirdDerivativeBoundary(    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddThirdDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);
    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 3; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) =
          coef * j * (j - 1) * (j - 2);
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 3; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) =
          coef * j * (j - 1) * (j - 2);
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }
  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(376, 0)" endLine="(455, 1)" clone_start="39" clone_end="47">
			<code function_name="NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs)">bool NovatelParser::handle_best_pos(const novatel::BestPos* pos,
                                    uint16_t gps_week, uint32_t gps_millisecs) {
  _gnss.mutable_position()-&gt;set_lon(pos-&gt;longitude);
  _gnss.mutable_position()-&gt;set_lat(pos-&gt;latitude);
  _gnss.mutable_position()-&gt;set_height(pos-&gt;height_msl + pos-&gt;undulation);
  _gnss.mutable_position_std_dev()-&gt;set_x(pos-&gt;longitude_std_dev);
  _gnss.mutable_position_std_dev()-&gt;set_y(pos-&gt;latitude_std_dev);
  _gnss.mutable_position_std_dev()-&gt;set_z(pos-&gt;height_std_dev);
  _gnss.set_num_sats(pos-&gt;num_sats_in_solution);
  if (_solution_status != pos-&gt;solution_status) {
    _solution_status = pos-&gt;solution_status;
    ROS_INFO_STREAM("Solution status: " &lt;&lt; static_cast&lt;int&gt;(_solution_status));
  }
  if (_position_type != pos-&gt;position_type) {
    _position_type = pos-&gt;position_type;
    ROS_INFO_STREAM("Position type: " &lt;&lt; static_cast&lt;int&gt;(_position_type));
  }
  _gnss.set_solution_status(static_cast&lt;uint32_t&gt;(pos-&gt;solution_status));
  if (pos-&gt;solution_status == novatel::SolutionStatus::SOL_COMPUTED) {
    _gnss.set_position_type(static_cast&lt;uint32_t&gt;(pos-&gt;position_type));
    switch (pos-&gt;position_type) {
      case novatel::SolutionType::SINGLE:
      case novatel::SolutionType::INS_PSRSP:
        _gnss.set_type(apollo::drivers::gnss::Gnss::SINGLE);
        break;
      case novatel::SolutionType::PSRDIFF:
      case novatel::SolutionType::WAAS:
      case novatel::SolutionType::INS_SBAS:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PSRDIFF);
        break;
      case novatel::SolutionType::FLOATCONV:
      case novatel::SolutionType::L1_FLOAT:
      case novatel::SolutionType::IONOFREE_FLOAT:
      case novatel::SolutionType::NARROW_FLOAT:
      case novatel::SolutionType::RTK_DIRECT_INS:
      case novatel::SolutionType::INS_RTKFLOAT:
        _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_FLOAT);
        break;
      case novatel::SolutionType::WIDELANE:
      case novatel::SolutionType::NARROWLANE:
      case novatel::SolutionType::L1_INT:
      case novatel::SolutionType::WIDE_INT:
      case novatel::SolutionType::NARROW_INT:
      case novatel::SolutionType::INS_RTKFIXED:
        _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_INTEGER);
        break;
      case novatel::SolutionType::OMNISTAR:
      case novatel::SolutionType::INS_OMNISTAR:
      case novatel::SolutionType::INS_OMNISTAR_HP:
      case novatel::SolutionType::INS_OMNISTAR_XP:
      case novatel::SolutionType::OMNISTAR_HP:
      case novatel::SolutionType::OMNISTAR_XP:
      case novatel::SolutionType::PPP_CONVERGING:
      case novatel::SolutionType::PPP:
      case novatel::SolutionType::INS_PPP_CONVERGING:
      case novatel::SolutionType::INS_PPP:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PPP);
        break;
      case novatel::SolutionType::PROPOGATED:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PROPAGATED);
        break;
      default:
        _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
    }
  } else {
    _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
    _gnss.set_position_type(0);
  }
  if (pos-&gt;datum_id != novatel::DatumId::WGS84) {
    ROS_ERROR_STREAM_THROTTLE(
        5, "Unexpected Datum Id: " &lt;&lt; static_cast&lt;int&gt;(pos-&gt;datum_id));
  }

  double seconds = gps_week * SECONDS_PER_WEEK + gps_millisecs * 1e-3;
  if (_gnss.measurement_time() != seconds) {
    _gnss.set_measurement_time(seconds);
    return false;
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(376, 0)" endLine="(455, 1)" clone_start="31" clone_end="39">
			<code function_name="NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs)">bool NovatelParser::handle_best_pos(const novatel::BestPos* pos,
                                    uint16_t gps_week, uint32_t gps_millisecs) {
  _gnss.mutable_position()-&gt;set_lon(pos-&gt;longitude);
  _gnss.mutable_position()-&gt;set_lat(pos-&gt;latitude);
  _gnss.mutable_position()-&gt;set_height(pos-&gt;height_msl + pos-&gt;undulation);
  _gnss.mutable_position_std_dev()-&gt;set_x(pos-&gt;longitude_std_dev);
  _gnss.mutable_position_std_dev()-&gt;set_y(pos-&gt;latitude_std_dev);
  _gnss.mutable_position_std_dev()-&gt;set_z(pos-&gt;height_std_dev);
  _gnss.set_num_sats(pos-&gt;num_sats_in_solution);
  if (_solution_status != pos-&gt;solution_status) {
    _solution_status = pos-&gt;solution_status;
    ROS_INFO_STREAM("Solution status: " &lt;&lt; static_cast&lt;int&gt;(_solution_status));
  }
  if (_position_type != pos-&gt;position_type) {
    _position_type = pos-&gt;position_type;
    ROS_INFO_STREAM("Position type: " &lt;&lt; static_cast&lt;int&gt;(_position_type));
  }
  _gnss.set_solution_status(static_cast&lt;uint32_t&gt;(pos-&gt;solution_status));
  if (pos-&gt;solution_status == novatel::SolutionStatus::SOL_COMPUTED) {
    _gnss.set_position_type(static_cast&lt;uint32_t&gt;(pos-&gt;position_type));
    switch (pos-&gt;position_type) {
      case novatel::SolutionType::SINGLE:
      case novatel::SolutionType::INS_PSRSP:
        _gnss.set_type(apollo::drivers::gnss::Gnss::SINGLE);
        break;
      case novatel::SolutionType::PSRDIFF:
      case novatel::SolutionType::WAAS:
      case novatel::SolutionType::INS_SBAS:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PSRDIFF);
        break;
      case novatel::SolutionType::FLOATCONV:
      case novatel::SolutionType::L1_FLOAT:
      case novatel::SolutionType::IONOFREE_FLOAT:
      case novatel::SolutionType::NARROW_FLOAT:
      case novatel::SolutionType::RTK_DIRECT_INS:
      case novatel::SolutionType::INS_RTKFLOAT:
        _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_FLOAT);
        break;
      case novatel::SolutionType::WIDELANE:
      case novatel::SolutionType::NARROWLANE:
      case novatel::SolutionType::L1_INT:
      case novatel::SolutionType::WIDE_INT:
      case novatel::SolutionType::NARROW_INT:
      case novatel::SolutionType::INS_RTKFIXED:
        _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_INTEGER);
        break;
      case novatel::SolutionType::OMNISTAR:
      case novatel::SolutionType::INS_OMNISTAR:
      case novatel::SolutionType::INS_OMNISTAR_HP:
      case novatel::SolutionType::INS_OMNISTAR_XP:
      case novatel::SolutionType::OMNISTAR_HP:
      case novatel::SolutionType::OMNISTAR_XP:
      case novatel::SolutionType::PPP_CONVERGING:
      case novatel::SolutionType::PPP:
      case novatel::SolutionType::INS_PPP_CONVERGING:
      case novatel::SolutionType::INS_PPP:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PPP);
        break;
      case novatel::SolutionType::PROPOGATED:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PROPAGATED);
        break;
      default:
        _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
    }
  } else {
    _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
    _gnss.set_position_type(0);
  }
  if (pos-&gt;datum_id != novatel::DatumId::WGS84) {
    ROS_ERROR_STREAM_THROTTLE(
        5, "Unexpected Datum Id: " &lt;&lt; static_cast&lt;int&gt;(pos-&gt;datum_id));
  }

  double seconds = gps_week * SECONDS_PER_WEEK + gps_millisecs * 1e-3;
  if (_gnss.measurement_time() != seconds) {
    _gnss.set_measurement_time(seconds);
    return false;
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(376, 0)" endLine="(455, 1)" clone_start="51" clone_end="59">
			<code function_name="NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs)">bool NovatelParser::handle_best_pos(const novatel::BestPos* pos,
                                    uint16_t gps_week, uint32_t gps_millisecs) {
  _gnss.mutable_position()-&gt;set_lon(pos-&gt;longitude);
  _gnss.mutable_position()-&gt;set_lat(pos-&gt;latitude);
  _gnss.mutable_position()-&gt;set_height(pos-&gt;height_msl + pos-&gt;undulation);
  _gnss.mutable_position_std_dev()-&gt;set_x(pos-&gt;longitude_std_dev);
  _gnss.mutable_position_std_dev()-&gt;set_y(pos-&gt;latitude_std_dev);
  _gnss.mutable_position_std_dev()-&gt;set_z(pos-&gt;height_std_dev);
  _gnss.set_num_sats(pos-&gt;num_sats_in_solution);
  if (_solution_status != pos-&gt;solution_status) {
    _solution_status = pos-&gt;solution_status;
    ROS_INFO_STREAM("Solution status: " &lt;&lt; static_cast&lt;int&gt;(_solution_status));
  }
  if (_position_type != pos-&gt;position_type) {
    _position_type = pos-&gt;position_type;
    ROS_INFO_STREAM("Position type: " &lt;&lt; static_cast&lt;int&gt;(_position_type));
  }
  _gnss.set_solution_status(static_cast&lt;uint32_t&gt;(pos-&gt;solution_status));
  if (pos-&gt;solution_status == novatel::SolutionStatus::SOL_COMPUTED) {
    _gnss.set_position_type(static_cast&lt;uint32_t&gt;(pos-&gt;position_type));
    switch (pos-&gt;position_type) {
      case novatel::SolutionType::SINGLE:
      case novatel::SolutionType::INS_PSRSP:
        _gnss.set_type(apollo::drivers::gnss::Gnss::SINGLE);
        break;
      case novatel::SolutionType::PSRDIFF:
      case novatel::SolutionType::WAAS:
      case novatel::SolutionType::INS_SBAS:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PSRDIFF);
        break;
      case novatel::SolutionType::FLOATCONV:
      case novatel::SolutionType::L1_FLOAT:
      case novatel::SolutionType::IONOFREE_FLOAT:
      case novatel::SolutionType::NARROW_FLOAT:
      case novatel::SolutionType::RTK_DIRECT_INS:
      case novatel::SolutionType::INS_RTKFLOAT:
        _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_FLOAT);
        break;
      case novatel::SolutionType::WIDELANE:
      case novatel::SolutionType::NARROWLANE:
      case novatel::SolutionType::L1_INT:
      case novatel::SolutionType::WIDE_INT:
      case novatel::SolutionType::NARROW_INT:
      case novatel::SolutionType::INS_RTKFIXED:
        _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_INTEGER);
        break;
      case novatel::SolutionType::OMNISTAR:
      case novatel::SolutionType::INS_OMNISTAR:
      case novatel::SolutionType::INS_OMNISTAR_HP:
      case novatel::SolutionType::INS_OMNISTAR_XP:
      case novatel::SolutionType::OMNISTAR_HP:
      case novatel::SolutionType::OMNISTAR_XP:
      case novatel::SolutionType::PPP_CONVERGING:
      case novatel::SolutionType::PPP:
      case novatel::SolutionType::INS_PPP_CONVERGING:
      case novatel::SolutionType::INS_PPP:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PPP);
        break;
      case novatel::SolutionType::PROPOGATED:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PROPAGATED);
        break;
      default:
        _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
    }
  } else {
    _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
    _gnss.set_position_type(0);
  }
  if (pos-&gt;datum_id != novatel::DatumId::WGS84) {
    ROS_ERROR_STREAM_THROTTLE(
        5, "Unexpected Datum Id: " &lt;&lt; static_cast&lt;int&gt;(pos-&gt;datum_id));
  }

  double seconds = gps_week * SECONDS_PER_WEEK + gps_millisecs * 1e-3;
  if (_gnss.measurement_time() != seconds) {
    _gnss.set_measurement_time(seconds);
    return false;
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(398, 0)" endLine="(405, 1)" clone_start="1" clone_end="8">
			<code function_name="LincolnController::Brake(double pedal)">void LincolnController::Brake(double pedal) {
  if (!(driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
        driving_mode() == Chassis::AUTO_SPEED_ONLY)) {
    AINFO &lt;&lt; "The current drive mode does not need to set acceleration.";
    return;
  }
  brake_60_-&gt;set_pedal(pedal);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(409, 0)" endLine="(416, 1)" clone_start="1" clone_end="8">
			<code function_name="LincolnController::Throttle(double pedal)">void LincolnController::Throttle(double pedal) {
  if (!(driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
        driving_mode() == Chassis::AUTO_SPEED_ONLY)) {
    AINFO &lt;&lt; "The current drive mode does not need to set acceleration.";
    return;
  }
  throttle_62_-&gt;set_pedal(pedal);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(409, 0)" endLine="(416, 1)" clone_start="1" clone_end="5">
			<code function_name="LincolnController::Throttle(double pedal)">void LincolnController::Throttle(double pedal) {
  if (!(driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
        driving_mode() == Chassis::AUTO_SPEED_ONLY)) {
    AINFO &lt;&lt; "The current drive mode does not need to set acceleration.";
    return;
  }
  throttle_62_-&gt;set_pedal(pedal);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(422, 0)" endLine="(431, 1)" clone_start="1" clone_end="5">
			<code function_name="LincolnController::Steer(double angle)">void LincolnController::Steer(double angle) {
  if (!(driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
        driving_mode() == Chassis::AUTO_STEER_ONLY)) {
    AINFO &lt;&lt; "The current driving mode does not need to set steer.";
    return;
  }
  const double real_angle = params_.max_steer_angle() * angle / 100.0;
  // reverse sign
  steering_64_-&gt;set_steering_angle(real_angle)-&gt;set_steering_angle_speed(200);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\monitor\monitor_buffer.cc" startLine="(31, 0)" endLine="(53, 1)" clone_start="8" clone_end="16">
			<code function_name="MonitorBuffer::PrintLog()">void MonitorBuffer::PrintLog() {
  if (monitor_msg_items_.empty()) {
    return;
  }
  const auto level = monitor_msg_items_.back().first;
  const auto &amp;msg = monitor_msg_items_.back().second;
  switch (level) {
    case MonitorMessageItem::INFO:
      AINFO &lt;&lt; msg;
      break;
    case MonitorMessageItem::WARN:
      AWARN &lt;&lt; msg;
      break;
    case MonitorMessageItem::ERROR:
      AERROR &lt;&lt; msg;
      break;
    case MonitorMessageItem::FATAL:
      AFATAL &lt;&lt; msg;
      break;
    default:
      AERROR &lt;&lt; "[unknown monitor level]: " &lt;&lt; msg;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\monitor\monitor_buffer.cc" startLine="(31, 0)" endLine="(53, 1)" clone_start="11" clone_end="19">
			<code function_name="MonitorBuffer::PrintLog()">void MonitorBuffer::PrintLog() {
  if (monitor_msg_items_.empty()) {
    return;
  }
  const auto level = monitor_msg_items_.back().first;
  const auto &amp;msg = monitor_msg_items_.back().second;
  switch (level) {
    case MonitorMessageItem::INFO:
      AINFO &lt;&lt; msg;
      break;
    case MonitorMessageItem::WARN:
      AWARN &lt;&lt; msg;
      break;
    case MonitorMessageItem::ERROR:
      AERROR &lt;&lt; msg;
      break;
    case MonitorMessageItem::FATAL:
      AFATAL &lt;&lt; msg;
      break;
    default:
      AERROR &lt;&lt; "[unknown monitor level]: " &lt;&lt; msg;
  }
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\common\pid_controller.cc" startLine="(25, 0)" endLine="(58, 1)" clone_start="4" clone_end="16">
			<code function_name="PIDController::Control(const double error, const double dt)">double PIDController::Control(const double error, const double dt) {
  if (dt &lt;= 0) {
    AWARN &lt;&lt; "dt &lt;= 0, will use the last output, dt: " &lt;&lt; dt;
    return previous_output_;
  }
  double diff = 0;
  double output = 0;

  if (first_hit_) {
    first_hit_ = false;
  } else {
    diff = (error - previous_error_) / dt;
  }
  // integral hold
  if (!integrator_enabled_) {
    integral_ = 0;
  } else if (!integrator_hold_) {
    integral_ += error * dt * ki_;
    // apply Ki before integrating to avoid steps when change Ki at steady state
    if (integral_ &gt; integrator_saturation_high_) {
      integral_ = integrator_saturation_high_;
      integrator_saturation_status_ = 1;
    } else if (integral_ &lt; integrator_saturation_low_) {
      integral_ = integrator_saturation_low_;
      integrator_saturation_status_ = -1;
    } else {
      integrator_saturation_status_ = 0;
    }
  }
  previous_error_ = error;
  output = error * kp_ + integral_ + diff * kd_;  // Ki already applied
  previous_output_ = output;
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\common\pid_BC_controller.cc" startLine="(27, 0)" endLine="(65, 1)" clone_start="4" clone_end="17">
			<code function_name="PIDBCController::Control(const double error, const double dt)">double PIDBCController::Control(const double error, const double dt) {
  if (dt &lt;= 0) {
    AWARN &lt;&lt; "dt &lt;= 0, will use the last output";
    return previous_output_;
  }
  double diff = 0;
  double output = 0;

  if (first_hit_) {
    first_hit_ = false;
  } else {
    diff = (error - previous_error_) / dt;
  }

  // backward caculation
  if (!integrator_enabled_) {
    integral_ = 0;
  } else {
    double u = error * kp_ + integral_ + error * dt * ki_ + diff * kd_;
    double aw_term = common::math::Clamp(u, output_saturation_high_,
                                                   output_saturation_low_) -
                     u;
    if (aw_term &gt; 1e-6) {
      output_saturation_status_ = -1;
    } else if (aw_term &lt; -1e-6) {
      output_saturation_status_ = 1;
    } else {
      output_saturation_status_ = 0;
    }
    integral_ += kaw_ * aw_term + error * dt;
  }

  previous_error_ = error;
  output = common::math::Clamp(
      error * kp_ + integral_ + diff * kd_, output_saturation_high_,
      output_saturation_low_);  // Ki already applied
  previous_output_ = output;
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\common\pid_IC_controller.cc" startLine="(27, 0)" endLine="(69, 1)" clone_start="4" clone_end="16">
			<code function_name="PIDICController::Control(const double error, const double dt)">double PIDICController::Control(const double error, const double dt) {
  if (dt &lt;= 0) {
    AWARN &lt;&lt; "dt &lt;= 0, will use the last output";
    return previous_output_;
  }
  double diff = 0;
  double output = 0;

  if (first_hit_) {
    first_hit_ = false;
  } else {
    diff = (error - previous_error_) / dt;
  }
  // integral clamping
  if (!integrator_enabled_) {
    integral_ = 0;
  } else {
    double u = error * kp_ + integral_ + error * dt * ki_ + diff * kd_;
    if (((error * u) &gt; 0) &amp;&amp;
        ((u &gt; output_saturation_high_) || (u &lt; output_saturation_low_))) {
    } else {
      // Only update integral then
      integral_ += error * dt * ki_;
    }
  }

  previous_error_ = error;
  output = error * kp_ + integral_ + diff * kd_;

  if (output &gt;= output_saturation_high_) {
    output_saturation_status_ = 1;
  } else if (output &lt;= output_saturation_low_) {
    output_saturation_status_ = -1;
  } else {
    output_saturation_status_ = 0;
  }

  output = common::math::Clamp(
      error * kp_ + integral_ + diff * kd_, output_saturation_high_,
      output_saturation_low_);  // Ki already applied
  previous_output_ = output;
  return output;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\map\map_service.cc" startLine="(128, 0)" endLine="(171, 1)" clone_start="15" clone_end="28">
			<code function_name="MapService::CollectMapElementIds(const PointENU &amp;point, double radius) const">MapElementIds MapService::CollectMapElementIds(const PointENU &amp;point,
                                               double radius) const {
  MapElementIds result;

  std::vector&lt;LaneInfoConstPtr&gt; lanes;
  if (sim_map_.GetLanes(point, radius, &amp;lanes) != 0) {
    AERROR &lt;&lt; "Fail to get lanes from sim_map.";
  }
  ExtractIds(lanes, &amp;result.lane);

  std::vector&lt;CrosswalkInfoConstPtr&gt; crosswalks;
  if (sim_map_.GetCrosswalks(point, radius, &amp;crosswalks) != 0) {
    AERROR &lt;&lt; "Fail to get crosswalks from sim_map.";
  }
  ExtractIds(crosswalks, &amp;result.crosswalk);

  std::vector&lt;JunctionInfoConstPtr&gt; junctions;
  if (sim_map_.GetJunctions(point, radius, &amp;junctions) != 0) {
    AERROR &lt;&lt; "Fail to get junctions from sim_map.";
  }
  ExtractIds(junctions, &amp;result.junction);

  std::vector&lt;SignalInfoConstPtr&gt; signals;
  if (sim_map_.GetSignals(point, radius, &amp;signals) != 0) {
    AERROR &lt;&lt; "Failed to get signals from sim_map.";
  }

  ExtractIds(signals, &amp;result.signal);
  ExtractOverlapIds(signals, &amp;result.overlap);

  std::vector&lt;StopSignInfoConstPtr&gt; stop_signs;
  if (sim_map_.GetStopSigns(point, radius, &amp;stop_signs) != 0) {
    AERROR &lt;&lt; "Failed to get stop signs from sim_map.";
  }
  ExtractIds(stop_signs, &amp;result.stop_sign);

  std::vector&lt;YieldSignInfoConstPtr&gt; yield_signs;
  if (sim_map_.GetYieldSigns(point, radius, &amp;yield_signs) != 0) {
    AERROR &lt;&lt; "Failed to get yield signs from sim_map.";
  }
  ExtractIds(yield_signs, &amp;result.yield);

  return result;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\map\map_service.cc" startLine="(128, 0)" endLine="(171, 1)" clone_start="9" clone_end="21">
			<code function_name="MapService::CollectMapElementIds(const PointENU &amp;point, double radius) const">MapElementIds MapService::CollectMapElementIds(const PointENU &amp;point,
                                               double radius) const {
  MapElementIds result;

  std::vector&lt;LaneInfoConstPtr&gt; lanes;
  if (sim_map_.GetLanes(point, radius, &amp;lanes) != 0) {
    AERROR &lt;&lt; "Fail to get lanes from sim_map.";
  }
  ExtractIds(lanes, &amp;result.lane);

  std::vector&lt;CrosswalkInfoConstPtr&gt; crosswalks;
  if (sim_map_.GetCrosswalks(point, radius, &amp;crosswalks) != 0) {
    AERROR &lt;&lt; "Fail to get crosswalks from sim_map.";
  }
  ExtractIds(crosswalks, &amp;result.crosswalk);

  std::vector&lt;JunctionInfoConstPtr&gt; junctions;
  if (sim_map_.GetJunctions(point, radius, &amp;junctions) != 0) {
    AERROR &lt;&lt; "Fail to get junctions from sim_map.";
  }
  ExtractIds(junctions, &amp;result.junction);

  std::vector&lt;SignalInfoConstPtr&gt; signals;
  if (sim_map_.GetSignals(point, radius, &amp;signals) != 0) {
    AERROR &lt;&lt; "Failed to get signals from sim_map.";
  }

  ExtractIds(signals, &amp;result.signal);
  ExtractOverlapIds(signals, &amp;result.overlap);

  std::vector&lt;StopSignInfoConstPtr&gt; stop_signs;
  if (sim_map_.GetStopSigns(point, radius, &amp;stop_signs) != 0) {
    AERROR &lt;&lt; "Failed to get stop signs from sim_map.";
  }
  ExtractIds(stop_signs, &amp;result.stop_sign);

  std::vector&lt;YieldSignInfoConstPtr&gt; yield_signs;
  if (sim_map_.GetYieldSigns(point, radius, &amp;yield_signs) != 0) {
    AERROR &lt;&lt; "Failed to get yield signs from sim_map.";
  }
  ExtractIds(yield_signs, &amp;result.yield);

  return result;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\map\map_service.cc" startLine="(128, 0)" endLine="(171, 1)" clone_start="29" clone_end="41">
			<code function_name="MapService::CollectMapElementIds(const PointENU &amp;point, double radius) const">MapElementIds MapService::CollectMapElementIds(const PointENU &amp;point,
                                               double radius) const {
  MapElementIds result;

  std::vector&lt;LaneInfoConstPtr&gt; lanes;
  if (sim_map_.GetLanes(point, radius, &amp;lanes) != 0) {
    AERROR &lt;&lt; "Fail to get lanes from sim_map.";
  }
  ExtractIds(lanes, &amp;result.lane);

  std::vector&lt;CrosswalkInfoConstPtr&gt; crosswalks;
  if (sim_map_.GetCrosswalks(point, radius, &amp;crosswalks) != 0) {
    AERROR &lt;&lt; "Fail to get crosswalks from sim_map.";
  }
  ExtractIds(crosswalks, &amp;result.crosswalk);

  std::vector&lt;JunctionInfoConstPtr&gt; junctions;
  if (sim_map_.GetJunctions(point, radius, &amp;junctions) != 0) {
    AERROR &lt;&lt; "Fail to get junctions from sim_map.";
  }
  ExtractIds(junctions, &amp;result.junction);

  std::vector&lt;SignalInfoConstPtr&gt; signals;
  if (sim_map_.GetSignals(point, radius, &amp;signals) != 0) {
    AERROR &lt;&lt; "Failed to get signals from sim_map.";
  }

  ExtractIds(signals, &amp;result.signal);
  ExtractOverlapIds(signals, &amp;result.overlap);

  std::vector&lt;StopSignInfoConstPtr&gt; stop_signs;
  if (sim_map_.GetStopSigns(point, radius, &amp;stop_signs) != 0) {
    AERROR &lt;&lt; "Failed to get stop signs from sim_map.";
  }
  ExtractIds(stop_signs, &amp;result.stop_sign);

  std::vector&lt;YieldSignInfoConstPtr&gt; yield_signs;
  if (sim_map_.GetYieldSigns(point, radius, &amp;yield_signs) != 0) {
    AERROR &lt;&lt; "Failed to get yield signs from sim_map.";
  }
  ExtractIds(yield_signs, &amp;result.yield);

  return result;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\core\result_generator.cc" startLine="(137, 0)" endLine="(170, 1)" clone_start="33" clone_end="34">
			<code function_name="ExtractBasicPassages(    const std::vector&lt;NodeWithRange&gt;&amp; nodes, std::vector&lt;std::vector&lt;NodeWithRange&gt;&gt;* const nodes_of_passages, std::vector&lt;RoutingResponse::LaneChangeInfo::Type&gt;* const lane_change_types)">bool ExtractBasicPassages(
    const std::vector&lt;NodeWithRange&gt;&amp; nodes,
    std::vector&lt;std::vector&lt;NodeWithRange&gt;&gt;* const nodes_of_passages,
    std::vector&lt;RoutingResponse::LaneChangeInfo::Type&gt;* const
        lane_change_types) {
  assert(!nodes.empty());
  nodes_of_passages-&gt;clear();
  lane_change_types-&gt;clear();
  std::vector&lt;NodeWithRange&gt; nodes_of_passage;
  nodes_of_passage.push_back(nodes.at(0));
  for (size_t i = 1; i &lt; nodes.size(); ++i) {
    auto edge =
        nodes.at(i - 1).GetTopoNode()-&gt;GetOutEdgeTo(nodes.at(i).GetTopoNode());
    if (edge == nullptr) {
      AERROR &lt;&lt; "Get null pointer to edge from " &lt;&lt; nodes.at(i - 1).LaneId()
             &lt;&lt; " to " &lt;&lt; nodes.at(i).LaneId();
      return false;
    }
    if (edge-&gt;Type() == TET_LEFT || edge-&gt;Type() == TET_RIGHT) {
      nodes_of_passages-&gt;push_back(nodes_of_passage);
      nodes_of_passage.clear();
      if (edge-&gt;Type() == TET_LEFT) {
        lane_change_types-&gt;push_back(
            RoutingResponse::LaneChangeInfo::LEFT_FORWARD);
      } else {
        lane_change_types-&gt;push_back(
            RoutingResponse::LaneChangeInfo::RIGHT_FORWARD);
      }
    }
    nodes_of_passage.push_back(nodes.at(i));
  }
  nodes_of_passages-&gt;push_back(nodes_of_passage);
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\core\result_generator.cc" startLine="(172, 0)" endLine="(185, 1)" clone_start="13" clone_end="14">
			<code function_name="IsReachableFrom(const TopoNode* node,const std::vector&lt;NodeWithRange&gt;&amp; to_nodes, const NodeWithRange** const reachable_node)">bool IsReachableFrom(const TopoNode* node,
                     const std::vector&lt;NodeWithRange&gt;&amp; to_nodes,
                     const NodeWithRange** const reachable_node) {
  for (const auto&amp; to_node : to_nodes) {
    auto edge = to_node.GetTopoNode()-&gt;GetInEdgeFrom(node);
    if (edge != nullptr) {
      if (edge-&gt;Type() == TET_LEFT || edge-&gt;Type() == TET_RIGHT) {
        *reachable_node = &amp;to_node;
        return true;
      }
    }
  }
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\core\result_generator.cc" startLine="(172, 0)" endLine="(185, 1)" clone_start="1" clone_end="13">
			<code function_name="IsReachableFrom(const TopoNode* node,const std::vector&lt;NodeWithRange&gt;&amp; to_nodes, const NodeWithRange** const reachable_node)">bool IsReachableFrom(const TopoNode* node,
                     const std::vector&lt;NodeWithRange&gt;&amp; to_nodes,
                     const NodeWithRange** const reachable_node) {
  for (const auto&amp; to_node : to_nodes) {
    auto edge = to_node.GetTopoNode()-&gt;GetInEdgeFrom(node);
    if (edge != nullptr) {
      if (edge-&gt;Type() == TET_LEFT || edge-&gt;Type() == TET_RIGHT) {
        *reachable_node = &amp;to_node;
        return true;
      }
    }
  }
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\core\result_generator.cc" startLine="(187, 0)" endLine="(200, 1)" clone_start="1" clone_end="13">
			<code function_name="IsReachableTo(const TopoNode* node,const std::vector&lt;NodeWithRange&gt;&amp; from_nodes, const NodeWithRange** const reachable_node)">bool IsReachableTo(const TopoNode* node,
                   const std::vector&lt;NodeWithRange&gt;&amp; from_nodes,
                   const NodeWithRange** const reachable_node) {
  for (const auto&amp; from_node : from_nodes) {
    auto edge = from_node.GetTopoNode()-&gt;GetOutEdgeTo(node);
    if (edge != nullptr) {
      if (edge-&gt;Type() == TET_LEFT || edge-&gt;Type() == TET_RIGHT) {
        *reachable_node = &amp;from_node;
        return true;
      }
    }
  }
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\planning_util.cc" startLine="(73, 0)" endLine="(100, 1)" clone_start="20" clone_end="28">
			<code function_name="InterpolateUsingLinearApproximation(const PathPoint &amp;p0,const PathPoint &amp;p1, const double s)">PathPoint InterpolateUsingLinearApproximation(const PathPoint &amp;p0,
                                              const PathPoint &amp;p1,
                                              const double s) {
  double s0 = p0.s();
  double s1 = p1.s();
  CHECK(s0 &lt; s1);

  PathPoint path_point;
  double weight = (s - s0) / (s1 - s0);
  double x = (1 - weight) * p0.x() + weight * p1.x();
  double y = (1 - weight) * p0.y() + weight * p1.y();
  double cos_heading =
      (1 - weight) * std::cos(p0.theta()) + weight * std::cos(p1.theta());
  double sin_heading =
      (1 - weight) * std::sin(p0.theta()) + weight * std::sin(p1.theta());
  double theta = std::atan2(sin_heading, cos_heading);
  double kappa = (1 - weight) * p0.kappa() + weight * p1.kappa();
  double dkappa = (1 - weight) * p0.dkappa() + weight * p1.dkappa();
  double ddkappa = (1 - weight) * p0.ddkappa() + weight * p1.ddkappa();
  path_point.set_x(x);
  path_point.set_y(y);
  path_point.set_theta(theta);
  path_point.set_kappa(kappa);
  path_point.set_dkappa(dkappa);
  path_point.set_ddkappa(ddkappa);
  path_point.set_s(s);
  return path_point;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\planning_util.cc" startLine="(35, 0)" endLine="(71, 1)" clone_start="29" clone_end="37">
			<code function_name="interpolate(const PathPoint &amp;p0, const PathPoint &amp;p1, const double s)">PathPoint interpolate(const PathPoint &amp;p0, const PathPoint &amp;p1,
                      const double s) {
  double s0 = p0.s();
  double s1 = p1.s();
  CHECK(s0 &lt;= s &amp;&amp; s &lt;= s1);

  std::array&lt;double, 2&gt; gx0{{p0.theta(), p0.kappa()}};
  std::array&lt;double, 2&gt; gx1{{p1.theta(), p1.kappa()}};
  HermiteSpline&lt;double, 3&gt; geometry_spline(gx0, gx1, s0, s1);
  auto func_cos_theta = [&amp;geometry_spline](const double s) {
    auto theta = geometry_spline.Evaluate(0, s);
    return std::cos(theta);
  };
  auto func_sin_theta = [&amp;geometry_spline](const double s) {
    auto theta = geometry_spline.Evaluate(0, s);
    return std::sin(theta);
  };

  double x =
      p0.x() + common::math::IntegrateByGaussLegendre(func_cos_theta, s0, s);
  double y =
      p0.y() + common::math::IntegrateByGaussLegendre(func_sin_theta, s0, s);
  double theta = geometry_spline.Evaluate(0, s);
  double kappa = geometry_spline.Evaluate(1, s);
  double dkappa = geometry_spline.Evaluate(2, s);
  double d2kappa = geometry_spline.Evaluate(3, s);

  PathPoint p;
  p.set_x(x);
  p.set_y(y);
  p.set_theta(theta);
  p.set_kappa(kappa);
  p.set_dkappa(dkappa);
  p.set_ddkappa(d2kappa);
  p.set_s(s);
  return p;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\planning_util.cc" startLine="(102, 0)" endLine="(167, 1)" clone_start="1" clone_end="1">
			<code function_name="interpolate(const TrajectoryPoint &amp;tp0, const TrajectoryPoint &amp;tp1, const double t)">TrajectoryPoint interpolate(const TrajectoryPoint &amp;tp0,
                            const TrajectoryPoint &amp;tp1, const double t) {
  if (std::abs(tp0.path_point().s() - tp0.path_point().s()) &lt; 1.0e-4) {
    return tp1;
  }

  const PathPoint &amp;pp0 = tp0.path_point();
  const PathPoint &amp;pp1 = tp1.path_point();
  double t0 = tp0.relative_time();
  double t1 = tp1.relative_time();

  std::array&lt;double, 2&gt; dx0{{tp0.v(), tp0.a()}};
  std::array&lt;double, 2&gt; dx1{{tp1.v(), tp1.a()}};
  HermiteSpline&lt;double, 3&gt; dynamic_spline(dx0, dx1, t0, t1);

  double s0 = 0.0;
  auto func_v = [&amp;dynamic_spline](const double t) {
    return dynamic_spline.Evaluate(0, t);
  };
  double s1 = common::math::IntegrateByGaussLegendre(func_v, t0, t1);
  double s = common::math::IntegrateByGaussLegendre(func_v, t0, t);

  if (std::abs(tp0.path_point().s() - s1) &lt; 1.0e-4) {
    return tp1;
  }

  double v = dynamic_spline.Evaluate(0, t);
  double a = dynamic_spline.Evaluate(1, t);

  std::array&lt;double, 2&gt; gx0{{pp0.theta(), pp0.kappa()}};
  std::array&lt;double, 2&gt; gx1{{pp1.theta(), pp1.kappa()}};
  HermiteSpline&lt;double, 3&gt; geometry_spline(gx0, gx1, s0, s1);
  auto func_cos_theta = [&amp;geometry_spline](const double s) {
    auto theta = geometry_spline.Evaluate(0, s);
    return std::cos(theta);
  };
  auto func_sin_theta = [&amp;geometry_spline](const double s) {
    auto theta = geometry_spline.Evaluate(0, s);
    return std::sin(theta);
  };

  double x =
      pp0.x() + common::math::IntegrateByGaussLegendre(func_cos_theta, s0, s);
  double y =
      pp0.y() + common::math::IntegrateByGaussLegendre(func_sin_theta, s0, s);
  double theta = geometry_spline.Evaluate(0, s);
  double kappa = geometry_spline.Evaluate(1, s);
  double dkappa = geometry_spline.Evaluate(2, s);
  double d2kappa = geometry_spline.Evaluate(3, s);

  TrajectoryPoint tp;
  tp.set_v(v);
  tp.set_a(a);

  PathPoint *path_point = tp.mutable_path_point();
  path_point-&gt;set_x(x);
  path_point-&gt;set_y(y);
  path_point-&gt;set_theta(theta);
  path_point-&gt;set_kappa(kappa);
  path_point-&gt;set_dkappa(dkappa);
  path_point-&gt;set_ddkappa(d2kappa);
  path_point-&gt;set_s(s);

  // check the diff of computed s1 and p1.s()?
  return tp;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\planning_util.cc" startLine="(73, 0)" endLine="(100, 1)" clone_start="1" clone_end="1">
			<code function_name="InterpolateUsingLinearApproximation(const PathPoint &amp;p0,const PathPoint &amp;p1, const double s)">PathPoint InterpolateUsingLinearApproximation(const PathPoint &amp;p0,
                                              const PathPoint &amp;p1,
                                              const double s) {
  double s0 = p0.s();
  double s1 = p1.s();
  CHECK(s0 &lt; s1);

  PathPoint path_point;
  double weight = (s - s0) / (s1 - s0);
  double x = (1 - weight) * p0.x() + weight * p1.x();
  double y = (1 - weight) * p0.y() + weight * p1.y();
  double cos_heading =
      (1 - weight) * std::cos(p0.theta()) + weight * std::cos(p1.theta());
  double sin_heading =
      (1 - weight) * std::sin(p0.theta()) + weight * std::sin(p1.theta());
  double theta = std::atan2(sin_heading, cos_heading);
  double kappa = (1 - weight) * p0.kappa() + weight * p1.kappa();
  double dkappa = (1 - weight) * p0.dkappa() + weight * p1.dkappa();
  double ddkappa = (1 - weight) * p0.ddkappa() + weight * p1.ddkappa();
  path_point.set_x(x);
  path_point.set_y(y);
  path_point.set_theta(theta);
  path_point.set_kappa(kappa);
  path_point.set_dkappa(dkappa);
  path_point.set_ddkappa(ddkappa);
  path_point.set_s(s);
  return path_point;
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(636, 0)" endLine="(677, 1)" clone_start="15" clone_end="27">
			<code function_name="Obstacle::InitKFPedestrianTracker(Feature* feature)">void Obstacle::InitKFPedestrianTracker(Feature* feature) {
  // Set transition matrix F
  Eigen::Matrix&lt;double, 2, 2&gt; F;
  F.setIdentity();
  kf_pedestrian_tracker_.SetTransitionMatrix(F);

  // Set observation matrix H
  Eigen::Matrix&lt;double, 2, 2&gt; H;
  H.setIdentity();
  kf_pedestrian_tracker_.SetObservationMatrix(H);

  // Set control matrix
  Eigen::Matrix&lt;double, 2, 4&gt; B;
  B.setZero();
  kf_pedestrian_tracker_.SetControlMatrix(B);

  // Set covariance of transition noise matrix Q
  Eigen::Matrix&lt;double, 2, 2&gt; Q;
  Q.setIdentity();
  Q *= FLAGS_q_var;
  kf_pedestrian_tracker_.SetTransitionNoise(Q);

  // Set observation noise matrix R
  Eigen::Matrix&lt;double, 2, 2&gt; R;
  R.setIdentity();
  R *= FLAGS_r_var;
  kf_pedestrian_tracker_.SetObservationNoise(R);

  // Set current state covariance matrix P
  Eigen::Matrix&lt;double, 2, 2&gt; P;
  P.setIdentity();
  P *= FLAGS_p_var;

  // Set initial state
  Eigen::Matrix&lt;double, 2, 1&gt; x;
  x(0, 0) = feature-&gt;position().x();
  x(1, 0) = feature-&gt;position().y();

  kf_pedestrian_tracker_.SetStateEstimate(x, P);

  kf_pedestrian_tracker_enabled_ = true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(364, 0)" endLine="(406, 1)" clone_start="12" clone_end="24">
			<code function_name="Obstacle::InitKFMotionTracker(Feature* feature)">void Obstacle::InitKFMotionTracker(Feature* feature) {
  // Set transition matrix F
  Eigen::Matrix&lt;double, 6, 6&gt; F;
  F.setIdentity();
  kf_motion_tracker_.SetTransitionMatrix(F);

  // Set observation matrix H
  Eigen::Matrix&lt;double, 2, 6&gt; H;
  H.setZero();
  H(0, 0) = 1.0;
  H(1, 1) = 1.0;
  kf_motion_tracker_.SetObservationMatrix(H);

  // Set covariance of transition noise matrix Q
  Eigen::Matrix&lt;double, 6, 6&gt; Q;
  Q.setIdentity();
  Q *= FLAGS_q_var;
  kf_motion_tracker_.SetTransitionNoise(Q);

  // Set observation noise matrix R
  Eigen::Matrix&lt;double, 2, 2&gt; R;
  R.setIdentity();
  R *= FLAGS_r_var;
  kf_motion_tracker_.SetObservationNoise(R);

  // Set current state covariance matrix P
  Eigen::Matrix&lt;double, 6, 6&gt; P;
  P.setIdentity();
  P *= FLAGS_p_var;

  // Set initial state
  Eigen::Matrix&lt;double, 6, 1&gt; x;
  x(0, 0) = feature-&gt;position().x();
  x(1, 0) = feature-&gt;position().y();
  x(2, 0) = feature-&gt;velocity().x();
  x(3, 0) = feature-&gt;velocity().y();
  x(4, 0) = feature-&gt;acceleration().x();
  x(5, 0) = feature-&gt;acceleration().y();

  kf_motion_tracker_.SetStateEstimate(x, P);

  kf_motion_tracker_enabled_ = true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(468, 0)" endLine="(504, 1)" clone_start="22" clone_end="34">
			<code function_name="Obstacle::InitKFLaneTracker(const std::string&amp; lane_id, const double beta)">void Obstacle::InitKFLaneTracker(const std::string&amp; lane_id,
                                 const double beta) {
  KalmanFilter&lt;double, 4, 2, 0&gt; kf;

  // transition matrix: update delta_t at each processing step
  Eigen::Matrix&lt;double, 4, 4&gt; F;
  F.setIdentity();
  F(1, 1) = beta;
  kf.SetTransitionMatrix(F);

  // observation matrix
  Eigen::Matrix&lt;double, 2, 4&gt; H;
  H.setZero();
  H(0, 0) = 1.0;
  H(1, 1) = 1.0;
  kf.SetObservationMatrix(H);

  // Set covariance of transition noise matrix Q
  Eigen::Matrix&lt;double, 4, 4&gt; Q;
  Q.setIdentity();
  Q *= FLAGS_q_var;
  kf.SetTransitionNoise(Q);

  // Set observation noise matrix R
  Eigen::Matrix&lt;double, 2, 2&gt; R;
  R.setIdentity();
  R *= FLAGS_r_var;
  kf.SetObservationNoise(R);

  // Set current state covariance matrix P
  Eigen::Matrix&lt;double, 4, 4&gt; P;
  P.setIdentity();
  P *= FLAGS_p_var;
  kf.SetStateCovariance(P);

  kf_lane_trackers_.emplace(lane_id, std::move(kf));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(468, 0)" endLine="(504, 1)" clone_start="16" clone_end="28">
			<code function_name="Obstacle::InitKFLaneTracker(const std::string&amp; lane_id, const double beta)">void Obstacle::InitKFLaneTracker(const std::string&amp; lane_id,
                                 const double beta) {
  KalmanFilter&lt;double, 4, 2, 0&gt; kf;

  // transition matrix: update delta_t at each processing step
  Eigen::Matrix&lt;double, 4, 4&gt; F;
  F.setIdentity();
  F(1, 1) = beta;
  kf.SetTransitionMatrix(F);

  // observation matrix
  Eigen::Matrix&lt;double, 2, 4&gt; H;
  H.setZero();
  H(0, 0) = 1.0;
  H(1, 1) = 1.0;
  kf.SetObservationMatrix(H);

  // Set covariance of transition noise matrix Q
  Eigen::Matrix&lt;double, 4, 4&gt; Q;
  Q.setIdentity();
  Q *= FLAGS_q_var;
  kf.SetTransitionNoise(Q);

  // Set observation noise matrix R
  Eigen::Matrix&lt;double, 2, 2&gt; R;
  R.setIdentity();
  R *= FLAGS_r_var;
  kf.SetObservationNoise(R);

  // Set current state covariance matrix P
  Eigen::Matrix&lt;double, 4, 4&gt; P;
  P.setIdentity();
  P *= FLAGS_p_var;
  kf.SetStateCovariance(P);

  kf_lane_trackers_.emplace(lane_id, std::move(kf));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\sub_topo_graph.cc" startLine="(224, 0)" endLine="(249, 1)" clone_start="19" clone_end="26">
			<code function_name="SubTopoGraph::InitInSubNodeSubEdge(TopoNode* const sub_node, const std::unordered_set&lt;const TopoEdge*&gt; origin_edge)">void SubTopoGraph::InitInSubNodeSubEdge(
    TopoNode* const sub_node,
    const std::unordered_set&lt;const TopoEdge*&gt; origin_edge) {
  std::unordered_set&lt;TopoNode*&gt; other_sub_nodes;
  for (const auto* in_edge : origin_edge) {
    if (GetSubNodes(in_edge-&gt;FromNode(), &amp;other_sub_nodes)) {
      for (auto* sub_from_node : other_sub_nodes) {
        if (!sub_from_node-&gt;IsOverlapEnough(sub_node, in_edge)) {
          continue;
        }
        std::shared_ptr&lt;TopoEdge&gt; topo_edge_ptr;
        topo_edge_ptr.reset(
            new TopoEdge(in_edge-&gt;PbEdge(), sub_from_node, sub_node));
        sub_node-&gt;AddInEdge(topo_edge_ptr.get());
        sub_from_node-&gt;AddOutEdge(topo_edge_ptr.get());
        topo_edges_.push_back(std::move(topo_edge_ptr));
      }
    } else if (in_edge-&gt;FromNode()-&gt;IsOverlapEnough(sub_node, in_edge)) {
      std::shared_ptr&lt;TopoEdge&gt; topo_edge_ptr;
      topo_edge_ptr.reset(
          new TopoEdge(in_edge-&gt;PbEdge(), in_edge-&gt;FromNode(), sub_node));
      sub_node-&gt;AddInEdge(topo_edge_ptr.get());
      topo_edges_.push_back(std::move(topo_edge_ptr));
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\sub_topo_graph.cc" startLine="(301, 0)" endLine="(332, 1)" clone_start="25" clone_end="32">
			<code function_name="SubTopoGraph::AddPotentialInEdge(    TopoNode* const sub_node, const std::unordered_set&lt;const TopoEdge*&gt; origin_edge)">void SubTopoGraph::AddPotentialInEdge(
    TopoNode* const sub_node,
    const std::unordered_set&lt;const TopoEdge*&gt; origin_edge) {
  std::unordered_set&lt;TopoNode*&gt; other_sub_nodes;
  for (const auto* in_edge : origin_edge) {
    if (GetSubNodes(in_edge-&gt;FromNode(), &amp;other_sub_nodes)) {
      for (auto* sub_from_node : other_sub_nodes) {
        if (sub_node-&gt;GetInEdgeFrom(sub_from_node) != nullptr) {
          continue;
        }
        if (!IsReachable(sub_from_node, sub_node)) {
          continue;
        }
        std::shared_ptr&lt;TopoEdge&gt; topo_edge_ptr;
        topo_edge_ptr.reset(
            new TopoEdge(in_edge-&gt;PbEdge(), sub_from_node, sub_node));
        sub_node-&gt;AddInEdge(topo_edge_ptr.get());
        sub_from_node-&gt;AddOutEdge(topo_edge_ptr.get());
        topo_edges_.push_back(std::move(topo_edge_ptr));
      }
    } else {
      if (sub_node-&gt;GetInEdgeFrom(in_edge-&gt;FromNode()) != nullptr) {
        continue;
      }
      std::shared_ptr&lt;TopoEdge&gt; topo_edge_ptr;
      topo_edge_ptr.reset(
          new TopoEdge(in_edge-&gt;PbEdge(), in_edge-&gt;FromNode(), sub_node));
      sub_node-&gt;AddInEdge(topo_edge_ptr.get());
      topo_edges_.push_back(std::move(topo_edge_ptr));
    }
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\sub_topo_graph.cc" startLine="(251, 0)" endLine="(276, 1)" clone_start="1" clone_end="7">
			<code function_name="SubTopoGraph::InitOutSubNodeSubEdge(    TopoNode* const sub_node, const std::unordered_set&lt;const TopoEdge*&gt; origin_edge)">void SubTopoGraph::InitOutSubNodeSubEdge(
    TopoNode* const sub_node,
    const std::unordered_set&lt;const TopoEdge*&gt; origin_edge) {
  std::unordered_set&lt;TopoNode*&gt; other_sub_nodes;
  for (const auto* out_edge : origin_edge) {
    if (GetSubNodes(out_edge-&gt;ToNode(), &amp;other_sub_nodes)) {
      for (auto* sub_to_node : other_sub_nodes) {
        if (!sub_node-&gt;IsOverlapEnough(sub_to_node, out_edge)) {
          continue;
        }
        std::shared_ptr&lt;TopoEdge&gt; topo_edge_ptr;
        topo_edge_ptr.reset(
            new TopoEdge(out_edge-&gt;PbEdge(), sub_node, sub_to_node));
        sub_node-&gt;AddOutEdge(topo_edge_ptr.get());
        sub_to_node-&gt;AddInEdge(topo_edge_ptr.get());
        topo_edges_.push_back(std::move(topo_edge_ptr));
      }
    } else if (sub_node-&gt;IsOverlapEnough(out_edge-&gt;ToNode(), out_edge)) {
      std::shared_ptr&lt;TopoEdge&gt; topo_edge_ptr;
      topo_edge_ptr.reset(
          new TopoEdge(out_edge-&gt;PbEdge(), sub_node, out_edge-&gt;ToNode()));
      sub_node-&gt;AddOutEdge(topo_edge_ptr.get());
      topo_edges_.push_back(std::move(topo_edge_ptr));
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\sub_topo_graph.cc" startLine="(334, 0)" endLine="(365, 1)" clone_start="1" clone_end="7">
			<code function_name="SubTopoGraph::AddPotentialOutEdge(    TopoNode* const sub_node, const std::unordered_set&lt;const TopoEdge*&gt; origin_edge)">void SubTopoGraph::AddPotentialOutEdge(
    TopoNode* const sub_node,
    const std::unordered_set&lt;const TopoEdge*&gt; origin_edge) {
  std::unordered_set&lt;TopoNode*&gt; other_sub_nodes;
  for (const auto* out_edge : origin_edge) {
    if (GetSubNodes(out_edge-&gt;ToNode(), &amp;other_sub_nodes)) {
      for (auto* sub_to_node : other_sub_nodes) {
        if (sub_node-&gt;GetOutEdgeTo(sub_to_node) != nullptr) {
          continue;
        }
        if (!IsReachable(sub_node, sub_to_node)) {
          continue;
        }
        std::shared_ptr&lt;TopoEdge&gt; topo_edge_ptr;
        topo_edge_ptr.reset(
            new TopoEdge(out_edge-&gt;PbEdge(), sub_node, sub_to_node));
        sub_node-&gt;AddOutEdge(topo_edge_ptr.get());
        sub_to_node-&gt;AddInEdge(topo_edge_ptr.get());
        topo_edges_.push_back(std::move(topo_edge_ptr));
      }
    } else {
      if (sub_node-&gt;GetOutEdgeTo(out_edge-&gt;ToNode()) != nullptr) {
        continue;
      }
      std::shared_ptr&lt;TopoEdge&gt; topo_edge_ptr;
      topo_edge_ptr.reset(
          new TopoEdge(out_edge-&gt;PbEdge(), sub_node, out_edge-&gt;ToNode()));
      sub_node-&gt;AddOutEdge(topo_edge_ptr.get());
      topo_edges_.push_back(std::move(topo_edge_ptr));
    }
  }
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\compensator_nodelet.cpp" startLine="(28, 2)" endLine="(28, 25)" clone_start="1" clone_end="1">
			<code function_name="CompensatorNodelet()">  CompensatorNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\convert_nodelet.cpp" startLine="(28, 2)" endLine="(28, 21)" clone_start="1" clone_end="1">
			<code function_name="ConvertNodelet()">  ConvertNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\pcd_exporter_nodelet.cpp" startLine="(28, 2)" endLine="(28, 25)" clone_start="1" clone_end="1">
			<code function_name="PCDExporterNodelet()">  PCDExporterNodelet() {}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\compensator_nodelet.cpp" startLine="(29, 2)" endLine="(29, 26)" clone_start="1" clone_end="1">
			<code function_name="~CompensatorNodelet()">  ~CompensatorNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\convert_nodelet.cpp" startLine="(29, 2)" endLine="(29, 22)" clone_start="1" clone_end="1">
			<code function_name="~ConvertNodelet()">  ~ConvertNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\pcd_exporter_nodelet.cpp" startLine="(29, 2)" endLine="(29, 26)" clone_start="1" clone_end="1">
			<code function_name="~PCDExporterNodelet()">  ~PCDExporterNodelet() {}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\compensator_nodelet.cpp" startLine="(37, 0)" endLine="(40, 1)" clone_start="1" clone_end="2">
			<code function_name="CompensatorNodelet::onInit()">void CompensatorNodelet::onInit() {
  ROS_INFO("Compensator nodelet init");
  _compensator.reset(new Compensator(getNodeHandle(), getPrivateNodeHandle()));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\convert_nodelet.cpp" startLine="(37, 0)" endLine="(41, 1)" clone_start="1" clone_end="2">
			<code function_name="ConvertNodelet::onInit()">void ConvertNodelet::onInit() {
  ROS_INFO("Point cloud nodelet init");
  _conv.reset(new Convert());
  _conv-&gt;init(getNodeHandle(), getPrivateNodeHandle());
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\pcd_exporter_nodelet.cpp" startLine="(37, 0)" endLine="(41, 1)" clone_start="1" clone_end="2">
			<code function_name="PCDExporterNodelet::onInit()">void PCDExporterNodelet::onInit() {
  ROS_INFO("Pcd exporter nodelet init");
  _instance.reset(new PCDExporter(getNodeHandle(), getPrivateNodeHandle()));
  _instance-&gt;init();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(266, 0)" endLine="(319, 1)" clone_start="24" clone_end="35">
			<code function_name="RawStream::connect()">bool RawStream::connect() {
  if (_data_stream) {
    if (_data_stream-&gt;get_status() != Stream::Status::CONNECTED) {
      if (!_data_stream-&gt;connect()) {
        ROS_ERROR("data stream connect failed.");
        return false;
      }
      _data_stream_status-&gt;status = Stream::Status::CONNECTED;
      _stream_status-&gt;set_ins_stream_type(
          apollo::common::gnss_status::StreamStatus::CONNECTED);
    }
  }

  if (_command_stream) {
    if (_command_stream-&gt;get_status() != Stream::Status::CONNECTED) {
      if (!_data_stream-&gt;connect()) {
        ROS_ERROR("command stream connect failed.");
        return false;
      }
      _command_stream_status-&gt;status = Stream::Status::CONNECTED;
    }
  }

  if (_in_rtk_stream) {
    if (_in_rtk_stream-&gt;get_status() != Stream::Status::CONNECTED) {
      if (!_in_rtk_stream-&gt;connect()) {
        ROS_ERROR("in rtk stream connect failed.");
      } else {
        _in_rtk_stream_status-&gt;status = Stream::Status::CONNECTED;
        _stream_status-&gt;set_rtk_stream_in_type(
            apollo::common::gnss_status::StreamStatus::CONNECTED);
      }
    }
  } else {
    _stream_status-&gt;set_rtk_stream_in_type(
        apollo::common::gnss_status::StreamStatus::CONNECTED);
  }

  if (_out_rtk_stream) {
    if (_out_rtk_stream-&gt;get_status() != Stream::Status::CONNECTED) {
      if (!_out_rtk_stream-&gt;connect()) {
        ROS_ERROR("out rtk stream connect failed.");
      } else {
        _out_rtk_stream_status-&gt;status = Stream::Status::CONNECTED;
        _stream_status-&gt;set_rtk_stream_out_type(
            apollo::common::gnss_status::StreamStatus::CONNECTED);
      }
    }
  } else {
    _stream_status-&gt;set_rtk_stream_out_type(
        apollo::common::gnss_status::StreamStatus::CONNECTED);
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(266, 0)" endLine="(319, 1)" clone_start="39" clone_end="50">
			<code function_name="RawStream::connect()">bool RawStream::connect() {
  if (_data_stream) {
    if (_data_stream-&gt;get_status() != Stream::Status::CONNECTED) {
      if (!_data_stream-&gt;connect()) {
        ROS_ERROR("data stream connect failed.");
        return false;
      }
      _data_stream_status-&gt;status = Stream::Status::CONNECTED;
      _stream_status-&gt;set_ins_stream_type(
          apollo::common::gnss_status::StreamStatus::CONNECTED);
    }
  }

  if (_command_stream) {
    if (_command_stream-&gt;get_status() != Stream::Status::CONNECTED) {
      if (!_data_stream-&gt;connect()) {
        ROS_ERROR("command stream connect failed.");
        return false;
      }
      _command_stream_status-&gt;status = Stream::Status::CONNECTED;
    }
  }

  if (_in_rtk_stream) {
    if (_in_rtk_stream-&gt;get_status() != Stream::Status::CONNECTED) {
      if (!_in_rtk_stream-&gt;connect()) {
        ROS_ERROR("in rtk stream connect failed.");
      } else {
        _in_rtk_stream_status-&gt;status = Stream::Status::CONNECTED;
        _stream_status-&gt;set_rtk_stream_in_type(
            apollo::common::gnss_status::StreamStatus::CONNECTED);
      }
    }
  } else {
    _stream_status-&gt;set_rtk_stream_in_type(
        apollo::common::gnss_status::StreamStatus::CONNECTED);
  }

  if (_out_rtk_stream) {
    if (_out_rtk_stream-&gt;get_status() != Stream::Status::CONNECTED) {
      if (!_out_rtk_stream-&gt;connect()) {
        ROS_ERROR("out rtk stream connect failed.");
      } else {
        _out_rtk_stream_status-&gt;status = Stream::Status::CONNECTED;
        _stream_status-&gt;set_rtk_stream_out_type(
            apollo::common::gnss_status::StreamStatus::CONNECTED);
      }
    }
  } else {
    _stream_status-&gt;set_rtk_stream_out_type(
        apollo::common::gnss_status::StreamStatus::CONNECTED);
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(39, 0)" endLine="(43, 1)" clone_start="1" clone_end="5">
			<code function_name="Accel6b::lateral_acceleration(const std::uint8_t *bytes, const int32_t length) const">double Accel6b::lateral_acceleration(const std::uint8_t *bytes,
                                     const int32_t length) const {
  DCHECK_GE(length, 2);
  return parse_two_frames(bytes[0], bytes[1]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(61, 0)" endLine="(65, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::pedal_input(const std::uint8_t *bytes, int32_t length) const">double Brake61::pedal_input(const std::uint8_t *bytes, int32_t length) const {
  DCHECK_GE(length, 2);
  // Pedal Input from the physical pedal
  return parse_two_frames(bytes[0], bytes[1]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(63, 0)" endLine="(67, 1)" clone_start="1" clone_end="5">
			<code function_name="Wheelspeed6a::front_left_wheel_speed(const std::uint8_t *bytes, int32_t length) const">double Wheelspeed6a::front_left_wheel_speed(const std::uint8_t *bytes,
                                            int32_t length) const {
  DCHECK_GE(length, 2);
  return parse_two_frames(bytes[0], bytes[1]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(69, 0)" endLine="(73, 1)" clone_start="1" clone_end="5">
			<code function_name="Wheelspeed6a::front_right_wheel_speed(const std::uint8_t *bytes, int32_t length) const">double Wheelspeed6a::front_right_wheel_speed(const std::uint8_t *bytes,
                                             int32_t length) const {
  DCHECK_GE(length, 4);
  return parse_two_frames(bytes[2], bytes[3]);
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(45, 0)" endLine="(49, 1)" clone_start="1" clone_end="5">
			<code function_name="Accel6b::longitudinal_acceleration(const std::uint8_t *bytes, const int32_t length) const">double Accel6b::longitudinal_acceleration(const std::uint8_t *bytes,
                                          const int32_t length) const {
  DCHECK_GE(length, 4);
  return parse_two_frames(bytes[2], bytes[3]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(67, 0)" endLine="(71, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::pedal_cmd(const std::uint8_t *bytes, int32_t length) const">double Brake61::pedal_cmd(const std::uint8_t *bytes, int32_t length) const {
  DCHECK_GE(length, 4);
  // Pedal Command from the command message
  return parse_two_frames(bytes[2], bytes[3]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(69, 0)" endLine="(73, 1)" clone_start="1" clone_end="5">
			<code function_name="Wheelspeed6a::front_right_wheel_speed(const std::uint8_t *bytes, int32_t length) const">double Wheelspeed6a::front_right_wheel_speed(const std::uint8_t *bytes,
                                             int32_t length) const {
  DCHECK_GE(length, 4);
  return parse_two_frames(bytes[2], bytes[3]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(75, 0)" endLine="(79, 1)" clone_start="1" clone_end="5">
			<code function_name="Wheelspeed6a::rear_left_wheel_speed(const std::uint8_t *bytes, int32_t length) const">double Wheelspeed6a::rear_left_wheel_speed(const std::uint8_t *bytes,
                                           int32_t length) const {
  DCHECK_GE(length, 6);
  return parse_two_frames(bytes[4], bytes[5]);
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(51, 0)" endLine="(55, 1)" clone_start="1" clone_end="4">
			<code function_name="Accel6b::vertical_acceleration(const std::uint8_t *bytes, const int32_t length) const">double Accel6b::vertical_acceleration(const std::uint8_t *bytes,
                                      const int32_t length) const {
  DCHECK_GE(length, 6);
  return parse_two_frames(bytes[4], bytes[5]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(73, 0)" endLine="(77, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake61::pedal_output(const std::uint8_t *bytes, int32_t length) const">double Brake61::pedal_output(const std::uint8_t *bytes, int32_t length) const {
  DCHECK_GE(length, 6);
  // Pedal Output is the maximum of PI and PC
  return parse_two_frames(bytes[4], bytes[5]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(75, 0)" endLine="(79, 1)" clone_start="1" clone_end="4">
			<code function_name="Wheelspeed6a::rear_left_wheel_speed(const std::uint8_t *bytes, int32_t length) const">double Wheelspeed6a::rear_left_wheel_speed(const std::uint8_t *bytes,
                                           int32_t length) const {
  DCHECK_GE(length, 6);
  return parse_two_frames(bytes[4], bytes[5]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(81, 0)" endLine="(85, 1)" clone_start="1" clone_end="4">
			<code function_name="Wheelspeed6a::rear_right_wheel_speed(const std::uint8_t *bytes, int32_t length) const">double Wheelspeed6a::rear_right_wheel_speed(const std::uint8_t *bytes,
                                            int32_t length) const {
  DCHECK_GE(length, 8);
  return parse_two_frames(bytes[6], bytes[7]);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(717, 0)" endLine="(783, 1)" clone_start="1" clone_end="11">
			<code function_name="Obstacle::SetCurrentLanes(Feature* feature)">void Obstacle::SetCurrentLanes(Feature* feature) {
  PredictionMap* map = PredictionMap::instance();

  Eigen::Vector2d point(feature-&gt;position().x(), feature-&gt;position().y());
  double heading = feature-&gt;theta();
  if (FLAGS_enable_kf_tracking) {
    point[0] = feature-&gt;t_position().x();
    point[1] = feature-&gt;t_position().y();
    heading = feature-&gt;t_velocity_heading();
  }
  std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt; current_lanes;
  map-&gt;OnLane(current_lanes_, point, heading, FLAGS_search_radius, true,
              &amp;current_lanes);
  current_lanes_ = current_lanes;
  if (current_lanes_.empty()) {
    ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has no current lanes.";
    kf_lane_trackers_.clear();
    return;
  }
  Lane lane;
  if (feature-&gt;has_lane()) {
    lane = feature-&gt;lane();
  }
  double min_heading_diff = std::numeric_limits&lt;double&gt;::infinity();
  for (std::shared_ptr&lt;const LaneInfo&gt; current_lane : current_lanes) {
    int turn_type = map-&gt;LaneTurnType(current_lane-&gt;id().id());
    std::string lane_id = current_lane-&gt;id().id();
    double s = 0.0;
    double l = 0.0;
    map-&gt;GetProjection(point, current_lane, &amp;s, &amp;l);
    if (s &lt; 0.0) {
      continue;
    }

    common::math::Vec2d vec_point(point[0], point[1]);
    double distance = 0.0;
    common::PointENU nearest_point =
        current_lane-&gt;GetNearestPoint(vec_point, &amp;distance);
    double nearest_point_heading =
        map-&gt;PathHeading(current_lane, nearest_point);
    double angle_diff = common::math::AngleDiff(heading, nearest_point_heading);
    double left = 0.0;
    double right = 0.0;
    current_lane-&gt;GetWidth(s, &amp;left, &amp;right);
    LaneFeature* lane_feature = lane.add_current_lane_feature();
    lane_feature-&gt;set_lane_turn_type(turn_type);
    lane_feature-&gt;set_lane_id(lane_id);
    lane_feature-&gt;set_lane_s(s);
    lane_feature-&gt;set_lane_l(l);
    lane_feature-&gt;set_angle_diff(angle_diff);
    lane_feature-&gt;set_dist_to_left_boundary(left - l);
    lane_feature-&gt;set_dist_to_right_boundary(right + l);
    if (std::fabs(angle_diff) &lt; min_heading_diff) {
      lane.mutable_lane_feature()-&gt;CopyFrom(*lane_feature);
      min_heading_diff = std::fabs(angle_diff);
    }
    ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has current lanes ["
           &lt;&lt; lane_feature-&gt;ShortDebugString() &lt;&lt; "].";
  }

  if (lane.has_lane_feature()) {
    ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has one current lane ["
           &lt;&lt; lane.lane_feature().ShortDebugString() &lt;&lt; "].";
  }

  feature-&gt;mutable_lane()-&gt;CopyFrom(lane);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(785, 0)" endLine="(842, 1)" clone_start="1" clone_end="12">
			<code function_name="Obstacle::SetNearbyLanes(Feature* feature)">void Obstacle::SetNearbyLanes(Feature* feature) {
  PredictionMap* map = PredictionMap::instance();

  Eigen::Vector2d point(feature-&gt;position().x(), feature-&gt;position().y());
  double theta = feature-&gt;theta();
  if (FLAGS_enable_kf_tracking) {
    point[0] = feature-&gt;t_position().x();
    point[1] = feature-&gt;t_position().y();
    theta = feature-&gt;t_velocity_heading();
  }

  std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt; nearby_lanes;
  map-&gt;NearbyLanesByCurrentLanes(point, theta, FLAGS_search_radius * 2.0,
                                 current_lanes_, &amp;nearby_lanes);
  if (nearby_lanes.empty()) {
    ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has no nearby lanes.";
    return;
  }

  for (std::shared_ptr&lt;const LaneInfo&gt; nearby_lane : nearby_lanes) {
    if (nearby_lane == nullptr) {
      continue;
    }
    double s = -1.0;
    double l = 0.0;
    map-&gt;GetProjection(point, nearby_lane, &amp;s, &amp;l);
    if (s &lt; 0.0 || s &gt;= nearby_lane-&gt;total_length()) {
      continue;
    }
    int turn_type = map-&gt;LaneTurnType(nearby_lane-&gt;id().id());
    double heading = feature-&gt;theta();
    if (FLAGS_enable_kf_tracking) {
      heading = feature-&gt;t_velocity_heading();
    }
    double angle_diff = 0.0;
    hdmap::MapPathPoint nearest_point;
    if (!map-&gt;ProjectionFromLane(nearby_lane, s, &amp;nearest_point)) {
      angle_diff = common::math::AngleDiff(nearest_point.heading(), heading);
    }

    double left = 0.0;
    double right = 0.0;
    nearby_lane-&gt;GetWidth(s, &amp;left, &amp;right);

    LaneFeature* lane_feature =
        feature-&gt;mutable_lane()-&gt;add_nearby_lane_feature();

    lane_feature-&gt;set_lane_turn_type(turn_type);
    lane_feature-&gt;set_lane_id(nearby_lane-&gt;id().id());
    lane_feature-&gt;set_lane_s(s);
    lane_feature-&gt;set_lane_l(l);
    lane_feature-&gt;set_angle_diff(angle_diff);
    lane_feature-&gt;set_dist_to_left_boundary(left - l);
    lane_feature-&gt;set_dist_to_right_boundary(right + l);
    ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has nearby lanes ["
           &lt;&lt; lane_feature-&gt;ShortDebugString() &lt;&lt; "]";
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\lib\config_manager\config_manager.cc" startLine="(145, 0)" endLine="(227, 1)" clone_start="54" clone_end="66">
			<code function_name="ModelConfig::Reset(const ModelConfigProto&amp; proto)">bool ModelConfig::Reset(const ModelConfigProto&amp; proto) {
  name_ = proto.name();
  version_ = proto.version();

  integer_param_map_.clear();
  string_param_map_.clear();
  double_param_map_.clear();
  float_param_map_.clear();
  bool_param_map_.clear();
  array_integer_param_map_.clear();
  array_string_param_map_.clear();
  array_double_param_map_.clear();
  array_float_param_map_.clear();
  array_bool_param_map_.clear();

  for (const KeyValueInt&amp; pair : proto.integer_params()) {
    integer_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueString&amp; pair : proto.string_params()) {
    string_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueDouble&amp; pair : proto.double_params()) {
    double_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueFloat&amp; pair : proto.float_params()) {
    float_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueBool&amp; pair : proto.bool_params()) {
    bool_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueArrayInt&amp; pair : proto.array_integer_params()) {
    std::vector&lt;int&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_integer_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayString&amp; pair : proto.array_string_params()) {
    std::vector&lt;std::string&gt; values;
    values.reserve(pair.values_size());
    for (const std::string&amp; value : pair.values()) {
      values.push_back(value);
    }
    array_string_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayDouble&amp; pair : proto.array_double_params()) {
    std::vector&lt;double&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_double_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayFloat&amp; pair : proto.array_float_params()) {
    std::vector&lt;float&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_float_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayBool&amp; pair : proto.array_bool_params()) {
    std::vector&lt;bool&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_bool_param_map_.emplace(pair.name(), values);
  }

  AINFO &lt;&lt; "reset ModelConfig. model_name: " &lt;&lt; name_
        &lt;&lt; " integer_param_map's size: " &lt;&lt; integer_param_map_.size()
        &lt;&lt; " string_param_map's size: " &lt;&lt; string_param_map_.size()
        &lt;&lt; " double_param_map's size: " &lt;&lt; double_param_map_.size()
        &lt;&lt; " float_param_map's size: " &lt;&lt; float_param_map_.size()
        &lt;&lt; " bool_param_map's size: " &lt;&lt; bool_param_map_.size()
        &lt;&lt; " array_integer_param_map's size: "
        &lt;&lt; array_integer_param_map_.size()
        &lt;&lt; " array_string_param_map's size: " &lt;&lt; array_string_param_map_.size()
        &lt;&lt; " array_double_param_map's size: " &lt;&lt; array_double_param_map_.size()
        &lt;&lt; " array_float_param_map's size: " &lt;&lt; array_float_param_map_.size()
        &lt;&lt; " array_bool_param_map's size: " &lt;&lt; array_bool_param_map_.size();

  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\lib\config_manager\config_manager.cc" startLine="(145, 0)" endLine="(227, 1)" clone_start="48" clone_end="60">
			<code function_name="ModelConfig::Reset(const ModelConfigProto&amp; proto)">bool ModelConfig::Reset(const ModelConfigProto&amp; proto) {
  name_ = proto.name();
  version_ = proto.version();

  integer_param_map_.clear();
  string_param_map_.clear();
  double_param_map_.clear();
  float_param_map_.clear();
  bool_param_map_.clear();
  array_integer_param_map_.clear();
  array_string_param_map_.clear();
  array_double_param_map_.clear();
  array_float_param_map_.clear();
  array_bool_param_map_.clear();

  for (const KeyValueInt&amp; pair : proto.integer_params()) {
    integer_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueString&amp; pair : proto.string_params()) {
    string_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueDouble&amp; pair : proto.double_params()) {
    double_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueFloat&amp; pair : proto.float_params()) {
    float_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueBool&amp; pair : proto.bool_params()) {
    bool_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueArrayInt&amp; pair : proto.array_integer_params()) {
    std::vector&lt;int&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_integer_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayString&amp; pair : proto.array_string_params()) {
    std::vector&lt;std::string&gt; values;
    values.reserve(pair.values_size());
    for (const std::string&amp; value : pair.values()) {
      values.push_back(value);
    }
    array_string_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayDouble&amp; pair : proto.array_double_params()) {
    std::vector&lt;double&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_double_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayFloat&amp; pair : proto.array_float_params()) {
    std::vector&lt;float&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_float_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayBool&amp; pair : proto.array_bool_params()) {
    std::vector&lt;bool&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_bool_param_map_.emplace(pair.name(), values);
  }

  AINFO &lt;&lt; "reset ModelConfig. model_name: " &lt;&lt; name_
        &lt;&lt; " integer_param_map's size: " &lt;&lt; integer_param_map_.size()
        &lt;&lt; " string_param_map's size: " &lt;&lt; string_param_map_.size()
        &lt;&lt; " double_param_map's size: " &lt;&lt; double_param_map_.size()
        &lt;&lt; " float_param_map's size: " &lt;&lt; float_param_map_.size()
        &lt;&lt; " bool_param_map's size: " &lt;&lt; bool_param_map_.size()
        &lt;&lt; " array_integer_param_map's size: "
        &lt;&lt; array_integer_param_map_.size()
        &lt;&lt; " array_string_param_map's size: " &lt;&lt; array_string_param_map_.size()
        &lt;&lt; " array_double_param_map's size: " &lt;&lt; array_double_param_map_.size()
        &lt;&lt; " array_float_param_map's size: " &lt;&lt; array_float_param_map_.size()
        &lt;&lt; " array_bool_param_map's size: " &lt;&lt; array_bool_param_map_.size();

  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\common\pose_util.h" startLine="(31, 0)" endLine="(51, 1)" clone_start="3" clone_end="11">
			<code function_name="QuaternionToRotationMatrix(const T* quat, T* R)">void QuaternionToRotationMatrix(const T* quat, T* R) {
  T x2 = quat[0] * quat[0];
  T xy = quat[0] * quat[1];
  T rx = quat[3] * quat[0];
  T y2 = quat[1] * quat[1];
  T yz = quat[1] * quat[2];
  T ry = quat[3] * quat[1];
  T z2 = quat[2] * quat[2];
  T zx = quat[2] * quat[0];
  T rz = quat[3] * quat[2];
  T r2 = quat[3] * quat[3];
  R[0] = r2 + x2 - y2 - z2;  // fill diagonal terms
  R[4] = r2 - x2 + y2 - z2;
  R[8] = r2 - x2 - y2 + z2;
  R[3] = 2 * (xy + rz);  // fill off diagonal terms
  R[6] = 2 * (zx - ry);
  R[7] = 2 * (yz + rx);
  R[1] = 2 * (xy - rz);
  R[2] = 2 * (zx + ry);
  R[5] = 2 * (yz - rx);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\common\pose_util.h" startLine="(31, 0)" endLine="(51, 1)" clone_start="2" clone_end="10">
			<code function_name="QuaternionToRotationMatrix(const T* quat, T* R)">void QuaternionToRotationMatrix(const T* quat, T* R) {
  T x2 = quat[0] * quat[0];
  T xy = quat[0] * quat[1];
  T rx = quat[3] * quat[0];
  T y2 = quat[1] * quat[1];
  T yz = quat[1] * quat[2];
  T ry = quat[3] * quat[1];
  T z2 = quat[2] * quat[2];
  T zx = quat[2] * quat[0];
  T rz = quat[3] * quat[2];
  T r2 = quat[3] * quat[3];
  R[0] = r2 + x2 - y2 - z2;  // fill diagonal terms
  R[4] = r2 - x2 + y2 - z2;
  R[8] = r2 - x2 - y2 + z2;
  R[3] = 2 * (xy + rz);  // fill off diagonal terms
  R[6] = 2 * (zx - ry);
  R[7] = 2 * (yz + rx);
  R[1] = 2 * (xy - rz);
  R[2] = 2 * (zx + ry);
  R[5] = 2 * (yz - rx);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(26, 0)" endLine="(51, 1)" clone_start="18" clone_end="26">
			<code function_name="Gps6f::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Gps6f::Parse(const std::uint8_t *bytes, int32_t length,
                  ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_basic()-&gt;set_altitude(altitude(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_heading(heading(bytes, length));
  // speed mph -&gt; mps
  chassis_detail-&gt;mutable_basic()-&gt;set_gps_speed(speed(bytes, length) *
                                                 0.44704);
  chassis_detail-&gt;mutable_basic()-&gt;set_hdop(hdop(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_vdop(vdop(bytes, length));
  switch (fix_quality(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_NO);
      break;
    case 1:
      chassis_detail-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_2D);
      break;
    case 2:
      chassis_detail-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_3D);
      break;
    default:
      chassis_detail-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_INVALID);
      break;
  }
  chassis_detail-&gt;mutable_basic()-&gt;set_num_satellites(
      num_satellites(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(26, 0)" endLine="(90, 1)" clone_start="56" clone_end="65">
			<code function_name="Gear67::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Gear67::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t gear = gear_state(bytes, length);
  switch (gear) {
    case 0x01:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_PARKING);
      break;
    case 0x02:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_REVERSE);
      break;
    case 0x03:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_NEUTRAL);
      break;
    case 0x04:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_DRIVE);
      break;
    case 0x05:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_LOW);
      break;
    case 0x00:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_NONE);
      break;
    default:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_INVALID);
      break;
  }

  if (is_driver_override(bytes, length)) {
    // last shift requested by driver
    chassis_detail-&gt;mutable_gear()-&gt;set_is_shift_position_valid(false);
  } else {
    // last shift requested by-wire
    chassis_detail-&gt;mutable_gear()-&gt;set_is_shift_position_valid(true);
  }
  chassis_detail-&gt;mutable_gear()-&gt;set_driver_override(
      is_driver_override(bytes, length));

  int32_t gear_cmd = reported_gear_cmd(bytes, length);
  switch (gear_cmd) {
    case 0x01:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_PARKING);
      break;
    case 0x02:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_REVERSE);
      break;
    case 0x03:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_NEUTRAL);
      break;
    case 0x04:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_DRIVE);
      break;
    case 0x05:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_LOW);
      break;
    case 0x00:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_NONE);
      break;
    default:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_INVALID);
      break;
  }

  chassis_detail-&gt;mutable_gear()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(53, 0)" endLine="(63, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6f::altitude(const std::uint8_t *bytes, int32_t length) const">double Gps6f::altitude(const std::uint8_t *bytes, int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.250000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(92, 0)" endLine="(96, 1)" clone_start="1" clone_end="3">
			<code function_name="Gear67::gear_state(const std::uint8_t *bytes, int32_t length) const">int32_t Gear67::gear_state(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(492, 0)" endLine="(612, 1)" clone_start="49" clone_end="60">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  if (!chassis_detail.has_eps()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO eps."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_brake()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO brake."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gas()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gas."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gear()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gear."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR_EVERY(100) &lt;&lt; "Steering fault detected: "
                      &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR_EVERY(100) &lt;&lt; "Brake fault detected: "
                      &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR_EVERY(100) &lt;&lt; "Throttle fault detected: "
                      &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR_EVERY(100) &lt;&lt; "Gear fault detected: "
                      &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(492, 0)" endLine="(612, 1)" clone_start="27" clone_end="38">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  if (!chassis_detail.has_eps()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO eps."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_brake()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO brake."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gas()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gas."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gear()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gear."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR_EVERY(100) &lt;&lt; "Steering fault detected: "
                      &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR_EVERY(100) &lt;&lt; "Brake fault detected: "
                      &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR_EVERY(100) &lt;&lt; "Throttle fault detected: "
                      &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR_EVERY(100) &lt;&lt; "Gear fault detected: "
                      &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(136, 0)" endLine="(144, 1)" clone_start="8" clone_end="9">
			<code function_name="Brakeinfo74::braking_torque_actual(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::braking_torque_actual(const std::uint8_t *bytes,
                                          int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 4);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 4.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(86, 0)" endLine="(90, 1)" clone_start="4" clone_end="5">
			<code function_name="Gps6f::vdop(const std::uint8_t *bytes, int32_t length) const">double Gps6f::vdop(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(146, 0)" endLine="(152, 1)" clone_start="1" clone_end="7">
			<code function_name="Brakeinfo74::hill_start_assist_mode(const std::uint8_t *bytes, int32_t length) const">int32_t Brakeinfo74::hill_start_assist_mode(const std::uint8_t *bytes,
                                            int32_t length) const {
  // see table for status code
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(4, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(92, 0)" endLine="(96, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6f::fix_quality(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6f::fix_quality(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 7);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(154, 0)" endLine="(160, 1)" clone_start="1" clone_end="6">
			<code function_name="Brakeinfo74::parking_brake_status(const std::uint8_t *bytes, int32_t length) const">int32_t Brakeinfo74::parking_brake_status(const std::uint8_t *bytes,
                                          int32_t length) const {
  // see table for status code
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(6, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(98, 0)" endLine="(102, 1)" clone_start="1" clone_end="4">
			<code function_name="Gps6f::num_satellites(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6f::num_satellites(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 7);
  int32_t x = frame.get_byte(3, 5);
  return x;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(587, 0)" endLine="(608, 1)" clone_start="2" clone_end="10">
			<code function_name="HDMapImpl::Clear()">void HDMapImpl::Clear() {
  map_.Clear();
  lane_table_.clear();
  junction_table_.clear();
  signal_table_.clear();
  crosswalk_table_.clear();
  stop_sign_table_.clear();
  yield_sign_table_.clear();
  overlap_table_.clear();
  lane_segment_boxes_.clear();
  lane_segment_kdtree_.reset(nullptr);
  junction_polygon_boxes_.clear();
  junction_polygon_kdtree_.reset(nullptr);
  crosswalk_polygon_boxes_.clear();
  crosswalk_polygon_kdtree_.reset(nullptr);
  signal_segment_boxes_.clear();
  signal_segment_kdtree_.reset(nullptr);
  stop_sign_segment_boxes_.clear();
  stop_sign_segment_kdtree_.reset(nullptr);
  yield_sign_segment_boxes_.clear();
  yield_sign_segment_kdtree_.reset(nullptr);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\lib\config_manager\config_manager.cc" startLine="(145, 0)" endLine="(227, 1)" clone_start="6" clone_end="14">
			<code function_name="ModelConfig::Reset(const ModelConfigProto&amp; proto)">bool ModelConfig::Reset(const ModelConfigProto&amp; proto) {
  name_ = proto.name();
  version_ = proto.version();

  integer_param_map_.clear();
  string_param_map_.clear();
  double_param_map_.clear();
  float_param_map_.clear();
  bool_param_map_.clear();
  array_integer_param_map_.clear();
  array_string_param_map_.clear();
  array_double_param_map_.clear();
  array_float_param_map_.clear();
  array_bool_param_map_.clear();

  for (const KeyValueInt&amp; pair : proto.integer_params()) {
    integer_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueString&amp; pair : proto.string_params()) {
    string_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueDouble&amp; pair : proto.double_params()) {
    double_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueFloat&amp; pair : proto.float_params()) {
    float_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueBool&amp; pair : proto.bool_params()) {
    bool_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueArrayInt&amp; pair : proto.array_integer_params()) {
    std::vector&lt;int&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_integer_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayString&amp; pair : proto.array_string_params()) {
    std::vector&lt;std::string&gt; values;
    values.reserve(pair.values_size());
    for (const std::string&amp; value : pair.values()) {
      values.push_back(value);
    }
    array_string_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayDouble&amp; pair : proto.array_double_params()) {
    std::vector&lt;double&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_double_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayFloat&amp; pair : proto.array_float_params()) {
    std::vector&lt;float&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_float_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayBool&amp; pair : proto.array_bool_params()) {
    std::vector&lt;bool&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_bool_param_map_.emplace(pair.name(), values);
  }

  AINFO &lt;&lt; "reset ModelConfig. model_name: " &lt;&lt; name_
        &lt;&lt; " integer_param_map's size: " &lt;&lt; integer_param_map_.size()
        &lt;&lt; " string_param_map's size: " &lt;&lt; string_param_map_.size()
        &lt;&lt; " double_param_map's size: " &lt;&lt; double_param_map_.size()
        &lt;&lt; " float_param_map's size: " &lt;&lt; float_param_map_.size()
        &lt;&lt; " bool_param_map's size: " &lt;&lt; bool_param_map_.size()
        &lt;&lt; " array_integer_param_map's size: "
        &lt;&lt; array_integer_param_map_.size()
        &lt;&lt; " array_string_param_map's size: " &lt;&lt; array_string_param_map_.size()
        &lt;&lt; " array_double_param_map's size: " &lt;&lt; array_double_param_map_.size()
        &lt;&lt; " array_float_param_map's size: " &lt;&lt; array_float_param_map_.size()
        &lt;&lt; " array_bool_param_map's size: " &lt;&lt; array_bool_param_map_.size();

  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\lib\config_manager\config_manager.cc" startLine="(145, 0)" endLine="(227, 1)" clone_start="5" clone_end="13">
			<code function_name="ModelConfig::Reset(const ModelConfigProto&amp; proto)">bool ModelConfig::Reset(const ModelConfigProto&amp; proto) {
  name_ = proto.name();
  version_ = proto.version();

  integer_param_map_.clear();
  string_param_map_.clear();
  double_param_map_.clear();
  float_param_map_.clear();
  bool_param_map_.clear();
  array_integer_param_map_.clear();
  array_string_param_map_.clear();
  array_double_param_map_.clear();
  array_float_param_map_.clear();
  array_bool_param_map_.clear();

  for (const KeyValueInt&amp; pair : proto.integer_params()) {
    integer_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueString&amp; pair : proto.string_params()) {
    string_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueDouble&amp; pair : proto.double_params()) {
    double_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueFloat&amp; pair : proto.float_params()) {
    float_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueBool&amp; pair : proto.bool_params()) {
    bool_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueArrayInt&amp; pair : proto.array_integer_params()) {
    std::vector&lt;int&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_integer_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayString&amp; pair : proto.array_string_params()) {
    std::vector&lt;std::string&gt; values;
    values.reserve(pair.values_size());
    for (const std::string&amp; value : pair.values()) {
      values.push_back(value);
    }
    array_string_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayDouble&amp; pair : proto.array_double_params()) {
    std::vector&lt;double&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_double_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayFloat&amp; pair : proto.array_float_params()) {
    std::vector&lt;float&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_float_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayBool&amp; pair : proto.array_bool_params()) {
    std::vector&lt;bool&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_bool_param_map_.emplace(pair.name(), values);
  }

  AINFO &lt;&lt; "reset ModelConfig. model_name: " &lt;&lt; name_
        &lt;&lt; " integer_param_map's size: " &lt;&lt; integer_param_map_.size()
        &lt;&lt; " string_param_map's size: " &lt;&lt; string_param_map_.size()
        &lt;&lt; " double_param_map's size: " &lt;&lt; double_param_map_.size()
        &lt;&lt; " float_param_map's size: " &lt;&lt; float_param_map_.size()
        &lt;&lt; " bool_param_map's size: " &lt;&lt; bool_param_map_.size()
        &lt;&lt; " array_integer_param_map's size: "
        &lt;&lt; array_integer_param_map_.size()
        &lt;&lt; " array_string_param_map's size: " &lt;&lt; array_string_param_map_.size()
        &lt;&lt; " array_double_param_map's size: " &lt;&lt; array_double_param_map_.size()
        &lt;&lt; " array_float_param_map's size: " &lt;&lt; array_float_param_map_.size()
        &lt;&lt; " array_bool_param_map's size: " &lt;&lt; array_bool_param_map_.size();

  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\hermite_spline.h" startLine="(63, 0)" endLine="(200, 1)" clone_start="8" clone_end="16">
			<code function_name="HermiteSpline&lt;T, N&gt;::Evaluate(const std::uint32_t order, const double z) const">inline T HermiteSpline&lt;T, N&gt;::Evaluate(const std::uint32_t order,
                                       const double z) const {
  CHECK_LE(z0_, z);
  CHECK_LE(z, z0_ + delta_z_);

  // if N == 3, cubic hermite spline, N == 5, qunitic hermite spline
  if (N == 3) {
    const T&amp; p0 = x0_[0];
    const T&amp; v0 = x0_[1];
    const T&amp; p1 = x1_[0];
    const T&amp; v1 = x1_[1];
    switch (order) {
      case 0: {
        double t = (z - z0_) / delta_z_;
        double t2 = t * t;
        double t3 = t2 * t;

        return (2.0 * t3 - 3.0 * t2 + 1.0) * p0 + (t3 - 2 * t2 + t) * v0 +
               (-2.0 * t3 + 3.0 * t2) * p1 + (t3 - t2) * v1;
      }
      case 1: {
        double t = (z - z0_) / delta_z_;
        double t2 = t * t;

        return (6.0 * t2 - 6.0 * t) * p0 + (3.0 * t2 - 4 * t + 1.0) * v0 +
               (-6.0 * t2 + 6.0 * t) * p1 + (3.0 * t2 - 2.0 * t) * v1;
      }
      case 2: {
        double t = (z - z0_) / delta_z_;
        return (12.0 * t - 6.0) * p0 + (6.0 * t - 4.0) * v0 +
               (-12.0 * t + 6.0) * p1 + (6.0 * t - 2.0) * v1;
      }
      case 3: {
        return 12.0 * p0 + 6.0 * v0 - 12.0 * p1 + 6.0 * v1;
      }
      default: { break; }
    }
  } else {
    CHECK_EQ(5, N);
    const T&amp; p0 = x0_[0];
    const T&amp; v0 = x0_[1];
    const T&amp; a0 = x0_[2];
    const T&amp; p1 = x1_[0];
    const T&amp; v1 = x1_[1];
    const T&amp; a1 = x1_[2];

    switch (order) {
      case 0: {
        double t = (z - z0_) / delta_z_;
        double t2 = t * t;
        double t3 = t * t2;
        double t4 = t2 * t2;
        double t5 = t2 * t3;
        double det0 = t3 - t4;
        double det1 = t4 - t5;
        double h0 = 1.0 - 10.0 * t3 + 15.0 * t4 - 6.0 * t5;
        double h1 = t - 6.0 * t3 + 8.0 * t4 - 3.0 * t5;
        double h2 = 0.5 * (t2 - t5) - 1.5 * det0;
        double h3 = 10.0 * t3 - 15.0 * t4 + 6.0 * t5;
        double h4 = -4.0 * det0 + 3.0 * det1;
        double h5 = 0.5 * (det0 - det1);

        return h0 * p0 + h1 * v0 + h2 * a0 + h3 * p1 + h4 * v1 + h5 * a1;
      }
      case 1: {
        double t = (z - z0_) / delta_z_;
        double t2 = t * t;
        double t3 = t * t2;
        double t4 = t2 * t2;
        double det0 = t2 - t3;
        double det1 = t3 - t4;
        double dh0 = -30.0 * det0 + 30.0 * det1;
        double dh1 = 1 - 18.0 * t2 + 32.0 * t3 - 15.0 * t4;
        double dh2 = t - 4.5 * t2 + 6.0 * t3 - 2.5 * t4;
        double dh3 = 30.0 * det0 - 30.0 * det1;
        double dh4 = -12.0 * t2 + 28.0 * t3 - 15.0 * t4;
        double dh5 = 1.5 * det0 - 2.5 * det1;

        return dh0 * p0 + dh1 * v0 + dh2 * a0 + dh3 * p1 + dh4 * v1 + dh5 * a1;
      }
      case 2: {
        double t = (z - z0_) / delta_z_;
        double t2 = t * t;
        double t3 = t * t2;
        double det0 = t - t2;
        double det1 = t2 - t3;
        double ddh0 = -60.0 * det0 + 120.0 * det1;
        double ddh1 = -36.0 * det0 + 60.0 * det1;
        double ddh2 = 1.0 - 9.0 * t + 18.0 * t2 - 10.0 * t3;
        double ddh3 = 60.0 * det0 - 120.0 * det1;
        double ddh4 = -24.0 * det0 + 60.0 * det1;
        double ddh5 = 3.0 * t - 12.0 * t2 + 10.0 * t3;

        return ddh0 * p0 + ddh1 * v0 + ddh2 * a0 + ddh3 * p1 + ddh4 * v1 +
               ddh5 * a1;
      }
      case 3: {
        double t = (z - z0_) / delta_z_;
        double t2 = t * t;
        double det = t - t2;
        double dddh0 = -60.0 + 360.0 * det;
        double dddh1 = -36.0 + 192.0 * t - 180.0 * t2;
        double dddh2 = -9.0 + 36.0 * t - 30.0 * t2;
        double dddh3 = 60.0 - 360.0 * det;
        double dddh4 = -24.0 + 168.0 * t - 180.0 * t2;
        double dddh5 = 3.0 - 24.0 * t + 30.0 * t2;

        return dddh0 * p0 + dddh1 * v0 + dddh2 * a0 + dddh3 * p1 + dddh4 * v1 +
               dddh5 * a1;
      }
      case 4: {
        double t = (z - z0_) / delta_z_;
        double d4h0 = 360.0 - 720.0 * t;
        double d4h1 = 192.0 - 360.0 * t;
        double d4h2 = 36.0 - 60.0 * t;
        double d4h3 = -360.0 + 720.0 * t;
        double d4h4 = 168.0 - 360.0 * t;
        double d4h5 = -24.0 + 60.0 * t;

        return d4h0 * p0 + d4h1 * v0 + d4h2 * a0 + d4h3 * p1 + d4h4 * v1 +
               d4h5 * a1;
      }
      case 5: {
        double d5h0 = -720.0;
        double d5h1 = -360.0;
        double d5h2 = -60.0;
        double d5h3 = 720.0;
        double d5h4 = -360.0;
        double d5h5 = 60.0;

        return d5h0 * p0 + d5h1 * v0 + d5h2 * a0 + d5h3 * p1 + d5h4 * v1 +
               d5h5 * a1;
      }
      default: { break; }
    }
  }
  return T();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\hermite_spline.h" startLine="(63, 0)" endLine="(200, 1)" clone_start="42" clone_end="51">
			<code function_name="HermiteSpline&lt;T, N&gt;::Evaluate(const std::uint32_t order, const double z) const">inline T HermiteSpline&lt;T, N&gt;::Evaluate(const std::uint32_t order,
                                       const double z) const {
  CHECK_LE(z0_, z);
  CHECK_LE(z, z0_ + delta_z_);

  // if N == 3, cubic hermite spline, N == 5, qunitic hermite spline
  if (N == 3) {
    const T&amp; p0 = x0_[0];
    const T&amp; v0 = x0_[1];
    const T&amp; p1 = x1_[0];
    const T&amp; v1 = x1_[1];
    switch (order) {
      case 0: {
        double t = (z - z0_) / delta_z_;
        double t2 = t * t;
        double t3 = t2 * t;

        return (2.0 * t3 - 3.0 * t2 + 1.0) * p0 + (t3 - 2 * t2 + t) * v0 +
               (-2.0 * t3 + 3.0 * t2) * p1 + (t3 - t2) * v1;
      }
      case 1: {
        double t = (z - z0_) / delta_z_;
        double t2 = t * t;

        return (6.0 * t2 - 6.0 * t) * p0 + (3.0 * t2 - 4 * t + 1.0) * v0 +
               (-6.0 * t2 + 6.0 * t) * p1 + (3.0 * t2 - 2.0 * t) * v1;
      }
      case 2: {
        double t = (z - z0_) / delta_z_;
        return (12.0 * t - 6.0) * p0 + (6.0 * t - 4.0) * v0 +
               (-12.0 * t + 6.0) * p1 + (6.0 * t - 2.0) * v1;
      }
      case 3: {
        return 12.0 * p0 + 6.0 * v0 - 12.0 * p1 + 6.0 * v1;
      }
      default: { break; }
    }
  } else {
    CHECK_EQ(5, N);
    const T&amp; p0 = x0_[0];
    const T&amp; v0 = x0_[1];
    const T&amp; a0 = x0_[2];
    const T&amp; p1 = x1_[0];
    const T&amp; v1 = x1_[1];
    const T&amp; a1 = x1_[2];

    switch (order) {
      case 0: {
        double t = (z - z0_) / delta_z_;
        double t2 = t * t;
        double t3 = t * t2;
        double t4 = t2 * t2;
        double t5 = t2 * t3;
        double det0 = t3 - t4;
        double det1 = t4 - t5;
        double h0 = 1.0 - 10.0 * t3 + 15.0 * t4 - 6.0 * t5;
        double h1 = t - 6.0 * t3 + 8.0 * t4 - 3.0 * t5;
        double h2 = 0.5 * (t2 - t5) - 1.5 * det0;
        double h3 = 10.0 * t3 - 15.0 * t4 + 6.0 * t5;
        double h4 = -4.0 * det0 + 3.0 * det1;
        double h5 = 0.5 * (det0 - det1);

        return h0 * p0 + h1 * v0 + h2 * a0 + h3 * p1 + h4 * v1 + h5 * a1;
      }
      case 1: {
        double t = (z - z0_) / delta_z_;
        double t2 = t * t;
        double t3 = t * t2;
        double t4 = t2 * t2;
        double det0 = t2 - t3;
        double det1 = t3 - t4;
        double dh0 = -30.0 * det0 + 30.0 * det1;
        double dh1 = 1 - 18.0 * t2 + 32.0 * t3 - 15.0 * t4;
        double dh2 = t - 4.5 * t2 + 6.0 * t3 - 2.5 * t4;
        double dh3 = 30.0 * det0 - 30.0 * det1;
        double dh4 = -12.0 * t2 + 28.0 * t3 - 15.0 * t4;
        double dh5 = 1.5 * det0 - 2.5 * det1;

        return dh0 * p0 + dh1 * v0 + dh2 * a0 + dh3 * p1 + dh4 * v1 + dh5 * a1;
      }
      case 2: {
        double t = (z - z0_) / delta_z_;
        double t2 = t * t;
        double t3 = t * t2;
        double det0 = t - t2;
        double det1 = t2 - t3;
        double ddh0 = -60.0 * det0 + 120.0 * det1;
        double ddh1 = -36.0 * det0 + 60.0 * det1;
        double ddh2 = 1.0 - 9.0 * t + 18.0 * t2 - 10.0 * t3;
        double ddh3 = 60.0 * det0 - 120.0 * det1;
        double ddh4 = -24.0 * det0 + 60.0 * det1;
        double ddh5 = 3.0 * t - 12.0 * t2 + 10.0 * t3;

        return ddh0 * p0 + ddh1 * v0 + ddh2 * a0 + ddh3 * p1 + ddh4 * v1 +
               ddh5 * a1;
      }
      case 3: {
        double t = (z - z0_) / delta_z_;
        double t2 = t * t;
        double det = t - t2;
        double dddh0 = -60.0 + 360.0 * det;
        double dddh1 = -36.0 + 192.0 * t - 180.0 * t2;
        double dddh2 = -9.0 + 36.0 * t - 30.0 * t2;
        double dddh3 = 60.0 - 360.0 * det;
        double dddh4 = -24.0 + 168.0 * t - 180.0 * t2;
        double dddh5 = 3.0 - 24.0 * t + 30.0 * t2;

        return dddh0 * p0 + dddh1 * v0 + dddh2 * a0 + dddh3 * p1 + dddh4 * v1 +
               dddh5 * a1;
      }
      case 4: {
        double t = (z - z0_) / delta_z_;
        double d4h0 = 360.0 - 720.0 * t;
        double d4h1 = 192.0 - 360.0 * t;
        double d4h2 = 36.0 - 60.0 * t;
        double d4h3 = -360.0 + 720.0 * t;
        double d4h4 = 168.0 - 360.0 * t;
        double d4h5 = -24.0 + 60.0 * t;

        return d4h0 * p0 + d4h1 * v0 + d4h2 * a0 + d4h3 * p1 + d4h4 * v1 +
               d4h5 * a1;
      }
      case 5: {
        double d5h0 = -720.0;
        double d5h1 = -360.0;
        double d5h2 = -60.0;
        double d5h3 = 720.0;
        double d5h4 = -360.0;
        double d5h5 = 60.0;

        return d5h0 * p0 + d5h1 * v0 + d5h2 * a0 + d5h3 * p1 + d5h4 * v1 +
               d5h5 * a1;
      }
      default: { break; }
    }
  }
  return T();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\kalman_filter.cc" startLine="(62, 0)" endLine="(93, 1)" clone_start="6" clone_end="16">
			<code function_name="KalmanFilter::InitParams(const double&amp; measurement_noise, const double&amp; initial_velocity_noise, const double&amp; xy_propagation_noise, const double&amp; z_propagation_noise)">bool KalmanFilter::InitParams(
  const double&amp; measurement_noise,
  const double&amp; initial_velocity_noise,
  const double&amp; xy_propagation_noise,
  const double&amp; z_propagation_noise) {
  if (measurement_noise &lt; 0) {
    AERROR &lt;&lt; "invalid measurement noise of KalmanFilter!";
    return false;
  }
  if (initial_velocity_noise &lt; 0) {
    AERROR &lt;&lt; "invalid intial velocity noise of KalmanFilter!";
    return false;
  }
  if (xy_propagation_noise &lt; 0) {
    AERROR &lt;&lt; "invalid xy propagation noise of KalmanFilter!";
    return false;
  }
  if (z_propagation_noise &lt; 0) {
    AERROR &lt;&lt; "invalid z propagation noise of KalmanFilter!";
    return false;
  }
  s_measurement_noise_ = measurement_noise;
  s_initial_velocity_noise_ = initial_velocity_noise;
  s_propagation_noise_(0, 0) = xy_propagation_noise;
  s_propagation_noise_(1, 1) = xy_propagation_noise;
  s_propagation_noise_(2, 2) = z_propagation_noise;
  AINFO &lt;&lt; "measurment noise of KalmanFilter is " &lt;&lt; s_measurement_noise_;
  AINFO &lt;&lt; "initial velocity noise of KalmanFilter is "
        &lt;&lt; s_initial_velocity_noise_;
  AINFO &lt;&lt; "propagation noise of KalmanFilter is\n" &lt;&lt; s_propagation_noise_;
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\kalman_filter.cc" startLine="(62, 0)" endLine="(93, 1)" clone_start="10" clone_end="20">
			<code function_name="KalmanFilter::InitParams(const double&amp; measurement_noise, const double&amp; initial_velocity_noise, const double&amp; xy_propagation_noise, const double&amp; z_propagation_noise)">bool KalmanFilter::InitParams(
  const double&amp; measurement_noise,
  const double&amp; initial_velocity_noise,
  const double&amp; xy_propagation_noise,
  const double&amp; z_propagation_noise) {
  if (measurement_noise &lt; 0) {
    AERROR &lt;&lt; "invalid measurement noise of KalmanFilter!";
    return false;
  }
  if (initial_velocity_noise &lt; 0) {
    AERROR &lt;&lt; "invalid intial velocity noise of KalmanFilter!";
    return false;
  }
  if (xy_propagation_noise &lt; 0) {
    AERROR &lt;&lt; "invalid xy propagation noise of KalmanFilter!";
    return false;
  }
  if (z_propagation_noise &lt; 0) {
    AERROR &lt;&lt; "invalid z propagation noise of KalmanFilter!";
    return false;
  }
  s_measurement_noise_ = measurement_noise;
  s_initial_velocity_noise_ = initial_velocity_noise;
  s_propagation_noise_(0, 0) = xy_propagation_noise;
  s_propagation_noise_(1, 1) = xy_propagation_noise;
  s_propagation_noise_(2, 2) = z_propagation_noise;
  AINFO &lt;&lt; "measurment noise of KalmanFilter is " &lt;&lt; s_measurement_noise_;
  AINFO &lt;&lt; "initial velocity noise of KalmanFilter is "
        &lt;&lt; s_initial_velocity_noise_;
  AINFO &lt;&lt; "propagation noise of KalmanFilter is\n" &lt;&lt; s_propagation_noise_;
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\pedestrian\regional_predictor.cc" startLine="(90, 0)" endLine="(119, 1)" clone_start="1" clone_end="14">
			<code function_name="RegionalPredictor::GenerateStillTrajectory(const Obstacle* obstacle, double probability)">void RegionalPredictor::GenerateStillTrajectory(const Obstacle* obstacle,
                                                double probability) {
  if (obstacle == nullptr) {
    AERROR &lt;&lt; "Missing obstacle.";
    return;
  }
  const Feature&amp; feature = obstacle-&gt;latest_feature();
  if (!feature.has_position() || !feature.position().has_x() ||
      !feature.position().has_y() || !feature.has_velocity()) {
    AERROR &lt;&lt; "Missing position or velocity.";
    return;
  }

  Eigen::Vector2d position(feature.position().x(), feature.position().y());
  double heading = 0.0 - M_PI;
  const int num_traj = FLAGS_num_trajectory_still_pedestrian;
  const double delta_heading = 2.0 * M_PI / num_traj;
  const double speed = FLAGS_pedestrian_min_speed;
  const double total_time = FLAGS_prediction_pedestrian_total_time;
  const int start_index = NumOfTrajectories();

  for (int i = 0; i &lt; num_traj; ++i) {
    std::vector&lt;TrajectoryPoint&gt; points;
    DrawStillTrajectory(position, heading, speed, total_time, &amp;points);
    Trajectory trajectory = GenerateTrajectory(points);
    trajectories_.push_back(std::move(trajectory));
    heading += delta_heading;
  }
  SetEqualProbability(probability, start_index);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\pedestrian\regional_predictor.cc" startLine="(121, 0)" endLine="(162, 1)" clone_start="1" clone_end="14">
			<code function_name="RegionalPredictor::GenerateMovingTrajectory(const Obstacle* obstacle, double probability)">void RegionalPredictor::GenerateMovingTrajectory(const Obstacle* obstacle,
                                                 double probability) {
  if (obstacle == nullptr) {
    AERROR &lt;&lt; "Missing obstacle.";
    return;
  }
  const Feature&amp; feature = obstacle-&gt;latest_feature();
  if (!feature.has_position() || !feature.position().has_x() ||
      !feature.position().has_y() || !feature.has_velocity()) {
    AERROR &lt;&lt; "Missing position or velocity.";
    return;
  }

  Eigen::Vector2d position(feature.position().x(), feature.position().y());
  Eigen::Vector2d velocity(feature.velocity().x(), feature.velocity().y());
  Eigen::Vector2d acc(0.0, 0.0);
  if (FLAGS_enable_kf_tracking) {
    velocity[0] = feature.t_velocity().x();
    velocity[1] = feature.t_velocity().y();
  }
  if (FLAGS_enable_pedestrian_acc) {
    acc = {feature.acceleration().x(), feature.acceleration().y()};
    if (FLAGS_enable_kf_tracking) {
      acc = {feature.t_acceleration().x(), feature.t_acceleration().y()};
    }
  }

  const double total_time = FLAGS_prediction_pedestrian_total_time;
  std::vector&lt;TrajectoryPoint&gt; left_points;
  std::vector&lt;TrajectoryPoint&gt; right_points;

  DrawMovingTrajectory(position, velocity, acc,
                       obstacle-&gt;kf_pedestrian_tracker(), total_time,
                       &amp;left_points, &amp;right_points);
  int start_index = NumOfTrajectories();

  Trajectory left_trajectory = GenerateTrajectory(left_points);
  Trajectory right_trajectory = GenerateTrajectory(right_points);
  trajectories_.push_back(std::move(left_trajectory));
  trajectories_.push_back(std::move(right_trajectory));
  SetEqualProbability(probability, start_index);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\reference_line\reference_line_smoother.cc" startLine="(153, 0)" endLine="(212, 1)" clone_start="50" clone_end="60">
			<code function_name="ReferenceLineSmoother::ApplyConstraint( const ReferenceLine&amp; raw_reference_line)">bool ReferenceLineSmoother::ApplyConstraint(
    const ReferenceLine&amp; raw_reference_line) {
  const double t_length = t_knots_.back() - t_knots_.front();
  const double dt = t_length / (smoother_config_.num_evaluated_points() - 1);
  std::vector&lt;double&gt; evaluated_t;
  double accumulated_eval_t = 0.0;
  for (std::uint32_t i = 0; i &lt; smoother_config_.num_evaluated_points();
       ++i, accumulated_eval_t += dt) {
    evaluated_t.push_back(accumulated_eval_t);
  }
  std::vector&lt;common::PathPoint&gt; path_points;
  if (!ExtractEvaluatedPoints(raw_reference_line, evaluated_t, &amp;path_points)) {
    AERROR &lt;&lt; "Extract evaluated points failed";
    return false;
  }

  // Add x, y boundary constraint
  std::vector&lt;double&gt; headings;
  std::vector&lt;double&gt; longitidinal_bound;
  std::vector&lt;double&gt; lateral_bound;
  std::vector&lt;common::math::Vec2d&gt; xy_points;
  for (std::uint32_t i = 0; i &lt; path_points.size(); ++i) {
    const double kBoundCoeff = 0.5;
    headings.push_back(path_points[i].theta());
    longitidinal_bound.push_back(kBoundCoeff *
                                 smoother_config_.boundary_bound());
    lateral_bound.push_back(smoother_config_.boundary_bound());
    xy_points.emplace_back(path_points[i].x(), path_points[i].y());
  }

  static constexpr double kFixedBoundLimit = 0.01;
  if (longitidinal_bound.size() &gt; 0) {
    longitidinal_bound.front() = kFixedBoundLimit;
    longitidinal_bound.back() = kFixedBoundLimit;
  }

  if (lateral_bound.size() &gt; 0) {
    lateral_bound.front() = 0.0;
    lateral_bound.back() = kFixedBoundLimit;
  }

  CHECK_EQ(evaluated_t.size(), headings.size());
  CHECK_EQ(evaluated_t.size(), xy_points.size());
  CHECK_EQ(evaluated_t.size(), longitidinal_bound.size());
  CHECK_EQ(evaluated_t.size(), lateral_bound.size());

  auto* spline_constraint = spline_solver_-&gt;mutable_constraint();
  if (!spline_constraint-&gt;Add2dBoundary(evaluated_t, headings, xy_points,
                                        longitidinal_bound, lateral_bound)) {
    AERROR &lt;&lt; "Add 2d boundary constraint failed";
    return false;
  }

  if (!spline_constraint-&gt;AddThirdDerivativeSmoothConstraint()) {
    AERROR &lt;&lt; "Add jointness constraint failed";
    return false;
  }

  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\qp_spline_path\qp_spline_path_generator.cc" startLine="(234, 0)" endLine="(324, 1)" clone_start="81" clone_end="91">
			<code function_name="QpSplinePathGenerator::AddConstraint( const QpFrenetFrame&amp; qp_frenet_frame)">bool QpSplinePathGenerator::AddConstraint(
    const QpFrenetFrame&amp; qp_frenet_frame) {
  Spline1dConstraint* spline_constraint =
      spline_generator_-&gt;mutable_spline_constraint();

  // add init status constraint, equality constraint
  spline_constraint-&gt;AddPointConstraint(init_frenet_point_.s(),
                                        init_frenet_point_.l());
  spline_constraint-&gt;AddPointDerivativeConstraint(init_frenet_point_.s(),
                                                  init_frenet_point_.dl());
  spline_constraint-&gt;AddPointSecondDerivativeConstraint(
      init_frenet_point_.s(), init_frenet_point_.ddl());

  ADEBUG &lt;&lt; "init frenet point: " &lt;&lt; init_frenet_point_.ShortDebugString();

  // add end point constraint, equality constraint
  spline_constraint-&gt;AddPointConstraint(knots_.back(), 0.0);

  spline_constraint-&gt;AddPointDerivativeConstraint(knots_.back(), 0.0);

  spline_constraint-&gt;AddPointSecondDerivativeConstraint(knots_.back(), 0.0);

  // kappa bound is based on the inequality:
  // kappa = d(phi)/ds &lt;= d(phi)/dx = d2y/dx2
  std::vector&lt;double&gt; kappa_lower_bound(evaluated_s_.size(),
                                        -FLAGS_kappa_bound);
  std::vector&lt;double&gt; kappa_upper_bound(evaluated_s_.size(), FLAGS_kappa_bound);
  if (!spline_constraint-&gt;AddSecondDerivativeBoundary(
          evaluated_s_, kappa_lower_bound, kappa_upper_bound)) {
    AERROR &lt;&lt; "Fail to add second derivative boundary.";
    return false;
  }

  // add map bound constraint
  const auto lateral_buf = qp_spline_path_config_.cross_lane_extension_buffer();
  std::vector&lt;double&gt; boundary_low;
  std::vector&lt;double&gt; boundary_high;
  for (const double s : evaluated_s_) {
    std::pair&lt;double, double&gt; road_boundary(0.0, 0.0);
    std::pair&lt;double, double&gt; static_obs_boundary(0.0, 0.0);
    std::pair&lt;double, double&gt; dynamic_obs_boundary(0.0, 0.0);

    qp_frenet_frame.GetMapBound(s, &amp;road_boundary);
    qp_frenet_frame.GetStaticObstacleBound(s, &amp;static_obs_boundary);
    qp_frenet_frame.GetDynamicObstacleBound(s, &amp;dynamic_obs_boundary);

    road_boundary.first =
        std::fmin(road_boundary.first, init_frenet_point_.l() - lateral_buf);
    road_boundary.second =
        std::fmax(road_boundary.second, init_frenet_point_.l() + lateral_buf);

    boundary_low.emplace_back(common::util::MaxElement(
        std::vector&lt;double&gt;{road_boundary.first, static_obs_boundary.first,
                            dynamic_obs_boundary.first}));
    boundary_high.emplace_back(common::util::MinElement(
        std::vector&lt;double&gt;{road_boundary.second, static_obs_boundary.second,
                            dynamic_obs_boundary.second}));

    ADEBUG &lt;&lt; "s:" &lt;&lt; s &lt;&lt; " boundary_low:" &lt;&lt; boundary_low.back()
           &lt;&lt; " boundary_high:" &lt;&lt; boundary_high.back()
           &lt;&lt; " road_boundary_low: " &lt;&lt; road_boundary.first
           &lt;&lt; " road_boundary_high: " &lt;&lt; road_boundary.second
           &lt;&lt; " static_obs_boundary_low: " &lt;&lt; static_obs_boundary.first
           &lt;&lt; " static_obs_boundary_high: " &lt;&lt; static_obs_boundary.second
           &lt;&lt; " dynamic_obs_boundary_low: " &lt;&lt; dynamic_obs_boundary.first
           &lt;&lt; " dynamic_obs_boundary_high: " &lt;&lt; dynamic_obs_boundary.second;
  }

  if (planning_debug_) {
    apollo::planning_internal::SLFrameDebug* sl_frame =
        planning_debug_-&gt;mutable_planning_data()-&gt;mutable_sl_frame()-&gt;Add();
    for (size_t i = 0; i &lt; evaluated_s_.size(); ++i) {
      sl_frame-&gt;mutable_aggregated_boundary_s()-&gt;Add(evaluated_s_[i]);
      sl_frame-&gt;mutable_aggregated_boundary_low()-&gt;Add(boundary_low[i]);
      sl_frame-&gt;mutable_aggregated_boundary_high()-&gt;Add(boundary_high[i]);
    }
  }

  if (!spline_constraint-&gt;AddBoundary(evaluated_s_, boundary_low,
                                      boundary_high)) {
    AERROR &lt;&lt; "Add boundary constraint failed";
    return false;
  }

  // add spline joint third derivative constraint
  if (!spline_constraint-&gt;AddThirdDerivativeSmoothConstraint()) {
    AERROR &lt;&lt; "Add spline joint third derivative constraint failed!";
    return false;
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\reference_line\reference_line_smoother.cc" startLine="(214, 0)" endLine="(235, 1)" clone_start="1" clone_end="5">
			<code function_name="ReferenceLineSmoother::ApplyKernel()">bool ReferenceLineSmoother::ApplyKernel() {
  Spline2dKernel* kernel = spline_solver_-&gt;mutable_kernel();

  // add spline kernel
  if (smoother_config_.derivative_weight() &gt; 0.0) {
    kernel-&gt;AddDerivativeKernelMatrix(smoother_config_.derivative_weight());
  }

  if (smoother_config_.second_derivative_weight() &gt; 0.0) {
    kernel-&gt;AddSecondOrderDerivativeMatrix(
        smoother_config_.second_derivative_weight());
  }

  if (smoother_config_.third_derivative_weight() &gt; 0.0) {
    kernel-&gt;AddThirdOrderDerivativeMatrix(
        smoother_config_.third_derivative_weight());
  }

  constexpr double kReferenceLineSmootherKernelWeight = 0.01;
  kernel-&gt;AddRegularization(kReferenceLineSmootherKernelWeight);
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\qp_spline_path\qp_spline_path_generator.cc" startLine="(326, 0)" endLine="(356, 1)" clone_start="1" clone_end="4">
			<code function_name="QpSplinePathGenerator::AddKernel()">void QpSplinePathGenerator::AddKernel() {
  Spline1dKernel* spline_kernel = spline_generator_-&gt;mutable_spline_kernel();

  if (qp_spline_path_config_.reference_line_weight() &gt; 0.0) {
    std::vector&lt;double&gt; ref_l(evaluated_s_.size(), 0.0);

    DCHECK_EQ(evaluated_s_.size(), ref_l.size());
    spline_kernel-&gt;AddReferenceLineKernelMatrix(
        evaluated_s_, ref_l, qp_spline_path_config_.reference_line_weight());
  }

  if (qp_spline_path_config_.regularization_weight() &gt; 0.0) {
    spline_kernel-&gt;AddRegularization(
        qp_spline_path_config_.regularization_weight());
  }

  if (qp_spline_path_config_.derivative_weight() &gt; 0.0) {
    spline_kernel-&gt;AddDerivativeKernelMatrix(
        qp_spline_path_config_.derivative_weight());
  }

  if (qp_spline_path_config_.second_derivative_weight() &gt; 0.0) {
    spline_kernel-&gt;AddSecondOrderDerivativeMatrix(
        qp_spline_path_config_.second_derivative_weight());
  }

  if (qp_spline_path_config_.third_derivative_weight() &gt; 0.0) {
    spline_kernel-&gt;AddThirdOrderDerivativeMatrix(
        qp_spline_path_config_.third_derivative_weight());
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\lib\config_manager\config_manager.cc" startLine="(145, 0)" endLine="(227, 1)" clone_start="20" clone_end="36">
			<code function_name="ModelConfig::Reset(const ModelConfigProto&amp; proto)">bool ModelConfig::Reset(const ModelConfigProto&amp; proto) {
  name_ = proto.name();
  version_ = proto.version();

  integer_param_map_.clear();
  string_param_map_.clear();
  double_param_map_.clear();
  float_param_map_.clear();
  bool_param_map_.clear();
  array_integer_param_map_.clear();
  array_string_param_map_.clear();
  array_double_param_map_.clear();
  array_float_param_map_.clear();
  array_bool_param_map_.clear();

  for (const KeyValueInt&amp; pair : proto.integer_params()) {
    integer_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueString&amp; pair : proto.string_params()) {
    string_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueDouble&amp; pair : proto.double_params()) {
    double_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueFloat&amp; pair : proto.float_params()) {
    float_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueBool&amp; pair : proto.bool_params()) {
    bool_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueArrayInt&amp; pair : proto.array_integer_params()) {
    std::vector&lt;int&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_integer_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayString&amp; pair : proto.array_string_params()) {
    std::vector&lt;std::string&gt; values;
    values.reserve(pair.values_size());
    for (const std::string&amp; value : pair.values()) {
      values.push_back(value);
    }
    array_string_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayDouble&amp; pair : proto.array_double_params()) {
    std::vector&lt;double&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_double_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayFloat&amp; pair : proto.array_float_params()) {
    std::vector&lt;float&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_float_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayBool&amp; pair : proto.array_bool_params()) {
    std::vector&lt;bool&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_bool_param_map_.emplace(pair.name(), values);
  }

  AINFO &lt;&lt; "reset ModelConfig. model_name: " &lt;&lt; name_
        &lt;&lt; " integer_param_map's size: " &lt;&lt; integer_param_map_.size()
        &lt;&lt; " string_param_map's size: " &lt;&lt; string_param_map_.size()
        &lt;&lt; " double_param_map's size: " &lt;&lt; double_param_map_.size()
        &lt;&lt; " float_param_map's size: " &lt;&lt; float_param_map_.size()
        &lt;&lt; " bool_param_map's size: " &lt;&lt; bool_param_map_.size()
        &lt;&lt; " array_integer_param_map's size: "
        &lt;&lt; array_integer_param_map_.size()
        &lt;&lt; " array_string_param_map's size: " &lt;&lt; array_string_param_map_.size()
        &lt;&lt; " array_double_param_map's size: " &lt;&lt; array_double_param_map_.size()
        &lt;&lt; " array_float_param_map's size: " &lt;&lt; array_float_param_map_.size()
        &lt;&lt; " array_bool_param_map's size: " &lt;&lt; array_bool_param_map_.size();

  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\lib\config_manager\config_manager.cc" startLine="(145, 0)" endLine="(227, 1)" clone_start="16" clone_end="32">
			<code function_name="ModelConfig::Reset(const ModelConfigProto&amp; proto)">bool ModelConfig::Reset(const ModelConfigProto&amp; proto) {
  name_ = proto.name();
  version_ = proto.version();

  integer_param_map_.clear();
  string_param_map_.clear();
  double_param_map_.clear();
  float_param_map_.clear();
  bool_param_map_.clear();
  array_integer_param_map_.clear();
  array_string_param_map_.clear();
  array_double_param_map_.clear();
  array_float_param_map_.clear();
  array_bool_param_map_.clear();

  for (const KeyValueInt&amp; pair : proto.integer_params()) {
    integer_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueString&amp; pair : proto.string_params()) {
    string_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueDouble&amp; pair : proto.double_params()) {
    double_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueFloat&amp; pair : proto.float_params()) {
    float_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueBool&amp; pair : proto.bool_params()) {
    bool_param_map_.emplace(pair.name(), pair.value());
  }

  for (const KeyValueArrayInt&amp; pair : proto.array_integer_params()) {
    std::vector&lt;int&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_integer_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayString&amp; pair : proto.array_string_params()) {
    std::vector&lt;std::string&gt; values;
    values.reserve(pair.values_size());
    for (const std::string&amp; value : pair.values()) {
      values.push_back(value);
    }
    array_string_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayDouble&amp; pair : proto.array_double_params()) {
    std::vector&lt;double&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_double_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayFloat&amp; pair : proto.array_float_params()) {
    std::vector&lt;float&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_float_param_map_.emplace(pair.name(), values);
  }

  for (const KeyValueArrayBool&amp; pair : proto.array_bool_params()) {
    std::vector&lt;bool&gt; values;
    RepeatedToVector(pair.values(), &amp;values);
    array_bool_param_map_.emplace(pair.name(), values);
  }

  AINFO &lt;&lt; "reset ModelConfig. model_name: " &lt;&lt; name_
        &lt;&lt; " integer_param_map's size: " &lt;&lt; integer_param_map_.size()
        &lt;&lt; " string_param_map's size: " &lt;&lt; string_param_map_.size()
        &lt;&lt; " double_param_map's size: " &lt;&lt; double_param_map_.size()
        &lt;&lt; " float_param_map's size: " &lt;&lt; float_param_map_.size()
        &lt;&lt; " bool_param_map's size: " &lt;&lt; bool_param_map_.size()
        &lt;&lt; " array_integer_param_map's size: "
        &lt;&lt; array_integer_param_map_.size()
        &lt;&lt; " array_string_param_map's size: " &lt;&lt; array_string_param_map_.size()
        &lt;&lt; " array_double_param_map's size: " &lt;&lt; array_double_param_map_.size()
        &lt;&lt; " array_float_param_map's size: " &lt;&lt; array_float_param_map_.size()
        &lt;&lt; " array_bool_param_map's size: " &lt;&lt; array_bool_param_map_.size();

  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\qp_spline_path\qp_frenet_frame.cc" startLine="(154, 0)" endLine="(225, 1)" clone_start="23" clone_end="34">
			<code function_name="QpFrenetFrame::MapDynamicObstacleWithDecision( const PathObstacle&amp; path_obstacle)">bool QpFrenetFrame::MapDynamicObstacleWithDecision(
    const PathObstacle&amp; path_obstacle) {
  const Obstacle* ptr_obstacle = path_obstacle.obstacle();
  if (!path_obstacle.HasLateralDecision()) {
    ADEBUG &lt;&lt; "object has no lateral decision";
    return false;
  }
  const auto&amp; decision = path_obstacle.LateralDecision();
  if (!decision.has_nudge()) {
    AWARN &lt;&lt; "only support nudge now";
    return true;
  }
  const auto&amp; nudge = decision.nudge();
  for (const SpeedPoint&amp; veh_point : discretized_vehicle_location_) {
    double time = veh_point.t();
    common::TrajectoryPoint trajectory_point =
        ptr_obstacle-&gt;GetPointAtTime(time);
    common::math::Box2d obs_box =
        ptr_obstacle-&gt;GetBoundingBox(trajectory_point);
    // project obs_box on reference line
    std::vector&lt;common::math::Vec2d&gt; corners;
    obs_box.GetAllCorners(&amp;corners);
    std::vector&lt;common::SLPoint&gt; sl_corners;

    for (const auto&amp; corner_xy : corners) {
      common::SLPoint cur_point;
      if (!reference_line_.XYToSL(corner_xy, &amp;cur_point)) {
        AERROR &lt;&lt; "Fail to map xy point " &lt;&lt; corner_xy.DebugString() &lt;&lt; " to "
               &lt;&lt; cur_point.ShortDebugString();
        return false;
      }
      // shift box base on buffer
      cur_point.set_l(cur_point.l() + nudge.distance_l());
      sl_corners.push_back(std::move(cur_point));
    }

    for (uint32_t i = 0; i &lt; sl_corners.size(); ++i) {
      common::SLPoint sl_first = sl_corners[i % sl_corners.size()];
      common::SLPoint sl_second = sl_corners[(i + 1) % sl_corners.size()];
      if (sl_first.s() &lt; sl_second.s()) {
        std::swap(sl_first, sl_second);
      }

      std::pair&lt;double, double&gt; bound = MapLateralConstraint(
          sl_first, sl_second, nudge.type(),
          veh_point.s() - vehicle_param_.back_edge_to_center(),
          veh_point.s() + vehicle_param_.front_edge_to_center());

      // update bound map
      double s_resolution = std::fabs(veh_point.v() * time_resolution_);
      double updated_start_s =
          init_frenet_point_.s() + veh_point.s() - s_resolution;
      double updated_end_s =
          init_frenet_point_.s() + veh_point.s() + s_resolution;
      if (updated_end_s &gt; evaluated_knots_.back() ||
          updated_start_s &lt; evaluated_knots_.front()) {
        continue;
      }
      std::pair&lt;uint32_t, uint32_t&gt; update_index_range =
          FindInterval(updated_start_s, updated_end_s);

      for (uint32_t j = update_index_range.first;
           j &lt;= update_index_range.second; ++j) {
        dynamic_obstacle_bound_[j].first =
            std::max(bound.first, dynamic_obstacle_bound_[j].first);
        dynamic_obstacle_bound_[j].second =
            std::min(bound.second, dynamic_obstacle_bound_[j].second);
      }
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\qp_spline_path\qp_frenet_frame.cc" startLine="(251, 0)" endLine="(278, 1)" clone_start="4" clone_end="15">
			<code function_name="QpFrenetFrame::MapPolygon(const std::vector&lt;common::math::Vec2d&gt;&amp; corners, const ObjectNudge&amp; nudge, std::vector&lt;std::pair&lt;double, double&gt;&gt;* const bound_map)">bool QpFrenetFrame::MapPolygon(
    const std::vector&lt;common::math::Vec2d&gt;&amp; corners, const ObjectNudge&amp; nudge,
    std::vector&lt;std::pair&lt;double, double&gt;&gt;* const bound_map) {
  std::vector&lt;common::SLPoint&gt; sl_corners;

  for (const auto&amp; corner_xy : corners) {
    common::SLPoint cur_point;
    if (!reference_line_.XYToSL(corner_xy, &amp;cur_point)) {
      AERROR &lt;&lt; "Fail to map xy point " &lt;&lt; corner_xy.DebugString() &lt;&lt; " to "
             &lt;&lt; cur_point.DebugString();
      return false;
    }
    // shift box base on buffer
    cur_point.set_l(cur_point.l() + nudge.distance_l());
    sl_corners.push_back(std::move(cur_point));
  }

  const auto corner_size = sl_corners.size();
  for (uint32_t i = 0; i &lt; corner_size; ++i) {
    if (!MapLine(sl_corners[i % corner_size], sl_corners[(i + 1) % corner_size],
                 nudge.type(), bound_map)) {
      AERROR &lt;&lt; "Map box line (sl) " &lt;&lt; sl_corners[i].DebugString() &lt;&lt; "-&gt;"
             &lt;&lt; sl_corners[i + 1].DebugString();
      return false;
    }
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\strategy\a_star_strategy.cc" startLine="(335, 0)" endLine="(359, 1)" clone_start="13" clone_end="24">
			<code function_name="AStarStrategy::GetResidualS(const TopoNode* node)">double AStarStrategy::GetResidualS(const TopoNode* node) {
  double start_s = node-&gt;StartS();
  const auto iter = enter_s_.find(node);
  if (iter != enter_s_.end()) {
    if (iter-&gt;second &gt; node-&gt;EndS()) {
      return 0.0;
    }
    start_s = iter-&gt;second;
  } else {
    AWARN &lt;&lt; "lane " &lt;&lt; node-&gt;LaneId() &lt;&lt; "(" &lt;&lt; node-&gt;StartS() &lt;&lt; ", "
          &lt;&lt; node-&gt;EndS() &lt;&lt; "not found in enter_s map";
  }
  double end_s = node-&gt;EndS();
  const TopoNode* succ_node = nullptr;
  for (const auto* edge : node-&gt;OutToAllEdge()) {
    if (edge-&gt;ToNode()-&gt;LaneId() == node-&gt;LaneId()) {
      succ_node = edge-&gt;ToNode();
      break;
    }
  }
  if (succ_node != nullptr) {
    end_s = succ_node-&gt;EndS();
  }
  return (end_s - start_s);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\strategy\a_star_strategy.cc" startLine="(361, 0)" endLine="(388, 1)" clone_start="16" clone_end="27">
			<code function_name="AStarStrategy::GetResidualS(const TopoEdge* edge, const TopoNode* to_node)">double AStarStrategy::GetResidualS(const TopoEdge* edge,
                                   const TopoNode* to_node) {
  if (edge-&gt;Type() == TopoEdgeType::TET_FORWARD) {
    return std::numeric_limits&lt;double&gt;::max();
  }
  double start_s = to_node-&gt;StartS();
  const auto* from_node = edge-&gt;FromNode();
  const auto iter = enter_s_.find(from_node);
  if (iter != enter_s_.end()) {
    double temp_s = iter-&gt;second / from_node-&gt;Length() * to_node-&gt;Length();
    start_s = std::max(start_s, temp_s);
  } else {
    AWARN &lt;&lt; "lane " &lt;&lt; from_node-&gt;LaneId() &lt;&lt; "(" &lt;&lt; from_node-&gt;StartS()
          &lt;&lt; ", " &lt;&lt; from_node-&gt;EndS() &lt;&lt; "not found in enter_s map";
  }
  double end_s = to_node-&gt;EndS();
  const TopoNode* succ_node = nullptr;
  for (const auto* edge : to_node-&gt;OutToAllEdge()) {
    if (edge-&gt;ToNode()-&gt;LaneId() == to_node-&gt;LaneId()) {
      succ_node = edge-&gt;ToNode();
      break;
    }
  }
  if (succ_node != nullptr) {
    end_s = succ_node-&gt;EndS();
  }
  return (end_s - start_s);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(53, 0)" endLine="(56, 1)" clone_start="1" clone_end="4">
			<code function_name="Steering64::set_steering_angle(double angle)">Steering64 *Steering64::set_steering_angle(double angle) {
  steering_angle_ = angle;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(49, 0)" endLine="(52, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle62::set_pedal(double pedal)">Throttle62 *Throttle62::set_pedal(double pedal) {
  pedal_cmd_ = pedal;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(58, 0)" endLine="(61, 1)" clone_start="1" clone_end="4">
			<code function_name="Steering64::set_enable()">Steering64 *Steering64::set_enable() {
  steering_enable_ = true;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(54, 0)" endLine="(57, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle62::set_enable()">Throttle62 *Throttle62::set_enable() {
  pedal_enable_ = true;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(63, 0)" endLine="(66, 1)" clone_start="1" clone_end="3">
			<code function_name="Steering64::set_disable()">Steering64 *Steering64::set_disable() {
  steering_enable_ = false;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(59, 0)" endLine="(62, 1)" clone_start="1" clone_end="3">
			<code function_name="Throttle62::set_disable()">Throttle62 *Throttle62::set_disable() {
  pedal_enable_ = false;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\controller\lat_controller.cc" startLine="(265, 0)" endLine="(370, 1)" clone_start="75" clone_end="85">
			<code function_name="LatController::ComputeControlCommand(const localization::LocalizationEstimate *localization, const canbus::Chassis *chassis, const planning::ADCTrajectory *planning_published_trajectory, ControlCommand *cmd)">Status LatController::ComputeControlCommand(
    const localization::LocalizationEstimate *localization,
    const canbus::Chassis *chassis,
    const planning::ADCTrajectory *planning_published_trajectory,
    ControlCommand *cmd) {
  VehicleState::instance()-&gt;set_linear_velocity(
      std::max(VehicleState::instance()-&gt;linear_velocity(), 1.0));

  trajectory_analyzer_ =
      std::move(TrajectoryAnalyzer(planning_published_trajectory));

  SimpleLateralDebug *debug = cmd-&gt;mutable_debug()-&gt;mutable_simple_lat_debug();
  debug-&gt;Clear();

  // Update state = [Lateral Error, Lateral Error Rate, Heading Error, Heading
  // Error Rate, preview lateral error1 , preview lateral error2, ...]
  UpdateStateAnalyticalMatching(debug);

  UpdateMatrix();

  // Compound discrete matrix with road preview model
  UpdateMatrixCompound();

  // Add gain sheduler for higher speed steering
  if (FLAGS_enable_gain_scheduler) {
    matrix_q_updated_(0, 0) =
        matrix_q_(0, 0) * lat_err_interpolation_-&gt;Interpolate(
                              VehicleState::instance()-&gt;linear_velocity());
    matrix_q_updated_(2, 2) =
        matrix_q_(2, 2) * heading_err_interpolation_-&gt;Interpolate(
                              VehicleState::instance()-&gt;linear_velocity());
    common::math::SolveLQRProblem(matrix_adc_, matrix_bdc_, matrix_q_updated_,
                                  matrix_r_, lqr_eps_, lqr_max_iteration_,
                                  &amp;matrix_k_);
  } else {
    common::math::SolveLQRProblem(matrix_adc_, matrix_bdc_, matrix_q_,
                                  matrix_r_, lqr_eps_, lqr_max_iteration_,
                                  &amp;matrix_k_);
  }

  // feedback = - K * state
  // Convert vehicle steer angle from rad to degree and then to steer degree
  // then to 100% ratio
  double steer_angle_feedback = -(matrix_k_ * matrix_state_)(0, 0) * 180 /
                                M_PI * steer_transmission_ratio_ /
                                steer_single_direction_max_degree_ * 100;

  double steer_angle_feedforward = ComputeFeedForward(debug-&gt;curvature());
  double steer_angle = steer_angle_feedback + steer_angle_feedforward;

  // Clamp the steer angle to -100.0 to 100.0
  steer_angle = apollo::common::math::Clamp(steer_angle, -100.0, 100.0);

  if (FLAGS_set_steer_limit) {
    double steer_limit =
        std::atan(max_lat_acc_ * wheelbase_ /
                  (VehicleState::instance()-&gt;linear_velocity() *
                   VehicleState::instance()-&gt;linear_velocity())) *
        steer_transmission_ratio_ * 180 / M_PI /
        steer_single_direction_max_degree_ * 100;

    // Clamp the steer angle
    double steer_angle_limited =
        apollo::common::math::Clamp(steer_angle, -steer_limit, steer_limit);
    steer_angle_limited = digital_filter_.Filter(steer_angle_limited);
    cmd-&gt;set_steering_target(steer_angle_limited);
    debug-&gt;set_steer_angle_limited(steer_angle_limited);
  } else {
    steer_angle = digital_filter_.Filter(steer_angle);
    cmd-&gt;set_steering_target(steer_angle);
  }

  cmd-&gt;set_steering_rate(FLAGS_steer_angle_rate);
  // compute extra information for logging and debugging
  double steer_angle_lateral_contribution =
      -matrix_k_(0, 0) * matrix_state_(0, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_lateral_rate_contribution =
      -matrix_k_(0, 1) * matrix_state_(1, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_heading_contribution =
      -matrix_k_(0, 2) * matrix_state_(2, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_heading_rate_contribution =
      -matrix_k_(0, 3) * matrix_state_(3, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  debug-&gt;set_heading(VehicleState::instance()-&gt;heading());
  debug-&gt;set_steer_angle(steer_angle);
  debug-&gt;set_steer_angle_feedforward(steer_angle_feedforward);
  debug-&gt;set_steer_angle_lateral_contribution(steer_angle_lateral_contribution);
  debug-&gt;set_steer_angle_lateral_rate_contribution(
      steer_angle_lateral_rate_contribution);
  debug-&gt;set_steer_angle_heading_contribution(steer_angle_heading_contribution);
  debug-&gt;set_steer_angle_heading_rate_contribution(
      steer_angle_heading_rate_contribution);
  debug-&gt;set_steer_angle_feedback(steer_angle_feedback);
  debug-&gt;set_steering_position(chassis-&gt;steering_percentage());
  debug-&gt;set_ref_speed(VehicleState::instance()-&gt;linear_velocity());

  ProcessLogs(debug, chassis);
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\controller\lat_controller.cc" startLine="(265, 0)" endLine="(370, 1)" clone_start="79" clone_end="89">
			<code function_name="LatController::ComputeControlCommand(const localization::LocalizationEstimate *localization, const canbus::Chassis *chassis, const planning::ADCTrajectory *planning_published_trajectory, ControlCommand *cmd)">Status LatController::ComputeControlCommand(
    const localization::LocalizationEstimate *localization,
    const canbus::Chassis *chassis,
    const planning::ADCTrajectory *planning_published_trajectory,
    ControlCommand *cmd) {
  VehicleState::instance()-&gt;set_linear_velocity(
      std::max(VehicleState::instance()-&gt;linear_velocity(), 1.0));

  trajectory_analyzer_ =
      std::move(TrajectoryAnalyzer(planning_published_trajectory));

  SimpleLateralDebug *debug = cmd-&gt;mutable_debug()-&gt;mutable_simple_lat_debug();
  debug-&gt;Clear();

  // Update state = [Lateral Error, Lateral Error Rate, Heading Error, Heading
  // Error Rate, preview lateral error1 , preview lateral error2, ...]
  UpdateStateAnalyticalMatching(debug);

  UpdateMatrix();

  // Compound discrete matrix with road preview model
  UpdateMatrixCompound();

  // Add gain sheduler for higher speed steering
  if (FLAGS_enable_gain_scheduler) {
    matrix_q_updated_(0, 0) =
        matrix_q_(0, 0) * lat_err_interpolation_-&gt;Interpolate(
                              VehicleState::instance()-&gt;linear_velocity());
    matrix_q_updated_(2, 2) =
        matrix_q_(2, 2) * heading_err_interpolation_-&gt;Interpolate(
                              VehicleState::instance()-&gt;linear_velocity());
    common::math::SolveLQRProblem(matrix_adc_, matrix_bdc_, matrix_q_updated_,
                                  matrix_r_, lqr_eps_, lqr_max_iteration_,
                                  &amp;matrix_k_);
  } else {
    common::math::SolveLQRProblem(matrix_adc_, matrix_bdc_, matrix_q_,
                                  matrix_r_, lqr_eps_, lqr_max_iteration_,
                                  &amp;matrix_k_);
  }

  // feedback = - K * state
  // Convert vehicle steer angle from rad to degree and then to steer degree
  // then to 100% ratio
  double steer_angle_feedback = -(matrix_k_ * matrix_state_)(0, 0) * 180 /
                                M_PI * steer_transmission_ratio_ /
                                steer_single_direction_max_degree_ * 100;

  double steer_angle_feedforward = ComputeFeedForward(debug-&gt;curvature());
  double steer_angle = steer_angle_feedback + steer_angle_feedforward;

  // Clamp the steer angle to -100.0 to 100.0
  steer_angle = apollo::common::math::Clamp(steer_angle, -100.0, 100.0);

  if (FLAGS_set_steer_limit) {
    double steer_limit =
        std::atan(max_lat_acc_ * wheelbase_ /
                  (VehicleState::instance()-&gt;linear_velocity() *
                   VehicleState::instance()-&gt;linear_velocity())) *
        steer_transmission_ratio_ * 180 / M_PI /
        steer_single_direction_max_degree_ * 100;

    // Clamp the steer angle
    double steer_angle_limited =
        apollo::common::math::Clamp(steer_angle, -steer_limit, steer_limit);
    steer_angle_limited = digital_filter_.Filter(steer_angle_limited);
    cmd-&gt;set_steering_target(steer_angle_limited);
    debug-&gt;set_steer_angle_limited(steer_angle_limited);
  } else {
    steer_angle = digital_filter_.Filter(steer_angle);
    cmd-&gt;set_steering_target(steer_angle);
  }

  cmd-&gt;set_steering_rate(FLAGS_steer_angle_rate);
  // compute extra information for logging and debugging
  double steer_angle_lateral_contribution =
      -matrix_k_(0, 0) * matrix_state_(0, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_lateral_rate_contribution =
      -matrix_k_(0, 1) * matrix_state_(1, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_heading_contribution =
      -matrix_k_(0, 2) * matrix_state_(2, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  double steer_angle_heading_rate_contribution =
      -matrix_k_(0, 3) * matrix_state_(3, 0) * 180 / M_PI *
      steer_transmission_ratio_ / steer_single_direction_max_degree_ * 100;

  debug-&gt;set_heading(VehicleState::instance()-&gt;heading());
  debug-&gt;set_steer_angle(steer_angle);
  debug-&gt;set_steer_angle_feedforward(steer_angle_feedforward);
  debug-&gt;set_steer_angle_lateral_contribution(steer_angle_lateral_contribution);
  debug-&gt;set_steer_angle_lateral_rate_contribution(
      steer_angle_lateral_rate_contribution);
  debug-&gt;set_steer_angle_heading_contribution(steer_angle_heading_contribution);
  debug-&gt;set_steer_angle_heading_rate_contribution(
      steer_angle_heading_rate_contribution);
  debug-&gt;set_steer_angle_feedback(steer_angle_feedback);
  debug-&gt;set_steering_position(chassis-&gt;steering_percentage());
  debug-&gt;set_ref_speed(VehicleState::instance()-&gt;linear_velocity());

  ProcessLogs(debug, chassis);
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(168, 0)" endLine="(289, 1)" clone_start="24" clone_end="34">
			<code function_name="LanesXmlParser::ParseLane(const tinyxml2::XMLElement&amp; xml_node, LaneInternal* lane_internal)">Status LanesXmlParser::ParseLane(const tinyxml2::XMLElement&amp; xml_node,
                                 LaneInternal* lane_internal) {
  CHECK_NOTNULL(lane_internal);

  PbLane* lane = &amp;lane_internal-&gt;lane;
  // lane id
  int id = 0;
  int checker = xml_node.QueryIntAttribute("id", &amp;id);
  if (checker != tinyxml2::XML_SUCCESS) {
    std::string err_msg = "Error parse lane id";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  std::string lane_id;
  checker = UtilXmlParser::QueryStringAttribute(xml_node, "uid", &amp;lane_id);
  if (checker != tinyxml2::XML_SUCCESS) {
    std::string err_msg = "Error parse lane uid";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  lane-&gt;mutable_id()-&gt;set_id(lane_id);

  // lane type
  std::string lane_type;
  checker = UtilXmlParser::QueryStringAttribute(xml_node, "type", &amp;lane_type);
  if (checker != tinyxml2::XML_SUCCESS) {
    std::string err_msg = "Error parse lane type.";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  PbLaneType pb_lane_type;
  Status success = ToPbLaneType(lane_type, &amp;pb_lane_type);
  if (!success.ok()) {
    std::string err_msg = "Error convert lane type to pb lane type.";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  lane-&gt;set_type(pb_lane_type);

  // border
  const tinyxml2::XMLElement* sub_node = xml_node.FirstChildElement("border");
  if (sub_node) {
    PbLaneBoundary* lane_boundary = lane-&gt;mutable_right_boundary();
    CHECK(lane_boundary != nullptr);
    success =
        UtilXmlParser::ParseCurve(*sub_node, lane_boundary-&gt;mutable_curve());
    if (!success.ok()) {
      std::string err_msg = "Error parse lane border";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }
    lane_boundary-&gt;set_length(
        UtilXmlParser::CurveLength(*lane_boundary-&gt;mutable_curve()));
  }

  // road mark
  if (sub_node) {
    sub_node = sub_node-&gt;FirstChildElement("borderType");
  }
  while (sub_node) {
    PbLaneBoundary* lane_boundary = lane-&gt;mutable_right_boundary();
    PbLaneBoundaryTypeType boundary_type;
    success = ParseLaneBorderMark(*sub_node, &amp;boundary_type);
    if (!success.ok()) {
      std::string err_msg = "Error parse lane border type";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }
    double s_offset = 0.0;
    checker = sub_node-&gt;QueryDoubleAttribute("sOffset", &amp;s_offset);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse lane boundary type offset.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }
    auto lane_boundary_type = lane_boundary-&gt;add_boundary_type();
    lane_boundary_type-&gt;set_s(s_offset);
    lane_boundary_type-&gt;add_types(boundary_type);
    sub_node = sub_node-&gt;NextSiblingElement("borderType");
  }

  // reference line
  if (IsReferenceLane(id)) {
    return Status::OK();
  }

  // turn type
  std::string turn_type;
  checker =
      UtilXmlParser::QueryStringAttribute(xml_node, "turnType", &amp;turn_type);
  if (checker != tinyxml2::XML_SUCCESS) {
    std::string err_msg = "Error parse lane turn type.";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  PbTurnType pb_turn_type;
  success = ToPbTurnType(turn_type, &amp;pb_turn_type);
  if (!success.ok()) {
    std::string err_msg = "Error convert turn type to pb turn type.";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  lane-&gt;set_turn(pb_turn_type);

  // direction
  RETURN_IF_ERROR(ParseDirection(xml_node, lane));

  // link
  sub_node = xml_node.FirstChildElement("link");
  if (sub_node) {
    ParseLaneLink(*sub_node, lane);
  }

  // center curve
  RETURN_IF_ERROR(ParseCenterCurve(xml_node, lane));
  // speed
  RETURN_IF_ERROR(ParseSpeed(xml_node, lane));
  // sample association
  RETURN_IF_ERROR(ParseSampleAssociates(xml_node, lane));

  // overlap object
  ParseObjectOverlapGroup(xml_node, &amp;lane_internal-&gt;overlap_objects);
  // overlap signal
  ParseSignalOverlapGroup(xml_node, &amp;lane_internal-&gt;overlap_signals);
  // overlap junction
  ParseJunctionOverlapGroup(xml_node, &amp;lane_internal-&gt;overlap_junctions);
  // overlap lane
  ParseLaneOverlapGroup(xml_node, &amp;lane_internal-&gt;overlap_lanes);

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(291, 0)" endLine="(310, 1)" clone_start="7" clone_end="17">
			<code function_name="LanesXmlParser::ParseDirection(const tinyxml2::XMLElement&amp; xml_node, PbLane* lane)">Status LanesXmlParser::ParseDirection(const tinyxml2::XMLElement&amp; xml_node,
                                      PbLane* lane) {
  CHECK_NOTNULL(lane);
  std::string direction;
  int checker =
      UtilXmlParser::QueryStringAttribute(xml_node, "direction", &amp;direction);
  if (checker != tinyxml2::XML_SUCCESS) {
    std::string err_msg = "Error parse lane direction.";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  PbLaneDirection pb_lane_direction;
  Status success = ToPbDirection(direction, &amp;pb_lane_direction);
  if (!success.ok()) {
    std::string err_msg = "Error convert direction to pb direction";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  lane-&gt;set_direction(pb_lane_direction);

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(376, 0)" endLine="(455, 1)" clone_start="48" clone_end="56">
			<code function_name="NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs)">bool NovatelParser::handle_best_pos(const novatel::BestPos* pos,
                                    uint16_t gps_week, uint32_t gps_millisecs) {
  _gnss.mutable_position()-&gt;set_lon(pos-&gt;longitude);
  _gnss.mutable_position()-&gt;set_lat(pos-&gt;latitude);
  _gnss.mutable_position()-&gt;set_height(pos-&gt;height_msl + pos-&gt;undulation);
  _gnss.mutable_position_std_dev()-&gt;set_x(pos-&gt;longitude_std_dev);
  _gnss.mutable_position_std_dev()-&gt;set_y(pos-&gt;latitude_std_dev);
  _gnss.mutable_position_std_dev()-&gt;set_z(pos-&gt;height_std_dev);
  _gnss.set_num_sats(pos-&gt;num_sats_in_solution);
  if (_solution_status != pos-&gt;solution_status) {
    _solution_status = pos-&gt;solution_status;
    ROS_INFO_STREAM("Solution status: " &lt;&lt; static_cast&lt;int&gt;(_solution_status));
  }
  if (_position_type != pos-&gt;position_type) {
    _position_type = pos-&gt;position_type;
    ROS_INFO_STREAM("Position type: " &lt;&lt; static_cast&lt;int&gt;(_position_type));
  }
  _gnss.set_solution_status(static_cast&lt;uint32_t&gt;(pos-&gt;solution_status));
  if (pos-&gt;solution_status == novatel::SolutionStatus::SOL_COMPUTED) {
    _gnss.set_position_type(static_cast&lt;uint32_t&gt;(pos-&gt;position_type));
    switch (pos-&gt;position_type) {
      case novatel::SolutionType::SINGLE:
      case novatel::SolutionType::INS_PSRSP:
        _gnss.set_type(apollo::drivers::gnss::Gnss::SINGLE);
        break;
      case novatel::SolutionType::PSRDIFF:
      case novatel::SolutionType::WAAS:
      case novatel::SolutionType::INS_SBAS:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PSRDIFF);
        break;
      case novatel::SolutionType::FLOATCONV:
      case novatel::SolutionType::L1_FLOAT:
      case novatel::SolutionType::IONOFREE_FLOAT:
      case novatel::SolutionType::NARROW_FLOAT:
      case novatel::SolutionType::RTK_DIRECT_INS:
      case novatel::SolutionType::INS_RTKFLOAT:
        _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_FLOAT);
        break;
      case novatel::SolutionType::WIDELANE:
      case novatel::SolutionType::NARROWLANE:
      case novatel::SolutionType::L1_INT:
      case novatel::SolutionType::WIDE_INT:
      case novatel::SolutionType::NARROW_INT:
      case novatel::SolutionType::INS_RTKFIXED:
        _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_INTEGER);
        break;
      case novatel::SolutionType::OMNISTAR:
      case novatel::SolutionType::INS_OMNISTAR:
      case novatel::SolutionType::INS_OMNISTAR_HP:
      case novatel::SolutionType::INS_OMNISTAR_XP:
      case novatel::SolutionType::OMNISTAR_HP:
      case novatel::SolutionType::OMNISTAR_XP:
      case novatel::SolutionType::PPP_CONVERGING:
      case novatel::SolutionType::PPP:
      case novatel::SolutionType::INS_PPP_CONVERGING:
      case novatel::SolutionType::INS_PPP:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PPP);
        break;
      case novatel::SolutionType::PROPOGATED:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PROPAGATED);
        break;
      default:
        _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
    }
  } else {
    _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
    _gnss.set_position_type(0);
  }
  if (pos-&gt;datum_id != novatel::DatumId::WGS84) {
    ROS_ERROR_STREAM_THROTTLE(
        5, "Unexpected Datum Id: " &lt;&lt; static_cast&lt;int&gt;(pos-&gt;datum_id));
  }

  double seconds = gps_week * SECONDS_PER_WEEK + gps_millisecs * 1e-3;
  if (_gnss.measurement_time() != seconds) {
    _gnss.set_measurement_time(seconds);
    return false;
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(376, 0)" endLine="(455, 1)" clone_start="47" clone_end="55">
			<code function_name="NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs)">bool NovatelParser::handle_best_pos(const novatel::BestPos* pos,
                                    uint16_t gps_week, uint32_t gps_millisecs) {
  _gnss.mutable_position()-&gt;set_lon(pos-&gt;longitude);
  _gnss.mutable_position()-&gt;set_lat(pos-&gt;latitude);
  _gnss.mutable_position()-&gt;set_height(pos-&gt;height_msl + pos-&gt;undulation);
  _gnss.mutable_position_std_dev()-&gt;set_x(pos-&gt;longitude_std_dev);
  _gnss.mutable_position_std_dev()-&gt;set_y(pos-&gt;latitude_std_dev);
  _gnss.mutable_position_std_dev()-&gt;set_z(pos-&gt;height_std_dev);
  _gnss.set_num_sats(pos-&gt;num_sats_in_solution);
  if (_solution_status != pos-&gt;solution_status) {
    _solution_status = pos-&gt;solution_status;
    ROS_INFO_STREAM("Solution status: " &lt;&lt; static_cast&lt;int&gt;(_solution_status));
  }
  if (_position_type != pos-&gt;position_type) {
    _position_type = pos-&gt;position_type;
    ROS_INFO_STREAM("Position type: " &lt;&lt; static_cast&lt;int&gt;(_position_type));
  }
  _gnss.set_solution_status(static_cast&lt;uint32_t&gt;(pos-&gt;solution_status));
  if (pos-&gt;solution_status == novatel::SolutionStatus::SOL_COMPUTED) {
    _gnss.set_position_type(static_cast&lt;uint32_t&gt;(pos-&gt;position_type));
    switch (pos-&gt;position_type) {
      case novatel::SolutionType::SINGLE:
      case novatel::SolutionType::INS_PSRSP:
        _gnss.set_type(apollo::drivers::gnss::Gnss::SINGLE);
        break;
      case novatel::SolutionType::PSRDIFF:
      case novatel::SolutionType::WAAS:
      case novatel::SolutionType::INS_SBAS:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PSRDIFF);
        break;
      case novatel::SolutionType::FLOATCONV:
      case novatel::SolutionType::L1_FLOAT:
      case novatel::SolutionType::IONOFREE_FLOAT:
      case novatel::SolutionType::NARROW_FLOAT:
      case novatel::SolutionType::RTK_DIRECT_INS:
      case novatel::SolutionType::INS_RTKFLOAT:
        _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_FLOAT);
        break;
      case novatel::SolutionType::WIDELANE:
      case novatel::SolutionType::NARROWLANE:
      case novatel::SolutionType::L1_INT:
      case novatel::SolutionType::WIDE_INT:
      case novatel::SolutionType::NARROW_INT:
      case novatel::SolutionType::INS_RTKFIXED:
        _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_INTEGER);
        break;
      case novatel::SolutionType::OMNISTAR:
      case novatel::SolutionType::INS_OMNISTAR:
      case novatel::SolutionType::INS_OMNISTAR_HP:
      case novatel::SolutionType::INS_OMNISTAR_XP:
      case novatel::SolutionType::OMNISTAR_HP:
      case novatel::SolutionType::OMNISTAR_XP:
      case novatel::SolutionType::PPP_CONVERGING:
      case novatel::SolutionType::PPP:
      case novatel::SolutionType::INS_PPP_CONVERGING:
      case novatel::SolutionType::INS_PPP:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PPP);
        break;
      case novatel::SolutionType::PROPOGATED:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PROPAGATED);
        break;
      default:
        _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
    }
  } else {
    _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
    _gnss.set_position_type(0);
  }
  if (pos-&gt;datum_id != novatel::DatumId::WGS84) {
    ROS_ERROR_STREAM_THROTTLE(
        5, "Unexpected Datum Id: " &lt;&lt; static_cast&lt;int&gt;(pos-&gt;datum_id));
  }

  double seconds = gps_week * SECONDS_PER_WEEK + gps_millisecs * 1e-3;
  if (_gnss.measurement_time() != seconds) {
    _gnss.set_measurement_time(seconds);
    return false;
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\pnc_map.cc" startLine="(64, 0)" endLine="(77, 1)" clone_start="2" clone_end="13">
			<code function_name="RemoveDuplicates(std::vector&lt;MapPathPoint&gt; *points)">void RemoveDuplicates(std::vector&lt;MapPathPoint&gt; *points) {
  CHECK_NOTNULL(points);
  int count = 0;
  const double limit = kDuplicatedPointsEpsilon * kDuplicatedPointsEpsilon;
  for (size_t i = 0; i &lt; points-&gt;size(); ++i) {
    if (count == 0 ||
        (*points)[i].DistanceSquareTo((*points)[count - 1]) &gt; limit) {
      (*points)[count++] = (*points)[i];
    } else {
      (*points)[count - 1].add_lane_waypoints((*points)[i].lane_waypoints());
    }
  }
  points-&gt;resize(count);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\reference_line\reference_point.cc" startLine="(63, 0)" endLine="(76, 1)" clone_start="2" clone_end="13">
			<code function_name="ReferencePoint::RemoveDuplicates(std::vector&lt;ReferencePoint&gt;* points)">void ReferencePoint::RemoveDuplicates(std::vector&lt;ReferencePoint&gt;* points) {
  CHECK_NOTNULL(points);
  int count = 0;
  const double limit = kDuplicatedPointsEpsilon * kDuplicatedPointsEpsilon;
  for (size_t i = 0; i &lt; points-&gt;size(); ++i) {
    if (count == 0 ||
        (*points)[i].DistanceSquareTo((*points)[count - 1]) &gt; limit) {
      (*points)[count++] = (*points)[i];
    } else {
      (*points)[count - 1].add_lane_waypoints((*points)[i].lane_waypoints());
    }
  }
  points-&gt;resize(count);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\tirepressure_71.cc" startLine="(26, 0)" endLine="(36, 1)" clone_start="3" clone_end="11">
			<code function_name="Tirepressure71::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Tirepressure71::Parse(const std::uint8_t *bytes, int32_t length,
                           ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_safety()-&gt;set_front_left_tire_press(
      front_left_tire(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_front_right_tire_press(
      front_right_tire(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_rear_left_tire_press(
      rear_left_tire(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_rear_right_tire_press(
      rear_right_tire(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="76" clone_end="84">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length,
                        ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\tirepressure_71.cc" startLine="(38, 0)" endLine="(45, 1)" clone_start="1" clone_end="6">
			<code function_name="Tirepressure71::front_left_tire(const std::uint8_t *bytes, int32_t length) const">int32_t Tirepressure71::front_left_tire(const std::uint8_t *bytes,
                                        int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  return (high &lt;&lt; 8) | low;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(111, 0)" endLine="(119, 1)" clone_start="1" clone_end="6">
			<code function_name="Brakeinfo74::braking_torque_request(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::braking_torque_request(const std::uint8_t *bytes,
                                           int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 4);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 4.000000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(204, 0)" endLine="(215, 1)" clone_start="6" clone_end="12">
			<code function_name="Obstacle::SetTimestamp(const PerceptionObstacle&amp; perception_obstacle, const double timestamp, Feature* feature)">void Obstacle::SetTimestamp(const PerceptionObstacle&amp; perception_obstacle,
                            const double timestamp, Feature* feature) {
  double ts = timestamp;
  if (perception_obstacle.has_timestamp() &amp;&amp;
      perception_obstacle.timestamp() &gt; 0.0) {
    ts = perception_obstacle.timestamp();
  }
  feature-&gt;set_timestamp(ts);

  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has timestamp [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; ts &lt;&lt; "].";
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(326, 0)" endLine="(336, 1)" clone_start="5" clone_end="11">
			<code function_name="Obstacle::SetTheta(const PerceptionObstacle&amp; perception_obstacle, Feature* feature)">void Obstacle::SetTheta(const PerceptionObstacle&amp; perception_obstacle,
                        Feature* feature) {
  double theta = 0.0;
  if (perception_obstacle.has_theta()) {
    theta = perception_obstacle.theta();
  }
  feature-&gt;set_theta(theta);

  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has theta [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; theta &lt;&lt; "].";
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(217, 0)" endLine="(243, 1)" clone_start="1" clone_end="7">
			<code function_name="Obstacle::SetPosition(const PerceptionObstacle&amp; perception_obstacle, Feature* feature)">void Obstacle::SetPosition(const PerceptionObstacle&amp; perception_obstacle,
                           Feature* feature) {
  double x = 0.0;
  double y = 0.0;
  double z = 0.0;

  if (perception_obstacle.has_position()) {
    if (perception_obstacle.position().has_x()) {
      x = perception_obstacle.position().x();
    }
    if (perception_obstacle.position().has_y()) {
      y = perception_obstacle.position().y();
    }
    if (perception_obstacle.position().has_z()) {
      z = perception_obstacle.position().z();
    }
  }

  feature-&gt;mutable_position()-&gt;set_x(x);
  feature-&gt;mutable_position()-&gt;set_y(y);
  feature-&gt;mutable_position()-&gt;set_z(z);

  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has position [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; x &lt;&lt; ", " &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; y &lt;&lt; ", " &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; z &lt;&lt; "].";
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(338, 0)" endLine="(362, 1)" clone_start="1" clone_end="7">
			<code function_name="Obstacle::SetLengthWidthHeight( const PerceptionObstacle&amp; perception_obstacle, Feature* feature)">void Obstacle::SetLengthWidthHeight(
    const PerceptionObstacle&amp; perception_obstacle, Feature* feature) {
  double length = 0.0;
  double width = 0.0;
  double height = 0.0;

  if (perception_obstacle.has_length()) {
    length = perception_obstacle.length();
  }
  if (perception_obstacle.has_width()) {
    width = perception_obstacle.width();
  }
  if (perception_obstacle.has_height()) {
    height = perception_obstacle.height();
  }

  feature-&gt;set_length(length);
  feature-&gt;set_width(width);
  feature-&gt;set_height(height);

  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has dimension [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; length &lt;&lt; ", " &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; width &lt;&lt; ", " &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; height &lt;&lt; "].";
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\qp_spline_path\qp_spline_path_optimizer.cc" startLine="(32, 0)" endLine="(33, 47)" clone_start="1" clone_end="2">
			<code function_name="QpSplinePathOptimizer::QpSplinePathOptimizer()">QpSplinePathOptimizer::QpSplinePathOptimizer()
    : PathOptimizer("QpSplinePathOptimizer") {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\dp_poly_path\dp_poly_path_optimizer.cc" startLine="(36, 0)" endLine="(37, 45)" clone_start="1" clone_end="2">
			<code function_name="DpPolyPathOptimizer::DpPolyPathOptimizer()">DpPolyPathOptimizer::DpPolyPathOptimizer()
    : PathOptimizer("DpPolyPathOptimizer") {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\qp_spline_path\qp_spline_path_optimizer.cc" startLine="(35, 0)" endLine="(39, 1)" clone_start="1" clone_end="5">
			<code function_name="QpSplinePathOptimizer::Init(const PlanningConfig&amp; config)">bool QpSplinePathOptimizer::Init(const PlanningConfig&amp; config) {
  qp_spline_path_config_ = config.em_planner_config().qp_spline_path_config();
  is_init_ = true;
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\dp_poly_path\dp_poly_path_optimizer.cc" startLine="(39, 0)" endLine="(43, 1)" clone_start="1" clone_end="5">
			<code function_name="DpPolyPathOptimizer::Init(const PlanningConfig &amp;config)">bool DpPolyPathOptimizer::Init(const PlanningConfig &amp;config) {
  config_ = config.em_planner_config().dp_poly_path_config();
  is_init_ = true;
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\qp_spline_path\qp_spline_path_optimizer.cc" startLine="(41, 0)" endLine="(61, 1)" clone_start="1" clone_end="7">
			<code function_name="QpSplinePathOptimizer::Process(const SpeedData&amp; speed_data,const ReferenceLine&amp; reference_line, const common::TrajectoryPoint&amp; init_point, PathData* const path_data)">Status QpSplinePathOptimizer::Process(const SpeedData&amp; speed_data,
                                      const ReferenceLine&amp; reference_line,
                                      const common::TrajectoryPoint&amp; init_point,
                                      PathData* const path_data) {
  if (!is_init_) {
    AERROR &lt;&lt; "Please call Init() before Process.";
    return Status(ErrorCode::PLANNING_ERROR, "Not init.");
  }
  QpSplinePathGenerator path_generator(reference_line, qp_spline_path_config_);
  path_generator.SetDebugLogger(frame_-&gt;DebugLogger());

  if (!path_generator.Generate(
          reference_line_info_-&gt;path_decision()-&gt;path_obstacles().Items(),
          speed_data, init_point, path_data)) {
    const std::string msg = "failed to generate spline path!";
    AERROR &lt;&lt; msg;
    return Status(ErrorCode::PLANNING_ERROR, msg);
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\dp_poly_path\dp_poly_path_optimizer.cc" startLine="(45, 0)" endLine="(64, 1)" clone_start="1" clone_end="7">
			<code function_name="DpPolyPathOptimizer::Process(const SpeedData &amp;speed_data,const ReferenceLine &amp;reference_line, const common::TrajectoryPoint &amp;init_point, PathData *const path_data)">Status DpPolyPathOptimizer::Process(const SpeedData &amp;speed_data,
                                    const ReferenceLine &amp;reference_line,
                                    const common::TrajectoryPoint &amp;init_point,
                                    PathData *const path_data) {
  if (!is_init_) {
    AERROR &lt;&lt; "Please call Init() before Process().";
    return Status(ErrorCode::PLANNING_ERROR, "Not inited.");
  }
  CHECK_NOTNULL(path_data);
  DPRoadGraph dp_road_graph(config_, reference_line, speed_data);
  if (!dp_road_graph.FindPathTunnel(
          init_point,
          reference_line_info_-&gt;path_decision()-&gt;path_obstacles().Items(),
          path_data)) {
    AERROR &lt;&lt; "Failed to find tunnel in road graph";
    return Status(ErrorCode::PLANNING_ERROR, "dp_road_graph path generation");
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\glfw_viewer.cc" startLine="(274, 0)" endLine="(304, 1)" clone_start="5" clone_end="14">
			<code function_name="GLFWViewer::PreDraw()">void GLFWViewer::PreDraw() {
  Eigen::Matrix4d e_proj_mat = pers_camera_-&gt;GetProjectionMat();

  // column major
  GLdouble proj_mat[16] = {
      e_proj_mat(0, 0), e_proj_mat(1, 0), e_proj_mat(2, 0), e_proj_mat(3, 0),
      e_proj_mat(0, 1), e_proj_mat(1, 1), e_proj_mat(2, 1), e_proj_mat(3, 1),
      e_proj_mat(0, 2), e_proj_mat(1, 2), e_proj_mat(2, 2), e_proj_mat(3, 2),
      e_proj_mat(0, 3), e_proj_mat(1, 3), e_proj_mat(2, 3), e_proj_mat(3, 3)};
  GLdouble mode_mat[16] = {
      mode_mat_(0, 0), mode_mat_(1, 0), mode_mat_(2, 0), mode_mat_(3, 0),
      mode_mat_(0, 1), mode_mat_(1, 1), mode_mat_(2, 1), mode_mat_(3, 1),
      mode_mat_(0, 2), mode_mat_(1, 2), mode_mat_(2, 2), mode_mat_(3, 2),
      mode_mat_(0, 3), mode_mat_(1, 3), mode_mat_(2, 3), mode_mat_(3, 3)};
  GLdouble view_mat[16] = {
      view_mat_(0, 0), view_mat_(1, 0), view_mat_(2, 0), view_mat_(3, 0),
      view_mat_(0, 1), view_mat_(1, 1), view_mat_(2, 1), view_mat_(3, 1),
      view_mat_(0, 2), view_mat_(1, 2), view_mat_(2, 2), view_mat_(3, 2),
      view_mat_(0, 3), view_mat_(1, 3), view_mat_(2, 3), view_mat_(3, 3)};

  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glMultMatrixd(proj_mat);
  glMatrixMode(GL_MODELVIEW);
  glLoadMatrixd(mode_mat);
  glMultMatrixd(view_mat);

  GLfloat light_position[] = {1.0, -1.0, 1.0, 0.0};
  glLightfv(GL_LIGHT0, GL_POSITION, light_position);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\glfw_viewer.cc" startLine="(274, 0)" endLine="(304, 1)" clone_start="10" clone_end="19">
			<code function_name="GLFWViewer::PreDraw()">void GLFWViewer::PreDraw() {
  Eigen::Matrix4d e_proj_mat = pers_camera_-&gt;GetProjectionMat();

  // column major
  GLdouble proj_mat[16] = {
      e_proj_mat(0, 0), e_proj_mat(1, 0), e_proj_mat(2, 0), e_proj_mat(3, 0),
      e_proj_mat(0, 1), e_proj_mat(1, 1), e_proj_mat(2, 1), e_proj_mat(3, 1),
      e_proj_mat(0, 2), e_proj_mat(1, 2), e_proj_mat(2, 2), e_proj_mat(3, 2),
      e_proj_mat(0, 3), e_proj_mat(1, 3), e_proj_mat(2, 3), e_proj_mat(3, 3)};
  GLdouble mode_mat[16] = {
      mode_mat_(0, 0), mode_mat_(1, 0), mode_mat_(2, 0), mode_mat_(3, 0),
      mode_mat_(0, 1), mode_mat_(1, 1), mode_mat_(2, 1), mode_mat_(3, 1),
      mode_mat_(0, 2), mode_mat_(1, 2), mode_mat_(2, 2), mode_mat_(3, 2),
      mode_mat_(0, 3), mode_mat_(1, 3), mode_mat_(2, 3), mode_mat_(3, 3)};
  GLdouble view_mat[16] = {
      view_mat_(0, 0), view_mat_(1, 0), view_mat_(2, 0), view_mat_(3, 0),
      view_mat_(0, 1), view_mat_(1, 1), view_mat_(2, 1), view_mat_(3, 1),
      view_mat_(0, 2), view_mat_(1, 2), view_mat_(2, 2), view_mat_(3, 2),
      view_mat_(0, 3), view_mat_(1, 3), view_mat_(2, 3), view_mat_(3, 3)};

  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glMultMatrixd(proj_mat);
  glMatrixMode(GL_MODELVIEW);
  glLoadMatrixd(mode_mat);
  glMultMatrixd(view_mat);

  GLfloat light_position[] = {1.0, -1.0, 1.0, 0.0};
  glLightfv(GL_LIGHT0, GL_POSITION, light_position);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\camera.cc" startLine="(93, 0)" endLine="(120, 1)" clone_start="12" clone_end="22">
			<code function_name="Camera::PointOnScreen(Eigen::Vector3d point)">Eigen::Vector3d Camera::PointOnScreen(Eigen::Vector3d point) {
  GLdouble x = 0.0;
  GLdouble y = 0.0;
  GLdouble z = 0.0;
  static GLint viewport[4];
  viewport[0] = 0;
  viewport[1] = screen_height_;
  viewport[2] = screen_width_;
  viewport[3] =
      -screen_height_;  // origin of opengl frame is at left-bottom corner

  GLdouble view_mat[16] = {
      view_mat_(0, 0), view_mat_(1, 0), view_mat_(2, 0), view_mat_(3, 0),
      view_mat_(0, 1), view_mat_(1, 1), view_mat_(2, 1), view_mat_(3, 1),
      view_mat_(0, 2), view_mat_(1, 2), view_mat_(2, 2), view_mat_(3, 2),
      view_mat_(0, 3), view_mat_(1, 3), view_mat_(2, 3), view_mat_(3, 3)};

  GLdouble proj_mat[16] = {
      proj_mat_(0, 0), proj_mat_(1, 0), proj_mat_(2, 0), proj_mat_(3, 0),
      proj_mat_(0, 1), proj_mat_(1, 1), proj_mat_(2, 1), proj_mat_(3, 1),
      proj_mat_(0, 2), proj_mat_(1, 2), proj_mat_(2, 2), proj_mat_(3, 2),
      proj_mat_(0, 3), proj_mat_(1, 3), proj_mat_(2, 3), proj_mat_(3, 3)};
  // here the view_mat should be view_mode_mat acutally
  gluProject(point(0), point(1), point(2), view_mat, proj_mat, viewport, &amp;x, &amp;y,
             &amp;z);

  return Eigen::Vector3d(x, y, z);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\turnsignal_68.cc" startLine="(39, 0)" endLine="(42, 1)" clone_start="1" clone_end="4">
			<code function_name="Turnsignal68::set_turn_none()">Turnsignal68 *Turnsignal68::set_turn_none() {
  turn_cmd_ = 0x00;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(40, 0)" endLine="(43, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_none()">Gear66 *Gear66::set_gear_none() {
  gear_ = 0x00;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\turnsignal_68.cc" startLine="(44, 0)" endLine="(47, 1)" clone_start="1" clone_end="4">
			<code function_name="Turnsignal68::set_turn_left()">Turnsignal68 *Turnsignal68::set_turn_left() {
  turn_cmd_ = 0x01;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(45, 0)" endLine="(48, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_park()">Gear66 *Gear66::set_gear_park() {
  gear_ = 0x01;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\turnsignal_68.cc" startLine="(49, 0)" endLine="(52, 1)" clone_start="1" clone_end="3">
			<code function_name="Turnsignal68::set_turn_right()">Turnsignal68 *Turnsignal68::set_turn_right() {
  turn_cmd_ = 0x02;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(50, 0)" endLine="(53, 1)" clone_start="1" clone_end="3">
			<code function_name="Gear66::set_gear_reverse()">Gear66 *Gear66::set_gear_reverse() {
  gear_ = 0x02;
  return this;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(28, 0)" endLine="(31, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle62::GetPeriod() const">uint32_t Throttle62::GetPeriod() const {
  static const uint32_t PERIOD = 20 * 1000;
  return PERIOD;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(26, 0)" endLine="(31, 1)" clone_start="1" clone_end="6">
			<code function_name="Steering64::GetPeriod() const">uint32_t Steering64::GetPeriod() const {
  // receive rate??
  // receive timeout would trigger fault, letting en=0 and etc.
  static const uint32_t PERIOD = 20 * 1000;
  return PERIOD;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(27, 0)" endLine="(30, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake60::GetPeriod() const">uint32_t Brake60::GetPeriod() const {
  static const uint32_t PERIOD = 20 * 1000;
  return PERIOD;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(33, 0)" endLine="(39, 1)" clone_start="1" clone_end="6">
			<code function_name="Throttle62::UpdateData(uint8_t *data)">void Throttle62::UpdateData(uint8_t *data) {
  set_pedal_p(data, pedal_cmd_);
  set_enable_p(data, pedal_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_ignore_driver_override_p(data, ignore_driver_override_);
  set_watchdog_counter_p(data, watchdog_counter_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(33, 0)" endLine="(41, 1)" clone_start="1" clone_end="6">
			<code function_name="Steering64::UpdateData(uint8_t *data)">void Steering64::UpdateData(uint8_t *data) {
  set_steering_angle_p(data, steering_angle_);
  set_enable_p(data, steering_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_ignore_driver_override_p(data, ignore_driver_override_);
  set_steering_angle_speed_p(data, steering_angle_speed_);
  set_watchdog_counter_p(data, watchdog_counter_);
  set_disable_audible_warning_p(data, disable_audible_warning_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(32, 0)" endLine="(38, 1)" clone_start="1" clone_end="6">
			<code function_name="Brake60::UpdateData(uint8_t *data)">void Brake60::UpdateData(uint8_t *data) {
  set_pedal_p(data, pedal_cmd_);
  set_boo_cmd_p(data, boo_cmd_);
  set_enable_p(data, pedal_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_watchdog_counter_p(data, watchdog_counter_);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="129" clone_end="149">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="64" clone_end="82">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length,
                        ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(587, 0)" endLine="(608, 1)" clone_start="12" clone_end="21">
			<code function_name="HDMapImpl::Clear()">void HDMapImpl::Clear() {
  map_.Clear();
  lane_table_.clear();
  junction_table_.clear();
  signal_table_.clear();
  crosswalk_table_.clear();
  stop_sign_table_.clear();
  yield_sign_table_.clear();
  overlap_table_.clear();
  lane_segment_boxes_.clear();
  lane_segment_kdtree_.reset(nullptr);
  junction_polygon_boxes_.clear();
  junction_polygon_kdtree_.reset(nullptr);
  crosswalk_polygon_boxes_.clear();
  crosswalk_polygon_kdtree_.reset(nullptr);
  signal_segment_boxes_.clear();
  signal_segment_kdtree_.reset(nullptr);
  stop_sign_segment_boxes_.clear();
  stop_sign_segment_kdtree_.reset(nullptr);
  yield_sign_segment_boxes_.clear();
  yield_sign_segment_kdtree_.reset(nullptr);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(587, 0)" endLine="(608, 1)" clone_start="10" clone_end="19">
			<code function_name="HDMapImpl::Clear()">void HDMapImpl::Clear() {
  map_.Clear();
  lane_table_.clear();
  junction_table_.clear();
  signal_table_.clear();
  crosswalk_table_.clear();
  stop_sign_table_.clear();
  yield_sign_table_.clear();
  overlap_table_.clear();
  lane_segment_boxes_.clear();
  lane_segment_kdtree_.reset(nullptr);
  junction_polygon_boxes_.clear();
  junction_polygon_kdtree_.reset(nullptr);
  crosswalk_polygon_boxes_.clear();
  crosswalk_polygon_kdtree_.reset(nullptr);
  signal_segment_boxes_.clear();
  signal_segment_kdtree_.reset(nullptr);
  stop_sign_segment_boxes_.clear();
  stop_sign_segment_kdtree_.reset(nullptr);
  yield_sign_segment_boxes_.clear();
  yield_sign_segment_kdtree_.reset(nullptr);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(121, 0)" endLine="(127, 1)" clone_start="1" clone_end="7">
			<code function_name="Brakeinfo74::hill_start_assist_status(const std::uint8_t *bytes, int32_t length) const">int32_t Brakeinfo74::hill_start_assist_status(const std::uint8_t *bytes,
                                              int32_t length) const {
  // see table for status code
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(4, 3);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(92, 0)" endLine="(96, 1)" clone_start="1" clone_end="5">
			<code function_name="Gear67::gear_state(const std::uint8_t *bytes, int32_t length) const">int32_t Gear67::gear_state(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(129, 0)" endLine="(134, 1)" clone_start="1" clone_end="6">
			<code function_name="Brakeinfo74::is_vehicle_stationary(const std::uint8_t *bytes, int32_t length) const">bool Brakeinfo74::is_vehicle_stationary(const std::uint8_t *bytes,
                                        int32_t length) const {
  // false for moving, true for stationary
  Byte frame(bytes + 1);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(98, 0)" endLine="(102, 1)" clone_start="1" clone_end="5">
			<code function_name="Gear67::is_driver_override(const std::uint8_t *bytes, int32_t length) const">bool Gear67::is_driver_override(const std::uint8_t *bytes,
                                int32_t length) const {
  Byte frame(bytes + 0);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(136, 0)" endLine="(144, 1)" clone_start="1" clone_end="4">
			<code function_name="Brakeinfo74::braking_torque_actual(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::braking_torque_actual(const std::uint8_t *bytes,
                                          int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 4);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 4.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(104, 0)" endLine="(109, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear67::reported_gear_cmd(const std::uint8_t *bytes, int32_t length) const">int32_t Gear67::reported_gear_cmd(const std::uint8_t *bytes,
                                  int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(4, 3);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\pcd_exporter_nodelet.cpp" startLine="(28, 2)" endLine="(28, 25)" clone_start="1" clone_end="1">
			<code function_name="PCDExporterNodelet()">  PCDExporterNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\compensator_nodelet.cpp" startLine="(28, 2)" endLine="(28, 25)" clone_start="1" clone_end="1">
			<code function_name="CompensatorNodelet()">  CompensatorNodelet() {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\pcd_exporter_nodelet.cpp" startLine="(29, 2)" endLine="(29, 26)" clone_start="1" clone_end="1">
			<code function_name="~PCDExporterNodelet()">  ~PCDExporterNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\compensator_nodelet.cpp" startLine="(29, 2)" endLine="(29, 26)" clone_start="1" clone_end="1">
			<code function_name="~CompensatorNodelet()">  ~CompensatorNodelet() {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\pcd_exporter_nodelet.cpp" startLine="(37, 0)" endLine="(41, 1)" clone_start="1" clone_end="3">
			<code function_name="PCDExporterNodelet::onInit()">void PCDExporterNodelet::onInit() {
  ROS_INFO("Pcd exporter nodelet init");
  _instance.reset(new PCDExporter(getNodeHandle(), getPrivateNodeHandle()));
  _instance-&gt;init();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\compensator_nodelet.cpp" startLine="(37, 0)" endLine="(40, 1)" clone_start="1" clone_end="3">
			<code function_name="CompensatorNodelet::onInit()">void CompensatorNodelet::onInit() {
  ROS_INFO("Compensator nodelet init");
  _compensator.reset(new Compensator(getNodeHandle(), getPrivateNodeHandle()));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\data_parser.cpp" startLine="(235, 0)" endLine="(277, 1)" clone_start="42" clone_end="43">
			<code function_name="DataParser::publish_odometry_pb_message(const MessagePtr message)">void DataParser::publish_odometry_pb_message(const MessagePtr message) {
  ::apollo::drivers::gnss::Ins *ins = As&lt;::apollo::drivers::gnss::Ins&gt;(message);
  boost::shared_ptr&lt;::apollo::localization::Gps&gt; gps(
      new ::apollo::localization::Gps());
  if (!gps) {
    ROS_ERROR("New gps failed.");
    return;
  }

  double unix_sec = apollo::drivers::util::gps2unix(ins-&gt;measurement_time());
  gps-&gt;mutable_header()-&gt;set_timestamp_sec(unix_sec);
  auto *gps_msg = gps-&gt;mutable_localization();

  // 1. pose xyz
  double x = ins-&gt;position().lon();
  double y = ins-&gt;position().lat();
  x *= DEG_TO_RAD_LOCAL;
  y *= DEG_TO_RAD_LOCAL;

  pj_transform(_wgs84pj_source, _utm_target, 1, 1, &amp;x, &amp;y, NULL);

  gps_msg-&gt;mutable_position()-&gt;set_x(x);
  gps_msg-&gt;mutable_position()-&gt;set_y(y);
  gps_msg-&gt;mutable_position()-&gt;set_z(ins-&gt;position().height());

  // 2. orientation
  Eigen::Quaterniond q =
      Eigen::AngleAxisd(ins-&gt;euler_angles().z() - 90 * DEG_TO_RAD_LOCAL,
                        Eigen::Vector3d::UnitZ()) *
      Eigen::AngleAxisd(-ins-&gt;euler_angles().y(), Eigen::Vector3d::UnitX()) *
      Eigen::AngleAxisd(ins-&gt;euler_angles().x(), Eigen::Vector3d::UnitY());

  gps_msg-&gt;mutable_orientation()-&gt;set_qx(q.x());
  gps_msg-&gt;mutable_orientation()-&gt;set_qy(q.y());
  gps_msg-&gt;mutable_orientation()-&gt;set_qz(q.z());
  gps_msg-&gt;mutable_orientation()-&gt;set_qw(q.w());

  gps_msg-&gt;mutable_linear_velocity()-&gt;set_x(ins-&gt;linear_velocity().x());
  gps_msg-&gt;mutable_linear_velocity()-&gt;set_y(ins-&gt;linear_velocity().y());
  gps_msg-&gt;mutable_linear_velocity()-&gt;set_z(ins-&gt;linear_velocity().z());

  _nav_odometry_publisher.publish(gps);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\data_parser.cpp" startLine="(229, 0)" endLine="(233, 1)" clone_start="4" clone_end="5">
			<code function_name="DataParser::publish_ins_message(const MessagePtr message)">void DataParser::publish_ins_message(const MessagePtr message) {
    boost::shared_ptr&lt;::apollo::drivers::gnss::Ins&gt; ins(
        new ::apollo::drivers::gnss::Ins(*As&lt;::apollo::drivers::gnss::Ins&gt;(message)));
    _ins_publisher.publish(ins);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\data_parser.cpp" startLine="(279, 0)" endLine="(305, 1)" clone_start="1" clone_end="12">
			<code function_name="DataParser::publish_corrimu_pb_message(const MessagePtr message)">void DataParser::publish_corrimu_pb_message(const MessagePtr message) {
  ::apollo::drivers::gnss::Ins *ins = As&lt;::apollo::drivers::gnss::Ins&gt;(message);
  boost::shared_ptr&lt;::apollo::localization::Imu&gt; imu(
      new ::apollo::localization::Imu());
  if (!imu) {
    ROS_ERROR("New imu failed.");
    return;
  }
  double unix_sec = apollo::drivers::util::gps2unix(ins-&gt;measurement_time());
  imu-&gt;mutable_header()-&gt;set_timestamp_sec(unix_sec);

  auto *imu_msg = imu-&gt;mutable_imu();
  imu_msg-&gt;mutable_linear_acceleration()-&gt;set_x(
      -ins-&gt;linear_acceleration().y());
  imu_msg-&gt;mutable_linear_acceleration()-&gt;set_y(ins-&gt;linear_acceleration().x());
  imu_msg-&gt;mutable_linear_acceleration()-&gt;set_z(ins-&gt;linear_acceleration().z());

  imu_msg-&gt;mutable_angular_velocity()-&gt;set_x(-ins-&gt;angular_velocity().y());
  imu_msg-&gt;mutable_angular_velocity()-&gt;set_y(ins-&gt;angular_velocity().x());
  imu_msg-&gt;mutable_angular_velocity()-&gt;set_z(ins-&gt;angular_velocity().z());

  imu_msg-&gt;mutable_euler_angles()-&gt;set_x(ins-&gt;euler_angles().x());
  imu_msg-&gt;mutable_euler_angles()-&gt;set_y(ins-&gt;euler_angles().y());
  imu_msg-&gt;mutable_euler_angles()-&gt;set_z(ins-&gt;euler_angles().z());

  _imu_publisher.publish(imu);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\data_parser.cpp" startLine="(235, 0)" endLine="(277, 1)" clone_start="1" clone_end="12">
			<code function_name="DataParser::publish_odometry_pb_message(const MessagePtr message)">void DataParser::publish_odometry_pb_message(const MessagePtr message) {
  ::apollo::drivers::gnss::Ins *ins = As&lt;::apollo::drivers::gnss::Ins&gt;(message);
  boost::shared_ptr&lt;::apollo::localization::Gps&gt; gps(
      new ::apollo::localization::Gps());
  if (!gps) {
    ROS_ERROR("New gps failed.");
    return;
  }

  double unix_sec = apollo::drivers::util::gps2unix(ins-&gt;measurement_time());
  gps-&gt;mutable_header()-&gt;set_timestamp_sec(unix_sec);
  auto *gps_msg = gps-&gt;mutable_localization();

  // 1. pose xyz
  double x = ins-&gt;position().lon();
  double y = ins-&gt;position().lat();
  x *= DEG_TO_RAD_LOCAL;
  y *= DEG_TO_RAD_LOCAL;

  pj_transform(_wgs84pj_source, _utm_target, 1, 1, &amp;x, &amp;y, NULL);

  gps_msg-&gt;mutable_position()-&gt;set_x(x);
  gps_msg-&gt;mutable_position()-&gt;set_y(y);
  gps_msg-&gt;mutable_position()-&gt;set_z(ins-&gt;position().height());

  // 2. orientation
  Eigen::Quaterniond q =
      Eigen::AngleAxisd(ins-&gt;euler_angles().z() - 90 * DEG_TO_RAD_LOCAL,
                        Eigen::Vector3d::UnitZ()) *
      Eigen::AngleAxisd(-ins-&gt;euler_angles().y(), Eigen::Vector3d::UnitX()) *
      Eigen::AngleAxisd(ins-&gt;euler_angles().x(), Eigen::Vector3d::UnitY());

  gps_msg-&gt;mutable_orientation()-&gt;set_qx(q.x());
  gps_msg-&gt;mutable_orientation()-&gt;set_qy(q.y());
  gps_msg-&gt;mutable_orientation()-&gt;set_qz(q.z());
  gps_msg-&gt;mutable_orientation()-&gt;set_qw(q.w());

  gps_msg-&gt;mutable_linear_velocity()-&gt;set_x(ins-&gt;linear_velocity().x());
  gps_msg-&gt;mutable_linear_velocity()-&gt;set_y(ins-&gt;linear_velocity().y());
  gps_msg-&gt;mutable_linear_velocity()-&gt;set_z(ins-&gt;linear_velocity().z());

  _nav_odometry_publisher.publish(gps);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(26, 0)" endLine="(50, 1)" clone_start="5" clone_end="23">
			<code function_name="Throttle63::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Throttle63::Parse(const std::uint8_t *bytes, int32_t length,
                       ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_gas()-&gt;set_throttle_input(pedal_input(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_throttle_cmd(pedal_cmd(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_throttle_output(
      pedal_output(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_throttle_enabled(
      is_enabled(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  chassis_detail-&gt;mutable_check_response()-&gt;set_is_vcu_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(29, 0)" endLine="(59, 1)" clone_start="12" clone_end="29">
			<code function_name="Brake61::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brake61::Parse(const std::uint8_t *bytes, int32_t length,
                    ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_output(
      pedal_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  chassis_detail-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(26, 0)" endLine="(65, 1)" clone_start="21" clone_end="38">
			<code function_name="Steering65::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Steering65::Parse(const std::uint8_t *bytes, int32_t length,
                       ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_eps()-&gt;set_steering_angle(
      steering_angle(bytes, length));
  // no steering angle speed

  chassis_detail-&gt;mutable_eps()-&gt;set_steering_angle_cmd(
      reported_steering_angle_cmd(bytes, length));
  // ?
  chassis_detail-&gt;mutable_eps()-&gt;set_is_steering_angle_valid(true);
  // vehicle speed from steering, kph -&gt; mps
  chassis_detail-&gt;mutable_eps()-&gt;set_vehicle_speed(
      vehicle_speed(bytes, length) / 3.6);

  // speed, as it has a higher accuracy
  // kph -&gt; mps
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_vehicle_spd(
      vehicle_speed(bytes, length) / 3.6);
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_spd_valid(true);

  chassis_detail-&gt;mutable_eps()-&gt;set_epas_torque(epas_torque(bytes, length));
  chassis_detail-&gt;mutable_eps()-&gt;set_steering_enabled(
      is_enabled(bytes, length));
  chassis_detail-&gt;mutable_eps()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  chassis_detail-&gt;mutable_eps()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  chassis_detail-&gt;mutable_eps()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  chassis_detail-&gt;mutable_eps()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  chassis_detail-&gt;mutable_eps()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  chassis_detail-&gt;mutable_eps()-&gt;set_calibration_fault(
      is_calibration_fault(bytes, length));
  chassis_detail-&gt;mutable_eps()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  chassis_detail-&gt;mutable_check_response()-&gt;set_is_eps_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(76, 0)" endLine="(78, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline2dSeg::derivative_y(const double t) const">double Spline2dSeg::derivative_y(const double t) const {
  return derivative_y_(t);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(72, 0)" endLine="(74, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline2dSeg::DerivativeX(const double t) const">double Spline2dSeg::DerivativeX(const double t) const {
  return derivative_x_(t);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(80, 0)" endLine="(82, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline2dSeg::SecondDerivativeX(const double t) const">double Spline2dSeg::SecondDerivativeX(const double t) const {
  return second_derivative_x_(t);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(76, 0)" endLine="(78, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline2dSeg::derivative_y(const double t) const">double Spline2dSeg::derivative_y(const double t) const {
  return derivative_y_(t);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(84, 0)" endLine="(86, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline2dSeg::second_derivative_y(const double t) const">double Spline2dSeg::second_derivative_y(const double t) const {
  return second_derivative_y_(t);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(80, 0)" endLine="(82, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline2dSeg::SecondDerivativeX(const double t) const">double Spline2dSeg::SecondDerivativeX(const double t) const {
  return second_derivative_x_(t);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(88, 0)" endLine="(90, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline2dSeg::ThirdDerivativeX(const double t) const">double Spline2dSeg::ThirdDerivativeX(const double t) const {
  return third_derivative_x_(t);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(84, 0)" endLine="(86, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline2dSeg::second_derivative_y(const double t) const">double Spline2dSeg::second_derivative_y(const double t) const {
  return second_derivative_y_(t);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(92, 0)" endLine="(94, 1)" clone_start="1" clone_end="2">
			<code function_name="Spline2dSeg::third_derivative_y(const double t) const">double Spline2dSeg::third_derivative_y(const double t) const {
  return third_derivative_y_(t);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_seg.cc" startLine="(88, 0)" endLine="(90, 1)" clone_start="1" clone_end="2">
			<code function_name="Spline2dSeg::ThirdDerivativeX(const double t) const">double Spline2dSeg::ThirdDerivativeX(const double t) const {
  return third_derivative_x_(t);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.cc" startLine="(387, 0)" endLine="(431, 1)" clone_start="18" clone_end="31">
			<code function_name="LaneInfo::UpdateOverlaps(const HDMapImpl &amp;map_instance)">void LaneInfo::UpdateOverlaps(const HDMapImpl &amp;map_instance) {
  for (const auto &amp;overlap_id : overlap_ids_) {
    const auto &amp;overlap_ptr =
        map_instance.GetOverlapById(MakeMapId(overlap_id));
    if (overlap_ptr == nullptr) {
      continue;
    }
    overlaps_.emplace_back(overlap_ptr);
    for (const auto &amp;object : overlap_ptr-&gt;overlap().object()) {
      const auto &amp;object_id = object.id().id();
      if (object_id == lane_.id().id()) {
        continue;
      }
      const auto &amp;object_map_id = MakeMapId(object_id);
      if (map_instance.GetLaneById(object_map_id) != nullptr) {
        cross_lanes_.emplace_back(overlap_ptr);
      }
      if (map_instance.GetSignalById(object_map_id) != nullptr) {
        signals_.emplace_back(overlap_ptr);
      }
      if (map_instance.GetYieldSignById(object_map_id) != nullptr) {
        yield_signs_.emplace_back(overlap_ptr);
      }
      if (map_instance.GetStopSignById(object_map_id) != nullptr) {
        stop_signs_.emplace_back(overlap_ptr);
      }
      if (map_instance.GetCrosswalkById(object_map_id) != nullptr) {
        crosswalks_.emplace_back(overlap_ptr);
      }
      if (map_instance.GetJunctionById(object_map_id) != nullptr) {
        junctions_.emplace_back(overlap_ptr);
      }

      // TODO(all): support parking and speed bump
      /*
      if (map_instance.get_parking_space_by_id(object_map_id) != nullptr) {
        parking_spaces_.emplace_back(overlap_ptr);
      }
      if (map_instance.get_speed_bump_by_id(object_map_id) != nullptr) {
        speed_bumps_.emplace_back(overlap_ptr);
      }
      */
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.cc" startLine="(387, 0)" endLine="(431, 1)" clone_start="15" clone_end="28">
			<code function_name="LaneInfo::UpdateOverlaps(const HDMapImpl &amp;map_instance)">void LaneInfo::UpdateOverlaps(const HDMapImpl &amp;map_instance) {
  for (const auto &amp;overlap_id : overlap_ids_) {
    const auto &amp;overlap_ptr =
        map_instance.GetOverlapById(MakeMapId(overlap_id));
    if (overlap_ptr == nullptr) {
      continue;
    }
    overlaps_.emplace_back(overlap_ptr);
    for (const auto &amp;object : overlap_ptr-&gt;overlap().object()) {
      const auto &amp;object_id = object.id().id();
      if (object_id == lane_.id().id()) {
        continue;
      }
      const auto &amp;object_map_id = MakeMapId(object_id);
      if (map_instance.GetLaneById(object_map_id) != nullptr) {
        cross_lanes_.emplace_back(overlap_ptr);
      }
      if (map_instance.GetSignalById(object_map_id) != nullptr) {
        signals_.emplace_back(overlap_ptr);
      }
      if (map_instance.GetYieldSignById(object_map_id) != nullptr) {
        yield_signs_.emplace_back(overlap_ptr);
      }
      if (map_instance.GetStopSignById(object_map_id) != nullptr) {
        stop_signs_.emplace_back(overlap_ptr);
      }
      if (map_instance.GetCrosswalkById(object_map_id) != nullptr) {
        crosswalks_.emplace_back(overlap_ptr);
      }
      if (map_instance.GetJunctionById(object_map_id) != nullptr) {
        junctions_.emplace_back(overlap_ptr);
      }

      // TODO(all): support parking and speed bump
      /*
      if (map_instance.get_parking_space_by_id(object_map_id) != nullptr) {
        parking_spaces_.emplace_back(overlap_ptr);
      }
      if (map_instance.get_speed_bump_by_id(object_map_id) != nullptr) {
        speed_bumps_.emplace_back(overlap_ptr);
      }
      */
    }
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(154, 0)" endLine="(160, 1)" clone_start="1" clone_end="7">
			<code function_name="Brakeinfo74::parking_brake_status(const std::uint8_t *bytes, int32_t length) const">int32_t Brakeinfo74::parking_brake_status(const std::uint8_t *bytes,
                                          int32_t length) const {
  // see table for status code
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(6, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\version_7f.cc" startLine="(58, 0)" endLine="(63, 1)" clone_start="1" clone_end="6">
			<code function_name="Version7f::module_name(const std::uint8_t *bytes, int32_t length) const">int32_t Version7f::module_name(const std::uint8_t *bytes,
                               int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 8);
  return x;  // 0x03 means Steering/Shifter, otherwise ignore
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(162, 0)" endLine="(173, 1)" clone_start="1" clone_end="7">
			<code function_name="Brakeinfo74::wheel_torque_actual(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::wheel_torque_actual(const std::uint8_t *bytes,
                                        int32_t length) const {
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 6);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FFF) {
    value -= 0x4000;
  }
  return value * 4.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\version_7f.cc" startLine="(65, 0)" endLine="(73, 1)" clone_start="1" clone_end="7">
			<code function_name="Version7f::major_version(const std::uint8_t *bytes, int32_t length) const">int32_t Version7f::major_version(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\version_7f.cc" startLine="(26, 0)" endLine="(56, 1)" clone_start="4" clone_end="19">
			<code function_name="Version7f::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Version7f::Parse(const std::uint8_t *bytes, int32_t length,
                      ChassisDetail *chassis_detail) const {
  switch (module_name(bytes, length)) {
    case 0x01:
      chassis_detail-&gt;mutable_brake()-&gt;set_major_version(
          major_version(bytes, length));
      chassis_detail-&gt;mutable_brake()-&gt;set_minor_version(
          minor_version(bytes, length));
      chassis_detail-&gt;mutable_brake()-&gt;set_build_number(
          build_number(bytes, length));
      break;
    case 0x02:
      chassis_detail-&gt;mutable_gas()-&gt;set_major_version(
          major_version(bytes, length));
      chassis_detail-&gt;mutable_gas()-&gt;set_minor_version(
          minor_version(bytes, length));
      chassis_detail-&gt;mutable_gas()-&gt;set_build_number(
          build_number(bytes, length));
      break;
    case 0x03:
      chassis_detail-&gt;mutable_eps()-&gt;set_major_version(
          major_version(bytes, length));
      chassis_detail-&gt;mutable_eps()-&gt;set_minor_version(
          minor_version(bytes, length));
      chassis_detail-&gt;mutable_eps()-&gt;set_build_number(
          build_number(bytes, length));
      break;
    default:
      break;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\version_7f.cc" startLine="(26, 0)" endLine="(56, 1)" clone_start="12" clone_end="27">
			<code function_name="Version7f::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Version7f::Parse(const std::uint8_t *bytes, int32_t length,
                      ChassisDetail *chassis_detail) const {
  switch (module_name(bytes, length)) {
    case 0x01:
      chassis_detail-&gt;mutable_brake()-&gt;set_major_version(
          major_version(bytes, length));
      chassis_detail-&gt;mutable_brake()-&gt;set_minor_version(
          minor_version(bytes, length));
      chassis_detail-&gt;mutable_brake()-&gt;set_build_number(
          build_number(bytes, length));
      break;
    case 0x02:
      chassis_detail-&gt;mutable_gas()-&gt;set_major_version(
          major_version(bytes, length));
      chassis_detail-&gt;mutable_gas()-&gt;set_minor_version(
          minor_version(bytes, length));
      chassis_detail-&gt;mutable_gas()-&gt;set_build_number(
          build_number(bytes, length));
      break;
    case 0x03:
      chassis_detail-&gt;mutable_eps()-&gt;set_major_version(
          major_version(bytes, length));
      chassis_detail-&gt;mutable_eps()-&gt;set_minor_version(
          minor_version(bytes, length));
      chassis_detail-&gt;mutable_eps()-&gt;set_build_number(
          build_number(bytes, length));
      break;
    default:
      break;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(134, 2)" endLine="(134, 45)" clone_start="1" clone_end="1">
			<code function_name="DummyObjectFilter()">  DummyObjectFilter() : BaseObjectFilter() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.h" startLine="(29, 4)" endLine="(29, 50)" clone_start="1" clone_end="1">
			<code function_name="MinBoxObjectBuilder()">    MinBoxObjectBuilder() : BaseObjectBuilder() {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(135, 2)" endLine="(135, 25)" clone_start="1" clone_end="1">
			<code function_name="~DummyObjectFilter()">  ~DummyObjectFilter() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.h" startLine="(30, 4)" endLine="(30, 37)" clone_start="1" clone_end="1">
			<code function_name="~MinBoxObjectBuilder()">    virtual ~MinBoxObjectBuilder() {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(137, 2)" endLine="(139, 3)" clone_start="1" clone_end="3">
			<code function_name="Init() override">  bool Init() override {
    return result_init_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.h" startLine="(32, 4)" endLine="(35, 5)" clone_start="1" clone_end="4">
			<code function_name="Init() override">    bool Init() override {
        // Do something.
        return true;
    }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(144, 2)" endLine="(146, 3)" clone_start="1" clone_end="3">
			<code function_name="name() const override">  std::string name() const override {
    return "DummyObjectFilter";
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.h" startLine="(41, 4)" endLine="(43, 5)" clone_start="1" clone_end="3">
			<code function_name="name() const override">    std::string name() const override {
        return "MinBoxObjectBuilder";
    }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(510, 0)" endLine="(547, 1)" clone_start="16" clone_end="25">
			<code function_name="NovatelParser::handle_ins_pva(const novatel::InsPva* pva)">bool NovatelParser::handle_ins_pva(const novatel::InsPva* pva) {
  if (_ins_status != pva-&gt;status) {
    _ins_status = pva-&gt;status;
    ROS_INFO_STREAM("INS status: " &lt;&lt; static_cast&lt;int&gt;(_ins_status));
  }
  _ins.mutable_position()-&gt;set_lon(pva-&gt;longitude);
  _ins.mutable_position()-&gt;set_lat(pva-&gt;latitude);
  _ins.mutable_position()-&gt;set_height(pva-&gt;height);
  _ins.mutable_euler_angles()-&gt;set_x(pva-&gt;roll * DEG_TO_RAD);
  _ins.mutable_euler_angles()-&gt;set_y(-pva-&gt;pitch * DEG_TO_RAD);
  _ins.mutable_euler_angles()-&gt;set_z(azimuth_deg_to_yaw_rad(pva-&gt;azimuth));
  _ins.mutable_linear_velocity()-&gt;set_x(pva-&gt;east_velocity);
  _ins.mutable_linear_velocity()-&gt;set_y(pva-&gt;north_velocity);
  _ins.mutable_linear_velocity()-&gt;set_z(pva-&gt;up_velocity);

  switch (pva-&gt;status) {
    case novatel::InsStatus::ALIGNMENT_COMPLETE:
    case novatel::InsStatus::SOLUTION_GOOD:
      _ins.set_type(apollo::drivers::gnss::Ins::GOOD);
      break;
    case novatel::InsStatus::ALIGNING:
    case novatel::InsStatus::HIGH_VARIANCE:
    case novatel::InsStatus::SOLUTION_FREE:
      _ins.set_type(apollo::drivers::gnss::Ins::CONVERGING);
      break;
    default:
      _ins.set_type(apollo::drivers::gnss::Ins::INVALID);
  }

  double seconds = pva-&gt;gps_week * SECONDS_PER_WEEK + pva-&gt;gps_seconds;
  if (_ins.measurement_time() != seconds) {
    _ins.set_measurement_time(seconds);
    return false;
  }

  _ins.mutable_header()-&gt;set_timestamp_sec(ros::Time::now().toSec());
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(376, 0)" endLine="(455, 1)" clone_start="21" clone_end="30">
			<code function_name="NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs)">bool NovatelParser::handle_best_pos(const novatel::BestPos* pos,
                                    uint16_t gps_week, uint32_t gps_millisecs) {
  _gnss.mutable_position()-&gt;set_lon(pos-&gt;longitude);
  _gnss.mutable_position()-&gt;set_lat(pos-&gt;latitude);
  _gnss.mutable_position()-&gt;set_height(pos-&gt;height_msl + pos-&gt;undulation);
  _gnss.mutable_position_std_dev()-&gt;set_x(pos-&gt;longitude_std_dev);
  _gnss.mutable_position_std_dev()-&gt;set_y(pos-&gt;latitude_std_dev);
  _gnss.mutable_position_std_dev()-&gt;set_z(pos-&gt;height_std_dev);
  _gnss.set_num_sats(pos-&gt;num_sats_in_solution);
  if (_solution_status != pos-&gt;solution_status) {
    _solution_status = pos-&gt;solution_status;
    ROS_INFO_STREAM("Solution status: " &lt;&lt; static_cast&lt;int&gt;(_solution_status));
  }
  if (_position_type != pos-&gt;position_type) {
    _position_type = pos-&gt;position_type;
    ROS_INFO_STREAM("Position type: " &lt;&lt; static_cast&lt;int&gt;(_position_type));
  }
  _gnss.set_solution_status(static_cast&lt;uint32_t&gt;(pos-&gt;solution_status));
  if (pos-&gt;solution_status == novatel::SolutionStatus::SOL_COMPUTED) {
    _gnss.set_position_type(static_cast&lt;uint32_t&gt;(pos-&gt;position_type));
    switch (pos-&gt;position_type) {
      case novatel::SolutionType::SINGLE:
      case novatel::SolutionType::INS_PSRSP:
        _gnss.set_type(apollo::drivers::gnss::Gnss::SINGLE);
        break;
      case novatel::SolutionType::PSRDIFF:
      case novatel::SolutionType::WAAS:
      case novatel::SolutionType::INS_SBAS:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PSRDIFF);
        break;
      case novatel::SolutionType::FLOATCONV:
      case novatel::SolutionType::L1_FLOAT:
      case novatel::SolutionType::IONOFREE_FLOAT:
      case novatel::SolutionType::NARROW_FLOAT:
      case novatel::SolutionType::RTK_DIRECT_INS:
      case novatel::SolutionType::INS_RTKFLOAT:
        _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_FLOAT);
        break;
      case novatel::SolutionType::WIDELANE:
      case novatel::SolutionType::NARROWLANE:
      case novatel::SolutionType::L1_INT:
      case novatel::SolutionType::WIDE_INT:
      case novatel::SolutionType::NARROW_INT:
      case novatel::SolutionType::INS_RTKFIXED:
        _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_INTEGER);
        break;
      case novatel::SolutionType::OMNISTAR:
      case novatel::SolutionType::INS_OMNISTAR:
      case novatel::SolutionType::INS_OMNISTAR_HP:
      case novatel::SolutionType::INS_OMNISTAR_XP:
      case novatel::SolutionType::OMNISTAR_HP:
      case novatel::SolutionType::OMNISTAR_XP:
      case novatel::SolutionType::PPP_CONVERGING:
      case novatel::SolutionType::PPP:
      case novatel::SolutionType::INS_PPP_CONVERGING:
      case novatel::SolutionType::INS_PPP:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PPP);
        break;
      case novatel::SolutionType::PROPOGATED:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PROPAGATED);
        break;
      default:
        _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
    }
  } else {
    _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
    _gnss.set_position_type(0);
  }
  if (pos-&gt;datum_id != novatel::DatumId::WGS84) {
    ROS_ERROR_STREAM_THROTTLE(
        5, "Unexpected Datum Id: " &lt;&lt; static_cast&lt;int&gt;(pos-&gt;datum_id));
  }

  double seconds = gps_week * SECONDS_PER_WEEK + gps_millisecs * 1e-3;
  if (_gnss.measurement_time() != seconds) {
    _gnss.set_measurement_time(seconds);
    return false;
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(109, 0)" endLine="(113, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_watchdog_counter_applying_brakes(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_watchdog_counter_applying_brakes(const std::uint8_t *bytes,
                                                  int32_t length) const {
  Byte frame(bytes + 6);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(98, 0)" endLine="(102, 1)" clone_start="1" clone_end="5">
			<code function_name="Gear67::is_driver_override(const std::uint8_t *bytes, int32_t length) const">bool Gear67::is_driver_override(const std::uint8_t *bytes,
                                int32_t length) const {
  Byte frame(bytes + 0);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(115, 0)" endLine="(121, 1)" clone_start="1" clone_end="7">
			<code function_name="Brake61::watchdog_counter_source(const std::uint8_t *bytes, int32_t length) const">int32_t Brake61::watchdog_counter_source(const std::uint8_t *bytes,
                                         int32_t length) const {
  // see table for status code
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(104, 0)" endLine="(109, 1)" clone_start="1" clone_end="6">
			<code function_name="Gear67::reported_gear_cmd(const std::uint8_t *bytes, int32_t length) const">int32_t Gear67::reported_gear_cmd(const std::uint8_t *bytes,
                                  int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(4, 3);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(123, 0)" endLine="(126, 1)" clone_start="1" clone_end="3">
			<code function_name="Brake61::is_enabled(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_enabled(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(111, 0)" endLine="(114, 1)" clone_start="1" clone_end="3">
			<code function_name="Gear67::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const">bool Gear67::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 0);
  return frame.is_bit_1(7);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(380, 0)" endLine="(413, 1)" clone_start="5" clone_end="18">
			<code function_name="RawStream::stream_status_check()">void RawStream::stream_status_check() {
  bool status_report = false;
  apollo::common::gnss_status::StreamStatus_Type report_stream_status;

  if (_data_stream &amp;&amp;
      (_data_stream-&gt;get_status() != _data_stream_status-&gt;status)) {
    _data_stream_status-&gt;status = _data_stream-&gt;get_status();
    status_report = true;
    switch_stream_status(_data_stream_status-&gt;status, report_stream_status);
    _stream_status-&gt;set_ins_stream_type(report_stream_status);
  }

  if (_in_rtk_stream &amp;&amp;
      (_in_rtk_stream-&gt;get_status() != _in_rtk_stream_status-&gt;status)) {
    _in_rtk_stream_status-&gt;status = _in_rtk_stream-&gt;get_status();
    status_report = true;
    switch_stream_status(_in_rtk_stream_status-&gt;status, report_stream_status);
    _stream_status-&gt;set_rtk_stream_in_type(report_stream_status);
  }

  if (_out_rtk_stream &amp;&amp;
      (_out_rtk_stream-&gt;get_status() != _out_rtk_stream_status-&gt;status)) {
    _out_rtk_stream_status-&gt;status = _out_rtk_stream-&gt;get_status();
    status_report = true;
    switch_stream_status(_out_rtk_stream_status-&gt;status, report_stream_status);
    _stream_status-&gt;set_rtk_stream_out_type(report_stream_status);
  }

  if (status_report) {
    _stream_status-&gt;mutable_header()-&gt;set_timestamp_sec(
        ros::Time::now().toSec());
    _stream_status_publisher.publish(_stream_status);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(380, 0)" endLine="(413, 1)" clone_start="13" clone_end="26">
			<code function_name="RawStream::stream_status_check()">void RawStream::stream_status_check() {
  bool status_report = false;
  apollo::common::gnss_status::StreamStatus_Type report_stream_status;

  if (_data_stream &amp;&amp;
      (_data_stream-&gt;get_status() != _data_stream_status-&gt;status)) {
    _data_stream_status-&gt;status = _data_stream-&gt;get_status();
    status_report = true;
    switch_stream_status(_data_stream_status-&gt;status, report_stream_status);
    _stream_status-&gt;set_ins_stream_type(report_stream_status);
  }

  if (_in_rtk_stream &amp;&amp;
      (_in_rtk_stream-&gt;get_status() != _in_rtk_stream_status-&gt;status)) {
    _in_rtk_stream_status-&gt;status = _in_rtk_stream-&gt;get_status();
    status_report = true;
    switch_stream_status(_in_rtk_stream_status-&gt;status, report_stream_status);
    _stream_status-&gt;set_rtk_stream_in_type(report_stream_status);
  }

  if (_out_rtk_stream &amp;&amp;
      (_out_rtk_stream-&gt;get_status() != _out_rtk_stream_status-&gt;status)) {
    _out_rtk_stream_status-&gt;status = _out_rtk_stream-&gt;get_status();
    status_report = true;
    switch_stream_status(_out_rtk_stream_status-&gt;status, report_stream_status);
    _stream_status-&gt;set_rtk_stream_out_type(report_stream_status);
  }

  if (status_report) {
    _stream_status-&gt;mutable_header()-&gt;set_timestamp_sec(
        ros::Time::now().toSec());
    _stream_status_publisher.publish(_stream_status);
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(617, 0)" endLine="(664, 1)" clone_start="19" clone_end="31">
			<code function_name="LanesXmlParser::ParseLaneLink(const tinyxml2::XMLElement&amp; xml_node, PbLane* lane)">void LanesXmlParser::ParseLaneLink(const tinyxml2::XMLElement&amp; xml_node,
                                   PbLane* lane) {
  CHECK_NOTNULL(lane);

  const tinyxml2::XMLElement* sub_node =
      xml_node.FirstChildElement("predecessor");
  while (sub_node) {
    std::string lane_id;
    int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                    &amp;lane_id);
    if (checker == tinyxml2::XML_SUCCESS) {
      PbID* pb_lane_id = lane-&gt;add_predecessor_id();
      pb_lane_id-&gt;set_id(lane_id);
    }
    sub_node = sub_node-&gt;NextSiblingElement("predecessor");
  }

  sub_node = xml_node.FirstChildElement("successor");
  while (sub_node) {
    std::string lane_id;
    int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                    &amp;lane_id);
    if (checker == tinyxml2::XML_SUCCESS) {
      PbID* pb_lane_id = lane-&gt;add_successor_id();
      pb_lane_id-&gt;set_id(lane_id);
    }
    sub_node = sub_node-&gt;NextSiblingElement("successor");
  }
  sub_node = xml_node.FirstChildElement("neighbor");
  while (sub_node) {
    std::string side;
    std::string direction;
    std::string lane_id;
    int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                   &amp;lane_id);
    checker += UtilXmlParser::QueryStringAttribute(*sub_node, "side", &amp;side);
    checker +=
        UtilXmlParser::QueryStringAttribute(*sub_node, "direction", &amp;direction);
    if (checker == tinyxml2::XML_SUCCESS) {
      if (side == "left") {
        lane-&gt;add_left_neighbor_forward_lane_id()-&gt;set_id(lane_id);
      } else if (side == "right") {
        lane-&gt;add_right_neighbor_forward_lane_id()-&gt;set_id(lane_id);
      }
    }
    sub_node = sub_node-&gt;NextSiblingElement("neighbor");
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(617, 0)" endLine="(664, 1)" clone_start="7" clone_end="20">
			<code function_name="LanesXmlParser::ParseLaneLink(const tinyxml2::XMLElement&amp; xml_node, PbLane* lane)">void LanesXmlParser::ParseLaneLink(const tinyxml2::XMLElement&amp; xml_node,
                                   PbLane* lane) {
  CHECK_NOTNULL(lane);

  const tinyxml2::XMLElement* sub_node =
      xml_node.FirstChildElement("predecessor");
  while (sub_node) {
    std::string lane_id;
    int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                    &amp;lane_id);
    if (checker == tinyxml2::XML_SUCCESS) {
      PbID* pb_lane_id = lane-&gt;add_predecessor_id();
      pb_lane_id-&gt;set_id(lane_id);
    }
    sub_node = sub_node-&gt;NextSiblingElement("predecessor");
  }

  sub_node = xml_node.FirstChildElement("successor");
  while (sub_node) {
    std::string lane_id;
    int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                    &amp;lane_id);
    if (checker == tinyxml2::XML_SUCCESS) {
      PbID* pb_lane_id = lane-&gt;add_successor_id();
      pb_lane_id-&gt;set_id(lane_id);
    }
    sub_node = sub_node-&gt;NextSiblingElement("successor");
  }
  sub_node = xml_node.FirstChildElement("neighbor");
  while (sub_node) {
    std::string side;
    std::string direction;
    std::string lane_id;
    int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                   &amp;lane_id);
    checker += UtilXmlParser::QueryStringAttribute(*sub_node, "side", &amp;side);
    checker +=
        UtilXmlParser::QueryStringAttribute(*sub_node, "direction", &amp;direction);
    if (checker == tinyxml2::XML_SUCCESS) {
      if (side == "left") {
        lane-&gt;add_left_neighbor_forward_lane_id()-&gt;set_id(lane_id);
      } else if (side == "right") {
        lane-&gt;add_right_neighbor_forward_lane_id()-&gt;set_id(lane_id);
      }
    }
    sub_node = sub_node-&gt;NextSiblingElement("neighbor");
  }
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(26, 0)" endLine="(114, 1)" clone_start="84" clone_end="89">
			<code function_name="SignalsXmlParser::ParseTrafficLights(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;TrafficLightInternal&gt;* traffic_lights)">Status SignalsXmlParser::ParseTrafficLights(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;TrafficLightInternal&gt;* traffic_lights) {
  CHECK_NOTNULL(traffic_lights);
  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "trafficLight") {
      PbSignal traffic_light;
      traffic_light.mutable_id()-&gt;set_id(object_id);
      std::string layout_type;
      int checker = UtilXmlParser::QueryStringAttribute(
          *signal_node, "layoutType", &amp;layout_type);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse signal layout type.";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      PbSignalType signal_layout_type;
      ToPbSignalType(layout_type, &amp;signal_layout_type);
      traffic_light.set_type(signal_layout_type);

      PbPolygon* polygon = traffic_light.mutable_boundary();
      auto outline_node = signal_node-&gt;FirstChildElement("outline");
      if (outline_node == nullptr) {
        std::string err_msg = "Error parse signal outline";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseOutline(*outline_node, polygon));
      auto sub_node = signal_node-&gt;FirstChildElement("subSignal");
      if (sub_node == nullptr) {
        std::string err_msg = "Error parse sub signal.";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      while (sub_node) {
        std::string sub_signal_id;
        std::string sub_signal_xml_type;
        checker = UtilXmlParser::QueryStringAttribute(*sub_node, "type",
                                                      &amp;sub_signal_xml_type);
        checker += UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                       &amp;sub_signal_id);
        if (checker != tinyxml2::XML_SUCCESS) {
          std::string err_msg = "Error parse sub signal layout type.";
          return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
        }

        PbSubSignal* sub_signal = traffic_light.add_subsignal();
        PbSubSignalType sub_signal_type;
        ToPbSubSignalType(sub_signal_xml_type, &amp;sub_signal_type);
        sub_signal-&gt;mutable_id()-&gt;set_id(sub_signal_id);
        sub_signal-&gt;set_type(sub_signal_type);
        PbPoint3D* pt = sub_signal-&gt;mutable_location();
        RETURN_IF_ERROR(UtilXmlParser::ParsePoint(*sub_node, pt));

        sub_node = sub_node-&gt;NextSiblingElement("subSignal");
      }

      TrafficLightInternal trafficlight_internal;
      trafficlight_internal.id = object_id;
      trafficlight_internal.traffic_light = traffic_light;

      sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                            &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          trafficlight_internal.stop_line_ids.insert(stop_line_id);
          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      traffic_lights-&gt;emplace_back(trafficlight_internal);
    }
    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(511, 0)" endLine="(551, 1)" clone_start="34" clone_end="41">
			<code function_name="LanesXmlParser::ParseLaneOverlapGroup(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;OverlapWithLane&gt;* lane_overlaps)">Status LanesXmlParser::ParseLaneOverlapGroup(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;OverlapWithLane&gt;* lane_overlaps) {
  CHECK_NOTNULL(lane_overlaps);

  auto overlap_node = xml_node.FirstChildElement("laneOverlapGroup");
  if (overlap_node) {
    auto sub_node = overlap_node-&gt;FirstChildElement("laneReference");
    while (sub_node) {
      std::string lane_id;
      double start_s = 0.0;
      double end_s = 0.0;
      int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                   &amp;lane_id);
      checker += sub_node-&gt;QueryDoubleAttribute("startOffset", &amp;start_s);
      checker += sub_node-&gt;QueryDoubleAttribute("endOffset", &amp;end_s);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse lane lane overlap";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      bool is_merge = false;
      checker = sub_node-&gt;QueryBoolAttribute("isMerge", &amp;is_merge);
      if (checker != tinyxml2::XML_SUCCESS) {
        is_merge = false;
      }

      OverlapWithLane overlap_with_lane;
      overlap_with_lane.object_id = lane_id;
      overlap_with_lane.start_s = start_s;
      overlap_with_lane.end_s = end_s;
      overlap_with_lane.is_merge = is_merge;

      lane_overlaps-&gt;push_back(overlap_with_lane);

      sub_node = sub_node-&gt;NextSiblingElement("laneReference");
    }
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(62, 0)" endLine="(91, 1)" clone_start="24" clone_end="30">
			<code function_name="LanesXmlParser::ParseSectionBoundary( const tinyxml2::XMLElement&amp; xml_node, PbBoundaryPolygon* boundary)">Status LanesXmlParser::ParseSectionBoundary(
    const tinyxml2::XMLElement&amp; xml_node, PbBoundaryPolygon* boundary) {
  CHECK_NOTNULL(boundary);

  auto boundaries_node = xml_node.FirstChildElement("boundaries");
  if (boundaries_node == nullptr) {
    std::string err_msg = "Error parse boundaries";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  auto sub_node = boundaries_node-&gt;FirstChildElement("boundary");
  while (sub_node) {
    PbBoundaryEdge* boundary_edge = boundary-&gt;add_edge();
    RETURN_IF_ERROR(
        UtilXmlParser::ParseCurve(*sub_node, boundary_edge-&gt;mutable_curve()));
    std::string type;
    int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "type", &amp;type);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse boundary type";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }
    PbBoundaryEdgeType boundary_type;
    RETURN_IF_ERROR(ToPbBoundaryType(type, &amp;boundary_type));
    boundary_edge-&gt;set_type(boundary_type);

    sub_node = sub_node-&gt;NextSiblingElement("boundary");
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(116, 0)" endLine="(140, 1)" clone_start="1" clone_end="10">
			<code function_name="SignalsXmlParser::ToPbSignalType(const std::string&amp; xml_type, PbSignalType* signal_type)">Status SignalsXmlParser::ToPbSignalType(const std::string&amp; xml_type,
                                        PbSignalType* signal_type) {
  CHECK_NOTNULL(signal_type);

  std::string upper_str = UtilXmlParser::ToUpper(xml_type);

  if (upper_str == "UNKNOWN") {
    *signal_type = hdmap::Signal::UNKNOWN;
  } else if (upper_str == "MIX2HORIZONTAL") {
    *signal_type = hdmap::Signal::MIX_2_HORIZONTAL;
  } else if (upper_str == "MIX2VERTICAL") {
    *signal_type = hdmap::Signal::MIX_2_VERTICAL;
  } else if (upper_str == "MIX3HORIZONTAL") {
    *signal_type = hdmap::Signal::MIX_3_HORIZONTAL;
  } else if (upper_str == "MIX3VERTICAL") {
    *signal_type = hdmap::Signal::MIX_3_VERTICAL;
  } else if (upper_str == "SINGLE") {
    *signal_type = hdmap::Signal::SINGLE;
  } else {
    std::string err_msg = "Error or unsupport signal layout type";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(553, 0)" endLine="(573, 1)" clone_start="1" clone_end="10">
			<code function_name="LanesXmlParser::ToPbLaneType(const std::string&amp; type, PbLaneType* lane_type)">Status LanesXmlParser::ToPbLaneType(const std::string&amp; type,
                                    PbLaneType* lane_type) {
  CHECK_NOTNULL(lane_type);

  std::string upper_str = UtilXmlParser::ToUpper(type);

  if (upper_str == "NONE") {
    *lane_type = hdmap::Lane::NONE;
  } else if (upper_str == "DRIVING") {
    *lane_type = hdmap::Lane::CITY_DRIVING;
  } else if (upper_str == "BIKING") {
    *lane_type = hdmap::Lane::BIKING;
  } else if (upper_str == "PARKING") {
    *lane_type = hdmap::Lane::PARKING;
  } else {
    std::string err_msg = "Error or unsupport lane type:" + type;
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(93, 0)" endLine="(108, 1)" clone_start="1" clone_end="10">
			<code function_name="LanesXmlParser::ToPbBoundaryType(const std::string&amp; type, PbBoundaryEdgeType* boundary_type)">Status LanesXmlParser::ToPbBoundaryType(const std::string&amp; type,
                                        PbBoundaryEdgeType* boundary_type) {
  CHECK_NOTNULL(boundary_type);

  std::string upper_type = UtilXmlParser::ToUpper(type);

  if (upper_type == "LEFTBOUNDARY") {
    *boundary_type = hdmap::BoundaryEdge::LEFT_BOUNDARY;
  } else if (upper_type == "RIGHTBOUNDARY") {
    *boundary_type = hdmap::BoundaryEdge::RIGHT_BOUNDARY;
  } else {
    *boundary_type = hdmap::BoundaryEdge::NORMAL;
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_kernel.cc" startLine="(123, 0)" endLine="(166, 1)" clone_start="18" clone_end="33">
			<code function_name="Spline2dKernel::AddReferenceLineKernelMatrix(const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;Vec2d&gt;&amp; ref_points, const double weight)">bool Spline2dKernel::AddReferenceLineKernelMatrix(
    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;Vec2d&gt;&amp; ref_points,
    const double weight) {
  if (ref_points.size() != t_coord.size()) {
    return false;
  }

  for (std::uint32_t i = 0; i &lt; t_coord.size(); ++i) {
    double cur_index = find_index(t_coord[i]);
    double cur_rel_t = t_coord[i] - t_knots_[cur_index];
    // update offset
    double offset_coef_x = -ref_points[i].x() * weight;
    double offset_coef_y = -ref_points[i].y() * weight;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      offset_(j + (2 * cur_index) * spline_order_, 0) = offset_coef_x;
      offset_(j + (2 * cur_index + 1) * spline_order_, 0) = offset_coef_y;
      offset_coef_x *= cur_rel_t;
      offset_coef_y *= cur_rel_t;
    }

    // update kernel matrix
    Eigen::MatrixXd ref_kernel(spline_order_, spline_order_);

    double cur_t = 1.0;
    std::vector&lt;double&gt; power_t;
    for (std::uint32_t n = 0; n + 1 &lt; 2 * spline_order_; ++n) {
      power_t.emplace_back(cur_t);
      cur_t *= cur_rel_t;
    }

    for (std::uint32_t r = 0; r &lt; spline_order_; ++r) {
      for (std::uint32_t c = 0; c &lt; spline_order_; ++c) {
        ref_kernel(r, c) = power_t[r + c];
      }
    }
    kernel_matrix_.block((2 * cur_index) * spline_order_,
                         (2 * cur_index) * spline_order_, spline_order_,
                         spline_order_) += weight * ref_kernel;
    kernel_matrix_.block((2 * cur_index + 1) * spline_order_,
                         (2 * cur_index + 1) * spline_order_, spline_order_,
                         spline_order_) += weight * ref_kernel;
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_kernel.cc" startLine="(119, 0)" endLine="(155, 1)" clone_start="15" clone_end="29">
			<code function_name="Spline1dKernel::AddReferenceLineKernelMatrix(const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; ref_x, const double weight)">bool Spline1dKernel::AddReferenceLineKernelMatrix(
    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; ref_x,
    const double weight) {
  if (ref_x.size() != x_coord.size()) {
    return false;
  }

  for (std::uint32_t i = 0; i &lt; x_coord.size(); ++i) {
    double cur_index = find_index(x_coord[i]);
    double cur_rel_x = x_coord[i] - x_knots_[cur_index];
    // update offset
    double offset_coef = -2.0 * ref_x[i] * weight;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      offset_(j + cur_index * spline_order_, 0) += offset_coef;
      offset_coef *= cur_rel_x;
    }
    // update kernel matrix
    Eigen::MatrixXd ref_kernel(spline_order_, spline_order_);

    double cur_x = 1.0;
    std::vector&lt;double&gt; power_x;
    for (std::uint32_t n = 0; n + 1 &lt; 2 * spline_order_; ++n) {
      power_x.emplace_back(cur_x);
      cur_x *= cur_rel_x;
    }

    for (std::uint32_t r = 0; r &lt; spline_order_; ++r) {
      for (std::uint32_t c = 0; c &lt; spline_order_; ++c) {
        ref_kernel(r, c) = power_x[r + c];
      }
    }

    kernel_matrix_.block(cur_index * spline_order_, cur_index * spline_order_,
                         spline_order_, spline_order_) += weight * ref_kernel;
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\aabox2d.cc" startLine="(135, 0)" endLine="(145, 1)" clone_start="1" clone_end="10">
			<code function_name="AABox2d::MergeFrom(const Vec2d &amp;other_point)">void AABox2d::MergeFrom(const Vec2d &amp;other_point) {
  const double x1 = std::min(min_x(), other_point.x());
  const double x2 = std::max(max_x(), other_point.x());
  const double y1 = std::min(min_y(), other_point.y());
  const double y2 = std::max(max_y(), other_point.y());
  center_ = Vec2d((x1 + x2) / 2.0, (y1 + y2) / 2.0);
  length_ = x2 - x1;
  width_ = y2 - y1;
  half_length_ = length_ / 2.0;
  half_width_ = width_ / 2.0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\aabox2d.cc" startLine="(123, 0)" endLine="(133, 1)" clone_start="1" clone_end="10">
			<code function_name="AABox2d::MergeFrom(const AABox2d &amp;other_box)">void AABox2d::MergeFrom(const AABox2d &amp;other_box) {
  const double x1 = std::min(min_x(), other_box.min_x());
  const double x2 = std::max(max_x(), other_box.max_x());
  const double y1 = std::min(min_y(), other_box.min_y());
  const double y2 = std::max(max_y(), other_box.max_y());
  center_ = Vec2d((x1 + x2) / 2.0, (y1 + y2) / 2.0);
  length_ = x2 - x1;
  width_ = y2 - y1;
  half_length_ = length_ / 2.0;
  half_width_ = width_ / 2.0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(26, 0)" endLine="(65, 1)" clone_start="19" clone_end="36">
			<code function_name="Steering65::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Steering65::Parse(const std::uint8_t *bytes, int32_t length,
                       ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_eps()-&gt;set_steering_angle(
      steering_angle(bytes, length));
  // no steering angle speed

  chassis_detail-&gt;mutable_eps()-&gt;set_steering_angle_cmd(
      reported_steering_angle_cmd(bytes, length));
  // ?
  chassis_detail-&gt;mutable_eps()-&gt;set_is_steering_angle_valid(true);
  // vehicle speed from steering, kph -&gt; mps
  chassis_detail-&gt;mutable_eps()-&gt;set_vehicle_speed(
      vehicle_speed(bytes, length) / 3.6);

  // speed, as it has a higher accuracy
  // kph -&gt; mps
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_vehicle_spd(
      vehicle_speed(bytes, length) / 3.6);
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_spd_valid(true);

  chassis_detail-&gt;mutable_eps()-&gt;set_epas_torque(epas_torque(bytes, length));
  chassis_detail-&gt;mutable_eps()-&gt;set_steering_enabled(
      is_enabled(bytes, length));
  chassis_detail-&gt;mutable_eps()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  chassis_detail-&gt;mutable_eps()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  chassis_detail-&gt;mutable_eps()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  chassis_detail-&gt;mutable_eps()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  chassis_detail-&gt;mutable_eps()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  chassis_detail-&gt;mutable_eps()-&gt;set_calibration_fault(
      is_calibration_fault(bytes, length));
  chassis_detail-&gt;mutable_eps()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  chassis_detail-&gt;mutable_check_response()-&gt;set_is_eps_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="164" clone_end="189">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(26, 0)" endLine="(33, 1)" clone_start="1" clone_end="8">
			<code function_name="Throttleinfo75::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Throttleinfo75::Parse(const std::uint8_t *bytes, int32_t length,
                           ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_ems()-&gt;set_engine_rpm(engine_rpm(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_accelerator_pedal(
      acc_pedal_percent(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_accelerator_pedal_rate(
      acc_pedal_rate(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6d.cc" startLine="(26, 0)" endLine="(31, 1)" clone_start="1" clone_end="6">
			<code function_name="Gps6d::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Gps6d::Parse(const std::uint8_t *bytes, int32_t length,
                  ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_basic()-&gt;set_latitude(latitude(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_longitude(longitude(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_gps_valid(is_valid(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(35, 0)" endLine="(43, 1)" clone_start="1" clone_end="6">
			<code function_name="Throttleinfo75::engine_rpm(const std::uint8_t *bytes, int32_t length) const">double Throttleinfo75::engine_rpm(const std::uint8_t *bytes,
                                  int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.25;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6d.cc" startLine="(33, 0)" endLine="(57, 1)" clone_start="1" clone_end="6">
			<code function_name="Gps6d::latitude(const std::uint8_t *bytes, int32_t length) const">double Gps6d::latitude(const std::uint8_t *bytes, int32_t length) const {
  Byte frame_0(bytes + 3);
  int32_t value = frame_0.get_byte(0, 7);

  Byte frame_1(bytes + 2);
  int32_t t = frame_1.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_2(bytes + 1);
  t = frame_2.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_3(bytes);
  t = frame_3.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  if (value &gt; 0x3FFFFFFF) {
    value -= 0x80000000;
  }

  return value * (1.000000 / 3.000000) * 1e-6;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(151, 0)" endLine="(153, 1)" clone_start="1" clone_end="3">
			<code function_name="ActiveSetQpSolver::set_debug_info(const bool enable)">void ActiveSetQpSolver::set_debug_info(const bool enable) {
  debug_info_ = enable;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(147, 0)" endLine="(149, 1)" clone_start="1" clone_end="3">
			<code function_name="ActiveSetQpSolver::set_qp_eps_iter_ref(const double eps)">void ActiveSetQpSolver::set_qp_eps_iter_ref(const double eps) {
  qp_eps_iter_ref_ = eps;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(155, 0)" endLine="(157, 1)" clone_start="1" clone_end="3">
			<code function_name="ActiveSetQpSolver::set_l_lower_bound(const double l_lower_bound)">void ActiveSetQpSolver::set_l_lower_bound(const double l_lower_bound) {
  l_lower_bound_ = l_lower_bound;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(151, 0)" endLine="(153, 1)" clone_start="1" clone_end="3">
			<code function_name="ActiveSetQpSolver::set_debug_info(const bool enable)">void ActiveSetQpSolver::set_debug_info(const bool enable) {
  debug_info_ = enable;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(159, 0)" endLine="(161, 1)" clone_start="1" clone_end="3">
			<code function_name="ActiveSetQpSolver::set_l_upper_bound(const double l_upper_bound)">void ActiveSetQpSolver::set_l_upper_bound(const double l_upper_bound) {
  l_upper_bound_ = l_upper_bound;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(155, 0)" endLine="(157, 1)" clone_start="1" clone_end="3">
			<code function_name="ActiveSetQpSolver::set_l_lower_bound(const double l_lower_bound)">void ActiveSetQpSolver::set_l_lower_bound(const double l_lower_bound) {
  l_lower_bound_ = l_lower_bound;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(163, 0)" endLine="(166, 1)" clone_start="1" clone_end="4">
			<code function_name="ActiveSetQpSolver::set_constraint_upper_bound( const double la_upper_bound)">void ActiveSetQpSolver::set_constraint_upper_bound(
    const double la_upper_bound) {
  constraint_upper_bound_ = la_upper_bound;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(159, 0)" endLine="(161, 1)" clone_start="1" clone_end="3">
			<code function_name="ActiveSetQpSolver::set_l_upper_bound(const double l_upper_bound)">void ActiveSetQpSolver::set_l_upper_bound(const double l_upper_bound) {
  l_upper_bound_ = l_upper_bound;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(168, 0)" endLine="(170, 1)" clone_start="1" clone_end="2">
			<code function_name="ActiveSetQpSolver::set_max_iteration(const int max_iter)">void ActiveSetQpSolver::set_max_iteration(const int max_iter) {
  max_iteration_ = max_iter;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\math\qp_solver\active_set_qp_solver.cc" startLine="(163, 0)" endLine="(166, 1)" clone_start="1" clone_end="3">
			<code function_name="ActiveSetQpSolver::set_constraint_upper_bound( const double la_upper_bound)">void ActiveSetQpSolver::set_constraint_upper_bound(
    const double la_upper_bound) {
  constraint_upper_bound_ = la_upper_bound;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(49, 0)" endLine="(57, 1)" clone_start="8" clone_end="9">
			<code function_name="Brake60::set_pedal(double pedal)">Brake60 *Brake60::set_pedal(double pedal) {
  pedal_cmd_ = pedal;
  if (pedal_cmd_ &lt; 1e-3) {
    disable_boo_cmd();
  } else {
    enable_boo_cmd();
  }
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(59, 0)" endLine="(62, 1)" clone_start="3" clone_end="4">
			<code function_name="Brake60::enable_boo_cmd()">Brake60 *Brake60::enable_boo_cmd() {
  boo_cmd_ = true;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(59, 0)" endLine="(62, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake60::enable_boo_cmd()">Brake60 *Brake60::enable_boo_cmd() {
  boo_cmd_ = true;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(64, 0)" endLine="(67, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake60::disable_boo_cmd()">Brake60 *Brake60::disable_boo_cmd() {
  boo_cmd_ = false;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(64, 0)" endLine="(67, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake60::disable_boo_cmd()">Brake60 *Brake60::disable_boo_cmd() {
  boo_cmd_ = false;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(69, 0)" endLine="(72, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake60::set_enable()">Brake60 *Brake60::set_enable() {
  pedal_enable_ = true;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(69, 0)" endLine="(72, 1)" clone_start="1" clone_end="3">
			<code function_name="Brake60::set_enable()">Brake60 *Brake60::set_enable() {
  pedal_enable_ = true;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(74, 0)" endLine="(77, 1)" clone_start="1" clone_end="3">
			<code function_name="Brake60::set_disable()">Brake60 *Brake60::set_disable() {
  pedal_enable_ = false;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\frame.cc" startLine="(266, 0)" endLine="(297, 1)" clone_start="15" clone_end="26">
			<code function_name="Frame::CreateReferenceLineFromRouting( const common::PointENU &amp;position, const routing::RoutingResponse &amp;routing)">std::vector&lt;ReferenceLine&gt; Frame::CreateReferenceLineFromRouting(
    const common::PointENU &amp;position, const routing::RoutingResponse &amp;routing) {
  std::vector&lt;ReferenceLine&gt; reference_lines;
  std::vector&lt;std::vector&lt;hdmap::LaneSegment&gt;&gt; route_segments;
  if (!pnc_map_-&gt;GetLaneSegmentsFromRouting(
          routing, position, FLAGS_look_backward_distance,
          FLAGS_look_forward_distance, &amp;route_segments)) {
    AERROR &lt;&lt; "Failed to extract segments from routing";
    return reference_lines;
  }

  ReferenceLineSmoother smoother;
  smoother.Init(smoother_config_);

  for (const auto &amp;segments : route_segments) {
    hdmap::Path hdmap_path;
    pnc_map_-&gt;CreatePathFromLaneSegments(segments, &amp;hdmap_path);
    if (FLAGS_enable_smooth_reference_line) {
      ReferenceLine reference_line;
      if (!smoother.Smooth(ReferenceLine(hdmap_path), &amp;reference_line)) {
        AERROR &lt;&lt; "Failed to smooth reference line";
        continue;
      }
      reference_lines.push_back(std::move(reference_line));
    } else {
      reference_lines.emplace_back(hdmap_path);
    }
  }

  AERROR_IF(reference_lines.empty()) &lt;&lt; "No smooth reference lines available";
  return reference_lines;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\reference_line\reference_line_provider.cc" startLine="(124, 0)" endLine="(170, 1)" clone_start="19" clone_end="30">
			<code function_name="ReferenceLineProvider::CreateReferenceLineFromRouting( const common::PointENU &amp;position, const routing::RoutingResponse &amp;routing)">bool ReferenceLineProvider::CreateReferenceLineFromRouting(
    const common::PointENU &amp;position, const routing::RoutingResponse &amp;routing) {
  std::vector&lt;std::vector&lt;hdmap::LaneSegment&gt;&gt; route_segments;

  // additional smooth reference line length, unit: meter
  const double kForwardAdditionalLength = 30;
  if (!pnc_map_-&gt;GetLaneSegmentsFromRouting(
          routing, position, FLAGS_look_backward_distance,
          FLAGS_look_forward_distance + kForwardAdditionalLength,
          &amp;route_segments)) {
    AERROR &lt;&lt; "Failed to extract segments from routing";
    return false;
  }

  ReferenceLineSmoother smoother;
  smoother.Init(smoother_config_);

  std::vector&lt;ReferenceLine&gt; reference_lines;
  for (const auto &amp;segments : route_segments) {
    hdmap::Path hdmap_path;
    pnc_map_-&gt;CreatePathFromLaneSegments(segments, &amp;hdmap_path);
    if (FLAGS_enable_smooth_reference_line) {
      ReferenceLine reference_line;
      if (!smoother.Smooth(ReferenceLine(hdmap_path), &amp;reference_line)) {
        AERROR &lt;&lt; "Failed to smooth reference line";
        continue;
      }
      reference_lines.push_back(std::move(reference_line));
    } else {
      reference_lines.emplace_back(hdmap_path);
    }
  }

  if (reference_lines.empty()) {
    AERROR &lt;&lt; "No smooth reference lines available";
    return false;
  }

  std::lock_guard&lt;std::mutex&gt; lock(reference_line_groups_mutex_);
  reference_line_groups_.push_back(reference_lines);
  const size_t kMaxStoredReferenceLineGroups = 3;
  while (reference_line_groups_.size() &gt; kMaxStoredReferenceLineGroups) {
    reference_line_groups_.pop_front();
  }

  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(37, 0)" endLine="(42, 1)" clone_start="1" clone_end="6">
			<code function_name="TcpStream::TcpStream(const char* address, uint16_t port, uint32_t timeout_usec)">TcpStream::TcpStream(const char* address, uint16_t port, uint32_t timeout_usec)
    : _sockfd(-1), _errno(0) {
  _peer_addr = inet_addr(address);
  _peer_port = htons(port);
  _timeout_usec = timeout_usec;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(61, 0)" endLine="(67, 1)" clone_start="1" clone_end="7">
			<code function_name="UdpStream::UdpStream(const char* address, uint16_t port, uint32_t timeout_usec)">UdpStream::UdpStream(const char* address, uint16_t port, uint32_t timeout_usec)
    : _sockfd(-1), _errno(0) {
  _peer_addr = inet_addr(address);
  _peer_port = htons(port);
  _timeout_usec = timeout_usec;
  // call open or call open in connect later
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(44, 0)" endLine="(44, 42)" clone_start="1" clone_end="1">
			<code function_name="TcpStream::~TcpStream()">TcpStream::~TcpStream() { this-&gt;close(); }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(69, 0)" endLine="(69, 42)" clone_start="1" clone_end="1">
			<code function_name="UdpStream::~UdpStream()">UdpStream::~UdpStream() { this-&gt;close(); }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(46, 0)" endLine="(56, 1)" clone_start="1" clone_end="7">
			<code function_name="TcpStream::open()">void TcpStream::open() {
  int fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (fd &lt; 0) {
    // error
    ROS_ERROR_STREAM("create socket failed, errno: " &lt;&lt; errno &lt;&lt; ", "
                                                     &lt;&lt; strerror(errno));
    return;
  }

  _sockfd = fd;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(71, 0)" endLine="(133, 1)" clone_start="1" clone_end="7">
			<code function_name="UdpStream::open()">void UdpStream::open() {
  int fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
  if (fd &lt; 0) {
    // error
    ROS_ERROR_STREAM("Create socket failed, errno: " &lt;&lt; errno &lt;&lt; ", "
                                                     &lt;&lt; strerror(errno));
    return;
  }

  // block or not block
  if (_timeout_usec != 0) {
    int flags = fcntl(fd, F_GETFL, 0);
    if (flags == -1) {
      ::close(fd);
      ROS_ERROR_STREAM("fcntl get flag failed, errno: " &lt;&lt; errno &lt;&lt; ", "
                                                        &lt;&lt; strerror(errno));
      return;
    }

    if (fcntl(fd, F_SETFL, flags &amp; ~O_NONBLOCK) == -1) {
      ::close(fd);
      ROS_ERROR_STREAM("fcntl set block failed, errno: " &lt;&lt; errno &lt;&lt; ", "
                                                         &lt;&lt; strerror(errno));
      return;
    }

    struct timeval block_to = {_timeout_usec / 1000000,
                               _timeout_usec % 1000000};
    if (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, (char*)&amp;block_to,
                   sizeof(block_to)) &lt; 0) {
      ::close(fd);
      ROS_ERROR_STREAM("setsockopt set rcv timeout failed, errno: "
                       &lt;&lt; errno &lt;&lt; ", " &lt;&lt; strerror(errno));
      return;
    }

    if (setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, (char*)&amp;block_to,
                   sizeof(block_to)) &lt; 0) {
      ::close(fd);
      ROS_ERROR_STREAM("setsockopt set snd timeout failed, errno: "
                       &lt;&lt; errno &lt;&lt; ", " &lt;&lt; strerror(errno));
      return;
    }
  } else {
    int flags = fcntl(fd, F_GETFL, 0);
    if (flags == -1) {
      ::close(fd);
      ROS_ERROR_STREAM("fcntl get flag failed, errno: " &lt;&lt; errno &lt;&lt; ", "
                                                        &lt;&lt; strerror(errno));
      return;
    }

    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {
      ::close(fd);
      ROS_ERROR_STREAM("fcntl set non block failed, errno: "
                       &lt;&lt; errno &lt;&lt; ", " &lt;&lt; strerror(errno));
      return;
    }
  }

  _sockfd = fd;
  return;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(145, 0)" endLine="(145, 45)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::z() const">double VehicleState::z() const { return z_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(143, 0)" endLine="(143, 45)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::y() const">double VehicleState::y() const { return y_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(147, 0)" endLine="(147, 51)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::roll() const">double VehicleState::roll() const { return roll_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(145, 0)" endLine="(145, 45)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::z() const">double VehicleState::z() const { return z_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(149, 0)" endLine="(149, 53)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::pitch() const">double VehicleState::pitch() const { return pitch_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(147, 0)" endLine="(147, 51)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::roll() const">double VehicleState::roll() const { return roll_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(151, 0)" endLine="(151, 49)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::yaw() const">double VehicleState::yaw() const { return yaw_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(149, 0)" endLine="(149, 53)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::pitch() const">double VehicleState::pitch() const { return pitch_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(153, 0)" endLine="(153, 57)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::heading() const">double VehicleState::heading() const { return heading_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(151, 0)" endLine="(151, 49)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::yaw() const">double VehicleState::yaw() const { return yaw_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(155, 0)" endLine="(155, 53)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::kappa() const">double VehicleState::kappa() const { return kappa_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(153, 0)" endLine="(153, 57)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::heading() const">double VehicleState::heading() const { return heading_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(157, 0)" endLine="(157, 66)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::linear_velocity() const">double VehicleState::linear_velocity() const { return linear_v_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(155, 0)" endLine="(155, 53)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::kappa() const">double VehicleState::kappa() const { return kappa_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(159, 0)" endLine="(159, 68)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::angular_velocity() const">double VehicleState::angular_velocity() const { return angular_v_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(157, 0)" endLine="(157, 66)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::linear_velocity() const">double VehicleState::linear_velocity() const { return linear_v_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(161, 0)" endLine="(161, 72)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::linear_acceleration() const">double VehicleState::linear_acceleration() const { return linear_a_y_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(159, 0)" endLine="(159, 68)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::angular_velocity() const">double VehicleState::angular_velocity() const { return angular_v_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(163, 0)" endLine="(163, 51)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::gear() const">double VehicleState::gear() const { return gear_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\vehicle_state\vehicle_state.cc" startLine="(161, 0)" endLine="(161, 72)" clone_start="1" clone_end="1">
			<code function_name="VehicleState::linear_acceleration() const">double VehicleState::linear_acceleration() const { return linear_a_y_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\sub_topo_graph.cc" startLine="(118, 0)" endLine="(136, 1)" clone_start="1" clone_end="15">
			<code function_name="SubTopoGraph::GetSubInEdgesIntoSubGraph(const TopoEdge* edge, std::unordered_set&lt;const TopoEdge*&gt;* const sub_edges) const">void SubTopoGraph::GetSubInEdgesIntoSubGraph(
    const TopoEdge* edge,
    std::unordered_set&lt;const TopoEdge*&gt;* const sub_edges) const {
  const auto* from_node = edge-&gt;FromNode();
  const auto* to_node = edge-&gt;ToNode();
  std::unordered_set&lt;TopoNode*&gt; sub_nodes;
  if (from_node-&gt;IsSubNode() || to_node-&gt;IsSubNode() ||
      !GetSubNodes(to_node, &amp;sub_nodes)) {
    sub_edges-&gt;insert(edge);
    return;
  }
  for (const auto* sub_node : sub_nodes) {
    for (const auto* in_edge : sub_node-&gt;InFromAllEdge()) {
      if (in_edge-&gt;FromNode() == from_node) {
        sub_edges-&gt;insert(in_edge);
      }
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\sub_topo_graph.cc" startLine="(138, 0)" endLine="(156, 1)" clone_start="1" clone_end="15">
			<code function_name="SubTopoGraph::GetSubOutEdgesIntoSubGraph(    const TopoEdge* edge, std::unordered_set&lt;const TopoEdge*&gt;* const sub_edges) const">void SubTopoGraph::GetSubOutEdgesIntoSubGraph(
    const TopoEdge* edge,
    std::unordered_set&lt;const TopoEdge*&gt;* const sub_edges) const {
  const auto* from_node = edge-&gt;FromNode();
  const auto* to_node = edge-&gt;ToNode();
  std::unordered_set&lt;TopoNode*&gt; sub_nodes;
  if (from_node-&gt;IsSubNode() || to_node-&gt;IsSubNode() ||
      !GetSubNodes(from_node, &amp;sub_nodes)) {
    sub_edges-&gt;insert(edge);
    return;
  }
  for (const auto* sub_node : sub_nodes) {
    for (const auto* out_edge : sub_node-&gt;OutToAllEdge()) {
      if (out_edge-&gt;ToNode() == to_node) {
        sub_edges-&gt;insert(out_edge);
      }
    }
  }
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="68" clone_end="84">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length,
                        ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="169" clone_end="195">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(26, 0)" endLine="(41, 1)" clone_start="5" clone_end="16">
			<code function_name="Gps6e::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Gps6e::Parse(const std::uint8_t *bytes, int32_t length,
                  ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_basic()-&gt;set_year(year(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_month(month(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_day(day(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_hours(hours(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_minutes(minutes(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_seconds(seconds(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_compass_direction(
      compass_direction(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_pdop(pdop(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_is_gps_fault(
      is_gps_fault(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_is_inferred(
      is_inferred_position(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(111, 0)" endLine="(119, 1)" clone_start="1" clone_end="4">
			<code function_name="Brakeinfo74::braking_torque_request(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::braking_torque_request(const std::uint8_t *bytes,
                                           int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 4);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 4.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(222, 0)" endLine="(227, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::turn_signal_status(const std::uint8_t *bytes, int32_t length) const">int32_t Misc69::turn_signal_status(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(43, 0)" endLine="(47, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6e::year(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::year(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 7);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\opengl_visualizer.cc" startLine="(74, 0)" endLine="(87, 1)" clone_start="3" clone_end="13">
			<code function_name="OpenglVisualizer::SetCameraPosition()">void OpenglVisualizer::SetCameraPosition() {
  up_velodyne_.x = 0;
  up_velodyne_.y = 1;
  up_velodyne_.z = 0;
  forward_velodyne_.x = 1;
  forward_velodyne_.y = 0;
  forward_velodyne_.z = 0;
  view_point_velodyne_.x = 0;
  view_point_velodyne_.y = 0;
  view_point_velodyne_.z = 0;
  camera_center_velodyne_.x = 0;
  camera_center_velodyne_.y = 0;
  camera_center_velodyne_.z = 100;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\opengl_visualizer.cc" startLine="(74, 0)" endLine="(87, 1)" clone_start="2" clone_end="12">
			<code function_name="OpenglVisualizer::SetCameraPosition()">void OpenglVisualizer::SetCameraPosition() {
  up_velodyne_.x = 0;
  up_velodyne_.y = 1;
  up_velodyne_.z = 0;
  forward_velodyne_.x = 1;
  forward_velodyne_.y = 0;
  forward_velodyne_.z = 0;
  view_point_velodyne_.x = 0;
  view_point_velodyne_.y = 0;
  view_point_velodyne_.z = 0;
  camera_center_velodyne_.x = 0;
  camera_center_velodyne_.y = 0;
  camera_center_velodyne_.z = 100;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\interface\base_object_builder.h" startLine="(85, 2)" endLine="(139, 3)" clone_start="40" clone_end="53">
			<code function_name="SetDefaultValue(pcl_util::PointCloudPtr cloud, ObjectPtr obj,Eigen::Vector4f* min_pt, Eigen::Vector4f* max_pt)">  virtual void SetDefaultValue(pcl_util::PointCloudPtr cloud, ObjectPtr obj,
                               Eigen::Vector4f* min_pt,
                               Eigen::Vector4f* max_pt) {
    GetCloudMinMax3D&lt;pcl_util::Point&gt;(cloud, min_pt, max_pt);
    Eigen::Vector3f center(((*min_pt)[0] + (*max_pt)[0]) / 2,
                           ((*min_pt)[1] + (*max_pt)[1]) / 2,
                           ((*min_pt)[2] + (*max_pt)[2]) / 2);

    // handle degeneration case
    float epslin = 1e-3;
    for (int i = 0; i &lt; 3; i++) {
      if ((*max_pt)[i] - (*min_pt)[i] &lt; epslin) {
        (*max_pt)[i] = center[i] + epslin / 2;
        (*min_pt)[i] = center[i] - epslin / 2;
      }
    }

    // length
    obj-&gt;length = (*max_pt)[0] - (*min_pt)[0];
    // width
    obj-&gt;width = (*max_pt)[1] - (*min_pt)[1];
    if (obj-&gt;length - obj-&gt;width &lt; 0) {
      float tmp = obj-&gt;length;
      obj-&gt;length = obj-&gt;width;
      obj-&gt;width = tmp;
      obj-&gt;direction = Eigen::Vector3d(0.0, 1.0, 0.0);
    } else {
      obj-&gt;direction = Eigen::Vector3d(1.0, 0.0, 0.0);
    }
    // height
    obj-&gt;height = (*max_pt)[2] - (*min_pt)[2];
    // center
    obj-&gt;center = Eigen::Vector3d(((*max_pt)[0] + (*min_pt)[0]) / 2,
                                  ((*max_pt)[1] + (*min_pt)[1]) / 2,
                                  ((*max_pt)[2] + (*min_pt)[2]) / 2);
    // polygon
    if (cloud-&gt;size() &lt; 4) {
      obj-&gt;polygon.points.resize(4);
      obj-&gt;polygon.points[0].x = static_cast&lt;double&gt;((*min_pt)[0]);
      obj-&gt;polygon.points[0].y = static_cast&lt;double&gt;((*min_pt)[1]);
      obj-&gt;polygon.points[0].z = static_cast&lt;double&gt;((*min_pt)[2]);

      obj-&gt;polygon.points[1].x = static_cast&lt;double&gt;((*max_pt)[0]);
      obj-&gt;polygon.points[1].y = static_cast&lt;double&gt;((*min_pt)[1]);
      obj-&gt;polygon.points[1].z = static_cast&lt;double&gt;((*min_pt)[2]);

      obj-&gt;polygon.points[2].x = static_cast&lt;double&gt;((*max_pt)[0]);
      obj-&gt;polygon.points[2].y = static_cast&lt;double&gt;((*max_pt)[1]);
      obj-&gt;polygon.points[2].z = static_cast&lt;double&gt;((*min_pt)[2]);

      obj-&gt;polygon.points[3].x = static_cast&lt;double&gt;((*min_pt)[0]);
      obj-&gt;polygon.points[3].y = static_cast&lt;double&gt;((*max_pt)[1]);
      obj-&gt;polygon.points[3].z = static_cast&lt;double&gt;((*min_pt)[2]);
    }
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\interface\base_object_builder.h" startLine="(85, 2)" endLine="(139, 3)" clone_start="39" clone_end="52">
			<code function_name="SetDefaultValue(pcl_util::PointCloudPtr cloud, ObjectPtr obj,Eigen::Vector4f* min_pt, Eigen::Vector4f* max_pt)">  virtual void SetDefaultValue(pcl_util::PointCloudPtr cloud, ObjectPtr obj,
                               Eigen::Vector4f* min_pt,
                               Eigen::Vector4f* max_pt) {
    GetCloudMinMax3D&lt;pcl_util::Point&gt;(cloud, min_pt, max_pt);
    Eigen::Vector3f center(((*min_pt)[0] + (*max_pt)[0]) / 2,
                           ((*min_pt)[1] + (*max_pt)[1]) / 2,
                           ((*min_pt)[2] + (*max_pt)[2]) / 2);

    // handle degeneration case
    float epslin = 1e-3;
    for (int i = 0; i &lt; 3; i++) {
      if ((*max_pt)[i] - (*min_pt)[i] &lt; epslin) {
        (*max_pt)[i] = center[i] + epslin / 2;
        (*min_pt)[i] = center[i] - epslin / 2;
      }
    }

    // length
    obj-&gt;length = (*max_pt)[0] - (*min_pt)[0];
    // width
    obj-&gt;width = (*max_pt)[1] - (*min_pt)[1];
    if (obj-&gt;length - obj-&gt;width &lt; 0) {
      float tmp = obj-&gt;length;
      obj-&gt;length = obj-&gt;width;
      obj-&gt;width = tmp;
      obj-&gt;direction = Eigen::Vector3d(0.0, 1.0, 0.0);
    } else {
      obj-&gt;direction = Eigen::Vector3d(1.0, 0.0, 0.0);
    }
    // height
    obj-&gt;height = (*max_pt)[2] - (*min_pt)[2];
    // center
    obj-&gt;center = Eigen::Vector3d(((*max_pt)[0] + (*min_pt)[0]) / 2,
                                  ((*max_pt)[1] + (*min_pt)[1]) / 2,
                                  ((*max_pt)[2] + (*min_pt)[2]) / 2);
    // polygon
    if (cloud-&gt;size() &lt; 4) {
      obj-&gt;polygon.points.resize(4);
      obj-&gt;polygon.points[0].x = static_cast&lt;double&gt;((*min_pt)[0]);
      obj-&gt;polygon.points[0].y = static_cast&lt;double&gt;((*min_pt)[1]);
      obj-&gt;polygon.points[0].z = static_cast&lt;double&gt;((*min_pt)[2]);

      obj-&gt;polygon.points[1].x = static_cast&lt;double&gt;((*max_pt)[0]);
      obj-&gt;polygon.points[1].y = static_cast&lt;double&gt;((*min_pt)[1]);
      obj-&gt;polygon.points[1].z = static_cast&lt;double&gt;((*min_pt)[2]);

      obj-&gt;polygon.points[2].x = static_cast&lt;double&gt;((*max_pt)[0]);
      obj-&gt;polygon.points[2].y = static_cast&lt;double&gt;((*max_pt)[1]);
      obj-&gt;polygon.points[2].z = static_cast&lt;double&gt;((*min_pt)[2]);

      obj-&gt;polygon.points[3].x = static_cast&lt;double&gt;((*min_pt)[0]);
      obj-&gt;polygon.points[3].y = static_cast&lt;double&gt;((*max_pt)[1]);
      obj-&gt;polygon.points[3].z = static_cast&lt;double&gt;((*min_pt)[2]);
    }
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\path_obstacle.cc" startLine="(220, 0)" endLine="(259, 1)" clone_start="16" clone_end="26">
			<code function_name="PathObstacle::MergeLongitudinalDecision( const ObjectDecisionType&amp; lhs, const ObjectDecisionType&amp; rhs)">ObjectDecisionType PathObstacle::MergeLongitudinalDecision(
    const ObjectDecisionType&amp; lhs, const ObjectDecisionType&amp; rhs) {
  if (lhs.object_tag_case() == ObjectDecisionType::OBJECT_TAG_NOT_SET) {
    return rhs;
  }
  if (rhs.object_tag_case() == ObjectDecisionType::OBJECT_TAG_NOT_SET) {
    return lhs;
  }
  auto lhs_iter =
      s_longitudinal_decision_safety_sorter_.find(lhs.object_tag_case());
  DCHECK(lhs_iter != s_longitudinal_decision_safety_sorter_.end())
      &lt;&lt; "decision : " &lt;&lt; lhs.ShortDebugString()
      &lt;&lt; " not found in safety sorter";
  auto rhs_iter =
      s_longitudinal_decision_safety_sorter_.find(rhs.object_tag_case());
  DCHECK(rhs_iter != s_longitudinal_decision_safety_sorter_.end())
      &lt;&lt; "decision : " &lt;&lt; rhs.ShortDebugString()
      &lt;&lt; " not found in safety sorter";
  if (lhs_iter-&gt;second &lt; rhs_iter-&gt;second) {
    return rhs;
  } else if (lhs_iter-&gt;second &gt; rhs_iter-&gt;second) {
    return lhs;
  } else {
    if (lhs.has_ignore()) {
      return rhs;
    } else if (lhs.has_stop()) {
      return lhs.stop().distance_s() &lt; rhs.stop().distance_s() ? lhs : rhs;
    } else if (lhs.has_yield()) {
      return lhs.yield().distance_s() &lt; rhs.yield().distance_s() ? lhs : rhs;
    } else if (lhs.has_follow()) {
      return lhs.follow().distance_s() &lt; rhs.follow().distance_s() ? lhs : rhs;
    } else if (lhs.has_overtake()) {
      return lhs.overtake().distance_s() &gt; rhs.overtake().distance_s() ? lhs
                                                                       : rhs;
    } else {
      DCHECK(false) &lt;&lt; "Unknown decision";
    }
  }
  return lhs;  // stop compiler complaining
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\path_obstacle.cc" startLine="(273, 0)" endLine="(308, 1)" clone_start="14" clone_end="24">
			<code function_name="PathObstacle::MergeLateralDecision( const ObjectDecisionType&amp; lhs, const ObjectDecisionType&amp; rhs)">ObjectDecisionType PathObstacle::MergeLateralDecision(
    const ObjectDecisionType&amp; lhs, const ObjectDecisionType&amp; rhs) {
  if (lhs.object_tag_case() == ObjectDecisionType::OBJECT_TAG_NOT_SET) {
    return rhs;
  }
  if (rhs.object_tag_case() == ObjectDecisionType::OBJECT_TAG_NOT_SET) {
    return lhs;
  }
  auto lhs_iter = s_lateral_decision_safety_sorter_.find(lhs.object_tag_case());
  DCHECK(lhs_iter != s_lateral_decision_safety_sorter_.end())
      &lt;&lt; "decision : " &lt;&lt; lhs.ShortDebugString()
      &lt;&lt; " not found in safety sorter";
  auto rhs_iter = s_lateral_decision_safety_sorter_.find(rhs.object_tag_case());
  DCHECK(rhs_iter != s_lateral_decision_safety_sorter_.end())
      &lt;&lt; "decision : " &lt;&lt; rhs.ShortDebugString()
      &lt;&lt; " not found in safety sorter";
  if (lhs_iter-&gt;second &lt; rhs_iter-&gt;second) {
    return rhs;
  } else if (lhs_iter-&gt;second &gt; rhs_iter-&gt;second) {
    return lhs;
  } else {
    if (lhs.has_ignore()) {
      return rhs;
    } else if (lhs.has_nudge()) {
      DCHECK(lhs.nudge().type() == rhs.nudge().type())
          &lt;&lt; "could not merge left nudge and right nudge";
      return std::fabs(lhs.nudge().distance_l()) &gt;
                     std::fabs(rhs.nudge().distance_l())
                 ? lhs
                 : rhs;
    }
  }
  DCHECK(false) &lt;&lt; "Does not have rule to merge decision: "
                &lt;&lt; lhs.ShortDebugString()
                &lt;&lt; " and decision: " &lt;&lt; rhs.ShortDebugString();
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(575, 0)" endLine="(595, 1)" clone_start="10" clone_end="21">
			<code function_name="LanesXmlParser::ToPbTurnType(const std::string&amp; type, PbTurnType* pb_turn_type)">Status LanesXmlParser::ToPbTurnType(const std::string&amp; type,
                                    PbTurnType* pb_turn_type) {
  CHECK_NOTNULL(pb_turn_type);

  std::string upper_str = UtilXmlParser::ToUpper(type);

  if (upper_str == "NOTURN") {
    *pb_turn_type = hdmap::Lane::NO_TURN;
  } else if (upper_str == "LEFTTURN") {
    *pb_turn_type = hdmap::Lane::LEFT_TURN;
  } else if (upper_str == "RIGHTTURN") {
    *pb_turn_type = hdmap::Lane::RIGHT_TURN;
  } else if (upper_str == "UTURN") {
    *pb_turn_type = hdmap::Lane::U_TURN;
  } else {
    std::string err_msg = "Error or unsupport turn type:" + type;
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(553, 0)" endLine="(573, 1)" clone_start="10" clone_end="21">
			<code function_name="LanesXmlParser::ToPbLaneType(const std::string&amp; type, PbLaneType* lane_type)">Status LanesXmlParser::ToPbLaneType(const std::string&amp; type,
                                    PbLaneType* lane_type) {
  CHECK_NOTNULL(lane_type);

  std::string upper_str = UtilXmlParser::ToUpper(type);

  if (upper_str == "NONE") {
    *lane_type = hdmap::Lane::NONE;
  } else if (upper_str == "DRIVING") {
    *lane_type = hdmap::Lane::CITY_DRIVING;
  } else if (upper_str == "BIKING") {
    *lane_type = hdmap::Lane::BIKING;
  } else if (upper_str == "PARKING") {
    *lane_type = hdmap::Lane::PARKING;
  } else {
    std::string err_msg = "Error or unsupport lane type:" + type;
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(597, 0)" endLine="(615, 1)" clone_start="8" clone_end="19">
			<code function_name="LanesXmlParser::ToPbDirection(const std::string&amp; type, PbLaneDirection* pb_direction)">Status LanesXmlParser::ToPbDirection(const std::string&amp; type,
                                     PbLaneDirection* pb_direction) {
  CHECK_NOTNULL(pb_direction);

  std::string upper_str = UtilXmlParser::ToUpper(type);

  if (upper_str == "FORWARD") {
    *pb_direction = hdmap::Lane::FORWARD;
  } else if (upper_str == "BACKWARD") {
    *pb_direction = hdmap::Lane::BACKWARD;
  } else if (upper_str == "BIDIRECTION") {
    *pb_direction = hdmap::Lane::BIDIRECTION;
  } else {
    std::string err_msg = "Error or unsupport dirction:" + type;
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(597, 0)" endLine="(615, 1)" clone_start="1" clone_end="3">
			<code function_name="LanesXmlParser::ToPbDirection(const std::string&amp; type, PbLaneDirection* pb_direction)">Status LanesXmlParser::ToPbDirection(const std::string&amp; type,
                                     PbLaneDirection* pb_direction) {
  CHECK_NOTNULL(pb_direction);

  std::string upper_str = UtilXmlParser::ToUpper(type);

  if (upper_str == "FORWARD") {
    *pb_direction = hdmap::Lane::FORWARD;
  } else if (upper_str == "BACKWARD") {
    *pb_direction = hdmap::Lane::BACKWARD;
  } else if (upper_str == "BIDIRECTION") {
    *pb_direction = hdmap::Lane::BIDIRECTION;
  } else {
    std::string err_msg = "Error or unsupport dirction:" + type;
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(575, 0)" endLine="(595, 1)" clone_start="1" clone_end="3">
			<code function_name="LanesXmlParser::ToPbTurnType(const std::string&amp; type, PbTurnType* pb_turn_type)">Status LanesXmlParser::ToPbTurnType(const std::string&amp; type,
                                    PbTurnType* pb_turn_type) {
  CHECK_NOTNULL(pb_turn_type);

  std::string upper_str = UtilXmlParser::ToUpper(type);

  if (upper_str == "NOTURN") {
    *pb_turn_type = hdmap::Lane::NO_TURN;
  } else if (upper_str == "LEFTTURN") {
    *pb_turn_type = hdmap::Lane::LEFT_TURN;
  } else if (upper_str == "RIGHTTURN") {
    *pb_turn_type = hdmap::Lane::RIGHT_TURN;
  } else if (upper_str == "UTURN") {
    *pb_turn_type = hdmap::Lane::U_TURN;
  } else {
    std::string err_msg = "Error or unsupport turn type:" + type;
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(617, 0)" endLine="(664, 1)" clone_start="1" clone_end="3">
			<code function_name="LanesXmlParser::ParseLaneLink(const tinyxml2::XMLElement&amp; xml_node, PbLane* lane)">void LanesXmlParser::ParseLaneLink(const tinyxml2::XMLElement&amp; xml_node,
                                   PbLane* lane) {
  CHECK_NOTNULL(lane);

  const tinyxml2::XMLElement* sub_node =
      xml_node.FirstChildElement("predecessor");
  while (sub_node) {
    std::string lane_id;
    int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                    &amp;lane_id);
    if (checker == tinyxml2::XML_SUCCESS) {
      PbID* pb_lane_id = lane-&gt;add_predecessor_id();
      pb_lane_id-&gt;set_id(lane_id);
    }
    sub_node = sub_node-&gt;NextSiblingElement("predecessor");
  }

  sub_node = xml_node.FirstChildElement("successor");
  while (sub_node) {
    std::string lane_id;
    int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                    &amp;lane_id);
    if (checker == tinyxml2::XML_SUCCESS) {
      PbID* pb_lane_id = lane-&gt;add_successor_id();
      pb_lane_id-&gt;set_id(lane_id);
    }
    sub_node = sub_node-&gt;NextSiblingElement("successor");
  }
  sub_node = xml_node.FirstChildElement("neighbor");
  while (sub_node) {
    std::string side;
    std::string direction;
    std::string lane_id;
    int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                   &amp;lane_id);
    checker += UtilXmlParser::QueryStringAttribute(*sub_node, "side", &amp;side);
    checker +=
        UtilXmlParser::QueryStringAttribute(*sub_node, "direction", &amp;direction);
    if (checker == tinyxml2::XML_SUCCESS) {
      if (side == "left") {
        lane-&gt;add_left_neighbor_forward_lane_id()-&gt;set_id(lane_id);
      } else if (side == "right") {
        lane-&gt;add_right_neighbor_forward_lane_id()-&gt;set_id(lane_id);
      }
    }
    sub_node = sub_node-&gt;NextSiblingElement("neighbor");
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(46, 2)" endLine="(46, 16)" clone_start="1" clone_end="1">
			<code function_name="UdpStream()">  UdpStream() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(73, 2)" endLine="(73, 19)" clone_start="1" clone_end="1">
			<code function_name="SerialStream()">  SerialStream() {}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(53, 0)" endLine="(63, 1)" clone_start="1" clone_end="11">
			<code function_name="Gps6f::altitude(const std::uint8_t *bytes, int32_t length) const">double Gps6f::altitude(const std::uint8_t *bytes, int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.250000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gyro_6c.cc" startLine="(35, 0)" endLine="(45, 1)" clone_start="1" clone_end="11">
			<code function_name="Gyro6c::roll_rate(const std::uint8_t *bytes, int32_t length) const">double Gyro6c::roll_rate(const std::uint8_t *bytes, int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.000200;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(175, 0)" endLine="(187, 1)" clone_start="1" clone_end="13">
			<code function_name="Brakeinfo74::acceleration_over_ground(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::acceleration_over_ground(const std::uint8_t *bytes,
                                             int32_t length) const {
  // vehicle acceleration over ground estimate
  Byte frame_high(bytes + 7);
  int32_t high = frame_high.get_byte(0, 2);
  Byte frame_low(bytes + 6);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FF) {
    value -= 0x400;
  }
  return value * 0.035000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(162, 0)" endLine="(173, 1)" clone_start="1" clone_end="12">
			<code function_name="Brakeinfo74::wheel_torque_actual(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::wheel_torque_actual(const std::uint8_t *bytes,
                                        int32_t length) const {
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 6);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FFF) {
    value -= 0x4000;
  }
  return value * 4.000000;
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(65, 0)" endLine="(72, 1)" clone_start="1" clone_end="2">
			<code function_name="Gps6f::heading(const std::uint8_t *bytes, int32_t length) const">double Gps6f::heading(const std::uint8_t *bytes, int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gyro_6c.cc" startLine="(47, 0)" endLine="(57, 1)" clone_start="1" clone_end="2">
			<code function_name="Gyro6c::yaw_rate(const std::uint8_t *bytes, int32_t length) const">double Gyro6c::yaw_rate(const std::uint8_t *bytes, int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.000200;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(189, 0)" endLine="(193, 1)" clone_start="1" clone_end="3">
			<code function_name="Brakeinfo74::is_abs_active(const std::uint8_t *bytes, int32_t length) const">bool Brakeinfo74::is_abs_active(const std::uint8_t *bytes,
                                int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(175, 0)" endLine="(187, 1)" clone_start="1" clone_end="4">
			<code function_name="Brakeinfo74::acceleration_over_ground(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::acceleration_over_ground(const std::uint8_t *bytes,
                                             int32_t length) const {
  // vehicle acceleration over ground estimate
  Byte frame_high(bytes + 7);
  int32_t high = frame_high.get_byte(0, 2);
  Byte frame_low(bytes + 6);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FF) {
    value -= 0x400;
  }
  return value * 0.035000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_seg_kernel.cc" startLine="(46, 0)" endLine="(54, 1)" clone_start="1" clone_end="9">
			<code function_name="SplineSegKernel::DerivativeKernel(const std::uint32_t order, const double accumulated_x)">Eigen::MatrixXd SplineSegKernel::DerivativeKernel(const std::uint32_t order,
                                                  const double accumulated_x) {
  if (order &gt; reserved_order_) {
    CalculateDerivative(order);
  }
  Eigen::MatrixXd term_matrix;
  integrated_term_matrix(order, accumulated_x, "derivative", &amp;term_matrix);
  return kernel_derivative_.block(0, 0, order, order).cwiseProduct(term_matrix);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_seg_kernel.cc" startLine="(36, 0)" endLine="(44, 1)" clone_start="1" clone_end="9">
			<code function_name="SplineSegKernel::Kernel(const std::uint32_t order, const double accumulated_x)">Eigen::MatrixXd SplineSegKernel::Kernel(const std::uint32_t order,
                                        const double accumulated_x) {
  if (order &gt; reserved_order_) {
    calculate_fx(order);
  }
  Eigen::MatrixXd term_matrix;
  integrated_term_matrix(order, accumulated_x, "fx", &amp;term_matrix);
  return kernel_fx_.block(0, 0, order, order).cwiseProduct(term_matrix);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_seg_kernel.cc" startLine="(56, 0)" endLine="(65, 1)" clone_start="1" clone_end="7">
			<code function_name="SplineSegKernel::SecondOrderDerivativeKernel( const std::uint32_t order, const double accumulated_x)">Eigen::MatrixXd SplineSegKernel::SecondOrderDerivativeKernel(
    const std::uint32_t order, const double accumulated_x) {
  if (order &gt; reserved_order_) {
    CalculateSecondOrderDerivative(order);
  }
  Eigen::MatrixXd term_matrix;
  integrated_term_matrix(order, accumulated_x, "second_order", &amp;term_matrix);
  return kernel_second_order_derivative_.block(0, 0, order, order)
      .cwiseProduct(term_matrix);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_seg_kernel.cc" startLine="(46, 0)" endLine="(54, 1)" clone_start="1" clone_end="7">
			<code function_name="SplineSegKernel::DerivativeKernel(const std::uint32_t order, const double accumulated_x)">Eigen::MatrixXd SplineSegKernel::DerivativeKernel(const std::uint32_t order,
                                                  const double accumulated_x) {
  if (order &gt; reserved_order_) {
    CalculateDerivative(order);
  }
  Eigen::MatrixXd term_matrix;
  integrated_term_matrix(order, accumulated_x, "derivative", &amp;term_matrix);
  return kernel_derivative_.block(0, 0, order, order).cwiseProduct(term_matrix);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(492, 0)" endLine="(612, 1)" clone_start="15" clone_end="26">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  if (!chassis_detail.has_eps()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO eps."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_brake()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO brake."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gas()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gas."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gear()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gear."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR_EVERY(100) &lt;&lt; "Steering fault detected: "
                      &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR_EVERY(100) &lt;&lt; "Brake fault detected: "
                      &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR_EVERY(100) &lt;&lt; "Throttle fault detected: "
                      &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR_EVERY(100) &lt;&lt; "Gear fault detected: "
                      &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(492, 0)" endLine="(612, 1)" clone_start="59" clone_end="70">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  if (!chassis_detail.has_eps()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO eps."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_brake()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO brake."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gas()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gas."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gear()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gear."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR_EVERY(100) &lt;&lt; "Steering fault detected: "
                      &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR_EVERY(100) &lt;&lt; "Brake fault detected: "
                      &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR_EVERY(100) &lt;&lt; "Throttle fault detected: "
                      &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR_EVERY(100) &lt;&lt; "Gear fault detected: "
                      &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="228" clone_end="243">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="232" clone_end="248">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_constraint.cc" startLine="(71, 0)" endLine="(96, 1)" clone_start="1" clone_end="17">
			<code function_name="PiecewiseLinearConstraint::AddBoundary(const std::vector&lt;uint32_t&gt;&amp; index_list, const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool PiecewiseLinearConstraint::AddBoundary(
    const std::vector&lt;uint32_t&gt;&amp; index_list,
    const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  if (index_list.size() != lower_bound.size() ||
      index_list.size() != upper_bound.size()) {
    AERROR &lt;&lt; "The sizes of index list, lower_bound, upper_bound are not "
              "identical.";
    return false;
  }
  Eigen::MatrixXd inequality_matrix =
      Eigen::MatrixXd::Zero(2 * index_list.size(), dimension_);
  Eigen::MatrixXd inequality_boundary =
      Eigen::MatrixXd::Zero(2 * index_list.size(), 1);

  for (uint32_t i = 0; i &lt; index_list.size(); ++i) {
    uint32_t index = index_list[i];
    inequality_matrix(2 * i, index) = -1.0;
    inequality_boundary(2 * i, 0) = -upper_bound[i];
    inequality_matrix(2 * i + 1, index) = 1.0;
    inequality_boundary(2 * i + 1, 0) = lower_bound[i];
  }
  inequality_matrices_.push_back(inequality_matrix);
  inequality_boundaries_.push_back(inequality_boundary);
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_constraint.cc" startLine="(98, 0)" endLine="(131, 1)" clone_start="1" clone_end="17">
			<code function_name="PiecewiseLinearConstraint::AddDerivativeBoundary(    const std::vector&lt;uint32_t&gt;&amp; index_list,     const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool PiecewiseLinearConstraint::AddDerivativeBoundary(
    const std::vector&lt;uint32_t&gt;&amp; index_list,
    const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  if (index_list.size() != lower_bound.size() ||
      index_list.size() != upper_bound.size()) {
    AERROR &lt;&lt; "The sizes of index list, lower_bound, upper_bound are not "
              "identical.";
    return false;
  }
  Eigen::MatrixXd inequality_matrix =
      Eigen::MatrixXd::Zero(2 * index_list.size(), dimension_);
  Eigen::MatrixXd inequality_boundary =
      Eigen::MatrixXd::Zero(2 * index_list.size(), 1);

  for (uint32_t i = 0; i &lt; index_list.size(); ++i) {
    uint32_t index = index_list[i];
    if (index == 0) {
      AERROR &lt;&lt; "Index should NOT be 0.";
      return false;
    }

    inequality_matrix(2 * i, index - 1) = 1.0;
    inequality_matrix(2 * i, index) = -1.0;
    inequality_boundary(2 * i, 0) = -unit_segment_ * upper_bound[i];

    inequality_matrix(2 * i + 1, index - 1) = -1.0;
    inequality_matrix(2 * i + 1, index) = 1.0;
    inequality_boundary(2 * i, 0) = unit_segment_ * lower_bound[i];
  }
  inequality_matrices_.push_back(inequality_matrix);
  inequality_boundaries_.push_back(inequality_boundary);
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(435, 0)" endLine="(466, 1)" clone_start="15" clone_end="25">
			<code function_name="Obstacle::UpdateMotionBelief(Feature* feature)">void Obstacle::UpdateMotionBelief(Feature* feature) {
  auto state = kf_motion_tracker_.GetStateEstimate();
  feature-&gt;mutable_t_position()-&gt;set_x(state(0, 0));
  feature-&gt;mutable_t_position()-&gt;set_y(state(1, 0));
  feature-&gt;mutable_t_position()-&gt;set_z(0.0);
  feature-&gt;mutable_t_velocity()-&gt;set_x(state(2, 0));
  feature-&gt;mutable_t_velocity()-&gt;set_y(state(3, 0));
  feature-&gt;mutable_t_velocity()-&gt;set_z(0.0);
  feature-&gt;set_t_velocity_heading(std::atan2(state(3, 0), state(2, 0)));
  double acc_x = common::math::Clamp(state(4, 0), FLAGS_min_acc, FLAGS_max_acc);
  double acc_y = common::math::Clamp(state(5, 0), FLAGS_min_acc, FLAGS_max_acc);
  feature-&gt;mutable_t_acceleration()-&gt;set_x(acc_x);
  feature-&gt;mutable_t_acceleration()-&gt;set_y(acc_y);
  feature-&gt;mutable_t_acceleration()-&gt;set_z(0.0);
  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has tracked position [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; feature-&gt;t_position().x() &lt;&lt; ", "
         &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; feature-&gt;t_position().y()
         &lt;&lt; ", " &lt;&lt; std::fixed &lt;&lt; std::setprecision(6)
         &lt;&lt; feature-&gt;t_position().z() &lt;&lt; "]";
  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has tracked velocity [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; feature-&gt;t_velocity().x() &lt;&lt; ", "
         &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; feature-&gt;t_velocity().y()
         &lt;&lt; ", " &lt;&lt; std::fixed &lt;&lt; std::setprecision(6)
         &lt;&lt; feature-&gt;t_velocity().z() &lt;&lt; "]";
  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has tracked acceleration [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; feature-&gt;t_acceleration().x() &lt;&lt; ", "
         &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; feature-&gt;t_acceleration().y()
         &lt;&lt; ", " &lt;&lt; std::fixed &lt;&lt; std::setprecision(6)
         &lt;&lt; feature-&gt;t_acceleration().z() &lt;&lt; "]";
  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has velocity heading [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; feature-&gt;t_velocity_heading() &lt;&lt; "].";
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(435, 0)" endLine="(466, 1)" clone_start="20" clone_end="30">
			<code function_name="Obstacle::UpdateMotionBelief(Feature* feature)">void Obstacle::UpdateMotionBelief(Feature* feature) {
  auto state = kf_motion_tracker_.GetStateEstimate();
  feature-&gt;mutable_t_position()-&gt;set_x(state(0, 0));
  feature-&gt;mutable_t_position()-&gt;set_y(state(1, 0));
  feature-&gt;mutable_t_position()-&gt;set_z(0.0);
  feature-&gt;mutable_t_velocity()-&gt;set_x(state(2, 0));
  feature-&gt;mutable_t_velocity()-&gt;set_y(state(3, 0));
  feature-&gt;mutable_t_velocity()-&gt;set_z(0.0);
  feature-&gt;set_t_velocity_heading(std::atan2(state(3, 0), state(2, 0)));
  double acc_x = common::math::Clamp(state(4, 0), FLAGS_min_acc, FLAGS_max_acc);
  double acc_y = common::math::Clamp(state(5, 0), FLAGS_min_acc, FLAGS_max_acc);
  feature-&gt;mutable_t_acceleration()-&gt;set_x(acc_x);
  feature-&gt;mutable_t_acceleration()-&gt;set_y(acc_y);
  feature-&gt;mutable_t_acceleration()-&gt;set_z(0.0);
  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has tracked position [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; feature-&gt;t_position().x() &lt;&lt; ", "
         &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; feature-&gt;t_position().y()
         &lt;&lt; ", " &lt;&lt; std::fixed &lt;&lt; std::setprecision(6)
         &lt;&lt; feature-&gt;t_position().z() &lt;&lt; "]";
  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has tracked velocity [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; feature-&gt;t_velocity().x() &lt;&lt; ", "
         &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; feature-&gt;t_velocity().y()
         &lt;&lt; ", " &lt;&lt; std::fixed &lt;&lt; std::setprecision(6)
         &lt;&lt; feature-&gt;t_velocity().z() &lt;&lt; "]";
  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has tracked acceleration [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; feature-&gt;t_acceleration().x() &lt;&lt; ", "
         &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; feature-&gt;t_acceleration().y()
         &lt;&lt; ", " &lt;&lt; std::fixed &lt;&lt; std::setprecision(6)
         &lt;&lt; feature-&gt;t_acceleration().z() &lt;&lt; "]";
  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has velocity heading [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; feature-&gt;t_velocity_heading() &lt;&lt; "].";
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\simulation_world\simulation_world_service.cc" startLine="(215, 0)" endLine="(243, 1)" clone_start="10" clone_end="20">
			<code function_name="LocateMarker(const apollo::planning::ObjectDecisionType &amp;decision, Decision *world_decision)">bool LocateMarker(const apollo::planning::ObjectDecisionType &amp;decision,
                  Decision *world_decision) {
  apollo::common::PointENU fence_point;
  double heading;
  if (decision.has_stop() &amp;&amp; decision.stop().has_stop_point()) {
    world_decision-&gt;set_type(Decision_Type_STOP);
    fence_point = decision.stop().stop_point();
    heading = decision.stop().stop_heading();
  } else if (decision.has_follow() &amp;&amp; decision.follow().has_fence_point()) {
    world_decision-&gt;set_type(Decision_Type_FOLLOW);
    fence_point = decision.follow().fence_point();
    heading = decision.follow().fence_heading();
  } else if (decision.has_yield() &amp;&amp; decision.yield().has_fence_point()) {
    world_decision-&gt;set_type(Decision_Type_YIELD);
    fence_point = decision.yield().fence_point();
    heading = decision.yield().fence_heading();
  } else if (decision.has_overtake() &amp;&amp; decision.overtake().has_fence_point()) {
    world_decision-&gt;set_type(Decision_Type_OVERTAKE);
    fence_point = decision.overtake().fence_point();
    heading = decision.overtake().fence_heading();
  } else {
    return false;
  }

  world_decision-&gt;set_position_x(fence_point.x());
  world_decision-&gt;set_position_y(fence_point.y());
  world_decision-&gt;set_heading(heading);
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\simulation_world\simulation_world_service.cc" startLine="(215, 0)" endLine="(243, 1)" clone_start="6" clone_end="16">
			<code function_name="LocateMarker(const apollo::planning::ObjectDecisionType &amp;decision, Decision *world_decision)">bool LocateMarker(const apollo::planning::ObjectDecisionType &amp;decision,
                  Decision *world_decision) {
  apollo::common::PointENU fence_point;
  double heading;
  if (decision.has_stop() &amp;&amp; decision.stop().has_stop_point()) {
    world_decision-&gt;set_type(Decision_Type_STOP);
    fence_point = decision.stop().stop_point();
    heading = decision.stop().stop_heading();
  } else if (decision.has_follow() &amp;&amp; decision.follow().has_fence_point()) {
    world_decision-&gt;set_type(Decision_Type_FOLLOW);
    fence_point = decision.follow().fence_point();
    heading = decision.follow().fence_heading();
  } else if (decision.has_yield() &amp;&amp; decision.yield().has_fence_point()) {
    world_decision-&gt;set_type(Decision_Type_YIELD);
    fence_point = decision.yield().fence_point();
    heading = decision.yield().fence_heading();
  } else if (decision.has_overtake() &amp;&amp; decision.overtake().has_fence_point()) {
    world_decision-&gt;set_type(Decision_Type_OVERTAKE);
    fence_point = decision.overtake().fence_point();
    heading = decision.overtake().fence_heading();
  } else {
    return false;
  }

  world_decision-&gt;set_position_x(fence_point.x());
  world_decision-&gt;set_position_y(fence_point.y());
  world_decision-&gt;set_heading(heading);
  return true;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(89, 0)" endLine="(101, 1)" clone_start="12" clone_end="13">
			<code function_name="Steering65::reported_steering_angle_cmd(const std::uint8_t *bytes, int32_t length) const">double Steering65::reported_steering_angle_cmd(const std::uint8_t *bytes,
                                               int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x8000) {
    value = value - 0x10000;
  }

  return value * 0.100000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(53, 0)" endLine="(63, 1)" clone_start="10" clone_end="11">
			<code function_name="Gps6f::altitude(const std::uint8_t *bytes, int32_t length) const">double Gps6f::altitude(const std::uint8_t *bytes, int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.250000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(35, 0)" endLine="(43, 1)" clone_start="8" clone_end="9">
			<code function_name="Throttleinfo75::engine_rpm(const std::uint8_t *bytes, int32_t length) const">double Throttleinfo75::engine_rpm(const std::uint8_t *bytes,
                                  int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.25;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(103, 0)" endLine="(111, 1)" clone_start="1" clone_end="9">
			<code function_name="Steering65::vehicle_speed(const std::uint8_t *bytes, int32_t length) const">double Steering65::vehicle_speed(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(65, 0)" endLine="(72, 1)" clone_start="1" clone_end="8">
			<code function_name="Gps6f::heading(const std::uint8_t *bytes, int32_t length) const">double Gps6f::heading(const std::uint8_t *bytes, int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(45, 0)" endLine="(53, 1)" clone_start="1" clone_end="9">
			<code function_name="Throttleinfo75::acc_pedal_percent(const std::uint8_t *bytes, int32_t length) const">double Throttleinfo75::acc_pedal_percent(const std::uint8_t *bytes,
                                         int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 2);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.1;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(113, 0)" endLine="(121, 1)" clone_start="1" clone_end="4">
			<code function_name="Steering65::epas_torque(const std::uint8_t *bytes, int32_t length) const">double Steering65::epas_torque(const std::uint8_t *bytes,
                               int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 8);
  if (x &gt; 0x7F) {
    x -= 0x100;
  }
  return x * 0.062500;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(74, 0)" endLine="(78, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6f::speed(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6f::speed(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 8);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(55, 0)" endLine="(63, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttleinfo75::acc_pedal_rate(const std::uint8_t *bytes, int32_t length) const">double Throttleinfo75::acc_pedal_rate(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 8);
  if (x &gt; 0x3F) {
    x -= 0x100;
  }
  return x * 0.04;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(141, 0)" endLine="(264, 1)" clone_start="59" clone_end="72">
			<code function_name="RawStream::init(const std::string &amp;cfg_file)">bool RawStream::init(const std::string &amp;cfg_file) {
  if (!_stream_status) {
    ROS_ERROR_STREAM("New stream status failed.");
    return false;
  }
  _stream_status-&gt;mutable_header()-&gt;set_timestamp_sec(ros::Time::now().toSec());
  _stream_status-&gt;set_ins_stream_type(
      apollo::common::gnss_status::StreamStatus::DISCONNECTED);
  _stream_status-&gt;set_rtk_stream_in_type(
      apollo::common::gnss_status::StreamStatus::DISCONNECTED);
  _stream_status-&gt;set_rtk_stream_out_type(
      apollo::common::gnss_status::StreamStatus::DISCONNECTED);
  _stream_status_publisher.publish(_stream_status);
  if (!parse_config_text(cfg_file, &amp;_config)) {
    ROS_INFO("Parse config context failed.");
    return false;
  }
  ROS_INFO_STREAM("Loaded config:\n" &lt;&lt; _config.DebugString());

  // Creates streams.
  Stream *s = nullptr;
  if (!_config.has_data()) {
    ROS_INFO("Error: Config file must provide the data stream.");
    return false;
  }
  s = create_stream(_config.data());
  if (s == nullptr) {
    ROS_ERROR("Failed to create data stream.");
    return false;
  }
  _data_stream.reset(s);

  Status *status = new Status();
  if (!status) {
    ROS_ERROR("Failed to create data stream status.");
    return false;
  }
  _data_stream_status.reset(status);

  if (_config.has_command()) {
    s = create_stream(_config.command());
    if (s == nullptr) {
      ROS_ERROR("Failed to create command stream.");
      return false;
    }
    _command_stream.reset(s);

    status = new Status();
    if (!status) {
      ROS_ERROR("Failed to create command stream status.");
      return false;
    }
    _command_stream_status.reset(status);
  } else {
    _command_stream = _data_stream;
    _command_stream_status = _data_stream_status;
  }

  if (_config.has_rtk_from()) {
    s = create_stream(_config.rtk_from());
    if (s == nullptr) {
      ROS_ERROR("Failed to create rtk_from stream.");
      return false;
    }
    _in_rtk_stream.reset(s);

    status = new Status();
    if (!status) {
      ROS_ERROR("Failed to create rtk_from stream status.");
      return false;
    }
    _in_rtk_stream_status.reset(status);

    if (_config.has_rtk_to()) {
      s = create_stream(_config.rtk_to());
      if (s == nullptr) {
        ROS_ERROR("Failed to create rtk_to stream.");
        return false;
      }
      _out_rtk_stream.reset(s);

      status = new Status();
      if (!status) {
        ROS_ERROR("Failed to create rtk_to stream status.");
        return false;
      }
      _out_rtk_stream_status.reset(status);
    } else {
      _out_rtk_stream = _data_stream;
      _out_rtk_stream_status = _data_stream_status;
    }

    if (_config.has_rtk_solution_type()) {
      if (_config.rtk_solution_type() ==
          config::Config::RTK_SOFTWARE_SOLUTION) {
        _rtk_software_solution = true;
      }
    }
  }

  if (_config.login_commands_size() == 0) {
    ROS_WARN("No login_commands in config file.");
  }

  if (_config.logout_commands_size() == 0) {
    ROS_WARN("No logout_commands in config file.");
  }

  // connect and login
  if (!connect()) {
    ROS_ERROR("gnss driver connect failed.");
    return false;
  }

  if (!login()) {
    ROS_ERROR("gnss driver login failed.");
    return false;
  }

  _data_thread_ptr.reset(new std::thread(&amp;RawStream::data_spin, this));
  _ntrip_thread_ptr.reset(new std::thread(&amp;RawStream::ntrip_spin, this));

  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(141, 0)" endLine="(264, 1)" clone_start="40" clone_end="53">
			<code function_name="RawStream::init(const std::string &amp;cfg_file)">bool RawStream::init(const std::string &amp;cfg_file) {
  if (!_stream_status) {
    ROS_ERROR_STREAM("New stream status failed.");
    return false;
  }
  _stream_status-&gt;mutable_header()-&gt;set_timestamp_sec(ros::Time::now().toSec());
  _stream_status-&gt;set_ins_stream_type(
      apollo::common::gnss_status::StreamStatus::DISCONNECTED);
  _stream_status-&gt;set_rtk_stream_in_type(
      apollo::common::gnss_status::StreamStatus::DISCONNECTED);
  _stream_status-&gt;set_rtk_stream_out_type(
      apollo::common::gnss_status::StreamStatus::DISCONNECTED);
  _stream_status_publisher.publish(_stream_status);
  if (!parse_config_text(cfg_file, &amp;_config)) {
    ROS_INFO("Parse config context failed.");
    return false;
  }
  ROS_INFO_STREAM("Loaded config:\n" &lt;&lt; _config.DebugString());

  // Creates streams.
  Stream *s = nullptr;
  if (!_config.has_data()) {
    ROS_INFO("Error: Config file must provide the data stream.");
    return false;
  }
  s = create_stream(_config.data());
  if (s == nullptr) {
    ROS_ERROR("Failed to create data stream.");
    return false;
  }
  _data_stream.reset(s);

  Status *status = new Status();
  if (!status) {
    ROS_ERROR("Failed to create data stream status.");
    return false;
  }
  _data_stream_status.reset(status);

  if (_config.has_command()) {
    s = create_stream(_config.command());
    if (s == nullptr) {
      ROS_ERROR("Failed to create command stream.");
      return false;
    }
    _command_stream.reset(s);

    status = new Status();
    if (!status) {
      ROS_ERROR("Failed to create command stream status.");
      return false;
    }
    _command_stream_status.reset(status);
  } else {
    _command_stream = _data_stream;
    _command_stream_status = _data_stream_status;
  }

  if (_config.has_rtk_from()) {
    s = create_stream(_config.rtk_from());
    if (s == nullptr) {
      ROS_ERROR("Failed to create rtk_from stream.");
      return false;
    }
    _in_rtk_stream.reset(s);

    status = new Status();
    if (!status) {
      ROS_ERROR("Failed to create rtk_from stream status.");
      return false;
    }
    _in_rtk_stream_status.reset(status);

    if (_config.has_rtk_to()) {
      s = create_stream(_config.rtk_to());
      if (s == nullptr) {
        ROS_ERROR("Failed to create rtk_to stream.");
        return false;
      }
      _out_rtk_stream.reset(s);

      status = new Status();
      if (!status) {
        ROS_ERROR("Failed to create rtk_to stream status.");
        return false;
      }
      _out_rtk_stream_status.reset(status);
    } else {
      _out_rtk_stream = _data_stream;
      _out_rtk_stream_status = _data_stream_status;
    }

    if (_config.has_rtk_solution_type()) {
      if (_config.rtk_solution_type() ==
          config::Config::RTK_SOFTWARE_SOLUTION) {
        _rtk_software_solution = true;
      }
    }
  }

  if (_config.login_commands_size() == 0) {
    ROS_WARN("No login_commands in config file.");
  }

  if (_config.logout_commands_size() == 0) {
    ROS_WARN("No logout_commands in config file.");
  }

  // connect and login
  if (!connect()) {
    ROS_ERROR("gnss driver connect failed.");
    return false;
  }

  if (!login()) {
    ROS_ERROR("gnss driver login failed.");
    return false;
  }

  _data_thread_ptr.reset(new std::thread(&amp;RawStream::data_spin, this));
  _ntrip_thread_ptr.reset(new std::thread(&amp;RawStream::ntrip_spin, this));

  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(141, 0)" endLine="(264, 1)" clone_start="74" clone_end="87">
			<code function_name="RawStream::init(const std::string &amp;cfg_file)">bool RawStream::init(const std::string &amp;cfg_file) {
  if (!_stream_status) {
    ROS_ERROR_STREAM("New stream status failed.");
    return false;
  }
  _stream_status-&gt;mutable_header()-&gt;set_timestamp_sec(ros::Time::now().toSec());
  _stream_status-&gt;set_ins_stream_type(
      apollo::common::gnss_status::StreamStatus::DISCONNECTED);
  _stream_status-&gt;set_rtk_stream_in_type(
      apollo::common::gnss_status::StreamStatus::DISCONNECTED);
  _stream_status-&gt;set_rtk_stream_out_type(
      apollo::common::gnss_status::StreamStatus::DISCONNECTED);
  _stream_status_publisher.publish(_stream_status);
  if (!parse_config_text(cfg_file, &amp;_config)) {
    ROS_INFO("Parse config context failed.");
    return false;
  }
  ROS_INFO_STREAM("Loaded config:\n" &lt;&lt; _config.DebugString());

  // Creates streams.
  Stream *s = nullptr;
  if (!_config.has_data()) {
    ROS_INFO("Error: Config file must provide the data stream.");
    return false;
  }
  s = create_stream(_config.data());
  if (s == nullptr) {
    ROS_ERROR("Failed to create data stream.");
    return false;
  }
  _data_stream.reset(s);

  Status *status = new Status();
  if (!status) {
    ROS_ERROR("Failed to create data stream status.");
    return false;
  }
  _data_stream_status.reset(status);

  if (_config.has_command()) {
    s = create_stream(_config.command());
    if (s == nullptr) {
      ROS_ERROR("Failed to create command stream.");
      return false;
    }
    _command_stream.reset(s);

    status = new Status();
    if (!status) {
      ROS_ERROR("Failed to create command stream status.");
      return false;
    }
    _command_stream_status.reset(status);
  } else {
    _command_stream = _data_stream;
    _command_stream_status = _data_stream_status;
  }

  if (_config.has_rtk_from()) {
    s = create_stream(_config.rtk_from());
    if (s == nullptr) {
      ROS_ERROR("Failed to create rtk_from stream.");
      return false;
    }
    _in_rtk_stream.reset(s);

    status = new Status();
    if (!status) {
      ROS_ERROR("Failed to create rtk_from stream status.");
      return false;
    }
    _in_rtk_stream_status.reset(status);

    if (_config.has_rtk_to()) {
      s = create_stream(_config.rtk_to());
      if (s == nullptr) {
        ROS_ERROR("Failed to create rtk_to stream.");
        return false;
      }
      _out_rtk_stream.reset(s);

      status = new Status();
      if (!status) {
        ROS_ERROR("Failed to create rtk_to stream status.");
        return false;
      }
      _out_rtk_stream_status.reset(status);
    } else {
      _out_rtk_stream = _data_stream;
      _out_rtk_stream_status = _data_stream_status;
    }

    if (_config.has_rtk_solution_type()) {
      if (_config.rtk_solution_type() ==
          config::Config::RTK_SOFTWARE_SOLUTION) {
        _rtk_software_solution = true;
      }
    }
  }

  if (_config.login_commands_size() == 0) {
    ROS_WARN("No login_commands in config file.");
  }

  if (_config.logout_commands_size() == 0) {
    ROS_WARN("No logout_commands in config file.");
  }

  // connect and login
  if (!connect()) {
    ROS_ERROR("gnss driver connect failed.");
    return false;
  }

  if (!login()) {
    ROS_ERROR("gnss driver login failed.");
    return false;
  }

  _data_thread_ptr.reset(new std::thread(&amp;RawStream::data_spin, this));
  _ntrip_thread_ptr.reset(new std::thread(&amp;RawStream::ntrip_spin, this));

  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(55, 0)" endLine="(58, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_neutral()">Gear66 *Gear66::set_gear_neutral() {
  gear_ = 0x03;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\turnsignal_68.cc" startLine="(39, 0)" endLine="(42, 1)" clone_start="1" clone_end="4">
			<code function_name="Turnsignal68::set_turn_none()">Turnsignal68 *Turnsignal68::set_turn_none() {
  turn_cmd_ = 0x00;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(60, 0)" endLine="(63, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_drive()">Gear66 *Gear66::set_gear_drive() {
  gear_ = 0x04;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\turnsignal_68.cc" startLine="(44, 0)" endLine="(47, 1)" clone_start="1" clone_end="4">
			<code function_name="Turnsignal68::set_turn_left()">Turnsignal68 *Turnsignal68::set_turn_left() {
  turn_cmd_ = 0x01;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(65, 0)" endLine="(68, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_low()">Gear66 *Gear66::set_gear_low() {
  gear_ = 0x05;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\turnsignal_68.cc" startLine="(49, 0)" endLine="(52, 1)" clone_start="1" clone_end="4">
			<code function_name="Turnsignal68::set_turn_right()">Turnsignal68 *Turnsignal68::set_turn_right() {
  turn_cmd_ = 0x02;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(71, 0)" endLine="(75, 1)" clone_start="1" clone_end="2">
			<code function_name="Gear66::set_gear_p(uint8_t *data, int32_t gear)">void Gear66::set_gear_p(uint8_t *data, int32_t gear) {
  gear = ProtocolData::BoundedValue(0, 5, gear);
  Byte frame(data);
  frame.set_value(gear, 0, 3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\turnsignal_68.cc" startLine="(56, 0)" endLine="(60, 1)" clone_start="1" clone_end="2">
			<code function_name="Turnsignal68::set_turn_cmd_p(uint8_t *data, int32_t turn_cmd)">void Turnsignal68::set_turn_cmd_p(uint8_t *data, int32_t turn_cmd) {
  turn_cmd = ProtocolData::BoundedValue(0, 3, turn_cmd);
  Byte frame(data + 0);
  frame.set_value(turn_cmd, 0, 2);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6d.cc" startLine="(59, 0)" endLine="(83, 1)" clone_start="1" clone_end="13">
			<code function_name="Gps6d::longitude(const std::uint8_t *bytes, int32_t length) const">double Gps6d::longitude(const std::uint8_t *bytes, int32_t length) const {
  Byte frame_0(bytes + 7);
  int32_t value = frame_0.get_byte(0, 7);

  Byte frame_1(bytes + 6);
  int32_t t = frame_1.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_2(bytes + 5);
  t = frame_2.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_3(bytes + 4);
  t = frame_3.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  if (value &gt; 0x3FFFFFFF) {
    value -= 0x80000000;
  }

  return value * (1.000000 / 3.000000) * 1e-6;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6d.cc" startLine="(33, 0)" endLine="(57, 1)" clone_start="1" clone_end="13">
			<code function_name="Gps6d::latitude(const std::uint8_t *bytes, int32_t length) const">double Gps6d::latitude(const std::uint8_t *bytes, int32_t length) const {
  Byte frame_0(bytes + 3);
  int32_t value = frame_0.get_byte(0, 7);

  Byte frame_1(bytes + 2);
  int32_t t = frame_1.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_2(bytes + 1);
  t = frame_2.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  Byte frame_3(bytes);
  t = frame_3.get_byte(0, 8);
  value &lt;&lt;= 8;
  value |= t;

  if (value &gt; 0x3FFFFFFF) {
    value -= 0x80000000;
  }

  return value * (1.000000 / 3.000000) * 1e-6;
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(111, 0)" endLine="(151, 1)" clone_start="11" clone_end="24">
			<code function_name="ProtoOrganizer::GetLaneObjectOverlapElements(const std::string&amp; lane_id, const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes)">void ProtoOrganizer::GetLaneObjectOverlapElements(
    const std::string&amp; lane_id,
    const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes) {
  for (auto&amp; overlap_object : overlap_with_lanes) {
    std::string object_id = overlap_object.object_id;
    if (proto_data_.pb_crosswalks.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_clear_areas.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_speed_bumps.count(object_id) &lt;= 0) {
      continue;
    }
    PbOverlap overlap;
    std::string overlap_id = CreateOverlapId();
    proto_data_.pb_lanes[lane_id].add_overlap_id()-&gt;set_id(overlap_id);
    overlap.mutable_id()-&gt;set_id(overlap_id);
    PbObjectOverlapInfo* object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(lane_id);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_start_s(
        overlap_object.start_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_end_s(
        overlap_object.end_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_is_merge(
        overlap_object.is_merge);
    object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
    if (proto_data_.pb_crosswalks.count(object_id) &gt; 0) {
      proto_data_.pb_crosswalks[object_id].add_overlap_id()-&gt;set_id(overlap_id);
      object_overlap-&gt;mutable_crosswalk_overlap_info();
    } else if (proto_data_.pb_clear_areas.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_clear_area_overlap_info();
      proto_data_.pb_clear_areas[object_id].add_overlap_id()-&gt;set_id(
          overlap_id);
    } else if (proto_data_.pb_speed_bumps.count(object_id)) {
      object_overlap-&gt;mutable_speed_bump_overlap_info();
      proto_data_.pb_speed_bumps[object_id].add_overlap_id()-&gt;set_id(
          overlap_id);
    } else {
      AERROR &lt;&lt; "unknown object, object id:" &lt;&lt; object_id;
    }
    proto_data_.pb_overlaps[overlap_id] = overlap;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(228, 0)" endLine="(278, 1)" clone_start="18" clone_end="30">
			<code function_name="ProtoOrganizer::GetLaneLaneOverlapElements(const std::unordered_map&lt;std::pair&lt;std::string, std::string&gt;, OverlapWithLane, HashFunc&gt;&amp; lane_lane_overlaps)">void ProtoOrganizer::GetLaneLaneOverlapElements(
    const std::unordered_map&lt;std::pair&lt;std::string, std::string&gt;,
                             OverlapWithLane, HashFunc&gt;&amp; lane_lane_overlaps) {
  std::unordered_set&lt;std::string&gt; close_set;
  for (auto&amp; overlap_lane_pair : lane_lane_overlaps) {
    auto&amp; lane_id = overlap_lane_pair.first.first;
    auto&amp; overlap_lane = overlap_lane_pair.second;
    std::string object_id = overlap_lane.object_id;
    std::string unique_object_id = lane_id + "_" + object_id;
    if (close_set.count(unique_object_id) &gt; 0) {
      continue;
    }
    unique_object_id = object_id + "_" + lane_id;
    if (close_set.count(unique_object_id) &gt; 0) {
      continue;
    }
    close_set.insert(unique_object_id);
    PbOverlap overlap;
    std::string overlap_id = CreateOverlapId();
    proto_data_.pb_lanes[lane_id].add_overlap_id()-&gt;set_id(overlap_id);
    overlap.mutable_id()-&gt;set_id(overlap_id);
    PbObjectOverlapInfo* object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(lane_id);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_start_s(
        overlap_lane.start_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_end_s(overlap_lane.end_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_is_merge(
        overlap_lane.is_merge);
    object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
    if (proto_data_.pb_lanes.count(object_id) &lt;= 0) {
      AERROR &lt;&lt; "unknown overlap lane, id:" &lt;&lt; object_id;
      continue;
    }

    if (lane_lane_overlaps.count(make_pair(object_id, lane_id)) &lt;= 0) {
      AERROR &lt;&lt; "lane overlap is not symmetrical " &lt;&lt; overlap_id;
      continue;
    }
    auto&amp; lane_lane_overlap =
        lane_lane_overlaps.at(make_pair(object_id, lane_id));
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_start_s(
        lane_lane_overlap.start_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_end_s(
        lane_lane_overlap.end_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_is_merge(
        lane_lane_overlap.is_merge);
    proto_data_.pb_lanes[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    proto_data_.pb_overlaps[overlap_id] = overlap;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(153, 0)" endLine="(193, 1)" clone_start="12" clone_end="25">
			<code function_name="ProtoOrganizer::GetLaneSignalOverlapElements(    const std::string&amp; lane_id, const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes)">void ProtoOrganizer::GetLaneSignalOverlapElements(
    const std::string&amp; lane_id,
    const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes) {
  for (auto&amp; overlap_signal : overlap_with_lanes) {
    std::string object_id = overlap_signal.object_id;
    if (proto_data_.pb_signals.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_stop_signs.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_yield_signs.count(object_id) &lt;= 0) {
      AINFO &lt;&lt; "cannot find signal object_id:" &lt;&lt; object_id;
      continue;
    }
    PbOverlap overlap;
    std::string overlap_id = CreateOverlapId();
    proto_data_.pb_lanes[lane_id].add_overlap_id()-&gt;set_id(overlap_id);
    overlap.mutable_id()-&gt;set_id(overlap_id);
    PbObjectOverlapInfo* object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(lane_id);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_start_s(
        overlap_signal.start_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_end_s(
        overlap_signal.end_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_is_merge(
        overlap_signal.is_merge);
    object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
    if (proto_data_.pb_signals.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_signal_overlap_info();
      proto_data_.pb_signals[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    } else if (proto_data_.pb_stop_signs.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_stop_sign_overlap_info();
      proto_data_.pb_stop_signs[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    } else if (proto_data_.pb_yield_signs.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_yield_sign_overlap_info();
      proto_data_.pb_yield_signs[object_id].add_overlap_id()-&gt;set_id(
          overlap_id);
    } else {
      AERROR &lt;&lt; "unknown signal, signal id:" &lt;&lt; object_id;
    }
    proto_data_.pb_overlaps[overlap_id] = overlap;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(195, 0)" endLine="(226, 1)" clone_start="10" clone_end="23">
			<code function_name="ProtoOrganizer::GetLaneJunctionOverlapElements(    const std::string&amp; lane_id, const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes)">void ProtoOrganizer::GetLaneJunctionOverlapElements(
    const std::string&amp; lane_id,
    const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes) {
  for (auto&amp; overlap_junction : overlap_with_lanes) {
    std::string object_id = overlap_junction.object_id;
    if (proto_data_.pb_junctions.count(object_id) &lt;= 0) {
      AINFO &lt;&lt; "cannot find junction object " &lt;&lt; object_id;
      continue;
    }
    PbOverlap overlap;
    std::string overlap_id = CreateOverlapId();
    proto_data_.pb_lanes[lane_id].add_overlap_id()-&gt;set_id(overlap_id);
    overlap.mutable_id()-&gt;set_id(overlap_id);
    PbObjectOverlapInfo* object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(lane_id);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_start_s(
        overlap_junction.start_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_end_s(
        overlap_junction.end_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_is_merge(
        overlap_junction.is_merge);
    object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
    if (proto_data_.pb_junctions.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_junction_overlap_info();
      proto_data_.pb_junctions[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    } else {
      AERROR &lt;&lt; "unknown junction overlap, id:" &lt;&lt; object_id;
    }
    proto_data_.pb_overlaps[overlap_id] = overlap;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\control.cc" startLine="(216, 0)" endLine="(257, 1)" clone_start="11" clone_end="24">
			<code function_name="Control::CheckInput()">Status Control::CheckInput() {
  AdapterManager::Observe();
  auto localization_adapter = AdapterManager::GetLocalization();
  if (localization_adapter-&gt;Empty()) {
    AWARN_EVERY(100) &lt;&lt; "No Localization msg yet. ";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "No localization msg");
  }
  localization_ = localization_adapter-&gt;GetLatestObserved();
  ADEBUG &lt;&lt; "Received localization:" &lt;&lt; localization_.ShortDebugString();

  auto chassis_adapter = AdapterManager::GetChassis();
  if (chassis_adapter-&gt;Empty()) {
    AWARN_EVERY(100) &lt;&lt; "No Chassis msg yet. ";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "No chassis msg");
  }
  chassis_ = chassis_adapter-&gt;GetLatestObserved();
  ADEBUG &lt;&lt; "Received chassis:" &lt;&lt; chassis_.ShortDebugString();

  auto trajectory_adapter = AdapterManager::GetPlanning();
  if (trajectory_adapter-&gt;Empty()) {
    AWARN_EVERY(100) &lt;&lt; "No planning msg yet. ";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "No planning msg");
  }
  trajectory_ = trajectory_adapter-&gt;GetLatestObserved();
  if (!trajectory_.estop().is_estop() &amp;&amp;
      trajectory_.trajectory_point_size() == 0) {
    AWARN_EVERY(100) &lt;&lt; "planning has no trajectory point. ";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR,
                  "planning has no trajectory point.");
  }

  for (auto &amp;trajectory_point : *trajectory_.mutable_trajectory_point()) {
    if (trajectory_point.v() &lt; control_conf_.minimum_speed_resolution()) {
      trajectory_point.set_v(0.0);
      trajectory_point.set_a(0.0);
    }
  }

  common::VehicleState::instance()-&gt;Update(localization_, chassis_);

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\control.cc" startLine="(216, 0)" endLine="(257, 1)" clone_start="3" clone_end="16">
			<code function_name="Control::CheckInput()">Status Control::CheckInput() {
  AdapterManager::Observe();
  auto localization_adapter = AdapterManager::GetLocalization();
  if (localization_adapter-&gt;Empty()) {
    AWARN_EVERY(100) &lt;&lt; "No Localization msg yet. ";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "No localization msg");
  }
  localization_ = localization_adapter-&gt;GetLatestObserved();
  ADEBUG &lt;&lt; "Received localization:" &lt;&lt; localization_.ShortDebugString();

  auto chassis_adapter = AdapterManager::GetChassis();
  if (chassis_adapter-&gt;Empty()) {
    AWARN_EVERY(100) &lt;&lt; "No Chassis msg yet. ";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "No chassis msg");
  }
  chassis_ = chassis_adapter-&gt;GetLatestObserved();
  ADEBUG &lt;&lt; "Received chassis:" &lt;&lt; chassis_.ShortDebugString();

  auto trajectory_adapter = AdapterManager::GetPlanning();
  if (trajectory_adapter-&gt;Empty()) {
    AWARN_EVERY(100) &lt;&lt; "No planning msg yet. ";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, "No planning msg");
  }
  trajectory_ = trajectory_adapter-&gt;GetLatestObserved();
  if (!trajectory_.estop().is_estop() &amp;&amp;
      trajectory_.trajectory_point_size() == 0) {
    AWARN_EVERY(100) &lt;&lt; "planning has no trajectory point. ";
    return Status(ErrorCode::CONTROL_COMPUTE_ERROR,
                  "planning has no trajectory point.");
  }

  for (auto &amp;trajectory_point : *trajectory_.mutable_trajectory_point()) {
    if (trajectory_point.v() &lt; control_conf_.minimum_speed_resolution()) {
      trajectory_point.set_v(0.0);
      trajectory_point.set_a(0.0);
    }
  }

  common::VehicleState::instance()-&gt;Update(localization_, chassis_);

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\core\navigator.cc" startLine="(35, 0)" endLine="(78, 1)" clone_start="5" clone_end="17">
			<code function_name="ShowRequestInfo(const RoutingRequest&amp; request, const TopoGraph* graph)">bool ShowRequestInfo(const RoutingRequest&amp; request, const TopoGraph* graph) {
  const auto&amp; start = request.start();
  const auto&amp; end = request.end();
  const auto* node = graph-&gt;GetNode(start.id());
  if (node == nullptr) {
    AERROR &lt;&lt; "Start node is not found in topo graph! ID: " &lt;&lt; start.id();
    return false;
  }
  AINFO &lt;&lt; "Start point:\tlane id: " &lt;&lt; start.id() &lt;&lt; " s: " &lt;&lt; start.s()
        &lt;&lt; " x: " &lt;&lt; start.pose().x() &lt;&lt; " y: " &lt;&lt; start.pose().y()
        &lt;&lt; " length: " &lt;&lt; node-&gt;Length();

  for (const auto&amp; wp : request.waypoint()) {
    node = graph-&gt;GetNode(wp.id());
    if (node == nullptr) {
      AERROR &lt;&lt; "Way node is not found in topo graph! ID: " &lt;&lt; wp.id();
      return false;
    }
    AINFO &lt;&lt; "Way point:\tlane id: " &lt;&lt; wp.id() &lt;&lt; " s: " &lt;&lt; wp.s()
          &lt;&lt; " x: " &lt;&lt; wp.pose().x() &lt;&lt; " y: " &lt;&lt; wp.pose().y()
          &lt;&lt; " length: " &lt;&lt; node-&gt;Length();
  }

  for (const auto&amp; bl : request.blacklisted_lane()) {
    node = graph-&gt;GetNode(bl.id());
    if (node == nullptr) {
      AERROR &lt;&lt; "Black list node is not found in topo graph! ID: " &lt;&lt; bl.id();
      return false;
    }
    AINFO &lt;&lt; "Black point:\tlane id: " &lt;&lt; bl.id()
          &lt;&lt; " start_s: " &lt;&lt; bl.start_s() &lt;&lt; " end_s: " &lt;&lt; bl.end_s()
          &lt;&lt; " length: " &lt;&lt; node-&gt;Length();
  }

  node = graph-&gt;GetNode(end.id());
  if (node == nullptr) {
    AERROR &lt;&lt; "End node is not found in topo graph! ID: " &lt;&lt; end.id();
    return false;
  }
  AINFO &lt;&lt; "End point:\tlane id: " &lt;&lt; end.id() &lt;&lt; " s: " &lt;&lt; end.s()
        &lt;&lt; " x: " &lt;&lt; end.pose().x() &lt;&lt; " y: " &lt;&lt; end.pose().y()
        &lt;&lt; " length: " &lt;&lt; node-&gt;Length();
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\core\navigator.cc" startLine="(35, 0)" endLine="(78, 1)" clone_start="15" clone_end="28">
			<code function_name="ShowRequestInfo(const RoutingRequest&amp; request, const TopoGraph* graph)">bool ShowRequestInfo(const RoutingRequest&amp; request, const TopoGraph* graph) {
  const auto&amp; start = request.start();
  const auto&amp; end = request.end();
  const auto* node = graph-&gt;GetNode(start.id());
  if (node == nullptr) {
    AERROR &lt;&lt; "Start node is not found in topo graph! ID: " &lt;&lt; start.id();
    return false;
  }
  AINFO &lt;&lt; "Start point:\tlane id: " &lt;&lt; start.id() &lt;&lt; " s: " &lt;&lt; start.s()
        &lt;&lt; " x: " &lt;&lt; start.pose().x() &lt;&lt; " y: " &lt;&lt; start.pose().y()
        &lt;&lt; " length: " &lt;&lt; node-&gt;Length();

  for (const auto&amp; wp : request.waypoint()) {
    node = graph-&gt;GetNode(wp.id());
    if (node == nullptr) {
      AERROR &lt;&lt; "Way node is not found in topo graph! ID: " &lt;&lt; wp.id();
      return false;
    }
    AINFO &lt;&lt; "Way point:\tlane id: " &lt;&lt; wp.id() &lt;&lt; " s: " &lt;&lt; wp.s()
          &lt;&lt; " x: " &lt;&lt; wp.pose().x() &lt;&lt; " y: " &lt;&lt; wp.pose().y()
          &lt;&lt; " length: " &lt;&lt; node-&gt;Length();
  }

  for (const auto&amp; bl : request.blacklisted_lane()) {
    node = graph-&gt;GetNode(bl.id());
    if (node == nullptr) {
      AERROR &lt;&lt; "Black list node is not found in topo graph! ID: " &lt;&lt; bl.id();
      return false;
    }
    AINFO &lt;&lt; "Black point:\tlane id: " &lt;&lt; bl.id()
          &lt;&lt; " start_s: " &lt;&lt; bl.start_s() &lt;&lt; " end_s: " &lt;&lt; bl.end_s()
          &lt;&lt; " length: " &lt;&lt; node-&gt;Length();
  }

  node = graph-&gt;GetNode(end.id());
  if (node == nullptr) {
    AERROR &lt;&lt; "End node is not found in topo graph! ID: " &lt;&lt; end.id();
    return false;
  }
  AINFO &lt;&lt; "End point:\tlane id: " &lt;&lt; end.id() &lt;&lt; " s: " &lt;&lt; end.s()
        &lt;&lt; " x: " &lt;&lt; end.pose().x() &lt;&lt; " y: " &lt;&lt; end.pose().y()
        &lt;&lt; " length: " &lt;&lt; node-&gt;Length();
  return true;
}</code>
		</source>
	</dup>
	<dup count="8">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(146, 0)" endLine="(152, 1)" clone_start="1" clone_end="7">
			<code function_name="Brakeinfo74::hill_start_assist_mode(const std::uint8_t *bytes, int32_t length) const">int32_t Brakeinfo74::hill_start_assist_mode(const std::uint8_t *bytes,
                                            int32_t length) const {
  // see table for status code
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(4, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(229, 0)" endLine="(234, 1)" clone_start="1" clone_end="6">
			<code function_name="Misc69::high_beam_status(const std::uint8_t *bytes, int32_t length) const">int32_t Misc69::high_beam_status(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(2, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(222, 0)" endLine="(227, 1)" clone_start="1" clone_end="6">
			<code function_name="Misc69::turn_signal_status(const std::uint8_t *bytes, int32_t length) const">int32_t Misc69::turn_signal_status(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(67, 0)" endLine="(71, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::minutes(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::minutes(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(61, 0)" endLine="(65, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::hours(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::hours(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(55, 0)" endLine="(59, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::day(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::day(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 2);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(49, 0)" endLine="(53, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::month(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::month(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(43, 0)" endLine="(47, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::year(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::year(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 7);
  return x;
}</code>
		</source>
	</dup>
	<dup count="8">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(154, 0)" endLine="(160, 1)" clone_start="1" clone_end="7">
			<code function_name="Brakeinfo74::parking_brake_status(const std::uint8_t *bytes, int32_t length) const">int32_t Brakeinfo74::parking_brake_status(const std::uint8_t *bytes,
                                          int32_t length) const {
  // see table for status code
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(6, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(236, 0)" endLine="(240, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::wiper_status(const std::uint8_t *bytes, int32_t length) const">int32_t Misc69::wiper_status(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(229, 0)" endLine="(234, 1)" clone_start="1" clone_end="6">
			<code function_name="Misc69::high_beam_status(const std::uint8_t *bytes, int32_t length) const">int32_t Misc69::high_beam_status(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(2, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(73, 0)" endLine="(77, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::seconds(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::seconds(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 5);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(67, 0)" endLine="(71, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::minutes(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::minutes(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(61, 0)" endLine="(65, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::hours(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::hours(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(55, 0)" endLine="(59, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::day(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::day(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 2);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(49, 0)" endLine="(53, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::month(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::month(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 4);
  return x;
}</code>
		</source>
	</dup>
	<dup count="8">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(162, 0)" endLine="(173, 1)" clone_start="1" clone_end="4">
			<code function_name="Brakeinfo74::wheel_torque_actual(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::wheel_torque_actual(const std::uint8_t *bytes,
                                        int32_t length) const {
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 6);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FFF) {
    value -= 0x4000;
  }
  return value * 4.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(242, 0)" endLine="(247, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::ambient_light_status(const std::uint8_t *bytes, int32_t length) const">int32_t Misc69::ambient_light_status(const std::uint8_t *bytes,
                                     int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(236, 0)" endLine="(240, 1)" clone_start="1" clone_end="3">
			<code function_name="Misc69::wiper_status(const std::uint8_t *bytes, int32_t length) const">int32_t Misc69::wiper_status(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(79, 0)" endLine="(84, 1)" clone_start="1" clone_end="4">
			<code function_name="Gps6e::compass_direction(const std::uint8_t *bytes, int32_t length) const">double Gps6e::compass_direction(const std::uint8_t *bytes,
                                int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 4);
  return x * 45.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(73, 0)" endLine="(77, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6e::seconds(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::seconds(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 5);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(67, 0)" endLine="(71, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6e::minutes(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::minutes(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(61, 0)" endLine="(65, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6e::hours(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::hours(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(55, 0)" endLine="(59, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6e::day(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::day(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 2);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(267, 0)" endLine="(280, 1)" clone_start="11" clone_end="14">
			<code function_name="Spline1dConstraint::AddPointConstraint(const double x, const double fx)">bool Spline1dConstraint::AddPointConstraint(const double x, const double fx) {
  std::uint32_t index = FindIndex(x);
  std::vector&lt;double&gt; power_x;
  GeneratePowerX(x - x_knots_[index], spline_order_, &amp;power_x);
  Eigen::MatrixXd equality_constraint =
      Eigen::MatrixXd::Zero(1, (x_knots_.size() - 1) * spline_order_);
  std::uint32_t index_offset = index * spline_order_;
  for (std::uint32_t i = 0; i &lt; spline_order_; ++i) {
    equality_constraint(0, index_offset + i) = power_x[i];
  }
  Eigen::MatrixXd equality_boundary(1, 1);
  equality_boundary(0, 0) = fx;
  return AddEqualityConstraint(equality_constraint, equality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(282, 0)" endLine="(296, 1)" clone_start="12" clone_end="15">
			<code function_name="Spline1dConstraint::AddPointDerivativeConstraint(const double x, const double dfx)">bool Spline1dConstraint::AddPointDerivativeConstraint(const double x,
                                                      const double dfx) {
  std::uint32_t index = FindIndex(x);
  std::vector&lt;double&gt; power_x;
  GeneratePowerX(x - x_knots_[index], spline_order_, &amp;power_x);
  Eigen::MatrixXd equality_constraint =
      Eigen::MatrixXd::Zero(1, (x_knots_.size() - 1) * spline_order_);
  std::uint32_t index_offset = index * spline_order_;
  for (std::uint32_t i = 1; i &lt; spline_order_; ++i) {
    equality_constraint(0, index_offset + i) = power_x[i - 1] * i;
  }
  Eigen::MatrixXd equality_boundary(1, 1);
  equality_boundary(0, 0) = dfx;
  return AddEqualityConstraint(equality_constraint, equality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(298, 0)" endLine="(312, 1)" clone_start="12" clone_end="15">
			<code function_name="Spline1dConstraint::AddPointSecondDerivativeConstraint(const double x, const double ddfx)">bool Spline1dConstraint::AddPointSecondDerivativeConstraint(const double x,
                                                            const double ddfx) {
  std::uint32_t index = FindIndex(x);
  std::vector&lt;double&gt; power_x;
  GeneratePowerX(x - x_knots_[index], spline_order_, &amp;power_x);
  Eigen::MatrixXd equality_constraint =
      Eigen::MatrixXd::Zero(1, (x_knots_.size() - 1) * spline_order_);
  std::uint32_t index_offset = index * spline_order_;
  for (std::uint32_t i = 2; i &lt; spline_order_; ++i) {
    equality_constraint(0, index_offset + i) = power_x[i - 2] * i * (i - 1);
  }
  Eigen::MatrixXd equality_boundary(1, 1);
  equality_boundary(0, 0) = ddfx;
  return AddEqualityConstraint(equality_constraint, equality_boundary);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(282, 0)" endLine="(296, 1)" clone_start="1" clone_end="9">
			<code function_name="Spline1dConstraint::AddPointDerivativeConstraint(const double x, const double dfx)">bool Spline1dConstraint::AddPointDerivativeConstraint(const double x,
                                                      const double dfx) {
  std::uint32_t index = FindIndex(x);
  std::vector&lt;double&gt; power_x;
  GeneratePowerX(x - x_knots_[index], spline_order_, &amp;power_x);
  Eigen::MatrixXd equality_constraint =
      Eigen::MatrixXd::Zero(1, (x_knots_.size() - 1) * spline_order_);
  std::uint32_t index_offset = index * spline_order_;
  for (std::uint32_t i = 1; i &lt; spline_order_; ++i) {
    equality_constraint(0, index_offset + i) = power_x[i - 1] * i;
  }
  Eigen::MatrixXd equality_boundary(1, 1);
  equality_boundary(0, 0) = dfx;
  return AddEqualityConstraint(equality_constraint, equality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(298, 0)" endLine="(312, 1)" clone_start="1" clone_end="9">
			<code function_name="Spline1dConstraint::AddPointSecondDerivativeConstraint(const double x, const double ddfx)">bool Spline1dConstraint::AddPointSecondDerivativeConstraint(const double x,
                                                            const double ddfx) {
  std::uint32_t index = FindIndex(x);
  std::vector&lt;double&gt; power_x;
  GeneratePowerX(x - x_knots_[index], spline_order_, &amp;power_x);
  Eigen::MatrixXd equality_constraint =
      Eigen::MatrixXd::Zero(1, (x_knots_.size() - 1) * spline_order_);
  std::uint32_t index_offset = index * spline_order_;
  for (std::uint32_t i = 2; i &lt; spline_order_; ++i) {
    equality_constraint(0, index_offset + i) = power_x[i - 2] * i * (i - 1);
  }
  Eigen::MatrixXd equality_boundary(1, 1);
  equality_boundary(0, 0) = ddfx;
  return AddEqualityConstraint(equality_constraint, equality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(314, 0)" endLine="(329, 1)" clone_start="1" clone_end="9">
			<code function_name="Spline1dConstraint::AddPointThirdDerivativeConstraint(const double x, const double dddfx)">bool Spline1dConstraint::AddPointThirdDerivativeConstraint(const double x,
                                                           const double dddfx) {
  std::uint32_t index = FindIndex(x);
  std::vector&lt;double&gt; power_x;
  GeneratePowerX(x - x_knots_[index], spline_order_, &amp;power_x);
  Eigen::MatrixXd equality_constraint =
      Eigen::MatrixXd::Zero(1, (x_knots_.size() - 1) * spline_order_);
  std::uint32_t index_offset = index * spline_order_;
  for (std::uint32_t i = 3; i &lt; spline_order_; ++i) {
    equality_constraint(0, index_offset + i) =
        power_x[i - 3] * i * (i - 1) * (i - 2);
  }
  Eigen::MatrixXd equality_boundary(1, 1);
  equality_boundary(0, 0) = dddfx;
  return AddEqualityConstraint(equality_constraint, equality_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(33, 0)" endLine="(41, 1)" clone_start="4" clone_end="9">
			<code function_name="Steering64::UpdateData(uint8_t *data)">void Steering64::UpdateData(uint8_t *data) {
  set_steering_angle_p(data, steering_angle_);
  set_enable_p(data, steering_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_ignore_driver_override_p(data, ignore_driver_override_);
  set_steering_angle_speed_p(data, steering_angle_speed_);
  set_watchdog_counter_p(data, watchdog_counter_);
  set_disable_audible_warning_p(data, disable_audible_warning_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(33, 0)" endLine="(39, 1)" clone_start="2" clone_end="7">
			<code function_name="Throttle62::UpdateData(uint8_t *data)">void Throttle62::UpdateData(uint8_t *data) {
  set_pedal_p(data, pedal_cmd_);
  set_enable_p(data, pedal_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_ignore_driver_override_p(data, ignore_driver_override_);
  set_watchdog_counter_p(data, watchdog_counter_);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(43, 0)" endLine="(51, 1)" clone_start="1" clone_end="6">
			<code function_name="Steering64::Reset()">void Steering64::Reset() {
  steering_angle_ = 0.0;
  steering_enable_ = false;
  clear_driver_override_flag_ = false;
  ignore_driver_override_ = false;
  steering_angle_speed_ = 0.0;
  watchdog_counter_ = 0;
  disable_audible_warning_ = false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(41, 0)" endLine="(47, 1)" clone_start="1" clone_end="6">
			<code function_name="Throttle62::Reset()">void Throttle62::Reset() {
  pedal_cmd_ = 0.0;
  pedal_enable_ = false;
  clear_driver_override_flag_ = false;
  ignore_driver_override_ = false;
  watchdog_counter_ = 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\monitor\hwmonitor\hw\esdcan\esdcan_err_str.cc" startLine="(22, 0)" endLine="(127, 1)" clone_start="2" clone_end="12">
			<code function_name="esdcan_err_to_str(NTCAN_RESULT ntstatus)">const char *esdcan_err_to_str(NTCAN_RESULT ntstatus) {
  switch (ntstatus) {
    case NTCAN_SUCCESS:
      return "NTCAN_SUCCESS";
    case NTCAN_RX_TIMEOUT:
      return "NTCAN_RX_TIMEOUT";
    case NTCAN_TX_TIMEOUT:
      return "NTCAN_TX_TIMEOUT";
    case NTCAN_TX_ERROR:
      return "NTCAN_TX_ERROR";
    case NTCAN_CONTR_OFF_BUS:
      return "NTCAN_CONTR_OFF_BUS";
    case NTCAN_CONTR_BUSY:
      return "NTCAN_CONTR_BUSY";
    case NTCAN_CONTR_WARN:
      return "NTCAN_CONTR_WARN";
    case NTCAN_NO_ID_ENABLED:
      return "NTCAN_NO_ID_ENABLED";
    case NTCAN_ID_ALREADY_ENABLED:
      return "NTCAN_ID_ALREADY_ENABLED";
    case NTCAN_ID_NOT_ENABLED:
      return "NTCAN_ID_NOT_ENABLED";
    case NTCAN_INVALID_FIRMWARE:
      return "NTCAN_INVALID_FIRMWARE";
    case NTCAN_MESSAGE_LOST:
      return "NTCAN_MESSAGE_LOST";
    case NTCAN_INVALID_PARAMETER:
      return "NTCAN_INVALID_PARAMETER";
    case NTCAN_INVALID_HANDLE:
      return "NTCAN_INVALID_HANDLE";
    case NTCAN_NET_NOT_FOUND:
      return "NTCAN_NET_NOT_FOUND";
#ifdef NTCAN_IO_INCOMPLETE
    case NTCAN_IO_INCOMPLETE:
      return "NTCAN_IO_INCOMPLETE";
#endif
#ifdef NTCAN_IO_PENDING
    case NTCAN_IO_PENDING:
      return "NTCAN_IO_PENDING";
#endif
#ifdef NTCAN_INVALID_HARDWARE
    case NTCAN_INVALID_HARDWARE:
      return "NTCAN_INVALID_HARDWARE";
#endif
#ifdef NTCAN_PENDING_WRITE
    case NTCAN_PENDING_WRITE:
      return "NTCAN_PENDING_WRITE";
#endif
#ifdef NTCAN_PENDING_READ
    case NTCAN_PENDING_READ:
      return "NTCAN_PENDING_READ";
#endif
#ifdef NTCAN_INVALID_DRIVER
    case NTCAN_INVALID_DRIVER:
      return "NTCAN_INVALID_DRIVER";
#endif
#ifdef NTCAN_OPERATION_ABORTED
    case NTCAN_OPERATION_ABORTED:
      return "NTCAN_OPERATION_ABORTED";
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
    case NTCAN_WRONG_DEVICE_STATE:
      return "NTCAN_WRONG_DEVICE_STATE";
#endif
    case NTCAN_INSUFFICIENT_RESOURCES:
      return "NTCAN_INSUFFICIENT_RESOURCES";
#ifdef NTCAN_HANDLE_FORCED_CLOSE
    case NTCAN_HANDLE_FORCED_CLOSE:
      return "NTCAN_HANDLE_FORCED_CLOSE";
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
    case NTCAN_NOT_IMPLEMENTED:
      return "NTCAN_NOT_IMPLEMENTED";
#endif
#ifdef NTCAN_NOT_SUPPORTED
    case NTCAN_NOT_SUPPORTED:
      return "NTCAN_NOT_SUPPORTED";
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
    case NTCAN_SOCK_CONN_TIMEOUT:
      return "NTCAN_SOCK_CONN_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
    case NTCAN_SOCK_CMD_TIMEOUT:
      return "NTCAN_SOCK_CMD_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
    case NTCAN_SOCK_HOST_NOT_FOUND:
      return "NTCAN_SOCK_HOST_NOT_FOUND";
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
    case NTCAN_CONTR_ERR_PASSIVE:
      return "NTCAN_CONTR_ERR_PASSIVE";
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
    case NTCAN_ERROR_NO_BAUDRATE:
      return "NTCAN_ERROR_NO_BAUDRATE";
#endif
#ifdef NTCAN_ERROR_LOM
    case NTCAN_ERROR_LOM:
      return "NTCAN_ERROR_LOM";
#endif
    default:
      return "NTCAN_UNKNOWN";
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\base\types.cc" startLine="(21, 0)" endLine="(35, 1)" clone_start="2" clone_end="12">
			<code function_name="GetSensorType(SensorType sensor_type)">std::string GetSensorType(SensorType sensor_type) {
  switch (sensor_type) {
    case VELODYNE_64:
      return "velodyne_64";
    case VELODYNE_16:
      return "velodyne_16";
    case RADAR:
      return "radar";
    case CAMERA:
      return "camera";
    case UNKNOWN_SENSOR_TYPE:
      return "unknown_sensor_type";
  }
  return "";
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\objects_xml_parser.cc" startLine="(26, 0)" endLine="(57, 1)" clone_start="20" clone_end="32">
			<code function_name="ObjectsXmlParser::ParseCrosswalks(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;PbCrosswalk&gt;* crosswalks)">Status ObjectsXmlParser::ParseCrosswalks(const tinyxml2::XMLElement&amp; xml_node,
                                         std::vector&lt;PbCrosswalk&gt;* crosswalks) {
  CHECK_NOTNULL(crosswalks);
  const tinyxml2::XMLElement* sub_node = xml_node.FirstChildElement("object");
  while (sub_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*sub_node, "type", &amp;object_type);
    checker += UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse object type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "crosswalk") {
      PbCrosswalk crosswalk;
      crosswalk.mutable_id()-&gt;set_id(object_id);
      PbPolygon* polygon = crosswalk.mutable_polygon();
      const tinyxml2::XMLElement* outline_node =
          sub_node-&gt;FirstChildElement("outline");
      if (outline_node == nullptr) {
        std::string err_msg = "Error parse crosswalk outline";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseOutline(*outline_node, polygon));
      crosswalks-&gt;emplace_back(crosswalk);
    }
    sub_node = sub_node-&gt;NextSiblingElement("object");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\objects_xml_parser.cc" startLine="(59, 0)" endLine="(94, 1)" clone_start="23" clone_end="36">
			<code function_name="ObjectsXmlParser::ParseClearAreas(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;PbClearArea&gt;* clear_areas)">Status ObjectsXmlParser::ParseClearAreas(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;PbClearArea&gt;* clear_areas) {
  CHECK_NOTNULL(clear_areas);
  const tinyxml2::XMLElement* sub_node = xml_node.FirstChildElement("object");
  while (sub_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
    checker +=
        UtilXmlParser::QueryStringAttribute(*sub_node, "type", &amp;object_type);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse object type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "clearArea") {
      PbClearArea clear_area;
      clear_area.mutable_id()-&gt;set_id(object_id);
      PbPolygon* polygon = clear_area.mutable_polygon();
      CHECK(polygon != nullptr);
      const tinyxml2::XMLElement* outline_node =
          sub_node-&gt;FirstChildElement("outline");
      if (outline_node == nullptr) {
        std::string err_msg = "Error parse cleararea outline";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseOutline(*outline_node, polygon));
      clear_areas-&gt;emplace_back(clear_area);
    }
    sub_node = sub_node-&gt;NextSiblingElement("object");
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\objects_xml_parser.cc" startLine="(59, 0)" endLine="(94, 1)" clone_start="1" clone_end="4">
			<code function_name="ObjectsXmlParser::ParseClearAreas(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;PbClearArea&gt;* clear_areas)">Status ObjectsXmlParser::ParseClearAreas(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;PbClearArea&gt;* clear_areas) {
  CHECK_NOTNULL(clear_areas);
  const tinyxml2::XMLElement* sub_node = xml_node.FirstChildElement("object");
  while (sub_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
    checker +=
        UtilXmlParser::QueryStringAttribute(*sub_node, "type", &amp;object_type);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse object type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "clearArea") {
      PbClearArea clear_area;
      clear_area.mutable_id()-&gt;set_id(object_id);
      PbPolygon* polygon = clear_area.mutable_polygon();
      CHECK(polygon != nullptr);
      const tinyxml2::XMLElement* outline_node =
          sub_node-&gt;FirstChildElement("outline");
      if (outline_node == nullptr) {
        std::string err_msg = "Error parse cleararea outline";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseOutline(*outline_node, polygon));
      clear_areas-&gt;emplace_back(clear_area);
    }
    sub_node = sub_node-&gt;NextSiblingElement("object");
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\objects_xml_parser.cc" startLine="(96, 0)" endLine="(134, 1)" clone_start="1" clone_end="4">
			<code function_name="ObjectsXmlParser::ParseSpeedBumps(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;PbSpeedBump&gt;* speed_bumps)">Status ObjectsXmlParser::ParseSpeedBumps(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;PbSpeedBump&gt;* speed_bumps) {
  CHECK_NOTNULL(speed_bumps);
  const tinyxml2::XMLElement* object_node =
      xml_node.FirstChildElement("object");
  while (object_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*object_node, "id", &amp;object_id);
    checker +=
        UtilXmlParser::QueryStringAttribute(*object_node, "type", &amp;object_type);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse object type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "speedBump") {
      PbSpeedBump speed_bump;
      const tinyxml2::XMLElement* sub_node =
          object_node-&gt;FirstChildElement("geometry");
      speed_bump.mutable_id()-&gt;set_id(object_id);
      while (sub_node) {
        PbCurve* curve = speed_bump.add_position();
        PbCurveSegment* curve_segment = curve-&gt;add_segment();
        RETURN_IF_ERROR(UtilXmlParser::ParseGeometry(*sub_node, curve_segment));
        sub_node = sub_node-&gt;NextSiblingElement("geometry");
      }
      if (speed_bump.position_size() &lt;= 0) {
        std::string err_msg = "Error speed bump miss stop line.";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      speed_bumps-&gt;emplace_back(speed_bump);
    }
    object_node = object_node-&gt;NextSiblingElement("object");
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(63, 0)" endLine="(66, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMap::GetJunctions(const apollo::common::PointENU&amp; point, double distance, std::vector&lt;JunctionInfoConstPtr&gt;* junctions) const">int HDMap::GetJunctions(const apollo::common::PointENU&amp; point, double distance,
                        std::vector&lt;JunctionInfoConstPtr&gt;* junctions) const {
  return impl_.GetJunctions(point, distance, junctions);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(58, 0)" endLine="(61, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMap::GetLanes(const apollo::common::PointENU&amp; point, double distance, std::vector&lt;LaneInfoConstPtr&gt;* lanes) const">int HDMap::GetLanes(const apollo::common::PointENU&amp; point, double distance,
                    std::vector&lt;LaneInfoConstPtr&gt;* lanes) const {
  return impl_.GetLanes(point, distance, lanes);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(68, 0)" endLine="(71, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMap::GetSignals(const apollo::common::PointENU&amp; point, double distance, std::vector&lt;SignalInfoConstPtr&gt;* signals) const">int HDMap::GetSignals(const apollo::common::PointENU&amp; point, double distance,
                      std::vector&lt;SignalInfoConstPtr&gt;* signals) const {
  return impl_.GetSignals(point, distance, signals);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(63, 0)" endLine="(66, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMap::GetJunctions(const apollo::common::PointENU&amp; point, double distance, std::vector&lt;JunctionInfoConstPtr&gt;* junctions) const">int HDMap::GetJunctions(const apollo::common::PointENU&amp; point, double distance,
                        std::vector&lt;JunctionInfoConstPtr&gt;* junctions) const {
  return impl_.GetJunctions(point, distance, junctions);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(73, 0)" endLine="(76, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMap::GetCrosswalks(const apollo::common::PointENU&amp; point, double distance, std::vector&lt;CrosswalkInfoConstPtr&gt;* crosswalks) const">int HDMap::GetCrosswalks(const apollo::common::PointENU&amp; point, double distance,
                         std::vector&lt;CrosswalkInfoConstPtr&gt;* crosswalks) const {
  return impl_.GetCrosswalks(point, distance, crosswalks);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(68, 0)" endLine="(71, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMap::GetSignals(const apollo::common::PointENU&amp; point, double distance, std::vector&lt;SignalInfoConstPtr&gt;* signals) const">int HDMap::GetSignals(const apollo::common::PointENU&amp; point, double distance,
                      std::vector&lt;SignalInfoConstPtr&gt;* signals) const {
  return impl_.GetSignals(point, distance, signals);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(78, 0)" endLine="(81, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMap::GetStopSigns(const apollo::common::PointENU&amp; point, double distance, std::vector&lt;StopSignInfoConstPtr&gt;* stop_signs) const">int HDMap::GetStopSigns(const apollo::common::PointENU&amp; point, double distance,
                        std::vector&lt;StopSignInfoConstPtr&gt;* stop_signs) const {
  return impl_.GetStopSigns(point, distance, stop_signs);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(73, 0)" endLine="(76, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMap::GetCrosswalks(const apollo::common::PointENU&amp; point, double distance, std::vector&lt;CrosswalkInfoConstPtr&gt;* crosswalks) const">int HDMap::GetCrosswalks(const apollo::common::PointENU&amp; point, double distance,
                         std::vector&lt;CrosswalkInfoConstPtr&gt;* crosswalks) const {
  return impl_.GetCrosswalks(point, distance, crosswalks);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(83, 0)" endLine="(87, 1)" clone_start="1" clone_end="5">
			<code function_name="HDMap::GetYieldSigns(const apollo::common::PointENU&amp; point, double distance, std::vector&lt;YieldSignInfoConstPtr&gt;* yield_signs) const">int HDMap::GetYieldSigns(
    const apollo::common::PointENU&amp; point, double distance,
    std::vector&lt;YieldSignInfoConstPtr&gt;* yield_signs) const {
  return impl_.GetYieldSigns(point, distance, yield_signs);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(78, 0)" endLine="(81, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMap::GetStopSigns(const apollo::common::PointENU&amp; point, double distance, std::vector&lt;StopSignInfoConstPtr&gt;* stop_signs) const">int HDMap::GetStopSigns(const apollo::common::PointENU&amp; point, double distance,
                        std::vector&lt;StopSignInfoConstPtr&gt;* stop_signs) const {
  return impl_.GetStopSigns(point, distance, stop_signs);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(89, 0)" endLine="(92, 1)" clone_start="1" clone_end="3">
			<code function_name="HDMap::GetRoads(const apollo::common::PointENU&amp; point, double distance, std::vector&lt;RoadInfoConstPtr&gt;* roads) const">int HDMap::GetRoads(const apollo::common::PointENU&amp; point, double distance,
                    std::vector&lt;RoadInfoConstPtr&gt;* roads) const {
  return impl_.GetRoads(point, distance, roads);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(83, 0)" endLine="(87, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMap::GetYieldSigns(const apollo::common::PointENU&amp; point, double distance, std::vector&lt;YieldSignInfoConstPtr&gt;* yield_signs) const">int HDMap::GetYieldSigns(
    const apollo::common::PointENU&amp; point, double distance,
    std::vector&lt;YieldSignInfoConstPtr&gt;* yield_signs) const {
  return impl_.GetYieldSigns(point, distance, yield_signs);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.cc" startLine="(133, 0)" endLine="(318, 1)" clone_start="146" clone_end="157">
			<code function_name="MinBoxObjectBuilder::ReconstructPolygon(const Eigen::Vector3d &amp;ref_ct, ObjectPtr obj)">void  MinBoxObjectBuilder::ReconstructPolygon(
        const Eigen::Vector3d &amp;ref_ct,
        ObjectPtr obj) {
    if (obj-&gt;polygon.points.size() &lt;= 0) {
        return;
    }
    size_t max_point_index = 0;
    size_t min_point_index = 0;
    Eigen::Vector3d p;
    p[0] = obj-&gt;polygon.points[0].x;
    p[1] = obj-&gt;polygon.points[0].y;
    p[2] = obj-&gt;polygon.points[0].z;
    Eigen::Vector3d max_point = p - ref_ct;
    Eigen::Vector3d min_point = p - ref_ct;
    for (size_t i = 1; i &lt; obj-&gt;polygon.points.size(); ++i) {
        Eigen::Vector3d p;
        p[0] = obj-&gt;polygon.points[i].x;
        p[1] = obj-&gt;polygon.points[i].y;
        p[2] = obj-&gt;polygon.points[i].z;
        Eigen::Vector3d ray = p - ref_ct;
        // clock direction
        if (max_point[0] * ray[1] - ray[0] * max_point[1] &lt; EPSILON) {
            max_point = ray;
            max_point_index = i;
        }
        // unclock direction
        if (min_point[0] * ray[1] - ray[0] * min_point[1] &gt; EPSILON) {
            min_point = ray;
            min_point_index = i;
        }
    }
    Eigen::Vector3d line = max_point - min_point;
    double total_len = 0;
    double max_dis = 0;
    bool has_out = false;
    for (size_t i = min_point_index, count = 0;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist = sqrt((p[0] - p_x[0]) * (p[0] - p_x[0])
                        + (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist - max_dis &gt; EPSILON) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                   || (i == max_point_index &amp;&amp; j == min_point_index)) {
            size_t k = (j + 1) % obj-&gt;polygon.points.size();
            Eigen::Vector3d p_k;
            p_k[0] = obj-&gt;polygon.points[k].x;
            p_k[1] = obj-&gt;polygon.points[k].y;
            p_k[2] = obj-&gt;polygon.points[k].z;
            Eigen::Vector3d p_j;
            p_j[0] = obj-&gt;polygon.points[j].x;
            p_j[1] = obj-&gt;polygon.points[j].y;
            p_j[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
            } else {
                // outline
                has_out = true;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p_x - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist =
                        sqrt((p[0] - p_x[0]) * (p[0] - p_x[0]) +
                            (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist &gt; max_dis) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        }
    }
    size_t count = 0;
    double min_area = std::numeric_limits&lt;double&gt;::max();
    for (size_t i = min_point_index;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        Eigen::Vector3d p_j;
        p_j[0] = obj-&gt;polygon.points[j].x;
        p_j[1] = obj-&gt;polygon.points[j].y;
        p_j[2] = obj-&gt;polygon.points[j].z;
        double dist = sqrt((p_x[0] - p_j[0]) * (p_x[0] - p_j[0])
                + (p_x[1] - p_j[1])* (p_x[1] - p_j[1]));
        if (dist &lt; max_dis &amp;&amp; (dist / total_len) &lt; 0.5) {
            continue;
        }
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0;
                double width = 0;
                Eigen::Vector3d dir;
                double area =
                    ComputeAreaAlongOneEdge(obj, i,
                                        &amp;center, &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                    || (i == max_point_index &amp;&amp; j == min_point_index)) {
            if (!has_out) {
                continue;
            }
            Eigen::Vector3d center;
            double length = 0;
            double width = 0;
            Eigen::Vector3d dir;
            double area =
               ComputeAreaAlongOneEdge(obj, i, &amp;center, &amp;length, &amp;width, &amp;dir);
            if (area &lt; min_area) {
                obj-&gt;center = center;
                obj-&gt;length = length;
                obj-&gt;width = width;
                obj-&gt;direction = dir;
                min_area = area;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[i].x;
            p[1] = obj-&gt;polygon.points[i].y;
            p[2] = obj-&gt;polygon.points[i].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0.0;
                double width = 0.0;
                Eigen::Vector3d dir;
                double area =
                   ComputeAreaAlongOneEdge(obj, i, &amp;center,
                                           &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        }
    }
    obj-&gt;direction.normalize();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.cc" startLine="(133, 0)" endLine="(318, 1)" clone_start="124" clone_end="136">
			<code function_name="MinBoxObjectBuilder::ReconstructPolygon(const Eigen::Vector3d &amp;ref_ct, ObjectPtr obj)">void  MinBoxObjectBuilder::ReconstructPolygon(
        const Eigen::Vector3d &amp;ref_ct,
        ObjectPtr obj) {
    if (obj-&gt;polygon.points.size() &lt;= 0) {
        return;
    }
    size_t max_point_index = 0;
    size_t min_point_index = 0;
    Eigen::Vector3d p;
    p[0] = obj-&gt;polygon.points[0].x;
    p[1] = obj-&gt;polygon.points[0].y;
    p[2] = obj-&gt;polygon.points[0].z;
    Eigen::Vector3d max_point = p - ref_ct;
    Eigen::Vector3d min_point = p - ref_ct;
    for (size_t i = 1; i &lt; obj-&gt;polygon.points.size(); ++i) {
        Eigen::Vector3d p;
        p[0] = obj-&gt;polygon.points[i].x;
        p[1] = obj-&gt;polygon.points[i].y;
        p[2] = obj-&gt;polygon.points[i].z;
        Eigen::Vector3d ray = p - ref_ct;
        // clock direction
        if (max_point[0] * ray[1] - ray[0] * max_point[1] &lt; EPSILON) {
            max_point = ray;
            max_point_index = i;
        }
        // unclock direction
        if (min_point[0] * ray[1] - ray[0] * min_point[1] &gt; EPSILON) {
            min_point = ray;
            min_point_index = i;
        }
    }
    Eigen::Vector3d line = max_point - min_point;
    double total_len = 0;
    double max_dis = 0;
    bool has_out = false;
    for (size_t i = min_point_index, count = 0;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist = sqrt((p[0] - p_x[0]) * (p[0] - p_x[0])
                        + (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist - max_dis &gt; EPSILON) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                   || (i == max_point_index &amp;&amp; j == min_point_index)) {
            size_t k = (j + 1) % obj-&gt;polygon.points.size();
            Eigen::Vector3d p_k;
            p_k[0] = obj-&gt;polygon.points[k].x;
            p_k[1] = obj-&gt;polygon.points[k].y;
            p_k[2] = obj-&gt;polygon.points[k].z;
            Eigen::Vector3d p_j;
            p_j[0] = obj-&gt;polygon.points[j].x;
            p_j[1] = obj-&gt;polygon.points[j].y;
            p_j[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
            } else {
                // outline
                has_out = true;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p_x - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist =
                        sqrt((p[0] - p_x[0]) * (p[0] - p_x[0]) +
                            (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist &gt; max_dis) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        }
    }
    size_t count = 0;
    double min_area = std::numeric_limits&lt;double&gt;::max();
    for (size_t i = min_point_index;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        Eigen::Vector3d p_j;
        p_j[0] = obj-&gt;polygon.points[j].x;
        p_j[1] = obj-&gt;polygon.points[j].y;
        p_j[2] = obj-&gt;polygon.points[j].z;
        double dist = sqrt((p_x[0] - p_j[0]) * (p_x[0] - p_j[0])
                + (p_x[1] - p_j[1])* (p_x[1] - p_j[1]));
        if (dist &lt; max_dis &amp;&amp; (dist / total_len) &lt; 0.5) {
            continue;
        }
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0;
                double width = 0;
                Eigen::Vector3d dir;
                double area =
                    ComputeAreaAlongOneEdge(obj, i,
                                        &amp;center, &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                    || (i == max_point_index &amp;&amp; j == min_point_index)) {
            if (!has_out) {
                continue;
            }
            Eigen::Vector3d center;
            double length = 0;
            double width = 0;
            Eigen::Vector3d dir;
            double area =
               ComputeAreaAlongOneEdge(obj, i, &amp;center, &amp;length, &amp;width, &amp;dir);
            if (area &lt; min_area) {
                obj-&gt;center = center;
                obj-&gt;length = length;
                obj-&gt;width = width;
                obj-&gt;direction = dir;
                min_area = area;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[i].x;
            p[1] = obj-&gt;polygon.points[i].y;
            p[2] = obj-&gt;polygon.points[i].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0.0;
                double width = 0.0;
                Eigen::Vector3d dir;
                double area =
                   ComputeAreaAlongOneEdge(obj, i, &amp;center,
                                           &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        }
    }
    obj-&gt;direction.normalize();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.cc" startLine="(133, 0)" endLine="(318, 1)" clone_start="166" clone_end="178">
			<code function_name="MinBoxObjectBuilder::ReconstructPolygon(const Eigen::Vector3d &amp;ref_ct, ObjectPtr obj)">void  MinBoxObjectBuilder::ReconstructPolygon(
        const Eigen::Vector3d &amp;ref_ct,
        ObjectPtr obj) {
    if (obj-&gt;polygon.points.size() &lt;= 0) {
        return;
    }
    size_t max_point_index = 0;
    size_t min_point_index = 0;
    Eigen::Vector3d p;
    p[0] = obj-&gt;polygon.points[0].x;
    p[1] = obj-&gt;polygon.points[0].y;
    p[2] = obj-&gt;polygon.points[0].z;
    Eigen::Vector3d max_point = p - ref_ct;
    Eigen::Vector3d min_point = p - ref_ct;
    for (size_t i = 1; i &lt; obj-&gt;polygon.points.size(); ++i) {
        Eigen::Vector3d p;
        p[0] = obj-&gt;polygon.points[i].x;
        p[1] = obj-&gt;polygon.points[i].y;
        p[2] = obj-&gt;polygon.points[i].z;
        Eigen::Vector3d ray = p - ref_ct;
        // clock direction
        if (max_point[0] * ray[1] - ray[0] * max_point[1] &lt; EPSILON) {
            max_point = ray;
            max_point_index = i;
        }
        // unclock direction
        if (min_point[0] * ray[1] - ray[0] * min_point[1] &gt; EPSILON) {
            min_point = ray;
            min_point_index = i;
        }
    }
    Eigen::Vector3d line = max_point - min_point;
    double total_len = 0;
    double max_dis = 0;
    bool has_out = false;
    for (size_t i = min_point_index, count = 0;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist = sqrt((p[0] - p_x[0]) * (p[0] - p_x[0])
                        + (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist - max_dis &gt; EPSILON) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                   || (i == max_point_index &amp;&amp; j == min_point_index)) {
            size_t k = (j + 1) % obj-&gt;polygon.points.size();
            Eigen::Vector3d p_k;
            p_k[0] = obj-&gt;polygon.points[k].x;
            p_k[1] = obj-&gt;polygon.points[k].y;
            p_k[2] = obj-&gt;polygon.points[k].z;
            Eigen::Vector3d p_j;
            p_j[0] = obj-&gt;polygon.points[j].x;
            p_j[1] = obj-&gt;polygon.points[j].y;
            p_j[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
            } else {
                // outline
                has_out = true;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p_x - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist =
                        sqrt((p[0] - p_x[0]) * (p[0] - p_x[0]) +
                            (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist &gt; max_dis) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        }
    }
    size_t count = 0;
    double min_area = std::numeric_limits&lt;double&gt;::max();
    for (size_t i = min_point_index;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        Eigen::Vector3d p_j;
        p_j[0] = obj-&gt;polygon.points[j].x;
        p_j[1] = obj-&gt;polygon.points[j].y;
        p_j[2] = obj-&gt;polygon.points[j].z;
        double dist = sqrt((p_x[0] - p_j[0]) * (p_x[0] - p_j[0])
                + (p_x[1] - p_j[1])* (p_x[1] - p_j[1]));
        if (dist &lt; max_dis &amp;&amp; (dist / total_len) &lt; 0.5) {
            continue;
        }
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0;
                double width = 0;
                Eigen::Vector3d dir;
                double area =
                    ComputeAreaAlongOneEdge(obj, i,
                                        &amp;center, &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                    || (i == max_point_index &amp;&amp; j == min_point_index)) {
            if (!has_out) {
                continue;
            }
            Eigen::Vector3d center;
            double length = 0;
            double width = 0;
            Eigen::Vector3d dir;
            double area =
               ComputeAreaAlongOneEdge(obj, i, &amp;center, &amp;length, &amp;width, &amp;dir);
            if (area &lt; min_area) {
                obj-&gt;center = center;
                obj-&gt;length = length;
                obj-&gt;width = width;
                obj-&gt;direction = dir;
                min_area = area;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[i].x;
            p[1] = obj-&gt;polygon.points[i].y;
            p[2] = obj-&gt;polygon.points[i].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0.0;
                double width = 0.0;
                Eigen::Vector3d dir;
                double area =
                   ComputeAreaAlongOneEdge(obj, i, &amp;center,
                                           &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        }
    }
    obj-&gt;direction.normalize();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(492, 0)" endLine="(612, 1)" clone_start="63" clone_end="75">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  if (!chassis_detail.has_eps()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO eps."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_brake()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO brake."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gas()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gas."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gear()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gear."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR_EVERY(100) &lt;&lt; "Steering fault detected: "
                      &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR_EVERY(100) &lt;&lt; "Brake fault detected: "
                      &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR_EVERY(100) &lt;&lt; "Throttle fault detected: "
                      &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR_EVERY(100) &lt;&lt; "Gear fault detected: "
                      &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(492, 0)" endLine="(612, 1)" clone_start="21" clone_end="33">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  if (!chassis_detail.has_eps()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO eps."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_brake()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO brake."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gas()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gas."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gear()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gear."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR_EVERY(100) &lt;&lt; "Steering fault detected: "
                      &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR_EVERY(100) &lt;&lt; "Brake fault detected: "
                      &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR_EVERY(100) &lt;&lt; "Throttle fault detected: "
                      &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR_EVERY(100) &lt;&lt; "Gear fault detected: "
                      &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(844, 0)" endLine="(890, 1)" clone_start="27" clone_end="38">
			<code function_name="Obstacle::SetLaneGraphFeature(Feature* feature)">void Obstacle::SetLaneGraphFeature(Feature* feature) {
  PredictionMap* map = PredictionMap::instance();
  double speed = feature-&gt;speed();
  double acc = feature-&gt;acc();
  if (FLAGS_enable_kf_tracking) {
    speed = feature-&gt;t_speed();
    acc = feature-&gt;t_acc();
  }
  double road_graph_distance =
      speed * FLAGS_prediction_duration +
      0.5 * acc * FLAGS_prediction_duration * FLAGS_prediction_duration +
      FLAGS_min_prediction_length;
  for (auto&amp; lane : feature-&gt;lane().current_lane_feature()) {
    std::shared_ptr&lt;const LaneInfo&gt; lane_info = map-&gt;LaneById(lane.lane_id());
    RoadGraph road_graph(lane.lane_s(), road_graph_distance, lane_info);
    LaneGraph lane_graph;
    road_graph.BuildLaneGraph(&amp;lane_graph);
    for (const auto&amp; lane_seq : lane_graph.lane_sequence()) {
      feature-&gt;mutable_lane()
          -&gt;mutable_lane_graph()
          -&gt;add_lane_sequence()
          -&gt;CopyFrom(lane_seq);
      ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] set a lane sequence ["
             &lt;&lt; lane_seq.ShortDebugString() &lt;&lt; "].";
    }
  }
  for (auto&amp; lane : feature-&gt;lane().nearby_lane_feature()) {
    std::shared_ptr&lt;const LaneInfo&gt; lane_info = map-&gt;LaneById(lane.lane_id());
    RoadGraph road_graph(lane.lane_s(), road_graph_distance, lane_info);
    LaneGraph lane_graph;
    road_graph.BuildLaneGraph(&amp;lane_graph);
    for (const auto&amp; lane_seq : lane_graph.lane_sequence()) {
      feature-&gt;mutable_lane()
          -&gt;mutable_lane_graph()
          -&gt;add_lane_sequence()
          -&gt;CopyFrom(lane_seq);
      ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] set a lane sequence ["
             &lt;&lt; lane_seq.ShortDebugString() &lt;&lt; "].";
    }
  }

  if (feature-&gt;has_lane() &amp;&amp; feature-&gt;lane().has_lane_graph()) {
    SetLanePoints(feature);
  }

  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] set lane graph features.";
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(844, 0)" endLine="(890, 1)" clone_start="13" clone_end="24">
			<code function_name="Obstacle::SetLaneGraphFeature(Feature* feature)">void Obstacle::SetLaneGraphFeature(Feature* feature) {
  PredictionMap* map = PredictionMap::instance();
  double speed = feature-&gt;speed();
  double acc = feature-&gt;acc();
  if (FLAGS_enable_kf_tracking) {
    speed = feature-&gt;t_speed();
    acc = feature-&gt;t_acc();
  }
  double road_graph_distance =
      speed * FLAGS_prediction_duration +
      0.5 * acc * FLAGS_prediction_duration * FLAGS_prediction_duration +
      FLAGS_min_prediction_length;
  for (auto&amp; lane : feature-&gt;lane().current_lane_feature()) {
    std::shared_ptr&lt;const LaneInfo&gt; lane_info = map-&gt;LaneById(lane.lane_id());
    RoadGraph road_graph(lane.lane_s(), road_graph_distance, lane_info);
    LaneGraph lane_graph;
    road_graph.BuildLaneGraph(&amp;lane_graph);
    for (const auto&amp; lane_seq : lane_graph.lane_sequence()) {
      feature-&gt;mutable_lane()
          -&gt;mutable_lane_graph()
          -&gt;add_lane_sequence()
          -&gt;CopyFrom(lane_seq);
      ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] set a lane sequence ["
             &lt;&lt; lane_seq.ShortDebugString() &lt;&lt; "].";
    }
  }
  for (auto&amp; lane : feature-&gt;lane().nearby_lane_feature()) {
    std::shared_ptr&lt;const LaneInfo&gt; lane_info = map-&gt;LaneById(lane.lane_id());
    RoadGraph road_graph(lane.lane_s(), road_graph_distance, lane_info);
    LaneGraph lane_graph;
    road_graph.BuildLaneGraph(&amp;lane_graph);
    for (const auto&amp; lane_seq : lane_graph.lane_sequence()) {
      feature-&gt;mutable_lane()
          -&gt;mutable_lane_graph()
          -&gt;add_lane_sequence()
          -&gt;CopyFrom(lane_seq);
      ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] set a lane sequence ["
             &lt;&lt; lane_seq.ShortDebugString() &lt;&lt; "].";
    }
  }

  if (feature-&gt;has_lane() &amp;&amp; feature-&gt;lane().has_lane_graph()) {
    SetLanePoints(feature);
  }

  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] set lane graph features.";
}</code>
		</source>
	</dup>
	<dup count="6">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="135" clone_end="157">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(29, 0)" endLine="(59, 1)" clone_start="8" clone_end="27">
			<code function_name="Brake61::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brake61::Parse(const std::uint8_t *bytes, int32_t length,
                    ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_output(
      pedal_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  chassis_detail-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(29, 0)" endLine="(59, 1)" clone_start="7" clone_end="25">
			<code function_name="Brake61::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brake61::Parse(const std::uint8_t *bytes, int32_t length,
                    ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_output(
      pedal_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  chassis_detail-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(29, 0)" endLine="(59, 1)" clone_start="5" clone_end="23">
			<code function_name="Brake61::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brake61::Parse(const std::uint8_t *bytes, int32_t length,
                    ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_output(
      pedal_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  chassis_detail-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(29, 0)" endLine="(59, 1)" clone_start="4" clone_end="21">
			<code function_name="Brake61::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brake61::Parse(const std::uint8_t *bytes, int32_t length,
                    ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_output(
      pedal_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  chassis_detail-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(29, 0)" endLine="(59, 1)" clone_start="3" clone_end="19">
			<code function_name="Brake61::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brake61::Parse(const std::uint8_t *bytes, int32_t length,
                    ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_output(
      pedal_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  chassis_detail-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\tools\teleop.cc" startLine="(257, 2)" endLine="(276, 3)" clone_start="5" clone_end="16">
			<code function_name="GetGear(int32_t gear)">  Chassis::GearPosition GetGear(int32_t gear) {
    switch (gear) {
      case 0:
        return Chassis::GEAR_NEUTRAL;
      case 1:
        return Chassis::GEAR_DRIVE;
      case 2:
        return Chassis::GEAR_REVERSE;
      case 3:
        return Chassis::GEAR_PARKING;
      case 4:
        return Chassis::GEAR_LOW;
      case 5:
        return Chassis::GEAR_INVALID;
      case 6:
        return Chassis::GEAR_NONE;
      default:
        return Chassis::GEAR_INVALID;
    }
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\tools\teleop.cc" startLine="(257, 2)" endLine="(276, 3)" clone_start="3" clone_end="14">
			<code function_name="GetGear(int32_t gear)">  Chassis::GearPosition GetGear(int32_t gear) {
    switch (gear) {
      case 0:
        return Chassis::GEAR_NEUTRAL;
      case 1:
        return Chassis::GEAR_DRIVE;
      case 2:
        return Chassis::GEAR_REVERSE;
      case 3:
        return Chassis::GEAR_PARKING;
      case 4:
        return Chassis::GEAR_LOW;
      case 5:
        return Chassis::GEAR_INVALID;
      case 6:
        return Chassis::GEAR_NONE;
      default:
        return Chassis::GEAR_INVALID;
    }
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(54, 0)" endLine="(119, 1)" clone_start="40" clone_end="54">
			<code function_name="create_stream(const config::Stream &amp;sd)">Stream *create_stream(const config::Stream &amp;sd) {
  switch (sd.type_case()) {
    case config::Stream::kSerial:
      if (!sd.serial().has_device()) {
        ROS_ERROR("Serial def has no device field.");
        return nullptr;
      }
      if (!sd.serial().has_baud_rate()) {
        ROS_ERROR_STREAM(
            "Serial def has no baud_rate field. Use default baud rate "
            &lt;&lt; sd.serial().baud_rate());
        return nullptr;
      }
      return Stream::create_serial(sd.serial().device().c_str(),
                                   sd.serial().baud_rate());

    case config::Stream::kTcp:
      if (!sd.tcp().has_address()) {
        ROS_ERROR("tcp def has no address field.");
        return nullptr;
      }
      if (!sd.tcp().has_port()) {
        ROS_ERROR("tcp def has no port field.");
        return nullptr;
      }
      return Stream::create_tcp(sd.tcp().address().c_str(), sd.tcp().port());

    case config::Stream::kUdp:
      if (!sd.udp().has_address()) {
        ROS_ERROR("tcp def has no address field.");
        return nullptr;
      }
      if (!sd.udp().has_port()) {
        ROS_ERROR("tcp def has no port field.");
        return nullptr;
      }
      return Stream::create_udp(sd.udp().address().c_str(), sd.udp().port());

    case config::Stream::kNtrip:
      if (!sd.ntrip().has_address()) {
        ROS_ERROR("ntrip def has no address field.");
        return nullptr;
      }
      if (!sd.ntrip().has_port()) {
        ROS_ERROR("ntrip def has no port field.");
        return nullptr;
      }
      if (!sd.ntrip().has_mount_point()) {
        ROS_ERROR("ntrip def has no mount point field.");
        return nullptr;
      }
      if (!sd.ntrip().has_user()) {
        ROS_ERROR("ntrip def has no user field.");
        return nullptr;
      }
      if (!sd.ntrip().has_password()) {
        ROS_ERROR("ntrip def has no passwd field.");
        return nullptr;
      }
      return Stream::create_ntrip(
          sd.ntrip().address(), sd.ntrip().port(), sd.ntrip().mount_point(),
          sd.ntrip().user(), sd.ntrip().password(), sd.ntrip().timeout_s());
    default:
      return nullptr;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(54, 0)" endLine="(119, 1)" clone_start="44" clone_end="58">
			<code function_name="create_stream(const config::Stream &amp;sd)">Stream *create_stream(const config::Stream &amp;sd) {
  switch (sd.type_case()) {
    case config::Stream::kSerial:
      if (!sd.serial().has_device()) {
        ROS_ERROR("Serial def has no device field.");
        return nullptr;
      }
      if (!sd.serial().has_baud_rate()) {
        ROS_ERROR_STREAM(
            "Serial def has no baud_rate field. Use default baud rate "
            &lt;&lt; sd.serial().baud_rate());
        return nullptr;
      }
      return Stream::create_serial(sd.serial().device().c_str(),
                                   sd.serial().baud_rate());

    case config::Stream::kTcp:
      if (!sd.tcp().has_address()) {
        ROS_ERROR("tcp def has no address field.");
        return nullptr;
      }
      if (!sd.tcp().has_port()) {
        ROS_ERROR("tcp def has no port field.");
        return nullptr;
      }
      return Stream::create_tcp(sd.tcp().address().c_str(), sd.tcp().port());

    case config::Stream::kUdp:
      if (!sd.udp().has_address()) {
        ROS_ERROR("tcp def has no address field.");
        return nullptr;
      }
      if (!sd.udp().has_port()) {
        ROS_ERROR("tcp def has no port field.");
        return nullptr;
      }
      return Stream::create_udp(sd.udp().address().c_str(), sd.udp().port());

    case config::Stream::kNtrip:
      if (!sd.ntrip().has_address()) {
        ROS_ERROR("ntrip def has no address field.");
        return nullptr;
      }
      if (!sd.ntrip().has_port()) {
        ROS_ERROR("ntrip def has no port field.");
        return nullptr;
      }
      if (!sd.ntrip().has_mount_point()) {
        ROS_ERROR("ntrip def has no mount point field.");
        return nullptr;
      }
      if (!sd.ntrip().has_user()) {
        ROS_ERROR("ntrip def has no user field.");
        return nullptr;
      }
      if (!sd.ntrip().has_password()) {
        ROS_ERROR("ntrip def has no passwd field.");
        return nullptr;
      }
      return Stream::create_ntrip(
          sd.ntrip().address(), sd.ntrip().port(), sd.ntrip().mount_point(),
          sd.ntrip().user(), sd.ntrip().password(), sd.ntrip().timeout_s());
    default:
      return nullptr;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\path\path_data.cc" startLine="(55, 0)" endLine="(69, 1)" clone_start="1" clone_end="14">
			<code function_name="PathData::SetFrenetPath(const FrenetFramePath &amp;frenet_path)">bool PathData::SetFrenetPath(const FrenetFramePath &amp;frenet_path) {
  if (reference_line_ == nullptr) {
    AERROR &lt;&lt; "Should NOT set frenet path when reference line is nullptr. "
              "Please set reference line first.";
    return false;
  }
  frenet_path_ = frenet_path;
  if (!SLToXY(frenet_path_, &amp;discretized_path_)) {
    AERROR &lt;&lt; "Fail to transfer frenet path to discretized path.";
    return false;
  }
  DCHECK_EQ(discretized_path_.NumOfPoints(), frenet_path_.points().size());
  path_data_history_.push_back(std::make_pair(discretized_path_, frenet_path_));
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\path\path_data.cc" startLine="(39, 0)" endLine="(53, 1)" clone_start="1" clone_end="14">
			<code function_name="PathData::SetDiscretizedPath(const DiscretizedPath &amp;path)">bool PathData::SetDiscretizedPath(const DiscretizedPath &amp;path) {
  if (reference_line_ == nullptr) {
    AERROR &lt;&lt; "Should NOT set discretized path when reference line is nullptr. "
              "Please set reference line first.";
    return false;
  }
  discretized_path_ = path;
  if (!XYToSL(discretized_path_, &amp;frenet_path_)) {
    AERROR &lt;&lt; "Fail to transfer discretized path to frenet path.";
    return false;
  }
  DCHECK_EQ(discretized_path_.NumOfPoints(), frenet_path_.points().size());
  path_data_history_.push_back(std::make_pair(discretized_path_, frenet_path_));
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\speed_optimizer.cc" startLine="(82, 0)" endLine="(130, 1)" clone_start="14" clone_end="27">
			<code function_name="SpeedOptimizer::RecordSTGraphDebug(const std::vector&lt;StBoundary&gt;&amp; boundaries, const SpeedLimit&amp; speed_limits, const SpeedData&amp; speed_data, STGraphDebug* st_graph_debug)">void SpeedOptimizer::RecordSTGraphDebug(
    const std::vector&lt;StBoundary&gt;&amp; boundaries, const SpeedLimit&amp; speed_limits,
    const SpeedData&amp; speed_data, STGraphDebug* st_graph_debug) {
  if (!FLAGS_enable_record_debug) {
    ADEBUG &lt;&lt; "Skip record debug info";
    return;
  }

  st_graph_debug-&gt;set_name(Name());
  for (const auto boundary : boundaries) {
    auto boundary_debug = st_graph_debug-&gt;add_boundary();
    boundary_debug-&gt;set_name(boundary.id());
    switch (boundary.boundary_type()) {
      case StBoundary::BoundaryType::FOLLOW:
        boundary_debug-&gt;set_type(StGraphBoundaryDebug::ST_BOUNDARY_TYPE_FOLLOW);
        break;
      case StBoundary::BoundaryType::OVERTAKE:
        boundary_debug-&gt;set_type(
            StGraphBoundaryDebug::ST_BOUNDARY_TYPE_OVERTAKE);
        break;
      case StBoundary::BoundaryType::STOP:
        boundary_debug-&gt;set_type(StGraphBoundaryDebug::ST_BOUNDARY_TYPE_STOP);
        break;
      case StBoundary::BoundaryType::UNKNOWN:
        boundary_debug-&gt;set_type(
            StGraphBoundaryDebug::ST_BOUNDARY_TYPE_UNKNOWN);
        break;
      case StBoundary::BoundaryType::YIELD:
        boundary_debug-&gt;set_type(StGraphBoundaryDebug::ST_BOUNDARY_TYPE_YIELD);
        break;
    }

    for (const auto point : boundary.points()) {
      auto point_debug = boundary_debug-&gt;add_point();
      point_debug-&gt;set_t(point.x());
      point_debug-&gt;set_s(point.y());
    }
  }

  for (const auto point : speed_limits.speed_limit_points()) {
    common::SpeedPoint speed_point;
    speed_point.set_s(point.first);
    speed_point.set_v(point.second);
    st_graph_debug-&gt;add_speed_limit()-&gt;CopyFrom(speed_point);
  }

  st_graph_debug-&gt;mutable_speed_profile()-&gt;CopyFrom(
      {speed_data.speed_vector().begin(), speed_data.speed_vector().end()});
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\tasks\speed_optimizer.cc" startLine="(82, 0)" endLine="(130, 1)" clone_start="17" clone_end="30">
			<code function_name="SpeedOptimizer::RecordSTGraphDebug(const std::vector&lt;StBoundary&gt;&amp; boundaries, const SpeedLimit&amp; speed_limits, const SpeedData&amp; speed_data, STGraphDebug* st_graph_debug)">void SpeedOptimizer::RecordSTGraphDebug(
    const std::vector&lt;StBoundary&gt;&amp; boundaries, const SpeedLimit&amp; speed_limits,
    const SpeedData&amp; speed_data, STGraphDebug* st_graph_debug) {
  if (!FLAGS_enable_record_debug) {
    ADEBUG &lt;&lt; "Skip record debug info";
    return;
  }

  st_graph_debug-&gt;set_name(Name());
  for (const auto boundary : boundaries) {
    auto boundary_debug = st_graph_debug-&gt;add_boundary();
    boundary_debug-&gt;set_name(boundary.id());
    switch (boundary.boundary_type()) {
      case StBoundary::BoundaryType::FOLLOW:
        boundary_debug-&gt;set_type(StGraphBoundaryDebug::ST_BOUNDARY_TYPE_FOLLOW);
        break;
      case StBoundary::BoundaryType::OVERTAKE:
        boundary_debug-&gt;set_type(
            StGraphBoundaryDebug::ST_BOUNDARY_TYPE_OVERTAKE);
        break;
      case StBoundary::BoundaryType::STOP:
        boundary_debug-&gt;set_type(StGraphBoundaryDebug::ST_BOUNDARY_TYPE_STOP);
        break;
      case StBoundary::BoundaryType::UNKNOWN:
        boundary_debug-&gt;set_type(
            StGraphBoundaryDebug::ST_BOUNDARY_TYPE_UNKNOWN);
        break;
      case StBoundary::BoundaryType::YIELD:
        boundary_debug-&gt;set_type(StGraphBoundaryDebug::ST_BOUNDARY_TYPE_YIELD);
        break;
    }

    for (const auto point : boundary.points()) {
      auto point_debug = boundary_debug-&gt;add_point();
      point_debug-&gt;set_t(point.x());
      point_debug-&gt;set_s(point.y());
    }
  }

  for (const auto point : speed_limits.speed_limit_points()) {
    common::SpeedPoint speed_point;
    speed_point.set_s(point.first);
    speed_point.set_v(point.second);
    st_graph_debug-&gt;add_speed_limit()-&gt;CopyFrom(speed_point);
  }

  st_graph_debug-&gt;mutable_speed_profile()-&gt;CopyFrom(
      {speed_data.speed_vector().begin(), speed_data.speed_vector().end()});
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(492, 0)" endLine="(612, 1)" clone_start="85" clone_end="98">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  if (!chassis_detail.has_eps()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO eps."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_brake()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO brake."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gas()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gas."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gear()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gear."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR_EVERY(100) &lt;&lt; "Steering fault detected: "
                      &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR_EVERY(100) &lt;&lt; "Brake fault detected: "
                      &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR_EVERY(100) &lt;&lt; "Throttle fault detected: "
                      &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR_EVERY(100) &lt;&lt; "Gear fault detected: "
                      &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(492, 0)" endLine="(612, 1)" clone_start="94" clone_end="107">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  if (!chassis_detail.has_eps()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO eps."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_brake()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO brake."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gas()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gas."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gear()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gear."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR_EVERY(100) &lt;&lt; "Steering fault detected: "
                      &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR_EVERY(100) &lt;&lt; "Brake fault detected: "
                      &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR_EVERY(100) &lt;&lt; "Throttle fault detected: "
                      &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR_EVERY(100) &lt;&lt; "Gear fault detected: "
                      &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\common\prediction_map.cc" startLine="(154, 0)" endLine="(201, 1)" clone_start="30" clone_end="44">
			<code function_name="PredictionMap::NearbyLanesByCurrentLanes(    const Eigen::Vector2d&amp; point, const double heading, const double radius, const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes, std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;* nearby_lanes)">void PredictionMap::NearbyLanesByCurrentLanes(
    const Eigen::Vector2d&amp; point, const double heading, const double radius,
    const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes,
    std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;* nearby_lanes) {
  if (lanes.size() == 0) {
    std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt; prev_lanes(0);
    OnLane(prev_lanes, point, heading, radius, false, nearby_lanes);
  } else {
    std::unordered_set&lt;std::string&gt; lane_ids;
    for (auto&amp; lane_ptr : lanes) {
      if (lane_ptr == nullptr) {
        continue;
      }
      for (auto&amp; lane_id : lane_ptr-&gt;lane().left_neighbor_forward_lane_id()) {
        const std::string&amp; id = lane_id.id();
        if (lane_ids.find(id) != lane_ids.end()) {
          continue;
        }
        std::shared_ptr&lt;const LaneInfo&gt; nearby_lane = LaneById(id);
        double s = -1.0;
        double l = 0.0;
        GetProjection(point, nearby_lane, &amp;s, &amp;l);
        if (common::math::DoubleCompare(s, 0.0) &gt;= 0 &amp;&amp;
            common::math::DoubleCompare(std::fabs(l), radius) &gt; 0) {
          continue;
        }
        lane_ids.insert(id);
        nearby_lanes-&gt;push_back(nearby_lane);
      }
      for (auto&amp; lane_id : lane_ptr-&gt;lane().right_neighbor_forward_lane_id()) {
        const std::string&amp; id = lane_id.id();
        if (lane_ids.find(id) != lane_ids.end()) {
          continue;
        }
        std::shared_ptr&lt;const LaneInfo&gt; nearby_lane = LaneById(id);
        double s = -1.0;
        double l = 0.0;
        GetProjection(point, nearby_lane, &amp;s, &amp;l);
        if (common::math::DoubleCompare(s, 0.0) &gt;= 0 &amp;&amp;
            common::math::DoubleCompare(std::fabs(l), radius) &gt; 0) {
          continue;
        }
        lane_ids.insert(id);
        nearby_lanes-&gt;push_back(nearby_lane);
      }
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\common\prediction_map.cc" startLine="(154, 0)" endLine="(201, 1)" clone_start="14" clone_end="28">
			<code function_name="PredictionMap::NearbyLanesByCurrentLanes(    const Eigen::Vector2d&amp; point, const double heading, const double radius, const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes, std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;* nearby_lanes)">void PredictionMap::NearbyLanesByCurrentLanes(
    const Eigen::Vector2d&amp; point, const double heading, const double radius,
    const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes,
    std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;* nearby_lanes) {
  if (lanes.size() == 0) {
    std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt; prev_lanes(0);
    OnLane(prev_lanes, point, heading, radius, false, nearby_lanes);
  } else {
    std::unordered_set&lt;std::string&gt; lane_ids;
    for (auto&amp; lane_ptr : lanes) {
      if (lane_ptr == nullptr) {
        continue;
      }
      for (auto&amp; lane_id : lane_ptr-&gt;lane().left_neighbor_forward_lane_id()) {
        const std::string&amp; id = lane_id.id();
        if (lane_ids.find(id) != lane_ids.end()) {
          continue;
        }
        std::shared_ptr&lt;const LaneInfo&gt; nearby_lane = LaneById(id);
        double s = -1.0;
        double l = 0.0;
        GetProjection(point, nearby_lane, &amp;s, &amp;l);
        if (common::math::DoubleCompare(s, 0.0) &gt;= 0 &amp;&amp;
            common::math::DoubleCompare(std::fabs(l), radius) &gt; 0) {
          continue;
        }
        lane_ids.insert(id);
        nearby_lanes-&gt;push_back(nearby_lane);
      }
      for (auto&amp; lane_id : lane_ptr-&gt;lane().right_neighbor_forward_lane_id()) {
        const std::string&amp; id = lane_id.id();
        if (lane_ids.find(id) != lane_ids.end()) {
          continue;
        }
        std::shared_ptr&lt;const LaneInfo&gt; nearby_lane = LaneById(id);
        double s = -1.0;
        double l = 0.0;
        GetProjection(point, nearby_lane, &amp;s, &amp;l);
        if (common::math::DoubleCompare(s, 0.0) &gt;= 0 &amp;&amp;
            common::math::DoubleCompare(std::fabs(l), radius) &gt; 0) {
          continue;
        }
        lane_ids.insert(id);
        nearby_lanes-&gt;push_back(nearby_lane);
      }
    }
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_kernel.cc" startLine="(97, 0)" endLine="(106, 1)" clone_start="1" clone_end="10">
			<code function_name="Spline1dKernel::AddSecondOrderDerivativeMatrix(const double weight)">void Spline1dKernel::AddSecondOrderDerivativeMatrix(const double weight) {
  for (std::uint32_t i = 0; i + 1 &lt; x_knots_.size(); ++i) {
    Eigen::MatrixXd cur_kernel =
        SplineSegKernel::instance()-&gt;SecondOrderDerivativeKernel(
            spline_order_, x_knots_[i + 1] - x_knots_[i]) *
        weight;
    kernel_matrix_.block(i * spline_order_, i * spline_order_, spline_order_,
                         spline_order_) += cur_kernel;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_kernel.cc" startLine="(86, 0)" endLine="(95, 1)" clone_start="1" clone_end="10">
			<code function_name="Spline1dKernel::AddDerivativeKernelMatrix(const double weight)">void Spline1dKernel::AddDerivativeKernelMatrix(const double weight) {
  for (std::uint32_t i = 0; i + 1 &lt; x_knots_.size(); ++i) {
    Eigen::MatrixXd cur_kernel =
        SplineSegKernel::instance()-&gt;DerivativeKernel(
            spline_order_, x_knots_[i + 1] - x_knots_[i]) *
        weight;
    kernel_matrix_.block(i * spline_order_, i * spline_order_, spline_order_,
                         spline_order_) += cur_kernel;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_kernel.cc" startLine="(108, 0)" endLine="(117, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline1dKernel::AddThirdOrderDerivativeMatrix(const double weight)">void Spline1dKernel::AddThirdOrderDerivativeMatrix(const double weight) {
  for (std::uint32_t i = 0; i + 1 &lt; x_knots_.size(); ++i) {
    Eigen::MatrixXd cur_kernel =
        SplineSegKernel::instance()-&gt;ThirdOrderDerivativeKernel(
            spline_order_, x_knots_[i + 1] - x_knots_[i]) *
        weight;
    kernel_matrix_.block(i * spline_order_, i * spline_order_, spline_order_,
                         spline_order_) += cur_kernel;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_kernel.cc" startLine="(97, 0)" endLine="(106, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline1dKernel::AddSecondOrderDerivativeMatrix(const double weight)">void Spline1dKernel::AddSecondOrderDerivativeMatrix(const double weight) {
  for (std::uint32_t i = 0; i + 1 &lt; x_knots_.size(); ++i) {
    Eigen::MatrixXd cur_kernel =
        SplineSegKernel::instance()-&gt;SecondOrderDerivativeKernel(
            spline_order_, x_knots_[i + 1] - x_knots_[i]) *
        weight;
    kernel_matrix_.block(i * spline_order_, i * spline_order_, spline_order_,
                         spline_order_) += cur_kernel;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(26, 0)" endLine="(51, 1)" clone_start="8" clone_end="19">
			<code function_name="Gps6f::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Gps6f::Parse(const std::uint8_t *bytes, int32_t length,
                  ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_basic()-&gt;set_altitude(altitude(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_heading(heading(bytes, length));
  // speed mph -&gt; mps
  chassis_detail-&gt;mutable_basic()-&gt;set_gps_speed(speed(bytes, length) *
                                                 0.44704);
  chassis_detail-&gt;mutable_basic()-&gt;set_hdop(hdop(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_vdop(vdop(bytes, length));
  switch (fix_quality(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_NO);
      break;
    case 1:
      chassis_detail-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_2D);
      break;
    case 2:
      chassis_detail-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_3D);
      break;
    default:
      chassis_detail-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_INVALID);
      break;
  }
  chassis_detail-&gt;mutable_basic()-&gt;set_num_satellites(
      num_satellites(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="34" clone_end="47">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length,
                        ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\sub_topo_graph.cc" startLine="(290, 0)" endLine="(299, 1)" clone_start="1" clone_end="10">
			<code function_name="SubTopoGraph::AddPotentialEdge(const TopoNode* topo_node)">void SubTopoGraph::AddPotentialEdge(const TopoNode* topo_node) {
  std::unordered_set&lt;TopoNode*&gt; sub_nodes;
  if (!GetSubNodes(topo_node, &amp;sub_nodes)) {
    return;
  }
  for (auto* sub_node : sub_nodes) {
    AddPotentialInEdge(sub_node, topo_node-&gt;InFromLeftOrRightEdge());
    AddPotentialOutEdge(sub_node, topo_node-&gt;OutToLeftOrRightEdge());
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\sub_topo_graph.cc" startLine="(212, 0)" endLine="(222, 1)" clone_start="1" clone_end="11">
			<code function_name="SubTopoGraph::InitSubEdge(const TopoNode* topo_node)">void SubTopoGraph::InitSubEdge(const TopoNode* topo_node) {
  std::unordered_set&lt;TopoNode*&gt; sub_nodes;
  if (!GetSubNodes(topo_node, &amp;sub_nodes)) {
    return;
  }

  for (auto* sub_node : sub_nodes) {
    InitInSubNodeSubEdge(sub_node, topo_node-&gt;InFromAllEdge());
    InitOutSubNodeSubEdge(sub_node, topo_node-&gt;OutToAllEdge());
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\sub_topo_graph.cc" startLine="(301, 0)" endLine="(332, 1)" clone_start="1" clone_end="7">
			<code function_name="SubTopoGraph::AddPotentialInEdge(    TopoNode* const sub_node, const std::unordered_set&lt;const TopoEdge*&gt; origin_edge)">void SubTopoGraph::AddPotentialInEdge(
    TopoNode* const sub_node,
    const std::unordered_set&lt;const TopoEdge*&gt; origin_edge) {
  std::unordered_set&lt;TopoNode*&gt; other_sub_nodes;
  for (const auto* in_edge : origin_edge) {
    if (GetSubNodes(in_edge-&gt;FromNode(), &amp;other_sub_nodes)) {
      for (auto* sub_from_node : other_sub_nodes) {
        if (sub_node-&gt;GetInEdgeFrom(sub_from_node) != nullptr) {
          continue;
        }
        if (!IsReachable(sub_from_node, sub_node)) {
          continue;
        }
        std::shared_ptr&lt;TopoEdge&gt; topo_edge_ptr;
        topo_edge_ptr.reset(
            new TopoEdge(in_edge-&gt;PbEdge(), sub_from_node, sub_node));
        sub_node-&gt;AddInEdge(topo_edge_ptr.get());
        sub_from_node-&gt;AddOutEdge(topo_edge_ptr.get());
        topo_edges_.push_back(std::move(topo_edge_ptr));
      }
    } else {
      if (sub_node-&gt;GetInEdgeFrom(in_edge-&gt;FromNode()) != nullptr) {
        continue;
      }
      std::shared_ptr&lt;TopoEdge&gt; topo_edge_ptr;
      topo_edge_ptr.reset(
          new TopoEdge(in_edge-&gt;PbEdge(), in_edge-&gt;FromNode(), sub_node));
      sub_node-&gt;AddInEdge(topo_edge_ptr.get());
      topo_edges_.push_back(std::move(topo_edge_ptr));
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\sub_topo_graph.cc" startLine="(224, 0)" endLine="(249, 1)" clone_start="1" clone_end="7">
			<code function_name="SubTopoGraph::InitInSubNodeSubEdge(TopoNode* const sub_node, const std::unordered_set&lt;const TopoEdge*&gt; origin_edge)">void SubTopoGraph::InitInSubNodeSubEdge(
    TopoNode* const sub_node,
    const std::unordered_set&lt;const TopoEdge*&gt; origin_edge) {
  std::unordered_set&lt;TopoNode*&gt; other_sub_nodes;
  for (const auto* in_edge : origin_edge) {
    if (GetSubNodes(in_edge-&gt;FromNode(), &amp;other_sub_nodes)) {
      for (auto* sub_from_node : other_sub_nodes) {
        if (!sub_from_node-&gt;IsOverlapEnough(sub_node, in_edge)) {
          continue;
        }
        std::shared_ptr&lt;TopoEdge&gt; topo_edge_ptr;
        topo_edge_ptr.reset(
            new TopoEdge(in_edge-&gt;PbEdge(), sub_from_node, sub_node));
        sub_node-&gt;AddInEdge(topo_edge_ptr.get());
        sub_from_node-&gt;AddOutEdge(topo_edge_ptr.get());
        topo_edges_.push_back(std::move(topo_edge_ptr));
      }
    } else if (in_edge-&gt;FromNode()-&gt;IsOverlapEnough(sub_node, in_edge)) {
      std::shared_ptr&lt;TopoEdge&gt; topo_edge_ptr;
      topo_edge_ptr.reset(
          new TopoEdge(in_edge-&gt;PbEdge(), in_edge-&gt;FromNode(), sub_node));
      sub_node-&gt;AddInEdge(topo_edge_ptr.get());
      topo_edges_.push_back(std::move(topo_edge_ptr));
    }
  }
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="103" clone_end="116">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="42" clone_end="54">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="3" clone_end="16">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="22" clone_end="34">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\sub_topo_graph.cc" startLine="(224, 0)" endLine="(249, 1)" clone_start="1" clone_end="16">
			<code function_name="SubTopoGraph::InitInSubNodeSubEdge(TopoNode* const sub_node, const std::unordered_set&lt;const TopoEdge*&gt; origin_edge)">void SubTopoGraph::InitInSubNodeSubEdge(
    TopoNode* const sub_node,
    const std::unordered_set&lt;const TopoEdge*&gt; origin_edge) {
  std::unordered_set&lt;TopoNode*&gt; other_sub_nodes;
  for (const auto* in_edge : origin_edge) {
    if (GetSubNodes(in_edge-&gt;FromNode(), &amp;other_sub_nodes)) {
      for (auto* sub_from_node : other_sub_nodes) {
        if (!sub_from_node-&gt;IsOverlapEnough(sub_node, in_edge)) {
          continue;
        }
        std::shared_ptr&lt;TopoEdge&gt; topo_edge_ptr;
        topo_edge_ptr.reset(
            new TopoEdge(in_edge-&gt;PbEdge(), sub_from_node, sub_node));
        sub_node-&gt;AddInEdge(topo_edge_ptr.get());
        sub_from_node-&gt;AddOutEdge(topo_edge_ptr.get());
        topo_edges_.push_back(std::move(topo_edge_ptr));
      }
    } else if (in_edge-&gt;FromNode()-&gt;IsOverlapEnough(sub_node, in_edge)) {
      std::shared_ptr&lt;TopoEdge&gt; topo_edge_ptr;
      topo_edge_ptr.reset(
          new TopoEdge(in_edge-&gt;PbEdge(), in_edge-&gt;FromNode(), sub_node));
      sub_node-&gt;AddInEdge(topo_edge_ptr.get());
      topo_edges_.push_back(std::move(topo_edge_ptr));
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\sub_topo_graph.cc" startLine="(251, 0)" endLine="(276, 1)" clone_start="1" clone_end="16">
			<code function_name="SubTopoGraph::InitOutSubNodeSubEdge(    TopoNode* const sub_node, const std::unordered_set&lt;const TopoEdge*&gt; origin_edge)">void SubTopoGraph::InitOutSubNodeSubEdge(
    TopoNode* const sub_node,
    const std::unordered_set&lt;const TopoEdge*&gt; origin_edge) {
  std::unordered_set&lt;TopoNode*&gt; other_sub_nodes;
  for (const auto* out_edge : origin_edge) {
    if (GetSubNodes(out_edge-&gt;ToNode(), &amp;other_sub_nodes)) {
      for (auto* sub_to_node : other_sub_nodes) {
        if (!sub_node-&gt;IsOverlapEnough(sub_to_node, out_edge)) {
          continue;
        }
        std::shared_ptr&lt;TopoEdge&gt; topo_edge_ptr;
        topo_edge_ptr.reset(
            new TopoEdge(out_edge-&gt;PbEdge(), sub_node, sub_to_node));
        sub_node-&gt;AddOutEdge(topo_edge_ptr.get());
        sub_to_node-&gt;AddInEdge(topo_edge_ptr.get());
        topo_edges_.push_back(std::move(topo_edge_ptr));
      }
    } else if (sub_node-&gt;IsOverlapEnough(out_edge-&gt;ToNode(), out_edge)) {
      std::shared_ptr&lt;TopoEdge&gt; topo_edge_ptr;
      topo_edge_ptr.reset(
          new TopoEdge(out_edge-&gt;PbEdge(), sub_node, out_edge-&gt;ToNode()));
      sub_node-&gt;AddOutEdge(topo_edge_ptr.get());
      topo_edges_.push_back(std::move(topo_edge_ptr));
    }
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\glfw_viewer.cc" startLine="(164, 0)" endLine="(272, 1)" clone_start="86" clone_end="103">
			<code function_name="GLFWViewer::OpenglInit()">bool GLFWViewer::OpenglInit() {
  glClearColor(bg_color_(0), bg_color_(1), bg_color_(2), 0.0);
  glClearDepth(1.0f);
  glShadeModel(GL_SMOOTH);
  glDepthFunc(GL_LEQUAL);
  // lighting
  GLfloat mat_shininess[] = {20.0};
  GLfloat light_position[] = {1.0, -1.0, 1.0, 0.0};
  GLfloat lmodel_ambient[] = {.5, .5, .5, 1.0};
  glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
  glLightfv(GL_LIGHT0, GL_POSITION, light_position);
  glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
  glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
  glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);
  glEnable(GL_LIGHT0);
  glEnable(GL_LIGHTING);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_NORMALIZE);
  glEnable(GL_COLOR_MATERIAL);

  // glew
  if (glewInit() != GLEW_OK) {
    AERROR &lt;&lt; "Failed to initialize glew !";
    exit(EXIT_FAILURE);
  }

  // allocation of vbo
  // point cloud
  {
    GLfloat cloud_colors[kPoint_Num_Per_Cloud_VAO_][3];
    GLuint cloud_indices[kPoint_Num_Per_Cloud_VAO_];
    for (int i = 0; i &lt; kPoint_Num_Per_Cloud_VAO_; i++) {
      cloud_colors[i][0] = 0.7;
      cloud_colors[i][1] = 0.7;
      cloud_colors[i][2] = 0.7;
      cloud_indices[i] = GLuint(i);
    }

    glGenVertexArrays(kCloud_VAO_Num_, cloud_VAO_buf_ids_);
    for (int i = 0; i &lt; kCloud_VAO_Num_; i++) {
      glBindVertexArray(cloud_VAO_buf_ids_[i]);

      glGenBuffers(NUM_VBO_TYPE, cloud_VBO_buf_ids_[i]);
      glBindBuffer(GL_ARRAY_BUFFER, cloud_VBO_buf_ids_[i][VBO_VERTICES]);
      glBufferData(GL_ARRAY_BUFFER, sizeof(cloud_verts_), cloud_verts_,
                   GL_STREAM_DRAW);
      glVertexPointer(3, GL_FLOAT, 0, BUFFER_OFFSET(0));
      glEnableClientState(GL_VERTEX_ARRAY);

      glBindBuffer(GL_ARRAY_BUFFER, cloud_VBO_buf_ids_[i][VBO_COLORS]);
      glBufferData(GL_ARRAY_BUFFER, sizeof(cloud_colors), cloud_colors,
                   GL_STREAM_DRAW);
      glColorPointer(3, GL_FLOAT, 0, BUFFER_OFFSET(0));
      glEnableClientState(GL_COLOR_ARRAY);

      glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,
                   cloud_VBO_buf_ids_[i][VBO_ELEMENTS]);
      glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(cloud_indices),
                   cloud_indices, GL_STREAM_DRAW);
    }
  }
  // circle
  {
    GLfloat circle_verts[kPoint_Num_Per_Circle_VAO_][3];
    GLfloat circle_colors[kPoint_Num_Per_Circle_VAO_][3];
    GLuint circle_indices[kPoint_Num_Per_Circle_VAO_];

    for (int i = 0; i &lt; kPoint_Num_Per_Circle_VAO_; ++i) {
      circle_verts[i][2] = -1.0;
      circle_colors[i][0] = 0.0;
      circle_colors[i][1] = 0.0;
      circle_colors[i][2] = 0.9;
      circle_indices[i] = GLuint(i);
    }

    float ang_interv =
        2 * M_PI / static_cast&lt;float&gt;(kPoint_Num_Per_Circle_VAO_);
    glGenVertexArrays(kCircle_VAO_Num_, circle_VAO_buf_ids_);
    for (int vao = 0; vao &lt; kCircle_VAO_Num_; ++vao) {
      for (int i = 0; i &lt; kPoint_Num_Per_Circle_VAO_; ++i) {
        float theta = i * ang_interv;
        circle_verts[i][0] = 20 * (vao + 1) * cos(theta);
        circle_verts[i][1] = 20 * (vao + 1) * sin(theta);
      }

      glBindVertexArray(circle_VAO_buf_ids_[vao]);

      glGenBuffers(NUM_VBO_TYPE, circle_VBO_buf_ids_[vao]);
      glBindBuffer(GL_ARRAY_BUFFER, circle_VBO_buf_ids_[vao][VBO_VERTICES]);
      glBufferData(GL_ARRAY_BUFFER, sizeof(circle_verts), circle_verts,
                   GL_STATIC_DRAW);
      glVertexPointer(3, GL_FLOAT, 0, BUFFER_OFFSET(0));
      glEnableClientState(GL_VERTEX_ARRAY);

      glBindBuffer(GL_ARRAY_BUFFER, circle_VBO_buf_ids_[vao][VBO_COLORS]);
      glBufferData(GL_ARRAY_BUFFER, sizeof(circle_colors), circle_colors,
                   GL_STATIC_DRAW);
      glColorPointer(3, GL_FLOAT, 0, BUFFER_OFFSET(0));
      glEnableClientState(GL_COLOR_ARRAY);

      glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,
                   circle_VBO_buf_ids_[vao][VBO_ELEMENTS]);
      glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(circle_indices),
                   circle_indices, GL_STATIC_DRAW);
    }
  }

  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\glfw_viewer.cc" startLine="(164, 0)" endLine="(272, 1)" clone_start="41" clone_end="58">
			<code function_name="GLFWViewer::OpenglInit()">bool GLFWViewer::OpenglInit() {
  glClearColor(bg_color_(0), bg_color_(1), bg_color_(2), 0.0);
  glClearDepth(1.0f);
  glShadeModel(GL_SMOOTH);
  glDepthFunc(GL_LEQUAL);
  // lighting
  GLfloat mat_shininess[] = {20.0};
  GLfloat light_position[] = {1.0, -1.0, 1.0, 0.0};
  GLfloat lmodel_ambient[] = {.5, .5, .5, 1.0};
  glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
  glLightfv(GL_LIGHT0, GL_POSITION, light_position);
  glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
  glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
  glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);
  glEnable(GL_LIGHT0);
  glEnable(GL_LIGHTING);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_NORMALIZE);
  glEnable(GL_COLOR_MATERIAL);

  // glew
  if (glewInit() != GLEW_OK) {
    AERROR &lt;&lt; "Failed to initialize glew !";
    exit(EXIT_FAILURE);
  }

  // allocation of vbo
  // point cloud
  {
    GLfloat cloud_colors[kPoint_Num_Per_Cloud_VAO_][3];
    GLuint cloud_indices[kPoint_Num_Per_Cloud_VAO_];
    for (int i = 0; i &lt; kPoint_Num_Per_Cloud_VAO_; i++) {
      cloud_colors[i][0] = 0.7;
      cloud_colors[i][1] = 0.7;
      cloud_colors[i][2] = 0.7;
      cloud_indices[i] = GLuint(i);
    }

    glGenVertexArrays(kCloud_VAO_Num_, cloud_VAO_buf_ids_);
    for (int i = 0; i &lt; kCloud_VAO_Num_; i++) {
      glBindVertexArray(cloud_VAO_buf_ids_[i]);

      glGenBuffers(NUM_VBO_TYPE, cloud_VBO_buf_ids_[i]);
      glBindBuffer(GL_ARRAY_BUFFER, cloud_VBO_buf_ids_[i][VBO_VERTICES]);
      glBufferData(GL_ARRAY_BUFFER, sizeof(cloud_verts_), cloud_verts_,
                   GL_STREAM_DRAW);
      glVertexPointer(3, GL_FLOAT, 0, BUFFER_OFFSET(0));
      glEnableClientState(GL_VERTEX_ARRAY);

      glBindBuffer(GL_ARRAY_BUFFER, cloud_VBO_buf_ids_[i][VBO_COLORS]);
      glBufferData(GL_ARRAY_BUFFER, sizeof(cloud_colors), cloud_colors,
                   GL_STREAM_DRAW);
      glColorPointer(3, GL_FLOAT, 0, BUFFER_OFFSET(0));
      glEnableClientState(GL_COLOR_ARRAY);

      glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,
                   cloud_VBO_buf_ids_[i][VBO_ELEMENTS]);
      glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(cloud_indices),
                   cloud_indices, GL_STREAM_DRAW);
    }
  }
  // circle
  {
    GLfloat circle_verts[kPoint_Num_Per_Circle_VAO_][3];
    GLfloat circle_colors[kPoint_Num_Per_Circle_VAO_][3];
    GLuint circle_indices[kPoint_Num_Per_Circle_VAO_];

    for (int i = 0; i &lt; kPoint_Num_Per_Circle_VAO_; ++i) {
      circle_verts[i][2] = -1.0;
      circle_colors[i][0] = 0.0;
      circle_colors[i][1] = 0.0;
      circle_colors[i][2] = 0.9;
      circle_indices[i] = GLuint(i);
    }

    float ang_interv =
        2 * M_PI / static_cast&lt;float&gt;(kPoint_Num_Per_Circle_VAO_);
    glGenVertexArrays(kCircle_VAO_Num_, circle_VAO_buf_ids_);
    for (int vao = 0; vao &lt; kCircle_VAO_Num_; ++vao) {
      for (int i = 0; i &lt; kPoint_Num_Per_Circle_VAO_; ++i) {
        float theta = i * ang_interv;
        circle_verts[i][0] = 20 * (vao + 1) * cos(theta);
        circle_verts[i][1] = 20 * (vao + 1) * sin(theta);
      }

      glBindVertexArray(circle_VAO_buf_ids_[vao]);

      glGenBuffers(NUM_VBO_TYPE, circle_VBO_buf_ids_[vao]);
      glBindBuffer(GL_ARRAY_BUFFER, circle_VBO_buf_ids_[vao][VBO_VERTICES]);
      glBufferData(GL_ARRAY_BUFFER, sizeof(circle_verts), circle_verts,
                   GL_STATIC_DRAW);
      glVertexPointer(3, GL_FLOAT, 0, BUFFER_OFFSET(0));
      glEnableClientState(GL_VERTEX_ARRAY);

      glBindBuffer(GL_ARRAY_BUFFER, circle_VBO_buf_ids_[vao][VBO_COLORS]);
      glBufferData(GL_ARRAY_BUFFER, sizeof(circle_colors), circle_colors,
                   GL_STATIC_DRAW);
      glColorPointer(3, GL_FLOAT, 0, BUFFER_OFFSET(0));
      glEnableClientState(GL_COLOR_ARRAY);

      glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,
                   circle_VBO_buf_ids_[vao][VBO_ELEMENTS]);
      glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(circle_indices),
                   circle_indices, GL_STATIC_DRAW);
    }
  }

  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(283, 0)" endLine="(318, 1)" clone_start="30" clone_end="36">
			<code function_name="TcpStream::write(const uint8_t* buffer, size_t length)">size_t TcpStream::write(const uint8_t* buffer, size_t length) {
  size_t total_nsent = 0;

  if (_status != Stream::Status::CONNECTED) {
    disconnect();
    connect();
    if (_status != Stream::Status::CONNECTED) {
      return 0;
    }
  }

  while (length &gt; 0) {
    ssize_t nsent = ::send(_sockfd, buffer, length, 0);
    if (nsent &lt; 0) {
      if (errno == EINTR) {
        continue;
      } else {
        // error
        if (errno == EPIPE || errno == ECONNRESET) {
          _status = Stream::Status::DISCONNECTED;
          _errno = errno;
        } else if (errno != EAGAIN) {
          _status = Stream::Status::ERROR;
          _errno = errno;
        }
        return total_nsent;
      }
    }

    total_nsent += nsent;
    length -= nsent;
    buffer += nsent;
  }

  return total_nsent;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(334, 0)" endLine="(386, 1)" clone_start="47" clone_end="53">
			<code function_name="SerialStream::write(const uint8_t* data, size_t length)">size_t SerialStream::write(const uint8_t* data, size_t length) {
  if (!_is_open) {
    if (!connect()) {
      return 0;
    }
    ROS_INFO_STREAM("Connect " &lt;&lt; _device_name &lt;&lt; " success.");
  }

  size_t total_nsent = 0;
  size_t delay_times = 0;

  while ((length &gt; 0) &amp;&amp; (delay_times &lt; 5)) {
    ssize_t nsent = ::write(_fd, data, length);
    if (nsent &lt; 0) {
      ROS_ERROR_STREAM(
          "Serial stream write data failed, error: " &lt;&lt; strerror(errno));
      switch (errno) {
        case EAGAIN:
        case EINVAL:
          nsent = 0;
          break;

        case EBADF:
        case EIO:
          disconnect();
          if (connect()) {
            ROS_INFO_STREAM("Reconnect " &lt;&lt; _device_name &lt;&lt; "success.");
            nsent = 0;
            break;  // has recoverable
          }

        default:
          _status = Stream::Status::ERROR;
          _errno = errno;
          return total_nsent;
      }
    }

    if (nsent == 0) {
      if (!wait_writable(_byte_time_us)) {
        break;
      }
      ++delay_times;
      continue;
    }

    total_nsent += nsent;
    length -= nsent;
    data += nsent;
  }

  return total_nsent;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(320, 0)" endLine="(340, 1)" clone_start="1" clone_end="10">
			<code function_name="TcpStream::readable(uint32_t timeout_us)">bool TcpStream::readable(uint32_t timeout_us) {
  // Setup a select call to block for serial data or a timeout
  timespec timeout_ts;
  fd_set readfds;
  FD_ZERO(&amp;readfds);
  FD_SET(_sockfd, &amp;readfds);

  timeout_ts.tv_sec = timeout_us / 1000000;
  timeout_ts.tv_nsec = (timeout_us % 1000000) * 1000;
  int r = pselect(_sockfd + 1, &amp;readfds, NULL, NULL, &amp;timeout_ts, NULL);
  if (r &lt; 0) {
    _status = Stream::Status::ERROR;
    _errno = errno;
    ROS_ERROR("Failed to wait tcp data: %d, %s", errno, strerror(errno));
    return false;
  } else if (r == 0 || !FD_ISSET(_sockfd, &amp;readfds)) {
    return false;
  }
  // Data available to read.
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(388, 0)" endLine="(408, 1)" clone_start="1" clone_end="10">
			<code function_name="SerialStream::wait_readable(uint32_t timeout_us)">bool SerialStream::wait_readable(uint32_t timeout_us) {
  // Setup a select call to block for serial data or a timeout
  timespec timeout_ts;
  fd_set readfds;
  FD_ZERO(&amp;readfds);
  FD_SET(_fd, &amp;readfds);

  timeout_ts.tv_sec = timeout_us / 1000000;
  timeout_ts.tv_nsec = (timeout_us % 1000000) * 1000;
  int r = pselect(_fd + 1, &amp;readfds, NULL, NULL, &amp;timeout_ts, NULL);
  if (r &lt;= 0) {
    return false;
  }

  // This shouldn't happen, if r &gt; 0 our fd has to be in the list!
  if (!FD_ISSET(_fd, &amp;readfds)) {
    return false;
  }
  // Data available to read.
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\map\map_service.cc" startLine="(128, 0)" endLine="(171, 1)" clone_start="11" clone_end="28">
			<code function_name="MapService::CollectMapElementIds(const PointENU &amp;point, double radius) const">MapElementIds MapService::CollectMapElementIds(const PointENU &amp;point,
                                               double radius) const {
  MapElementIds result;

  std::vector&lt;LaneInfoConstPtr&gt; lanes;
  if (sim_map_.GetLanes(point, radius, &amp;lanes) != 0) {
    AERROR &lt;&lt; "Fail to get lanes from sim_map.";
  }
  ExtractIds(lanes, &amp;result.lane);

  std::vector&lt;CrosswalkInfoConstPtr&gt; crosswalks;
  if (sim_map_.GetCrosswalks(point, radius, &amp;crosswalks) != 0) {
    AERROR &lt;&lt; "Fail to get crosswalks from sim_map.";
  }
  ExtractIds(crosswalks, &amp;result.crosswalk);

  std::vector&lt;JunctionInfoConstPtr&gt; junctions;
  if (sim_map_.GetJunctions(point, radius, &amp;junctions) != 0) {
    AERROR &lt;&lt; "Fail to get junctions from sim_map.";
  }
  ExtractIds(junctions, &amp;result.junction);

  std::vector&lt;SignalInfoConstPtr&gt; signals;
  if (sim_map_.GetSignals(point, radius, &amp;signals) != 0) {
    AERROR &lt;&lt; "Failed to get signals from sim_map.";
  }

  ExtractIds(signals, &amp;result.signal);
  ExtractOverlapIds(signals, &amp;result.overlap);

  std::vector&lt;StopSignInfoConstPtr&gt; stop_signs;
  if (sim_map_.GetStopSigns(point, radius, &amp;stop_signs) != 0) {
    AERROR &lt;&lt; "Failed to get stop signs from sim_map.";
  }
  ExtractIds(stop_signs, &amp;result.stop_sign);

  std::vector&lt;YieldSignInfoConstPtr&gt; yield_signs;
  if (sim_map_.GetYieldSigns(point, radius, &amp;yield_signs) != 0) {
    AERROR &lt;&lt; "Failed to get yield signs from sim_map.";
  }
  ExtractIds(yield_signs, &amp;result.yield);

  return result;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\map\map_service.cc" startLine="(128, 0)" endLine="(171, 1)" clone_start="5" clone_end="21">
			<code function_name="MapService::CollectMapElementIds(const PointENU &amp;point, double radius) const">MapElementIds MapService::CollectMapElementIds(const PointENU &amp;point,
                                               double radius) const {
  MapElementIds result;

  std::vector&lt;LaneInfoConstPtr&gt; lanes;
  if (sim_map_.GetLanes(point, radius, &amp;lanes) != 0) {
    AERROR &lt;&lt; "Fail to get lanes from sim_map.";
  }
  ExtractIds(lanes, &amp;result.lane);

  std::vector&lt;CrosswalkInfoConstPtr&gt; crosswalks;
  if (sim_map_.GetCrosswalks(point, radius, &amp;crosswalks) != 0) {
    AERROR &lt;&lt; "Fail to get crosswalks from sim_map.";
  }
  ExtractIds(crosswalks, &amp;result.crosswalk);

  std::vector&lt;JunctionInfoConstPtr&gt; junctions;
  if (sim_map_.GetJunctions(point, radius, &amp;junctions) != 0) {
    AERROR &lt;&lt; "Fail to get junctions from sim_map.";
  }
  ExtractIds(junctions, &amp;result.junction);

  std::vector&lt;SignalInfoConstPtr&gt; signals;
  if (sim_map_.GetSignals(point, radius, &amp;signals) != 0) {
    AERROR &lt;&lt; "Failed to get signals from sim_map.";
  }

  ExtractIds(signals, &amp;result.signal);
  ExtractOverlapIds(signals, &amp;result.overlap);

  std::vector&lt;StopSignInfoConstPtr&gt; stop_signs;
  if (sim_map_.GetStopSigns(point, radius, &amp;stop_signs) != 0) {
    AERROR &lt;&lt; "Failed to get stop signs from sim_map.";
  }
  ExtractIds(stop_signs, &amp;result.stop_sign);

  std::vector&lt;YieldSignInfoConstPtr&gt; yield_signs;
  if (sim_map_.GetYieldSigns(point, radius, &amp;yield_signs) != 0) {
    AERROR &lt;&lt; "Failed to get yield signs from sim_map.";
  }
  ExtractIds(yield_signs, &amp;result.yield);

  return result;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(135, 0)" endLine="(141, 1)" clone_start="1" clone_end="7">
			<code function_name="UdpStream::close()">void UdpStream::close() {
  if (_sockfd &gt; 0) {
    ::close(_sockfd);
    _sockfd = -1;
    _status = Stream::Status::DISCONNECTED;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(128, 0)" endLine="(134, 1)" clone_start="1" clone_end="7">
			<code function_name="TcpStream::close()">void TcpStream::close() {
  if (_sockfd &gt; 0) {
    ::close(_sockfd);
    _sockfd = -1;
    _status = Stream::Status::DISCONNECTED;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(143, 0)" endLine="(159, 1)" clone_start="1" clone_end="10">
			<code function_name="UdpStream::connect()">bool UdpStream::connect() {
  if (_sockfd &lt; 0) {
    this-&gt;open();
    if (_sockfd &lt; 0) {
      return false;
    }
  }

  if (_status == Stream::Status::CONNECTED) {
    return true;
  }

  // upper layer support ping method ??
  login();
  _status = Stream::Status::CONNECTED;
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(136, 0)" endLine="(228, 1)" clone_start="1" clone_end="11">
			<code function_name="TcpStream::connect()">bool TcpStream::connect() {
  if (_sockfd &lt; 0) {
    this-&gt;open();
    if (_sockfd &lt; 0) {
      // error
      return false;
    }
  }

  if (_status == Stream::Status::CONNECTED) {
    return true;
  }

  fd_set fds;
  timeval timeo = {10, 0};
  int ret = 0;
  sockaddr_in peer_addr;

  bzero(&amp;peer_addr, sizeof(peer_addr));
  peer_addr.sin_family = AF_INET;
  peer_addr.sin_port = _peer_port;
  peer_addr.sin_addr.s_addr = _peer_addr;

  int fd_flags = fcntl(_sockfd, F_GETFL);
  if (fd_flags &lt; 0 || fcntl(_sockfd, F_SETFL, fd_flags | O_NONBLOCK) &lt; 0) {
    ROS_ERROR_STREAM("Failed to set noblock, error: " &lt;&lt; strerror(errno));
    return false;
  }

  while ((ret = ::connect(_sockfd, reinterpret_cast&lt;sockaddr*&gt;(&amp;peer_addr),
                          sizeof(peer_addr))) &lt; 0) {
    if (errno == EINTR) {
      ROS_INFO("Tcp connect return EINTR.");
      continue;
    } else {
      if ((errno != EISCONN) &amp;&amp; (errno != EINPROGRESS) &amp;&amp; (errno != EALREADY)) {
        _status = Stream::Status::ERROR;
        _errno = errno;
        ROS_ERROR_STREAM("Connect failed, error: " &lt;&lt; strerror(errno));
        return false;
      }

      FD_ZERO(&amp;fds);
      FD_SET(_sockfd, &amp;fds);
      ret = select(_sockfd + 1, NULL, &amp;fds, NULL, &amp;timeo);
      if (ret &lt; 0) {
        _status = Stream::Status::ERROR;
        _errno = errno;
        ROS_ERROR_STREAM("Wait connect failed, error: " &lt;&lt; strerror(errno));
        return false;
      } else if (ret == 0) {
        ROS_INFO("Tcp connect timeout.");
        return false;
      } else if (FD_ISSET(_sockfd, &amp;fds)) {
        int error = 0;
        socklen_t len = sizeof(int);

        if (getsockopt(_sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len) &lt; 0) {
          _status = Stream::Status::ERROR;
          _errno = errno;
          ROS_ERROR_STREAM("Getsockopt failed, error: " &lt;&lt; strerror(errno));
          return false;
        }
        if (error != 0) {
          _status = Stream::Status::ERROR;
          _errno = errno;
          ROS_ERROR_STREAM("Socket error: " &lt;&lt; strerror(errno));
          return false;
        }

        // connect successfully
        break;
      } else {
        _status = Stream::Status::ERROR;
        _errno = errno;
        ROS_ERROR("Should not be here.");
        return false;
      }
    }
  }

  if (!init_socket()) {
    close();
    _status = Stream::Status::ERROR;
    _errno = errno;
    ROS_ERROR("Failed to init socket.");
    return false;
  }
  ROS_INFO("Tcp connect success.");
  _status = Stream::Status::CONNECTED;
  login();
  return true;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(26, 0)" endLine="(50, 1)" clone_start="1" clone_end="19">
			<code function_name="Throttle63::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Throttle63::Parse(const std::uint8_t *bytes, int32_t length,
                       ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_gas()-&gt;set_throttle_input(pedal_input(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_throttle_cmd(pedal_cmd(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_throttle_output(
      pedal_output(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_throttle_enabled(
      is_enabled(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  chassis_detail-&gt;mutable_check_response()-&gt;set_is_vcu_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(26, 0)" endLine="(41, 1)" clone_start="1" clone_end="14">
			<code function_name="Gps6e::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Gps6e::Parse(const std::uint8_t *bytes, int32_t length,
                  ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_basic()-&gt;set_year(year(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_month(month(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_day(day(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_hours(hours(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_minutes(minutes(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_seconds(seconds(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_compass_direction(
      compass_direction(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_pdop(pdop(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_is_gps_fault(
      is_gps_fault(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_is_inferred(
      is_inferred_position(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(29, 0)" endLine="(59, 1)" clone_start="1" clone_end="15">
			<code function_name="Brake61::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brake61::Parse(const std::uint8_t *bytes, int32_t length,
                    ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_output(
      pedal_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  chassis_detail-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(239, 0)" endLine="(374, 1)" clone_start="44" clone_end="61">
			<code function_name="NovatelParser::prepare_message(MessagePtr&amp; message_ptr)">Parser::MessageType NovatelParser::prepare_message(MessagePtr&amp; message_ptr) {
  if (!check_crc()) {
    ROS_ERROR("CRC check failed.");
    return MessageType::NONE;
  }

  uint8_t* message = nullptr;
  novatel::MessageId message_id;
  uint16_t message_length;
  uint16_t gps_week;
  uint32_t gps_millisecs;
  if (_buffer[2] == novatel::SYNC_2_LONG_HEADER) {
    auto header = reinterpret_cast&lt;const novatel::LongHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::LongHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  } else {
    auto header = reinterpret_cast&lt;const novatel::ShortHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::ShortHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  }
  switch (message_id) {
    case novatel::BESTGNSSPOS:
    case novatel::BESTPOS:
    case novatel::PSRPOS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestPos), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestPos)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_pos(reinterpret_cast&lt;novatel::BestPos*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::BESTGNSSVEL:
    case novatel::BESTVEL:
    case novatel::PSRVEL:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestVel), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestVel)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_vel(reinterpret_cast&lt;novatel::BestVel*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::CORRIMUDATA:
    case novatel::CORRIMUDATAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::CorrImuData),
      // "Incorrect message_length");
      if (message_length != sizeof(novatel::CorrImuData)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_corr_imu_data(
              reinterpret_cast&lt;novatel::CorrImuData*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSCOV:
    case novatel::INSCOVS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsCov), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsCov)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_cov(reinterpret_cast&lt;novatel::InsCov*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSPVA:
    case novatel::INSPVAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsPva), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsPva)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_pva(reinterpret_cast&lt;novatel::InsPva*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::RAWIMUX:
    case novatel::RAWIMUSX:
      // ROS_ERROR_COND(message_length != sizeof(novatel::RawImuX), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::RawImuX)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_raw_imu_x(reinterpret_cast&lt;novatel::RawImuX*&gt;(message))) {
        message_ptr = &amp;_imu;
        return MessageType::IMU;
      }
      break;

    case novatel::INSPVAX:
        if (message_length != sizeof(novatel::InsPvaX)) {
          ROS_ERROR("Incorrect message_length");
          break;
        }

        if (handle_ins_pvax(reinterpret_cast&lt;novatel::InsPvaX*&gt;(message))) {
          message_ptr = &amp;_ins_stat;
          return MessageType::INS_STAT;
        }
        break;
    default:
      break;
  }
  return MessageType::NONE;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(239, 0)" endLine="(374, 1)" clone_start="28" clone_end="45">
			<code function_name="NovatelParser::prepare_message(MessagePtr&amp; message_ptr)">Parser::MessageType NovatelParser::prepare_message(MessagePtr&amp; message_ptr) {
  if (!check_crc()) {
    ROS_ERROR("CRC check failed.");
    return MessageType::NONE;
  }

  uint8_t* message = nullptr;
  novatel::MessageId message_id;
  uint16_t message_length;
  uint16_t gps_week;
  uint32_t gps_millisecs;
  if (_buffer[2] == novatel::SYNC_2_LONG_HEADER) {
    auto header = reinterpret_cast&lt;const novatel::LongHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::LongHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  } else {
    auto header = reinterpret_cast&lt;const novatel::ShortHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::ShortHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  }
  switch (message_id) {
    case novatel::BESTGNSSPOS:
    case novatel::BESTPOS:
    case novatel::PSRPOS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestPos), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestPos)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_pos(reinterpret_cast&lt;novatel::BestPos*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::BESTGNSSVEL:
    case novatel::BESTVEL:
    case novatel::PSRVEL:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestVel), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestVel)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_vel(reinterpret_cast&lt;novatel::BestVel*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::CORRIMUDATA:
    case novatel::CORRIMUDATAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::CorrImuData),
      // "Incorrect message_length");
      if (message_length != sizeof(novatel::CorrImuData)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_corr_imu_data(
              reinterpret_cast&lt;novatel::CorrImuData*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSCOV:
    case novatel::INSCOVS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsCov), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsCov)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_cov(reinterpret_cast&lt;novatel::InsCov*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSPVA:
    case novatel::INSPVAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsPva), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsPva)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_pva(reinterpret_cast&lt;novatel::InsPva*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::RAWIMUX:
    case novatel::RAWIMUSX:
      // ROS_ERROR_COND(message_length != sizeof(novatel::RawImuX), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::RawImuX)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_raw_imu_x(reinterpret_cast&lt;novatel::RawImuX*&gt;(message))) {
        message_ptr = &amp;_imu;
        return MessageType::IMU;
      }
      break;

    case novatel::INSPVAX:
        if (message_length != sizeof(novatel::InsPvaX)) {
          ROS_ERROR("Incorrect message_length");
          break;
        }

        if (handle_ins_pvax(reinterpret_cast&lt;novatel::InsPvaX*&gt;(message))) {
          message_ptr = &amp;_ins_stat;
          return MessageType::INS_STAT;
        }
        break;
    default:
      break;
  }
  return MessageType::NONE;
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(144, 2)" endLine="(146, 3)" clone_start="1" clone_end="3">
			<code function_name="name() const override">  std::string name() const override {
    return "DummyObjectFilter";
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(95, 2)" endLine="(97, 3)" clone_start="1" clone_end="3">
			<code function_name="name() const override">  std::string name() const override {
    return "DummySegmentation";
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(69, 2)" endLine="(71, 3)" clone_start="1" clone_end="3">
			<code function_name="name() const override">  std::string name() const override {
    return "DummyGroundDetector";
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(44, 2)" endLine="(46, 3)" clone_start="1" clone_end="3">
			<code function_name="name() const override">  std::string name() const override {
    return "DummyROIFilter";
  }</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(157, 2)" endLine="(157, 35)" clone_start="1" clone_end="1">
			<code function_name="DummyTracker()">  DummyTracker() : BaseTracker() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(108, 2)" endLine="(108, 47)" clone_start="1" clone_end="1">
			<code function_name="DummyObjectBuilder()">  DummyObjectBuilder() : BaseObjectBuilder() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(83, 2)" endLine="(83, 45)" clone_start="1" clone_end="1">
			<code function_name="DummySegmentation()">  DummySegmentation() : BaseSegmentation() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(58, 2)" endLine="(58, 49)" clone_start="1" clone_end="1">
			<code function_name="DummyGroundDetector()">  DummyGroundDetector() : BaseGroundDetector() {}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(158, 2)" endLine="(158, 28)" clone_start="1" clone_end="1">
			<code function_name="~DummyTracker()">  ~DummyTracker() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(109, 2)" endLine="(109, 34)" clone_start="1" clone_end="1">
			<code function_name="~DummyObjectBuilder()">  ~DummyObjectBuilder() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(84, 2)" endLine="(84, 33)" clone_start="1" clone_end="1">
			<code function_name="~DummySegmentation()">  ~DummySegmentation() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(59, 2)" endLine="(59, 35)" clone_start="1" clone_end="1">
			<code function_name="~DummyGroundDetector()">  ~DummyGroundDetector() = default;</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(160, 2)" endLine="(162, 3)" clone_start="1" clone_end="2">
			<code function_name="Init() override">  bool Init() override {
    return result_init_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(111, 2)" endLine="(113, 3)" clone_start="1" clone_end="2">
			<code function_name="Init() override">  bool Init() override {
    return result_init_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(86, 2)" endLine="(88, 3)" clone_start="1" clone_end="2">
			<code function_name="Init() override">  bool Init() override {
    return result_init_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.h" startLine="(61, 2)" endLine="(63, 3)" clone_start="1" clone_end="2">
			<code function_name="Init() override">  bool Init() override {
    return result_init_;
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\message_manager.h" startLine="(131, 0)" endLine="(144, 1)" clone_start="1" clone_end="12">
			<code function_name="MessageManager::AddSendProtocolData()">void MessageManager::AddSendProtocolData() {
  send_protocol_data_.emplace_back(new T());
  auto *dt = send_protocol_data_.back().get();
  if (dt == nullptr) {
    return;
  }
  protocol_data_map_[T::ID] = dt;
  if (need_check) {
    check_ids_[T::ID].period = dt-&gt;GetPeriod();
    check_ids_[T::ID].real_period = 0;
    check_ids_[T::ID].last_time = 0;
    check_ids_[T::ID].error_count = 0;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\message_manager.h" startLine="(115, 0)" endLine="(128, 1)" clone_start="1" clone_end="12">
			<code function_name="MessageManager::AddRecvProtocolData()">void MessageManager::AddRecvProtocolData() {
  recv_protocol_data_.emplace_back(new T());
  auto *dt = recv_protocol_data_.back().get();
  if (dt == nullptr) {
    return;
  }
  protocol_data_map_[T::ID] = dt;
  if (need_check) {
    check_ids_[T::ID].period = dt-&gt;GetPeriod();
    check_ids_[T::ID].real_period = 0;
    check_ids_[T::ID].last_time = 0;
    check_ids_[T::ID].error_count = 0;
  }
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(288, 0)" endLine="(309, 1)" clone_start="21" clone_end="22">
			<code function_name="Spline2dConstraint::AddSmoothConstraint()">bool Spline2dConstraint::AddSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(2 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(2 * (t_knots_.size() - 2), 1);
  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);

    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(2 * i, j + index_offset) = power_t[j];
      affine_equality(2 * i + 1, j + index_offset + spline_order_) = power_t[j];
    }
    affine_equality(2 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(2 * i + 1, index_offset + 3 * spline_order_) = -1.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(243, 0)" endLine="(285, 1)" clone_start="42" clone_end="43">
			<code function_name="Spline2dConstraint::AddPointAngleConstraint(const double t, const double angle)">bool Spline2dConstraint::AddPointAngleConstraint(const double t,
                                                 const double angle) {
  const std::uint32_t index = FindIndex(t);
  const std::uint32_t index_offset = index * 2 * spline_order_;
  const double rel_t = t - t_knots_[index];

  // add equality constraint
  Eigen::MatrixXd affine_equality = Eigen::MatrixXd::Zero(1, total_param_);
  Eigen::MatrixXd affine_boundary = Eigen::MatrixXd::Zero(1, 1);
  std::vector&lt;double&gt; line_derivative_coef = AffineDerivativeCoef(angle, rel_t);
  for (std::uint32_t i = 0; i &lt; line_derivative_coef.size(); ++i) {
    affine_equality(0, i + index_offset) = line_derivative_coef[i];
  }

  // add inequality constraint
  Eigen::MatrixXd affine_inequality = Eigen::MatrixXd::Zero(2, total_param_);
  Eigen::MatrixXd affine_inequality_boundary = Eigen::MatrixXd::Zero(2, 1);
  std::vector&lt;double&gt; t_coef = DerivativeCoef(rel_t);
  int x_sign = 1;
  int y_sign = 1;
  double normalized_angle = fmod(angle, M_PI * 2);
  if (normalized_angle &lt; 0) {
    normalized_angle += M_PI * 2;
  }
  if (normalized_angle &gt; (M_PI / 2) &amp;&amp; normalized_angle &lt; (M_PI * 1.5)) {
    x_sign = -1;
    affine_inequality_boundary(0, 0) *= -1;
  }

  if (normalized_angle &gt;= M_PI) {
    y_sign = -1;
    affine_inequality_boundary(1, 0) *= -1;
  }

  for (std::uint32_t i = 0; i &lt; t_coef.size(); ++i) {
    affine_inequality(0, i + index_offset) = t_coef[i] * x_sign;
    affine_inequality(1, i + index_offset + spline_order_) = t_coef[i] * y_sign;
  }
  if (!AddEqualityConstraint(affine_equality, affine_boundary)) {
    return false;
  }
  return AddInequalityConstraint(affine_inequality, affine_inequality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(342, 0)" endLine="(375, 1)" clone_start="33" clone_end="34">
			<code function_name="Spline2dConstraint::AddSecondDerivativeSmoothConstraint()">bool Spline2dConstraint::AddSecondDerivativeSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(6 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(6 * (t_knots_.size() - 2), 1);

  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);
    std::vector&lt;double&gt; derivative_t = DerivativeCoef(rel_t);
    std::vector&lt;double&gt; second_derivative_t = SecondDerivativeCoef(rel_t);
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(6 * i, j + index_offset) = power_t[j];
      affine_equality(6 * i + 1, j + index_offset) = derivative_t[j];
      affine_equality(6 * i + 2, j + index_offset) = second_derivative_t[j];
      affine_equality(6 * i + 3, j + index_offset + spline_order_) = power_t[j];
      affine_equality(6 * i + 4, j + index_offset + spline_order_) =
          derivative_t[j];
      affine_equality(6 * i + 5, j + index_offset + spline_order_) =
          second_derivative_t[j];
    }
    affine_equality(6 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(6 * i + 1, index_offset + 2 * spline_order_ + 1) = -1.0;
    affine_equality(6 * i + 2, index_offset + 2 * spline_order_ + 2) = -2.0;
    affine_equality(6 * i + 3, index_offset + 3 * spline_order_) = -1.0;
    affine_equality(6 * i + 4, index_offset + 3 * spline_order_ + 1) = -1.0;
    affine_equality(6 * i + 5, index_offset + 3 * spline_order_ + 2) = -2.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(312, 0)" endLine="(339, 1)" clone_start="27" clone_end="28">
			<code function_name="Spline2dConstraint::AddDerivativeSmoothConstraint()">bool Spline2dConstraint::AddDerivativeSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(4 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(4 * (t_knots_.size() - 2), 1);

  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);
    std::vector&lt;double&gt; derivative_t = DerivativeCoef(rel_t);
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(4 * i, j + index_offset) = power_t[j];
      affine_equality(4 * i + 1, j + index_offset) = derivative_t[j];
      affine_equality(4 * i + 2, j + index_offset + spline_order_) = power_t[j];
      affine_equality(4 * i + 3, j + index_offset + spline_order_) =
          derivative_t[j];
    }
    affine_equality(4 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(4 * i + 1, index_offset + 2 * spline_order_ + 1) = -1.0;
    affine_equality(4 * i + 2, index_offset + 3 * spline_order_) = -1.0;
    affine_equality(4 * i + 3, index_offset + 3 * spline_order_ + 1) = -1.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(312, 0)" endLine="(339, 1)" clone_start="1" clone_end="13">
			<code function_name="Spline2dConstraint::AddDerivativeSmoothConstraint()">bool Spline2dConstraint::AddDerivativeSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(4 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(4 * (t_knots_.size() - 2), 1);

  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);
    std::vector&lt;double&gt; derivative_t = DerivativeCoef(rel_t);
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(4 * i, j + index_offset) = power_t[j];
      affine_equality(4 * i + 1, j + index_offset) = derivative_t[j];
      affine_equality(4 * i + 2, j + index_offset + spline_order_) = power_t[j];
      affine_equality(4 * i + 3, j + index_offset + spline_order_) =
          derivative_t[j];
    }
    affine_equality(4 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(4 * i + 1, index_offset + 2 * spline_order_ + 1) = -1.0;
    affine_equality(4 * i + 2, index_offset + 3 * spline_order_) = -1.0;
    affine_equality(4 * i + 3, index_offset + 3 * spline_order_ + 1) = -1.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(288, 0)" endLine="(309, 1)" clone_start="1" clone_end="12">
			<code function_name="Spline2dConstraint::AddSmoothConstraint()">bool Spline2dConstraint::AddSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(2 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(2 * (t_knots_.size() - 2), 1);
  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);

    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(2 * i, j + index_offset) = power_t[j];
      affine_equality(2 * i + 1, j + index_offset + spline_order_) = power_t[j];
    }
    affine_equality(2 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(2 * i + 1, index_offset + 3 * spline_order_) = -1.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(378, 0)" endLine="(417, 1)" clone_start="1" clone_end="13">
			<code function_name="Spline2dConstraint::AddThirdDerivativeSmoothConstraint()">bool Spline2dConstraint::AddThirdDerivativeSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(8 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(8 * (t_knots_.size() - 2), 1);

  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);
    std::vector&lt;double&gt; derivative_t = DerivativeCoef(rel_t);
    std::vector&lt;double&gt; second_derivative_t = SecondDerivativeCoef(rel_t);
    std::vector&lt;double&gt; third_derivative_t = ThirdDerivativeCoef(rel_t);
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(8 * i, j + index_offset) = power_t[j];
      affine_equality(8 * i + 1, j + index_offset) = derivative_t[j];
      affine_equality(8 * i + 2, j + index_offset) = second_derivative_t[j];
      affine_equality(8 * i + 3, j + index_offset) = third_derivative_t[j];
      affine_equality(8 * i + 4, j + index_offset + spline_order_) = power_t[j];
      affine_equality(8 * i + 5, j + index_offset + spline_order_) =
          derivative_t[j];
      affine_equality(8 * i + 6, j + index_offset + spline_order_) =
          second_derivative_t[j];
      affine_equality(8 * i + 7, j + index_offset + spline_order_) =
          third_derivative_t[j];
    }
    affine_equality(8 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(8 * i + 1, index_offset + 2 * spline_order_ + 1) = -1.0;
    affine_equality(8 * i + 2, index_offset + 2 * spline_order_ + 2) = -2.0;
    affine_equality(8 * i + 3, index_offset + 2 * spline_order_ + 3) = -6.0;
    affine_equality(8 * i + 4, index_offset + 3 * spline_order_) = -1.0;
    affine_equality(8 * i + 5, index_offset + 3 * spline_order_ + 1) = -1.0;
    affine_equality(8 * i + 6, index_offset + 3 * spline_order_ + 2) = -2.0;
    affine_equality(8 * i + 7, index_offset + 3 * spline_order_ + 3) = -6.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(342, 0)" endLine="(375, 1)" clone_start="1" clone_end="13">
			<code function_name="Spline2dConstraint::AddSecondDerivativeSmoothConstraint()">bool Spline2dConstraint::AddSecondDerivativeSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(6 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(6 * (t_knots_.size() - 2), 1);

  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);
    std::vector&lt;double&gt; derivative_t = DerivativeCoef(rel_t);
    std::vector&lt;double&gt; second_derivative_t = SecondDerivativeCoef(rel_t);
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(6 * i, j + index_offset) = power_t[j];
      affine_equality(6 * i + 1, j + index_offset) = derivative_t[j];
      affine_equality(6 * i + 2, j + index_offset) = second_derivative_t[j];
      affine_equality(6 * i + 3, j + index_offset + spline_order_) = power_t[j];
      affine_equality(6 * i + 4, j + index_offset + spline_order_) =
          derivative_t[j];
      affine_equality(6 * i + 5, j + index_offset + spline_order_) =
          second_derivative_t[j];
    }
    affine_equality(6 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(6 * i + 1, index_offset + 2 * spline_order_ + 1) = -1.0;
    affine_equality(6 * i + 2, index_offset + 2 * spline_order_ + 2) = -2.0;
    affine_equality(6 * i + 3, index_offset + 3 * spline_order_) = -1.0;
    affine_equality(6 * i + 4, index_offset + 3 * spline_order_ + 1) = -1.0;
    affine_equality(6 * i + 5, index_offset + 3 * spline_order_ + 2) = -2.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(111, 0)" endLine="(151, 1)" clone_start="9" clone_end="25">
			<code function_name="ProtoOrganizer::GetLaneObjectOverlapElements(const std::string&amp; lane_id, const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes)">void ProtoOrganizer::GetLaneObjectOverlapElements(
    const std::string&amp; lane_id,
    const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes) {
  for (auto&amp; overlap_object : overlap_with_lanes) {
    std::string object_id = overlap_object.object_id;
    if (proto_data_.pb_crosswalks.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_clear_areas.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_speed_bumps.count(object_id) &lt;= 0) {
      continue;
    }
    PbOverlap overlap;
    std::string overlap_id = CreateOverlapId();
    proto_data_.pb_lanes[lane_id].add_overlap_id()-&gt;set_id(overlap_id);
    overlap.mutable_id()-&gt;set_id(overlap_id);
    PbObjectOverlapInfo* object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(lane_id);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_start_s(
        overlap_object.start_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_end_s(
        overlap_object.end_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_is_merge(
        overlap_object.is_merge);
    object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
    if (proto_data_.pb_crosswalks.count(object_id) &gt; 0) {
      proto_data_.pb_crosswalks[object_id].add_overlap_id()-&gt;set_id(overlap_id);
      object_overlap-&gt;mutable_crosswalk_overlap_info();
    } else if (proto_data_.pb_clear_areas.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_clear_area_overlap_info();
      proto_data_.pb_clear_areas[object_id].add_overlap_id()-&gt;set_id(
          overlap_id);
    } else if (proto_data_.pb_speed_bumps.count(object_id)) {
      object_overlap-&gt;mutable_speed_bump_overlap_info();
      proto_data_.pb_speed_bumps[object_id].add_overlap_id()-&gt;set_id(
          overlap_id);
    } else {
      AERROR &lt;&lt; "unknown object, object id:" &lt;&lt; object_id;
    }
    proto_data_.pb_overlaps[overlap_id] = overlap;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(153, 0)" endLine="(193, 1)" clone_start="10" clone_end="26">
			<code function_name="ProtoOrganizer::GetLaneSignalOverlapElements(    const std::string&amp; lane_id, const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes)">void ProtoOrganizer::GetLaneSignalOverlapElements(
    const std::string&amp; lane_id,
    const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes) {
  for (auto&amp; overlap_signal : overlap_with_lanes) {
    std::string object_id = overlap_signal.object_id;
    if (proto_data_.pb_signals.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_stop_signs.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_yield_signs.count(object_id) &lt;= 0) {
      AINFO &lt;&lt; "cannot find signal object_id:" &lt;&lt; object_id;
      continue;
    }
    PbOverlap overlap;
    std::string overlap_id = CreateOverlapId();
    proto_data_.pb_lanes[lane_id].add_overlap_id()-&gt;set_id(overlap_id);
    overlap.mutable_id()-&gt;set_id(overlap_id);
    PbObjectOverlapInfo* object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(lane_id);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_start_s(
        overlap_signal.start_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_end_s(
        overlap_signal.end_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_is_merge(
        overlap_signal.is_merge);
    object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
    if (proto_data_.pb_signals.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_signal_overlap_info();
      proto_data_.pb_signals[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    } else if (proto_data_.pb_stop_signs.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_stop_sign_overlap_info();
      proto_data_.pb_stop_signs[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    } else if (proto_data_.pb_yield_signs.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_yield_sign_overlap_info();
      proto_data_.pb_yield_signs[object_id].add_overlap_id()-&gt;set_id(
          overlap_id);
    } else {
      AERROR &lt;&lt; "unknown signal, signal id:" &lt;&lt; object_id;
    }
    proto_data_.pb_overlaps[overlap_id] = overlap;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(195, 0)" endLine="(226, 1)" clone_start="8" clone_end="24">
			<code function_name="ProtoOrganizer::GetLaneJunctionOverlapElements(    const std::string&amp; lane_id, const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes)">void ProtoOrganizer::GetLaneJunctionOverlapElements(
    const std::string&amp; lane_id,
    const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes) {
  for (auto&amp; overlap_junction : overlap_with_lanes) {
    std::string object_id = overlap_junction.object_id;
    if (proto_data_.pb_junctions.count(object_id) &lt;= 0) {
      AINFO &lt;&lt; "cannot find junction object " &lt;&lt; object_id;
      continue;
    }
    PbOverlap overlap;
    std::string overlap_id = CreateOverlapId();
    proto_data_.pb_lanes[lane_id].add_overlap_id()-&gt;set_id(overlap_id);
    overlap.mutable_id()-&gt;set_id(overlap_id);
    PbObjectOverlapInfo* object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(lane_id);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_start_s(
        overlap_junction.start_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_end_s(
        overlap_junction.end_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_is_merge(
        overlap_junction.is_merge);
    object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
    if (proto_data_.pb_junctions.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_junction_overlap_info();
      proto_data_.pb_junctions[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    } else {
      AERROR &lt;&lt; "unknown junction overlap, id:" &lt;&lt; object_id;
    }
    proto_data_.pb_overlaps[overlap_id] = overlap;
  }
}</code>
		</source>
	</dup>
	<dup count="6">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="59" clone_end="81">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="103" clone_end="122">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="176" clone_end="198">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="165" clone_end="187">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="154" clone_end="176">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="142" clone_end="165">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\can_client\can_client_tool.cc" startLine="(248, 0)" endLine="(334, 1)" clone_start="18" clone_end="34">
			<code function_name="main(int32_t argc, char **argv)">int main(int32_t argc, char **argv) {
  google::InitGoogleLogging(argv[0]);
  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);

  using apollo::canbus::CANCardParameter;
  using apollo::canbus::CanClient;
  using apollo::canbus::CanClientFactory;
  using apollo::canbus::TestCanParam;
  using apollo::canbus::CanAgent;
  using apollo::common::ErrorCode;
  CANCardParameter can_client_conf_a;
  std::shared_ptr&lt;TestCanParam&gt; param_ptr_a(new TestCanParam());
  std::shared_ptr&lt;TestCanParam&gt; param_ptr_b(new TestCanParam());

  auto *can_client_factory = CanClientFactory::instance();
  can_client_factory-&gt;RegisterCanClients();

  if (!apollo::common::util::GetProtoFromFile(FLAGS_can_client_conf_file_a,
                                              &amp;can_client_conf_a)) {
    AERROR &lt;&lt; "Unable to load canbus conf file: "
           &lt;&lt; FLAGS_can_client_conf_file_a;
    return 1;
  } else {
    AINFO &lt;&lt; "Conf file is loaded: " &lt;&lt; FLAGS_can_client_conf_file_a;
  }
  AINFO &lt;&lt; can_client_conf_a.ShortDebugString();
  auto client_a = can_client_factory-&gt;CreateObject(can_client_conf_a.brand());
  if (!client_a || !client_a-&gt;Init(can_client_conf_a) ||
      client_a-&gt;Start() != ErrorCode::OK) {
    AERROR &lt;&lt; "Create can client a failed.";
    return 1;
  }
  param_ptr_a-&gt;can_client = client_a.get();
  param_ptr_a-&gt;is_first_agent = true;
  param_ptr_a-&gt;conf = can_client_conf_a;

  CANCardParameter can_client_conf_b;
  std::unique_ptr&lt;CanClient&gt; client_b;
  if (!FLAGS_only_one_send) {
    if (!apollo::common::util::GetProtoFromFile(FLAGS_can_client_conf_file_b,
                                                &amp;can_client_conf_b)) {
      AERROR &lt;&lt; "Unable to load canbus conf file: "
             &lt;&lt; FLAGS_can_client_conf_file_b;
      return 1;
    } else {
      AINFO &lt;&lt; "Conf file is loaded: " &lt;&lt; FLAGS_can_client_conf_file_b;
    }
    AINFO &lt;&lt; can_client_conf_b.ShortDebugString();
    client_b = can_client_factory-&gt;CreateObject(can_client_conf_b.brand());
    if (!client_b || !client_b-&gt;Init(can_client_conf_b) ||
        client_b-&gt;Start() != ErrorCode::OK) {
      AERROR &lt;&lt; "Create can client b failed.";
      return 1;
    }
    param_ptr_b-&gt;can_client = client_b.get();
    param_ptr_b-&gt;conf = can_client_conf_b;
  }

  CanAgent agent_a(param_ptr_a.get());
  CanAgent agent_b(param_ptr_b.get());
  agent_a.AddOtherAgent(&amp;agent_b);
  agent_b.AddOtherAgent(&amp;agent_a);
  if (!agent_a.Start()) {
    AERROR &lt;&lt; "Agent a start failed.";
    return -1;
  }
  if (FLAGS_only_one_send) {
    agent_b.is_receiving(true);
    agent_b.is_sending_finish(true);
  } else {
    if (!agent_b.Start()) {
      AERROR &lt;&lt; "Agent b start failed.";
      return -1;
    }
  }

  agent_a.WaitForFinish();
  if (!FLAGS_only_one_send) {
    agent_b.WaitForFinish();
  }
  param_ptr_a-&gt;print();
  if (!FLAGS_only_one_send) {
    param_ptr_b-&gt;print();
  }

  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\can_client\can_client_tool.cc" startLine="(248, 0)" endLine="(334, 1)" clone_start="40" clone_end="56">
			<code function_name="main(int32_t argc, char **argv)">int main(int32_t argc, char **argv) {
  google::InitGoogleLogging(argv[0]);
  google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);

  using apollo::canbus::CANCardParameter;
  using apollo::canbus::CanClient;
  using apollo::canbus::CanClientFactory;
  using apollo::canbus::TestCanParam;
  using apollo::canbus::CanAgent;
  using apollo::common::ErrorCode;
  CANCardParameter can_client_conf_a;
  std::shared_ptr&lt;TestCanParam&gt; param_ptr_a(new TestCanParam());
  std::shared_ptr&lt;TestCanParam&gt; param_ptr_b(new TestCanParam());

  auto *can_client_factory = CanClientFactory::instance();
  can_client_factory-&gt;RegisterCanClients();

  if (!apollo::common::util::GetProtoFromFile(FLAGS_can_client_conf_file_a,
                                              &amp;can_client_conf_a)) {
    AERROR &lt;&lt; "Unable to load canbus conf file: "
           &lt;&lt; FLAGS_can_client_conf_file_a;
    return 1;
  } else {
    AINFO &lt;&lt; "Conf file is loaded: " &lt;&lt; FLAGS_can_client_conf_file_a;
  }
  AINFO &lt;&lt; can_client_conf_a.ShortDebugString();
  auto client_a = can_client_factory-&gt;CreateObject(can_client_conf_a.brand());
  if (!client_a || !client_a-&gt;Init(can_client_conf_a) ||
      client_a-&gt;Start() != ErrorCode::OK) {
    AERROR &lt;&lt; "Create can client a failed.";
    return 1;
  }
  param_ptr_a-&gt;can_client = client_a.get();
  param_ptr_a-&gt;is_first_agent = true;
  param_ptr_a-&gt;conf = can_client_conf_a;

  CANCardParameter can_client_conf_b;
  std::unique_ptr&lt;CanClient&gt; client_b;
  if (!FLAGS_only_one_send) {
    if (!apollo::common::util::GetProtoFromFile(FLAGS_can_client_conf_file_b,
                                                &amp;can_client_conf_b)) {
      AERROR &lt;&lt; "Unable to load canbus conf file: "
             &lt;&lt; FLAGS_can_client_conf_file_b;
      return 1;
    } else {
      AINFO &lt;&lt; "Conf file is loaded: " &lt;&lt; FLAGS_can_client_conf_file_b;
    }
    AINFO &lt;&lt; can_client_conf_b.ShortDebugString();
    client_b = can_client_factory-&gt;CreateObject(can_client_conf_b.brand());
    if (!client_b || !client_b-&gt;Init(can_client_conf_b) ||
        client_b-&gt;Start() != ErrorCode::OK) {
      AERROR &lt;&lt; "Create can client b failed.";
      return 1;
    }
    param_ptr_b-&gt;can_client = client_b.get();
    param_ptr_b-&gt;conf = can_client_conf_b;
  }

  CanAgent agent_a(param_ptr_a.get());
  CanAgent agent_b(param_ptr_b.get());
  agent_a.AddOtherAgent(&amp;agent_b);
  agent_b.AddOtherAgent(&amp;agent_a);
  if (!agent_a.Start()) {
    AERROR &lt;&lt; "Agent a start failed.";
    return -1;
  }
  if (FLAGS_only_one_send) {
    agent_b.is_receiving(true);
    agent_b.is_sending_finish(true);
  } else {
    if (!agent_b.Start()) {
      AERROR &lt;&lt; "Agent b start failed.";
      return -1;
    }
  }

  agent_a.WaitForFinish();
  if (!FLAGS_only_one_send) {
    agent_b.WaitForFinish();
  }
  param_ptr_a-&gt;print();
  if (!FLAGS_only_one_send) {
    param_ptr_b-&gt;print();
  }

  return 0;
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\objects_xml_parser.cc" startLine="(59, 0)" endLine="(94, 1)" clone_start="6" clone_end="20">
			<code function_name="ObjectsXmlParser::ParseClearAreas(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;PbClearArea&gt;* clear_areas)">Status ObjectsXmlParser::ParseClearAreas(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;PbClearArea&gt;* clear_areas) {
  CHECK_NOTNULL(clear_areas);
  const tinyxml2::XMLElement* sub_node = xml_node.FirstChildElement("object");
  while (sub_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
    checker +=
        UtilXmlParser::QueryStringAttribute(*sub_node, "type", &amp;object_type);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse object type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "clearArea") {
      PbClearArea clear_area;
      clear_area.mutable_id()-&gt;set_id(object_id);
      PbPolygon* polygon = clear_area.mutable_polygon();
      CHECK(polygon != nullptr);
      const tinyxml2::XMLElement* outline_node =
          sub_node-&gt;FirstChildElement("outline");
      if (outline_node == nullptr) {
        std::string err_msg = "Error parse cleararea outline";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseOutline(*outline_node, polygon));
      clear_areas-&gt;emplace_back(clear_area);
    }
    sub_node = sub_node-&gt;NextSiblingElement("object");
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(216, 0)" endLine="(259, 1)" clone_start="7" clone_end="21">
			<code function_name="SignalsXmlParser::ParseYieldSigns(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;YieldSignInternal&gt;* yield_signs)">Status SignalsXmlParser::ParseYieldSigns(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;YieldSignInternal&gt;* yield_signs) {
  CHECK_NOTNULL(yield_signs);

  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "yieldSign") {
      PbYieldSign yield_sign;
      yield_sign.mutable_id()-&gt;set_id(object_id);
      YieldSignInternal yield_sign_internal;
      yield_sign_internal.id = object_id;
      yield_sign_internal.yield_sign = yield_sign;
      auto sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                            &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          yield_sign_internal.stop_line_ids.insert(stop_line_id);

          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      yield_signs-&gt;emplace_back(yield_sign_internal);
    }

    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(171, 0)" endLine="(214, 1)" clone_start="7" clone_end="21">
			<code function_name="SignalsXmlParser::ParseStopSigns(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;StopSignInternal&gt;* stop_signs)">Status SignalsXmlParser::ParseStopSigns(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;StopSignInternal&gt;* stop_signs) {
  CHECK_NOTNULL(stop_signs);

  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "stopSign") {
      PbStopSign stop_sign;
      stop_sign.mutable_id()-&gt;set_id(object_id);

      StopSignInternal stop_sign_internal;
      stop_sign_internal.stop_sign = stop_sign;

      auto sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          stop_sign_internal.stop_line_ids.insert(stop_line_id);

          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      stop_signs-&gt;emplace_back(stop_sign_internal);
    }

    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(26, 0)" endLine="(114, 1)" clone_start="6" clone_end="20">
			<code function_name="SignalsXmlParser::ParseTrafficLights(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;TrafficLightInternal&gt;* traffic_lights)">Status SignalsXmlParser::ParseTrafficLights(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;TrafficLightInternal&gt;* traffic_lights) {
  CHECK_NOTNULL(traffic_lights);
  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "trafficLight") {
      PbSignal traffic_light;
      traffic_light.mutable_id()-&gt;set_id(object_id);
      std::string layout_type;
      int checker = UtilXmlParser::QueryStringAttribute(
          *signal_node, "layoutType", &amp;layout_type);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse signal layout type.";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      PbSignalType signal_layout_type;
      ToPbSignalType(layout_type, &amp;signal_layout_type);
      traffic_light.set_type(signal_layout_type);

      PbPolygon* polygon = traffic_light.mutable_boundary();
      auto outline_node = signal_node-&gt;FirstChildElement("outline");
      if (outline_node == nullptr) {
        std::string err_msg = "Error parse signal outline";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseOutline(*outline_node, polygon));
      auto sub_node = signal_node-&gt;FirstChildElement("subSignal");
      if (sub_node == nullptr) {
        std::string err_msg = "Error parse sub signal.";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      while (sub_node) {
        std::string sub_signal_id;
        std::string sub_signal_xml_type;
        checker = UtilXmlParser::QueryStringAttribute(*sub_node, "type",
                                                      &amp;sub_signal_xml_type);
        checker += UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                       &amp;sub_signal_id);
        if (checker != tinyxml2::XML_SUCCESS) {
          std::string err_msg = "Error parse sub signal layout type.";
          return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
        }

        PbSubSignal* sub_signal = traffic_light.add_subsignal();
        PbSubSignalType sub_signal_type;
        ToPbSubSignalType(sub_signal_xml_type, &amp;sub_signal_type);
        sub_signal-&gt;mutable_id()-&gt;set_id(sub_signal_id);
        sub_signal-&gt;set_type(sub_signal_type);
        PbPoint3D* pt = sub_signal-&gt;mutable_location();
        RETURN_IF_ERROR(UtilXmlParser::ParsePoint(*sub_node, pt));

        sub_node = sub_node-&gt;NextSiblingElement("subSignal");
      }

      TrafficLightInternal trafficlight_internal;
      trafficlight_internal.id = object_id;
      trafficlight_internal.traffic_light = traffic_light;

      sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                            &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          trafficlight_internal.stop_line_ids.insert(stop_line_id);
          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      traffic_lights-&gt;emplace_back(trafficlight_internal);
    }
    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_constraint.cc" startLine="(133, 0)" endLine="(181, 1)" clone_start="6" clone_end="21">
			<code function_name="PiecewiseLinearConstraint::AddSecondDerivativeBoundary(const double init_derivative, const std::vector&lt;uint32_t&gt;&amp; index_list,     const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool PiecewiseLinearConstraint::AddSecondDerivativeBoundary(
    const double init_derivative, const std::vector&lt;uint32_t&gt;&amp; index_list,
    const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  // TODO(Liangliang): implement this function
  if (index_list.size() != lower_bound.size() ||
      index_list.size() != upper_bound.size()) {
    AERROR &lt;&lt; "The sizes of index list, lower_bound, upper_bound are not "
              "identical.";
    return false;
  }
  Eigen::MatrixXd inequality_matrix =
      Eigen::MatrixXd::Zero(2 * index_list.size(), dimension_);
  Eigen::MatrixXd inequality_boundary =
      Eigen::MatrixXd::Zero(2 * index_list.size(), 1);

  for (uint32_t i = 0; i &lt; index_list.size(); ++i) {
    uint32_t index = index_list[i];
    if (index == 0) {
      AERROR &lt;&lt; "Index should NOT be 0.";
      return false;
    }

    const double upper = upper_bound[i];
    const double lower = lower_bound[i];
    if (index == 1) {
      inequality_matrix(2 * i, 1) = -1.0;
      inequality_boundary(2 * i, 1) = -(upper * unit_segment_ * unit_segment_ +
                                        init_derivative * unit_segment_);
      inequality_matrix(2 * i + 1, 1) = 1.0;
      inequality_boundary(2 * i + 1, 1) =
          lower * unit_segment_ * unit_segment_ +
          init_derivative * unit_segment_;
    } else {
      inequality_matrix(2 * i, index - 2) = -1.0;
      inequality_matrix(2 * i, index - 1) = 2.0;
      inequality_matrix(2 * i, index) = -1.0;
      inequality_boundary(2 * i, 0) = -upper * unit_segment_ * unit_segment_;

      inequality_matrix(2 * i + 1, index - 2) = 1.0;
      inequality_matrix(2 * i + 1, index - 1) = -2.0;
      inequality_matrix(2 * i + 1, index) = 1.0;
      inequality_boundary(2 * i + 1, 0) = lower * unit_segment_ * unit_segment_;
    }
  }
  inequality_matrices_.push_back(inequality_matrix);
  inequality_boundaries_.push_back(inequality_boundary);
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\piecewise_linear_constraint.cc" startLine="(98, 0)" endLine="(131, 1)" clone_start="5" clone_end="20">
			<code function_name="PiecewiseLinearConstraint::AddDerivativeBoundary(    const std::vector&lt;uint32_t&gt;&amp; index_list,     const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool PiecewiseLinearConstraint::AddDerivativeBoundary(
    const std::vector&lt;uint32_t&gt;&amp; index_list,
    const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  if (index_list.size() != lower_bound.size() ||
      index_list.size() != upper_bound.size()) {
    AERROR &lt;&lt; "The sizes of index list, lower_bound, upper_bound are not "
              "identical.";
    return false;
  }
  Eigen::MatrixXd inequality_matrix =
      Eigen::MatrixXd::Zero(2 * index_list.size(), dimension_);
  Eigen::MatrixXd inequality_boundary =
      Eigen::MatrixXd::Zero(2 * index_list.size(), 1);

  for (uint32_t i = 0; i &lt; index_list.size(); ++i) {
    uint32_t index = index_list[i];
    if (index == 0) {
      AERROR &lt;&lt; "Index should NOT be 0.";
      return false;
    }

    inequality_matrix(2 * i, index - 1) = 1.0;
    inequality_matrix(2 * i, index) = -1.0;
    inequality_boundary(2 * i, 0) = -unit_segment_ * upper_bound[i];

    inequality_matrix(2 * i + 1, index - 1) = -1.0;
    inequality_matrix(2 * i + 1, index) = 1.0;
    inequality_boundary(2 * i, 0) = unit_segment_ * lower_bound[i];
  }
  inequality_matrices_.push_back(inequality_matrix);
  inequality_boundaries_.push_back(inequality_boundary);
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(142, 0)" endLine="(169, 1)" clone_start="10" clone_end="22">
			<code function_name="SignalsXmlParser::ToPbSubSignalType(const std::string&amp; xml_type, PbSubSignalType* sub_signal_type)">Status SignalsXmlParser::ToPbSubSignalType(const std::string&amp; xml_type,
                                           PbSubSignalType* sub_signal_type) {
  CHECK_NOTNULL(sub_signal_type);

  std::string upper_str = UtilXmlParser::ToUpper(xml_type);

  if (upper_str == "UNKNOWN") {
    *sub_signal_type = hdmap::Subsignal::UNKNOWN;
  } else if (upper_str == "CIRCLE") {
    *sub_signal_type = hdmap::Subsignal::CIRCLE;
  } else if (upper_str == "ARROWLEFT") {
    *sub_signal_type = hdmap::Subsignal::ARROW_LEFT;
  } else if (upper_str == "ARROWFORWARD") {
    *sub_signal_type = hdmap::Subsignal::ARROW_FORWARD;
  } else if (upper_str == "ARROWRIGHT") {
    *sub_signal_type = hdmap::Subsignal::ARROW_RIGHT;
  } else if (upper_str == "ARROWLEFTANDFORWARD") {
    *sub_signal_type = hdmap::Subsignal::ARROW_LEFT_AND_FORWARD;
  } else if (upper_str == "ARROWRIGHTANDFORWARD") {
    *sub_signal_type = hdmap::Subsignal::ARROW_RIGHT_AND_FORWARD;
  } else if (upper_str == "ARROWUTURN") {
    *sub_signal_type = hdmap::Subsignal::ARROW_U_TURN;
  } else {
    std::string err_msg = "Error or unsupport sub signal type";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(142, 0)" endLine="(169, 1)" clone_start="8" clone_end="20">
			<code function_name="SignalsXmlParser::ToPbSubSignalType(const std::string&amp; xml_type, PbSubSignalType* sub_signal_type)">Status SignalsXmlParser::ToPbSubSignalType(const std::string&amp; xml_type,
                                           PbSubSignalType* sub_signal_type) {
  CHECK_NOTNULL(sub_signal_type);

  std::string upper_str = UtilXmlParser::ToUpper(xml_type);

  if (upper_str == "UNKNOWN") {
    *sub_signal_type = hdmap::Subsignal::UNKNOWN;
  } else if (upper_str == "CIRCLE") {
    *sub_signal_type = hdmap::Subsignal::CIRCLE;
  } else if (upper_str == "ARROWLEFT") {
    *sub_signal_type = hdmap::Subsignal::ARROW_LEFT;
  } else if (upper_str == "ARROWFORWARD") {
    *sub_signal_type = hdmap::Subsignal::ARROW_FORWARD;
  } else if (upper_str == "ARROWRIGHT") {
    *sub_signal_type = hdmap::Subsignal::ARROW_RIGHT;
  } else if (upper_str == "ARROWLEFTANDFORWARD") {
    *sub_signal_type = hdmap::Subsignal::ARROW_LEFT_AND_FORWARD;
  } else if (upper_str == "ARROWRIGHTANDFORWARD") {
    *sub_signal_type = hdmap::Subsignal::ARROW_RIGHT_AND_FORWARD;
  } else if (upper_str == "ARROWUTURN") {
    *sub_signal_type = hdmap::Subsignal::ARROW_U_TURN;
  } else {
    std::string err_msg = "Error or unsupport sub signal type";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(288, 0)" endLine="(309, 1)" clone_start="21" clone_end="22">
			<code function_name="Spline2dConstraint::AddSmoothConstraint()">bool Spline2dConstraint::AddSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(2 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(2 * (t_knots_.size() - 2), 1);
  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);

    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(2 * i, j + index_offset) = power_t[j];
      affine_equality(2 * i + 1, j + index_offset + spline_order_) = power_t[j];
    }
    affine_equality(2 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(2 * i + 1, index_offset + 3 * spline_order_) = -1.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(312, 0)" endLine="(339, 1)" clone_start="27" clone_end="28">
			<code function_name="Spline2dConstraint::AddDerivativeSmoothConstraint()">bool Spline2dConstraint::AddDerivativeSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(4 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(4 * (t_knots_.size() - 2), 1);

  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);
    std::vector&lt;double&gt; derivative_t = DerivativeCoef(rel_t);
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(4 * i, j + index_offset) = power_t[j];
      affine_equality(4 * i + 1, j + index_offset) = derivative_t[j];
      affine_equality(4 * i + 2, j + index_offset + spline_order_) = power_t[j];
      affine_equality(4 * i + 3, j + index_offset + spline_order_) =
          derivative_t[j];
    }
    affine_equality(4 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(4 * i + 1, index_offset + 2 * spline_order_ + 1) = -1.0;
    affine_equality(4 * i + 2, index_offset + 3 * spline_order_) = -1.0;
    affine_equality(4 * i + 3, index_offset + 3 * spline_order_ + 1) = -1.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(342, 0)" endLine="(375, 1)" clone_start="33" clone_end="34">
			<code function_name="Spline2dConstraint::AddSecondDerivativeSmoothConstraint()">bool Spline2dConstraint::AddSecondDerivativeSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(6 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(6 * (t_knots_.size() - 2), 1);

  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);
    std::vector&lt;double&gt; derivative_t = DerivativeCoef(rel_t);
    std::vector&lt;double&gt; second_derivative_t = SecondDerivativeCoef(rel_t);
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(6 * i, j + index_offset) = power_t[j];
      affine_equality(6 * i + 1, j + index_offset) = derivative_t[j];
      affine_equality(6 * i + 2, j + index_offset) = second_derivative_t[j];
      affine_equality(6 * i + 3, j + index_offset + spline_order_) = power_t[j];
      affine_equality(6 * i + 4, j + index_offset + spline_order_) =
          derivative_t[j];
      affine_equality(6 * i + 5, j + index_offset + spline_order_) =
          second_derivative_t[j];
    }
    affine_equality(6 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(6 * i + 1, index_offset + 2 * spline_order_ + 1) = -1.0;
    affine_equality(6 * i + 2, index_offset + 2 * spline_order_ + 2) = -2.0;
    affine_equality(6 * i + 3, index_offset + 3 * spline_order_) = -1.0;
    affine_equality(6 * i + 4, index_offset + 3 * spline_order_ + 1) = -1.0;
    affine_equality(6 * i + 5, index_offset + 3 * spline_order_ + 2) = -2.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(312, 0)" endLine="(339, 1)" clone_start="1" clone_end="14">
			<code function_name="Spline2dConstraint::AddDerivativeSmoothConstraint()">bool Spline2dConstraint::AddDerivativeSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(4 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(4 * (t_knots_.size() - 2), 1);

  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);
    std::vector&lt;double&gt; derivative_t = DerivativeCoef(rel_t);
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(4 * i, j + index_offset) = power_t[j];
      affine_equality(4 * i + 1, j + index_offset) = derivative_t[j];
      affine_equality(4 * i + 2, j + index_offset + spline_order_) = power_t[j];
      affine_equality(4 * i + 3, j + index_offset + spline_order_) =
          derivative_t[j];
    }
    affine_equality(4 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(4 * i + 1, index_offset + 2 * spline_order_ + 1) = -1.0;
    affine_equality(4 * i + 2, index_offset + 3 * spline_order_) = -1.0;
    affine_equality(4 * i + 3, index_offset + 3 * spline_order_ + 1) = -1.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(342, 0)" endLine="(375, 1)" clone_start="1" clone_end="14">
			<code function_name="Spline2dConstraint::AddSecondDerivativeSmoothConstraint()">bool Spline2dConstraint::AddSecondDerivativeSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(6 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(6 * (t_knots_.size() - 2), 1);

  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);
    std::vector&lt;double&gt; derivative_t = DerivativeCoef(rel_t);
    std::vector&lt;double&gt; second_derivative_t = SecondDerivativeCoef(rel_t);
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(6 * i, j + index_offset) = power_t[j];
      affine_equality(6 * i + 1, j + index_offset) = derivative_t[j];
      affine_equality(6 * i + 2, j + index_offset) = second_derivative_t[j];
      affine_equality(6 * i + 3, j + index_offset + spline_order_) = power_t[j];
      affine_equality(6 * i + 4, j + index_offset + spline_order_) =
          derivative_t[j];
      affine_equality(6 * i + 5, j + index_offset + spline_order_) =
          second_derivative_t[j];
    }
    affine_equality(6 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(6 * i + 1, index_offset + 2 * spline_order_ + 1) = -1.0;
    affine_equality(6 * i + 2, index_offset + 2 * spline_order_ + 2) = -2.0;
    affine_equality(6 * i + 3, index_offset + 3 * spline_order_) = -1.0;
    affine_equality(6 * i + 4, index_offset + 3 * spline_order_ + 1) = -1.0;
    affine_equality(6 * i + 5, index_offset + 3 * spline_order_ + 2) = -2.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(378, 0)" endLine="(417, 1)" clone_start="1" clone_end="14">
			<code function_name="Spline2dConstraint::AddThirdDerivativeSmoothConstraint()">bool Spline2dConstraint::AddThirdDerivativeSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(8 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(8 * (t_knots_.size() - 2), 1);

  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);
    std::vector&lt;double&gt; derivative_t = DerivativeCoef(rel_t);
    std::vector&lt;double&gt; second_derivative_t = SecondDerivativeCoef(rel_t);
    std::vector&lt;double&gt; third_derivative_t = ThirdDerivativeCoef(rel_t);
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(8 * i, j + index_offset) = power_t[j];
      affine_equality(8 * i + 1, j + index_offset) = derivative_t[j];
      affine_equality(8 * i + 2, j + index_offset) = second_derivative_t[j];
      affine_equality(8 * i + 3, j + index_offset) = third_derivative_t[j];
      affine_equality(8 * i + 4, j + index_offset + spline_order_) = power_t[j];
      affine_equality(8 * i + 5, j + index_offset + spline_order_) =
          derivative_t[j];
      affine_equality(8 * i + 6, j + index_offset + spline_order_) =
          second_derivative_t[j];
      affine_equality(8 * i + 7, j + index_offset + spline_order_) =
          third_derivative_t[j];
    }
    affine_equality(8 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(8 * i + 1, index_offset + 2 * spline_order_ + 1) = -1.0;
    affine_equality(8 * i + 2, index_offset + 2 * spline_order_ + 2) = -2.0;
    affine_equality(8 * i + 3, index_offset + 2 * spline_order_ + 3) = -6.0;
    affine_equality(8 * i + 4, index_offset + 3 * spline_order_) = -1.0;
    affine_equality(8 * i + 5, index_offset + 3 * spline_order_ + 1) = -1.0;
    affine_equality(8 * i + 6, index_offset + 3 * spline_order_ + 2) = -2.0;
    affine_equality(8 * i + 7, index_offset + 3 * spline_order_ + 3) = -6.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\controller\lat_controller.cc" startLine="(56, 0)" endLine="(73, 1)" clone_start="4" clone_end="16">
			<code function_name="WriteHeaders(std::ofstream &amp;file_stream)">void WriteHeaders(std::ofstream &amp;file_stream) {
  file_stream &lt;&lt; "current_lateral_error,"
              &lt;&lt; "current_ref_heading,"
              &lt;&lt; "current_heading,"
              &lt;&lt; "current_heading_error,"
              &lt;&lt; "heading_error_rate,"
              &lt;&lt; "lateral_error_rate,"
              &lt;&lt; "current_curvature,"
              &lt;&lt; "steer_angle,"
              &lt;&lt; "steer_angle_feedforward,"
              &lt;&lt; "steer_angle_lateral_contribution,"
              &lt;&lt; "steer_angle_lateral_rate_contribution,"
              &lt;&lt; "steer_angle_heading_contribution,"
              &lt;&lt; "steer_angle_heading_rate_contribution,"
              &lt;&lt; "steer_angle_feedback,"
              &lt;&lt; "steering_position,"
              &lt;&lt; "v" &lt;&lt; std::endl;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\controller\lat_controller.cc" startLine="(56, 0)" endLine="(73, 1)" clone_start="3" clone_end="15">
			<code function_name="WriteHeaders(std::ofstream &amp;file_stream)">void WriteHeaders(std::ofstream &amp;file_stream) {
  file_stream &lt;&lt; "current_lateral_error,"
              &lt;&lt; "current_ref_heading,"
              &lt;&lt; "current_heading,"
              &lt;&lt; "current_heading_error,"
              &lt;&lt; "heading_error_rate,"
              &lt;&lt; "lateral_error_rate,"
              &lt;&lt; "current_curvature,"
              &lt;&lt; "steer_angle,"
              &lt;&lt; "steer_angle_feedforward,"
              &lt;&lt; "steer_angle_lateral_contribution,"
              &lt;&lt; "steer_angle_lateral_rate_contribution,"
              &lt;&lt; "steer_angle_heading_contribution,"
              &lt;&lt; "steer_angle_heading_rate_contribution,"
              &lt;&lt; "steer_angle_feedback,"
              &lt;&lt; "steering_position,"
              &lt;&lt; "v" &lt;&lt; std::endl;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(29, 0)" endLine="(59, 1)" clone_start="1" clone_end="17">
			<code function_name="Brake61::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brake61::Parse(const std::uint8_t *bytes, int32_t length,
                    ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_output(
      pedal_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  chassis_detail-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(26, 0)" endLine="(50, 1)" clone_start="1" clone_end="21">
			<code function_name="Throttle63::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Throttle63::Parse(const std::uint8_t *bytes, int32_t length,
                       ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_gas()-&gt;set_throttle_input(pedal_input(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_throttle_cmd(pedal_cmd(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_throttle_output(
      pedal_output(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_throttle_enabled(
      is_enabled(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  chassis_detail-&gt;mutable_check_response()-&gt;set_is_vcu_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(26, 0)" endLine="(33, 1)" clone_start="3" clone_end="8">
			<code function_name="Throttleinfo75::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Throttleinfo75::Parse(const std::uint8_t *bytes, int32_t length,
                           ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_ems()-&gt;set_engine_rpm(engine_rpm(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_accelerator_pedal(
      acc_pedal_percent(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_accelerator_pedal_rate(
      acc_pedal_rate(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="78" clone_end="84">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length,
                        ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(35, 0)" endLine="(43, 1)" clone_start="1" clone_end="9">
			<code function_name="Throttleinfo75::engine_rpm(const std::uint8_t *bytes, int32_t length) const">double Throttleinfo75::engine_rpm(const std::uint8_t *bytes,
                                  int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.25;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(111, 0)" endLine="(119, 1)" clone_start="1" clone_end="9">
			<code function_name="Brakeinfo74::braking_torque_request(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::braking_torque_request(const std::uint8_t *bytes,
                                           int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 4);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 4.000000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(45, 0)" endLine="(53, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttleinfo75::acc_pedal_percent(const std::uint8_t *bytes, int32_t length) const">double Throttleinfo75::acc_pedal_percent(const std::uint8_t *bytes,
                                         int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 2);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.1;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(121, 0)" endLine="(127, 1)" clone_start="1" clone_end="5">
			<code function_name="Brakeinfo74::hill_start_assist_status(const std::uint8_t *bytes, int32_t length) const">int32_t Brakeinfo74::hill_start_assist_status(const std::uint8_t *bytes,
                                              int32_t length) const {
  // see table for status code
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(4, 3);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(553, 0)" endLine="(573, 1)" clone_start="17" clone_end="21">
			<code function_name="LanesXmlParser::ToPbLaneType(const std::string&amp; type, PbLaneType* lane_type)">Status LanesXmlParser::ToPbLaneType(const std::string&amp; type,
                                    PbLaneType* lane_type) {
  CHECK_NOTNULL(lane_type);

  std::string upper_str = UtilXmlParser::ToUpper(type);

  if (upper_str == "NONE") {
    *lane_type = hdmap::Lane::NONE;
  } else if (upper_str == "DRIVING") {
    *lane_type = hdmap::Lane::CITY_DRIVING;
  } else if (upper_str == "BIKING") {
    *lane_type = hdmap::Lane::BIKING;
  } else if (upper_str == "PARKING") {
    *lane_type = hdmap::Lane::PARKING;
  } else {
    std::string err_msg = "Error or unsupport lane type:" + type;
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(116, 0)" endLine="(140, 1)" clone_start="21" clone_end="25">
			<code function_name="SignalsXmlParser::ToPbSignalType(const std::string&amp; xml_type, PbSignalType* signal_type)">Status SignalsXmlParser::ToPbSignalType(const std::string&amp; xml_type,
                                        PbSignalType* signal_type) {
  CHECK_NOTNULL(signal_type);

  std::string upper_str = UtilXmlParser::ToUpper(xml_type);

  if (upper_str == "UNKNOWN") {
    *signal_type = hdmap::Signal::UNKNOWN;
  } else if (upper_str == "MIX2HORIZONTAL") {
    *signal_type = hdmap::Signal::MIX_2_HORIZONTAL;
  } else if (upper_str == "MIX2VERTICAL") {
    *signal_type = hdmap::Signal::MIX_2_VERTICAL;
  } else if (upper_str == "MIX3HORIZONTAL") {
    *signal_type = hdmap::Signal::MIX_3_HORIZONTAL;
  } else if (upper_str == "MIX3VERTICAL") {
    *signal_type = hdmap::Signal::MIX_3_VERTICAL;
  } else if (upper_str == "SINGLE") {
    *signal_type = hdmap::Signal::SINGLE;
  } else {
    std::string err_msg = "Error or unsupport signal layout type";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(575, 0)" endLine="(595, 1)" clone_start="1" clone_end="14">
			<code function_name="LanesXmlParser::ToPbTurnType(const std::string&amp; type, PbTurnType* pb_turn_type)">Status LanesXmlParser::ToPbTurnType(const std::string&amp; type,
                                    PbTurnType* pb_turn_type) {
  CHECK_NOTNULL(pb_turn_type);

  std::string upper_str = UtilXmlParser::ToUpper(type);

  if (upper_str == "NOTURN") {
    *pb_turn_type = hdmap::Lane::NO_TURN;
  } else if (upper_str == "LEFTTURN") {
    *pb_turn_type = hdmap::Lane::LEFT_TURN;
  } else if (upper_str == "RIGHTTURN") {
    *pb_turn_type = hdmap::Lane::RIGHT_TURN;
  } else if (upper_str == "UTURN") {
    *pb_turn_type = hdmap::Lane::U_TURN;
  } else {
    std::string err_msg = "Error or unsupport turn type:" + type;
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(142, 0)" endLine="(169, 1)" clone_start="1" clone_end="14">
			<code function_name="SignalsXmlParser::ToPbSubSignalType(const std::string&amp; xml_type, PbSubSignalType* sub_signal_type)">Status SignalsXmlParser::ToPbSubSignalType(const std::string&amp; xml_type,
                                           PbSubSignalType* sub_signal_type) {
  CHECK_NOTNULL(sub_signal_type);

  std::string upper_str = UtilXmlParser::ToUpper(xml_type);

  if (upper_str == "UNKNOWN") {
    *sub_signal_type = hdmap::Subsignal::UNKNOWN;
  } else if (upper_str == "CIRCLE") {
    *sub_signal_type = hdmap::Subsignal::CIRCLE;
  } else if (upper_str == "ARROWLEFT") {
    *sub_signal_type = hdmap::Subsignal::ARROW_LEFT;
  } else if (upper_str == "ARROWFORWARD") {
    *sub_signal_type = hdmap::Subsignal::ARROW_FORWARD;
  } else if (upper_str == "ARROWRIGHT") {
    *sub_signal_type = hdmap::Subsignal::ARROW_RIGHT;
  } else if (upper_str == "ARROWLEFTANDFORWARD") {
    *sub_signal_type = hdmap::Subsignal::ARROW_LEFT_AND_FORWARD;
  } else if (upper_str == "ARROWRIGHTANDFORWARD") {
    *sub_signal_type = hdmap::Subsignal::ARROW_RIGHT_AND_FORWARD;
  } else if (upper_str == "ARROWUTURN") {
    *sub_signal_type = hdmap::Subsignal::ARROW_U_TURN;
  } else {
    std::string err_msg = "Error or unsupport sub signal type";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\camera\camera_localization.cc" startLine="(80, 0)" endLine="(133, 1)" clone_start="13" clone_end="32">
			<code function_name="CameraLocalization::OnTimer(const ros::TimerEvent &amp;event)">void CameraLocalization::OnTimer(const ros::TimerEvent &amp;event) {
  double time_delay =
      common::time::ToSecond(Clock::Now()) - last_received_timestamp_sec_;
  MonitorBuffer buffer(&amp;monitor_);
  if (FLAGS_enable_gps_timestamp &amp;&amp;
      time_delay &gt; FLAGS_gps_time_delay_tolerance) {
    buffer.ERROR() &lt;&lt; "GPS message time delay: " &lt;&lt; time_delay;
    buffer.PrintLog();
  }
  if (FLAGS_enable_camera_timestamp &amp;&amp;
      time_delay &gt; FLAGS_camera_time_delay_tolerance) {
    AERROR &lt;&lt; "Camera message time delay: " &lt;&lt; time_delay;
    buffer.ERROR() &lt;&lt; "Camera message time delay: " &lt;&lt; time_delay;
    buffer.PrintLog();
  }

  // Take a snapshot of the current received messages.
  AdapterManager::Observe();

  if (AdapterManager::GetGps()-&gt;Empty()) {
    AERROR &lt;&lt; "GPS message buffer is empty.";
    if (service_started_) {
      buffer.ERROR("GPS message buffer is empty.");
    }
    return;
  }
  if (AdapterManager::GetCamera()-&gt;Empty()) {
    AERROR &lt;&lt; "Camera message buffer is empty.";
    if (service_started_) {
      buffer.ERROR("Camera message buffer is empty.");
    }
    return;
  }
  if (use_imu_ &amp;&amp; AdapterManager::GetImu()-&gt;Empty()) {
    AERROR &lt;&lt; "Imu message buffer is empty.";
    if (service_started_) {
      buffer.ERROR("Imu message buffer is empty.");
    }
    return;
  }

  // publish localization messages
  if (!PublishLocalization()) {
    buffer.ERROR("Publish localization failed");
    buffer.PrintLog();
    return;
  }
  service_started_ = true;

  // watch dog
  RunWatchDog();

  last_received_timestamp_sec_ = common::time::ToSecond(Clock::Now());
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\rtk\rtk_localization.cc" startLine="(64, 0)" endLine="(100, 1)" clone_start="7" clone_end="26">
			<code function_name="RTKLocalization::OnTimer(const ros::TimerEvent &amp;event)">void RTKLocalization::OnTimer(const ros::TimerEvent &amp;event) {
  double time_delay =
      common::time::ToSecond(Clock::Now()) - last_received_timestamp_sec_;
  common::monitor::MonitorBuffer buffer(&amp;monitor_);
  if (FLAGS_enable_gps_timestamp &amp;&amp;
      time_delay &gt; FLAGS_gps_time_delay_tolerance) {
    buffer.ERROR() &lt;&lt; "GPS message time delay: " &lt;&lt; time_delay;
    buffer.PrintLog();
  }

  // Take a snapshot of the current received messages.
  AdapterManager::Observe();

  if (AdapterManager::GetGps()-&gt;Empty()) {
    AERROR &lt;&lt; "GPS message buffer is empty.";
    if (service_started_) {
      buffer.ERROR("GPS message buffer is empty.");
    }
    return;
  }
  if (AdapterManager::GetImu()-&gt;Empty()) {
    AERROR &lt;&lt; "IMU message buffer is empty.";
    if (service_started_) {
      buffer.ERROR("IMU message buffer is empty.");
    }
    return;
  }

  // publish localization messages
  PublishLocalization();
  service_started_ = true;

  // watch dog
  RunWatchDog();

  last_received_timestamp_sec_ = common::time::ToSecond(Clock::Now());
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\parser_nodelet.cpp" startLine="(30, 2)" endLine="(30, 20)" clone_start="1" clone_end="1">
			<code function_name="ParserNodelet()">  ParserNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\stream_nodelet.cpp" startLine="(39, 2)" endLine="(39, 20)" clone_start="1" clone_end="1">
			<code function_name="StreamNodelet()">  StreamNodelet() {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\parser_nodelet.cpp" startLine="(31, 2)" endLine="(31, 21)" clone_start="1" clone_end="1">
			<code function_name="~ParserNodelet()">  ~ParserNodelet() {}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\stream_nodelet.cpp" startLine="(40, 2)" endLine="(40, 21)" clone_start="1" clone_end="1">
			<code function_name="~StreamNodelet()">  ~StreamNodelet() {}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\parser_nodelet.cpp" startLine="(39, 0)" endLine="(72, 1)" clone_start="1" clone_end="6">
			<code function_name="ParserNodelet::onInit()">void ParserNodelet::onInit() {
  ros::NodeHandle&amp; nh = getPrivateNodeHandle();
  std::string gnss_conf;
  std::string raw_data_topic;
  std::string ins_stat_topic;
  std::string corr_imu_topic;
  std::string odometry_topic;
  std::string gnss_status_topic;
  std::string ins_status_topic;

  nh.param("gnss_conf", gnss_conf, std::string("./conf/gnss_conf.txt"));
  nh.param("raw_data_topic", raw_data_topic,
           std::string("/apollo/sensor/gnss/raw_data"));
  nh.param("ins_stat_topic", ins_stat_topic,
           std::string("/apollo/sensor/gnss/ins_stat"));
  nh.param("corr_imu_topic", corr_imu_topic,
           std::string("/apollo/sensor/gnss/corrected_imu"));
  nh.param("odometry_topic", odometry_topic,
           std::string("/apollo/sensor/gnss/odometry"));
  nh.param("gnss_status_topic", gnss_status_topic,
           std::string("/apollo/sensor/gnss/gnss_status"));
  nh.param("ins_status_topic", ins_status_topic,
           std::string("/apollo/sensor/gnss/ins_status"));

  _data_parser.reset(new DataParser(nh, raw_data_topic, ins_stat_topic,
                                    corr_imu_topic, odometry_topic,
                                    gnss_status_topic, ins_status_topic));
  if (!_data_parser-&gt;init(gnss_conf)) {
    ROS_ERROR("Init parser nodelet failed.");
    ROS_ERROR_STREAM("Init parser nodelet failed.");
    return;
  }
  ROS_INFO("Init parser nodelet success.");
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\stream_nodelet.cpp" startLine="(47, 0)" endLine="(74, 1)" clone_start="1" clone_end="6">
			<code function_name="StreamNodelet::onInit()">void StreamNodelet::onInit() {
  ros::NodeHandle&amp; nh = getPrivateNodeHandle();
  std::string gnss_conf;
  std::string raw_data_topic;
  std::string rtcm_data_topic;
  std::string stream_status_topic;

  nh.param("gnss_conf", gnss_conf, std::string("./conf/gnss_conf.txt"));
  nh.param("raw_data_topic", raw_data_topic,
           std::string("/apollo/sensor/gnss/raw_data"));
  nh.param("rtcm_data_topic", rtcm_data_topic,
           std::string("/apollo/sensor/gnss/rtcm_data"));
  nh.param("stream_status_topic", stream_status_topic,
           std::string("/apollo/sensor/gnss/stream_status"));

  ROS_INFO_STREAM("gnss conf: " &lt;&lt; gnss_conf);
  ROS_INFO_STREAM("raw data topic: " &lt;&lt; raw_data_topic);

  init_signal();
  _raw_stream.reset(new RawStream(nh, getName(), raw_data_topic,
                                  rtcm_data_topic, stream_status_topic));
  if (!_raw_stream-&gt;init(gnss_conf)) {
    ROS_ERROR("Init stream nodelet failed.");
    ROS_ERROR_STREAM("Init stream nodelet failed.");
    return;
  }
  ROS_INFO("Init stream nodelet success.");
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(29, 0)" endLine="(59, 1)" clone_start="9" clone_end="31">
			<code function_name="Brake61::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brake61::Parse(const std::uint8_t *bytes, int32_t length,
                    ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_output(
      pedal_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  chassis_detail-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(26, 0)" endLine="(50, 1)" clone_start="3" clone_end="25">
			<code function_name="Throttle63::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Throttle63::Parse(const std::uint8_t *bytes, int32_t length,
                       ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_gas()-&gt;set_throttle_input(pedal_input(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_throttle_cmd(pedal_cmd(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_throttle_output(
      pedal_output(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_throttle_enabled(
      is_enabled(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  chassis_detail-&gt;mutable_gas()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  chassis_detail-&gt;mutable_check_response()-&gt;set_is_vcu_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(61, 0)" endLine="(65, 1)" clone_start="1" clone_end="1">
			<code function_name="Brake61::pedal_input(const std::uint8_t *bytes, int32_t length) const">double Brake61::pedal_input(const std::uint8_t *bytes, int32_t length) const {
  DCHECK_GE(length, 2);
  // Pedal Input from the physical pedal
  return parse_two_frames(bytes[0], bytes[1]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(52, 0)" endLine="(64, 1)" clone_start="1" clone_end="1">
			<code function_name="Throttle63::pedal_input(const std::uint8_t *bytes, int32_t length) const">double Throttle63::pedal_input(const std::uint8_t *bytes,
                               int32_t length) const {
  // Pedal Input from the physical pedal
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(136, 0)" endLine="(144, 1)" clone_start="1" clone_end="9">
			<code function_name="Brakeinfo74::braking_torque_actual(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::braking_torque_actual(const std::uint8_t *bytes,
                                          int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 4);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 4.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(111, 0)" endLine="(119, 1)" clone_start="1" clone_end="9">
			<code function_name="Brakeinfo74::braking_torque_request(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::braking_torque_request(const std::uint8_t *bytes,
                                           int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 4);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 4.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(65, 0)" endLine="(72, 1)" clone_start="1" clone_end="8">
			<code function_name="Gps6f::heading(const std::uint8_t *bytes, int32_t length) const">double Gps6f::heading(const std::uint8_t *bytes, int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(146, 0)" endLine="(152, 1)" clone_start="1" clone_end="7">
			<code function_name="Brakeinfo74::hill_start_assist_mode(const std::uint8_t *bytes, int32_t length) const">int32_t Brakeinfo74::hill_start_assist_mode(const std::uint8_t *bytes,
                                            int32_t length) const {
  // see table for status code
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(4, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(121, 0)" endLine="(127, 1)" clone_start="1" clone_end="7">
			<code function_name="Brakeinfo74::hill_start_assist_status(const std::uint8_t *bytes, int32_t length) const">int32_t Brakeinfo74::hill_start_assist_status(const std::uint8_t *bytes,
                                              int32_t length) const {
  // see table for status code
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(4, 3);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(74, 0)" endLine="(78, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6f::speed(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6f::speed(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 8);
  return x;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(154, 0)" endLine="(160, 1)" clone_start="1" clone_end="4">
			<code function_name="Brakeinfo74::parking_brake_status(const std::uint8_t *bytes, int32_t length) const">int32_t Brakeinfo74::parking_brake_status(const std::uint8_t *bytes,
                                          int32_t length) const {
  // see table for status code
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(6, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(129, 0)" endLine="(134, 1)" clone_start="1" clone_end="4">
			<code function_name="Brakeinfo74::is_vehicle_stationary(const std::uint8_t *bytes, int32_t length) const">bool Brakeinfo74::is_vehicle_stationary(const std::uint8_t *bytes,
                                        int32_t length) const {
  // false for moving, true for stationary
  Byte frame(bytes + 1);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(80, 0)" endLine="(84, 1)" clone_start="1" clone_end="2">
			<code function_name="Gps6f::hdop(const std::uint8_t *bytes, int32_t length) const">double Gps6f::hdop(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 5);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="116" clone_end="135">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(26, 0)" endLine="(51, 1)" clone_start="11" clone_end="24">
			<code function_name="Gps6f::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Gps6f::Parse(const std::uint8_t *bytes, int32_t length,
                  ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_basic()-&gt;set_altitude(altitude(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_heading(heading(bytes, length));
  // speed mph -&gt; mps
  chassis_detail-&gt;mutable_basic()-&gt;set_gps_speed(speed(bytes, length) *
                                                 0.44704);
  chassis_detail-&gt;mutable_basic()-&gt;set_hdop(hdop(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_vdop(vdop(bytes, length));
  switch (fix_quality(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_NO);
      break;
    case 1:
      chassis_detail-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_2D);
      break;
    case 2:
      chassis_detail-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_3D);
      break;
    default:
      chassis_detail-&gt;mutable_basic()-&gt;set_quality(BasicInfo::FIX_INVALID);
      break;
  }
  chassis_detail-&gt;mutable_basic()-&gt;set_num_satellites(
      num_satellites(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="38" clone_end="54">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="100" clone_end="116">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="19" clone_end="34">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="5" clone_end="20">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length,
                        ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="52" clone_end="66">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length,
                        ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="38" clone_end="50">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length,
                        ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(58, 0)" endLine="(97, 1)" clone_start="1" clone_end="21">
			<code function_name="Spline2dConstraint::Add2dBoundary(const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle, const std::vector&lt;Vec2d&gt;&amp; ref_point, const std::vector&lt;double&gt;&amp; longitidinal_bound, const std::vector&lt;double&gt;&amp; lateral_bound)">bool Spline2dConstraint::Add2dBoundary(
    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle,
    const std::vector&lt;Vec2d&gt;&amp; ref_point,
    const std::vector&lt;double&gt;&amp; longitidinal_bound,
    const std::vector&lt;double&gt;&amp; lateral_bound) {
  if (t_coord.size() != angle.size() || angle.size() != ref_point.size() ||
      ref_point.size() != longitidinal_bound.size() ||
      longitidinal_bound.size() != lateral_bound.size()) {
    return false;
  }
  Eigen::MatrixXd affine_inequality =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), 1);
  for (std::uint32_t i = 0; i &lt; t_coord.size(); ++i) {
    const double d_longitudinal = SignDistance(ref_point[i], angle[i]);
    const double d_lateral = SignDistance(ref_point[i], angle[i] - M_PI / 2.0);
    const std::uint32_t index = FindIndex(t_coord[i]);
    const double rel_t = t_coord[i] - t_knots_[index];
    const std::uint32_t index_offset = 2 * index * spline_order_;
    std::vector&lt;double&gt; longi_coef = AffineCoef(angle[i], rel_t);
    std::vector&lt;double&gt; lateral_coef = AffineCoef(angle[i] - M_PI / 2, rel_t);
    for (std::uint32_t j = 0; j &lt; 2 * spline_order_; ++j) {
      // upper longi
      affine_inequality(4 * i, index_offset + j) = longi_coef[j];
      // lower longi
      affine_inequality(4 * i + 1, index_offset + j) = -longi_coef[j];
      // upper lateral
      affine_inequality(4 * i + 2, index_offset + j) = lateral_coef[j];
      // lower lateral
      affine_inequality(4 * i + 3, index_offset + j) = -lateral_coef[j];
    }

    affine_boundary(4 * i, 0) = d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 1, 0) = -d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 2, 0) = d_lateral - lateral_bound[i];
    affine_boundary(4 * i + 3, 0) = -d_lateral - lateral_bound[i];
  }
  return AddInequalityConstraint(affine_inequality, affine_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(99, 0)" endLine="(139, 1)" clone_start="1" clone_end="21">
			<code function_name="Spline2dConstraint::Add2dDerivativeBoundary(    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle,     const std::vector&lt;Vec2d&gt;&amp; ref_point,     const std::vector&lt;double&gt;&amp; longitidinal_bound, const std::vector&lt;double&gt;&amp; lateral_bound)">bool Spline2dConstraint::Add2dDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle,
    const std::vector&lt;Vec2d&gt;&amp; ref_point,
    const std::vector&lt;double&gt;&amp; longitidinal_bound,
    const std::vector&lt;double&gt;&amp; lateral_bound) {
  if (t_coord.size() != angle.size() || angle.size() != ref_point.size() ||
      ref_point.size() != longitidinal_bound.size() ||
      longitidinal_bound.size() != lateral_bound.size()) {
    return false;
  }
  Eigen::MatrixXd affine_inequality =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), 1);
  for (std::uint32_t i = 0; i &lt; t_coord.size(); ++i) {
    const double d_longitudinal = SignDistance(ref_point[i], angle[i]);
    const double d_lateral = SignDistance(ref_point[i], angle[i] - M_PI / 2.0);
    const std::uint32_t index = FindIndex(t_coord[i]);
    const double rel_t = t_coord[i] - t_knots_[index];
    const std::uint32_t index_offset = 2 * index * spline_order_;
    std::vector&lt;double&gt; longi_coef = AffineDerivativeCoef(angle[i], rel_t);
    std::vector&lt;double&gt; lateral_coef =
        AffineDerivativeCoef(angle[i] - M_PI / 2, rel_t);
    for (std::uint32_t j = 0; j &lt; 2 * spline_order_; ++j) {
      // upper longi
      affine_inequality(4 * i, index_offset + j) = longi_coef[j];
      // lower longi
      affine_inequality(4 * i + 1, index_offset + j) = -longi_coef[j];
      // upper lateral
      affine_inequality(4 * i + 2, index_offset + j) = lateral_coef[j];
      // lower lateral
      affine_inequality(4 * i + 3, index_offset + j) = -lateral_coef[j];
    }

    affine_boundary(4 * i, 0) = d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 1, 0) = -d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 2, 0) = d_lateral - lateral_bound[i];
    affine_boundary(4 * i + 3, 0) = -d_lateral - lateral_bound[i];
  }
  return AddInequalityConstraint(affine_inequality, affine_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(184, 0)" endLine="(224, 1)" clone_start="1" clone_end="21">
			<code function_name="Spline2dConstraint::Add2dThirdDerivativeBoundary(    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle,     const std::vector&lt;Vec2d&gt;&amp; ref_point,     const std::vector&lt;double&gt;&amp; longitidinal_bound, const std::vector&lt;double&gt;&amp; lateral_bound)">bool Spline2dConstraint::Add2dThirdDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle,
    const std::vector&lt;Vec2d&gt;&amp; ref_point,
    const std::vector&lt;double&gt;&amp; longitidinal_bound,
    const std::vector&lt;double&gt;&amp; lateral_bound) {
  if (t_coord.size() != angle.size() || angle.size() != ref_point.size() ||
      ref_point.size() != longitidinal_bound.size() ||
      longitidinal_bound.size() != lateral_bound.size()) {
    return false;
  }
  Eigen::MatrixXd affine_inequality =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), 1);
  for (std::uint32_t i = 0; i &lt; t_coord.size(); ++i) {
    const double d_longitudinal = SignDistance(ref_point[i], angle[i]);
    const double d_lateral = SignDistance(ref_point[i], angle[i] - M_PI / 2.0);
    const std::uint32_t index = FindIndex(t_coord[i]);
    const double rel_t = t_coord[i] - t_knots_[index];
    const std::uint32_t index_offset = 2 * index * spline_order_;
    std::vector&lt;double&gt; longi_coef = AffineThirdDerivativeCoef(angle[i], rel_t);
    std::vector&lt;double&gt; lateral_coef =
        AffineThirdDerivativeCoef(angle[i] - M_PI / 2, rel_t);
    for (std::uint32_t j = 0; j &lt; 2 * spline_order_; ++j) {
      // upper longi
      affine_inequality(4 * i, index_offset + j) = longi_coef[j];
      // lower longi
      affine_inequality(4 * i + 1, index_offset + j) = -longi_coef[j];
      // upper lateral
      affine_inequality(4 * i + 2, index_offset + j) = lateral_coef[j];
      // lower lateral
      affine_inequality(4 * i + 3, index_offset + j) = -lateral_coef[j];
    }

    affine_boundary(4 * i, 0) = d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 1, 0) = -d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 2, 0) = d_lateral - lateral_bound[i];
    affine_boundary(4 * i + 3, 0) = -d_lateral - lateral_bound[i];
  }
  return AddInequalityConstraint(affine_inequality, affine_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_kernel.cc" startLine="(79, 0)" endLine="(91, 1)" clone_start="1" clone_end="13">
			<code function_name="Spline2dKernel::AddDerivativeKernelMatrix(const double weight)">void Spline2dKernel::AddDerivativeKernelMatrix(const double weight) {
  for (std::uint32_t i = 0; i + 1 &lt; t_knots_.size(); ++i) {
    Eigen::MatrixXd cur_kernel =
        SplineSegKernel::instance()-&gt;DerivativeKernel(
            spline_order_, t_knots_[i + 1] - t_knots_[i]) *
        weight;
    kernel_matrix_.block(2 * i * spline_order_, 2 * i * spline_order_,
                         spline_order_, spline_order_) += cur_kernel;
    kernel_matrix_.block((2 * i + 1) * spline_order_,
                         (2 * i + 1) * spline_order_, spline_order_,
                         spline_order_) += cur_kernel;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_kernel.cc" startLine="(93, 0)" endLine="(105, 1)" clone_start="1" clone_end="13">
			<code function_name="Spline2dKernel::AddSecondOrderDerivativeMatrix(const double weight)">void Spline2dKernel::AddSecondOrderDerivativeMatrix(const double weight) {
  for (std::uint32_t i = 0; i + 1 &lt; t_knots_.size(); ++i) {
    Eigen::MatrixXd cur_kernel =
        SplineSegKernel::instance()-&gt;SecondOrderDerivativeKernel(
            spline_order_, t_knots_[i + 1] - t_knots_[i]) *
        weight;
    kernel_matrix_.block(2 * i * spline_order_, 2 * i * spline_order_,
                         spline_order_, spline_order_) += cur_kernel;
    kernel_matrix_.block((2 * i + 1) * spline_order_,
                         (2 * i + 1) * spline_order_, spline_order_,
                         spline_order_) += cur_kernel;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_kernel.cc" startLine="(93, 0)" endLine="(105, 1)" clone_start="1" clone_end="9">
			<code function_name="Spline2dKernel::AddSecondOrderDerivativeMatrix(const double weight)">void Spline2dKernel::AddSecondOrderDerivativeMatrix(const double weight) {
  for (std::uint32_t i = 0; i + 1 &lt; t_knots_.size(); ++i) {
    Eigen::MatrixXd cur_kernel =
        SplineSegKernel::instance()-&gt;SecondOrderDerivativeKernel(
            spline_order_, t_knots_[i + 1] - t_knots_[i]) *
        weight;
    kernel_matrix_.block(2 * i * spline_order_, 2 * i * spline_order_,
                         spline_order_, spline_order_) += cur_kernel;
    kernel_matrix_.block((2 * i + 1) * spline_order_,
                         (2 * i + 1) * spline_order_, spline_order_,
                         spline_order_) += cur_kernel;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_kernel.cc" startLine="(107, 0)" endLine="(119, 1)" clone_start="1" clone_end="9">
			<code function_name="Spline2dKernel::AddThirdOrderDerivativeMatrix(const double weight)">void Spline2dKernel::AddThirdOrderDerivativeMatrix(const double weight) {
  for (std::uint32_t i = 0; i + 1 &lt; t_knots_.size(); ++i) {
    Eigen::MatrixXd cur_kernel =
        SplineSegKernel::instance()-&gt;ThirdOrderDerivativeKernel(
            spline_order_, t_knots_[i + 1] - t_knots_[i]) *
        weight;
    kernel_matrix_.block(2 * i * spline_order_, 2 * i * spline_order_,
                         spline_order_, spline_order_) += cur_kernel;
    kernel_matrix_.block((2 * i + 1) * spline_order_,
                         (2 * i + 1) * spline_order_, spline_order_,
                         spline_order_) += cur_kernel;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(65, 0)" endLine="(72, 1)" clone_start="1" clone_end="8">
			<code function_name="Gps6f::heading(const std::uint8_t *bytes, int32_t length) const">double Gps6f::heading(const std::uint8_t *bytes, int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(136, 0)" endLine="(144, 1)" clone_start="1" clone_end="9">
			<code function_name="Brakeinfo74::braking_torque_actual(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::braking_torque_actual(const std::uint8_t *bytes,
                                          int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 4);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 4.000000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(74, 0)" endLine="(78, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6f::speed(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6f::speed(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 8);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(146, 0)" endLine="(152, 1)" clone_start="1" clone_end="7">
			<code function_name="Brakeinfo74::hill_start_assist_mode(const std::uint8_t *bytes, int32_t length) const">int32_t Brakeinfo74::hill_start_assist_mode(const std::uint8_t *bytes,
                                            int32_t length) const {
  // see table for status code
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(4, 2);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(80, 0)" endLine="(84, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6f::hdop(const std::uint8_t *bytes, int32_t length) const">double Gps6f::hdop(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 5);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(154, 0)" endLine="(160, 1)" clone_start="1" clone_end="5">
			<code function_name="Brakeinfo74::parking_brake_status(const std::uint8_t *bytes, int32_t length) const">int32_t Brakeinfo74::parking_brake_status(const std::uint8_t *bytes,
                                          int32_t length) const {
  // see table for status code
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(6, 2);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.cc" startLine="(320, 0)" endLine="(391, 1)" clone_start="54" clone_end="70">
			<code function_name="MinBoxObjectBuilder::ComputePolygon2dxy(ObjectPtr obj)">void MinBoxObjectBuilder::ComputePolygon2dxy(ObjectPtr obj) {
    Eigen::Vector4f min_pt;
    Eigen::Vector4f max_pt;
    pcl_util::PointCloudPtr cloud = obj-&gt;cloud;
    SetDefaultValue(cloud, obj, &amp;min_pt, &amp;max_pt);
    if (cloud-&gt;points.size() &lt; 4u) {
        return;
    }
    GetCloudMinMax3D&lt;Point&gt;(cloud, &amp;min_pt, &amp;max_pt);
    obj-&gt;height = static_cast&lt;double&gt;(max_pt[2]) -
                    static_cast&lt;double&gt;(min_pt[2]);
    const double min_eps = 10 * std::numeric_limits&lt;double&gt;::epsilon();
    // double min_eps = 0.1;
    // if ((max_pt[0] - min_pt[0]) &lt; min_eps) {
    //     _cloud-&gt;points[0].x += min_eps;
    // }
    // if ((max_pt[1] - min_pt[1]) &lt; min_eps) {
    //     _cloud-&gt;points[0].y += min_eps;
    // }
    const double diff_x = cloud-&gt;points[1].x - cloud-&gt;points[0].x;
    const double diff_y = cloud-&gt;points[1].y - cloud-&gt;points[0].y;
    size_t idx = 0;
    for (idx = 2; idx &lt; cloud-&gt;points.size(); ++idx) {
        const double tdiff_x = cloud-&gt;points[idx].x - cloud-&gt;points[0].x;
        const double tdiff_y = cloud-&gt;points[idx].y - cloud-&gt;points[0].y;
        if ((diff_x * tdiff_y - tdiff_x * diff_y) &gt; min_eps) {
            break;
        }
    }
    if (idx &gt;= cloud-&gt;points.size()) {
        cloud-&gt;points[0].x += min_eps;
        cloud-&gt;points[0].y += min_eps;
        cloud-&gt;points[1].x -= min_eps;
    }

    PointCloudPtr pcd_xy(new PointCloud);
    for (size_t i = 0; i &lt; cloud-&gt;points.size(); ++i) {
        Point p = cloud-&gt;points[i];
        p.z = min_pt[2];
        pcd_xy-&gt;push_back(p);
    }

    ConvexHull2DXY&lt;pcl_util::Point&gt; hull;
    hull.setInputCloud(pcd_xy);
    hull.setDimension(2);
    std::vector&lt;pcl::Vertices&gt; poly_vt;
    PointCloudPtr plane_hull(new PointCloud);
    hull.Reconstruct2dxy(plane_hull, &amp;poly_vt);

    if (poly_vt.size() == 1u) {
        std::vector&lt;int&gt; ind(poly_vt[0].vertices.begin(),
                            poly_vt[0].vertices.end());
        TransformPointCloud(plane_hull, ind, &amp;obj-&gt;polygon);
    } else {
        obj-&gt;polygon.points.resize(4);
        obj-&gt;polygon.points[0].x = static_cast&lt;double&gt;(min_pt[0]);
        obj-&gt;polygon.points[0].y = static_cast&lt;double&gt;(min_pt[1]);
        obj-&gt;polygon.points[0].z = static_cast&lt;double&gt;(min_pt[2]);

        obj-&gt;polygon.points[1].x = static_cast&lt;double&gt;(min_pt[0]);
        obj-&gt;polygon.points[1].y = static_cast&lt;double&gt;(max_pt[1]);
        obj-&gt;polygon.points[1].z = static_cast&lt;double&gt;(min_pt[2]);

        obj-&gt;polygon.points[2].x = static_cast&lt;double&gt;(max_pt[0]);
        obj-&gt;polygon.points[2].y = static_cast&lt;double&gt;(max_pt[1]);
        obj-&gt;polygon.points[2].z = static_cast&lt;double&gt;(min_pt[2]);

        obj-&gt;polygon.points[3].x = static_cast&lt;double&gt;(max_pt[0]);
        obj-&gt;polygon.points[3].y = static_cast&lt;double&gt;(min_pt[1]);
        obj-&gt;polygon.points[3].z = static_cast&lt;double&gt;(min_pt[2]);
    }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\dummy\dummy_algorithms.cc" startLine="(59, 0)" endLine="(85, 1)" clone_start="8" clone_end="25">
			<code function_name="DummyObjectBuilder::BuildObject(const ObjectBuilderOptions &amp;options, ObjectPtr obj)">void DummyObjectBuilder::BuildObject(const ObjectBuilderOptions &amp;options,
                                     ObjectPtr obj) {
  Eigen::Vector4f min_pt;
  Eigen::Vector4f max_pt;
  PointCloudPtr cloud = obj-&gt;cloud;
  SetDefaultValue(cloud, obj, &amp;min_pt, &amp;max_pt);
  if (cloud-&gt;points.size() &lt; 4u) {
    return;
  }
  obj-&gt;polygon.points.resize(4);
  obj-&gt;polygon.points[0].x = static_cast&lt;double&gt;(min_pt[0]);
  obj-&gt;polygon.points[0].y = static_cast&lt;double&gt;(min_pt[1]);
  obj-&gt;polygon.points[0].z = static_cast&lt;double&gt;(min_pt[2]);

  obj-&gt;polygon.points[1].x = static_cast&lt;double&gt;(min_pt[0]);
  obj-&gt;polygon.points[1].y = static_cast&lt;double&gt;(max_pt[1]);
  obj-&gt;polygon.points[1].z = static_cast&lt;double&gt;(min_pt[2]);

  obj-&gt;polygon.points[2].x = static_cast&lt;double&gt;(max_pt[0]);
  obj-&gt;polygon.points[2].y = static_cast&lt;double&gt;(max_pt[1]);
  obj-&gt;polygon.points[2].z = static_cast&lt;double&gt;(min_pt[2]);

  obj-&gt;polygon.points[3].x = static_cast&lt;double&gt;(max_pt[0]);
  obj-&gt;polygon.points[3].y = static_cast&lt;double&gt;(min_pt[1]);
  obj-&gt;polygon.points[3].z = static_cast&lt;double&gt;(min_pt[2]);
  obj-&gt;anchor_point = obj-&gt;center;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(42, 0)" endLine="(101, 1)" clone_start="30" clone_end="47">
			<code function_name="ProtoOrganizer::GetRoadElements(std::vector&lt;RoadInternal&gt;* roads)">void ProtoOrganizer::GetRoadElements(std::vector&lt;RoadInternal&gt;* roads) {
  for (auto&amp; road_internal : *roads) {
    // lanes
    for (auto&amp; section_internal : road_internal.sections) {
      for (auto&amp; lane_internal : section_internal.lanes) {
        std::string lane_id = lane_internal.lane.id().id();
        proto_data_.pb_lanes[lane_id] = lane_internal.lane;
        section_internal.section.add_lane_id()-&gt;set_id(lane_id);
      }
      (*road_internal.road.add_section()) = section_internal.section;
      proto_data_.pb_roads[road_internal.id] = road_internal.road;
    }
    // crosswalks
    for (auto&amp; crosswalk : road_internal.crosswalks) {
      proto_data_.pb_crosswalks[crosswalk.id().id()] = crosswalk;
    }
    // clear areas
    for (auto&amp; clear_area : road_internal.clear_areas) {
      proto_data_.pb_clear_areas[clear_area.id().id()] = clear_area;
    }
    // speed_bump
    for (auto&amp; speed_bump : road_internal.speed_bumps) {
      proto_data_.pb_speed_bumps[speed_bump.id().id()] = speed_bump;
    }
    // stop lines
    for (auto&amp; stop_line_internal : road_internal.stop_lines) {
      proto_data_.pb_stop_lines[stop_line_internal.id] = stop_line_internal;
    }
    // traffic_lights
    for (auto&amp; traffic_light_internal : road_internal.traffic_lights) {
      auto&amp; traffic_light = traffic_light_internal.traffic_light;
      for (auto stop_line_id : traffic_light_internal.stop_line_ids) {
        CHECK_GT(proto_data_.pb_stop_lines.count(stop_line_id), 0);
        auto&amp; stop_line_curve = proto_data_.pb_stop_lines[stop_line_id].curve;
        (*traffic_light.add_stop_line()) = stop_line_curve;
      }
      proto_data_.pb_signals[traffic_light.id().id()] = traffic_light;
    }
    // stop signs
    for (auto&amp; stop_sign_internal : road_internal.stop_signs) {
      auto&amp; stop_sign = stop_sign_internal.stop_sign;
      for (auto stop_line_id : stop_sign_internal.stop_line_ids) {
        CHECK_GT(proto_data_.pb_stop_lines.count(stop_line_id), 0);
        auto&amp; stop_line_curve = proto_data_.pb_stop_lines[stop_line_id].curve;
        (*stop_sign.add_stop_line()) = stop_line_curve;
      }
      proto_data_.pb_stop_signs[stop_sign.id().id()] = stop_sign;
    }
    // yield signs
    for (auto&amp; yield_sign_internal : road_internal.yield_signs) {
      auto&amp; yield_sign = yield_sign_internal.yield_sign;
      for (auto stop_line_id : yield_sign_internal.stop_line_ids) {
        CHECK_GT(proto_data_.pb_stop_lines.count(stop_line_id), 0);
        auto&amp; stop_line_curve = proto_data_.pb_stop_lines[stop_line_id].curve;
        (*yield_sign.add_stop_line()) = stop_line_curve;
      }
      proto_data_.pb_yield_signs[yield_sign.id().id()] = yield_sign;
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(42, 0)" endLine="(101, 1)" clone_start="40" clone_end="57">
			<code function_name="ProtoOrganizer::GetRoadElements(std::vector&lt;RoadInternal&gt;* roads)">void ProtoOrganizer::GetRoadElements(std::vector&lt;RoadInternal&gt;* roads) {
  for (auto&amp; road_internal : *roads) {
    // lanes
    for (auto&amp; section_internal : road_internal.sections) {
      for (auto&amp; lane_internal : section_internal.lanes) {
        std::string lane_id = lane_internal.lane.id().id();
        proto_data_.pb_lanes[lane_id] = lane_internal.lane;
        section_internal.section.add_lane_id()-&gt;set_id(lane_id);
      }
      (*road_internal.road.add_section()) = section_internal.section;
      proto_data_.pb_roads[road_internal.id] = road_internal.road;
    }
    // crosswalks
    for (auto&amp; crosswalk : road_internal.crosswalks) {
      proto_data_.pb_crosswalks[crosswalk.id().id()] = crosswalk;
    }
    // clear areas
    for (auto&amp; clear_area : road_internal.clear_areas) {
      proto_data_.pb_clear_areas[clear_area.id().id()] = clear_area;
    }
    // speed_bump
    for (auto&amp; speed_bump : road_internal.speed_bumps) {
      proto_data_.pb_speed_bumps[speed_bump.id().id()] = speed_bump;
    }
    // stop lines
    for (auto&amp; stop_line_internal : road_internal.stop_lines) {
      proto_data_.pb_stop_lines[stop_line_internal.id] = stop_line_internal;
    }
    // traffic_lights
    for (auto&amp; traffic_light_internal : road_internal.traffic_lights) {
      auto&amp; traffic_light = traffic_light_internal.traffic_light;
      for (auto stop_line_id : traffic_light_internal.stop_line_ids) {
        CHECK_GT(proto_data_.pb_stop_lines.count(stop_line_id), 0);
        auto&amp; stop_line_curve = proto_data_.pb_stop_lines[stop_line_id].curve;
        (*traffic_light.add_stop_line()) = stop_line_curve;
      }
      proto_data_.pb_signals[traffic_light.id().id()] = traffic_light;
    }
    // stop signs
    for (auto&amp; stop_sign_internal : road_internal.stop_signs) {
      auto&amp; stop_sign = stop_sign_internal.stop_sign;
      for (auto stop_line_id : stop_sign_internal.stop_line_ids) {
        CHECK_GT(proto_data_.pb_stop_lines.count(stop_line_id), 0);
        auto&amp; stop_line_curve = proto_data_.pb_stop_lines[stop_line_id].curve;
        (*stop_sign.add_stop_line()) = stop_line_curve;
      }
      proto_data_.pb_stop_signs[stop_sign.id().id()] = stop_sign;
    }
    // yield signs
    for (auto&amp; yield_sign_internal : road_internal.yield_signs) {
      auto&amp; yield_sign = yield_sign_internal.yield_sign;
      for (auto stop_line_id : yield_sign_internal.stop_line_ids) {
        CHECK_GT(proto_data_.pb_stop_lines.count(stop_line_id), 0);
        auto&amp; stop_line_curve = proto_data_.pb_stop_lines[stop_line_id].curve;
        (*yield_sign.add_stop_line()) = stop_line_curve;
      }
      proto_data_.pb_yield_signs[yield_sign.id().id()] = yield_sign;
    }
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\tests\test_monitor.cpp" startLine="(43, 0)" endLine="(70, 1)" clone_start="2" clone_end="17">
			<code function_name="stream_status_callback(const apollo::common::gnss_status::StreamStatus &amp;stream_status)">void stream_status_callback(const apollo::common::gnss_status::StreamStatus &amp;stream_status) {
    switch (stream_status.ins_stream_type()) {
    case apollo::common::gnss_status::StreamStatus::CONNECTED:
        fprintf(stdout, "INS stream is CONNECTED.\r\n");
        break;
    case apollo::common::gnss_status::StreamStatus::DISCONNECTED:
        fprintf(stdout, "INS stream is DISCONNECTED.\r\n");
        break;
    }

    switch (stream_status.rtk_stream_in_type()) {
    case apollo::common::gnss_status::StreamStatus::CONNECTED:
        fprintf(stdout, "rtk stream in is CONNECTED.\r\n");
        break;
    case apollo::common::gnss_status::StreamStatus::DISCONNECTED:
        fprintf(stdout, "rtk stream in is DISCONNECTED.\r\n");
        break;
    }

    switch (stream_status.rtk_stream_out_type()) {
    case apollo::common::gnss_status::StreamStatus::CONNECTED:
        fprintf(stdout, "rtk stream out CONNECTED.\r\n");
        break;
    case apollo::common::gnss_status::StreamStatus::DISCONNECTED:
        fprintf(stdout, "rtk stream out DISCONNECTED.\r\n");
        break;
    }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\tests\test_monitor.cpp" startLine="(43, 0)" endLine="(70, 1)" clone_start="11" clone_end="26">
			<code function_name="stream_status_callback(const apollo::common::gnss_status::StreamStatus &amp;stream_status)">void stream_status_callback(const apollo::common::gnss_status::StreamStatus &amp;stream_status) {
    switch (stream_status.ins_stream_type()) {
    case apollo::common::gnss_status::StreamStatus::CONNECTED:
        fprintf(stdout, "INS stream is CONNECTED.\r\n");
        break;
    case apollo::common::gnss_status::StreamStatus::DISCONNECTED:
        fprintf(stdout, "INS stream is DISCONNECTED.\r\n");
        break;
    }

    switch (stream_status.rtk_stream_in_type()) {
    case apollo::common::gnss_status::StreamStatus::CONNECTED:
        fprintf(stdout, "rtk stream in is CONNECTED.\r\n");
        break;
    case apollo::common::gnss_status::StreamStatus::DISCONNECTED:
        fprintf(stdout, "rtk stream in is DISCONNECTED.\r\n");
        break;
    }

    switch (stream_status.rtk_stream_out_type()) {
    case apollo::common::gnss_status::StreamStatus::CONNECTED:
        fprintf(stdout, "rtk stream out CONNECTED.\r\n");
        break;
    case apollo::common::gnss_status::StreamStatus::DISCONNECTED:
        fprintf(stdout, "rtk stream out DISCONNECTED.\r\n");
        break;
    }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(40, 0)" endLine="(100, 1)" clone_start="15" clone_end="36">
			<code function_name="HDMapImpl::LoadMapFromFile(const std::string&amp; map_filename)">int HDMapImpl::LoadMapFromFile(const std::string&amp; map_filename) {
  Clear();

  if (apollo::common::util::EndWith(map_filename, ".xml")) {
    if (!adapter::OpendriveAdapter::LoadData(map_filename, &amp;map_)) {
      return -1;
    }
  } else if (!apollo::common::util::GetProtoFromFile(map_filename, &amp;map_)) {
    return -1;
  }

  for (const auto&amp; lane : map_.lane()) {
    lane_table_[lane.id().id()].reset(new LaneInfo(lane));
  }
  for (const auto&amp; junction : map_.junction()) {
    junction_table_[junction.id().id()].reset(new JunctionInfo(junction));
  }
  for (const auto&amp; signal : map_.signal()) {
    signal_table_[signal.id().id()].reset(new SignalInfo(signal));
  }
  for (const auto&amp; crosswalk : map_.crosswalk()) {
    crosswalk_table_[crosswalk.id().id()].reset(new CrosswalkInfo(crosswalk));
  }
  for (const auto&amp; stop_sign : map_.stop_sign()) {
    stop_sign_table_[stop_sign.id().id()].reset(new StopSignInfo(stop_sign));
  }
  for (const auto&amp; yield_sign : map_.yield()) {
    yield_sign_table_[yield_sign.id().id()].reset(
        new YieldSignInfo(yield_sign));
  }
  for (const auto&amp; overlap : map_.overlap()) {
    overlap_table_[overlap.id().id()].reset(new OverlapInfo(overlap));
  }

  for (const auto&amp; road : map_.road()) {
    road_table_[road.id().id()].reset(new RoadInfo(road));
  }

  for (const auto&amp; road_ptr_pair : road_table_) {
    const auto&amp; road_id = road_ptr_pair.second-&gt;id();
    for (const auto&amp; road_section : road_ptr_pair.second-&gt;sections()) {
      const auto&amp; section_id = road_section.id();
      for (const auto&amp; lane_id : road_section.lane_id()) {
        lane_table_[lane_id.id()]-&gt;set_road_id(road_id);
        lane_table_[lane_id.id()]-&gt;set_section_id(section_id);
      }
    }
  }
  for (const auto&amp; lane_ptr_pair : lane_table_) {
    lane_ptr_pair.second-&gt;PostProcess(*this);
  }

  BuildLaneSegmentKDTree();
  BuildJunctionPolygonKDTree();
  BuildSignalSegmentKDTree();
  BuildCrosswalkPolygonKDTree();
  BuildStopSignSegmentKDTree();
  BuildYieldSignSegmentKDTree();

  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(40, 0)" endLine="(100, 1)" clone_start="12" clone_end="32">
			<code function_name="HDMapImpl::LoadMapFromFile(const std::string&amp; map_filename)">int HDMapImpl::LoadMapFromFile(const std::string&amp; map_filename) {
  Clear();

  if (apollo::common::util::EndWith(map_filename, ".xml")) {
    if (!adapter::OpendriveAdapter::LoadData(map_filename, &amp;map_)) {
      return -1;
    }
  } else if (!apollo::common::util::GetProtoFromFile(map_filename, &amp;map_)) {
    return -1;
  }

  for (const auto&amp; lane : map_.lane()) {
    lane_table_[lane.id().id()].reset(new LaneInfo(lane));
  }
  for (const auto&amp; junction : map_.junction()) {
    junction_table_[junction.id().id()].reset(new JunctionInfo(junction));
  }
  for (const auto&amp; signal : map_.signal()) {
    signal_table_[signal.id().id()].reset(new SignalInfo(signal));
  }
  for (const auto&amp; crosswalk : map_.crosswalk()) {
    crosswalk_table_[crosswalk.id().id()].reset(new CrosswalkInfo(crosswalk));
  }
  for (const auto&amp; stop_sign : map_.stop_sign()) {
    stop_sign_table_[stop_sign.id().id()].reset(new StopSignInfo(stop_sign));
  }
  for (const auto&amp; yield_sign : map_.yield()) {
    yield_sign_table_[yield_sign.id().id()].reset(
        new YieldSignInfo(yield_sign));
  }
  for (const auto&amp; overlap : map_.overlap()) {
    overlap_table_[overlap.id().id()].reset(new OverlapInfo(overlap));
  }

  for (const auto&amp; road : map_.road()) {
    road_table_[road.id().id()].reset(new RoadInfo(road));
  }

  for (const auto&amp; road_ptr_pair : road_table_) {
    const auto&amp; road_id = road_ptr_pair.second-&gt;id();
    for (const auto&amp; road_section : road_ptr_pair.second-&gt;sections()) {
      const auto&amp; section_id = road_section.id();
      for (const auto&amp; lane_id : road_section.lane_id()) {
        lane_table_[lane_id.id()]-&gt;set_road_id(road_id);
        lane_table_[lane_id.id()]-&gt;set_section_id(section_id);
      }
    }
  }
  for (const auto&amp; lane_ptr_pair : lane_table_) {
    lane_ptr_pair.second-&gt;PostProcess(*this);
  }

  BuildLaneSegmentKDTree();
  BuildJunctionPolygonKDTree();
  BuildSignalSegmentKDTree();
  BuildCrosswalkPolygonKDTree();
  BuildStopSignSegmentKDTree();
  BuildYieldSignSegmentKDTree();

  return 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="36" clone_end="50">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length,
                        ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="3" clone_end="20">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length,
                        ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(26, 0)" endLine="(114, 1)" clone_start="84" clone_end="89">
			<code function_name="SignalsXmlParser::ParseTrafficLights(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;TrafficLightInternal&gt;* traffic_lights)">Status SignalsXmlParser::ParseTrafficLights(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;TrafficLightInternal&gt;* traffic_lights) {
  CHECK_NOTNULL(traffic_lights);
  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "trafficLight") {
      PbSignal traffic_light;
      traffic_light.mutable_id()-&gt;set_id(object_id);
      std::string layout_type;
      int checker = UtilXmlParser::QueryStringAttribute(
          *signal_node, "layoutType", &amp;layout_type);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse signal layout type.";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      PbSignalType signal_layout_type;
      ToPbSignalType(layout_type, &amp;signal_layout_type);
      traffic_light.set_type(signal_layout_type);

      PbPolygon* polygon = traffic_light.mutable_boundary();
      auto outline_node = signal_node-&gt;FirstChildElement("outline");
      if (outline_node == nullptr) {
        std::string err_msg = "Error parse signal outline";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseOutline(*outline_node, polygon));
      auto sub_node = signal_node-&gt;FirstChildElement("subSignal");
      if (sub_node == nullptr) {
        std::string err_msg = "Error parse sub signal.";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      while (sub_node) {
        std::string sub_signal_id;
        std::string sub_signal_xml_type;
        checker = UtilXmlParser::QueryStringAttribute(*sub_node, "type",
                                                      &amp;sub_signal_xml_type);
        checker += UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                       &amp;sub_signal_id);
        if (checker != tinyxml2::XML_SUCCESS) {
          std::string err_msg = "Error parse sub signal layout type.";
          return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
        }

        PbSubSignal* sub_signal = traffic_light.add_subsignal();
        PbSubSignalType sub_signal_type;
        ToPbSubSignalType(sub_signal_xml_type, &amp;sub_signal_type);
        sub_signal-&gt;mutable_id()-&gt;set_id(sub_signal_id);
        sub_signal-&gt;set_type(sub_signal_type);
        PbPoint3D* pt = sub_signal-&gt;mutable_location();
        RETURN_IF_ERROR(UtilXmlParser::ParsePoint(*sub_node, pt));

        sub_node = sub_node-&gt;NextSiblingElement("subSignal");
      }

      TrafficLightInternal trafficlight_internal;
      trafficlight_internal.id = object_id;
      trafficlight_internal.traffic_light = traffic_light;

      sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                            &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          trafficlight_internal.stop_line_ids.insert(stop_line_id);
          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      traffic_lights-&gt;emplace_back(trafficlight_internal);
    }
    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(511, 0)" endLine="(551, 1)" clone_start="34" clone_end="41">
			<code function_name="LanesXmlParser::ParseLaneOverlapGroup(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;OverlapWithLane&gt;* lane_overlaps)">Status LanesXmlParser::ParseLaneOverlapGroup(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;OverlapWithLane&gt;* lane_overlaps) {
  CHECK_NOTNULL(lane_overlaps);

  auto overlap_node = xml_node.FirstChildElement("laneOverlapGroup");
  if (overlap_node) {
    auto sub_node = overlap_node-&gt;FirstChildElement("laneReference");
    while (sub_node) {
      std::string lane_id;
      double start_s = 0.0;
      double end_s = 0.0;
      int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                   &amp;lane_id);
      checker += sub_node-&gt;QueryDoubleAttribute("startOffset", &amp;start_s);
      checker += sub_node-&gt;QueryDoubleAttribute("endOffset", &amp;end_s);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse lane lane overlap";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      bool is_merge = false;
      checker = sub_node-&gt;QueryBoolAttribute("isMerge", &amp;is_merge);
      if (checker != tinyxml2::XML_SUCCESS) {
        is_merge = false;
      }

      OverlapWithLane overlap_with_lane;
      overlap_with_lane.object_id = lane_id;
      overlap_with_lane.start_s = start_s;
      overlap_with_lane.end_s = end_s;
      overlap_with_lane.is_merge = is_merge;

      lane_overlaps-&gt;push_back(overlap_with_lane);

      sub_node = sub_node-&gt;NextSiblingElement("laneReference");
    }
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(116, 0)" endLine="(140, 1)" clone_start="1" clone_end="14">
			<code function_name="SignalsXmlParser::ToPbSignalType(const std::string&amp; xml_type, PbSignalType* signal_type)">Status SignalsXmlParser::ToPbSignalType(const std::string&amp; xml_type,
                                        PbSignalType* signal_type) {
  CHECK_NOTNULL(signal_type);

  std::string upper_str = UtilXmlParser::ToUpper(xml_type);

  if (upper_str == "UNKNOWN") {
    *signal_type = hdmap::Signal::UNKNOWN;
  } else if (upper_str == "MIX2HORIZONTAL") {
    *signal_type = hdmap::Signal::MIX_2_HORIZONTAL;
  } else if (upper_str == "MIX2VERTICAL") {
    *signal_type = hdmap::Signal::MIX_2_VERTICAL;
  } else if (upper_str == "MIX3HORIZONTAL") {
    *signal_type = hdmap::Signal::MIX_3_HORIZONTAL;
  } else if (upper_str == "MIX3VERTICAL") {
    *signal_type = hdmap::Signal::MIX_3_VERTICAL;
  } else if (upper_str == "SINGLE") {
    *signal_type = hdmap::Signal::SINGLE;
  } else {
    std::string err_msg = "Error or unsupport signal layout type";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(553, 0)" endLine="(573, 1)" clone_start="1" clone_end="14">
			<code function_name="LanesXmlParser::ToPbLaneType(const std::string&amp; type, PbLaneType* lane_type)">Status LanesXmlParser::ToPbLaneType(const std::string&amp; type,
                                    PbLaneType* lane_type) {
  CHECK_NOTNULL(lane_type);

  std::string upper_str = UtilXmlParser::ToUpper(type);

  if (upper_str == "NONE") {
    *lane_type = hdmap::Lane::NONE;
  } else if (upper_str == "DRIVING") {
    *lane_type = hdmap::Lane::CITY_DRIVING;
  } else if (upper_str == "BIKING") {
    *lane_type = hdmap::Lane::BIKING;
  } else if (upper_str == "PARKING") {
    *lane_type = hdmap::Lane::PARKING;
  } else {
    std::string err_msg = "Error or unsupport lane type:" + type;
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(74, 0)" endLine="(78, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6f::speed(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6f::speed(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 8);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(73, 0)" endLine="(77, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::seconds(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::seconds(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 5);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(80, 0)" endLine="(84, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6f::hdop(const std::uint8_t *bytes, int32_t length) const">double Gps6f::hdop(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 5);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(79, 0)" endLine="(84, 1)" clone_start="1" clone_end="6">
			<code function_name="Gps6e::compass_direction(const std::uint8_t *bytes, int32_t length) const">double Gps6e::compass_direction(const std::uint8_t *bytes,
                                int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 4);
  return x * 45.000000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(86, 0)" endLine="(90, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6f::vdop(const std::uint8_t *bytes, int32_t length) const">double Gps6f::vdop(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(86, 0)" endLine="(90, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::pdop(const std::uint8_t *bytes, int32_t length) const">double Gps6e::pdop(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 7);
  int32_t x = frame.get_byte(0, 5);
  return x * 0.200000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(92, 0)" endLine="(96, 1)" clone_start="1" clone_end="2">
			<code function_name="Gps6f::fix_quality(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6f::fix_quality(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 7);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(92, 0)" endLine="(95, 1)" clone_start="1" clone_end="2">
			<code function_name="Gps6e::is_gps_fault(const std::uint8_t *bytes, int32_t length) const">bool Gps6e::is_gps_fault(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(5);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\can_client\esd\esd_can_client.cc" startLine="(178, 0)" endLine="(287, 1)" clone_start="11" clone_end="24">
			<code function_name="EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus)">std::string EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus) {
  struct ERR2STR {
    NTCAN_RESULT ntstatus;
    const char *str;
  };

  int8_t str_buf[ERROR_BUF_SIZE];

  static const struct ERR2STR err2str[] = {
      {NTCAN_SUCCESS, "NTCAN_SUCCESS"},
      {NTCAN_RX_TIMEOUT, "NTCAN_RX_TIMEOUT"},
      {NTCAN_TX_TIMEOUT, "NTCAN_TX_TIMEOUT"},
      {NTCAN_TX_ERROR, "NTCAN_TX_ERROR"},
      {NTCAN_CONTR_OFF_BUS, "NTCAN_CONTR_OFF_BUS"},
      {NTCAN_CONTR_BUSY, "NTCAN_CONTR_BUSY"},
      {NTCAN_CONTR_WARN, "NTCAN_CONTR_WARN"},
      {NTCAN_NO_ID_ENABLED, "NTCAN_NO_ID_ENABLED"},
      {NTCAN_ID_ALREADY_ENABLED, "NTCAN_ID_ALREADY_ENABLED"},
      {NTCAN_ID_NOT_ENABLED, "NTCAN_ID_NOT_ENABLED"},
      {NTCAN_INVALID_FIRMWARE, "NTCAN_INVALID_FIRMWARE"},
      {NTCAN_MESSAGE_LOST, "NTCAN_MESSAGE_LOST"},
      {NTCAN_INVALID_PARAMETER, "NTCAN_INVALID_PARAMETER"},
      {NTCAN_INVALID_HANDLE, "NTCAN_INVALID_HANDLE"},
      {NTCAN_NET_NOT_FOUND, "NTCAN_NET_NOT_FOUND"},
#ifdef NTCAN_IO_INCOMPLETE
      {NTCAN_IO_INCOMPLETE, "NTCAN_IO_INCOMPLETE"},
#endif
#ifdef NTCAN_IO_PENDING
      {NTCAN_IO_PENDING, "NTCAN_IO_PENDING"},
#endif
#ifdef NTCAN_INVALID_HARDWARE
      {NTCAN_INVALID_HARDWARE, "NTCAN_INVALID_HARDWARE"},
#endif
#ifdef NTCAN_PENDING_WRITE
      {NTCAN_PENDING_WRITE, "NTCAN_PENDING_WRITE"},
#endif
#ifdef NTCAN_PENDING_READ
      {NTCAN_PENDING_READ, "NTCAN_PENDING_READ"},
#endif
#ifdef NTCAN_INVALID_DRIVER
      {NTCAN_INVALID_DRIVER, "NTCAN_INVALID_DRIVER"},
#endif
#ifdef NTCAN_OPERATION_ABORTED
      {NTCAN_OPERATION_ABORTED, "NTCAN_OPERATION_ABORTED"},
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
      {NTCAN_WRONG_DEVICE_STATE, "NTCAN_WRONG_DEVICE_STATE"},
#endif
      {NTCAN_INSUFFICIENT_RESOURCES, "NTCAN_INSUFFICIENT_RESOURCES"},
#ifdef NTCAN_HANDLE_FORCED_CLOSE
      {NTCAN_HANDLE_FORCED_CLOSE, "NTCAN_HANDLE_FORCED_CLOSE"},
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
      {NTCAN_NOT_IMPLEMENTED, "NTCAN_NOT_IMPLEMENTED"},
#endif
#ifdef NTCAN_NOT_SUPPORTED
      {NTCAN_NOT_SUPPORTED, "NTCAN_NOT_SUPPORTED"},
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
      {NTCAN_SOCK_CONN_TIMEOUT, "NTCAN_SOCK_CONN_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
      {NTCAN_SOCK_CMD_TIMEOUT, "NTCAN_SOCK_CMD_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
      {NTCAN_SOCK_HOST_NOT_FOUND, "NTCAN_SOCK_HOST_NOT_FOUND"},
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
      {NTCAN_CONTR_ERR_PASSIVE, "NTCAN_CONTR_ERR_PASSIVE"},
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
      {NTCAN_ERROR_NO_BAUDRATE, "NTCAN_ERROR_NO_BAUDRATE"},
#endif
#ifdef NTCAN_ERROR_LOM
      {NTCAN_ERROR_LOM, "NTCAN_ERROR_LOM"},
#endif
      {(NTCAN_RESULT)0xffffffff, "NTCAN_UNKNOWN"} /* stop-mark */
  };

  const struct ERR2STR *es = err2str;

  do {
    if (es-&gt;ntstatus == ntstatus) {
      break;
    }
    es++;
  } while ((uint32_t)es-&gt;ntstatus != 0xffffffff);

#ifdef NTCAN_ERROR_FORMAT_LONG
  {
    NTCAN_RESULT res;
    char sz_error_text[60];

    res = canFormatError(ntstatus, NTCAN_ERROR_FORMAT_LONG, sz_error_text,
                         sizeof(sz_error_text) - 1);
    if (NTCAN_SUCCESS == res) {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s - %s",
               es-&gt;str, sz_error_text);
    } else {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
               es-&gt;str, ntstatus);
    }
  }
#else
  snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
           es-&gt;str, ntstatus);
#endif /* of NTCAN_ERROR_FORMAT_LONG */

  return std::string((const char *)(str_buf));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\can_client\esd\esd_can_client.cc" startLine="(178, 0)" endLine="(287, 1)" clone_start="10" clone_end="23">
			<code function_name="EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus)">std::string EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus) {
  struct ERR2STR {
    NTCAN_RESULT ntstatus;
    const char *str;
  };

  int8_t str_buf[ERROR_BUF_SIZE];

  static const struct ERR2STR err2str[] = {
      {NTCAN_SUCCESS, "NTCAN_SUCCESS"},
      {NTCAN_RX_TIMEOUT, "NTCAN_RX_TIMEOUT"},
      {NTCAN_TX_TIMEOUT, "NTCAN_TX_TIMEOUT"},
      {NTCAN_TX_ERROR, "NTCAN_TX_ERROR"},
      {NTCAN_CONTR_OFF_BUS, "NTCAN_CONTR_OFF_BUS"},
      {NTCAN_CONTR_BUSY, "NTCAN_CONTR_BUSY"},
      {NTCAN_CONTR_WARN, "NTCAN_CONTR_WARN"},
      {NTCAN_NO_ID_ENABLED, "NTCAN_NO_ID_ENABLED"},
      {NTCAN_ID_ALREADY_ENABLED, "NTCAN_ID_ALREADY_ENABLED"},
      {NTCAN_ID_NOT_ENABLED, "NTCAN_ID_NOT_ENABLED"},
      {NTCAN_INVALID_FIRMWARE, "NTCAN_INVALID_FIRMWARE"},
      {NTCAN_MESSAGE_LOST, "NTCAN_MESSAGE_LOST"},
      {NTCAN_INVALID_PARAMETER, "NTCAN_INVALID_PARAMETER"},
      {NTCAN_INVALID_HANDLE, "NTCAN_INVALID_HANDLE"},
      {NTCAN_NET_NOT_FOUND, "NTCAN_NET_NOT_FOUND"},
#ifdef NTCAN_IO_INCOMPLETE
      {NTCAN_IO_INCOMPLETE, "NTCAN_IO_INCOMPLETE"},
#endif
#ifdef NTCAN_IO_PENDING
      {NTCAN_IO_PENDING, "NTCAN_IO_PENDING"},
#endif
#ifdef NTCAN_INVALID_HARDWARE
      {NTCAN_INVALID_HARDWARE, "NTCAN_INVALID_HARDWARE"},
#endif
#ifdef NTCAN_PENDING_WRITE
      {NTCAN_PENDING_WRITE, "NTCAN_PENDING_WRITE"},
#endif
#ifdef NTCAN_PENDING_READ
      {NTCAN_PENDING_READ, "NTCAN_PENDING_READ"},
#endif
#ifdef NTCAN_INVALID_DRIVER
      {NTCAN_INVALID_DRIVER, "NTCAN_INVALID_DRIVER"},
#endif
#ifdef NTCAN_OPERATION_ABORTED
      {NTCAN_OPERATION_ABORTED, "NTCAN_OPERATION_ABORTED"},
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
      {NTCAN_WRONG_DEVICE_STATE, "NTCAN_WRONG_DEVICE_STATE"},
#endif
      {NTCAN_INSUFFICIENT_RESOURCES, "NTCAN_INSUFFICIENT_RESOURCES"},
#ifdef NTCAN_HANDLE_FORCED_CLOSE
      {NTCAN_HANDLE_FORCED_CLOSE, "NTCAN_HANDLE_FORCED_CLOSE"},
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
      {NTCAN_NOT_IMPLEMENTED, "NTCAN_NOT_IMPLEMENTED"},
#endif
#ifdef NTCAN_NOT_SUPPORTED
      {NTCAN_NOT_SUPPORTED, "NTCAN_NOT_SUPPORTED"},
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
      {NTCAN_SOCK_CONN_TIMEOUT, "NTCAN_SOCK_CONN_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
      {NTCAN_SOCK_CMD_TIMEOUT, "NTCAN_SOCK_CMD_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
      {NTCAN_SOCK_HOST_NOT_FOUND, "NTCAN_SOCK_HOST_NOT_FOUND"},
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
      {NTCAN_CONTR_ERR_PASSIVE, "NTCAN_CONTR_ERR_PASSIVE"},
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
      {NTCAN_ERROR_NO_BAUDRATE, "NTCAN_ERROR_NO_BAUDRATE"},
#endif
#ifdef NTCAN_ERROR_LOM
      {NTCAN_ERROR_LOM, "NTCAN_ERROR_LOM"},
#endif
      {(NTCAN_RESULT)0xffffffff, "NTCAN_UNKNOWN"} /* stop-mark */
  };

  const struct ERR2STR *es = err2str;

  do {
    if (es-&gt;ntstatus == ntstatus) {
      break;
    }
    es++;
  } while ((uint32_t)es-&gt;ntstatus != 0xffffffff);

#ifdef NTCAN_ERROR_FORMAT_LONG
  {
    NTCAN_RESULT res;
    char sz_error_text[60];

    res = canFormatError(ntstatus, NTCAN_ERROR_FORMAT_LONG, sz_error_text,
                         sizeof(sz_error_text) - 1);
    if (NTCAN_SUCCESS == res) {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s - %s",
               es-&gt;str, sz_error_text);
    } else {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
               es-&gt;str, ntstatus);
    }
  }
#else
  snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
           es-&gt;str, ntstatus);
#endif /* of NTCAN_ERROR_FORMAT_LONG */

  return std::string((const char *)(str_buf));
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(331, 0)" endLine="(354, 1)" clone_start="18" clone_end="24">
			<code function_name="Spline1dConstraint::AddSmoothConstraint()">bool Spline1dConstraint::AddSmoothConstraint() {
  if (x_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd equality_constraint = Eigen::MatrixXd::Zero(
      x_knots_.size() - 2, (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd equality_boundary =
      Eigen::MatrixXd::Zero(x_knots_.size() - 2, 1);

  for (std::uint32_t i = 0; i &lt; x_knots_.size() - 2; ++i) {
    double left_coef = 1.0;
    double right_coef = -1.0;
    const double x_left = x_knots_[i + 1] - x_knots_[i];
    const double x_right = 0.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      equality_constraint(i, spline_order_ * i + j) = left_coef;
      equality_constraint(i, spline_order_ * (i + 1) + j) = right_coef;
      left_coef *= x_left;
      right_coef *= x_right;
    }
  }
  return equality_constraint_.AddConstraint(equality_constraint,
                                            equality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(392, 0)" endLine="(439, 1)" clone_start="42" clone_end="48">
			<code function_name="Spline1dConstraint::AddSecondDerivativeSmoothConstraint()">bool Spline1dConstraint::AddSecondDerivativeSmoothConstraint() {
  if (x_knots_.size() &lt; 3) {
    return false;
  }

  const std::uint32_t n_constraint = (x_knots_.size() - 2) * 3;
  Eigen::MatrixXd equality_constraint = Eigen::MatrixXd::Zero(
      n_constraint, (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd equality_boundary = Eigen::MatrixXd::Zero(n_constraint, 1);

  for (std::uint32_t i = 0; i &lt; n_constraint; i += 3) {
    double left_coef = 1.0;
    double right_coef = -1.0;
    double left_dcoef = 1.0;
    double right_dcoef = -1.0;
    double left_ddcoef = 1.0;
    double right_ddcoef = -1.0;

    const double x_left = x_knots_[i / 3 + 1] - x_knots_[i / 3];
    const double x_right = 0.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      equality_constraint(i, spline_order_ * (i / 3) + j) = left_coef;
      equality_constraint(i, spline_order_ * (i / 3 + 1) + j) = right_coef;

      if (j &gt;= 2) {
        equality_constraint(i + 2, spline_order_ * i / 3 + j) =
            left_ddcoef * j * (j - 1);
        equality_constraint(i + 2, spline_order_ * (i / 3 + 1) + j) =
            right_ddcoef * j * (j - 1);
        left_ddcoef = left_dcoef;
        right_ddcoef = right_dcoef;
      }

      if (j &gt;= 1) {
        equality_constraint(i + 1, spline_order_ * (i / 3) + j) =
            left_dcoef * j;
        equality_constraint(i + 1, spline_order_ * (i / 3 + 1) + j) =
            right_dcoef * j;
        left_dcoef = left_coef;
        right_dcoef = right_coef;
      }
      left_coef *= x_left;
      right_coef *= x_right;
    }
  }
  return equality_constraint_.AddConstraint(equality_constraint,
                                            equality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(356, 0)" endLine="(390, 1)" clone_start="29" clone_end="35">
			<code function_name="Spline1dConstraint::AddDerivativeSmoothConstraint()">bool Spline1dConstraint::AddDerivativeSmoothConstraint() {
  if (x_knots_.size() &lt; 3) {
    return false;
  }

  const std::uint32_t n_constraint = (x_knots_.size() - 2) * 2;
  Eigen::MatrixXd equality_constraint = Eigen::MatrixXd::Zero(
      n_constraint, (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd equality_boundary = Eigen::MatrixXd::Zero(n_constraint, 1);

  for (std::uint32_t i = 0; i &lt; n_constraint; i += 2) {
    double left_coef = 1.0;
    double right_coef = -1.0;
    double left_dcoef = 1.0;
    double right_dcoef = -1.0;
    const double x_left = x_knots_[i / 2 + 1] - x_knots_[i / 2];
    const double x_right = 0.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      equality_constraint(i, spline_order_ * (i / 2) + j) = left_coef;
      equality_constraint(i, spline_order_ * ((i / 2) + 1) + j) = right_coef;
      if (j &gt;= 1) {
        equality_constraint(i + 1, spline_order_ * (i / 2) + j) =
            left_dcoef * j;
        equality_constraint(i + 1, spline_order_ * ((i / 2) + 1) + j) =
            right_dcoef * j;
        left_dcoef = left_coef;
        right_dcoef = right_coef;
      }
      left_coef *= x_left;
      right_coef *= x_right;
    }
  }
  return equality_constraint_.AddConstraint(equality_constraint,
                                            equality_boundary);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(356, 0)" endLine="(390, 1)" clone_start="1" clone_end="15">
			<code function_name="Spline1dConstraint::AddDerivativeSmoothConstraint()">bool Spline1dConstraint::AddDerivativeSmoothConstraint() {
  if (x_knots_.size() &lt; 3) {
    return false;
  }

  const std::uint32_t n_constraint = (x_knots_.size() - 2) * 2;
  Eigen::MatrixXd equality_constraint = Eigen::MatrixXd::Zero(
      n_constraint, (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd equality_boundary = Eigen::MatrixXd::Zero(n_constraint, 1);

  for (std::uint32_t i = 0; i &lt; n_constraint; i += 2) {
    double left_coef = 1.0;
    double right_coef = -1.0;
    double left_dcoef = 1.0;
    double right_dcoef = -1.0;
    const double x_left = x_knots_[i / 2 + 1] - x_knots_[i / 2];
    const double x_right = 0.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      equality_constraint(i, spline_order_ * (i / 2) + j) = left_coef;
      equality_constraint(i, spline_order_ * ((i / 2) + 1) + j) = right_coef;
      if (j &gt;= 1) {
        equality_constraint(i + 1, spline_order_ * (i / 2) + j) =
            left_dcoef * j;
        equality_constraint(i + 1, spline_order_ * ((i / 2) + 1) + j) =
            right_dcoef * j;
        left_dcoef = left_coef;
        right_dcoef = right_coef;
      }
      left_coef *= x_left;
      right_coef *= x_right;
    }
  }
  return equality_constraint_.AddConstraint(equality_constraint,
                                            equality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(441, 0)" endLine="(499, 1)" clone_start="1" clone_end="15">
			<code function_name="Spline1dConstraint::AddThirdDerivativeSmoothConstraint()">bool Spline1dConstraint::AddThirdDerivativeSmoothConstraint() {
  if (x_knots_.size() &lt; 3) {
    return false;
  }

  const std::uint32_t n_constraint = (x_knots_.size() - 2) * 4;
  Eigen::MatrixXd equality_constraint = Eigen::MatrixXd::Zero(
      n_constraint, (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd equality_boundary = Eigen::MatrixXd::Zero(n_constraint, 1);

  for (std::uint32_t i = 0; i &lt; n_constraint; i += 4) {
    double left_coef = 1.0;
    double right_coef = -1.0;
    double left_dcoef = 1.0;
    double right_dcoef = -1.0;
    double left_ddcoef = 1.0;
    double right_ddcoef = -1.0;
    double left_dddcoef = 1.0;
    double right_dddcoef = -1.0;

    const double x_left = x_knots_[i / 4 + 1] - x_knots_[i / 4];
    const double x_right = 0.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      equality_constraint(i, spline_order_ * i / 4 + j) = left_coef;
      equality_constraint(i, spline_order_ * (i / 4 + 1) + j) = right_coef;

      if (j &gt;= 3) {
        equality_constraint(i + 3, spline_order_ * i / 4 + j) =
            left_dddcoef * j * (j - 1) * (j - 2);
        equality_constraint(i + 3, spline_order_ * (i / 4 + 1) + j) =
            right_dddcoef * j * (j - 1) * (j - 2);
        left_dddcoef = left_ddcoef;
        right_dddcoef = right_ddcoef;
      }

      if (j &gt;= 2) {
        equality_constraint(i + 2, spline_order_ * i / 4 + j) =
            left_ddcoef * j * (j - 1);
        equality_constraint(i + 2, spline_order_ * (i / 4 + 1) + j) =
            right_ddcoef * j * (j - 1);
        left_ddcoef = left_dcoef;
        right_ddcoef = right_dcoef;
      }

      if (j &gt;= 1) {
        equality_constraint(i + 1, spline_order_ * i / 4 + j) = left_dcoef * j;
        equality_constraint(i + 1, spline_order_ * (i / 4 + 1) + j) =
            right_dcoef * j;
        left_dcoef = left_coef;
        right_dcoef = right_coef;
      }

      left_coef *= x_left;
      right_coef *= x_right;
    }
  }
  return equality_constraint_.AddConstraint(equality_constraint,
                                            equality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(392, 0)" endLine="(439, 1)" clone_start="1" clone_end="15">
			<code function_name="Spline1dConstraint::AddSecondDerivativeSmoothConstraint()">bool Spline1dConstraint::AddSecondDerivativeSmoothConstraint() {
  if (x_knots_.size() &lt; 3) {
    return false;
  }

  const std::uint32_t n_constraint = (x_knots_.size() - 2) * 3;
  Eigen::MatrixXd equality_constraint = Eigen::MatrixXd::Zero(
      n_constraint, (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd equality_boundary = Eigen::MatrixXd::Zero(n_constraint, 1);

  for (std::uint32_t i = 0; i &lt; n_constraint; i += 3) {
    double left_coef = 1.0;
    double right_coef = -1.0;
    double left_dcoef = 1.0;
    double right_dcoef = -1.0;
    double left_ddcoef = 1.0;
    double right_ddcoef = -1.0;

    const double x_left = x_knots_[i / 3 + 1] - x_knots_[i / 3];
    const double x_right = 0.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      equality_constraint(i, spline_order_ * (i / 3) + j) = left_coef;
      equality_constraint(i, spline_order_ * (i / 3 + 1) + j) = right_coef;

      if (j &gt;= 2) {
        equality_constraint(i + 2, spline_order_ * i / 3 + j) =
            left_ddcoef * j * (j - 1);
        equality_constraint(i + 2, spline_order_ * (i / 3 + 1) + j) =
            right_ddcoef * j * (j - 1);
        left_ddcoef = left_dcoef;
        right_ddcoef = right_dcoef;
      }

      if (j &gt;= 1) {
        equality_constraint(i + 1, spline_order_ * (i / 3) + j) =
            left_dcoef * j;
        equality_constraint(i + 1, spline_order_ * (i / 3 + 1) + j) =
            right_dcoef * j;
        left_dcoef = left_coef;
        right_dcoef = right_coef;
      }
      left_coef *= x_left;
      right_coef *= x_right;
    }
  }
  return equality_constraint_.AddConstraint(equality_constraint,
                                            equality_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(35, 0)" endLine="(43, 1)" clone_start="8" clone_end="9">
			<code function_name="Throttleinfo75::engine_rpm(const std::uint8_t *bytes, int32_t length) const">double Throttleinfo75::engine_rpm(const std::uint8_t *bytes,
                                  int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.25;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(89, 0)" endLine="(101, 1)" clone_start="12" clone_end="13">
			<code function_name="Steering65::reported_steering_angle_cmd(const std::uint8_t *bytes, int32_t length) const">double Steering65::reported_steering_angle_cmd(const std::uint8_t *bytes,
                                               int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x8000) {
    value = value - 0x10000;
  }

  return value * 0.100000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(45, 0)" endLine="(53, 1)" clone_start="1" clone_end="9">
			<code function_name="Throttleinfo75::acc_pedal_percent(const std::uint8_t *bytes, int32_t length) const">double Throttleinfo75::acc_pedal_percent(const std::uint8_t *bytes,
                                         int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 2);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.1;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(103, 0)" endLine="(111, 1)" clone_start="1" clone_end="9">
			<code function_name="Steering65::vehicle_speed(const std::uint8_t *bytes, int32_t length) const">double Steering65::vehicle_speed(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttleinfo_75.cc" startLine="(55, 0)" endLine="(63, 1)" clone_start="1" clone_end="8">
			<code function_name="Throttleinfo75::acc_pedal_rate(const std::uint8_t *bytes, int32_t length) const">double Throttleinfo75::acc_pedal_rate(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 8);
  if (x &gt; 0x3F) {
    x -= 0x100;
  }
  return x * 0.04;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(113, 0)" endLine="(121, 1)" clone_start="1" clone_end="8">
			<code function_name="Steering65::epas_torque(const std::uint8_t *bytes, int32_t length) const">double Steering65::epas_torque(const std::uint8_t *bytes,
                               int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 8);
  if (x &gt; 0x7F) {
    x -= 0x100;
  }
  return x * 0.062500;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(234, 2)" endLine="(236, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; signal_overlaps() const {
    return signal_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(231, 2)" endLine="(233, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; lane_overlaps() const {
    return lane_overlaps_;
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(237, 2)" endLine="(239, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; yield_sign_overlaps() const {
    return yield_sign_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(234, 2)" endLine="(236, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; signal_overlaps() const {
    return signal_overlaps_;
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(240, 2)" endLine="(242, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; stop_sign_overlaps() const {
    return stop_sign_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(237, 2)" endLine="(239, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; yield_sign_overlaps() const {
    return yield_sign_overlaps_;
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(243, 2)" endLine="(245, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; crosswalk_overlaps() const {
    return crosswalk_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(240, 2)" endLine="(242, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; stop_sign_overlaps() const {
    return stop_sign_overlaps_;
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(246, 2)" endLine="(248, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; parking_space_overlaps() const {
    return parking_space_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(243, 2)" endLine="(245, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; crosswalk_overlaps() const {
    return crosswalk_overlaps_;
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(249, 2)" endLine="(251, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; junction_overlaps() const {
    return junction_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(246, 2)" endLine="(248, 3)" clone_start="1" clone_end="3">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; parking_space_overlaps() const {
    return parking_space_overlaps_;
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(252, 2)" endLine="(254, 3)" clone_start="1" clone_end="2">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; speed_bump_overlaps() const {
    return speed_bump_overlaps_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.h" startLine="(249, 2)" endLine="(251, 3)" clone_start="1" clone_end="2">
			<code function_name="length() const">  const std::vector&lt;PathOverlap&gt;&amp; junction_overlaps() const {
    return junction_overlaps_;
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\rtk\rtk_localization.h" startLine="(56, 2)" endLine="(56, 39)" clone_start="1" clone_end="1">
			<code function_name="~RTKLocalization()">  virtual ~RTKLocalization() = default;</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\camera\camera_localization.h" startLine="(58, 2)" endLine="(58, 42)" clone_start="1" clone_end="1">
			<code function_name="~CameraLocalization()">  virtual ~CameraLocalization() = default;</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(38, 0)" endLine="(59, 1)" clone_start="5" clone_end="18">
			<code function_name="get_serial_baudrate(uint32_t rate)">speed_t get_serial_baudrate(uint32_t rate) {
  switch (rate) {
    case 9600:
      return B9600;
    case 19200:
      return B19200;
    case 38400:
      return B38400;
    case 57600:
      return B57600;
    case 115200:
      return B115200;
    case 230400:
      return B230400;
    case 460800:
      return B460800;
    case 921600:
      return B921600;
    default:
      return 0;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\serial_stream.cpp" startLine="(38, 0)" endLine="(59, 1)" clone_start="3" clone_end="16">
			<code function_name="get_serial_baudrate(uint32_t rate)">speed_t get_serial_baudrate(uint32_t rate) {
  switch (rate) {
    case 9600:
      return B9600;
    case 19200:
      return B19200;
    case 38400:
      return B38400;
    case 57600:
      return B57600;
    case 115200:
      return B115200;
    case 230400:
      return B230400;
    case 460800:
      return B460800;
    case 921600:
      return B921600;
    default:
      return 0;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="53" clone_end="70">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length,
                        ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="21" clone_end="36">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length,
                        ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\common\pid_IC_controller.cc" startLine="(27, 0)" endLine="(69, 1)" clone_start="1" clone_end="18">
			<code function_name="PIDICController::Control(const double error, const double dt)">double PIDICController::Control(const double error, const double dt) {
  if (dt &lt;= 0) {
    AWARN &lt;&lt; "dt &lt;= 0, will use the last output";
    return previous_output_;
  }
  double diff = 0;
  double output = 0;

  if (first_hit_) {
    first_hit_ = false;
  } else {
    diff = (error - previous_error_) / dt;
  }
  // integral clamping
  if (!integrator_enabled_) {
    integral_ = 0;
  } else {
    double u = error * kp_ + integral_ + error * dt * ki_ + diff * kd_;
    if (((error * u) &gt; 0) &amp;&amp;
        ((u &gt; output_saturation_high_) || (u &lt; output_saturation_low_))) {
    } else {
      // Only update integral then
      integral_ += error * dt * ki_;
    }
  }

  previous_error_ = error;
  output = error * kp_ + integral_ + diff * kd_;

  if (output &gt;= output_saturation_high_) {
    output_saturation_status_ = 1;
  } else if (output &lt;= output_saturation_low_) {
    output_saturation_status_ = -1;
  } else {
    output_saturation_status_ = 0;
  }

  output = common::math::Clamp(
      error * kp_ + integral_ + diff * kd_, output_saturation_high_,
      output_saturation_low_);  // Ki already applied
  previous_output_ = output;
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\control\common\pid_BC_controller.cc" startLine="(27, 0)" endLine="(65, 1)" clone_start="1" clone_end="19">
			<code function_name="PIDBCController::Control(const double error, const double dt)">double PIDBCController::Control(const double error, const double dt) {
  if (dt &lt;= 0) {
    AWARN &lt;&lt; "dt &lt;= 0, will use the last output";
    return previous_output_;
  }
  double diff = 0;
  double output = 0;

  if (first_hit_) {
    first_hit_ = false;
  } else {
    diff = (error - previous_error_) / dt;
  }

  // backward caculation
  if (!integrator_enabled_) {
    integral_ = 0;
  } else {
    double u = error * kp_ + integral_ + error * dt * ki_ + diff * kd_;
    double aw_term = common::math::Clamp(u, output_saturation_high_,
                                                   output_saturation_low_) -
                     u;
    if (aw_term &gt; 1e-6) {
      output_saturation_status_ = -1;
    } else if (aw_term &lt; -1e-6) {
      output_saturation_status_ = 1;
    } else {
      output_saturation_status_ = 0;
    }
    integral_ += kaw_ * aw_term + error * dt;
  }

  previous_error_ = error;
  output = common::math::Clamp(
      error * kp_ + integral_ + diff * kd_, output_saturation_high_,
      output_saturation_low_);  // Ki already applied
  previous_output_ = output;
  return output;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(116, 0)" endLine="(140, 1)" clone_start="8" clone_end="24">
			<code function_name="SignalsXmlParser::ToPbSignalType(const std::string&amp; xml_type, PbSignalType* signal_type)">Status SignalsXmlParser::ToPbSignalType(const std::string&amp; xml_type,
                                        PbSignalType* signal_type) {
  CHECK_NOTNULL(signal_type);

  std::string upper_str = UtilXmlParser::ToUpper(xml_type);

  if (upper_str == "UNKNOWN") {
    *signal_type = hdmap::Signal::UNKNOWN;
  } else if (upper_str == "MIX2HORIZONTAL") {
    *signal_type = hdmap::Signal::MIX_2_HORIZONTAL;
  } else if (upper_str == "MIX2VERTICAL") {
    *signal_type = hdmap::Signal::MIX_2_VERTICAL;
  } else if (upper_str == "MIX3HORIZONTAL") {
    *signal_type = hdmap::Signal::MIX_3_HORIZONTAL;
  } else if (upper_str == "MIX3VERTICAL") {
    *signal_type = hdmap::Signal::MIX_3_VERTICAL;
  } else if (upper_str == "SINGLE") {
    *signal_type = hdmap::Signal::SINGLE;
  } else {
    std::string err_msg = "Error or unsupport signal layout type";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(142, 0)" endLine="(169, 1)" clone_start="12" clone_end="27">
			<code function_name="SignalsXmlParser::ToPbSubSignalType(const std::string&amp; xml_type, PbSubSignalType* sub_signal_type)">Status SignalsXmlParser::ToPbSubSignalType(const std::string&amp; xml_type,
                                           PbSubSignalType* sub_signal_type) {
  CHECK_NOTNULL(sub_signal_type);

  std::string upper_str = UtilXmlParser::ToUpper(xml_type);

  if (upper_str == "UNKNOWN") {
    *sub_signal_type = hdmap::Subsignal::UNKNOWN;
  } else if (upper_str == "CIRCLE") {
    *sub_signal_type = hdmap::Subsignal::CIRCLE;
  } else if (upper_str == "ARROWLEFT") {
    *sub_signal_type = hdmap::Subsignal::ARROW_LEFT;
  } else if (upper_str == "ARROWFORWARD") {
    *sub_signal_type = hdmap::Subsignal::ARROW_FORWARD;
  } else if (upper_str == "ARROWRIGHT") {
    *sub_signal_type = hdmap::Subsignal::ARROW_RIGHT;
  } else if (upper_str == "ARROWLEFTANDFORWARD") {
    *sub_signal_type = hdmap::Subsignal::ARROW_LEFT_AND_FORWARD;
  } else if (upper_str == "ARROWRIGHTANDFORWARD") {
    *sub_signal_type = hdmap::Subsignal::ARROW_RIGHT_AND_FORWARD;
  } else if (upper_str == "ARROWUTURN") {
    *sub_signal_type = hdmap::Subsignal::ARROW_U_TURN;
  } else {
    std::string err_msg = "Error or unsupport sub signal type";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(217, 0)" endLine="(243, 1)" clone_start="26" clone_end="27">
			<code function_name="Obstacle::SetPosition(const PerceptionObstacle&amp; perception_obstacle, Feature* feature)">void Obstacle::SetPosition(const PerceptionObstacle&amp; perception_obstacle,
                           Feature* feature) {
  double x = 0.0;
  double y = 0.0;
  double z = 0.0;

  if (perception_obstacle.has_position()) {
    if (perception_obstacle.position().has_x()) {
      x = perception_obstacle.position().x();
    }
    if (perception_obstacle.position().has_y()) {
      y = perception_obstacle.position().y();
    }
    if (perception_obstacle.position().has_z()) {
      z = perception_obstacle.position().z();
    }
  }

  feature-&gt;mutable_position()-&gt;set_x(x);
  feature-&gt;mutable_position()-&gt;set_y(y);
  feature-&gt;mutable_position()-&gt;set_z(z);

  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has position [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; x &lt;&lt; ", " &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; y &lt;&lt; ", " &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; z &lt;&lt; "].";
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(204, 0)" endLine="(215, 1)" clone_start="11" clone_end="12">
			<code function_name="Obstacle::SetTimestamp(const PerceptionObstacle&amp; perception_obstacle, const double timestamp, Feature* feature)">void Obstacle::SetTimestamp(const PerceptionObstacle&amp; perception_obstacle,
                            const double timestamp, Feature* feature) {
  double ts = timestamp;
  if (perception_obstacle.has_timestamp() &amp;&amp;
      perception_obstacle.timestamp() &gt; 0.0) {
    ts = perception_obstacle.timestamp();
  }
  feature-&gt;set_timestamp(ts);

  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has timestamp [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; ts &lt;&lt; "].";
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(245, 0)" endLine="(280, 1)" clone_start="1" clone_end="21">
			<code function_name="Obstacle::SetVelocity(const PerceptionObstacle&amp; perception_obstacle, Feature* feature)">void Obstacle::SetVelocity(const PerceptionObstacle&amp; perception_obstacle,
                           Feature* feature) {
  double velocity_x = 0.0;
  double velocity_y = 0.0;
  double velocity_z = 0.0;

  if (perception_obstacle.has_velocity()) {
    if (perception_obstacle.velocity().has_x()) {
      velocity_x = perception_obstacle.velocity().x();
    }
    if (perception_obstacle.velocity().has_y()) {
      velocity_y = perception_obstacle.velocity().y();
    }
    if (perception_obstacle.velocity().has_z()) {
      velocity_z = perception_obstacle.velocity().z();
    }
  }

  feature-&gt;mutable_velocity()-&gt;set_x(velocity_x);
  feature-&gt;mutable_velocity()-&gt;set_y(velocity_y);
  feature-&gt;mutable_velocity()-&gt;set_z(velocity_z);

  double speed = std::hypot(std::hypot(velocity_x, velocity_y), velocity_z);
  double velocity_heading = std::atan2(velocity_y, velocity_x);
  feature-&gt;set_velocity_heading(velocity_heading);
  feature-&gt;set_speed(speed);

  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has velocity [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; velocity_x &lt;&lt; ", " &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; velocity_y &lt;&lt; ", " &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; velocity_z &lt;&lt; "]";
  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has velocity heading [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; velocity_heading &lt;&lt; "] ";
  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has speed [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; speed &lt;&lt; "].";
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(217, 0)" endLine="(243, 1)" clone_start="1" clone_end="21">
			<code function_name="Obstacle::SetPosition(const PerceptionObstacle&amp; perception_obstacle, Feature* feature)">void Obstacle::SetPosition(const PerceptionObstacle&amp; perception_obstacle,
                           Feature* feature) {
  double x = 0.0;
  double y = 0.0;
  double z = 0.0;

  if (perception_obstacle.has_position()) {
    if (perception_obstacle.position().has_x()) {
      x = perception_obstacle.position().x();
    }
    if (perception_obstacle.position().has_y()) {
      y = perception_obstacle.position().y();
    }
    if (perception_obstacle.position().has_z()) {
      z = perception_obstacle.position().z();
    }
  }

  feature-&gt;mutable_position()-&gt;set_x(x);
  feature-&gt;mutable_position()-&gt;set_y(y);
  feature-&gt;mutable_position()-&gt;set_z(z);

  ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id_ &lt;&lt; "] has position [" &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; x &lt;&lt; ", " &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; y &lt;&lt; ", " &lt;&lt; std::fixed
         &lt;&lt; std::setprecision(6) &lt;&lt; z &lt;&lt; "].";
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(312, 0)" endLine="(339, 1)" clone_start="25" clone_end="28">
			<code function_name="Spline2dConstraint::AddDerivativeSmoothConstraint()">bool Spline2dConstraint::AddDerivativeSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(4 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(4 * (t_knots_.size() - 2), 1);

  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);
    std::vector&lt;double&gt; derivative_t = DerivativeCoef(rel_t);
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(4 * i, j + index_offset) = power_t[j];
      affine_equality(4 * i + 1, j + index_offset) = derivative_t[j];
      affine_equality(4 * i + 2, j + index_offset + spline_order_) = power_t[j];
      affine_equality(4 * i + 3, j + index_offset + spline_order_) =
          derivative_t[j];
    }
    affine_equality(4 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(4 * i + 1, index_offset + 2 * spline_order_ + 1) = -1.0;
    affine_equality(4 * i + 2, index_offset + 3 * spline_order_) = -1.0;
    affine_equality(4 * i + 3, index_offset + 3 * spline_order_ + 1) = -1.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(342, 0)" endLine="(375, 1)" clone_start="31" clone_end="34">
			<code function_name="Spline2dConstraint::AddSecondDerivativeSmoothConstraint()">bool Spline2dConstraint::AddSecondDerivativeSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(6 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(6 * (t_knots_.size() - 2), 1);

  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);
    std::vector&lt;double&gt; derivative_t = DerivativeCoef(rel_t);
    std::vector&lt;double&gt; second_derivative_t = SecondDerivativeCoef(rel_t);
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(6 * i, j + index_offset) = power_t[j];
      affine_equality(6 * i + 1, j + index_offset) = derivative_t[j];
      affine_equality(6 * i + 2, j + index_offset) = second_derivative_t[j];
      affine_equality(6 * i + 3, j + index_offset + spline_order_) = power_t[j];
      affine_equality(6 * i + 4, j + index_offset + spline_order_) =
          derivative_t[j];
      affine_equality(6 * i + 5, j + index_offset + spline_order_) =
          second_derivative_t[j];
    }
    affine_equality(6 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(6 * i + 1, index_offset + 2 * spline_order_ + 1) = -1.0;
    affine_equality(6 * i + 2, index_offset + 2 * spline_order_ + 2) = -2.0;
    affine_equality(6 * i + 3, index_offset + 3 * spline_order_) = -1.0;
    affine_equality(6 * i + 4, index_offset + 3 * spline_order_ + 1) = -1.0;
    affine_equality(6 * i + 5, index_offset + 3 * spline_order_ + 2) = -2.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(342, 0)" endLine="(375, 1)" clone_start="1" clone_end="15">
			<code function_name="Spline2dConstraint::AddSecondDerivativeSmoothConstraint()">bool Spline2dConstraint::AddSecondDerivativeSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(6 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(6 * (t_knots_.size() - 2), 1);

  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);
    std::vector&lt;double&gt; derivative_t = DerivativeCoef(rel_t);
    std::vector&lt;double&gt; second_derivative_t = SecondDerivativeCoef(rel_t);
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(6 * i, j + index_offset) = power_t[j];
      affine_equality(6 * i + 1, j + index_offset) = derivative_t[j];
      affine_equality(6 * i + 2, j + index_offset) = second_derivative_t[j];
      affine_equality(6 * i + 3, j + index_offset + spline_order_) = power_t[j];
      affine_equality(6 * i + 4, j + index_offset + spline_order_) =
          derivative_t[j];
      affine_equality(6 * i + 5, j + index_offset + spline_order_) =
          second_derivative_t[j];
    }
    affine_equality(6 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(6 * i + 1, index_offset + 2 * spline_order_ + 1) = -1.0;
    affine_equality(6 * i + 2, index_offset + 2 * spline_order_ + 2) = -2.0;
    affine_equality(6 * i + 3, index_offset + 3 * spline_order_) = -1.0;
    affine_equality(6 * i + 4, index_offset + 3 * spline_order_ + 1) = -1.0;
    affine_equality(6 * i + 5, index_offset + 3 * spline_order_ + 2) = -2.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(378, 0)" endLine="(417, 1)" clone_start="1" clone_end="15">
			<code function_name="Spline2dConstraint::AddThirdDerivativeSmoothConstraint()">bool Spline2dConstraint::AddThirdDerivativeSmoothConstraint() {
  if (t_knots_.size() &lt; 3) {
    return false;
  }
  Eigen::MatrixXd affine_equality =
      Eigen::MatrixXd::Zero(8 * (t_knots_.size() - 2), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(8 * (t_knots_.size() - 2), 1);

  for (std::uint32_t i = 0; i + 2 &lt; t_knots_.size(); ++i) {
    const double rel_t = t_knots_[i + 1] - t_knots_[i];
    const std::uint32_t index_offset = 2 * i * spline_order_;
    std::vector&lt;double&gt; power_t = PolyCoef(rel_t);
    std::vector&lt;double&gt; derivative_t = DerivativeCoef(rel_t);
    std::vector&lt;double&gt; second_derivative_t = SecondDerivativeCoef(rel_t);
    std::vector&lt;double&gt; third_derivative_t = ThirdDerivativeCoef(rel_t);
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      affine_equality(8 * i, j + index_offset) = power_t[j];
      affine_equality(8 * i + 1, j + index_offset) = derivative_t[j];
      affine_equality(8 * i + 2, j + index_offset) = second_derivative_t[j];
      affine_equality(8 * i + 3, j + index_offset) = third_derivative_t[j];
      affine_equality(8 * i + 4, j + index_offset + spline_order_) = power_t[j];
      affine_equality(8 * i + 5, j + index_offset + spline_order_) =
          derivative_t[j];
      affine_equality(8 * i + 6, j + index_offset + spline_order_) =
          second_derivative_t[j];
      affine_equality(8 * i + 7, j + index_offset + spline_order_) =
          third_derivative_t[j];
    }
    affine_equality(8 * i, index_offset + 2 * spline_order_) = -1.0;
    affine_equality(8 * i + 1, index_offset + 2 * spline_order_ + 1) = -1.0;
    affine_equality(8 * i + 2, index_offset + 2 * spline_order_ + 2) = -2.0;
    affine_equality(8 * i + 3, index_offset + 2 * spline_order_ + 3) = -6.0;
    affine_equality(8 * i + 4, index_offset + 3 * spline_order_) = -1.0;
    affine_equality(8 * i + 5, index_offset + 3 * spline_order_ + 1) = -1.0;
    affine_equality(8 * i + 6, index_offset + 3 * spline_order_ + 2) = -2.0;
    affine_equality(8 * i + 7, index_offset + 3 * spline_order_ + 3) = -6.0;
  }
  return AddEqualityConstraint(affine_equality, affine_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(27, 0)" endLine="(30, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake60::GetPeriod() const">uint32_t Brake60::GetPeriod() const {
  static const uint32_t PERIOD = 20 * 1000;
  return PERIOD;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(28, 0)" endLine="(31, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle62::GetPeriod() const">uint32_t Throttle62::GetPeriod() const {
  static const uint32_t PERIOD = 20 * 1000;
  return PERIOD;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(32, 0)" endLine="(38, 1)" clone_start="1" clone_end="7">
			<code function_name="Brake60::UpdateData(uint8_t *data)">void Brake60::UpdateData(uint8_t *data) {
  set_pedal_p(data, pedal_cmd_);
  set_boo_cmd_p(data, boo_cmd_);
  set_enable_p(data, pedal_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_watchdog_counter_p(data, watchdog_counter_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(33, 0)" endLine="(39, 1)" clone_start="1" clone_end="7">
			<code function_name="Throttle62::UpdateData(uint8_t *data)">void Throttle62::UpdateData(uint8_t *data) {
  set_pedal_p(data, pedal_cmd_);
  set_enable_p(data, pedal_enable_);
  set_clear_driver_override_flag_p(data, clear_driver_override_flag_);
  set_ignore_driver_override_p(data, ignore_driver_override_);
  set_watchdog_counter_p(data, watchdog_counter_);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(40, 0)" endLine="(47, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake60::Reset()">void Brake60::Reset() {
  pedal_cmd_ = 0.0;
  boo_cmd_ = false;
  pedal_enable_ = false;
  clear_driver_override_flag_ = false;
  ignore_driver_override_ = false;
  watchdog_counter_ = 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(41, 0)" endLine="(47, 1)" clone_start="1" clone_end="5">
			<code function_name="Throttle62::Reset()">void Throttle62::Reset() {
  pedal_cmd_ = 0.0;
  pedal_enable_ = false;
  clear_driver_override_flag_ = false;
  ignore_driver_override_ = false;
  watchdog_counter_ = 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\rtk\rtk_localization.cc" startLine="(256, 0)" endLine="(363, 1)" clone_start="48" clone_end="77">
			<code function_name="RTKLocalization::ComposeLocalizationMsg(const localization::Gps &amp;gps_msg, const localization::Imu &amp;imu_msg, LocalizationEstimate *localization)">void RTKLocalization::ComposeLocalizationMsg(
    const localization::Gps &amp;gps_msg, const localization::Imu &amp;imu_msg,
    LocalizationEstimate *localization) {
  localization-&gt;Clear();

  // header
  AdapterManager::FillLocalizationHeader(FLAGS_localization_module_name,
                                         localization);
  if (FLAGS_enable_gps_timestamp) {
    // copy time stamp, do NOT use Clock::Now()
    localization-&gt;mutable_header()-&gt;set_timestamp_sec(
        gps_msg.header().timestamp_sec());
  }

  // combine gps and imu
  auto mutable_pose = localization-&gt;mutable_pose();
  if (gps_msg.has_localization()) {
    const auto &amp;pose = gps_msg.localization();

    if (pose.has_position()) {
      // position
      // world frame -&gt; map frame
      mutable_pose-&gt;mutable_position()-&gt;set_x(pose.position().x() -
                                              map_offset_[0]);
      mutable_pose-&gt;mutable_position()-&gt;set_y(pose.position().y() -
                                              map_offset_[1]);
      mutable_pose-&gt;mutable_position()-&gt;set_z(pose.position().z() -
                                              map_offset_[2]);
    }

    // orientation
    if (pose.has_orientation()) {
      mutable_pose-&gt;mutable_orientation()-&gt;CopyFrom(pose.orientation());
      double heading = common::math::QuaternionToHeading(
          pose.orientation().qw(), pose.orientation().qx(),
          pose.orientation().qy(), pose.orientation().qz());
      mutable_pose-&gt;set_heading(heading);
    }
    // linear velocity
    if (pose.has_linear_velocity()) {
      mutable_pose-&gt;mutable_linear_velocity()-&gt;CopyFrom(pose.linear_velocity());
    }
  }

  if (imu_msg.has_imu()) {
    const auto &amp;imu = imu_msg.imu();
    // linear acceleration
    if (imu.has_linear_acceleration()) {
      if (FLAGS_enable_map_reference_unify) {
        if (localization-&gt;pose().has_orientation()) {
          // linear_acceleration:
          // convert from vehicle reference to map reference
          Vector3d orig(imu.linear_acceleration().x(),
                        imu.linear_acceleration().y(),
                        imu.linear_acceleration().z());
          Vector3d vec = common::math::QuaternionRotate(
              localization-&gt;pose().orientation(), orig);
          mutable_pose-&gt;mutable_linear_acceleration()-&gt;set_x(vec[0]);
          mutable_pose-&gt;mutable_linear_acceleration()-&gt;set_y(vec[1]);
          mutable_pose-&gt;mutable_linear_acceleration()-&gt;set_z(vec[2]);

          // linear_acceleration_vfr
          mutable_pose-&gt;mutable_linear_acceleration_vrf()-&gt;CopyFrom(
              imu.linear_acceleration());

        } else {
          AERROR &lt;&lt; "[PrepareLocalizationMsg]: "
                 &lt;&lt; "fail to convert linear_acceleration";
        }
      } else {
        mutable_pose-&gt;mutable_linear_acceleration()-&gt;CopyFrom(
            imu.linear_acceleration());
      }
    }

    // angular velocity
    if (imu.has_angular_velocity()) {
      if (FLAGS_enable_map_reference_unify) {
        if (localization-&gt;pose().has_orientation()) {
          // angular_velocity:
          // convert from vehicle reference to map reference
          Vector3d orig(imu.angular_velocity().x(), imu.angular_velocity().y(),
                        imu.angular_velocity().z());
          Vector3d vec = common::math::QuaternionRotate(
              localization-&gt;pose().orientation(), orig);
          mutable_pose-&gt;mutable_angular_velocity()-&gt;set_x(vec[0]);
          mutable_pose-&gt;mutable_angular_velocity()-&gt;set_y(vec[1]);
          mutable_pose-&gt;mutable_angular_velocity()-&gt;set_z(vec[2]);

          // angular_velocity_vf
          mutable_pose-&gt;mutable_angular_velocity_vrf()-&gt;CopyFrom(
              imu.angular_velocity());
        } else {
          AERROR &lt;&lt; "[PrepareLocalizationMsg]: "
                 &lt;&lt; "fail to convert angular_velocity";
        }
      } else {
        mutable_pose-&gt;mutable_angular_velocity()-&gt;CopyFrom(
            imu.angular_velocity());
      }
    }

    // euler angle
    if (imu.has_euler_angles()) {
      mutable_pose-&gt;mutable_euler_angles()-&gt;CopyFrom(imu.euler_angles());
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\rtk\rtk_localization.cc" startLine="(256, 0)" endLine="(363, 1)" clone_start="77" clone_end="104">
			<code function_name="RTKLocalization::ComposeLocalizationMsg(const localization::Gps &amp;gps_msg, const localization::Imu &amp;imu_msg, LocalizationEstimate *localization)">void RTKLocalization::ComposeLocalizationMsg(
    const localization::Gps &amp;gps_msg, const localization::Imu &amp;imu_msg,
    LocalizationEstimate *localization) {
  localization-&gt;Clear();

  // header
  AdapterManager::FillLocalizationHeader(FLAGS_localization_module_name,
                                         localization);
  if (FLAGS_enable_gps_timestamp) {
    // copy time stamp, do NOT use Clock::Now()
    localization-&gt;mutable_header()-&gt;set_timestamp_sec(
        gps_msg.header().timestamp_sec());
  }

  // combine gps and imu
  auto mutable_pose = localization-&gt;mutable_pose();
  if (gps_msg.has_localization()) {
    const auto &amp;pose = gps_msg.localization();

    if (pose.has_position()) {
      // position
      // world frame -&gt; map frame
      mutable_pose-&gt;mutable_position()-&gt;set_x(pose.position().x() -
                                              map_offset_[0]);
      mutable_pose-&gt;mutable_position()-&gt;set_y(pose.position().y() -
                                              map_offset_[1]);
      mutable_pose-&gt;mutable_position()-&gt;set_z(pose.position().z() -
                                              map_offset_[2]);
    }

    // orientation
    if (pose.has_orientation()) {
      mutable_pose-&gt;mutable_orientation()-&gt;CopyFrom(pose.orientation());
      double heading = common::math::QuaternionToHeading(
          pose.orientation().qw(), pose.orientation().qx(),
          pose.orientation().qy(), pose.orientation().qz());
      mutable_pose-&gt;set_heading(heading);
    }
    // linear velocity
    if (pose.has_linear_velocity()) {
      mutable_pose-&gt;mutable_linear_velocity()-&gt;CopyFrom(pose.linear_velocity());
    }
  }

  if (imu_msg.has_imu()) {
    const auto &amp;imu = imu_msg.imu();
    // linear acceleration
    if (imu.has_linear_acceleration()) {
      if (FLAGS_enable_map_reference_unify) {
        if (localization-&gt;pose().has_orientation()) {
          // linear_acceleration:
          // convert from vehicle reference to map reference
          Vector3d orig(imu.linear_acceleration().x(),
                        imu.linear_acceleration().y(),
                        imu.linear_acceleration().z());
          Vector3d vec = common::math::QuaternionRotate(
              localization-&gt;pose().orientation(), orig);
          mutable_pose-&gt;mutable_linear_acceleration()-&gt;set_x(vec[0]);
          mutable_pose-&gt;mutable_linear_acceleration()-&gt;set_y(vec[1]);
          mutable_pose-&gt;mutable_linear_acceleration()-&gt;set_z(vec[2]);

          // linear_acceleration_vfr
          mutable_pose-&gt;mutable_linear_acceleration_vrf()-&gt;CopyFrom(
              imu.linear_acceleration());

        } else {
          AERROR &lt;&lt; "[PrepareLocalizationMsg]: "
                 &lt;&lt; "fail to convert linear_acceleration";
        }
      } else {
        mutable_pose-&gt;mutable_linear_acceleration()-&gt;CopyFrom(
            imu.linear_acceleration());
      }
    }

    // angular velocity
    if (imu.has_angular_velocity()) {
      if (FLAGS_enable_map_reference_unify) {
        if (localization-&gt;pose().has_orientation()) {
          // angular_velocity:
          // convert from vehicle reference to map reference
          Vector3d orig(imu.angular_velocity().x(), imu.angular_velocity().y(),
                        imu.angular_velocity().z());
          Vector3d vec = common::math::QuaternionRotate(
              localization-&gt;pose().orientation(), orig);
          mutable_pose-&gt;mutable_angular_velocity()-&gt;set_x(vec[0]);
          mutable_pose-&gt;mutable_angular_velocity()-&gt;set_y(vec[1]);
          mutable_pose-&gt;mutable_angular_velocity()-&gt;set_z(vec[2]);

          // angular_velocity_vf
          mutable_pose-&gt;mutable_angular_velocity_vrf()-&gt;CopyFrom(
              imu.angular_velocity());
        } else {
          AERROR &lt;&lt; "[PrepareLocalizationMsg]: "
                 &lt;&lt; "fail to convert angular_velocity";
        }
      } else {
        mutable_pose-&gt;mutable_angular_velocity()-&gt;CopyFrom(
            imu.angular_velocity());
      }
    }

    // euler angle
    if (imu.has_euler_angles()) {
      mutable_pose-&gt;mutable_euler_angles()-&gt;CopyFrom(imu.euler_angles());
    }
  }
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(115, 0)" endLine="(121, 1)" clone_start="6" clone_end="7">
			<code function_name="Brake61::watchdog_counter_source(const std::uint8_t *bytes, int32_t length) const">int32_t Brake61::watchdog_counter_source(const std::uint8_t *bytes,
                                         int32_t length) const {
  // see table for status code
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(79, 0)" endLine="(90, 1)" clone_start="11" clone_end="12">
			<code function_name="Brake61::parse_two_frames(const std::uint8_t low_byte, const std::uint8_t high_byte) const">double Brake61::parse_two_frames(const std::uint8_t low_byte,
                                 const std::uint8_t high_byte) const {
  Byte frame_high(&amp;high_byte);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(&amp;low_byte);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(93, 0)" endLine="(98, 1)" clone_start="5" clone_end="6">
			<code function_name="Throttle63::watchdog_counter_source(const std::uint8_t *bytes, int32_t length) const">int32_t Throttle63::watchdog_counter_source(const std::uint8_t *bytes,
                                            int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(242, 0)" endLine="(247, 1)" clone_start="5" clone_end="6">
			<code function_name="Misc69::ambient_light_status(const std::uint8_t *bytes, int32_t length) const">int32_t Misc69::ambient_light_status(const std::uint8_t *bytes,
                                     int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(123, 0)" endLine="(126, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake61::is_enabled(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_enabled(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(92, 0)" endLine="(96, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::boo_input(const std::uint8_t *bytes, int32_t length) const">bool Brake61::boo_input(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 6);
  // seems typo here
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(100, 0)" endLine="(103, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle63::is_enabled(const std::uint8_t *bytes, int32_t length) const">bool Throttle63::is_enabled(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(249, 0)" endLine="(253, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_on_pressed(const std::uint8_t *bytes,
                               int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(128, 0)" endLine="(132, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_driver_override(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_driver_override(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(98, 0)" endLine="(101, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake61::boo_cmd(const std::uint8_t *bytes, int32_t length) const">bool Brake61::boo_cmd(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 6);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(105, 0)" endLine="(109, 1)" clone_start="1" clone_end="5">
			<code function_name="Throttle63::is_driver_override(const std::uint8_t *bytes, int32_t length) const">bool Throttle63::is_driver_override(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(255, 0)" endLine="(259, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_off_pressed(const std::uint8_t *bytes,
                                int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(4);
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(134, 0)" endLine="(138, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_driver_activity(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_driver_activity(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(103, 0)" endLine="(107, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::boo_output(const std::uint8_t *bytes, int32_t length) const">bool Brake61::boo_output(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 6);
  // seems typo here
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(111, 0)" endLine="(115, 1)" clone_start="1" clone_end="5">
			<code function_name="Throttle63::is_driver_activity(const std::uint8_t *bytes, int32_t length) const">bool Throttle63::is_driver_activity(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(261, 0)" endLine="(265, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_resume_pressed(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(5);
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(140, 0)" endLine="(144, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_watchdog_counter_fault(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_watchdog_counter_fault(const std::uint8_t *bytes,
                                        int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(109, 0)" endLine="(113, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_watchdog_counter_applying_brakes(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_watchdog_counter_applying_brakes(const std::uint8_t *bytes,
                                                  int32_t length) const {
  Byte frame(bytes + 6);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(117, 0)" endLine="(121, 1)" clone_start="1" clone_end="5">
			<code function_name="Throttle63::is_watchdog_counter_fault(const std::uint8_t *bytes, int32_t length) const">bool Throttle63::is_watchdog_counter_fault(const std::uint8_t *bytes,
                                           int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(267, 0)" endLine="(271, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_cancel_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_cancel_pressed(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(6);
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(146, 0)" endLine="(150, 1)" clone_start="1" clone_end="3">
			<code function_name="Brake61::is_channel_1_fault(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_channel_1_fault(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(115, 0)" endLine="(121, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake61::watchdog_counter_source(const std::uint8_t *bytes, int32_t length) const">int32_t Brake61::watchdog_counter_source(const std::uint8_t *bytes,
                                         int32_t length) const {
  // see table for status code
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(123, 0)" endLine="(127, 1)" clone_start="1" clone_end="3">
			<code function_name="Throttle63::is_channel_1_fault(const std::uint8_t *bytes, int32_t length) const">bool Throttle63::is_channel_1_fault(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(273, 0)" endLine="(277, 1)" clone_start="1" clone_end="3">
			<code function_name="Misc69::is_acc_on_or_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_on_or_off_pressed(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(0);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\tools\teleop.cc" startLine="(111, 2)" endLine="(253, 3)" clone_start="34" clone_end="50">
			<code function_name="KeyboardLoopThreadFunc()">  void KeyboardLoopThreadFunc() {
    char c = 0;
    int32_t level = 0;
    double brake = 0;
    double throttle = 0;
    double steering = 0;
    struct termios cooked_;
    struct termios raw_;
    int32_t kfd_ = 0;
    bool parking_brake = false;
    Chassis::GearPosition gear = Chassis::GEAR_INVALID;
    PadMessage pad_msg;
    ControlCommand &amp;control_command_ = control_command();

    // get the console in raw mode
    tcgetattr(kfd_, &amp;cooked_);
    std::memcpy(&amp;raw_, &amp;cooked_, sizeof(struct termios));
    raw_.c_lflag &amp;= ~(ICANON | ECHO);
    // Setting a new line, then end of file
    raw_.c_cc[VEOL] = 1;
    raw_.c_cc[VEOF] = 2;
    tcsetattr(kfd_, TCSANOW, &amp;raw_);
    puts("Teleop:\nReading from keyboard now.");
    puts("---------------------------");
    puts("Use arrow keys to drive the car.");
    while (IsRunning()) {
      // get the next event from the keyboard
      if (read(kfd_, &amp;c, 1) &lt; 0) {
        perror("read():");
        exit(-1);
      }

      switch (c) {
        case KEYCODE_UP1:  // accelerate
        case KEYCODE_UP2:
          brake = control_command_.brake();
          throttle = control_command_.throttle();
          if (brake &gt; 1e-6) {
            brake = GetCommand(brake, -FLAGS_brake_inc_delta);
            control_command_.set_brake(brake);
          } else {
            throttle = GetCommand(throttle, FLAGS_throttle_inc_delta);
            control_command_.set_throttle(throttle);
          }
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_DN1:  // decelerate
        case KEYCODE_DN2:
          brake = control_command_.brake();
          throttle = control_command_.throttle();
          if (throttle &gt; 1e-6) {
            throttle = GetCommand(throttle, -FLAGS_throttle_inc_delta);
            control_command_.set_throttle(throttle);
          } else {
            brake = GetCommand(brake, FLAGS_brake_inc_delta);
            control_command_.set_brake(brake);
          }
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_LF1:  // left
        case KEYCODE_LF2:
          steering = control_command_.steering_target();
          steering = GetCommand(steering, FLAGS_steer_inc_delta);
          control_command_.set_steering_target(steering);
          printf("Steering Target = %.2f\n", steering);
          break;
        case KEYCODE_RT1:  // right
        case KEYCODE_RT2:
          steering = control_command_.steering_target();
          steering = GetCommand(steering, -FLAGS_steer_inc_delta);
          control_command_.set_steering_target(steering);
          printf("Steering Target = %.2f\n", steering);
          break;
        case KEYCODE_PKBK:  // hand brake
          parking_brake = !control_command_.parking_brake();
          control_command_.set_parking_brake(parking_brake);
          printf("Parking Brake Toggled:%d\n", parking_brake);
          break;
        case KEYCODE_ESTOP:
          control_command_.set_brake(50.0);
          printf("Estop Brake:%.2f\n", control_command_.brake());
          break;
        case KEYCODE_SETT1:  // set throttle
        case KEYCODE_SETT2:
          // read keyboard again
          if (read(kfd_, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          control_command_.set_throttle(level * 10.0);
          control_command_.set_brake(0.0);
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_SETG1:
        case KEYCODE_SETG2:
          // read keyboard again
          if (read(kfd_, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          gear = GetGear(level);
          control_command_.set_gear_location(gear);
          printf("Gear set to %d.\n", level);
          break;
        case KEYCODE_SETB1:
        case KEYCODE_SETB2:
          // read keyboard again
          if (read(kfd_, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          control_command_.set_throttle(0.0);
          control_command_.set_brake(level * 10.0);
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_MODE:
          // read keyboard again
          if (read(kfd_, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          GetPadMessage(&amp;pad_msg, level);
          control_command_.mutable_pad_msg()-&gt;CopyFrom(pad_msg);
          sleep(1);
          control_command_.mutable_pad_msg()-&gt;Clear();
          break;
        case KEYCODE_HELP:
        case KEYCODE_HELP2:
          PrintKeycode();
          break;
        default:
          // printf("%X\n", c);
          break;
      }
    }  // keyboard_loop big while
    tcsetattr(kfd_, TCSANOW, &amp;cooked_);
    printf("keyboard_loop thread quited.\n");
    return;
  }  // end of keyboard loop thread</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\tools\teleop.cc" startLine="(111, 2)" endLine="(253, 3)" clone_start="48" clone_end="64">
			<code function_name="KeyboardLoopThreadFunc()">  void KeyboardLoopThreadFunc() {
    char c = 0;
    int32_t level = 0;
    double brake = 0;
    double throttle = 0;
    double steering = 0;
    struct termios cooked_;
    struct termios raw_;
    int32_t kfd_ = 0;
    bool parking_brake = false;
    Chassis::GearPosition gear = Chassis::GEAR_INVALID;
    PadMessage pad_msg;
    ControlCommand &amp;control_command_ = control_command();

    // get the console in raw mode
    tcgetattr(kfd_, &amp;cooked_);
    std::memcpy(&amp;raw_, &amp;cooked_, sizeof(struct termios));
    raw_.c_lflag &amp;= ~(ICANON | ECHO);
    // Setting a new line, then end of file
    raw_.c_cc[VEOL] = 1;
    raw_.c_cc[VEOF] = 2;
    tcsetattr(kfd_, TCSANOW, &amp;raw_);
    puts("Teleop:\nReading from keyboard now.");
    puts("---------------------------");
    puts("Use arrow keys to drive the car.");
    while (IsRunning()) {
      // get the next event from the keyboard
      if (read(kfd_, &amp;c, 1) &lt; 0) {
        perror("read():");
        exit(-1);
      }

      switch (c) {
        case KEYCODE_UP1:  // accelerate
        case KEYCODE_UP2:
          brake = control_command_.brake();
          throttle = control_command_.throttle();
          if (brake &gt; 1e-6) {
            brake = GetCommand(brake, -FLAGS_brake_inc_delta);
            control_command_.set_brake(brake);
          } else {
            throttle = GetCommand(throttle, FLAGS_throttle_inc_delta);
            control_command_.set_throttle(throttle);
          }
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_DN1:  // decelerate
        case KEYCODE_DN2:
          brake = control_command_.brake();
          throttle = control_command_.throttle();
          if (throttle &gt; 1e-6) {
            throttle = GetCommand(throttle, -FLAGS_throttle_inc_delta);
            control_command_.set_throttle(throttle);
          } else {
            brake = GetCommand(brake, FLAGS_brake_inc_delta);
            control_command_.set_brake(brake);
          }
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_LF1:  // left
        case KEYCODE_LF2:
          steering = control_command_.steering_target();
          steering = GetCommand(steering, FLAGS_steer_inc_delta);
          control_command_.set_steering_target(steering);
          printf("Steering Target = %.2f\n", steering);
          break;
        case KEYCODE_RT1:  // right
        case KEYCODE_RT2:
          steering = control_command_.steering_target();
          steering = GetCommand(steering, -FLAGS_steer_inc_delta);
          control_command_.set_steering_target(steering);
          printf("Steering Target = %.2f\n", steering);
          break;
        case KEYCODE_PKBK:  // hand brake
          parking_brake = !control_command_.parking_brake();
          control_command_.set_parking_brake(parking_brake);
          printf("Parking Brake Toggled:%d\n", parking_brake);
          break;
        case KEYCODE_ESTOP:
          control_command_.set_brake(50.0);
          printf("Estop Brake:%.2f\n", control_command_.brake());
          break;
        case KEYCODE_SETT1:  // set throttle
        case KEYCODE_SETT2:
          // read keyboard again
          if (read(kfd_, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          control_command_.set_throttle(level * 10.0);
          control_command_.set_brake(0.0);
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_SETG1:
        case KEYCODE_SETG2:
          // read keyboard again
          if (read(kfd_, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          gear = GetGear(level);
          control_command_.set_gear_location(gear);
          printf("Gear set to %d.\n", level);
          break;
        case KEYCODE_SETB1:
        case KEYCODE_SETB2:
          // read keyboard again
          if (read(kfd_, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          control_command_.set_throttle(0.0);
          control_command_.set_brake(level * 10.0);
          printf("Throttle = %.2f, Brake = %.2f\n", control_command_.throttle(),
                 control_command_.brake());
          break;
        case KEYCODE_MODE:
          // read keyboard again
          if (read(kfd_, &amp;c, 1) &lt; 0) {
            exit(-1);
          }
          level = c - KEYCODE_ZERO;
          GetPadMessage(&amp;pad_msg, level);
          control_command_.mutable_pad_msg()-&gt;CopyFrom(pad_msg);
          sleep(1);
          control_command_.mutable_pad_msg()-&gt;Clear();
          break;
        case KEYCODE_HELP:
        case KEYCODE_HELP2:
          PrintKeycode();
          break;
        default:
          // printf("%X\n", c);
          break;
      }
    }  // keyboard_loop big while
    tcsetattr(kfd_, TCSANOW, &amp;cooked_);
    printf("keyboard_loop thread quited.\n");
    return;
  }  // end of keyboard loop thread</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(321, 0)" endLine="(357, 1)" clone_start="2" clone_end="23">
			<code function_name="RawStream::disconnect()">bool RawStream::disconnect() {
  if (_data_stream) {
    if (_data_stream-&gt;get_status() == Stream::Status::CONNECTED) {
      if (!_data_stream-&gt;disconnect()) {
        ROS_ERROR("data stream disconnect failed.");
        return false;
      }
    }
  }

  if (_command_stream) {
    if (_command_stream-&gt;get_status() == Stream::Status::CONNECTED) {
      if (!_data_stream-&gt;disconnect()) {
        ROS_ERROR("command stream disconnect failed.");
        return false;
      }
    }
  }
  if (_in_rtk_stream) {
    if (_in_rtk_stream-&gt;get_status() == Stream::Status::CONNECTED) {
      if (!_in_rtk_stream-&gt;disconnect()) {
        ROS_ERROR("in rtk stream disconnect failed.");
        return false;
      }
    }
  }
  if (_out_rtk_stream) {
    if (_out_rtk_stream-&gt;get_status() == Stream::Status::CONNECTED) {
      if (!_out_rtk_stream-&gt;disconnect()) {
        ROS_ERROR("out rtk stream disconnect failed.");
        return false;
      }
    }
  }

  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(321, 0)" endLine="(357, 1)" clone_start="11" clone_end="31">
			<code function_name="RawStream::disconnect()">bool RawStream::disconnect() {
  if (_data_stream) {
    if (_data_stream-&gt;get_status() == Stream::Status::CONNECTED) {
      if (!_data_stream-&gt;disconnect()) {
        ROS_ERROR("data stream disconnect failed.");
        return false;
      }
    }
  }

  if (_command_stream) {
    if (_command_stream-&gt;get_status() == Stream::Status::CONNECTED) {
      if (!_data_stream-&gt;disconnect()) {
        ROS_ERROR("command stream disconnect failed.");
        return false;
      }
    }
  }
  if (_in_rtk_stream) {
    if (_in_rtk_stream-&gt;get_status() == Stream::Status::CONNECTED) {
      if (!_in_rtk_stream-&gt;disconnect()) {
        ROS_ERROR("in rtk stream disconnect failed.");
        return false;
      }
    }
  }
  if (_out_rtk_stream) {
    if (_out_rtk_stream-&gt;get_status() == Stream::Status::CONNECTED) {
      if (!_out_rtk_stream-&gt;disconnect()) {
        ROS_ERROR("out rtk stream disconnect failed.");
        return false;
      }
    }
  }

  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\util_xml_parser.cc" startLine="(117, 0)" endLine="(148, 1)" clone_start="11" clone_end="32">
			<code function_name="UtilXmlParser::ParseOutline(const tinyxml2::XMLElement&amp; xml_node, PbPolygon* polygon)">Status UtilXmlParser::ParseOutline(const tinyxml2::XMLElement&amp; xml_node,
                                   PbPolygon* polygon) {
  const tinyxml2::XMLElement* sub_node =
      xml_node.FirstChildElement("cornerGlobal");
  while (sub_node) {
    double ptx = 0.0;
    double pty = 0.0;
    double ptz = 0.0;
    int checker = tinyxml2::XML_SUCCESS;
    checker += sub_node-&gt;QueryDoubleAttribute("x", &amp;ptx);
    checker += sub_node-&gt;QueryDoubleAttribute("y", &amp;pty);
    checker += sub_node-&gt;QueryDoubleAttribute("z", &amp;ptz);

    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parsing cornerGlobal point attributes";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    PbPoint3D* pt = polygon-&gt;add_point();
    double output_x = 0.0;
    double output_y = 0.0;
    double output_z = 0.0;
    WGS84ToUTM(ptx, pty, ptz, &amp;output_x, &amp;output_y, &amp;output_z);
    pt-&gt;set_x(output_x);
    pt-&gt;set_y(output_y);
    // pt-&gt;set_z(output_z);

    sub_node = sub_node-&gt;NextSiblingElement("cornerGlobal");
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\util_xml_parser.cc" startLine="(87, 0)" endLine="(115, 1)" clone_start="9" clone_end="29">
			<code function_name="UtilXmlParser::ParsePointSet(const tinyxml2::XMLElement&amp; xml_node, PbLineSegment* line_segment)">Status UtilXmlParser::ParsePointSet(const tinyxml2::XMLElement&amp; xml_node,
                                    PbLineSegment* line_segment) {
  const tinyxml2::XMLElement* sub_node = xml_node.FirstChildElement("point");
  while (sub_node) {
    double ptx = 0.0;
    double pty = 0.0;
    double ptz = 0.0;
    int checker = tinyxml2::XML_SUCCESS;
    checker += sub_node-&gt;QueryDoubleAttribute("x", &amp;ptx);
    checker += sub_node-&gt;QueryDoubleAttribute("y", &amp;pty);

    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parsing geometry point attributes";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    PbPoint3D* pt = line_segment-&gt;add_point();
    double output_x = 0.0;
    double output_y = 0.0;
    double output_z = 0.0;
    WGS84ToUTM(ptx, pty, ptz, &amp;output_x, &amp;output_y, &amp;output_z);
    pt-&gt;set_x(output_x);
    pt-&gt;set_y(output_y);

    sub_node = sub_node-&gt;NextSiblingElement("point");
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\util_xml_parser.cc" startLine="(150, 0)" endLine="(178, 1)" clone_start="1" clone_end="1">
			<code function_name="UtilXmlParser::ParsePoint(const tinyxml2::XMLElement&amp; xml_node, PbPoint3D* pt)">Status UtilXmlParser::ParsePoint(const tinyxml2::XMLElement&amp; xml_node,
                                 PbPoint3D* pt) {
  CHECK_NOTNULL(pt);

  const auto sub_node = xml_node.FirstChildElement("centerPoint");
  CHECK(sub_node != nullptr);
  int checker = tinyxml2::XML_SUCCESS;
  double ptx = 0.0;
  double pty = 0.0;
  double ptz = 0.0;
  checker += sub_node-&gt;QueryDoubleAttribute("x", &amp;ptx);
  checker += sub_node-&gt;QueryDoubleAttribute("y", &amp;pty);
  checker += sub_node-&gt;QueryDoubleAttribute("z", &amp;ptz);

  if (checker != tinyxml2::XML_SUCCESS) {
    std::string err_msg = "Error parse point attributes";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  double output_x = 0.0;
  double output_y = 0.0;
  double output_z = 0.0;
  WGS84ToUTM(ptx, pty, ptz, &amp;output_x, &amp;output_y, &amp;output_z);
  pt-&gt;set_x(output_x);
  pt-&gt;set_y(output_y);
  pt-&gt;set_z(output_z);

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\util_xml_parser.cc" startLine="(117, 0)" endLine="(148, 1)" clone_start="1" clone_end="1">
			<code function_name="UtilXmlParser::ParseOutline(const tinyxml2::XMLElement&amp; xml_node, PbPolygon* polygon)">Status UtilXmlParser::ParseOutline(const tinyxml2::XMLElement&amp; xml_node,
                                   PbPolygon* polygon) {
  const tinyxml2::XMLElement* sub_node =
      xml_node.FirstChildElement("cornerGlobal");
  while (sub_node) {
    double ptx = 0.0;
    double pty = 0.0;
    double ptz = 0.0;
    int checker = tinyxml2::XML_SUCCESS;
    checker += sub_node-&gt;QueryDoubleAttribute("x", &amp;ptx);
    checker += sub_node-&gt;QueryDoubleAttribute("y", &amp;pty);
    checker += sub_node-&gt;QueryDoubleAttribute("z", &amp;ptz);

    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parsing cornerGlobal point attributes";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    PbPoint3D* pt = polygon-&gt;add_point();
    double output_x = 0.0;
    double output_y = 0.0;
    double output_z = 0.0;
    WGS84ToUTM(ptx, pty, ptz, &amp;output_x, &amp;output_y, &amp;output_z);
    pt-&gt;set_x(output_x);
    pt-&gt;set_y(output_y);
    // pt-&gt;set_z(output_z);

    sub_node = sub_node-&gt;NextSiblingElement("cornerGlobal");
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\tcp_stream.cpp" startLine="(283, 0)" endLine="(318, 1)" clone_start="14" clone_end="35">
			<code function_name="TcpStream::write(const uint8_t* buffer, size_t length)">size_t TcpStream::write(const uint8_t* buffer, size_t length) {
  size_t total_nsent = 0;

  if (_status != Stream::Status::CONNECTED) {
    disconnect();
    connect();
    if (_status != Stream::Status::CONNECTED) {
      return 0;
    }
  }

  while (length &gt; 0) {
    ssize_t nsent = ::send(_sockfd, buffer, length, 0);
    if (nsent &lt; 0) {
      if (errno == EINTR) {
        continue;
      } else {
        // error
        if (errno == EPIPE || errno == ECONNRESET) {
          _status = Stream::Status::DISCONNECTED;
          _errno = errno;
        } else if (errno != EAGAIN) {
          _status = Stream::Status::ERROR;
          _errno = errno;
        }
        return total_nsent;
      }
    }

    total_nsent += nsent;
    length -= nsent;
    buffer += nsent;
  }

  return total_nsent;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\udp_stream.cpp" startLine="(199, 0)" endLine="(233, 1)" clone_start="13" clone_end="34">
			<code function_name="UdpStream::write(const uint8_t* data, size_t length)">size_t UdpStream::write(const uint8_t* data, size_t length) {
  size_t total_nsent = 0;
  struct sockaddr_in peer_sockaddr;
  bzero(&amp;peer_sockaddr, sizeof(peer_sockaddr));
  peer_sockaddr.sin_family = AF_INET;
  peer_sockaddr.sin_port = _peer_port;
  peer_sockaddr.sin_addr.s_addr = _peer_addr;

  while (length &gt; 0) {
    ssize_t nsent =
        ::sendto(_sockfd, data, length, 0, (struct sockaddr*)&amp;peer_sockaddr,
                 (socklen_t)sizeof(peer_sockaddr));
    if (nsent &lt; 0) {  // error
      if (errno == EINTR) {
        continue;
      } else {
        // error
        if (errno == EPIPE || errno == ECONNRESET) {
          _status = Stream::Status::DISCONNECTED;
          _errno = errno;
        } else if (errno != EAGAIN) {
          _status = Stream::Status::ERROR;
          _errno = errno;
        }
        return total_nsent;
      }
    }

    total_nsent += nsent;
    length -= nsent;
    data += nsent;
  }

  return total_nsent;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(53, 0)" endLine="(63, 1)" clone_start="1" clone_end="11">
			<code function_name="Gps6f::altitude(const std::uint8_t *bytes, int32_t length) const">double Gps6f::altitude(const std::uint8_t *bytes, int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.250000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gyro_6c.cc" startLine="(35, 0)" endLine="(45, 1)" clone_start="1" clone_end="11">
			<code function_name="Gyro6c::roll_rate(const std::uint8_t *bytes, int32_t length) const">double Gyro6c::roll_rate(const std::uint8_t *bytes, int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.000200;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(162, 0)" endLine="(173, 1)" clone_start="1" clone_end="12">
			<code function_name="Brakeinfo74::wheel_torque_actual(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::wheel_torque_actual(const std::uint8_t *bytes,
                                        int32_t length) const {
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 6);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FFF) {
    value -= 0x4000;
  }
  return value * 4.000000;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6f.cc" startLine="(65, 0)" endLine="(72, 1)" clone_start="1" clone_end="6">
			<code function_name="Gps6f::heading(const std::uint8_t *bytes, int32_t length) const">double Gps6f::heading(const std::uint8_t *bytes, int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gyro_6c.cc" startLine="(47, 0)" endLine="(57, 1)" clone_start="1" clone_end="6">
			<code function_name="Gyro6c::yaw_rate(const std::uint8_t *bytes, int32_t length) const">double Gyro6c::yaw_rate(const std::uint8_t *bytes, int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.000200;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(175, 0)" endLine="(187, 1)" clone_start="1" clone_end="8">
			<code function_name="Brakeinfo74::acceleration_over_ground(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::acceleration_over_ground(const std::uint8_t *bytes,
                                             int32_t length) const {
  // vehicle acceleration over ground estimate
  Byte frame_high(bytes + 7);
  int32_t high = frame_high.get_byte(0, 2);
  Byte frame_low(bytes + 6);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FF) {
    value -= 0x400;
  }
  return value * 0.035000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\simulation_world\simulation_world_service.cc" startLine="(138, 0)" endLine="(165, 1)" clone_start="7" clone_end="21">
			<code function_name="SetObstacleType(const PerceptionObstacle &amp;obstacle, Object *world_object)">void SetObstacleType(const PerceptionObstacle &amp;obstacle, Object *world_object) {
  if (world_object == nullptr) {
    return;
  }

  switch (obstacle.type()) {
    case PerceptionObstacle::UNKNOWN:
      world_object-&gt;set_type(Object_Type_UNKNOWN);
      break;
    case PerceptionObstacle::UNKNOWN_MOVABLE:
      world_object-&gt;set_type(Object_Type_UNKNOWN_MOVABLE);
      break;
    case PerceptionObstacle::UNKNOWN_UNMOVABLE:
      world_object-&gt;set_type(Object_Type_UNKNOWN_UNMOVABLE);
      break;
    case PerceptionObstacle::PEDESTRIAN:
      world_object-&gt;set_type(Object_Type_PEDESTRIAN);
      break;
    case PerceptionObstacle::BICYCLE:
      world_object-&gt;set_type(Object_Type_BICYCLE);
      break;
    case PerceptionObstacle::VEHICLE:
      world_object-&gt;set_type(Object_Type_VEHICLE);
      break;
    default:
      world_object-&gt;set_type(Object_Type_VIRTUAL);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\simulation_world\simulation_world_service.cc" startLine="(138, 0)" endLine="(165, 1)" clone_start="10" clone_end="24">
			<code function_name="SetObstacleType(const PerceptionObstacle &amp;obstacle, Object *world_object)">void SetObstacleType(const PerceptionObstacle &amp;obstacle, Object *world_object) {
  if (world_object == nullptr) {
    return;
  }

  switch (obstacle.type()) {
    case PerceptionObstacle::UNKNOWN:
      world_object-&gt;set_type(Object_Type_UNKNOWN);
      break;
    case PerceptionObstacle::UNKNOWN_MOVABLE:
      world_object-&gt;set_type(Object_Type_UNKNOWN_MOVABLE);
      break;
    case PerceptionObstacle::UNKNOWN_UNMOVABLE:
      world_object-&gt;set_type(Object_Type_UNKNOWN_UNMOVABLE);
      break;
    case PerceptionObstacle::PEDESTRIAN:
      world_object-&gt;set_type(Object_Type_PEDESTRIAN);
      break;
    case PerceptionObstacle::BICYCLE:
      world_object-&gt;set_type(Object_Type_BICYCLE);
      break;
    case PerceptionObstacle::VEHICLE:
      world_object-&gt;set_type(Object_Type_VEHICLE);
      break;
    default:
      world_object-&gt;set_type(Object_Type_VIRTUAL);
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(26, 0)" endLine="(28, 1)" clone_start="2" clone_end="3">
			<code function_name="HDMap::GetLaneById(const Id&amp; id) const">LaneInfoConstPtr HDMap::GetLaneById(const Id&amp; id) const {
  return impl_.GetLaneById(id);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(22, 0)" endLine="(24, 1)" clone_start="2" clone_end="3">
			<code function_name="HDMap::LoadMapFromFile(const std::string&amp; map_filename)">int HDMap::LoadMapFromFile(const std::string&amp; map_filename) {
  return impl_.LoadMapFromFile(map_filename);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(30, 0)" endLine="(32, 1)" clone_start="1" clone_end="3">
			<code function_name="HDMap::GetJunctionById(const Id&amp; id) const">JunctionInfoConstPtr HDMap::GetJunctionById(const Id&amp; id) const {
  return impl_.GetJunctionById(id);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(26, 0)" endLine="(28, 1)" clone_start="1" clone_end="3">
			<code function_name="HDMap::GetLaneById(const Id&amp; id) const">LaneInfoConstPtr HDMap::GetLaneById(const Id&amp; id) const {
  return impl_.GetLaneById(id);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(34, 0)" endLine="(36, 1)" clone_start="1" clone_end="3">
			<code function_name="HDMap::GetSignalById(const Id&amp; id) const">SignalInfoConstPtr HDMap::GetSignalById(const Id&amp; id) const {
  return impl_.GetSignalById(id);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(30, 0)" endLine="(32, 1)" clone_start="1" clone_end="3">
			<code function_name="HDMap::GetJunctionById(const Id&amp; id) const">JunctionInfoConstPtr HDMap::GetJunctionById(const Id&amp; id) const {
  return impl_.GetJunctionById(id);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(38, 0)" endLine="(40, 1)" clone_start="1" clone_end="3">
			<code function_name="HDMap::GetCrosswalkById(const Id&amp; id) const">CrosswalkInfoConstPtr HDMap::GetCrosswalkById(const Id&amp; id) const {
  return impl_.GetCrosswalkById(id);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(34, 0)" endLine="(36, 1)" clone_start="1" clone_end="3">
			<code function_name="HDMap::GetSignalById(const Id&amp; id) const">SignalInfoConstPtr HDMap::GetSignalById(const Id&amp; id) const {
  return impl_.GetSignalById(id);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(42, 0)" endLine="(44, 1)" clone_start="1" clone_end="3">
			<code function_name="HDMap::GetStopSignById(const Id&amp; id) const">StopSignInfoConstPtr HDMap::GetStopSignById(const Id&amp; id) const {
  return impl_.GetStopSignById(id);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(38, 0)" endLine="(40, 1)" clone_start="1" clone_end="3">
			<code function_name="HDMap::GetCrosswalkById(const Id&amp; id) const">CrosswalkInfoConstPtr HDMap::GetCrosswalkById(const Id&amp; id) const {
  return impl_.GetCrosswalkById(id);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(46, 0)" endLine="(48, 1)" clone_start="1" clone_end="3">
			<code function_name="HDMap::GetYieldSignById(const Id&amp; id) const">YieldSignInfoConstPtr HDMap::GetYieldSignById(const Id&amp; id) const {
  return impl_.GetYieldSignById(id);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(42, 0)" endLine="(44, 1)" clone_start="1" clone_end="3">
			<code function_name="HDMap::GetStopSignById(const Id&amp; id) const">StopSignInfoConstPtr HDMap::GetStopSignById(const Id&amp; id) const {
  return impl_.GetStopSignById(id);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(50, 0)" endLine="(52, 1)" clone_start="1" clone_end="3">
			<code function_name="HDMap::GetOverlapById(const Id&amp; id) const">OverlapInfoConstPtr HDMap::GetOverlapById(const Id&amp; id) const {
  return impl_.GetOverlapById(id);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(46, 0)" endLine="(48, 1)" clone_start="1" clone_end="3">
			<code function_name="HDMap::GetYieldSignById(const Id&amp; id) const">YieldSignInfoConstPtr HDMap::GetYieldSignById(const Id&amp; id) const {
  return impl_.GetYieldSignById(id);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(54, 0)" endLine="(56, 1)" clone_start="1" clone_end="2">
			<code function_name="HDMap::GetRoadById(const Id&amp; id) const">RoadInfoConstPtr HDMap::GetRoadById(const Id&amp; id) const {
  return impl_.GetRoadById(id);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap.cc" startLine="(50, 0)" endLine="(52, 1)" clone_start="1" clone_end="2">
			<code function_name="HDMap::GetOverlapById(const Id&amp; id) const">OverlapInfoConstPtr HDMap::GetOverlapById(const Id&amp; id) const {
  return impl_.GetOverlapById(id);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(492, 0)" endLine="(612, 1)" clone_start="30" clone_end="47">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  if (!chassis_detail.has_eps()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO eps."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_brake()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO brake."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gas()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gas."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gear()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gear."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR_EVERY(100) &lt;&lt; "Steering fault detected: "
                      &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR_EVERY(100) &lt;&lt; "Brake fault detected: "
                      &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR_EVERY(100) &lt;&lt; "Throttle fault detected: "
                      &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR_EVERY(100) &lt;&lt; "Gear fault detected: "
                      &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(492, 0)" endLine="(612, 1)" clone_start="8" clone_end="24">
			<code function_name="LincolnController::CheckChassisError()">bool LincolnController::CheckChassisError() {
  // steer fault
  ChassisDetail chassis_detail;
  message_manager_-&gt;GetChassisDetail(&amp;chassis_detail);

  int32_t error_cnt = 0;
  int32_t chassis_error_mask = 0;
  if (!chassis_detail.has_eps()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO eps."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  bool steer_fault = chassis_detail.eps().watchdog_fault() |
                     chassis_detail.eps().channel_1_fault() |
                     chassis_detail.eps().channel_2_fault() |
                     chassis_detail.eps().calibration_fault() |
                     chassis_detail.eps().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.eps().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().calibration_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.eps().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_brake()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO brake."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // brake fault
  bool brake_fault = chassis_detail.brake().watchdog_fault() |
                     chassis_detail.brake().channel_1_fault() |
                     chassis_detail.brake().channel_2_fault() |
                     chassis_detail.brake().boo_fault() |
                     chassis_detail.brake().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.brake().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |= ((chassis_detail.brake().boo_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.brake().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gas()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gas."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // throttle fault
  bool throttle_fault = chassis_detail.gas().watchdog_fault() |
                        chassis_detail.gas().channel_1_fault() |
                        chassis_detail.gas().channel_2_fault() |
                        chassis_detail.gas().connector_fault();

  chassis_error_mask |=
      ((chassis_detail.gas().watchdog_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_1_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().channel_2_fault()) &lt;&lt; (error_cnt++));
  chassis_error_mask |=
      ((chassis_detail.gas().connector_fault()) &lt;&lt; (error_cnt++));

  if (!chassis_detail.has_gear()) {
    AERROR_EVERY(100) &lt;&lt; "ChassisDetail has NO gear."
                      &lt;&lt; chassis_detail.DebugString();
    return false;
  }
  // gear fault
  bool gear_fault = chassis_detail.gear().canbus_fault();

  chassis_error_mask |=
      ((chassis_detail.gear().canbus_fault()) &lt;&lt; (error_cnt++));

  set_chassis_error_mask(chassis_error_mask);

  if (steer_fault) {
    AERROR_EVERY(100) &lt;&lt; "Steering fault detected: "
                      &lt;&lt; chassis_detail.eps().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().calibration_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.eps().connector_fault();
  }

  if (brake_fault) {
    AERROR_EVERY(100) &lt;&lt; "Brake fault detected: "
                      &lt;&lt; chassis_detail.brake().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().boo_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.brake().connector_fault();
  }

  if (throttle_fault) {
    AERROR_EVERY(100) &lt;&lt; "Throttle fault detected: "
                      &lt;&lt; chassis_detail.gas().watchdog_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_1_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().channel_2_fault() &lt;&lt; ", "
                      &lt;&lt; chassis_detail.gas().connector_fault();
  }

  if (gear_fault) {
    AERROR_EVERY(100) &lt;&lt; "Gear fault detected: "
                      &lt;&lt; chassis_detail.gear().canbus_fault();
  }

  if (steer_fault || brake_fault || throttle_fault) {
    return true;
  }

  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(364, 0)" endLine="(406, 1)" clone_start="12" clone_end="34">
			<code function_name="Obstacle::InitKFMotionTracker(Feature* feature)">void Obstacle::InitKFMotionTracker(Feature* feature) {
  // Set transition matrix F
  Eigen::Matrix&lt;double, 6, 6&gt; F;
  F.setIdentity();
  kf_motion_tracker_.SetTransitionMatrix(F);

  // Set observation matrix H
  Eigen::Matrix&lt;double, 2, 6&gt; H;
  H.setZero();
  H(0, 0) = 1.0;
  H(1, 1) = 1.0;
  kf_motion_tracker_.SetObservationMatrix(H);

  // Set covariance of transition noise matrix Q
  Eigen::Matrix&lt;double, 6, 6&gt; Q;
  Q.setIdentity();
  Q *= FLAGS_q_var;
  kf_motion_tracker_.SetTransitionNoise(Q);

  // Set observation noise matrix R
  Eigen::Matrix&lt;double, 2, 2&gt; R;
  R.setIdentity();
  R *= FLAGS_r_var;
  kf_motion_tracker_.SetObservationNoise(R);

  // Set current state covariance matrix P
  Eigen::Matrix&lt;double, 6, 6&gt; P;
  P.setIdentity();
  P *= FLAGS_p_var;

  // Set initial state
  Eigen::Matrix&lt;double, 6, 1&gt; x;
  x(0, 0) = feature-&gt;position().x();
  x(1, 0) = feature-&gt;position().y();
  x(2, 0) = feature-&gt;velocity().x();
  x(3, 0) = feature-&gt;velocity().y();
  x(4, 0) = feature-&gt;acceleration().x();
  x(5, 0) = feature-&gt;acceleration().y();

  kf_motion_tracker_.SetStateEstimate(x, P);

  kf_motion_tracker_enabled_ = true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(636, 0)" endLine="(677, 1)" clone_start="15" clone_end="37">
			<code function_name="Obstacle::InitKFPedestrianTracker(Feature* feature)">void Obstacle::InitKFPedestrianTracker(Feature* feature) {
  // Set transition matrix F
  Eigen::Matrix&lt;double, 2, 2&gt; F;
  F.setIdentity();
  kf_pedestrian_tracker_.SetTransitionMatrix(F);

  // Set observation matrix H
  Eigen::Matrix&lt;double, 2, 2&gt; H;
  H.setIdentity();
  kf_pedestrian_tracker_.SetObservationMatrix(H);

  // Set control matrix
  Eigen::Matrix&lt;double, 2, 4&gt; B;
  B.setZero();
  kf_pedestrian_tracker_.SetControlMatrix(B);

  // Set covariance of transition noise matrix Q
  Eigen::Matrix&lt;double, 2, 2&gt; Q;
  Q.setIdentity();
  Q *= FLAGS_q_var;
  kf_pedestrian_tracker_.SetTransitionNoise(Q);

  // Set observation noise matrix R
  Eigen::Matrix&lt;double, 2, 2&gt; R;
  R.setIdentity();
  R *= FLAGS_r_var;
  kf_pedestrian_tracker_.SetObservationNoise(R);

  // Set current state covariance matrix P
  Eigen::Matrix&lt;double, 2, 2&gt; P;
  P.setIdentity();
  P *= FLAGS_p_var;

  // Set initial state
  Eigen::Matrix&lt;double, 2, 1&gt; x;
  x(0, 0) = feature-&gt;position().x();
  x(1, 0) = feature-&gt;position().y();

  kf_pedestrian_tracker_.SetStateEstimate(x, P);

  kf_pedestrian_tracker_enabled_ = true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(89, 0)" endLine="(101, 1)" clone_start="1" clone_end="13">
			<code function_name="Steering65::reported_steering_angle_cmd(const std::uint8_t *bytes, int32_t length) const">double Steering65::reported_steering_angle_cmd(const std::uint8_t *bytes,
                                               int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x8000) {
    value = value - 0x10000;
  }

  return value * 0.100000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(75, 0)" endLine="(87, 1)" clone_start="1" clone_end="13">
			<code function_name="Steering65::steering_angle(const std::uint8_t *bytes, int32_t length) const">double Steering65::steering_angle(const std::uint8_t *bytes,
                                  int32_t length) const {
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x8000) {
    value = value - 0x10000;
  }

  return value * 0.100000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(103, 0)" endLine="(111, 1)" clone_start="1" clone_end="7">
			<code function_name="Steering65::vehicle_speed(const std::uint8_t *bytes, int32_t length) const">double Steering65::vehicle_speed(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(89, 0)" endLine="(101, 1)" clone_start="1" clone_end="7">
			<code function_name="Steering65::reported_steering_angle_cmd(const std::uint8_t *bytes, int32_t length) const">double Steering65::reported_steering_angle_cmd(const std::uint8_t *bytes,
                                               int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x8000) {
    value = value - 0x10000;
  }

  return value * 0.100000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(40, 0)" endLine="(43, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_none()">Gear66 *Gear66::set_gear_none() {
  gear_ = 0x00;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(45, 0)" endLine="(48, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_park()">Gear66 *Gear66::set_gear_park() {
  gear_ = 0x01;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(45, 0)" endLine="(48, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_park()">Gear66 *Gear66::set_gear_park() {
  gear_ = 0x01;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(50, 0)" endLine="(53, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_reverse()">Gear66 *Gear66::set_gear_reverse() {
  gear_ = 0x02;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(50, 0)" endLine="(53, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_reverse()">Gear66 *Gear66::set_gear_reverse() {
  gear_ = 0x02;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(55, 0)" endLine="(58, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_neutral()">Gear66 *Gear66::set_gear_neutral() {
  gear_ = 0x03;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(55, 0)" endLine="(58, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_neutral()">Gear66 *Gear66::set_gear_neutral() {
  gear_ = 0x03;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(60, 0)" endLine="(63, 1)" clone_start="1" clone_end="4">
			<code function_name="Gear66::set_gear_drive()">Gear66 *Gear66::set_gear_drive() {
  gear_ = 0x04;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(60, 0)" endLine="(63, 1)" clone_start="1" clone_end="3">
			<code function_name="Gear66::set_gear_drive()">Gear66 *Gear66::set_gear_drive() {
  gear_ = 0x04;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_66.cc" startLine="(65, 0)" endLine="(68, 1)" clone_start="1" clone_end="3">
			<code function_name="Gear66::set_gear_low()">Gear66 *Gear66::set_gear_low() {
  gear_ = 0x05;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(29, 0)" endLine="(59, 1)" clone_start="4" clone_end="27">
			<code function_name="Brake61::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brake61::Parse(const std::uint8_t *bytes, int32_t length,
                    ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_output(
      pedal_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  chassis_detail-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(29, 0)" endLine="(59, 1)" clone_start="3" clone_end="25">
			<code function_name="Brake61::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brake61::Parse(const std::uint8_t *bytes, int32_t length,
                    ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_input(pedal_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_cmd(pedal_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_output(
      pedal_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_input(boo_input(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_cmd(boo_cmd(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_output(boo_output(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_applying_brakes(
      is_watchdog_counter_applying_brakes(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_source(
      watchdog_counter_source(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_enabled(is_enabled(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_override(
      is_driver_override(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_driver_activity(
      is_driver_activity(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_watchdog_fault(
      is_watchdog_counter_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_1_fault(
      is_channel_1_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_channel_2_fault(
      is_channel_2_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_boo_fault(
      is_boo_switch_fault(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_connector_fault(
      is_connector_fault(bytes, length));
  chassis_detail-&gt;mutable_check_response()-&gt;set_is_esp_online(
      !is_driver_override(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(26, 0)" endLine="(114, 1)" clone_start="68" clone_end="88">
			<code function_name="SignalsXmlParser::ParseTrafficLights(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;TrafficLightInternal&gt;* traffic_lights)">Status SignalsXmlParser::ParseTrafficLights(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;TrafficLightInternal&gt;* traffic_lights) {
  CHECK_NOTNULL(traffic_lights);
  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "trafficLight") {
      PbSignal traffic_light;
      traffic_light.mutable_id()-&gt;set_id(object_id);
      std::string layout_type;
      int checker = UtilXmlParser::QueryStringAttribute(
          *signal_node, "layoutType", &amp;layout_type);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse signal layout type.";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      PbSignalType signal_layout_type;
      ToPbSignalType(layout_type, &amp;signal_layout_type);
      traffic_light.set_type(signal_layout_type);

      PbPolygon* polygon = traffic_light.mutable_boundary();
      auto outline_node = signal_node-&gt;FirstChildElement("outline");
      if (outline_node == nullptr) {
        std::string err_msg = "Error parse signal outline";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseOutline(*outline_node, polygon));
      auto sub_node = signal_node-&gt;FirstChildElement("subSignal");
      if (sub_node == nullptr) {
        std::string err_msg = "Error parse sub signal.";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      while (sub_node) {
        std::string sub_signal_id;
        std::string sub_signal_xml_type;
        checker = UtilXmlParser::QueryStringAttribute(*sub_node, "type",
                                                      &amp;sub_signal_xml_type);
        checker += UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                       &amp;sub_signal_id);
        if (checker != tinyxml2::XML_SUCCESS) {
          std::string err_msg = "Error parse sub signal layout type.";
          return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
        }

        PbSubSignal* sub_signal = traffic_light.add_subsignal();
        PbSubSignalType sub_signal_type;
        ToPbSubSignalType(sub_signal_xml_type, &amp;sub_signal_type);
        sub_signal-&gt;mutable_id()-&gt;set_id(sub_signal_id);
        sub_signal-&gt;set_type(sub_signal_type);
        PbPoint3D* pt = sub_signal-&gt;mutable_location();
        RETURN_IF_ERROR(UtilXmlParser::ParsePoint(*sub_node, pt));

        sub_node = sub_node-&gt;NextSiblingElement("subSignal");
      }

      TrafficLightInternal trafficlight_internal;
      trafficlight_internal.id = object_id;
      trafficlight_internal.traffic_light = traffic_light;

      sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                            &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          trafficlight_internal.stop_line_ids.insert(stop_line_id);
          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      traffic_lights-&gt;emplace_back(trafficlight_internal);
    }
    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(216, 0)" endLine="(259, 1)" clone_start="22" clone_end="43">
			<code function_name="SignalsXmlParser::ParseYieldSigns(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;YieldSignInternal&gt;* yield_signs)">Status SignalsXmlParser::ParseYieldSigns(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;YieldSignInternal&gt;* yield_signs) {
  CHECK_NOTNULL(yield_signs);

  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "yieldSign") {
      PbYieldSign yield_sign;
      yield_sign.mutable_id()-&gt;set_id(object_id);
      YieldSignInternal yield_sign_internal;
      yield_sign_internal.id = object_id;
      yield_sign_internal.yield_sign = yield_sign;
      auto sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                            &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          yield_sign_internal.stop_line_ids.insert(stop_line_id);

          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      yield_signs-&gt;emplace_back(yield_sign_internal);
    }

    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\vehicle_controller.cc" startLine="(37, 0)" endLine="(91, 1)" clone_start="23" clone_end="42">
			<code function_name="VehicleController::SetDrivingMode( const Chassis::DrivingMode &amp;driving_mode)">ErrorCode VehicleController::SetDrivingMode(
    const Chassis::DrivingMode &amp;driving_mode) {
  if (driving_mode == Chassis::EMERGENCY_MODE) {
    AINFO &lt;&lt; "Can't set vehicle to EMERGENCY_MODE driving mode.";
    return ErrorCode::CANBUS_ERROR;
  }

  // vehicle in emergency mode only response to manual mode to reset.
  if (driving_mode_ == Chassis::EMERGENCY_MODE &amp;&amp;
      driving_mode != Chassis::COMPLETE_MANUAL) {
    AINFO
        &lt;&lt; "Vehicle in EMERGENCY_MODE, only response to COMPLETE_MANUAL mode.";
    AINFO &lt;&lt; "Only response to RESET ACTION.";
    return ErrorCode::CANBUS_ERROR;
  }

  // if current mode is same as previous, no need to set.
  if (driving_mode_ == driving_mode) {
    return ErrorCode::OK;
  }

  switch (driving_mode) {
    case Chassis::COMPLETE_AUTO_DRIVE: {
      if (EnableAutoMode() != ErrorCode::OK) {
        AERROR &lt;&lt; "Fail to EnableAutoMode.";
        return ErrorCode::CANBUS_ERROR;
      }
      break;
    }
    case Chassis::COMPLETE_MANUAL: {
      if (DisableAutoMode() != ErrorCode::OK) {
        AERROR &lt;&lt; "Fail to DisableAutoMode.";
        return ErrorCode::CANBUS_ERROR;
      }
      break;
    }
    case Chassis::AUTO_STEER_ONLY: {
      if (EnableSteeringOnlyMode() != ErrorCode::OK) {
        AERROR &lt;&lt; "Fail to EnableSpeedOnlyMode.";
        return ErrorCode::CANBUS_ERROR;
      }
      break;
    }
    case Chassis::AUTO_SPEED_ONLY: {
      if (EnableSpeedOnlyMode() != ErrorCode::OK) {
        AERROR &lt;&lt; "Fail to EnableSpeedOnlyMode";
        return ErrorCode::CANBUS_ERROR;
      }
      break;
    }
    default:
      break;
  }
  return ErrorCode::OK;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\vehicle_controller.cc" startLine="(37, 0)" endLine="(91, 1)" clone_start="30" clone_end="49">
			<code function_name="VehicleController::SetDrivingMode( const Chassis::DrivingMode &amp;driving_mode)">ErrorCode VehicleController::SetDrivingMode(
    const Chassis::DrivingMode &amp;driving_mode) {
  if (driving_mode == Chassis::EMERGENCY_MODE) {
    AINFO &lt;&lt; "Can't set vehicle to EMERGENCY_MODE driving mode.";
    return ErrorCode::CANBUS_ERROR;
  }

  // vehicle in emergency mode only response to manual mode to reset.
  if (driving_mode_ == Chassis::EMERGENCY_MODE &amp;&amp;
      driving_mode != Chassis::COMPLETE_MANUAL) {
    AINFO
        &lt;&lt; "Vehicle in EMERGENCY_MODE, only response to COMPLETE_MANUAL mode.";
    AINFO &lt;&lt; "Only response to RESET ACTION.";
    return ErrorCode::CANBUS_ERROR;
  }

  // if current mode is same as previous, no need to set.
  if (driving_mode_ == driving_mode) {
    return ErrorCode::OK;
  }

  switch (driving_mode) {
    case Chassis::COMPLETE_AUTO_DRIVE: {
      if (EnableAutoMode() != ErrorCode::OK) {
        AERROR &lt;&lt; "Fail to EnableAutoMode.";
        return ErrorCode::CANBUS_ERROR;
      }
      break;
    }
    case Chassis::COMPLETE_MANUAL: {
      if (DisableAutoMode() != ErrorCode::OK) {
        AERROR &lt;&lt; "Fail to DisableAutoMode.";
        return ErrorCode::CANBUS_ERROR;
      }
      break;
    }
    case Chassis::AUTO_STEER_ONLY: {
      if (EnableSteeringOnlyMode() != ErrorCode::OK) {
        AERROR &lt;&lt; "Fail to EnableSpeedOnlyMode.";
        return ErrorCode::CANBUS_ERROR;
      }
      break;
    }
    case Chassis::AUTO_SPEED_ONLY: {
      if (EnableSpeedOnlyMode() != ErrorCode::OK) {
        AERROR &lt;&lt; "Fail to EnableSpeedOnlyMode";
        return ErrorCode::CANBUS_ERROR;
      }
      break;
    }
    default:
      break;
  }
  return ErrorCode::OK;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\evaluator\evaluator_manager.cc" startLine="(32, 0)" endLine="(34, 1)" clone_start="2" clone_end="3">
			<code function_name="EvaluatorManager::RegisterEvaluators()">void EvaluatorManager::RegisterEvaluators() {
  RegisterEvaluator(ObstacleConf::MLP_EVALUATOR);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\predictor_manager.cc" startLine="(36, 0)" endLine="(40, 1)" clone_start="4" clone_end="5">
			<code function_name="PredictorManager::RegisterPredictors()">void PredictorManager::RegisterPredictors() {
  RegisterPredictor(ObstacleConf::LANE_SEQUENCE_PREDICTOR);
  RegisterPredictor(ObstacleConf::FREE_MOVE_PREDICTOR);
  RegisterPredictor(ObstacleConf::REGIONAL_PREDICTOR);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\evaluator\evaluator_manager.cc" startLine="(36, 0)" endLine="(59, 1)" clone_start="1" clone_end="17">
			<code function_name="EvaluatorManager::Init(const PredictionConf&amp; config)">void EvaluatorManager::Init(const PredictionConf&amp; config) {
  for (const auto&amp; obstacle_conf : config.obstacle_conf()) {
    if (!obstacle_conf.has_obstacle_type()) {
      ADEBUG &lt;&lt; "Obstacle config [" &lt;&lt; obstacle_conf.ShortDebugString()
             &lt;&lt; "] has not defined obstacle type, status or evaluator type.";
      continue;
    }

    if (obstacle_conf.obstacle_type() == PerceptionObstacle::VEHICLE) {
      if (!obstacle_conf.has_obstacle_status() ||
          !obstacle_conf.has_evaluator_type()) {
        ADEBUG &lt;&lt; "Vehicle obstacle config ["
               &lt;&lt; obstacle_conf.ShortDebugString()
               &lt;&lt; "] has not defined obstacle status and evaluator type.";
        continue;
      } else if (obstacle_conf.obstacle_status() == ObstacleConf::ON_LANE) {
        vehicle_on_lane_evaluator_ = obstacle_conf.evaluator_type();
      }
    }
  }

  AINFO &lt;&lt; "Defined vehicle on lane obstacle evaluator ["
        &lt;&lt; vehicle_on_lane_evaluator_ &lt;&lt; "]";
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\predictor\predictor_manager.cc" startLine="(42, 0)" endLine="(75, 1)" clone_start="1" clone_end="17">
			<code function_name="PredictorManager::Init(const PredictionConf&amp; config)">void PredictorManager::Init(const PredictionConf&amp; config) {
  for (const auto&amp; obstacle_conf : config.obstacle_conf()) {
    if (!obstacle_conf.has_obstacle_type()) {
      ADEBUG &lt;&lt; "Obstacle config [" &lt;&lt; obstacle_conf.ShortDebugString()
             &lt;&lt; "] has not defined obstacle type.";
      continue;
    }

    if (obstacle_conf.obstacle_type() == PerceptionObstacle::VEHICLE) {
      if (!obstacle_conf.has_obstacle_status() ||
          !obstacle_conf.has_predictor_type()) {
        ADEBUG &lt;&lt; "Vehicle obstacle config ["
               &lt;&lt; obstacle_conf.ShortDebugString()
               &lt;&lt; "] has not defined obstacle status or predictor type.";
        continue;
      } else if (obstacle_conf.obstacle_status() == ObstacleConf::ON_LANE) {
        vehicle_on_lane_predictor_ = obstacle_conf.predictor_type();
      } else if (obstacle_conf.obstacle_status() == ObstacleConf::OFF_LANE) {
        vehicle_off_lane_predictor_ = obstacle_conf.predictor_type();
      }
    } else if (obstacle_conf.obstacle_type() ==
               PerceptionObstacle::PEDESTRIAN) {
      pedestrian_predictor_ = obstacle_conf.predictor_type();
    }
  }

  AINFO &lt;&lt; "Defined vehicle on lane obstacle predictor ["
        &lt;&lt; vehicle_on_lane_predictor_ &lt;&lt; "].";
  AINFO &lt;&lt; "Defined vehicle off lane obstacle predictor ["
        &lt;&lt; vehicle_off_lane_predictor_ &lt;&lt; "].";
  AINFO &lt;&lt; "Defined pedestrian obstacle predictor [" &lt;&lt; pedestrian_predictor_
        &lt;&lt; "].";
  AINFO &lt;&lt; "Defined default obstacle predictor [" &lt;&lt; default_predictor_ &lt;&lt; "].";
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\version_7f.cc" startLine="(58, 0)" endLine="(63, 1)" clone_start="5" clone_end="6">
			<code function_name="Version7f::module_name(const std::uint8_t *bytes, int32_t length) const">int32_t Version7f::module_name(const std::uint8_t *bytes,
                               int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 8);
  return x;  // 0x03 means Steering/Shifter, otherwise ignore
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\version_7f.cc" startLine="(65, 0)" endLine="(73, 1)" clone_start="8" clone_end="9">
			<code function_name="Version7f::major_version(const std::uint8_t *bytes, int32_t length) const">int32_t Version7f::major_version(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\version_7f.cc" startLine="(65, 0)" endLine="(73, 1)" clone_start="1" clone_end="9">
			<code function_name="Version7f::major_version(const std::uint8_t *bytes, int32_t length) const">int32_t Version7f::major_version(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\version_7f.cc" startLine="(75, 0)" endLine="(83, 1)" clone_start="1" clone_end="9">
			<code function_name="Version7f::minor_version(const std::uint8_t *bytes, int32_t length) const">int32_t Version7f::minor_version(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\version_7f.cc" startLine="(75, 0)" endLine="(83, 1)" clone_start="1" clone_end="8">
			<code function_name="Version7f::minor_version(const std::uint8_t *bytes, int32_t length) const">int32_t Version7f::minor_version(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\version_7f.cc" startLine="(85, 0)" endLine="(93, 1)" clone_start="1" clone_end="8">
			<code function_name="Version7f::build_number(const std::uint8_t *bytes, int32_t length) const">int32_t Version7f::build_number(const std::uint8_t *bytes,
                                int32_t length) const {
  Byte frame_high(bytes + 7);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 6);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(39, 0)" endLine="(43, 1)" clone_start="1" clone_end="5">
			<code function_name="Accel6b::lateral_acceleration(const std::uint8_t *bytes, const int32_t length) const">double Accel6b::lateral_acceleration(const std::uint8_t *bytes,
                                     const int32_t length) const {
  DCHECK_GE(length, 2);
  return parse_two_frames(bytes[0], bytes[1]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(61, 0)" endLine="(65, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::pedal_input(const std::uint8_t *bytes, int32_t length) const">double Brake61::pedal_input(const std::uint8_t *bytes, int32_t length) const {
  DCHECK_GE(length, 2);
  // Pedal Input from the physical pedal
  return parse_two_frames(bytes[0], bytes[1]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(69, 0)" endLine="(73, 1)" clone_start="1" clone_end="5">
			<code function_name="Wheelspeed6a::front_right_wheel_speed(const std::uint8_t *bytes, int32_t length) const">double Wheelspeed6a::front_right_wheel_speed(const std::uint8_t *bytes,
                                             int32_t length) const {
  DCHECK_GE(length, 4);
  return parse_two_frames(bytes[2], bytes[3]);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(45, 0)" endLine="(49, 1)" clone_start="1" clone_end="5">
			<code function_name="Accel6b::longitudinal_acceleration(const std::uint8_t *bytes, const int32_t length) const">double Accel6b::longitudinal_acceleration(const std::uint8_t *bytes,
                                          const int32_t length) const {
  DCHECK_GE(length, 4);
  return parse_two_frames(bytes[2], bytes[3]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(67, 0)" endLine="(71, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::pedal_cmd(const std::uint8_t *bytes, int32_t length) const">double Brake61::pedal_cmd(const std::uint8_t *bytes, int32_t length) const {
  DCHECK_GE(length, 4);
  // Pedal Command from the command message
  return parse_two_frames(bytes[2], bytes[3]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(75, 0)" endLine="(79, 1)" clone_start="1" clone_end="5">
			<code function_name="Wheelspeed6a::rear_left_wheel_speed(const std::uint8_t *bytes, int32_t length) const">double Wheelspeed6a::rear_left_wheel_speed(const std::uint8_t *bytes,
                                           int32_t length) const {
  DCHECK_GE(length, 6);
  return parse_two_frames(bytes[4], bytes[5]);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(51, 0)" endLine="(55, 1)" clone_start="1" clone_end="5">
			<code function_name="Accel6b::vertical_acceleration(const std::uint8_t *bytes, const int32_t length) const">double Accel6b::vertical_acceleration(const std::uint8_t *bytes,
                                      const int32_t length) const {
  DCHECK_GE(length, 6);
  return parse_two_frames(bytes[4], bytes[5]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(73, 0)" endLine="(77, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::pedal_output(const std::uint8_t *bytes, int32_t length) const">double Brake61::pedal_output(const std::uint8_t *bytes, int32_t length) const {
  DCHECK_GE(length, 6);
  // Pedal Output is the maximum of PI and PC
  return parse_two_frames(bytes[4], bytes[5]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(81, 0)" endLine="(85, 1)" clone_start="1" clone_end="5">
			<code function_name="Wheelspeed6a::rear_right_wheel_speed(const std::uint8_t *bytes, int32_t length) const">double Wheelspeed6a::rear_right_wheel_speed(const std::uint8_t *bytes,
                                            int32_t length) const {
  DCHECK_GE(length, 8);
  return parse_two_frames(bytes[6], bytes[7]);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\accel_6b.cc" startLine="(57, 0)" endLine="(68, 1)" clone_start="1" clone_end="7">
			<code function_name="Accel6b::parse_two_frames(const std::uint8_t low_byte, const std::uint8_t high_byte) const">double Accel6b::parse_two_frames(const std::uint8_t low_byte,
                                 const std::uint8_t high_byte) const {
  Byte high_frame(&amp;high_byte);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(&amp;low_byte);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.010000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(79, 0)" endLine="(90, 1)" clone_start="1" clone_end="7">
			<code function_name="Brake61::parse_two_frames(const std::uint8_t low_byte, const std::uint8_t high_byte) const">double Brake61::parse_two_frames(const std::uint8_t low_byte,
                                 const std::uint8_t high_byte) const {
  Byte frame_high(&amp;high_byte);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(&amp;low_byte);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" startLine="(87, 0)" endLine="(95, 1)" clone_start="1" clone_end="7">
			<code function_name="Wheelspeed6a::parse_two_frames(const std::uint8_t low_byte, const std::uint8_t high_byte) const">double Wheelspeed6a::parse_two_frames(const std::uint8_t low_byte,
                                      const std::uint8_t high_byte) const {
  Byte high_frame(&amp;high_byte);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(&amp;low_byte);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  return value * 0.010000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\lib\velodyne64_parser.cpp" startLine="(53, 0)" endLine="(116, 1)" clone_start="15" clone_end="30">
			<code function_name="Velodyne64Parser::set_base_time_from_packets( const velodyne_msgs::VelodynePacket&amp; pkt)">void Velodyne64Parser::set_base_time_from_packets(
    const velodyne_msgs::VelodynePacket&amp; pkt) {
  const RawPacket* raw = (const RawPacket*)&amp;pkt.data[0];
  StatusType status_type = StatusType(raw-&gt;status_type);
  char status_value = raw-&gt;status_value;

  static int year = -1, month = -1, day = -1, hour = -1, minute = -1,
             second = -1;
  static int gps_status = 0;
  static tm time;

  switch (status_type) {
    case YEAR:
      year = status_value + 2000;
      break;
    case MONTH:
      month = status_value;
      break;
    case DATE:
      day = status_value;
      break;
    case HOURS:
      hour = status_value;
      break;
    case MINUTES:
      minute = status_value;
      break;
    case SECONDS:
      second = status_value;
      break;
    case GPS_STATUS:
      gps_status = status_value;
      break;
    default:
      break;
  }

  ROS_INFO("Get base time from packets. Obtained (%d.%d.%d %d:%d:%d)", year,
           month, day, hour, minute, second);

  if (status_type == GPS_STATUS &amp;&amp; year &gt; 0 &amp;&amp; month &gt; 0 &amp;&amp; day &gt; 0 &amp;&amp;
      hour &gt;= 0 &amp;&amp; minute &gt;= 0 &amp;&amp; second &gt;= 0) {
    if (gps_status != 65) {
      ROS_WARN_STREAM("Sync failed because Velodyne-GPS Sync is NOT good! "
                      &lt;&lt; "Status: " &lt;&lt; (int)gps_status
                      &lt;&lt; " (65 = both; 86 = gps only; 80 = PPS only; 0 "
                      &lt;&lt; "= GPS not connected)");
    }

    time.tm_year = year - 1900;
    time.tm_mon = month - 1;
    time.tm_mday = day;
    time.tm_hour = hour;
    time.tm_min = 0;
    time.tm_sec = 0;

    ROS_INFO("Set base unix time: (%d.%d.%d %d:%d:%d)", time.tm_year,
             time.tm_mon, time.tm_mday, time.tm_hour, time.tm_min, time.tm_sec);
    uint64_t unix_base = static_cast&lt;uint64_t&gt;(timegm(&amp;time));
    for (int i = 0; i &lt; 4; ++i) {
      _gps_base_usec[i] = unix_base * 1000000;
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\lib\velodyne64_parser.cpp" startLine="(53, 0)" endLine="(116, 1)" clone_start="18" clone_end="33">
			<code function_name="Velodyne64Parser::set_base_time_from_packets( const velodyne_msgs::VelodynePacket&amp; pkt)">void Velodyne64Parser::set_base_time_from_packets(
    const velodyne_msgs::VelodynePacket&amp; pkt) {
  const RawPacket* raw = (const RawPacket*)&amp;pkt.data[0];
  StatusType status_type = StatusType(raw-&gt;status_type);
  char status_value = raw-&gt;status_value;

  static int year = -1, month = -1, day = -1, hour = -1, minute = -1,
             second = -1;
  static int gps_status = 0;
  static tm time;

  switch (status_type) {
    case YEAR:
      year = status_value + 2000;
      break;
    case MONTH:
      month = status_value;
      break;
    case DATE:
      day = status_value;
      break;
    case HOURS:
      hour = status_value;
      break;
    case MINUTES:
      minute = status_value;
      break;
    case SECONDS:
      second = status_value;
      break;
    case GPS_STATUS:
      gps_status = status_value;
      break;
    default:
      break;
  }

  ROS_INFO("Get base time from packets. Obtained (%d.%d.%d %d:%d:%d)", year,
           month, day, hour, minute, second);

  if (status_type == GPS_STATUS &amp;&amp; year &gt; 0 &amp;&amp; month &gt; 0 &amp;&amp; day &gt; 0 &amp;&amp;
      hour &gt;= 0 &amp;&amp; minute &gt;= 0 &amp;&amp; second &gt;= 0) {
    if (gps_status != 65) {
      ROS_WARN_STREAM("Sync failed because Velodyne-GPS Sync is NOT good! "
                      &lt;&lt; "Status: " &lt;&lt; (int)gps_status
                      &lt;&lt; " (65 = both; 86 = gps only; 80 = PPS only; 0 "
                      &lt;&lt; "= GPS not connected)");
    }

    time.tm_year = year - 1900;
    time.tm_mon = month - 1;
    time.tm_mday = day;
    time.tm_hour = hour;
    time.tm_min = 0;
    time.tm_sec = 0;

    ROS_INFO("Set base unix time: (%d.%d.%d %d:%d:%d)", time.tm_year,
             time.tm_mon, time.tm_mday, time.tm_hour, time.tm_min, time.tm_sec);
    uint64_t unix_base = static_cast&lt;uint64_t&gt;(timegm(&amp;time));
    for (int i = 0; i &lt; 4; ++i) {
      _gps_base_usec[i] = unix_base * 1000000;
    }
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_range_manager.cc" startLine="(28, 0)" endLine="(52, 1)" clone_start="1" clone_end="23">
			<code function_name="merge_block_range(const TopoNode* topo_node,const std::vector&lt;NodeSRange&gt;&amp; origin_range, std::vector&lt;NodeSRange&gt;* block_range)">void merge_block_range(const TopoNode* topo_node,
                       const std::vector&lt;NodeSRange&gt;&amp; origin_range,
                       std::vector&lt;NodeSRange&gt;* block_range) {
  std::vector&lt;NodeSRange&gt; sorted_origin_range;
  sorted_origin_range.insert(sorted_origin_range.end(), origin_range.begin(),
                             origin_range.end());
  sort(sorted_origin_range.begin(), sorted_origin_range.end());
  int cur_index = 0;
  int total_size = sorted_origin_range.size();
  while (cur_index &lt; total_size) {
    NodeSRange range(sorted_origin_range[cur_index]);
    ++cur_index;
    while (cur_index &lt; total_size &amp;&amp;
           range.MergeRangeOverlap(sorted_origin_range[cur_index])) {
      ++cur_index;
    }
    if (range.EndS() &lt; topo_node-&gt;StartS() ||
        range.StartS() &gt; topo_node-&gt;EndS()) {
      continue;
    }
    range.SetStartS(std::max(topo_node-&gt;StartS(), range.StartS()));
    range.SetEndS(std::min(topo_node-&gt;EndS(), range.EndS()));
    block_range-&gt;push_back(std::move(range));
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\sub_topo_graph.cc" startLine="(41, 0)" endLine="(65, 1)" clone_start="1" clone_end="23">
			<code function_name="MergeBlockRange(const TopoNode* topo_node,const std::vector&lt;NodeSRange&gt;&amp; origin_range, std::vector&lt;NodeSRange&gt;* block_range)">void MergeBlockRange(const TopoNode* topo_node,
                     const std::vector&lt;NodeSRange&gt;&amp; origin_range,
                     std::vector&lt;NodeSRange&gt;* block_range) {
  std::vector&lt;NodeSRange&gt; sorted_origin_range;
  sorted_origin_range.insert(sorted_origin_range.end(), origin_range.begin(),
                             origin_range.end());
  sort(sorted_origin_range.begin(), sorted_origin_range.end());
  int cur_index = 0;
  int total_size = sorted_origin_range.size();
  while (cur_index &lt; total_size) {
    NodeSRange range(sorted_origin_range[cur_index]);
    ++cur_index;
    while (cur_index &lt; total_size &amp;&amp;
           range.MergeRangeOverlap(sorted_origin_range[cur_index])) {
      ++cur_index;
    }
    if (range.EndS() &lt; topo_node-&gt;StartS() ||
        range.StartS() &gt; topo_node-&gt;EndS()) {
      continue;
    }
    range.SetStartS(std::max(topo_node-&gt;StartS(), range.StartS()));
    range.SetEndS(std::min(topo_node-&gt;EndS(), range.EndS()));
    block_range-&gt;push_back(std::move(range));
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(116, 0)" endLine="(140, 1)" clone_start="24" clone_end="25">
			<code function_name="SignalsXmlParser::ToPbSignalType(const std::string&amp; xml_type, PbSignalType* signal_type)">Status SignalsXmlParser::ToPbSignalType(const std::string&amp; xml_type,
                                        PbSignalType* signal_type) {
  CHECK_NOTNULL(signal_type);

  std::string upper_str = UtilXmlParser::ToUpper(xml_type);

  if (upper_str == "UNKNOWN") {
    *signal_type = hdmap::Signal::UNKNOWN;
  } else if (upper_str == "MIX2HORIZONTAL") {
    *signal_type = hdmap::Signal::MIX_2_HORIZONTAL;
  } else if (upper_str == "MIX2VERTICAL") {
    *signal_type = hdmap::Signal::MIX_2_VERTICAL;
  } else if (upper_str == "MIX3HORIZONTAL") {
    *signal_type = hdmap::Signal::MIX_3_HORIZONTAL;
  } else if (upper_str == "MIX3VERTICAL") {
    *signal_type = hdmap::Signal::MIX_3_VERTICAL;
  } else if (upper_str == "SINGLE") {
    *signal_type = hdmap::Signal::SINGLE;
  } else {
    std::string err_msg = "Error or unsupport signal layout type";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(26, 0)" endLine="(114, 1)" clone_start="88" clone_end="89">
			<code function_name="SignalsXmlParser::ParseTrafficLights(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;TrafficLightInternal&gt;* traffic_lights)">Status SignalsXmlParser::ParseTrafficLights(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;TrafficLightInternal&gt;* traffic_lights) {
  CHECK_NOTNULL(traffic_lights);
  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "trafficLight") {
      PbSignal traffic_light;
      traffic_light.mutable_id()-&gt;set_id(object_id);
      std::string layout_type;
      int checker = UtilXmlParser::QueryStringAttribute(
          *signal_node, "layoutType", &amp;layout_type);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse signal layout type.";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      PbSignalType signal_layout_type;
      ToPbSignalType(layout_type, &amp;signal_layout_type);
      traffic_light.set_type(signal_layout_type);

      PbPolygon* polygon = traffic_light.mutable_boundary();
      auto outline_node = signal_node-&gt;FirstChildElement("outline");
      if (outline_node == nullptr) {
        std::string err_msg = "Error parse signal outline";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseOutline(*outline_node, polygon));
      auto sub_node = signal_node-&gt;FirstChildElement("subSignal");
      if (sub_node == nullptr) {
        std::string err_msg = "Error parse sub signal.";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      while (sub_node) {
        std::string sub_signal_id;
        std::string sub_signal_xml_type;
        checker = UtilXmlParser::QueryStringAttribute(*sub_node, "type",
                                                      &amp;sub_signal_xml_type);
        checker += UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                       &amp;sub_signal_id);
        if (checker != tinyxml2::XML_SUCCESS) {
          std::string err_msg = "Error parse sub signal layout type.";
          return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
        }

        PbSubSignal* sub_signal = traffic_light.add_subsignal();
        PbSubSignalType sub_signal_type;
        ToPbSubSignalType(sub_signal_xml_type, &amp;sub_signal_type);
        sub_signal-&gt;mutable_id()-&gt;set_id(sub_signal_id);
        sub_signal-&gt;set_type(sub_signal_type);
        PbPoint3D* pt = sub_signal-&gt;mutable_location();
        RETURN_IF_ERROR(UtilXmlParser::ParsePoint(*sub_node, pt));

        sub_node = sub_node-&gt;NextSiblingElement("subSignal");
      }

      TrafficLightInternal trafficlight_internal;
      trafficlight_internal.id = object_id;
      trafficlight_internal.traffic_light = traffic_light;

      sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                            &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          trafficlight_internal.stop_line_ids.insert(stop_line_id);
          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      traffic_lights-&gt;emplace_back(trafficlight_internal);
    }
    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(142, 0)" endLine="(169, 1)" clone_start="1" clone_end="18">
			<code function_name="SignalsXmlParser::ToPbSubSignalType(const std::string&amp; xml_type, PbSubSignalType* sub_signal_type)">Status SignalsXmlParser::ToPbSubSignalType(const std::string&amp; xml_type,
                                           PbSubSignalType* sub_signal_type) {
  CHECK_NOTNULL(sub_signal_type);

  std::string upper_str = UtilXmlParser::ToUpper(xml_type);

  if (upper_str == "UNKNOWN") {
    *sub_signal_type = hdmap::Subsignal::UNKNOWN;
  } else if (upper_str == "CIRCLE") {
    *sub_signal_type = hdmap::Subsignal::CIRCLE;
  } else if (upper_str == "ARROWLEFT") {
    *sub_signal_type = hdmap::Subsignal::ARROW_LEFT;
  } else if (upper_str == "ARROWFORWARD") {
    *sub_signal_type = hdmap::Subsignal::ARROW_FORWARD;
  } else if (upper_str == "ARROWRIGHT") {
    *sub_signal_type = hdmap::Subsignal::ARROW_RIGHT;
  } else if (upper_str == "ARROWLEFTANDFORWARD") {
    *sub_signal_type = hdmap::Subsignal::ARROW_LEFT_AND_FORWARD;
  } else if (upper_str == "ARROWRIGHTANDFORWARD") {
    *sub_signal_type = hdmap::Subsignal::ARROW_RIGHT_AND_FORWARD;
  } else if (upper_str == "ARROWUTURN") {
    *sub_signal_type = hdmap::Subsignal::ARROW_U_TURN;
  } else {
    std::string err_msg = "Error or unsupport sub signal type";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(116, 0)" endLine="(140, 1)" clone_start="1" clone_end="18">
			<code function_name="SignalsXmlParser::ToPbSignalType(const std::string&amp; xml_type, PbSignalType* signal_type)">Status SignalsXmlParser::ToPbSignalType(const std::string&amp; xml_type,
                                        PbSignalType* signal_type) {
  CHECK_NOTNULL(signal_type);

  std::string upper_str = UtilXmlParser::ToUpper(xml_type);

  if (upper_str == "UNKNOWN") {
    *signal_type = hdmap::Signal::UNKNOWN;
  } else if (upper_str == "MIX2HORIZONTAL") {
    *signal_type = hdmap::Signal::MIX_2_HORIZONTAL;
  } else if (upper_str == "MIX2VERTICAL") {
    *signal_type = hdmap::Signal::MIX_2_VERTICAL;
  } else if (upper_str == "MIX3HORIZONTAL") {
    *signal_type = hdmap::Signal::MIX_3_HORIZONTAL;
  } else if (upper_str == "MIX3VERTICAL") {
    *signal_type = hdmap::Signal::MIX_3_VERTICAL;
  } else if (upper_str == "SINGLE") {
    *signal_type = hdmap::Signal::SINGLE;
  } else {
    std::string err_msg = "Error or unsupport signal layout type";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(344, 0)" endLine="(391, 1)" clone_start="14" clone_end="34">
			<code function_name="LincolnController::Gear(Chassis::GearPosition gear_position)">void LincolnController::Gear(Chassis::GearPosition gear_position) {
  if (!(driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
        driving_mode() == Chassis::AUTO_SPEED_ONLY)) {
    AINFO &lt;&lt; "this drive mode no need to set gear.";
    return;
  }
  // enable steering to enable shifting
  // actually, if we wanna shift from parking
  // to some other state
  // we need to apply a brake
  // which needs to be done by human or
  // some canbus cmd
  switch (gear_position) {
    case Chassis::GEAR_NEUTRAL: {
      gear_66_-&gt;set_gear_neutral();
      break;
    }
    case Chassis::GEAR_REVERSE: {
      gear_66_-&gt;set_gear_reverse();
      break;
    }
    case Chassis::GEAR_DRIVE: {
      gear_66_-&gt;set_gear_drive();
      break;
    }
    case Chassis::GEAR_PARKING: {
      gear_66_-&gt;set_gear_park();
      break;
    }
    case Chassis::GEAR_LOW: {
      gear_66_-&gt;set_gear_low();
      break;
    }
    case Chassis::GEAR_NONE: {
      gear_66_-&gt;set_gear_none();
      break;
    }
    case Chassis::GEAR_INVALID: {
      AERROR &lt;&lt; "Gear command is invalid!";
      gear_66_-&gt;set_gear_none();
      break;
    }
    default: {
      gear_66_-&gt;set_gear_none();
      break;
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(344, 0)" endLine="(391, 1)" clone_start="18" clone_end="38">
			<code function_name="LincolnController::Gear(Chassis::GearPosition gear_position)">void LincolnController::Gear(Chassis::GearPosition gear_position) {
  if (!(driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
        driving_mode() == Chassis::AUTO_SPEED_ONLY)) {
    AINFO &lt;&lt; "this drive mode no need to set gear.";
    return;
  }
  // enable steering to enable shifting
  // actually, if we wanna shift from parking
  // to some other state
  // we need to apply a brake
  // which needs to be done by human or
  // some canbus cmd
  switch (gear_position) {
    case Chassis::GEAR_NEUTRAL: {
      gear_66_-&gt;set_gear_neutral();
      break;
    }
    case Chassis::GEAR_REVERSE: {
      gear_66_-&gt;set_gear_reverse();
      break;
    }
    case Chassis::GEAR_DRIVE: {
      gear_66_-&gt;set_gear_drive();
      break;
    }
    case Chassis::GEAR_PARKING: {
      gear_66_-&gt;set_gear_park();
      break;
    }
    case Chassis::GEAR_LOW: {
      gear_66_-&gt;set_gear_low();
      break;
    }
    case Chassis::GEAR_NONE: {
      gear_66_-&gt;set_gear_none();
      break;
    }
    case Chassis::GEAR_INVALID: {
      AERROR &lt;&lt; "Gear command is invalid!";
      gear_66_-&gt;set_gear_none();
      break;
    }
    default: {
      gear_66_-&gt;set_gear_none();
      break;
    }
  }
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(48, 0)" endLine="(58, 1)" clone_start="1" clone_end="11">
			<code function_name="ObjectTrack::SetTrackCachedHistorySizeMaximum( const int&amp; track_cached_history_size_maximum)">bool ObjectTrack::SetTrackCachedHistorySizeMaximum(
    const int&amp; track_cached_history_size_maximum) {
  if (track_cached_history_size_maximum &gt; 0) {
    s_track_cached_history_size_maximum_ = track_cached_history_size_maximum;
    AINFO &lt;&lt; "track cached history size maximum of object track is "
          &lt;&lt; s_track_cached_history_size_maximum_;
    return true;
  }
  AERROR &lt;&lt; "invalid track cached history size maximum of object track!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(60, 0)" endLine="(69, 1)" clone_start="1" clone_end="10">
			<code function_name="ObjectTrack::SetSpeedNoiseMaximum(const double&amp; speed_noise_maximum)">bool ObjectTrack::SetSpeedNoiseMaximum(const double&amp; speed_noise_maximum) {
  if (speed_noise_maximum &gt; 0) {
    s_speed_noise_maximum_ = speed_noise_maximum;
    AINFO &lt;&lt; "speed noise maximum of object track is "
          &lt;&lt; s_speed_noise_maximum_;
    return true;
  }
  AERROR &lt;&lt; "invalid speed noise maximum of object track!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\kalman_filter.cc" startLine="(38, 0)" endLine="(48, 1)" clone_start="1" clone_end="11">
			<code function_name="KalmanFilter::SetAssociationScoreMaximum( const double&amp; association_score_maximum)">bool KalmanFilter::SetAssociationScoreMaximum(
  const double&amp; association_score_maximum) {
  if (association_score_maximum &gt; 0) {
    s_association_score_maximum_ = association_score_maximum;
    AINFO &lt;&lt; "association score maximum of KalmanFilter is "
          &lt;&lt; s_association_score_maximum_;
    return true;
  }
  AERROR &lt;&lt; "invalid association score maximum of KalmanFilter!";
  return false;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(60, 0)" endLine="(69, 1)" clone_start="1" clone_end="9">
			<code function_name="ObjectTrack::SetSpeedNoiseMaximum(const double&amp; speed_noise_maximum)">bool ObjectTrack::SetSpeedNoiseMaximum(const double&amp; speed_noise_maximum) {
  if (speed_noise_maximum &gt; 0) {
    s_speed_noise_maximum_ = speed_noise_maximum;
    AINFO &lt;&lt; "speed noise maximum of object track is "
          &lt;&lt; s_speed_noise_maximum_;
    return true;
  }
  AERROR &lt;&lt; "invalid speed noise maximum of object track!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(71, 0)" endLine="(81, 1)" clone_start="1" clone_end="10">
			<code function_name="ObjectTrack::SetAccelerationNoiseMaximum( const double&amp; acceleration_noise_maximum)">bool ObjectTrack::SetAccelerationNoiseMaximum(
    const double&amp; acceleration_noise_maximum) {
  if (acceleration_noise_maximum &gt; 0) {
    s_acceleration_noise_maximum_ = acceleration_noise_maximum;
    AINFO &lt;&lt; "acceleration noise maximum of object track is "
          &lt;&lt; s_acceleration_noise_maximum_;
    return true;
  }
  AERROR &lt;&lt; "invalid acceleration noise maximum of object track!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\kalman_filter.cc" startLine="(50, 0)" endLine="(60, 1)" clone_start="1" clone_end="10">
			<code function_name="KalmanFilter::SetBreakdownThresholdMaximum( const double&amp; breakdown_threshold_maximum)">bool KalmanFilter::SetBreakdownThresholdMaximum(
  const double&amp; breakdown_threshold_maximum) {
  if (breakdown_threshold_maximum &gt; 0) {
    s_breakdown_threshold_maximum_ = breakdown_threshold_maximum;
    AINFO &lt;&lt; "breakdown threshold maximum of KalmanFilter is "
          &lt;&lt; s_breakdown_threshold_maximum_;
    return true;
  }
  AERROR &lt;&lt; "invalid breakdown threshold maximum of KalmanFilter!";
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(195, 0)" endLine="(226, 1)" clone_start="7" clone_end="26">
			<code function_name="ProtoOrganizer::GetLaneJunctionOverlapElements(    const std::string&amp; lane_id, const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes)">void ProtoOrganizer::GetLaneJunctionOverlapElements(
    const std::string&amp; lane_id,
    const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes) {
  for (auto&amp; overlap_junction : overlap_with_lanes) {
    std::string object_id = overlap_junction.object_id;
    if (proto_data_.pb_junctions.count(object_id) &lt;= 0) {
      AINFO &lt;&lt; "cannot find junction object " &lt;&lt; object_id;
      continue;
    }
    PbOverlap overlap;
    std::string overlap_id = CreateOverlapId();
    proto_data_.pb_lanes[lane_id].add_overlap_id()-&gt;set_id(overlap_id);
    overlap.mutable_id()-&gt;set_id(overlap_id);
    PbObjectOverlapInfo* object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(lane_id);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_start_s(
        overlap_junction.start_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_end_s(
        overlap_junction.end_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_is_merge(
        overlap_junction.is_merge);
    object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
    if (proto_data_.pb_junctions.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_junction_overlap_info();
      proto_data_.pb_junctions[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    } else {
      AERROR &lt;&lt; "unknown junction overlap, id:" &lt;&lt; object_id;
    }
    proto_data_.pb_overlaps[overlap_id] = overlap;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(153, 0)" endLine="(193, 1)" clone_start="9" clone_end="28">
			<code function_name="ProtoOrganizer::GetLaneSignalOverlapElements(    const std::string&amp; lane_id, const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes)">void ProtoOrganizer::GetLaneSignalOverlapElements(
    const std::string&amp; lane_id,
    const std::vector&lt;OverlapWithLane&gt;&amp; overlap_with_lanes) {
  for (auto&amp; overlap_signal : overlap_with_lanes) {
    std::string object_id = overlap_signal.object_id;
    if (proto_data_.pb_signals.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_stop_signs.count(object_id) &lt;= 0 &amp;&amp;
        proto_data_.pb_yield_signs.count(object_id) &lt;= 0) {
      AINFO &lt;&lt; "cannot find signal object_id:" &lt;&lt; object_id;
      continue;
    }
    PbOverlap overlap;
    std::string overlap_id = CreateOverlapId();
    proto_data_.pb_lanes[lane_id].add_overlap_id()-&gt;set_id(overlap_id);
    overlap.mutable_id()-&gt;set_id(overlap_id);
    PbObjectOverlapInfo* object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(lane_id);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_start_s(
        overlap_signal.start_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_end_s(
        overlap_signal.end_s);
    object_overlap-&gt;mutable_lane_overlap_info()-&gt;set_is_merge(
        overlap_signal.is_merge);
    object_overlap = overlap.add_object();
    object_overlap-&gt;mutable_id()-&gt;set_id(object_id);
    if (proto_data_.pb_signals.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_signal_overlap_info();
      proto_data_.pb_signals[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    } else if (proto_data_.pb_stop_signs.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_stop_sign_overlap_info();
      proto_data_.pb_stop_signs[object_id].add_overlap_id()-&gt;set_id(overlap_id);
    } else if (proto_data_.pb_yield_signs.count(object_id) &gt; 0) {
      object_overlap-&gt;mutable_yield_sign_overlap_info();
      proto_data_.pb_yield_signs[object_id].add_overlap_id()-&gt;set_id(
          overlap_id);
    } else {
      AERROR &lt;&lt; "unknown signal, signal id:" &lt;&lt; object_id;
    }
    proto_data_.pb_overlaps[overlap_id] = overlap;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(88, 0)" endLine="(94, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline2d::second_derivative_y(const double t) const">double Spline2d::second_derivative_y(const double t) const {
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = find_index(t);
  return splines_[index].second_derivative_y(t - t_knots_[index]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d.cc" startLine="(48, 0)" endLine="(55, 1)" clone_start="1" clone_end="8">
			<code function_name="Spline1d::Derivative(const double x) const">double Spline1d::Derivative(const double x) const {
  // zero order spline
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = FindIndex(x);
  return splines_[index].Derivative(x - x_knots_[index]);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(96, 0)" endLine="(102, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline2d::ThirdDerivativeX(const double t) const">double Spline2d::ThirdDerivativeX(const double t) const {
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = find_index(t);
  return splines_[index].ThirdDerivativeX(t - t_knots_[index]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d.cc" startLine="(57, 0)" endLine="(63, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline1d::SecondOrderDerivative(const double x) const">double Spline1d::SecondOrderDerivative(const double x) const {
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = FindIndex(x);
  return splines_[index].SecondOrderDerivative(x - x_knots_[index]);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(104, 0)" endLine="(110, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline2d::third_derivative_y(const double t) const">double Spline2d::third_derivative_y(const double t) const {
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = find_index(t);
  return splines_[index].third_derivative_y(t - t_knots_[index]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d.cc" startLine="(65, 0)" endLine="(71, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline1d::ThirdOrderDerivative(const double x) const">double Spline1d::ThirdOrderDerivative(const double x) const {
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = FindIndex(x);
  return splines_[index].ThirdOrderDerivative(x - x_knots_[index]);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(114, 0)" endLine="(132, 1)" clone_start="1" clone_end="1">
			<code function_name="Spline2d::set_splines(const Eigen::MatrixXd&amp; params, const std::uint32_t order)">bool Spline2d::set_splines(const Eigen::MatrixXd&amp; params,
                           const std::uint32_t order) {
  // check if the parameter size fit
  if (2 * t_knots_.size() * order !=
      2 * order + static_cast&lt;std::uint32_t&gt;(params.rows())) {
    return false;
  }
  for (std::uint32_t i = 0; i &lt; splines_.size(); ++i) {
    std::vector&lt;double&gt; spline_piece_x(order, 0.0);
    std::vector&lt;double&gt; spline_piece_y(order, 0.0);
    for (std::uint32_t j = 0; j &lt; order; ++j) {
      spline_piece_x[j] = params(2 * i * order + j, 0);
      spline_piece_y[j] = params((2 * i + 1) * order + j, 0);
    }
    splines_[i].SetParams(spline_piece_x, spline_piece_y);
  }
  spline_order_ = order;
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d.cc" startLine="(73, 0)" endLine="(89, 1)" clone_start="1" clone_end="1">
			<code function_name="Spline1d::SetSplineSegs(const Eigen::MatrixXd&amp; params, const std::uint32_t order)">bool Spline1d::SetSplineSegs(const Eigen::MatrixXd&amp; params,
                             const std::uint32_t order) {
  // check if the parameter size fit
  if (x_knots_.size() * order !=
      order + static_cast&lt;std::uint32_t&gt;(params.rows())) {
    return false;
  }
  for (std::uint32_t i = 0; i &lt; splines_.size(); ++i) {
    std::vector&lt;double&gt; spline_piece(order, 0.0);
    for (std::uint32_t j = 0; j &lt; order; ++j) {
      spline_piece[j] = params(i * order + j, 0);
    }
    splines_[i].SetParams(spline_piece);
  }
  spline_order_ = order;
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(45, 0)" endLine="(116, 1)" clone_start="34" clone_end="58">
			<code function_name="LincolnController::Init(const VehicleParameter &amp;params,CanSender *const can_sender, MessageManager *const message_manager)">ErrorCode LincolnController::Init(const VehicleParameter &amp;params,
                                  CanSender *const can_sender,
                                  MessageManager *const message_manager) {
  if (is_initialized_) {
    AINFO &lt;&lt; "LincolnController has already been initiated.";
    return ErrorCode::CANBUS_ERROR;
  }

  params_.CopyFrom(params);
  if (!params_.has_driving_mode()) {
    AERROR &lt;&lt; "Vehicle conf pb not set driving_mode.";
    return ErrorCode::CANBUS_ERROR;
  }

  if (can_sender == nullptr) {
    return ErrorCode::CANBUS_ERROR;
  }
  can_sender_ = can_sender;

  if (message_manager == nullptr) {
    AERROR &lt;&lt; "protocol manager is null.";
    return ErrorCode::CANBUS_ERROR;
  }
  message_manager_ = message_manager;

  // sender part
  brake_60_ = dynamic_cast&lt;Brake60 *&gt;(
      message_manager_-&gt;GetMutableProtocolDataById(Brake60::ID));
  if (brake_60_ == nullptr) {
    AERROR &lt;&lt; "Brake60 does not exist in the LincolnMessageManager!";
    return ErrorCode::CANBUS_ERROR;
  }

  throttle_62_ = dynamic_cast&lt;Throttle62 *&gt;(
      message_manager_-&gt;GetMutableProtocolDataById(Throttle62::ID));
  if (throttle_62_ == nullptr) {
    AERROR &lt;&lt; "Throttle62 does not exist in the LincolnMessageManager!";
    return ErrorCode::CANBUS_ERROR;
  }

  steering_64_ = dynamic_cast&lt;Steering64 *&gt;(
      message_manager_-&gt;GetMutableProtocolDataById(Steering64::ID));
  if (steering_64_ == nullptr) {
    AERROR &lt;&lt; "Steering64 does not exist in the LincolnMessageManager!";
    return ErrorCode::CANBUS_ERROR;
  }

  gear_66_ = dynamic_cast&lt;Gear66 *&gt;(
      message_manager_-&gt;GetMutableProtocolDataById(Gear66::ID));
  if (gear_66_ == nullptr) {
    AERROR &lt;&lt; "Gear66 does not exist in the LincolnMessageManager!";
    return ErrorCode::CANBUS_ERROR;
  }
  turnsignal_68_ = dynamic_cast&lt;Turnsignal68 *&gt;(
      message_manager_-&gt;GetMutableProtocolDataById(Turnsignal68::ID));
  if (turnsignal_68_ == nullptr) {
    AERROR &lt;&lt; "Turnsignal68 does not exist in the LincolnMessageManager!";
    return ErrorCode::CANBUS_ERROR;
  }

  can_sender_-&gt;AddMessage(Brake60::ID, brake_60_, false);
  can_sender_-&gt;AddMessage(Throttle62::ID, throttle_62_, false);
  can_sender_-&gt;AddMessage(Steering64::ID, steering_64_, false);
  can_sender_-&gt;AddMessage(Gear66::ID, gear_66_, false);
  can_sender_-&gt;AddMessage(Turnsignal68::ID, turnsignal_68_, false);

  // need sleep to ensure all messages received
  AINFO &lt;&lt; "Controller is initialized.";

  is_initialized_ = true;
  return ErrorCode::OK;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(45, 0)" endLine="(116, 1)" clone_start="27" clone_end="52">
			<code function_name="LincolnController::Init(const VehicleParameter &amp;params,CanSender *const can_sender, MessageManager *const message_manager)">ErrorCode LincolnController::Init(const VehicleParameter &amp;params,
                                  CanSender *const can_sender,
                                  MessageManager *const message_manager) {
  if (is_initialized_) {
    AINFO &lt;&lt; "LincolnController has already been initiated.";
    return ErrorCode::CANBUS_ERROR;
  }

  params_.CopyFrom(params);
  if (!params_.has_driving_mode()) {
    AERROR &lt;&lt; "Vehicle conf pb not set driving_mode.";
    return ErrorCode::CANBUS_ERROR;
  }

  if (can_sender == nullptr) {
    return ErrorCode::CANBUS_ERROR;
  }
  can_sender_ = can_sender;

  if (message_manager == nullptr) {
    AERROR &lt;&lt; "protocol manager is null.";
    return ErrorCode::CANBUS_ERROR;
  }
  message_manager_ = message_manager;

  // sender part
  brake_60_ = dynamic_cast&lt;Brake60 *&gt;(
      message_manager_-&gt;GetMutableProtocolDataById(Brake60::ID));
  if (brake_60_ == nullptr) {
    AERROR &lt;&lt; "Brake60 does not exist in the LincolnMessageManager!";
    return ErrorCode::CANBUS_ERROR;
  }

  throttle_62_ = dynamic_cast&lt;Throttle62 *&gt;(
      message_manager_-&gt;GetMutableProtocolDataById(Throttle62::ID));
  if (throttle_62_ == nullptr) {
    AERROR &lt;&lt; "Throttle62 does not exist in the LincolnMessageManager!";
    return ErrorCode::CANBUS_ERROR;
  }

  steering_64_ = dynamic_cast&lt;Steering64 *&gt;(
      message_manager_-&gt;GetMutableProtocolDataById(Steering64::ID));
  if (steering_64_ == nullptr) {
    AERROR &lt;&lt; "Steering64 does not exist in the LincolnMessageManager!";
    return ErrorCode::CANBUS_ERROR;
  }

  gear_66_ = dynamic_cast&lt;Gear66 *&gt;(
      message_manager_-&gt;GetMutableProtocolDataById(Gear66::ID));
  if (gear_66_ == nullptr) {
    AERROR &lt;&lt; "Gear66 does not exist in the LincolnMessageManager!";
    return ErrorCode::CANBUS_ERROR;
  }
  turnsignal_68_ = dynamic_cast&lt;Turnsignal68 *&gt;(
      message_manager_-&gt;GetMutableProtocolDataById(Turnsignal68::ID));
  if (turnsignal_68_ == nullptr) {
    AERROR &lt;&lt; "Turnsignal68 does not exist in the LincolnMessageManager!";
    return ErrorCode::CANBUS_ERROR;
  }

  can_sender_-&gt;AddMessage(Brake60::ID, brake_60_, false);
  can_sender_-&gt;AddMessage(Throttle62::ID, throttle_62_, false);
  can_sender_-&gt;AddMessage(Steering64::ID, steering_64_, false);
  can_sender_-&gt;AddMessage(Gear66::ID, gear_66_, false);
  can_sender_-&gt;AddMessage(Turnsignal68::ID, turnsignal_68_, false);

  // need sleep to ensure all messages received
  AINFO &lt;&lt; "Controller is initialized.";

  is_initialized_ = true;
  return ErrorCode::OK;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(171, 0)" endLine="(214, 1)" clone_start="1" clone_end="21">
			<code function_name="SignalsXmlParser::ParseStopSigns(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;StopSignInternal&gt;* stop_signs)">Status SignalsXmlParser::ParseStopSigns(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;StopSignInternal&gt;* stop_signs) {
  CHECK_NOTNULL(stop_signs);

  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "stopSign") {
      PbStopSign stop_sign;
      stop_sign.mutable_id()-&gt;set_id(object_id);

      StopSignInternal stop_sign_internal;
      stop_sign_internal.stop_sign = stop_sign;

      auto sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          stop_sign_internal.stop_line_ids.insert(stop_line_id);

          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      stop_signs-&gt;emplace_back(stop_sign_internal);
    }

    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(216, 0)" endLine="(259, 1)" clone_start="1" clone_end="21">
			<code function_name="SignalsXmlParser::ParseYieldSigns(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;YieldSignInternal&gt;* yield_signs)">Status SignalsXmlParser::ParseYieldSigns(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;YieldSignInternal&gt;* yield_signs) {
  CHECK_NOTNULL(yield_signs);

  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "yieldSign") {
      PbYieldSign yield_sign;
      yield_sign.mutable_id()-&gt;set_id(object_id);
      YieldSignInternal yield_sign_internal;
      yield_sign_internal.id = object_id;
      yield_sign_internal.yield_sign = yield_sign;
      auto sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                            &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          yield_sign_internal.stop_line_ids.insert(stop_line_id);

          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      yield_signs-&gt;emplace_back(yield_sign_internal);
    }

    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(26, 0)" endLine="(114, 1)" clone_start="1" clone_end="20">
			<code function_name="SignalsXmlParser::ParseTrafficLights(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;TrafficLightInternal&gt;* traffic_lights)">Status SignalsXmlParser::ParseTrafficLights(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;TrafficLightInternal&gt;* traffic_lights) {
  CHECK_NOTNULL(traffic_lights);
  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "trafficLight") {
      PbSignal traffic_light;
      traffic_light.mutable_id()-&gt;set_id(object_id);
      std::string layout_type;
      int checker = UtilXmlParser::QueryStringAttribute(
          *signal_node, "layoutType", &amp;layout_type);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse signal layout type.";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      PbSignalType signal_layout_type;
      ToPbSignalType(layout_type, &amp;signal_layout_type);
      traffic_light.set_type(signal_layout_type);

      PbPolygon* polygon = traffic_light.mutable_boundary();
      auto outline_node = signal_node-&gt;FirstChildElement("outline");
      if (outline_node == nullptr) {
        std::string err_msg = "Error parse signal outline";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseOutline(*outline_node, polygon));
      auto sub_node = signal_node-&gt;FirstChildElement("subSignal");
      if (sub_node == nullptr) {
        std::string err_msg = "Error parse sub signal.";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      while (sub_node) {
        std::string sub_signal_id;
        std::string sub_signal_xml_type;
        checker = UtilXmlParser::QueryStringAttribute(*sub_node, "type",
                                                      &amp;sub_signal_xml_type);
        checker += UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                       &amp;sub_signal_id);
        if (checker != tinyxml2::XML_SUCCESS) {
          std::string err_msg = "Error parse sub signal layout type.";
          return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
        }

        PbSubSignal* sub_signal = traffic_light.add_subsignal();
        PbSubSignalType sub_signal_type;
        ToPbSubSignalType(sub_signal_xml_type, &amp;sub_signal_type);
        sub_signal-&gt;mutable_id()-&gt;set_id(sub_signal_id);
        sub_signal-&gt;set_type(sub_signal_type);
        PbPoint3D* pt = sub_signal-&gt;mutable_location();
        RETURN_IF_ERROR(UtilXmlParser::ParsePoint(*sub_node, pt));

        sub_node = sub_node-&gt;NextSiblingElement("subSignal");
      }

      TrafficLightInternal trafficlight_internal;
      trafficlight_internal.id = object_id;
      trafficlight_internal.traffic_light = traffic_light;

      sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                            &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          trafficlight_internal.stop_line_ids.insert(stop_line_id);
          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      traffic_lights-&gt;emplace_back(trafficlight_internal);
    }
    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="4">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(511, 0)" endLine="(551, 1)" clone_start="15" clone_end="40">
			<code function_name="LanesXmlParser::ParseLaneOverlapGroup(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;OverlapWithLane&gt;* lane_overlaps)">Status LanesXmlParser::ParseLaneOverlapGroup(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;OverlapWithLane&gt;* lane_overlaps) {
  CHECK_NOTNULL(lane_overlaps);

  auto overlap_node = xml_node.FirstChildElement("laneOverlapGroup");
  if (overlap_node) {
    auto sub_node = overlap_node-&gt;FirstChildElement("laneReference");
    while (sub_node) {
      std::string lane_id;
      double start_s = 0.0;
      double end_s = 0.0;
      int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                   &amp;lane_id);
      checker += sub_node-&gt;QueryDoubleAttribute("startOffset", &amp;start_s);
      checker += sub_node-&gt;QueryDoubleAttribute("endOffset", &amp;end_s);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse lane lane overlap";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      bool is_merge = false;
      checker = sub_node-&gt;QueryBoolAttribute("isMerge", &amp;is_merge);
      if (checker != tinyxml2::XML_SUCCESS) {
        is_merge = false;
      }

      OverlapWithLane overlap_with_lane;
      overlap_with_lane.object_id = lane_id;
      overlap_with_lane.start_s = start_s;
      overlap_with_lane.end_s = end_s;
      overlap_with_lane.is_merge = is_merge;

      lane_overlaps-&gt;push_back(overlap_with_lane);

      sub_node = sub_node-&gt;NextSiblingElement("laneReference");
    }
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(470, 0)" endLine="(509, 1)" clone_start="15" clone_end="39">
			<code function_name="LanesXmlParser::ParseJunctionOverlapGroup(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;OverlapWithLane&gt;* junction_overlaps)">Status LanesXmlParser::ParseJunctionOverlapGroup(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;OverlapWithLane&gt;* junction_overlaps) {
  CHECK_NOTNULL(junction_overlaps);

  auto overlap_group = xml_node.FirstChildElement("junctionOverlapGroup");
  if (overlap_group) {
    auto sub_node = overlap_group-&gt;FirstChildElement("junctionReference");
    while (sub_node) {
      std::string object_id;
      double start_s = 0.0;
      double end_s = 0.0;
      int checker =
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
      checker += sub_node-&gt;QueryDoubleAttribute("startOffset", &amp;start_s);
      checker += sub_node-&gt;QueryDoubleAttribute("endOffset", &amp;end_s);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse lane junction overlap";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      bool is_merge = false;
      checker = sub_node-&gt;QueryBoolAttribute("isMerge", &amp;is_merge);
      if (checker != tinyxml2::XML_SUCCESS) {
        is_merge = false;
      }

      OverlapWithLane overlap_with_lane;
      overlap_with_lane.object_id = object_id;
      overlap_with_lane.start_s = start_s;
      overlap_with_lane.end_s = end_s;
      overlap_with_lane.is_merge = is_merge;

      junction_overlaps-&gt;push_back(overlap_with_lane);

      sub_node = sub_node-&gt;NextSiblingElement("junctionReference");
    }
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(429, 0)" endLine="(468, 1)" clone_start="15" clone_end="39">
			<code function_name="LanesXmlParser::ParseSignalOverlapGroup(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;OverlapWithLane&gt;* signal_overlaps)">Status LanesXmlParser::ParseSignalOverlapGroup(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;OverlapWithLane&gt;* signal_overlaps) {
  CHECK_NOTNULL(signal_overlaps);

  auto signal_overlap = xml_node.FirstChildElement("signalOverlapGroup");
  if (signal_overlap) {
    auto sub_node = signal_overlap-&gt;FirstChildElement("signalReference");
    while (sub_node) {
      std::string object_id;
      double start_s = 0.0;
      double end_s = 0.0;
      int checker =
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
      checker += sub_node-&gt;QueryDoubleAttribute("startOffset", &amp;start_s);
      checker += sub_node-&gt;QueryDoubleAttribute("endOffset", &amp;end_s);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse lane signal overlap";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      bool is_merge = false;
      checker = sub_node-&gt;QueryBoolAttribute("isMerge", &amp;is_merge);
      if (checker != tinyxml2::XML_SUCCESS) {
        is_merge = false;
      }

      OverlapWithLane overlap_with_lane;
      overlap_with_lane.object_id = object_id;
      overlap_with_lane.start_s = start_s;
      overlap_with_lane.end_s = end_s;
      overlap_with_lane.is_merge = is_merge;

      signal_overlaps-&gt;push_back(overlap_with_lane);

      sub_node = sub_node-&gt;NextSiblingElement("signalReference");
    }
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(389, 0)" endLine="(427, 1)" clone_start="15" clone_end="38">
			<code function_name="LanesXmlParser::ParseObjectOverlapGroup(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;OverlapWithLane&gt;* object_overlaps)">Status LanesXmlParser::ParseObjectOverlapGroup(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;OverlapWithLane&gt;* object_overlaps) {
  CHECK_NOTNULL(object_overlaps);

  auto object_overlap = xml_node.FirstChildElement("objectOverlapGroup");
  if (object_overlap) {
    auto sub_node = object_overlap-&gt;FirstChildElement("objectReference");
    while (sub_node) {
      std::string object_id;
      double start_s = 0.0;
      double end_s = 0.0;
      int checker =
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
      checker += sub_node-&gt;QueryDoubleAttribute("startOffset", &amp;start_s);
      checker += sub_node-&gt;QueryDoubleAttribute("endOffset", &amp;end_s);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse lane object overlap";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      bool is_merge = false;
      checker = sub_node-&gt;QueryBoolAttribute("isMerge", &amp;is_merge);
      if (checker != tinyxml2::XML_SUCCESS) {
        is_merge = false;
      }

      OverlapWithLane overlap_with_lane;
      overlap_with_lane.object_id = object_id;
      overlap_with_lane.start_s = start_s;
      overlap_with_lane.end_s = end_s;
      overlap_with_lane.is_merge = is_merge;
      object_overlaps-&gt;push_back(overlap_with_lane);

      sub_node = sub_node-&gt;NextSiblingElement("objectReference");
    }
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(364, 0)" endLine="(406, 1)" clone_start="5" clone_end="29">
			<code function_name="Obstacle::InitKFMotionTracker(Feature* feature)">void Obstacle::InitKFMotionTracker(Feature* feature) {
  // Set transition matrix F
  Eigen::Matrix&lt;double, 6, 6&gt; F;
  F.setIdentity();
  kf_motion_tracker_.SetTransitionMatrix(F);

  // Set observation matrix H
  Eigen::Matrix&lt;double, 2, 6&gt; H;
  H.setZero();
  H(0, 0) = 1.0;
  H(1, 1) = 1.0;
  kf_motion_tracker_.SetObservationMatrix(H);

  // Set covariance of transition noise matrix Q
  Eigen::Matrix&lt;double, 6, 6&gt; Q;
  Q.setIdentity();
  Q *= FLAGS_q_var;
  kf_motion_tracker_.SetTransitionNoise(Q);

  // Set observation noise matrix R
  Eigen::Matrix&lt;double, 2, 2&gt; R;
  R.setIdentity();
  R *= FLAGS_r_var;
  kf_motion_tracker_.SetObservationNoise(R);

  // Set current state covariance matrix P
  Eigen::Matrix&lt;double, 6, 6&gt; P;
  P.setIdentity();
  P *= FLAGS_p_var;

  // Set initial state
  Eigen::Matrix&lt;double, 6, 1&gt; x;
  x(0, 0) = feature-&gt;position().x();
  x(1, 0) = feature-&gt;position().y();
  x(2, 0) = feature-&gt;velocity().x();
  x(3, 0) = feature-&gt;velocity().y();
  x(4, 0) = feature-&gt;acceleration().x();
  x(5, 0) = feature-&gt;acceleration().y();

  kf_motion_tracker_.SetStateEstimate(x, P);

  kf_motion_tracker_enabled_ = true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\container\obstacles\obstacle.cc" startLine="(468, 0)" endLine="(504, 1)" clone_start="9" clone_end="33">
			<code function_name="Obstacle::InitKFLaneTracker(const std::string&amp; lane_id, const double beta)">void Obstacle::InitKFLaneTracker(const std::string&amp; lane_id,
                                 const double beta) {
  KalmanFilter&lt;double, 4, 2, 0&gt; kf;

  // transition matrix: update delta_t at each processing step
  Eigen::Matrix&lt;double, 4, 4&gt; F;
  F.setIdentity();
  F(1, 1) = beta;
  kf.SetTransitionMatrix(F);

  // observation matrix
  Eigen::Matrix&lt;double, 2, 4&gt; H;
  H.setZero();
  H(0, 0) = 1.0;
  H(1, 1) = 1.0;
  kf.SetObservationMatrix(H);

  // Set covariance of transition noise matrix Q
  Eigen::Matrix&lt;double, 4, 4&gt; Q;
  Q.setIdentity();
  Q *= FLAGS_q_var;
  kf.SetTransitionNoise(Q);

  // Set observation noise matrix R
  Eigen::Matrix&lt;double, 2, 2&gt; R;
  R.setIdentity();
  R *= FLAGS_r_var;
  kf.SetObservationNoise(R);

  // Set current state covariance matrix P
  Eigen::Matrix&lt;double, 4, 4&gt; P;
  P.setIdentity();
  P *= FLAGS_p_var;
  kf.SetStateCovariance(P);

  kf_lane_trackers_.emplace(lane_id, std::move(kf));
}</code>
		</source>
	</dup>
	<dup count="5">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(142, 0)" endLine="(145, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMapImpl::GetLanes(const PointENU&amp; point, double distance, std::vector&lt;LaneInfoConstPtr&gt;* lanes) const">int HDMapImpl::GetLanes(const PointENU&amp; point, double distance,
                        std::vector&lt;LaneInfoConstPtr&gt;* lanes) const {
  return GetLanes({point.x(), point.y()}, distance, lanes);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(265, 0)" endLine="(269, 1)" clone_start="1" clone_end="5">
			<code function_name="HDMapImpl::GetStopSigns(    const PointENU&amp; point, double distance, std::vector&lt;StopSignInfoConstPtr&gt;* stop_signs) const">int HDMapImpl::GetStopSigns(
    const PointENU&amp; point, double distance,
    std::vector&lt;StopSignInfoConstPtr&gt;* stop_signs) const {
  return GetStopSigns({point.x(), point.y()}, distance, stop_signs);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(240, 0)" endLine="(244, 1)" clone_start="1" clone_end="5">
			<code function_name="HDMapImpl::GetCrosswalks(    const PointENU&amp; point, double distance, std::vector&lt;CrosswalkInfoConstPtr&gt;* crosswalks) const">int HDMapImpl::GetCrosswalks(
    const PointENU&amp; point, double distance,
    std::vector&lt;CrosswalkInfoConstPtr&gt;* crosswalks) const {
  return GetCrosswalks({point.x(), point.y()}, distance, crosswalks);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(217, 0)" endLine="(220, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMapImpl::GetSignals(const PointENU&amp; point, double distance, std::vector&lt;SignalInfoConstPtr&gt;* signals) const">int HDMapImpl::GetSignals(const PointENU&amp; point, double distance,
                          std::vector&lt;SignalInfoConstPtr&gt;* signals) const {
  return GetSignals({point.x(), point.y()}, distance, signals);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(192, 0)" endLine="(196, 1)" clone_start="1" clone_end="5">
			<code function_name="HDMapImpl::GetJunctions(const PointENU&amp; point, double distance, std::vector&lt;JunctionInfoConstPtr&gt;* junctions) const">int HDMapImpl::GetJunctions(
    const PointENU&amp; point, double distance,
    std::vector&lt;JunctionInfoConstPtr&gt;* junctions) const {
  return GetJunctions({point.x(), point.y()}, distance, junctions);
}</code>
		</source>
	</dup>
	<dup count="5">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(147, 0)" endLine="(165, 1)" clone_start="1" clone_end="19">
			<code function_name="HDMapImpl::GetLanes(const Vec2d&amp; point, double distance, std::vector&lt;LaneInfoConstPtr&gt;* lanes) const">int HDMapImpl::GetLanes(const Vec2d&amp; point, double distance,
                        std::vector&lt;LaneInfoConstPtr&gt;* lanes) const {
  if (lanes == nullptr || lane_segment_kdtree_ == nullptr) {
    return -1;
  }

  lanes-&gt;clear();
  std::vector&lt;std::string&gt; ids;
  const int status =
      SearchObjects(point, distance, *lane_segment_kdtree_, &amp;ids);
  if (status &lt; 0) {
    return status;
  }

  for (const auto&amp; id : ids) {
    lanes-&gt;emplace_back(GetLaneById(CreateHDMapId(id)));
  }
  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(271, 0)" endLine="(288, 1)" clone_start="1" clone_end="18">
			<code function_name="HDMapImpl::GetStopSigns(    const Vec2d&amp; point, double distance, std::vector&lt;StopSignInfoConstPtr&gt;* stop_signs) const">int HDMapImpl::GetStopSigns(
    const Vec2d&amp; point, double distance,
    std::vector&lt;StopSignInfoConstPtr&gt;* stop_signs) const {
  if (stop_signs == nullptr || stop_sign_segment_kdtree_ == nullptr) {
    return -1;
  }
  stop_signs-&gt;clear();
  std::vector&lt;std::string&gt; ids;
  const int status =
      SearchObjects(point, distance, *stop_sign_segment_kdtree_, &amp;ids);
  if (status &lt; 0) {
    return status;
  }
  for (const auto&amp; id : ids) {
    stop_signs-&gt;emplace_back(GetStopSignById(CreateHDMapId(id)));
  }
  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(246, 0)" endLine="(263, 1)" clone_start="1" clone_end="18">
			<code function_name="HDMapImpl::GetCrosswalks(    const Vec2d&amp; point, double distance, std::vector&lt;CrosswalkInfoConstPtr&gt;* crosswalks) const">int HDMapImpl::GetCrosswalks(
    const Vec2d&amp; point, double distance,
    std::vector&lt;CrosswalkInfoConstPtr&gt;* crosswalks) const {
  if (crosswalks == nullptr || crosswalk_polygon_kdtree_ == nullptr) {
    return -1;
  }
  crosswalks-&gt;clear();
  std::vector&lt;std::string&gt; ids;
  const int status =
      SearchObjects(point, distance, *crosswalk_polygon_kdtree_, &amp;ids);
  if (status &lt; 0) {
    return status;
  }
  for (const auto&amp; id : ids) {
    crosswalks-&gt;emplace_back(GetCrosswalkById(CreateHDMapId(id)));
  }
  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(222, 0)" endLine="(238, 1)" clone_start="1" clone_end="17">
			<code function_name="HDMapImpl::GetSignals(const Vec2d&amp; point, double distance, std::vector&lt;SignalInfoConstPtr&gt;* signals) const">int HDMapImpl::GetSignals(const Vec2d&amp; point, double distance,
                          std::vector&lt;SignalInfoConstPtr&gt;* signals) const {
  if (signals == nullptr || signal_segment_kdtree_ == nullptr) {
    return -1;
  }
  signals-&gt;clear();
  std::vector&lt;std::string&gt; ids;
  const int status =
      SearchObjects(point, distance, *signal_segment_kdtree_, &amp;ids);
  if (status &lt; 0) {
    return status;
  }
  for (const auto&amp; id : ids) {
    signals-&gt;emplace_back(GetSignalById(CreateHDMapId(id)));
  }
  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(198, 0)" endLine="(215, 1)" clone_start="1" clone_end="18">
			<code function_name="HDMapImpl::GetJunctions(const Vec2d&amp; point, double distance, std::vector&lt;JunctionInfoConstPtr&gt;* junctions) const">int HDMapImpl::GetJunctions(
    const Vec2d&amp; point, double distance,
    std::vector&lt;JunctionInfoConstPtr&gt;* junctions) const {
  if (junctions == nullptr || junction_polygon_kdtree_ == nullptr) {
    return -1;
  }
  junctions-&gt;clear();
  std::vector&lt;std::string&gt; ids;
  const int status =
      SearchObjects(point, distance, *junction_polygon_kdtree_, &amp;ids);
  if (status &lt; 0) {
    return status;
  }
  for (const auto&amp; id : ids) {
    junctions-&gt;emplace_back(GetJunctionById(CreateHDMapId(id)));
  }
  return 0;
}</code>
		</source>
	</dup>
	<dup count="5">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(167, 0)" endLine="(170, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMapImpl::GetRoads(const PointENU&amp; point, double distance, std::vector&lt;RoadInfoConstPtr&gt;* roads) const">int HDMapImpl::GetRoads(const PointENU&amp; point, double distance,
                        std::vector&lt;RoadInfoConstPtr&gt;* roads) const {
  return GetRoads({point.x(), point.y()}, distance, roads);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(290, 0)" endLine="(294, 1)" clone_start="1" clone_end="5">
			<code function_name="HDMapImpl::GetYieldSigns(    const PointENU&amp; point, double distance, std::vector&lt;YieldSignInfoConstPtr&gt;* yield_signs) const">int HDMapImpl::GetYieldSigns(
    const PointENU&amp; point, double distance,
    std::vector&lt;YieldSignInfoConstPtr&gt;* yield_signs) const {
  return GetYieldSigns({point.x(), point.y()}, distance, yield_signs);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(265, 0)" endLine="(269, 1)" clone_start="1" clone_end="5">
			<code function_name="HDMapImpl::GetStopSigns(    const PointENU&amp; point, double distance, std::vector&lt;StopSignInfoConstPtr&gt;* stop_signs) const">int HDMapImpl::GetStopSigns(
    const PointENU&amp; point, double distance,
    std::vector&lt;StopSignInfoConstPtr&gt;* stop_signs) const {
  return GetStopSigns({point.x(), point.y()}, distance, stop_signs);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(240, 0)" endLine="(244, 1)" clone_start="1" clone_end="5">
			<code function_name="HDMapImpl::GetCrosswalks(    const PointENU&amp; point, double distance, std::vector&lt;CrosswalkInfoConstPtr&gt;* crosswalks) const">int HDMapImpl::GetCrosswalks(
    const PointENU&amp; point, double distance,
    std::vector&lt;CrosswalkInfoConstPtr&gt;* crosswalks) const {
  return GetCrosswalks({point.x(), point.y()}, distance, crosswalks);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(217, 0)" endLine="(220, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMapImpl::GetSignals(const PointENU&amp; point, double distance, std::vector&lt;SignalInfoConstPtr&gt;* signals) const">int HDMapImpl::GetSignals(const PointENU&amp; point, double distance,
                          std::vector&lt;SignalInfoConstPtr&gt;* signals) const {
  return GetSignals({point.x(), point.y()}, distance, signals);
}</code>
		</source>
	</dup>
	<dup count="5">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(172, 0)" endLine="(190, 1)" clone_start="1" clone_end="1">
			<code function_name="HDMapImpl::GetRoads(const Vec2d&amp; point, double distance, std::vector&lt;RoadInfoConstPtr&gt;* roads) const">int HDMapImpl::GetRoads(const Vec2d&amp; point, double distance,
                        std::vector&lt;RoadInfoConstPtr&gt;* roads) const {
  std::vector&lt;LaneInfoConstPtr&gt; lanes;
  if (GetLanes(point, distance, &amp;lanes) != 0) {
    return -1;
  }
  std::unordered_set&lt;std::string&gt; road_ids;
  for (auto&amp; lane : lanes) {
    road_ids.insert(lane-&gt;road_id().id());
  }

  for (auto&amp; road_id : road_ids) {
    RoadInfoConstPtr road = GetRoadById(CreateHDMapId(road_id));
    CHECK_NOTNULL(road);
    roads-&gt;push_back(road);
  }

  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(296, 0)" endLine="(314, 1)" clone_start="1" clone_end="1">
			<code function_name="HDMapImpl::GetYieldSigns(    const Vec2d&amp; point, double distance, std::vector&lt;YieldSignInfoConstPtr&gt;* yield_signs) const">int HDMapImpl::GetYieldSigns(
    const Vec2d&amp; point, double distance,
    std::vector&lt;YieldSignInfoConstPtr&gt;* yield_signs) const {
  if (yield_signs == nullptr || yield_sign_segment_kdtree_ == nullptr) {
    return -1;
  }
  yield_signs-&gt;clear();
  std::vector&lt;std::string&gt; ids;
  const int status =
      SearchObjects(point, distance, *yield_sign_segment_kdtree_, &amp;ids);
  if (status &lt; 0) {
    return status;
  }
  for (const auto&amp; id : ids) {
    yield_signs-&gt;emplace_back(GetYieldSignById(CreateHDMapId(id)));
  }

  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(271, 0)" endLine="(288, 1)" clone_start="1" clone_end="1">
			<code function_name="HDMapImpl::GetStopSigns(    const Vec2d&amp; point, double distance, std::vector&lt;StopSignInfoConstPtr&gt;* stop_signs) const">int HDMapImpl::GetStopSigns(
    const Vec2d&amp; point, double distance,
    std::vector&lt;StopSignInfoConstPtr&gt;* stop_signs) const {
  if (stop_signs == nullptr || stop_sign_segment_kdtree_ == nullptr) {
    return -1;
  }
  stop_signs-&gt;clear();
  std::vector&lt;std::string&gt; ids;
  const int status =
      SearchObjects(point, distance, *stop_sign_segment_kdtree_, &amp;ids);
  if (status &lt; 0) {
    return status;
  }
  for (const auto&amp; id : ids) {
    stop_signs-&gt;emplace_back(GetStopSignById(CreateHDMapId(id)));
  }
  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(246, 0)" endLine="(263, 1)" clone_start="1" clone_end="1">
			<code function_name="HDMapImpl::GetCrosswalks(    const Vec2d&amp; point, double distance, std::vector&lt;CrosswalkInfoConstPtr&gt;* crosswalks) const">int HDMapImpl::GetCrosswalks(
    const Vec2d&amp; point, double distance,
    std::vector&lt;CrosswalkInfoConstPtr&gt;* crosswalks) const {
  if (crosswalks == nullptr || crosswalk_polygon_kdtree_ == nullptr) {
    return -1;
  }
  crosswalks-&gt;clear();
  std::vector&lt;std::string&gt; ids;
  const int status =
      SearchObjects(point, distance, *crosswalk_polygon_kdtree_, &amp;ids);
  if (status &lt; 0) {
    return status;
  }
  for (const auto&amp; id : ids) {
    crosswalks-&gt;emplace_back(GetCrosswalkById(CreateHDMapId(id)));
  }
  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(222, 0)" endLine="(238, 1)" clone_start="1" clone_end="1">
			<code function_name="HDMapImpl::GetSignals(const Vec2d&amp; point, double distance, std::vector&lt;SignalInfoConstPtr&gt;* signals) const">int HDMapImpl::GetSignals(const Vec2d&amp; point, double distance,
                          std::vector&lt;SignalInfoConstPtr&gt;* signals) const {
  if (signals == nullptr || signal_segment_kdtree_ == nullptr) {
    return -1;
  }
  signals-&gt;clear();
  std::vector&lt;std::string&gt; ids;
  const int status =
      SearchObjects(point, distance, *signal_segment_kdtree_, &amp;ids);
  if (status &lt; 0) {
    return status;
  }
  for (const auto&amp; id : ids) {
    signals-&gt;emplace_back(GetSignalById(CreateHDMapId(id)));
  }
  return 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\opengl_visualizer.cc" startLine="(89, 0)" endLine="(121, 1)" clone_start="7" clone_end="24">
			<code function_name="OpenglVisualizer::SetMainCarPoints()">void OpenglVisualizer::SetMainCarPoints() {
  main_car_points_velodyne_.resize(9);
  main_car_points_velodyne_.at(0).x = 0;
  main_car_points_velodyne_.at(0).y = 0;
  main_car_points_velodyne_.at(0).z = 0;

  main_car_points_velodyne_.at(1).x = 0;
  main_car_points_velodyne_.at(1).y = 0;
  main_car_points_velodyne_.at(1).z = -velodyne_height_;
  main_car_points_velodyne_.at(2).x = 3;
  main_car_points_velodyne_.at(2).y = 0;
  main_car_points_velodyne_.at(2).z = -velodyne_height_;

  main_car_points_velodyne_.at(3).x = 2.5;
  main_car_points_velodyne_.at(3).y = 1.0;
  main_car_points_velodyne_.at(3).z = -velodyne_height_;
  main_car_points_velodyne_.at(4).x = 2.5;
  main_car_points_velodyne_.at(4).y = -1.0;
  main_car_points_velodyne_.at(4).z = -velodyne_height_;
  main_car_points_velodyne_.at(5).x = -2.5;
  main_car_points_velodyne_.at(5).y = -1.0;
  main_car_points_velodyne_.at(5).z = -velodyne_height_;
  main_car_points_velodyne_.at(6).x = -2.5;
  main_car_points_velodyne_.at(6).y = 1.0;
  main_car_points_velodyne_.at(6).z = -velodyne_height_;

  main_car_points_velodyne_.at(7).x = 0;
  main_car_points_velodyne_.at(7).y = 0;
  main_car_points_velodyne_.at(7).z = 160;
  main_car_points_velodyne_.at(8).x = -40;
  main_car_points_velodyne_.at(8).y = 0;
  main_car_points_velodyne_.at(8).z = 50;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\opengl_visualizer.cc" startLine="(89, 0)" endLine="(121, 1)" clone_start="10" clone_end="28">
			<code function_name="OpenglVisualizer::SetMainCarPoints()">void OpenglVisualizer::SetMainCarPoints() {
  main_car_points_velodyne_.resize(9);
  main_car_points_velodyne_.at(0).x = 0;
  main_car_points_velodyne_.at(0).y = 0;
  main_car_points_velodyne_.at(0).z = 0;

  main_car_points_velodyne_.at(1).x = 0;
  main_car_points_velodyne_.at(1).y = 0;
  main_car_points_velodyne_.at(1).z = -velodyne_height_;
  main_car_points_velodyne_.at(2).x = 3;
  main_car_points_velodyne_.at(2).y = 0;
  main_car_points_velodyne_.at(2).z = -velodyne_height_;

  main_car_points_velodyne_.at(3).x = 2.5;
  main_car_points_velodyne_.at(3).y = 1.0;
  main_car_points_velodyne_.at(3).z = -velodyne_height_;
  main_car_points_velodyne_.at(4).x = 2.5;
  main_car_points_velodyne_.at(4).y = -1.0;
  main_car_points_velodyne_.at(4).z = -velodyne_height_;
  main_car_points_velodyne_.at(5).x = -2.5;
  main_car_points_velodyne_.at(5).y = -1.0;
  main_car_points_velodyne_.at(5).z = -velodyne_height_;
  main_car_points_velodyne_.at(6).x = -2.5;
  main_car_points_velodyne_.at(6).y = 1.0;
  main_car_points_velodyne_.at(6).z = -velodyne_height_;

  main_car_points_velodyne_.at(7).x = 0;
  main_car_points_velodyne_.at(7).y = 0;
  main_car_points_velodyne_.at(7).z = 160;
  main_car_points_velodyne_.at(8).x = -40;
  main_car_points_velodyne_.at(8).y = 0;
  main_car_points_velodyne_.at(8).z = 50;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(54, 0)" endLine="(119, 1)" clone_start="24" clone_end="46">
			<code function_name="create_stream(const config::Stream &amp;sd)">Stream *create_stream(const config::Stream &amp;sd) {
  switch (sd.type_case()) {
    case config::Stream::kSerial:
      if (!sd.serial().has_device()) {
        ROS_ERROR("Serial def has no device field.");
        return nullptr;
      }
      if (!sd.serial().has_baud_rate()) {
        ROS_ERROR_STREAM(
            "Serial def has no baud_rate field. Use default baud rate "
            &lt;&lt; sd.serial().baud_rate());
        return nullptr;
      }
      return Stream::create_serial(sd.serial().device().c_str(),
                                   sd.serial().baud_rate());

    case config::Stream::kTcp:
      if (!sd.tcp().has_address()) {
        ROS_ERROR("tcp def has no address field.");
        return nullptr;
      }
      if (!sd.tcp().has_port()) {
        ROS_ERROR("tcp def has no port field.");
        return nullptr;
      }
      return Stream::create_tcp(sd.tcp().address().c_str(), sd.tcp().port());

    case config::Stream::kUdp:
      if (!sd.udp().has_address()) {
        ROS_ERROR("tcp def has no address field.");
        return nullptr;
      }
      if (!sd.udp().has_port()) {
        ROS_ERROR("tcp def has no port field.");
        return nullptr;
      }
      return Stream::create_udp(sd.udp().address().c_str(), sd.udp().port());

    case config::Stream::kNtrip:
      if (!sd.ntrip().has_address()) {
        ROS_ERROR("ntrip def has no address field.");
        return nullptr;
      }
      if (!sd.ntrip().has_port()) {
        ROS_ERROR("ntrip def has no port field.");
        return nullptr;
      }
      if (!sd.ntrip().has_mount_point()) {
        ROS_ERROR("ntrip def has no mount point field.");
        return nullptr;
      }
      if (!sd.ntrip().has_user()) {
        ROS_ERROR("ntrip def has no user field.");
        return nullptr;
      }
      if (!sd.ntrip().has_password()) {
        ROS_ERROR("ntrip def has no passwd field.");
        return nullptr;
      }
      return Stream::create_ntrip(
          sd.ntrip().address(), sd.ntrip().port(), sd.ntrip().mount_point(),
          sd.ntrip().user(), sd.ntrip().password(), sd.ntrip().timeout_s());
    default:
      return nullptr;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(54, 0)" endLine="(119, 1)" clone_start="12" clone_end="35">
			<code function_name="create_stream(const config::Stream &amp;sd)">Stream *create_stream(const config::Stream &amp;sd) {
  switch (sd.type_case()) {
    case config::Stream::kSerial:
      if (!sd.serial().has_device()) {
        ROS_ERROR("Serial def has no device field.");
        return nullptr;
      }
      if (!sd.serial().has_baud_rate()) {
        ROS_ERROR_STREAM(
            "Serial def has no baud_rate field. Use default baud rate "
            &lt;&lt; sd.serial().baud_rate());
        return nullptr;
      }
      return Stream::create_serial(sd.serial().device().c_str(),
                                   sd.serial().baud_rate());

    case config::Stream::kTcp:
      if (!sd.tcp().has_address()) {
        ROS_ERROR("tcp def has no address field.");
        return nullptr;
      }
      if (!sd.tcp().has_port()) {
        ROS_ERROR("tcp def has no port field.");
        return nullptr;
      }
      return Stream::create_tcp(sd.tcp().address().c_str(), sd.tcp().port());

    case config::Stream::kUdp:
      if (!sd.udp().has_address()) {
        ROS_ERROR("tcp def has no address field.");
        return nullptr;
      }
      if (!sd.udp().has_port()) {
        ROS_ERROR("tcp def has no port field.");
        return nullptr;
      }
      return Stream::create_udp(sd.udp().address().c_str(), sd.udp().port());

    case config::Stream::kNtrip:
      if (!sd.ntrip().has_address()) {
        ROS_ERROR("ntrip def has no address field.");
        return nullptr;
      }
      if (!sd.ntrip().has_port()) {
        ROS_ERROR("ntrip def has no port field.");
        return nullptr;
      }
      if (!sd.ntrip().has_mount_point()) {
        ROS_ERROR("ntrip def has no mount point field.");
        return nullptr;
      }
      if (!sd.ntrip().has_user()) {
        ROS_ERROR("ntrip def has no user field.");
        return nullptr;
      }
      if (!sd.ntrip().has_password()) {
        ROS_ERROR("ntrip def has no passwd field.");
        return nullptr;
      }
      return Stream::create_ntrip(
          sd.ntrip().address(), sd.ntrip().port(), sd.ntrip().mount_point(),
          sd.ntrip().user(), sd.ntrip().password(), sd.ntrip().timeout_s());
    default:
      return nullptr;
  }
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(49, 0)" endLine="(54, 1)" clone_start="4" clone_end="6">
			<code function_name="Spline1dConstraint::AddEqualityConstraint(    const Eigen::MatrixXd&amp; constraint_matrix, const Eigen::MatrixXd&amp; constraint_boundary)">bool Spline1dConstraint::AddEqualityConstraint(
    const Eigen::MatrixXd&amp; constraint_matrix,
    const Eigen::MatrixXd&amp; constraint_boundary) {
  return equality_constraint_.AddConstraint(constraint_matrix,
                                            constraint_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(56, 0)" endLine="(107, 1)" clone_start="50" clone_end="52">
			<code function_name="Spline1dConstraint::AddBoundary(const std::vector&lt;double&gt;&amp; x_coord,const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddBoundary(const std::vector&lt;double&gt;&amp; x_coord,
                                     const std::vector&lt;double&gt;&amp; lower_bound,
                                     const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }
  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);

    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) = coef;
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) = coef;
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }

  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(109, 0)" endLine="(159, 1)" clone_start="49" clone_end="51">
			<code function_name="Spline1dConstraint::AddDerivativeBoundary(const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }

  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);
    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 1; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) = coef * j;
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 1; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) = coef * j;
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }
  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(56, 0)" endLine="(107, 1)" clone_start="1" clone_end="30">
			<code function_name="Spline1dConstraint::AddBoundary(const std::vector&lt;double&gt;&amp; x_coord,const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddBoundary(const std::vector&lt;double&gt;&amp; x_coord,
                                     const std::vector&lt;double&gt;&amp; lower_bound,
                                     const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }
  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);

    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) = coef;
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) = coef;
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }

  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(109, 0)" endLine="(159, 1)" clone_start="1" clone_end="30">
			<code function_name="Spline1dConstraint::AddDerivativeBoundary(const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }

  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);
    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 1; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) = coef * j;
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 1; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) = coef * j;
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }
  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(161, 0)" endLine="(211, 1)" clone_start="1" clone_end="30">
			<code function_name="Spline1dConstraint::AddSecondDerivativeBoundary(    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddSecondDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }

  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);
    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 2; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) = coef * j * (j - 1);
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 2; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) = coef * j * (j - 1);
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }
  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d.cc" startLine="(40, 0)" endLine="(46, 1)" clone_start="5" clone_end="7">
			<code function_name="Spline1d::operator()(const double x) const">double Spline1d::operator()(const double x) const {
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = FindIndex(x);
  return splines_[index](x - x_knots_[index]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(38, 0)" endLine="(44, 1)" clone_start="5" clone_end="7">
			<code function_name="Spline2d::operator()(const double t) const">std::pair&lt;double, double&gt; Spline2d::operator()(const double t) const {
  if (splines_.size() == 0) {
    return std::make_pair(0.0, 0.0);
  }
  std::uint32_t index = find_index(t);
  return splines_[index](t - t_knots_[index]);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d.cc" startLine="(48, 0)" endLine="(55, 1)" clone_start="1" clone_end="8">
			<code function_name="Spline1d::Derivative(const double x) const">double Spline1d::Derivative(const double x) const {
  // zero order spline
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = FindIndex(x);
  return splines_[index].Derivative(x - x_knots_[index]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(46, 0)" endLine="(52, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline2d::x(const double t) const">double Spline2d::x(const double t) const {
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = find_index(t);
  return splines_[index].x(t - t_knots_[index]);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d.cc" startLine="(57, 0)" endLine="(63, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline1d::SecondOrderDerivative(const double x) const">double Spline1d::SecondOrderDerivative(const double x) const {
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = FindIndex(x);
  return splines_[index].SecondOrderDerivative(x - x_knots_[index]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(54, 0)" endLine="(60, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline2d::y(const double t) const">double Spline2d::y(const double t) const {
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = find_index(t);
  return splines_[index].y(t - t_knots_[index]);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d.cc" startLine="(65, 0)" endLine="(71, 1)" clone_start="1" clone_end="6">
			<code function_name="Spline1d::ThirdOrderDerivative(const double x) const">double Spline1d::ThirdOrderDerivative(const double x) const {
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = FindIndex(x);
  return splines_[index].ThirdOrderDerivative(x - x_knots_[index]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(62, 0)" endLine="(69, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline2d::DerivativeX(const double t) const">double Spline2d::DerivativeX(const double t) const {
  // zero order spline
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = find_index(t);
  return splines_[index].DerivativeX(t - t_knots_[index]);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_solver.cc" startLine="(42, 0)" endLine="(65, 1)" clone_start="1" clone_end="24">
			<code function_name="Spline2dSolver::Solve()">bool Spline2dSolver::Solve() {
  const Eigen::MatrixXd&amp; kernel_matrix = kernel_.kernel_matrix();
  const Eigen::MatrixXd&amp; offset = kernel_.offset();
  const Eigen::MatrixXd&amp; inequality_constraint_matrix =
      constraint_.inequality_constraint().constraint_matrix();
  const Eigen::MatrixXd&amp; inequality_constraint_boundary =
      constraint_.inequality_constraint().constraint_boundary();
  const Eigen::MatrixXd&amp; equality_constraint_matrix =
      constraint_.equality_constraint().constraint_matrix();
  const Eigen::MatrixXd&amp; equality_constraint_boundary =
      constraint_.equality_constraint().constraint_boundary();

  qp_solver_.reset(new apollo::common::math::ActiveSetQpSolver(
      kernel_matrix, offset, inequality_constraint_matrix,
      inequality_constraint_boundary, equality_constraint_matrix,
      equality_constraint_boundary));
  if (!qp_solver_-&gt;Solve()) {
    return false;
  }

  const std::uint32_t spline_order = spline_.spline_order();
  const Eigen::MatrixXd solved_params = qp_solver_-&gt;params();
  return spline_.set_splines(solved_params, spline_order);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_generator.cc" startLine="(54, 0)" endLine="(78, 1)" clone_start="1" clone_end="25">
			<code function_name="Spline1dGenerator::Solve()">bool Spline1dGenerator::Solve() {
  const Eigen::MatrixXd&amp; kernel_matrix = spline_kernel_.kernel_matrix();
  const Eigen::MatrixXd&amp; offset = spline_kernel_.offset();
  const Eigen::MatrixXd&amp; inequality_constraint_matrix =
      spline_constraint_.inequality_constraint().constraint_matrix();
  const Eigen::MatrixXd&amp; inequality_constraint_boundary =
      spline_constraint_.inequality_constraint().constraint_boundary();
  const Eigen::MatrixXd&amp; equality_constraint_matrix =
      spline_constraint_.equality_constraint().constraint_matrix();
  const Eigen::MatrixXd&amp; equality_constraint_boundary =
      spline_constraint_.equality_constraint().constraint_boundary();

  qp_solver_.reset(new apollo::common::math::ActiveSetQpSolver(
      kernel_matrix, offset, inequality_constraint_matrix,
      inequality_constraint_boundary, equality_constraint_matrix,
      equality_constraint_boundary));

  if (!qp_solver_-&gt;Solve()) {
    return false;
  }

  const std::uint32_t spline_order = spline_.spline_order();
  const Eigen::MatrixXd solved_params = qp_solver_-&gt;params();
  return spline_.SetSplineSegs(solved_params, spline_order);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_solver.cc" startLine="(68, 0)" endLine="(68, 66)" clone_start="1" clone_end="1">
			<code function_name="Spline2dSolver::Solve()">const Spline2d&amp; Spline2dSolver::spline() const { return spline_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_generator.cc" startLine="(80, 0)" endLine="(80, 69)" clone_start="1" clone_end="1">
			<code function_name="Spline1dGenerator::Solve()">const Spline1d&amp; Spline1dGenerator::spline() const { return spline_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\segmentation\cnnseg\cnn_segmentation.cc" startLine="(28, 0)" endLine="(132, 1)" clone_start="66" clone_end="85">
			<code function_name="CNNSegmentation::Init()">bool CNNSegmentation::Init() {
  string config_file;
  string proto_file;
  string weight_file;
  if (!GetConfigs(&amp;config_file, &amp;proto_file, &amp;weight_file)) {
    return false;
  }
  AINFO &lt;&lt; "--    config_file: " &lt;&lt; config_file;
  AINFO &lt;&lt; "--     proto_file: " &lt;&lt; proto_file;
  AINFO &lt;&lt; "--    weight_file: " &lt;&lt; weight_file;

  if (!apollo::common::util::GetProtoFromFile(config_file, &amp;cnnseg_param_)) {
    AERROR &lt;&lt; "Failed to load config file of CNNSegmentation.";
  }

  /// set parameters
  auto network_param = cnnseg_param_.network_param();
  auto feature_param = cnnseg_param_.feature_param();

  if (feature_param.has_point_cloud_range()) {
    range_ = static_cast&lt;float&gt;(feature_param.point_cloud_range());
  } else {
    range_ = 60.0;
  }
  if (feature_param.has_width()) {
    width_ = static_cast&lt;int&gt;(feature_param.width());
  } else {
    width_ = 512;
  }
  if (feature_param.has_height()) {
    height_ = static_cast&lt;int&gt;(feature_param.height());
  } else {
    height_ = 512;
  }

/// Instantiate Caffe net
#ifndef USE_CAFFE_GPU
  caffe::Caffe::set_mode(caffe::Caffe::CPU);
#else
  int gpu_id =
      cnnseg_param_.has_gpu_id() ? static_cast&lt;int&gt;(cnnseg_param_.gpu_id()) : 0;
  CHECK_GE(gpu_id, 0);
  caffe::Caffe::SetDevice(gpu_id);
  caffe::Caffe::set_mode(caffe::Caffe::GPU);
  caffe::Caffe::DeviceQuery();
#endif

  caffe_net_.reset(new caffe::Net&lt;float&gt;(proto_file, caffe::TEST));
  caffe_net_-&gt;CopyTrainedLayersFrom(weight_file);

#ifndef USE_CAFFE_GPU
  AINFO &lt;&lt; "using Caffe CPU mode";
#else
  AINFO &lt;&lt; "using Caffe GPU mode";
#endif

  /// set related Caffe blobs
  // center offset prediction
  string instance_pt_blob_name = network_param.has_instance_pt_blob()
                                     ? network_param.instance_pt_blob()
                                     : "instance_pt";
  instance_pt_blob_ = caffe_net_-&gt;blob_by_name(instance_pt_blob_name);
  CHECK(instance_pt_blob_ != nullptr) &lt;&lt; "`" &lt;&lt; instance_pt_blob_name
                                      &lt;&lt; "` not exists!";
  // objectness prediction
  string category_pt_blob_name = network_param.has_category_pt_blob()
                                     ? network_param.category_pt_blob()
                                     : "category_score";
  category_pt_blob_ = caffe_net_-&gt;blob_by_name(category_pt_blob_name);
  CHECK(category_pt_blob_ != nullptr) &lt;&lt; "`" &lt;&lt; category_pt_blob_name
                                      &lt;&lt; "` not exists!";
  // positiveness (foreground object probability) prediction
  string confidence_pt_blob_name = network_param.has_confidence_pt_blob()
                                       ? network_param.confidence_pt_blob()
                                       : "confidence_score";
  confidence_pt_blob_ = caffe_net_-&gt;blob_by_name(confidence_pt_blob_name);
  CHECK(confidence_pt_blob_ != nullptr) &lt;&lt; "`" &lt;&lt; confidence_pt_blob_name
                                        &lt;&lt; "` not exists!";
  // object height prediction
  string height_pt_blob_name = network_param.has_height_pt_blob()
                                   ? network_param.height_pt_blob()
                                   : "height_pt";
  height_pt_blob_ = caffe_net_-&gt;blob_by_name(height_pt_blob_name);
  CHECK(height_pt_blob_ != nullptr) &lt;&lt; "`" &lt;&lt; height_pt_blob_name
                                    &lt;&lt; "` not exists!";
  // raw feature data
  string feature_blob_name =
      network_param.has_feature_blob() ? network_param.feature_blob() : "data";
  feature_blob_ = caffe_net_-&gt;blob_by_name(feature_blob_name);
  CHECK(feature_blob_ != nullptr) &lt;&lt; "`" &lt;&lt; feature_blob_name
                                  &lt;&lt; "` not exists!";

  cluster2d_.reset(new cnnseg::Cluster2D());
  if (!cluster2d_-&gt;Init(height_, width_, range_)) {
    AERROR &lt;&lt; "Fail to init cluster2d for CNNSegmentation";
  }

  feature_generator_.reset(new cnnseg::FeatureGenerator&lt;float&gt;());
  if (!feature_generator_-&gt;Init(feature_param, feature_blob_.get())) {
    AERROR &lt;&lt; "Fail to init feature generator for CNNSegmentation";
    return false;
  }

  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\segmentation\cnnseg\cnn_segmentation.cc" startLine="(28, 0)" endLine="(132, 1)" clone_start="59" clone_end="78">
			<code function_name="CNNSegmentation::Init()">bool CNNSegmentation::Init() {
  string config_file;
  string proto_file;
  string weight_file;
  if (!GetConfigs(&amp;config_file, &amp;proto_file, &amp;weight_file)) {
    return false;
  }
  AINFO &lt;&lt; "--    config_file: " &lt;&lt; config_file;
  AINFO &lt;&lt; "--     proto_file: " &lt;&lt; proto_file;
  AINFO &lt;&lt; "--    weight_file: " &lt;&lt; weight_file;

  if (!apollo::common::util::GetProtoFromFile(config_file, &amp;cnnseg_param_)) {
    AERROR &lt;&lt; "Failed to load config file of CNNSegmentation.";
  }

  /// set parameters
  auto network_param = cnnseg_param_.network_param();
  auto feature_param = cnnseg_param_.feature_param();

  if (feature_param.has_point_cloud_range()) {
    range_ = static_cast&lt;float&gt;(feature_param.point_cloud_range());
  } else {
    range_ = 60.0;
  }
  if (feature_param.has_width()) {
    width_ = static_cast&lt;int&gt;(feature_param.width());
  } else {
    width_ = 512;
  }
  if (feature_param.has_height()) {
    height_ = static_cast&lt;int&gt;(feature_param.height());
  } else {
    height_ = 512;
  }

/// Instantiate Caffe net
#ifndef USE_CAFFE_GPU
  caffe::Caffe::set_mode(caffe::Caffe::CPU);
#else
  int gpu_id =
      cnnseg_param_.has_gpu_id() ? static_cast&lt;int&gt;(cnnseg_param_.gpu_id()) : 0;
  CHECK_GE(gpu_id, 0);
  caffe::Caffe::SetDevice(gpu_id);
  caffe::Caffe::set_mode(caffe::Caffe::GPU);
  caffe::Caffe::DeviceQuery();
#endif

  caffe_net_.reset(new caffe::Net&lt;float&gt;(proto_file, caffe::TEST));
  caffe_net_-&gt;CopyTrainedLayersFrom(weight_file);

#ifndef USE_CAFFE_GPU
  AINFO &lt;&lt; "using Caffe CPU mode";
#else
  AINFO &lt;&lt; "using Caffe GPU mode";
#endif

  /// set related Caffe blobs
  // center offset prediction
  string instance_pt_blob_name = network_param.has_instance_pt_blob()
                                     ? network_param.instance_pt_blob()
                                     : "instance_pt";
  instance_pt_blob_ = caffe_net_-&gt;blob_by_name(instance_pt_blob_name);
  CHECK(instance_pt_blob_ != nullptr) &lt;&lt; "`" &lt;&lt; instance_pt_blob_name
                                      &lt;&lt; "` not exists!";
  // objectness prediction
  string category_pt_blob_name = network_param.has_category_pt_blob()
                                     ? network_param.category_pt_blob()
                                     : "category_score";
  category_pt_blob_ = caffe_net_-&gt;blob_by_name(category_pt_blob_name);
  CHECK(category_pt_blob_ != nullptr) &lt;&lt; "`" &lt;&lt; category_pt_blob_name
                                      &lt;&lt; "` not exists!";
  // positiveness (foreground object probability) prediction
  string confidence_pt_blob_name = network_param.has_confidence_pt_blob()
                                       ? network_param.confidence_pt_blob()
                                       : "confidence_score";
  confidence_pt_blob_ = caffe_net_-&gt;blob_by_name(confidence_pt_blob_name);
  CHECK(confidence_pt_blob_ != nullptr) &lt;&lt; "`" &lt;&lt; confidence_pt_blob_name
                                        &lt;&lt; "` not exists!";
  // object height prediction
  string height_pt_blob_name = network_param.has_height_pt_blob()
                                   ? network_param.height_pt_blob()
                                   : "height_pt";
  height_pt_blob_ = caffe_net_-&gt;blob_by_name(height_pt_blob_name);
  CHECK(height_pt_blob_ != nullptr) &lt;&lt; "`" &lt;&lt; height_pt_blob_name
                                    &lt;&lt; "` not exists!";
  // raw feature data
  string feature_blob_name =
      network_param.has_feature_blob() ? network_param.feature_blob() : "data";
  feature_blob_ = caffe_net_-&gt;blob_by_name(feature_blob_name);
  CHECK(feature_blob_ != nullptr) &lt;&lt; "`" &lt;&lt; feature_blob_name
                                  &lt;&lt; "` not exists!";

  cluster2d_.reset(new cnnseg::Cluster2D());
  if (!cluster2d_-&gt;Init(height_, width_, range_)) {
    AERROR &lt;&lt; "Fail to init cluster2d for CNNSegmentation";
  }

  feature_generator_.reset(new cnnseg::FeatureGenerator&lt;float&gt;());
  if (!feature_generator_-&gt;Init(feature_param, feature_blob_.get())) {
    AERROR &lt;&lt; "Fail to init feature generator for CNNSegmentation";
    return false;
  }

  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\sub_topo_graph.cc" startLine="(301, 0)" endLine="(332, 1)" clone_start="1" clone_end="25">
			<code function_name="SubTopoGraph::AddPotentialInEdge(    TopoNode* const sub_node, const std::unordered_set&lt;const TopoEdge*&gt; origin_edge)">void SubTopoGraph::AddPotentialInEdge(
    TopoNode* const sub_node,
    const std::unordered_set&lt;const TopoEdge*&gt; origin_edge) {
  std::unordered_set&lt;TopoNode*&gt; other_sub_nodes;
  for (const auto* in_edge : origin_edge) {
    if (GetSubNodes(in_edge-&gt;FromNode(), &amp;other_sub_nodes)) {
      for (auto* sub_from_node : other_sub_nodes) {
        if (sub_node-&gt;GetInEdgeFrom(sub_from_node) != nullptr) {
          continue;
        }
        if (!IsReachable(sub_from_node, sub_node)) {
          continue;
        }
        std::shared_ptr&lt;TopoEdge&gt; topo_edge_ptr;
        topo_edge_ptr.reset(
            new TopoEdge(in_edge-&gt;PbEdge(), sub_from_node, sub_node));
        sub_node-&gt;AddInEdge(topo_edge_ptr.get());
        sub_from_node-&gt;AddOutEdge(topo_edge_ptr.get());
        topo_edges_.push_back(std::move(topo_edge_ptr));
      }
    } else {
      if (sub_node-&gt;GetInEdgeFrom(in_edge-&gt;FromNode()) != nullptr) {
        continue;
      }
      std::shared_ptr&lt;TopoEdge&gt; topo_edge_ptr;
      topo_edge_ptr.reset(
          new TopoEdge(in_edge-&gt;PbEdge(), in_edge-&gt;FromNode(), sub_node));
      sub_node-&gt;AddInEdge(topo_edge_ptr.get());
      topo_edges_.push_back(std::move(topo_edge_ptr));
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\sub_topo_graph.cc" startLine="(334, 0)" endLine="(365, 1)" clone_start="1" clone_end="25">
			<code function_name="SubTopoGraph::AddPotentialOutEdge(    TopoNode* const sub_node, const std::unordered_set&lt;const TopoEdge*&gt; origin_edge)">void SubTopoGraph::AddPotentialOutEdge(
    TopoNode* const sub_node,
    const std::unordered_set&lt;const TopoEdge*&gt; origin_edge) {
  std::unordered_set&lt;TopoNode*&gt; other_sub_nodes;
  for (const auto* out_edge : origin_edge) {
    if (GetSubNodes(out_edge-&gt;ToNode(), &amp;other_sub_nodes)) {
      for (auto* sub_to_node : other_sub_nodes) {
        if (sub_node-&gt;GetOutEdgeTo(sub_to_node) != nullptr) {
          continue;
        }
        if (!IsReachable(sub_node, sub_to_node)) {
          continue;
        }
        std::shared_ptr&lt;TopoEdge&gt; topo_edge_ptr;
        topo_edge_ptr.reset(
            new TopoEdge(out_edge-&gt;PbEdge(), sub_node, sub_to_node));
        sub_node-&gt;AddOutEdge(topo_edge_ptr.get());
        sub_to_node-&gt;AddInEdge(topo_edge_ptr.get());
        topo_edges_.push_back(std::move(topo_edge_ptr));
      }
    } else {
      if (sub_node-&gt;GetOutEdgeTo(out_edge-&gt;ToNode()) != nullptr) {
        continue;
      }
      std::shared_ptr&lt;TopoEdge&gt; topo_edge_ptr;
      topo_edge_ptr.reset(
          new TopoEdge(out_edge-&gt;PbEdge(), sub_node, out_edge-&gt;ToNode()));
      sub_node-&gt;AddOutEdge(topo_edge_ptr.get());
      topo_edges_.push_back(std::move(topo_edge_ptr));
    }
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\range_utils.h" startLine="(25, 0)" endLine="(47, 1)" clone_start="20" clone_end="23">
			<code function_name="BinarySearchForSLarger(const std::vector&lt;T&gt;&amp; sorted_vec, double value_s)">int BinarySearchForSLarger(const std::vector&lt;T&gt;&amp; sorted_vec, double value_s) {
  if (sorted_vec.empty()) {
    return -1;
  }
  int start_index = 0;
  int end_index = sorted_vec.size() - 1;
  double internal_s = 0.0;
  int middle_index = 0;
  while (end_index - start_index &gt; 1) {
    middle_index = (start_index + end_index) / 2;
    internal_s = sorted_vec[middle_index].StartS();
    if (internal_s &gt; value_s) {
      end_index = middle_index;
    } else {
      start_index = middle_index;
    }
  }
  double end_s = sorted_vec[start_index].EndS();
  if (value_s &lt;= end_s) {
    return start_index;
  }
  return end_index;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\range_utils.h" startLine="(25, 0)" endLine="(47, 1)" clone_start="1" clone_end="18">
			<code function_name="BinarySearchForSLarger(const std::vector&lt;T&gt;&amp; sorted_vec, double value_s)">int BinarySearchForSLarger(const std::vector&lt;T&gt;&amp; sorted_vec, double value_s) {
  if (sorted_vec.empty()) {
    return -1;
  }
  int start_index = 0;
  int end_index = sorted_vec.size() - 1;
  double internal_s = 0.0;
  int middle_index = 0;
  while (end_index - start_index &gt; 1) {
    middle_index = (start_index + end_index) / 2;
    internal_s = sorted_vec[middle_index].StartS();
    if (internal_s &gt; value_s) {
      end_index = middle_index;
    } else {
      start_index = middle_index;
    }
  }
  double end_s = sorted_vec[start_index].EndS();
  if (value_s &lt;= end_s) {
    return start_index;
  }
  return end_index;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(162, 0)" endLine="(173, 1)" clone_start="1" clone_end="12">
			<code function_name="Brakeinfo74::wheel_torque_actual(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::wheel_torque_actual(const std::uint8_t *bytes,
                                        int32_t length) const {
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 6);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FFF) {
    value -= 0x4000;
  }
  return value * 4.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gyro_6c.cc" startLine="(35, 0)" endLine="(45, 1)" clone_start="1" clone_end="11">
			<code function_name="Gyro6c::roll_rate(const std::uint8_t *bytes, int32_t length) const">double Gyro6c::roll_rate(const std::uint8_t *bytes, int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.000200;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(175, 0)" endLine="(187, 1)" clone_start="1" clone_end="12">
			<code function_name="Brakeinfo74::acceleration_over_ground(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::acceleration_over_ground(const std::uint8_t *bytes,
                                             int32_t length) const {
  // vehicle acceleration over ground estimate
  Byte frame_high(bytes + 7);
  int32_t high = frame_high.get_byte(0, 2);
  Byte frame_low(bytes + 6);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FF) {
    value -= 0x400;
  }
  return value * 0.035000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gyro_6c.cc" startLine="(47, 0)" endLine="(57, 1)" clone_start="1" clone_end="10">
			<code function_name="Gyro6c::yaw_rate(const std::uint8_t *bytes, int32_t length) const">double Gyro6c::yaw_rate(const std::uint8_t *bytes, int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x7FFF) {
    value -= 0x10000;
  }
  return value * 0.000200;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\spiral_curve\quintic_spiral_curve.cc" startLine="(36, 0)" endLine="(40, 1)" clone_start="1" clone_end="5">
			<code function_name="QuinticSpiralCurve::QuinticSpiralCurve(const common::PathPoint&amp; s, const common::PathPoint&amp; e)">QuinticSpiralCurve::QuinticSpiralCurve(const common::PathPoint&amp; s,
                                       const common::PathPoint&amp; e)
    : SpiralCurve(s, e, 5) {
  // generate an order 5 spiral path with four parameters
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\spiral_curve\cubic_spiral_curve.cc" startLine="(35, 0)" endLine="(39, 1)" clone_start="1" clone_end="5">
			<code function_name="CubicSpiralCurve::CubicSpiralCurve(const common::PathPoint&amp; s, const common::PathPoint&amp; e)">CubicSpiralCurve::CubicSpiralCurve(const common::PathPoint&amp; s,
                                   const common::PathPoint&amp; e)
    : SpiralCurve(s, e, 3) {
  // generate an order 3 cubic spiral path with four parameters
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\spiral_curve\quintic_spiral_curve.cc" startLine="(42, 0)" endLine="(191, 1)" clone_start="1" clone_end="24">
			<code function_name="QuinticSpiralCurve::CalculatePath()">bool QuinticSpiralCurve::CalculatePath() {
  // extract infos
  double x_s = start_point().x();
  double y_s = start_point().y();
  double theta_s = std::fmod(start_point().theta(), s_two_pi_);

  if (theta_s &lt; 0) {
    theta_s += s_two_pi_;
  }

  double x_t = end_point().x() - x_s;  // with position
  double y_t = end_point().y() - y_s;  // with position

  double x_g = std::cos(theta_s) * x_t + std::sin(theta_s) * y_t;
  double y_g = -std::sin(theta_s) * x_t + std::cos(theta_s) * y_t;
  double theta_g = std::fmod(end_point().theta(), s_two_pi_);
  theta_g -= theta_s;

  while (theta_g &lt; -M_PI) {
    theta_g += s_two_pi_;
  }

  while (theta_g &gt; +M_PI) {
    theta_g -= s_two_pi_;
  }

  double sg = (theta_g * theta_g / 5 + 1.0) * std::sqrt(x_g * x_g + y_g * y_g);

  std::array&lt;double, 6&gt; p_shoot;
  p_shoot[0] = start_point().kappa();
  p_shoot[1] = start_point().dkappa();
  p_shoot[2] = start_point().ddkappa();
  p_shoot[3] = 0.0;
  p_shoot[4] = 0.0;
  p_shoot[5] = end_point().kappa();

  // intermediate params
  Eigen::Matrix&lt;double, 3, 1&gt; q_g;
  q_g &lt;&lt; x_g, y_g, theta_g;            // goal, x(p, sg), y(p, sg), theta(p, sg)
  Eigen::Matrix&lt;double, 3, 3&gt; jacobi;  // Jacobian matrix for newton method

  // simpson integrations func values in Jacobian
  // integration point initialization:
  double ds =
      sg / (spiral_config().simpson_size() - 1);  // bandwith for integration
  // basic theta value vectors:
  std::vector&lt;double&gt; theta(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; cos_theta(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; sin_theta(spiral_config().simpson_size(), 0.0);
  // partial derivatvies vectors for Jacobian
  std::vector&lt;double&gt; ptp_p3(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; ptp_p4(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; ptp_sg(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; sin_ptp_p3(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; sin_ptp_p4(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; sin_ptp_sg(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; cos_ptp_p3(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; cos_ptp_p4(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; cos_ptp_sg(spiral_config().simpson_size(), 0.0);
  // newton iteration difference (col) vectors
  Eigen::Matrix&lt;double, 3, 1&gt; delta_q;  // goal difference
  Eigen::Matrix&lt;double, 3, 1&gt; delta_p;  // parameter difference
  Eigen::Matrix&lt;double, 3, 1&gt;
      q_guess;      // q with current paramter, delta_q = q_g - q_guess
  double diff = 0;  // absolute error for q iteration stop

  for (int32_t nt = 0; nt &lt; spiral_config().newton_raphson_max_iter(); ++nt) {
    // calculate parameters for simpson integration
    double s = 0;

    for (int32_t i = 0; i &lt; spiral_config().simpson_size(); ++i) {
      theta[i] = SpiralFormula::theta_func_k5(s, sg, p_shoot);

      cos_theta[i] = std::cos(theta[i]);
      sin_theta[i] = std::sin(theta[i]);

      ptp_p3[i] = SpiralFormula::partial_theta_p3_k5(s, sg);
      ptp_p4[i] = SpiralFormula::partial_theta_p4_k5(s, sg);
      ptp_sg[i] = SpiralFormula::partial_theta_sg_k5(s, sg, p_shoot);

      sin_ptp_p3[i] = sin_theta[i] * ptp_p3[i];
      sin_ptp_p4[i] = sin_theta[i] * ptp_p4[i];
      sin_ptp_sg[i] = sin_theta[i] * ptp_sg[i];

      cos_ptp_p3[i] = cos_theta[i] * ptp_p3[i];
      cos_ptp_p4[i] = cos_theta[i] * ptp_p4[i];
      cos_ptp_sg[i] = cos_theta[i] * ptp_sg[i];
      s += ds;
    }

    // update Jacobian and delta q
    jacobi(0, 0) = -apollo::common::math::IntegrateBySimpson(
        sin_ptp_p3, ds, spiral_config().simpson_size());

    jacobi(0, 1) = -apollo::common::math::IntegrateBySimpson(
        sin_ptp_p4, ds, spiral_config().simpson_size());

    jacobi(0, 2) = cos_theta[spiral_config().simpson_size() - 1] -
                   apollo::common::math::IntegrateBySimpson(
                       sin_ptp_sg, ds, spiral_config().simpson_size());

    jacobi(1, 0) = apollo::common::math::IntegrateBySimpson(
        cos_ptp_p3, ds, spiral_config().simpson_size());

    jacobi(1, 1) = apollo::common::math::IntegrateBySimpson(
        cos_ptp_p4, ds, spiral_config().simpson_size());

    jacobi(1, 2) = sin_theta[spiral_config().simpson_size() - 1] +
                   apollo::common::math::IntegrateBySimpson(
                       cos_ptp_sg, ds, spiral_config().simpson_size());

    jacobi(2, 0) = ptp_p3[spiral_config().simpson_size() - 1];

    jacobi(2, 1) = ptp_p4[spiral_config().simpson_size() - 1];

    jacobi(2, 2) = ptp_sg[spiral_config().simpson_size() - 1];

    q_guess(0) = apollo::common::math::IntegrateBySimpson(
        cos_theta, ds, spiral_config().simpson_size());

    q_guess(1) = apollo::common::math::IntegrateBySimpson(
        sin_theta, ds, spiral_config().simpson_size());

    q_guess(2) = theta[spiral_config().simpson_size() - 1];

    delta_q = q_g - q_guess;

    // early stop
    diff =
        std::fabs(delta_q(0)) + std::fabs(delta_q(1)) + std::fabs(delta_q(2));

    if (diff &lt; spiral_config().newton_raphson_tol()) {
      break;
    }

    delta_p = jacobi.lu().solve(delta_q);
    // update p, sg, ds
    p_shoot[3] += delta_p(0);
    p_shoot[4] += delta_p(1);
    sg += delta_p(2);
    ds = sg / (spiral_config().simpson_size() - 1);
  }

  // update params
  PrependToPParams(p_shoot.begin(), p_shoot.end());
  set_sg(sg);
  set_error(diff);

  return diff &lt; spiral_config().newton_raphson_tol() &amp;&amp; ResultSanityCheck();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\spiral_curve\cubic_spiral_curve.cc" startLine="(41, 0)" endLine="(180, 1)" clone_start="1" clone_end="25">
			<code function_name="CubicSpiralCurve::CalculatePath()">bool CubicSpiralCurve::CalculatePath() {
  // calculate path with initialize table
  double x_s = start_point().x();
  double y_s = start_point().y();
  double theta_s = std::fmod(start_point().theta(), s_two_pi_);

  if (theta_s &lt; 0) {
    theta_s += s_two_pi_;
  }

  double x_t = end_point().x() - x_s;
  double y_t = end_point().y() - y_s;

  // with position and rotation transformation
  double x_g = std::cos(theta_s) * x_t + std::sin(theta_s) * y_t;
  double y_g = -std::sin(theta_s) * x_t + std::cos(theta_s) * y_t;
  double theta_g = std::fmod(end_point().theta(), s_two_pi_);
  theta_g -= theta_s;

  while (theta_g &lt; -M_PI) {
    theta_g += s_two_pi_;
  }

  while (theta_g &gt; +M_PI) {
    theta_g -= s_two_pi_;
  }
  std::array&lt;double, 4&gt; p_shoot;
  double sg =
      (theta_g * theta_g / 5.0 + 1.0) * std::sqrt(x_g * x_g + y_g * y_g);
  p_shoot[0] = start_point().kappa();
  p_shoot[1] = 0.0;
  p_shoot[2] = 0.0;
  p_shoot[3] = end_point().kappa();

  // intermediate params
  Eigen::Matrix&lt;double, 3, 1&gt; q_g;
  q_g &lt;&lt; x_g, y_g, theta_g;            // goal, x(p, sg), y(p, sg), theta(p, sg)
  Eigen::Matrix&lt;double, 3, 3&gt; jacobi;  // Jacobian matrix for newton method

  // simpson integrations func values in Jacobian
  // integration point initialization:
  double ds =
      sg / (spiral_config().simpson_size() - 1);  // bandwith for integration
  // basic theta value vectors:
  std::vector&lt;double&gt; theta(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; cos_theta(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; sin_theta(spiral_config().simpson_size(), 0.0);
  // partial derivatvies vectors for Jacobian
  std::vector&lt;double&gt; ptp_p1(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; ptp_p2(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; ptp_sg(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; sin_ptp_p1(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; sin_ptp_p2(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; sin_ptp_sg(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; cos_ptp_p1(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; cos_ptp_p2(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; cos_ptp_sg(spiral_config().simpson_size(), 0.0);

  // newton iteration difference (col) vectors
  Eigen::Matrix&lt;double, 3, 1&gt; delta_q;  // goal difference
  Eigen::Matrix&lt;double, 3, 1&gt; delta_p;  // parameter difference
  Eigen::Matrix&lt;double, 3, 1&gt;
      q_guess;        // q with current paramter, delta_q = q_g - q_guess
  double diff = 0.0;  // absolute error for q iteration stop

  for (int32_t nt = 0; nt &lt; spiral_config().newton_raphson_max_iter(); ++nt) {
    // calculate parameters for simpson integration
    double s = 0.0;

    for (int32_t i = 0; i &lt; spiral_config().simpson_size(); ++i) {
      theta[i] = SpiralFormula::theta_func_k3(s, sg, p_shoot);

      cos_theta[i] = std::cos(theta[i]);
      sin_theta[i] = std::sin(theta[i]);

      ptp_p1[i] = SpiralFormula::partial_theta_p1_k3(s, sg);
      ptp_p2[i] = SpiralFormula::partial_theta_p2_k3(s, sg);
      ptp_sg[i] = SpiralFormula::partial_theta_sg_k3(s, sg, p_shoot);

      sin_ptp_p1[i] = sin_theta[i] * ptp_p1[i];
      sin_ptp_p2[i] = sin_theta[i] * ptp_p2[i];
      sin_ptp_sg[i] = sin_theta[i] * ptp_sg[i];

      cos_ptp_p1[i] = cos_theta[i] * ptp_p1[i];
      cos_ptp_p2[i] = cos_theta[i] * ptp_p2[i];
      cos_ptp_sg[i] = cos_theta[i] * ptp_sg[i];
      s += ds;
    }

    // update Jacobian and delta q
    jacobi(0, 0) = -apollo::common::math::IntegrateBySimpson(
        sin_ptp_p1, ds, spiral_config().simpson_size());
    jacobi(0, 1) = -apollo::common::math::IntegrateBySimpson(
        sin_ptp_p2, ds, spiral_config().simpson_size());
    jacobi(0, 2) = cos_theta[spiral_config().simpson_size() - 1] -
                   apollo::common::math::IntegrateBySimpson(
                       sin_ptp_sg, ds, spiral_config().simpson_size());

    jacobi(1, 0) = apollo::common::math::IntegrateBySimpson(
        cos_ptp_p1, ds, spiral_config().simpson_size());
    jacobi(1, 1) = apollo::common::math::IntegrateBySimpson(
        cos_ptp_p2, ds, spiral_config().simpson_size());
    jacobi(1, 2) = sin_theta[spiral_config().simpson_size() - 1] +
                   apollo::common::math::IntegrateBySimpson(
                       cos_ptp_sg, ds, spiral_config().simpson_size());

    jacobi(2, 0) = ptp_p1[spiral_config().simpson_size() - 1];
    jacobi(2, 1) = ptp_p2[spiral_config().simpson_size() - 1];
    jacobi(2, 2) = ptp_sg[spiral_config().simpson_size() - 1];

    q_guess(0) = apollo::common::math::IntegrateBySimpson(
        cos_theta, ds, spiral_config().simpson_size());
    q_guess(1) = apollo::common::math::IntegrateBySimpson(
        sin_theta, ds, spiral_config().simpson_size());
    q_guess(2) = theta[spiral_config().simpson_size() - 1];

    delta_q = q_g - q_guess;

    diff =
        std::fabs(delta_q(0)) + std::fabs(delta_q(1)) + std::fabs(delta_q(2));

    if (diff &lt; spiral_config().newton_raphson_tol()) {
      break;
    }

    // solve by lu decomposition
    delta_p = jacobi.lu().solve(delta_q);
    // update p, sg, ds
    p_shoot[1] += delta_p(0);
    p_shoot[2] += delta_p(1);
    sg += delta_p(2);
    ds = sg / (spiral_config().simpson_size() - 1);
  }

  PrependToPParams(p_shoot.begin(), p_shoot.end());
  set_sg(sg);
  set_error(diff);

  return diff &lt; spiral_config().newton_raphson_tol() &amp;&amp; ResultSanityCheck();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(338, 0)" endLine="(380, 1)" clone_start="5" clone_end="30">
			<code function_name="ProtoOrganizer::OutputData(apollo::hdmap::Map* pb_map)">void ProtoOrganizer::OutputData(apollo::hdmap::Map* pb_map) {
  for (auto&amp; road_pair : proto_data_.pb_roads) {
    *(pb_map-&gt;add_road()) = road_pair.second;
  }
  for (auto&amp; lane_pair : proto_data_.pb_lanes) {
    *(pb_map-&gt;add_lane()) = lane_pair.second;
  }
  for (auto&amp; crosswalk_pair : proto_data_.pb_crosswalks) {
    *(pb_map-&gt;add_crosswalk()) = crosswalk_pair.second;
  }
  for (auto&amp; clear_area_pair : proto_data_.pb_clear_areas) {
    *(pb_map-&gt;add_clear_area()) = clear_area_pair.second;
  }
  for (auto&amp; speed_bump_pair : proto_data_.pb_speed_bumps) {
    *(pb_map-&gt;add_speed_bump()) = speed_bump_pair.second;
  }
  for (auto&amp; signal_pair : proto_data_.pb_signals) {
    *(pb_map-&gt;add_signal()) = signal_pair.second;
  }
  for (auto&amp; stop_sign_pair : proto_data_.pb_stop_signs) {
    *(pb_map-&gt;add_stop_sign()) = stop_sign_pair.second;
  }
  for (auto&amp; yield_sign_pair : proto_data_.pb_yield_signs) {
    *(pb_map-&gt;add_yield()) = yield_sign_pair.second;
  }
  for (auto&amp; junction_pair : proto_data_.pb_junctions) {
    *(pb_map-&gt;add_junction()) = junction_pair.second;
  }
  for (auto&amp; overlap_pair : proto_data_.pb_overlaps) {
    *(pb_map-&gt;add_overlap()) = overlap_pair.second;
  }

  AINFO &lt;&lt; "hdmap statistics: roads-" &lt;&lt; proto_data_.pb_roads.size()
        &lt;&lt; ",lanes-" &lt;&lt; proto_data_.pb_lanes.size() &lt;&lt; ",crosswalks-"
        &lt;&lt; proto_data_.pb_crosswalks.size() &lt;&lt; ",clear areas-"
        &lt;&lt; proto_data_.pb_clear_areas.size() &lt;&lt; ",speed bumps-"
        &lt;&lt; proto_data_.pb_speed_bumps.size() &lt;&lt; ",signals-"
        &lt;&lt; proto_data_.pb_signals.size() &lt;&lt; ",stop signs-"
        &lt;&lt; proto_data_.pb_stop_signs.size() &lt;&lt; ",yield signs-"
        &lt;&lt; proto_data_.pb_yield_signs.size() &lt;&lt; ",junctions-"
        &lt;&lt; proto_data_.pb_junctions.size() &lt;&lt; ",overlaps-"
        &lt;&lt; proto_data_.pb_overlaps.size();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\proto_organizer.cc" startLine="(338, 0)" endLine="(380, 1)" clone_start="2" clone_end="27">
			<code function_name="ProtoOrganizer::OutputData(apollo::hdmap::Map* pb_map)">void ProtoOrganizer::OutputData(apollo::hdmap::Map* pb_map) {
  for (auto&amp; road_pair : proto_data_.pb_roads) {
    *(pb_map-&gt;add_road()) = road_pair.second;
  }
  for (auto&amp; lane_pair : proto_data_.pb_lanes) {
    *(pb_map-&gt;add_lane()) = lane_pair.second;
  }
  for (auto&amp; crosswalk_pair : proto_data_.pb_crosswalks) {
    *(pb_map-&gt;add_crosswalk()) = crosswalk_pair.second;
  }
  for (auto&amp; clear_area_pair : proto_data_.pb_clear_areas) {
    *(pb_map-&gt;add_clear_area()) = clear_area_pair.second;
  }
  for (auto&amp; speed_bump_pair : proto_data_.pb_speed_bumps) {
    *(pb_map-&gt;add_speed_bump()) = speed_bump_pair.second;
  }
  for (auto&amp; signal_pair : proto_data_.pb_signals) {
    *(pb_map-&gt;add_signal()) = signal_pair.second;
  }
  for (auto&amp; stop_sign_pair : proto_data_.pb_stop_signs) {
    *(pb_map-&gt;add_stop_sign()) = stop_sign_pair.second;
  }
  for (auto&amp; yield_sign_pair : proto_data_.pb_yield_signs) {
    *(pb_map-&gt;add_yield()) = yield_sign_pair.second;
  }
  for (auto&amp; junction_pair : proto_data_.pb_junctions) {
    *(pb_map-&gt;add_junction()) = junction_pair.second;
  }
  for (auto&amp; overlap_pair : proto_data_.pb_overlaps) {
    *(pb_map-&gt;add_overlap()) = overlap_pair.second;
  }

  AINFO &lt;&lt; "hdmap statistics: roads-" &lt;&lt; proto_data_.pb_roads.size()
        &lt;&lt; ",lanes-" &lt;&lt; proto_data_.pb_lanes.size() &lt;&lt; ",crosswalks-"
        &lt;&lt; proto_data_.pb_crosswalks.size() &lt;&lt; ",clear areas-"
        &lt;&lt; proto_data_.pb_clear_areas.size() &lt;&lt; ",speed bumps-"
        &lt;&lt; proto_data_.pb_speed_bumps.size() &lt;&lt; ",signals-"
        &lt;&lt; proto_data_.pb_signals.size() &lt;&lt; ",stop signs-"
        &lt;&lt; proto_data_.pb_stop_signs.size() &lt;&lt; ",yield signs-"
        &lt;&lt; proto_data_.pb_yield_signs.size() &lt;&lt; ",junctions-"
        &lt;&lt; proto_data_.pb_junctions.size() &lt;&lt; ",overlaps-"
        &lt;&lt; proto_data_.pb_overlaps.size();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\tirepressure_71.cc" startLine="(47, 0)" endLine="(54, 1)" clone_start="1" clone_end="8">
			<code function_name="Tirepressure71::front_right_tire(const std::uint8_t *bytes, int32_t length) const">int32_t Tirepressure71::front_right_tire(const std::uint8_t *bytes,
                                         int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  return (high &lt;&lt; 8) | low;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\tirepressure_71.cc" startLine="(38, 0)" endLine="(45, 1)" clone_start="1" clone_end="8">
			<code function_name="Tirepressure71::front_left_tire(const std::uint8_t *bytes, int32_t length) const">int32_t Tirepressure71::front_left_tire(const std::uint8_t *bytes,
                                        int32_t length) const {
  Byte high_frame(bytes + 1);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 0);
  int32_t low = low_frame.get_byte(0, 8);
  return (high &lt;&lt; 8) | low;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\tirepressure_71.cc" startLine="(56, 0)" endLine="(63, 1)" clone_start="1" clone_end="8">
			<code function_name="Tirepressure71::rear_left_tire(const std::uint8_t *bytes, int32_t length) const">int32_t Tirepressure71::rear_left_tire(const std::uint8_t *bytes,
                                       int32_t length) const {
  Byte high_frame(bytes + 5);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 4);
  int32_t low = low_frame.get_byte(0, 8);
  return (high &lt;&lt; 8) | low;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\tirepressure_71.cc" startLine="(47, 0)" endLine="(54, 1)" clone_start="1" clone_end="8">
			<code function_name="Tirepressure71::front_right_tire(const std::uint8_t *bytes, int32_t length) const">int32_t Tirepressure71::front_right_tire(const std::uint8_t *bytes,
                                         int32_t length) const {
  Byte high_frame(bytes + 3);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 2);
  int32_t low = low_frame.get_byte(0, 8);
  return (high &lt;&lt; 8) | low;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\tirepressure_71.cc" startLine="(65, 0)" endLine="(72, 1)" clone_start="1" clone_end="7">
			<code function_name="Tirepressure71::rear_right_tire(const std::uint8_t *bytes, int32_t length) const">int32_t Tirepressure71::rear_right_tire(const std::uint8_t *bytes,
                                        int32_t length) const {
  Byte high_frame(bytes + 7);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 6);
  int32_t low = low_frame.get_byte(0, 8);
  return (high &lt;&lt; 8) | low;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\tirepressure_71.cc" startLine="(56, 0)" endLine="(63, 1)" clone_start="1" clone_end="7">
			<code function_name="Tirepressure71::rear_left_tire(const std::uint8_t *bytes, int32_t length) const">int32_t Tirepressure71::rear_left_tire(const std::uint8_t *bytes,
                                       int32_t length) const {
  Byte high_frame(bytes + 5);
  int32_t high = high_frame.get_byte(0, 8);
  Byte low_frame(bytes + 4);
  int32_t low = low_frame.get_byte(0, 8);
  return (high &lt;&lt; 8) | low;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(174, 0)" endLine="(176, 1)" clone_start="2" clone_end="3">
			<code function_name="TopoNode::IsVirtual() const">const std::unordered_set&lt;const TopoEdge*&gt;&amp; TopoNode::InFromAllEdge() const {
  return in_from_all_edge_set_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(170, 0)" endLine="(172, 1)" clone_start="2" clone_end="3">
			<code function_name="TopoNode::IsVirtual() const">const std::vector&lt;NodeSRange&gt;&amp; TopoNode::RightOutRange() const {
  return right_out_sorted_range_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(178, 0)" endLine="(180, 1)" clone_start="1" clone_end="3">
			<code function_name="TopoNode::IsVirtual() const">const std::unordered_set&lt;const TopoEdge*&gt;&amp; TopoNode::InFromLeftEdge() const {
  return in_from_left_edge_set_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(174, 0)" endLine="(176, 1)" clone_start="1" clone_end="3">
			<code function_name="TopoNode::IsVirtual() const">const std::unordered_set&lt;const TopoEdge*&gt;&amp; TopoNode::InFromAllEdge() const {
  return in_from_all_edge_set_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(182, 0)" endLine="(184, 1)" clone_start="1" clone_end="3">
			<code function_name="TopoNode::IsVirtual() const">const std::unordered_set&lt;const TopoEdge*&gt;&amp; TopoNode::InFromRightEdge() const {
  return in_from_right_edge_set_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(178, 0)" endLine="(180, 1)" clone_start="1" clone_end="3">
			<code function_name="TopoNode::IsVirtual() const">const std::unordered_set&lt;const TopoEdge*&gt;&amp; TopoNode::InFromLeftEdge() const {
  return in_from_left_edge_set_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(186, 0)" endLine="(189, 1)" clone_start="1" clone_end="4">
			<code function_name="TopoNode::IsVirtual() const">const std::unordered_set&lt;const TopoEdge*&gt;&amp; TopoNode::InFromLeftOrRightEdge()
    const {
  return in_from_left_or_right_edge_set_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(182, 0)" endLine="(184, 1)" clone_start="1" clone_end="3">
			<code function_name="TopoNode::IsVirtual() const">const std::unordered_set&lt;const TopoEdge*&gt;&amp; TopoNode::InFromRightEdge() const {
  return in_from_right_edge_set_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(191, 0)" endLine="(193, 1)" clone_start="1" clone_end="3">
			<code function_name="TopoNode::IsVirtual() const">const std::unordered_set&lt;const TopoEdge*&gt;&amp; TopoNode::InFromPreEdge() const {
  return in_from_pre_edge_set_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(186, 0)" endLine="(189, 1)" clone_start="1" clone_end="4">
			<code function_name="TopoNode::IsVirtual() const">const std::unordered_set&lt;const TopoEdge*&gt;&amp; TopoNode::InFromLeftOrRightEdge()
    const {
  return in_from_left_or_right_edge_set_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(195, 0)" endLine="(197, 1)" clone_start="1" clone_end="3">
			<code function_name="TopoNode::IsVirtual() const">const std::unordered_set&lt;const TopoEdge*&gt;&amp; TopoNode::OutToAllEdge() const {
  return out_to_all_edge_set_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(191, 0)" endLine="(193, 1)" clone_start="1" clone_end="3">
			<code function_name="TopoNode::IsVirtual() const">const std::unordered_set&lt;const TopoEdge*&gt;&amp; TopoNode::InFromPreEdge() const {
  return in_from_pre_edge_set_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(199, 0)" endLine="(201, 1)" clone_start="1" clone_end="3">
			<code function_name="TopoNode::IsVirtual() const">const std::unordered_set&lt;const TopoEdge*&gt;&amp; TopoNode::OutToLeftEdge() const {
  return out_to_left_edge_set_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(195, 0)" endLine="(197, 1)" clone_start="1" clone_end="3">
			<code function_name="TopoNode::IsVirtual() const">const std::unordered_set&lt;const TopoEdge*&gt;&amp; TopoNode::OutToAllEdge() const {
  return out_to_all_edge_set_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(203, 0)" endLine="(205, 1)" clone_start="1" clone_end="3">
			<code function_name="TopoNode::IsVirtual() const">const std::unordered_set&lt;const TopoEdge*&gt;&amp; TopoNode::OutToRightEdge() const {
  return out_to_right_edge_set_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(199, 0)" endLine="(201, 1)" clone_start="1" clone_end="3">
			<code function_name="TopoNode::IsVirtual() const">const std::unordered_set&lt;const TopoEdge*&gt;&amp; TopoNode::OutToLeftEdge() const {
  return out_to_left_edge_set_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(207, 0)" endLine="(210, 1)" clone_start="1" clone_end="4">
			<code function_name="TopoNode::IsVirtual() const">const std::unordered_set&lt;const TopoEdge*&gt;&amp; TopoNode::OutToLeftOrRightEdge()
    const {
  return out_to_left_or_right_edge_set_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(203, 0)" endLine="(205, 1)" clone_start="1" clone_end="3">
			<code function_name="TopoNode::IsVirtual() const">const std::unordered_set&lt;const TopoEdge*&gt;&amp; TopoNode::OutToRightEdge() const {
  return out_to_right_edge_set_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(212, 0)" endLine="(214, 1)" clone_start="1" clone_end="2">
			<code function_name="TopoNode::IsVirtual() const">const std::unordered_set&lt;const TopoEdge*&gt;&amp; TopoNode::OutToSucEdge() const {
  return out_to_suc_edge_set_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(207, 0)" endLine="(210, 1)" clone_start="1" clone_end="3">
			<code function_name="TopoNode::IsVirtual() const">const std::unordered_set&lt;const TopoEdge*&gt;&amp; TopoNode::OutToLeftOrRightEdge()
    const {
  return out_to_left_or_right_edge_set_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(141, 0)" endLine="(264, 1)" clone_start="34" clone_end="59">
			<code function_name="RawStream::init(const std::string &amp;cfg_file)">bool RawStream::init(const std::string &amp;cfg_file) {
  if (!_stream_status) {
    ROS_ERROR_STREAM("New stream status failed.");
    return false;
  }
  _stream_status-&gt;mutable_header()-&gt;set_timestamp_sec(ros::Time::now().toSec());
  _stream_status-&gt;set_ins_stream_type(
      apollo::common::gnss_status::StreamStatus::DISCONNECTED);
  _stream_status-&gt;set_rtk_stream_in_type(
      apollo::common::gnss_status::StreamStatus::DISCONNECTED);
  _stream_status-&gt;set_rtk_stream_out_type(
      apollo::common::gnss_status::StreamStatus::DISCONNECTED);
  _stream_status_publisher.publish(_stream_status);
  if (!parse_config_text(cfg_file, &amp;_config)) {
    ROS_INFO("Parse config context failed.");
    return false;
  }
  ROS_INFO_STREAM("Loaded config:\n" &lt;&lt; _config.DebugString());

  // Creates streams.
  Stream *s = nullptr;
  if (!_config.has_data()) {
    ROS_INFO("Error: Config file must provide the data stream.");
    return false;
  }
  s = create_stream(_config.data());
  if (s == nullptr) {
    ROS_ERROR("Failed to create data stream.");
    return false;
  }
  _data_stream.reset(s);

  Status *status = new Status();
  if (!status) {
    ROS_ERROR("Failed to create data stream status.");
    return false;
  }
  _data_stream_status.reset(status);

  if (_config.has_command()) {
    s = create_stream(_config.command());
    if (s == nullptr) {
      ROS_ERROR("Failed to create command stream.");
      return false;
    }
    _command_stream.reset(s);

    status = new Status();
    if (!status) {
      ROS_ERROR("Failed to create command stream status.");
      return false;
    }
    _command_stream_status.reset(status);
  } else {
    _command_stream = _data_stream;
    _command_stream_status = _data_stream_status;
  }

  if (_config.has_rtk_from()) {
    s = create_stream(_config.rtk_from());
    if (s == nullptr) {
      ROS_ERROR("Failed to create rtk_from stream.");
      return false;
    }
    _in_rtk_stream.reset(s);

    status = new Status();
    if (!status) {
      ROS_ERROR("Failed to create rtk_from stream status.");
      return false;
    }
    _in_rtk_stream_status.reset(status);

    if (_config.has_rtk_to()) {
      s = create_stream(_config.rtk_to());
      if (s == nullptr) {
        ROS_ERROR("Failed to create rtk_to stream.");
        return false;
      }
      _out_rtk_stream.reset(s);

      status = new Status();
      if (!status) {
        ROS_ERROR("Failed to create rtk_to stream status.");
        return false;
      }
      _out_rtk_stream_status.reset(status);
    } else {
      _out_rtk_stream = _data_stream;
      _out_rtk_stream_status = _data_stream_status;
    }

    if (_config.has_rtk_solution_type()) {
      if (_config.rtk_solution_type() ==
          config::Config::RTK_SOFTWARE_SOLUTION) {
        _rtk_software_solution = true;
      }
    }
  }

  if (_config.login_commands_size() == 0) {
    ROS_WARN("No login_commands in config file.");
  }

  if (_config.logout_commands_size() == 0) {
    ROS_WARN("No logout_commands in config file.");
  }

  // connect and login
  if (!connect()) {
    ROS_ERROR("gnss driver connect failed.");
    return false;
  }

  if (!login()) {
    ROS_ERROR("gnss driver login failed.");
    return false;
  }

  _data_thread_ptr.reset(new std::thread(&amp;RawStream::data_spin, this));
  _ntrip_thread_ptr.reset(new std::thread(&amp;RawStream::ntrip_spin, this));

  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\raw_stream.cpp" startLine="(141, 0)" endLine="(264, 1)" clone_start="68" clone_end="93">
			<code function_name="RawStream::init(const std::string &amp;cfg_file)">bool RawStream::init(const std::string &amp;cfg_file) {
  if (!_stream_status) {
    ROS_ERROR_STREAM("New stream status failed.");
    return false;
  }
  _stream_status-&gt;mutable_header()-&gt;set_timestamp_sec(ros::Time::now().toSec());
  _stream_status-&gt;set_ins_stream_type(
      apollo::common::gnss_status::StreamStatus::DISCONNECTED);
  _stream_status-&gt;set_rtk_stream_in_type(
      apollo::common::gnss_status::StreamStatus::DISCONNECTED);
  _stream_status-&gt;set_rtk_stream_out_type(
      apollo::common::gnss_status::StreamStatus::DISCONNECTED);
  _stream_status_publisher.publish(_stream_status);
  if (!parse_config_text(cfg_file, &amp;_config)) {
    ROS_INFO("Parse config context failed.");
    return false;
  }
  ROS_INFO_STREAM("Loaded config:\n" &lt;&lt; _config.DebugString());

  // Creates streams.
  Stream *s = nullptr;
  if (!_config.has_data()) {
    ROS_INFO("Error: Config file must provide the data stream.");
    return false;
  }
  s = create_stream(_config.data());
  if (s == nullptr) {
    ROS_ERROR("Failed to create data stream.");
    return false;
  }
  _data_stream.reset(s);

  Status *status = new Status();
  if (!status) {
    ROS_ERROR("Failed to create data stream status.");
    return false;
  }
  _data_stream_status.reset(status);

  if (_config.has_command()) {
    s = create_stream(_config.command());
    if (s == nullptr) {
      ROS_ERROR("Failed to create command stream.");
      return false;
    }
    _command_stream.reset(s);

    status = new Status();
    if (!status) {
      ROS_ERROR("Failed to create command stream status.");
      return false;
    }
    _command_stream_status.reset(status);
  } else {
    _command_stream = _data_stream;
    _command_stream_status = _data_stream_status;
  }

  if (_config.has_rtk_from()) {
    s = create_stream(_config.rtk_from());
    if (s == nullptr) {
      ROS_ERROR("Failed to create rtk_from stream.");
      return false;
    }
    _in_rtk_stream.reset(s);

    status = new Status();
    if (!status) {
      ROS_ERROR("Failed to create rtk_from stream status.");
      return false;
    }
    _in_rtk_stream_status.reset(status);

    if (_config.has_rtk_to()) {
      s = create_stream(_config.rtk_to());
      if (s == nullptr) {
        ROS_ERROR("Failed to create rtk_to stream.");
        return false;
      }
      _out_rtk_stream.reset(s);

      status = new Status();
      if (!status) {
        ROS_ERROR("Failed to create rtk_to stream status.");
        return false;
      }
      _out_rtk_stream_status.reset(status);
    } else {
      _out_rtk_stream = _data_stream;
      _out_rtk_stream_status = _data_stream_status;
    }

    if (_config.has_rtk_solution_type()) {
      if (_config.rtk_solution_type() ==
          config::Config::RTK_SOFTWARE_SOLUTION) {
        _rtk_software_solution = true;
      }
    }
  }

  if (_config.login_commands_size() == 0) {
    ROS_WARN("No login_commands in config file.");
  }

  if (_config.logout_commands_size() == 0) {
    ROS_WARN("No logout_commands in config file.");
  }

  // connect and login
  if (!connect()) {
    ROS_ERROR("gnss driver connect failed.");
    return false;
  }

  if (!login()) {
    ROS_ERROR("gnss driver login failed.");
    return false;
  }

  _data_thread_ptr.reset(new std::thread(&amp;RawStream::data_spin, this));
  _ntrip_thread_ptr.reset(new std::thread(&amp;RawStream::ntrip_spin, this));

  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(376, 0)" endLine="(455, 1)" clone_start="34" clone_end="52">
			<code function_name="NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs)">bool NovatelParser::handle_best_pos(const novatel::BestPos* pos,
                                    uint16_t gps_week, uint32_t gps_millisecs) {
  _gnss.mutable_position()-&gt;set_lon(pos-&gt;longitude);
  _gnss.mutable_position()-&gt;set_lat(pos-&gt;latitude);
  _gnss.mutable_position()-&gt;set_height(pos-&gt;height_msl + pos-&gt;undulation);
  _gnss.mutable_position_std_dev()-&gt;set_x(pos-&gt;longitude_std_dev);
  _gnss.mutable_position_std_dev()-&gt;set_y(pos-&gt;latitude_std_dev);
  _gnss.mutable_position_std_dev()-&gt;set_z(pos-&gt;height_std_dev);
  _gnss.set_num_sats(pos-&gt;num_sats_in_solution);
  if (_solution_status != pos-&gt;solution_status) {
    _solution_status = pos-&gt;solution_status;
    ROS_INFO_STREAM("Solution status: " &lt;&lt; static_cast&lt;int&gt;(_solution_status));
  }
  if (_position_type != pos-&gt;position_type) {
    _position_type = pos-&gt;position_type;
    ROS_INFO_STREAM("Position type: " &lt;&lt; static_cast&lt;int&gt;(_position_type));
  }
  _gnss.set_solution_status(static_cast&lt;uint32_t&gt;(pos-&gt;solution_status));
  if (pos-&gt;solution_status == novatel::SolutionStatus::SOL_COMPUTED) {
    _gnss.set_position_type(static_cast&lt;uint32_t&gt;(pos-&gt;position_type));
    switch (pos-&gt;position_type) {
      case novatel::SolutionType::SINGLE:
      case novatel::SolutionType::INS_PSRSP:
        _gnss.set_type(apollo::drivers::gnss::Gnss::SINGLE);
        break;
      case novatel::SolutionType::PSRDIFF:
      case novatel::SolutionType::WAAS:
      case novatel::SolutionType::INS_SBAS:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PSRDIFF);
        break;
      case novatel::SolutionType::FLOATCONV:
      case novatel::SolutionType::L1_FLOAT:
      case novatel::SolutionType::IONOFREE_FLOAT:
      case novatel::SolutionType::NARROW_FLOAT:
      case novatel::SolutionType::RTK_DIRECT_INS:
      case novatel::SolutionType::INS_RTKFLOAT:
        _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_FLOAT);
        break;
      case novatel::SolutionType::WIDELANE:
      case novatel::SolutionType::NARROWLANE:
      case novatel::SolutionType::L1_INT:
      case novatel::SolutionType::WIDE_INT:
      case novatel::SolutionType::NARROW_INT:
      case novatel::SolutionType::INS_RTKFIXED:
        _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_INTEGER);
        break;
      case novatel::SolutionType::OMNISTAR:
      case novatel::SolutionType::INS_OMNISTAR:
      case novatel::SolutionType::INS_OMNISTAR_HP:
      case novatel::SolutionType::INS_OMNISTAR_XP:
      case novatel::SolutionType::OMNISTAR_HP:
      case novatel::SolutionType::OMNISTAR_XP:
      case novatel::SolutionType::PPP_CONVERGING:
      case novatel::SolutionType::PPP:
      case novatel::SolutionType::INS_PPP_CONVERGING:
      case novatel::SolutionType::INS_PPP:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PPP);
        break;
      case novatel::SolutionType::PROPOGATED:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PROPAGATED);
        break;
      default:
        _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
    }
  } else {
    _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
    _gnss.set_position_type(0);
  }
  if (pos-&gt;datum_id != novatel::DatumId::WGS84) {
    ROS_ERROR_STREAM_THROTTLE(
        5, "Unexpected Datum Id: " &lt;&lt; static_cast&lt;int&gt;(pos-&gt;datum_id));
  }

  double seconds = gps_week * SECONDS_PER_WEEK + gps_millisecs * 1e-3;
  if (_gnss.measurement_time() != seconds) {
    _gnss.set_measurement_time(seconds);
    return false;
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(376, 0)" endLine="(455, 1)" clone_start="26" clone_end="44">
			<code function_name="NovatelParser::handle_best_pos(const novatel::BestPos* pos, uint16_t gps_week, uint32_t gps_millisecs)">bool NovatelParser::handle_best_pos(const novatel::BestPos* pos,
                                    uint16_t gps_week, uint32_t gps_millisecs) {
  _gnss.mutable_position()-&gt;set_lon(pos-&gt;longitude);
  _gnss.mutable_position()-&gt;set_lat(pos-&gt;latitude);
  _gnss.mutable_position()-&gt;set_height(pos-&gt;height_msl + pos-&gt;undulation);
  _gnss.mutable_position_std_dev()-&gt;set_x(pos-&gt;longitude_std_dev);
  _gnss.mutable_position_std_dev()-&gt;set_y(pos-&gt;latitude_std_dev);
  _gnss.mutable_position_std_dev()-&gt;set_z(pos-&gt;height_std_dev);
  _gnss.set_num_sats(pos-&gt;num_sats_in_solution);
  if (_solution_status != pos-&gt;solution_status) {
    _solution_status = pos-&gt;solution_status;
    ROS_INFO_STREAM("Solution status: " &lt;&lt; static_cast&lt;int&gt;(_solution_status));
  }
  if (_position_type != pos-&gt;position_type) {
    _position_type = pos-&gt;position_type;
    ROS_INFO_STREAM("Position type: " &lt;&lt; static_cast&lt;int&gt;(_position_type));
  }
  _gnss.set_solution_status(static_cast&lt;uint32_t&gt;(pos-&gt;solution_status));
  if (pos-&gt;solution_status == novatel::SolutionStatus::SOL_COMPUTED) {
    _gnss.set_position_type(static_cast&lt;uint32_t&gt;(pos-&gt;position_type));
    switch (pos-&gt;position_type) {
      case novatel::SolutionType::SINGLE:
      case novatel::SolutionType::INS_PSRSP:
        _gnss.set_type(apollo::drivers::gnss::Gnss::SINGLE);
        break;
      case novatel::SolutionType::PSRDIFF:
      case novatel::SolutionType::WAAS:
      case novatel::SolutionType::INS_SBAS:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PSRDIFF);
        break;
      case novatel::SolutionType::FLOATCONV:
      case novatel::SolutionType::L1_FLOAT:
      case novatel::SolutionType::IONOFREE_FLOAT:
      case novatel::SolutionType::NARROW_FLOAT:
      case novatel::SolutionType::RTK_DIRECT_INS:
      case novatel::SolutionType::INS_RTKFLOAT:
        _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_FLOAT);
        break;
      case novatel::SolutionType::WIDELANE:
      case novatel::SolutionType::NARROWLANE:
      case novatel::SolutionType::L1_INT:
      case novatel::SolutionType::WIDE_INT:
      case novatel::SolutionType::NARROW_INT:
      case novatel::SolutionType::INS_RTKFIXED:
        _gnss.set_type(apollo::drivers::gnss::Gnss::RTK_INTEGER);
        break;
      case novatel::SolutionType::OMNISTAR:
      case novatel::SolutionType::INS_OMNISTAR:
      case novatel::SolutionType::INS_OMNISTAR_HP:
      case novatel::SolutionType::INS_OMNISTAR_XP:
      case novatel::SolutionType::OMNISTAR_HP:
      case novatel::SolutionType::OMNISTAR_XP:
      case novatel::SolutionType::PPP_CONVERGING:
      case novatel::SolutionType::PPP:
      case novatel::SolutionType::INS_PPP_CONVERGING:
      case novatel::SolutionType::INS_PPP:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PPP);
        break;
      case novatel::SolutionType::PROPOGATED:
        _gnss.set_type(apollo::drivers::gnss::Gnss::PROPAGATED);
        break;
      default:
        _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
    }
  } else {
    _gnss.set_type(apollo::drivers::gnss::Gnss::INVALID);
    _gnss.set_position_type(0);
  }
  if (pos-&gt;datum_id != novatel::DatumId::WGS84) {
    ROS_ERROR_STREAM_THROTTLE(
        5, "Unexpected Datum Id: " &lt;&lt; static_cast&lt;int&gt;(pos-&gt;datum_id));
  }

  double seconds = gps_week * SECONDS_PER_WEEK + gps_millisecs * 1e-3;
  if (_gnss.measurement_time() != seconds) {
    _gnss.set_measurement_time(seconds);
    return false;
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(48, 0)" endLine="(58, 1)" clone_start="7" clone_end="11">
			<code function_name="ObjectTrack::SetTrackCachedHistorySizeMaximum( const int&amp; track_cached_history_size_maximum)">bool ObjectTrack::SetTrackCachedHistorySizeMaximum(
    const int&amp; track_cached_history_size_maximum) {
  if (track_cached_history_size_maximum &gt; 0) {
    s_track_cached_history_size_maximum_ = track_cached_history_size_maximum;
    AINFO &lt;&lt; "track cached history size maximum of object track is "
          &lt;&lt; s_track_cached_history_size_maximum_;
    return true;
  }
  AERROR &lt;&lt; "invalid track cached history size maximum of object track!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(38, 0)" endLine="(46, 1)" clone_start="5" clone_end="9">
			<code function_name="ObjectTrack::SetFilterMethod(const std::string&amp; filter_method_name)">bool ObjectTrack::SetFilterMethod(const std::string&amp; filter_method_name) {
  if (filter_method_name == "kalman_filter") {
    s_filter_method_ = KALMAN_FILTER;
    AINFO &lt;&lt; "filter method of object track is " &lt;&lt; filter_method_name;
    return true;
  }
  AERROR &lt;&lt; "invalid filter method name of object track!";
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(60, 0)" endLine="(69, 1)" clone_start="1" clone_end="10">
			<code function_name="ObjectTrack::SetSpeedNoiseMaximum(const double&amp; speed_noise_maximum)">bool ObjectTrack::SetSpeedNoiseMaximum(const double&amp; speed_noise_maximum) {
  if (speed_noise_maximum &gt; 0) {
    s_speed_noise_maximum_ = speed_noise_maximum;
    AINFO &lt;&lt; "speed noise maximum of object track is "
          &lt;&lt; s_speed_noise_maximum_;
    return true;
  }
  AERROR &lt;&lt; "invalid speed noise maximum of object track!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(48, 0)" endLine="(58, 1)" clone_start="1" clone_end="11">
			<code function_name="ObjectTrack::SetTrackCachedHistorySizeMaximum( const int&amp; track_cached_history_size_maximum)">bool ObjectTrack::SetTrackCachedHistorySizeMaximum(
    const int&amp; track_cached_history_size_maximum) {
  if (track_cached_history_size_maximum &gt; 0) {
    s_track_cached_history_size_maximum_ = track_cached_history_size_maximum;
    AINFO &lt;&lt; "track cached history size maximum of object track is "
          &lt;&lt; s_track_cached_history_size_maximum_;
    return true;
  }
  AERROR &lt;&lt; "invalid track cached history size maximum of object track!";
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(71, 0)" endLine="(81, 1)" clone_start="1" clone_end="10">
			<code function_name="ObjectTrack::SetAccelerationNoiseMaximum( const double&amp; acceleration_noise_maximum)">bool ObjectTrack::SetAccelerationNoiseMaximum(
    const double&amp; acceleration_noise_maximum) {
  if (acceleration_noise_maximum &gt; 0) {
    s_acceleration_noise_maximum_ = acceleration_noise_maximum;
    AINFO &lt;&lt; "acceleration noise maximum of object track is "
          &lt;&lt; s_acceleration_noise_maximum_;
    return true;
  }
  AERROR &lt;&lt; "invalid acceleration noise maximum of object track!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(60, 0)" endLine="(69, 1)" clone_start="1" clone_end="9">
			<code function_name="ObjectTrack::SetSpeedNoiseMaximum(const double&amp; speed_noise_maximum)">bool ObjectTrack::SetSpeedNoiseMaximum(const double&amp; speed_noise_maximum) {
  if (speed_noise_maximum &gt; 0) {
    s_speed_noise_maximum_ = speed_noise_maximum;
    AINFO &lt;&lt; "speed noise maximum of object track is "
          &lt;&lt; s_speed_noise_maximum_;
    return true;
  }
  AERROR &lt;&lt; "invalid speed noise maximum of object track!";
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(258, 0)" endLine="(280, 1)" clone_start="1" clone_end="22">
			<code function_name="TopoNode::AddInEdge(const TopoEdge* edge)">void TopoNode::AddInEdge(const TopoEdge* edge) {
  if (edge-&gt;ToNode() != this) {
    return;
  }
  if (in_edge_map_.count(edge-&gt;FromNode()) != 0) {
    return;
  }
  switch (edge-&gt;Type()) {
    case TET_LEFT:
      in_from_right_edge_set_.insert(edge);
      in_from_left_or_right_edge_set_.insert(edge);
      break;
    case TET_RIGHT:
      in_from_left_edge_set_.insert(edge);
      in_from_left_or_right_edge_set_.insert(edge);
      break;
    default:
      in_from_pre_edge_set_.insert(edge);
      break;
  }
  in_from_all_edge_set_.insert(edge);
  in_edge_map_[edge-&gt;FromNode()] = edge;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\graph\topo_node.cc" startLine="(282, 0)" endLine="(304, 1)" clone_start="1" clone_end="22">
			<code function_name="TopoNode::AddOutEdge(const TopoEdge* edge)">void TopoNode::AddOutEdge(const TopoEdge* edge) {
  if (edge-&gt;FromNode() != this) {
    return;
  }
  if (out_edge_map_.count(edge-&gt;ToNode()) != 0) {
    return;
  }
  switch (edge-&gt;Type()) {
    case TET_LEFT:
      out_to_left_edge_set_.insert(edge);
      out_to_left_or_right_edge_set_.insert(edge);
      break;
    case TET_RIGHT:
      out_to_right_edge_set_.insert(edge);
      out_to_left_or_right_edge_set_.insert(edge);
      break;
    default:
      out_to_suc_edge_set_.insert(edge);
      break;
  }
  out_to_all_edge_set_.insert(edge);
  out_edge_map_[edge-&gt;ToNode()] = edge;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(356, 0)" endLine="(390, 1)" clone_start="25" clone_end="35">
			<code function_name="Spline1dConstraint::AddDerivativeSmoothConstraint()">bool Spline1dConstraint::AddDerivativeSmoothConstraint() {
  if (x_knots_.size() &lt; 3) {
    return false;
  }

  const std::uint32_t n_constraint = (x_knots_.size() - 2) * 2;
  Eigen::MatrixXd equality_constraint = Eigen::MatrixXd::Zero(
      n_constraint, (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd equality_boundary = Eigen::MatrixXd::Zero(n_constraint, 1);

  for (std::uint32_t i = 0; i &lt; n_constraint; i += 2) {
    double left_coef = 1.0;
    double right_coef = -1.0;
    double left_dcoef = 1.0;
    double right_dcoef = -1.0;
    const double x_left = x_knots_[i / 2 + 1] - x_knots_[i / 2];
    const double x_right = 0.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      equality_constraint(i, spline_order_ * (i / 2) + j) = left_coef;
      equality_constraint(i, spline_order_ * ((i / 2) + 1) + j) = right_coef;
      if (j &gt;= 1) {
        equality_constraint(i + 1, spline_order_ * (i / 2) + j) =
            left_dcoef * j;
        equality_constraint(i + 1, spline_order_ * ((i / 2) + 1) + j) =
            right_dcoef * j;
        left_dcoef = left_coef;
        right_dcoef = right_coef;
      }
      left_coef *= x_left;
      right_coef *= x_right;
    }
  }
  return equality_constraint_.AddConstraint(equality_constraint,
                                            equality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(392, 0)" endLine="(439, 1)" clone_start="38" clone_end="48">
			<code function_name="Spline1dConstraint::AddSecondDerivativeSmoothConstraint()">bool Spline1dConstraint::AddSecondDerivativeSmoothConstraint() {
  if (x_knots_.size() &lt; 3) {
    return false;
  }

  const std::uint32_t n_constraint = (x_knots_.size() - 2) * 3;
  Eigen::MatrixXd equality_constraint = Eigen::MatrixXd::Zero(
      n_constraint, (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd equality_boundary = Eigen::MatrixXd::Zero(n_constraint, 1);

  for (std::uint32_t i = 0; i &lt; n_constraint; i += 3) {
    double left_coef = 1.0;
    double right_coef = -1.0;
    double left_dcoef = 1.0;
    double right_dcoef = -1.0;
    double left_ddcoef = 1.0;
    double right_ddcoef = -1.0;

    const double x_left = x_knots_[i / 3 + 1] - x_knots_[i / 3];
    const double x_right = 0.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      equality_constraint(i, spline_order_ * (i / 3) + j) = left_coef;
      equality_constraint(i, spline_order_ * (i / 3 + 1) + j) = right_coef;

      if (j &gt;= 2) {
        equality_constraint(i + 2, spline_order_ * i / 3 + j) =
            left_ddcoef * j * (j - 1);
        equality_constraint(i + 2, spline_order_ * (i / 3 + 1) + j) =
            right_ddcoef * j * (j - 1);
        left_ddcoef = left_dcoef;
        right_ddcoef = right_dcoef;
      }

      if (j &gt;= 1) {
        equality_constraint(i + 1, spline_order_ * (i / 3) + j) =
            left_dcoef * j;
        equality_constraint(i + 1, spline_order_ * (i / 3 + 1) + j) =
            right_dcoef * j;
        left_dcoef = left_coef;
        right_dcoef = right_coef;
      }
      left_coef *= x_left;
      right_coef *= x_right;
    }
  }
  return equality_constraint_.AddConstraint(equality_constraint,
                                            equality_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(392, 0)" endLine="(439, 1)" clone_start="1" clone_end="17">
			<code function_name="Spline1dConstraint::AddSecondDerivativeSmoothConstraint()">bool Spline1dConstraint::AddSecondDerivativeSmoothConstraint() {
  if (x_knots_.size() &lt; 3) {
    return false;
  }

  const std::uint32_t n_constraint = (x_knots_.size() - 2) * 3;
  Eigen::MatrixXd equality_constraint = Eigen::MatrixXd::Zero(
      n_constraint, (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd equality_boundary = Eigen::MatrixXd::Zero(n_constraint, 1);

  for (std::uint32_t i = 0; i &lt; n_constraint; i += 3) {
    double left_coef = 1.0;
    double right_coef = -1.0;
    double left_dcoef = 1.0;
    double right_dcoef = -1.0;
    double left_ddcoef = 1.0;
    double right_ddcoef = -1.0;

    const double x_left = x_knots_[i / 3 + 1] - x_knots_[i / 3];
    const double x_right = 0.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      equality_constraint(i, spline_order_ * (i / 3) + j) = left_coef;
      equality_constraint(i, spline_order_ * (i / 3 + 1) + j) = right_coef;

      if (j &gt;= 2) {
        equality_constraint(i + 2, spline_order_ * i / 3 + j) =
            left_ddcoef * j * (j - 1);
        equality_constraint(i + 2, spline_order_ * (i / 3 + 1) + j) =
            right_ddcoef * j * (j - 1);
        left_ddcoef = left_dcoef;
        right_ddcoef = right_dcoef;
      }

      if (j &gt;= 1) {
        equality_constraint(i + 1, spline_order_ * (i / 3) + j) =
            left_dcoef * j;
        equality_constraint(i + 1, spline_order_ * (i / 3 + 1) + j) =
            right_dcoef * j;
        left_dcoef = left_coef;
        right_dcoef = right_coef;
      }
      left_coef *= x_left;
      right_coef *= x_right;
    }
  }
  return equality_constraint_.AddConstraint(equality_constraint,
                                            equality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(441, 0)" endLine="(499, 1)" clone_start="1" clone_end="17">
			<code function_name="Spline1dConstraint::AddThirdDerivativeSmoothConstraint()">bool Spline1dConstraint::AddThirdDerivativeSmoothConstraint() {
  if (x_knots_.size() &lt; 3) {
    return false;
  }

  const std::uint32_t n_constraint = (x_knots_.size() - 2) * 4;
  Eigen::MatrixXd equality_constraint = Eigen::MatrixXd::Zero(
      n_constraint, (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd equality_boundary = Eigen::MatrixXd::Zero(n_constraint, 1);

  for (std::uint32_t i = 0; i &lt; n_constraint; i += 4) {
    double left_coef = 1.0;
    double right_coef = -1.0;
    double left_dcoef = 1.0;
    double right_dcoef = -1.0;
    double left_ddcoef = 1.0;
    double right_ddcoef = -1.0;
    double left_dddcoef = 1.0;
    double right_dddcoef = -1.0;

    const double x_left = x_knots_[i / 4 + 1] - x_knots_[i / 4];
    const double x_right = 0.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      equality_constraint(i, spline_order_ * i / 4 + j) = left_coef;
      equality_constraint(i, spline_order_ * (i / 4 + 1) + j) = right_coef;

      if (j &gt;= 3) {
        equality_constraint(i + 3, spline_order_ * i / 4 + j) =
            left_dddcoef * j * (j - 1) * (j - 2);
        equality_constraint(i + 3, spline_order_ * (i / 4 + 1) + j) =
            right_dddcoef * j * (j - 1) * (j - 2);
        left_dddcoef = left_ddcoef;
        right_dddcoef = right_ddcoef;
      }

      if (j &gt;= 2) {
        equality_constraint(i + 2, spline_order_ * i / 4 + j) =
            left_ddcoef * j * (j - 1);
        equality_constraint(i + 2, spline_order_ * (i / 4 + 1) + j) =
            right_ddcoef * j * (j - 1);
        left_ddcoef = left_dcoef;
        right_ddcoef = right_dcoef;
      }

      if (j &gt;= 1) {
        equality_constraint(i + 1, spline_order_ * i / 4 + j) = left_dcoef * j;
        equality_constraint(i + 1, spline_order_ * (i / 4 + 1) + j) =
            right_dcoef * j;
        left_dcoef = left_coef;
        right_dcoef = right_coef;
      }

      left_coef *= x_left;
      right_coef *= x_right;
    }
  }
  return equality_constraint_.AddConstraint(equality_constraint,
                                            equality_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\objects_xml_parser.cc" startLine="(59, 0)" endLine="(94, 1)" clone_start="30" clone_end="36">
			<code function_name="ObjectsXmlParser::ParseClearAreas(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;PbClearArea&gt;* clear_areas)">Status ObjectsXmlParser::ParseClearAreas(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;PbClearArea&gt;* clear_areas) {
  CHECK_NOTNULL(clear_areas);
  const tinyxml2::XMLElement* sub_node = xml_node.FirstChildElement("object");
  while (sub_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
    checker +=
        UtilXmlParser::QueryStringAttribute(*sub_node, "type", &amp;object_type);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse object type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "clearArea") {
      PbClearArea clear_area;
      clear_area.mutable_id()-&gt;set_id(object_id);
      PbPolygon* polygon = clear_area.mutable_polygon();
      CHECK(polygon != nullptr);
      const tinyxml2::XMLElement* outline_node =
          sub_node-&gt;FirstChildElement("outline");
      if (outline_node == nullptr) {
        std::string err_msg = "Error parse cleararea outline";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseOutline(*outline_node, polygon));
      clear_areas-&gt;emplace_back(clear_area);
    }
    sub_node = sub_node-&gt;NextSiblingElement("object");
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\objects_xml_parser.cc" startLine="(96, 0)" endLine="(134, 1)" clone_start="34" clone_end="39">
			<code function_name="ObjectsXmlParser::ParseSpeedBumps(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;PbSpeedBump&gt;* speed_bumps)">Status ObjectsXmlParser::ParseSpeedBumps(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;PbSpeedBump&gt;* speed_bumps) {
  CHECK_NOTNULL(speed_bumps);
  const tinyxml2::XMLElement* object_node =
      xml_node.FirstChildElement("object");
  while (object_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*object_node, "id", &amp;object_id);
    checker +=
        UtilXmlParser::QueryStringAttribute(*object_node, "type", &amp;object_type);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse object type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "speedBump") {
      PbSpeedBump speed_bump;
      const tinyxml2::XMLElement* sub_node =
          object_node-&gt;FirstChildElement("geometry");
      speed_bump.mutable_id()-&gt;set_id(object_id);
      while (sub_node) {
        PbCurve* curve = speed_bump.add_position();
        PbCurveSegment* curve_segment = curve-&gt;add_segment();
        RETURN_IF_ERROR(UtilXmlParser::ParseGeometry(*sub_node, curve_segment));
        sub_node = sub_node-&gt;NextSiblingElement("geometry");
      }
      if (speed_bump.position_size() &lt;= 0) {
        std::string err_msg = "Error speed bump miss stop line.";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      speed_bumps-&gt;emplace_back(speed_bump);
    }
    object_node = object_node-&gt;NextSiblingElement("object");
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\objects_xml_parser.cc" startLine="(96, 0)" endLine="(134, 1)" clone_start="1" clone_end="20">
			<code function_name="ObjectsXmlParser::ParseSpeedBumps(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;PbSpeedBump&gt;* speed_bumps)">Status ObjectsXmlParser::ParseSpeedBumps(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;PbSpeedBump&gt;* speed_bumps) {
  CHECK_NOTNULL(speed_bumps);
  const tinyxml2::XMLElement* object_node =
      xml_node.FirstChildElement("object");
  while (object_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*object_node, "id", &amp;object_id);
    checker +=
        UtilXmlParser::QueryStringAttribute(*object_node, "type", &amp;object_type);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse object type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "speedBump") {
      PbSpeedBump speed_bump;
      const tinyxml2::XMLElement* sub_node =
          object_node-&gt;FirstChildElement("geometry");
      speed_bump.mutable_id()-&gt;set_id(object_id);
      while (sub_node) {
        PbCurve* curve = speed_bump.add_position();
        PbCurveSegment* curve_segment = curve-&gt;add_segment();
        RETURN_IF_ERROR(UtilXmlParser::ParseGeometry(*sub_node, curve_segment));
        sub_node = sub_node-&gt;NextSiblingElement("geometry");
      }
      if (speed_bump.position_size() &lt;= 0) {
        std::string err_msg = "Error speed bump miss stop line.";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      speed_bumps-&gt;emplace_back(speed_bump);
    }
    object_node = object_node-&gt;NextSiblingElement("object");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\objects_xml_parser.cc" startLine="(136, 0)" endLine="(170, 1)" clone_start="1" clone_end="20">
			<code function_name="ObjectsXmlParser::ParseStopLines(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;StopLineInternal&gt;* stop_lines)">Status ObjectsXmlParser::ParseStopLines(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;StopLineInternal&gt;* stop_lines) {
  CHECK_NOTNULL(stop_lines);
  const tinyxml2::XMLElement* object_node =
      xml_node.FirstChildElement("object");
  while (object_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*object_node, "id", &amp;object_id);
    checker +=
        UtilXmlParser::QueryStringAttribute(*object_node, "type", &amp;object_type);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse object type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "stopline") {
      StopLineInternal stop_line;
      stop_line.id = object_id;
      PbCurveSegment* curve_segment = stop_line.curve.add_segment();
      CHECK(curve_segment != nullptr);
      const auto sub_node = object_node-&gt;FirstChildElement("geometry");
      if (sub_node == nullptr) {
        std::string err_msg = "Error parse stopline geometry";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }
      RETURN_IF_ERROR(UtilXmlParser::ParseGeometry(*sub_node, curve_segment));
      stop_lines-&gt;emplace_back(stop_line);
    }
    object_node = object_node-&gt;NextSiblingElement("object");
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(171, 0)" endLine="(214, 1)" clone_start="43" clone_end="44">
			<code function_name="SignalsXmlParser::ParseStopSigns(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;StopSignInternal&gt;* stop_signs)">Status SignalsXmlParser::ParseStopSigns(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;StopSignInternal&gt;* stop_signs) {
  CHECK_NOTNULL(stop_signs);

  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "stopSign") {
      PbStopSign stop_sign;
      stop_sign.mutable_id()-&gt;set_id(object_id);

      StopSignInternal stop_sign_internal;
      stop_sign_internal.stop_sign = stop_sign;

      auto sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          stop_sign_internal.stop_line_ids.insert(stop_line_id);

          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      stop_signs-&gt;emplace_back(stop_sign_internal);
    }

    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(142, 0)" endLine="(169, 1)" clone_start="27" clone_end="28">
			<code function_name="SignalsXmlParser::ToPbSubSignalType(const std::string&amp; xml_type, PbSubSignalType* sub_signal_type)">Status SignalsXmlParser::ToPbSubSignalType(const std::string&amp; xml_type,
                                           PbSubSignalType* sub_signal_type) {
  CHECK_NOTNULL(sub_signal_type);

  std::string upper_str = UtilXmlParser::ToUpper(xml_type);

  if (upper_str == "UNKNOWN") {
    *sub_signal_type = hdmap::Subsignal::UNKNOWN;
  } else if (upper_str == "CIRCLE") {
    *sub_signal_type = hdmap::Subsignal::CIRCLE;
  } else if (upper_str == "ARROWLEFT") {
    *sub_signal_type = hdmap::Subsignal::ARROW_LEFT;
  } else if (upper_str == "ARROWFORWARD") {
    *sub_signal_type = hdmap::Subsignal::ARROW_FORWARD;
  } else if (upper_str == "ARROWRIGHT") {
    *sub_signal_type = hdmap::Subsignal::ARROW_RIGHT;
  } else if (upper_str == "ARROWLEFTANDFORWARD") {
    *sub_signal_type = hdmap::Subsignal::ARROW_LEFT_AND_FORWARD;
  } else if (upper_str == "ARROWRIGHTANDFORWARD") {
    *sub_signal_type = hdmap::Subsignal::ARROW_RIGHT_AND_FORWARD;
  } else if (upper_str == "ARROWUTURN") {
    *sub_signal_type = hdmap::Subsignal::ARROW_U_TURN;
  } else {
    std::string err_msg = "Error or unsupport sub signal type";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(216, 0)" endLine="(259, 1)" clone_start="1" clone_end="23">
			<code function_name="SignalsXmlParser::ParseYieldSigns(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;YieldSignInternal&gt;* yield_signs)">Status SignalsXmlParser::ParseYieldSigns(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;YieldSignInternal&gt;* yield_signs) {
  CHECK_NOTNULL(yield_signs);

  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "yieldSign") {
      PbYieldSign yield_sign;
      yield_sign.mutable_id()-&gt;set_id(object_id);
      YieldSignInternal yield_sign_internal;
      yield_sign_internal.id = object_id;
      yield_sign_internal.yield_sign = yield_sign;
      auto sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                            &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          yield_sign_internal.stop_line_ids.insert(stop_line_id);

          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      yield_signs-&gt;emplace_back(yield_sign_internal);
    }

    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\signals_xml_parser.cc" startLine="(171, 0)" endLine="(214, 1)" clone_start="1" clone_end="24">
			<code function_name="SignalsXmlParser::ParseStopSigns(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;StopSignInternal&gt;* stop_signs)">Status SignalsXmlParser::ParseStopSigns(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;StopSignInternal&gt;* stop_signs) {
  CHECK_NOTNULL(stop_signs);

  auto signal_node = xml_node.FirstChildElement("signal");
  while (signal_node) {
    std::string object_type;
    std::string object_id;
    int checker =
        UtilXmlParser::QueryStringAttribute(*signal_node, "type", &amp;object_type);
    checker +=
        UtilXmlParser::QueryStringAttribute(*signal_node, "id", &amp;object_id);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse signal type.";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    if (object_type == "stopSign") {
      PbStopSign stop_sign;
      stop_sign.mutable_id()-&gt;set_id(object_id);

      StopSignInternal stop_sign_internal;
      stop_sign_internal.stop_sign = stop_sign;

      auto sub_node = signal_node-&gt;FirstChildElement("stopline");
      if (sub_node) {
        sub_node = sub_node-&gt;FirstChildElement("objectReference");
        while (sub_node) {
          std::string stop_line_id;
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;stop_line_id);
          CHECK(checker == tinyxml2::XML_SUCCESS);
          stop_sign_internal.stop_line_ids.insert(stop_line_id);

          sub_node = sub_node-&gt;NextSiblingElement("objectReference");
        }
      }
      stop_signs-&gt;emplace_back(stop_sign_internal);
    }

    signal_node = signal_node-&gt;NextSiblingElement("signal");
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.cc" startLine="(133, 0)" endLine="(318, 1)" clone_start="160" clone_end="180">
			<code function_name="MinBoxObjectBuilder::ReconstructPolygon(const Eigen::Vector3d &amp;ref_ct, ObjectPtr obj)">void  MinBoxObjectBuilder::ReconstructPolygon(
        const Eigen::Vector3d &amp;ref_ct,
        ObjectPtr obj) {
    if (obj-&gt;polygon.points.size() &lt;= 0) {
        return;
    }
    size_t max_point_index = 0;
    size_t min_point_index = 0;
    Eigen::Vector3d p;
    p[0] = obj-&gt;polygon.points[0].x;
    p[1] = obj-&gt;polygon.points[0].y;
    p[2] = obj-&gt;polygon.points[0].z;
    Eigen::Vector3d max_point = p - ref_ct;
    Eigen::Vector3d min_point = p - ref_ct;
    for (size_t i = 1; i &lt; obj-&gt;polygon.points.size(); ++i) {
        Eigen::Vector3d p;
        p[0] = obj-&gt;polygon.points[i].x;
        p[1] = obj-&gt;polygon.points[i].y;
        p[2] = obj-&gt;polygon.points[i].z;
        Eigen::Vector3d ray = p - ref_ct;
        // clock direction
        if (max_point[0] * ray[1] - ray[0] * max_point[1] &lt; EPSILON) {
            max_point = ray;
            max_point_index = i;
        }
        // unclock direction
        if (min_point[0] * ray[1] - ray[0] * min_point[1] &gt; EPSILON) {
            min_point = ray;
            min_point_index = i;
        }
    }
    Eigen::Vector3d line = max_point - min_point;
    double total_len = 0;
    double max_dis = 0;
    bool has_out = false;
    for (size_t i = min_point_index, count = 0;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist = sqrt((p[0] - p_x[0]) * (p[0] - p_x[0])
                        + (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist - max_dis &gt; EPSILON) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                   || (i == max_point_index &amp;&amp; j == min_point_index)) {
            size_t k = (j + 1) % obj-&gt;polygon.points.size();
            Eigen::Vector3d p_k;
            p_k[0] = obj-&gt;polygon.points[k].x;
            p_k[1] = obj-&gt;polygon.points[k].y;
            p_k[2] = obj-&gt;polygon.points[k].z;
            Eigen::Vector3d p_j;
            p_j[0] = obj-&gt;polygon.points[j].x;
            p_j[1] = obj-&gt;polygon.points[j].y;
            p_j[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
            } else {
                // outline
                has_out = true;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p_x - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist =
                        sqrt((p[0] - p_x[0]) * (p[0] - p_x[0]) +
                            (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist &gt; max_dis) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        }
    }
    size_t count = 0;
    double min_area = std::numeric_limits&lt;double&gt;::max();
    for (size_t i = min_point_index;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        Eigen::Vector3d p_j;
        p_j[0] = obj-&gt;polygon.points[j].x;
        p_j[1] = obj-&gt;polygon.points[j].y;
        p_j[2] = obj-&gt;polygon.points[j].z;
        double dist = sqrt((p_x[0] - p_j[0]) * (p_x[0] - p_j[0])
                + (p_x[1] - p_j[1])* (p_x[1] - p_j[1]));
        if (dist &lt; max_dis &amp;&amp; (dist / total_len) &lt; 0.5) {
            continue;
        }
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0;
                double width = 0;
                Eigen::Vector3d dir;
                double area =
                    ComputeAreaAlongOneEdge(obj, i,
                                        &amp;center, &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                    || (i == max_point_index &amp;&amp; j == min_point_index)) {
            if (!has_out) {
                continue;
            }
            Eigen::Vector3d center;
            double length = 0;
            double width = 0;
            Eigen::Vector3d dir;
            double area =
               ComputeAreaAlongOneEdge(obj, i, &amp;center, &amp;length, &amp;width, &amp;dir);
            if (area &lt; min_area) {
                obj-&gt;center = center;
                obj-&gt;length = length;
                obj-&gt;width = width;
                obj-&gt;direction = dir;
                min_area = area;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[i].x;
            p[1] = obj-&gt;polygon.points[i].y;
            p[2] = obj-&gt;polygon.points[i].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0.0;
                double width = 0.0;
                Eigen::Vector3d dir;
                double area =
                   ComputeAreaAlongOneEdge(obj, i, &amp;center,
                                           &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        }
    }
    obj-&gt;direction.normalize();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\object_builder\min_box\min_box.cc" startLine="(133, 0)" endLine="(318, 1)" clone_start="118" clone_end="138">
			<code function_name="MinBoxObjectBuilder::ReconstructPolygon(const Eigen::Vector3d &amp;ref_ct, ObjectPtr obj)">void  MinBoxObjectBuilder::ReconstructPolygon(
        const Eigen::Vector3d &amp;ref_ct,
        ObjectPtr obj) {
    if (obj-&gt;polygon.points.size() &lt;= 0) {
        return;
    }
    size_t max_point_index = 0;
    size_t min_point_index = 0;
    Eigen::Vector3d p;
    p[0] = obj-&gt;polygon.points[0].x;
    p[1] = obj-&gt;polygon.points[0].y;
    p[2] = obj-&gt;polygon.points[0].z;
    Eigen::Vector3d max_point = p - ref_ct;
    Eigen::Vector3d min_point = p - ref_ct;
    for (size_t i = 1; i &lt; obj-&gt;polygon.points.size(); ++i) {
        Eigen::Vector3d p;
        p[0] = obj-&gt;polygon.points[i].x;
        p[1] = obj-&gt;polygon.points[i].y;
        p[2] = obj-&gt;polygon.points[i].z;
        Eigen::Vector3d ray = p - ref_ct;
        // clock direction
        if (max_point[0] * ray[1] - ray[0] * max_point[1] &lt; EPSILON) {
            max_point = ray;
            max_point_index = i;
        }
        // unclock direction
        if (min_point[0] * ray[1] - ray[0] * min_point[1] &gt; EPSILON) {
            min_point = ray;
            min_point_index = i;
        }
    }
    Eigen::Vector3d line = max_point - min_point;
    double total_len = 0;
    double max_dis = 0;
    bool has_out = false;
    for (size_t i = min_point_index, count = 0;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist = sqrt((p[0] - p_x[0]) * (p[0] - p_x[0])
                        + (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist - max_dis &gt; EPSILON) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                   || (i == max_point_index &amp;&amp; j == min_point_index)) {
            size_t k = (j + 1) % obj-&gt;polygon.points.size();
            Eigen::Vector3d p_k;
            p_k[0] = obj-&gt;polygon.points[k].x;
            p_k[1] = obj-&gt;polygon.points[k].y;
            p_k[2] = obj-&gt;polygon.points[k].z;
            Eigen::Vector3d p_j;
            p_j[0] = obj-&gt;polygon.points[j].x;
            p_j[1] = obj-&gt;polygon.points[j].y;
            p_j[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
            } else {
                // outline
                has_out = true;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p_x - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; EPSILON) {
                double dist =
                        sqrt((p[0] - p_x[0]) * (p[0] - p_x[0]) +
                            (p[1] - p_x[1])* (p[1] - p_x[1]));
                total_len += dist;
                if (dist &gt; max_dis) {
                    max_dis = dist;
                }
            } else {
                // outline
                has_out = true;
            }
        }
    }
    size_t count = 0;
    double min_area = std::numeric_limits&lt;double&gt;::max();
    for (size_t i = min_point_index;
        count &lt; obj-&gt;polygon.points.size();
        i = (i + 1) % obj-&gt;polygon.points.size(), ++count) {
        Eigen::Vector3d p_x;
        p_x[0] = obj-&gt;polygon.points[i].x;
        p_x[1] = obj-&gt;polygon.points[i].y;
        p_x[2] = obj-&gt;polygon.points[i].z;
        size_t j = (i + 1) % obj-&gt;polygon.points.size();
        Eigen::Vector3d p_j;
        p_j[0] = obj-&gt;polygon.points[j].x;
        p_j[1] = obj-&gt;polygon.points[j].y;
        p_j[2] = obj-&gt;polygon.points[j].z;
        double dist = sqrt((p_x[0] - p_j[0]) * (p_x[0] - p_j[0])
                + (p_x[1] - p_j[1])* (p_x[1] - p_j[1]));
        if (dist &lt; max_dis &amp;&amp; (dist / total_len) &lt; 0.5) {
            continue;
        }
        if (j != min_point_index &amp;&amp; j != max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[j].x;
            p[1] = obj-&gt;polygon.points[j].y;
            p[2] = obj-&gt;polygon.points[j].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0;
                double width = 0;
                Eigen::Vector3d dir;
                double area =
                    ComputeAreaAlongOneEdge(obj, i,
                                        &amp;center, &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        } else if ((i == min_point_index &amp;&amp; j == max_point_index)
                    || (i == max_point_index &amp;&amp; j == min_point_index)) {
            if (!has_out) {
                continue;
            }
            Eigen::Vector3d center;
            double length = 0;
            double width = 0;
            Eigen::Vector3d dir;
            double area =
               ComputeAreaAlongOneEdge(obj, i, &amp;center, &amp;length, &amp;width, &amp;dir);
            if (area &lt; min_area) {
                obj-&gt;center = center;
                obj-&gt;length = length;
                obj-&gt;width = width;
                obj-&gt;direction = dir;
                min_area = area;
            }
        } else if (j == min_point_index || j == max_point_index) {
            Eigen::Vector3d p;
            p[0] = obj-&gt;polygon.points[i].x;
            p[1] = obj-&gt;polygon.points[i].y;
            p[2] = obj-&gt;polygon.points[i].z;
            Eigen::Vector3d ray = p - min_point;
            if (line[0] * ray[1] - ray[0] * line[1] &lt; 0) {
                Eigen::Vector3d center;
                double length = 0.0;
                double width = 0.0;
                Eigen::Vector3d dir;
                double area =
                   ComputeAreaAlongOneEdge(obj, i, &amp;center,
                                           &amp;length, &amp;width, &amp;dir);
                if (area &lt; min_area) {
                    obj-&gt;center = center;
                    obj-&gt;length = length;
                    obj-&gt;width = width;
                    obj-&gt;direction = dir;
                    min_area = area;
                }
            } else {
                // outline
            }
        }
    }
    obj-&gt;direction.normalize();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\planning_util.cc" startLine="(102, 0)" endLine="(167, 1)" clone_start="30" clone_end="53">
			<code function_name="interpolate(const TrajectoryPoint &amp;tp0, const TrajectoryPoint &amp;tp1, const double t)">TrajectoryPoint interpolate(const TrajectoryPoint &amp;tp0,
                            const TrajectoryPoint &amp;tp1, const double t) {
  if (std::abs(tp0.path_point().s() - tp0.path_point().s()) &lt; 1.0e-4) {
    return tp1;
  }

  const PathPoint &amp;pp0 = tp0.path_point();
  const PathPoint &amp;pp1 = tp1.path_point();
  double t0 = tp0.relative_time();
  double t1 = tp1.relative_time();

  std::array&lt;double, 2&gt; dx0{{tp0.v(), tp0.a()}};
  std::array&lt;double, 2&gt; dx1{{tp1.v(), tp1.a()}};
  HermiteSpline&lt;double, 3&gt; dynamic_spline(dx0, dx1, t0, t1);

  double s0 = 0.0;
  auto func_v = [&amp;dynamic_spline](const double t) {
    return dynamic_spline.Evaluate(0, t);
  };
  double s1 = common::math::IntegrateByGaussLegendre(func_v, t0, t1);
  double s = common::math::IntegrateByGaussLegendre(func_v, t0, t);

  if (std::abs(tp0.path_point().s() - s1) &lt; 1.0e-4) {
    return tp1;
  }

  double v = dynamic_spline.Evaluate(0, t);
  double a = dynamic_spline.Evaluate(1, t);

  std::array&lt;double, 2&gt; gx0{{pp0.theta(), pp0.kappa()}};
  std::array&lt;double, 2&gt; gx1{{pp1.theta(), pp1.kappa()}};
  HermiteSpline&lt;double, 3&gt; geometry_spline(gx0, gx1, s0, s1);
  auto func_cos_theta = [&amp;geometry_spline](const double s) {
    auto theta = geometry_spline.Evaluate(0, s);
    return std::cos(theta);
  };
  auto func_sin_theta = [&amp;geometry_spline](const double s) {
    auto theta = geometry_spline.Evaluate(0, s);
    return std::sin(theta);
  };

  double x =
      pp0.x() + common::math::IntegrateByGaussLegendre(func_cos_theta, s0, s);
  double y =
      pp0.y() + common::math::IntegrateByGaussLegendre(func_sin_theta, s0, s);
  double theta = geometry_spline.Evaluate(0, s);
  double kappa = geometry_spline.Evaluate(1, s);
  double dkappa = geometry_spline.Evaluate(2, s);
  double d2kappa = geometry_spline.Evaluate(3, s);

  TrajectoryPoint tp;
  tp.set_v(v);
  tp.set_a(a);

  PathPoint *path_point = tp.mutable_path_point();
  path_point-&gt;set_x(x);
  path_point-&gt;set_y(y);
  path_point-&gt;set_theta(theta);
  path_point-&gt;set_kappa(kappa);
  path_point-&gt;set_dkappa(dkappa);
  path_point-&gt;set_ddkappa(d2kappa);
  path_point-&gt;set_s(s);

  // check the diff of computed s1 and p1.s()?
  return tp;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\common\planning_util.cc" startLine="(35, 0)" endLine="(71, 1)" clone_start="7" clone_end="30">
			<code function_name="interpolate(const PathPoint &amp;p0, const PathPoint &amp;p1, const double s)">PathPoint interpolate(const PathPoint &amp;p0, const PathPoint &amp;p1,
                      const double s) {
  double s0 = p0.s();
  double s1 = p1.s();
  CHECK(s0 &lt;= s &amp;&amp; s &lt;= s1);

  std::array&lt;double, 2&gt; gx0{{p0.theta(), p0.kappa()}};
  std::array&lt;double, 2&gt; gx1{{p1.theta(), p1.kappa()}};
  HermiteSpline&lt;double, 3&gt; geometry_spline(gx0, gx1, s0, s1);
  auto func_cos_theta = [&amp;geometry_spline](const double s) {
    auto theta = geometry_spline.Evaluate(0, s);
    return std::cos(theta);
  };
  auto func_sin_theta = [&amp;geometry_spline](const double s) {
    auto theta = geometry_spline.Evaluate(0, s);
    return std::sin(theta);
  };

  double x =
      p0.x() + common::math::IntegrateByGaussLegendre(func_cos_theta, s0, s);
  double y =
      p0.y() + common::math::IntegrateByGaussLegendre(func_sin_theta, s0, s);
  double theta = geometry_spline.Evaluate(0, s);
  double kappa = geometry_spline.Evaluate(1, s);
  double dkappa = geometry_spline.Evaluate(2, s);
  double d2kappa = geometry_spline.Evaluate(3, s);

  PathPoint p;
  p.set_x(x);
  p.set_y(y);
  p.set_theta(theta);
  p.set_kappa(kappa);
  p.set_dkappa(dkappa);
  p.set_ddkappa(d2kappa);
  p.set_s(s);
  return p;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\spiral_curve\quintic_spiral_curve.cc" startLine="(249, 0)" endLine="(309, 1)" clone_start="33" clone_end="60">
			<code function_name="QuinticSpiralCurve::GetPathVecWithS(const std::vector&lt;double&gt;&amp; vec_s, std::vector&lt;common::PathPoint&gt;* path_points) const">Status QuinticSpiralCurve::GetPathVecWithS(
    const std::vector&lt;double&gt;&amp; vec_s,
    std::vector&lt;common::PathPoint&gt;* path_points) const {
  CHECK_NOTNULL(path_points);

  if (error() &gt; spiral_config().newton_raphson_tol()) {
    return Status(ErrorCode::PLANNING_ERROR,
                  "QuinticSpiralCurve::get_path_vec_with_s");
  }

  if (vec_s.size() == 0) {
    return Status::OK();
  }

  const std::uint32_t n = vec_s.size();

  common::PathPoint ref_point = start_point();

  path_points-&gt;resize(n);
  std::vector&lt;common::PathPoint&gt;&amp; result = *path_points;
  std::array&lt;double, 6&gt; p_value;
  std::copy(p_params().begin(), p_params().end(), p_value.begin());
  std::array&lt;double, 6&gt; a_params = SpiralFormula::p_to_a_k5(sg(), p_value);

  for (std::uint32_t i = 0; i &lt; n; ++i) {
    result[i].set_s(vec_s[i]);
    result[i].set_theta(SpiralFormula::theta_func_k5_a(vec_s[i], a_params) +
                        ref_point.theta());
    result[i].set_kappa(SpiralFormula::kappa_func_k5_a(vec_s[i], a_params));
    result[i].set_dkappa(SpiralFormula::dkappa_func_k5_a(vec_s[i], a_params));
  }

  double dx = 0.0;
  double dy = 0.0;

  // start from here, add k = 0, revise the result[k] = ...
  dx += (vec_s[0] - ref_point.s()) *
        (std::cos(std::fmod(ref_point.theta(), s_two_pi_)) +
         std::cos(std::fmod(result[0].theta(), s_two_pi_))) /
        2.0;
  dy += (vec_s[0] - ref_point.s()) *
        (std::cos(std::fmod(ref_point.theta(), s_two_pi_)) +
         std::cos(std::fmod(result[0].theta(), s_two_pi_))) /
        2.0;
  result[0].set_x(dx + ref_point.x());
  result[0].set_y(dy + ref_point.y());
  for (std::uint32_t k = 1; k &lt; n; ++k) {
    dx += (vec_s[k] - vec_s[k - 1]) *
          (std::cos(std::fmod(result[k - 1].theta(), s_two_pi_)) +
           std::cos(std::fmod(result[k].theta(), s_two_pi_))) /
          2.0;
    dy += (vec_s[k] - vec_s[k - 1]) *
          (std::sin(std::fmod(result[k - 1].theta(), s_two_pi_)) +
           std::sin(std::fmod(result[k].theta(), s_two_pi_))) /
          2.0;
    result[k].set_x(dx + ref_point.x());
    result[k].set_y(dy + ref_point.y());
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\spiral_curve\cubic_spiral_curve.cc" startLine="(240, 0)" endLine="(301, 1)" clone_start="34" clone_end="61">
			<code function_name="CubicSpiralCurve::GetPathVecWithS(const std::vector&lt;double&gt;&amp; vec_s, std::vector&lt;common::PathPoint&gt;* path_points) const">Status CubicSpiralCurve::GetPathVecWithS(
    const std::vector&lt;double&gt;&amp; vec_s,
    std::vector&lt;common::PathPoint&gt;* path_points) const {
  CHECK_NOTNULL(path_points);

  if (vec_s.empty() || error() &gt; spiral_config().newton_raphson_tol()) {
    return Status(ErrorCode::PLANNING_ERROR,
                  "CubicSpiralCurve::get_path_vec_with_s");
  }

  const std::uint32_t n = vec_s.size();
  std::vector&lt;common::PathPoint&gt;&amp; result = *path_points;
  result.resize(n);

  std::array&lt;double, 4&gt; p_value;
  std::copy_n(p_params().begin(), 4, p_value.begin());

  common::PathPoint ref_point(start_point());

  ref_point.set_s(0.0);
  std::array&lt;double, 4&gt; a_params = SpiralFormula::p_to_a_k3(sg(), p_value);

  for (std::uint32_t i = 0; i &lt; n; ++i) {
    result[i].set_s(vec_s[i]);
    result[i].set_theta(
        planning::SpiralFormula::theta_func_k3_a(vec_s[i], a_params) +
        ref_point.theta());
    result[i].set_kappa(
        planning::SpiralFormula::kappa_func_k3_a(vec_s[i], a_params));
    result[i].set_dkappa(
        planning::SpiralFormula::dkappa_func_k3_a(vec_s[i], a_params));
  }

  double dx = 0.0;
  double dy = 0.0;
  // start from here, add k = 0, revise the result[k] = ...
  dx += (vec_s[0] - ref_point.s()) *
        (std::cos(std::fmod(ref_point.theta(), s_two_pi_)) +
         std::cos(std::fmod(result[0].theta(), s_two_pi_))) /
        2.0;
  dy += (vec_s[0] - ref_point.s()) *
        (std::sin(std::fmod(ref_point.theta(), s_two_pi_)) +
         std::sin(std::fmod(result[0].theta(), s_two_pi_))) /
        2.0;
  result[0].set_x(dx + ref_point.x());
  result[0].set_y(dy + ref_point.y());

  for (std::uint32_t k = 1; k &lt; n; ++k) {
    dx += (vec_s[k] - vec_s[k - 1]) *
          (std::cos(std::fmod(result[k - 1].theta(), s_two_pi_)) +
           std::cos(std::fmod(result[k].theta(), s_two_pi_))) /
          2.0;
    dy += (vec_s[k] - vec_s[k - 1]) *
          (std::sin(std::fmod(result[k - 1].theta(), s_two_pi_)) +
           std::sin(std::fmod(result[k].theta(), s_two_pi_))) /
          2.0;
    result[k].set_x(dx + ref_point.x());
    result[k].set_y(dy + ref_point.y());
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(297, 0)" endLine="(318, 1)" clone_start="18" clone_end="22">
			<code function_name="LincolnController::EnableSteeringOnlyMode()">ErrorCode LincolnController::EnableSteeringOnlyMode() {
  if (driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
      driving_mode() == Chassis::AUTO_STEER_ONLY) {
    set_driving_mode(Chassis::AUTO_STEER_ONLY);
    AINFO &lt;&lt; "Already in AUTO_STEER_ONLY mode";
    return ErrorCode::OK;
  }
  brake_60_-&gt;set_disable();
  throttle_62_-&gt;set_disable();
  steering_64_-&gt;set_enable();

  can_sender_-&gt;Update();
  if (CheckResponse(CHECK_RESPONSE_STEER_UNIT_FLAG, true) == false) {
    AERROR &lt;&lt; "Failed to switch to AUTO_STEER_ONLY mode.";
    Emergency();
    return ErrorCode::CANBUS_ERROR;
  } else {
    set_driving_mode(Chassis::AUTO_STEER_ONLY);
    AINFO &lt;&lt; "Switch to AUTO_STEER_ONLY mode ok.";
    return ErrorCode::OK;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(288, 0)" endLine="(295, 1)" clone_start="5" clone_end="8">
			<code function_name="LincolnController::DisableAutoMode()">ErrorCode LincolnController::DisableAutoMode() {
  ResetProtocol();
  can_sender_-&gt;Update();
  set_driving_mode(Chassis::COMPLETE_MANUAL);
  set_chassis_error_code(Chassis::NO_ERROR);
  AINFO &lt;&lt; "Switch to COMPLETE_MANUAL ok.";
  return ErrorCode::OK;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(320, 0)" endLine="(341, 1)" clone_start="1" clone_end="20">
			<code function_name="LincolnController::EnableSpeedOnlyMode()">ErrorCode LincolnController::EnableSpeedOnlyMode() {
  if (driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
      driving_mode() == Chassis::AUTO_SPEED_ONLY) {
    set_driving_mode(Chassis::AUTO_SPEED_ONLY);
    AINFO &lt;&lt; "Already in AUTO_SPEED_ONLY mode";
    return ErrorCode::OK;
  }
  brake_60_-&gt;set_enable();
  throttle_62_-&gt;set_enable();
  steering_64_-&gt;set_disable();

  can_sender_-&gt;Update();
  if (CheckResponse(CHECK_RESPONSE_SPEED_UNIT_FLAG, true) == false) {
    AERROR &lt;&lt; "Failed to switch to AUTO_STEER_ONLY mode.";
    Emergency();
    return ErrorCode::CANBUS_ERROR;
  } else {
    set_driving_mode(Chassis::AUTO_SPEED_ONLY);
    AINFO &lt;&lt; "Switch to AUTO_SPEED_ONLY mode ok.";
    return ErrorCode::OK;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\lincoln_controller.cc" startLine="(297, 0)" endLine="(318, 1)" clone_start="1" clone_end="20">
			<code function_name="LincolnController::EnableSteeringOnlyMode()">ErrorCode LincolnController::EnableSteeringOnlyMode() {
  if (driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
      driving_mode() == Chassis::AUTO_STEER_ONLY) {
    set_driving_mode(Chassis::AUTO_STEER_ONLY);
    AINFO &lt;&lt; "Already in AUTO_STEER_ONLY mode";
    return ErrorCode::OK;
  }
  brake_60_-&gt;set_disable();
  throttle_62_-&gt;set_disable();
  steering_64_-&gt;set_enable();

  can_sender_-&gt;Update();
  if (CheckResponse(CHECK_RESPONSE_STEER_UNIT_FLAG, true) == false) {
    AERROR &lt;&lt; "Failed to switch to AUTO_STEER_ONLY mode.";
    Emergency();
    return ErrorCode::CANBUS_ERROR;
  } else {
    set_driving_mode(Chassis::AUTO_STEER_ONLY);
    AINFO &lt;&lt; "Switch to AUTO_STEER_ONLY mode ok.";
    return ErrorCode::OK;
  }
}</code>
		</source>
	</dup>
	<dup count="6">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\adapters\adapter_manager.cc" startLine="(45, 0)" endLine="(131, 1)" clone_start="54" clone_end="79">
			<code function_name="AdapterManager::Init(const AdapterManagerConfig &amp;configs)">void AdapterManager::Init(const AdapterManagerConfig &amp;configs) {
  instance()-&gt;initialized_ = true;
  if (configs.is_ros()) {
    instance()-&gt;node_handle_.reset(new ros::NodeHandle());
  }

  for (const auto &amp;config : configs.config()) {
    switch (config.type()) {
      case AdapterConfig::POINT_CLOUD:
        EnablePointCloud(FLAGS_pointcloud_topic, config.mode(),
                         config.message_history_limit());
        break;
      case AdapterConfig::GPS:
        EnableGps(FLAGS_gps_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::IMU:
        EnableImu(FLAGS_imu_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS:
        EnableChassis(FLAGS_chassis_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::LOCALIZATION:
        EnableLocalization(FLAGS_localization_topic, config.mode(),
                           config.message_history_limit());
        break;
      case AdapterConfig::PERCEPTION_OBSTACLES:
        EnablePerceptionObstacles(FLAGS_perception_obstacle_topic,
                                  config.mode(),
                                  config.message_history_limit());
        break;
      case AdapterConfig::TRAFFIC_LIGHT_DETECTION:
        EnableTrafficLightDetection(FLAGS_traffic_light_detection_topic,
                                    config.mode(),
                                    config.message_history_limit());
      case AdapterConfig::PAD:
        EnablePad(FLAGS_pad_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CONTROL_COMMAND:
        EnableControlCommand(FLAGS_control_command_topic, config.mode(),
                             config.message_history_limit());
        break;
      case AdapterConfig::ROUTING_REQUEST:
        EnableRoutingRequest(FLAGS_routing_request_topic, config.mode(),
                             config.message_history_limit());
        break;
      case AdapterConfig::ROUTING_RESPONSE:
        EnableRoutingResponse(FLAGS_routing_response_topic, config.mode(),
                              config.message_history_limit());
        break;
      case AdapterConfig::PLANNING_TRAJECTORY:
        EnablePlanning(FLAGS_planning_trajectory_topic, config.mode(),
                       config.message_history_limit());
        break;
      case AdapterConfig::PREDICTION:
        EnablePrediction(FLAGS_prediction_topic, config.mode(),
                         config.message_history_limit());
        break;
      case AdapterConfig::MONITOR:
        EnableMonitor(FLAGS_monitor_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS_DETAIL:
        EnableChassisDetail(FLAGS_chassis_detail_topic, config.mode(),
                            config.message_history_limit());
        break;
      case AdapterConfig::RELATIVE_ODOMETRY:
        EnableRelativeOdometry(FLAGS_relative_odometry_topic, config.mode(),
                               config.message_history_limit());
        break;
      case AdapterConfig::INS_STAT:
        EnableInsStat(FLAGS_ins_stat_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::HMI_COMMAND:
        EnableHMICommand(FLAGS_hmi_command_topic, config.mode(),
                         config.message_history_limit());
        break;
      default:
        AERROR &lt;&lt; "Unknown adapter config type!";
        break;
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\adapters\adapter_manager.cc" startLine="(45, 0)" endLine="(131, 1)" clone_start="50" clone_end="75">
			<code function_name="AdapterManager::Init(const AdapterManagerConfig &amp;configs)">void AdapterManager::Init(const AdapterManagerConfig &amp;configs) {
  instance()-&gt;initialized_ = true;
  if (configs.is_ros()) {
    instance()-&gt;node_handle_.reset(new ros::NodeHandle());
  }

  for (const auto &amp;config : configs.config()) {
    switch (config.type()) {
      case AdapterConfig::POINT_CLOUD:
        EnablePointCloud(FLAGS_pointcloud_topic, config.mode(),
                         config.message_history_limit());
        break;
      case AdapterConfig::GPS:
        EnableGps(FLAGS_gps_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::IMU:
        EnableImu(FLAGS_imu_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS:
        EnableChassis(FLAGS_chassis_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::LOCALIZATION:
        EnableLocalization(FLAGS_localization_topic, config.mode(),
                           config.message_history_limit());
        break;
      case AdapterConfig::PERCEPTION_OBSTACLES:
        EnablePerceptionObstacles(FLAGS_perception_obstacle_topic,
                                  config.mode(),
                                  config.message_history_limit());
        break;
      case AdapterConfig::TRAFFIC_LIGHT_DETECTION:
        EnableTrafficLightDetection(FLAGS_traffic_light_detection_topic,
                                    config.mode(),
                                    config.message_history_limit());
      case AdapterConfig::PAD:
        EnablePad(FLAGS_pad_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CONTROL_COMMAND:
        EnableControlCommand(FLAGS_control_command_topic, config.mode(),
                             config.message_history_limit());
        break;
      case AdapterConfig::ROUTING_REQUEST:
        EnableRoutingRequest(FLAGS_routing_request_topic, config.mode(),
                             config.message_history_limit());
        break;
      case AdapterConfig::ROUTING_RESPONSE:
        EnableRoutingResponse(FLAGS_routing_response_topic, config.mode(),
                              config.message_history_limit());
        break;
      case AdapterConfig::PLANNING_TRAJECTORY:
        EnablePlanning(FLAGS_planning_trajectory_topic, config.mode(),
                       config.message_history_limit());
        break;
      case AdapterConfig::PREDICTION:
        EnablePrediction(FLAGS_prediction_topic, config.mode(),
                         config.message_history_limit());
        break;
      case AdapterConfig::MONITOR:
        EnableMonitor(FLAGS_monitor_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS_DETAIL:
        EnableChassisDetail(FLAGS_chassis_detail_topic, config.mode(),
                            config.message_history_limit());
        break;
      case AdapterConfig::RELATIVE_ODOMETRY:
        EnableRelativeOdometry(FLAGS_relative_odometry_topic, config.mode(),
                               config.message_history_limit());
        break;
      case AdapterConfig::INS_STAT:
        EnableInsStat(FLAGS_ins_stat_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::HMI_COMMAND:
        EnableHMICommand(FLAGS_hmi_command_topic, config.mode(),
                         config.message_history_limit());
        break;
      default:
        AERROR &lt;&lt; "Unknown adapter config type!";
        break;
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\adapters\adapter_manager.cc" startLine="(45, 0)" endLine="(131, 1)" clone_start="46" clone_end="71">
			<code function_name="AdapterManager::Init(const AdapterManagerConfig &amp;configs)">void AdapterManager::Init(const AdapterManagerConfig &amp;configs) {
  instance()-&gt;initialized_ = true;
  if (configs.is_ros()) {
    instance()-&gt;node_handle_.reset(new ros::NodeHandle());
  }

  for (const auto &amp;config : configs.config()) {
    switch (config.type()) {
      case AdapterConfig::POINT_CLOUD:
        EnablePointCloud(FLAGS_pointcloud_topic, config.mode(),
                         config.message_history_limit());
        break;
      case AdapterConfig::GPS:
        EnableGps(FLAGS_gps_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::IMU:
        EnableImu(FLAGS_imu_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS:
        EnableChassis(FLAGS_chassis_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::LOCALIZATION:
        EnableLocalization(FLAGS_localization_topic, config.mode(),
                           config.message_history_limit());
        break;
      case AdapterConfig::PERCEPTION_OBSTACLES:
        EnablePerceptionObstacles(FLAGS_perception_obstacle_topic,
                                  config.mode(),
                                  config.message_history_limit());
        break;
      case AdapterConfig::TRAFFIC_LIGHT_DETECTION:
        EnableTrafficLightDetection(FLAGS_traffic_light_detection_topic,
                                    config.mode(),
                                    config.message_history_limit());
      case AdapterConfig::PAD:
        EnablePad(FLAGS_pad_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CONTROL_COMMAND:
        EnableControlCommand(FLAGS_control_command_topic, config.mode(),
                             config.message_history_limit());
        break;
      case AdapterConfig::ROUTING_REQUEST:
        EnableRoutingRequest(FLAGS_routing_request_topic, config.mode(),
                             config.message_history_limit());
        break;
      case AdapterConfig::ROUTING_RESPONSE:
        EnableRoutingResponse(FLAGS_routing_response_topic, config.mode(),
                              config.message_history_limit());
        break;
      case AdapterConfig::PLANNING_TRAJECTORY:
        EnablePlanning(FLAGS_planning_trajectory_topic, config.mode(),
                       config.message_history_limit());
        break;
      case AdapterConfig::PREDICTION:
        EnablePrediction(FLAGS_prediction_topic, config.mode(),
                         config.message_history_limit());
        break;
      case AdapterConfig::MONITOR:
        EnableMonitor(FLAGS_monitor_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS_DETAIL:
        EnableChassisDetail(FLAGS_chassis_detail_topic, config.mode(),
                            config.message_history_limit());
        break;
      case AdapterConfig::RELATIVE_ODOMETRY:
        EnableRelativeOdometry(FLAGS_relative_odometry_topic, config.mode(),
                               config.message_history_limit());
        break;
      case AdapterConfig::INS_STAT:
        EnableInsStat(FLAGS_ins_stat_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::HMI_COMMAND:
        EnableHMICommand(FLAGS_hmi_command_topic, config.mode(),
                         config.message_history_limit());
        break;
      default:
        AERROR &lt;&lt; "Unknown adapter config type!";
        break;
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\adapters\adapter_manager.cc" startLine="(45, 0)" endLine="(131, 1)" clone_start="42" clone_end="67">
			<code function_name="AdapterManager::Init(const AdapterManagerConfig &amp;configs)">void AdapterManager::Init(const AdapterManagerConfig &amp;configs) {
  instance()-&gt;initialized_ = true;
  if (configs.is_ros()) {
    instance()-&gt;node_handle_.reset(new ros::NodeHandle());
  }

  for (const auto &amp;config : configs.config()) {
    switch (config.type()) {
      case AdapterConfig::POINT_CLOUD:
        EnablePointCloud(FLAGS_pointcloud_topic, config.mode(),
                         config.message_history_limit());
        break;
      case AdapterConfig::GPS:
        EnableGps(FLAGS_gps_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::IMU:
        EnableImu(FLAGS_imu_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS:
        EnableChassis(FLAGS_chassis_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::LOCALIZATION:
        EnableLocalization(FLAGS_localization_topic, config.mode(),
                           config.message_history_limit());
        break;
      case AdapterConfig::PERCEPTION_OBSTACLES:
        EnablePerceptionObstacles(FLAGS_perception_obstacle_topic,
                                  config.mode(),
                                  config.message_history_limit());
        break;
      case AdapterConfig::TRAFFIC_LIGHT_DETECTION:
        EnableTrafficLightDetection(FLAGS_traffic_light_detection_topic,
                                    config.mode(),
                                    config.message_history_limit());
      case AdapterConfig::PAD:
        EnablePad(FLAGS_pad_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CONTROL_COMMAND:
        EnableControlCommand(FLAGS_control_command_topic, config.mode(),
                             config.message_history_limit());
        break;
      case AdapterConfig::ROUTING_REQUEST:
        EnableRoutingRequest(FLAGS_routing_request_topic, config.mode(),
                             config.message_history_limit());
        break;
      case AdapterConfig::ROUTING_RESPONSE:
        EnableRoutingResponse(FLAGS_routing_response_topic, config.mode(),
                              config.message_history_limit());
        break;
      case AdapterConfig::PLANNING_TRAJECTORY:
        EnablePlanning(FLAGS_planning_trajectory_topic, config.mode(),
                       config.message_history_limit());
        break;
      case AdapterConfig::PREDICTION:
        EnablePrediction(FLAGS_prediction_topic, config.mode(),
                         config.message_history_limit());
        break;
      case AdapterConfig::MONITOR:
        EnableMonitor(FLAGS_monitor_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS_DETAIL:
        EnableChassisDetail(FLAGS_chassis_detail_topic, config.mode(),
                            config.message_history_limit());
        break;
      case AdapterConfig::RELATIVE_ODOMETRY:
        EnableRelativeOdometry(FLAGS_relative_odometry_topic, config.mode(),
                               config.message_history_limit());
        break;
      case AdapterConfig::INS_STAT:
        EnableInsStat(FLAGS_ins_stat_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::HMI_COMMAND:
        EnableHMICommand(FLAGS_hmi_command_topic, config.mode(),
                         config.message_history_limit());
        break;
      default:
        AERROR &lt;&lt; "Unknown adapter config type!";
        break;
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\adapters\adapter_manager.cc" startLine="(45, 0)" endLine="(131, 1)" clone_start="38" clone_end="63">
			<code function_name="AdapterManager::Init(const AdapterManagerConfig &amp;configs)">void AdapterManager::Init(const AdapterManagerConfig &amp;configs) {
  instance()-&gt;initialized_ = true;
  if (configs.is_ros()) {
    instance()-&gt;node_handle_.reset(new ros::NodeHandle());
  }

  for (const auto &amp;config : configs.config()) {
    switch (config.type()) {
      case AdapterConfig::POINT_CLOUD:
        EnablePointCloud(FLAGS_pointcloud_topic, config.mode(),
                         config.message_history_limit());
        break;
      case AdapterConfig::GPS:
        EnableGps(FLAGS_gps_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::IMU:
        EnableImu(FLAGS_imu_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS:
        EnableChassis(FLAGS_chassis_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::LOCALIZATION:
        EnableLocalization(FLAGS_localization_topic, config.mode(),
                           config.message_history_limit());
        break;
      case AdapterConfig::PERCEPTION_OBSTACLES:
        EnablePerceptionObstacles(FLAGS_perception_obstacle_topic,
                                  config.mode(),
                                  config.message_history_limit());
        break;
      case AdapterConfig::TRAFFIC_LIGHT_DETECTION:
        EnableTrafficLightDetection(FLAGS_traffic_light_detection_topic,
                                    config.mode(),
                                    config.message_history_limit());
      case AdapterConfig::PAD:
        EnablePad(FLAGS_pad_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CONTROL_COMMAND:
        EnableControlCommand(FLAGS_control_command_topic, config.mode(),
                             config.message_history_limit());
        break;
      case AdapterConfig::ROUTING_REQUEST:
        EnableRoutingRequest(FLAGS_routing_request_topic, config.mode(),
                             config.message_history_limit());
        break;
      case AdapterConfig::ROUTING_RESPONSE:
        EnableRoutingResponse(FLAGS_routing_response_topic, config.mode(),
                              config.message_history_limit());
        break;
      case AdapterConfig::PLANNING_TRAJECTORY:
        EnablePlanning(FLAGS_planning_trajectory_topic, config.mode(),
                       config.message_history_limit());
        break;
      case AdapterConfig::PREDICTION:
        EnablePrediction(FLAGS_prediction_topic, config.mode(),
                         config.message_history_limit());
        break;
      case AdapterConfig::MONITOR:
        EnableMonitor(FLAGS_monitor_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS_DETAIL:
        EnableChassisDetail(FLAGS_chassis_detail_topic, config.mode(),
                            config.message_history_limit());
        break;
      case AdapterConfig::RELATIVE_ODOMETRY:
        EnableRelativeOdometry(FLAGS_relative_odometry_topic, config.mode(),
                               config.message_history_limit());
        break;
      case AdapterConfig::INS_STAT:
        EnableInsStat(FLAGS_ins_stat_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::HMI_COMMAND:
        EnableHMICommand(FLAGS_hmi_command_topic, config.mode(),
                         config.message_history_limit());
        break;
      default:
        AERROR &lt;&lt; "Unknown adapter config type!";
        break;
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\adapters\adapter_manager.cc" startLine="(45, 0)" endLine="(131, 1)" clone_start="9" clone_end="35">
			<code function_name="AdapterManager::Init(const AdapterManagerConfig &amp;configs)">void AdapterManager::Init(const AdapterManagerConfig &amp;configs) {
  instance()-&gt;initialized_ = true;
  if (configs.is_ros()) {
    instance()-&gt;node_handle_.reset(new ros::NodeHandle());
  }

  for (const auto &amp;config : configs.config()) {
    switch (config.type()) {
      case AdapterConfig::POINT_CLOUD:
        EnablePointCloud(FLAGS_pointcloud_topic, config.mode(),
                         config.message_history_limit());
        break;
      case AdapterConfig::GPS:
        EnableGps(FLAGS_gps_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::IMU:
        EnableImu(FLAGS_imu_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS:
        EnableChassis(FLAGS_chassis_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::LOCALIZATION:
        EnableLocalization(FLAGS_localization_topic, config.mode(),
                           config.message_history_limit());
        break;
      case AdapterConfig::PERCEPTION_OBSTACLES:
        EnablePerceptionObstacles(FLAGS_perception_obstacle_topic,
                                  config.mode(),
                                  config.message_history_limit());
        break;
      case AdapterConfig::TRAFFIC_LIGHT_DETECTION:
        EnableTrafficLightDetection(FLAGS_traffic_light_detection_topic,
                                    config.mode(),
                                    config.message_history_limit());
      case AdapterConfig::PAD:
        EnablePad(FLAGS_pad_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CONTROL_COMMAND:
        EnableControlCommand(FLAGS_control_command_topic, config.mode(),
                             config.message_history_limit());
        break;
      case AdapterConfig::ROUTING_REQUEST:
        EnableRoutingRequest(FLAGS_routing_request_topic, config.mode(),
                             config.message_history_limit());
        break;
      case AdapterConfig::ROUTING_RESPONSE:
        EnableRoutingResponse(FLAGS_routing_response_topic, config.mode(),
                              config.message_history_limit());
        break;
      case AdapterConfig::PLANNING_TRAJECTORY:
        EnablePlanning(FLAGS_planning_trajectory_topic, config.mode(),
                       config.message_history_limit());
        break;
      case AdapterConfig::PREDICTION:
        EnablePrediction(FLAGS_prediction_topic, config.mode(),
                         config.message_history_limit());
        break;
      case AdapterConfig::MONITOR:
        EnableMonitor(FLAGS_monitor_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS_DETAIL:
        EnableChassisDetail(FLAGS_chassis_detail_topic, config.mode(),
                            config.message_history_limit());
        break;
      case AdapterConfig::RELATIVE_ODOMETRY:
        EnableRelativeOdometry(FLAGS_relative_odometry_topic, config.mode(),
                               config.message_history_limit());
        break;
      case AdapterConfig::INS_STAT:
        EnableInsStat(FLAGS_ins_stat_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::HMI_COMMAND:
        EnableHMICommand(FLAGS_hmi_command_topic, config.mode(),
                         config.message_history_limit());
        break;
      default:
        AERROR &lt;&lt; "Unknown adapter config type!";
        break;
    }
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(109, 0)" endLine="(159, 1)" clone_start="44" clone_end="51">
			<code function_name="Spline1dConstraint::AddDerivativeBoundary(const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }

  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);
    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 1; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) = coef * j;
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 1; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) = coef * j;
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }
  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(56, 0)" endLine="(107, 1)" clone_start="44" clone_end="52">
			<code function_name="Spline1dConstraint::AddBoundary(const std::vector&lt;double&gt;&amp; x_coord,const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddBoundary(const std::vector&lt;double&gt;&amp; x_coord,
                                     const std::vector&lt;double&gt;&amp; lower_bound,
                                     const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }
  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);

    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) = coef;
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 0; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) = coef;
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }

  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(161, 0)" endLine="(211, 1)" clone_start="1" clone_end="30">
			<code function_name="Spline1dConstraint::AddSecondDerivativeBoundary(    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddSecondDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }

  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);
    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 2; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) = coef * j * (j - 1);
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 2; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) = coef * j * (j - 1);
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }
  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_constraint.cc" startLine="(109, 0)" endLine="(159, 1)" clone_start="1" clone_end="30">
			<code function_name="Spline1dConstraint::AddDerivativeBoundary(const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound, const std::vector&lt;double&gt;&amp; upper_bound)">bool Spline1dConstraint::AddDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; x_coord, const std::vector&lt;double&gt;&amp; lower_bound,
    const std::vector&lt;double&gt;&amp; upper_bound) {
  std::vector&lt;double&gt; filtered_lower_bound;
  std::vector&lt;double&gt; filtered_upper_bound;
  std::vector&lt;double&gt; filtered_lower_bound_x;
  std::vector&lt;double&gt; filtered_upper_bound_x;

  if (x_knots_.size() &lt; 2) {
    return false;
  }

  if (!FilterConstraints(x_coord, lower_bound, upper_bound,
                         &amp;filtered_lower_bound_x, &amp;filtered_lower_bound,
                         &amp;filtered_upper_bound_x, &amp;filtered_upper_bound)) {
    return false;
  }

  // emplace affine constraints
  Eigen::MatrixXd inequality_constraint = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(),
      (x_knots_.size() - 1) * spline_order_);
  Eigen::MatrixXd inequality_boundary = Eigen::MatrixXd::Zero(
      filtered_upper_bound.size() + filtered_lower_bound.size(), 1);

  for (std::uint32_t i = 0; i &lt; filtered_lower_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_lower_bound_x[i]);
    const double corrected_x = filtered_lower_bound_x[i] - x_knots_[index];
    double coef = 1.0;
    for (std::uint32_t j = 1; j &lt; spline_order_; ++j) {
      inequality_constraint(i, j + index * spline_order_) = coef * j;
      coef *= corrected_x;
    }
    inequality_boundary(i, 0) = filtered_lower_bound[i];
  }

  for (std::uint32_t i = 0; i &lt; filtered_upper_bound.size(); ++i) {
    std::uint32_t index = FindIndex(filtered_upper_bound_x[i]);
    const double corrected_x = filtered_upper_bound_x[i] - x_knots_[index];
    double coef = -1.0;
    for (std::uint32_t j = 1; j &lt; spline_order_; ++j) {
      inequality_constraint(i + filtered_lower_bound.size(),
                            j + index * spline_order_) = coef * j;
      coef *= corrected_x;
    }
    inequality_boundary(i + filtered_lower_bound.size(), 0) =
        -filtered_upper_bound[i];
  }
  return inequality_constraint_.AddConstraint(inequality_constraint,
                                              inequality_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\lib\calibration.cpp" startLine="(154, 0)" endLine="(182, 1)" clone_start="7" clone_end="26">
			<code function_name="operator&gt;&gt;(const YAML::Node&amp; node, Calibration&amp; calibration)">YAML::Emitter&amp; operator&lt;&lt;(YAML::Emitter&amp; out,
                          const std::pair&lt;int, LaserCorrection&gt; correction) {
  out &lt;&lt; YAML::BeginMap;
  out &lt;&lt; YAML::Key &lt;&lt; LASER_ID &lt;&lt; YAML::Value &lt;&lt; correction.first;
  out &lt;&lt; YAML::Key &lt;&lt; ROT_CORRECTION &lt;&lt; YAML::Value
      &lt;&lt; correction.second.rot_correction;
  out &lt;&lt; YAML::Key &lt;&lt; VERT_CORRECTION &lt;&lt; YAML::Value
      &lt;&lt; correction.second.vert_correction;
  out &lt;&lt; YAML::Key &lt;&lt; DIST_CORRECTION &lt;&lt; YAML::Value
      &lt;&lt; correction.second.dist_correction;
  out &lt;&lt; YAML::Key &lt;&lt; DIST_CORRECTION_X &lt;&lt; YAML::Value
      &lt;&lt; correction.second.dist_correction_x;
  out &lt;&lt; YAML::Key &lt;&lt; DIST_CORRECTION_Y &lt;&lt; YAML::Value
      &lt;&lt; correction.second.dist_correction_y;
  out &lt;&lt; YAML::Key &lt;&lt; VERT_OFFSET_CORRECTION &lt;&lt; YAML::Value
      &lt;&lt; correction.second.vert_offset_correction;
  out &lt;&lt; YAML::Key &lt;&lt; HORIZ_OFFSET_CORRECTION &lt;&lt; YAML::Value
      &lt;&lt; correction.second.horiz_offset_correction;
  out &lt;&lt; YAML::Key &lt;&lt; MAX_INTENSITY &lt;&lt; YAML::Value
      &lt;&lt; correction.second.max_intensity;
  out &lt;&lt; YAML::Key &lt;&lt; MIN_INTENSITY &lt;&lt; YAML::Value
      &lt;&lt; correction.second.min_intensity;
  out &lt;&lt; YAML::Key &lt;&lt; FOCAL_DISTANCE &lt;&lt; YAML::Value
      &lt;&lt; correction.second.focal_distance;
  out &lt;&lt; YAML::Key &lt;&lt; FOCAL_SLOPE &lt;&lt; YAML::Value
      &lt;&lt; correction.second.focal_slope;
  out &lt;&lt; YAML::EndMap;
  return out;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\velodyne\velodyne_pointcloud\src\lib\calibration.cpp" startLine="(154, 0)" endLine="(182, 1)" clone_start="5" clone_end="24">
			<code function_name="operator&gt;&gt;(const YAML::Node&amp; node, Calibration&amp; calibration)">YAML::Emitter&amp; operator&lt;&lt;(YAML::Emitter&amp; out,
                          const std::pair&lt;int, LaserCorrection&gt; correction) {
  out &lt;&lt; YAML::BeginMap;
  out &lt;&lt; YAML::Key &lt;&lt; LASER_ID &lt;&lt; YAML::Value &lt;&lt; correction.first;
  out &lt;&lt; YAML::Key &lt;&lt; ROT_CORRECTION &lt;&lt; YAML::Value
      &lt;&lt; correction.second.rot_correction;
  out &lt;&lt; YAML::Key &lt;&lt; VERT_CORRECTION &lt;&lt; YAML::Value
      &lt;&lt; correction.second.vert_correction;
  out &lt;&lt; YAML::Key &lt;&lt; DIST_CORRECTION &lt;&lt; YAML::Value
      &lt;&lt; correction.second.dist_correction;
  out &lt;&lt; YAML::Key &lt;&lt; DIST_CORRECTION_X &lt;&lt; YAML::Value
      &lt;&lt; correction.second.dist_correction_x;
  out &lt;&lt; YAML::Key &lt;&lt; DIST_CORRECTION_Y &lt;&lt; YAML::Value
      &lt;&lt; correction.second.dist_correction_y;
  out &lt;&lt; YAML::Key &lt;&lt; VERT_OFFSET_CORRECTION &lt;&lt; YAML::Value
      &lt;&lt; correction.second.vert_offset_correction;
  out &lt;&lt; YAML::Key &lt;&lt; HORIZ_OFFSET_CORRECTION &lt;&lt; YAML::Value
      &lt;&lt; correction.second.horiz_offset_correction;
  out &lt;&lt; YAML::Key &lt;&lt; MAX_INTENSITY &lt;&lt; YAML::Value
      &lt;&lt; correction.second.max_intensity;
  out &lt;&lt; YAML::Key &lt;&lt; MIN_INTENSITY &lt;&lt; YAML::Value
      &lt;&lt; correction.second.min_intensity;
  out &lt;&lt; YAML::Key &lt;&lt; FOCAL_DISTANCE &lt;&lt; YAML::Value
      &lt;&lt; correction.second.focal_distance;
  out &lt;&lt; YAML::Key &lt;&lt; FOCAL_SLOPE &lt;&lt; YAML::Value
      &lt;&lt; correction.second.focal_slope;
  out &lt;&lt; YAML::EndMap;
  return out;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(113, 0)" endLine="(121, 1)" clone_start="5" clone_end="9">
			<code function_name="Steering65::epas_torque(const std::uint8_t *bytes, int32_t length) const">double Steering65::epas_torque(const std::uint8_t *bytes,
                               int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 8);
  if (x &gt; 0x7F) {
    x -= 0x100;
  }
  return x * 0.062500;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(175, 0)" endLine="(187, 1)" clone_start="9" clone_end="13">
			<code function_name="Brakeinfo74::acceleration_over_ground(const std::uint8_t *bytes, int32_t length) const">double Brakeinfo74::acceleration_over_ground(const std::uint8_t *bytes,
                                             int32_t length) const {
  // vehicle acceleration over ground estimate
  Byte frame_high(bytes + 7);
  int32_t high = frame_high.get_byte(0, 2);
  Byte frame_low(bytes + 6);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  if (value &gt; 0x1FF) {
    value -= 0x400;
  }
  return value * 0.035000;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(123, 0)" endLine="(126, 1)" clone_start="1" clone_end="4">
			<code function_name="Steering65::is_enabled(const std::uint8_t *bytes, int32_t length) const">bool Steering65::is_enabled(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(189, 0)" endLine="(193, 1)" clone_start="1" clone_end="5">
			<code function_name="Brakeinfo74::is_abs_active(const std::uint8_t *bytes, int32_t length) const">bool Brakeinfo74::is_abs_active(const std::uint8_t *bytes,
                                int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(2);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(128, 0)" endLine="(133, 1)" clone_start="1" clone_end="6">
			<code function_name="Steering65::is_driver_override(const std::uint8_t *bytes, int32_t length) const">bool Steering65::is_driver_override(const std::uint8_t *bytes,
                                    int32_t length) const {
  // Cleared on rising edge of EN bit in command message
  Byte frame(bytes + 7);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(195, 0)" endLine="(199, 1)" clone_start="1" clone_end="5">
			<code function_name="Brakeinfo74::is_abs_enabled(const std::uint8_t *bytes, int32_t length) const">bool Brakeinfo74::is_abs_enabled(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(135, 0)" endLine="(139, 1)" clone_start="1" clone_end="5">
			<code function_name="Steering65::is_driver_activity(const std::uint8_t *bytes, int32_t length) const">bool Steering65::is_driver_activity(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(201, 0)" endLine="(205, 1)" clone_start="1" clone_end="5">
			<code function_name="Brakeinfo74::is_stability_control_active(const std::uint8_t *bytes, int32_t length) const">bool Brakeinfo74::is_stability_control_active(const std::uint8_t *bytes,
                                              int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(4);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(141, 0)" endLine="(145, 1)" clone_start="1" clone_end="5">
			<code function_name="Steering65::is_watchdog_counter_fault(const std::uint8_t *bytes, int32_t length) const">bool Steering65::is_watchdog_counter_fault(const std::uint8_t *bytes,
                                           int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(207, 0)" endLine="(211, 1)" clone_start="1" clone_end="5">
			<code function_name="Brakeinfo74::is_stability_control_enabled(const std::uint8_t *bytes, int32_t length) const">bool Brakeinfo74::is_stability_control_enabled(const std::uint8_t *bytes,
                                               int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(5);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(147, 0)" endLine="(151, 1)" clone_start="1" clone_end="5">
			<code function_name="Steering65::is_channel_1_fault(const std::uint8_t *bytes, int32_t length) const">bool Steering65::is_channel_1_fault(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(213, 0)" endLine="(217, 1)" clone_start="1" clone_end="5">
			<code function_name="Brakeinfo74::is_traction_control_active(const std::uint8_t *bytes, int32_t length) const">bool Brakeinfo74::is_traction_control_active(const std::uint8_t *bytes,
                                             int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(6);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(153, 0)" endLine="(157, 1)" clone_start="1" clone_end="4">
			<code function_name="Steering65::is_channel_2_fault(const std::uint8_t *bytes, int32_t length) const">bool Steering65::is_channel_2_fault(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(219, 0)" endLine="(223, 1)" clone_start="1" clone_end="4">
			<code function_name="Brakeinfo74::is_traction_control_enabled(const std::uint8_t *bytes, int32_t length) const">bool Brakeinfo74::is_traction_control_enabled(const std::uint8_t *bytes,
                                              int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(7);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(102, 0)" endLine="(105, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMapImpl::GetLaneById(const Id&amp; id) const">LaneInfoConstPtr HDMapImpl::GetLaneById(const Id&amp; id) const {
  LaneTable::const_iterator it = lane_table_.find(id.id());
  return it != lane_table_.end() ? it-&gt;second : nullptr;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(107, 0)" endLine="(110, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMapImpl::GetJunctionById(const Id&amp; id) const">JunctionInfoConstPtr HDMapImpl::GetJunctionById(const Id&amp; id) const {
  JunctionTable::const_iterator it = junction_table_.find(id.id());
  return it != junction_table_.end() ? it-&gt;second : nullptr;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(107, 0)" endLine="(110, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMapImpl::GetJunctionById(const Id&amp; id) const">JunctionInfoConstPtr HDMapImpl::GetJunctionById(const Id&amp; id) const {
  JunctionTable::const_iterator it = junction_table_.find(id.id());
  return it != junction_table_.end() ? it-&gt;second : nullptr;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(112, 0)" endLine="(115, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMapImpl::GetSignalById(const Id&amp; id) const">SignalInfoConstPtr HDMapImpl::GetSignalById(const Id&amp; id) const {
  SignalTable::const_iterator it = signal_table_.find(id.id());
  return it != signal_table_.end() ? it-&gt;second : nullptr;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(112, 0)" endLine="(115, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMapImpl::GetSignalById(const Id&amp; id) const">SignalInfoConstPtr HDMapImpl::GetSignalById(const Id&amp; id) const {
  SignalTable::const_iterator it = signal_table_.find(id.id());
  return it != signal_table_.end() ? it-&gt;second : nullptr;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(117, 0)" endLine="(120, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMapImpl::GetCrosswalkById(const Id&amp; id) const">CrosswalkInfoConstPtr HDMapImpl::GetCrosswalkById(const Id&amp; id) const {
  CrosswalkTable::const_iterator it = crosswalk_table_.find(id.id());
  return it != crosswalk_table_.end() ? it-&gt;second : nullptr;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(117, 0)" endLine="(120, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMapImpl::GetCrosswalkById(const Id&amp; id) const">CrosswalkInfoConstPtr HDMapImpl::GetCrosswalkById(const Id&amp; id) const {
  CrosswalkTable::const_iterator it = crosswalk_table_.find(id.id());
  return it != crosswalk_table_.end() ? it-&gt;second : nullptr;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(122, 0)" endLine="(125, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMapImpl::GetStopSignById(const Id&amp; id) const">StopSignInfoConstPtr HDMapImpl::GetStopSignById(const Id&amp; id) const {
  StopSignTable::const_iterator it = stop_sign_table_.find(id.id());
  return it != stop_sign_table_.end() ? it-&gt;second : nullptr;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(122, 0)" endLine="(125, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMapImpl::GetStopSignById(const Id&amp; id) const">StopSignInfoConstPtr HDMapImpl::GetStopSignById(const Id&amp; id) const {
  StopSignTable::const_iterator it = stop_sign_table_.find(id.id());
  return it != stop_sign_table_.end() ? it-&gt;second : nullptr;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(127, 0)" endLine="(130, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMapImpl::GetYieldSignById(const Id&amp; id) const">YieldSignInfoConstPtr HDMapImpl::GetYieldSignById(const Id&amp; id) const {
  YieldSignTable::const_iterator it = yield_sign_table_.find(id.id());
  return it != yield_sign_table_.end() ? it-&gt;second : nullptr;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(127, 0)" endLine="(130, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMapImpl::GetYieldSignById(const Id&amp; id) const">YieldSignInfoConstPtr HDMapImpl::GetYieldSignById(const Id&amp; id) const {
  YieldSignTable::const_iterator it = yield_sign_table_.find(id.id());
  return it != yield_sign_table_.end() ? it-&gt;second : nullptr;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(132, 0)" endLine="(135, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMapImpl::GetOverlapById(const Id&amp; id) const">OverlapInfoConstPtr HDMapImpl::GetOverlapById(const Id&amp; id) const {
  OverlapTable::const_iterator it = overlap_table_.find(id.id());
  return it != overlap_table_.end() ? it-&gt;second : nullptr;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(132, 0)" endLine="(135, 1)" clone_start="1" clone_end="3">
			<code function_name="HDMapImpl::GetOverlapById(const Id&amp; id) const">OverlapInfoConstPtr HDMapImpl::GetOverlapById(const Id&amp; id) const {
  OverlapTable::const_iterator it = overlap_table_.find(id.id());
  return it != overlap_table_.end() ? it-&gt;second : nullptr;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(137, 0)" endLine="(140, 1)" clone_start="1" clone_end="3">
			<code function_name="HDMapImpl::GetRoadById(const Id&amp; id) const">RoadInfoConstPtr HDMapImpl::GetRoadById(const Id&amp; id) const {
  RoadTable::const_iterator it = road_table_.find(id.id());
  return it != road_table_.end() ? it-&gt;second : nullptr;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="157" clone_end="193">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="146" clone_end="182">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="51" clone_end="86">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\spiral_curve\cubic_spiral_curve.cc" startLine="(182, 0)" endLine="(238, 1)" clone_start="28" clone_end="57">
			<code function_name="CubicSpiralCurve::GetPathVec( const std::uint32_t n, std::vector&lt;common::PathPoint&gt;* path_points) const">Status CubicSpiralCurve::GetPathVec(
    const std::uint32_t n, std::vector&lt;common::PathPoint&gt;* path_points) const {
  CHECK_NOTNULL(path_points);

  // initialization
  if (n &lt; 2 || error() &gt; spiral_config().newton_raphson_tol()) {
    return Status(ErrorCode::PLANNING_ERROR, "CubicSpiralCurve::get_path_vec");
  }

  path_points-&gt;resize(n);

  std::vector&lt;common::PathPoint&gt;&amp; result = *path_points;
  const double ds = sg() / (n - 1);

  std::array&lt;double, 4&gt; p_value;
  std::copy_n(p_params().begin(), 4, p_value.begin());

  result[0].set_x(start_point().x());
  result[0].set_y(start_point().y());
  result[0].set_theta(start_point().theta());
  result[0].set_kappa(start_point().kappa());
  result[0].set_dkappa(SpiralFormula::dkappa_func_k3(0, sg(), p_value));

  // calculate path x, y using iterative trapezoidal method
  // initialization
  double s = ds;
  // calculate heading kappa along the path
  std::array&lt;double, 4&gt; a_params = SpiralFormula::p_to_a_k3(sg(), p_value);

  for (std::uint32_t i = 1; i &lt; n; ++i) {
    result[i].set_s(s);
    result[i].set_theta(SpiralFormula::theta_func_k3_a(s, a_params) +
                        result[0].theta());
    result[i].set_kappa(SpiralFormula::kappa_func_k3_a(s, a_params));
    result[i].set_dkappa(SpiralFormula::dkappa_func_k3_a(s, a_params));
    s += ds;
  }

  // integration x, y along the path
  double dx = 0;
  double dy = 0;

  for (std::uint32_t k = 1; k &lt; n; ++k) {
    dx = (dx / k) * (k - 1) +
         (std::cos(std::fmod(result[k].theta(), s_two_pi_)) +
          std::cos(std::fmod(result[k - 1].theta(), s_two_pi_))) /
             (2 * k);
    dy = (dy / k) * (k - 1) +
         (std::sin(std::fmod(result[k].theta(), s_two_pi_)) +
          std::sin(std::fmod(result[k - 1].theta(), s_two_pi_))) /
             (2 * k);
    result[k].set_x(result[k].s() * dx + result[0].x());
    result[k].set_y(result[k].s() * dy + result[0].y());
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\spiral_curve\quintic_spiral_curve.cc" startLine="(193, 0)" endLine="(247, 1)" clone_start="26" clone_end="55">
			<code function_name="QuinticSpiralCurve::GetPathVec( const std::uint32_t n, std::vector&lt;common::PathPoint&gt;* path_points) const">Status QuinticSpiralCurve::GetPathVec(
    const std::uint32_t n, std::vector&lt;common::PathPoint&gt;* path_points) const {
  CHECK_NOTNULL(path_points);

  if (n &lt;= 1 || error() &gt; spiral_config().newton_raphson_tol()) {
    return Status(ErrorCode::PLANNING_ERROR,
                  "QuinticSpiralCurve::get_path_vec");
  }

  path_points-&gt;resize(n);
  std::vector&lt;common::PathPoint&gt;&amp; result = *path_points;

  result[0].set_x(start_point().x());
  result[0].set_y(start_point().y());
  result[0].set_theta(start_point().theta());
  result[0].set_kappa(start_point().kappa());
  result[0].set_dkappa(start_point().dkappa());
  result[0].set_ddkappa(start_point().ddkappa());

  const double ds = sg() / (n - 1);
  double s = ds;

  // calculate theta kappa along the path
  std::array&lt;double, 6&gt; p_value;
  std::copy(p_params().begin(), p_params().end(), p_value.begin());
  std::array&lt;double, 6&gt; a_params = SpiralFormula::p_to_a_k5(sg(), p_value);

  for (std::uint32_t i = 1; i &lt; n; ++i) {
    result[i].set_s(s);
    result[i].set_theta(SpiralFormula::theta_func_k5_a(s, a_params) +
                        result[0].theta());
    result[i].set_kappa(SpiralFormula::kappa_func_k5_a(s, a_params));
    result[i].set_dkappa(SpiralFormula::dkappa_func_k5_a(s, a_params));
    s += ds;
  }

  // integration x, y along the path
  double dx = 0.0;
  double dy = 0.0;

  for (std::uint32_t k = 1; k &lt; n; ++k) {
    dx = (dx / k) * (k - 1) +
         (std::cos(std::fmod(result[k].theta(), s_two_pi_)) +
          std::cos(std::fmod(result[k - 1].theta(), s_two_pi_))) /
             (2 * k);
    dy = (dy / k) * (k - 1) +
         (std::sin(std::fmod(result[k].theta(), s_two_pi_)) +
          std::sin(std::fmod(result[k - 1].theta(), s_two_pi_))) /
             (2 * k);
    result[k].set_x(result[k].s() * dx + result[0].x());
    result[k].set_y(result[k].s() * dy + result[0].y());
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\spiral_curve\cubic_spiral_curve.cc" startLine="(240, 0)" endLine="(301, 1)" clone_start="1" clone_end="4">
			<code function_name="CubicSpiralCurve::GetPathVecWithS(const std::vector&lt;double&gt;&amp; vec_s, std::vector&lt;common::PathPoint&gt;* path_points) const">Status CubicSpiralCurve::GetPathVecWithS(
    const std::vector&lt;double&gt;&amp; vec_s,
    std::vector&lt;common::PathPoint&gt;* path_points) const {
  CHECK_NOTNULL(path_points);

  if (vec_s.empty() || error() &gt; spiral_config().newton_raphson_tol()) {
    return Status(ErrorCode::PLANNING_ERROR,
                  "CubicSpiralCurve::get_path_vec_with_s");
  }

  const std::uint32_t n = vec_s.size();
  std::vector&lt;common::PathPoint&gt;&amp; result = *path_points;
  result.resize(n);

  std::array&lt;double, 4&gt; p_value;
  std::copy_n(p_params().begin(), 4, p_value.begin());

  common::PathPoint ref_point(start_point());

  ref_point.set_s(0.0);
  std::array&lt;double, 4&gt; a_params = SpiralFormula::p_to_a_k3(sg(), p_value);

  for (std::uint32_t i = 0; i &lt; n; ++i) {
    result[i].set_s(vec_s[i]);
    result[i].set_theta(
        planning::SpiralFormula::theta_func_k3_a(vec_s[i], a_params) +
        ref_point.theta());
    result[i].set_kappa(
        planning::SpiralFormula::kappa_func_k3_a(vec_s[i], a_params));
    result[i].set_dkappa(
        planning::SpiralFormula::dkappa_func_k3_a(vec_s[i], a_params));
  }

  double dx = 0.0;
  double dy = 0.0;
  // start from here, add k = 0, revise the result[k] = ...
  dx += (vec_s[0] - ref_point.s()) *
        (std::cos(std::fmod(ref_point.theta(), s_two_pi_)) +
         std::cos(std::fmod(result[0].theta(), s_two_pi_))) /
        2.0;
  dy += (vec_s[0] - ref_point.s()) *
        (std::sin(std::fmod(ref_point.theta(), s_two_pi_)) +
         std::sin(std::fmod(result[0].theta(), s_two_pi_))) /
        2.0;
  result[0].set_x(dx + ref_point.x());
  result[0].set_y(dy + ref_point.y());

  for (std::uint32_t k = 1; k &lt; n; ++k) {
    dx += (vec_s[k] - vec_s[k - 1]) *
          (std::cos(std::fmod(result[k - 1].theta(), s_two_pi_)) +
           std::cos(std::fmod(result[k].theta(), s_two_pi_))) /
          2.0;
    dy += (vec_s[k] - vec_s[k - 1]) *
          (std::sin(std::fmod(result[k - 1].theta(), s_two_pi_)) +
           std::sin(std::fmod(result[k].theta(), s_two_pi_))) /
          2.0;
    result[k].set_x(dx + ref_point.x());
    result[k].set_y(dy + ref_point.y());
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\spiral_curve\quintic_spiral_curve.cc" startLine="(249, 0)" endLine="(309, 1)" clone_start="1" clone_end="4">
			<code function_name="QuinticSpiralCurve::GetPathVecWithS(const std::vector&lt;double&gt;&amp; vec_s, std::vector&lt;common::PathPoint&gt;* path_points) const">Status QuinticSpiralCurve::GetPathVecWithS(
    const std::vector&lt;double&gt;&amp; vec_s,
    std::vector&lt;common::PathPoint&gt;* path_points) const {
  CHECK_NOTNULL(path_points);

  if (error() &gt; spiral_config().newton_raphson_tol()) {
    return Status(ErrorCode::PLANNING_ERROR,
                  "QuinticSpiralCurve::get_path_vec_with_s");
  }

  if (vec_s.size() == 0) {
    return Status::OK();
  }

  const std::uint32_t n = vec_s.size();

  common::PathPoint ref_point = start_point();

  path_points-&gt;resize(n);
  std::vector&lt;common::PathPoint&gt;&amp; result = *path_points;
  std::array&lt;double, 6&gt; p_value;
  std::copy(p_params().begin(), p_params().end(), p_value.begin());
  std::array&lt;double, 6&gt; a_params = SpiralFormula::p_to_a_k5(sg(), p_value);

  for (std::uint32_t i = 0; i &lt; n; ++i) {
    result[i].set_s(vec_s[i]);
    result[i].set_theta(SpiralFormula::theta_func_k5_a(vec_s[i], a_params) +
                        ref_point.theta());
    result[i].set_kappa(SpiralFormula::kappa_func_k5_a(vec_s[i], a_params));
    result[i].set_dkappa(SpiralFormula::dkappa_func_k5_a(vec_s[i], a_params));
  }

  double dx = 0.0;
  double dy = 0.0;

  // start from here, add k = 0, revise the result[k] = ...
  dx += (vec_s[0] - ref_point.s()) *
        (std::cos(std::fmod(ref_point.theta(), s_two_pi_)) +
         std::cos(std::fmod(result[0].theta(), s_two_pi_))) /
        2.0;
  dy += (vec_s[0] - ref_point.s()) *
        (std::cos(std::fmod(ref_point.theta(), s_two_pi_)) +
         std::cos(std::fmod(result[0].theta(), s_two_pi_))) /
        2.0;
  result[0].set_x(dx + ref_point.x());
  result[0].set_y(dy + ref_point.y());
  for (std::uint32_t k = 1; k &lt; n; ++k) {
    dx += (vec_s[k] - vec_s[k - 1]) *
          (std::cos(std::fmod(result[k - 1].theta(), s_two_pi_)) +
           std::cos(std::fmod(result[k].theta(), s_two_pi_))) /
          2.0;
    dy += (vec_s[k] - vec_s[k - 1]) *
          (std::sin(std::fmod(result[k - 1].theta(), s_two_pi_)) +
           std::sin(std::fmod(result[k].theta(), s_two_pi_))) /
          2.0;
    result[k].set_x(dx + ref_point.x());
    result[k].set_y(dy + ref_point.y());
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(52, 0)" endLine="(64, 1)" clone_start="1" clone_end="13">
			<code function_name="Throttle63::pedal_input(const std::uint8_t *bytes, int32_t length) const">double Throttle63::pedal_input(const std::uint8_t *bytes,
                               int32_t length) const {
  // Pedal Input from the physical pedal
  Byte frame_high(bytes + 1);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 0);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(66, 0)" endLine="(77, 1)" clone_start="1" clone_end="12">
			<code function_name="Throttle63::pedal_cmd(const std::uint8_t *bytes, int32_t length) const">double Throttle63::pedal_cmd(const std::uint8_t *bytes, int32_t length) const {
  // Pedal Command from the command message
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(66, 0)" endLine="(77, 1)" clone_start="1" clone_end="12">
			<code function_name="Throttle63::pedal_cmd(const std::uint8_t *bytes, int32_t length) const">double Throttle63::pedal_cmd(const std::uint8_t *bytes, int32_t length) const {
  // Pedal Command from the command message
  Byte frame_high(bytes + 3);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 2);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(79, 0)" endLine="(91, 1)" clone_start="1" clone_end="13">
			<code function_name="Throttle63::pedal_output(const std::uint8_t *bytes, int32_t length) const">double Throttle63::pedal_output(const std::uint8_t *bytes,
                                int32_t length) const {
  // Pedal Output is the maximum of PI and PC
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(79, 0)" endLine="(91, 1)" clone_start="1" clone_end="5">
			<code function_name="Throttle63::pedal_output(const std::uint8_t *bytes, int32_t length) const">double Throttle63::pedal_output(const std::uint8_t *bytes,
                                int32_t length) const {
  // Pedal Output is the maximum of PI and PC
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(93, 0)" endLine="(98, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle63::watchdog_counter_source(const std::uint8_t *bytes, int32_t length) const">int32_t Throttle63::watchdog_counter_source(const std::uint8_t *bytes,
                                            int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(214, 2)" endLine="(214, 47)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const Id &amp;id() const { return signal_.id(); }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(256, 2)" endLine="(256, 50)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const Id &amp;id() const { return stop_sign_.id(); }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(278, 2)" endLine="(278, 51)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const Id &amp;id() const { return yield_sign_.id(); }</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(215, 2)" endLine="(215, 50)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const Signal &amp;signal() const { return signal_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(257, 2)" endLine="(257, 58)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const StopSign &amp;stop_sign() const { return stop_sign_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(279, 2)" endLine="(279, 61)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const YieldSign &amp;yield_sign() const { return yield_sign_; }</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(216, 2)" endLine="(218, 3)" clone_start="1" clone_end="3">
			<code function_name="set_section_id(const Id &amp;section_id)">  const std::vector&lt;apollo::common::math::LineSegment2d&gt; &amp;segments() const {
    return segments_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(258, 2)" endLine="(260, 3)" clone_start="1" clone_end="3">
			<code function_name="set_section_id(const Id &amp;section_id)">  const std::vector&lt;apollo::common::math::LineSegment2d&gt; &amp;segments() const {
    return segments_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(280, 2)" endLine="(282, 3)" clone_start="1" clone_end="3">
			<code function_name="set_section_id(const Id &amp;section_id)">  const std::vector&lt;apollo::common::math::LineSegment2d&gt; &amp;segments() const {
    return segments_;
  }</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(236, 2)" endLine="(236, 50)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const Id &amp;id() const { return crosswalk_.id(); }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(278, 2)" endLine="(278, 51)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const Id &amp;id() const { return yield_sign_.id(); }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(300, 2)" endLine="(300, 48)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const Id &amp;id() const { return overlap_.id(); }</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(237, 2)" endLine="(237, 59)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const Crosswalk &amp;crosswalk() const { return crosswalk_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(279, 2)" endLine="(279, 61)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const YieldSign &amp;yield_sign() const { return yield_sign_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(301, 2)" endLine="(301, 53)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const Overlap &amp;overlap() const { return overlap_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="99" clone_end="127">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="36" clone_end="65">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(256, 2)" endLine="(256, 50)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const Id &amp;id() const { return stop_sign_.id(); }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(214, 2)" endLine="(214, 47)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const Id &amp;id() const { return signal_.id(); }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(257, 2)" endLine="(257, 58)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const StopSign &amp;stop_sign() const { return stop_sign_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(215, 2)" endLine="(215, 50)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const Signal &amp;signal() const { return signal_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(258, 2)" endLine="(260, 3)" clone_start="1" clone_end="3">
			<code function_name="set_section_id(const Id &amp;section_id)">  const std::vector&lt;apollo::common::math::LineSegment2d&gt; &amp;segments() const {
    return segments_;
  }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(216, 2)" endLine="(218, 3)" clone_start="1" clone_end="3">
			<code function_name="set_section_id(const Id &amp;section_id)">  const std::vector&lt;apollo::common::math::LineSegment2d&gt; &amp;segments() const {
    return segments_;
  }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(278, 2)" endLine="(278, 51)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const Id &amp;id() const { return yield_sign_.id(); }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(236, 2)" endLine="(236, 50)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const Id &amp;id() const { return crosswalk_.id(); }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(279, 2)" endLine="(279, 61)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const YieldSign &amp;yield_sign() const { return yield_sign_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_common.h" startLine="(237, 2)" endLine="(237, 59)" clone_start="1" clone_end="1">
			<code function_name="set_section_id(const Id &amp;section_id)">  const Crosswalk &amp;crosswalk() const { return crosswalk_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(49, 0)" endLine="(53, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::month(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::month(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(43, 0)" endLine="(47, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::year(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::year(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 7);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(55, 0)" endLine="(59, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::day(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::day(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 2);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(49, 0)" endLine="(53, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::month(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::month(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 4);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(61, 0)" endLine="(65, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::hours(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::hours(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(55, 0)" endLine="(59, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::day(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::day(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 2);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(67, 0)" endLine="(71, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::minutes(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::minutes(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(61, 0)" endLine="(65, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::hours(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::hours(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(73, 0)" endLine="(77, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::seconds(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::seconds(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 5);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(67, 0)" endLine="(71, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::minutes(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::minutes(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(79, 0)" endLine="(84, 1)" clone_start="1" clone_end="4">
			<code function_name="Gps6e::compass_direction(const std::uint8_t *bytes, int32_t length) const">double Gps6e::compass_direction(const std::uint8_t *bytes,
                                int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(0, 4);
  return x * 45.000000;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(73, 0)" endLine="(77, 1)" clone_start="1" clone_end="3">
			<code function_name="Gps6e::seconds(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::seconds(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 5);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(26, 0)" endLine="(90, 1)" clone_start="3" clone_end="25">
			<code function_name="Gear67::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Gear67::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t gear = gear_state(bytes, length);
  switch (gear) {
    case 0x01:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_PARKING);
      break;
    case 0x02:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_REVERSE);
      break;
    case 0x03:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_NEUTRAL);
      break;
    case 0x04:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_DRIVE);
      break;
    case 0x05:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_LOW);
      break;
    case 0x00:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_NONE);
      break;
    default:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_INVALID);
      break;
  }

  if (is_driver_override(bytes, length)) {
    // last shift requested by driver
    chassis_detail-&gt;mutable_gear()-&gt;set_is_shift_position_valid(false);
  } else {
    // last shift requested by-wire
    chassis_detail-&gt;mutable_gear()-&gt;set_is_shift_position_valid(true);
  }
  chassis_detail-&gt;mutable_gear()-&gt;set_driver_override(
      is_driver_override(bytes, length));

  int32_t gear_cmd = reported_gear_cmd(bytes, length);
  switch (gear_cmd) {
    case 0x01:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_PARKING);
      break;
    case 0x02:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_REVERSE);
      break;
    case 0x03:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_NEUTRAL);
      break;
    case 0x04:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_DRIVE);
      break;
    case 0x05:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_LOW);
      break;
    case 0x00:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_NONE);
      break;
    default:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_INVALID);
      break;
  }

  chassis_detail-&gt;mutable_gear()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gear_67.cc" startLine="(26, 0)" endLine="(90, 1)" clone_start="38" clone_end="60">
			<code function_name="Gear67::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Gear67::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t gear = gear_state(bytes, length);
  switch (gear) {
    case 0x01:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_PARKING);
      break;
    case 0x02:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_REVERSE);
      break;
    case 0x03:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_NEUTRAL);
      break;
    case 0x04:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_DRIVE);
      break;
    case 0x05:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_LOW);
      break;
    case 0x00:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_NONE);
      break;
    default:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_state(Chassis::GEAR_INVALID);
      break;
  }

  if (is_driver_override(bytes, length)) {
    // last shift requested by driver
    chassis_detail-&gt;mutable_gear()-&gt;set_is_shift_position_valid(false);
  } else {
    // last shift requested by-wire
    chassis_detail-&gt;mutable_gear()-&gt;set_is_shift_position_valid(true);
  }
  chassis_detail-&gt;mutable_gear()-&gt;set_driver_override(
      is_driver_override(bytes, length));

  int32_t gear_cmd = reported_gear_cmd(bytes, length);
  switch (gear_cmd) {
    case 0x01:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_PARKING);
      break;
    case 0x02:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_REVERSE);
      break;
    case 0x03:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_NEUTRAL);
      break;
    case 0x04:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_DRIVE);
      break;
    case 0x05:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_LOW);
      break;
    case 0x00:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_NONE);
      break;
    default:
      chassis_detail-&gt;mutable_gear()-&gt;set_gear_cmd(Chassis::GEAR_INVALID);
      break;
  }

  chassis_detail-&gt;mutable_gear()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="10">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brakeinfo_74.cc" startLine="(26, 0)" endLine="(109, 1)" clone_start="6" clone_end="32">
			<code function_name="Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Brakeinfo74::Parse(const std::uint8_t *bytes, int32_t length,
                        ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_req(
      braking_torque_request(bytes, length));
  switch (hill_start_assist_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_INACTIVE);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_FINDING_GRADIENT);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_PRESSED);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(
          Brake::HSA_ACTIVE_RELEASED);
      break;
    case 4:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAST_RELEASE);
      break;
    case 5:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_SLOW_RELEASE);
      break;
    case 6:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_FAILED);
      break;
    case 7:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_status(Brake::HSA_UNDEFINED);
      break;
  }
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_vehicle_standstill(
      is_vehicle_stationary(bytes, length));
  chassis_detail-&gt;mutable_brake()-&gt;set_brake_torque_act(
      braking_torque_actual(bytes, length));
  switch (hill_start_assist_mode(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_AUTO);
      break;
    case 2:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MANUAL);
      break;
    case 3:
      chassis_detail-&gt;mutable_brake()-&gt;set_hsa_mode(Brake::HSA_MODE_UNDEFINED);
      break;
  }
  switch (parking_brake_status(bytes, length)) {
    case 0:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_TRANSITION);
      break;
    case 2:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(Epb::PBRAKE_ON);
      break;
    case 3:
      chassis_detail-&gt;mutable_epb()-&gt;set_parking_brake_status(
          Epb::PBRAKE_FAULT);
      break;
  }
  chassis_detail-&gt;mutable_brake()-&gt;set_wheel_torque_act(
      wheel_torque_actual(bytes, length));
  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_acc_est(
      acceleration_over_ground(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_active(
      is_abs_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_abs_enabled(
      is_abs_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_active(
      is_stability_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_stab_enabled(
      is_stability_control_enabled(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_active(
      is_traction_control_active(bytes, length));
  chassis_detail-&gt;mutable_esp()-&gt;set_is_trac_enabled(
      is_traction_control_enabled(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="74" clone_end="100">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="70" clone_end="97">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="66" clone_end="94">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="62" clone_end="91">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="58" clone_end="87">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="54" clone_end="83">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="50" clone_end="79">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="47" clone_end="76">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="44" clone_end="73">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\simulation_world\simulation_world_service.cc" startLine="(167, 0)" endLine="(199, 1)" clone_start="3" clone_end="26">
			<code function_name="SetStopReason(const StopReasonCode &amp;reason_code, Decision *decision)">void SetStopReason(const StopReasonCode &amp;reason_code, Decision *decision) {
  switch (reason_code) {
    case StopReasonCode::STOP_REASON_HEAD_VEHICLE:
      decision-&gt;set_stopreason(Decision::STOP_REASON_HEAD_VEHICLE);
      break;
    case StopReasonCode::STOP_REASON_DESTINATION:
      decision-&gt;set_stopreason(Decision::STOP_REASON_DESTINATION);
      break;
    case StopReasonCode::STOP_REASON_PEDESTRIAN:
      decision-&gt;set_stopreason(Decision::STOP_REASON_PEDESTRIAN);
      break;
    case StopReasonCode::STOP_REASON_OBSTACLE:
      decision-&gt;set_stopreason(Decision::STOP_REASON_OBSTACLE);
      break;
    case StopReasonCode::STOP_REASON_SIGNAL:
      decision-&gt;set_stopreason(Decision::STOP_REASON_SIGNAL);
      break;
    case StopReasonCode::STOP_REASON_STOP_SIGN:
      decision-&gt;set_stopreason(Decision::STOP_REASON_STOP_SIGN);
      break;
    case StopReasonCode::STOP_REASON_YIELD_SIGN:
      decision-&gt;set_stopreason(Decision::STOP_REASON_YIELD_SIGN);
      break;
    case StopReasonCode::STOP_REASON_CLEAR_ZONE:
      decision-&gt;set_stopreason(Decision::STOP_REASON_CLEAR_ZONE);
      break;
    case StopReasonCode::STOP_REASON_CROSSWALK:
      decision-&gt;set_stopreason(Decision::STOP_REASON_CROSSWALK);
      break;
    default:
      AWARN &lt;&lt; "Unrecognizable stop reason code:" &lt;&lt; reason_code;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\simulation_world\simulation_world_service.cc" startLine="(167, 0)" endLine="(199, 1)" clone_start="6" clone_end="29">
			<code function_name="SetStopReason(const StopReasonCode &amp;reason_code, Decision *decision)">void SetStopReason(const StopReasonCode &amp;reason_code, Decision *decision) {
  switch (reason_code) {
    case StopReasonCode::STOP_REASON_HEAD_VEHICLE:
      decision-&gt;set_stopreason(Decision::STOP_REASON_HEAD_VEHICLE);
      break;
    case StopReasonCode::STOP_REASON_DESTINATION:
      decision-&gt;set_stopreason(Decision::STOP_REASON_DESTINATION);
      break;
    case StopReasonCode::STOP_REASON_PEDESTRIAN:
      decision-&gt;set_stopreason(Decision::STOP_REASON_PEDESTRIAN);
      break;
    case StopReasonCode::STOP_REASON_OBSTACLE:
      decision-&gt;set_stopreason(Decision::STOP_REASON_OBSTACLE);
      break;
    case StopReasonCode::STOP_REASON_SIGNAL:
      decision-&gt;set_stopreason(Decision::STOP_REASON_SIGNAL);
      break;
    case StopReasonCode::STOP_REASON_STOP_SIGN:
      decision-&gt;set_stopreason(Decision::STOP_REASON_STOP_SIGN);
      break;
    case StopReasonCode::STOP_REASON_YIELD_SIGN:
      decision-&gt;set_stopreason(Decision::STOP_REASON_YIELD_SIGN);
      break;
    case StopReasonCode::STOP_REASON_CLEAR_ZONE:
      decision-&gt;set_stopreason(Decision::STOP_REASON_CLEAR_ZONE);
      break;
    case StopReasonCode::STOP_REASON_CROSSWALK:
      decision-&gt;set_stopreason(Decision::STOP_REASON_CROSSWALK);
      break;
    default:
      AWARN &lt;&lt; "Unrecognizable stop reason code:" &lt;&lt; reason_code;
  }
}</code>
		</source>
	</dup>
	<dup count="17">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(123, 0)" endLine="(126, 1)" clone_start="1" clone_end="4">
			<code function_name="Steering65::is_enabled(const std::uint8_t *bytes, int32_t length) const">bool Steering65::is_enabled(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(123, 0)" endLine="(126, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake61::is_enabled(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_enabled(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(332, 0)" endLine="(336, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_left_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_rear_left_door_open(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(326, 0)" endLine="(330, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_door_open(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(320, 0)" endLine="(324, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_driver_door_open(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(315, 0)" endLine="(318, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(309, 0)" endLine="(313, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_lka_on_or_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_lka_on_or_off_pressed(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(303, 0)" endLine="(307, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t *bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(297, 0)" endLine="(301, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t *bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(291, 0)" endLine="(295, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(285, 0)" endLine="(289, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(279, 0)" endLine="(283, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t *bytes,
                                             int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(273, 0)" endLine="(277, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_or_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_on_or_off_pressed(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(267, 0)" endLine="(271, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_cancel_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_cancel_pressed(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(261, 0)" endLine="(265, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_resume_pressed(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(255, 0)" endLine="(259, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_off_pressed(const std::uint8_t *bytes,
                                int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(249, 0)" endLine="(253, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_on_pressed(const std::uint8_t *bytes,
                               int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="17">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(128, 0)" endLine="(133, 1)" clone_start="1" clone_end="6">
			<code function_name="Steering65::is_driver_override(const std::uint8_t *bytes, int32_t length) const">bool Steering65::is_driver_override(const std::uint8_t *bytes,
                                    int32_t length) const {
  // Cleared on rising edge of EN bit in command message
  Byte frame(bytes + 7);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(128, 0)" endLine="(132, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_driver_override(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_driver_override(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(338, 0)" endLine="(342, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_right_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_rear_right_door_open(const std::uint8_t *bytes,
                                     int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(332, 0)" endLine="(336, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_left_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_rear_left_door_open(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(326, 0)" endLine="(330, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_door_open(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(320, 0)" endLine="(324, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_driver_door_open(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(315, 0)" endLine="(318, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(309, 0)" endLine="(313, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_lka_on_or_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_lka_on_or_off_pressed(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(303, 0)" endLine="(307, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t *bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(297, 0)" endLine="(301, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t *bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(291, 0)" endLine="(295, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(285, 0)" endLine="(289, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(279, 0)" endLine="(283, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t *bytes,
                                             int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(273, 0)" endLine="(277, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_or_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_on_or_off_pressed(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(267, 0)" endLine="(271, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_cancel_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_cancel_pressed(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(261, 0)" endLine="(265, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_resume_pressed(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(255, 0)" endLine="(259, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_off_pressed(const std::uint8_t *bytes,
                                int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(4);
}</code>
		</source>
	</dup>
	<dup count="17">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(135, 0)" endLine="(139, 1)" clone_start="1" clone_end="5">
			<code function_name="Steering65::is_driver_activity(const std::uint8_t *bytes, int32_t length) const">bool Steering65::is_driver_activity(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(134, 0)" endLine="(138, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_driver_activity(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_driver_activity(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(344, 0)" endLine="(347, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_hood_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_hood_open(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(338, 0)" endLine="(342, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_right_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_rear_right_door_open(const std::uint8_t *bytes,
                                     int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(332, 0)" endLine="(336, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_left_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_rear_left_door_open(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(326, 0)" endLine="(330, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_door_open(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(320, 0)" endLine="(324, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_driver_door_open(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(315, 0)" endLine="(318, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(309, 0)" endLine="(313, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_lka_on_or_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_lka_on_or_off_pressed(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(303, 0)" endLine="(307, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t *bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(297, 0)" endLine="(301, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t *bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(291, 0)" endLine="(295, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(285, 0)" endLine="(289, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(279, 0)" endLine="(283, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t *bytes,
                                             int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(273, 0)" endLine="(277, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_or_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_on_or_off_pressed(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(267, 0)" endLine="(271, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_cancel_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_cancel_pressed(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(261, 0)" endLine="(265, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_resume_pressed(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(5);
}</code>
		</source>
	</dup>
	<dup count="17">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(141, 0)" endLine="(145, 1)" clone_start="1" clone_end="5">
			<code function_name="Steering65::is_watchdog_counter_fault(const std::uint8_t *bytes, int32_t length) const">bool Steering65::is_watchdog_counter_fault(const std::uint8_t *bytes,
                                           int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(140, 0)" endLine="(144, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_watchdog_counter_fault(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_watchdog_counter_fault(const std::uint8_t *bytes,
                                        int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(349, 0)" endLine="(352, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_trunk_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_trunk_open(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(344, 0)" endLine="(347, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_hood_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_hood_open(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(338, 0)" endLine="(342, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_right_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_rear_right_door_open(const std::uint8_t *bytes,
                                     int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(332, 0)" endLine="(336, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_left_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_rear_left_door_open(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(326, 0)" endLine="(330, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_door_open(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(320, 0)" endLine="(324, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_driver_door_open(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(315, 0)" endLine="(318, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(309, 0)" endLine="(313, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_lka_on_or_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_lka_on_or_off_pressed(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(303, 0)" endLine="(307, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t *bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(297, 0)" endLine="(301, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t *bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(291, 0)" endLine="(295, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(285, 0)" endLine="(289, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(279, 0)" endLine="(283, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t *bytes,
                                             int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(273, 0)" endLine="(277, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_or_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_on_or_off_pressed(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(267, 0)" endLine="(271, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_cancel_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_cancel_pressed(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(6);
}</code>
		</source>
	</dup>
	<dup count="17">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(147, 0)" endLine="(151, 1)" clone_start="1" clone_end="5">
			<code function_name="Steering65::is_channel_1_fault(const std::uint8_t *bytes, int32_t length) const">bool Steering65::is_channel_1_fault(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(146, 0)" endLine="(150, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_channel_1_fault(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_channel_1_fault(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(354, 0)" endLine="(358, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_detected(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_detected(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(349, 0)" endLine="(352, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_trunk_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_trunk_open(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(344, 0)" endLine="(347, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_hood_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_hood_open(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(338, 0)" endLine="(342, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_right_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_rear_right_door_open(const std::uint8_t *bytes,
                                     int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(332, 0)" endLine="(336, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_left_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_rear_left_door_open(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(326, 0)" endLine="(330, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_door_open(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(320, 0)" endLine="(324, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_driver_door_open(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(315, 0)" endLine="(318, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(309, 0)" endLine="(313, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_lka_on_or_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_lka_on_or_off_pressed(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(303, 0)" endLine="(307, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t *bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(297, 0)" endLine="(301, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t *bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(291, 0)" endLine="(295, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(285, 0)" endLine="(289, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(279, 0)" endLine="(283, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t *bytes,
                                             int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(273, 0)" endLine="(277, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_or_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_on_or_off_pressed(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(0);
}</code>
		</source>
	</dup>
	<dup count="17">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(153, 0)" endLine="(157, 1)" clone_start="1" clone_end="5">
			<code function_name="Steering65::is_channel_2_fault(const std::uint8_t *bytes, int32_t length) const">bool Steering65::is_channel_2_fault(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(152, 0)" endLine="(156, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_channel_2_fault(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_channel_2_fault(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(360, 0)" endLine="(364, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_airbag_enabled(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_airbag_enabled(const std::uint8_t *bytes,
                                         int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(354, 0)" endLine="(358, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_detected(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_detected(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(349, 0)" endLine="(352, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_trunk_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_trunk_open(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(344, 0)" endLine="(347, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_hood_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_hood_open(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(338, 0)" endLine="(342, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_right_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_rear_right_door_open(const std::uint8_t *bytes,
                                     int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(332, 0)" endLine="(336, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_left_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_rear_left_door_open(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(326, 0)" endLine="(330, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_door_open(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(320, 0)" endLine="(324, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_driver_door_open(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(315, 0)" endLine="(318, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(309, 0)" endLine="(313, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_lka_on_or_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_lka_on_or_off_pressed(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(303, 0)" endLine="(307, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t *bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(297, 0)" endLine="(301, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t *bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(291, 0)" endLine="(295, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(285, 0)" endLine="(289, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(279, 0)" endLine="(283, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t *bytes,
                                             int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(1);
}</code>
		</source>
	</dup>
	<dup count="17">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(159, 0)" endLine="(163, 1)" clone_start="1" clone_end="5">
			<code function_name="Steering65::is_calibration_fault(const std::uint8_t *bytes, int32_t length) const">bool Steering65::is_calibration_fault(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(158, 0)" endLine="(162, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_boo_switch_fault(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_boo_switch_fault(const std::uint8_t *bytes,
                                  int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(366, 0)" endLine="(370, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_belt_buckled(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_driver_belt_buckled(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 4);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(360, 0)" endLine="(364, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_airbag_enabled(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_airbag_enabled(const std::uint8_t *bytes,
                                         int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(354, 0)" endLine="(358, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_detected(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_detected(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(349, 0)" endLine="(352, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_trunk_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_trunk_open(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(344, 0)" endLine="(347, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_hood_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_hood_open(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(338, 0)" endLine="(342, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_right_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_rear_right_door_open(const std::uint8_t *bytes,
                                     int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(332, 0)" endLine="(336, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_left_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_rear_left_door_open(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(326, 0)" endLine="(330, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_door_open(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(320, 0)" endLine="(324, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_driver_door_open(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(315, 0)" endLine="(318, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(309, 0)" endLine="(313, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_lka_on_or_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_lka_on_or_off_pressed(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(303, 0)" endLine="(307, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t *bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(297, 0)" endLine="(301, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t *bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(291, 0)" endLine="(295, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(285, 0)" endLine="(289, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
	</dup>
	<dup count="17">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_65.cc" startLine="(165, 0)" endLine="(169, 1)" clone_start="1" clone_end="4">
			<code function_name="Steering65::is_connector_fault(const std::uint8_t *bytes, int32_t length) const">bool Steering65::is_connector_fault(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(164, 0)" endLine="(168, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake61::is_connector_fault(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_connector_fault(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(372, 0)" endLine="(376, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_passenger_belt_buckled(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_belt_buckled(const std::uint8_t *bytes,
                                       int32_t length) const {
  Byte frame(bytes + 4);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(366, 0)" endLine="(370, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_driver_belt_buckled(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_driver_belt_buckled(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 4);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(360, 0)" endLine="(364, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_passenger_airbag_enabled(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_airbag_enabled(const std::uint8_t *bytes,
                                         int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(354, 0)" endLine="(358, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_passenger_detected(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_detected(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(349, 0)" endLine="(352, 1)" clone_start="1" clone_end="3">
			<code function_name="Misc69::is_trunk_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_trunk_open(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(344, 0)" endLine="(347, 1)" clone_start="1" clone_end="3">
			<code function_name="Misc69::is_hood_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_hood_open(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(338, 0)" endLine="(342, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_rear_right_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_rear_right_door_open(const std::uint8_t *bytes,
                                     int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(332, 0)" endLine="(336, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_rear_left_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_rear_left_door_open(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(326, 0)" endLine="(330, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_passenger_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_door_open(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(320, 0)" endLine="(324, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_driver_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_driver_door_open(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(315, 0)" endLine="(318, 1)" clone_start="1" clone_end="3">
			<code function_name="Misc69::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(309, 0)" endLine="(313, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_lka_on_or_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_lka_on_or_off_pressed(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(303, 0)" endLine="(307, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t *bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(297, 0)" endLine="(301, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t *bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(291, 0)" endLine="(295, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(230, 0)" endLine="(276, 1)" clone_start="7" clone_end="46">
			<code function_name="ObjectTrack::UpdateWithoutObject(const Eigen::VectorXf&amp; predict_state, const double&amp; time_diff)">void ObjectTrack::UpdateWithoutObject(const Eigen::VectorXf&amp; predict_state,
                                      const double&amp; time_diff) {
  // A. update object of track
  TrackedObjectPtr new_obj(new TrackedObject());
  new_obj-&gt;clone(*current_object_);
  Eigen::Vector3f predicted_shift = predict_state.tail(3) * time_diff;
  new_obj-&gt;anchor_point = current_object_-&gt;anchor_point + predicted_shift;
  new_obj-&gt;barycenter = current_object_-&gt;barycenter + predicted_shift;
  new_obj-&gt;center = current_object_-&gt;center + predicted_shift;

  // B. update cloud &amp; polygon
  pcl_util::PointCloudPtr pc = new_obj-&gt;object_ptr-&gt;cloud;
  for (size_t j = 0; j &lt; pc-&gt;points.size(); ++j) {
    pc-&gt;points[j].x += predicted_shift[0];
    pc-&gt;points[j].y += predicted_shift[1];
    pc-&gt;points[j].z += predicted_shift[2];
  }
  PolygonDType&amp; polygon = new_obj-&gt;object_ptr-&gt;polygon;
  for (size_t j = 0; j &lt; polygon.points.size(); ++j) {
    polygon.points[j].x += predicted_shift[0];
    polygon.points[j].y += predicted_shift[1];
    polygon.points[j].z += predicted_shift[2];
  }

  // C. update filter without object
  filter_-&gt;UpdateWithoutObject(time_diff);

  // D. update states of track
  belief_anchor_point_ = new_obj-&gt;anchor_point;
  // NEED TO NOTICE: All the states would be collected mainly based on states
  // of tracked object. Thus, update tracked object when you update the state
  // of track !!!!
  new_obj-&gt;velocity = belief_velocity_;

  // E. update track info
  age_++;
  consecutive_invisible_count_++;
  period_ += time_diff;

  // F. update history
  int history_size = history_objects_.size();
  if (history_size &gt;= s_track_cached_history_size_maximum_) {
    history_objects_.pop_front();
  }
  history_objects_.push_back(current_object_);
  current_object_ = new_obj;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\object_track.cc" startLine="(183, 0)" endLine="(228, 1)" clone_start="6" clone_end="45">
			<code function_name="ObjectTrack::UpdateWithoutObject(const double&amp; time_diff)">void ObjectTrack::UpdateWithoutObject(const double&amp; time_diff) {
  // A. update object of track
  TrackedObjectPtr new_obj(new TrackedObject());
  new_obj-&gt;clone(*current_object_);
  Eigen::Vector3f predicted_shift = belief_velocity_ * time_diff;
  new_obj-&gt;anchor_point = current_object_-&gt;anchor_point + predicted_shift;
  new_obj-&gt;barycenter = current_object_-&gt;barycenter + predicted_shift;
  new_obj-&gt;center = current_object_-&gt;center + predicted_shift;

  // B. update cloud &amp; polygon
  pcl_util::PointCloudPtr pc = new_obj-&gt;object_ptr-&gt;cloud;
  for (size_t j = 0; j &lt; pc-&gt;points.size(); ++j) {
    pc-&gt;points[j].x += predicted_shift[0];
    pc-&gt;points[j].y += predicted_shift[1];
    pc-&gt;points[j].z += predicted_shift[2];
  }
  PolygonDType&amp; polygon = new_obj-&gt;object_ptr-&gt;polygon;
  for (size_t j = 0; j &lt; polygon.points.size(); ++j) {
    polygon.points[j].x += predicted_shift[0];
    polygon.points[j].y += predicted_shift[1];
    polygon.points[j].z += predicted_shift[2];
  }

  // C. update filter
  filter_-&gt;UpdateWithoutObject(time_diff);

  // D. update states of track
  belief_anchor_point_ = new_obj-&gt;anchor_point;
  // NEED TO NOTICE: All the states would be collected mainly based on states
  // of tracked object. Thus, update tracked object when you update the state
  // of track !!!!
  new_obj-&gt;velocity = belief_velocity_;

  // E. update track info
  age_++;
  consecutive_invisible_count_++;
  period_ += time_diff;

  // F. update history
  int history_size = history_objects_.size();
  if (history_size &gt;= s_track_cached_history_size_maximum_) {
    history_objects_.pop_front();
  }
  history_objects_.push_back(current_object_);
  current_object_ = new_obj;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\can_client\esd\esd_can_client.cc" startLine="(178, 0)" endLine="(287, 1)" clone_start="53" clone_end="76">
			<code function_name="EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus)">std::string EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus) {
  struct ERR2STR {
    NTCAN_RESULT ntstatus;
    const char *str;
  };

  int8_t str_buf[ERROR_BUF_SIZE];

  static const struct ERR2STR err2str[] = {
      {NTCAN_SUCCESS, "NTCAN_SUCCESS"},
      {NTCAN_RX_TIMEOUT, "NTCAN_RX_TIMEOUT"},
      {NTCAN_TX_TIMEOUT, "NTCAN_TX_TIMEOUT"},
      {NTCAN_TX_ERROR, "NTCAN_TX_ERROR"},
      {NTCAN_CONTR_OFF_BUS, "NTCAN_CONTR_OFF_BUS"},
      {NTCAN_CONTR_BUSY, "NTCAN_CONTR_BUSY"},
      {NTCAN_CONTR_WARN, "NTCAN_CONTR_WARN"},
      {NTCAN_NO_ID_ENABLED, "NTCAN_NO_ID_ENABLED"},
      {NTCAN_ID_ALREADY_ENABLED, "NTCAN_ID_ALREADY_ENABLED"},
      {NTCAN_ID_NOT_ENABLED, "NTCAN_ID_NOT_ENABLED"},
      {NTCAN_INVALID_FIRMWARE, "NTCAN_INVALID_FIRMWARE"},
      {NTCAN_MESSAGE_LOST, "NTCAN_MESSAGE_LOST"},
      {NTCAN_INVALID_PARAMETER, "NTCAN_INVALID_PARAMETER"},
      {NTCAN_INVALID_HANDLE, "NTCAN_INVALID_HANDLE"},
      {NTCAN_NET_NOT_FOUND, "NTCAN_NET_NOT_FOUND"},
#ifdef NTCAN_IO_INCOMPLETE
      {NTCAN_IO_INCOMPLETE, "NTCAN_IO_INCOMPLETE"},
#endif
#ifdef NTCAN_IO_PENDING
      {NTCAN_IO_PENDING, "NTCAN_IO_PENDING"},
#endif
#ifdef NTCAN_INVALID_HARDWARE
      {NTCAN_INVALID_HARDWARE, "NTCAN_INVALID_HARDWARE"},
#endif
#ifdef NTCAN_PENDING_WRITE
      {NTCAN_PENDING_WRITE, "NTCAN_PENDING_WRITE"},
#endif
#ifdef NTCAN_PENDING_READ
      {NTCAN_PENDING_READ, "NTCAN_PENDING_READ"},
#endif
#ifdef NTCAN_INVALID_DRIVER
      {NTCAN_INVALID_DRIVER, "NTCAN_INVALID_DRIVER"},
#endif
#ifdef NTCAN_OPERATION_ABORTED
      {NTCAN_OPERATION_ABORTED, "NTCAN_OPERATION_ABORTED"},
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
      {NTCAN_WRONG_DEVICE_STATE, "NTCAN_WRONG_DEVICE_STATE"},
#endif
      {NTCAN_INSUFFICIENT_RESOURCES, "NTCAN_INSUFFICIENT_RESOURCES"},
#ifdef NTCAN_HANDLE_FORCED_CLOSE
      {NTCAN_HANDLE_FORCED_CLOSE, "NTCAN_HANDLE_FORCED_CLOSE"},
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
      {NTCAN_NOT_IMPLEMENTED, "NTCAN_NOT_IMPLEMENTED"},
#endif
#ifdef NTCAN_NOT_SUPPORTED
      {NTCAN_NOT_SUPPORTED, "NTCAN_NOT_SUPPORTED"},
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
      {NTCAN_SOCK_CONN_TIMEOUT, "NTCAN_SOCK_CONN_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
      {NTCAN_SOCK_CMD_TIMEOUT, "NTCAN_SOCK_CMD_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
      {NTCAN_SOCK_HOST_NOT_FOUND, "NTCAN_SOCK_HOST_NOT_FOUND"},
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
      {NTCAN_CONTR_ERR_PASSIVE, "NTCAN_CONTR_ERR_PASSIVE"},
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
      {NTCAN_ERROR_NO_BAUDRATE, "NTCAN_ERROR_NO_BAUDRATE"},
#endif
#ifdef NTCAN_ERROR_LOM
      {NTCAN_ERROR_LOM, "NTCAN_ERROR_LOM"},
#endif
      {(NTCAN_RESULT)0xffffffff, "NTCAN_UNKNOWN"} /* stop-mark */
  };

  const struct ERR2STR *es = err2str;

  do {
    if (es-&gt;ntstatus == ntstatus) {
      break;
    }
    es++;
  } while ((uint32_t)es-&gt;ntstatus != 0xffffffff);

#ifdef NTCAN_ERROR_FORMAT_LONG
  {
    NTCAN_RESULT res;
    char sz_error_text[60];

    res = canFormatError(ntstatus, NTCAN_ERROR_FORMAT_LONG, sz_error_text,
                         sizeof(sz_error_text) - 1);
    if (NTCAN_SUCCESS == res) {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s - %s",
               es-&gt;str, sz_error_text);
    } else {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
               es-&gt;str, ntstatus);
    }
  }
#else
  snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
           es-&gt;str, ntstatus);
#endif /* of NTCAN_ERROR_FORMAT_LONG */

  return std::string((const char *)(str_buf));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\can_client\esd\esd_can_client.cc" startLine="(178, 0)" endLine="(287, 1)" clone_start="50" clone_end="73">
			<code function_name="EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus)">std::string EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus) {
  struct ERR2STR {
    NTCAN_RESULT ntstatus;
    const char *str;
  };

  int8_t str_buf[ERROR_BUF_SIZE];

  static const struct ERR2STR err2str[] = {
      {NTCAN_SUCCESS, "NTCAN_SUCCESS"},
      {NTCAN_RX_TIMEOUT, "NTCAN_RX_TIMEOUT"},
      {NTCAN_TX_TIMEOUT, "NTCAN_TX_TIMEOUT"},
      {NTCAN_TX_ERROR, "NTCAN_TX_ERROR"},
      {NTCAN_CONTR_OFF_BUS, "NTCAN_CONTR_OFF_BUS"},
      {NTCAN_CONTR_BUSY, "NTCAN_CONTR_BUSY"},
      {NTCAN_CONTR_WARN, "NTCAN_CONTR_WARN"},
      {NTCAN_NO_ID_ENABLED, "NTCAN_NO_ID_ENABLED"},
      {NTCAN_ID_ALREADY_ENABLED, "NTCAN_ID_ALREADY_ENABLED"},
      {NTCAN_ID_NOT_ENABLED, "NTCAN_ID_NOT_ENABLED"},
      {NTCAN_INVALID_FIRMWARE, "NTCAN_INVALID_FIRMWARE"},
      {NTCAN_MESSAGE_LOST, "NTCAN_MESSAGE_LOST"},
      {NTCAN_INVALID_PARAMETER, "NTCAN_INVALID_PARAMETER"},
      {NTCAN_INVALID_HANDLE, "NTCAN_INVALID_HANDLE"},
      {NTCAN_NET_NOT_FOUND, "NTCAN_NET_NOT_FOUND"},
#ifdef NTCAN_IO_INCOMPLETE
      {NTCAN_IO_INCOMPLETE, "NTCAN_IO_INCOMPLETE"},
#endif
#ifdef NTCAN_IO_PENDING
      {NTCAN_IO_PENDING, "NTCAN_IO_PENDING"},
#endif
#ifdef NTCAN_INVALID_HARDWARE
      {NTCAN_INVALID_HARDWARE, "NTCAN_INVALID_HARDWARE"},
#endif
#ifdef NTCAN_PENDING_WRITE
      {NTCAN_PENDING_WRITE, "NTCAN_PENDING_WRITE"},
#endif
#ifdef NTCAN_PENDING_READ
      {NTCAN_PENDING_READ, "NTCAN_PENDING_READ"},
#endif
#ifdef NTCAN_INVALID_DRIVER
      {NTCAN_INVALID_DRIVER, "NTCAN_INVALID_DRIVER"},
#endif
#ifdef NTCAN_OPERATION_ABORTED
      {NTCAN_OPERATION_ABORTED, "NTCAN_OPERATION_ABORTED"},
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
      {NTCAN_WRONG_DEVICE_STATE, "NTCAN_WRONG_DEVICE_STATE"},
#endif
      {NTCAN_INSUFFICIENT_RESOURCES, "NTCAN_INSUFFICIENT_RESOURCES"},
#ifdef NTCAN_HANDLE_FORCED_CLOSE
      {NTCAN_HANDLE_FORCED_CLOSE, "NTCAN_HANDLE_FORCED_CLOSE"},
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
      {NTCAN_NOT_IMPLEMENTED, "NTCAN_NOT_IMPLEMENTED"},
#endif
#ifdef NTCAN_NOT_SUPPORTED
      {NTCAN_NOT_SUPPORTED, "NTCAN_NOT_SUPPORTED"},
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
      {NTCAN_SOCK_CONN_TIMEOUT, "NTCAN_SOCK_CONN_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
      {NTCAN_SOCK_CMD_TIMEOUT, "NTCAN_SOCK_CMD_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
      {NTCAN_SOCK_HOST_NOT_FOUND, "NTCAN_SOCK_HOST_NOT_FOUND"},
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
      {NTCAN_CONTR_ERR_PASSIVE, "NTCAN_CONTR_ERR_PASSIVE"},
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
      {NTCAN_ERROR_NO_BAUDRATE, "NTCAN_ERROR_NO_BAUDRATE"},
#endif
#ifdef NTCAN_ERROR_LOM
      {NTCAN_ERROR_LOM, "NTCAN_ERROR_LOM"},
#endif
      {(NTCAN_RESULT)0xffffffff, "NTCAN_UNKNOWN"} /* stop-mark */
  };

  const struct ERR2STR *es = err2str;

  do {
    if (es-&gt;ntstatus == ntstatus) {
      break;
    }
    es++;
  } while ((uint32_t)es-&gt;ntstatus != 0xffffffff);

#ifdef NTCAN_ERROR_FORMAT_LONG
  {
    NTCAN_RESULT res;
    char sz_error_text[60];

    res = canFormatError(ntstatus, NTCAN_ERROR_FORMAT_LONG, sz_error_text,
                         sizeof(sz_error_text) - 1);
    if (NTCAN_SUCCESS == res) {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s - %s",
               es-&gt;str, sz_error_text);
    } else {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
               es-&gt;str, ntstatus);
    }
  }
#else
  snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
           es-&gt;str, ntstatus);
#endif /* of NTCAN_ERROR_FORMAT_LONG */

  return std::string((const char *)(str_buf));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\can_client\esd\esd_can_client.cc" startLine="(178, 0)" endLine="(287, 1)" clone_start="25" clone_end="48">
			<code function_name="EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus)">std::string EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus) {
  struct ERR2STR {
    NTCAN_RESULT ntstatus;
    const char *str;
  };

  int8_t str_buf[ERROR_BUF_SIZE];

  static const struct ERR2STR err2str[] = {
      {NTCAN_SUCCESS, "NTCAN_SUCCESS"},
      {NTCAN_RX_TIMEOUT, "NTCAN_RX_TIMEOUT"},
      {NTCAN_TX_TIMEOUT, "NTCAN_TX_TIMEOUT"},
      {NTCAN_TX_ERROR, "NTCAN_TX_ERROR"},
      {NTCAN_CONTR_OFF_BUS, "NTCAN_CONTR_OFF_BUS"},
      {NTCAN_CONTR_BUSY, "NTCAN_CONTR_BUSY"},
      {NTCAN_CONTR_WARN, "NTCAN_CONTR_WARN"},
      {NTCAN_NO_ID_ENABLED, "NTCAN_NO_ID_ENABLED"},
      {NTCAN_ID_ALREADY_ENABLED, "NTCAN_ID_ALREADY_ENABLED"},
      {NTCAN_ID_NOT_ENABLED, "NTCAN_ID_NOT_ENABLED"},
      {NTCAN_INVALID_FIRMWARE, "NTCAN_INVALID_FIRMWARE"},
      {NTCAN_MESSAGE_LOST, "NTCAN_MESSAGE_LOST"},
      {NTCAN_INVALID_PARAMETER, "NTCAN_INVALID_PARAMETER"},
      {NTCAN_INVALID_HANDLE, "NTCAN_INVALID_HANDLE"},
      {NTCAN_NET_NOT_FOUND, "NTCAN_NET_NOT_FOUND"},
#ifdef NTCAN_IO_INCOMPLETE
      {NTCAN_IO_INCOMPLETE, "NTCAN_IO_INCOMPLETE"},
#endif
#ifdef NTCAN_IO_PENDING
      {NTCAN_IO_PENDING, "NTCAN_IO_PENDING"},
#endif
#ifdef NTCAN_INVALID_HARDWARE
      {NTCAN_INVALID_HARDWARE, "NTCAN_INVALID_HARDWARE"},
#endif
#ifdef NTCAN_PENDING_WRITE
      {NTCAN_PENDING_WRITE, "NTCAN_PENDING_WRITE"},
#endif
#ifdef NTCAN_PENDING_READ
      {NTCAN_PENDING_READ, "NTCAN_PENDING_READ"},
#endif
#ifdef NTCAN_INVALID_DRIVER
      {NTCAN_INVALID_DRIVER, "NTCAN_INVALID_DRIVER"},
#endif
#ifdef NTCAN_OPERATION_ABORTED
      {NTCAN_OPERATION_ABORTED, "NTCAN_OPERATION_ABORTED"},
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
      {NTCAN_WRONG_DEVICE_STATE, "NTCAN_WRONG_DEVICE_STATE"},
#endif
      {NTCAN_INSUFFICIENT_RESOURCES, "NTCAN_INSUFFICIENT_RESOURCES"},
#ifdef NTCAN_HANDLE_FORCED_CLOSE
      {NTCAN_HANDLE_FORCED_CLOSE, "NTCAN_HANDLE_FORCED_CLOSE"},
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
      {NTCAN_NOT_IMPLEMENTED, "NTCAN_NOT_IMPLEMENTED"},
#endif
#ifdef NTCAN_NOT_SUPPORTED
      {NTCAN_NOT_SUPPORTED, "NTCAN_NOT_SUPPORTED"},
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
      {NTCAN_SOCK_CONN_TIMEOUT, "NTCAN_SOCK_CONN_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
      {NTCAN_SOCK_CMD_TIMEOUT, "NTCAN_SOCK_CMD_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
      {NTCAN_SOCK_HOST_NOT_FOUND, "NTCAN_SOCK_HOST_NOT_FOUND"},
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
      {NTCAN_CONTR_ERR_PASSIVE, "NTCAN_CONTR_ERR_PASSIVE"},
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
      {NTCAN_ERROR_NO_BAUDRATE, "NTCAN_ERROR_NO_BAUDRATE"},
#endif
#ifdef NTCAN_ERROR_LOM
      {NTCAN_ERROR_LOM, "NTCAN_ERROR_LOM"},
#endif
      {(NTCAN_RESULT)0xffffffff, "NTCAN_UNKNOWN"} /* stop-mark */
  };

  const struct ERR2STR *es = err2str;

  do {
    if (es-&gt;ntstatus == ntstatus) {
      break;
    }
    es++;
  } while ((uint32_t)es-&gt;ntstatus != 0xffffffff);

#ifdef NTCAN_ERROR_FORMAT_LONG
  {
    NTCAN_RESULT res;
    char sz_error_text[60];

    res = canFormatError(ntstatus, NTCAN_ERROR_FORMAT_LONG, sz_error_text,
                         sizeof(sz_error_text) - 1);
    if (NTCAN_SUCCESS == res) {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s - %s",
               es-&gt;str, sz_error_text);
    } else {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
               es-&gt;str, ntstatus);
    }
  }
#else
  snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
           es-&gt;str, ntstatus);
#endif /* of NTCAN_ERROR_FORMAT_LONG */

  return std::string((const char *)(str_buf));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(511, 0)" endLine="(551, 1)" clone_start="40" clone_end="41">
			<code function_name="LanesXmlParser::ParseLaneOverlapGroup(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;OverlapWithLane&gt;* lane_overlaps)">Status LanesXmlParser::ParseLaneOverlapGroup(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;OverlapWithLane&gt;* lane_overlaps) {
  CHECK_NOTNULL(lane_overlaps);

  auto overlap_node = xml_node.FirstChildElement("laneOverlapGroup");
  if (overlap_node) {
    auto sub_node = overlap_node-&gt;FirstChildElement("laneReference");
    while (sub_node) {
      std::string lane_id;
      double start_s = 0.0;
      double end_s = 0.0;
      int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                   &amp;lane_id);
      checker += sub_node-&gt;QueryDoubleAttribute("startOffset", &amp;start_s);
      checker += sub_node-&gt;QueryDoubleAttribute("endOffset", &amp;end_s);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse lane lane overlap";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      bool is_merge = false;
      checker = sub_node-&gt;QueryBoolAttribute("isMerge", &amp;is_merge);
      if (checker != tinyxml2::XML_SUCCESS) {
        is_merge = false;
      }

      OverlapWithLane overlap_with_lane;
      overlap_with_lane.object_id = lane_id;
      overlap_with_lane.start_s = start_s;
      overlap_with_lane.end_s = end_s;
      overlap_with_lane.is_merge = is_merge;

      lane_overlaps-&gt;push_back(overlap_with_lane);

      sub_node = sub_node-&gt;NextSiblingElement("laneReference");
    }
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(553, 0)" endLine="(573, 1)" clone_start="20" clone_end="21">
			<code function_name="LanesXmlParser::ToPbLaneType(const std::string&amp; type, PbLaneType* lane_type)">Status LanesXmlParser::ToPbLaneType(const std::string&amp; type,
                                    PbLaneType* lane_type) {
  CHECK_NOTNULL(lane_type);

  std::string upper_str = UtilXmlParser::ToUpper(type);

  if (upper_str == "NONE") {
    *lane_type = hdmap::Lane::NONE;
  } else if (upper_str == "DRIVING") {
    *lane_type = hdmap::Lane::CITY_DRIVING;
  } else if (upper_str == "BIKING") {
    *lane_type = hdmap::Lane::BIKING;
  } else if (upper_str == "PARKING") {
    *lane_type = hdmap::Lane::PARKING;
  } else {
    std::string err_msg = "Error or unsupport lane type:" + type;
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(553, 0)" endLine="(573, 1)" clone_start="1" clone_end="21">
			<code function_name="LanesXmlParser::ToPbLaneType(const std::string&amp; type, PbLaneType* lane_type)">Status LanesXmlParser::ToPbLaneType(const std::string&amp; type,
                                    PbLaneType* lane_type) {
  CHECK_NOTNULL(lane_type);

  std::string upper_str = UtilXmlParser::ToUpper(type);

  if (upper_str == "NONE") {
    *lane_type = hdmap::Lane::NONE;
  } else if (upper_str == "DRIVING") {
    *lane_type = hdmap::Lane::CITY_DRIVING;
  } else if (upper_str == "BIKING") {
    *lane_type = hdmap::Lane::BIKING;
  } else if (upper_str == "PARKING") {
    *lane_type = hdmap::Lane::PARKING;
  } else {
    std::string err_msg = "Error or unsupport lane type:" + type;
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(575, 0)" endLine="(595, 1)" clone_start="1" clone_end="21">
			<code function_name="LanesXmlParser::ToPbTurnType(const std::string&amp; type, PbTurnType* pb_turn_type)">Status LanesXmlParser::ToPbTurnType(const std::string&amp; type,
                                    PbTurnType* pb_turn_type) {
  CHECK_NOTNULL(pb_turn_type);

  std::string upper_str = UtilXmlParser::ToUpper(type);

  if (upper_str == "NOTURN") {
    *pb_turn_type = hdmap::Lane::NO_TURN;
  } else if (upper_str == "LEFTTURN") {
    *pb_turn_type = hdmap::Lane::LEFT_TURN;
  } else if (upper_str == "RIGHTTURN") {
    *pb_turn_type = hdmap::Lane::RIGHT_TURN;
  } else if (upper_str == "UTURN") {
    *pb_turn_type = hdmap::Lane::U_TURN;
  } else {
    std::string err_msg = "Error or unsupport turn type:" + type;
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(575, 0)" endLine="(595, 1)" clone_start="1" clone_end="12">
			<code function_name="LanesXmlParser::ToPbTurnType(const std::string&amp; type, PbTurnType* pb_turn_type)">Status LanesXmlParser::ToPbTurnType(const std::string&amp; type,
                                    PbTurnType* pb_turn_type) {
  CHECK_NOTNULL(pb_turn_type);

  std::string upper_str = UtilXmlParser::ToUpper(type);

  if (upper_str == "NOTURN") {
    *pb_turn_type = hdmap::Lane::NO_TURN;
  } else if (upper_str == "LEFTTURN") {
    *pb_turn_type = hdmap::Lane::LEFT_TURN;
  } else if (upper_str == "RIGHTTURN") {
    *pb_turn_type = hdmap::Lane::RIGHT_TURN;
  } else if (upper_str == "UTURN") {
    *pb_turn_type = hdmap::Lane::U_TURN;
  } else {
    std::string err_msg = "Error or unsupport turn type:" + type;
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(597, 0)" endLine="(615, 1)" clone_start="1" clone_end="12">
			<code function_name="LanesXmlParser::ToPbDirection(const std::string&amp; type, PbLaneDirection* pb_direction)">Status LanesXmlParser::ToPbDirection(const std::string&amp; type,
                                     PbLaneDirection* pb_direction) {
  CHECK_NOTNULL(pb_direction);

  std::string upper_str = UtilXmlParser::ToUpper(type);

  if (upper_str == "FORWARD") {
    *pb_direction = hdmap::Lane::FORWARD;
  } else if (upper_str == "BACKWARD") {
    *pb_direction = hdmap::Lane::BACKWARD;
  } else if (upper_str == "BIDIRECTION") {
    *pb_direction = hdmap::Lane::BIDIRECTION;
  } else {
    std::string err_msg = "Error or unsupport dirction:" + type;
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(523, 0)" endLine="(529, 1)" clone_start="1" clone_end="7">
			<code function_name="HDMapImpl::BuildLaneSegmentKDTree()">void HDMapImpl::BuildLaneSegmentKDTree() {
  AABoxKDTreeParams params;
  params.max_leaf_dimension = 5.0;  // meters.
  params.max_leaf_size = 16;
  BuildSegmentKDTree(lane_table_, params, &amp;lane_segment_boxes_,
                     &amp;lane_segment_kdtree_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(531, 0)" endLine="(537, 1)" clone_start="1" clone_end="7">
			<code function_name="HDMapImpl::BuildJunctionPolygonKDTree()">void HDMapImpl::BuildJunctionPolygonKDTree() {
  AABoxKDTreeParams params;
  params.max_leaf_dimension = 5.0;  // meters.
  params.max_leaf_size = 1;
  BuildPolygonKDTree(junction_table_, params, &amp;junction_polygon_boxes_,
                     &amp;junction_polygon_kdtree_);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(531, 0)" endLine="(537, 1)" clone_start="1" clone_end="7">
			<code function_name="HDMapImpl::BuildJunctionPolygonKDTree()">void HDMapImpl::BuildJunctionPolygonKDTree() {
  AABoxKDTreeParams params;
  params.max_leaf_dimension = 5.0;  // meters.
  params.max_leaf_size = 1;
  BuildPolygonKDTree(junction_table_, params, &amp;junction_polygon_boxes_,
                     &amp;junction_polygon_kdtree_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(539, 0)" endLine="(545, 1)" clone_start="1" clone_end="7">
			<code function_name="HDMapImpl::BuildCrosswalkPolygonKDTree()">void HDMapImpl::BuildCrosswalkPolygonKDTree() {
  AABoxKDTreeParams params;
  params.max_leaf_dimension = 5.0;  // meters.
  params.max_leaf_size = 1;
  BuildPolygonKDTree(crosswalk_table_, params, &amp;crosswalk_polygon_boxes_,
                     &amp;crosswalk_polygon_kdtree_);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(539, 0)" endLine="(545, 1)" clone_start="1" clone_end="7">
			<code function_name="HDMapImpl::BuildCrosswalkPolygonKDTree()">void HDMapImpl::BuildCrosswalkPolygonKDTree() {
  AABoxKDTreeParams params;
  params.max_leaf_dimension = 5.0;  // meters.
  params.max_leaf_size = 1;
  BuildPolygonKDTree(crosswalk_table_, params, &amp;crosswalk_polygon_boxes_,
                     &amp;crosswalk_polygon_kdtree_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(547, 0)" endLine="(553, 1)" clone_start="1" clone_end="7">
			<code function_name="HDMapImpl::BuildSignalSegmentKDTree()">void HDMapImpl::BuildSignalSegmentKDTree() {
  AABoxKDTreeParams params;
  params.max_leaf_dimension = 5.0;  // meters.
  params.max_leaf_size = 4;
  BuildSegmentKDTree(signal_table_, params, &amp;signal_segment_boxes_,
                     &amp;signal_segment_kdtree_);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(547, 0)" endLine="(553, 1)" clone_start="1" clone_end="7">
			<code function_name="HDMapImpl::BuildSignalSegmentKDTree()">void HDMapImpl::BuildSignalSegmentKDTree() {
  AABoxKDTreeParams params;
  params.max_leaf_dimension = 5.0;  // meters.
  params.max_leaf_size = 4;
  BuildSegmentKDTree(signal_table_, params, &amp;signal_segment_boxes_,
                     &amp;signal_segment_kdtree_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(555, 0)" endLine="(561, 1)" clone_start="1" clone_end="7">
			<code function_name="HDMapImpl::BuildStopSignSegmentKDTree()">void HDMapImpl::BuildStopSignSegmentKDTree() {
  AABoxKDTreeParams params;
  params.max_leaf_dimension = 5.0;  // meters.
  params.max_leaf_size = 4;
  BuildSegmentKDTree(stop_sign_table_, params, &amp;stop_sign_segment_boxes_,
                     &amp;stop_sign_segment_kdtree_);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(555, 0)" endLine="(561, 1)" clone_start="1" clone_end="5">
			<code function_name="HDMapImpl::BuildStopSignSegmentKDTree()">void HDMapImpl::BuildStopSignSegmentKDTree() {
  AABoxKDTreeParams params;
  params.max_leaf_dimension = 5.0;  // meters.
  params.max_leaf_size = 4;
  BuildSegmentKDTree(stop_sign_table_, params, &amp;stop_sign_segment_boxes_,
                     &amp;stop_sign_segment_kdtree_);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(563, 0)" endLine="(569, 1)" clone_start="1" clone_end="5">
			<code function_name="HDMapImpl::BuildYieldSignSegmentKDTree()">void HDMapImpl::BuildYieldSignSegmentKDTree() {
  AABoxKDTreeParams params;
  params.max_leaf_dimension = 5.0;  // meters.
  params.max_leaf_size = 4;
  BuildSegmentKDTree(yield_sign_table_, params, &amp;yield_sign_segment_boxes_,
                     &amp;yield_sign_segment_kdtree_);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\can_client\esd\esd_can_client.cc" startLine="(178, 0)" endLine="(287, 1)" clone_start="24" clone_end="48">
			<code function_name="EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus)">std::string EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus) {
  struct ERR2STR {
    NTCAN_RESULT ntstatus;
    const char *str;
  };

  int8_t str_buf[ERROR_BUF_SIZE];

  static const struct ERR2STR err2str[] = {
      {NTCAN_SUCCESS, "NTCAN_SUCCESS"},
      {NTCAN_RX_TIMEOUT, "NTCAN_RX_TIMEOUT"},
      {NTCAN_TX_TIMEOUT, "NTCAN_TX_TIMEOUT"},
      {NTCAN_TX_ERROR, "NTCAN_TX_ERROR"},
      {NTCAN_CONTR_OFF_BUS, "NTCAN_CONTR_OFF_BUS"},
      {NTCAN_CONTR_BUSY, "NTCAN_CONTR_BUSY"},
      {NTCAN_CONTR_WARN, "NTCAN_CONTR_WARN"},
      {NTCAN_NO_ID_ENABLED, "NTCAN_NO_ID_ENABLED"},
      {NTCAN_ID_ALREADY_ENABLED, "NTCAN_ID_ALREADY_ENABLED"},
      {NTCAN_ID_NOT_ENABLED, "NTCAN_ID_NOT_ENABLED"},
      {NTCAN_INVALID_FIRMWARE, "NTCAN_INVALID_FIRMWARE"},
      {NTCAN_MESSAGE_LOST, "NTCAN_MESSAGE_LOST"},
      {NTCAN_INVALID_PARAMETER, "NTCAN_INVALID_PARAMETER"},
      {NTCAN_INVALID_HANDLE, "NTCAN_INVALID_HANDLE"},
      {NTCAN_NET_NOT_FOUND, "NTCAN_NET_NOT_FOUND"},
#ifdef NTCAN_IO_INCOMPLETE
      {NTCAN_IO_INCOMPLETE, "NTCAN_IO_INCOMPLETE"},
#endif
#ifdef NTCAN_IO_PENDING
      {NTCAN_IO_PENDING, "NTCAN_IO_PENDING"},
#endif
#ifdef NTCAN_INVALID_HARDWARE
      {NTCAN_INVALID_HARDWARE, "NTCAN_INVALID_HARDWARE"},
#endif
#ifdef NTCAN_PENDING_WRITE
      {NTCAN_PENDING_WRITE, "NTCAN_PENDING_WRITE"},
#endif
#ifdef NTCAN_PENDING_READ
      {NTCAN_PENDING_READ, "NTCAN_PENDING_READ"},
#endif
#ifdef NTCAN_INVALID_DRIVER
      {NTCAN_INVALID_DRIVER, "NTCAN_INVALID_DRIVER"},
#endif
#ifdef NTCAN_OPERATION_ABORTED
      {NTCAN_OPERATION_ABORTED, "NTCAN_OPERATION_ABORTED"},
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
      {NTCAN_WRONG_DEVICE_STATE, "NTCAN_WRONG_DEVICE_STATE"},
#endif
      {NTCAN_INSUFFICIENT_RESOURCES, "NTCAN_INSUFFICIENT_RESOURCES"},
#ifdef NTCAN_HANDLE_FORCED_CLOSE
      {NTCAN_HANDLE_FORCED_CLOSE, "NTCAN_HANDLE_FORCED_CLOSE"},
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
      {NTCAN_NOT_IMPLEMENTED, "NTCAN_NOT_IMPLEMENTED"},
#endif
#ifdef NTCAN_NOT_SUPPORTED
      {NTCAN_NOT_SUPPORTED, "NTCAN_NOT_SUPPORTED"},
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
      {NTCAN_SOCK_CONN_TIMEOUT, "NTCAN_SOCK_CONN_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
      {NTCAN_SOCK_CMD_TIMEOUT, "NTCAN_SOCK_CMD_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
      {NTCAN_SOCK_HOST_NOT_FOUND, "NTCAN_SOCK_HOST_NOT_FOUND"},
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
      {NTCAN_CONTR_ERR_PASSIVE, "NTCAN_CONTR_ERR_PASSIVE"},
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
      {NTCAN_ERROR_NO_BAUDRATE, "NTCAN_ERROR_NO_BAUDRATE"},
#endif
#ifdef NTCAN_ERROR_LOM
      {NTCAN_ERROR_LOM, "NTCAN_ERROR_LOM"},
#endif
      {(NTCAN_RESULT)0xffffffff, "NTCAN_UNKNOWN"} /* stop-mark */
  };

  const struct ERR2STR *es = err2str;

  do {
    if (es-&gt;ntstatus == ntstatus) {
      break;
    }
    es++;
  } while ((uint32_t)es-&gt;ntstatus != 0xffffffff);

#ifdef NTCAN_ERROR_FORMAT_LONG
  {
    NTCAN_RESULT res;
    char sz_error_text[60];

    res = canFormatError(ntstatus, NTCAN_ERROR_FORMAT_LONG, sz_error_text,
                         sizeof(sz_error_text) - 1);
    if (NTCAN_SUCCESS == res) {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s - %s",
               es-&gt;str, sz_error_text);
    } else {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
               es-&gt;str, ntstatus);
    }
  }
#else
  snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
           es-&gt;str, ntstatus);
#endif /* of NTCAN_ERROR_FORMAT_LONG */

  return std::string((const char *)(str_buf));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\can_client\esd\esd_can_client.cc" startLine="(178, 0)" endLine="(287, 1)" clone_start="49" clone_end="73">
			<code function_name="EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus)">std::string EsdCanClient::GetErrorString(const NTCAN_RESULT ntstatus) {
  struct ERR2STR {
    NTCAN_RESULT ntstatus;
    const char *str;
  };

  int8_t str_buf[ERROR_BUF_SIZE];

  static const struct ERR2STR err2str[] = {
      {NTCAN_SUCCESS, "NTCAN_SUCCESS"},
      {NTCAN_RX_TIMEOUT, "NTCAN_RX_TIMEOUT"},
      {NTCAN_TX_TIMEOUT, "NTCAN_TX_TIMEOUT"},
      {NTCAN_TX_ERROR, "NTCAN_TX_ERROR"},
      {NTCAN_CONTR_OFF_BUS, "NTCAN_CONTR_OFF_BUS"},
      {NTCAN_CONTR_BUSY, "NTCAN_CONTR_BUSY"},
      {NTCAN_CONTR_WARN, "NTCAN_CONTR_WARN"},
      {NTCAN_NO_ID_ENABLED, "NTCAN_NO_ID_ENABLED"},
      {NTCAN_ID_ALREADY_ENABLED, "NTCAN_ID_ALREADY_ENABLED"},
      {NTCAN_ID_NOT_ENABLED, "NTCAN_ID_NOT_ENABLED"},
      {NTCAN_INVALID_FIRMWARE, "NTCAN_INVALID_FIRMWARE"},
      {NTCAN_MESSAGE_LOST, "NTCAN_MESSAGE_LOST"},
      {NTCAN_INVALID_PARAMETER, "NTCAN_INVALID_PARAMETER"},
      {NTCAN_INVALID_HANDLE, "NTCAN_INVALID_HANDLE"},
      {NTCAN_NET_NOT_FOUND, "NTCAN_NET_NOT_FOUND"},
#ifdef NTCAN_IO_INCOMPLETE
      {NTCAN_IO_INCOMPLETE, "NTCAN_IO_INCOMPLETE"},
#endif
#ifdef NTCAN_IO_PENDING
      {NTCAN_IO_PENDING, "NTCAN_IO_PENDING"},
#endif
#ifdef NTCAN_INVALID_HARDWARE
      {NTCAN_INVALID_HARDWARE, "NTCAN_INVALID_HARDWARE"},
#endif
#ifdef NTCAN_PENDING_WRITE
      {NTCAN_PENDING_WRITE, "NTCAN_PENDING_WRITE"},
#endif
#ifdef NTCAN_PENDING_READ
      {NTCAN_PENDING_READ, "NTCAN_PENDING_READ"},
#endif
#ifdef NTCAN_INVALID_DRIVER
      {NTCAN_INVALID_DRIVER, "NTCAN_INVALID_DRIVER"},
#endif
#ifdef NTCAN_OPERATION_ABORTED
      {NTCAN_OPERATION_ABORTED, "NTCAN_OPERATION_ABORTED"},
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
      {NTCAN_WRONG_DEVICE_STATE, "NTCAN_WRONG_DEVICE_STATE"},
#endif
      {NTCAN_INSUFFICIENT_RESOURCES, "NTCAN_INSUFFICIENT_RESOURCES"},
#ifdef NTCAN_HANDLE_FORCED_CLOSE
      {NTCAN_HANDLE_FORCED_CLOSE, "NTCAN_HANDLE_FORCED_CLOSE"},
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
      {NTCAN_NOT_IMPLEMENTED, "NTCAN_NOT_IMPLEMENTED"},
#endif
#ifdef NTCAN_NOT_SUPPORTED
      {NTCAN_NOT_SUPPORTED, "NTCAN_NOT_SUPPORTED"},
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
      {NTCAN_SOCK_CONN_TIMEOUT, "NTCAN_SOCK_CONN_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
      {NTCAN_SOCK_CMD_TIMEOUT, "NTCAN_SOCK_CMD_TIMEOUT"},
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
      {NTCAN_SOCK_HOST_NOT_FOUND, "NTCAN_SOCK_HOST_NOT_FOUND"},
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
      {NTCAN_CONTR_ERR_PASSIVE, "NTCAN_CONTR_ERR_PASSIVE"},
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
      {NTCAN_ERROR_NO_BAUDRATE, "NTCAN_ERROR_NO_BAUDRATE"},
#endif
#ifdef NTCAN_ERROR_LOM
      {NTCAN_ERROR_LOM, "NTCAN_ERROR_LOM"},
#endif
      {(NTCAN_RESULT)0xffffffff, "NTCAN_UNKNOWN"} /* stop-mark */
  };

  const struct ERR2STR *es = err2str;

  do {
    if (es-&gt;ntstatus == ntstatus) {
      break;
    }
    es++;
  } while ((uint32_t)es-&gt;ntstatus != 0xffffffff);

#ifdef NTCAN_ERROR_FORMAT_LONG
  {
    NTCAN_RESULT res;
    char sz_error_text[60];

    res = canFormatError(ntstatus, NTCAN_ERROR_FORMAT_LONG, sz_error_text,
                         sizeof(sz_error_text) - 1);
    if (NTCAN_SUCCESS == res) {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s - %s",
               es-&gt;str, sz_error_text);
    } else {
      snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
               es-&gt;str, ntstatus);
    }
  }
#else
  snprintf(reinterpret_cast&lt;char *&gt;(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
           es-&gt;str, ntstatus);
#endif /* of NTCAN_ERROR_FORMAT_LONG */

  return std::string((const char *)(str_buf));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(141, 0)" endLine="(182, 1)" clone_start="23" clone_end="42">
			<code function_name="Spline2dConstraint::Add2dSecondDerivativeBoundary(    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle,     const std::vector&lt;Vec2d&gt;&amp; ref_point,     const std::vector&lt;double&gt;&amp; longitidinal_bound, const std::vector&lt;double&gt;&amp; lateral_bound)">bool Spline2dConstraint::Add2dSecondDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle,
    const std::vector&lt;Vec2d&gt;&amp; ref_point,
    const std::vector&lt;double&gt;&amp; longitidinal_bound,
    const std::vector&lt;double&gt;&amp; lateral_bound) {
  if (t_coord.size() != angle.size() || angle.size() != ref_point.size() ||
      ref_point.size() != longitidinal_bound.size() ||
      longitidinal_bound.size() != lateral_bound.size()) {
    return false;
  }
  Eigen::MatrixXd affine_inequality =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), 1);
  for (std::uint32_t i = 0; i &lt; t_coord.size(); ++i) {
    const double d_longitudinal = SignDistance(ref_point[i], angle[i]);
    const double d_lateral = SignDistance(ref_point[i], angle[i] - M_PI / 2.0);
    const std::uint32_t index = FindIndex(t_coord[i]);
    const double rel_t = t_coord[i] - t_knots_[index];
    const std::uint32_t index_offset = 2 * index * spline_order_;
    std::vector&lt;double&gt; longi_coef =
        AffineSecondDerivativeCoef(angle[i], rel_t);
    std::vector&lt;double&gt; lateral_coef =
        AffineSecondDerivativeCoef(angle[i] - M_PI / 2, rel_t);
    for (std::uint32_t j = 0; j &lt; 2 * spline_order_; ++j) {
      // upper longi
      affine_inequality(4 * i, index_offset + j) = longi_coef[j];
      // lower longi
      affine_inequality(4 * i + 1, index_offset + j) = -longi_coef[j];
      // upper lateral
      affine_inequality(4 * i + 2, index_offset + j) = lateral_coef[j];
      // lower lateral
      affine_inequality(4 * i + 3, index_offset + j) = -lateral_coef[j];
    }

    affine_boundary(4 * i, 0) = d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 1, 0) = -d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 2, 0) = d_lateral - lateral_bound[i];
    affine_boundary(4 * i + 3, 0) = -d_lateral - lateral_bound[i];
  }
  return AddInequalityConstraint(affine_inequality, affine_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(99, 0)" endLine="(139, 1)" clone_start="22" clone_end="41">
			<code function_name="Spline2dConstraint::Add2dDerivativeBoundary(    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle,     const std::vector&lt;Vec2d&gt;&amp; ref_point,     const std::vector&lt;double&gt;&amp; longitidinal_bound, const std::vector&lt;double&gt;&amp; lateral_bound)">bool Spline2dConstraint::Add2dDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle,
    const std::vector&lt;Vec2d&gt;&amp; ref_point,
    const std::vector&lt;double&gt;&amp; longitidinal_bound,
    const std::vector&lt;double&gt;&amp; lateral_bound) {
  if (t_coord.size() != angle.size() || angle.size() != ref_point.size() ||
      ref_point.size() != longitidinal_bound.size() ||
      longitidinal_bound.size() != lateral_bound.size()) {
    return false;
  }
  Eigen::MatrixXd affine_inequality =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), 1);
  for (std::uint32_t i = 0; i &lt; t_coord.size(); ++i) {
    const double d_longitudinal = SignDistance(ref_point[i], angle[i]);
    const double d_lateral = SignDistance(ref_point[i], angle[i] - M_PI / 2.0);
    const std::uint32_t index = FindIndex(t_coord[i]);
    const double rel_t = t_coord[i] - t_knots_[index];
    const std::uint32_t index_offset = 2 * index * spline_order_;
    std::vector&lt;double&gt; longi_coef = AffineDerivativeCoef(angle[i], rel_t);
    std::vector&lt;double&gt; lateral_coef =
        AffineDerivativeCoef(angle[i] - M_PI / 2, rel_t);
    for (std::uint32_t j = 0; j &lt; 2 * spline_order_; ++j) {
      // upper longi
      affine_inequality(4 * i, index_offset + j) = longi_coef[j];
      // lower longi
      affine_inequality(4 * i + 1, index_offset + j) = -longi_coef[j];
      // upper lateral
      affine_inequality(4 * i + 2, index_offset + j) = lateral_coef[j];
      // lower lateral
      affine_inequality(4 * i + 3, index_offset + j) = -lateral_coef[j];
    }

    affine_boundary(4 * i, 0) = d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 1, 0) = -d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 2, 0) = d_lateral - lateral_bound[i];
    affine_boundary(4 * i + 3, 0) = -d_lateral - lateral_bound[i];
  }
  return AddInequalityConstraint(affine_inequality, affine_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(184, 0)" endLine="(224, 1)" clone_start="1" clone_end="20">
			<code function_name="Spline2dConstraint::Add2dThirdDerivativeBoundary(    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle,     const std::vector&lt;Vec2d&gt;&amp; ref_point,     const std::vector&lt;double&gt;&amp; longitidinal_bound, const std::vector&lt;double&gt;&amp; lateral_bound)">bool Spline2dConstraint::Add2dThirdDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle,
    const std::vector&lt;Vec2d&gt;&amp; ref_point,
    const std::vector&lt;double&gt;&amp; longitidinal_bound,
    const std::vector&lt;double&gt;&amp; lateral_bound) {
  if (t_coord.size() != angle.size() || angle.size() != ref_point.size() ||
      ref_point.size() != longitidinal_bound.size() ||
      longitidinal_bound.size() != lateral_bound.size()) {
    return false;
  }
  Eigen::MatrixXd affine_inequality =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), 1);
  for (std::uint32_t i = 0; i &lt; t_coord.size(); ++i) {
    const double d_longitudinal = SignDistance(ref_point[i], angle[i]);
    const double d_lateral = SignDistance(ref_point[i], angle[i] - M_PI / 2.0);
    const std::uint32_t index = FindIndex(t_coord[i]);
    const double rel_t = t_coord[i] - t_knots_[index];
    const std::uint32_t index_offset = 2 * index * spline_order_;
    std::vector&lt;double&gt; longi_coef = AffineThirdDerivativeCoef(angle[i], rel_t);
    std::vector&lt;double&gt; lateral_coef =
        AffineThirdDerivativeCoef(angle[i] - M_PI / 2, rel_t);
    for (std::uint32_t j = 0; j &lt; 2 * spline_order_; ++j) {
      // upper longi
      affine_inequality(4 * i, index_offset + j) = longi_coef[j];
      // lower longi
      affine_inequality(4 * i + 1, index_offset + j) = -longi_coef[j];
      // upper lateral
      affine_inequality(4 * i + 2, index_offset + j) = lateral_coef[j];
      // lower lateral
      affine_inequality(4 * i + 3, index_offset + j) = -lateral_coef[j];
    }

    affine_boundary(4 * i, 0) = d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 1, 0) = -d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 2, 0) = d_lateral - lateral_bound[i];
    affine_boundary(4 * i + 3, 0) = -d_lateral - lateral_bound[i];
  }
  return AddInequalityConstraint(affine_inequality, affine_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(141, 0)" endLine="(182, 1)" clone_start="1" clone_end="20">
			<code function_name="Spline2dConstraint::Add2dSecondDerivativeBoundary(    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle,     const std::vector&lt;Vec2d&gt;&amp; ref_point,     const std::vector&lt;double&gt;&amp; longitidinal_bound, const std::vector&lt;double&gt;&amp; lateral_bound)">bool Spline2dConstraint::Add2dSecondDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle,
    const std::vector&lt;Vec2d&gt;&amp; ref_point,
    const std::vector&lt;double&gt;&amp; longitidinal_bound,
    const std::vector&lt;double&gt;&amp; lateral_bound) {
  if (t_coord.size() != angle.size() || angle.size() != ref_point.size() ||
      ref_point.size() != longitidinal_bound.size() ||
      longitidinal_bound.size() != lateral_bound.size()) {
    return false;
  }
  Eigen::MatrixXd affine_inequality =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), 1);
  for (std::uint32_t i = 0; i &lt; t_coord.size(); ++i) {
    const double d_longitudinal = SignDistance(ref_point[i], angle[i]);
    const double d_lateral = SignDistance(ref_point[i], angle[i] - M_PI / 2.0);
    const std::uint32_t index = FindIndex(t_coord[i]);
    const double rel_t = t_coord[i] - t_knots_[index];
    const std::uint32_t index_offset = 2 * index * spline_order_;
    std::vector&lt;double&gt; longi_coef =
        AffineSecondDerivativeCoef(angle[i], rel_t);
    std::vector&lt;double&gt; lateral_coef =
        AffineSecondDerivativeCoef(angle[i] - M_PI / 2, rel_t);
    for (std::uint32_t j = 0; j &lt; 2 * spline_order_; ++j) {
      // upper longi
      affine_inequality(4 * i, index_offset + j) = longi_coef[j];
      // lower longi
      affine_inequality(4 * i + 1, index_offset + j) = -longi_coef[j];
      // upper lateral
      affine_inequality(4 * i + 2, index_offset + j) = lateral_coef[j];
      // lower lateral
      affine_inequality(4 * i + 3, index_offset + j) = -lateral_coef[j];
    }

    affine_boundary(4 * i, 0) = d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 1, 0) = -d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 2, 0) = d_lateral - lateral_bound[i];
    affine_boundary(4 * i + 3, 0) = -d_lateral - lateral_bound[i];
  }
  return AddInequalityConstraint(affine_inequality, affine_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\onboard\lidar_process.cc" startLine="(232, 0)" endLine="(289, 1)" clone_start="3" clone_end="39">
			<code function_name="LidarProcess::InitAlgorithmPlugin()">bool LidarProcess::InitAlgorithmPlugin() {
  /// init roi filter
  roi_filter_.reset(
      BaseROIFilterRegisterer::GetInstanceByName(FLAGS_onboard_roi_filter));
  if (!roi_filter_) {
    AERROR &lt;&lt; "Failed to get instance: " &lt;&lt; FLAGS_onboard_roi_filter;
    return false;
  }
  if (!roi_filter_-&gt;Init()) {
    AERROR &lt;&lt; "Failed to init roi filter: " &lt;&lt; roi_filter_-&gt;name();
    return false;
  }
  AINFO &lt;&lt; "Init algorithm plugin successfully, roi_filter_: "
        &lt;&lt; roi_filter_-&gt;name();

  /// init segmentation
  segmentor_.reset(
      BaseSegmentationRegisterer::GetInstanceByName(FLAGS_onboard_segmentor));
  if (!segmentor_) {
    AERROR &lt;&lt; "Failed to get instance: " &lt;&lt; FLAGS_onboard_segmentor;
    return false;
  }
  if (!segmentor_-&gt;Init()) {
    AERROR &lt;&lt; "Failed to init segmentor: " &lt;&lt; segmentor_-&gt;name();
    return false;
  }
  AINFO &lt;&lt; "Init algorithm plugin successfully, segmentor: "
        &lt;&lt; segmentor_-&gt;name();

  /// init object build
  object_builder_.reset(BaseObjectBuilderRegisterer::GetInstanceByName(
      FLAGS_onboard_object_builder));
  if (!object_builder_) {
    AERROR &lt;&lt; "Failed to get instance: " &lt;&lt; FLAGS_onboard_object_builder;
    return false;
  }
  if (!object_builder_-&gt;Init()) {
    AERROR &lt;&lt; "Failed to init object builder: " &lt;&lt; object_builder_-&gt;name();
    return false;
  }
  AINFO &lt;&lt; "Init algorithm plugin successfully, object builder: "
        &lt;&lt; object_builder_-&gt;name();

  /// init tracker
  tracker_.reset(
      BaseTrackerRegisterer::GetInstanceByName(FLAGS_onboard_tracker));
  if (!tracker_) {
    AERROR &lt;&lt; "Failed to get instance: " &lt;&lt; FLAGS_onboard_tracker;
    return false;
  }
  if (!tracker_-&gt;Init()) {
    AERROR &lt;&lt; "Failed to init tracker: " &lt;&lt; tracker_-&gt;name();
    return false;
  }
  AINFO &lt;&lt; "Init algorithm plugin successfully, tracker: " &lt;&lt; tracker_-&gt;name();

  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\onboard\lidar_process.cc" startLine="(232, 0)" endLine="(289, 1)" clone_start="17" clone_end="53">
			<code function_name="LidarProcess::InitAlgorithmPlugin()">bool LidarProcess::InitAlgorithmPlugin() {
  /// init roi filter
  roi_filter_.reset(
      BaseROIFilterRegisterer::GetInstanceByName(FLAGS_onboard_roi_filter));
  if (!roi_filter_) {
    AERROR &lt;&lt; "Failed to get instance: " &lt;&lt; FLAGS_onboard_roi_filter;
    return false;
  }
  if (!roi_filter_-&gt;Init()) {
    AERROR &lt;&lt; "Failed to init roi filter: " &lt;&lt; roi_filter_-&gt;name();
    return false;
  }
  AINFO &lt;&lt; "Init algorithm plugin successfully, roi_filter_: "
        &lt;&lt; roi_filter_-&gt;name();

  /// init segmentation
  segmentor_.reset(
      BaseSegmentationRegisterer::GetInstanceByName(FLAGS_onboard_segmentor));
  if (!segmentor_) {
    AERROR &lt;&lt; "Failed to get instance: " &lt;&lt; FLAGS_onboard_segmentor;
    return false;
  }
  if (!segmentor_-&gt;Init()) {
    AERROR &lt;&lt; "Failed to init segmentor: " &lt;&lt; segmentor_-&gt;name();
    return false;
  }
  AINFO &lt;&lt; "Init algorithm plugin successfully, segmentor: "
        &lt;&lt; segmentor_-&gt;name();

  /// init object build
  object_builder_.reset(BaseObjectBuilderRegisterer::GetInstanceByName(
      FLAGS_onboard_object_builder));
  if (!object_builder_) {
    AERROR &lt;&lt; "Failed to get instance: " &lt;&lt; FLAGS_onboard_object_builder;
    return false;
  }
  if (!object_builder_-&gt;Init()) {
    AERROR &lt;&lt; "Failed to init object builder: " &lt;&lt; object_builder_-&gt;name();
    return false;
  }
  AINFO &lt;&lt; "Init algorithm plugin successfully, object builder: "
        &lt;&lt; object_builder_-&gt;name();

  /// init tracker
  tracker_.reset(
      BaseTrackerRegisterer::GetInstanceByName(FLAGS_onboard_tracker));
  if (!tracker_) {
    AERROR &lt;&lt; "Failed to get instance: " &lt;&lt; FLAGS_onboard_tracker;
    return false;
  }
  if (!tracker_-&gt;Init()) {
    AERROR &lt;&lt; "Failed to init tracker: " &lt;&lt; tracker_-&gt;name();
    return false;
  }
  AINFO &lt;&lt; "Init algorithm plugin successfully, tracker: " &lt;&lt; tracker_-&gt;name();

  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\rtk\rtk_localization.cc" startLine="(374, 0)" endLine="(422, 1)" clone_start="9" clone_end="47">
			<code function_name="RTKLocalization::RunWatchDog()">void RTKLocalization::RunWatchDog() {
  if (!FLAGS_enable_watchdog) {
    return;
  }

  common::monitor::MonitorBuffer buffer(&amp;monitor_);

  // check GPS time stamp against ROS timer
  double gps_delay_sec =
      common::time::ToSecond(Clock::Now()) -
      AdapterManager::GetGps()-&gt;GetLatestObserved().header().timestamp_sec();
  int64_t gps_delay_cycle_cnt =
      static_cast&lt;int64_t&gt;(gps_delay_sec * FLAGS_localization_publish_freq);

  bool msg_lost = false;
  if (FLAGS_enable_gps_timestamp &amp;&amp;
      (gps_delay_cycle_cnt &gt; FLAGS_report_threshold_err_num)) {
    msg_lost = true;

    buffer.ERROR() &lt;&lt; "Raw GPS Message Lost. GPS message is "
                   &lt;&lt; gps_delay_cycle_cnt &lt;&lt; " cycle " &lt;&lt; gps_delay_sec
                   &lt;&lt; " sec behind current time.";
    buffer.PrintLog();
  }

  // check IMU time stamp against ROS timer
  double imu_delay_sec =
      common::time::ToSecond(Clock::Now()) -
      AdapterManager::GetImu()-&gt;GetLatestObserved().header().timestamp_sec();
  int64_t imu_delay_cycle_cnt =
      static_cast&lt;int64_t&gt;(imu_delay_sec * FLAGS_localization_publish_freq);
  if (FLAGS_enable_gps_timestamp &amp;&amp;
      imu_delay_cycle_cnt &gt; FLAGS_report_threshold_err_num) {
    msg_lost = true;

    buffer.ERROR() &lt;&lt; "Raw GPS Message Lost. IMU message is "
                   &lt;&lt; imu_delay_cycle_cnt &lt;&lt; " cycle " &lt;&lt; imu_delay_sec
                   &lt;&lt; " sec behind current time.";
    buffer.PrintLog();
  }

  // to prevent it from beeping continuously
  if (msg_lost &amp;&amp; (last_reported_timestamp_sec_ &lt; 1. ||
                   common::time::ToSecond(Clock::Now()) &gt;
                       last_reported_timestamp_sec_ + 1.)) {
    AERROR &lt;&lt; "gps/imu frame lost!";
    last_reported_timestamp_sec_ = common::time::ToSecond(Clock::Now());
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\localization\camera\camera_localization.cc" startLine="(192, 0)" endLine="(240, 1)" clone_start="9" clone_end="47">
			<code function_name="CameraLocalization::RunWatchDog()">void CameraLocalization::RunWatchDog() {
  if (!FLAGS_enable_watchdog) {
    return;
  }

  MonitorBuffer buffer(&amp;monitor_);

  // check GPS time stamp against ROS timer
  double gps_delay_sec =
      common::time::ToSecond(Clock::Now()) -
      AdapterManager::GetGps()-&gt;GetLatestObserved().header().timestamp_sec();
  int64_t gps_delay_cycle_cnt =
      static_cast&lt;int64_t&gt;(gps_delay_sec * FLAGS_localization_publish_freq);

  bool msg_lost = false;
  if (FLAGS_enable_gps_timestamp &amp;&amp;
      (gps_delay_cycle_cnt &gt; FLAGS_report_threshold_err_num)) {
    msg_lost = true;

    buffer.ERROR() &lt;&lt; "Raw GPS Message Lost. GPS message is "
                   &lt;&lt; gps_delay_cycle_cnt &lt;&lt; " cycle " &lt;&lt; gps_delay_sec
                   &lt;&lt; " sec behind current time.";
    buffer.PrintLog();
  }

  // check Camera time stamp against ROS timer
  double camera_delay_sec =
      common::time::ToSecond(Clock::Now()) -
      AdapterManager::GetCamera()-&gt;GetLatestObserved().header().timestamp_sec();
  int64_t camera_delay_cycle_cnt =
      static_cast&lt;int64_t&gt;(camera_delay_sec * FLAGS_localization_publish_freq);
  if (FLAGS_enable_gps_timestamp &amp;&amp;
      camera_delay_cycle_cnt &gt; FLAGS_report_threshold_err_num) {
    msg_lost = true;

    buffer.ERROR() &lt;&lt; "Raw Camera Message Lost. IMU message is "
                   &lt;&lt; camera_delay_cycle_cnt &lt;&lt; " cycle " &lt;&lt; camera_delay_sec
                   &lt;&lt; " sec behind current time.";
    buffer.PrintLog();
  }

  // to prevent it from beeping continuously
  if (msg_lost &amp;&amp; (last_reported_timestamp_sec_ &lt; 1. ||
                   common::time::ToSecond(Clock::Now()) &gt;
                       last_reported_timestamp_sec_ + 1.)) {
    AERROR &lt;&lt; "gps/camera frame lost!";
    last_reported_timestamp_sec_ = common::time::ToSecond(Clock::Now());
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_kernel.cc" startLine="(31, 0)" endLine="(38, 1)" clone_start="6" clone_end="8">
			<code function_name="Spline2dKernel::Spline2dKernel(const std::vector&lt;double&gt;&amp; t_knots, const std::uint32_t spline_order)">Spline2dKernel::Spline2dKernel(const std::vector&lt;double&gt;&amp; t_knots,
                               const std::uint32_t spline_order)
    : t_knots_(t_knots), spline_order_(spline_order) {
  total_params_ =
      (t_knots_.size() &gt; 1 ? 2 * (t_knots_.size() - 1) * spline_order_ : 0);
  kernel_matrix_ = Eigen::MatrixXd::Zero(total_params_, total_params_);
  offset_ = Eigen::MatrixXd::Zero(total_params_, 1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_kernel.cc" startLine="(39, 0)" endLine="(46, 1)" clone_start="6" clone_end="8">
			<code function_name="Spline1dKernel::Spline1dKernel(const std::vector&lt;double&gt;&amp; x_knots, const std::uint32_t spline_order)">Spline1dKernel::Spline1dKernel(const std::vector&lt;double&gt;&amp; x_knots,
                               const std::uint32_t spline_order)
    : x_knots_(x_knots), spline_order_(spline_order) {
  total_params_ =
      (x_knots.size() &gt; 1 ? (x_knots.size() - 1) * spline_order_ : 0);
  kernel_matrix_ = Eigen::MatrixXd::Zero(total_params_, total_params_);
  offset_ = Eigen::MatrixXd::Zero(total_params_, 1);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_kernel.cc" startLine="(41, 0)" endLine="(45, 1)" clone_start="1" clone_end="5">
			<code function_name="Spline2dKernel::AddRegularization(const double regularization_param)">void Spline2dKernel::AddRegularization(const double regularization_param) {
  Eigen::MatrixXd id_matrix =
      Eigen::MatrixXd::Identity(kernel_matrix_.rows(), kernel_matrix_.cols());
  kernel_matrix_ += id_matrix * regularization_param;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_kernel.cc" startLine="(48, 0)" endLine="(52, 1)" clone_start="1" clone_end="5">
			<code function_name="Spline1dKernel::AddRegularization(const double regularized_param)">void Spline1dKernel::AddRegularization(const double regularized_param) {
  Eigen::MatrixXd id_matrix =
      Eigen::MatrixXd::Identity(kernel_matrix_.rows(), kernel_matrix_.cols());
  kernel_matrix_ += id_matrix * regularized_param;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_kernel.cc" startLine="(47, 0)" endLine="(58, 1)" clone_start="1" clone_end="12">
			<code function_name="Spline2dKernel::AddKernel(const Eigen::MatrixXd&amp; kernel,const Eigen::MatrixXd&amp; offset, const double weight)">bool Spline2dKernel::AddKernel(const Eigen::MatrixXd&amp; kernel,
                               const Eigen::MatrixXd&amp; offset,
                               const double weight) {
  if (kernel.rows() != kernel.cols() ||
      kernel.rows() != kernel_matrix_.rows() || offset.cols() != 1 ||
      offset.rows() != offset_.rows()) {
    return false;
  }
  kernel_matrix_ += kernel * weight;
  offset_ += offset * weight;
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_kernel.cc" startLine="(54, 0)" endLine="(65, 1)" clone_start="1" clone_end="12">
			<code function_name="Spline1dKernel::AddKernel(const Eigen::MatrixXd&amp; kernel,const Eigen::MatrixXd&amp; offset, const double weight)">bool Spline1dKernel::AddKernel(const Eigen::MatrixXd&amp; kernel,
                               const Eigen::MatrixXd&amp; offset,
                               const double weight) {
  if (kernel.rows() != kernel.cols() ||
      kernel.rows() != kernel_matrix_.rows() || offset.cols() != 1 ||
      offset.rows() != offset_.rows()) {
    return false;
  }
  kernel_matrix_ += kernel * weight;
  offset_ += offset * weight;
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_kernel.cc" startLine="(60, 0)" endLine="(64, 1)" clone_start="1" clone_end="5">
			<code function_name="Spline2dKernel::AddKernel(const Eigen::MatrixXd&amp; kernel, const double weight)">bool Spline2dKernel::AddKernel(const Eigen::MatrixXd&amp; kernel,
                               const double weight) {
  Eigen::MatrixXd offset = Eigen::MatrixXd::Zero(kernel.rows(), 1);
  return AddKernel(kernel, offset, weight);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_kernel.cc" startLine="(67, 0)" endLine="(71, 1)" clone_start="1" clone_end="5">
			<code function_name="Spline1dKernel::AddKernel(const Eigen::MatrixXd&amp; kernel, const double weight)">bool Spline1dKernel::AddKernel(const Eigen::MatrixXd&amp; kernel,
                               const double weight) {
  Eigen::MatrixXd offset = Eigen::MatrixXd::Zero(kernel.rows(), 1);
  return AddKernel(kernel, offset, weight);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_kernel.cc" startLine="(66, 0)" endLine="(68, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline2dKernel::mutable_kernel_matrix()">Eigen::MatrixXd* Spline2dKernel::mutable_kernel_matrix() {
  return &amp;kernel_matrix_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_kernel.cc" startLine="(73, 0)" endLine="(75, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline1dKernel::mutable_kernel_matrix()">Eigen::MatrixXd* Spline1dKernel::mutable_kernel_matrix() {
  return &amp;kernel_matrix_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_kernel.cc" startLine="(70, 0)" endLine="(70, 70)" clone_start="1" clone_end="1">
			<code function_name="Spline2dKernel::mutable_offset()">Eigen::MatrixXd* Spline2dKernel::mutable_offset() { return &amp;offset_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_kernel.cc" startLine="(77, 0)" endLine="(77, 70)" clone_start="1" clone_end="1">
			<code function_name="Spline1dKernel::mutable_offset()">Eigen::MatrixXd* Spline1dKernel::mutable_offset() { return &amp;offset_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_kernel.cc" startLine="(72, 0)" endLine="(74, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline2dKernel::mutable_offset()">const Eigen::MatrixXd&amp; Spline2dKernel::kernel_matrix() const {
  return kernel_matrix_;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_kernel.cc" startLine="(79, 0)" endLine="(81, 1)" clone_start="1" clone_end="3">
			<code function_name="Spline1dKernel::mutable_offset()">const Eigen::MatrixXd&amp; Spline1dKernel::kernel_matrix() const {
  return kernel_matrix_;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_kernel.cc" startLine="(76, 0)" endLine="(76, 73)" clone_start="1" clone_end="1">
			<code function_name="Spline2dKernel::mutable_offset()">const Eigen::MatrixXd&amp; Spline2dKernel::offset() const { return offset_; }</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_kernel.cc" startLine="(83, 0)" endLine="(83, 73)" clone_start="1" clone_end="1">
			<code function_name="Spline1dKernel::mutable_offset()">const Eigen::MatrixXd&amp; Spline1dKernel::offset() const { return offset_; }</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_kernel.cc" startLine="(79, 0)" endLine="(91, 1)" clone_start="1" clone_end="6">
			<code function_name="Spline2dKernel::AddDerivativeKernelMatrix(const double weight)">void Spline2dKernel::AddDerivativeKernelMatrix(const double weight) {
  for (std::uint32_t i = 0; i + 1 &lt; t_knots_.size(); ++i) {
    Eigen::MatrixXd cur_kernel =
        SplineSegKernel::instance()-&gt;DerivativeKernel(
            spline_order_, t_knots_[i + 1] - t_knots_[i]) *
        weight;
    kernel_matrix_.block(2 * i * spline_order_, 2 * i * spline_order_,
                         spline_order_, spline_order_) += cur_kernel;
    kernel_matrix_.block((2 * i + 1) * spline_order_,
                         (2 * i + 1) * spline_order_, spline_order_,
                         spline_order_) += cur_kernel;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_1d_kernel.cc" startLine="(86, 0)" endLine="(95, 1)" clone_start="1" clone_end="6">
			<code function_name="Spline1dKernel::AddDerivativeKernelMatrix(const double weight)">void Spline1dKernel::AddDerivativeKernelMatrix(const double weight) {
  for (std::uint32_t i = 0; i + 1 &lt; x_knots_.size(); ++i) {
    Eigen::MatrixXd cur_kernel =
        SplineSegKernel::instance()-&gt;DerivativeKernel(
            spline_order_, x_knots_[i + 1] - x_knots_[i]) *
        weight;
    kernel_matrix_.block(i * spline_order_, i * spline_order_, spline_order_,
                         spline_order_) += cur_kernel;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(236, 0)" endLine="(240, 1)" clone_start="4" clone_end="5">
			<code function_name="Misc69::wiper_status(const std::uint8_t *bytes, int32_t length) const">int32_t Misc69::wiper_status(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(79, 0)" endLine="(91, 1)" clone_start="12" clone_end="13">
			<code function_name="Throttle63::pedal_output(const std::uint8_t *bytes, int32_t length) const">double Throttle63::pedal_output(const std::uint8_t *bytes,
                                int32_t length) const {
  // Pedal Output is the maximum of PI and PC
  Byte frame_high(bytes + 5);
  int32_t high = frame_high.get_byte(0, 8);
  Byte frame_low(bytes + 4);
  int32_t low = frame_low.get_byte(0, 8);
  int32_t value = (high &lt;&lt; 8) | low;
  // control needs a value in range [0, 100] %
  double output = 100.0 * value * 1.52590218966964e-05;
  output = ProtocolData::BoundedValue(0.0, 100.0, output);
  return output;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(242, 0)" endLine="(247, 1)" clone_start="1" clone_end="6">
			<code function_name="Misc69::ambient_light_status(const std::uint8_t *bytes, int32_t length) const">int32_t Misc69::ambient_light_status(const std::uint8_t *bytes,
                                     int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(93, 0)" endLine="(98, 1)" clone_start="1" clone_end="6">
			<code function_name="Throttle63::watchdog_counter_source(const std::uint8_t *bytes, int32_t length) const">int32_t Throttle63::watchdog_counter_source(const std::uint8_t *bytes,
                                            int32_t length) const {
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(249, 0)" endLine="(253, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_on_pressed(const std::uint8_t *bytes,
                               int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(100, 0)" endLine="(103, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle63::is_enabled(const std::uint8_t *bytes, int32_t length) const">bool Throttle63::is_enabled(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(0);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(255, 0)" endLine="(259, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_off_pressed(const std::uint8_t *bytes,
                                int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(105, 0)" endLine="(109, 1)" clone_start="1" clone_end="5">
			<code function_name="Throttle63::is_driver_override(const std::uint8_t *bytes, int32_t length) const">bool Throttle63::is_driver_override(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(1);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(261, 0)" endLine="(265, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_resume_pressed(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(111, 0)" endLine="(115, 1)" clone_start="1" clone_end="5">
			<code function_name="Throttle63::is_driver_activity(const std::uint8_t *bytes, int32_t length) const">bool Throttle63::is_driver_activity(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(2);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(267, 0)" endLine="(271, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_cancel_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_cancel_pressed(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(117, 0)" endLine="(121, 1)" clone_start="1" clone_end="5">
			<code function_name="Throttle63::is_watchdog_counter_fault(const std::uint8_t *bytes, int32_t length) const">bool Throttle63::is_watchdog_counter_fault(const std::uint8_t *bytes,
                                           int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(273, 0)" endLine="(277, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_or_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_on_or_off_pressed(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(123, 0)" endLine="(127, 1)" clone_start="1" clone_end="5">
			<code function_name="Throttle63::is_channel_1_fault(const std::uint8_t *bytes, int32_t length) const">bool Throttle63::is_channel_1_fault(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(4);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(279, 0)" endLine="(283, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t *bytes,
                                             int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(129, 0)" endLine="(133, 1)" clone_start="1" clone_end="5">
			<code function_name="Throttle63::is_channel_2_fault(const std::uint8_t *bytes, int32_t length) const">bool Throttle63::is_channel_2_fault(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(5);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(285, 0)" endLine="(289, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_63.cc" startLine="(135, 0)" endLine="(139, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle63::is_connector_fault(const std::uint8_t *bytes, int32_t length) const">bool Throttle63::is_connector_fault(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(7);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="167" clone_end="195">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(26, 0)" endLine="(41, 1)" clone_start="4" clone_end="16">
			<code function_name="Gps6e::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Gps6e::Parse(const std::uint8_t *bytes, int32_t length,
                  ChassisDetail *chassis_detail) const {
  chassis_detail-&gt;mutable_basic()-&gt;set_year(year(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_month(month(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_day(day(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_hours(hours(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_minutes(minutes(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_seconds(seconds(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_compass_direction(
      compass_direction(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_pdop(pdop(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_is_gps_fault(
      is_gps_fault(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_is_inferred(
      is_inferred_position(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(222, 0)" endLine="(227, 1)" clone_start="1" clone_end="6">
			<code function_name="Misc69::turn_signal_status(const std::uint8_t *bytes, int32_t length) const">int32_t Misc69::turn_signal_status(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(43, 0)" endLine="(47, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::year(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::year(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(0, 7);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(229, 0)" endLine="(234, 1)" clone_start="1" clone_end="6">
			<code function_name="Misc69::high_beam_status(const std::uint8_t *bytes, int32_t length) const">int32_t Misc69::high_beam_status(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(2, 2);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(49, 0)" endLine="(53, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::month(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::month(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 4);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(236, 0)" endLine="(240, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::wiper_status(const std::uint8_t *bytes, int32_t length) const">int32_t Misc69::wiper_status(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 0);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(55, 0)" endLine="(59, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::day(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::day(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 2);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(242, 0)" endLine="(247, 1)" clone_start="1" clone_end="6">
			<code function_name="Misc69::ambient_light_status(const std::uint8_t *bytes, int32_t length) const">int32_t Misc69::ambient_light_status(const std::uint8_t *bytes,
                                     int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(61, 0)" endLine="(65, 1)" clone_start="1" clone_end="5">
			<code function_name="Gps6e::hours(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::hours(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 3);
  int32_t x = frame.get_byte(0, 5);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(249, 0)" endLine="(253, 1)" clone_start="1" clone_end="3">
			<code function_name="Misc69::is_acc_on_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_on_pressed(const std::uint8_t *bytes,
                               int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\gps_6e.cc" startLine="(67, 0)" endLine="(71, 1)" clone_start="1" clone_end="2">
			<code function_name="Gps6e::minutes(const std::uint8_t *bytes, int32_t length) const">int32_t Gps6e::minutes(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 4);
  int32_t x = frame.get_byte(0, 6);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.cc" startLine="(696, 0)" endLine="(829, 1)" clone_start="37" clone_end="68">
			<code function_name="PathApproximation::GetProjection(const Path&amp; path,const common::math::Vec2d&amp; point, double* accumulate_s, double* lateral, double* min_distance) const">bool PathApproximation::GetProjection(const Path&amp; path,
                                      const common::math::Vec2d&amp; point,
                                      double* accumulate_s, double* lateral,
                                      double* min_distance) const {
  if (num_points_ == 0) {
    return false;
  }
  if (accumulate_s == nullptr || lateral == nullptr ||
      min_distance == nullptr) {
    return false;
  }
  double min_distance_sqr = std::numeric_limits&lt;double&gt;::infinity();
  int estimate_nearest_segment_idx = -1;
  std::vector&lt;double&gt; distance_sqr_to_segments;
  distance_sqr_to_segments.reserve(segments_.size());
  for (size_t i = 0; i &lt; segments_.size(); ++i) {
    const double distance_sqr = segments_[i].DistanceSquareTo(point);
    distance_sqr_to_segments.push_back(distance_sqr);
    if (distance_sqr &lt; min_distance_sqr) {
      min_distance_sqr = distance_sqr;
      estimate_nearest_segment_idx = i;
    }
  }
  if (estimate_nearest_segment_idx &lt; 0) {
    return false;
  }
  const auto&amp; original_segments = path.segments();
  const int num_original_segments = static_cast&lt;int&gt;(original_segments.size());
  const auto&amp; original_accumulated_s = path.accumulated_s();
  double min_distance_sqr_with_error =
      Sqr(sqrt(min_distance_sqr) +
          max_error_per_segment_[estimate_nearest_segment_idx] + max_error_);
  *min_distance = std::numeric_limits&lt;double&gt;::infinity();
  int nearest_segment_idx = -1;
  for (size_t i = 0; i &lt; segments_.size(); ++i) {
    if (distance_sqr_to_segments[i] &gt;= min_distance_sqr_with_error) {
      continue;
    }
    int first_segment_idx = original_ids_[i];
    int last_segment_idx = original_ids_[i + 1] - 1;
    double max_original_projection = std::numeric_limits&lt;double&gt;::infinity();
    if (first_segment_idx &lt; last_segment_idx) {
      const auto&amp; segment = segments_[i];
      const double projection = segment.ProjectOntoUnit(point);
      const double prod_sqr = Sqr(segment.ProductOntoUnit(point));
      if (prod_sqr &gt;= min_distance_sqr_with_error) {
        continue;
      }
      const double scan_distance = sqrt(min_distance_sqr_with_error - prod_sqr);
      const double min_projection = projection - scan_distance;
      max_original_projection = projections_[i] + projection + scan_distance;
      if (min_projection &gt; 0.0) {
        const double limit = projections_[i] + min_projection;
        const int sample_index =
            std::max(0, static_cast&lt;int&gt;(limit / kSampleDistance));
        if (sample_index &gt;= num_projection_samples_) {
          first_segment_idx = last_segment_idx;
        } else {
          first_segment_idx =
              std::max(first_segment_idx,
                       sampled_max_original_projections_to_left_[sample_index]);
          if (first_segment_idx &gt;= last_segment_idx) {
            first_segment_idx = last_segment_idx;
          } else {
            while (first_segment_idx &lt; last_segment_idx &amp;&amp;
                   max_original_projections_to_left_[first_segment_idx + 1] &lt;
                       limit) {
              ++first_segment_idx;
            }
          }
        }
      }
    }
    bool min_distance_updated = false;
    bool is_within_end_point = false;
    for (int idx = first_segment_idx; idx &lt;= last_segment_idx; ++idx) {
      if (min_original_projections_to_right_[idx] &gt; max_original_projection) {
        break;
      }
      const auto&amp; original_segment = original_segments[idx];
      const double x0 = point.x() - original_segment.start().x();
      const double y0 = point.y() - original_segment.start().y();
      const double ux = original_segment.unit_direction().x();
      const double uy = original_segment.unit_direction().y();
      double proj = x0 * ux + y0 * uy;
      double distance = 0.0;
      if (proj &lt; 0.0) {
        if (is_within_end_point) {
          continue;
        }
        is_within_end_point = true;
        distance = hypot(x0, y0);
      } else if (proj &lt;= original_segment.length()) {
        is_within_end_point = true;
        distance = std::abs(x0 * uy - y0 * ux);
      } else {
        is_within_end_point = false;
        if (idx != last_segment_idx) {
          continue;
        }
        distance = original_segment.end().DistanceTo(point);
      }
      if (distance &lt; *min_distance) {
        min_distance_updated = true;
        *min_distance = distance;
        nearest_segment_idx = idx;
      }
    }
    if (min_distance_updated) {
      min_distance_sqr_with_error = Sqr(*min_distance + max_error_);
    }
  }
  if (nearest_segment_idx &gt;= 0) {
    const auto&amp; segment = original_segments[nearest_segment_idx];
    double proj = segment.ProjectOntoUnit(point);
    const double prod = segment.ProductOntoUnit(point);
    if (nearest_segment_idx &gt; 0) {
      proj = std::max(0.0, proj);
    }
    if (nearest_segment_idx + 1 &lt; num_original_segments) {
      proj = std::min(segment.length(), proj);
    }
    *accumulate_s = original_accumulated_s[nearest_segment_idx] + proj;
    if ((nearest_segment_idx == 0 &amp;&amp; proj &lt; 0.0) ||
        (nearest_segment_idx + 1 == num_original_segments &amp;&amp;
         proj &gt; segment.length())) {
      *lateral = prod;
    } else {
      *lateral = (prod &gt; 0 ? (*min_distance) : -(*min_distance));
    }
    return true;
  }
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\pnc_map\path.cc" startLine="(831, 0)" endLine="(896, 1)" clone_start="15" clone_end="46">
			<code function_name="PathApproximation::OverlapWith(const Path&amp; path, const Box2d&amp; box, double width) const">bool PathApproximation::OverlapWith(const Path&amp; path, const Box2d&amp; box,
                                    double width) const {
  if (num_points_ == 0) {
    return false;
  }
  const Vec2d center = box.center();
  const double radius = box.diagonal() / 2.0 + width;
  const double radius_sqr = Sqr(radius);
  const auto&amp; original_segments = path.segments();
  for (size_t i = 0; i &lt; segments_.size(); ++i) {
    const LineSegment2d&amp; segment = segments_[i];
    const double max_error = max_error_per_segment_[i];
    const double radius_sqr_with_error = Sqr(radius + max_error);
    if (segment.DistanceSquareTo(center) &gt; radius_sqr_with_error) {
      continue;
    }
    int first_segment_idx = original_ids_[i];
    int last_segment_idx = original_ids_[i + 1] - 1;
    double max_original_projection = std::numeric_limits&lt;double&gt;::infinity();
    if (first_segment_idx &lt; last_segment_idx) {
      const auto&amp; segment = segments_[i];
      const double projection = segment.ProjectOntoUnit(center);
      const double prod_sqr = Sqr(segment.ProductOntoUnit(center));
      if (prod_sqr &gt;= radius_sqr_with_error) {
        continue;
      }
      const double scan_distance = sqrt(radius_sqr_with_error - prod_sqr);
      const double min_projection = projection - scan_distance;
      max_original_projection = projections_[i] + projection + scan_distance;
      if (min_projection &gt; 0.0) {
        const double limit = projections_[i] + min_projection;
        const int sample_index =
            std::max(0, static_cast&lt;int&gt;(limit / kSampleDistance));
        if (sample_index &gt;= num_projection_samples_) {
          first_segment_idx = last_segment_idx;
        } else {
          first_segment_idx =
              std::max(first_segment_idx,
                       sampled_max_original_projections_to_left_[sample_index]);
          if (first_segment_idx &gt;= last_segment_idx) {
            first_segment_idx = last_segment_idx;
          } else {
            while (first_segment_idx &lt; last_segment_idx &amp;&amp;
                   max_original_projections_to_left_[first_segment_idx + 1] &lt;
                       limit) {
              ++first_segment_idx;
            }
          }
        }
      }
    }
    for (int idx = first_segment_idx; idx &lt;= last_segment_idx; ++idx) {
      if (min_original_projections_to_right_[idx] &gt; max_original_projection) {
        break;
      }
      const auto&amp; original_segment = original_segments[idx];
      if (original_segment.DistanceSquareTo(center) &gt; radius_sqr) {
        continue;
      }
      if (box.DistanceTo(original_segment) &lt;= width) {
        return true;
      }
    }
  }
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="151" clone_end="198">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\hm_tracker.cc" startLine="(47, 0)" endLine="(314, 1)" clone_start="140" clone_end="187">
			<code function_name="HmObjectTracker::Init()">bool HmObjectTracker::Init() {
  // Initialize tracker's configs
  using apollo::perception::ConfigManager;
  using apollo::perception::ModelConfig;

  const ModelConfig* model_config = nullptr;
  if (!ConfigManager::instance()-&gt;GetModelConfig(name(), &amp;model_config)) {
    AERROR &lt;&lt; "not found model config: " &lt;&lt; name();
    return false;
  }

  // A. Basic tracker setup
  std::string matcher_method_name = "hungarian_matcher";
  std::string filter_method_name = "kalman_filter";
  int track_cached_history_size_maximum = 5;
  int track_consecutive_invisible_maximum = 1;
  float track_visible_ratio_minimum = 0.6;
  int collect_age_minimum = 0;
  int collect_consecutive_invisible_maximum = 0;
  float acceleration_noise_maximum = 5;
  float speed_noise_maximum = 0.4;
  // load match method
  if (!model_config-&gt;GetValue("matcher_method_name",
    &amp;matcher_method_name)) {
    AERROR &lt;&lt; "Failed to get matcher method name! " &lt;&lt; name();
    return false;
  }
  if (!SetMatcherMethod(matcher_method_name)) {
    AERROR &lt;&lt; "Failed to set matcher method! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    matcher_ = new HungarianMatcher();
  } else {
    matcher_method_ = HUNGARIAN_MATCHER;
    matcher_ = new HungarianMatcher();
    AWARN &lt;&lt; "invalid matcher method! default HungarianMatcher in use!";
  }
  // load filter method
  if (!model_config-&gt;GetValue("filter_method_name", &amp;filter_method_name)) {
    AERROR &lt;&lt; "Failed to get filter method name! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetFilterMethod(filter_method_name)) {
    AERROR &lt;&lt; "Failed to set filter method! " &lt;&lt; name();
    return false;
  } else {
    filter_method_ = ObjectTrack::s_filter_method_;
  }
  // load track cached history size maximum
  if (!model_config-&gt;GetValue("track_cached_history_size_maximum",
    &amp;track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to get track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetTrackCachedHistorySizeMaximum(
    track_cached_history_size_maximum)) {
    AERROR &lt;&lt; "Failed to set track cached history size maximum! " &lt;&lt; name();
    return false;
  }
  // load track consevutive invisible maximum
  if (!model_config-&gt;GetValue("track_consecutive_invisible_maximum",
    &amp;track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackConsecutiveInvisibleMaximum(
    track_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set track consecutive invisible maximum! " &lt;&lt; name();
    return false;
  }
  // load track visible ratio minimum
  if (!model_config-&gt;GetValue("track_visible_ratio_minimum",
    &amp;track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to get track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrackSet::SetTrackVisibleRatioMinimum(
    track_visible_ratio_minimum)) {
    AERROR &lt;&lt; "Failed to set track visible ratio minimum! " &lt;&lt; name();
    return false;
  }
  // load collect age minimum
  if (!model_config-&gt;GetValue("collect_age_minimum", &amp;collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to get collect age minimum! " &lt;&lt; name();
    return false;
  }
  if (!SetCollectAgeMinimum(collect_age_minimum)) {
    AERROR &lt;&lt; "Failed to set collect age minimum! " &lt;&lt; name();
    return false;
  }
  // load collect consecutive invisible maximum
  if (!model_config-&gt;GetValue("collect_consecutive_invisible_maximum",
    &amp;collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to get collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  if (!SetCollectConsecutiveInvisibleMaximum(
    collect_consecutive_invisible_maximum)) {
    AERROR &lt;&lt; "Failed to set collect consecutive invisible maximum! "
           &lt;&lt; name();
    return false;
  }
  // load acceleration maximum
  if (!model_config-&gt;GetValue("acceleration_noise_maximum",
    &amp;acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetAccelerationNoiseMaximum(acceleration_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set acceleration noise maximum! " &lt;&lt; name();
    return false;
  }
  // load speed noise maximum
  if (!model_config-&gt;GetValue("speed_noise_maximum", &amp;speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to get speed noise maximum! " &lt;&lt; name();
    return false;
  }
  if (!ObjectTrack::SetSpeedNoiseMaximum(speed_noise_maximum)) {
    AERROR &lt;&lt; "Failed to set speed noise maximum! " &lt;&lt; name();
    return false;
  }

  // B. Matcher setup
  float match_distance_maximum = 4.0;
  float location_distance_weight = 0.6;
  float direction_distance_weight = 0.2f;
  float bbox_size_distance_weight = 0.1f;
  float point_num_distance_weight = 0.1f;
  float histogram_distance_weight = 0.5f;
  int histogram_bin_size = 10;
  // load match distance maximum
  if (!model_config-&gt;GetValue("match_distance_maximum",
    &amp;match_distance_maximum)) {
    AERROR &lt;&lt; "Failed to get match distance maximum! " &lt;&lt; name();
    return false;
  }
  if (matcher_method_ == HUNGARIAN_MATCHER) {
    if (!HungarianMatcher::SetMatchDistanceMaximum(match_distance_maximum)) {
      AERROR &lt;&lt; "Failed to set match distance maximum! " &lt;&lt; name();
      return false;
    }
  }
  // load location distance weight
  if (!model_config-&gt;GetValue("location_distance_weight",
    &amp;location_distance_weight)) {
    AERROR &lt;&lt; "Failed to get location distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetLocationDistanceWeight(
    location_distance_weight)) {
    AERROR &lt;&lt; "Failed to set location distance weight! " &lt;&lt; name();
    return false;
  }
  // load direction distance weight
  if (!model_config-&gt;GetValue("direction_distance_weight",
    &amp;direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to get direction distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetDirectionDistanceWeight(
    direction_distance_weight)) {
    AERROR &lt;&lt; "Failed to set direction distance weight! " &lt;&lt; name();
    return false;
  }
  // load bbox size distance weight
  if (!model_config-&gt;GetValue("bbox_size_distance_weight",
    &amp;bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to get bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetBboxSizeDistanceWeight(
    bbox_size_distance_weight)) {
    AERROR &lt;&lt; "Failed to set bbox size distance weight! " &lt;&lt; name();
    return false;
  }
  // load point num distance weight
  if (!model_config-&gt;GetValue("point_num_distance_weight",
    &amp;point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to get point num distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetPointNumDistanceWeight(
    point_num_distance_weight)) {
    AERROR &lt;&lt; "Failed to set point num distance weight! " &lt;&lt; name();
    return false;
  }
  // load histogram distance weight
  if (!model_config-&gt;GetValue("histogram_distance_weight",
    &amp;histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to get histogram distance weight! " &lt;&lt; name();
    return false;
  }
  if (!TrackObjectDistance::SetHistogramDistanceWeight(
    histogram_distance_weight)) {
    AERROR &lt;&lt; "Failed to set histogram distance weight! " &lt;&lt; name();
    return false;
  }
  use_histogram_for_match_ =
    histogram_distance_weight &gt; FLT_EPSILON ? true : false;
  if (!model_config-&gt;GetValue("histogram_bin_size", &amp;histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to get histogram bin size! " &lt;&lt; name();
    return false;
  }
  if (!SetHistogramBinSize(histogram_bin_size)) {
    AERROR &lt;&lt; "Failed to set histogram bin size! " &lt;&lt; name();
    return false;
  }

  // C. Filter setup
  bool use_adaptive = false;
  if (!model_config-&gt;GetValue("use_adaptive", &amp;use_adaptive)) {
    AERROR &lt;&lt; "Failed to get use adaptive! " &lt;&lt; name();
    return false;
  }

  if (filter_method_ == KALMAN_FILTER) {
    double association_score_maximum = match_distance_maximum;
    float measurement_noise = 0.4f;
    float initial_velocity_noise = 5.0f;
    float xy_propagation_noise = 10.0f;
    float z_propagation_noise = 10.0f;
    float breakdown_threshold_maximum = 10.0;
    KalmanFilter::SetUseAdaptive(use_adaptive);
    if (!KalmanFilter::SetAssociationScoreMaximum(
      association_score_maximum)) {
      AERROR &lt;&lt; "Failed to set association score maximum! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("measurement_noise", &amp;measurement_noise)) {
      AERROR &lt;&lt; "Failed to get measurement noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("initial_velocity_noise",
      &amp;initial_velocity_noise)) {
      AERROR &lt;&lt; "Failed to get initial velocity noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("xy_propagation_noise",
      &amp;xy_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get xy propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("z_propagation_noise",
      &amp;z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to get z propagation noise! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::InitParams(measurement_noise, initial_velocity_noise,
                                  xy_propagation_noise,
                                  z_propagation_noise)) {
      AERROR &lt;&lt; "Failed to set params for kalman filter! " &lt;&lt; name();
      return false;
    }
    if (!model_config-&gt;GetValue("breakdown_threshold_maximum",
      &amp;breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to get breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
    if (!KalmanFilter::SetBreakdownThresholdMaximum(
      breakdown_threshold_maximum)) {
      AERROR &lt;&lt; "Failed to set breakdown threshold maximum! " &lt;&lt; name();
      return false;
    }
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(76, 0)" endLine="(94, 1)" clone_start="10" clone_end="19">
			<code function_name="Steering64::set_steering_angle_p(uint8_t *data, double angle)">void Steering64::set_steering_angle_p(uint8_t *data, double angle) {
  angle = ProtocolData::BoundedValue(-470.0, 470.0, angle);
  int32_t x = angle / 0.100000;

  // add offset
  if (x &lt; 0) {
    x += 0x10000;
  }

  std::uint8_t t = 0;
  t = x &amp; 0xFF;  // low
  Byte frame_low(data + 0);
  frame_low.set_value(t, 0, 8);

  x &gt;&gt;= 8;  // high
  t = x &amp; 0xFF;
  Byte frame_high(data + 1);
  frame_high.set_value(t, 0, 8);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(66, 0)" endLine="(82, 1)" clone_start="7" clone_end="17">
			<code function_name="Throttle62::set_pedal_p(uint8_t *data, double pedal)">void Throttle62::set_pedal_p(uint8_t *data, double pedal) {
  // change from [0-100] to [0.00-1.00]
  // and a rough mapping
  pedal /= 100.0;
  pedal = ProtocolData::BoundedValue(0.0, 1.0, pedal);
  int32_t x = pedal / 1.52590218966964e-05;
  std::uint8_t t = 0;

  t = x &amp; 0xFF;
  Byte frame_low(data + 0);
  frame_low.set_value(t, 0, 8);

  x &gt;&gt;= 8;
  t = x &amp; 0xFF;
  Byte frame_high(data + 1);
  frame_high.set_value(t, 0, 8);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(79, 0)" endLine="(95, 1)" clone_start="7" clone_end="17">
			<code function_name="Brake60::set_pedal_p(uint8_t *data, double pedal)">void Brake60::set_pedal_p(uint8_t *data, double pedal) {
  // change from [0-100] to [0.00-1.00]
  // and a rough mapping
  pedal /= 100.;
  pedal = ProtocolData::BoundedValue(0.0, 1.0, pedal);
  int32_t x = pedal / 1.52590218966964e-05;
  std::uint8_t t = 0;

  t = x &amp; 0xFF;
  Byte frame_low(data + 0);
  frame_low.set_value(t, 0, 8);

  x &gt;&gt;= 8;
  t = x &amp; 0xFF;
  Byte frame_high(data + 1);
  frame_high.set_value(t, 0, 8);
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(96, 0)" endLine="(103, 1)" clone_start="1" clone_end="8">
			<code function_name="Steering64::set_enable_p(uint8_t *bytes, bool enable)">void Steering64::set_enable_p(uint8_t *bytes, bool enable) {
  Byte frame(bytes + 2);
  if (enable) {
    frame.set_bit_1(0);
  } else {
    frame.set_bit_0(0);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(84, 0)" endLine="(91, 1)" clone_start="1" clone_end="8">
			<code function_name="Throttle62::set_enable_p(uint8_t *bytes, bool enable)">void Throttle62::set_enable_p(uint8_t *bytes, bool enable) {
  Byte frame(bytes + 3);
  if (enable) {
    frame.set_bit_1(0);
  } else {
    frame.set_bit_0(0);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(97, 0)" endLine="(104, 1)" clone_start="1" clone_end="8">
			<code function_name="Brake60::set_boo_cmd_p(uint8_t *bytes, bool boo_cmd)">void Brake60::set_boo_cmd_p(uint8_t *bytes, bool boo_cmd) {
  Byte frame(bytes + 2);
  if (boo_cmd) {
    frame.set_bit_1(0);
  } else {
    frame.set_bit_0(0);
  }
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(105, 0)" endLine="(112, 1)" clone_start="1" clone_end="8">
			<code function_name="Steering64::set_clear_driver_override_flag_p(uint8_t *bytes, bool clear)">void Steering64::set_clear_driver_override_flag_p(uint8_t *bytes, bool clear) {
  Byte frame(bytes + 2);
  if (clear) {
    frame.set_bit_1(1);
  } else {
    frame.set_bit_0(1);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(93, 0)" endLine="(100, 1)" clone_start="1" clone_end="8">
			<code function_name="Throttle62::set_clear_driver_override_flag_p(uint8_t *bytes, bool clear)">void Throttle62::set_clear_driver_override_flag_p(uint8_t *bytes, bool clear) {
  Byte frame(bytes + 3);
  if (clear) {
    frame.set_bit_1(1);
  } else {
    frame.set_bit_0(1);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(106, 0)" endLine="(113, 1)" clone_start="1" clone_end="8">
			<code function_name="Brake60::set_enable_p(uint8_t *bytes, bool enable)">void Brake60::set_enable_p(uint8_t *bytes, bool enable) {
  Byte frame(bytes + 3);
  if (enable) {
    frame.set_bit_1(0);
  } else {
    frame.set_bit_0(0);
  }
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(114, 0)" endLine="(121, 1)" clone_start="1" clone_end="8">
			<code function_name="Steering64::set_ignore_driver_override_p(uint8_t *bytes, bool ignore)">void Steering64::set_ignore_driver_override_p(uint8_t *bytes, bool ignore) {
  Byte frame(bytes + 2);
  if (ignore) {
    frame.set_bit_1(2);
  } else {
    frame.set_bit_0(2);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(102, 0)" endLine="(109, 1)" clone_start="1" clone_end="8">
			<code function_name="Throttle62::set_ignore_driver_override_p(uint8_t *bytes, bool ignore)">void Throttle62::set_ignore_driver_override_p(uint8_t *bytes, bool ignore) {
  Byte frame(bytes + 3);
  if (ignore) {
    frame.set_bit_1(2);
  } else {
    frame.set_bit_0(2);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(115, 0)" endLine="(122, 1)" clone_start="1" clone_end="8">
			<code function_name="Brake60::set_clear_driver_override_flag_p(uint8_t *bytes, bool clear)">void Brake60::set_clear_driver_override_flag_p(uint8_t *bytes, bool clear) {
  Byte frame(bytes + 3);
  if (clear) {
    frame.set_bit_1(1);
  } else {
    frame.set_bit_0(1);
  }
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\steering_64.cc" startLine="(123, 0)" endLine="(129, 1)" clone_start="1" clone_end="2">
			<code function_name="Steering64::set_steering_angle_speed_p(uint8_t *data, double angle_speed)">void Steering64::set_steering_angle_speed_p(uint8_t *data, double angle_speed) {
  angle_speed = ProtocolData::BoundedValue(0.0, 500.0, angle_speed);
  int32_t x = angle_speed / 2.000000;

  Byte frame(data + 3);
  frame.set_value(x, 0, 8);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(111, 0)" endLine="(115, 1)" clone_start="1" clone_end="2">
			<code function_name="Throttle62::set_watchdog_counter_p(uint8_t *data, int32_t count)">void Throttle62::set_watchdog_counter_p(uint8_t *data, int32_t count) {
  count = ProtocolData::BoundedValue(0, 255, count);
  Byte frame(data + 7);
  frame.set_value(count, 0, 8);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(124, 0)" endLine="(128, 1)" clone_start="1" clone_end="2">
			<code function_name="Brake60::set_watchdog_counter_p(uint8_t *data, int32_t count)">void Brake60::set_watchdog_counter_p(uint8_t *data, int32_t count) {
  count = ProtocolData::BoundedValue(0, 255, count);
  Byte frame(data + 7);
  frame.set_value(count, 0, 8);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\strategy\a_star_strategy.cc" startLine="(126, 0)" endLine="(172, 1)" clone_start="7" clone_end="47">
			<code function_name="AdjustLaneChangeForward( std::vector&lt;const TopoNode*&gt;* const result_node_vec)">bool AdjustLaneChangeForward(
    std::vector&lt;const TopoNode*&gt;* const result_node_vec) {
  for (size_t i = 1; i &lt; result_node_vec-&gt;size() - 1; ++i) {
    const auto* from_node = result_node_vec-&gt;at(i - 1);
    const auto* to_node = result_node_vec-&gt;at(i);
    const auto* base_node = result_node_vec-&gt;at(i + 1);
    const auto* from_to_edge = from_node-&gt;GetOutEdgeTo(to_node);
    if (from_to_edge == nullptr) {
      // may need to recalculate edge,
      // because only edge from origin node to subnode is saved
      from_to_edge = to_node-&gt;GetInEdgeFrom(from_node);
    }
    if (from_to_edge == nullptr) {
      AERROR &lt;&lt; "Get null ptr to edge:" &lt;&lt; from_node-&gt;LaneId() &lt;&lt; " ("
             &lt;&lt; from_node-&gt;StartS() &lt;&lt; ", " &lt;&lt; from_node-&gt;EndS() &lt;&lt; ")"
             &lt;&lt; " --&gt; " &lt;&lt; to_node-&gt;LaneId() &lt;&lt; " (" &lt;&lt; to_node-&gt;StartS()
             &lt;&lt; ", " &lt;&lt; to_node-&gt;EndS() &lt;&lt; ")";
      return false;
    }
    if (from_to_edge-&gt;Type() != TopoEdgeType::TET_FORWARD) {
      if (base_node-&gt;EndS() - base_node-&gt;StartS() &lt;
          to_node-&gt;EndS() - to_node-&gt;StartS()) {
        continue;
      }
      std::vector&lt;const TopoNode*&gt; candidate_set;
      candidate_set.push_back(to_node);
      const auto&amp; in_edges = base_node-&gt;InFromLeftOrRightEdge();
      for (const auto* edge : in_edges) {
        const auto* candidate_node = edge-&gt;FromNode();
        if (candidate_node == to_node) {
          continue;
        }
        if (candidate_node-&gt;GetInEdgeFrom(from_node) != nullptr) {
          candidate_set.push_back(candidate_node);
        }
      }
      const auto* largest_node = GetLargestNode(candidate_set);
      if (largest_node == nullptr) {
        return false;
      }
      if (largest_node != to_node) {
        result_node_vec-&gt;at(i) = largest_node;
      }
    }
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\strategy\a_star_strategy.cc" startLine="(78, 0)" endLine="(124, 1)" clone_start="7" clone_end="47">
			<code function_name="AdjustLaneChangeBackward( std::vector&lt;const TopoNode*&gt;* const result_node_vec)">bool AdjustLaneChangeBackward(
    std::vector&lt;const TopoNode*&gt;* const result_node_vec) {
  for (int i = static_cast&lt;int&gt;(result_node_vec-&gt;size()) - 2; i &gt; 0; --i) {
    const auto* from_node = result_node_vec-&gt;at(i);
    const auto* to_node = result_node_vec-&gt;at(i + 1);
    const auto* base_node = result_node_vec-&gt;at(i - 1);
    const auto* from_to_edge = from_node-&gt;GetOutEdgeTo(to_node);
    if (from_to_edge == nullptr) {
      // may need to recalculate edge,
      // because only edge from origin node to subnode is saved
      from_to_edge = to_node-&gt;GetInEdgeFrom(from_node);
    }
    if (from_to_edge == nullptr) {
      AERROR &lt;&lt; "Get null ptr to edge:" &lt;&lt; from_node-&gt;LaneId() &lt;&lt; " ("
             &lt;&lt; from_node-&gt;StartS() &lt;&lt; ", " &lt;&lt; from_node-&gt;EndS() &lt;&lt; ")"
             &lt;&lt; " --&gt; " &lt;&lt; to_node-&gt;LaneId() &lt;&lt; " (" &lt;&lt; to_node-&gt;StartS()
             &lt;&lt; ", " &lt;&lt; to_node-&gt;EndS() &lt;&lt; ")";
      return false;
    }
    if (from_to_edge-&gt;Type() != TopoEdgeType::TET_FORWARD) {
      if (base_node-&gt;EndS() - base_node-&gt;StartS() &lt;
          from_node-&gt;EndS() - from_node-&gt;StartS()) {
        continue;
      }
      std::vector&lt;const TopoNode*&gt; candidate_set;
      candidate_set.push_back(from_node);
      const auto&amp; out_edges = base_node-&gt;OutToLeftOrRightEdge();
      for (const auto* edge : out_edges) {
        const auto* candidate_node = edge-&gt;ToNode();
        if (candidate_node == from_node) {
          continue;
        }
        if (candidate_node-&gt;GetOutEdgeTo(to_node) != nullptr) {
          candidate_set.push_back(candidate_node);
        }
      }
      const auto* largest_node = GetLargestNode(candidate_set);
      if (largest_node == nullptr) {
        return false;
      }
      if (largest_node != from_node) {
        result_node_vec-&gt;at(i) = largest_node;
      }
    }
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\strategy\a_star_strategy.cc" startLine="(174, 0)" endLine="(187, 1)" clone_start="1" clone_end="1">
			<code function_name="AdjustLaneChange(std::vector&lt;const TopoNode*&gt;* const result_node_vec)">bool AdjustLaneChange(std::vector&lt;const TopoNode*&gt;* const result_node_vec) {
  if (result_node_vec-&gt;size() &lt; 3) {
    return true;
  }
  if (!AdjustLaneChangeBackward(result_node_vec)) {
    AERROR &lt;&lt; "Failed to adjust lane change backward";
    return false;
  }
  if (!AdjustLaneChangeForward(result_node_vec)) {
    AERROR &lt;&lt; "Failed to adjust lane change backward";
    return false;
  }
  return true;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\routing\strategy\a_star_strategy.cc" startLine="(126, 0)" endLine="(172, 1)" clone_start="1" clone_end="1">
			<code function_name="AdjustLaneChangeForward( std::vector&lt;const TopoNode*&gt;* const result_node_vec)">bool AdjustLaneChangeForward(
    std::vector&lt;const TopoNode*&gt;* const result_node_vec) {
  for (size_t i = 1; i &lt; result_node_vec-&gt;size() - 1; ++i) {
    const auto* from_node = result_node_vec-&gt;at(i - 1);
    const auto* to_node = result_node_vec-&gt;at(i);
    const auto* base_node = result_node_vec-&gt;at(i + 1);
    const auto* from_to_edge = from_node-&gt;GetOutEdgeTo(to_node);
    if (from_to_edge == nullptr) {
      // may need to recalculate edge,
      // because only edge from origin node to subnode is saved
      from_to_edge = to_node-&gt;GetInEdgeFrom(from_node);
    }
    if (from_to_edge == nullptr) {
      AERROR &lt;&lt; "Get null ptr to edge:" &lt;&lt; from_node-&gt;LaneId() &lt;&lt; " ("
             &lt;&lt; from_node-&gt;StartS() &lt;&lt; ", " &lt;&lt; from_node-&gt;EndS() &lt;&lt; ")"
             &lt;&lt; " --&gt; " &lt;&lt; to_node-&gt;LaneId() &lt;&lt; " (" &lt;&lt; to_node-&gt;StartS()
             &lt;&lt; ", " &lt;&lt; to_node-&gt;EndS() &lt;&lt; ")";
      return false;
    }
    if (from_to_edge-&gt;Type() != TopoEdgeType::TET_FORWARD) {
      if (base_node-&gt;EndS() - base_node-&gt;StartS() &lt;
          to_node-&gt;EndS() - to_node-&gt;StartS()) {
        continue;
      }
      std::vector&lt;const TopoNode*&gt; candidate_set;
      candidate_set.push_back(to_node);
      const auto&amp; in_edges = base_node-&gt;InFromLeftOrRightEdge();
      for (const auto* edge : in_edges) {
        const auto* candidate_node = edge-&gt;FromNode();
        if (candidate_node == to_node) {
          continue;
        }
        if (candidate_node-&gt;GetInEdgeFrom(from_node) != nullptr) {
          candidate_set.push_back(candidate_node);
        }
      }
      const auto* largest_node = GetLargestNode(candidate_set);
      if (largest_node == nullptr) {
        return false;
      }
      if (largest_node != to_node) {
        result_node_vec-&gt;at(i) = largest_node;
      }
    }
  }
  return true;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(115, 0)" endLine="(121, 1)" clone_start="1" clone_end="7">
			<code function_name="Brake61::watchdog_counter_source(const std::uint8_t *bytes, int32_t length) const">int32_t Brake61::watchdog_counter_source(const std::uint8_t *bytes,
                                         int32_t length) const {
  // see table for status code
  Byte frame(bytes + 6);
  int32_t x = frame.get_byte(4, 4);
  return x;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(242, 0)" endLine="(247, 1)" clone_start="1" clone_end="6">
			<code function_name="Misc69::ambient_light_status(const std::uint8_t *bytes, int32_t length) const">int32_t Misc69::ambient_light_status(const std::uint8_t *bytes,
                                     int32_t length) const {
  Byte frame(bytes + 1);
  int32_t x = frame.get_byte(0, 3);
  return x;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(123, 0)" endLine="(126, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake61::is_enabled(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_enabled(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(249, 0)" endLine="(253, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_on_pressed(const std::uint8_t *bytes,
                               int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(128, 0)" endLine="(132, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_driver_override(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_driver_override(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(255, 0)" endLine="(259, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_off_pressed(const std::uint8_t *bytes,
                                int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(4);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(134, 0)" endLine="(138, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_driver_activity(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_driver_activity(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(261, 0)" endLine="(265, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_resume_pressed(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(5);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(140, 0)" endLine="(144, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_watchdog_counter_fault(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_watchdog_counter_fault(const std::uint8_t *bytes,
                                        int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(267, 0)" endLine="(271, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_cancel_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_cancel_pressed(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(6);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(146, 0)" endLine="(150, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_channel_1_fault(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_channel_1_fault(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(273, 0)" endLine="(277, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_or_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_on_or_off_pressed(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(0);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(152, 0)" endLine="(156, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_channel_2_fault(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_channel_2_fault(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(279, 0)" endLine="(283, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t *bytes,
                                             int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(1);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(158, 0)" endLine="(162, 1)" clone_start="1" clone_end="5">
			<code function_name="Brake61::is_boo_switch_fault(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_boo_switch_fault(const std::uint8_t *bytes,
                                  int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(285, 0)" endLine="(289, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_61.cc" startLine="(164, 0)" endLine="(168, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake61::is_connector_fault(const std::uint8_t *bytes, int32_t length) const">bool Brake61::is_connector_fault(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 7);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(291, 0)" endLine="(295, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\monitor\hwmonitor\hw\esdcan\esdcan_err_str.cc" startLine="(22, 0)" endLine="(127, 1)" clone_start="5" clone_end="32">
			<code function_name="esdcan_err_to_str(NTCAN_RESULT ntstatus)">const char *esdcan_err_to_str(NTCAN_RESULT ntstatus) {
  switch (ntstatus) {
    case NTCAN_SUCCESS:
      return "NTCAN_SUCCESS";
    case NTCAN_RX_TIMEOUT:
      return "NTCAN_RX_TIMEOUT";
    case NTCAN_TX_TIMEOUT:
      return "NTCAN_TX_TIMEOUT";
    case NTCAN_TX_ERROR:
      return "NTCAN_TX_ERROR";
    case NTCAN_CONTR_OFF_BUS:
      return "NTCAN_CONTR_OFF_BUS";
    case NTCAN_CONTR_BUSY:
      return "NTCAN_CONTR_BUSY";
    case NTCAN_CONTR_WARN:
      return "NTCAN_CONTR_WARN";
    case NTCAN_NO_ID_ENABLED:
      return "NTCAN_NO_ID_ENABLED";
    case NTCAN_ID_ALREADY_ENABLED:
      return "NTCAN_ID_ALREADY_ENABLED";
    case NTCAN_ID_NOT_ENABLED:
      return "NTCAN_ID_NOT_ENABLED";
    case NTCAN_INVALID_FIRMWARE:
      return "NTCAN_INVALID_FIRMWARE";
    case NTCAN_MESSAGE_LOST:
      return "NTCAN_MESSAGE_LOST";
    case NTCAN_INVALID_PARAMETER:
      return "NTCAN_INVALID_PARAMETER";
    case NTCAN_INVALID_HANDLE:
      return "NTCAN_INVALID_HANDLE";
    case NTCAN_NET_NOT_FOUND:
      return "NTCAN_NET_NOT_FOUND";
#ifdef NTCAN_IO_INCOMPLETE
    case NTCAN_IO_INCOMPLETE:
      return "NTCAN_IO_INCOMPLETE";
#endif
#ifdef NTCAN_IO_PENDING
    case NTCAN_IO_PENDING:
      return "NTCAN_IO_PENDING";
#endif
#ifdef NTCAN_INVALID_HARDWARE
    case NTCAN_INVALID_HARDWARE:
      return "NTCAN_INVALID_HARDWARE";
#endif
#ifdef NTCAN_PENDING_WRITE
    case NTCAN_PENDING_WRITE:
      return "NTCAN_PENDING_WRITE";
#endif
#ifdef NTCAN_PENDING_READ
    case NTCAN_PENDING_READ:
      return "NTCAN_PENDING_READ";
#endif
#ifdef NTCAN_INVALID_DRIVER
    case NTCAN_INVALID_DRIVER:
      return "NTCAN_INVALID_DRIVER";
#endif
#ifdef NTCAN_OPERATION_ABORTED
    case NTCAN_OPERATION_ABORTED:
      return "NTCAN_OPERATION_ABORTED";
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
    case NTCAN_WRONG_DEVICE_STATE:
      return "NTCAN_WRONG_DEVICE_STATE";
#endif
    case NTCAN_INSUFFICIENT_RESOURCES:
      return "NTCAN_INSUFFICIENT_RESOURCES";
#ifdef NTCAN_HANDLE_FORCED_CLOSE
    case NTCAN_HANDLE_FORCED_CLOSE:
      return "NTCAN_HANDLE_FORCED_CLOSE";
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
    case NTCAN_NOT_IMPLEMENTED:
      return "NTCAN_NOT_IMPLEMENTED";
#endif
#ifdef NTCAN_NOT_SUPPORTED
    case NTCAN_NOT_SUPPORTED:
      return "NTCAN_NOT_SUPPORTED";
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
    case NTCAN_SOCK_CONN_TIMEOUT:
      return "NTCAN_SOCK_CONN_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
    case NTCAN_SOCK_CMD_TIMEOUT:
      return "NTCAN_SOCK_CMD_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
    case NTCAN_SOCK_HOST_NOT_FOUND:
      return "NTCAN_SOCK_HOST_NOT_FOUND";
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
    case NTCAN_CONTR_ERR_PASSIVE:
      return "NTCAN_CONTR_ERR_PASSIVE";
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
    case NTCAN_ERROR_NO_BAUDRATE:
      return "NTCAN_ERROR_NO_BAUDRATE";
#endif
#ifdef NTCAN_ERROR_LOM
    case NTCAN_ERROR_LOM:
      return "NTCAN_ERROR_LOM";
#endif
    default:
      return "NTCAN_UNKNOWN";
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\monitor\hwmonitor\hw\esdcan\esdcan_err_str.cc" startLine="(22, 0)" endLine="(127, 1)" clone_start="3" clone_end="30">
			<code function_name="esdcan_err_to_str(NTCAN_RESULT ntstatus)">const char *esdcan_err_to_str(NTCAN_RESULT ntstatus) {
  switch (ntstatus) {
    case NTCAN_SUCCESS:
      return "NTCAN_SUCCESS";
    case NTCAN_RX_TIMEOUT:
      return "NTCAN_RX_TIMEOUT";
    case NTCAN_TX_TIMEOUT:
      return "NTCAN_TX_TIMEOUT";
    case NTCAN_TX_ERROR:
      return "NTCAN_TX_ERROR";
    case NTCAN_CONTR_OFF_BUS:
      return "NTCAN_CONTR_OFF_BUS";
    case NTCAN_CONTR_BUSY:
      return "NTCAN_CONTR_BUSY";
    case NTCAN_CONTR_WARN:
      return "NTCAN_CONTR_WARN";
    case NTCAN_NO_ID_ENABLED:
      return "NTCAN_NO_ID_ENABLED";
    case NTCAN_ID_ALREADY_ENABLED:
      return "NTCAN_ID_ALREADY_ENABLED";
    case NTCAN_ID_NOT_ENABLED:
      return "NTCAN_ID_NOT_ENABLED";
    case NTCAN_INVALID_FIRMWARE:
      return "NTCAN_INVALID_FIRMWARE";
    case NTCAN_MESSAGE_LOST:
      return "NTCAN_MESSAGE_LOST";
    case NTCAN_INVALID_PARAMETER:
      return "NTCAN_INVALID_PARAMETER";
    case NTCAN_INVALID_HANDLE:
      return "NTCAN_INVALID_HANDLE";
    case NTCAN_NET_NOT_FOUND:
      return "NTCAN_NET_NOT_FOUND";
#ifdef NTCAN_IO_INCOMPLETE
    case NTCAN_IO_INCOMPLETE:
      return "NTCAN_IO_INCOMPLETE";
#endif
#ifdef NTCAN_IO_PENDING
    case NTCAN_IO_PENDING:
      return "NTCAN_IO_PENDING";
#endif
#ifdef NTCAN_INVALID_HARDWARE
    case NTCAN_INVALID_HARDWARE:
      return "NTCAN_INVALID_HARDWARE";
#endif
#ifdef NTCAN_PENDING_WRITE
    case NTCAN_PENDING_WRITE:
      return "NTCAN_PENDING_WRITE";
#endif
#ifdef NTCAN_PENDING_READ
    case NTCAN_PENDING_READ:
      return "NTCAN_PENDING_READ";
#endif
#ifdef NTCAN_INVALID_DRIVER
    case NTCAN_INVALID_DRIVER:
      return "NTCAN_INVALID_DRIVER";
#endif
#ifdef NTCAN_OPERATION_ABORTED
    case NTCAN_OPERATION_ABORTED:
      return "NTCAN_OPERATION_ABORTED";
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
    case NTCAN_WRONG_DEVICE_STATE:
      return "NTCAN_WRONG_DEVICE_STATE";
#endif
    case NTCAN_INSUFFICIENT_RESOURCES:
      return "NTCAN_INSUFFICIENT_RESOURCES";
#ifdef NTCAN_HANDLE_FORCED_CLOSE
    case NTCAN_HANDLE_FORCED_CLOSE:
      return "NTCAN_HANDLE_FORCED_CLOSE";
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
    case NTCAN_NOT_IMPLEMENTED:
      return "NTCAN_NOT_IMPLEMENTED";
#endif
#ifdef NTCAN_NOT_SUPPORTED
    case NTCAN_NOT_SUPPORTED:
      return "NTCAN_NOT_SUPPORTED";
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
    case NTCAN_SOCK_CONN_TIMEOUT:
      return "NTCAN_SOCK_CONN_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
    case NTCAN_SOCK_CMD_TIMEOUT:
      return "NTCAN_SOCK_CMD_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
    case NTCAN_SOCK_HOST_NOT_FOUND:
      return "NTCAN_SOCK_HOST_NOT_FOUND";
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
    case NTCAN_CONTR_ERR_PASSIVE:
      return "NTCAN_CONTR_ERR_PASSIVE";
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
    case NTCAN_ERROR_NO_BAUDRATE:
      return "NTCAN_ERROR_NO_BAUDRATE";
#endif
#ifdef NTCAN_ERROR_LOM
    case NTCAN_ERROR_LOM:
      return "NTCAN_ERROR_LOM";
#endif
    default:
      return "NTCAN_UNKNOWN";
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\adapters\adapter_manager.cc" startLine="(45, 0)" endLine="(131, 1)" clone_start="38" clone_end="77">
			<code function_name="AdapterManager::Init(const AdapterManagerConfig &amp;configs)">void AdapterManager::Init(const AdapterManagerConfig &amp;configs) {
  instance()-&gt;initialized_ = true;
  if (configs.is_ros()) {
    instance()-&gt;node_handle_.reset(new ros::NodeHandle());
  }

  for (const auto &amp;config : configs.config()) {
    switch (config.type()) {
      case AdapterConfig::POINT_CLOUD:
        EnablePointCloud(FLAGS_pointcloud_topic, config.mode(),
                         config.message_history_limit());
        break;
      case AdapterConfig::GPS:
        EnableGps(FLAGS_gps_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::IMU:
        EnableImu(FLAGS_imu_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS:
        EnableChassis(FLAGS_chassis_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::LOCALIZATION:
        EnableLocalization(FLAGS_localization_topic, config.mode(),
                           config.message_history_limit());
        break;
      case AdapterConfig::PERCEPTION_OBSTACLES:
        EnablePerceptionObstacles(FLAGS_perception_obstacle_topic,
                                  config.mode(),
                                  config.message_history_limit());
        break;
      case AdapterConfig::TRAFFIC_LIGHT_DETECTION:
        EnableTrafficLightDetection(FLAGS_traffic_light_detection_topic,
                                    config.mode(),
                                    config.message_history_limit());
      case AdapterConfig::PAD:
        EnablePad(FLAGS_pad_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CONTROL_COMMAND:
        EnableControlCommand(FLAGS_control_command_topic, config.mode(),
                             config.message_history_limit());
        break;
      case AdapterConfig::ROUTING_REQUEST:
        EnableRoutingRequest(FLAGS_routing_request_topic, config.mode(),
                             config.message_history_limit());
        break;
      case AdapterConfig::ROUTING_RESPONSE:
        EnableRoutingResponse(FLAGS_routing_response_topic, config.mode(),
                              config.message_history_limit());
        break;
      case AdapterConfig::PLANNING_TRAJECTORY:
        EnablePlanning(FLAGS_planning_trajectory_topic, config.mode(),
                       config.message_history_limit());
        break;
      case AdapterConfig::PREDICTION:
        EnablePrediction(FLAGS_prediction_topic, config.mode(),
                         config.message_history_limit());
        break;
      case AdapterConfig::MONITOR:
        EnableMonitor(FLAGS_monitor_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS_DETAIL:
        EnableChassisDetail(FLAGS_chassis_detail_topic, config.mode(),
                            config.message_history_limit());
        break;
      case AdapterConfig::RELATIVE_ODOMETRY:
        EnableRelativeOdometry(FLAGS_relative_odometry_topic, config.mode(),
                               config.message_history_limit());
        break;
      case AdapterConfig::INS_STAT:
        EnableInsStat(FLAGS_ins_stat_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::HMI_COMMAND:
        EnableHMICommand(FLAGS_hmi_command_topic, config.mode(),
                         config.message_history_limit());
        break;
      default:
        AERROR &lt;&lt; "Unknown adapter config type!";
        break;
    }
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\common\adapters\adapter_manager.cc" startLine="(45, 0)" endLine="(131, 1)" clone_start="42" clone_end="81">
			<code function_name="AdapterManager::Init(const AdapterManagerConfig &amp;configs)">void AdapterManager::Init(const AdapterManagerConfig &amp;configs) {
  instance()-&gt;initialized_ = true;
  if (configs.is_ros()) {
    instance()-&gt;node_handle_.reset(new ros::NodeHandle());
  }

  for (const auto &amp;config : configs.config()) {
    switch (config.type()) {
      case AdapterConfig::POINT_CLOUD:
        EnablePointCloud(FLAGS_pointcloud_topic, config.mode(),
                         config.message_history_limit());
        break;
      case AdapterConfig::GPS:
        EnableGps(FLAGS_gps_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::IMU:
        EnableImu(FLAGS_imu_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS:
        EnableChassis(FLAGS_chassis_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::LOCALIZATION:
        EnableLocalization(FLAGS_localization_topic, config.mode(),
                           config.message_history_limit());
        break;
      case AdapterConfig::PERCEPTION_OBSTACLES:
        EnablePerceptionObstacles(FLAGS_perception_obstacle_topic,
                                  config.mode(),
                                  config.message_history_limit());
        break;
      case AdapterConfig::TRAFFIC_LIGHT_DETECTION:
        EnableTrafficLightDetection(FLAGS_traffic_light_detection_topic,
                                    config.mode(),
                                    config.message_history_limit());
      case AdapterConfig::PAD:
        EnablePad(FLAGS_pad_topic, config.mode(),
                  config.message_history_limit());
        break;
      case AdapterConfig::CONTROL_COMMAND:
        EnableControlCommand(FLAGS_control_command_topic, config.mode(),
                             config.message_history_limit());
        break;
      case AdapterConfig::ROUTING_REQUEST:
        EnableRoutingRequest(FLAGS_routing_request_topic, config.mode(),
                             config.message_history_limit());
        break;
      case AdapterConfig::ROUTING_RESPONSE:
        EnableRoutingResponse(FLAGS_routing_response_topic, config.mode(),
                              config.message_history_limit());
        break;
      case AdapterConfig::PLANNING_TRAJECTORY:
        EnablePlanning(FLAGS_planning_trajectory_topic, config.mode(),
                       config.message_history_limit());
        break;
      case AdapterConfig::PREDICTION:
        EnablePrediction(FLAGS_prediction_topic, config.mode(),
                         config.message_history_limit());
        break;
      case AdapterConfig::MONITOR:
        EnableMonitor(FLAGS_monitor_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::CHASSIS_DETAIL:
        EnableChassisDetail(FLAGS_chassis_detail_topic, config.mode(),
                            config.message_history_limit());
        break;
      case AdapterConfig::RELATIVE_ODOMETRY:
        EnableRelativeOdometry(FLAGS_relative_odometry_topic, config.mode(),
                               config.message_history_limit());
        break;
      case AdapterConfig::INS_STAT:
        EnableInsStat(FLAGS_ins_stat_topic, config.mode(),
                      config.message_history_limit());
        break;
      case AdapterConfig::HMI_COMMAND:
        EnableHMICommand(FLAGS_hmi_command_topic, config.mode(),
                         config.message_history_limit());
        break;
      default:
        AERROR &lt;&lt; "Unknown adapter config type!";
        break;
    }
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\map\map_service.cc" startLine="(173, 0)" endLine="(234, 1)" clone_start="5" clone_end="49">
			<code function_name="MapService::RetrieveMapElements(const MapElementIds &amp;ids) const">Map MapService::RetrieveMapElements(const MapElementIds &amp;ids) const {
  Map result;
  Id map_id;

  for (const auto &amp;id : ids.lane) {
    map_id.set_id(id);
    auto element = sim_map_.GetLaneById(map_id);
    if (element) {
      *result.add_lane() = element-&gt;lane();
    }
  }

  for (const auto &amp;id : ids.crosswalk) {
    map_id.set_id(id);
    auto element = sim_map_.GetCrosswalkById(map_id);
    if (element) {
      *result.add_crosswalk() = element-&gt;crosswalk();
    }
  }

  for (const auto &amp;id : ids.junction) {
    map_id.set_id(id);
    auto element = sim_map_.GetJunctionById(map_id);
    if (element) {
      *result.add_junction() = element-&gt;junction();
    }
  }

  for (const auto &amp;id : ids.signal) {
    map_id.set_id(id);
    auto element = sim_map_.GetSignalById(map_id);
    if (element) {
      *result.add_signal() = element-&gt;signal();
    }
  }

  for (const auto &amp;id : ids.stop_sign) {
    map_id.set_id(id);
    auto element = sim_map_.GetStopSignById(map_id);
    if (element) {
      *result.add_stop_sign() = element-&gt;stop_sign();
    }
  }

  for (const auto &amp;id : ids.yield) {
    map_id.set_id(id);
    auto element = sim_map_.GetYieldSignById(map_id);
    if (element) {
      *result.add_yield() = element-&gt;yield_sign();
    }
  }

  for (const auto &amp;id : ids.overlap) {
    map_id.set_id(id);
    auto element = sim_map_.GetOverlapById(map_id);
    if (element) {
      *result.add_overlap() = element-&gt;overlap();
    }
  }

  return result;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\dreamview\backend\map\map_service.cc" startLine="(173, 0)" endLine="(234, 1)" clone_start="13" clone_end="57">
			<code function_name="MapService::RetrieveMapElements(const MapElementIds &amp;ids) const">Map MapService::RetrieveMapElements(const MapElementIds &amp;ids) const {
  Map result;
  Id map_id;

  for (const auto &amp;id : ids.lane) {
    map_id.set_id(id);
    auto element = sim_map_.GetLaneById(map_id);
    if (element) {
      *result.add_lane() = element-&gt;lane();
    }
  }

  for (const auto &amp;id : ids.crosswalk) {
    map_id.set_id(id);
    auto element = sim_map_.GetCrosswalkById(map_id);
    if (element) {
      *result.add_crosswalk() = element-&gt;crosswalk();
    }
  }

  for (const auto &amp;id : ids.junction) {
    map_id.set_id(id);
    auto element = sim_map_.GetJunctionById(map_id);
    if (element) {
      *result.add_junction() = element-&gt;junction();
    }
  }

  for (const auto &amp;id : ids.signal) {
    map_id.set_id(id);
    auto element = sim_map_.GetSignalById(map_id);
    if (element) {
      *result.add_signal() = element-&gt;signal();
    }
  }

  for (const auto &amp;id : ids.stop_sign) {
    map_id.set_id(id);
    auto element = sim_map_.GetStopSignById(map_id);
    if (element) {
      *result.add_stop_sign() = element-&gt;stop_sign();
    }
  }

  for (const auto &amp;id : ids.yield) {
    map_id.set_id(id);
    auto element = sim_map_.GetYieldSignById(map_id);
    if (element) {
      *result.add_yield() = element-&gt;yield_sign();
    }
  }

  for (const auto &amp;id : ids.overlap) {
    map_id.set_id(id);
    auto element = sim_map_.GetOverlapById(map_id);
    if (element) {
      *result.add_overlap() = element-&gt;overlap();
    }
  }

  return result;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(239, 0)" endLine="(374, 1)" clone_start="55" clone_end="106">
			<code function_name="NovatelParser::prepare_message(MessagePtr&amp; message_ptr)">Parser::MessageType NovatelParser::prepare_message(MessagePtr&amp; message_ptr) {
  if (!check_crc()) {
    ROS_ERROR("CRC check failed.");
    return MessageType::NONE;
  }

  uint8_t* message = nullptr;
  novatel::MessageId message_id;
  uint16_t message_length;
  uint16_t gps_week;
  uint32_t gps_millisecs;
  if (_buffer[2] == novatel::SYNC_2_LONG_HEADER) {
    auto header = reinterpret_cast&lt;const novatel::LongHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::LongHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  } else {
    auto header = reinterpret_cast&lt;const novatel::ShortHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::ShortHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  }
  switch (message_id) {
    case novatel::BESTGNSSPOS:
    case novatel::BESTPOS:
    case novatel::PSRPOS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestPos), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestPos)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_pos(reinterpret_cast&lt;novatel::BestPos*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::BESTGNSSVEL:
    case novatel::BESTVEL:
    case novatel::PSRVEL:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestVel), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestVel)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_vel(reinterpret_cast&lt;novatel::BestVel*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::CORRIMUDATA:
    case novatel::CORRIMUDATAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::CorrImuData),
      // "Incorrect message_length");
      if (message_length != sizeof(novatel::CorrImuData)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_corr_imu_data(
              reinterpret_cast&lt;novatel::CorrImuData*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSCOV:
    case novatel::INSCOVS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsCov), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsCov)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_cov(reinterpret_cast&lt;novatel::InsCov*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSPVA:
    case novatel::INSPVAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsPva), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsPva)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_pva(reinterpret_cast&lt;novatel::InsPva*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::RAWIMUX:
    case novatel::RAWIMUSX:
      // ROS_ERROR_COND(message_length != sizeof(novatel::RawImuX), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::RawImuX)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_raw_imu_x(reinterpret_cast&lt;novatel::RawImuX*&gt;(message))) {
        message_ptr = &amp;_imu;
        return MessageType::IMU;
      }
      break;

    case novatel::INSPVAX:
        if (message_length != sizeof(novatel::InsPvaX)) {
          ROS_ERROR("Incorrect message_length");
          break;
        }

        if (handle_ins_pvax(reinterpret_cast&lt;novatel::InsPvaX*&gt;(message))) {
          message_ptr = &amp;_ins_stat;
          return MessageType::INS_STAT;
        }
        break;
    default:
      break;
  }
  return MessageType::NONE;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\drivers\gnss\src\impl\novatel_parser.cpp" startLine="(239, 0)" endLine="(374, 1)" clone_start="71" clone_end="121">
			<code function_name="NovatelParser::prepare_message(MessagePtr&amp; message_ptr)">Parser::MessageType NovatelParser::prepare_message(MessagePtr&amp; message_ptr) {
  if (!check_crc()) {
    ROS_ERROR("CRC check failed.");
    return MessageType::NONE;
  }

  uint8_t* message = nullptr;
  novatel::MessageId message_id;
  uint16_t message_length;
  uint16_t gps_week;
  uint32_t gps_millisecs;
  if (_buffer[2] == novatel::SYNC_2_LONG_HEADER) {
    auto header = reinterpret_cast&lt;const novatel::LongHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::LongHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  } else {
    auto header = reinterpret_cast&lt;const novatel::ShortHeader*&gt;(_buffer.data());
    message = _buffer.data() + sizeof(novatel::ShortHeader);
    gps_week = header-&gt;gps_week;
    gps_millisecs = header-&gt;gps_millisecs;
    message_id = header-&gt;message_id;
    message_length = header-&gt;message_length;
  }
  switch (message_id) {
    case novatel::BESTGNSSPOS:
    case novatel::BESTPOS:
    case novatel::PSRPOS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestPos), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestPos)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_pos(reinterpret_cast&lt;novatel::BestPos*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::BESTGNSSVEL:
    case novatel::BESTVEL:
    case novatel::PSRVEL:
      // ROS_ERROR_COND(message_length != sizeof(novatel::BestVel), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::BestVel)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }
      if (handle_best_vel(reinterpret_cast&lt;novatel::BestVel*&gt;(message),
                          gps_week, gps_millisecs)) {
        message_ptr = &amp;_gnss;
        return MessageType::GNSS;
      }
      break;

    case novatel::CORRIMUDATA:
    case novatel::CORRIMUDATAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::CorrImuData),
      // "Incorrect message_length");
      if (message_length != sizeof(novatel::CorrImuData)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_corr_imu_data(
              reinterpret_cast&lt;novatel::CorrImuData*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSCOV:
    case novatel::INSCOVS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsCov), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsCov)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_cov(reinterpret_cast&lt;novatel::InsCov*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::INSPVA:
    case novatel::INSPVAS:
      // ROS_ERROR_COND(message_length != sizeof(novatel::InsPva), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::InsPva)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_ins_pva(reinterpret_cast&lt;novatel::InsPva*&gt;(message))) {
        message_ptr = &amp;_ins;
        return MessageType::INS;
      }
      break;

    case novatel::RAWIMUX:
    case novatel::RAWIMUSX:
      // ROS_ERROR_COND(message_length != sizeof(novatel::RawImuX), "Incorrect
      // message_length");
      if (message_length != sizeof(novatel::RawImuX)) {
        ROS_ERROR("Incorrect message_length");
        break;
      }

      if (handle_raw_imu_x(reinterpret_cast&lt;novatel::RawImuX*&gt;(message))) {
        message_ptr = &amp;_imu;
        return MessageType::IMU;
      }
      break;

    case novatel::INSPVAX:
        if (message_length != sizeof(novatel::InsPvaX)) {
          ROS_ERROR("Incorrect message_length");
          break;
        }

        if (handle_ins_pvax(reinterpret_cast&lt;novatel::InsPvaX*&gt;(message))) {
          message_ptr = &amp;_ins_stat;
          return MessageType::INS_STAT;
        }
        break;
    default:
      break;
  }
  return MessageType::NONE;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\track_object_distance.cc" startLine="(44, 0)" endLine="(54, 1)" clone_start="1" clone_end="11">
			<code function_name="TrackObjectDistance::SetDirectionDistanceWeight( const float&amp; direction_distance_weight)">bool TrackObjectDistance::SetDirectionDistanceWeight(
  const float&amp; direction_distance_weight) {
  if (direction_distance_weight &gt;= 0) {
    s_direction_distance_weight_ = direction_distance_weight;
    AINFO &lt;&lt; "direction distance weight of TrackObjectDistance is "
          &lt;&lt; s_direction_distance_weight_;
    return true;
  }
  AERROR &lt;&lt; "invalid direction distance weight of TrackObjectDistance!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\track_object_distance.cc" startLine="(32, 0)" endLine="(42, 1)" clone_start="1" clone_end="11">
			<code function_name="TrackObjectDistance::SetLocationDistanceWeight( const float&amp; location_distance_weight)">bool TrackObjectDistance::SetLocationDistanceWeight(
  const float&amp; location_distance_weight) {
  if (location_distance_weight &gt;= 0) {
    s_location_distance_weight_ = location_distance_weight;
    AINFO &lt;&lt; "location distance weight of TrackObjectDistance is "
          &lt;&lt; s_location_distance_weight_;
    return true;
  }
  AERROR &lt;&lt; "invalid location distance weight of TrackeObjectDistance!";
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\track_object_distance.cc" startLine="(56, 0)" endLine="(66, 1)" clone_start="1" clone_end="11">
			<code function_name="TrackObjectDistance::SetBboxSizeDistanceWeight( const float&amp; bbox_size_distance_weight)">bool TrackObjectDistance::SetBboxSizeDistanceWeight(
  const float&amp; bbox_size_distance_weight) {
  if (bbox_size_distance_weight &gt;= 0) {
    s_bbox_size_distance_weight_ = bbox_size_distance_weight;
    AINFO &lt;&lt; "bbox size distance weight of TrackObjectDistance is "
          &lt;&lt; s_bbox_size_distance_weight_;
    return true;
  }
  AERROR &lt;&lt; "invalid bbox size distance weight of TrackObjectDistance!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\track_object_distance.cc" startLine="(44, 0)" endLine="(54, 1)" clone_start="1" clone_end="11">
			<code function_name="TrackObjectDistance::SetDirectionDistanceWeight( const float&amp; direction_distance_weight)">bool TrackObjectDistance::SetDirectionDistanceWeight(
  const float&amp; direction_distance_weight) {
  if (direction_distance_weight &gt;= 0) {
    s_direction_distance_weight_ = direction_distance_weight;
    AINFO &lt;&lt; "direction distance weight of TrackObjectDistance is "
          &lt;&lt; s_direction_distance_weight_;
    return true;
  }
  AERROR &lt;&lt; "invalid direction distance weight of TrackObjectDistance!";
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\track_object_distance.cc" startLine="(68, 0)" endLine="(78, 1)" clone_start="1" clone_end="11">
			<code function_name="TrackObjectDistance::SetPointNumDistanceWeight( const float&amp; point_num_distance_weight)">bool TrackObjectDistance::SetPointNumDistanceWeight(
  const float&amp; point_num_distance_weight) {
  if (point_num_distance_weight &gt;= 0) {
    s_point_num_distance_weight_ = point_num_distance_weight;
    AINFO &lt;&lt; "point num distance weight of TrackObjectDistance is "
          &lt;&lt; s_point_num_distance_weight_;
    return true;
  }
  AERROR &lt;&lt; "invalid point num distance weight of TrackObjectDistance!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\track_object_distance.cc" startLine="(56, 0)" endLine="(66, 1)" clone_start="1" clone_end="11">
			<code function_name="TrackObjectDistance::SetBboxSizeDistanceWeight( const float&amp; bbox_size_distance_weight)">bool TrackObjectDistance::SetBboxSizeDistanceWeight(
  const float&amp; bbox_size_distance_weight) {
  if (bbox_size_distance_weight &gt;= 0) {
    s_bbox_size_distance_weight_ = bbox_size_distance_weight;
    AINFO &lt;&lt; "bbox size distance weight of TrackObjectDistance is "
          &lt;&lt; s_bbox_size_distance_weight_;
    return true;
  }
  AERROR &lt;&lt; "invalid bbox size distance weight of TrackObjectDistance!";
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\track_object_distance.cc" startLine="(80, 0)" endLine="(90, 1)" clone_start="1" clone_end="10">
			<code function_name="TrackObjectDistance::SetHistogramDistanceWeight( const float&amp; histogram_distance_weight)">bool TrackObjectDistance::SetHistogramDistanceWeight(
  const float&amp; histogram_distance_weight) {
  if (histogram_distance_weight &gt;= 0) {
    s_histogram_distance_weight_ = histogram_distance_weight;
    AINFO &lt;&lt; "histogram distance weight of TrackObjectDistance is "
          &lt;&lt; s_histogram_distance_weight_;
    return true;
  }
  AERROR &lt;&lt; "invalid histogram distance weight of TrackObjectDistance!";
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\tracker\hm_tracker\track_object_distance.cc" startLine="(68, 0)" endLine="(78, 1)" clone_start="1" clone_end="10">
			<code function_name="TrackObjectDistance::SetPointNumDistanceWeight( const float&amp; point_num_distance_weight)">bool TrackObjectDistance::SetPointNumDistanceWeight(
  const float&amp; point_num_distance_weight) {
  if (point_num_distance_weight &gt;= 0) {
    s_point_num_distance_weight_ = point_num_distance_weight;
    AINFO &lt;&lt; "point num distance weight of TrackObjectDistance is "
          &lt;&lt; s_point_num_distance_weight_;
    return true;
  }
  AERROR &lt;&lt; "invalid point num distance weight of TrackObjectDistance!";
  return false;
}</code>
		</source>
	</dup>
	<dup count="3">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\monitor\hwmonitor\hw\esdcan\esdcan_err_str.cc" startLine="(22, 0)" endLine="(127, 1)" clone_start="71" clone_end="102">
			<code function_name="esdcan_err_to_str(NTCAN_RESULT ntstatus)">const char *esdcan_err_to_str(NTCAN_RESULT ntstatus) {
  switch (ntstatus) {
    case NTCAN_SUCCESS:
      return "NTCAN_SUCCESS";
    case NTCAN_RX_TIMEOUT:
      return "NTCAN_RX_TIMEOUT";
    case NTCAN_TX_TIMEOUT:
      return "NTCAN_TX_TIMEOUT";
    case NTCAN_TX_ERROR:
      return "NTCAN_TX_ERROR";
    case NTCAN_CONTR_OFF_BUS:
      return "NTCAN_CONTR_OFF_BUS";
    case NTCAN_CONTR_BUSY:
      return "NTCAN_CONTR_BUSY";
    case NTCAN_CONTR_WARN:
      return "NTCAN_CONTR_WARN";
    case NTCAN_NO_ID_ENABLED:
      return "NTCAN_NO_ID_ENABLED";
    case NTCAN_ID_ALREADY_ENABLED:
      return "NTCAN_ID_ALREADY_ENABLED";
    case NTCAN_ID_NOT_ENABLED:
      return "NTCAN_ID_NOT_ENABLED";
    case NTCAN_INVALID_FIRMWARE:
      return "NTCAN_INVALID_FIRMWARE";
    case NTCAN_MESSAGE_LOST:
      return "NTCAN_MESSAGE_LOST";
    case NTCAN_INVALID_PARAMETER:
      return "NTCAN_INVALID_PARAMETER";
    case NTCAN_INVALID_HANDLE:
      return "NTCAN_INVALID_HANDLE";
    case NTCAN_NET_NOT_FOUND:
      return "NTCAN_NET_NOT_FOUND";
#ifdef NTCAN_IO_INCOMPLETE
    case NTCAN_IO_INCOMPLETE:
      return "NTCAN_IO_INCOMPLETE";
#endif
#ifdef NTCAN_IO_PENDING
    case NTCAN_IO_PENDING:
      return "NTCAN_IO_PENDING";
#endif
#ifdef NTCAN_INVALID_HARDWARE
    case NTCAN_INVALID_HARDWARE:
      return "NTCAN_INVALID_HARDWARE";
#endif
#ifdef NTCAN_PENDING_WRITE
    case NTCAN_PENDING_WRITE:
      return "NTCAN_PENDING_WRITE";
#endif
#ifdef NTCAN_PENDING_READ
    case NTCAN_PENDING_READ:
      return "NTCAN_PENDING_READ";
#endif
#ifdef NTCAN_INVALID_DRIVER
    case NTCAN_INVALID_DRIVER:
      return "NTCAN_INVALID_DRIVER";
#endif
#ifdef NTCAN_OPERATION_ABORTED
    case NTCAN_OPERATION_ABORTED:
      return "NTCAN_OPERATION_ABORTED";
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
    case NTCAN_WRONG_DEVICE_STATE:
      return "NTCAN_WRONG_DEVICE_STATE";
#endif
    case NTCAN_INSUFFICIENT_RESOURCES:
      return "NTCAN_INSUFFICIENT_RESOURCES";
#ifdef NTCAN_HANDLE_FORCED_CLOSE
    case NTCAN_HANDLE_FORCED_CLOSE:
      return "NTCAN_HANDLE_FORCED_CLOSE";
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
    case NTCAN_NOT_IMPLEMENTED:
      return "NTCAN_NOT_IMPLEMENTED";
#endif
#ifdef NTCAN_NOT_SUPPORTED
    case NTCAN_NOT_SUPPORTED:
      return "NTCAN_NOT_SUPPORTED";
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
    case NTCAN_SOCK_CONN_TIMEOUT:
      return "NTCAN_SOCK_CONN_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
    case NTCAN_SOCK_CMD_TIMEOUT:
      return "NTCAN_SOCK_CMD_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
    case NTCAN_SOCK_HOST_NOT_FOUND:
      return "NTCAN_SOCK_HOST_NOT_FOUND";
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
    case NTCAN_CONTR_ERR_PASSIVE:
      return "NTCAN_CONTR_ERR_PASSIVE";
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
    case NTCAN_ERROR_NO_BAUDRATE:
      return "NTCAN_ERROR_NO_BAUDRATE";
#endif
#ifdef NTCAN_ERROR_LOM
    case NTCAN_ERROR_LOM:
      return "NTCAN_ERROR_LOM";
#endif
    default:
      return "NTCAN_UNKNOWN";
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\monitor\hwmonitor\hw\esdcan\esdcan_err_str.cc" startLine="(22, 0)" endLine="(127, 1)" clone_start="67" clone_end="98">
			<code function_name="esdcan_err_to_str(NTCAN_RESULT ntstatus)">const char *esdcan_err_to_str(NTCAN_RESULT ntstatus) {
  switch (ntstatus) {
    case NTCAN_SUCCESS:
      return "NTCAN_SUCCESS";
    case NTCAN_RX_TIMEOUT:
      return "NTCAN_RX_TIMEOUT";
    case NTCAN_TX_TIMEOUT:
      return "NTCAN_TX_TIMEOUT";
    case NTCAN_TX_ERROR:
      return "NTCAN_TX_ERROR";
    case NTCAN_CONTR_OFF_BUS:
      return "NTCAN_CONTR_OFF_BUS";
    case NTCAN_CONTR_BUSY:
      return "NTCAN_CONTR_BUSY";
    case NTCAN_CONTR_WARN:
      return "NTCAN_CONTR_WARN";
    case NTCAN_NO_ID_ENABLED:
      return "NTCAN_NO_ID_ENABLED";
    case NTCAN_ID_ALREADY_ENABLED:
      return "NTCAN_ID_ALREADY_ENABLED";
    case NTCAN_ID_NOT_ENABLED:
      return "NTCAN_ID_NOT_ENABLED";
    case NTCAN_INVALID_FIRMWARE:
      return "NTCAN_INVALID_FIRMWARE";
    case NTCAN_MESSAGE_LOST:
      return "NTCAN_MESSAGE_LOST";
    case NTCAN_INVALID_PARAMETER:
      return "NTCAN_INVALID_PARAMETER";
    case NTCAN_INVALID_HANDLE:
      return "NTCAN_INVALID_HANDLE";
    case NTCAN_NET_NOT_FOUND:
      return "NTCAN_NET_NOT_FOUND";
#ifdef NTCAN_IO_INCOMPLETE
    case NTCAN_IO_INCOMPLETE:
      return "NTCAN_IO_INCOMPLETE";
#endif
#ifdef NTCAN_IO_PENDING
    case NTCAN_IO_PENDING:
      return "NTCAN_IO_PENDING";
#endif
#ifdef NTCAN_INVALID_HARDWARE
    case NTCAN_INVALID_HARDWARE:
      return "NTCAN_INVALID_HARDWARE";
#endif
#ifdef NTCAN_PENDING_WRITE
    case NTCAN_PENDING_WRITE:
      return "NTCAN_PENDING_WRITE";
#endif
#ifdef NTCAN_PENDING_READ
    case NTCAN_PENDING_READ:
      return "NTCAN_PENDING_READ";
#endif
#ifdef NTCAN_INVALID_DRIVER
    case NTCAN_INVALID_DRIVER:
      return "NTCAN_INVALID_DRIVER";
#endif
#ifdef NTCAN_OPERATION_ABORTED
    case NTCAN_OPERATION_ABORTED:
      return "NTCAN_OPERATION_ABORTED";
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
    case NTCAN_WRONG_DEVICE_STATE:
      return "NTCAN_WRONG_DEVICE_STATE";
#endif
    case NTCAN_INSUFFICIENT_RESOURCES:
      return "NTCAN_INSUFFICIENT_RESOURCES";
#ifdef NTCAN_HANDLE_FORCED_CLOSE
    case NTCAN_HANDLE_FORCED_CLOSE:
      return "NTCAN_HANDLE_FORCED_CLOSE";
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
    case NTCAN_NOT_IMPLEMENTED:
      return "NTCAN_NOT_IMPLEMENTED";
#endif
#ifdef NTCAN_NOT_SUPPORTED
    case NTCAN_NOT_SUPPORTED:
      return "NTCAN_NOT_SUPPORTED";
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
    case NTCAN_SOCK_CONN_TIMEOUT:
      return "NTCAN_SOCK_CONN_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
    case NTCAN_SOCK_CMD_TIMEOUT:
      return "NTCAN_SOCK_CMD_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
    case NTCAN_SOCK_HOST_NOT_FOUND:
      return "NTCAN_SOCK_HOST_NOT_FOUND";
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
    case NTCAN_CONTR_ERR_PASSIVE:
      return "NTCAN_CONTR_ERR_PASSIVE";
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
    case NTCAN_ERROR_NO_BAUDRATE:
      return "NTCAN_ERROR_NO_BAUDRATE";
#endif
#ifdef NTCAN_ERROR_LOM
    case NTCAN_ERROR_LOM:
      return "NTCAN_ERROR_LOM";
#endif
    default:
      return "NTCAN_UNKNOWN";
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\monitor\hwmonitor\hw\esdcan\esdcan_err_str.cc" startLine="(22, 0)" endLine="(127, 1)" clone_start="33" clone_end="64">
			<code function_name="esdcan_err_to_str(NTCAN_RESULT ntstatus)">const char *esdcan_err_to_str(NTCAN_RESULT ntstatus) {
  switch (ntstatus) {
    case NTCAN_SUCCESS:
      return "NTCAN_SUCCESS";
    case NTCAN_RX_TIMEOUT:
      return "NTCAN_RX_TIMEOUT";
    case NTCAN_TX_TIMEOUT:
      return "NTCAN_TX_TIMEOUT";
    case NTCAN_TX_ERROR:
      return "NTCAN_TX_ERROR";
    case NTCAN_CONTR_OFF_BUS:
      return "NTCAN_CONTR_OFF_BUS";
    case NTCAN_CONTR_BUSY:
      return "NTCAN_CONTR_BUSY";
    case NTCAN_CONTR_WARN:
      return "NTCAN_CONTR_WARN";
    case NTCAN_NO_ID_ENABLED:
      return "NTCAN_NO_ID_ENABLED";
    case NTCAN_ID_ALREADY_ENABLED:
      return "NTCAN_ID_ALREADY_ENABLED";
    case NTCAN_ID_NOT_ENABLED:
      return "NTCAN_ID_NOT_ENABLED";
    case NTCAN_INVALID_FIRMWARE:
      return "NTCAN_INVALID_FIRMWARE";
    case NTCAN_MESSAGE_LOST:
      return "NTCAN_MESSAGE_LOST";
    case NTCAN_INVALID_PARAMETER:
      return "NTCAN_INVALID_PARAMETER";
    case NTCAN_INVALID_HANDLE:
      return "NTCAN_INVALID_HANDLE";
    case NTCAN_NET_NOT_FOUND:
      return "NTCAN_NET_NOT_FOUND";
#ifdef NTCAN_IO_INCOMPLETE
    case NTCAN_IO_INCOMPLETE:
      return "NTCAN_IO_INCOMPLETE";
#endif
#ifdef NTCAN_IO_PENDING
    case NTCAN_IO_PENDING:
      return "NTCAN_IO_PENDING";
#endif
#ifdef NTCAN_INVALID_HARDWARE
    case NTCAN_INVALID_HARDWARE:
      return "NTCAN_INVALID_HARDWARE";
#endif
#ifdef NTCAN_PENDING_WRITE
    case NTCAN_PENDING_WRITE:
      return "NTCAN_PENDING_WRITE";
#endif
#ifdef NTCAN_PENDING_READ
    case NTCAN_PENDING_READ:
      return "NTCAN_PENDING_READ";
#endif
#ifdef NTCAN_INVALID_DRIVER
    case NTCAN_INVALID_DRIVER:
      return "NTCAN_INVALID_DRIVER";
#endif
#ifdef NTCAN_OPERATION_ABORTED
    case NTCAN_OPERATION_ABORTED:
      return "NTCAN_OPERATION_ABORTED";
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
    case NTCAN_WRONG_DEVICE_STATE:
      return "NTCAN_WRONG_DEVICE_STATE";
#endif
    case NTCAN_INSUFFICIENT_RESOURCES:
      return "NTCAN_INSUFFICIENT_RESOURCES";
#ifdef NTCAN_HANDLE_FORCED_CLOSE
    case NTCAN_HANDLE_FORCED_CLOSE:
      return "NTCAN_HANDLE_FORCED_CLOSE";
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
    case NTCAN_NOT_IMPLEMENTED:
      return "NTCAN_NOT_IMPLEMENTED";
#endif
#ifdef NTCAN_NOT_SUPPORTED
    case NTCAN_NOT_SUPPORTED:
      return "NTCAN_NOT_SUPPORTED";
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
    case NTCAN_SOCK_CONN_TIMEOUT:
      return "NTCAN_SOCK_CONN_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
    case NTCAN_SOCK_CMD_TIMEOUT:
      return "NTCAN_SOCK_CMD_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
    case NTCAN_SOCK_HOST_NOT_FOUND:
      return "NTCAN_SOCK_HOST_NOT_FOUND";
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
    case NTCAN_CONTR_ERR_PASSIVE:
      return "NTCAN_CONTR_ERR_PASSIVE";
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
    case NTCAN_ERROR_NO_BAUDRATE:
      return "NTCAN_ERROR_NO_BAUDRATE";
#endif
#ifdef NTCAN_ERROR_LOM
    case NTCAN_ERROR_LOM:
      return "NTCAN_ERROR_LOM";
#endif
    default:
      return "NTCAN_UNKNOWN";
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\monitor\hwmonitor\hw\esdcan\esdcan_err_str.cc" startLine="(22, 0)" endLine="(127, 1)" clone_start="65" clone_end="98">
			<code function_name="esdcan_err_to_str(NTCAN_RESULT ntstatus)">const char *esdcan_err_to_str(NTCAN_RESULT ntstatus) {
  switch (ntstatus) {
    case NTCAN_SUCCESS:
      return "NTCAN_SUCCESS";
    case NTCAN_RX_TIMEOUT:
      return "NTCAN_RX_TIMEOUT";
    case NTCAN_TX_TIMEOUT:
      return "NTCAN_TX_TIMEOUT";
    case NTCAN_TX_ERROR:
      return "NTCAN_TX_ERROR";
    case NTCAN_CONTR_OFF_BUS:
      return "NTCAN_CONTR_OFF_BUS";
    case NTCAN_CONTR_BUSY:
      return "NTCAN_CONTR_BUSY";
    case NTCAN_CONTR_WARN:
      return "NTCAN_CONTR_WARN";
    case NTCAN_NO_ID_ENABLED:
      return "NTCAN_NO_ID_ENABLED";
    case NTCAN_ID_ALREADY_ENABLED:
      return "NTCAN_ID_ALREADY_ENABLED";
    case NTCAN_ID_NOT_ENABLED:
      return "NTCAN_ID_NOT_ENABLED";
    case NTCAN_INVALID_FIRMWARE:
      return "NTCAN_INVALID_FIRMWARE";
    case NTCAN_MESSAGE_LOST:
      return "NTCAN_MESSAGE_LOST";
    case NTCAN_INVALID_PARAMETER:
      return "NTCAN_INVALID_PARAMETER";
    case NTCAN_INVALID_HANDLE:
      return "NTCAN_INVALID_HANDLE";
    case NTCAN_NET_NOT_FOUND:
      return "NTCAN_NET_NOT_FOUND";
#ifdef NTCAN_IO_INCOMPLETE
    case NTCAN_IO_INCOMPLETE:
      return "NTCAN_IO_INCOMPLETE";
#endif
#ifdef NTCAN_IO_PENDING
    case NTCAN_IO_PENDING:
      return "NTCAN_IO_PENDING";
#endif
#ifdef NTCAN_INVALID_HARDWARE
    case NTCAN_INVALID_HARDWARE:
      return "NTCAN_INVALID_HARDWARE";
#endif
#ifdef NTCAN_PENDING_WRITE
    case NTCAN_PENDING_WRITE:
      return "NTCAN_PENDING_WRITE";
#endif
#ifdef NTCAN_PENDING_READ
    case NTCAN_PENDING_READ:
      return "NTCAN_PENDING_READ";
#endif
#ifdef NTCAN_INVALID_DRIVER
    case NTCAN_INVALID_DRIVER:
      return "NTCAN_INVALID_DRIVER";
#endif
#ifdef NTCAN_OPERATION_ABORTED
    case NTCAN_OPERATION_ABORTED:
      return "NTCAN_OPERATION_ABORTED";
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
    case NTCAN_WRONG_DEVICE_STATE:
      return "NTCAN_WRONG_DEVICE_STATE";
#endif
    case NTCAN_INSUFFICIENT_RESOURCES:
      return "NTCAN_INSUFFICIENT_RESOURCES";
#ifdef NTCAN_HANDLE_FORCED_CLOSE
    case NTCAN_HANDLE_FORCED_CLOSE:
      return "NTCAN_HANDLE_FORCED_CLOSE";
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
    case NTCAN_NOT_IMPLEMENTED:
      return "NTCAN_NOT_IMPLEMENTED";
#endif
#ifdef NTCAN_NOT_SUPPORTED
    case NTCAN_NOT_SUPPORTED:
      return "NTCAN_NOT_SUPPORTED";
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
    case NTCAN_SOCK_CONN_TIMEOUT:
      return "NTCAN_SOCK_CONN_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
    case NTCAN_SOCK_CMD_TIMEOUT:
      return "NTCAN_SOCK_CMD_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
    case NTCAN_SOCK_HOST_NOT_FOUND:
      return "NTCAN_SOCK_HOST_NOT_FOUND";
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
    case NTCAN_CONTR_ERR_PASSIVE:
      return "NTCAN_CONTR_ERR_PASSIVE";
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
    case NTCAN_ERROR_NO_BAUDRATE:
      return "NTCAN_ERROR_NO_BAUDRATE";
#endif
#ifdef NTCAN_ERROR_LOM
    case NTCAN_ERROR_LOM:
      return "NTCAN_ERROR_LOM";
#endif
    default:
      return "NTCAN_UNKNOWN";
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\monitor\hwmonitor\hw\esdcan\esdcan_err_str.cc" startLine="(22, 0)" endLine="(127, 1)" clone_start="31" clone_end="64">
			<code function_name="esdcan_err_to_str(NTCAN_RESULT ntstatus)">const char *esdcan_err_to_str(NTCAN_RESULT ntstatus) {
  switch (ntstatus) {
    case NTCAN_SUCCESS:
      return "NTCAN_SUCCESS";
    case NTCAN_RX_TIMEOUT:
      return "NTCAN_RX_TIMEOUT";
    case NTCAN_TX_TIMEOUT:
      return "NTCAN_TX_TIMEOUT";
    case NTCAN_TX_ERROR:
      return "NTCAN_TX_ERROR";
    case NTCAN_CONTR_OFF_BUS:
      return "NTCAN_CONTR_OFF_BUS";
    case NTCAN_CONTR_BUSY:
      return "NTCAN_CONTR_BUSY";
    case NTCAN_CONTR_WARN:
      return "NTCAN_CONTR_WARN";
    case NTCAN_NO_ID_ENABLED:
      return "NTCAN_NO_ID_ENABLED";
    case NTCAN_ID_ALREADY_ENABLED:
      return "NTCAN_ID_ALREADY_ENABLED";
    case NTCAN_ID_NOT_ENABLED:
      return "NTCAN_ID_NOT_ENABLED";
    case NTCAN_INVALID_FIRMWARE:
      return "NTCAN_INVALID_FIRMWARE";
    case NTCAN_MESSAGE_LOST:
      return "NTCAN_MESSAGE_LOST";
    case NTCAN_INVALID_PARAMETER:
      return "NTCAN_INVALID_PARAMETER";
    case NTCAN_INVALID_HANDLE:
      return "NTCAN_INVALID_HANDLE";
    case NTCAN_NET_NOT_FOUND:
      return "NTCAN_NET_NOT_FOUND";
#ifdef NTCAN_IO_INCOMPLETE
    case NTCAN_IO_INCOMPLETE:
      return "NTCAN_IO_INCOMPLETE";
#endif
#ifdef NTCAN_IO_PENDING
    case NTCAN_IO_PENDING:
      return "NTCAN_IO_PENDING";
#endif
#ifdef NTCAN_INVALID_HARDWARE
    case NTCAN_INVALID_HARDWARE:
      return "NTCAN_INVALID_HARDWARE";
#endif
#ifdef NTCAN_PENDING_WRITE
    case NTCAN_PENDING_WRITE:
      return "NTCAN_PENDING_WRITE";
#endif
#ifdef NTCAN_PENDING_READ
    case NTCAN_PENDING_READ:
      return "NTCAN_PENDING_READ";
#endif
#ifdef NTCAN_INVALID_DRIVER
    case NTCAN_INVALID_DRIVER:
      return "NTCAN_INVALID_DRIVER";
#endif
#ifdef NTCAN_OPERATION_ABORTED
    case NTCAN_OPERATION_ABORTED:
      return "NTCAN_OPERATION_ABORTED";
#endif
#ifdef NTCAN_WRONG_DEVICE_STATE
    case NTCAN_WRONG_DEVICE_STATE:
      return "NTCAN_WRONG_DEVICE_STATE";
#endif
    case NTCAN_INSUFFICIENT_RESOURCES:
      return "NTCAN_INSUFFICIENT_RESOURCES";
#ifdef NTCAN_HANDLE_FORCED_CLOSE
    case NTCAN_HANDLE_FORCED_CLOSE:
      return "NTCAN_HANDLE_FORCED_CLOSE";
#endif
#ifdef NTCAN_NOT_IMPLEMENTED
    case NTCAN_NOT_IMPLEMENTED:
      return "NTCAN_NOT_IMPLEMENTED";
#endif
#ifdef NTCAN_NOT_SUPPORTED
    case NTCAN_NOT_SUPPORTED:
      return "NTCAN_NOT_SUPPORTED";
#endif
#ifdef NTCAN_SOCK_CONN_TIMEOUT
    case NTCAN_SOCK_CONN_TIMEOUT:
      return "NTCAN_SOCK_CONN_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_CMD_TIMEOUT
    case NTCAN_SOCK_CMD_TIMEOUT:
      return "NTCAN_SOCK_CMD_TIMEOUT";
#endif
#ifdef NTCAN_SOCK_HOST_NOT_FOUND
    case NTCAN_SOCK_HOST_NOT_FOUND:
      return "NTCAN_SOCK_HOST_NOT_FOUND";
#endif
#ifdef NTCAN_CONTR_ERR_PASSIVE
    case NTCAN_CONTR_ERR_PASSIVE:
      return "NTCAN_CONTR_ERR_PASSIVE";
#endif
#ifdef NTCAN_ERROR_NO_BAUDRATE
    case NTCAN_ERROR_NO_BAUDRATE:
      return "NTCAN_ERROR_NO_BAUDRATE";
#endif
#ifdef NTCAN_ERROR_LOM
    case NTCAN_ERROR_LOM:
      return "NTCAN_ERROR_LOM";
#endif
    default:
      return "NTCAN_UNKNOWN";
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(46, 0)" endLine="(52, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline2d::x(const double t) const">double Spline2d::x(const double t) const {
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = find_index(t);
  return splines_[index].x(t - t_knots_[index]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(54, 0)" endLine="(60, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline2d::y(const double t) const">double Spline2d::y(const double t) const {
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = find_index(t);
  return splines_[index].y(t - t_knots_[index]);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(54, 0)" endLine="(60, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline2d::y(const double t) const">double Spline2d::y(const double t) const {
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = find_index(t);
  return splines_[index].y(t - t_knots_[index]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(62, 0)" endLine="(69, 1)" clone_start="1" clone_end="8">
			<code function_name="Spline2d::DerivativeX(const double t) const">double Spline2d::DerivativeX(const double t) const {
  // zero order spline
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = find_index(t);
  return splines_[index].DerivativeX(t - t_knots_[index]);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(62, 0)" endLine="(69, 1)" clone_start="1" clone_end="8">
			<code function_name="Spline2d::DerivativeX(const double t) const">double Spline2d::DerivativeX(const double t) const {
  // zero order spline
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = find_index(t);
  return splines_[index].DerivativeX(t - t_knots_[index]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(71, 0)" endLine="(78, 1)" clone_start="1" clone_end="8">
			<code function_name="Spline2d::derivative_y(const double t) const">double Spline2d::derivative_y(const double t) const {
  // zero order spline
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = find_index(t);
  return splines_[index].derivative_y(t - t_knots_[index]);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(71, 0)" endLine="(78, 1)" clone_start="1" clone_end="8">
			<code function_name="Spline2d::derivative_y(const double t) const">double Spline2d::derivative_y(const double t) const {
  // zero order spline
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = find_index(t);
  return splines_[index].derivative_y(t - t_knots_[index]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(80, 0)" endLine="(86, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline2d::SecondDerivativeX(const double t) const">double Spline2d::SecondDerivativeX(const double t) const {
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = find_index(t);
  return splines_[index].SecondDerivativeX(t - t_knots_[index]);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(80, 0)" endLine="(86, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline2d::SecondDerivativeX(const double t) const">double Spline2d::SecondDerivativeX(const double t) const {
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = find_index(t);
  return splines_[index].SecondDerivativeX(t - t_knots_[index]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(88, 0)" endLine="(94, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline2d::second_derivative_y(const double t) const">double Spline2d::second_derivative_y(const double t) const {
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = find_index(t);
  return splines_[index].second_derivative_y(t - t_knots_[index]);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(88, 0)" endLine="(94, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline2d::second_derivative_y(const double t) const">double Spline2d::second_derivative_y(const double t) const {
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = find_index(t);
  return splines_[index].second_derivative_y(t - t_knots_[index]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(96, 0)" endLine="(102, 1)" clone_start="1" clone_end="7">
			<code function_name="Spline2d::ThirdDerivativeX(const double t) const">double Spline2d::ThirdDerivativeX(const double t) const {
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = find_index(t);
  return splines_[index].ThirdDerivativeX(t - t_knots_[index]);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(96, 0)" endLine="(102, 1)" clone_start="1" clone_end="6">
			<code function_name="Spline2d::ThirdDerivativeX(const double t) const">double Spline2d::ThirdDerivativeX(const double t) const {
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = find_index(t);
  return splines_[index].ThirdDerivativeX(t - t_knots_[index]);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d.cc" startLine="(104, 0)" endLine="(110, 1)" clone_start="1" clone_end="6">
			<code function_name="Spline2d::third_derivative_y(const double t) const">double Spline2d::third_derivative_y(const double t) const {
  if (splines_.size() == 0) {
    return 0.0;
  }
  std::uint32_t index = find_index(t);
  return splines_[index].third_derivative_y(t - t_knots_[index]);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\glfw_viewer.cc" startLine="(520, 0)" endLine="(568, 1)" clone_start="3" clone_end="37">
			<code function_name="GLFWViewer::GetClassColor(int cls, float rgb[3])">void GLFWViewer::GetClassColor(int cls, float rgb[3]) {
  switch (cls) {
    case 0:
      rgb[0] = 0.5;
      rgb[1] = 0;
      rgb[2] = 1;  // purple
      break;
    case 1:
      rgb[0] = 0;
      rgb[1] = 1;
      rgb[2] = 1;  // cryan
      break;
    case 2:
      rgb[0] = 1;
      rgb[1] = 1;
      rgb[2] = 0;  // yellow
      break;
    case 3:
      rgb[0] = 1;
      rgb[1] = 0.5;
      rgb[2] = 0.5;  // red
      break;
    case 4:
      rgb[0] = 0;
      rgb[1] = 0;
      rgb[2] = 1;  // blue
      break;
    case 5:
      rgb[0] = 0;
      rgb[1] = 1;
      rgb[2] = 0;  // green
      break;
    case 6:
      rgb[0] = 1;
      rgb[1] = 0.5;
      rgb[2] = 0;  // orange
      break;
    case 7:
      rgb[0] = 1;
      rgb[1] = 0;
      rgb[2] = 0;  // red
      break;
    default:
      rgb[0] = 1;
      rgb[1] = 1;
      rgb[2] = 1;  // white
      break;
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\perception\obstacle\lidar\visualizer\opengl_visualizer\glfw_viewer.cc" startLine="(520, 0)" endLine="(568, 1)" clone_start="8" clone_end="42">
			<code function_name="GLFWViewer::GetClassColor(int cls, float rgb[3])">void GLFWViewer::GetClassColor(int cls, float rgb[3]) {
  switch (cls) {
    case 0:
      rgb[0] = 0.5;
      rgb[1] = 0;
      rgb[2] = 1;  // purple
      break;
    case 1:
      rgb[0] = 0;
      rgb[1] = 1;
      rgb[2] = 1;  // cryan
      break;
    case 2:
      rgb[0] = 1;
      rgb[1] = 1;
      rgb[2] = 0;  // yellow
      break;
    case 3:
      rgb[0] = 1;
      rgb[1] = 0.5;
      rgb[2] = 0.5;  // red
      break;
    case 4:
      rgb[0] = 0;
      rgb[1] = 0;
      rgb[2] = 1;  // blue
      break;
    case 5:
      rgb[0] = 0;
      rgb[1] = 1;
      rgb[2] = 0;  // green
      break;
    case 6:
      rgb[0] = 1;
      rgb[1] = 0.5;
      rgb[2] = 0;  // orange
      break;
    case 7:
      rgb[0] = 1;
      rgb[1] = 0;
      rgb[2] = 0;  // red
      break;
    default:
      rgb[0] = 1;
      rgb[1] = 1;
      rgb[2] = 1;  // white
      break;
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(58, 0)" endLine="(97, 1)" clone_start="23" clone_end="40">
			<code function_name="Spline2dConstraint::Add2dBoundary(const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle, const std::vector&lt;Vec2d&gt;&amp; ref_point, const std::vector&lt;double&gt;&amp; longitidinal_bound, const std::vector&lt;double&gt;&amp; lateral_bound)">bool Spline2dConstraint::Add2dBoundary(
    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle,
    const std::vector&lt;Vec2d&gt;&amp; ref_point,
    const std::vector&lt;double&gt;&amp; longitidinal_bound,
    const std::vector&lt;double&gt;&amp; lateral_bound) {
  if (t_coord.size() != angle.size() || angle.size() != ref_point.size() ||
      ref_point.size() != longitidinal_bound.size() ||
      longitidinal_bound.size() != lateral_bound.size()) {
    return false;
  }
  Eigen::MatrixXd affine_inequality =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), 1);
  for (std::uint32_t i = 0; i &lt; t_coord.size(); ++i) {
    const double d_longitudinal = SignDistance(ref_point[i], angle[i]);
    const double d_lateral = SignDistance(ref_point[i], angle[i] - M_PI / 2.0);
    const std::uint32_t index = FindIndex(t_coord[i]);
    const double rel_t = t_coord[i] - t_knots_[index];
    const std::uint32_t index_offset = 2 * index * spline_order_;
    std::vector&lt;double&gt; longi_coef = AffineCoef(angle[i], rel_t);
    std::vector&lt;double&gt; lateral_coef = AffineCoef(angle[i] - M_PI / 2, rel_t);
    for (std::uint32_t j = 0; j &lt; 2 * spline_order_; ++j) {
      // upper longi
      affine_inequality(4 * i, index_offset + j) = longi_coef[j];
      // lower longi
      affine_inequality(4 * i + 1, index_offset + j) = -longi_coef[j];
      // upper lateral
      affine_inequality(4 * i + 2, index_offset + j) = lateral_coef[j];
      // lower lateral
      affine_inequality(4 * i + 3, index_offset + j) = -lateral_coef[j];
    }

    affine_boundary(4 * i, 0) = d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 1, 0) = -d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 2, 0) = d_lateral - lateral_bound[i];
    affine_boundary(4 * i + 3, 0) = -d_lateral - lateral_bound[i];
  }
  return AddInequalityConstraint(affine_inequality, affine_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(141, 0)" endLine="(182, 1)" clone_start="25" clone_end="42">
			<code function_name="Spline2dConstraint::Add2dSecondDerivativeBoundary(    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle,     const std::vector&lt;Vec2d&gt;&amp; ref_point,     const std::vector&lt;double&gt;&amp; longitidinal_bound, const std::vector&lt;double&gt;&amp; lateral_bound)">bool Spline2dConstraint::Add2dSecondDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle,
    const std::vector&lt;Vec2d&gt;&amp; ref_point,
    const std::vector&lt;double&gt;&amp; longitidinal_bound,
    const std::vector&lt;double&gt;&amp; lateral_bound) {
  if (t_coord.size() != angle.size() || angle.size() != ref_point.size() ||
      ref_point.size() != longitidinal_bound.size() ||
      longitidinal_bound.size() != lateral_bound.size()) {
    return false;
  }
  Eigen::MatrixXd affine_inequality =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), 1);
  for (std::uint32_t i = 0; i &lt; t_coord.size(); ++i) {
    const double d_longitudinal = SignDistance(ref_point[i], angle[i]);
    const double d_lateral = SignDistance(ref_point[i], angle[i] - M_PI / 2.0);
    const std::uint32_t index = FindIndex(t_coord[i]);
    const double rel_t = t_coord[i] - t_knots_[index];
    const std::uint32_t index_offset = 2 * index * spline_order_;
    std::vector&lt;double&gt; longi_coef =
        AffineSecondDerivativeCoef(angle[i], rel_t);
    std::vector&lt;double&gt; lateral_coef =
        AffineSecondDerivativeCoef(angle[i] - M_PI / 2, rel_t);
    for (std::uint32_t j = 0; j &lt; 2 * spline_order_; ++j) {
      // upper longi
      affine_inequality(4 * i, index_offset + j) = longi_coef[j];
      // lower longi
      affine_inequality(4 * i + 1, index_offset + j) = -longi_coef[j];
      // upper lateral
      affine_inequality(4 * i + 2, index_offset + j) = lateral_coef[j];
      // lower lateral
      affine_inequality(4 * i + 3, index_offset + j) = -lateral_coef[j];
    }

    affine_boundary(4 * i, 0) = d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 1, 0) = -d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 2, 0) = d_lateral - lateral_bound[i];
    affine_boundary(4 * i + 3, 0) = -d_lateral - lateral_bound[i];
  }
  return AddInequalityConstraint(affine_inequality, affine_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(99, 0)" endLine="(139, 1)" clone_start="1" clone_end="40">
			<code function_name="Spline2dConstraint::Add2dDerivativeBoundary(    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle,     const std::vector&lt;Vec2d&gt;&amp; ref_point,     const std::vector&lt;double&gt;&amp; longitidinal_bound, const std::vector&lt;double&gt;&amp; lateral_bound)">bool Spline2dConstraint::Add2dDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle,
    const std::vector&lt;Vec2d&gt;&amp; ref_point,
    const std::vector&lt;double&gt;&amp; longitidinal_bound,
    const std::vector&lt;double&gt;&amp; lateral_bound) {
  if (t_coord.size() != angle.size() || angle.size() != ref_point.size() ||
      ref_point.size() != longitidinal_bound.size() ||
      longitidinal_bound.size() != lateral_bound.size()) {
    return false;
  }
  Eigen::MatrixXd affine_inequality =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), 1);
  for (std::uint32_t i = 0; i &lt; t_coord.size(); ++i) {
    const double d_longitudinal = SignDistance(ref_point[i], angle[i]);
    const double d_lateral = SignDistance(ref_point[i], angle[i] - M_PI / 2.0);
    const std::uint32_t index = FindIndex(t_coord[i]);
    const double rel_t = t_coord[i] - t_knots_[index];
    const std::uint32_t index_offset = 2 * index * spline_order_;
    std::vector&lt;double&gt; longi_coef = AffineDerivativeCoef(angle[i], rel_t);
    std::vector&lt;double&gt; lateral_coef =
        AffineDerivativeCoef(angle[i] - M_PI / 2, rel_t);
    for (std::uint32_t j = 0; j &lt; 2 * spline_order_; ++j) {
      // upper longi
      affine_inequality(4 * i, index_offset + j) = longi_coef[j];
      // lower longi
      affine_inequality(4 * i + 1, index_offset + j) = -longi_coef[j];
      // upper lateral
      affine_inequality(4 * i + 2, index_offset + j) = lateral_coef[j];
      // lower lateral
      affine_inequality(4 * i + 3, index_offset + j) = -lateral_coef[j];
    }

    affine_boundary(4 * i, 0) = d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 1, 0) = -d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 2, 0) = d_lateral - lateral_bound[i];
    affine_boundary(4 * i + 3, 0) = -d_lateral - lateral_bound[i];
  }
  return AddInequalityConstraint(affine_inequality, affine_boundary);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\smoothing_spline\spline_2d_constraint.cc" startLine="(184, 0)" endLine="(224, 1)" clone_start="1" clone_end="40">
			<code function_name="Spline2dConstraint::Add2dThirdDerivativeBoundary(    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle,     const std::vector&lt;Vec2d&gt;&amp; ref_point,     const std::vector&lt;double&gt;&amp; longitidinal_bound, const std::vector&lt;double&gt;&amp; lateral_bound)">bool Spline2dConstraint::Add2dThirdDerivativeBoundary(
    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle,
    const std::vector&lt;Vec2d&gt;&amp; ref_point,
    const std::vector&lt;double&gt;&amp; longitidinal_bound,
    const std::vector&lt;double&gt;&amp; lateral_bound) {
  if (t_coord.size() != angle.size() || angle.size() != ref_point.size() ||
      ref_point.size() != longitidinal_bound.size() ||
      longitidinal_bound.size() != lateral_bound.size()) {
    return false;
  }
  Eigen::MatrixXd affine_inequality =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), total_param_);
  Eigen::MatrixXd affine_boundary =
      Eigen::MatrixXd::Zero(4 * t_coord.size(), 1);
  for (std::uint32_t i = 0; i &lt; t_coord.size(); ++i) {
    const double d_longitudinal = SignDistance(ref_point[i], angle[i]);
    const double d_lateral = SignDistance(ref_point[i], angle[i] - M_PI / 2.0);
    const std::uint32_t index = FindIndex(t_coord[i]);
    const double rel_t = t_coord[i] - t_knots_[index];
    const std::uint32_t index_offset = 2 * index * spline_order_;
    std::vector&lt;double&gt; longi_coef = AffineThirdDerivativeCoef(angle[i], rel_t);
    std::vector&lt;double&gt; lateral_coef =
        AffineThirdDerivativeCoef(angle[i] - M_PI / 2, rel_t);
    for (std::uint32_t j = 0; j &lt; 2 * spline_order_; ++j) {
      // upper longi
      affine_inequality(4 * i, index_offset + j) = longi_coef[j];
      // lower longi
      affine_inequality(4 * i + 1, index_offset + j) = -longi_coef[j];
      // upper lateral
      affine_inequality(4 * i + 2, index_offset + j) = lateral_coef[j];
      // lower lateral
      affine_inequality(4 * i + 3, index_offset + j) = -lateral_coef[j];
    }

    affine_boundary(4 * i, 0) = d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 1, 0) = -d_longitudinal - longitidinal_bound[i];
    affine_boundary(4 * i + 2, 0) = d_lateral - lateral_bound[i];
    affine_boundary(4 * i + 3, 0) = -d_lateral - lateral_bound[i];
  }
  return AddInequalityConstraint(affine_inequality, affine_boundary);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(49, 0)" endLine="(52, 1)" clone_start="2" clone_end="4">
			<code function_name="Throttle62::set_pedal(double pedal)">Throttle62 *Throttle62::set_pedal(double pedal) {
  pedal_cmd_ = pedal;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(64, 0)" endLine="(67, 1)" clone_start="2" clone_end="4">
			<code function_name="Brake60::disable_boo_cmd()">Brake60 *Brake60::disable_boo_cmd() {
  boo_cmd_ = false;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(54, 0)" endLine="(57, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle62::set_enable()">Throttle62 *Throttle62::set_enable() {
  pedal_enable_ = true;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(69, 0)" endLine="(72, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake60::set_enable()">Brake60 *Brake60::set_enable() {
  pedal_enable_ = true;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(59, 0)" endLine="(62, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle62::set_disable()">Throttle62 *Throttle62::set_disable() {
  pedal_enable_ = false;
  return this;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(74, 0)" endLine="(77, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake60::set_disable()">Brake60 *Brake60::set_disable() {
  pedal_enable_ = false;
  return this;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(66, 0)" endLine="(82, 1)" clone_start="1" clone_end="17">
			<code function_name="Throttle62::set_pedal_p(uint8_t *data, double pedal)">void Throttle62::set_pedal_p(uint8_t *data, double pedal) {
  // change from [0-100] to [0.00-1.00]
  // and a rough mapping
  pedal /= 100.0;
  pedal = ProtocolData::BoundedValue(0.0, 1.0, pedal);
  int32_t x = pedal / 1.52590218966964e-05;
  std::uint8_t t = 0;

  t = x &amp; 0xFF;
  Byte frame_low(data + 0);
  frame_low.set_value(t, 0, 8);

  x &gt;&gt;= 8;
  t = x &amp; 0xFF;
  Byte frame_high(data + 1);
  frame_high.set_value(t, 0, 8);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(79, 0)" endLine="(95, 1)" clone_start="1" clone_end="17">
			<code function_name="Brake60::set_pedal_p(uint8_t *data, double pedal)">void Brake60::set_pedal_p(uint8_t *data, double pedal) {
  // change from [0-100] to [0.00-1.00]
  // and a rough mapping
  pedal /= 100.;
  pedal = ProtocolData::BoundedValue(0.0, 1.0, pedal);
  int32_t x = pedal / 1.52590218966964e-05;
  std::uint8_t t = 0;

  t = x &amp; 0xFF;
  Byte frame_low(data + 0);
  frame_low.set_value(t, 0, 8);

  x &gt;&gt;= 8;
  t = x &amp; 0xFF;
  Byte frame_high(data + 1);
  frame_high.set_value(t, 0, 8);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(84, 0)" endLine="(91, 1)" clone_start="1" clone_end="8">
			<code function_name="Throttle62::set_enable_p(uint8_t *bytes, bool enable)">void Throttle62::set_enable_p(uint8_t *bytes, bool enable) {
  Byte frame(bytes + 3);
  if (enable) {
    frame.set_bit_1(0);
  } else {
    frame.set_bit_0(0);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(97, 0)" endLine="(104, 1)" clone_start="1" clone_end="8">
			<code function_name="Brake60::set_boo_cmd_p(uint8_t *bytes, bool boo_cmd)">void Brake60::set_boo_cmd_p(uint8_t *bytes, bool boo_cmd) {
  Byte frame(bytes + 2);
  if (boo_cmd) {
    frame.set_bit_1(0);
  } else {
    frame.set_bit_0(0);
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(93, 0)" endLine="(100, 1)" clone_start="1" clone_end="8">
			<code function_name="Throttle62::set_clear_driver_override_flag_p(uint8_t *bytes, bool clear)">void Throttle62::set_clear_driver_override_flag_p(uint8_t *bytes, bool clear) {
  Byte frame(bytes + 3);
  if (clear) {
    frame.set_bit_1(1);
  } else {
    frame.set_bit_0(1);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(106, 0)" endLine="(113, 1)" clone_start="1" clone_end="8">
			<code function_name="Brake60::set_enable_p(uint8_t *bytes, bool enable)">void Brake60::set_enable_p(uint8_t *bytes, bool enable) {
  Byte frame(bytes + 3);
  if (enable) {
    frame.set_bit_1(0);
  } else {
    frame.set_bit_0(0);
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(102, 0)" endLine="(109, 1)" clone_start="1" clone_end="8">
			<code function_name="Throttle62::set_ignore_driver_override_p(uint8_t *bytes, bool ignore)">void Throttle62::set_ignore_driver_override_p(uint8_t *bytes, bool ignore) {
  Byte frame(bytes + 3);
  if (ignore) {
    frame.set_bit_1(2);
  } else {
    frame.set_bit_0(2);
  }
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(115, 0)" endLine="(122, 1)" clone_start="1" clone_end="8">
			<code function_name="Brake60::set_clear_driver_override_flag_p(uint8_t *bytes, bool clear)">void Brake60::set_clear_driver_override_flag_p(uint8_t *bytes, bool clear) {
  Byte frame(bytes + 3);
  if (clear) {
    frame.set_bit_1(1);
  } else {
    frame.set_bit_0(1);
  }
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\throttle_62.cc" startLine="(111, 0)" endLine="(115, 1)" clone_start="1" clone_end="4">
			<code function_name="Throttle62::set_watchdog_counter_p(uint8_t *data, int32_t count)">void Throttle62::set_watchdog_counter_p(uint8_t *data, int32_t count) {
  count = ProtocolData::BoundedValue(0, 255, count);
  Byte frame(data + 7);
  frame.set_value(count, 0, 8);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\brake_60.cc" startLine="(124, 0)" endLine="(128, 1)" clone_start="1" clone_end="4">
			<code function_name="Brake60::set_watchdog_counter_p(uint8_t *data, int32_t count)">void Brake60::set_watchdog_counter_p(uint8_t *data, int32_t count) {
  count = ProtocolData::BoundedValue(0, 255, count);
  Byte frame(data + 7);
  frame.set_value(count, 0, 8);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="44" clone_end="97">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(26, 0)" endLine="(220, 1)" clone_start="47" clone_end="100">
			<code function_name="Misc69::Parse(const std::uint8_t *bytes, int32_t length, ChassisDetail *chassis_detail) const">void Misc69::Parse(const std::uint8_t *bytes, int32_t length,
                   ChassisDetail *chassis_detail) const {
  int32_t turn_light_type = turn_signal_status(bytes, length);
  switch (turn_light_type) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_LIGHT_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(Light::TURN_LEFT_ON);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_turn_light_type(
          Light::TURN_RIGHT_ON);
      break;
    case 3:
      break;
    default:
      break;
  }

  int32_t hi_beam_status = high_beam_status(bytes, length);
  switch (hi_beam_status) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_NULL);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_FLASH_TO_PASS);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(Light::BEAM_HIGH);
      break;
    case 3:
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_lamp_type(
          Light::BEAM_INVALID);
      break;
  }

  // wiper status, non-compatible
  int32_t wiper = wiper_status(bytes, length);
  switch (wiper) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_OFF);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_OFF);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_OFF_MOVING);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_OFF);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_ON);
      break;
    case 5:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_LOW);
      break;
    case 6:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MANUAL_HIGH);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_MIST_FLICK);
      break;
    case 8:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_WASH);
      break;
    case 9:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_AUTO_LOW);
      break;
    case 10:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_HIGH);
      break;
    case 11:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_COURTESY_WIPE);
      break;
    case 12:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(
          Light::WIPER_AUTO_ADJUST);
      break;
    case 13:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_RESERVED);
      break;
    case 14:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_STALLED);
      break;
    case 15:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_wiper(Light::WIPER_NO_DATA);
      break;
  }

  int32_t ambient = ambient_light_status(bytes, length);
  switch (ambient) {
    case 0:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(Light::AMBIENT_DARK);
      break;
    case 1:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_LIGHT);
      break;
    case 2:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TWILIGHT);
      break;
    case 3:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_ON);
      break;
    case 4:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_TUNNEL_OFF);
      break;
    case 7:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_NO_DATA);
      break;
    default:
      chassis_detail-&gt;mutable_light()-&gt;set_lincoln_ambient(
          Light::AMBIENT_INVALID);
      break;
  }

  // acc button related
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_button(
      is_acc_on_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_off_button(
      is_acc_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_button(
      is_acc_resume_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_cancel_button(
      is_acc_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_on_off_button(
      is_acc_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_res_cancel_button(
      is_acc_resume_or_cancel_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_spd_button(
      is_acc_increment_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_spd_button(
      is_acc_decrement_set_speed_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_inc_gap_button(
      is_acc_increment_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_acc_dec_gap_button(
      is_acc_decrement_following_gap_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_lka_button(
      is_lka_on_or_off_pressed(bytes, length));
  chassis_detail-&gt;mutable_basic()-&gt;set_canbus_fault(
      is_canbus_fault(bytes, length));

  // driver door
  if (is_driver_door_open(bytes, length)) {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(false);
  } else {
    chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_car_door_close(true);
  }

  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_door_open(
      is_passenger_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearleft_door_open(
      is_rear_left_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_rearright_door_open(
      is_rear_right_door_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_hood_open(
      is_hood_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_trunk_open(
      is_trunk_open(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_detected(
      is_passenger_detected(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_airbag_enabled(
      is_passenger_airbag_enabled(bytes, length));

  // airbag ? driver airbag?
  // chassis_detail-&gt;mutable_basic()-&gt;set_is_air_bag_deployed(
  //     is_passenger_airbag_enabled(bytes, length));

  // driver buckled
  chassis_detail-&gt;mutable_safety()-&gt;set_is_driver_buckled(
      is_driver_belt_buckled(bytes, length));
  chassis_detail-&gt;mutable_safety()-&gt;set_is_passenger_buckled(
      is_passenger_belt_buckled(bytes, length));

  // has error?, non-compatible
  // chassis_detail-&gt;mutable_safety()-&gt;set_has_error(
  //    is_canbus_fault(bytes, length));
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\common\prediction_map.cc" startLine="(235, 0)" endLine="(251, 1)" clone_start="1" clone_end="17">
			<code function_name="PredictionMap::IsRightNeighborLane(std::shared_ptr&lt;const LaneInfo&gt; right_lane, std::shared_ptr&lt;const LaneInfo&gt; curr_lane)">bool PredictionMap::IsRightNeighborLane(
    std::shared_ptr&lt;const LaneInfo&gt; right_lane,
    std::shared_ptr&lt;const LaneInfo&gt; curr_lane) {
  if (curr_lane == nullptr) {
    return true;
  }
  if (right_lane == nullptr) {
    return false;
  }
  for (auto&amp; right_lane_id :
       curr_lane-&gt;lane().right_neighbor_forward_lane_id()) {
    if (right_lane-&gt;id().id() == right_lane_id.id()) {
      return true;
    }
  }
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\common\prediction_map.cc" startLine="(203, 0)" endLine="(219, 1)" clone_start="1" clone_end="17">
			<code function_name="PredictionMap::IsLeftNeighborLane(std::shared_ptr&lt;const LaneInfo&gt; left_lane, std::shared_ptr&lt;const LaneInfo&gt; curr_lane)">bool PredictionMap::IsLeftNeighborLane(
    std::shared_ptr&lt;const LaneInfo&gt; left_lane,
    std::shared_ptr&lt;const LaneInfo&gt; curr_lane) {
  if (curr_lane == nullptr) {
    return true;
  }
  if (left_lane == nullptr) {
    return false;
  }
  for (const auto&amp; left_lane_id :
       curr_lane-&gt;lane().left_neighbor_forward_lane_id()) {
    if (left_lane-&gt;id().id() == left_lane_id.id()) {
      return true;
    }
  }
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\common\prediction_map.cc" startLine="(253, 0)" endLine="(265, 1)" clone_start="1" clone_end="13">
			<code function_name="PredictionMap::IsRightNeighborLane(    std::shared_ptr&lt;const LaneInfo&gt; right_lane, const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes)">bool PredictionMap::IsRightNeighborLane(
    std::shared_ptr&lt;const LaneInfo&gt; right_lane,
    const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes) {
  if (lanes.size() == 0) {
    return true;
  }
  for (const auto&amp; lane : lanes) {
    if (IsRightNeighborLane(right_lane, lane)) {
      return true;
    }
  }
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\common\prediction_map.cc" startLine="(221, 0)" endLine="(233, 1)" clone_start="1" clone_end="13">
			<code function_name="PredictionMap::IsLeftNeighborLane(    std::shared_ptr&lt;const LaneInfo&gt; left_lane, const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes)">bool PredictionMap::IsLeftNeighborLane(
    std::shared_ptr&lt;const LaneInfo&gt; left_lane,
    const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes) {
  if (lanes.size() == 0) {
    return true;
  }
  for (auto&amp; lane : lanes) {
    if (IsLeftNeighborLane(left_lane, lane)) {
      return true;
    }
  }
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\common\prediction_map.cc" startLine="(267, 0)" endLine="(281, 1)" clone_start="1" clone_end="15">
			<code function_name="PredictionMap::IsSuccessorLane(std::shared_ptr&lt;const LaneInfo&gt; succ_lane, std::shared_ptr&lt;const LaneInfo&gt; curr_lane)">bool PredictionMap::IsSuccessorLane(std::shared_ptr&lt;const LaneInfo&gt; succ_lane,
                                    std::shared_ptr&lt;const LaneInfo&gt; curr_lane) {
  if (curr_lane == nullptr) {
    return true;
  }
  if (succ_lane == nullptr) {
    return false;
  }
  for (auto&amp; successor_lane_id : curr_lane-&gt;lane().successor_id()) {
    if (succ_lane-&gt;id().id() == successor_lane_id.id()) {
      return true;
    }
  }
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\common\prediction_map.cc" startLine="(235, 0)" endLine="(251, 1)" clone_start="1" clone_end="17">
			<code function_name="PredictionMap::IsRightNeighborLane(std::shared_ptr&lt;const LaneInfo&gt; right_lane, std::shared_ptr&lt;const LaneInfo&gt; curr_lane)">bool PredictionMap::IsRightNeighborLane(
    std::shared_ptr&lt;const LaneInfo&gt; right_lane,
    std::shared_ptr&lt;const LaneInfo&gt; curr_lane) {
  if (curr_lane == nullptr) {
    return true;
  }
  if (right_lane == nullptr) {
    return false;
  }
  for (auto&amp; right_lane_id :
       curr_lane-&gt;lane().right_neighbor_forward_lane_id()) {
    if (right_lane-&gt;id().id() == right_lane_id.id()) {
      return true;
    }
  }
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\common\prediction_map.cc" startLine="(283, 0)" endLine="(295, 1)" clone_start="1" clone_end="13">
			<code function_name="PredictionMap::IsSuccessorLane(std::shared_ptr&lt;const LaneInfo&gt; succ_lane, const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes)">bool PredictionMap::IsSuccessorLane(
    std::shared_ptr&lt;const LaneInfo&gt; succ_lane,
    const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes) {
  if (lanes.size() == 0) {
    return true;
  }
  for (auto&amp; lane : lanes) {
    if (IsSuccessorLane(succ_lane, lane)) {
      return true;
    }
  }
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\common\prediction_map.cc" startLine="(253, 0)" endLine="(265, 1)" clone_start="1" clone_end="13">
			<code function_name="PredictionMap::IsRightNeighborLane(    std::shared_ptr&lt;const LaneInfo&gt; right_lane, const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes)">bool PredictionMap::IsRightNeighborLane(
    std::shared_ptr&lt;const LaneInfo&gt; right_lane,
    const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes) {
  if (lanes.size() == 0) {
    return true;
  }
  for (const auto&amp; lane : lanes) {
    if (IsRightNeighborLane(right_lane, lane)) {
      return true;
    }
  }
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\common\prediction_map.cc" startLine="(297, 0)" endLine="(312, 1)" clone_start="1" clone_end="16">
			<code function_name="PredictionMap::IsPredecessorLane(std::shared_ptr&lt;const LaneInfo&gt; pred_lane, std::shared_ptr&lt;const LaneInfo&gt; curr_lane)">bool PredictionMap::IsPredecessorLane(
    std::shared_ptr&lt;const LaneInfo&gt; pred_lane,
    std::shared_ptr&lt;const LaneInfo&gt; curr_lane) {
  if (curr_lane == nullptr) {
    return true;
  }
  if (pred_lane == nullptr) {
    return false;
  }
  for (auto&amp; predecessor_lane_id : curr_lane-&gt;lane().predecessor_id()) {
    if (pred_lane-&gt;id().id() == predecessor_lane_id.id()) {
      return true;
    }
  }
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\common\prediction_map.cc" startLine="(267, 0)" endLine="(281, 1)" clone_start="1" clone_end="15">
			<code function_name="PredictionMap::IsSuccessorLane(std::shared_ptr&lt;const LaneInfo&gt; succ_lane, std::shared_ptr&lt;const LaneInfo&gt; curr_lane)">bool PredictionMap::IsSuccessorLane(std::shared_ptr&lt;const LaneInfo&gt; succ_lane,
                                    std::shared_ptr&lt;const LaneInfo&gt; curr_lane) {
  if (curr_lane == nullptr) {
    return true;
  }
  if (succ_lane == nullptr) {
    return false;
  }
  for (auto&amp; successor_lane_id : curr_lane-&gt;lane().successor_id()) {
    if (succ_lane-&gt;id().id() == successor_lane_id.id()) {
      return true;
    }
  }
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\common\prediction_map.cc" startLine="(314, 0)" endLine="(326, 1)" clone_start="1" clone_end="13">
			<code function_name="PredictionMap::IsPredecessorLane(    std::shared_ptr&lt;const LaneInfo&gt; pred_lane, const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes)">bool PredictionMap::IsPredecessorLane(
    std::shared_ptr&lt;const LaneInfo&gt; pred_lane,
    const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes) {
  if (lanes.size() == 0) {
    return true;
  }
  for (auto&amp; lane : lanes) {
    if (IsPredecessorLane(pred_lane, lane)) {
      return true;
    }
  }
  return false;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\common\prediction_map.cc" startLine="(283, 0)" endLine="(295, 1)" clone_start="1" clone_end="13">
			<code function_name="PredictionMap::IsSuccessorLane(std::shared_ptr&lt;const LaneInfo&gt; succ_lane, const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes)">bool PredictionMap::IsSuccessorLane(
    std::shared_ptr&lt;const LaneInfo&gt; succ_lane,
    const std::vector&lt;std::shared_ptr&lt;const LaneInfo&gt;&gt;&amp; lanes) {
  if (lanes.size() == 0) {
    return true;
  }
  for (auto&amp; lane : lanes) {
    if (IsSuccessorLane(succ_lane, lane)) {
      return true;
    }
  }
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\common\prediction_map.cc" startLine="(328, 0)" endLine="(334, 1)" clone_start="1" clone_end="1">
			<code function_name="PredictionMap::IsIdenticalLane(std::shared_ptr&lt;const LaneInfo&gt; other_lane, std::shared_ptr&lt;const LaneInfo&gt; curr_lane)">bool PredictionMap::IsIdenticalLane(std::shared_ptr&lt;const LaneInfo&gt; other_lane,
                                    std::shared_ptr&lt;const LaneInfo&gt; curr_lane) {
  if (curr_lane == nullptr || other_lane == nullptr) {
    return true;
  }
  return other_lane-&gt;id().id() == curr_lane-&gt;id().id();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\prediction\common\prediction_map.cc" startLine="(297, 0)" endLine="(312, 1)" clone_start="1" clone_end="1">
			<code function_name="PredictionMap::IsPredecessorLane(std::shared_ptr&lt;const LaneInfo&gt; pred_lane, std::shared_ptr&lt;const LaneInfo&gt; curr_lane)">bool PredictionMap::IsPredecessorLane(
    std::shared_ptr&lt;const LaneInfo&gt; pred_lane,
    std::shared_ptr&lt;const LaneInfo&gt; curr_lane) {
  if (curr_lane == nullptr) {
    return true;
  }
  if (pred_lane == nullptr) {
    return false;
  }
  for (auto&amp; predecessor_lane_id : curr_lane-&gt;lane().predecessor_id()) {
    if (pred_lane-&gt;id().id() == predecessor_lane_id.id()) {
      return true;
    }
  }
  return false;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(198, 0)" endLine="(215, 1)" clone_start="17" clone_end="18">
			<code function_name="HDMapImpl::GetJunctions(const Vec2d&amp; point, double distance, std::vector&lt;JunctionInfoConstPtr&gt;* junctions) const">int HDMapImpl::GetJunctions(
    const Vec2d&amp; point, double distance,
    std::vector&lt;JunctionInfoConstPtr&gt;* junctions) const {
  if (junctions == nullptr || junction_polygon_kdtree_ == nullptr) {
    return -1;
  }
  junctions-&gt;clear();
  std::vector&lt;std::string&gt; ids;
  const int status =
      SearchObjects(point, distance, *junction_polygon_kdtree_, &amp;ids);
  if (status &lt; 0) {
    return status;
  }
  for (const auto&amp; id : ids) {
    junctions-&gt;emplace_back(GetJunctionById(CreateHDMapId(id)));
  }
  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(172, 0)" endLine="(190, 1)" clone_start="18" clone_end="19">
			<code function_name="HDMapImpl::GetRoads(const Vec2d&amp; point, double distance, std::vector&lt;RoadInfoConstPtr&gt;* roads) const">int HDMapImpl::GetRoads(const Vec2d&amp; point, double distance,
                        std::vector&lt;RoadInfoConstPtr&gt;* roads) const {
  std::vector&lt;LaneInfoConstPtr&gt; lanes;
  if (GetLanes(point, distance, &amp;lanes) != 0) {
    return -1;
  }
  std::unordered_set&lt;std::string&gt; road_ids;
  for (auto&amp; lane : lanes) {
    road_ids.insert(lane-&gt;road_id().id());
  }

  for (auto&amp; road_id : road_ids) {
    RoadInfoConstPtr road = GetRoadById(CreateHDMapId(road_id));
    CHECK_NOTNULL(road);
    roads-&gt;push_back(road);
  }

  return 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(217, 0)" endLine="(220, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMapImpl::GetSignals(const PointENU&amp; point, double distance, std::vector&lt;SignalInfoConstPtr&gt;* signals) const">int HDMapImpl::GetSignals(const PointENU&amp; point, double distance,
                          std::vector&lt;SignalInfoConstPtr&gt;* signals) const {
  return GetSignals({point.x(), point.y()}, distance, signals);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(192, 0)" endLine="(196, 1)" clone_start="1" clone_end="5">
			<code function_name="HDMapImpl::GetJunctions(const PointENU&amp; point, double distance, std::vector&lt;JunctionInfoConstPtr&gt;* junctions) const">int HDMapImpl::GetJunctions(
    const PointENU&amp; point, double distance,
    std::vector&lt;JunctionInfoConstPtr&gt;* junctions) const {
  return GetJunctions({point.x(), point.y()}, distance, junctions);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(222, 0)" endLine="(238, 1)" clone_start="1" clone_end="17">
			<code function_name="HDMapImpl::GetSignals(const Vec2d&amp; point, double distance, std::vector&lt;SignalInfoConstPtr&gt;* signals) const">int HDMapImpl::GetSignals(const Vec2d&amp; point, double distance,
                          std::vector&lt;SignalInfoConstPtr&gt;* signals) const {
  if (signals == nullptr || signal_segment_kdtree_ == nullptr) {
    return -1;
  }
  signals-&gt;clear();
  std::vector&lt;std::string&gt; ids;
  const int status =
      SearchObjects(point, distance, *signal_segment_kdtree_, &amp;ids);
  if (status &lt; 0) {
    return status;
  }
  for (const auto&amp; id : ids) {
    signals-&gt;emplace_back(GetSignalById(CreateHDMapId(id)));
  }
  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(198, 0)" endLine="(215, 1)" clone_start="1" clone_end="18">
			<code function_name="HDMapImpl::GetJunctions(const Vec2d&amp; point, double distance, std::vector&lt;JunctionInfoConstPtr&gt;* junctions) const">int HDMapImpl::GetJunctions(
    const Vec2d&amp; point, double distance,
    std::vector&lt;JunctionInfoConstPtr&gt;* junctions) const {
  if (junctions == nullptr || junction_polygon_kdtree_ == nullptr) {
    return -1;
  }
  junctions-&gt;clear();
  std::vector&lt;std::string&gt; ids;
  const int status =
      SearchObjects(point, distance, *junction_polygon_kdtree_, &amp;ids);
  if (status &lt; 0) {
    return status;
  }
  for (const auto&amp; id : ids) {
    junctions-&gt;emplace_back(GetJunctionById(CreateHDMapId(id)));
  }
  return 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(240, 0)" endLine="(244, 1)" clone_start="1" clone_end="5">
			<code function_name="HDMapImpl::GetCrosswalks(    const PointENU&amp; point, double distance, std::vector&lt;CrosswalkInfoConstPtr&gt;* crosswalks) const">int HDMapImpl::GetCrosswalks(
    const PointENU&amp; point, double distance,
    std::vector&lt;CrosswalkInfoConstPtr&gt;* crosswalks) const {
  return GetCrosswalks({point.x(), point.y()}, distance, crosswalks);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(217, 0)" endLine="(220, 1)" clone_start="1" clone_end="4">
			<code function_name="HDMapImpl::GetSignals(const PointENU&amp; point, double distance, std::vector&lt;SignalInfoConstPtr&gt;* signals) const">int HDMapImpl::GetSignals(const PointENU&amp; point, double distance,
                          std::vector&lt;SignalInfoConstPtr&gt;* signals) const {
  return GetSignals({point.x(), point.y()}, distance, signals);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(246, 0)" endLine="(263, 1)" clone_start="1" clone_end="18">
			<code function_name="HDMapImpl::GetCrosswalks(    const Vec2d&amp; point, double distance, std::vector&lt;CrosswalkInfoConstPtr&gt;* crosswalks) const">int HDMapImpl::GetCrosswalks(
    const Vec2d&amp; point, double distance,
    std::vector&lt;CrosswalkInfoConstPtr&gt;* crosswalks) const {
  if (crosswalks == nullptr || crosswalk_polygon_kdtree_ == nullptr) {
    return -1;
  }
  crosswalks-&gt;clear();
  std::vector&lt;std::string&gt; ids;
  const int status =
      SearchObjects(point, distance, *crosswalk_polygon_kdtree_, &amp;ids);
  if (status &lt; 0) {
    return status;
  }
  for (const auto&amp; id : ids) {
    crosswalks-&gt;emplace_back(GetCrosswalkById(CreateHDMapId(id)));
  }
  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(222, 0)" endLine="(238, 1)" clone_start="1" clone_end="17">
			<code function_name="HDMapImpl::GetSignals(const Vec2d&amp; point, double distance, std::vector&lt;SignalInfoConstPtr&gt;* signals) const">int HDMapImpl::GetSignals(const Vec2d&amp; point, double distance,
                          std::vector&lt;SignalInfoConstPtr&gt;* signals) const {
  if (signals == nullptr || signal_segment_kdtree_ == nullptr) {
    return -1;
  }
  signals-&gt;clear();
  std::vector&lt;std::string&gt; ids;
  const int status =
      SearchObjects(point, distance, *signal_segment_kdtree_, &amp;ids);
  if (status &lt; 0) {
    return status;
  }
  for (const auto&amp; id : ids) {
    signals-&gt;emplace_back(GetSignalById(CreateHDMapId(id)));
  }
  return 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(265, 0)" endLine="(269, 1)" clone_start="1" clone_end="5">
			<code function_name="HDMapImpl::GetStopSigns(    const PointENU&amp; point, double distance, std::vector&lt;StopSignInfoConstPtr&gt;* stop_signs) const">int HDMapImpl::GetStopSigns(
    const PointENU&amp; point, double distance,
    std::vector&lt;StopSignInfoConstPtr&gt;* stop_signs) const {
  return GetStopSigns({point.x(), point.y()}, distance, stop_signs);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(240, 0)" endLine="(244, 1)" clone_start="1" clone_end="5">
			<code function_name="HDMapImpl::GetCrosswalks(    const PointENU&amp; point, double distance, std::vector&lt;CrosswalkInfoConstPtr&gt;* crosswalks) const">int HDMapImpl::GetCrosswalks(
    const PointENU&amp; point, double distance,
    std::vector&lt;CrosswalkInfoConstPtr&gt;* crosswalks) const {
  return GetCrosswalks({point.x(), point.y()}, distance, crosswalks);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(271, 0)" endLine="(288, 1)" clone_start="1" clone_end="18">
			<code function_name="HDMapImpl::GetStopSigns(    const Vec2d&amp; point, double distance, std::vector&lt;StopSignInfoConstPtr&gt;* stop_signs) const">int HDMapImpl::GetStopSigns(
    const Vec2d&amp; point, double distance,
    std::vector&lt;StopSignInfoConstPtr&gt;* stop_signs) const {
  if (stop_signs == nullptr || stop_sign_segment_kdtree_ == nullptr) {
    return -1;
  }
  stop_signs-&gt;clear();
  std::vector&lt;std::string&gt; ids;
  const int status =
      SearchObjects(point, distance, *stop_sign_segment_kdtree_, &amp;ids);
  if (status &lt; 0) {
    return status;
  }
  for (const auto&amp; id : ids) {
    stop_signs-&gt;emplace_back(GetStopSignById(CreateHDMapId(id)));
  }
  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(246, 0)" endLine="(263, 1)" clone_start="1" clone_end="18">
			<code function_name="HDMapImpl::GetCrosswalks(    const Vec2d&amp; point, double distance, std::vector&lt;CrosswalkInfoConstPtr&gt;* crosswalks) const">int HDMapImpl::GetCrosswalks(
    const Vec2d&amp; point, double distance,
    std::vector&lt;CrosswalkInfoConstPtr&gt;* crosswalks) const {
  if (crosswalks == nullptr || crosswalk_polygon_kdtree_ == nullptr) {
    return -1;
  }
  crosswalks-&gt;clear();
  std::vector&lt;std::string&gt; ids;
  const int status =
      SearchObjects(point, distance, *crosswalk_polygon_kdtree_, &amp;ids);
  if (status &lt; 0) {
    return status;
  }
  for (const auto&amp; id : ids) {
    crosswalks-&gt;emplace_back(GetCrosswalkById(CreateHDMapId(id)));
  }
  return 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(290, 0)" endLine="(294, 1)" clone_start="1" clone_end="5">
			<code function_name="HDMapImpl::GetYieldSigns(    const PointENU&amp; point, double distance, std::vector&lt;YieldSignInfoConstPtr&gt;* yield_signs) const">int HDMapImpl::GetYieldSigns(
    const PointENU&amp; point, double distance,
    std::vector&lt;YieldSignInfoConstPtr&gt;* yield_signs) const {
  return GetYieldSigns({point.x(), point.y()}, distance, yield_signs);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(265, 0)" endLine="(269, 1)" clone_start="1" clone_end="5">
			<code function_name="HDMapImpl::GetStopSigns(    const PointENU&amp; point, double distance, std::vector&lt;StopSignInfoConstPtr&gt;* stop_signs) const">int HDMapImpl::GetStopSigns(
    const PointENU&amp; point, double distance,
    std::vector&lt;StopSignInfoConstPtr&gt;* stop_signs) const {
  return GetStopSigns({point.x(), point.y()}, distance, stop_signs);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(296, 0)" endLine="(314, 1)" clone_start="1" clone_end="18">
			<code function_name="HDMapImpl::GetYieldSigns(    const Vec2d&amp; point, double distance, std::vector&lt;YieldSignInfoConstPtr&gt;* yield_signs) const">int HDMapImpl::GetYieldSigns(
    const Vec2d&amp; point, double distance,
    std::vector&lt;YieldSignInfoConstPtr&gt;* yield_signs) const {
  if (yield_signs == nullptr || yield_sign_segment_kdtree_ == nullptr) {
    return -1;
  }
  yield_signs-&gt;clear();
  std::vector&lt;std::string&gt; ids;
  const int status =
      SearchObjects(point, distance, *yield_sign_segment_kdtree_, &amp;ids);
  if (status &lt; 0) {
    return status;
  }
  for (const auto&amp; id : ids) {
    yield_signs-&gt;emplace_back(GetYieldSignById(CreateHDMapId(id)));
  }

  return 0;
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\hdmap_impl.cc" startLine="(271, 0)" endLine="(288, 1)" clone_start="1" clone_end="17">
			<code function_name="HDMapImpl::GetStopSigns(    const Vec2d&amp; point, double distance, std::vector&lt;StopSignInfoConstPtr&gt;* stop_signs) const">int HDMapImpl::GetStopSigns(
    const Vec2d&amp; point, double distance,
    std::vector&lt;StopSignInfoConstPtr&gt;* stop_signs) const {
  if (stop_signs == nullptr || stop_sign_segment_kdtree_ == nullptr) {
    return -1;
  }
  stop_signs-&gt;clear();
  std::vector&lt;std::string&gt; ids;
  const int status =
      SearchObjects(point, distance, *stop_sign_segment_kdtree_, &amp;ids);
  if (status &lt; 0) {
    return status;
  }
  for (const auto&amp; id : ids) {
    stop_signs-&gt;emplace_back(GetStopSignById(CreateHDMapId(id)));
  }
  return 0;
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(249, 0)" endLine="(253, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_on_pressed(const std::uint8_t *bytes,
                               int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(255, 0)" endLine="(259, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_off_pressed(const std::uint8_t *bytes,
                                int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(4);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(255, 0)" endLine="(259, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_off_pressed(const std::uint8_t *bytes,
                                int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(261, 0)" endLine="(265, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_resume_pressed(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(5);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(261, 0)" endLine="(265, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_resume_pressed(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(267, 0)" endLine="(271, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_cancel_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_cancel_pressed(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(6);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(267, 0)" endLine="(271, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_cancel_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_cancel_pressed(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 1);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(273, 0)" endLine="(277, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_or_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_on_or_off_pressed(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(0);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(273, 0)" endLine="(277, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_on_or_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_on_or_off_pressed(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(279, 0)" endLine="(283, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t *bytes,
                                             int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(1);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(279, 0)" endLine="(283, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_resume_or_cancel_pressed(const std::uint8_t *bytes,
                                             int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(285, 0)" endLine="(289, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(285, 0)" endLine="(289, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_increment_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(291, 0)" endLine="(295, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(291, 0)" endLine="(295, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_decrement_set_speed_pressed(const std::uint8_t *bytes,
                                                int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(297, 0)" endLine="(301, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t *bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(4);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(297, 0)" endLine="(301, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_increment_following_gap_pressed(const std::uint8_t *bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(303, 0)" endLine="(307, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t *bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(5);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(303, 0)" endLine="(307, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_acc_decrement_following_gap_pressed(const std::uint8_t *bytes,
                                                    int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(309, 0)" endLine="(313, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_lka_on_or_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_lka_on_or_off_pressed(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(6);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(309, 0)" endLine="(313, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_lka_on_or_off_pressed(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_lka_on_or_off_pressed(const std::uint8_t *bytes,
                                      int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(315, 0)" endLine="(318, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(7);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(315, 0)" endLine="(318, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_canbus_fault(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 2);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(320, 0)" endLine="(324, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_driver_door_open(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(0);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(320, 0)" endLine="(324, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_driver_door_open(const std::uint8_t *bytes,
                                 int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(326, 0)" endLine="(330, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_door_open(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(1);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(326, 0)" endLine="(330, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_door_open(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(1);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(332, 0)" endLine="(336, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_left_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_rear_left_door_open(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(2);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(332, 0)" endLine="(336, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_left_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_rear_left_door_open(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(2);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(338, 0)" endLine="(342, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_right_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_rear_right_door_open(const std::uint8_t *bytes,
                                     int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(3);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(338, 0)" endLine="(342, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_rear_right_door_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_rear_right_door_open(const std::uint8_t *bytes,
                                     int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(3);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(344, 0)" endLine="(347, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_hood_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_hood_open(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(4);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(344, 0)" endLine="(347, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_hood_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_hood_open(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(4);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(349, 0)" endLine="(352, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_trunk_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_trunk_open(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(5);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(349, 0)" endLine="(352, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_trunk_open(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_trunk_open(const std::uint8_t *bytes, int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(5);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(354, 0)" endLine="(358, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_detected(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_detected(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(6);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(354, 0)" endLine="(358, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_detected(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_detected(const std::uint8_t *bytes,
                                   int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(6);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(360, 0)" endLine="(364, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_airbag_enabled(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_airbag_enabled(const std::uint8_t *bytes,
                                         int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(7);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(360, 0)" endLine="(364, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_passenger_airbag_enabled(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_airbag_enabled(const std::uint8_t *bytes,
                                         int32_t length) const {
  Byte frame(bytes + 3);
  return frame.is_bit_1(7);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(366, 0)" endLine="(370, 1)" clone_start="1" clone_end="5">
			<code function_name="Misc69::is_driver_belt_buckled(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_driver_belt_buckled(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 4);
  return frame.is_bit_1(0);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(366, 0)" endLine="(370, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_driver_belt_buckled(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_driver_belt_buckled(const std::uint8_t *bytes,
                                    int32_t length) const {
  Byte frame(bytes + 4);
  return frame.is_bit_1(0);
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\canbus\vehicle\lincoln\protocol\misc_69.cc" startLine="(372, 0)" endLine="(376, 1)" clone_start="1" clone_end="4">
			<code function_name="Misc69::is_passenger_belt_buckled(const std::uint8_t *bytes, int32_t length) const">bool Misc69::is_passenger_belt_buckled(const std::uint8_t *bytes,
                                       int32_t length) const {
  Byte frame(bytes + 4);
  return frame.is_bit_1(1);
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(389, 0)" endLine="(427, 1)" clone_start="33" clone_end="39">
			<code function_name="LanesXmlParser::ParseObjectOverlapGroup(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;OverlapWithLane&gt;* object_overlaps)">Status LanesXmlParser::ParseObjectOverlapGroup(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;OverlapWithLane&gt;* object_overlaps) {
  CHECK_NOTNULL(object_overlaps);

  auto object_overlap = xml_node.FirstChildElement("objectOverlapGroup");
  if (object_overlap) {
    auto sub_node = object_overlap-&gt;FirstChildElement("objectReference");
    while (sub_node) {
      std::string object_id;
      double start_s = 0.0;
      double end_s = 0.0;
      int checker =
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
      checker += sub_node-&gt;QueryDoubleAttribute("startOffset", &amp;start_s);
      checker += sub_node-&gt;QueryDoubleAttribute("endOffset", &amp;end_s);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse lane object overlap";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      bool is_merge = false;
      checker = sub_node-&gt;QueryBoolAttribute("isMerge", &amp;is_merge);
      if (checker != tinyxml2::XML_SUCCESS) {
        is_merge = false;
      }

      OverlapWithLane overlap_with_lane;
      overlap_with_lane.object_id = object_id;
      overlap_with_lane.start_s = start_s;
      overlap_with_lane.end_s = end_s;
      overlap_with_lane.is_merge = is_merge;
      object_overlaps-&gt;push_back(overlap_with_lane);

      sub_node = sub_node-&gt;NextSiblingElement("objectReference");
    }
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(349, 0)" endLine="(387, 1)" clone_start="33" clone_end="39">
			<code function_name="LanesXmlParser::ParseSampleAssociates( const tinyxml2::XMLElement&amp; xml_node, PbLane* lane)">Status LanesXmlParser::ParseSampleAssociates(
    const tinyxml2::XMLElement&amp; xml_node, PbLane* lane) {
  CHECK_NOTNULL(lane);
  auto sub_node = xml_node.FirstChildElement("sampleAssociates");
  if (sub_node == nullptr) {
    std::string err_msg = "Error parse sample associates";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }
  sub_node = sub_node-&gt;FirstChildElement("sampleAssociate");
  if (sub_node == nullptr) {
    std::string err_msg = "Error parse sample associate";
    return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
  }

  while (sub_node) {
    double left_width = 0.0;
    double right_width = 0.0;
    double s = 0.0;
    int checker = sub_node-&gt;QueryDoubleAttribute("sOffset", &amp;s);
    checker += sub_node-&gt;QueryDoubleAttribute("leftWidth", &amp;left_width);
    checker += sub_node-&gt;QueryDoubleAttribute("rightWidth", &amp;right_width);
    if (checker != tinyxml2::XML_SUCCESS) {
      std::string err_msg = "Error parse lane sample associate attribute";
      return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
    }

    auto left_sample = lane-&gt;add_left_sample();
    left_sample-&gt;set_s(s);
    left_sample-&gt;set_width(left_width);

    auto right_sample = lane-&gt;add_right_sample();
    right_sample-&gt;set_s(s);
    right_sample-&gt;set_width(right_width);

    sub_node = sub_node-&gt;NextSiblingElement("sampleAssociate");
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(429, 0)" endLine="(468, 1)" clone_start="1" clone_end="40">
			<code function_name="LanesXmlParser::ParseSignalOverlapGroup(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;OverlapWithLane&gt;* signal_overlaps)">Status LanesXmlParser::ParseSignalOverlapGroup(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;OverlapWithLane&gt;* signal_overlaps) {
  CHECK_NOTNULL(signal_overlaps);

  auto signal_overlap = xml_node.FirstChildElement("signalOverlapGroup");
  if (signal_overlap) {
    auto sub_node = signal_overlap-&gt;FirstChildElement("signalReference");
    while (sub_node) {
      std::string object_id;
      double start_s = 0.0;
      double end_s = 0.0;
      int checker =
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
      checker += sub_node-&gt;QueryDoubleAttribute("startOffset", &amp;start_s);
      checker += sub_node-&gt;QueryDoubleAttribute("endOffset", &amp;end_s);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse lane signal overlap";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      bool is_merge = false;
      checker = sub_node-&gt;QueryBoolAttribute("isMerge", &amp;is_merge);
      if (checker != tinyxml2::XML_SUCCESS) {
        is_merge = false;
      }

      OverlapWithLane overlap_with_lane;
      overlap_with_lane.object_id = object_id;
      overlap_with_lane.start_s = start_s;
      overlap_with_lane.end_s = end_s;
      overlap_with_lane.is_merge = is_merge;

      signal_overlaps-&gt;push_back(overlap_with_lane);

      sub_node = sub_node-&gt;NextSiblingElement("signalReference");
    }
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(389, 0)" endLine="(427, 1)" clone_start="1" clone_end="39">
			<code function_name="LanesXmlParser::ParseObjectOverlapGroup(const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;OverlapWithLane&gt;* object_overlaps)">Status LanesXmlParser::ParseObjectOverlapGroup(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;OverlapWithLane&gt;* object_overlaps) {
  CHECK_NOTNULL(object_overlaps);

  auto object_overlap = xml_node.FirstChildElement("objectOverlapGroup");
  if (object_overlap) {
    auto sub_node = object_overlap-&gt;FirstChildElement("objectReference");
    while (sub_node) {
      std::string object_id;
      double start_s = 0.0;
      double end_s = 0.0;
      int checker =
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
      checker += sub_node-&gt;QueryDoubleAttribute("startOffset", &amp;start_s);
      checker += sub_node-&gt;QueryDoubleAttribute("endOffset", &amp;end_s);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse lane object overlap";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      bool is_merge = false;
      checker = sub_node-&gt;QueryBoolAttribute("isMerge", &amp;is_merge);
      if (checker != tinyxml2::XML_SUCCESS) {
        is_merge = false;
      }

      OverlapWithLane overlap_with_lane;
      overlap_with_lane.object_id = object_id;
      overlap_with_lane.start_s = start_s;
      overlap_with_lane.end_s = end_s;
      overlap_with_lane.is_merge = is_merge;
      object_overlaps-&gt;push_back(overlap_with_lane);

      sub_node = sub_node-&gt;NextSiblingElement("objectReference");
    }
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(470, 0)" endLine="(509, 1)" clone_start="1" clone_end="40">
			<code function_name="LanesXmlParser::ParseJunctionOverlapGroup(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;OverlapWithLane&gt;* junction_overlaps)">Status LanesXmlParser::ParseJunctionOverlapGroup(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;OverlapWithLane&gt;* junction_overlaps) {
  CHECK_NOTNULL(junction_overlaps);

  auto overlap_group = xml_node.FirstChildElement("junctionOverlapGroup");
  if (overlap_group) {
    auto sub_node = overlap_group-&gt;FirstChildElement("junctionReference");
    while (sub_node) {
      std::string object_id;
      double start_s = 0.0;
      double end_s = 0.0;
      int checker =
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
      checker += sub_node-&gt;QueryDoubleAttribute("startOffset", &amp;start_s);
      checker += sub_node-&gt;QueryDoubleAttribute("endOffset", &amp;end_s);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse lane junction overlap";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      bool is_merge = false;
      checker = sub_node-&gt;QueryBoolAttribute("isMerge", &amp;is_merge);
      if (checker != tinyxml2::XML_SUCCESS) {
        is_merge = false;
      }

      OverlapWithLane overlap_with_lane;
      overlap_with_lane.object_id = object_id;
      overlap_with_lane.start_s = start_s;
      overlap_with_lane.end_s = end_s;
      overlap_with_lane.is_merge = is_merge;

      junction_overlaps-&gt;push_back(overlap_with_lane);

      sub_node = sub_node-&gt;NextSiblingElement("junctionReference");
    }
  }
  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(429, 0)" endLine="(468, 1)" clone_start="1" clone_end="40">
			<code function_name="LanesXmlParser::ParseSignalOverlapGroup(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;OverlapWithLane&gt;* signal_overlaps)">Status LanesXmlParser::ParseSignalOverlapGroup(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;OverlapWithLane&gt;* signal_overlaps) {
  CHECK_NOTNULL(signal_overlaps);

  auto signal_overlap = xml_node.FirstChildElement("signalOverlapGroup");
  if (signal_overlap) {
    auto sub_node = signal_overlap-&gt;FirstChildElement("signalReference");
    while (sub_node) {
      std::string object_id;
      double start_s = 0.0;
      double end_s = 0.0;
      int checker =
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
      checker += sub_node-&gt;QueryDoubleAttribute("startOffset", &amp;start_s);
      checker += sub_node-&gt;QueryDoubleAttribute("endOffset", &amp;end_s);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse lane signal overlap";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      bool is_merge = false;
      checker = sub_node-&gt;QueryBoolAttribute("isMerge", &amp;is_merge);
      if (checker != tinyxml2::XML_SUCCESS) {
        is_merge = false;
      }

      OverlapWithLane overlap_with_lane;
      overlap_with_lane.object_id = object_id;
      overlap_with_lane.start_s = start_s;
      overlap_with_lane.end_s = end_s;
      overlap_with_lane.is_merge = is_merge;

      signal_overlaps-&gt;push_back(overlap_with_lane);

      sub_node = sub_node-&gt;NextSiblingElement("signalReference");
    }
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(511, 0)" endLine="(551, 1)" clone_start="1" clone_end="12">
			<code function_name="LanesXmlParser::ParseLaneOverlapGroup(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;OverlapWithLane&gt;* lane_overlaps)">Status LanesXmlParser::ParseLaneOverlapGroup(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;OverlapWithLane&gt;* lane_overlaps) {
  CHECK_NOTNULL(lane_overlaps);

  auto overlap_node = xml_node.FirstChildElement("laneOverlapGroup");
  if (overlap_node) {
    auto sub_node = overlap_node-&gt;FirstChildElement("laneReference");
    while (sub_node) {
      std::string lane_id;
      double start_s = 0.0;
      double end_s = 0.0;
      int checker = UtilXmlParser::QueryStringAttribute(*sub_node, "id",
                                                   &amp;lane_id);
      checker += sub_node-&gt;QueryDoubleAttribute("startOffset", &amp;start_s);
      checker += sub_node-&gt;QueryDoubleAttribute("endOffset", &amp;end_s);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse lane lane overlap";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      bool is_merge = false;
      checker = sub_node-&gt;QueryBoolAttribute("isMerge", &amp;is_merge);
      if (checker != tinyxml2::XML_SUCCESS) {
        is_merge = false;
      }

      OverlapWithLane overlap_with_lane;
      overlap_with_lane.object_id = lane_id;
      overlap_with_lane.start_s = start_s;
      overlap_with_lane.end_s = end_s;
      overlap_with_lane.is_merge = is_merge;

      lane_overlaps-&gt;push_back(overlap_with_lane);

      sub_node = sub_node-&gt;NextSiblingElement("laneReference");
    }
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" startLine="(470, 0)" endLine="(509, 1)" clone_start="1" clone_end="12">
			<code function_name="LanesXmlParser::ParseJunctionOverlapGroup(    const tinyxml2::XMLElement&amp; xml_node, std::vector&lt;OverlapWithLane&gt;* junction_overlaps)">Status LanesXmlParser::ParseJunctionOverlapGroup(
    const tinyxml2::XMLElement&amp; xml_node,
    std::vector&lt;OverlapWithLane&gt;* junction_overlaps) {
  CHECK_NOTNULL(junction_overlaps);

  auto overlap_group = xml_node.FirstChildElement("junctionOverlapGroup");
  if (overlap_group) {
    auto sub_node = overlap_group-&gt;FirstChildElement("junctionReference");
    while (sub_node) {
      std::string object_id;
      double start_s = 0.0;
      double end_s = 0.0;
      int checker =
          UtilXmlParser::QueryStringAttribute(*sub_node, "id", &amp;object_id);
      checker += sub_node-&gt;QueryDoubleAttribute("startOffset", &amp;start_s);
      checker += sub_node-&gt;QueryDoubleAttribute("endOffset", &amp;end_s);
      if (checker != tinyxml2::XML_SUCCESS) {
        std::string err_msg = "Error parse lane junction overlap";
        return Status(apollo::common::ErrorCode::HDMAP_DATA_ERROR, err_msg);
      }

      bool is_merge = false;
      checker = sub_node-&gt;QueryBoolAttribute("isMerge", &amp;is_merge);
      if (checker != tinyxml2::XML_SUCCESS) {
        is_merge = false;
      }

      OverlapWithLane overlap_with_lane;
      overlap_with_lane.object_id = object_id;
      overlap_with_lane.start_s = start_s;
      overlap_with_lane.end_s = end_s;
      overlap_with_lane.is_merge = is_merge;

      junction_overlaps-&gt;push_back(overlap_with_lane);

      sub_node = sub_node-&gt;NextSiblingElement("junctionReference");
    }
  }
  return Status::OK();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\spiral_curve\quintic_spiral_curve.cc" startLine="(42, 0)" endLine="(191, 1)" clone_start="32" clone_end="150">
			<code function_name="QuinticSpiralCurve::CalculatePath()">bool QuinticSpiralCurve::CalculatePath() {
  // extract infos
  double x_s = start_point().x();
  double y_s = start_point().y();
  double theta_s = std::fmod(start_point().theta(), s_two_pi_);

  if (theta_s &lt; 0) {
    theta_s += s_two_pi_;
  }

  double x_t = end_point().x() - x_s;  // with position
  double y_t = end_point().y() - y_s;  // with position

  double x_g = std::cos(theta_s) * x_t + std::sin(theta_s) * y_t;
  double y_g = -std::sin(theta_s) * x_t + std::cos(theta_s) * y_t;
  double theta_g = std::fmod(end_point().theta(), s_two_pi_);
  theta_g -= theta_s;

  while (theta_g &lt; -M_PI) {
    theta_g += s_two_pi_;
  }

  while (theta_g &gt; +M_PI) {
    theta_g -= s_two_pi_;
  }

  double sg = (theta_g * theta_g / 5 + 1.0) * std::sqrt(x_g * x_g + y_g * y_g);

  std::array&lt;double, 6&gt; p_shoot;
  p_shoot[0] = start_point().kappa();
  p_shoot[1] = start_point().dkappa();
  p_shoot[2] = start_point().ddkappa();
  p_shoot[3] = 0.0;
  p_shoot[4] = 0.0;
  p_shoot[5] = end_point().kappa();

  // intermediate params
  Eigen::Matrix&lt;double, 3, 1&gt; q_g;
  q_g &lt;&lt; x_g, y_g, theta_g;            // goal, x(p, sg), y(p, sg), theta(p, sg)
  Eigen::Matrix&lt;double, 3, 3&gt; jacobi;  // Jacobian matrix for newton method

  // simpson integrations func values in Jacobian
  // integration point initialization:
  double ds =
      sg / (spiral_config().simpson_size() - 1);  // bandwith for integration
  // basic theta value vectors:
  std::vector&lt;double&gt; theta(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; cos_theta(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; sin_theta(spiral_config().simpson_size(), 0.0);
  // partial derivatvies vectors for Jacobian
  std::vector&lt;double&gt; ptp_p3(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; ptp_p4(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; ptp_sg(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; sin_ptp_p3(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; sin_ptp_p4(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; sin_ptp_sg(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; cos_ptp_p3(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; cos_ptp_p4(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; cos_ptp_sg(spiral_config().simpson_size(), 0.0);
  // newton iteration difference (col) vectors
  Eigen::Matrix&lt;double, 3, 1&gt; delta_q;  // goal difference
  Eigen::Matrix&lt;double, 3, 1&gt; delta_p;  // parameter difference
  Eigen::Matrix&lt;double, 3, 1&gt;
      q_guess;      // q with current paramter, delta_q = q_g - q_guess
  double diff = 0;  // absolute error for q iteration stop

  for (int32_t nt = 0; nt &lt; spiral_config().newton_raphson_max_iter(); ++nt) {
    // calculate parameters for simpson integration
    double s = 0;

    for (int32_t i = 0; i &lt; spiral_config().simpson_size(); ++i) {
      theta[i] = SpiralFormula::theta_func_k5(s, sg, p_shoot);

      cos_theta[i] = std::cos(theta[i]);
      sin_theta[i] = std::sin(theta[i]);

      ptp_p3[i] = SpiralFormula::partial_theta_p3_k5(s, sg);
      ptp_p4[i] = SpiralFormula::partial_theta_p4_k5(s, sg);
      ptp_sg[i] = SpiralFormula::partial_theta_sg_k5(s, sg, p_shoot);

      sin_ptp_p3[i] = sin_theta[i] * ptp_p3[i];
      sin_ptp_p4[i] = sin_theta[i] * ptp_p4[i];
      sin_ptp_sg[i] = sin_theta[i] * ptp_sg[i];

      cos_ptp_p3[i] = cos_theta[i] * ptp_p3[i];
      cos_ptp_p4[i] = cos_theta[i] * ptp_p4[i];
      cos_ptp_sg[i] = cos_theta[i] * ptp_sg[i];
      s += ds;
    }

    // update Jacobian and delta q
    jacobi(0, 0) = -apollo::common::math::IntegrateBySimpson(
        sin_ptp_p3, ds, spiral_config().simpson_size());

    jacobi(0, 1) = -apollo::common::math::IntegrateBySimpson(
        sin_ptp_p4, ds, spiral_config().simpson_size());

    jacobi(0, 2) = cos_theta[spiral_config().simpson_size() - 1] -
                   apollo::common::math::IntegrateBySimpson(
                       sin_ptp_sg, ds, spiral_config().simpson_size());

    jacobi(1, 0) = apollo::common::math::IntegrateBySimpson(
        cos_ptp_p3, ds, spiral_config().simpson_size());

    jacobi(1, 1) = apollo::common::math::IntegrateBySimpson(
        cos_ptp_p4, ds, spiral_config().simpson_size());

    jacobi(1, 2) = sin_theta[spiral_config().simpson_size() - 1] +
                   apollo::common::math::IntegrateBySimpson(
                       cos_ptp_sg, ds, spiral_config().simpson_size());

    jacobi(2, 0) = ptp_p3[spiral_config().simpson_size() - 1];

    jacobi(2, 1) = ptp_p4[spiral_config().simpson_size() - 1];

    jacobi(2, 2) = ptp_sg[spiral_config().simpson_size() - 1];

    q_guess(0) = apollo::common::math::IntegrateBySimpson(
        cos_theta, ds, spiral_config().simpson_size());

    q_guess(1) = apollo::common::math::IntegrateBySimpson(
        sin_theta, ds, spiral_config().simpson_size());

    q_guess(2) = theta[spiral_config().simpson_size() - 1];

    delta_q = q_g - q_guess;

    // early stop
    diff =
        std::fabs(delta_q(0)) + std::fabs(delta_q(1)) + std::fabs(delta_q(2));

    if (diff &lt; spiral_config().newton_raphson_tol()) {
      break;
    }

    delta_p = jacobi.lu().solve(delta_q);
    // update p, sg, ds
    p_shoot[3] += delta_p(0);
    p_shoot[4] += delta_p(1);
    sg += delta_p(2);
    ds = sg / (spiral_config().simpson_size() - 1);
  }

  // update params
  PrependToPParams(p_shoot.begin(), p_shoot.end());
  set_sg(sg);
  set_error(diff);

  return diff &lt; spiral_config().newton_raphson_tol() &amp;&amp; ResultSanityCheck();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\spiral_curve\cubic_spiral_curve.cc" startLine="(41, 0)" endLine="(180, 1)" clone_start="30" clone_end="140">
			<code function_name="CubicSpiralCurve::CalculatePath()">bool CubicSpiralCurve::CalculatePath() {
  // calculate path with initialize table
  double x_s = start_point().x();
  double y_s = start_point().y();
  double theta_s = std::fmod(start_point().theta(), s_two_pi_);

  if (theta_s &lt; 0) {
    theta_s += s_two_pi_;
  }

  double x_t = end_point().x() - x_s;
  double y_t = end_point().y() - y_s;

  // with position and rotation transformation
  double x_g = std::cos(theta_s) * x_t + std::sin(theta_s) * y_t;
  double y_g = -std::sin(theta_s) * x_t + std::cos(theta_s) * y_t;
  double theta_g = std::fmod(end_point().theta(), s_two_pi_);
  theta_g -= theta_s;

  while (theta_g &lt; -M_PI) {
    theta_g += s_two_pi_;
  }

  while (theta_g &gt; +M_PI) {
    theta_g -= s_two_pi_;
  }
  std::array&lt;double, 4&gt; p_shoot;
  double sg =
      (theta_g * theta_g / 5.0 + 1.0) * std::sqrt(x_g * x_g + y_g * y_g);
  p_shoot[0] = start_point().kappa();
  p_shoot[1] = 0.0;
  p_shoot[2] = 0.0;
  p_shoot[3] = end_point().kappa();

  // intermediate params
  Eigen::Matrix&lt;double, 3, 1&gt; q_g;
  q_g &lt;&lt; x_g, y_g, theta_g;            // goal, x(p, sg), y(p, sg), theta(p, sg)
  Eigen::Matrix&lt;double, 3, 3&gt; jacobi;  // Jacobian matrix for newton method

  // simpson integrations func values in Jacobian
  // integration point initialization:
  double ds =
      sg / (spiral_config().simpson_size() - 1);  // bandwith for integration
  // basic theta value vectors:
  std::vector&lt;double&gt; theta(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; cos_theta(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; sin_theta(spiral_config().simpson_size(), 0.0);
  // partial derivatvies vectors for Jacobian
  std::vector&lt;double&gt; ptp_p1(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; ptp_p2(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; ptp_sg(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; sin_ptp_p1(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; sin_ptp_p2(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; sin_ptp_sg(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; cos_ptp_p1(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; cos_ptp_p2(spiral_config().simpson_size(), 0.0);
  std::vector&lt;double&gt; cos_ptp_sg(spiral_config().simpson_size(), 0.0);

  // newton iteration difference (col) vectors
  Eigen::Matrix&lt;double, 3, 1&gt; delta_q;  // goal difference
  Eigen::Matrix&lt;double, 3, 1&gt; delta_p;  // parameter difference
  Eigen::Matrix&lt;double, 3, 1&gt;
      q_guess;        // q with current paramter, delta_q = q_g - q_guess
  double diff = 0.0;  // absolute error for q iteration stop

  for (int32_t nt = 0; nt &lt; spiral_config().newton_raphson_max_iter(); ++nt) {
    // calculate parameters for simpson integration
    double s = 0.0;

    for (int32_t i = 0; i &lt; spiral_config().simpson_size(); ++i) {
      theta[i] = SpiralFormula::theta_func_k3(s, sg, p_shoot);

      cos_theta[i] = std::cos(theta[i]);
      sin_theta[i] = std::sin(theta[i]);

      ptp_p1[i] = SpiralFormula::partial_theta_p1_k3(s, sg);
      ptp_p2[i] = SpiralFormula::partial_theta_p2_k3(s, sg);
      ptp_sg[i] = SpiralFormula::partial_theta_sg_k3(s, sg, p_shoot);

      sin_ptp_p1[i] = sin_theta[i] * ptp_p1[i];
      sin_ptp_p2[i] = sin_theta[i] * ptp_p2[i];
      sin_ptp_sg[i] = sin_theta[i] * ptp_sg[i];

      cos_ptp_p1[i] = cos_theta[i] * ptp_p1[i];
      cos_ptp_p2[i] = cos_theta[i] * ptp_p2[i];
      cos_ptp_sg[i] = cos_theta[i] * ptp_sg[i];
      s += ds;
    }

    // update Jacobian and delta q
    jacobi(0, 0) = -apollo::common::math::IntegrateBySimpson(
        sin_ptp_p1, ds, spiral_config().simpson_size());
    jacobi(0, 1) = -apollo::common::math::IntegrateBySimpson(
        sin_ptp_p2, ds, spiral_config().simpson_size());
    jacobi(0, 2) = cos_theta[spiral_config().simpson_size() - 1] -
                   apollo::common::math::IntegrateBySimpson(
                       sin_ptp_sg, ds, spiral_config().simpson_size());

    jacobi(1, 0) = apollo::common::math::IntegrateBySimpson(
        cos_ptp_p1, ds, spiral_config().simpson_size());
    jacobi(1, 1) = apollo::common::math::IntegrateBySimpson(
        cos_ptp_p2, ds, spiral_config().simpson_size());
    jacobi(1, 2) = sin_theta[spiral_config().simpson_size() - 1] +
                   apollo::common::math::IntegrateBySimpson(
                       cos_ptp_sg, ds, spiral_config().simpson_size());

    jacobi(2, 0) = ptp_p1[spiral_config().simpson_size() - 1];
    jacobi(2, 1) = ptp_p2[spiral_config().simpson_size() - 1];
    jacobi(2, 2) = ptp_sg[spiral_config().simpson_size() - 1];

    q_guess(0) = apollo::common::math::IntegrateBySimpson(
        cos_theta, ds, spiral_config().simpson_size());
    q_guess(1) = apollo::common::math::IntegrateBySimpson(
        sin_theta, ds, spiral_config().simpson_size());
    q_guess(2) = theta[spiral_config().simpson_size() - 1];

    delta_q = q_g - q_guess;

    diff =
        std::fabs(delta_q(0)) + std::fabs(delta_q(1)) + std::fabs(delta_q(2));

    if (diff &lt; spiral_config().newton_raphson_tol()) {
      break;
    }

    // solve by lu decomposition
    delta_p = jacobi.lu().solve(delta_q);
    // update p, sg, ds
    p_shoot[1] += delta_p(0);
    p_shoot[2] += delta_p(1);
    sg += delta_p(2);
    ds = sg / (spiral_config().simpson_size() - 1);
  }

  PrependToPParams(p_shoot.begin(), p_shoot.end());
  set_sg(sg);
  set_error(diff);

  return diff &lt; spiral_config().newton_raphson_tol() &amp;&amp; ResultSanityCheck();
}</code>
		</source>
	</dup>
	<dup count="2">
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\spiral_curve\quintic_spiral_curve.cc" startLine="(193, 0)" endLine="(247, 1)" clone_start="1" clone_end="3">
			<code function_name="QuinticSpiralCurve::GetPathVec( const std::uint32_t n, std::vector&lt;common::PathPoint&gt;* path_points) const">Status QuinticSpiralCurve::GetPathVec(
    const std::uint32_t n, std::vector&lt;common::PathPoint&gt;* path_points) const {
  CHECK_NOTNULL(path_points);

  if (n &lt;= 1 || error() &gt; spiral_config().newton_raphson_tol()) {
    return Status(ErrorCode::PLANNING_ERROR,
                  "QuinticSpiralCurve::get_path_vec");
  }

  path_points-&gt;resize(n);
  std::vector&lt;common::PathPoint&gt;&amp; result = *path_points;

  result[0].set_x(start_point().x());
  result[0].set_y(start_point().y());
  result[0].set_theta(start_point().theta());
  result[0].set_kappa(start_point().kappa());
  result[0].set_dkappa(start_point().dkappa());
  result[0].set_ddkappa(start_point().ddkappa());

  const double ds = sg() / (n - 1);
  double s = ds;

  // calculate theta kappa along the path
  std::array&lt;double, 6&gt; p_value;
  std::copy(p_params().begin(), p_params().end(), p_value.begin());
  std::array&lt;double, 6&gt; a_params = SpiralFormula::p_to_a_k5(sg(), p_value);

  for (std::uint32_t i = 1; i &lt; n; ++i) {
    result[i].set_s(s);
    result[i].set_theta(SpiralFormula::theta_func_k5_a(s, a_params) +
                        result[0].theta());
    result[i].set_kappa(SpiralFormula::kappa_func_k5_a(s, a_params));
    result[i].set_dkappa(SpiralFormula::dkappa_func_k5_a(s, a_params));
    s += ds;
  }

  // integration x, y along the path
  double dx = 0.0;
  double dy = 0.0;

  for (std::uint32_t k = 1; k &lt; n; ++k) {
    dx = (dx / k) * (k - 1) +
         (std::cos(std::fmod(result[k].theta(), s_two_pi_)) +
          std::cos(std::fmod(result[k - 1].theta(), s_two_pi_))) /
             (2 * k);
    dy = (dy / k) * (k - 1) +
         (std::sin(std::fmod(result[k].theta(), s_two_pi_)) +
          std::sin(std::fmod(result[k - 1].theta(), s_two_pi_))) /
             (2 * k);
    result[k].set_x(result[k].s() * dx + result[0].x());
    result[k].set_y(result[k].s() * dy + result[0].y());
  }

  return Status::OK();
}</code>
		</source>
		<source sourceFile="D:\download\apollo-1.5.0\apollo-1.5.0\modules\planning\math\spiral_curve\cubic_spiral_curve.cc" startLine="(182, 0)" endLine="(238, 1)" clone_start="1" clone_end="3">
			<code function_name="CubicSpiralCurve::GetPathVec( const std::uint32_t n, std::vector&lt;common::PathPoint&gt;* path_points) const">Status CubicSpiralCurve::GetPathVec(
    const std::uint32_t n, std::vector&lt;common::PathPoint&gt;* path_points) const {
  CHECK_NOTNULL(path_points);

  // initialization
  if (n &lt; 2 || error() &gt; spiral_config().newton_raphson_tol()) {
    return Status(ErrorCode::PLANNING_ERROR, "CubicSpiralCurve::get_path_vec");
  }

  path_points-&gt;resize(n);

  std::vector&lt;common::PathPoint&gt;&amp; result = *path_points;
  const double ds = sg() / (n - 1);

  std::array&lt;double, 4&gt; p_value;
  std::copy_n(p_params().begin(), 4, p_value.begin());

  result[0].set_x(start_point().x());
  result[0].set_y(start_point().y());
  result[0].set_theta(start_point().theta());
  result[0].set_kappa(start_point().kappa());
  result[0].set_dkappa(SpiralFormula::dkappa_func_k3(0, sg(), p_value));

  // calculate path x, y using iterative trapezoidal method
  // initialization
  double s = ds;
  // calculate heading kappa along the path
  std::array&lt;double, 4&gt; a_params = SpiralFormula::p_to_a_k3(sg(), p_value);

  for (std::uint32_t i = 1; i &lt; n; ++i) {
    result[i].set_s(s);
    result[i].set_theta(SpiralFormula::theta_func_k3_a(s, a_params) +
                        result[0].theta());
    result[i].set_kappa(SpiralFormula::kappa_func_k3_a(s, a_params));
    result[i].set_dkappa(SpiralFormula::dkappa_func_k3_a(s, a_params));
    s += ds;
  }

  // integration x, y along the path
  double dx = 0;
  double dy = 0;

  for (std::uint32_t k = 1; k &lt; n; ++k) {
    dx = (dx / k) * (k - 1) +
         (std::cos(std::fmod(result[k].theta(), s_two_pi_)) +
          std::cos(std::fmod(result[k - 1].theta(), s_two_pi_))) /
             (2 * k);
    dy = (dy / k) * (k - 1) +
         (std::sin(std::fmod(result[k].theta(), s_two_pi_)) +
          std::sin(std::fmod(result[k - 1].theta(), s_two_pi_))) /
             (2 * k);
    result[k].set_x(result[k].s() * dx + result[0].x());
    result[k].set_y(result[k].s() * dy + result[0].y());
  }

  return Status::OK();
}</code>
		</source>
	</dup>
	<summary count="916"/>
</Func_Clone>
