<?xml version="1.0" encoding="utf-8"?>
<Root>
	<commit hash="d23973e64047a7739cd2903cc216675eb1712c5b" author="storypku">
		<msg>Map: more descriptive binary map generator</msg>
		<modified_files>
			<file old_path="modules\map\tools\bin_map_generator.cc" new_path="modules\map\tools\bin_map_generator.cc" added_lines="15" deleted_lines="9">
				<diff>@@ -15,11 +15,11 @@ limitations under the License.
 
 #include "gflags/gflags.h"
 
+#include "modules/map/proto/map.pb.h"
+
 #include "cyber/common/file.h"
 #include "cyber/common/log.h"
-#include "modules/map/hdmap/adapter/opendrive_adapter.h"
 #include "modules/map/hdmap/hdmap_util.h"
-#include "modules/map/proto/map.pb.h"
 
 /**
  * A map tool to transform .txt map to .bin map
@@ -27,7 +27,7 @@ limitations under the License.
 
 DEFINE_string(output_dir, "/tmp", "output map directory");
 
-int main(int argc, char **argv) {
+int main(int argc, char *argv[]) {
   google::InitGoogleLogging(argv[0]);
   FLAGS_alsologtostderr = true;
 
@@ -35,18 +35,24 @@ int main(int argc, char **argv) {
 
   const auto map_filename = FLAGS_map_dir + "/base_map.txt";
   apollo::hdmap::Map pb_map;
-  ACHECK(apollo::cyber::common::GetProtoFromFile(map_filename, &amp;pb_map))
-      &lt;&lt; "fail to load data from : " &lt;&lt; map_filename;
+  if (!apollo::cyber::common::GetProtoFromFile(map_filename, &amp;pb_map)) {
+    AERROR &lt;&lt; "Failed to load txt map from " &lt;&lt; map_filename;
+    return -1;
+  } else {
+    AINFO &lt;&lt; "Loaded txt map from " &lt;&lt; map_filename;
+  }
 
   const std::string output_bin_file = FLAGS_output_dir + "/base_map.bin";
-  ACHECK(apollo::cyber::common::SetProtoToBinaryFile(pb_map, output_bin_file))
-      &lt;&lt; "failed to output binary format base map";
+  if (!apollo::cyber::common::SetProtoToBinaryFile(pb_map, output_bin_file)) {
+    AERROR &lt;&lt; "Failed to generate binary base map";
+    return -1;
+  }
 
   pb_map.Clear();
   ACHECK(apollo::cyber::common::GetProtoFromFile(output_bin_file, &amp;pb_map))
-      &lt;&lt; "failed to load map,transform map failed";
+      &lt;&lt; "Failed to load generated binary base map";
 
-  AINFO &lt;&lt; "transform map into .bin map success";
+  AINFO &lt;&lt; "Successfully converted .txt map to .bin map: " &lt;&lt; output_bin_file;
 
   return 0;
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b97403f8ce65fd41360cb01e0c7f3b8cceda06e0" author="xiaoMrzhang">
		<msg>Perception: empty unnecessary cache (#12654)</msg>
		<modified_files>
			<file old_path="modules\perception\inference\libtorch\torch_det.cc" new_path="modules\perception\inference\libtorch\torch_det.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -39,6 +39,7 @@ bool TorchDet::Init(const std::map&lt;std::string, std::vector&lt;int&gt;&gt; &amp;shapes) {
   // Init net
   torch::Device device(device_type_, device_id_);
   net_ = torch::jit::load(model_file_, device);
+  net_.eval();
 
   for (const auto&amp; name : output_names_) {
     auto blob = std::make_shared&lt;Blob&lt;float&gt;&gt;(2, 6, 1, 1);
@@ -79,7 +80,7 @@ void TorchDet::Infer() {
   auto input_param = blobs_[input_names_[1]];
 
   torch::Tensor tensor_image = torch::from_blob(
-                              blob-&gt;data()-&gt;mutable_cpu_data(),
+                              blob-&gt;data()-&gt;mutable_gpu_data(),
                               {blob-&gt;shape(0), blob-&gt;shape(1), blob-&gt;shape(2),
                               blob-&gt;shape(3)}, torch::kFloat32);
   torch::Tensor tensor_param = torch::from_blob(
</diff>
			</file>
			<file old_path="modules\perception\inference\libtorch\torch_net.cc" new_path="modules\perception\inference\libtorch\torch_net.cc" added_lines="5" deleted_lines="1">
				<diff>@@ -16,6 +16,8 @@
 
 #include "modules/perception/inference/libtorch/torch_net.h"
 
+#include &lt;c10/cuda/CUDACachingAllocator.h&gt;
+
 #include "cyber/common/log.h"
 
 namespace apollo {
@@ -39,6 +41,7 @@ bool TorchNet::Init(const std::map&lt;std::string, std::vector&lt;int&gt;&gt; &amp;shapes) {
   // Init net
   torch::Device device(device_type_, device_id_);
   net_ = torch::jit::load(model_file_, device);
+  net_.eval();
 
   for (auto name : output_names_) {
     auto blob = std::make_shared&lt;Blob&lt;float&gt;&gt;(1, 4, 1, 1);
@@ -82,7 +85,7 @@ void TorchNet::Infer() {
   // pay attention to the tensor shape order, if changed without permute
   // will get wrong result
   torch::Tensor tensor_image = torch::from_blob(
-                              blob-&gt;data()-&gt;mutable_cpu_data(),
+                              blob-&gt;data()-&gt;mutable_gpu_data(),
                               {blob-&gt;shape(1), blob-&gt;shape(2), blob-&gt;shape(3)},
                               torch::kFloat32);
   if (device_id_ &gt;= 0) {
@@ -99,6 +102,7 @@ void TorchNet::Infer() {
   torch::Tensor output = net_.forward({tensor_image}).toTensor();
   torch::Tensor prob = torch::softmax(output, 1);
   blobs_[output_names_[0]]-&gt;data()-&gt;set_gpu_data(prob.data_ptr());
+  c10::cuda::CUDACachingAllocator::emptyCache();
 }
 
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="12fba491ccffea37563c28ca606adf42d7c8c94a" author="Dontmovedad">
		<msg>obstacle detector: temporary commit for libtorch obstacle detector</msg>
		<modified_files>
			<file old_path=".cache\distdir\README.md" new_path="" added_lines="0" deleted_lines="1">
				<diff>@@ -1 +0,0 @@
-# Directory used as bazel `--distdir` destination
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\detector\yolov4\object_maintainer.h" new_path="modules\perception\camera\lib\obstacle\detector\yolov4\object_maintainer.h" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
+ * Copyright 2020 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the License);
  * you may not use this file except in compliance with the License.
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\detector\yolov4\region_output.cc" new_path="modules\perception\camera\lib\obstacle\detector\yolov4\region_output.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
+ * Copyright 2020 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the License);
  * you may not use this file except in compliance with the License.
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\detector\yolov4\region_output.h" new_path="modules\perception\camera\lib\obstacle\detector\yolov4\region_output.h" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
+ * Copyright 2020 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the License);
  * you may not use this file except in compliance with the License.
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\detector\yolov4\yolov4_obstacle_detector.cc" new_path="modules\perception\camera\lib\obstacle\detector\yolov4\yolov4_obstacle_detector.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
+ * Copyright 2020 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the License);
  * you may not use this file except in compliance with the License.
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\detector\yolov4\yolov4_obstacle_detector.h" new_path="modules\perception\camera\lib\obstacle\detector\yolov4\yolov4_obstacle_detector.h" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
+ * Copyright 2020 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the License);
  * you may not use this file except in compliance with the License.
</diff>
			</file>
			<file old_path="modules\perception\common\perception_gflags.cc" new_path="modules\perception\common\perception_gflags.cc" added_lines="18" deleted_lines="0">
				<diff>@@ -81,5 +81,23 @@ DEFINE_double(score_threshold, 0.5, "Classification score threshold.");
 DEFINE_double(nms_overlap_threshold, 0.5, "Nms overlap threshold.");
 DEFINE_int32(num_output_box_feature, 7, "Length of output box feature.");
 
+// emergency detection onnx
+DEFINE_string(onnx_obstacle_detector_model,
+              "/apollo/modules/perception/camera"
+              "/lib/obstacle/detector/yolov4/model/yolov4_1_3_416_416.onnx",
+              "The onnx model file for emergency detection");
+DEFINE_string(onnx_test_input_path,
+              "/apollo/modules/perception/inference"
+              "/onnx/testdata/dog.jpg",
+              "The test input image file for onnx inference");
+DEFINE_string(onnx_test_input_name_file,
+              "/apollo/modules/perception/inference"
+              "/onnx/testdata/coco.names",
+              "The test input coco name file for onnx inference");
+DEFINE_string(onnx_prediction_image_path,
+              "/apollo/modules/perception/inference"
+              "/onnx/testdata/prediction.jpg",
+              "The prediction output image file for onnx inference");
+DEFINE_int32(num_classes, 80, "number of classes for onnx inference");
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\common\perception_gflags.h" new_path="modules\perception\common\perception_gflags.h" added_lines="6" deleted_lines="0">
				<diff>@@ -55,5 +55,11 @@ DECLARE_double(score_threshold);
 DECLARE_double(nms_overlap_threshold);
 DECLARE_int32(num_output_box_feature);
 
+// emergency detection onnx
+DECLARE_string(onnx_obstacle_detector_model);
+DECLARE_string(onnx_test_input_path);
+DECLARE_string(onnx_test_input_name_file);
+DECLARE_string(onnx_prediction_image_path);
+DECLARE_int32(num_classes);
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="14797fc3b33ac48882cbc1d8d1a911110783f30a" author="Dontmovedad">
		<msg>Obstcle Detection: Add Libtorch Interence Unit Test</msg>
		<modified_files>
			<file old_path="modules\perception\common\perception_gflags.cc" new_path="modules\perception\common\perception_gflags.cc" added_lines="6" deleted_lines="0">
				<diff>@@ -99,5 +99,11 @@ DEFINE_string(onnx_prediction_image_path,
               "/onnx/testdata/prediction.jpg",
               "The prediction output image file for onnx inference");
 DEFINE_int32(num_classes, 80, "number of classes for onnx inference");
+
+// emergency detection libtorch
+DEFINE_string(torch_detector_model,
+              "/apollo/modules/perception/camera"
+              "/lib/obstacle/detector/yolov4/model/yolov4.pt",
+              "The torch model file for emergency detection");
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\common\perception_gflags.h" new_path="modules\perception\common\perception_gflags.h" added_lines="3" deleted_lines="0">
				<diff>@@ -61,5 +61,8 @@ DECLARE_string(onnx_test_input_path);
 DECLARE_string(onnx_test_input_name_file);
 DECLARE_string(onnx_prediction_image_path);
 DECLARE_int32(num_classes);
+
+// emergency detection libtorch
+DECLARE_string(torch_detector_model);
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\inference\onnx\libtorch_obstacle_detector.cc" new_path="modules\perception\inference\onnx\libtorch_obstacle_detector.cc" added_lines="76" deleted_lines="1">
				<diff>@@ -19,6 +19,81 @@
 
 #include &lt;utility&gt;
 #include &lt;vector&gt;
+#include &lt;omp.h&gt;
 
 #include "cyber/common/log.h"
-#include "modules/perception/common/perception_gflags.h"
\ No newline at end of file
+#include "modules/perception/common/perception_gflags.h"
+
+namespace apollo {
+namespace perception {
+namespace inference {
+
+LibtorchObstacleDetection::LibtorchObstacleDetection() : device_(torch::kCPU) {
+  LoadModel();
+}
+
+bool LibtorchObstacleDetection::Evaluate(const std::vector&lt;std::vector&lt;double&gt;&gt;&amp; imageFrame) {
+  // Sanity checks.
+  omp_set_num_threads(1);
+  if (imageFrame.size() == 0) {
+    AERROR &lt;&lt; "Got no channel in image frame!";
+    return false;
+  }
+  if (imageFrame[0].size() == 0) {
+    AERROR &lt;&lt; "Got no image frame in channel 0!";
+    return false;
+  }
+  if (imageFrame[0].size() != 72000) {
+    AERROR &lt;&lt; "imageFrame[0].size() = " &lt;&lt; imageFrame[0].size() &lt;&lt; ", skiping!";
+    return false;
+  }
+  // image imput size is 1920 * 1080 = 2073600
+  torch::Tensor image_tensor = torch::empty(32 * 3 * 3 * 3);
+  float* data = image_tensor.data_ptr&lt;float&gt;();
+
+  for (const auto&amp; channel : imageFrame) {
+    for (const auto&amp; i : channel) {
+      *data++ = static_cast&lt;float&gt;(i) / 32767.0;
+    }
+  }
+
+  torch::Tensor torch_input = torch::from_blob(image_tensor.data_ptr&lt;float&gt;(),
+                                               {32, 3, 3, 3, 3});
+  std::vector&lt;torch::jit::IValue&gt; torch_inputs;
+  torch_inputs.push_back(torch_input.to(device_));
+
+  auto start_time = std::chrono::system_clock::now();
+  at::Tensor torch_output_tensor = torch_model_.forward(torch_inputs).toTensor()
+                                               .to(torch::kCPU);
+
+  auto end_time = std::chrono::system_clock::now();
+  std::chrono::duration&lt;double&gt; diff = end_time - start_time;
+  AINFO &lt;&lt; "LibtorchObstacleDetection used time: " &lt;&lt; diff.count() * 1000 &lt;&lt; " ms.";
+  auto torch_output = torch_output_tensor.accessor&lt;float, 2&gt;();
+
+  // majority vote with 4 channels
+  float neg_score = torch_output[0][0] + torch_output[1][0] +
+                    torch_output[2][0] + torch_output[3][0];
+  float pos_score = torch_output[0][1] + torch_output[1][1] +
+                    torch_output[2][1] + torch_output[3][1];
+  ADEBUG &lt;&lt; "neg_score = " &lt;&lt; neg_score &lt;&lt; ", pos_score = " &lt;&lt; pos_score;
+  if (neg_score &lt; pos_score) {
+    return true;
+  } else {
+    return false;
+  }
+  return true;
+}
+
+void LibtorchObstacleDetection::LoadModel() {
+  if (torch::cuda::is_available()) {
+    AINFO &lt;&lt; "CUDA is available";
+    device_ = torch::Device(torch::kCUDA);
+  }
+  torch::set_num_threads(1);
+  torch_model_ = torch::jit::load(FLAGS_torch_detector_model, device_);
+}
+
+} // inference
+} // perception
+} // apollo
\ No newline at end of file
</diff>
			</file>
			<file old_path="modules\perception\inference\onnx\libtorch_obstacle_detector.h" new_path="modules\perception\inference\onnx\libtorch_obstacle_detector.h" added_lines="2" deleted_lines="2">
				<diff>@@ -26,11 +26,11 @@ namespace inference {
 
 class LibtorchObstacleDetection {
  public:
-  LibtrochObstacleDetection();
+  LibtorchObstacleDetection();
 
   ~LibtorchObstacleDetection() = default;
 
-  bool Evaluate();
+  bool Evaluate(const std::vector&lt;std::vector&lt;double&gt;&gt;&amp; imageFrame);
 
  private:
   void LoadModel();
</diff>
			</file>
			<file old_path="modules\perception\inference\onnx\onnx_obstacle_detector_test.cc" new_path="modules\perception\inference\onnx\libtorch_obstacle_detector_test.cc" added_lines="14" deleted_lines="11">
				<diff>@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *****************************************************************************/
-#include "modules/perception/inference/onnx/onnx_obstacle_detector.h"
+#include "modules/perception/inference/onnx/libtorch_obstacle_detector.h"
 
 #include "gtest/gtest.h"
 
@@ -23,16 +23,19 @@ namespace apollo {
 namespace perception {
 namespace inference {
 
-TEST(OnnxInferenceTest, test) {
-  OnnxObstacleDetector test_onnx_detector(
-    FLAGS_onnx_obstacle_detector_model,
-    FLAGS_num_classes,
-    FLAGS_onnx_test_input_path,
-    FLAGS_onnx_test_input_name_file,
-    FLAGS_onnx_prediction_image_path);
-  test_onnx_detector.Infer();
-  int dummy = 1;
-  EXPECT_EQ(dummy, 1);
+class LibtorchObstacleDetectionTest : public ::testing::Test {
+ public:
+  virtual void SetUp() {}
+
+ protected:
+  LibtorchObstacleDetection obstacle_detection_;
+};
+
+TEST_F(LibtorchObstacleDetectionTest, is_) {
+  std::vector&lt;std::vector&lt;double&gt;&gt; imageFrame(4,
+    (std::vector&lt;double&gt; (2073600, 0.01)));
+  bool result = obstacle_detection_.Evaluate(imageFrame);
+  EXPECT_EQ(result, false);
 }
 
 } // namespace inference
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="602173605d293b13ec1ed8037d0d1730ff81b46d" author="Dontmovedad">
		<msg>Obstacle Detector: fix lint</msg>
		<modified_files>
			<file old_path="modules\perception\inference\onnx\libtorch_obstacle_detector.cc" new_path="modules\perception\inference\onnx\libtorch_obstacle_detector.cc" added_lines="6" deleted_lines="6">
				<diff>@@ -1,4 +1,3 @@
-  
 /******************************************************************************
  * Copyright 2020 The Apollo Authors. All Rights Reserved.
  *
@@ -32,7 +31,8 @@ LibtorchObstacleDetection::LibtorchObstacleDetection() : device_(torch::kCPU) {
   LoadModel();
 }
 
-bool LibtorchObstacleDetection::Evaluate(const std::vector&lt;std::vector&lt;double&gt;&gt;&amp; imageFrame) {
+bool LibtorchObstacleDetection::Evaluate(
+  const std::vector&lt;std::vector&lt;double&gt;&gt;&amp; imageFrame) {
   // Sanity checks.
   omp_set_num_threads(1);
   if (imageFrame.size() == 0) {
@@ -68,7 +68,7 @@ bool LibtorchObstacleDetection::Evaluate(const std::vector&lt;std::vector&lt;double&gt;&gt;&amp;
 
   auto end_time = std::chrono::system_clock::now();
   std::chrono::duration&lt;double&gt; diff = end_time - start_time;
-  AINFO &lt;&lt; "LibtorchObstacleDetection used time: " &lt;&lt; diff.count() * 1000 &lt;&lt; " ms.";
+  AINFO &lt;&lt; "LibtorchDetection used time: " &lt;&lt; diff.count() * 1000 &lt;&lt; " ms.";
   auto torch_output = torch_output_tensor.accessor&lt;float, 2&gt;();
 
   // majority vote with 4 channels
@@ -94,6 +94,6 @@ void LibtorchObstacleDetection::LoadModel() {
   torch_model_ = torch::jit::load(FLAGS_torch_detector_model, device_);
 }
 
-} // inference
-} // perception
-} // apollo
\ No newline at end of file
+}  // namespace inference
+}  // namespace perception
+}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\inference\onnx\libtorch_obstacle_detector.h" new_path="modules\perception\inference\onnx\libtorch_obstacle_detector.h" added_lines="3" deleted_lines="3">
				<diff>@@ -40,6 +40,6 @@ class LibtorchObstacleDetection {
   torch::Device device_;
 };
 
-}  // inference
-}  // perception
-}  // apollo
+}  // namespace inference
+}  // namespace perception
+}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\inference\onnx\libtorch_obstacle_detector_test.cc" new_path="modules\perception\inference\onnx\libtorch_obstacle_detector_test.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -38,6 +38,6 @@ TEST_F(LibtorchObstacleDetectionTest, is_) {
   EXPECT_EQ(result, false);
 }
 
-} // namespace inference
-} // namespace perception
-} // namespace apollo
\ No newline at end of file
+}  // namespace inference
+}  // namespace perception
+}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\inference\onnx\onnx_obstacle_detector.cc" new_path="modules\perception\inference\onnx\onnx_obstacle_detector.cc" added_lines="76" deleted_lines="51">
				<diff>@@ -92,9 +92,8 @@ OnnxObstacleDetector::~OnnxObstacleDetector() {}
 
 void OnnxObstacleDetector::OnnxToTRTModel(
     const std::string&amp; model_file,  // name of the onnx model
-    nvinfer1::IHostMemory** trt_model_stream) {  // output buffer for the TensorRT model
+    nvinfer1::IHostMemory** trt_model_stream) {
   int verbosity = static_cast&lt;int&gt;(nvinfer1::ILogger::Severity::kWARNING);
-
   int kBatchSize = 1;
 
   // create the builder
@@ -119,7 +118,7 @@ void OnnxObstacleDetector::OnnxToTRTModel(
   config-&gt;setMaxWorkspaceSize(1&lt;&lt;20);
   config-&gt;setFlag(nvinfer1::BuilderFlag::kFP16);
   nvinfer1::ICudaEngine* engine =
-      builder-&gt;buildEngineWithConfig(*network, *config);
+  builder-&gt;buildEngineWithConfig(*network, *config);
 
   // serialize the engine, then close everything down
   *trt_model_stream = engine-&gt;serialize();
@@ -128,14 +127,13 @@ void OnnxObstacleDetector::OnnxToTRTModel(
   network-&gt;destroy();
   config-&gt;destroy();
   builder-&gt;destroy();
-  
+
   engine-&gt;destroy();
 }
 
 void OnnxObstacleDetector::TRTStreamToContext(
-  const nvinfer1::IHostMemory* yolov4_trt_model_stream, 
+  const nvinfer1::IHostMemory* yolov4_trt_model_stream,
   nvinfer1::IExecutionContext** context_ptr) {
-
   nvinfer1::ICudaEngine* engine;
   nvinfer1::IRuntime* runtime;
 
@@ -146,8 +144,9 @@ void OnnxObstacleDetector::TRTStreamToContext(
   }
 
   engine = runtime-&gt;deserializeCudaEngine(
-      yolov4_trt_model_stream-&gt;data(), yolov4_trt_model_stream-&gt;size(), nullptr);
-
+    yolov4_trt_model_stream-&gt;data(),
+    yolov4_trt_model_stream-&gt;size(),
+    nullptr);
   if (engine == nullptr) {
     std::cerr &lt;&lt; "Failed to create TensorRT Engine." &lt;&lt; std::endl;
   }
@@ -165,13 +164,15 @@ void OnnxObstacleDetector::TRTStreamToContext(
 void OnnxObstacleDetector::TRTStreamToContext(
   const std::vector&lt;char&gt;&amp; trt_model_stream,
   nvinfer1::IExecutionContext** context_ptr) {
-
   nvinfer1::IRuntime* runtime = nvinfer1::createInferRuntime(g_logger_);
   if (runtime == nullptr) {
     std::cerr &lt;&lt; "Failed to create TensorRT Runtime object." &lt;&lt; std::endl;
   }
 
-  nvinfer1::ICudaEngine* engine = runtime-&gt;deserializeCudaEngine(trt_model_stream.data(), trt_model_stream.size(), nullptr);
+  nvinfer1::ICudaEngine* engine = runtime-&gt;deserializeCudaEngine(
+    trt_model_stream.data(),
+    trt_model_stream.size(),
+    nullptr);
 
   if (engine == nullptr) {
     std::cerr &lt;&lt; "Failed to create TensorRT Engine." &lt;&lt; std::endl;
@@ -191,46 +192,51 @@ void OnnxObstacleDetector::postProcessing(cv::Mat&amp; img,
   float* output, int row_cnt,
   int num_classes,
   const std::vector&lt;std::string&gt;&amp; names) {
-  //TODO, only draw the bbox with higheest confidence.
   int col_cnt = num_classes + 4;
-
-  int maxid_i; // instance id
-  int maxid_j; // class id
+  int maxid_i;  // instance id
+  int maxid_j;  // class id
   float maxv = -1;
-  for (int i=0; i&lt;row_cnt; i++){
-    for (int j=4; j&lt;col_cnt; j++){
+  for (int i=0; i &lt; row_cnt; i++) {
+    for (int j=4; j &lt; col_cnt; j++) {
       float v = output[i*col_cnt+j];
-      if (maxv &lt; v &amp;&amp; v &gt; -2 &amp;&amp; v &lt; 2){
+      if (maxv &lt; v &amp;&amp; v &gt; -2 &amp;&amp; v &lt; 2) {
         maxv = v;
         maxid_i = i;
         maxid_j = j;
       }
     }
   }
-
   int width = img.cols;
   int height = img.rows;
   float* best_box = output + col_cnt * maxid_i;
-  int x1 = int((best_box[0] - best_box[2] / 2.0) * width);
-  int y1 = int((best_box[1] - best_box[3] / 2.0) * height);
-  int x2 = int((best_box[0] + best_box[2] / 2.0) * width);
-  int y2 = int((best_box[1] + best_box[3] / 2.0) * height);
-
-  cv::rectangle(img, cv::Point(x1,y1), cv::Point(x2,y2), cv::Scalar(0, 255, 0));
-  cv::putText(img, names[maxid_j-4], cv::Point2f(x1,y1), cv::FONT_HERSHEY_SIMPLEX, 1.2, cv::Scalar(0,0,255,255), 1);
+  int x1 = static_cast&lt;int&gt;((best_box[0] - best_box[2] / 2.0) * width);
+  int y1 = static_cast&lt;int&gt;((best_box[1] - best_box[3] / 2.0) * height);
+  int x2 = static_cast&lt;int&gt;((best_box[0] + best_box[2] / 2.0) * width);
+  int y2 = static_cast&lt;int&gt;((best_box[1] + best_box[3] / 2.0) * height);
+
+  cv::rectangle(img,
+    cv::Point(x1, y1),
+    cv::Point(x2, y2),
+    cv::Scalar(0, 255, 0));
+  cv::putText(img, names[maxid_j-4],
+    cv::Point2f(x1, y1),
+    cv::FONT_HERSHEY_SIMPLEX,
+    1.2,
+    cv::Scalar(0, 0, 255, 255),
+    1);
 }
 
-void OnnxObstacleDetector::inference(nvinfer1::IExecutionContext* yolov4_context_, 
-  int num_classes, const std::vector&lt;std::string&gt;&amp; names, 
-  const std::string&amp; image_path, const std::string&amp; prediction_image_path) {
-
+void OnnxObstacleDetector::inference(
+  nvinfer1::IExecutionContext* yolov4_context_,
+  int num_classes, const std::vector&lt;std::string&gt;&amp; names,
+  const std::string&amp; image_path,
+  const std::string&amp; prediction_image_path) {
   cv::Mat img_ori = cv::imread(image_path);
 
-  if (img_ori.empty()){
+  if (img_ori.empty()) {
     std::cout &lt;&lt; "Load image fail: " &lt;&lt; image_path &lt;&lt; std::endl;
     return;
-  }
-  else{
+  } else {
     std::cout &lt;&lt; "Load image success: " &lt;&lt; image_path &lt;&lt; std::endl;
   }
 
@@ -247,36 +253,46 @@ void OnnxObstacleDetector::inference(nvinfer1::IExecutionContext* yolov4_context
 
   int input_length = tot_length * sizeof(float);
   int row_cnt = 10647;
-  int output_length = 1 * row_cnt * (num_classes + 4) * sizeof(float); //3577392
+  int output_length = 1 *
+    row_cnt * (num_classes + 4) * sizeof(float);  // 3577392
 
-  float* input_image_ = (float*) malloc(input_length);
+  float* input_image_ = reinterpret_cast&lt;float*&gt;(malloc(input_length));
 
-  for (int i=0; i&lt;img.rows; i++){
-    for (int j=0; j&lt;img.cols; j++){
-      for (int k=0; k&lt;3; k++){
-        input_image_[k*img.rows*img.cols + i*img.cols + j] = static_cast&lt;float&gt;(img.data[i*img.cols*3+j*3+k]) / 255.0;
+  for (int i = 0; i &lt; img.rows; i++) {
+    for (int j = 0; j &lt; img.cols; j++) {
+      for (int k = 0; k &lt; 3; k++) {
+        input_image_[k*img.rows*img.cols + i*img.cols + j] =
+        static_cast&lt;float&gt;(img.data[i*img.cols*3+j*3+k]) / 255.0;
       }
     }
   }
 
   void* buffers[2];
   GPU_CHECK(cudaMalloc(&amp;buffers[0], input_length));
-  GPU_CHECK(cudaMemcpy(buffers[0], input_image_, input_length, cudaMemcpyHostToDevice));
+  GPU_CHECK(cudaMemcpy(buffers[0],
+    input_image_,
+    input_length,
+    cudaMemcpyHostToDevice));
 
   GPU_CHECK(cudaMalloc(&amp;buffers[1], output_length));
   GPU_CHECK(cudaMemset(buffers[1], 0, output_length));
-  
+
   yolov4_context_-&gt;enqueueV2(buffers, stream, nullptr);
   std::cout &lt;&lt; "Inference success" &lt;&lt; std::endl;
 
-  float* output = (float*) malloc(output_length);
-  GPU_CHECK(cudaMemcpy(output, buffers[1], output_length, cudaMemcpyDeviceToHost));
+  float* output = reinterpret_cast&lt;float*&gt;(malloc(output_length));
+  GPU_CHECK(
+    cudaMemcpy(
+      output,
+      buffers[1],
+      output_length,
+      cudaMemcpyDeviceToHost));
 
   postProcessing(img_ori, output, row_cnt, num_classes, names);
 
   cv::imwrite(prediction_image_path, img_ori);
-  std::cout &lt;&lt; "Save prediction image to " &lt;&lt; prediction_image_path &lt;&lt; std::endl;
-
+  std::cout &lt;&lt; "Save prediction image to "
+    &lt;&lt; prediction_image_path &lt;&lt; std::endl;
   GPU_CHECK(cudaFree(buffers[0]));
   GPU_CHECK(cudaFree(buffers[1]));
   free(input_image_);
@@ -289,13 +305,18 @@ void OnnxObstacleDetector::readNames(
   std::vector&lt;std::string&gt;&amp; names) {
   std::ifstream f_names(names_file_path);
   std::string s;
-  while (std::getline(f_names, s)){
+  while (std::getline(f_names, s)) {
     names.push_back(s);
   }
 }
 
-bool OnnxObstacleDetector::Init(const std::map&lt;std::string, std::vector&lt;int&gt;&gt; &amp;shapes) {
-  std::cout &lt;&lt; NV_TENSORRT_MAJOR  &lt;&lt; "." &lt;&lt; NV_TENSORRT_MINOR &lt;&lt; "." &lt;&lt; NV_TENSORRT_PATCH &lt;&lt; "." &lt;&lt; NV_TENSORRT_BUILD  &lt;&lt; std::endl;
+bool OnnxObstacleDetector::Init(
+  const std::map&lt;std::string,
+  std::vector&lt;int&gt;&gt; &amp;shapes) {
+  std::cout &lt;&lt; NV_TENSORRT_MAJOR
+  &lt;&lt; "." &lt;&lt; NV_TENSORRT_MINOR &lt;&lt; "."
+  &lt;&lt; NV_TENSORRT_PATCH &lt;&lt; "."
+  &lt;&lt; NV_TENSORRT_BUILD  &lt;&lt; std::endl;
   return true;
 }
 
@@ -306,7 +327,11 @@ void OnnxObstacleDetector::Infer() {
   TRTStreamToContext(trt_stream, &amp;context_);
 
   readNames(names_file_path_, names_);
-  inference(context_, num_classes_, names_, image_path_, prediction_image_path_);
+  inference(context_,
+    num_classes_,
+    names_,
+    image_path_,
+    prediction_image_path_);
 
   trt_stream-&gt;destroy();
 }
@@ -319,6 +344,6 @@ BlobPtr OnnxObstacleDetector::get_blob(const std::string &amp;name) {
   return iter-&gt;second;
 }
 
-} // namespace inference
-} // namespace perception
-} // namespace apollo
\ No newline at end of file
+}  // namespace inference
+}  // namespace perception
+}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\inference\onnx\onnx_obstacle_detector.h" new_path="modules\perception\inference\onnx\onnx_obstacle_detector.h" added_lines="15" deleted_lines="14">
				<diff>@@ -42,7 +42,7 @@ namespace inference {
 using BlobPtr = std::shared_ptr&lt;apollo::perception::base::Blob&lt;float&gt;&gt;;
 
 class OnnxObstacleDetector : public Inference {
-public:
+ public:
   OnnxObstacleDetector(const std::string &amp;model_file,
                         const int num_classes,
                         const std::string &amp;input_image_file,
@@ -53,37 +53,38 @@ public:
                         const std::vector&lt;std::string&gt; &amp;outputs,
                         const std::vector&lt;std::string&gt; &amp;inputs);
 
-	virtual ~OnnxObstacleDetector();
+  virtual ~OnnxObstacleDetector();
 
   void OnnxToTRTModel(const std::string&amp; model_file,
     nvinfer1::IHostMemory** trt_model_stream);
 
   void TRTStreamToContext(
-  const nvinfer1::IHostMemory* yolov4_trt_model_stream, 
+  const nvinfer1::IHostMemory* yolov4_trt_model_stream,
   nvinfer1::IExecutionContext** context_ptr);
 
   void TRTStreamToContext(
   const std::vector&lt;char&gt;&amp; trt_model_stream,
   nvinfer1::IExecutionContext** context_ptr);
 
-  void postProcessing(cv::Mat&amp; img,
+  void postProcessing(
+  const cv::Mat&amp; img,
   float* output, int row_cnt,
   int num_classes,
   const std::vector&lt;std::string&gt;&amp; names);
 
-  void inference(nvinfer1::IExecutionContext* yolov4_context_, 
-  int num_classes, const std::vector&lt;std::string&gt;&amp; names, 
+  void inference(nvinfer1::IExecutionContext* yolov4_context_,
+  int num_classes, const std::vector&lt;std::string&gt;&amp; names,
   const std::string&amp; image_path, const std::string&amp; prediction_image_path);
 
   void readNames(
   const std::string&amp; names_file_path,
-  std::vector&lt;std::string&gt;&amp; names);
+  const std::vector&lt;std::string&gt;&amp; names);
 
-	bool Init(const std::map&lt;std::string, std::vector&lt;int&gt;&gt; &amp;shapes) override;
-	void Infer() override;
+  bool Init(const std::map&lt;std::string, std::vector&lt;int&gt;&gt; &amp;shapes) override;
+  void Infer() override;
   BlobPtr get_blob(const std::string &amp;name) override;
 
-private:
+ private:
   std::string model_file_;
   std::vector&lt;std::string&gt; output_names_;
   std::vector&lt;std::string&gt; input_names_;
@@ -93,10 +94,10 @@ private:
   int num_classes_;
   std::vector&lt;std::string&gt; names_;
   std::string image_path_;
-  std::string names_file_path_; // coco.names
+  std::string names_file_path_;  // coco.names
   std::string prediction_image_path_;
 };
 
-} // namespace inference
-} // namespace perception
-} // namespace apollo
\ No newline at end of file
+}  // namespace inference
+}  // namespace perception
+}  // namespace apollo
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="da20d18aa3b8832cbc4d63aeeea630c0a8eefefb" author="Dontmovedad">
		<msg>Obstacle Detector: fix build error</msg>
		<modified_files>
			<file old_path="modules\perception\inference\onnx\onnx_obstacle_detector.cc" new_path="modules\perception\inference\onnx\onnx_obstacle_detector.cc" added_lines="8" deleted_lines="6">
				<diff>@@ -188,8 +188,9 @@ void OnnxObstacleDetector::TRTStreamToContext(
   std::cout &lt;&lt; "Create context success" &lt;&lt; std::endl;
 }
 
-void OnnxObstacleDetector::postProcessing(cv::Mat&amp; img,
-  float* output, int row_cnt,
+void OnnxObstacleDetector::postProcessing(const cv::Mat&amp; img,
+  float* output,
+  int row_cnt,
   int num_classes,
   const std::vector&lt;std::string&gt;&amp; names) {
   int col_cnt = num_classes + 4;
@@ -302,11 +303,11 @@ void OnnxObstacleDetector::inference(
 
 void OnnxObstacleDetector::readNames(
   const std::string&amp; names_file_path,
-  std::vector&lt;std::string&gt;&amp; names) {
+  std::vector&lt;std::string&gt;* names) {
   std::ifstream f_names(names_file_path);
   std::string s;
   while (std::getline(f_names, s)) {
-    names.push_back(s);
+    names-&gt;push_back(s);
   }
 }
 
@@ -326,10 +327,11 @@ void OnnxObstacleDetector::Infer() {
 
   TRTStreamToContext(trt_stream, &amp;context_);
 
-  readNames(names_file_path_, names_);
+  std::vector&lt;std::string&gt;* names =  new std::vector&lt;std::string&gt;;
+  readNames(names_file_path_, names);
   inference(context_,
     num_classes_,
-    names_,
+    *names,
     image_path_,
     prediction_image_path_);
 
</diff>
			</file>
			<file old_path="modules\perception\inference\onnx\onnx_obstacle_detector.h" new_path="modules\perception\inference\onnx\onnx_obstacle_detector.h" added_lines="1" deleted_lines="2">
				<diff>@@ -78,7 +78,7 @@ class OnnxObstacleDetector : public Inference {
 
   void readNames(
   const std::string&amp; names_file_path,
-  const std::vector&lt;std::string&gt;&amp; names);
+  std::vector&lt;std::string&gt;* names);
 
   bool Init(const std::map&lt;std::string, std::vector&lt;int&gt;&gt; &amp;shapes) override;
   void Infer() override;
@@ -92,7 +92,6 @@ class OnnxObstacleDetector : public Inference {
   nvinfer1::IExecutionContext* context_;
 
   int num_classes_;
-  std::vector&lt;std::string&gt; names_;
   std::string image_path_;
   std::string names_file_path_;  // coco.names
   std::string prediction_image_path_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="49fb6f639749a6a6165b18351cf31caff36d1d6a" author="Dontmovedad">
		<msg>fix test</msg>
		<modified_files>
			<file old_path="modules\perception\inference\onnx\libtorch_obstacle_detector.cc" new_path="modules\perception\inference\onnx\libtorch_obstacle_detector.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -36,15 +36,15 @@ bool LibtorchObstacleDetection::Evaluate(
   // Sanity checks.
   omp_set_num_threads(1);
   if (imageFrame.size() == 0) {
-    AERROR &lt;&lt; "Got no channel in image frame!";
+    AINFO &lt;&lt; "Got no channel in image frame!";
     return false;
   }
   if (imageFrame[0].size() == 0) {
-    AERROR &lt;&lt; "Got no image frame in channel 0!";
+    AINFO &lt;&lt; "Got no image frame in channel 0!";
     return false;
   }
   if (imageFrame[0].size() != 72000) {
-    AERROR &lt;&lt; "imageFrame[0].size() = " &lt;&lt; imageFrame[0].size() &lt;&lt; ", skiping!";
+    AINFO &lt;&lt; "imageFrame[0].size() = " &lt;&lt; imageFrame[0].size() &lt;&lt; ", skiping!";
     return false;
   }
   // image imput size is 1920 * 1080 = 2073600
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e260fd09d0381daade3dc4704503d330ebfdc3c3" author="Guodong Rong">
		<msg>Use two buffers to handle message larger than 65536 bytes.</msg>
		<modified_files>
			<file old_path="modules\contrib\cyber_bridge\client.cc" new_path="modules\contrib\cyber_bridge\client.cc" added_lines="47" deleted_lines="23">
				<diff>@@ -12,6 +12,7 @@
 #include &lt;utility&gt;
 
 #include "boost/bind.hpp"
+
 #include "cyber/common/log.h"
 #include "cyber/message/protobuf_factory.h"
 #include "modules/contrib/cyber_bridge/clients.h"
@@ -93,12 +94,24 @@ void Client::handle_read(const boost::system::error_code&amp; ec,
 }
 
 void Client::handle_write(const boost::system::error_code&amp; ec) {
-  if (ec &amp;&amp; ec != boost::asio::error::operation_aborted) {
-    AERROR &lt;&lt; "Client write failed, disconnecting" &lt;&lt; ec;
-    clients.stop(shared_from_this());
-    node.remove(shared_from_this());
+  if (ec) {
+    if (ec != boost::asio::error::operation_aborted) {
+      AERROR &lt;&lt; "Client write failed, disconnecting" &lt;&lt; ec;
+      clients.stop(shared_from_this());
+      node.remove(shared_from_this());
+    }
     return;
   }
+
+  std::lock_guard&lt;std::mutex&gt; lock(publish_mutex);
+  writing.clear();
+  if (!pending.empty()) {
+    writing.swap(pending);
+    boost::asio::async_write(
+        socket, boost::asio::buffer(writing.data(), writing.size()),
+        boost::bind(&amp;Client::handle_write, shared_from_this(),
+                    boost::asio::placeholders::error));
+  }
 }
 
 // [1] [count] [string] ... [string]
@@ -255,32 +268,43 @@ void Client::handle_publish() {
   buffer.erase(buffer.begin(), buffer.begin() + offset);
 }
 
-void Client::publish(const std::string&amp; channel, const std::string&amp; msg) {
-  std::vector&lt;uint8_t&gt; data;
-  data.reserve(sizeof(uint8_t) + sizeof(uint32_t) + channel.size() +
-               sizeof(uint32_t) + msg.size());
+void fill_data(std::vector&lt;uint8_t&gt;* data, const std::string&amp; channel,
+               const std::string&amp; msg) {
+  data-&gt;reserve(data-&gt;size() + sizeof(uint8_t) + sizeof(uint32_t) +
+                channel.size() + sizeof(uint32_t) + msg.size());
 
-  data.push_back(OP_PUBLISH);
+  data-&gt;push_back(OP_PUBLISH);
 
-  data.push_back(uint8_t(channel.size() &gt;&gt; 0));
-  data.push_back(uint8_t(channel.size() &gt;&gt; 8));
-  data.push_back(uint8_t(channel.size() &gt;&gt; 16));
-  data.push_back(uint8_t(channel.size() &gt;&gt; 24));
+  data-&gt;push_back(uint8_t(channel.size() &gt;&gt; 0));
+  data-&gt;push_back(uint8_t(channel.size() &gt;&gt; 8));
+  data-&gt;push_back(uint8_t(channel.size() &gt;&gt; 16));
+  data-&gt;push_back(uint8_t(channel.size() &gt;&gt; 24));
   const uint8_t* channel_data =
       reinterpret_cast&lt;const uint8_t*&gt;(channel.data());
-  data.insert(data.end(), channel_data, channel_data + channel.size());
+  data-&gt;insert(data-&gt;end(), channel_data, channel_data + channel.size());
 
-  data.push_back(uint8_t(msg.size() &gt;&gt; 0));
-  data.push_back(uint8_t(msg.size() &gt;&gt; 8));
-  data.push_back(uint8_t(msg.size() &gt;&gt; 16));
-  data.push_back(uint8_t(msg.size() &gt;&gt; 24));
+  data-&gt;push_back(uint8_t(msg.size() &gt;&gt; 0));
+  data-&gt;push_back(uint8_t(msg.size() &gt;&gt; 8));
+  data-&gt;push_back(uint8_t(msg.size() &gt;&gt; 16));
+  data-&gt;push_back(uint8_t(msg.size() &gt;&gt; 24));
   const uint8_t* msg_data = reinterpret_cast&lt;const uint8_t*&gt;(msg.data());
-  data.insert(data.end(), msg_data, msg_data + msg.size());
+  data-&gt;insert(data-&gt;end(), msg_data, msg_data + msg.size());
+}
 
-  boost::asio::async_write(
-      socket, boost::asio::buffer(data.data(), data.size()),
-      boost::bind(&amp;Client::handle_write, shared_from_this(),
-                  boost::asio::placeholders::error));
+void Client::publish(const std::string&amp; channel, const std::string&amp; msg) {
+  std::lock_guard&lt;std::mutex&gt; lock(publish_mutex);
+  if (writing.empty()) {
+    fill_data(&amp;writing, channel, msg);
+    boost::asio::async_write(
+        socket, boost::asio::buffer(writing.data(), writing.size()),
+        boost::bind(&amp;Client::handle_write, shared_from_this(),
+                    boost::asio::placeholders::error));
+  } else if (pending.size() &lt; MAX_PENDING_SIZE) {
+    fill_data(&amp;pending, channel, msg);
+  } else {
+    // If pending size is larger than MAX_PENDING_SIZE, discard the message.
+    AERROR &lt;&lt; "Pending size too large. Discard message.";
+  }
 }
 
 uint32_t Client::get32le(size_t offset) const {
</diff>
			</file>
			<file old_path="modules\contrib\cyber_bridge\client.h" new_path="modules\contrib\cyber_bridge\client.h" added_lines="5" deleted_lines="2">
				<diff>@@ -17,8 +17,7 @@ class Node;
 
 class Client : public std::enable_shared_from_this&lt;Client&gt; {
  public:
-  Client(Node* node, Clients* clients,
-         boost::asio::ip::tcp::socket socket);
+  Client(Node* node, Clients* clients, boost::asio::ip::tcp::socket socket);
   ~Client();
 
   void start();
@@ -34,6 +33,10 @@ class Client : public std::enable_shared_from_this&lt;Client&gt; {
 
   uint8_t temp[1024 * 1024];
   std::vector&lt;uint8_t&gt; buffer;
+  std::vector&lt;uint8_t&gt; writing;
+  std::vector&lt;uint8_t&gt; pending;
+  std::mutex publish_mutex;
+  const uint MAX_PENDING_SIZE = 1073741824;  // 1GB
 
   void handle_read(const boost::system::error_code&amp; ec, std::size_t length);
   void handle_write(const boost::system::error_code&amp; ec);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f5cef629673d2cabe8145820830630822dc1fb2e" author="storypku">
		<msg>Build: bazel target split for LiDAR utils</msg>
		<modified_files>
			<file old_path="modules\perception\common\graph\secure_matrix.h" new_path="modules\perception\common\graph\secure_matrix.h" added_lines="14" deleted_lines="10">
				<diff>@@ -16,6 +16,9 @@
 
 #pragma once
 
+#include &lt;algorithm&gt;
+#include &lt;string&gt;
+
 #include "Eigen/Dense"
 
 namespace apollo {
@@ -28,7 +31,7 @@ class SecureMat {
   EIGEN_MAKE_ALIGNED_OPERATOR_NEW
 
  public:
-  SecureMat() : height_(0), width_(0) { Reserve(max_height_, max_width_); }
+  SecureMat() { Reserve(max_height_, max_width_); }
 
   size_t height() { return height_; }
   size_t width() { return width_; }
@@ -36,10 +39,10 @@ class SecureMat {
   /* @brief: reserve memory of SecureMat
    * @params[IN] reserve_height: height of reserve memory
    * @params[IN] reserve_width: width of reserve memory
-   * @return nothing */
+   */
   void Reserve(const size_t reserve_height, const size_t reserve_width) {
-    max_height_ = (reserve_height &gt; max_height_) ? reserve_height : max_height_;
-    max_width_ = (reserve_width &gt; max_width_) ? reserve_width : max_width_;
+    max_height_ = std::max(reserve_height, max_height_);
+    max_width_ = std::max(reserve_width, max_width_);
     mat_.resize(max_height_, max_width_);
   }
 
@@ -53,19 +56,20 @@ class SecureMat {
     if (resize_height &lt;= max_height_ &amp;&amp; resize_width &lt;= max_width_) {
       return;
     }
-    max_height_ = (resize_height &gt; max_height_) ? resize_height : max_height_;
-    max_width_ = (resize_width &gt; max_width_) ? resize_width : max_width_;
+    max_height_ = std::max(resize_height, max_height_);
+    max_width_ = std::max(resize_width, max_width_);
     mat_.resize(max_height_, max_width_);
   }
 
-  void ToString(std::ostream* out_stream) {
-    std::ostream&amp; stream = *out_stream;
+  std::string ToString() const {
+    std::ostringstream oss;
     for (size_t row = 0; row &lt; height_; ++row) {
       for (size_t col = 0; col &lt; width_; ++col) {
-        stream &lt;&lt; mat_(row, col) &lt;&lt; "\t";
+        oss &lt;&lt; mat_(row, col) &lt;&lt; "\t";
       }
-      stream &lt;&lt; "\n";
+      oss &lt;&lt; "\n";
     }
+    return oss.str();
   }
 
   inline const T&amp; operator()(const size_t row, const size_t col) const {
</diff>
			</file>
			<file old_path="modules\perception\common\graph\secure_matrix_test.cc" new_path="modules\perception\common\graph\secure_matrix_test.cc" added_lines="0" deleted_lines="1">
				<diff>@@ -59,7 +59,6 @@ TEST(SecureMatTest, test_fill_mat) {
   test_mat(0, 1) = 2;
   test_mat(1, 0) = 3;
   test_mat(1, 1) = 4;
-  test_mat.ToString(&amp;std::cout);
   EXPECT_EQ(1, test_mat(0, 0));
   EXPECT_EQ(2, test_mat(0, 1));
   EXPECT_EQ(3, test_mat(1, 0));
</diff>
			</file>
			<file old_path="modules\perception\tool\benchmark\lidar\util\types.h" new_path="modules\perception\tool\benchmark\lidar\util\types.h" added_lines="22" deleted_lines="11">
				<diff>@@ -78,17 +78,28 @@ struct PointXYZIL {
 }  // namespace perception
 }  // namespace apollo
 
-POINT_CLOUD_REGISTER_POINT_STRUCT(apollo::perception::benchmark::PointXYZIT,
-                                  (float, x, x)(float, y, y)(float, z, z)(
-                                      uint8_t, intensity,
-                                      intensity)(double, timestamp, timestamp))
+POINT_CLOUD_REGISTER_POINT_STRUCT(
+        apollo::perception::benchmark::PointXYZIT,
+        (float, x, x)
+        (float, y, y)
+        (float, z, z)
+        (std::uint8_t, intensity, intensity)
+        (double, timestamp, timestamp)
+)
 
-POINT_CLOUD_REGISTER_POINT_STRUCT(apollo::perception::benchmark::PointXYZL,
-                                  (float, x, x)(float, y, y)(float, z,
-                                                             z)(uint32_t, label,
-                                                                label))
+POINT_CLOUD_REGISTER_POINT_STRUCT(
+        apollo::perception::benchmark::PointXYZL,
+        (float, x, x)
+        (float, y, y)
+        (float, z, z)
+        (std::uint32_t, label, label)
+)
 
 POINT_CLOUD_REGISTER_POINT_STRUCT(
-    apollo::perception::benchmark::PointXYZIL,
-    (float, x, x)(float, y, y)(float, z, z)(float, intensity,
-                                            intensity)(uint32_t, label, label))
+        apollo::perception::benchmark::PointXYZIL,
+        (float, x, x)
+        (float, y, y)
+        (float, z, z)
+        (float, intensity, intensity)
+        (std::uint32_t, label, label)
+)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8ce0d74eb2e4b7c2d6c7e618fd72c24562dab1ba" author="Dontmovedad">
		<msg>Obstacel Detector: Fix inference input dimension</msg>
		<modified_files>
			<file old_path="modules\perception\inference\onnx\libtorch_obstacle_detector.cc" new_path="modules\perception\inference\onnx\libtorch_obstacle_detector.cc" added_lines="11" deleted_lines="9">
				<diff>@@ -32,33 +32,35 @@ LibtorchObstacleDetection::LibtorchObstacleDetection() : device_(torch::kCPU) {
 }
 
 bool LibtorchObstacleDetection::Evaluate(
-  const std::vector&lt;std::vector&lt;double&gt;&gt;&amp; imageFrame) {
+  const std::vector&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt;&amp; imageFrame) {
   // Sanity checks.
   omp_set_num_threads(1);
   if (imageFrame.size() == 0) {
-    AINFO &lt;&lt; "Got no channel in image frame!";
+    AERROR &lt;&lt; "Got no channel in image frame!";
     return false;
   }
   if (imageFrame[0].size() == 0) {
-    AINFO &lt;&lt; "Got no image frame in channel 0!";
+    AERROR &lt;&lt; "Got no image frame in channel 0!";
     return false;
   }
-  if (imageFrame[0].size() != 72000) {
-    AINFO &lt;&lt; "imageFrame[0].size() = " &lt;&lt; imageFrame[0].size() &lt;&lt; ", skiping!";
+  if (imageFrame[0].size() != 369664) {
+    AERROR &lt;&lt; "imageFrame[0].size() = " &lt;&lt; imageFrame[0].size() &lt;&lt; ", skiping!";
     return false;
   }
-  // image imput size is 1920 * 1080 = 2073600
-  torch::Tensor image_tensor = torch::empty(32 * 3 * 3 * 3);
+  // image imput size is 608 * 608 = 369664
+  torch::Tensor image_tensor = torch::empty(1 * 3 * 608 * 608);
   float* data = image_tensor.data_ptr&lt;float&gt;();
 
   for (const auto&amp; channel : imageFrame) {
     for (const auto&amp; i : channel) {
-      *data++ = static_cast&lt;float&gt;(i) / 32767.0;
+      for (const auto&amp; j : i) {
+        *data++ = static_cast&lt;float&gt;(j) / 255.0;
+      }
     }
   }
 
   torch::Tensor torch_input = torch::from_blob(image_tensor.data_ptr&lt;float&gt;(),
-                                               {32, 3, 3, 3, 3});
+                                               {1, 3, 608, 608});
   std::vector&lt;torch::jit::IValue&gt; torch_inputs;
   torch_inputs.push_back(torch_input.to(device_));
 
</diff>
			</file>
			<file old_path="modules\perception\inference\onnx\libtorch_obstacle_detector.h" new_path="modules\perception\inference\onnx\libtorch_obstacle_detector.h" added_lines="5" deleted_lines="1">
				<diff>@@ -20,6 +20,10 @@
 #include "torch/script.h"
 #include "torch/torch.h"
 
+#include "opencv2/core/core.hpp"
+#include "opencv2/highgui/highgui.hpp"
+#include "opencv2/imgproc/imgproc.hpp"
+
 namespace apollo {
 namespace perception {
 namespace inference {
@@ -30,7 +34,7 @@ class LibtorchObstacleDetection {
 
   ~LibtorchObstacleDetection() = default;
 
-  bool Evaluate(const std::vector&lt;std::vector&lt;double&gt;&gt;&amp; imageFrame);
+  bool Evaluate(const std::vector&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt;&amp; imageFrame);
 
  private:
   void LoadModel();
</diff>
			</file>
			<file old_path="modules\perception\inference\onnx\libtorch_obstacle_detector_test.cc" new_path="modules\perception\inference\onnx\libtorch_obstacle_detector_test.cc" added_lines="1" deleted_lines="2">
				<diff>@@ -32,8 +32,7 @@ class LibtorchObstacleDetectionTest : public ::testing::Test {
 };
 
 TEST_F(LibtorchObstacleDetectionTest, is_) {
-  std::vector&lt;std::vector&lt;double&gt;&gt; imageFrame(4,
-    (std::vector&lt;double&gt; (2073600, 0.01)));
+  std::vector&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt;imageFrame(3, std::vector&lt;std::vector&lt;double&gt;&gt;(608, std::vector&lt;double&gt;(608, 0.01)));
   bool result = obstacle_detection_.Evaluate(imageFrame);
   EXPECT_EQ(result, false);
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="12585807f36e9e622de26bdbadf23cc5e0f79e48" author="Dontmovedad">
		<msg>Obstacle Detector: fix lint</msg>
		<modified_files>
			<file old_path="modules\perception\inference\onnx\libtorch_obstacle_detector.h" new_path="modules\perception\inference\onnx\libtorch_obstacle_detector.h" added_lines="2" deleted_lines="1">
				<diff>@@ -34,7 +34,8 @@ class LibtorchObstacleDetection {
 
   ~LibtorchObstacleDetection() = default;
 
-  bool Evaluate(const std::vector&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt;&amp; imageFrame);
+  bool Evaluate(
+    const std::vector&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt;&amp; imageFrame);
 
  private:
   void LoadModel();
</diff>
			</file>
			<file old_path="modules\perception\inference\onnx\libtorch_obstacle_detector_test.cc" new_path="modules\perception\inference\onnx\libtorch_obstacle_detector_test.cc" added_lines="3" deleted_lines="1">
				<diff>@@ -32,7 +32,9 @@ class LibtorchObstacleDetectionTest : public ::testing::Test {
 };
 
 TEST_F(LibtorchObstacleDetectionTest, is_) {
-  std::vector&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt;imageFrame(3, std::vector&lt;std::vector&lt;double&gt;&gt;(608, std::vector&lt;double&gt;(608, 0.01)));
+  std::vector&lt;std::vector&lt;std::vector&lt;double&gt; &gt; &gt;imageFrame(3,
+    std::vector&lt;std::vector&lt;double&gt; &gt;(608,
+    std::vector&lt;double&gt;(608, 0.01)));
   bool result = obstacle_detection_.Evaluate(imageFrame);
   EXPECT_EQ(result, false);
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9fd69f0d3ab5d215616cc77dea85a65b2881d509" author="Dontmovedad">
		<msg>Obstacle Detector: fix build error</msg>
		<modified_files>
			<file old_path="modules\perception\inference\onnx\libtorch_obstacle_detector.h" new_path="modules\perception\inference\onnx\libtorch_obstacle_detector.h" added_lines="0" deleted_lines="4">
				<diff>@@ -20,10 +20,6 @@
 #include "torch/script.h"
 #include "torch/torch.h"
 
-#include "opencv2/core/core.hpp"
-#include "opencv2/highgui/highgui.hpp"
-#include "opencv2/imgproc/imgproc.hpp"
-
 namespace apollo {
 namespace perception {
 namespace inference {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="09822f128f2bf561cc0a55589eb0d66f92c9056c" author="daohu527">
		<msg>cyber: unified preprocessing format</msg>
		<modified_files>
			<file old_path="cyber\class_loader\test\base.h" new_path="cyber\class_loader\test\base.h" added_lines="4" deleted_lines="1">
				<diff>@@ -14,10 +14,13 @@
  * limitations under the License.
  *****************************************************************************/
 
-#pragma once
+#ifndef CYBER_CLASS_LOADER_TEST_BASE_H_
+#define CYBER_CLASS_LOADER_TEST_BASE_H_
 
 class Base {
  public:
   virtual void DoSomething() = 0;
   virtual ~Base() {}
 };
+
+#endif  // CYBER_CLASS_LOADER_TEST_BASE_H_
</diff>
			</file>
			<file old_path="cyber\service_discovery\topology_manager.h" new_path="cyber\service_discovery\topology_manager.h" added_lines="4" deleted_lines="1">
				<diff>@@ -14,7 +14,8 @@
  * limitations under the License.
  *****************************************************************************/
 
-#pragma once
+#ifndef CYBER_SERVICE_DISCOVERY_TOPOLOGY_MANAGER_H_
+#define CYBER_SERVICE_DISCOVERY_TOPOLOGY_MANAGER_H_
 
 #include &lt;atomic&gt;
 #include &lt;functional&gt;
@@ -135,3 +136,5 @@ class TopologyManager {
 }  // namespace service_discovery
 }  // namespace cyber
 }  // namespace apollo
+
+#endif  // CYBER_SERVICE_DISCOVERY_TOPOLOGY_MANAGER_H_
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="46dc63da26142f3abf3a0cc92eabe1c6e8a5fdeb" author="changsh726">
		<msg>Cyber: reenable cpplint in cyber_monitor</msg>
		<modified_files>
			<file old_path="cyber\tools\cyber_monitor\general_channel_message.cc" new_path="cyber\tools\cyber_monitor\general_channel_message.cc" added_lines="23" deleted_lines="22">
				<diff>@@ -78,7 +78,8 @@ bool GeneralChannelMessage::isErrorCode(void* ptr) {
     case ErrorCode::NoCloseChannel:
       return true;
 
-    default: {}
+    default: {
+    }
   }
   return false;
 }
@@ -147,7 +148,8 @@ int GeneralChannelMessage::Render(const Screen* s, int key) {
       current_state_ = State::ShowInfo;
       break;
 
-    default: {}
+    default: {
+    }
   }
 
   clear();
@@ -164,10 +166,10 @@ int GeneralChannelMessage::Render(const Screen* s, int key) {
   if (is_enabled()) {
     switch (current_state_) {
       case State::ShowDebugString:
-        RenderDebugString(s, key, line_no);
+        RenderDebugString(s, key, &amp;line_no);
         break;
       case State::ShowInfo:
-        RenderInfo(s, key, line_no);
+        RenderInfo(s, key, &amp;line_no);
         break;
     }
   } else {
@@ -178,10 +180,9 @@ int GeneralChannelMessage::Render(const Screen* s, int key) {
   return line_no;
 }
 
-void GeneralChannelMessage::RenderInfo(const Screen* s, int key,
-                                       int&amp; line_no) {
-  page_item_count_ = s-&gt;Height() - line_no;
-  pages_ = static_cast&lt;int&gt;(readers_.size() + writers_.size() + line_no) /
+void GeneralChannelMessage::RenderInfo(const Screen* s, int key, int* line_no) {
+  page_item_count_ = s-&gt;Height() - *line_no;
+  pages_ = static_cast&lt;int&gt;(readers_.size() + writers_.size() + *line_no) /
                page_item_count_ +
            1;
   SplitPages(key);
@@ -208,24 +209,24 @@ void GeneralChannelMessage::RenderInfo(const Screen* s, int key,
   }
 
   if (hasReader) {
-    s-&gt;AddStr(0, line_no++, "Readers:");
+    s-&gt;AddStr(0, (*line_no)++, "Readers:");
     for (; iter != vec-&gt;cend(); ++iter) {
-      s-&gt;AddStr(ReaderWriterOffset, line_no++, iter-&gt;c_str());
+      s-&gt;AddStr(ReaderWriterOffset, (*line_no)++, iter-&gt;c_str());
     }
 
-    ++line_no;
+    ++(*line_no);
     vec = &amp;writers_;
     iter = vec-&gt;cbegin();
   }
 
-  s-&gt;AddStr(0, line_no++, "Writers:");
+  s-&gt;AddStr(0, (*line_no)++, "Writers:");
   for (; iter != vec-&gt;cend(); ++iter) {
-    s-&gt;AddStr(ReaderWriterOffset, line_no++, iter-&gt;c_str());
+    s-&gt;AddStr(ReaderWriterOffset, (*line_no)++, iter-&gt;c_str());
   }
 }
 
 void GeneralChannelMessage::RenderDebugString(const Screen* s, int key,
-                                              int&amp; line_no) {
+                                              int* line_no) {
   if (has_message_come()) {
     if (raw_msg_class_ == nullptr) {
       auto rawFactory = apollo::cyber::message::ProtobufFactory::Instance();
@@ -233,9 +234,9 @@ void GeneralChannelMessage::RenderDebugString(const Screen* s, int key,
     }
 
     if (raw_msg_class_ == nullptr) {
-      s-&gt;AddStr(0, line_no++, "Cannot Generate Message by Message Type");
+      s-&gt;AddStr(0, (*line_no)++, "Cannot Generate Message by Message Type");
     } else {
-      s-&gt;AddStr(0, line_no++, "FrameRatio: ");
+      s-&gt;AddStr(0, (*line_no)++, "FrameRatio: ");
 
       std::ostringstream outStr;
       outStr &lt;&lt; std::fixed &lt;&lt; std::setprecision(FrameRatio_Precision)
@@ -245,7 +246,7 @@ void GeneralChannelMessage::RenderDebugString(const Screen* s, int key,
       decltype(channel_message_) channelMsg = CopyMsgPtr();
 
       if (channelMsg-&gt;message.size()) {
-        s-&gt;AddStr(0, line_no++, "RawMessage Size: ");
+        s-&gt;AddStr(0, (*line_no)++, "RawMessage Size: ");
         outStr.str("");
         outStr &lt;&lt; channelMsg-&gt;message.size() &lt;&lt; " Bytes";
         if (channelMsg-&gt;message.size() &gt;= kGB) {
@@ -261,22 +262,22 @@ void GeneralChannelMessage::RenderDebugString(const Screen* s, int key,
         s-&gt;AddStr(outStr.str().c_str());
         if (raw_msg_class_-&gt;ParseFromString(channelMsg-&gt;message)) {
           int lcount = lineCount(*raw_msg_class_, s-&gt;Width());
-          page_item_count_ = s-&gt;Height() - line_no;
+          page_item_count_ = s-&gt;Height() - *line_no;
           pages_ = lcount / page_item_count_ + 1;
           SplitPages(key);
           int jumpLines = page_index_ * page_item_count_;
           jumpLines &lt;&lt;= 2;
           jumpLines /= 5;
-          GeneralMessageBase::PrintMessage(this, *raw_msg_class_, jumpLines, s,
+          GeneralMessageBase::PrintMessage(this, *raw_msg_class_, &amp;jumpLines, s,
                                            line_no, 0);
         } else {
-          s-&gt;AddStr(0, line_no++, "Cannot parse the raw message");
+          s-&gt;AddStr(0, (*line_no)++, "Cannot parse the raw message");
         }
       } else {
-        s-&gt;AddStr(0, line_no++, "The size of this raw Message is Zero");
+        s-&gt;AddStr(0, (*line_no)++, "The size of this raw Message is Zero");
       }
     }
   } else {
-    s-&gt;AddStr(0, line_no++, "No Message Came");
+    s-&gt;AddStr(0, (*line_no)++, "No Message Came");
   }
 }
</diff>
			</file>
			<file old_path="cyber\tools\cyber_monitor\general_channel_message.h" new_path="cyber\tools\cyber_monitor\general_channel_message.h" added_lines="18" deleted_lines="14">
				<diff>@@ -18,9 +18,13 @@
 #define TOOLS_CVT_MONITOR_GENERAL_CHANNEL_MESSAGE_H_
 
 #include &lt;atomic&gt;
+#include &lt;memory&gt;
+#include &lt;string&gt;
+#include &lt;vector&gt;
 
+#include "cyber/cyber.h"
 #include "cyber/message/raw_message.h"
-#include "general_message_base.h"
+#include "cyber/tools/cyber_monitor/general_message_base.h"
 
 class CyberTopologyMessage;
 class GeneralMessage;
@@ -74,12 +78,12 @@ class GeneralChannelMessage : public GeneralMessageBase {
 
   const std::string&amp; NodeName(void) const { return node_name_; }
 
-  void add_reader(const std::string&amp; reader) { DoAdd(readers_, reader); }
-  void del_reader(const std::string&amp; reader) { DoDelete(readers_, reader); }
+  void add_reader(const std::string&amp; reader) { DoAdd(&amp;readers_, reader); }
+  void del_reader(const std::string&amp; reader) { DoDelete(&amp;readers_, reader); }
 
-  void add_writer(const std::string&amp; writer) { DoAdd(writers_, writer); }
+  void add_writer(const std::string&amp; writer) { DoAdd(&amp;writers_, writer); }
   void del_writer(const std::string&amp; writer) {
-    DoDelete(writers_, writer);
+    DoDelete(&amp;writers_, writer);
     if (!writers_.size()) {
       set_has_message_come(false);
     }
@@ -119,23 +123,23 @@ class GeneralChannelMessage : public GeneralMessageBase {
   GeneralChannelMessage(const GeneralChannelMessage&amp;) = delete;
   GeneralChannelMessage&amp; operator=(const GeneralChannelMessage&amp;) = delete;
 
-  static void DoDelete(std::vector&lt;std::string&gt;&amp; vec, const std::string&amp; str) {
-    for (auto iter = vec.begin(); iter != vec.end(); ++iter) {
+  static void DoDelete(std::vector&lt;std::string&gt;* vec, const std::string&amp; str) {
+    for (auto iter = vec-&gt;begin(); iter != vec-&gt;end(); ++iter) {
       if (*iter == str) {
-        vec.erase(iter);
+        vec-&gt;erase(iter);
         break;
       }
     }
   }
 
-  static void DoAdd(std::vector&lt;std::string&gt;&amp; vec, const std::string&amp; str) {
-    for (auto iter = vec.begin(); iter != vec.end(); ++iter) {
-      if (*iter == str) {
+  static void DoAdd(std::vector&lt;std::string&gt;* vec, const std::string&amp; str) {
+    for (const auto&amp; item : *vec) {
+      if (item == str) {
         return;
       }
     }
 
-    vec.emplace_back(str);
+    vec-&gt;emplace_back(str);
   }
 
   void updateRawMessage(
@@ -159,8 +163,8 @@ class GeneralChannelMessage : public GeneralMessageBase {
 
   GeneralChannelMessage* OpenChannel(const std::string&amp; channelName);
 
-  void RenderDebugString(const Screen* s, int key, int&amp; line_no);
-  void RenderInfo(const Screen* s, int key, int&amp; line_no);
+  void RenderDebugString(const Screen* s, int key, int* line_no);
+  void RenderInfo(const Screen* s, int key, int* line_no);
 
   void set_has_message_come(bool b) { has_message_come_ = b; }
 
</diff>
			</file>
			<file old_path="cyber\tools\cyber_monitor\general_message.cc" new_path="cyber\tools\cyber_monitor\general_message.cc" added_lines="6" deleted_lines="5">
				<diff>@@ -109,7 +109,8 @@ int GeneralMessage::Render(const Screen* s, int key) {
 
     auto channelMsg = channelMsgPtr-&gt;CopyMsgPtr();
     if (!channelMsgPtr-&gt;raw_msg_class_-&gt;ParseFromString(channelMsg-&gt;message)) {
-      s-&gt;AddStr(0, line_no++, "Cannot Parse the message for Real-Time Updating");
+      s-&gt;AddStr(0, line_no++,
+                "Cannot Parse the message for Real-Time Updating");
       return line_no;
     }
 
@@ -167,13 +168,13 @@ int GeneralMessage::Render(const Screen* s, int key) {
       const std::vector&lt;int&gt; indices(
           SortProtobufMapByKeys(*message_ptr_, field_, *reflection_ptr_, size));
       if (is_folded_) {
-        GeneralMessageBase::PrintField(this, *message_ptr_, jumpLines, s,
-                                       line_no, 0, reflection_ptr_, field_,
+        GeneralMessageBase::PrintField(this, *message_ptr_, &amp;jumpLines, s,
+                                       &amp;line_no, 0, reflection_ptr_, field_,
                                        indices[itemIndex_]);
       } else {
         for (const int index : indices) {
-          GeneralMessageBase::PrintField(this, *message_ptr_, jumpLines, s,
-                                         line_no, 0, reflection_ptr_, field_,
+          GeneralMessageBase::PrintField(this, *message_ptr_, &amp;jumpLines, s,
+                                         &amp;line_no, 0, reflection_ptr_, field_,
                                          index);
         }
       }
</diff>
			</file>
			<file old_path="cyber\tools\cyber_monitor\general_message.h" new_path="cyber\tools\cyber_monitor\general_message.h" added_lines="1" deleted_lines="1">
				<diff>@@ -19,7 +19,7 @@
 
 #include "cyber/cyber.h"
 #include "cyber/message/raw_message.h"
-#include "general_message_base.h"
+#include "cyber/tools/cyber_monitor/general_message_base.h"
 
 class Screen;
 
</diff>
			</file>
			<file old_path="cyber\tools\cyber_monitor\general_message_base.cc" new_path="cyber\tools\cyber_monitor\general_message_base.cc" added_lines="26" deleted_lines="25">
				<diff>@@ -121,7 +121,8 @@ int GeneralMessageBase::lineCountOfField(
           break;
         }
 
-        default: {}
+        default: {
+        }
       }  // end switch
     }
   }
@@ -130,8 +131,8 @@ int GeneralMessageBase::lineCountOfField(
 
 void GeneralMessageBase::PrintMessage(GeneralMessageBase* baseMsg,
                                       const google::protobuf::Message&amp; msg,
-                                      int&amp; jumpLines, const Screen* s,
-                                      int&amp; line_no, int indent) {
+                                      int* jumpLines, const Screen* s,
+                                      int* line_no, int indent) {
   const google::protobuf::Reflection* reflection = msg.GetReflection();
   const google::protobuf::Descriptor* descriptor = msg.GetDescriptor();
   std::vector&lt;const google::protobuf::FieldDescriptor*&gt; fields;
@@ -142,13 +143,13 @@ void GeneralMessageBase::PrintMessage(GeneralMessageBase* baseMsg,
     reflection-&gt;ListFields(msg, &amp;fields);
   }
   for (std::size_t i = 0; i &lt; fields.size(); ++i) {
-    if (line_no &gt; s-&gt;Height()) {
+    if (*line_no &gt; s-&gt;Height()) {
       break;
     }
     const google::protobuf::FieldDescriptor* field = fields[i];
     if (field-&gt;is_repeated()) {
-      if (jumpLines) {
-        --jumpLines;
+      if (*jumpLines) {
+        --(*jumpLines);
       } else {
         std::ostringstream outStr;
         const std::string&amp; fieldName = field-&gt;name();
@@ -157,9 +158,9 @@ void GeneralMessageBase::PrintMessage(GeneralMessageBase* baseMsg,
         GeneralMessage* item =
             new GeneralMessage(baseMsg, &amp;msg, reflection, field);
         if (item) {
-          baseMsg-&gt;insertRepeatedMessage(line_no, item);
+          baseMsg-&gt;insertRepeatedMessage(*line_no, item);
         }
-        s-&gt;AddStr(indent, line_no++, outStr.str().c_str());
+        s-&gt;AddStr(indent, (*line_no)++, outStr.str().c_str());
       }
     } else {
       PrintField(baseMsg, msg, jumpLines, s, line_no, indent, reflection, field,
@@ -173,7 +174,7 @@ void GeneralMessageBase::PrintMessage(GeneralMessageBase* baseMsg,
     Screen::ColorPair c = s-&gt;Color();
     s-&gt;ClearCurrentColor();
     s-&gt;SetCurrentColor(Screen::RED_BLACK);
-    s-&gt;AddStr(indent, line_no++, "Have Unknown Fields");
+    s-&gt;AddStr(indent, (*line_no)++, "Have Unknown Fields");
     s-&gt;ClearCurrentColor();
     s-&gt;SetCurrentColor(c);
   }
@@ -181,7 +182,7 @@ void GeneralMessageBase::PrintMessage(GeneralMessageBase* baseMsg,
 
 void GeneralMessageBase::PrintField(
     GeneralMessageBase* baseMsg, const google::protobuf::Message&amp; msg,
-    int&amp; jumpLines, const Screen* s, int&amp; line_no, int indent,
+    int* jumpLines, const Screen* s, int* line_no, int indent,
     const google::protobuf::Reflection* ref,
     const google::protobuf::FieldDescriptor* field, int index) {
   std::ostringstream outStr;
@@ -190,8 +191,8 @@ void GeneralMessageBase::PrintField(
   switch (field-&gt;cpp_type()) {
 #define OUTPUT_FIELD(CPPTYPE, METHOD, PRECISION)                   \
   case google::protobuf::FieldDescriptor::CPPTYPE_##CPPTYPE:       \
-    if (jumpLines) {                                               \
-      --jumpLines;                                                 \
+    if (*jumpLines) {                                              \
+      --(*jumpLines);                                              \
     } else {                                                       \
       const std::string&amp; fieldName = field-&gt;name();                \
       outStr &lt;&lt; fieldName &lt;&lt; ": ";                                 \
@@ -204,7 +205,7 @@ void GeneralMessageBase::PrintField(
                      ? ref-&gt;GetRepeated##METHOD(msg, field, index) \
                      : ref-&gt;Get##METHOD(msg, field));              \
       outStr.flags(old_flags);                                     \
-      s-&gt;AddStr(indent, line_no++, outStr.str().c_str());           \
+      s-&gt;AddStr(indent, (*line_no)++, outStr.str().c_str());       \
     }                                                              \
     break
 
@@ -227,20 +228,20 @@ void GeneralMessageBase::PrintField(
         int lineWidth = 0;
         std::size_t i = 0;
 
-        for (; i &lt; str.size() &amp;&amp; jumpLines &gt; 0; ++i) {
+        for (; i &lt; str.size() &amp;&amp; *jumpLines &gt; 0; ++i) {
           if (str[i] == '\n' || str[i] == '\r') {
-            --jumpLines;
+            --(*jumpLines);
             lineWidth = 0;
           } else {
             ++lineWidth;
             if (lineWidth == s-&gt;Width()) {
-              --jumpLines;
+              --(*jumpLines);
               lineWidth = 0;
             }
           }
         }
 
-        if (jumpLines == 0) {
+        if (*jumpLines == 0) {
           lineWidth = 0;
           unsigned lineCount = 1;
 
@@ -266,8 +267,8 @@ void GeneralMessageBase::PrintField(
             outStr &lt;&lt; ch;
           }
 
-          s-&gt;AddStr(indent, line_no, outStr.str().c_str());
-          line_no += lineCount;
+          s-&gt;AddStr(indent, *line_no, outStr.str().c_str());
+          (*line_no) += lineCount;
         }
       }
 
@@ -275,8 +276,8 @@ void GeneralMessageBase::PrintField(
     }
 
     case google::protobuf::FieldDescriptor::CPPTYPE_ENUM: {
-      if (jumpLines) {
-        --jumpLines;
+      if (*jumpLines) {
+        --(*jumpLines);
       } else {
         const std::string&amp; fieldName = field-&gt;name();
         outStr &lt;&lt; fieldName &lt;&lt; ": ";
@@ -293,13 +294,13 @@ void GeneralMessageBase::PrintField(
         } else {
           outStr &lt;&lt; enum_value;
         }
-        s-&gt;AddStr(indent, line_no++, outStr.str().c_str());
+        s-&gt;AddStr(indent, (*line_no)++, outStr.str().c_str());
       }
       break;
     }
 
     case google::protobuf::FieldDescriptor::CPPTYPE_MESSAGE:
-      if (!jumpLines) {
+      if (!*jumpLines) {
         const std::string&amp; fieldName = field-&gt;name();
         outStr &lt;&lt; fieldName;
         if (!field-&gt;is_map()) {
@@ -308,9 +309,9 @@ void GeneralMessageBase::PrintField(
             outStr &lt;&lt; "[" &lt;&lt; index &lt;&lt; "] ";
           }
         }
-        s-&gt;AddStr(indent, line_no++, outStr.str().c_str());
+        s-&gt;AddStr(indent, (*line_no)++, outStr.str().c_str());
       } else {
-        --jumpLines;
+        --(*jumpLines);
       }
       GeneralMessageBase::PrintMessage(
           baseMsg,
</diff>
			</file>
			<file old_path="cyber\tools\cyber_monitor\general_message_base.h" new_path="cyber\tools\cyber_monitor\general_message_base.h" added_lines="4" deleted_lines="4">
				<diff>@@ -28,11 +28,11 @@ class Screen;
 class GeneralMessageBase : public RenderableMessage {
  protected:
   static void PrintMessage(GeneralMessageBase* baseMsg,
-                           const google::protobuf::Message&amp; msg, int&amp; jumpLines,
-                           const Screen* s, int&amp; line_no, int indent);
+                           const google::protobuf::Message&amp; msg, int* jumpLines,
+                           const Screen* s, int* line_no, int indent);
   static void PrintField(GeneralMessageBase* baseMsg,
-                         const google::protobuf::Message&amp; msg, int&amp; jumpLines,
-                         const Screen* s, int&amp; line_no, int indent,
+                         const google::protobuf::Message&amp; msg, int* jumpLines,
+                         const Screen* s, int* line_no, int indent,
                          const google::protobuf::Reflection* ref,
                          const google::protobuf::FieldDescriptor* field,
                          int index);
</diff>
			</file>
			<file old_path="cyber\tools\cyber_monitor\main.cc" new_path="cyber\tools\cyber_monitor\main.cc" added_lines="10" deleted_lines="10">
				<diff>@@ -14,15 +14,14 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "cyber_topology_message.h"
-#include "general_channel_message.h"
-#include "screen.h"
+#include &lt;csignal&gt;
+#include &lt;iostream&gt;
 
 #include "cyber/init.h"
 #include "cyber/service_discovery/topology_manager.h"
-
-#include &lt;csignal&gt;
-#include &lt;iostream&gt;
+#include "cyber/tools/cyber_monitor/cyber_topology_message.h"
+#include "cyber/tools/cyber_monitor/general_channel_message.h"
+#include "cyber/tools/cyber_monitor/screen.h"
 
 namespace {
 void SigResizeHandle(int) { Screen::Instance()-&gt;Resize(); }
@@ -44,7 +43,7 @@ enum COMMAND {
   CHANNEL     // 3 -&gt; 4
 };
 
-COMMAND parseOption(int argc, char *const argv[], std::string &amp;commandVal) {
+COMMAND parseOption(int argc, char *const argv[], std::string *commandVal) {
   if (argc &gt; 4) {
     return TOO_MANY_PARAMETER;
   }
@@ -59,7 +58,7 @@ COMMAND parseOption(int argc, char *const argv[], std::string &amp;commandVal) {
     }
     if (strcmp(opt, "-c") == 0) {
       if (argv[index + 1]) {
-        commandVal = argv[index + 1];
+        *commandVal = argv[index + 1];
         return CHANNEL;
       }
     }
@@ -75,7 +74,7 @@ COMMAND parseOption(int argc, char *const argv[], std::string &amp;commandVal) {
 int main(int argc, char *argv[]) {
   std::string val;
 
-  COMMAND com = parseOption(argc, argv, val);
+  COMMAND com = parseOption(argc, argv, &amp;val);
 
   switch (com) {
     case TOO_MANY_PARAMETER:
@@ -83,7 +82,8 @@ int main(int argc, char *argv[]) {
     case HELP:
       printHelp(argv[0]);
       return 0;
-    default:;
+    default: {
+    }
   }
 
   apollo::cyber::Init(argv[0]);
</diff>
			</file>
			<file old_path="cyber\tools\cyber_monitor\screen.cc" new_path="cyber\tools\cyber_monitor\screen.cc" added_lines="10" deleted_lines="7">
				<diff>@@ -14,20 +14,22 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "screen.h"
-#include "cyber_topology_message.h"
-#include "general_channel_message.h"
-#include "renderable_message.h"
+#include "cyber/tools/cyber_monitor/screen.h"
 
-#include &lt;ncurses.h&gt;
 #include &lt;unistd.h&gt;
+
 #include &lt;cstdio&gt;
 #include &lt;cstring&gt;
 #include &lt;iostream&gt;
 #include &lt;mutex&gt;
-#include &lt;string&gt;
 #include &lt;thread&gt;
 
+#include &lt;ncurses.h&gt;
+
+#include "cyber/tools/cyber_monitor/cyber_topology_message.h"
+#include "cyber/tools/cyber_monitor/general_channel_message.h"
+#include "cyber/tools/cyber_monitor/renderable_message.h"
+
 namespace {
 constexpr double MinHalfFrameRatio = 12.5;
 }
@@ -197,7 +199,8 @@ int Screen::SwitchState(int ch) {
         clear();
       }
       break;
-    default: {}
+    default: {
+    }
   }
   return ch;
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c7bf3116198bf5678660bbe59089293410d1da32" author="changsh726">
		<msg>Cyber: unified naming style in cyber_monitor</msg>
		<modified_files>
			<file old_path="cyber\tools\cyber_monitor\cyber_topology_message.cc" new_path="cyber\tools\cyber_monitor\cyber_topology_message.cc" added_lines="52" deleted_lines="50">
				<diff>@@ -19,9 +19,10 @@
 #include &lt;iomanip&gt;
 #include &lt;iostream&gt;
 
-#include "cyber/message/message_traits.h"
 #include "cyber/proto/role_attributes.pb.h"
 #include "cyber/proto/topology_change.pb.h"
+
+#include "cyber/message/message_traits.h"
 #include "cyber/tools/cyber_monitor/general_channel_message.h"
 #include "cyber/tools/cyber_monitor/screen.h"
 
@@ -37,27 +38,27 @@ CyberTopologyMessage::CyberTopologyMessage(const std::string&amp; channel)
 
 CyberTopologyMessage::~CyberTopologyMessage(void) {
   for (auto item : all_channels_map_) {
-    if (!GeneralChannelMessage::isErrorCode(item.second)) {
+    if (!GeneralChannelMessage::IsErrorCode(item.second)) {
       delete item.second;
     }
   }
 }
 
-bool CyberTopologyMessage::isFromHere(const std::string&amp; nodeName) {
-  std::ostringstream outStr;
-  outStr &lt;&lt; "MonitorReader" &lt;&lt; pid_;
+bool CyberTopologyMessage::IsFromHere(const std::string&amp; node_name) {
+  std::ostringstream out_str;
+  out_str &lt;&lt; "MonitorReader" &lt;&lt; pid_;
 
-  std::string templateName = outStr.str();
-  const std::string baseName = nodeName.substr(0, templateName.size());
+  std::string templateName = out_str.str();
+  const std::string baseName = node_name.substr(0, templateName.size());
 
   return (templateName.compare(baseName) == 0);
 }
 
 RenderableMessage* CyberTopologyMessage::Child(int line_no) const {
   RenderableMessage* ret = nullptr;
-  auto iter = findChild(line_no);
+  auto iter = FindChild(line_no);
   if (iter != all_channels_map_.cend() &amp;&amp;
-      !GeneralChannelMessage::isErrorCode(iter-&gt;second) &amp;&amp;
+      !GeneralChannelMessage::IsErrorCode(iter-&gt;second) &amp;&amp;
       iter-&gt;second-&gt;is_enabled()) {
     ret = iter-&gt;second;
   }
@@ -65,7 +66,7 @@ RenderableMessage* CyberTopologyMessage::Child(int line_no) const {
 }
 
 std::map&lt;std::string, GeneralChannelMessage*&gt;::const_iterator
-CyberTopologyMessage::findChild(int line_no) const {
+CyberTopologyMessage::FindChild(int line_no) const {
   --line_no;
 
   std::map&lt;std::string, GeneralChannelMessage*&gt;::const_iterator ret =
@@ -103,13 +104,13 @@ void CyberTopologyMessage::TopologyChanged(
     auto iter = all_channels_map_.find(changeMsg.role_attr().channel_name());
 
     if (iter != all_channels_map_.cend() &amp;&amp;
-        !GeneralChannelMessage::isErrorCode(iter-&gt;second)) {
-      const std::string&amp; nodeName = changeMsg.role_attr().node_name();
+        !GeneralChannelMessage::IsErrorCode(iter-&gt;second)) {
+      const std::string&amp; node_name = changeMsg.role_attr().node_name();
       if (::apollo::cyber::proto::RoleType::ROLE_WRITER ==
           changeMsg.role_type()) {
-        iter-&gt;second-&gt;del_writer(nodeName);
+        iter-&gt;second-&gt;del_writer(node_name);
       } else {
-        iter-&gt;second-&gt;del_reader(nodeName);
+        iter-&gt;second-&gt;del_reader(node_name);
       }
     }
   }
@@ -117,57 +118,57 @@ void CyberTopologyMessage::TopologyChanged(
 
 void CyberTopologyMessage::AddReaderWriter(
     const apollo::cyber::proto::RoleAttributes&amp; role, bool isWriter) {
-  const std::string&amp; channelName = role.channel_name();
+  const std::string&amp; channel_name = role.channel_name();
 
-  if (!specified_channel_.empty() &amp;&amp; specified_channel_ != channelName) {
+  if (!specified_channel_.empty() &amp;&amp; specified_channel_ != channel_name) {
     return;
   }
 
-  if (static_cast&lt;int&gt;(channelName.length()) &gt; col1_width_) {
-    col1_width_ = static_cast&lt;int&gt;(channelName.length());
+  if (static_cast&lt;int&gt;(channel_name.length()) &gt; col1_width_) {
+    col1_width_ = static_cast&lt;int&gt;(channel_name.length());
   }
 
-  const std::string&amp; nodeName = role.node_name();
-  if (isFromHere(nodeName)) {
+  const std::string&amp; node_name = role.node_name();
+  if (IsFromHere(node_name)) {
     return;
   }
 
-  GeneralChannelMessage* channelMsg = nullptr;
+  GeneralChannelMessage* channel_msg = nullptr;
   const std::string&amp; msgTypeName = role.message_type();
-  auto iter = all_channels_map_.find(channelName);
+  auto iter = all_channels_map_.find(channel_name);
   if (iter == all_channels_map_.cend()) {
     static int index = 0;
 
-    std::ostringstream outStr;
-    outStr &lt;&lt; "MonitorReader" &lt;&lt; pid_ &lt;&lt; '-' &lt;&lt; index++;
+    std::ostringstream out_str;
+    out_str &lt;&lt; "MonitorReader" &lt;&lt; pid_ &lt;&lt; '-' &lt;&lt; index++;
 
-    channelMsg = new GeneralChannelMessage(outStr.str(), this);
+    channel_msg = new GeneralChannelMessage(out_str.str(), this);
 
-    if (channelMsg != nullptr) {
-      if (!GeneralChannelMessage::isErrorCode(
-              channelMsg-&gt;OpenChannel(channelName))) {
-        channelMsg-&gt;set_message_type(msgTypeName);
-        channelMsg-&gt;add_reader(channelMsg-&gt;NodeName());
+    if (channel_msg != nullptr) {
+      if (!GeneralChannelMessage::IsErrorCode(
+              channel_msg-&gt;OpenChannel(channel_name))) {
+        channel_msg-&gt;set_message_type(msgTypeName);
+        channel_msg-&gt;add_reader(channel_msg-&gt;NodeName());
       }
     } else {
-      channelMsg = GeneralChannelMessage::castErrorCode2Ptr(
+      channel_msg = GeneralChannelMessage::CastErrorCode2Ptr(
           GeneralChannelMessage::ErrorCode::NewSubClassFailed);
     }
-    all_channels_map_[channelName] = channelMsg;
+    all_channels_map_[channel_name] = channel_msg;
   } else {
-    channelMsg = iter-&gt;second;
+    channel_msg = iter-&gt;second;
   }
 
-  if (!GeneralChannelMessage::isErrorCode(channelMsg)) {
+  if (!GeneralChannelMessage::IsErrorCode(channel_msg)) {
     if (isWriter) {
       if (msgTypeName != apollo::cyber::message::MessageType&lt;
                              apollo::cyber::message::RawMessage&gt;()) {
-        channelMsg-&gt;set_message_type(msgTypeName);
+        channel_msg-&gt;set_message_type(msgTypeName);
       }
 
-      channelMsg-&gt;add_writer(nodeName);
+      channel_msg-&gt;add_writer(node_name);
     } else {
-      channelMsg-&gt;add_reader(nodeName);
+      channel_msg-&gt;add_reader(node_name);
     }
   }
 }
@@ -185,14 +186,14 @@ void CyberTopologyMessage::ChangeState(const Screen* s, int key) {
       break;
 
     case ' ': {
-      auto iter = findChild(*line_no());
-      if (!GeneralChannelMessage::isErrorCode(iter-&gt;second)) {
+      auto iter = FindChild(*line_no());
+      if (!GeneralChannelMessage::IsErrorCode(iter-&gt;second)) {
         GeneralChannelMessage* child = iter-&gt;second;
         if (child-&gt;is_enabled()) {
           child-&gt;CloseChannel();
         } else {
           GeneralChannelMessage* ret = child-&gt;OpenChannel(iter-&gt;first);
-          if (GeneralChannelMessage::isErrorCode(ret)) {
+          if (GeneralChannelMessage::IsErrorCode(ret)) {
             delete child;
             all_channels_map_[iter-&gt;first] = ret;
           } else {
@@ -202,7 +203,8 @@ void CyberTopologyMessage::ChangeState(const Screen* s, int key) {
       }
     }
 
-    default: {}
+    default: {
+    }
   }
 }
 
@@ -233,14 +235,14 @@ int CyberTopologyMessage::Render(const Screen* s, int key) {
   }
 
   Screen::ColorPair color;
-  std::ostringstream outStr;
+  std::ostringstream out_str;
 
   tmp = page_item_count_ + 1;
   for (line = 1; iter != all_channels_map_.cend() &amp;&amp; line &lt; tmp;
        ++iter, ++line) {
     color = Screen::RED_BLACK;
 
-    if (!GeneralChannelMessage::isErrorCode(iter-&gt;second)) {
+    if (!GeneralChannelMessage::IsErrorCode(iter-&gt;second)) {
       if (iter-&gt;second-&gt;has_message_come()) {
         if (iter-&gt;second-&gt;is_enabled()) {
           color = Screen::GREEN_BLACK;
@@ -253,25 +255,25 @@ int CyberTopologyMessage::Render(const Screen* s, int key) {
     s-&gt;SetCurrentColor(color);
     s-&gt;AddStr(0, line, iter-&gt;first.c_str());
 
-    if (!GeneralChannelMessage::isErrorCode(iter-&gt;second)) {
+    if (!GeneralChannelMessage::IsErrorCode(iter-&gt;second)) {
       switch (second_column_) {
         case SecondColumnType::MessageType:
           s-&gt;AddStr(col1_width_ + SecondColumnOffset, line,
                     iter-&gt;second-&gt;message_type().c_str());
           break;
         case SecondColumnType::MessageFrameRatio: {
-          outStr.str("");
-          outStr &lt;&lt; std::fixed &lt;&lt; std::setprecision(FrameRatio_Precision)
-                 &lt;&lt; iter-&gt;second-&gt;frame_ratio();
+          out_str.str("");
+          out_str &lt;&lt; std::fixed &lt;&lt; std::setprecision(FrameRatio_Precision)
+                  &lt;&lt; iter-&gt;second-&gt;frame_ratio();
           s-&gt;AddStr(col1_width_ + SecondColumnOffset, line,
-                    outStr.str().c_str());
+                    out_str.str().c_str());
         } break;
       }
     } else {
       GeneralChannelMessage::ErrorCode errcode =
-          GeneralChannelMessage::castPtr2ErrorCode(iter-&gt;second);
+          GeneralChannelMessage::CastPtr2ErrorCode(iter-&gt;second);
       s-&gt;AddStr(col1_width_ + SecondColumnOffset, line,
-                GeneralChannelMessage::errCode2Str(errcode));
+                GeneralChannelMessage::ErrCode2Str(errcode));
     }
     s-&gt;ClearCurrentColor();
   }
</diff>
			</file>
			<file old_path="cyber\tools\cyber_monitor\cyber_topology_message.h" new_path="cyber\tools\cyber_monitor\cyber_topology_message.h" added_lines="2" deleted_lines="2">
				<diff>@@ -51,9 +51,9 @@ class CyberTopologyMessage : public RenderableMessage {
   CyberTopologyMessage&amp; operator=(const CyberTopologyMessage&amp;) = delete;
 
   void ChangeState(const Screen* s, int key);
-  bool isFromHere(const std::string&amp; nodeName);
+  bool IsFromHere(const std::string&amp; node_name);
 
-  std::map&lt;std::string, GeneralChannelMessage*&gt;::const_iterator findChild(
+  std::map&lt;std::string, GeneralChannelMessage*&gt;::const_iterator FindChild(
       int index) const;
 
   enum class SecondColumnType { MessageType, MessageFrameRatio };
</diff>
			</file>
			<file old_path="cyber\tools\cyber_monitor\general_channel_message.cc" new_path="cyber\tools\cyber_monitor\general_channel_message.cc" added_lines="43" deleted_lines="40">
				<diff>@@ -32,7 +32,7 @@ using apollo::cyber::record::kKB;
 using apollo::cyber::record::kMB;
 }  // namespace
 
-const char* GeneralChannelMessage::errCode2Str(
+const char* GeneralChannelMessage::ErrCode2Str(
     GeneralChannelMessage::ErrorCode errCode) {
   const char* ret;
   switch (errCode) {
@@ -66,7 +66,7 @@ const char* GeneralChannelMessage::errCode2Str(
   return ret;
 }
 
-bool GeneralChannelMessage::isErrorCode(void* ptr) {
+bool GeneralChannelMessage::IsErrorCode(void* ptr) {
   GeneralChannelMessage::ErrorCode err =
       (GeneralChannelMessage::ErrorCode)(reinterpret_cast&lt;intptr_t&gt;(ptr));
   switch (err) {
@@ -107,31 +107,31 @@ double GeneralChannelMessage::frame_ratio(void) {
 }
 
 GeneralChannelMessage* GeneralChannelMessage::OpenChannel(
-    const std::string&amp; channelName) {
-  if (channelName.empty() || node_name_.empty()) {
-    return castErrorCode2Ptr(ErrorCode::ChannelNameOrNodeNameIsEmpty);
+    const std::string&amp; channel_name) {
+  if (channel_name.empty() || node_name_.empty()) {
+    return CastErrorCode2Ptr(ErrorCode::ChannelNameOrNodeNameIsEmpty);
   }
   if (channel_node_ != nullptr || channel_reader_ != nullptr) {
-    return castErrorCode2Ptr(ErrorCode::NoCloseChannel);
+    return CastErrorCode2Ptr(ErrorCode::NoCloseChannel);
   }
 
   channel_node_ = apollo::cyber::CreateNode(node_name_);
   if (channel_node_ == nullptr) {
-    return castErrorCode2Ptr(ErrorCode::CreateNodeFailed);
+    return CastErrorCode2Ptr(ErrorCode::CreateNodeFailed);
   }
 
-  auto callBack =
+  auto callback =
       [this](
-          const std::shared_ptr&lt;apollo::cyber::message::RawMessage&gt;&amp; rawMsg) {
-        updateRawMessage(rawMsg);
+          const std::shared_ptr&lt;apollo::cyber::message::RawMessage&gt;&amp; raw_msg) {
+        UpdateRawMessage(raw_msg);
       };
 
   channel_reader_ =
       channel_node_-&gt;CreateReader&lt;apollo::cyber::message::RawMessage&gt;(
-          channelName, callBack);
+          channel_name, callback);
   if (channel_reader_ == nullptr) {
     channel_node_.reset();
-    return castErrorCode2Ptr(ErrorCode::CreateReaderFailed);
+    return CastErrorCode2Ptr(ErrorCode::CreateReaderFailed);
   }
   return this;
 }
@@ -187,7 +187,7 @@ void GeneralChannelMessage::RenderInfo(const Screen* s, int key, int* line_no) {
            1;
   SplitPages(key);
 
-  bool hasReader = true;
+  bool has_reader = true;
   std::vector&lt;std::string&gt;* vec = &amp;readers_;
 
   auto iter = vec-&gt;cbegin();
@@ -205,10 +205,10 @@ void GeneralChannelMessage::RenderInfo(const Screen* s, int key, int* line_no) {
       --y;
     }
 
-    hasReader = false;
+    has_reader = false;
   }
 
-  if (hasReader) {
+  if (has_reader) {
     s-&gt;AddStr(0, (*line_no)++, "Readers:");
     for (; iter != vec-&gt;cend(); ++iter) {
       s-&gt;AddStr(ReaderWriterOffset, (*line_no)++, iter-&gt;c_str());
@@ -238,38 +238,41 @@ void GeneralChannelMessage::RenderDebugString(const Screen* s, int key,
     } else {
       s-&gt;AddStr(0, (*line_no)++, "FrameRatio: ");
 
-      std::ostringstream outStr;
-      outStr &lt;&lt; std::fixed &lt;&lt; std::setprecision(FrameRatio_Precision)
-             &lt;&lt; frame_ratio();
-      s-&gt;AddStr(outStr.str().c_str());
+      std::ostringstream out_str;
+      out_str &lt;&lt; std::fixed &lt;&lt; std::setprecision(FrameRatio_Precision)
+              &lt;&lt; frame_ratio();
+      s-&gt;AddStr(out_str.str().c_str());
 
-      decltype(channel_message_) channelMsg = CopyMsgPtr();
+      decltype(channel_message_) channel_msg = CopyMsgPtr();
 
-      if (channelMsg-&gt;message.size()) {
+      if (channel_msg-&gt;message.size()) {
         s-&gt;AddStr(0, (*line_no)++, "RawMessage Size: ");
-        outStr.str("");
-        outStr &lt;&lt; channelMsg-&gt;message.size() &lt;&lt; " Bytes";
-        if (channelMsg-&gt;message.size() &gt;= kGB) {
-          outStr &lt;&lt; " (" &lt;&lt; static_cast&lt;float&gt;(channelMsg-&gt;message.size()) / kGB
-                 &lt;&lt; " GB)";
-        } else if (channelMsg-&gt;message.size() &gt;= kMB) {
-          outStr &lt;&lt; " (" &lt;&lt; static_cast&lt;float&gt;(channelMsg-&gt;message.size()) / kMB
-                 &lt;&lt; " MB)";
-        } else if (channelMsg-&gt;message.size() &gt;= kKB) {
-          outStr &lt;&lt; " (" &lt;&lt; static_cast&lt;float&gt;(channelMsg-&gt;message.size()) / kKB
-                 &lt;&lt; " KB)";
+        out_str.str("");
+        out_str &lt;&lt; channel_msg-&gt;message.size() &lt;&lt; " Bytes";
+        if (channel_msg-&gt;message.size() &gt;= kGB) {
+          out_str &lt;&lt; " ("
+                  &lt;&lt; static_cast&lt;float&gt;(channel_msg-&gt;message.size()) / kGB
+                  &lt;&lt; " GB)";
+        } else if (channel_msg-&gt;message.size() &gt;= kMB) {
+          out_str &lt;&lt; " ("
+                  &lt;&lt; static_cast&lt;float&gt;(channel_msg-&gt;message.size()) / kMB
+                  &lt;&lt; " MB)";
+        } else if (channel_msg-&gt;message.size() &gt;= kKB) {
+          out_str &lt;&lt; " ("
+                  &lt;&lt; static_cast&lt;float&gt;(channel_msg-&gt;message.size()) / kKB
+                  &lt;&lt; " KB)";
         }
-        s-&gt;AddStr(outStr.str().c_str());
-        if (raw_msg_class_-&gt;ParseFromString(channelMsg-&gt;message)) {
-          int lcount = lineCount(*raw_msg_class_, s-&gt;Width());
+        s-&gt;AddStr(out_str.str().c_str());
+        if (raw_msg_class_-&gt;ParseFromString(channel_msg-&gt;message)) {
+          int lcount = LineCount(*raw_msg_class_, s-&gt;Width());
           page_item_count_ = s-&gt;Height() - *line_no;
           pages_ = lcount / page_item_count_ + 1;
           SplitPages(key);
-          int jumpLines = page_index_ * page_item_count_;
-          jumpLines &lt;&lt;= 2;
-          jumpLines /= 5;
-          GeneralMessageBase::PrintMessage(this, *raw_msg_class_, &amp;jumpLines, s,
-                                           line_no, 0);
+          int jump_lines = page_index_ * page_item_count_;
+          jump_lines &lt;&lt;= 2;
+          jump_lines /= 5;
+          GeneralMessageBase::PrintMessage(this, *raw_msg_class_, &amp;jump_lines,
+                                           s, line_no, 0);
         } else {
           s-&gt;AddStr(0, (*line_no)++, "Cannot parse the raw message");
         }
</diff>
			</file>
			<file old_path="cyber\tools\cyber_monitor\general_channel_message.h" new_path="cyber\tools\cyber_monitor\general_channel_message.h" added_lines="14" deleted_lines="14">
				<diff>@@ -40,14 +40,14 @@ class GeneralChannelMessage : public GeneralMessageBase {
     NoCloseChannel = -6
   };
 
-  static const char* errCode2Str(ErrorCode errCode);
-  static bool isErrorCode(void* ptr);
+  static const char* ErrCode2Str(ErrorCode errCode);
+  static bool IsErrorCode(void* ptr);
 
-  static ErrorCode castPtr2ErrorCode(void* ptr) {
-    assert(isErrorCode(ptr));
+  static ErrorCode CastPtr2ErrorCode(void* ptr) {
+    assert(IsErrorCode(ptr));
     return static_cast&lt;ErrorCode&gt;(reinterpret_cast&lt;intptr_t&gt;(ptr));
   }
-  static GeneralChannelMessage* castErrorCode2Ptr(ErrorCode errCode) {
+  static GeneralChannelMessage* CastErrorCode2Ptr(ErrorCode errCode) {
     return reinterpret_cast&lt;GeneralChannelMessage*&gt;(
         static_cast&lt;intptr_t&gt;(errCode));
   }
@@ -102,7 +102,7 @@ class GeneralChannelMessage : public GeneralMessageBase {
   }
 
  private:
-  explicit GeneralChannelMessage(const std::string&amp; nodeName,
+  explicit GeneralChannelMessage(const std::string&amp; node_name,
                                  RenderableMessage* parent = nullptr)
       : GeneralMessageBase(parent),
         current_state_(State::ShowDebugString),
@@ -112,7 +112,7 @@ class GeneralChannelMessage : public GeneralMessageBase {
         last_time_(apollo::cyber::Time::MonoTime()),
         msg_time_(last_time_.ToNanosecond() + 1),
         channel_node_(nullptr),
-        node_name_(nodeName),
+        node_name_(node_name),
         readers_(),
         writers_(),
         channel_message_(nullptr),
@@ -142,26 +142,26 @@ class GeneralChannelMessage : public GeneralMessageBase {
     vec-&gt;emplace_back(str);
   }
 
-  void updateRawMessage(
-      const std::shared_ptr&lt;apollo::cyber::message::RawMessage&gt;&amp; rawMsg) {
+  void UpdateRawMessage(
+      const std::shared_ptr&lt;apollo::cyber::message::RawMessage&gt;&amp; raw_msg) {
     set_has_message_come(true);
     msg_time_ = apollo::cyber::Time::MonoTime();
     ++frame_counter_;
     std::lock_guard&lt;std::mutex&gt; _g(inner_lock_);
     channel_message_.reset();
-    channel_message_ = rawMsg;
+    channel_message_ = raw_msg;
   }
 
   std::shared_ptr&lt;apollo::cyber::message::RawMessage&gt; CopyMsgPtr(void) const {
-    decltype(channel_message_) channelMsg;
+    decltype(channel_message_) channel_msg;
     {
       std::lock_guard&lt;std::mutex&gt; g(inner_lock_);
-      channelMsg = channel_message_;
+      channel_msg = channel_message_;
     }
-    return channelMsg;
+    return channel_msg;
   }
 
-  GeneralChannelMessage* OpenChannel(const std::string&amp; channelName);
+  GeneralChannelMessage* OpenChannel(const std::string&amp; channel_name);
 
   void RenderDebugString(const Screen* s, int key, int* line_no);
   void RenderInfo(const Screen* s, int key, int* line_no);
</diff>
			</file>
			<file old_path="cyber\tools\cyber_monitor\general_message.cc" new_path="cyber\tools\cyber_monitor\general_message.cc" added_lines="28" deleted_lines="26">
				<diff>@@ -76,7 +76,7 @@ GeneralMessage::GeneralMessage(GeneralMessageBase* parent,
                                const google::protobuf::Reflection* reflection,
                                const google::protobuf::FieldDescriptor* field)
     : GeneralMessageBase(parent),
-      itemIndex_(0),
+      item_index_(0),
       is_folded_(true),
       field_(field),
       message_ptr_(msg),
@@ -91,24 +91,25 @@ int GeneralMessage::Render(const Screen* s, int key) {
       p = p-&gt;parent();
     }
 
-    GeneralChannelMessage* channelMsgPtr =
+    GeneralChannelMessage* channel_msg_ptr =
         static_cast&lt;GeneralChannelMessage*&gt;(p-&gt;parent());
     s-&gt;AddStr(0, line_no++, "ChannelName: ");
-    s-&gt;AddStr(channelMsgPtr-&gt;GetChannelName().c_str());
+    s-&gt;AddStr(channel_msg_ptr-&gt;GetChannelName().c_str());
 
     s-&gt;AddStr(0, line_no++, "MessageType: ");
-    s-&gt;AddStr(channelMsgPtr-&gt;message_type().c_str());
+    s-&gt;AddStr(channel_msg_ptr-&gt;message_type().c_str());
 
-    std::ostringstream outStr;
-    outStr &lt;&lt; std::fixed &lt;&lt; std::setprecision(FrameRatio_Precision)
-           &lt;&lt; channelMsgPtr-&gt;frame_ratio();
+    std::ostringstream out_str;
+    out_str &lt;&lt; std::fixed &lt;&lt; std::setprecision(FrameRatio_Precision)
+            &lt;&lt; channel_msg_ptr-&gt;frame_ratio();
     s-&gt;AddStr(0, line_no++, "FrameRatio: ");
-    s-&gt;AddStr(outStr.str().c_str());
+    s-&gt;AddStr(out_str.str().c_str());
 
     clear();
 
-    auto channelMsg = channelMsgPtr-&gt;CopyMsgPtr();
-    if (!channelMsgPtr-&gt;raw_msg_class_-&gt;ParseFromString(channelMsg-&gt;message)) {
+    auto channel_msg = channel_msg_ptr-&gt;CopyMsgPtr();
+    if (!channel_msg_ptr-&gt;raw_msg_class_-&gt;ParseFromString(
+            channel_msg-&gt;message)) {
       s-&gt;AddStr(0, line_no++,
                 "Cannot Parse the message for Real-Time Updating");
       return line_no;
@@ -125,10 +126,10 @@ int GeneralMessage::Render(const Screen* s, int key) {
         }
       }
 
-      if (size &lt;= itemIndex_) {
-        outStr.str("");
-        outStr &lt;&lt; "The item [" &lt;&lt; itemIndex_ &lt;&lt; "] has been empty !!!";
-        s-&gt;AddStr(0, line_no++, outStr.str().c_str());
+      if (size &lt;= item_index_) {
+        out_str.str("");
+        out_str &lt;&lt; "The item [" &lt;&lt; item_index_ &lt;&lt; "] has been empty !!!";
+        s-&gt;AddStr(0, line_no++, out_str.str().c_str());
         return line_no;
       }
 
@@ -138,25 +139,26 @@ int GeneralMessage::Render(const Screen* s, int key) {
         switch (key) {
           case 'n':
           case 'N':
-            ++itemIndex_;
-            if (itemIndex_ &gt;= size) {
-              itemIndex_ = 0;
+            ++item_index_;
+            if (item_index_ &gt;= size) {
+              item_index_ = 0;
             }
             break;
 
           case 'm':
           case 'M':
-            --itemIndex_;
-            if (itemIndex_ &lt; 0) {
-              itemIndex_ = size - 1;
+            --item_index_;
+            if (item_index_ &lt; 0) {
+              item_index_ = size - 1;
             }
             break;
 
-          default: {}
+          default: {
+          }
         }
       }
 
-      int lcount = lineCountOfField(*message_ptr_, s-&gt;Width(), field_,
+      int lcount = LineCountOfField(*message_ptr_, s-&gt;Width(), field_,
                                     reflection_ptr_, is_folded_);
       page_item_count_ = s-&gt;Height() - line_no - 8;
       if (page_item_count_ &lt; 1) {
@@ -164,16 +166,16 @@ int GeneralMessage::Render(const Screen* s, int key) {
       }
       pages_ = lcount / page_item_count_ + 1;
       SplitPages(key);
-      int jumpLines = page_index_ * page_item_count_;
+      int jump_lines = page_index_ * page_item_count_;
       const std::vector&lt;int&gt; indices(
           SortProtobufMapByKeys(*message_ptr_, field_, *reflection_ptr_, size));
       if (is_folded_) {
-        GeneralMessageBase::PrintField(this, *message_ptr_, &amp;jumpLines, s,
+        GeneralMessageBase::PrintField(this, *message_ptr_, &amp;jump_lines, s,
                                        &amp;line_no, 0, reflection_ptr_, field_,
-                                       indices[itemIndex_]);
+                                       indices[item_index_]);
       } else {
         for (const int index : indices) {
-          GeneralMessageBase::PrintField(this, *message_ptr_, &amp;jumpLines, s,
+          GeneralMessageBase::PrintField(this, *message_ptr_, &amp;jump_lines, s,
                                          &amp;line_no, 0, reflection_ptr_, field_,
                                          index);
         }
</diff>
			</file>
			<file old_path="cyber\tools\cyber_monitor\general_message.h" new_path="cyber\tools\cyber_monitor\general_message.h" added_lines="1" deleted_lines="1">
				<diff>@@ -42,7 +42,7 @@ class GeneralMessage : public GeneralMessageBase {
   GeneralMessage(const GeneralMessage&amp;) = delete;
   GeneralMessage&amp; operator=(const GeneralMessage&amp;) = delete;
 
-  int itemIndex_;
+  int item_index_;
   bool is_folded_;
   const google::protobuf::FieldDescriptor* field_;
   const google::protobuf::Message* message_ptr_;
</diff>
			</file>
			<file old_path="cyber\tools\cyber_monitor\general_message_base.cc" new_path="cyber\tools\cyber_monitor\general_message_base.cc" added_lines="73" deleted_lines="73">
				<diff>@@ -28,33 +28,33 @@ namespace {
 constexpr int INT_FLOAT_PRECISION = 6;
 constexpr int DOULBE_PRECISION = 9;
 
-int calculateStringLines(const std::string&amp; str, int screenWidth) {
+int CalculateStringLines(const std::string&amp; str, int screen_width) {
   int lineWidth = 0;
-  int lineCount = 0;
+  int line_count = 0;
   for (std::size_t i = 0; i &lt; str.size(); ++i) {
     if (str[i] == '\n' || str[i] == '\r') {
-      ++lineCount;
+      ++line_count;
       lineWidth = 0;
     } else {
       ++lineWidth;
-      if (lineWidth == screenWidth) {
-        ++lineCount;
+      if (lineWidth == screen_width) {
+        ++line_count;
         lineWidth = 0;
       }
     }
   }
 
   if (lineWidth) {
-    ++lineCount;
+    ++line_count;
   }
 
-  return lineCount;
+  return line_count;
 }
 
 }  // namespace
 
-int GeneralMessageBase::lineCount(const google::protobuf::Message&amp; msg,
-                                  int screenWidth) {
+int GeneralMessageBase::LineCount(const google::protobuf::Message&amp; msg,
+                                  int screen_width) {
   const google::protobuf::Reflection* reflection = msg.GetReflection();
   const google::protobuf::Descriptor* descriptor = msg.GetDescriptor();
   std::vector&lt;const google::protobuf::FieldDescriptor*&gt; fields;
@@ -68,14 +68,14 @@ int GeneralMessageBase::lineCount(const google::protobuf::Message&amp; msg,
   auto fsize = fields.size();
   int ret = 0;
   for (decltype(fsize) i = 0; i &lt; fsize; ++i) {
-    ret += lineCountOfField(msg, screenWidth, fields[i], reflection);
+    ret += LineCountOfField(msg, screen_width, fields[i], reflection);
   }  // end for
 
   return ret;
 }
 
-int GeneralMessageBase::lineCountOfField(
-    const google::protobuf::Message&amp; msg, int screenWidth,
+int GeneralMessageBase::LineCountOfField(
+    const google::protobuf::Message&amp; msg, int screen_width,
     const google::protobuf::FieldDescriptor* field,
     const google::protobuf::Reflection* reflection, bool is_folded) {
   int ret = 0;
@@ -87,14 +87,14 @@ int GeneralMessageBase::lineCountOfField(
           std::string scratch;
           const std::string&amp; value =
               reflection-&gt;GetRepeatedStringReference(msg, field, i, &amp;scratch);
-          ret += calculateStringLines(value, screenWidth);
+          ret += CalculateStringLines(value, screen_width);
           break;
         }
 
         case google::protobuf::FieldDescriptor::CPPTYPE_MESSAGE: {
-          const google::protobuf::Message&amp; childMsg =
+          const google::protobuf::Message&amp; child_msg =
               reflection-&gt;GetRepeatedMessage(msg, field, i);
-          ret += lineCount(childMsg, screenWidth);
+          ret += LineCount(child_msg, screen_width);
           break;
         }
 
@@ -110,14 +110,14 @@ int GeneralMessageBase::lineCountOfField(
           std::string scratch;
           const std::string&amp; value =
               reflection-&gt;GetStringReference(msg, field, &amp;scratch);
-          ret += calculateStringLines(value, screenWidth);
+          ret += CalculateStringLines(value, screen_width);
           break;
         }
 
         case google::protobuf::FieldDescriptor::CPPTYPE_MESSAGE: {
-          const google::protobuf::Message&amp; childMsg =
+          const google::protobuf::Message&amp; child_msg =
               reflection-&gt;GetMessage(msg, field);
-          ret += lineCount(childMsg, screenWidth);
+          ret += LineCount(child_msg, screen_width);
           break;
         }
 
@@ -131,7 +131,7 @@ int GeneralMessageBase::lineCountOfField(
 
 void GeneralMessageBase::PrintMessage(GeneralMessageBase* baseMsg,
                                       const google::protobuf::Message&amp; msg,
-                                      int* jumpLines, const Screen* s,
+                                      int* jump_lines, const Screen* s,
                                       int* line_no, int indent) {
   const google::protobuf::Reflection* reflection = msg.GetReflection();
   const google::protobuf::Descriptor* descriptor = msg.GetDescriptor();
@@ -148,23 +148,23 @@ void GeneralMessageBase::PrintMessage(GeneralMessageBase* baseMsg,
     }
     const google::protobuf::FieldDescriptor* field = fields[i];
     if (field-&gt;is_repeated()) {
-      if (*jumpLines) {
-        --(*jumpLines);
+      if (*jump_lines) {
+        --(*jump_lines);
       } else {
-        std::ostringstream outStr;
+        std::ostringstream out_str;
         const std::string&amp; fieldName = field-&gt;name();
-        outStr &lt;&lt; fieldName &lt;&lt; ": ";
-        outStr &lt;&lt; "+[" &lt;&lt; reflection-&gt;FieldSize(msg, field) &lt;&lt; " items]";
+        out_str &lt;&lt; fieldName &lt;&lt; ": ";
+        out_str &lt;&lt; "+[" &lt;&lt; reflection-&gt;FieldSize(msg, field) &lt;&lt; " items]";
         GeneralMessage* item =
             new GeneralMessage(baseMsg, &amp;msg, reflection, field);
         if (item) {
           baseMsg-&gt;insertRepeatedMessage(*line_no, item);
         }
-        s-&gt;AddStr(indent, (*line_no)++, outStr.str().c_str());
+        s-&gt;AddStr(indent, (*line_no)++, out_str.str().c_str());
       }
     } else {
-      PrintField(baseMsg, msg, jumpLines, s, line_no, indent, reflection, field,
-                 -1);
+      PrintField(baseMsg, msg, jump_lines, s, line_no, indent, reflection,
+                 field, -1);
     }  // end else
   }    // end for
 
@@ -182,31 +182,31 @@ void GeneralMessageBase::PrintMessage(GeneralMessageBase* baseMsg,
 
 void GeneralMessageBase::PrintField(
     GeneralMessageBase* baseMsg, const google::protobuf::Message&amp; msg,
-    int* jumpLines, const Screen* s, int* line_no, int indent,
+    int* jump_lines, const Screen* s, int* line_no, int indent,
     const google::protobuf::Reflection* ref,
     const google::protobuf::FieldDescriptor* field, int index) {
-  std::ostringstream outStr;
+  std::ostringstream out_str;
   std::ios_base::fmtflags old_flags;
 
   switch (field-&gt;cpp_type()) {
-#define OUTPUT_FIELD(CPPTYPE, METHOD, PRECISION)                   \
-  case google::protobuf::FieldDescriptor::CPPTYPE_##CPPTYPE:       \
-    if (*jumpLines) {                                              \
-      --(*jumpLines);                                              \
-    } else {                                                       \
-      const std::string&amp; fieldName = field-&gt;name();                \
-      outStr &lt;&lt; fieldName &lt;&lt; ": ";                                 \
-      if (field-&gt;is_repeated()) {                                  \
-        outStr &lt;&lt; "[" &lt;&lt; index &lt;&lt; "] ";                            \
-      }                                                            \
-      old_flags = outStr.flags();                                  \
-      outStr &lt;&lt; std::fixed &lt;&lt; std::setprecision(PRECISION)         \
-             &lt;&lt; (field-&gt;is_repeated()                              \
-                     ? ref-&gt;GetRepeated##METHOD(msg, field, index) \
-                     : ref-&gt;Get##METHOD(msg, field));              \
-      outStr.flags(old_flags);                                     \
-      s-&gt;AddStr(indent, (*line_no)++, outStr.str().c_str());       \
-    }                                                              \
+#define OUTPUT_FIELD(CPPTYPE, METHOD, PRECISION)                    \
+  case google::protobuf::FieldDescriptor::CPPTYPE_##CPPTYPE:        \
+    if (*jump_lines) {                                              \
+      --(*jump_lines);                                              \
+    } else {                                                        \
+      const std::string&amp; fieldName = field-&gt;name();                 \
+      out_str &lt;&lt; fieldName &lt;&lt; ": ";                                 \
+      if (field-&gt;is_repeated()) {                                   \
+        out_str &lt;&lt; "[" &lt;&lt; index &lt;&lt; "] ";                            \
+      }                                                             \
+      old_flags = out_str.flags();                                  \
+      out_str &lt;&lt; std::fixed &lt;&lt; std::setprecision(PRECISION)         \
+              &lt;&lt; (field-&gt;is_repeated()                              \
+                      ? ref-&gt;GetRepeated##METHOD(msg, field, index) \
+                      : ref-&gt;Get##METHOD(msg, field));              \
+      out_str.flags(old_flags);                                     \
+      s-&gt;AddStr(indent, (*line_no)++, out_str.str().c_str());       \
+    }                                                               \
     break
 
     OUTPUT_FIELD(INT32, Int32, INT_FLOAT_PRECISION);
@@ -228,47 +228,47 @@ void GeneralMessageBase::PrintField(
         int lineWidth = 0;
         std::size_t i = 0;
 
-        for (; i &lt; str.size() &amp;&amp; *jumpLines &gt; 0; ++i) {
+        for (; i &lt; str.size() &amp;&amp; *jump_lines &gt; 0; ++i) {
           if (str[i] == '\n' || str[i] == '\r') {
-            --(*jumpLines);
+            --(*jump_lines);
             lineWidth = 0;
           } else {
             ++lineWidth;
             if (lineWidth == s-&gt;Width()) {
-              --(*jumpLines);
+              --(*jump_lines);
               lineWidth = 0;
             }
           }
         }
 
-        if (*jumpLines == 0) {
+        if (*jump_lines == 0) {
           lineWidth = 0;
-          unsigned lineCount = 1;
+          unsigned line_count = 1;
 
           const std::string&amp; fieldName = field-&gt;name();
-          outStr &lt;&lt; fieldName &lt;&lt; ": ";
+          out_str &lt;&lt; fieldName &lt;&lt; ": ";
           if (field-&gt;is_repeated()) {
-            outStr &lt;&lt; "[" &lt;&lt; index &lt;&lt; "] ";
+            out_str &lt;&lt; "[" &lt;&lt; index &lt;&lt; "] ";
           }
 
           for (; i &lt; str.size(); ++i) {
             char ch = str[i];
             if (str[i] == '\n' || str[i] == '\r') {
-              ++lineCount;
+              ++line_count;
               lineWidth = 0;
               ch = '\n';
             } else {
               ++lineWidth;
               if (lineWidth == s-&gt;Width()) {
-                ++lineCount;
+                ++line_count;
                 lineWidth = 0;
               }
             }
-            outStr &lt;&lt; ch;
+            out_str &lt;&lt; ch;
           }
 
-          s-&gt;AddStr(indent, *line_no, outStr.str().c_str());
-          (*line_no) += lineCount;
+          s-&gt;AddStr(indent, *line_no, out_str.str().c_str());
+          (*line_no) += line_count;
         }
       }
 
@@ -276,13 +276,13 @@ void GeneralMessageBase::PrintField(
     }
 
     case google::protobuf::FieldDescriptor::CPPTYPE_ENUM: {
-      if (*jumpLines) {
-        --(*jumpLines);
+      if (*jump_lines) {
+        --(*jump_lines);
       } else {
         const std::string&amp; fieldName = field-&gt;name();
-        outStr &lt;&lt; fieldName &lt;&lt; ": ";
+        out_str &lt;&lt; fieldName &lt;&lt; ": ";
         if (field-&gt;is_repeated()) {
-          outStr &lt;&lt; "[" &lt;&lt; index &lt;&lt; "] ";
+          out_str &lt;&lt; "[" &lt;&lt; index &lt;&lt; "] ";
         }
         int enum_value = field-&gt;is_repeated()
                              ? ref-&gt;GetRepeatedEnumValue(msg, field, index)
@@ -290,34 +290,34 @@ void GeneralMessageBase::PrintField(
         const google::protobuf::EnumValueDescriptor* enum_desc =
             field-&gt;enum_type()-&gt;FindValueByNumber(enum_value);
         if (enum_desc != nullptr) {
-          outStr &lt;&lt; enum_desc-&gt;name();
+          out_str &lt;&lt; enum_desc-&gt;name();
         } else {
-          outStr &lt;&lt; enum_value;
+          out_str &lt;&lt; enum_value;
         }
-        s-&gt;AddStr(indent, (*line_no)++, outStr.str().c_str());
+        s-&gt;AddStr(indent, (*line_no)++, out_str.str().c_str());
       }
       break;
     }
 
     case google::protobuf::FieldDescriptor::CPPTYPE_MESSAGE:
-      if (!*jumpLines) {
+      if (!*jump_lines) {
         const std::string&amp; fieldName = field-&gt;name();
-        outStr &lt;&lt; fieldName;
+        out_str &lt;&lt; fieldName;
         if (!field-&gt;is_map()) {
-          outStr &lt;&lt; ": ";
+          out_str &lt;&lt; ": ";
           if (field-&gt;is_repeated()) {
-            outStr &lt;&lt; "[" &lt;&lt; index &lt;&lt; "] ";
+            out_str &lt;&lt; "[" &lt;&lt; index &lt;&lt; "] ";
           }
         }
-        s-&gt;AddStr(indent, (*line_no)++, outStr.str().c_str());
+        s-&gt;AddStr(indent, (*line_no)++, out_str.str().c_str());
       } else {
-        --(*jumpLines);
+        --(*jump_lines);
       }
       GeneralMessageBase::PrintMessage(
           baseMsg,
           field-&gt;is_repeated() ? ref-&gt;GetRepeatedMessage(msg, field, index)
                                : ref-&gt;GetMessage(msg, field),
-          jumpLines, s, line_no, indent + 2);
+          jump_lines, s, line_no, indent + 2);
       break;
   }
 }
</diff>
			</file>
			<file old_path="cyber\tools\cyber_monitor\general_message_base.h" new_path="cyber\tools\cyber_monitor\general_message_base.h" added_lines="7" deleted_lines="6">
				<diff>@@ -28,18 +28,19 @@ class Screen;
 class GeneralMessageBase : public RenderableMessage {
  protected:
   static void PrintMessage(GeneralMessageBase* baseMsg,
-                           const google::protobuf::Message&amp; msg, int* jumpLines,
-                           const Screen* s, int* line_no, int indent);
+                           const google::protobuf::Message&amp; msg,
+                           int* jump_lines, const Screen* s, int* line_no,
+                           int indent);
   static void PrintField(GeneralMessageBase* baseMsg,
-                         const google::protobuf::Message&amp; msg, int* jumpLines,
+                         const google::protobuf::Message&amp; msg, int* jump_lines,
                          const Screen* s, int* line_no, int indent,
                          const google::protobuf::Reflection* ref,
                          const google::protobuf::FieldDescriptor* field,
                          int index);
 
-  static int lineCount(const google::protobuf::Message&amp; msg, int screenWidth);
-  static int lineCountOfField(const google::protobuf::Message&amp; msg,
-                              int screenWidth,
+  static int LineCount(const google::protobuf::Message&amp; msg, int screen_width);
+  static int LineCountOfField(const google::protobuf::Message&amp; msg,
+                              int screen_width,
                               const google::protobuf::FieldDescriptor* field,
                               const google::protobuf::Reflection* reflection,
                               bool is_folded = true);
</diff>
			</file>
			<file old_path="cyber\tools\cyber_monitor\main.cc" new_path="cyber\tools\cyber_monitor\main.cc" added_lines="20" deleted_lines="20">
				<diff>@@ -27,9 +27,9 @@ namespace {
 void SigResizeHandle(int) { Screen::Instance()-&gt;Resize(); }
 void SigCtrlCHandle(int) { Screen::Instance()-&gt;Stop(); }
 
-void printHelp(const char *cmdName) {
+void printHelp(const char *cmd_name) {
   std::cout &lt;&lt; "Usage:\n"
-            &lt;&lt; cmdName &lt;&lt; "  [option]\nOption:\n"
+            &lt;&lt; cmd_name &lt;&lt; "  [option]\nOption:\n"
             &lt;&lt; "   -h print help info\n"
             &lt;&lt; "   -c specify one channel\n"
             &lt;&lt; "Interactive Command:\n"
@@ -43,7 +43,7 @@ enum COMMAND {
   CHANNEL     // 3 -&gt; 4
 };
 
-COMMAND parseOption(int argc, char *const argv[], std::string *commandVal) {
+COMMAND ParseOption(int argc, char *const argv[], std::string *command_val) {
   if (argc &gt; 4) {
     return TOO_MANY_PARAMETER;
   }
@@ -58,7 +58,7 @@ COMMAND parseOption(int argc, char *const argv[], std::string *commandVal) {
     }
     if (strcmp(opt, "-c") == 0) {
       if (argv[index + 1]) {
-        *commandVal = argv[index + 1];
+        *command_val = argv[index + 1];
         return CHANNEL;
       }
     }
@@ -74,7 +74,7 @@ COMMAND parseOption(int argc, char *const argv[], std::string *commandVal) {
 int main(int argc, char *argv[]) {
   std::string val;
 
-  COMMAND com = parseOption(argc, argv, &amp;val);
+  COMMAND com = ParseOption(argc, argv, &amp;val);
 
   switch (com) {
     case TOO_MANY_PARAMETER:
@@ -91,28 +91,28 @@ int main(int argc, char *argv[]) {
   FLAGS_alsologtostderr = 0;
   FLAGS_colorlogtostderr = 0;
 
-  CyberTopologyMessage topologyMsg(val);
+  CyberTopologyMessage topology_msg(val);
 
-  auto topologyCallback =
-      [&amp;topologyMsg](const apollo::cyber::proto::ChangeMsg &amp;change_msg) {
-        topologyMsg.TopologyChanged(change_msg);
+  auto topology_callback =
+      [&amp;topology_msg](const apollo::cyber::proto::ChangeMsg &amp;change_msg) {
+        topology_msg.TopologyChanged(change_msg);
       };
 
-  auto channelManager =
+  auto channel_manager =
       apollo::cyber::service_discovery::TopologyManager::Instance()
           -&gt;channel_manager();
-  channelManager-&gt;AddChangeListener(topologyCallback);
+  channel_manager-&gt;AddChangeListener(topology_callback);
 
-  std::vector&lt;apollo::cyber::proto::RoleAttributes&gt; roleVec;
-  channelManager-&gt;GetWriters(&amp;roleVec);
-  for (auto &amp;role : roleVec) {
-    topologyMsg.AddReaderWriter(role, true);
+  std::vector&lt;apollo::cyber::proto::RoleAttributes&gt; role_vec;
+  channel_manager-&gt;GetWriters(&amp;role_vec);
+  for (auto &amp;role : role_vec) {
+    topology_msg.AddReaderWriter(role, true);
   }
 
-  roleVec.clear();
-  channelManager-&gt;GetReaders(&amp;roleVec);
-  for (auto &amp;role : roleVec) {
-    topologyMsg.AddReaderWriter(role, false);
+  role_vec.clear();
+  channel_manager-&gt;GetReaders(&amp;role_vec);
+  for (auto &amp;role : role_vec) {
+    topology_msg.AddReaderWriter(role, false);
   }
 
   Screen *s = Screen::Instance();
@@ -120,7 +120,7 @@ int main(int argc, char *argv[]) {
   signal(SIGWINCH, SigResizeHandle);
   signal(SIGINT, SigCtrlCHandle);
 
-  s-&gt;SetCurrentRenderMessage(&amp;topologyMsg);
+  s-&gt;SetCurrentRenderMessage(&amp;topology_msg);
 
   s-&gt;Init();
   s-&gt;Run();
</diff>
			</file>
			<file old_path="cyber\tools\cyber_monitor\renderable_message.cc" new_path="cyber\tools\cyber_monitor\renderable_message.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -37,6 +37,7 @@ void RenderableMessage::SplitPages(int key) {
         page_index_ = 0;
       }
       break;
-    default: {}
+    default: {
+    }
   }
 }
</diff>
			</file>
			<file old_path="cyber\tools\cyber_monitor\screen.cc" new_path="cyber\tools\cyber_monitor\screen.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -24,12 +24,12 @@
 #include &lt;mutex&gt;
 #include &lt;thread&gt;
 
-#include &lt;ncurses.h&gt;
-
 #include "cyber/tools/cyber_monitor/cyber_topology_message.h"
 #include "cyber/tools/cyber_monitor/general_channel_message.h"
 #include "cyber/tools/cyber_monitor/renderable_message.h"
 
+#include &lt;ncurses.h&gt; // NOLINT
+
 namespace {
 constexpr double MinHalfFrameRatio = 12.5;
 }
</diff>
			</file>
			<file old_path="cyber\tools\cyber_monitor\screen.h" new_path="cyber\tools\cyber_monitor\screen.h" added_lines="4" deleted_lines="4">
				<diff>@@ -51,7 +51,7 @@ class Screen final {
   int Width(void) const;
   int Height(void) const;
 
-  void AddStr(int x, int y, ColorPair color, const char* cStr) const;
+  void AddStr(int x, int y, ColorPair color, const char* str) const;
 
   ColorPair Color(void) const { return current_color_pair_; }
   void SetCurrentColor(ColorPair color) const;
@@ -60,9 +60,9 @@ class Screen final {
   void MoveOffsetXY(int offsetX, int offsetY) const;
   void ClearCurrentColor(void) const;
 
-  void SetCurrentRenderMessage(RenderableMessage* const renderObj) {
-    if (renderObj) {
-      current_render_obj_ = renderObj;
+  void SetCurrentRenderMessage(RenderableMessage* const render_obj) {
+    if (render_obj) {
+      current_render_obj_ = render_obj;
     }
   }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a621dc54597e018b0665fad6170d098bc3f3499c" author="macDure">
		<msg>driver: change the socket can filter for devkit</msg>
		<modified_files>
			<file old_path="modules\drivers\canbus\can_client\socket\socket_can_client_raw.cc" new_path="modules\drivers\canbus\can_client\socket\socket_can_client_raw.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -79,8 +79,8 @@ ErrorCode SocketCanClientRaw::Start() {
 
   // 1. for non virtual busses, set receive message_id filter, ie white list
   if (interface_ != CANCardParameter::VIRTUAL) {
-    struct can_filter filter[512];
-    for (int i = 0; i &lt; 512; ++i) {
+    struct can_filter filter[2048];
+    for (int i = 0; i &lt; 2048; ++i) {
       filter[i].can_id = 0x000 + i;
       filter[i].can_mask = CAN_SFF_MASK;
     }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="988c4a8538931a93ed3b30ad3242dfb6c36d11ec" author="changsh726">
		<msg>cyber_monitor: unified naming style and removed unnecessary comments</msg>
		<modified_files>
			<file old_path="cyber\tools\cyber_monitor\general_message_base.cc" new_path="cyber\tools\cyber_monitor\general_message_base.cc" added_lines="22" deleted_lines="23">
				<diff>@@ -20,7 +20,6 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
-#include "cyber/tools/cyber_monitor/general_channel_message.h"
 #include "cyber/tools/cyber_monitor/general_message.h"
 #include "cyber/tools/cyber_monitor/screen.h"
 
@@ -29,22 +28,22 @@ constexpr int INT_FLOAT_PRECISION = 6;
 constexpr int DOULBE_PRECISION = 9;
 
 int CalculateStringLines(const std::string&amp; str, int screen_width) {
-  int lineWidth = 0;
+  int line_width = 0;
   int line_count = 0;
   for (std::size_t i = 0; i &lt; str.size(); ++i) {
     if (str[i] == '\n' || str[i] == '\r') {
       ++line_count;
-      lineWidth = 0;
+      line_width = 0;
     } else {
-      ++lineWidth;
-      if (lineWidth == screen_width) {
+      ++line_width;
+      if (line_width == screen_width) {
         ++line_count;
-        lineWidth = 0;
+        line_width = 0;
       }
     }
   }
 
-  if (lineWidth) {
+  if (line_width) {
     ++line_count;
   }
 
@@ -69,7 +68,7 @@ int GeneralMessageBase::LineCount(const google::protobuf::Message&amp; msg,
   int ret = 0;
   for (decltype(fsize) i = 0; i &lt; fsize; ++i) {
     ret += LineCountOfField(msg, screen_width, fields[i], reflection);
-  }  // end for
+  }
 
   return ret;
 }
@@ -100,7 +99,7 @@ int GeneralMessageBase::LineCountOfField(
 
         default:
           ret += 1;
-      }  // end switch
+      }
     }
   } else {
     ret = 1;
@@ -123,7 +122,7 @@ int GeneralMessageBase::LineCountOfField(
 
         default: {
         }
-      }  // end switch
+      }
     }
   }
   return ret;
@@ -158,15 +157,15 @@ void GeneralMessageBase::PrintMessage(GeneralMessageBase* baseMsg,
         GeneralMessage* item =
             new GeneralMessage(baseMsg, &amp;msg, reflection, field);
         if (item) {
-          baseMsg-&gt;insertRepeatedMessage(*line_no, item);
+          baseMsg-&gt;InsertRepeatedMessage(*line_no, item);
         }
         s-&gt;AddStr(indent, (*line_no)++, out_str.str().c_str());
       }
     } else {
       PrintField(baseMsg, msg, jump_lines, s, line_no, indent, reflection,
                  field, -1);
-    }  // end else
-  }    // end for
+    }
+  }
 
   const google::protobuf::UnknownFieldSet&amp; unknown_fields =
       reflection-&gt;GetUnknownFields(msg);
@@ -225,24 +224,24 @@ void GeneralMessageBase::PrintField(
               ? ref-&gt;GetRepeatedStringReference(msg, field, index, &amp;scratch)
               : ref-&gt;GetStringReference(msg, field, &amp;scratch);
       {
-        int lineWidth = 0;
+        int line_width = 0;
         std::size_t i = 0;
 
         for (; i &lt; str.size() &amp;&amp; *jump_lines &gt; 0; ++i) {
           if (str[i] == '\n' || str[i] == '\r') {
             --(*jump_lines);
-            lineWidth = 0;
+            line_width = 0;
           } else {
-            ++lineWidth;
-            if (lineWidth == s-&gt;Width()) {
+            ++line_width;
+            if (line_width == s-&gt;Width()) {
               --(*jump_lines);
-              lineWidth = 0;
+              line_width = 0;
             }
           }
         }
 
         if (*jump_lines == 0) {
-          lineWidth = 0;
+          line_width = 0;
           unsigned line_count = 1;
 
           const std::string&amp; fieldName = field-&gt;name();
@@ -255,13 +254,13 @@ void GeneralMessageBase::PrintField(
             char ch = str[i];
             if (str[i] == '\n' || str[i] == '\r') {
               ++line_count;
-              lineWidth = 0;
+              line_width = 0;
               ch = '\n';
             } else {
-              ++lineWidth;
-              if (lineWidth == s-&gt;Width()) {
+              ++line_width;
+              if (line_width == s-&gt;Width()) {
                 ++line_count;
-                lineWidth = 0;
+                line_width = 0;
               }
             }
             out_str &lt;&lt; ch;
</diff>
			</file>
			<file old_path="cyber\tools\cyber_monitor\general_message_base.h" new_path="cyber\tools\cyber_monitor\general_message_base.h" added_lines="2" deleted_lines="2">
				<diff>@@ -45,8 +45,8 @@ class GeneralMessageBase : public RenderableMessage {
                               const google::protobuf::Reflection* reflection,
                               bool is_folded = true);
 
-  void insertRepeatedMessage(int line_no, GeneralMessageBase* item) {
-    children_map_.insert(std::make_pair(line_no, item));
+  void InsertRepeatedMessage(int line_no, GeneralMessageBase* item) {
+    children_map_.emplace(line_no, item);
   }
 
   RenderableMessage* Child(int line_no) const override;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="18d137c206abae143bd19c7ac2096c8ba4ca709a" author="Flaviu">
		<msg>Optimized GetReaderAndLatestMessage function.

Replaced channel indetification from serial string matching to hash map matching.
Ran format, lint and tests on monitor module.</msg>
		<modified_files>
			<file old_path="modules\monitor\software\channel_monitor.cc" new_path="modules\monitor\software\channel_monitor.cc" added_lines="51" deleted_lines="75">
				<diff>@@ -27,22 +27,23 @@
 #include "google/protobuf/descriptor.h"
 #include "google/protobuf/dynamic_message.h"
 
-#include "cyber/common/log.h"
-#include "cyber/cyber.h"
-#include "modules/common/adapters/adapter_gflags.h"
 #include "modules/common/latency_recorder/proto/latency_record.pb.h"
-#include "modules/common/util/map_util.h"
 #include "modules/control/proto/control_cmd.pb.h"
 #include "modules/drivers/proto/conti_radar.pb.h"
 #include "modules/drivers/proto/pointcloud.pb.h"
 #include "modules/localization/proto/pose.pb.h"
 #include "modules/map/relative_map/proto/navigation.pb.h"
-#include "modules/monitor/common/monitor_manager.h"
-#include "modules/monitor/software/summary_monitor.h"
 #include "modules/perception/proto/perception_obstacle.pb.h"
 #include "modules/planning/proto/planning.pb.h"
 #include "modules/prediction/proto/prediction_obstacle.pb.h"
 
+#include "cyber/common/log.h"
+#include "cyber/cyber.h"
+#include "modules/common/adapters/adapter_gflags.h"
+#include "modules/common/util/map_util.h"
+#include "modules/monitor/common/monitor_manager.h"
+#include "modules/monitor/software/summary_monitor.h"
+
 DEFINE_string(channel_monitor_name, "ChannelMonitor",
               "Name of the channel monitor.");
 
@@ -53,79 +54,54 @@ namespace apollo {
 namespace monitor {
 namespace {
 
+using ReaderAndMessagePair =
+    std::pair&lt;std::shared_ptr&lt;cyber::ReaderBase&gt;,
+              std::shared_ptr&lt;google::protobuf::Message&gt;&gt;;
+
+template &lt;typename T&gt;
+ReaderAndMessagePair CreateReaderAndLatestsMessage(const std::string&amp; channel) {
+  const auto reader = MonitorManager::Instance()-&gt;CreateReader&lt;T&gt;(channel);
+  reader-&gt;Observe();
+  const auto message = reader-&gt;GetLatestObserved();
+  return {reader, message};
+}
+
 // We have to specify exact type of each channel. This function is a wrapper for
 // those only need a ReaderBase.
-std::pair&lt;std::shared_ptr&lt;cyber::ReaderBase&gt;,
-          std::shared_ptr&lt;google::protobuf::Message&gt;&gt;
-GetReaderAndLatestMessage(const std::string&amp; channel) {
-  auto manager = MonitorManager::Instance();
-  if (channel == FLAGS_control_command_topic) {
-    const auto reader = manager-&gt;CreateReader&lt;control::ControlCommand&gt;(channel);
-    reader-&gt;Observe();
-    const auto message = reader-&gt;GetLatestObserved();
-    return std::pair&lt;std::shared_ptr&lt;cyber::ReaderBase&gt;,
-                     std::shared_ptr&lt;google::protobuf::Message&gt;&gt;(reader,
-                                                                 message);
-  } else if (channel == FLAGS_localization_topic) {
-    const auto reader =
-        manager-&gt;CreateReader&lt;localization::LocalizationEstimate&gt;(channel);
-    reader-&gt;Observe();
-    const auto message = reader-&gt;GetLatestObserved();
-    return std::pair&lt;std::shared_ptr&lt;cyber::ReaderBase&gt;,
-                     std::shared_ptr&lt;google::protobuf::Message&gt;&gt;(reader,
-                                                                 message);
-  } else if (channel == FLAGS_perception_obstacle_topic) {
-    const auto reader =
-        manager-&gt;CreateReader&lt;perception::PerceptionObstacles&gt;(channel);
-    reader-&gt;Observe();
-    const auto message = reader-&gt;GetLatestObserved();
-    return std::pair&lt;std::shared_ptr&lt;cyber::ReaderBase&gt;,
-                     std::shared_ptr&lt;google::protobuf::Message&gt;&gt;(reader,
-                                                                 message);
-  } else if (channel == FLAGS_prediction_topic) {
-    const auto reader =
-        manager-&gt;CreateReader&lt;prediction::PredictionObstacles&gt;(channel);
-    reader-&gt;Observe();
-    const auto message = reader-&gt;GetLatestObserved();
-    return std::pair&lt;std::shared_ptr&lt;cyber::ReaderBase&gt;,
-                     std::shared_ptr&lt;google::protobuf::Message&gt;&gt;(reader,
-                                                                 message);
-  } else if (channel == FLAGS_planning_trajectory_topic) {
-    const auto reader = manager-&gt;CreateReader&lt;planning::ADCTrajectory&gt;(channel);
-    reader-&gt;Observe();
-    const auto message = reader-&gt;GetLatestObserved();
-    return std::pair&lt;std::shared_ptr&lt;cyber::ReaderBase&gt;,
-                     std::shared_ptr&lt;google::protobuf::Message&gt;&gt;(reader,
-                                                                 message);
-  } else if (channel == FLAGS_conti_radar_topic) {
-    const auto reader = manager-&gt;CreateReader&lt;drivers::ContiRadar&gt;(channel);
-    reader-&gt;Observe();
-    const auto message = reader-&gt;GetLatestObserved();
-    return std::pair&lt;std::shared_ptr&lt;cyber::ReaderBase&gt;,
-                     std::shared_ptr&lt;google::protobuf::Message&gt;&gt;(reader,
-                                                                 message);
-  } else if (channel == FLAGS_relative_map_topic) {
-    const auto reader = manager-&gt;CreateReader&lt;relative_map::MapMsg&gt;(channel);
-    reader-&gt;Observe();
-    const auto message = reader-&gt;GetLatestObserved();
-    return std::pair&lt;std::shared_ptr&lt;cyber::ReaderBase&gt;,
-                     std::shared_ptr&lt;google::protobuf::Message&gt;&gt;(reader,
-                                                                 message);
-  } else if (channel == FLAGS_pointcloud_topic ||
-             channel == FLAGS_pointcloud_128_topic ||
-             channel == FLAGS_pointcloud_16_front_up_topic) {
-    const auto reader = manager-&gt;CreateReader&lt;drivers::PointCloud&gt;(channel);
-    reader-&gt;Observe();
-    const auto message = reader-&gt;GetLatestObserved();
-    return std::pair&lt;std::shared_ptr&lt;cyber::ReaderBase&gt;,
-                     std::shared_ptr&lt;google::protobuf::Message&gt;&gt;(reader,
-                                                                 message);
+ReaderAndMessagePair GetReaderAndLatestMessage(const std::string&amp; channel) {
+  static const auto channel_function_map =
+      std::unordered_map&lt;std::string, std::function&lt;ReaderAndMessagePair(
+                                          const std::string&amp; channel)&gt;&gt;{
+          {FLAGS_control_command_topic,
+           &amp;CreateReaderAndLatestsMessage&lt;control::ControlCommand&gt;},
+          {FLAGS_localization_topic,
+           &amp;CreateReaderAndLatestsMessage&lt;localization::LocalizationEstimate&gt;},
+          {FLAGS_perception_obstacle_topic,
+           &amp;CreateReaderAndLatestsMessage&lt;perception::PerceptionObstacles&gt;},
+          {FLAGS_prediction_topic,
+           &amp;CreateReaderAndLatestsMessage&lt;prediction::PredictionObstacles&gt;},
+          {FLAGS_planning_trajectory_topic,
+           &amp;CreateReaderAndLatestsMessage&lt;planning::ADCTrajectory&gt;},
+          {FLAGS_conti_radar_topic,
+           &amp;CreateReaderAndLatestsMessage&lt;drivers::ContiRadar&gt;},
+          {FLAGS_relative_map_topic,
+           &amp;CreateReaderAndLatestsMessage&lt;relative_map::MapMsg&gt;},
+          {FLAGS_pointcloud_topic,
+           &amp;CreateReaderAndLatestsMessage&lt;drivers::PointCloud&gt;},
+          {FLAGS_pointcloud_128_topic,
+           &amp;CreateReaderAndLatestsMessage&lt;drivers::PointCloud&gt;},
+          {FLAGS_pointcloud_16_front_up_topic,
+           &amp;CreateReaderAndLatestsMessage&lt;drivers::PointCloud&gt;}
+          // Add more channels here if you want to monitor.
+      };
+
+  auto entry = channel_function_map.find(channel);
+  if (entry != channel_function_map.end()) {
+    return (entry-&gt;second)(channel);
   }
-  // Add more channels here if you want to monitor.
+
   AERROR &lt;&lt; "Channel is not handled by ChannelMonitor: " &lt;&lt; channel;
-  return std::pair&lt;std::shared_ptr&lt;cyber::ReaderBase&gt;,
-                   std::shared_ptr&lt;google::protobuf::Message&gt;&gt;(nullptr,
-                                                               nullptr);
+  return {nullptr, nullptr};
 }
 
 bool ValidateFields(const google::protobuf::Message&amp; message,
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9e2b0772e3a664804591c1f33a349367b6e99069" author="Chao Ma">
		<msg>canbus: add the battery info protocol in devkit (#12783)</msg>
		<modified_files>
			<file old_path="modules\canbus\vehicle\devkit\protocol\vcu_report_505.cc" new_path="modules\canbus\vehicle\devkit\protocol\vcu_report_505.cc" added_lines="13" deleted_lines="0">
				<diff>@@ -31,6 +31,8 @@ const int32_t Vcureport505::ID = 0x505;
 
 void Vcureport505::Parse(const std::uint8_t* bytes, int32_t length,
                          ChassisDetail* chassis) const {
+  chassis-&gt;mutable_devkit()-&gt;mutable_vcu_report_505()-&gt;set_battary_soc(
+      battary_soc(bytes, length));
   chassis-&gt;mutable_devkit()-&gt;mutable_vcu_report_505()-&gt;set_vehicle_mode_state(
       vehicle_mode_state(bytes, length));
   chassis-&gt;mutable_devkit()-&gt;mutable_vcu_report_505()-&gt;set_frontcrash_state(
@@ -45,6 +47,17 @@ void Vcureport505::Parse(const std::uint8_t* bytes, int32_t length,
       speed(bytes, length));
 }
 
+// config detail: {'name': 'battary_soc', 'offset': 0.0, 'precision': 1.0,
+// 'len': 8, 'is_signed_var': False, 'physical_range': '[0|100]', 'bit': 47,
+// 'type': 'int', 'order': 'motorola', 'physical_unit': '%'}
+int Vcureport505::battary_soc(const std::uint8_t* bytes, int32_t length) const {
+  Byte t0(bytes + 5);
+  int32_t x = t0.get_byte(0, 8);
+
+  int ret = x;
+  return ret;
+}
+
 // config detail: {'name': 'vehicle_mode_state', 'enum': {0:
 // 'VEHICLE_MODE_STATE_MANUAL_REMOTE_MODE', 1: 'VEHICLE_MODE_STATE_AUTO_MODE',
 // 2: 'VEHICLE_MODE_STATE_EMERGENCY_MODE', 3:
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\protocol\vcu_report_505.h" new_path="modules\canbus\vehicle\devkit\protocol\vcu_report_505.h" added_lines="5" deleted_lines="0">
				<diff>@@ -32,6 +32,11 @@ class Vcureport505 : public ::apollo::drivers::canbus::ProtocolData&lt;
              ChassisDetail* chassis) const override;
 
  private:
+  // config detail: {'name': 'Battary_Soc', 'offset': 0.0, 'precision': 1.0,
+  // 'len': 8, 'is_signed_var': False, 'physical_range': '[0|100]', 'bit': 47,
+  // 'type': 'int', 'order': 'motorola', 'physical_unit': '%'}
+  int battary_soc(const std::uint8_t* bytes, const int32_t length) const;
+
   // config detail: {'name': 'Vehicle_Mode_State', 'enum': {0:
   // 'VEHICLE_MODE_STATE_MANUAL_REMOTE_MODE', 1: 'VEHICLE_MODE_STATE_AUTO_MODE',
   // 2: 'VEHICLE_MODE_STATE_EMERGENCY_MODE', 3:
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\protocol\vcu_report_505_test.cc" new_path="modules\canbus\vehicle\devkit\protocol\vcu_report_505_test.cc" added_lines="1" deleted_lines="0">
				<diff>@@ -42,6 +42,7 @@ TEST_F(Vcureport505Test, General) {
   EXPECT_EQ(data[6], 0b00000100);
   EXPECT_EQ(data[7], 0b00000101);
 
+  EXPECT_EQ(cd.devkit().vcu_report_505().battary_soc(), 3);
   EXPECT_EQ(cd.devkit().vcu_report_505().vehicle_mode_state(), 1);
   EXPECT_EQ(cd.devkit().vcu_report_505().frontcrash_state(), 1);
   EXPECT_EQ(cd.devkit().vcu_report_505().backcrash_state(), 0);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="aab16153e9e96433c57ace7f4a4d7c82827e3857" author="lishuanghua">
		<msg>D-Kit : Add localization timer (#12796)</msg>
		<modified_files>
			<file old_path="modules\localization\msf\msf_localization.cc" new_path="modules\localization\msf\msf_localization.cc" added_lines="5" deleted_lines="1">
				<diff>@@ -185,6 +185,10 @@ void MSFLocalization::InitParams() {
       FLAGS_localization_std_x_threshold_2;
   localization_param_.localization_std_y_threshold_2 =
       FLAGS_localization_std_y_threshold_2;
+
+  localization_timer_.reset(new cyber::Timer(
+      10, [this]() { this-&gt;OnLocalizationTimer(); }, false));
+  localization_timer_-&gt;Start();
 }
 
 void MSFLocalization::OnPointCloud(
@@ -304,7 +308,7 @@ void MSFLocalization::OnGnssHeading(
   localization_integ_.GnssHeadingProcess(*gnss_heading_msg);
 }
 
-void MSFLocalization::OnGps() {
+void MSFLocalization::OnLocalizationTimer() {
   if (!raw_imu_msg_) {
     return;
   }
</diff>
			</file>
			<file old_path="modules\localization\msf\msf_localization.h" new_path="modules\localization\msf\msf_localization.h" added_lines="2" deleted_lines="1">
				<diff>@@ -75,9 +75,9 @@ class MSFLocalization {
       const std::shared_ptr&lt;drivers::gnss::GnssBestPose&gt; &amp;bestgnsspos_msg);
   void OnGnssHeading(
       const std::shared_ptr&lt;drivers::gnss::Heading&gt; &amp;gnss_heading_msg);
-  void OnGps();
 
   void SetPublisher(const std::shared_ptr&lt;LocalizationMsgPublisher&gt; &amp;publisher);
+  void OnLocalizationTimer();
 
  private:
   bool LoadGnssAntennaExtrinsic(const std::string &amp;file_path, double *offset_x,
@@ -105,6 +105,7 @@ class MSFLocalization {
   std::shared_ptr&lt;LocalizationMsgPublisher&gt; publisher_;
   std::shared_ptr&lt;drivers::gnss::Imu&gt; raw_imu_msg_;
   std::mutex mutex_imu_msg_;
+  std::unique_ptr&lt;cyber::Timer&gt; localization_timer_ = nullptr;
 };
 
 }  // namespace localization
</diff>
			</file>
			<file old_path="modules\localization\msf\msf_localization_component.cc" new_path="modules\localization\msf\msf_localization_component.cc" added_lines="0" deleted_lines="5">
				<diff>@@ -49,7 +49,6 @@ bool MSFLocalizationComponent::InitConfig() {
   lidar_topic_ = FLAGS_lidar_topic;
   bestgnsspos_topic_ = FLAGS_gnss_best_pose_topic;
   gnss_heading_topic_ = FLAGS_heading_topic;
-  gps_topic_ = FLAGS_gps_topic;
 
   if (!publisher_-&gt;InitConfig()) {
     AERROR &lt;&lt; "Init publisher config failed.";
@@ -90,10 +89,6 @@ bool MSFLocalizationComponent::InitIO() {
   gnss_heading_listener_ = this-&gt;node_-&gt;CreateReader&lt;drivers::gnss::Heading&gt;(
       gnss_heading_topic_, gnss_heading_call);
 
-  std::function&lt;void(const std::shared_ptr&lt;Gps&gt;&amp; gps_msg)&gt; gps_call =
-      std::bind(&amp;MSFLocalization::OnGps, &amp;localization_);
-  gps_listener_ = this-&gt;node_-&gt;CreateReader&lt;Gps&gt;(gps_topic_, gps_call);
-
   // init writer
   if (!publisher_-&gt;InitIO()) {
     AERROR &lt;&lt; "Init publisher io failed.";
</diff>
			</file>
			<file old_path="modules\localization\msf\msf_localization_component.h" new_path="modules\localization\msf\msf_localization_component.h" added_lines="0" deleted_lines="3">
				<diff>@@ -63,9 +63,6 @@ class MSFLocalizationComponent final
       gnss_heading_listener_ = nullptr;
   std::string gnss_heading_topic_ = "";
 
-  std::shared_ptr&lt;cyber::Reader&lt;Gps&gt;&gt; gps_listener_ = nullptr;
-  std::string gps_topic_ = "";
-
  private:
   std::shared_ptr&lt;LocalizationMsgPublisher&gt; publisher_;
   MSFLocalization localization_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e2540434c785bc3c4cc680bf3ce1cd6d4204d056" author="storypku">
		<msg>Build: use third_party/localization_msf as dependency</msg>
		<modified_files>
			<file old_path="modules\localization\msf\local_integ\gnss_msg_transfer.h" new_path="modules\localization\msf\local_integ\gnss_msg_transfer.h" added_lines="1" deleted_lines="1">
				<diff>@@ -21,7 +21,7 @@
 
 #pragma once
 
-#include "include/gnss_struct.h"
+#include "localization_msf/gnss_struct.h"
 #include "modules/drivers/gnss/proto/gnss_raw_observation.pb.h"
 
 /**
</diff>
			</file>
			<file old_path="modules\localization\msf\local_integ\localization_gnss_process.h" new_path="modules\localization\msf\local_integ\localization_gnss_process.h" added_lines="1" deleted_lines="1">
				<diff>@@ -26,7 +26,7 @@
 #include "Eigen/Core"
 #include "Eigen/Geometry"
 
-#include "include/gnss_solver.h"
+#include "localization_msf/gnss_solver.h"
 #include "modules/common/status/status.h"
 #include "modules/drivers/gnss/proto/gnss_raw_observation.pb.h"
 #include "modules/localization/msf/local_integ/localization_params.h"
</diff>
			</file>
			<file old_path="modules\localization\msf\local_integ\localization_integ.h" new_path="modules\localization\msf\local_integ\localization_integ.h" added_lines="2" deleted_lines="2">
				<diff>@@ -21,8 +21,8 @@
 
 #pragma once
 
-#include "include/gnss_struct.h"
-#include "include/sins_struct.h"
+#include "localization_msf/gnss_struct.h"
+#include "localization_msf/sins_struct.h"
 #include "modules/common/status/status.h"
 #include "modules/drivers/gnss/proto/gnss_best_pose.pb.h"
 #include "modules/drivers/gnss/proto/gnss_raw_observation.pb.h"
</diff>
			</file>
			<file old_path="modules\localization\msf\local_integ\localization_integ_process.h" new_path="modules\localization\msf\local_integ\localization_integ_process.h" added_lines="1" deleted_lines="1">
				<diff>@@ -23,7 +23,7 @@
 #include "Eigen/Geometry"
 #include "cyber/cyber.h"
 
-#include "include/sins.h"
+#include "localization_msf/sins.h"
 #include "modules/common/status/status.h"
 #include "modules/localization/msf/local_integ/localization_params.h"
 #include "modules/localization/proto/localization.pb.h"
</diff>
			</file>
			<file old_path="modules\localization\msf\local_integ\localization_lidar.h" new_path="modules\localization\msf\local_integ\localization_lidar.h" added_lines="1" deleted_lines="1">
				<diff>@@ -20,7 +20,7 @@
 #include &lt;vector&gt;
 
 #include "cyber/common/log.h"
-#include "include/lidar_locator.h"
+#include "localization_msf/lidar_locator.h"
 #include "modules/localization/msf/local_integ/localization_params.h"
 #include "modules/localization/msf/local_pyramid_map/base_map/base_map_node_index.h"
 #include "modules/localization/msf/local_pyramid_map/pyramid_map/pyramid_map.h"
</diff>
			</file>
			<file old_path="modules\localization\msf\local_integ\localization_lidar_process.h" new_path="modules\localization\msf\local_integ\localization_lidar_process.h" added_lines="2" deleted_lines="2">
				<diff>@@ -27,8 +27,8 @@
 #include "Eigen/Geometry"
 
 // TODO(Localization): Fix the typo of "forecast".
-#include "include/pose_forcast.h"
-#include "include/sins_struct.h"
+#include "localization_msf/pose_forcast.h"
+#include "localization_msf/sins_struct.h"
 #include "modules/common/status/status.h"
 #include "modules/localization/msf/local_integ/localization_lidar.h"
 #include "modules/localization/msf/local_integ/localization_params.h"
</diff>
			</file>
			<file old_path="modules\localization\msf\local_integ\measure_republish_process.h" new_path="modules\localization\msf\local_integ\measure_republish_process.h" added_lines="1" deleted_lines="1">
				<diff>@@ -27,7 +27,7 @@
 
 #include "Eigen/Core"
 #include "Eigen/Geometry"
-#include "include/sins_struct.h"
+#include "localization_msf/sins_struct.h"
 #include "modules/common/status/status.h"
 #include "modules/drivers/gnss/proto/gnss_best_pose.pb.h"
 #include "modules/drivers/gnss/proto/heading.pb.h"
</diff>
			</file>
			<file old_path="modules\localization\msf\local_integ\online_localization_expert.h" new_path="modules\localization\msf\local_integ\online_localization_expert.h" added_lines="1" deleted_lines="1">
				<diff>@@ -16,7 +16,7 @@
 
 #pragma once
 
-#include "include/sins_struct.h"
+#include "localization_msf/sins_struct.h"
 #include "modules/drivers/gnss/proto/gnss_best_pose.pb.h"
 #include "modules/localization/msf/local_integ/localization_params.h"
 #include "modules/localization/proto/localization.pb.h"
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c431f780f0e5bb23802333abce79e4b46c63b440" author="Jiahao Chen (Jerold)">
		<msg>Perception: fix perception crash (#12853)</msg>
		<modified_files>
			<file old_path="modules\perception\onboard\transform_wrapper\transform_wrapper.cc" new_path="modules\perception\onboard\transform_wrapper\transform_wrapper.cc" added_lines="30" deleted_lines="2">
				<diff>@@ -15,6 +15,8 @@
  *****************************************************************************/
 #include "modules/perception/onboard/transform_wrapper/transform_wrapper.h"
 
+#include &lt;limits&gt;
+
 #include "cyber/common/log.h"
 #include "modules/common/util/string_util.h"
 #include "modules/perception/common/sensor_manager/sensor_manager.h"
@@ -58,6 +60,32 @@ void TransformCache::AddTransform(const StampedTransform&amp; transform) {
   transforms_.push_back(transform);
 }
 
+Eigen::Quaterniond Slerp(const Eigen::Quaterniond&amp; source, const double&amp; t,
+                         const Eigen::Quaterniond&amp; other) {
+  const double one = 1.0 - std::numeric_limits&lt;double&gt;::epsilon();
+  double d = source.x() * other.x() + source.y() * other.y() +
+             source.z() * other.z() + source.w() * other.w();
+  double abs_d = std::abs(d);
+
+  double scale0;
+  double scale1;
+
+  if (abs_d &gt;= one) {
+    scale0 = 1.0 - t;
+    scale1 = t;
+  } else {
+    // theta is the angle between the 2 quaternions
+    double theta = std::acos(abs_d);
+    double sin_theta = std::sin(theta);
+
+    scale0 = std::sin((1.0 - t) * theta) / sin_theta;
+    scale1 = std::sin((t * theta)) / sin_theta;
+  }
+  if (d &lt; 0) scale1 = -scale1;
+
+  return Eigen::Quaterniond(scale0 * source.coeffs() + scale1 * other.coeffs());
+}
+
 bool TransformCache::QueryTransform(double timestamp,
                                     StampedTransform* transform,
                                     double max_duration) {
@@ -86,8 +114,8 @@ bool TransformCache::QueryTransform(double timestamp,
         (timestamp - transforms_[size - 2].timestamp) /
         (transforms_[size - 1].timestamp - transforms_[size - 2].timestamp);
 
-    transform-&gt;rotation = transforms_[size - 2].rotation.slerp(
-        ratio, transforms_[size - 1].rotation);
+    transform-&gt;rotation = Slerp(transforms_[size - 2].rotation, ratio,
+                                transforms_[size - 1].rotation);
 
     transform-&gt;translation.x() =
         transforms_[size - 2].translation.x() * (1 - ratio) +
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="2983aa98bbf1bff69def9e6dba4854fc0ab7725c" author="storypku">
		<msg>Typo: fix issue #12857</msg>
		<modified_files>
			<file old_path="modules\canbus\vehicle\ge3\ge3_controller.cc" new_path="modules\canbus\vehicle\ge3\ge3_controller.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -476,7 +476,7 @@ ErrorCode Ge3Controller::EnableSpeedOnlyMode() {
 
   can_sender_-&gt;Update();
   if (!CheckResponse(CHECK_RESPONSE_SPEED_UNIT_FLAG, true)) {
-    AERROR &lt;&lt; "Failed to switch to AUTO_STEER_ONLY mode.";
+    AERROR &lt;&lt; "Failed to switch to AUTO_SPEED_ONLY mode.";
     Emergency();
     set_chassis_error_code(Chassis::CHASSIS_ERROR);
     return ErrorCode::CANBUS_ERROR;
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\lexus\lexus_controller.cc" new_path="modules\canbus\vehicle\lexus\lexus_controller.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -387,7 +387,7 @@ ErrorCode LexusController::EnableSpeedOnlyMode() {
 
   can_sender_-&gt;Update();
   if (!CheckResponse(CHECK_RESPONSE_SPEED_UNIT_FLAG, true)) {
-    AERROR &lt;&lt; "Failed to switch to AUTO_STEER_ONLY mode.";
+    AERROR &lt;&lt; "Failed to switch to AUTO_SPEED_ONLY mode.";
     Emergency();
     set_chassis_error_code(Chassis::CHASSIS_ERROR);
     return ErrorCode::CANBUS_ERROR;
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\lincoln\lincoln_controller.cc" new_path="modules\canbus\vehicle\lincoln\lincoln_controller.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -457,7 +457,7 @@ ErrorCode LincolnController::EnableSpeedOnlyMode() {
 
   can_sender_-&gt;Update();
   if (!CheckResponse(CHECK_RESPONSE_SPEED_UNIT_FLAG, true)) {
-    AERROR &lt;&lt; "Failed to switch to AUTO_STEER_ONLY mode.";
+    AERROR &lt;&lt; "Failed to switch to AUTO_SPEED_ONLY mode.";
     CheckChassisError();
     Emergency();
     return ErrorCode::CANBUS_ERROR;
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\wey\wey_controller.cc" new_path="modules\canbus\vehicle\wey\wey_controller.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -498,7 +498,7 @@ ErrorCode WeyController::EnableSpeedOnlyMode() {
 
   can_sender_-&gt;Update();
   if (!CheckResponse(CHECK_RESPONSE_SPEED_UNIT_FLAG, true)) {
-    AERROR &lt;&lt; "Failed to switch to AUTO_STEER_ONLY mode.";
+    AERROR &lt;&lt; "Failed to switch to AUTO_SPEED_ONLY mode.";
     Emergency();
     set_chassis_error_code(Chassis::CHASSIS_ERROR);
     return ErrorCode::CANBUS_ERROR;
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\zhongyun\zhongyun_controller.cc" new_path="modules\canbus\vehicle\zhongyun\zhongyun_controller.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -354,7 +354,7 @@ ErrorCode ZhongyunController::EnableSpeedOnlyMode() {
 
   can_sender_-&gt;Update();
   if (CheckResponse(CHECK_RESPONSE_SPEED_UNIT_FLAG, true) == false) {
-    AERROR &lt;&lt; "Failed to switch to AUTO_STEER_ONLY mode.";
+    AERROR &lt;&lt; "Failed to switch to AUTO_SPEED_ONLY mode.";
     Emergency();
     set_chassis_error_code(Chassis::CHASSIS_ERROR);
     return ErrorCode::CANBUS_ERROR;
</diff>
			</file>
			<file old_path="modules\tools\gen_vehicle_protocol\template\controller.cc.tpl" new_path="modules\tools\gen_vehicle_protocol\template\controller.cc.tpl" added_lines="1" deleted_lines="1">
				<diff>@@ -203,7 +203,7 @@ ErrorCode %(car_type_cap)sController::EnableSpeedOnlyMode() {
 
   can_sender_-&gt;Update();
   if (!CheckResponse(CHECK_RESPONSE_SPEED_UNIT_FLAG, true)) {
-    AERROR &lt;&lt; "Failed to switch to AUTO_STEER_ONLY mode.";
+    AERROR &lt;&lt; "Failed to switch to AUTO_SPEED_ONLY mode.";
     Emergency();
     set_chassis_error_code(Chassis::CHASSIS_ERROR);
     return ErrorCode::CANBUS_ERROR;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="0b2b252780122fa55f9b406dc27d69079abe6cae" author="liufeng">
		<msg>Revert "cyber_recorder file writer threading bug fix (#12377)"

This reverts commit c9e58846902d3fbdefee1e1326abe4e45dcf479f.</msg>
		<modified_files>
			<file old_path="cyber\record\file\record_file_base.h" new_path="cyber\record\file\record_file_base.h" added_lines="1" deleted_lines="1">
				<diff>@@ -45,7 +45,7 @@ class RecordFileBase {
   std::string path_;
   proto::Header header_;
   proto::Index index_;
-  int fd_ = -1;
+  int fd_;
 };
 
 }  // namespace record
</diff>
			</file>
			<file old_path="cyber\record\file\record_file_test.cc" new_path="cyber\record\file\record_file_test.cc" added_lines="20" deleted_lines="21">
				<diff>@@ -222,56 +222,56 @@ TEST(RecordFileTest, TestOneChunkFile) {
 
 TEST(RecordFileTest, TestIndex) {
   {
-    RecordFileWriter rfw;
+    RecordFileWriter* rfw = new RecordFileWriter();
 
-    ASSERT_TRUE(rfw.Open(kTestFile2));
-    ASSERT_EQ(kTestFile2, rfw.GetPath());
+    ASSERT_TRUE(rfw-&gt;Open(kTestFile2));
+    ASSERT_EQ(kTestFile2, rfw-&gt;GetPath());
 
     Header header = HeaderBuilder::GetHeaderWithChunkParams(0, 0);
     header.set_segment_interval(0);
     header.set_segment_raw_size(0);
-    ASSERT_TRUE(rfw.WriteHeader(header));
-    ASSERT_FALSE(rfw.GetHeader().is_complete());
+    ASSERT_TRUE(rfw-&gt;WriteHeader(header));
+    ASSERT_FALSE(rfw-&gt;GetHeader().is_complete());
 
     Channel chan1;
     chan1.set_name(kChan1);
     chan1.set_message_type(kMsgType);
     chan1.set_proto_desc(kStr10B);
-    ASSERT_TRUE(rfw.WriteChannel(chan1));
+    ASSERT_TRUE(rfw-&gt;WriteChannel(chan1));
 
     Channel chan2;
     chan2.set_name(kChan2);
     chan2.set_message_type(kMsgType);
     chan2.set_proto_desc(kStr10B);
-    ASSERT_TRUE(rfw.WriteChannel(chan2));
+    ASSERT_TRUE(rfw-&gt;WriteChannel(chan2));
 
     SingleMessage msg1;
     msg1.set_channel_name(chan1.name());
     msg1.set_content(kStr10B);
     msg1.set_time(1e9);
-    ASSERT_TRUE(rfw.WriteMessage(msg1));
-    ASSERT_EQ(1, rfw.GetMessageNumber(chan1.name()));
+    ASSERT_TRUE(rfw-&gt;WriteMessage(msg1));
+    ASSERT_EQ(1, rfw-&gt;GetMessageNumber(chan1.name()));
 
     SingleMessage msg2;
     msg2.set_channel_name(chan2.name());
     msg2.set_content(kStr10B);
     msg2.set_time(2e9);
-    ASSERT_TRUE(rfw.WriteMessage(msg2));
-    ASSERT_EQ(1, rfw.GetMessageNumber(chan2.name()));
+    ASSERT_TRUE(rfw-&gt;WriteMessage(msg2));
+    ASSERT_EQ(1, rfw-&gt;GetMessageNumber(chan2.name()));
 
     SingleMessage msg3;
     msg3.set_channel_name(chan1.name());
     msg3.set_content(kStr10B);
     msg3.set_time(3e9);
-    ASSERT_TRUE(rfw.WriteMessage(msg3));
-    ASSERT_EQ(2, rfw.GetMessageNumber(chan1.name()));
-
-    rfw.Close();
-    ASSERT_TRUE(rfw.GetHeader().is_complete());
-    ASSERT_EQ(1, rfw.GetHeader().chunk_number());
-    ASSERT_EQ(1e9, rfw.GetHeader().begin_time());
-    ASSERT_EQ(3e9, rfw.GetHeader().end_time());
-    ASSERT_EQ(3, rfw.GetHeader().message_number());
+    ASSERT_TRUE(rfw-&gt;WriteMessage(msg3));
+    ASSERT_EQ(2, rfw-&gt;GetMessageNumber(chan1.name()));
+
+    rfw-&gt;Close();
+    ASSERT_TRUE(rfw-&gt;GetHeader().is_complete());
+    ASSERT_EQ(1, rfw-&gt;GetHeader().chunk_number());
+    ASSERT_EQ(1e9, rfw-&gt;GetHeader().begin_time());
+    ASSERT_EQ(3e9, rfw-&gt;GetHeader().end_time());
+    ASSERT_EQ(3, rfw-&gt;GetHeader().message_number());
   }
   {
     RecordFileReader reader;
@@ -304,7 +304,6 @@ TEST(RecordFileTest, TestIndex) {
       }
     }
   }
-  ASSERT_FALSE(remove(kTestFile2));
 }
 
 }  // namespace record
</diff>
			</file>
			<file old_path="cyber\record\file\record_file_writer.cc" new_path="cyber\record\file\record_file_writer.cc" added_lines="65" deleted_lines="34">
				<diff>@@ -35,6 +35,8 @@ using apollo::cyber::proto::Header;
 using apollo::cyber::proto::SectionType;
 using apollo::cyber::proto::SingleIndex;
 
+RecordFileWriter::RecordFileWriter() {}
+
 RecordFileWriter::~RecordFileWriter() { Close(); }
 
 bool RecordFileWriter::Open(const std::string&amp; path) {
@@ -50,31 +52,57 @@ bool RecordFileWriter::Open(const std::string&amp; path) {
            &lt;&lt; ", errno: " &lt;&lt; errno;
     return false;
   }
-  chunk_active_ = std::make_unique&lt;Chunk&gt;();
+  chunk_active_.reset(new Chunk());
+  chunk_flush_.reset(new Chunk());
+  is_writing_ = true;
+  flush_thread_ = std::make_shared&lt;std::thread&gt;([this]() { this-&gt;Flush(); });
+  if (flush_thread_ == nullptr) {
+    AERROR &lt;&lt; "Init flush thread error.";
+    return false;
+  }
   return true;
 }
 
 void RecordFileWriter::Close() {
-  if (fd_ &lt; 0) {
-    return;
-  }
-  flush_task_.wait();
-  Flush(*chunk_active_);
+  if (is_writing_) {
+    // wait for the flush operation that may exist now
+    while (!chunk_flush_-&gt;empty()) {
+      std::this_thread::sleep_for(std::chrono::milliseconds(100));
+    }
 
-  if (!WriteIndex()) {
-    AERROR &lt;&lt; "Write index section failed, file: " &lt;&lt; path_;
-  }
+    // last swap
+    {
+      std::unique_lock&lt;std::mutex&gt; flush_lock(flush_mutex_);
+      chunk_flush_.swap(chunk_active_);
+      flush_cv_.notify_one();
+    }
 
-  header_.set_is_complete(true);
-  if (!WriteHeader(header_)) {
-    AERROR &lt;&lt; "Overwrite header section failed, file: " &lt;&lt; path_;
-  }
+    // wait for the last flush operation
+    while (!chunk_flush_-&gt;empty()) {
+      std::this_thread::sleep_for(std::chrono::milliseconds(100));
+    }
 
-  if (close(fd_) &lt; 0) {
-    AERROR &lt;&lt; "Close file failed, file: " &lt;&lt; path_ &lt;&lt; ", fd: " &lt;&lt; fd_
-           &lt;&lt; ", errno: " &lt;&lt; errno;
+    is_writing_ = false;
+    flush_cv_.notify_all();
+    if (flush_thread_ &amp;&amp; flush_thread_-&gt;joinable()) {
+      flush_thread_-&gt;join();
+      flush_thread_ = nullptr;
+    }
+
+    if (!WriteIndex()) {
+      AERROR &lt;&lt; "Write index section failed, file: " &lt;&lt; path_;
+    }
+
+    header_.set_is_complete(true);
+    if (!WriteHeader(header_)) {
+      AERROR &lt;&lt; "Overwrite header section failed, file: " &lt;&lt; path_;
+    }
+
+    if (close(fd_) &lt; 0) {
+      AERROR &lt;&lt; "Close file failed, file: " &lt;&lt; path_ &lt;&lt; ", fd: " &lt;&lt; fd_
+             &lt;&lt; ", errno: " &lt;&lt; errno;
+    }
   }
-  fd_ = -1;
 }
 
 bool RecordFileWriter::WriteHeader(const Header&amp; header) {
@@ -168,7 +196,6 @@ bool RecordFileWriter::WriteChunk(const ChunkHeader&amp; chunk_header,
 }
 
 bool RecordFileWriter::WriteMessage(const proto::SingleMessage&amp; message) {
-  CHECK_GE(fd_, 0) &lt;&lt; "First, call Open";
   chunk_active_-&gt;add(message);
   auto it = channel_message_number_map_.find(message.channel_name());
   if (it != channel_message_number_map_.end()) {
@@ -190,28 +217,32 @@ bool RecordFileWriter::WriteMessage(const proto::SingleMessage&amp; message) {
   if (!need_flush) {
     return true;
   }
-
-  ACHECK(flush_task_.wait_for(std::chrono::milliseconds(0)) ==
-         std::future_status::ready)
-      &lt;&lt; "Flushing didn't finish. Either the hardware cannot keep up or the "
-         "flush rate is too fast.";
-
-  flush_task_ = std::async(
-      std::launch::async,
-      [this, chunk = std::move(chunk_active_)]() { this-&gt;Flush(*chunk); });
-  chunk_active_ = std::make_unique&lt;Chunk&gt;();
-
+  {
+    std::unique_lock&lt;std::mutex&gt; flush_lock(flush_mutex_);
+    chunk_flush_.swap(chunk_active_);
+    flush_cv_.notify_one();
+  }
   return true;
 }
 
-void RecordFileWriter::Flush(const Chunk&amp; chunk) {
-  if (!WriteChunk(chunk.header_, *(chunk.body_.get()))) {
-    AERROR &lt;&lt; "Write chunk fail.";
+void RecordFileWriter::Flush() {
+  while (is_writing_) {
+    std::unique_lock&lt;std::mutex&gt; flush_lock(flush_mutex_);
+    flush_cv_.wait(flush_lock,
+                   [this] { return !chunk_flush_-&gt;empty() || !is_writing_; });
+    if (!is_writing_) {
+      break;
+    }
+    if (chunk_flush_-&gt;empty()) {
+      continue;
+    }
+    if (!WriteChunk(chunk_flush_-&gt;header_, *(chunk_flush_-&gt;body_.get()))) {
+      AERROR &lt;&lt; "Write chunk fail.";
+    }
+    chunk_flush_-&gt;clear();
   }
 }
 
-void RecordFileWriter::WaitForWrite() { flush_task_.wait(); }
-
 uint64_t RecordFileWriter::GetMessageNumber(
     const std::string&amp; channel_name) const {
   auto search = channel_message_number_map_.find(channel_name);
</diff>
			</file>
			<file old_path="cyber\record\file\record_file_writer.h" new_path="cyber\record\file\record_file_writer.h" added_lines="11" deleted_lines="18">
				<diff>@@ -19,9 +19,9 @@
 
 #include &lt;condition_variable&gt;
 #include &lt;fstream&gt;
-#include &lt;future&gt;
 #include &lt;memory&gt;
 #include &lt;string&gt;
+#include &lt;thread&gt;
 #include &lt;type_traits&gt;
 #include &lt;unordered_map&gt;
 #include &lt;utility&gt;
@@ -74,13 +74,10 @@ struct Chunk {
   std::unique_ptr&lt;proto::ChunkBody&gt; body_ = nullptr;
 };
 
-/**
-Writes cyber record files on an asynchronous task
-*/
 class RecordFileWriter : public RecordFileBase {
  public:
-  RecordFileWriter() = default;
-  ~RecordFileWriter();
+  RecordFileWriter();
+  virtual ~RecordFileWriter();
   bool Open(const std::string&amp; path) override;
   void Close() override;
   bool WriteHeader(const proto::Header&amp; header);
@@ -88,22 +85,19 @@ class RecordFileWriter : public RecordFileBase {
   bool WriteMessage(const proto::SingleMessage&amp; message);
   uint64_t GetMessageNumber(const std::string&amp; channel_name) const;
 
-  // For testing
-  void WaitForWrite();
-
  private:
   bool WriteChunk(const proto::ChunkHeader&amp; chunk_header,
                   const proto::ChunkBody&amp; chunk_body);
   template &lt;typename T&gt;
   bool WriteSection(const T&amp; message);
   bool WriteIndex();
-  void Flush(const Chunk&amp; chunk);
-  bool IsChunkFlushEmpty();
-  void BlockUntilSpaceAvailable();
-  // make moveable
-  std::unique_ptr&lt;Chunk&gt; chunk_active_;
-  // Initialize with a dummy value to simplify checking later
-  std::future&lt;void&gt; flush_task_ = std::async(std::launch::async, []() {});
+  void Flush();
+  bool is_writing_ = false;
+  std::unique_ptr&lt;Chunk&gt; chunk_active_ = nullptr;
+  std::unique_ptr&lt;Chunk&gt; chunk_flush_ = nullptr;
+  std::shared_ptr&lt;std::thread&gt; flush_thread_ = nullptr;
+  std::mutex flush_mutex_;
+  std::condition_variable flush_cv_;
   std::unordered_map&lt;std::string, uint64_t&gt; channel_message_number_map_;
 };
 
@@ -131,8 +125,7 @@ bool RecordFileWriter::WriteSection(const T&amp; message) {
   Section section;
   /// zero out whole struct even if padded
   memset(&amp;section, 0, sizeof(section));
-  section.type = type;
-  section.size = static_cast&lt;int64_t&gt;(message.ByteSizeLong());
+  section = {type, static_cast&lt;int64_t&gt;(message.ByteSizeLong())};
   ssize_t count = write(fd_, &amp;section, sizeof(section));
   if (count &lt; 0) {
     AERROR &lt;&lt; "Write fd failed, fd: " &lt;&lt; fd_ &lt;&lt; ", errno: " &lt;&lt; errno;
</diff>
			</file>
			<file old_path="cyber\record\record_viewer_test.cc" new_path="cyber\record\record_viewer_test.cc" added_lines="23" deleted_lines="27">
				<diff>@@ -25,7 +25,6 @@
 
 #include "gtest/gtest.h"
 
-#include "cyber/common/file.h"
 #include "cyber/common/log.h"
 #include "cyber/record/record_reader.h"
 #include "cyber/record/record_writer.h"
@@ -54,9 +53,6 @@ static void ConstructRecord(uint64_t msg_num, uint64_t begin_time,
       ai = msg_num - 1 - i;
     }
     auto msg = std::make_shared&lt;RawMessage&gt;(std::to_string(ai));
-    // Since writer is meant for real time operations at a set rate,
-    // we need to wait in the test. Otherwise, we should write synchronously
-    writer.WaitForWrite();
     writer.WriteMessage(kChannelName1, msg, begin_time + time_step * ai);
   }
   ASSERT_EQ(msg_num, writer.GetMessageNumber(kChannelName1));
@@ -88,28 +84,28 @@ TEST(RecordTest, iterator_test) {
 
   uint64_t i = 0;
   for (auto&amp; msg : viewer) {
-    ASSERT_EQ(kChannelName1, msg.channel_name);
-    ASSERT_EQ(begin_time + step_time * i, msg.time);
-    ASSERT_EQ(std::to_string(i), msg.content);
-    ++i;
+    EXPECT_EQ(kChannelName1, msg.channel_name);
+    EXPECT_EQ(begin_time + step_time * i, msg.time);
+    EXPECT_EQ(std::to_string(i), msg.content);
+    i++;
   }
   EXPECT_EQ(msg_num, i);
 
   i = 0;
   std::for_each(viewer.begin(), viewer.end(), [&amp;i](RecordMessage&amp; msg) {
-    ASSERT_EQ(kChannelName1, msg.channel_name);
+    EXPECT_EQ(kChannelName1, msg.channel_name);
     // EXPECT_EQ(begin_time + step_time * i, msg.time);
-    ASSERT_EQ(std::to_string(i), msg.content);
-    ++i;
+    EXPECT_EQ(std::to_string(i), msg.content);
+    i++;
   });
   EXPECT_EQ(msg_num, i);
 
   i = 0;
   for (auto it = viewer.begin(); it != viewer.end(); ++it) {
-    ASSERT_EQ(kChannelName1, it-&gt;channel_name);
-    ASSERT_EQ(begin_time + step_time * i, it-&gt;time);
-    ASSERT_EQ(std::to_string(i), it-&gt;content);
-    ++i;
+    EXPECT_EQ(kChannelName1, it-&gt;channel_name);
+    EXPECT_EQ(begin_time + step_time * i, it-&gt;time);
+    EXPECT_EQ(std::to_string(i), it-&gt;content);
+    i++;
   }
   EXPECT_EQ(msg_num, i);
   ASSERT_FALSE(remove(kTestFile));
@@ -133,19 +129,19 @@ TEST(RecordTest, iterator_test_reverse) {
 
   uint64_t i = 0;
   for (auto&amp; msg : viewer) {
-    ASSERT_EQ(kChannelName1, msg.channel_name);
-    ASSERT_EQ(begin_time + step_time * i, msg.time);
-    ASSERT_EQ(std::to_string(i), msg.content);
-    ++i;
+    EXPECT_EQ(kChannelName1, msg.channel_name);
+    EXPECT_EQ(begin_time + step_time * i, msg.time);
+    EXPECT_EQ(std::to_string(i), msg.content);
+    i++;
   }
   EXPECT_EQ(msg_num, i);
 
   i = 0;
   for (auto it = viewer.begin(); it != viewer.end(); ++it) {
-    ASSERT_EQ(kChannelName1, it-&gt;channel_name);
-    ASSERT_EQ(begin_time + step_time * i, it-&gt;time);
-    ASSERT_EQ(std::to_string(i), it-&gt;content);
-    ++i;
+    EXPECT_EQ(kChannelName1, it-&gt;channel_name);
+    EXPECT_EQ(begin_time + step_time * i, it-&gt;time);
+    EXPECT_EQ(std::to_string(i), it-&gt;content);
+    i++;
   }
   EXPECT_EQ(msg_num, i);
   ASSERT_FALSE(remove(kTestFile));
@@ -219,10 +215,10 @@ TEST(RecordTest, mult_iterator_test) {
 
   uint64_t i = 0;
   for (auto&amp; msg : viewer) {  // #2 iterator
-    ASSERT_EQ(kChannelName1, msg.channel_name);
-    ASSERT_EQ(begin_time + step_time * i, msg.time);
-    ASSERT_EQ(std::to_string(i), msg.content);
-    ++i;
+    EXPECT_EQ(kChannelName1, msg.channel_name);
+    EXPECT_EQ(begin_time + step_time * i, msg.time);
+    EXPECT_EQ(std::to_string(i), msg.content);
+    i++;
   }
   EXPECT_EQ(msg_num, i);
   ASSERT_FALSE(remove(kTestFile));
</diff>
			</file>
			<file old_path="cyber\record\record_writer.cc" new_path="cyber\record\record_writer.cc" added_lines="0" deleted_lines="2">
				<diff>@@ -180,8 +180,6 @@ bool RecordWriter::IsNewChannel(const std::string&amp; channel_name) const {
          channel_message_number_map_.end();
 }
 
-void RecordWriter::WaitForWrite() { file_writer_-&gt;WaitForWrite(); }
-
 void RecordWriter::OnNewChannel(const std::string&amp; channel_name,
                                 const std::string&amp; message_type,
                                 const std::string&amp; proto_desc) {
</diff>
			</file>
			<file old_path="cyber\record\record_writer.h" new_path="cyber\record\record_writer.h" added_lines="0" deleted_lines="5">
				<diff>@@ -170,11 +170,6 @@ class RecordWriter : public RecordBase {
    */
   bool IsNewChannel(const std::string&amp; channel_name) const;
 
-  /**
-   * @brief Meant for testing
-   */
-  void WaitForWrite();
-
  private:
   bool WriteMessage(const proto::SingleMessage&amp; single_msg);
   bool SplitOutfile();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="87127ff3ced43baa6fd7a35fb414cc20b863ed41" author="liufeng">
		<msg>Revert "cyber_recorder close file asynchronously"

This reverts commit a98591bd2f73a4398e13ffc62b4ece33561ec472.</msg>
		<modified_files>
			<file old_path="cyber\record\record_writer.cc" new_path="cyber\record\record_writer.cc" added_lines="2" deleted_lines="8">
				<diff>@@ -16,11 +16,8 @@
 
 #include "cyber/record/record_writer.h"
 
-#include &lt;chrono&gt;
-#include &lt;future&gt;
 #include &lt;iomanip&gt;
 #include &lt;iostream&gt;
-#include &lt;utility&gt;
 
 #include "cyber/common/log.h"
 
@@ -144,11 +141,8 @@ bool RecordWriter::WriteMessage(const SingleMessage&amp; message) {
        message.time() - segment_begin_time_ &gt; header_.segment_interval()) ||
       (header_.segment_raw_size() &gt; 0 &amp;&amp;
        segment_raw_size_ &gt; header_.segment_raw_size())) {
-    ACHECK(old_file_writer_closer_.wait_for(std::chrono::milliseconds(0)) ==
-           std::future_status::ready);
-    // Close the file via the destructor asynchronously
-    old_file_writer_closer_ = std::async(
-        std::launch::async, [](FileWriterPtr p) {}, std::move(file_writer_));
+    file_writer_backup_.swap(file_writer_);
+    file_writer_backup_-&gt;Close();
     if (!SplitOutfile()) {
       AERROR &lt;&lt; "Split out file is failed.";
       return false;
</diff>
			</file>
			<file old_path="cyber\record\record_writer.h" new_path="cyber\record\record_writer.h" added_lines="1" deleted_lines="4">
				<diff>@@ -18,7 +18,6 @@
 #define CYBER_RECORD_RECORD_WRITER_H_
 
 #include &lt;cstdint&gt;
-#include &lt;future&gt;
 #include &lt;memory&gt;
 #include &lt;mutex&gt;
 #include &lt;set&gt;
@@ -186,9 +185,7 @@ class RecordWriter : public RecordBase {
   MessageTypeMap channel_message_type_map_;
   MessageProtoDescMap channel_proto_desc_map_;
   FileWriterPtr file_writer_ = nullptr;
-  // Initialize with a dummy value to simplify checking later
-  std::future&lt;void&gt; old_file_writer_closer_ =
-      std::async(std::launch::async, []() {});
+  FileWriterPtr file_writer_backup_ = nullptr;
   std::mutex mutex_;
   std::stringstream sstream_;
 };
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3bf0934cf6e8a2c64039e506bec989edf5de56ed" author="liufeng">
		<msg>Cyber: cyber_recorder file writer threading bug fix

Cyber: cyber_recorder file writer threading bug fix</msg>
		<modified_files>
			<file old_path="cyber\record\file\record_file_base.h" new_path="cyber\record\file\record_file_base.h" added_lines="1" deleted_lines="1">
				<diff>@@ -45,7 +45,7 @@ class RecordFileBase {
   std::string path_;
   proto::Header header_;
   proto::Index index_;
-  int fd_;
+  int fd_ = -1;
 };
 
 }  // namespace record
</diff>
			</file>
			<file old_path="cyber\record\file\record_file_writer.cc" new_path="cyber\record\file\record_file_writer.cc" added_lines="15" deleted_lines="3">
				<diff>@@ -35,7 +35,7 @@ using apollo::cyber::proto::Header;
 using apollo::cyber::proto::SectionType;
 using apollo::cyber::proto::SingleIndex;
 
-RecordFileWriter::RecordFileWriter() {}
+RecordFileWriter::RecordFileWriter() : is_writing_(false) {}
 
 RecordFileWriter::~RecordFileWriter() { Close(); }
 
@@ -66,7 +66,13 @@ bool RecordFileWriter::Open(const std::string&amp; path) {
 void RecordFileWriter::Close() {
   if (is_writing_) {
     // wait for the flush operation that may exist now
-    while (!chunk_flush_-&gt;empty()) {
+    while (1) {
+      {
+        std::unique_lock&lt;std::mutex&gt; flush_lock(flush_mutex_);
+        if (chunk_flush_-&gt;empty()) {
+          break;
+        }
+      }
       std::this_thread::sleep_for(std::chrono::milliseconds(100));
     }
 
@@ -78,7 +84,13 @@ void RecordFileWriter::Close() {
     }
 
     // wait for the last flush operation
-    while (!chunk_flush_-&gt;empty()) {
+    while (1) {
+      {
+        std::unique_lock&lt;std::mutex&gt; flush_lock(flush_mutex_);
+        if (chunk_flush_-&gt;empty()) {
+          break;
+        }
+      }
       std::this_thread::sleep_for(std::chrono::milliseconds(100));
     }
 
</diff>
			</file>
			<file old_path="cyber\record\file\record_file_writer.h" new_path="cyber\record\file\record_file_writer.h" added_lines="1" deleted_lines="1">
				<diff>@@ -92,7 +92,7 @@ class RecordFileWriter : public RecordFileBase {
   bool WriteSection(const T&amp; message);
   bool WriteIndex();
   void Flush();
-  bool is_writing_ = false;
+  std::atomic_bool is_writing_;
   std::unique_ptr&lt;Chunk&gt; chunk_active_ = nullptr;
   std::unique_ptr&lt;Chunk&gt; chunk_flush_ = nullptr;
   std::shared_ptr&lt;std::thread&gt; flush_thread_ = nullptr;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="fa7e766e31ed49543feac4d555bc448971331449" author="changsh726">
		<msg>Canbus: added error handler</msg>
		<modified_files>
			<file old_path="modules\canbus\vehicle\vehicle_controller.cc" new_path="modules\canbus\vehicle\vehicle_controller.cc" added_lines="5" deleted_lines="1">
				<diff>@@ -117,7 +117,11 @@ ErrorCode VehicleController::Update(const ControlCommand &amp;control_command) {
         break;
       }
     }
-    SetDrivingMode(mode);
+    auto error_code = SetDrivingMode(mode);
+    if (error_code != ErrorCode::OK) {
+      AERROR &lt;&lt; "Failed to set driving mode.";
+      return error_code;
+    }
   }
 
   if (driving_mode() == Chassis::COMPLETE_AUTO_DRIVE ||
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="2602397cece26fb56a5e6d4cedbb3b12b94324e3" author="Chao Ma">
		<msg>canbus: add the new battery soc protocol in chassis for vehicle dev_kit (#12866)</msg>
		<modified_files>
			<file old_path="modules\canbus\vehicle\devkit\devkit_controller.cc" new_path="modules\canbus\vehicle\devkit\devkit_controller.cc" added_lines="4" deleted_lines="26">
				<diff>@@ -184,8 +184,11 @@ Chassis DevkitController::chassis() {
       chassis_detail.devkit().vcu_report_505().has_speed()) {
     chassis_.set_speed_mps(
         static_cast&lt;float&gt;(chassis_detail.devkit().vcu_report_505().speed()));
+    chassis_.set_battery_soc(
+        chassis_detail.devkit().vcu_report_505().battery_soc());
   } else {
     chassis_.set_speed_mps(0);
+    chassis_.set_battery_soc(0);
   }
   // 7 no odometer
   // chassis_.set_odometer_m(0);
@@ -480,10 +483,6 @@ bool DevkitController::CheckChassisError() {
         devkit.steering_report_502().steer_flt1()) {
       return true;
     }
-    if (Steering_report_502::STEER_FLT2_STEER_SYSTEM_COMUNICATION_FAULT ==
-        devkit.steering_report_502().steer_flt2()) {
-      return true;
-    }
   }
   // drive fault
   if (devkit.has_throttle_report_500()) {
@@ -491,10 +490,6 @@ bool DevkitController::CheckChassisError() {
         devkit.throttle_report_500().throttle_flt1()) {
       return true;
     }
-    if (Throttle_report_500::THROTTLE_FLT2_DRIVE_SYSTEM_COMUNICATION_FAULT ==
-        devkit.throttle_report_500().throttle_flt2()) {
-      return true;
-    }
   }
   // brake fault
   if (devkit.has_brake_report_501()) {
@@ -502,25 +497,8 @@ bool DevkitController::CheckChassisError() {
         devkit.brake_report_501().brake_flt1()) {
       return true;
     }
-    if (Brake_report_501::BRAKE_FLT2_BRAKE_SYSTEM_COMUNICATION_FAULT ==
-        devkit.brake_report_501().brake_flt2()) {
-      return true;
-    }
-  }
-  // gear fault
-  if (devkit.has_gear_report_503()) {
-    if (Gear_report_503::GEAR_FLT_FAULT ==
-        devkit.gear_report_503().gear_flt()) {
-      return true;
-    }
-  }
-  // park fault
-  if (devkit.has_park_report_504()) {
-    if (Park_report_504::PARK_FLT_FAULT ==
-        devkit.park_report_504().park_flt()) {
-      return true;
-    }
   }
+
   return false;
 }
 
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\protocol\vcu_report_505.cc" new_path="modules\canbus\vehicle\devkit\protocol\vcu_report_505.cc" added_lines="4" deleted_lines="4">
				<diff>@@ -31,8 +31,8 @@ const int32_t Vcureport505::ID = 0x505;
 
 void Vcureport505::Parse(const std::uint8_t* bytes, int32_t length,
                          ChassisDetail* chassis) const {
-  chassis-&gt;mutable_devkit()-&gt;mutable_vcu_report_505()-&gt;set_battary_soc(
-      battary_soc(bytes, length));
+  chassis-&gt;mutable_devkit()-&gt;mutable_vcu_report_505()-&gt;set_battery_soc(
+      battery_soc(bytes, length));
   chassis-&gt;mutable_devkit()-&gt;mutable_vcu_report_505()-&gt;set_vehicle_mode_state(
       vehicle_mode_state(bytes, length));
   chassis-&gt;mutable_devkit()-&gt;mutable_vcu_report_505()-&gt;set_frontcrash_state(
@@ -47,10 +47,10 @@ void Vcureport505::Parse(const std::uint8_t* bytes, int32_t length,
       speed(bytes, length));
 }
 
-// config detail: {'name': 'battary_soc', 'offset': 0.0, 'precision': 1.0,
+// config detail: {'name': 'battery_soc', 'offset': 0.0, 'precision': 1.0,
 // 'len': 8, 'is_signed_var': False, 'physical_range': '[0|100]', 'bit': 47,
 // 'type': 'int', 'order': 'motorola', 'physical_unit': '%'}
-int Vcureport505::battary_soc(const std::uint8_t* bytes, int32_t length) const {
+int Vcureport505::battery_soc(const std::uint8_t* bytes, int32_t length) const {
   Byte t0(bytes + 5);
   int32_t x = t0.get_byte(0, 8);
 
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\protocol\vcu_report_505.h" new_path="modules\canbus\vehicle\devkit\protocol\vcu_report_505.h" added_lines="2" deleted_lines="2">
				<diff>@@ -32,10 +32,10 @@ class Vcureport505 : public ::apollo::drivers::canbus::ProtocolData&lt;
              ChassisDetail* chassis) const override;
 
  private:
-  // config detail: {'name': 'Battary_Soc', 'offset': 0.0, 'precision': 1.0,
+  // config detail: {'name': 'Battery_Soc', 'offset': 0.0, 'precision': 1.0,
   // 'len': 8, 'is_signed_var': False, 'physical_range': '[0|100]', 'bit': 47,
   // 'type': 'int', 'order': 'motorola', 'physical_unit': '%'}
-  int battary_soc(const std::uint8_t* bytes, const int32_t length) const;
+  int battery_soc(const std::uint8_t* bytes, const int32_t length) const;
 
   // config detail: {'name': 'Vehicle_Mode_State', 'enum': {0:
   // 'VEHICLE_MODE_STATE_MANUAL_REMOTE_MODE', 1: 'VEHICLE_MODE_STATE_AUTO_MODE',
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\protocol\vcu_report_505_test.cc" new_path="modules\canbus\vehicle\devkit\protocol\vcu_report_505_test.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -42,7 +42,7 @@ TEST_F(Vcureport505Test, General) {
   EXPECT_EQ(data[6], 0b00000100);
   EXPECT_EQ(data[7], 0b00000101);
 
-  EXPECT_EQ(cd.devkit().vcu_report_505().battary_soc(), 3);
+  EXPECT_EQ(cd.devkit().vcu_report_505().battery_soc(), 3);
   EXPECT_EQ(cd.devkit().vcu_report_505().vehicle_mode_state(), 1);
   EXPECT_EQ(cd.devkit().vcu_report_505().frontcrash_state(), 1);
   EXPECT_EQ(cd.devkit().vcu_report_505().backcrash_state(), 0);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6ebc91952044758094268c22a3dcecec7a3030af" author="Chao Ma">
		<msg>canbus: fix a typo in chassis battery soc info (#12870)</msg>
		<modified_files>
			<file old_path="modules\canbus\vehicle\devkit\devkit_controller.cc" new_path="modules\canbus\vehicle\devkit\devkit_controller.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -184,11 +184,11 @@ Chassis DevkitController::chassis() {
       chassis_detail.devkit().vcu_report_505().has_speed()) {
     chassis_.set_speed_mps(
         static_cast&lt;float&gt;(chassis_detail.devkit().vcu_report_505().speed()));
-    chassis_.set_battery_soc(
+    chassis_.set_battery_soc_percentage(
         chassis_detail.devkit().vcu_report_505().battery_soc());
   } else {
     chassis_.set_speed_mps(0);
-    chassis_.set_battery_soc(0);
+    chassis_.set_battery_soc_percentage(0);
   }
   // 7 no odometer
   // chassis_.set_odometer_m(0);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8edbac77cc969860085df93b96fe10f214333be3" author="Martin Jansa">
		<msg>cyber_recorder: add support for black listing topic names in record like in play and split

* this is useful to record all topic except explicit list of a few topic we
  really don't want to record, e.g. because the size</msg>
		<modified_files>
			<file old_path="cyber\tools\cyber_recorder\main.cc" new_path="cyber\tools\cyber_recorder\main.cc" added_lines="3" deleted_lines="2">
				<diff>@@ -42,7 +42,7 @@ using apollo::cyber::record::Recoverer;
 using apollo::cyber::record::Spliter;
 
 const char INFO_OPTIONS[] = "h";
-const char RECORD_OPTIONS[] = "o:ac:i:m:h";
+const char RECORD_OPTIONS[] = "o:ac:k:i:m:h";
 const char PLAY_OPTIONS[] = "f:ac:k:lr:b:e:s:d:p:h";
 const char SPLIT_OPTIONS[] = "f:o:c:k:b:e:h";
 const char RECOVER_OPTIONS[] = "f:o:h";
@@ -424,7 +424,8 @@ int main(int argc, char** argv) {
     }
     ::apollo::cyber::Init(argv[0]);
     auto recorder = std::make_shared&lt;Recorder&gt;(opt_output_vec[0], opt_all,
-                                               opt_white_channels, opt_header);
+                                               opt_white_channels,
+                                               opt_black_channels, opt_header);
     bool record_result = recorder-&gt;Start();
     if (record_result) {
       while (!::apollo::cyber::IsShutdown()) {
</diff>
			</file>
			<file old_path="cyber\tools\cyber_recorder\recorder.cc" new_path="cyber\tools\cyber_recorder\recorder.cc" added_lines="31" deleted_lines="7">
				<diff>@@ -23,22 +23,37 @@ namespace cyber {
 namespace record {
 
 Recorder::Recorder(const std::string&amp; output, bool all_channels,
-                   const std::vector&lt;std::string&gt;&amp; channel_vec)
-    : output_(output), all_channels_(all_channels), channel_vec_(channel_vec) {
+                   const std::vector&lt;std::string&gt;&amp; white_channels,
+                   const std::vector&lt;std::string&gt;&amp; black_channels)
+    : output_(output),
+      all_channels_(all_channels),
+      white_channels_(white_channels),
+      black_channels_(black_channels) {
   header_ = HeaderBuilder::GetHeader();
 }
 
 Recorder::Recorder(const std::string&amp; output, bool all_channels,
-                   const std::vector&lt;std::string&gt;&amp; channel_vec,
+                   const std::vector&lt;std::string&gt;&amp; white_channels,
+                   const std::vector&lt;std::string&gt;&amp; black_channels,
                    const proto::Header&amp; header)
     : output_(output),
       all_channels_(all_channels),
-      channel_vec_(channel_vec),
+      white_channels_(white_channels),
+      black_channels_(black_channels),
       header_(header) {}
 
 Recorder::~Recorder() { Stop(); }
 
 bool Recorder::Start() {
+  for (const auto&amp; channel_name : white_channels_) {
+    if (std::find(black_channels_.begin(), black_channels_.end(),
+                  channel_name) != black_channels_.end()) {
+      AERROR &lt;&lt; "find channel in both of white list and black list, channel: "
+             &lt;&lt; channel_name;
+      return false;
+    }
+  }
+
   writer_.reset(new RecordWriter(header_));
   if (!writer_-&gt;Open(output_)) {
     AERROR &lt;&lt; "Datafile open file error.";
@@ -110,11 +125,20 @@ void Recorder::FindNewChannel(const RoleAttributes&amp; role_attr) {
     return;
   }
   if (!all_channels_ &amp;&amp;
-      std::find(channel_vec_.begin(), channel_vec_.end(),
-                role_attr.channel_name()) == channel_vec_.end()) {
-    ADEBUG &lt;&lt; "New channel was found, but not in record list.";
+      std::find(white_channels_.begin(), white_channels_.end(),
+                role_attr.channel_name()) == white_channels_.end()) {
+    ADEBUG &lt;&lt; "New channel '" &lt;&lt; role_attr.channel_name()
+           &lt;&lt; "' was found, but not in record list.";
     return;
   }
+
+  if (std::find(black_channels_.begin(), black_channels_.end(),
+      role_attr.channel_name()) != black_channels_.end()) {
+    ADEBUG &lt;&lt; "New channel '" &lt;&lt; role_attr.channel_name()
+           &lt;&lt; "' was found, but it appears in the blacklist.";
+    return;
+  }
+
   if (channel_reader_map_.find(role_attr.channel_name()) ==
       channel_reader_map_.end()) {
     if (!writer_-&gt;WriteChannel(role_attr.channel_name(),
</diff>
			</file>
			<file old_path="cyber\tools\cyber_recorder\recorder.h" new_path="cyber\tools\cyber_recorder\recorder.h" added_lines="6" deleted_lines="3">
				<diff>@@ -47,9 +47,11 @@ namespace record {
 class Recorder : public std::enable_shared_from_this&lt;Recorder&gt; {
  public:
   Recorder(const std::string&amp; output, bool all_channels,
-           const std::vector&lt;std::string&gt;&amp; channel_vec);
+           const std::vector&lt;std::string&gt;&amp; white_channels,
+           const std::vector&lt;std::string&gt;&amp; black_channels);
   Recorder(const std::string&amp; output, bool all_channels,
-           const std::vector&lt;std::string&gt;&amp; channel_vec,
+           const std::vector&lt;std::string&gt;&amp; white_channels,
+           const std::vector&lt;std::string&gt;&amp; black_channels,
            const proto::Header&amp; header);
   ~Recorder();
   bool Start();
@@ -64,7 +66,8 @@ class Recorder : public std::enable_shared_from_this&lt;Recorder&gt; {
   Connection&lt;const ChangeMsg&amp;&gt; change_conn_;
   std::string output_;
   bool all_channels_ = true;
-  std::vector&lt;std::string&gt; channel_vec_;
+  std::vector&lt;std::string&gt; white_channels_;
+  std::vector&lt;std::string&gt; black_channels_;
   proto::Header header_;
   std::unordered_map&lt;std::string, std::shared_ptr&lt;ReaderBase&gt;&gt;
       channel_reader_map_;
</diff>
			</file>
			<file old_path="modules\data\tools\smart_recorder\realtime_record_processor.cc" new_path="modules\data\tools\smart_recorder\realtime_record_processor.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -128,13 +128,14 @@ bool RealtimeRecordProcessor::Init(const SmartRecordTrigger&amp; trigger_conf) {
   max_backward_time_ = trigger_conf.max_backward_time();
   min_restore_chunk_ = trigger_conf.min_restore_chunk();
   std::vector&lt;std::string&gt; all_channels;
+  std::vector&lt;std::string&gt; black_channels;
   const std::set&lt;std::string&gt;&amp; all_channels_set =
       ChannelPool::Instance()-&gt;GetAllChannels();
   std::copy(all_channels_set.begin(), all_channels_set.end(),
             std::back_inserter(all_channels));
   recorder_ = std::make_shared&lt;Recorder&gt;(
       absl::StrCat(source_record_dir_, "/", default_output_filename_), false,
-      all_channels, HeaderBuilder::GetHeader());
+      all_channels, black_channels, HeaderBuilder::GetHeader());
   // Init base
   if (!RecordProcessor::Init(trigger_conf)) {
     AERROR &lt;&lt; "base init failed";
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f73e0cbd4a93b47c7b42f18ddc46ee00b85e7f90" author="storypku">
		<msg>cyber/transport: BUILD files for sub directories and directory layout re-org</msg>
		<modified_files>
			<file old_path="cyber\transport\common\common_test.cc" new_path="" added_lines="0" deleted_lines="73">
				<diff>@@ -1,73 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-#include &lt;sys/epoll.h&gt;
-#include &lt;unistd.h&gt;
-
-#include &lt;string&gt;
-#include "gtest/gtest.h"
-
-#include "cyber/common/global_data.h"
-#include "cyber/transport/common/endpoint.h"
-#include "cyber/transport/common/identity.h"
-
-namespace apollo {
-namespace cyber {
-namespace transport {
-
-TEST(IdentityTest, identity_test) {
-  Identity id1;
-  Identity id2;
-  Identity id3;
-  EXPECT_NE(id1, id2);
-  EXPECT_NE(id2, id3);
-  EXPECT_NE(id1, id3);
-  EXPECT_NE(id1.HashValue(), id3.HashValue());
-
-  id2 = id2;
-  EXPECT_NE(id2, id3);
-  id2 = id3;
-  EXPECT_EQ(id2, id3);
-
-  Identity id4(id1);
-  EXPECT_EQ(id1, id4);
-  EXPECT_EQ(id1.ToString(), id4.ToString());
-  EXPECT_EQ(id1.HashValue(), id4.HashValue());
-}
-
-TEST(EndpointTest, endpoint_test) {
-  // empty attr
-  RoleAttributes attr;
-  Endpoint endpoint1(attr);
-  EXPECT_EQ(common::GlobalData::Instance()-&gt;HostName(),
-            endpoint1.attributes().host_name());
-  EXPECT_EQ(common::GlobalData::Instance()-&gt;ProcessId(),
-            endpoint1.attributes().process_id());
-  EXPECT_NE(0, endpoint1.attributes().id());
-
-  attr.set_host_name("caros");
-  attr.set_process_id(1024);
-  attr.set_id(123);
-  Endpoint endpoint2(attr);
-  EXPECT_EQ("caros", endpoint2.attributes().host_name());
-  EXPECT_EQ(1024, endpoint2.attributes().process_id());
-  EXPECT_EQ(123, endpoint2.attributes().id());
-  EXPECT_NE(std::string("endpoint"), std::string(endpoint2.id().data()));
-}
-
-}  // namespace transport
-}  // namespace cyber
-}  // namespace apollo
</diff>
			</file>
			<file old_path="cyber\transport\transceiver\hybrid_transceiver_test.cc" new_path="cyber\transport\integration_test\hybrid_transceiver_test.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="cyber\transport\transceiver\intra_transceiver_test.cc" new_path="cyber\transport\integration_test\intra_transceiver_test.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="cyber\transport\transceiver\rtps_transceiver_test.cc" new_path="cyber\transport\integration_test\rtps_transceiver_test.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="cyber\transport\transceiver\shm_transceiver_test.cc" new_path="cyber\transport\integration_test\shm_transceiver_test.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="455090bb85807df9a2a1d47632ae9dc8a09f075e" author="storypku">
		<msg>cyber: code optimization for transport

1) simplified identity implementation
2) remove WIN32 related preprocessing</msg>
		<modified_files>
			<file old_path="cyber\transport\common\endpoint.cc" new_path="cyber\transport\common\endpoint.cc" added_lines="1" deleted_lines="0">
				<diff>@@ -15,6 +15,7 @@
  *****************************************************************************/
 
 #include "cyber/transport/common/endpoint.h"
+
 #include "cyber/common/global_data.h"
 
 namespace apollo {
</diff>
			</file>
			<file old_path="cyber\transport\common\endpoint.h" new_path="cyber\transport\common\endpoint.h" added_lines="1" deleted_lines="0">
				<diff>@@ -21,6 +21,7 @@
 #include &lt;string&gt;
 
 #include "cyber/proto/role_attributes.pb.h"
+
 #include "cyber/transport/common/identity.h"
 
 namespace apollo {
</diff>
			</file>
			<file old_path="cyber\transport\common\endpoint_test.cc" new_path="cyber\transport\common\endpoint_test.cc" added_lines="3" deleted_lines="0">
				<diff>@@ -44,6 +44,9 @@ TEST(EndpointTest, construction) {
     EXPECT_EQ(erole.host_name(), "123");
     EXPECT_EQ(erole.process_id(), 54321);
     EXPECT_NE(erole.id(), e0.id().HashValue());
+
+    auto id = std::string(e0.id().data(), ID_SIZE);
+    EXPECT_NE(std::string("endpoint"), id);
   }
 }
 
</diff>
			</file>
			<file old_path="cyber\transport\common\identity.cc" new_path="cyber\transport\common\identity.cc" added_lines="15" deleted_lines="18">
				<diff>@@ -24,42 +24,40 @@ namespace apollo {
 namespace cyber {
 namespace transport {
 
-Identity::Identity(bool need_generate) : hash_value_(0), hash_value_str_("") {
-  memset(data_, 0, ID_SIZE);
+Identity::Identity(bool need_generate) : hash_value_(0) {
+  std::memset(data_, 0, ID_SIZE);
   if (need_generate) {
     uuid_t uuid;
     uuid_generate(uuid);
-    memcpy(data_, uuid, ID_SIZE);
+    std::memcpy(data_, uuid, ID_SIZE);
     Update();
   }
 }
 
-Identity::Identity(const Identity&amp; another) {
-  memcpy(data_, another.data(), ID_SIZE);
-  hash_value_ = another.hash_value_;
-  hash_value_str_ = another.hash_value_str_;
+Identity::Identity(const Identity&amp; rhs) {
+  std::memcpy(data_, rhs.data_, ID_SIZE);
+  hash_value_ = rhs.hash_value_;
 }
 
 Identity::~Identity() {}
 
-Identity&amp; Identity::operator=(const Identity&amp; another) {
-  if (this != &amp;another) {
-    memcpy(data_, another.data(), ID_SIZE);
-    hash_value_ = another.hash_value_;
-    hash_value_str_ = another.hash_value_str_;
+Identity&amp; Identity::operator=(const Identity&amp; rhs) {
+  if (this != &amp;rhs) {
+    std::memcpy(data_, rhs.data_, ID_SIZE);
+    hash_value_ = rhs.hash_value_;
   }
   return *this;
 }
 
-bool Identity::operator==(const Identity&amp; another) const {
-  return memcmp(data_, another.data(), ID_SIZE) == 0;
+bool Identity::operator==(const Identity&amp; rhs) const {
+  return std::memcmp(data_, rhs.data_, ID_SIZE) == 0;
 }
 
-bool Identity::operator!=(const Identity&amp; another) const {
-  return memcmp(data_, another.data(), ID_SIZE) != 0;
+bool Identity::operator!=(const Identity&amp; rhs) const {
+  return std::memcmp(data_, rhs.data_, ID_SIZE) != 0;
 }
 
-const std::string&amp; Identity::ToString() const { return hash_value_str_; }
+std::string Identity::ToString() const { return std::to_string(hash_value_); }
 
 size_t Identity::Length() const { return ID_SIZE; }
 
@@ -67,7 +65,6 @@ uint64_t Identity::HashValue() const { return hash_value_; }
 
 void Identity::Update() {
   hash_value_ = common::Hash(std::string(data_, ID_SIZE));
-  hash_value_str_ = std::to_string(hash_value_);
 }
 
 }  // namespace transport
</diff>
			</file>
			<file old_path="cyber\transport\common\identity.h" new_path="cyber\transport\common\identity.h" added_lines="3" deleted_lines="6">
				<diff>@@ -25,7 +25,7 @@ namespace apollo {
 namespace cyber {
 namespace transport {
 
-const uint8_t ID_SIZE = 8;
+constexpr uint8_t ID_SIZE = 8;
 
 class Identity {
  public:
@@ -37,18 +37,16 @@ class Identity {
   bool operator==(const Identity&amp; another) const;
   bool operator!=(const Identity&amp; another) const;
 
-  const std::string&amp; ToString() const;
+  std::string ToString() const;
   size_t Length() const;
   uint64_t HashValue() const;
 
-  // getter and setter
   const char* data() const { return data_; }
   void set_data(const char* data) {
     if (data == nullptr) {
       return;
     }
-    memset(data_, 0, sizeof(data_));
-    memcpy(data_, data, sizeof(data_));
+    std::memcpy(data_, data, sizeof(data_));
     Update();
   }
 
@@ -57,7 +55,6 @@ class Identity {
 
   char data_[ID_SIZE];
   uint64_t hash_value_;
-  std::string hash_value_str_;
 };
 
 }  // namespace transport
</diff>
			</file>
			<file old_path="cyber\transport\common\identity_test.cc" new_path="cyber\transport\common\identity_test.cc" added_lines="22" deleted_lines="2">
				<diff>@@ -26,14 +26,34 @@ TEST(IdentityTest, testConstructFalse) {
   Identity it(false);
 
   EXPECT_EQ(it.HashValue(), static_cast&lt;uint64_t&gt;(0));
-  EXPECT_EQ(it.ToString(), "");
+  EXPECT_EQ(it.ToString(), "0");
 }
 
 TEST(IdentityTest, testConstructTrue) {
   Identity it(true);
 
   EXPECT_NE(it.HashValue(), static_cast&lt;uint64_t&gt;(0));
-  EXPECT_NE(it.ToString(), "");
+  EXPECT_NE(it.ToString(), "0");
+}
+
+TEST(IdentityTest, testIdentityEqual) {
+  Identity id1;
+  Identity id2;
+  Identity id3;
+  EXPECT_NE(id1, id2);
+  EXPECT_NE(id2, id3);
+  EXPECT_NE(id1, id3);
+  EXPECT_NE(id1.HashValue(), id3.HashValue());
+
+  id2 = id2;
+  EXPECT_NE(id2, id3);
+  id2 = id3;
+  EXPECT_EQ(id2, id3);
+
+  Identity id4(id1);
+  EXPECT_EQ(id1, id4);
+  EXPECT_EQ(id1.ToString(), id4.ToString());
+  EXPECT_EQ(id1.HashValue(), id4.HashValue());
 }
 
 TEST(IdentityTest, testOperatorEqual) {
</diff>
			</file>
			<file old_path="cyber\transport\message\message_info.cc" new_path="cyber\transport\message\message_info.cc" added_lines="7" deleted_lines="10">
				<diff>@@ -16,7 +16,7 @@
 
 #include "cyber/transport/message/message_info.h"
 
-#include &lt;arpa/inet.h&gt;
+#include &lt;cstring&gt;
 
 #include "cyber/common/log.h"
 
@@ -67,26 +67,23 @@ bool MessageInfo::SerializeTo(std::string* dst) const {
   RETURN_VAL_IF_NULL(dst, false);
 
   dst-&gt;assign(sender_id_.data(), ID_SIZE);
-  dst-&gt;append(reinterpret_cast&lt;char*&gt;(const_cast&lt;uint64_t*&gt;(&amp;seq_num_)),
-              sizeof(seq_num_));
+  dst-&gt;append(reinterpret_cast&lt;const char*&gt;(&amp;seq_num_), sizeof(seq_num_));
   dst-&gt;append(spare_id_.data(), ID_SIZE);
 
   return true;
 }
 
 bool MessageInfo::SerializeTo(char* dst, std::size_t len) const {
-  RETURN_VAL_IF_NULL(dst, false);
-  if (len &lt; kSize) {
+  if (dst == nullptr || len &lt; kSize) {
     return false;
   }
 
   char* ptr = dst;
-  memcpy(ptr, sender_id_.data(), ID_SIZE);
+  std::memcpy(ptr, sender_id_.data(), ID_SIZE);
   ptr += ID_SIZE;
-  memcpy(ptr, reinterpret_cast&lt;char*&gt;(const_cast&lt;uint64_t*&gt;(&amp;seq_num_)),
-         sizeof(seq_num_));
+  std::memcpy(ptr, reinterpret_cast&lt;const char*&gt;(&amp;seq_num_), sizeof(seq_num_));
   ptr += sizeof(seq_num_);
-  memcpy(ptr, spare_id_.data(), ID_SIZE);
+  std::memcpy(ptr, spare_id_.data(), ID_SIZE);
 
   return true;
 }
@@ -105,7 +102,7 @@ bool MessageInfo::DeserializeFrom(const char* src, std::size_t len) {
   char* ptr = const_cast&lt;char*&gt;(src);
   sender_id_.set_data(ptr);
   ptr += ID_SIZE;
-  memcpy(reinterpret_cast&lt;char*&gt;(&amp;seq_num_), ptr, sizeof(seq_num_));
+  std::memcpy(reinterpret_cast&lt;char*&gt;(&amp;seq_num_), ptr, sizeof(seq_num_));
   ptr += sizeof(seq_num_);
   spare_id_.set_data(ptr);
 
</diff>
			</file>
			<file old_path="cyber\transport\rtps\underlay_message.cc" new_path="cyber\transport\rtps\underlay_message.cc" added_lines="0" deleted_lines="8">
				<diff>@@ -22,16 +22,8 @@
 
 #include "cyber/transport/rtps/underlay_message.h"
 
-#include "fastcdr/Cdr.h"
 #include "fastcdr/exceptions/BadParamException.h"
 
-#ifdef _WIN32
-// Remove linker warning LNK4221 on Visual Studio
-namespace {
-char dummy;
-}
-#endif
-
 namespace apollo {
 namespace cyber {
 namespace transport {
</diff>
			</file>
			<file old_path="cyber\transport\rtps\underlay_message.h" new_path="cyber\transport\rtps\underlay_message.h" added_lines="29" deleted_lines="79">
				<diff>@@ -24,35 +24,7 @@
 #include &lt;utility&gt;
 #include &lt;vector&gt;
 
-#if defined(_WIN32)
-#if defined(EPROSIMA_USER_DLL_EXPORT)
-#define ePcyberima_user_DllExport __declspec(dllexport)
-#else
-#define ePcyberima_user_DllExport
-#endif
-#else
-#define ePcyberima_user_DllExport
-#endif
-
-#if defined(_WIN32)
-#if defined(EPROSIMA_USER_DLL_EXPORT)
-#if defined(UnderlayMessage_SOURCE)
-#define UnderlayMessage_DllAPI __declspec(dllexport)
-#else
-#define UnderlayMessage_DllAPI __declspec(dllimport)
-#endif  // UnderlayMessage_SOURCE
-#else
-#define UnderlayMessage_DllAPI
-#endif
-#else
-#define UnderlayMessage_DllAPI
-#endif  // _WIN32
-
-namespace eprosima {
-namespace fastcdr {
-class Cdr;
-}
-}  // namespace eprosima
+#include "fastcdr/Cdr.h"
 
 namespace apollo {
 namespace cyber {
@@ -68,118 +40,105 @@ class UnderlayMessage {
   /*!
    * @brief Default constructor.
    */
-  ePcyberima_user_DllExport UnderlayMessage();
+  UnderlayMessage();
 
   /*!
    * @brief Default destructor.
    */
-  ePcyberima_user_DllExport ~UnderlayMessage();
+  ~UnderlayMessage();
 
   /*!
    * @brief Copy constructor.
    * @param x Reference to the object UnderlayMessage that will be copied.
    */
-  ePcyberima_user_DllExport UnderlayMessage(const UnderlayMessage&amp; x);
+  UnderlayMessage(const UnderlayMessage&amp; x);
 
   /*!
    * @brief Move constructor.
    * @param x Reference to the object UnderlayMessage that will be copied.
    */
-  ePcyberima_user_DllExport UnderlayMessage(UnderlayMessage&amp;&amp; x);
+  UnderlayMessage(UnderlayMessage&amp;&amp; x);
 
   /*!
    * @brief Copy assignment.
    * @param x Reference to the object UnderlayMessage that will be copied.
    */
-  ePcyberima_user_DllExport UnderlayMessage&amp; operator=(
-      const UnderlayMessage&amp; x);
+  UnderlayMessage&amp; operator=(const UnderlayMessage&amp; x);
 
   /*!
    * @brief Move assignment.
    * @param x Reference to the object UnderlayMessage that will be copied.
    */
-  ePcyberima_user_DllExport UnderlayMessage&amp; operator=(UnderlayMessage&amp;&amp; x);
+  UnderlayMessage&amp; operator=(UnderlayMessage&amp;&amp; x);
 
   /*!
    * @brief This function sets a value in member timestamp
    * @param _timestamp New value for member timestamp
    */
-  inline ePcyberima_user_DllExport void timestamp(int32_t _timestamp) {
-    m_timestamp = _timestamp;
-  }
+  inline void timestamp(int32_t _timestamp) { m_timestamp = _timestamp; }
 
   /*!
    * @brief This function returns the value of member timestamp
    * @return Value of member timestamp
    */
-  inline ePcyberima_user_DllExport int32_t timestamp() const {
-    return m_timestamp;
-  }
+  inline int32_t timestamp() const { return m_timestamp; }
 
   /*!
    * @brief This function returns a reference to member timestamp
    * @return Reference to member timestamp
    */
-  inline ePcyberima_user_DllExport int32_t&amp; timestamp() { return m_timestamp; }
+  inline int32_t&amp; timestamp() { return m_timestamp; }
   /*!
    * @brief This function sets a value in member seq
    * @param _seq New value for member seq
    */
-  inline ePcyberima_user_DllExport void seq(int32_t _seq) { m_seq = _seq; }
+  inline void seq(int32_t _seq) { m_seq = _seq; }
 
   /*!
    * @brief This function returns the value of member seq
    * @return Value of member seq
    */
-  inline ePcyberima_user_DllExport int32_t seq() const { return m_seq; }
+  inline int32_t seq() const { return m_seq; }
 
   /*!
    * @brief This function returns a reference to member seq
    * @return Reference to member seq
    */
-  inline ePcyberima_user_DllExport int32_t&amp; seq() { return m_seq; }
+  inline int32_t&amp; seq() { return m_seq; }
   /*!
    * @brief This function copies the value in member data
    * @param _data New value to be copied in member data
    */
-  inline ePcyberima_user_DllExport void data(const std::string&amp; _data) {
-    m_data = _data;
-  }
+  inline void data(const std::string&amp; _data) { m_data = _data; }
 
   /*!
    * @brief This function moves the value in member data
    * @param _data New value to be moved in member data
    */
-  inline ePcyberima_user_DllExport void data(std::string&amp;&amp; _data) {
-    m_data = std::move(_data);
-  }
+  inline void data(std::string&amp;&amp; _data) { m_data = std::move(_data); }
 
   /*!
    * @brief This function returns a constant reference to member data
    * @return Constant reference to member data
    */
-  inline ePcyberima_user_DllExport const std::string&amp; data() const {
-    return m_data;
-  }
+  inline const std::string&amp; data() const { return m_data; }
 
   /*!
    * @brief This function returns a reference to member data
    * @return Reference to member data
    */
-  inline ePcyberima_user_DllExport std::string&amp; data() { return m_data; }
+  inline std::string&amp; data() { return m_data; }
   /*!
    * @brief This function copies the value in member datatype
    * @param _datatype New value to be copied in member datatype
    */
-  inline ePcyberima_user_DllExport void datatype(const std::string&amp; _datatype) {
-    m_datatype = _datatype;
-  }
+  inline void datatype(const std::string&amp; _datatype) { m_datatype = _datatype; }
 
   /*!
    * @brief This function moves the value in member datatype
    * @param _datatype New value to be moved in member datatype
    */
-  inline ePcyberima_user_DllExport void datatype(std::string&amp;&amp; _datatype) {
+  inline void datatype(std::string&amp;&amp; _datatype) {
     m_datatype = std::move(_datatype);
   }
 
@@ -187,17 +146,13 @@ class UnderlayMessage {
    * @brief This function returns a constant reference to member datatype
    * @return Constant reference to member datatype
    */
-  inline ePcyberima_user_DllExport const std::string&amp; datatype() const {
-    return m_datatype;
-  }
+  inline const std::string&amp; datatype() const { return m_datatype; }
 
   /*!
    * @brief This function returns a reference to member datatype
    * @return Reference to member datatype
    */
-  inline ePcyberima_user_DllExport std::string&amp; datatype() {
-    return m_datatype;
-  }
+  inline std::string&amp; datatype() { return m_datatype; }
 
   /*!
    * @brief This function returns the maximum serialized size of an object
@@ -205,8 +160,7 @@ class UnderlayMessage {
    * @param current_alignment Buffer alignment.
    * @return Maximum serialized size.
    */
-  ePcyberima_user_DllExport static size_t getMaxCdrSerializedSize(
-      size_t current_alignment = 0);
+  static size_t getMaxCdrSerializedSize(size_t current_alignment = 0);
 
   /*!
    * @brief This function returns the serialized size of a data depending on the
@@ -215,22 +169,20 @@ class UnderlayMessage {
    * @param current_alignment Buffer alignment.
    * @return Serialized size.
    */
-  ePcyberima_user_DllExport static size_t getCdrSerializedSize(
-      const UnderlayMessage&amp; data, size_t current_alignment = 0);
+  static size_t getCdrSerializedSize(const UnderlayMessage&amp; data,
+                                     size_t current_alignment = 0);
 
   /*!
    * @brief This function serializes an object using CDR serialization.
    * @param cdr CDR serialization object.
    */
-  ePcyberima_user_DllExport void serialize(
-      eprosima::fastcdr::Cdr&amp; cdr) const;  // NOLINT
+  void serialize(eprosima::fastcdr::Cdr&amp; cdr) const;  // NOLINT
 
   /*!
    * @brief This function deserializes an object using CDR serialization.
    * @param cdr CDR serialization object.
    */
-  ePcyberima_user_DllExport void deserialize(
-      eprosima::fastcdr::Cdr&amp; cdr);  // NOLINT
+  void deserialize(eprosima::fastcdr::Cdr&amp; cdr);  // NOLINT
 
   /*!
    * @brief This function returns the maximum serialized size of the Key of an
@@ -239,21 +191,19 @@ class UnderlayMessage {
    * @param current_alignment Buffer alignment.
    * @return Maximum serialized size.
    */
-  ePcyberima_user_DllExport static size_t getKeyMaxCdrSerializedSize(
-      size_t current_alignment = 0);
+  static size_t getKeyMaxCdrSerializedSize(size_t current_alignment = 0);
 
   /*!
    * @brief This function tells you if the Key has been defined for this type
    */
-  ePcyberima_user_DllExport static bool isKeyDefined();
+  static bool isKeyDefined();
 
   /*!
    * @brief This function serializes the key members of an object using CDR
    * serialization.
    * @param cdr CDR serialization object.
    */
-  ePcyberima_user_DllExport void serializeKey(
-      eprosima::fastcdr::Cdr&amp; cdr) const;  // NOLINT
+  void serializeKey(eprosima::fastcdr::Cdr&amp; cdr) const;  // NOLINT
 
  private:
   int32_t m_timestamp;
</diff>
			</file>
			<file old_path="cyber\transport\shm\block.h" new_path="cyber\transport\shm\block.h" added_lines="1" deleted_lines="1">
				<diff>@@ -49,7 +49,7 @@ class Block {
   void ReleaseWriteLock();
   void ReleaseReadLock();
 
-  volatile std::atomic&lt;int32_t&gt; lock_num_ = {0};
+  std::atomic&lt;int32_t&gt; lock_num_ = {0};
 
   uint64_t msg_size_;
   uint64_t msg_info_size_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5f2d2c6cfe8f085778169f03b1947ea7d557b562" author="Chao Ma">
		<msg>canbus: add the battery info in vehicle ch (#12900)</msg>
		<modified_files>
			<file old_path="modules\canbus\vehicle\ch\ch_controller.cc" new_path="modules\canbus\vehicle\ch\ch_controller.cc" added_lines="11" deleted_lines="1">
				<diff>@@ -16,11 +16,12 @@
 
 #include "modules/canbus/vehicle/ch/ch_controller.h"
 
+#include "modules/common/proto/vehicle_signal.pb.h"
+
 #include "cyber/common/log.h"
 #include "cyber/time/time.h"
 #include "modules/canbus/vehicle/ch/ch_message_manager.h"
 #include "modules/canbus/vehicle/vehicle_controller.h"
-#include "modules/common/proto/vehicle_signal.pb.h"
 #include "modules/drivers/canbus/can_comm/can_sender.h"
 #include "modules/drivers/canbus/can_comm/protocol_data.h"
 
@@ -247,6 +248,15 @@ Chassis ChController::chassis() {
         "CANBUS not ready, firmware error or emergency button pressed!");
   }
 
+  // 27 battery soc
+  if (chassis_detail.ch().has_ecu_status_2_516() &amp;&amp;
+      chassis_detail.ch().ecu_status_2_516().has_battery_soc()) {
+    chassis_.set_battery_soc_percentage(
+        chassis_detail.ch().ecu_status_2_516().battery_soc());
+  } else {
+    chassis_.set_battery_soc_percentage(0);
+  }
+
   return chassis_;
 }
 
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\ch\protocol\ecu_status_2_516.cc" new_path="modules\canbus\vehicle\ch\protocol\ecu_status_2_516.cc" added_lines="35" deleted_lines="27">
				<diff>@@ -30,10 +30,10 @@ const int32_t Ecustatus2516::ID = 0x516;
 
 void Ecustatus2516::Parse(const std::uint8_t* bytes, int32_t length,
                           ChassisDetail* chassis) const {
-  chassis-&gt;mutable_ch()
-      -&gt;mutable_ecu_status_2_516()
-      -&gt;set_battery_remaining_capacity(
-          battery_remaining_capacity(bytes, length));
+  chassis-&gt;mutable_ch()-&gt;mutable_ecu_status_2_516()-&gt;set_battery_soc(
+      battery_soc(bytes, length));
+  chassis-&gt;mutable_ch()-&gt;mutable_ecu_status_2_516()-&gt;set_battery_capacity(
+      battery_capacity(bytes, length));
   chassis-&gt;mutable_ch()-&gt;mutable_ecu_status_2_516()-&gt;set_battery_voltage(
       battery_voltage(bytes, length));
   chassis-&gt;mutable_ch()-&gt;mutable_ecu_status_2_516()-&gt;set_battery_current(
@@ -42,28 +42,36 @@ void Ecustatus2516::Parse(const std::uint8_t* bytes, int32_t length,
       battery_temperature(bytes, length));
 }
 
-// config detail: {'description': 'Percentage of battery remaining (BMS
-// status)', 'offset': 0.0, 'precision': 1.0, 'len': 16, 'name':
-// 'battery_remaining_capacity', 'is_signed_var': False, 'physical_range':
-// '[0|100]', 'bit': 0, 'type': 'int', 'order': 'intel', 'physical_unit': '%'}
-int Ecustatus2516::battery_remaining_capacity(const std::uint8_t* bytes,
-                                              int32_t length) const {
-  Byte t0(bytes + 1);
+// config detail: {'bit': 0, 'description': 'Percentage of battery remaining
+// (BMS status)', 'is_signed_var': False, 'len': 8, 'name': 'battery_soc',
+// 'offset': 0.0, 'order': 'intel', 'physical_range': '[0|100]',
+// 'physical_unit': '%', 'precision': 1.0, 'type': 'int'}
+int Ecustatus2516::battery_soc(const std::uint8_t* bytes,
+                               int32_t length) const {
+  Byte t0(bytes + 0);
   int32_t x = t0.get_byte(0, 8);
 
-  Byte t1(bytes + 0);
-  int32_t t = t1.get_byte(0, 8);
-  x &lt;&lt;= 8;
-  x |= t;
+  int ret = x;
+  return ret;
+}
+
+// config detail: {'bit': 8, 'description': 'Battery full capacity (BMS
+// status)', 'is_signed_var': False, 'len': 8, 'name': 'battery_capacity',
+// 'offset': 0.0, 'order': 'intel', 'physical_range': '[0|100]',
+// 'physical_unit': 'Ah', 'precision': 1.0, 'type': 'int'}
+int Ecustatus2516::battery_capacity(const std::uint8_t* bytes,
+                                    int32_t length) const {
+  Byte t0(bytes + 1);
+  int32_t x = t0.get_byte(0, 8);
 
   int ret = x;
   return ret;
 }
 
-// config detail: {'description': 'Current battery voltage (BMS status)',
-// 'offset': 0.0, 'precision': 0.1, 'len': 16, 'name': 'battery_voltage',
-// 'is_signed_var': False, 'physical_range': '[0|0]', 'bit': 16, 'type':
-// 'double', 'order': 'intel', 'physical_unit': 'V'}
+// config detail: {'bit': 16, 'description': 'Current battery voltage (BMS
+// status)', 'is_signed_var': False, 'len': 16, 'name': 'battery_voltage',
+// 'offset': 0.0, 'order': 'intel', 'physical_range': '[0|80]', 'physical_unit':
+// 'V', 'precision': 0.1, 'type': 'double'}
 double Ecustatus2516::battery_voltage(const std::uint8_t* bytes,
                                       int32_t length) const {
   Byte t0(bytes + 3);
@@ -78,10 +86,10 @@ double Ecustatus2516::battery_voltage(const std::uint8_t* bytes,
   return ret;
 }
 
-// config detail: {'description': 'Current battery current (BMS status)',
-// 'offset': 0.0, 'precision': 0.1, 'len': 16, 'name': 'battery_current',
-// 'is_signed_var': True, 'physical_range': '[0|0]', 'bit': 32, 'type':
-// 'double', 'order': 'intel', 'physical_unit': 'A'}
+// config detail: {'bit': 32, 'description': 'Current battery current (BMS
+// status)', 'is_signed_var': True, 'len': 16, 'name': 'battery_current',
+// 'offset': 0.0, 'order': 'intel', 'physical_range': '[-60|60]',
+// 'physical_unit': 'A', 'precision': 0.1, 'type': 'double'}
 double Ecustatus2516::battery_current(const std::uint8_t* bytes,
                                       int32_t length) const {
   Byte t0(bytes + 5);
@@ -99,10 +107,10 @@ double Ecustatus2516::battery_current(const std::uint8_t* bytes,
   return ret;
 }
 
-// config detail: {'description': 'Current battery temperature (BMS status)',
-// 'offset': 0.0, 'precision': 1.0, 'len': 16, 'name': 'battery_temperature',
-// 'is_signed_var': True, 'physical_range': '[0|0]', 'bit': 48, 'type': 'int',
-// 'order': 'intel', 'physical_unit': '?'}
+// config detail: {'bit': 48, 'description': 'Current battery temperature (BMS
+// status)', 'is_signed_var': True, 'len': 16, 'name': 'battery_temperature',
+// 'offset': 0.0, 'order': 'intel', 'physical_range': '[-40|110]',
+// 'physical_unit': '', 'precision': 1.0, 'type': 'int'}
 int Ecustatus2516::battery_temperature(const std::uint8_t* bytes,
                                        int32_t length) const {
   Byte t0(bytes + 7);
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\ch\protocol\ecu_status_2_516.h" new_path="modules\canbus\vehicle\ch\protocol\ecu_status_2_516.h" added_lines="23" deleted_lines="18">
				<diff>@@ -32,29 +32,34 @@ class Ecustatus2516 : public ::apollo::drivers::canbus::ProtocolData&lt;
              ChassisDetail* chassis) const override;
 
  private:
-  // config detail: {'description': 'Percentage of battery remaining (BMS
-  // status)', 'offset': 0.0, 'precision': 1.0, 'len': 16, 'name':
-  // 'BATTERY_REMAINING_CAPACITY', 'is_signed_var': False, 'physical_range':
-  // '[0|0]', 'bit': 0, 'type': 'int', 'order': 'intel', 'physical_unit': '%'}
-  int battery_remaining_capacity(const std::uint8_t* bytes,
-                                 const int32_t length) const;
+  // config detail: {'bit': 0, 'description': 'Percentage of battery remaining
+  // (BMS status)', 'is_signed_var': False, 'len': 8, 'name': 'BATTERY_SOC',
+  // 'offset': 0.0, 'order': 'intel', 'physical_range': '[0|100]',
+  // 'physical_unit': '%', 'precision': 1.0, 'type': 'int'}
+  int battery_soc(const std::uint8_t* bytes, const int32_t length) const;
 
-  // config detail: {'description': 'Current battery voltage (BMS status)',
-  // 'offset': 0.0, 'precision': 0.1, 'len': 16, 'name': 'BATTERY_VOLTAGE',
-  // 'is_signed_var': False, 'physical_range': '[0|80]', 'bit': 16, 'type':
-  // 'double', 'order': 'intel', 'physical_unit': 'V'}
+  // config detail: {'bit': 8, 'description': 'Battery full capacity (BMS
+  // status)', 'is_signed_var': False, 'len': 8, 'name': 'BATTERY_CAPACITY',
+  // 'offset': 0.0, 'order': 'intel', 'physical_range': '[0|100]',
+  // 'physical_unit': 'Ah', 'precision': 1.0, 'type': 'int'}
+  int battery_capacity(const std::uint8_t* bytes, const int32_t length) const;
+
+  // config detail: {'bit': 16, 'description': 'Current battery voltage (BMS
+  // status)', 'is_signed_var': False, 'len': 16, 'name': 'BATTERY_VOLTAGE',
+  // 'offset': 0.0, 'order': 'intel', 'physical_range': '[0|80]',
+  // 'physical_unit': 'V', 'precision': 0.1, 'type': 'double'}
   double battery_voltage(const std::uint8_t* bytes, const int32_t length) const;
 
-  // config detail: {'description': 'Current battery current (BMS status)',
-  // 'offset': 0.0, 'precision': 0.1, 'len': 16, 'name': 'BATTERY_CURRENT',
-  // 'is_signed_var': True, 'physical_range': '[-60|60]', 'bit': 32, 'type':
-  // 'double', 'order': 'intel', 'physical_unit': 'A'}
+  // config detail: {'bit': 32, 'description': 'Current battery current (BMS
+  // status)', 'is_signed_var': True, 'len': 16, 'name': 'BATTERY_CURRENT',
+  // 'offset': 0.0, 'order': 'intel', 'physical_range': '[-60|60]',
+  // 'physical_unit': 'A', 'precision': 0.1, 'type': 'double'}
   double battery_current(const std::uint8_t* bytes, const int32_t length) const;
 
-  // config detail: {'description': 'Current battery temperature (BMS status)',
-  // 'offset': 0.0, 'precision': 1.0, 'len': 16, 'name': 'BATTERY_TEMPERATURE',
-  // 'is_signed_var': True, 'physical_range': '[-40|110]', 'bit': 48, 'type':
-  // 'int', 'order': 'intel', 'physical_unit': '\xc2\xa1\xc3\x89'}
+  // config detail: {'bit': 48, 'description': 'Current battery temperature (BMS
+  // status)', 'is_signed_var': True, 'len': 16, 'name': 'BATTERY_TEMPERATURE',
+  // 'offset': 0.0, 'order': 'intel', 'physical_range': '[-40|110]',
+  // 'physical_unit': '', 'precision': 1.0, 'type': 'int'}
   int battery_temperature(const std::uint8_t* bytes,
                           const int32_t length) const;
 };
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\ch\protocol\ecu_status_2_516_test.cc" new_path="modules\canbus\vehicle\ch\protocol\ecu_status_2_516_test.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -41,7 +41,8 @@ TEST_F(Ecustatus2516Test, General) {
   EXPECT_EQ(data[6], 0b00010011);
   EXPECT_EQ(data[7], 0b00010100);
 
-  EXPECT_EQ(cd.ch().ecu_status_2_516().battery_remaining_capacity(), 513);
+  EXPECT_EQ(cd.ch().ecu_status_2_516().battery_soc(), 1);
+  EXPECT_EQ(cd.ch().ecu_status_2_516().battery_capacity(), 2);
   EXPECT_DOUBLE_EQ(cd.ch().ecu_status_2_516().battery_voltage(), 102.7);
   EXPECT_DOUBLE_EQ(cd.ch().ecu_status_2_516().battery_current(),
                    460.90000000000003);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5edbffed8f3a9a9b76c78cf411126449fdf24852" author="Jiahao Chen">
		<msg>Perception: completely fix Eigen slerp function</msg>
		<modified_files>
			<file old_path="modules\perception\onboard\transform_wrapper\transform_wrapper.cc" new_path="modules\perception\onboard\transform_wrapper\transform_wrapper.cc" added_lines="4" deleted_lines="1">
				<diff>@@ -83,7 +83,10 @@ Eigen::Quaterniond Slerp(const Eigen::Quaterniond&amp; source, const double&amp; t,
   }
   if (d &lt; 0) scale1 = -scale1;
 
-  return Eigen::Quaterniond(scale0 * source.coeffs() + scale1 * other.coeffs());
+  return Eigen::Quaterniond(scale0 * source.w() + scale1 * other.w(),
+                            scale0 * source.x() + scale1 * other.x(),
+                            scale0 * source.y() + scale1 * other.y(),
+                            scale0 * source.z() + scale1 * other.z());
 }
 
 bool TransformCache::QueryTransform(double timestamp,
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="922462e75a964e2bc37300af7325f9c69b69087d" author="storypku">
		<msg>Build: remove tricky &amp; ugly "#define private public" leftovers</msg>
		<modified_files>
			<file old_path="modules\perception\common\io\io_util_test.cc" new_path="modules\perception\common\io\io_util_test.cc" added_lines="2" deleted_lines="4">
				<diff>@@ -13,12 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *****************************************************************************/
-#include "gtest/gtest.h"
-
-#define private public
-#define protected public
 #include "modules/perception/common/io/io_util.h"
 
+#include "gtest/gtest.h"
+
 namespace apollo {
 namespace perception {
 namespace common {
</diff>
			</file>
			<file old_path="modules\perception\fusion\common\kalman_filter_test.cc" new_path="modules\perception\fusion\common\kalman_filter_test.cc" added_lines="3" deleted_lines="2">
				<diff>@@ -13,10 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *****************************************************************************/
+#include "modules/perception/fusion/common/kalman_filter.h"
+
 #include "gtest/gtest.h"
-#define private public
+
 #include "cyber/common/log.h"
-#include "modules/perception/fusion/common/kalman_filter.h"
 
 namespace apollo {
 namespace perception {
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\data_association\hm_data_association\track_object_test.cc" new_path="modules\perception\fusion\lib\data_association\hm_data_association\track_object_test.cc" added_lines="1" deleted_lines="4">
				<diff>@@ -14,8 +14,6 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/perception/fusion/lib/data_association/hm_data_association/hm_tracks_objects_match.h"
-
 #include "gtest/gtest.h"
 
 #include "modules/perception/base/frame.h"
@@ -24,8 +22,7 @@
 #include "modules/perception/fusion/base/sensor_frame.h"
 #include "modules/perception/fusion/base/sensor_object.h"
 #include "modules/perception/fusion/base/track.h"
-
-#define private public
+#include "modules/perception/fusion/lib/data_association/hm_data_association/hm_tracks_objects_match.h"
 
 namespace apollo {
 namespace perception {
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\data_fusion\tracker\pbf_tracker\pbf_tracker_test.cc" new_path="modules\perception\fusion\lib\data_fusion\tracker\pbf_tracker\pbf_tracker_test.cc" added_lines="2" deleted_lines="4">
				<diff>@@ -14,6 +14,8 @@
  * limitations under the License.
  *****************************************************************************/
 
+#include "modules/perception/fusion/lib/data_fusion/tracker/pbf_tracker/pbf_tracker.h"
+
 #include "modules/perception/common/sensor_manager/sensor_manager.h"
 #include "modules/perception/fusion/base/base_init_options.h"
 #include "modules/perception/fusion/base/sensor.h"
@@ -21,10 +23,6 @@
 #include "modules/perception/fusion/base/sensor_object.h"
 #include "modules/perception/fusion/base/track.h"
 
-#define private public
-#define protected public
-#include "modules/perception/fusion/lib/data_fusion/tracker/pbf_tracker/pbf_tracker.h"
-
 namespace apollo {
 namespace perception {
 namespace fusion {
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\fusion_system\probabilistic_fusion\probabilistic_fusion_test.cc" new_path="modules\perception\fusion\lib\fusion_system\probabilistic_fusion\probabilistic_fusion_test.cc" added_lines="2" deleted_lines="3">
				<diff>@@ -13,13 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *****************************************************************************/
+#include "modules/perception/fusion/lib/fusion_system/probabilistic_fusion/probabilistic_fusion.h"
+
 #include "gtest/gtest.h"
 
-#define private public
-#define protected public
 #include "modules/perception/base/sensor_meta.h"
 #include "modules/perception/fusion/lib/data_fusion/tracker/pbf_tracker/pbf_tracker.h"
-#include "modules/perception/fusion/lib/fusion_system/probabilistic_fusion/probabilistic_fusion.h"
 
 namespace apollo {
 namespace perception {
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\entropy_calibrator_test.cc" new_path="modules\perception\inference\tensorrt\entropy_calibrator_test.cc" added_lines="3" deleted_lines="4">
				<diff>@@ -14,12 +14,11 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "cyber/common/log.h"
-#include "gtest/gtest.h"
+#include "modules/perception/inference/tensorrt/entropy_calibrator.h"
 
-#define private public
+#include "gtest/gtest.h"
 
-#include "modules/perception/inference/tensorrt/entropy_calibrator.h"
+#include "cyber/common/log.h"
 
 namespace apollo {
 namespace perception {
</diff>
			</file>
			<file old_path="modules\perception\lib\config_manager\config_manager_test.cc" new_path="modules\perception\lib\config_manager\config_manager_test.cc" added_lines="2" deleted_lines="3">
				<diff>@@ -13,12 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *****************************************************************************/
+#include "modules/perception/lib/config_manager/config_manager.h"
+
 #include "gtest/gtest.h"
 
-#define private public
-#define protected public
 #include "modules/perception/common/perception_gflags.h"
-#include "modules/perception/lib/config_manager/config_manager.h"
 
 namespace apollo {
 namespace perception {
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\ground_detector\spatio_temporal_ground_detector\spatio_temporal_ground_detector_test.cc" new_path="modules\perception\lidar\lib\ground_detector\spatio_temporal_ground_detector\spatio_temporal_ground_detector_test.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -14,11 +14,11 @@
  * limitations under the License.
  *****************************************************************************/
 
+#include "modules/perception/lidar/lib/ground_detector/spatio_temporal_ground_detector/spatio_temporal_ground_detector.h"
+
 #include "gtest/gtest.h"
-#include "pcl/io/pcd_io.h"
 
-#define private public
-#include "modules/perception/lidar/lib/ground_detector/spatio_temporal_ground_detector/spatio_temporal_ground_detector.h"
+#include "pcl/io/pcd_io.h"
 
 namespace apollo {
 namespace perception {
</diff>
			</file>
			<file old_path="modules\perception\radar\lib\tracker\conti_ars_tracker\conti_ars_tracker_test.cc" new_path="modules\perception\radar\lib\tracker\conti_ars_tracker\conti_ars_tracker_test.cc" added_lines="2" deleted_lines="4">
				<diff>@@ -13,15 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *****************************************************************************/
+#include "modules/perception/radar/lib/tracker/conti_ars_tracker/conti_ars_tracker.h"
+
 #include "gtest/gtest.h"
 
 #include "cyber/common/log.h"
 #include "modules/perception/common/perception_gflags.h"
 
-#define private public
-#define protected public
-#include "modules/perception/radar/lib/tracker/conti_ars_tracker/conti_ars_tracker.h"
-
 namespace apollo {
 namespace perception {
 namespace radar {
</diff>
			</file>
			<file old_path="modules\perception\radar\lib\tracker\matcher\hm_matcher_test.cc" new_path="modules\perception\radar\lib\tracker\matcher\hm_matcher_test.cc" added_lines="2" deleted_lines="4">
				<diff>@@ -13,6 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *****************************************************************************/
+#include "modules/perception/radar/lib/tracker/matcher/hm_matcher.h"
+
 #include "gtest/gtest.h"
 
 #include "cyber/common/log.h"
@@ -20,10 +22,6 @@
 #include "modules/perception/radar/lib/tracker/common/radar_track.h"
 #include "modules/perception/radar/lib/tracker/common/radar_track_manager.h"
 
-#define private public
-#define protected public
-#include "modules/perception/radar/lib/tracker/matcher/hm_matcher.h"
-
 namespace apollo {
 namespace perception {
 namespace radar {
</diff>
			</file>
			<file old_path="modules\planning\integration_tests\planning_test_base.h" new_path="modules\planning\integration_tests\planning_test_base.h" added_lines="1" deleted_lines="1">
				<diff>@@ -19,9 +19,9 @@
 #include &lt;string&gt;
 
 #include "gtest/gtest.h"
+
 #include "modules/planning/proto/traffic_rule_config.pb.h"
 
-#define protected public
 // TODO(all) #include "modules/planning/navi_planning.h"
 #include "modules/planning/on_lane_planning.h"
 #include "modules/planning/planning_base.h"
</diff>
			</file>
			<file old_path="modules\routing\topo_creator\graph_creator_test.cc" new_path="modules\routing\topo_creator\graph_creator_test.cc" added_lines="2" deleted_lines="3">
				<diff>@@ -14,11 +14,10 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "gtest/gtest.h"
-
-#define private public
 #include "modules/routing/topo_creator/graph_creator.h"
 
+#include "gtest/gtest.h"
+
 using apollo::hdmap::Lane;
 using apollo::routing::GraphCreator;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="35ab1bfb7fa27f07e2af2d5ade7508fbc379b11f" author="storypku">
		<msg>Build: sync with upstream master-390513e</msg>
		<modified_files>
			<file old_path="third_party\gpus\cuda\cuda_config.h.tpl" new_path="third_party\gpus\cuda\cuda_config.h.tpl" added_lines="1" deleted_lines="0">
				<diff>@@ -17,6 +17,7 @@ limitations under the License.
 #define CUDA_CUDA_CONFIG_H_
 
 #define TF_CUDA_VERSION "%{cuda_version}"
+#define TF_CUDART_VERSION "%{cudart_version}"
 #define TF_CUBLAS_VERSION "%{cublas_version}"
 #define TF_CUSOLVER_VERSION "%{cusolver_version}"
 #define TF_CURAND_VERSION "%{curand_version}"
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="bb029ec38c9bc678d2314cd0fd869f6911299e0a" author="zyc0222">
		<msg>update name of dev kit advanced sne-r (#12913)</msg>
		<modified_files>
			<file old_path="modules\calibration\data\dev_kit_advanced_3lidar\cancard_params\canbus.conf" new_path="modules\calibration\data\dev_kit_advanced_sne-r\cancard_params\canbus.conf" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_3lidar\localization_conf\localization.conf" new_path="modules\calibration\data\dev_kit_advanced_sne-r\localization_conf\localization.conf" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_3lidar\planning_conf\planning.conf" new_path="modules\calibration\data\dev_kit_advanced_sne-r\planning_conf\planning.conf" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b8a74275367a718db97b036ac62c2e6348267991" author="changsh726">
		<msg>sensor_calibration: fix field name error</msg>
		<modified_files>
			<file old_path="docs\Apollo_Fuel\examples\sensor_calibration\camera_12mm_to_lidar\camera_12mm_to_lidar.config" new_path="docs\Apollo_Fuel\examples\sensor_calibration\camera_12mm_to_lidar\camera_12mm_to_lidar.config" added_lines="3" deleted_lines="3">
				<diff>@@ -25,19 +25,19 @@ records: {
 channels: {
 	# channel of camera image channels
 	channel: {
-		descriptor: "front camera 12mm"
+		description: "front camera 12mm"
 		name: "/apollo/sensor/camera/front_12mm/image"
 		extraction_rate: 5
 	}
 	# channel of 16-beam lidar
 	channel: {
-		descriptor: "lidar 16 point cloud"
+		description: "lidar 16 point cloud"
 		name: "/apollo/sensor/lidar16/PointCloud2"
 		extraction_rate: 5
 	}
 	# channel of localization pose odometry
 	channel: {
-		descriptor: "GNSS odometry"
+		description: "GNSS odometry"
 		name: "/apollo/localization/pose"
 		extraction_rate: 1
 	}
</diff>
			</file>
			<file old_path="docs\Apollo_Fuel\examples\sensor_calibration\camera_6mm_to_lidar\camera_6mm_to_lidar.config" new_path="docs\Apollo_Fuel\examples\sensor_calibration\camera_6mm_to_lidar\camera_6mm_to_lidar.config" added_lines="3" deleted_lines="3">
				<diff>@@ -25,19 +25,19 @@ records: {
 channels: {
 	# channel of camera image channels
 	channel: {
-		descriptor: "front camera 6mm"
+		description: "front camera 6mm"
 		name: "/apollo/sensor/camera/front_6mm/image"
 		extraction_rate: 5
 	}
 	# channel of 16-beam lidar
 	channel: {
-		descriptor: "lidar 16 point cloud"
+		description: "lidar 16 point cloud"
 		name: "/apollo/sensor/lidar16/PointCloud2"
 		extraction_rate: 5
 	}
 	# channel of localization pose odometry
 	channel: {
-		descriptor: "GNSS odometry"
+		description: "GNSS odometry"
 		name: "/apollo/localization/pose"
 		extraction_rate: 1
 	}
</diff>
			</file>
			<file old_path="docs\Apollo_Fuel\examples\sensor_calibration\lidar_to_gnss\lidar_to_gnss.config" new_path="docs\Apollo_Fuel\examples\sensor_calibration\lidar_to_gnss\lidar_to_gnss.config" added_lines="2" deleted_lines="2">
				<diff>@@ -25,13 +25,13 @@ records: {
 channels: {
 	# channel of mulitple lidars
 	channel: {
-		descriptor: "lidar 16 front up point cloud"
+		description: "lidar 16 front up point cloud"
 		name: "/apollo/sensor/lidar16/PointCloud2"
 		extraction_rate: 5
 	}
 	# channel of GNSS odometry
 	channel: {
-		descriptor: "localization pose"
+		description: "localization pose"
 		name: "/apollo/localization/pose"
 		extraction_rate: 1
 	}
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a742e00cfee0338b0e0c7028f7024435cae6bf88" author="storypku">
		<msg>Build: fix "-Werror=sign-compare" for glog's CHECK_EQ/GT/LT</msg>
		<modified_files>
			<file old_path="modules\bridge\test\bridge_sender_test.cc" new_path="modules\bridge\test\bridge_sender_test.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -106,7 +106,7 @@ int main(int argc, char *argv[]) {
     count = 10000;
   } else {
     count = atoi(argv[1]);
-    CHECK_LE(count, 20000);
+    CHECK_LE(count, 20000U);
   }
   send("127.0.0.1", 8900, count);
   return 0;
</diff>
			</file>
			<file old_path="modules\common\math\integral.cc" new_path="modules\common\math\integral.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -26,7 +26,7 @@ namespace math {
 
 double IntegrateBySimpson(const std::vector&lt;double&gt;&amp; func, const double dx,
                           const std::size_t nsteps) {
-  CHECK_EQ(1, nsteps &amp; 1);
+  CHECK_EQ(1U, nsteps &amp; 1);
   double sum1 = 0.0;
   double sum2 = 0.0;
   for (std::size_t i = 1; i + 1 &lt; nsteps; ++i) {
</diff>
			</file>
			<file old_path="modules\common\math\mpc_osqp.cc" new_path="modules\common\math\mpc_osqp.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -56,7 +56,7 @@ void MpcOsqp::CalculateKernel(std::vector&lt;c_float&gt; *P_data,
   // col1:(row,val),...; col2:(row,val),....; ...
   std::vector&lt;std::vector&lt;std::pair&lt;c_int, c_float&gt;&gt;&gt; columns;
   columns.resize(num_param_);
-  int value_index = 0;
+  size_t value_index = 0;
   // state and terminal state
   for (size_t i = 0; i &lt;= horizon_; ++i) {
     for (size_t j = 0; j &lt; state_dim_; ++j) {
</diff>
			</file>
			<file old_path="modules\common\math\path_matcher.cc" new_path="modules\common\math\path_matcher.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -25,6 +25,7 @@
 #include &lt;vector&gt;
 
 #include "glog/logging.h"
+
 #include "modules/common/math/linear_interpolation.h"
 
 namespace apollo {
@@ -33,7 +34,7 @@ namespace math {
 
 PathPoint PathMatcher::MatchToPath(const std::vector&lt;PathPoint&gt;&amp; reference_line,
                                    const double x, const double y) {
-  CHECK_GT(reference_line.size(), 0);
+  CHECK_GT(reference_line.size(), 0U);
 
   auto func_distance_square = [](const PathPoint&amp; point, const double x,
                                  const double y) {
</diff>
			</file>
			<file old_path="modules\common\math\polygon2d.cc" new_path="modules\common\math\polygon2d.cc" added_lines="19" deleted_lines="18">
				<diff>@@ -23,6 +23,7 @@
 
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_join.h"
+
 #include "cyber/common/log.h"
 #include "modules/common/math/math_utils.h"
 #include "modules/common/util/string_util.h"
@@ -41,7 +42,7 @@ Polygon2d::Polygon2d(std::vector&lt;Vec2d&gt; points) : points_(std::move(points)) {
 }
 
 double Polygon2d::DistanceTo(const Vec2d &amp;point) const {
-  CHECK_GE(points_.size(), 3);
+  CHECK_GE(points_.size(), 3U);
   if (IsPointIn(point)) {
     return 0.0;
   }
@@ -53,7 +54,7 @@ double Polygon2d::DistanceTo(const Vec2d &amp;point) const {
 }
 
 double Polygon2d::DistanceSquareTo(const Vec2d &amp;point) const {
-  CHECK_GE(points_.size(), 3);
+  CHECK_GE(points_.size(), 3U);
   if (IsPointIn(point)) {
     return 0.0;
   }
@@ -69,7 +70,7 @@ double Polygon2d::DistanceTo(const LineSegment2d &amp;line_segment) const {
   if (line_segment.length() &lt;= kMathEpsilon) {
     return DistanceTo(line_segment.start());
   }
-  CHECK_GE(points_.size(), 3);
+  CHECK_GE(points_.size(), 3U);
   if (IsPointIn(line_segment.center())) {
     return 0.0;
   }
@@ -89,12 +90,12 @@ double Polygon2d::DistanceTo(const LineSegment2d &amp;line_segment) const {
 }
 
 double Polygon2d::DistanceTo(const Box2d &amp;box) const {
-  CHECK_GE(points_.size(), 3);
+  CHECK_GE(points_.size(), 3U);
   return DistanceTo(Polygon2d(box));
 }
 
 double Polygon2d::DistanceTo(const Polygon2d &amp;polygon) const {
-  CHECK_GE(points_.size(), 3);
+  CHECK_GE(points_.size(), 3U);
   CHECK_GE(polygon.num_points(), 3);
 
   if (IsPointIn(polygon.points()[0])) {
@@ -119,14 +120,14 @@ double Polygon2d::DistanceToBoundary(const Vec2d &amp;point) const {
 }
 
 bool Polygon2d::IsPointOnBoundary(const Vec2d &amp;point) const {
-  CHECK_GE(points_.size(), 3);
+  CHECK_GE(points_.size(), 3U);
   return std::any_of(
       line_segments_.begin(), line_segments_.end(),
       [&amp;](const LineSegment2d &amp;poly_seg) { return poly_seg.IsPointIn(point); });
 }
 
 bool Polygon2d::IsPointIn(const Vec2d &amp;point) const {
-  CHECK_GE(points_.size(), 3);
+  CHECK_GE(points_.size(), 3U);
   if (IsPointOnBoundary(point)) {
     return true;
   }
@@ -145,7 +146,7 @@ bool Polygon2d::IsPointIn(const Vec2d &amp;point) const {
 }
 
 bool Polygon2d::HasOverlap(const Polygon2d &amp;polygon) const {
-  CHECK_GE(points_.size(), 3);
+  CHECK_GE(points_.size(), 3U);
   if (polygon.max_x() &lt; min_x() || polygon.min_x() &gt; max_x() ||
       polygon.max_y() &lt; min_y() || polygon.min_y() &gt; max_y()) {
     return false;
@@ -157,7 +158,7 @@ bool Polygon2d::Contains(const LineSegment2d &amp;line_segment) const {
   if (line_segment.length() &lt;= kMathEpsilon) {
     return IsPointIn(line_segment.start());
   }
-  CHECK_GE(points_.size(), 3);
+  CHECK_GE(points_.size(), 3U);
   if (!IsPointIn(line_segment.start())) {
     return false;
   }
@@ -176,7 +177,7 @@ bool Polygon2d::Contains(const LineSegment2d &amp;line_segment) const {
 }
 
 bool Polygon2d::Contains(const Polygon2d &amp;polygon) const {
-  CHECK_GE(points_.size(), 3);
+  CHECK_GE(points_.size(), 3U);
   if (area_ &lt; polygon.area() - kMathEpsilon) {
     return false;
   }
@@ -328,12 +329,12 @@ bool Polygon2d::ClipConvexHull(const LineSegment2d &amp;line_segment,
   }
 
   points-&gt;swap(new_points);
-  return points-&gt;size() &gt;= 3;
+  return points-&gt;size() &gt;= 3U;
 }
 
 bool Polygon2d::ComputeOverlap(const Polygon2d &amp;other_polygon,
                                Polygon2d *const overlap_polygon) const {
-  CHECK_GE(points_.size(), 3);
+  CHECK_GE(points_.size(), 3U);
   CHECK_NOTNULL(overlap_polygon);
   ACHECK(is_convex_ &amp;&amp; other_polygon.is_convex());
   std::vector&lt;Vec2d&gt; points = other_polygon.points();
@@ -356,7 +357,7 @@ double Polygon2d::ComputeIoU(const Polygon2d &amp;other_polygon) const {
 }
 
 bool Polygon2d::HasOverlap(const LineSegment2d &amp;line_segment) const {
-  CHECK_GE(points_.size(), 3);
+  CHECK_GE(points_.size(), 3U);
   if ((line_segment.start().x() &lt; min_x_ &amp;&amp; line_segment.end().x() &lt; min_x_) ||
       (line_segment.start().x() &gt; max_x_ &amp;&amp; line_segment.end().x() &gt; max_x_) ||
       (line_segment.start().y() &lt; min_y_ &amp;&amp; line_segment.end().y() &lt; min_y_) ||
@@ -370,7 +371,7 @@ bool Polygon2d::HasOverlap(const LineSegment2d &amp;line_segment) const {
 
 bool Polygon2d::GetOverlap(const LineSegment2d &amp;line_segment,
                            Vec2d *const first, Vec2d *const last) const {
-  CHECK_GE(points_.size(), 3);
+  CHECK_GE(points_.size(), 3U);
   CHECK_NOTNULL(first);
   CHECK_NOTNULL(last);
 
@@ -421,7 +422,7 @@ std::vector&lt;Vec2d&gt; Polygon2d::GetAllVertices() const { return points_; }
 
 std::vector&lt;LineSegment2d&gt; Polygon2d::GetAllOverlaps(
     const LineSegment2d &amp;line_segment) const {
-  CHECK_GE(points_.size(), 3);
+  CHECK_GE(points_.size(), 3U);
 
   if (line_segment.length() &lt;= kMathEpsilon) {
     std::vector&lt;LineSegment2d&gt; overlaps;
@@ -475,7 +476,7 @@ std::vector&lt;LineSegment2d&gt; Polygon2d::GetAllOverlaps(
 
 void Polygon2d::ExtremePoints(const double heading, Vec2d *const first,
                               Vec2d *const last) const {
-  CHECK_GE(points_.size(), 3);
+  CHECK_GE(points_.size(), 3U);
   CHECK_NOTNULL(first);
   CHECK_NOTNULL(last);
 
@@ -500,7 +501,7 @@ AABox2d Polygon2d::AABoundingBox() const {
 }
 
 Box2d Polygon2d::BoundingBoxWithHeading(const double heading) const {
-  CHECK_GE(points_.size(), 3);
+  CHECK_GE(points_.size(), 3U);
   const Vec2d direction_vec = Vec2d::CreateUnitVec2d(heading);
   Vec2d px1;
   Vec2d px2;
@@ -519,7 +520,7 @@ Box2d Polygon2d::BoundingBoxWithHeading(const double heading) const {
 }
 
 Box2d Polygon2d::MinAreaBoundingBox() const {
-  CHECK_GE(points_.size(), 3);
+  CHECK_GE(points_.size(), 3U);
   if (!is_convex_) {
     Polygon2d convex_polygon;
     ComputeConvexHull(points_, &amp;convex_polygon);
</diff>
			</file>
			<file old_path="modules\control\common\trajectory_analyzer.cc" new_path="modules\control\common\trajectory_analyzer.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -67,7 +67,7 @@ TrajectoryAnalyzer::TrajectoryAnalyzer(
 
 PathPoint TrajectoryAnalyzer::QueryMatchedPathPoint(const double x,
                                                     const double y) const {
-  CHECK_GT(trajectory_points_.size(), 0);
+  CHECK_GT(trajectory_points_.size(), 0U);
 
   double d_min = PointDistanceSquare(trajectory_points_.front(), x, y);
   size_t index_min = 0;
@@ -237,7 +237,7 @@ PathPoint TrajectoryAnalyzer::FindMinDistancePoint(const TrajectoryPoint &amp;p0,
 
 void TrajectoryAnalyzer::TrajectoryTransformToCOM(
     const double rear_to_com_distance) {
-  CHECK_GT(trajectory_points_.size(), 0);
+  CHECK_GT(trajectory_points_.size(), 0U);
   for (size_t i = 0; i &lt; trajectory_points_.size(); ++i) {
     auto com = ComputeCOMPosition(rear_to_com_distance,
                                   trajectory_points_[i].path_point());
</diff>
			</file>
			<file old_path="modules\drivers\canbus\can_client\can_client.h" new_path="modules\drivers\canbus\can_client\can_client.h" added_lines="4" deleted_lines="3">
				<diff>@@ -27,11 +27,12 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
-#include "cyber/common/log.h"
 #include "modules/common/proto/error_code.pb.h"
-#include "modules/drivers/canbus/common/byte.h"
 #include "modules/drivers/canbus/proto/can_card_parameter.pb.h"
 
+#include "cyber/common/log.h"
+#include "modules/drivers/canbus/common/byte.h"
+
 /**
  * @namespace apollo::drivers::canbus
  * @brief apollo::drivers::canbus
@@ -137,7 +138,7 @@ class CanClient {
    */
   virtual apollo::common::ErrorCode SendSingleFrame(
       const std::vector&lt;CanFrame&gt; &amp;frames) {
-    CHECK_EQ(frames.size(), 1)
+    CHECK_EQ(frames.size(), 1U)
         &lt;&lt; "frames size not equal to 1, actual frame size :" &lt;&lt; frames.size();
     int32_t n = 1;
     return Send(frames, &amp;n);
</diff>
			</file>
			<file old_path="modules\localization\msf\common\util\compression.cc" new_path="modules\localization\msf\common\util\compression.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -81,7 +81,7 @@ int ZlibStrategy::ZlibCompress(BufferStr* src, BufferStr* dst) {
       }
       out = &amp;((*dst)[dst_idx]);
     } while (stream_data.avail_out == 0);
-    DCHECK_EQ(stream_data.avail_in, 0); /* all input will be used */
+    DCHECK_EQ(stream_data.avail_in, 0U); /* all input will be used */
 
     /* done when last data in file processed */
   } while (flush != Z_FINISH);
</diff>
			</file>
			<file old_path="modules\localization\msf\local_map\base_map\base_map.cc" new_path="modules\localization\msf\local_map\base_map\base_map.cc" added_lines="4" deleted_lines="4">
				<diff>@@ -14,12 +14,13 @@
  * limitations under the License.
  *****************************************************************************/
 
+#include "modules/localization/msf/local_map/base_map/base_map.h"
+
 #include &lt;vector&gt;
 
 #include "cyber/common/log.h"
 #include "cyber/task/task.h"
 #include "modules/localization/msf/common/util/system_utility.h"
-#include "modules/localization/msf/local_map/base_map/base_map.h"
 
 namespace apollo {
 namespace localization {
@@ -117,7 +118,7 @@ void BaseMap::AddDataset(const std::string dataset_path) {
 }
 
 void BaseMap::LoadMapNodes(std::set&lt;MapNodeIndex&gt;* map_ids) {
-  CHECK_LE(static_cast&lt;int&gt;(map_ids-&gt;size()), map_node_cache_lvl1_-&gt;Capacity());
+  CHECK_LE(map_ids-&gt;size(), map_node_cache_lvl1_-&gt;Capacity());
   // check in cacheL1
   typename std::set&lt;MapNodeIndex&gt;::iterator itr = map_ids-&gt;begin();
   while (itr != map_ids-&gt;end()) {
@@ -184,8 +185,7 @@ void BaseMap::LoadMapNodes(std::set&lt;MapNodeIndex&gt;* map_ids) {
 }
 
 void BaseMap::PreloadMapNodes(std::set&lt;MapNodeIndex&gt;* map_ids) {
-  DCHECK_LE(static_cast&lt;int&gt;(map_ids-&gt;size()),
-            map_node_cache_lvl2_-&gt;Capacity());
+  DCHECK_LE(map_ids-&gt;size(), map_node_cache_lvl2_-&gt;Capacity());
   // check in cacheL2
   typename std::set&lt;MapNodeIndex&gt;::iterator itr = map_ids-&gt;begin();
   while (itr != map_ids-&gt;end()) {
</diff>
			</file>
			<file old_path="modules\localization\msf\local_map\lossless_map\lossless_map_matrix.h" new_path="modules\localization\msf\local_map\lossless_map\lossless_map_matrix.h" added_lines="1" deleted_lines="1">
				<diff>@@ -28,7 +28,7 @@ namespace msf {
 
 /**@brief The first layer (layer 0) includes all the intensities from any
  * layers. Other layers only include the samples from a layer. */
-#define IDL_CAR_NUM_RESERVED_MAP_LAYER 2
+#define IDL_CAR_NUM_RESERVED_MAP_LAYER 2U
 
 struct LosslessMapSingleCell {
   /**@brief The default constructor. */
</diff>
			</file>
			<file old_path="modules\map\hdmap\adapter\proto_organizer.cc" new_path="modules\map\hdmap\adapter\proto_organizer.cc" added_lines="7" deleted_lines="8">
				<diff>@@ -18,6 +18,7 @@ limitations under the License.
 #include &lt;unordered_set&gt;
 
 #include "absl/strings/str_cat.h"
+
 #include "cyber/common/log.h"
 #include "modules/common/math/polygon2d.h"
 #include "modules/common/math/vec2d.h"
@@ -74,7 +75,7 @@ void ProtoOrganizer::GetRoadElements(std::vector&lt;RoadInternal&gt;* roads) {
     for (auto&amp; traffic_light_internal : road_internal.traffic_lights) {
       auto&amp; traffic_light = traffic_light_internal.traffic_light;
       for (auto stop_line_id : traffic_light_internal.stop_line_ids) {
-        CHECK_GT(proto_data_.pb_stop_lines.count(stop_line_id), 0);
+        CHECK_GT(proto_data_.pb_stop_lines.count(stop_line_id), 0U);
         auto&amp; stop_line_curve = proto_data_.pb_stop_lines[stop_line_id].curve;
         (*traffic_light.add_stop_line()) = stop_line_curve;
       }
@@ -84,7 +85,7 @@ void ProtoOrganizer::GetRoadElements(std::vector&lt;RoadInternal&gt;* roads) {
     for (auto&amp; stop_sign_internal : road_internal.stop_signs) {
       auto&amp; stop_sign = stop_sign_internal.stop_sign;
       for (auto stop_line_id : stop_sign_internal.stop_line_ids) {
-        CHECK_GT(proto_data_.pb_stop_lines.count(stop_line_id), 0);
+        CHECK_GT(proto_data_.pb_stop_lines.count(stop_line_id), 0U);
         auto&amp; stop_line_curve = proto_data_.pb_stop_lines[stop_line_id].curve;
         (*stop_sign.add_stop_line()) = stop_line_curve;
       }
@@ -94,7 +95,7 @@ void ProtoOrganizer::GetRoadElements(std::vector&lt;RoadInternal&gt;* roads) {
     for (auto&amp; yield_sign_internal : road_internal.yield_signs) {
       auto&amp; yield_sign = yield_sign_internal.yield_sign;
       for (auto stop_line_id : yield_sign_internal.stop_line_ids) {
-        CHECK_GT(proto_data_.pb_stop_lines.count(stop_line_id), 0);
+        CHECK_GT(proto_data_.pb_stop_lines.count(stop_line_id), 0U);
         auto&amp; stop_line_curve = proto_data_.pb_stop_lines[stop_line_id].curve;
         (*yield_sign.add_stop_line()) = stop_line_curve;
       }
@@ -224,8 +225,7 @@ void ProtoOrganizer::GetLaneSignalOverlapElements(
           overlap_id);
     } else if (proto_data_.pb_rsus.count(object_id) &gt; 0) {
       object_overlap-&gt;mutable_rsu_overlap_info();
-      proto_data_.pb_rsus[object_id].add_overlap_id()-&gt;set_id(
-          overlap_id);
+      proto_data_.pb_rsus[object_id].add_overlap_id()-&gt;set_id(overlap_id);
     } else {
       AERROR &lt;&lt; "unknown signal, signal id:" &lt;&lt; object_id;
     }
@@ -349,10 +349,9 @@ void ProtoOrganizer::GetJunctionObjectOverlapElements(
       } else if (proto_data_.pb_signals.count(object_id) &gt; 0) {
         object_overlap-&gt;mutable_signal_overlap_info();
         proto_data_.pb_signals[object_id].add_overlap_id()-&gt;set_id(overlap_id);
-    } else if (proto_data_.pb_rsus.count(object_id) &gt; 0) {
+      } else if (proto_data_.pb_rsus.count(object_id) &gt; 0) {
         object_overlap-&gt;mutable_rsu_overlap_info();
-        proto_data_.pb_rsus[object_id].add_overlap_id()-&gt;set_id(
-          overlap_id);
+        proto_data_.pb_rsus[object_id].add_overlap_id()-&gt;set_id(overlap_id);
       } else {
         continue;
       }
</diff>
			</file>
			<file old_path="modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" new_path="modules\map\hdmap\adapter\xml_parser\lanes_xml_parser.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -50,7 +50,7 @@ Status LanesXmlParser::Parse(const tinyxml2::XMLElement&amp; xml_node,
     sub_node = sub_node-&gt;NextSiblingElement("laneSection");
   }
 
-  CHECK_GT(sections-&gt;size(), 0);
+  CHECK_NE(sections-&gt;size(), 0U);
 
   return Status::OK();
 }
</diff>
			</file>
			<file old_path="modules\map\hdmap\hdmap_common.cc" new_path="modules\map\hdmap\hdmap_common.cc" added_lines="4" deleted_lines="5">
				<diff>@@ -107,7 +107,7 @@ LaneInfo::LaneInfo(const Lane &amp;lane) : lane_(lane) { Init(); }
 
 void LaneInfo::Init() {
   PointsFromCurve(lane_.central_curve(), &amp;points_);
-  CHECK_GE(points_.size(), 2);
+  CHECK_GE(points_.size(), 2U);
   segments_.clear();
   accumulated_s_.clear();
   unit_directions_.clear();
@@ -212,7 +212,7 @@ double LaneInfo::Heading(const double s) const {
 }
 
 double LaneInfo::Curvature(const double s) const {
-  if (points_.size() &lt; 2) {
+  if (points_.size() &lt; 2U) {
     AERROR &lt;&lt; "Not enough points to compute curvature.";
     return 0.0;
   }
@@ -550,7 +550,7 @@ void SignalInfo::Init() {
     points.emplace_back(segment.start());
     points.emplace_back(segment.end());
   }
-  CHECK_GT(points.size(), 0);
+  CHECK_GT(points.size(), 0U);
 }
 
 CrosswalkInfo::CrosswalkInfo(const Crosswalk &amp;crosswalk)
@@ -688,8 +688,7 @@ void PNCJunctionInfo::Init() {
   }
 }
 
-RSUInfo::RSUInfo(const RSU&amp; rsu) : _rsu(rsu) {
-}
+RSUInfo::RSUInfo(const RSU &amp;rsu) : _rsu(rsu) {}
 
 }  // namespace hdmap
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\map\pnc_map\path.cc" new_path="modules\map\pnc_map\path.cc" added_lines="17" deleted_lines="13">
				<diff>@@ -22,6 +22,7 @@
 
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_join.h"
+
 #include "modules/common/math/line_segment2d.h"
 #include "modules/common/math/math_utils.h"
 #include "modules/common/math/polygon2d.h"
@@ -319,7 +320,7 @@ Path::Path(const std::vector&lt;LaneSegment&gt;&amp; segments)
     path_points_.insert(path_points_.end(), points.begin(), points.end());
   }
   MapPathPoint::RemoveDuplicates(&amp;path_points_);
-  CHECK_GE(path_points_.size(), 2);
+  CHECK_GE(path_points_.size(), 2U);
   Init();
 }
 
@@ -331,7 +332,7 @@ Path::Path(std::vector&lt;LaneSegment&gt;&amp;&amp; segments)
     path_points_.insert(path_points_.end(), points.begin(), points.end());
   }
   MapPathPoint::RemoveDuplicates(&amp;path_points_);
-  CHECK_GE(path_points_.size(), 2);
+  CHECK_GE(path_points_.size(), 2U);
   Init();
 }
 
@@ -385,9 +386,9 @@ void Path::InitPoints() {
   num_sample_points_ = static_cast&lt;int&gt;(length_ / kSampleDistance) + 1;
   num_segments_ = num_points_ - 1;
 
-  CHECK_EQ(accumulated_s_.size(), num_points_);
-  CHECK_EQ(unit_directions_.size(), num_points_);
-  CHECK_EQ(segments_.size(), num_segments_);
+  CHECK_EQ(accumulated_s_.size(), static_cast&lt;size_t&gt;(num_points_));
+  CHECK_EQ(unit_directions_.size(), static_cast&lt;size_t&gt;(num_points_));
+  CHECK_EQ(segments_.size(), static_cast&lt;size_t&gt;(num_segments_));
 }
 
 void Path::InitLaneSegments() {
@@ -421,7 +422,8 @@ void Path::InitLaneSegments() {
       lane_segments_to_next_point_.push_back(LaneSegment());
     }
   }
-  CHECK_EQ(lane_segments_to_next_point_.size(), num_segments_);
+  CHECK_EQ(lane_segments_to_next_point_.size(),
+           static_cast&lt;size_t&gt;(num_segments_));
 }
 
 void Path::InitWidth() {
@@ -464,11 +466,13 @@ void Path::InitWidth() {
     }
     s += kSampleDistance;
   }
-  CHECK_EQ(lane_left_width_.size(), num_sample_points_);
-  CHECK_EQ(lane_right_width_.size(), num_sample_points_);
 
-  CHECK_EQ(road_left_width_.size(), num_sample_points_);
-  CHECK_EQ(road_right_width_.size(), num_sample_points_);
+  auto num_sample_points = static_cast&lt;size_t&gt;(num_sample_points_);
+  CHECK_EQ(lane_left_width_.size(), num_sample_points);
+  CHECK_EQ(lane_right_width_.size(), num_sample_points);
+
+  CHECK_EQ(road_left_width_.size(), num_sample_points);
+  CHECK_EQ(road_right_width_.size(), num_sample_points);
 }
 
 void Path::InitPointIndex() {
@@ -484,7 +488,7 @@ void Path::InitPointIndex() {
     last_point_index_.push_back(last_index);
     s += kSampleDistance;
   }
-  CHECK_EQ(last_point_index_.size(), num_sample_points_);
+  CHECK_EQ(last_point_index_.size(), static_cast&lt;size_t&gt;(num_sample_points_));
 }
 
 void Path::GetAllOverlaps(GetOverlapFromLaneFunc GetOverlaps_from_lane,
@@ -652,7 +656,7 @@ InterpolatedIndex Path::GetLaneIndexFromS(double s) const {
   if (s &lt;= 0.0) {
     return {0, 0.0};
   }
-  CHECK_GT(lane_segments_.size(), 0);
+  CHECK_GT(lane_segments_.size(), 0U);
   if (s &gt;= length_) {
     return {static_cast&lt;int&gt;(lane_segments_.size() - 1),
             lane_segments_.back().Length()};
@@ -1081,7 +1085,7 @@ void PathApproximation::InitProjections(const Path&amp; path) {
     proj += kSampleDistance;
   }
   CHECK_EQ(sampled_max_original_projections_to_left_.size(),
-           num_projection_samples_);
+           static_cast&lt;size_t&gt;(num_projection_samples_));
 }
 
 bool PathApproximation::GetProjection(const Path&amp; path,
</diff>
			</file>
			<file old_path="modules\map\tools\sim_map_generator.cc" new_path="modules\map\tools\sim_map_generator.cc" added_lines="4" deleted_lines="3">
				<diff>@@ -14,16 +14,17 @@
  * limitations under the License.
  *****************************************************************************/
 
+#include "absl/strings/match.h"
 #include "gflags/gflags.h"
 
-#include "absl/strings/match.h"
+#include "modules/map/proto/map.pb.h"
+
 #include "cyber/common/file.h"
 #include "cyber/common/log.h"
 #include "modules/common/configs/config_gflags.h"
 #include "modules/common/util/points_downsampler.h"
 #include "modules/map/hdmap/adapter/opendrive_adapter.h"
 #include "modules/map/hdmap/hdmap_util.h"
-#include "modules/map/proto/map.pb.h"
 
 /**
  * A map tool to generate a downsampled map to be displayed by dreamview
@@ -70,7 +71,7 @@ static void DownsampleCurve(Curve* curve) {
     *line_segment-&gt;add_point() = downsampled_points[index];
   }
   size_t new_size = line_segment-&gt;point_size();
-  CHECK_GT(new_size, 1);
+  CHECK_GT(new_size, 1U);
 
   AINFO &lt;&lt; "Lane curve downsampled from " &lt;&lt; points.size() &lt;&lt; " points to "
         &lt;&lt; new_size &lt;&lt; " points.";
</diff>
			</file>
			<file old_path="modules\perception\base\blob.h" new_path="modules\perception\base\blob.h" added_lines="2" deleted_lines="2">
				<diff>@@ -76,7 +76,7 @@ namespace apollo {
 namespace perception {
 namespace base {
 
-const int kMaxBlobAxes = 32;
+constexpr size_t kMaxBlobAxes = 32;
 
 /**
  * @brief A wrapper around SyncedMemory holders serving as the basic
@@ -242,7 +242,7 @@ class Blob {
   }
 
   inline int offset(const std::vector&lt;int&gt;&amp; indices) const {
-    CHECK_LE(indices.size(), num_axes());
+    CHECK_LE(indices.size(), static_cast&lt;size_t&gt;(num_axes()));
     int offset = 0;
     for (int i = 0; i &lt; num_axes(); ++i) {
       offset *= shape(i);
</diff>
			</file>
			<file old_path="modules\perception\base\image_8u.h" new_path="modules\perception\base\image_8u.h" added_lines="1" deleted_lines="1">
				<diff>@@ -59,7 +59,7 @@ class Image8U {
     CHECK_EQ(blob_-&gt;num_axes(), 3);
     CHECK_EQ(blob_-&gt;shape(2), channels_);
     CHECK_LE(offset_ + blob_-&gt;offset({rows - 1, cols - 1, channels_ - 1}),
-             blob_-&gt;count());
+             (int)(blob_-&gt;count()));
     width_step_ = blob_-&gt;offset({1, 0, 0}) * static_cast&lt;int&gt;(sizeof(uint8_t));
   }
 
</diff>
			</file>
			<file old_path="modules\perception\camera\common\camera_ground_plane.cc" new_path="modules\perception\camera\common\camera_ground_plane.cc" added_lines="11" deleted_lines="11">
				<diff>@@ -30,10 +30,10 @@ void ConvertGround3ToGround4(const float &amp;baseline,
                              const std::vector&lt;float&gt; &amp;ground3,
                              std::vector&lt;float&gt; *ground4) {
   CHECK_GT(baseline, 0.0f);
-  CHECK_EQ(k_mat.size(), 9);
-  CHECK_EQ(ground3.size(), 3);
+  CHECK_EQ(k_mat.size(), 9U);
+  CHECK_EQ(ground3.size(), 3U);
   CHECK_NOTNULL(ground4);
-  CHECK_EQ(ground4-&gt;size(), 4);
+  CHECK_EQ(ground4-&gt;size(), 4U);
   const float &amp;b = baseline;
   const float &amp;fx = k_mat[0];
   const float &amp;fy = k_mat[4];
@@ -51,10 +51,10 @@ bool ConvertGround4ToGround3(const float &amp;baseline,
                              const std::vector&lt;float&gt; &amp;ground4,
                              std::vector&lt;float&gt; *ground3) {
   CHECK_GT(baseline, 0.0f);
-  CHECK_EQ(k_mat.size(), 9);
-  CHECK_EQ(ground4.size(), 4);
+  CHECK_EQ(k_mat.size(), 9U);
+  CHECK_EQ(ground4.size(), 4U);
   CHECK_NOTNULL(ground3);
-  CHECK_EQ(ground3-&gt;size(), 3);
+  CHECK_EQ(ground3-&gt;size(), 3U);
   // normalization
   float p[4] = {ground4[0], ground4[1], ground4[2], ground4[3]};
   float norm = common::ISqrt(common::ISquaresum3(p));
@@ -80,8 +80,8 @@ void GetGroundPlanePitchHeight(const float &amp;baseline,
                                const std::vector&lt;float&gt; &amp;ground3, float *pitch,
                                float *cam_height) {
   CHECK_GT(baseline, 0.0f);
-  CHECK_EQ(k_mat.size(), 9);
-  CHECK_EQ(ground3.size(), 3);
+  CHECK_EQ(k_mat.size(), 9U);
+  CHECK_EQ(ground3.size(), 3U);
   CHECK_NOTNULL(pitch);
   CHECK_NOTNULL(cam_height);
   std::vector&lt;float&gt; ground4(4, 0.0f);
@@ -99,11 +99,11 @@ void GetGround3FromPitchHeight(const std::vector&lt;float&gt; &amp;k_mat,
                                const float &amp;baseline, const float &amp;pitch,
                                const float &amp;cam_height,
                                std::vector&lt;float&gt; *ground3) {
-  CHECK_EQ(k_mat.size(), 9);
+  CHECK_EQ(k_mat.size(), 9U);
   CHECK_GT(baseline, 0.0f);
   CHECK_GT(cam_height, 0.0f);
   CHECK_NOTNULL(ground3);
-  CHECK_EQ(ground3-&gt;size(), 3);
+  CHECK_EQ(ground3-&gt;size(), 3U);
   float sin_pitch = static_cast&lt;float&gt;(sin(pitch));
   float cos_pitch = static_cast&lt;float&gt;(cos(pitch));
   std::vector&lt;float&gt; ground4 = {0, cos_pitch, -sin_pitch, -cam_height};
@@ -133,7 +133,7 @@ GroundPlaneTracker::GroundPlaneTracker(int track_length) {
 
 void GroundPlaneTracker::Push(const std::vector&lt;float&gt; &amp;ph,
                               const float &amp;inlier_ratio) {
-  CHECK_EQ(ph.size(), 2);
+  CHECK_EQ(ph.size(), 2U);
   int i = 0;
   int length = static_cast&lt;int&gt;(pitch_height_inlier_tracks_.size());
   if (head_ == 0) {
</diff>
			</file>
			<file old_path="modules\perception\camera\common\camera_ground_plane.h" new_path="modules\perception\camera\common\camera_ground_plane.h" added_lines="2" deleted_lines="2">
				<diff>@@ -109,7 +109,7 @@ class CameraGroundPlaneDetector {
 
   void Init(const std::vector&lt;float&gt; &amp;k_mat, int width, int height,
             float baseline, int max_nr_samples = 1080) {
-    CHECK_EQ(k_mat.size(), 9);
+    CHECK_EQ(k_mat.size(), 9U);
     memcpy(k_mat_, k_mat.data(), sizeof(float) * 9);
     width_ = width;
     height_ = height;
@@ -136,7 +136,7 @@ class CameraGroundPlaneDetector {
 
  private:
   void FillGroundModel(const std::vector&lt;float&gt; &amp;ground3) {
-    CHECK_EQ(ground3.size(), 3);
+    CHECK_EQ(ground3.size(), 3U);
     l_[0] = ground3[0];
     l_[1] = ground3[1];
     l_[2] = ground3[2];
</diff>
			</file>
			<file old_path="modules\perception\inference\utils\binary_data.cc" new_path="modules\perception\inference\utils\binary_data.cc" added_lines="7" deleted_lines="7">
				<diff>@@ -14,10 +14,11 @@
  * limitations under the License.
  *****************************************************************************/
 
+#include "modules/perception/inference/utils/binary_data.h"
+
 #include &lt;vector&gt;
 
 #include "cyber/common/log.h"
-#include "modules/perception/inference/utils/binary_data.h"
 
 namespace apollo {
 namespace perception {
@@ -59,16 +60,16 @@ std::shared_ptr&lt;base::Blob&lt;Dtype&gt;&gt; BinaryReadBlob(FILE *fp) {
 
   // read dtype
   size_t nmemb = BinaryReadString(fp, dtype);
-  CHECK_GT(nmemb, 0);
+  CHECK_GT(nmemb, 0U);
   CHECK_EQ(get_dtype(*blob), dtype);
 
   // read dims
   nmemb = fread(&amp;ndim, sizeof(ndim), 1, fp);
-  CHECK_EQ(nmemb, 1);
+  CHECK_EQ(nmemb, 1U);
   std::vector&lt;int&gt; shape(ndim);
   for (int i = 0; i &lt; ndim; ++i) {
     nmemb = fread(&amp;shape[i], sizeof(shape[i]), 1, fp);
-    CHECK_EQ(nmemb, 1);
+    CHECK_EQ(nmemb, 1U);
   }
   if (ndim == 0) {
     return blob;
@@ -80,7 +81,7 @@ std::shared_ptr&lt;base::Blob&lt;Dtype&gt;&gt; BinaryReadBlob(FILE *fp) {
 
   // read data
   nmemb = fread(blob-&gt;mutable_cpu_data(), sizeof(Dtype), blob-&gt;count(), fp);
-  CHECK_EQ(nmemb, blob-&gt;count());
+  CHECK_EQ(static_cast&lt;int&gt;(nmemb), blob-&gt;count());
 
   return blob;
 }
@@ -164,8 +165,7 @@ BinaryReadFile(const char *file_path);
 
 template bool BinaryWriteFile(
     const char *file_path,
-    const std::map&lt;std::string, std::shared_ptr&lt;base::Blob&lt;float&gt;&gt;&gt;
-        &amp;data_dict);
+    const std::map&lt;std::string, std::shared_ptr&lt;base::Blob&lt;float&gt;&gt;&gt; &amp;data_dict);
 template bool BinaryWriteFile(
     const char *file_path,
     const std::map&lt;std::string, std::shared_ptr&lt;base::Blob&lt;double&gt;&gt;&gt;
</diff>
			</file>
			<file old_path="modules\perception\inference\utils\binary_data.h" new_path="modules\perception\inference\utils\binary_data.h" added_lines="4" deleted_lines="4">
				<diff>@@ -15,10 +15,10 @@
  *****************************************************************************/
 #pragma once
 
+#include &lt;limits&gt;
 #include &lt;map&gt;
 #include &lt;memory&gt;
 #include &lt;string&gt;
-#include &lt;limits&gt;
 
 #include "modules/perception/base/blob.h"
 
@@ -26,9 +26,9 @@ namespace apollo {
 namespace perception {
 namespace inference {
 
-static const int kMaxStrLen = 64;
-static const int kMinDim = 1;
-static const int kMaxDim = std::numeric_limits&lt;int&gt;::max();
+constexpr size_t kMaxStrLen = 64;
+constexpr int kMinDim = 1;
+constexpr int kMaxDim = std::numeric_limits&lt;int&gt;::max();
 
 size_t BinaryReadString(FILE *fp, char *name);
 size_t BinaryWriteString(FILE *fp, const std::string &amp;str);
</diff>
			</file>
			<file old_path="modules\perception\lib\registerer\registerer.h" new_path="modules\perception\lib\registerer\registerer.h" added_lines="2" deleted_lines="2">
				<diff>@@ -123,13 +123,13 @@ bool GetRegisteredClasses(
     static const ::std::string GetUniqInstanceName() {                \
       FactoryMap &amp;map =                                               \
           ::apollo::perception::lib::GlobalFactoryMap()[#base_class]; \
-      CHECK_EQ(map.size(), 1) &lt;&lt; map.size();                          \
+      CHECK_EQ(map.size(), 1U) &lt;&lt; map.size();                         \
       return map.begin()-&gt;first;                                      \
     }                                                                 \
     static base_class *GetUniqInstance() {                            \
       FactoryMap &amp;map =                                               \
           ::apollo::perception::lib::GlobalFactoryMap()[#base_class]; \
-      CHECK_EQ(map.size(), 1) &lt;&lt; map.size();                          \
+      CHECK_EQ(map.size(), 1U) &lt;&lt; map.size();                         \
       Any object = map.begin()-&gt;second-&gt;NewInstance();                \
       return *(object.AnyCast&lt;base_class *&gt;());                       \
     }                                                                 \
</diff>
			</file>
			<file old_path="modules\planning\common\path\frenet_frame_path.cc" new_path="modules\planning\common\path\frenet_frame_path.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -71,7 +71,7 @@ FrenetFramePoint FrenetFramePath::GetNearestPoint(const SLBoundary&amp; sl) const {
 }
 
 FrenetFramePoint FrenetFramePath::EvaluateByS(const double s) const {
-  CHECK_GT(size(), 1);
+  CHECK_GT(size(), 1U);
   auto it_lower = std::lower_bound(begin(), end(), s, LowerBoundComparator);
   if (it_lower == begin()) {
     return front();
</diff>
			</file>
			<file old_path="modules\planning\common\speed\st_boundary.cc" new_path="modules\planning\common\speed\st_boundary.cc" added_lines="5" deleted_lines="5">
				<diff>@@ -300,7 +300,7 @@ STBoundary STBoundary::ExpandByT(const double t) const {
   }
 
   size_t length = lower_points_.size();
-  DCHECK_GE(length, 2);
+  DCHECK_GE(length, 2U);
 
   const double right_delta_t =
       lower_points_[length - 1].t() - lower_points_[length - 2].t();
@@ -426,10 +426,10 @@ bool STBoundary::IsValid(
       if (std::fmax(curr_lower.t(), curr_upper.t()) + kMinDeltaT &gt;=
           std::fmin(next_lower.t(), next_upper.t())) {
         AERROR &lt;&lt; "Latter points should have larger t: "
-               &lt;&lt; "curr_lower[" &lt;&lt; curr_lower.DebugString()
-               &lt;&lt; "] curr_upper[" &lt;&lt; curr_upper.DebugString()
-               &lt;&lt; "] next_lower[" &lt;&lt; next_lower.DebugString()
-               &lt;&lt; "] next_upper[" &lt;&lt; next_upper.DebugString() &lt;&lt; "]";
+               &lt;&lt; "curr_lower[" &lt;&lt; curr_lower.DebugString() &lt;&lt; "] curr_upper["
+               &lt;&lt; curr_upper.DebugString() &lt;&lt; "] next_lower["
+               &lt;&lt; next_lower.DebugString() &lt;&lt; "] next_upper["
+               &lt;&lt; next_upper.DebugString() &lt;&lt; "]";
         return false;
       }
     }
</diff>
			</file>
			<file old_path="modules\planning\common\speed_limit.cc" new_path="modules\planning\common\speed_limit.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -40,7 +40,7 @@ const std::vector&lt;std::pair&lt;double, double&gt;&gt;&amp; SpeedLimit::speed_limit_points()
 }
 
 double SpeedLimit::GetSpeedLimitByS(const double s) const {
-  CHECK_GE(speed_limit_points_.size(), 2);
+  CHECK_GE(speed_limit_points_.size(), 2U);
   DCHECK_GE(s, speed_limit_points_.front().first);
 
   auto compare_s = [](const std::pair&lt;double, double&gt;&amp; point, const double s) {
</diff>
			</file>
			<file old_path="modules\planning\common\trajectory1d\piecewise_acceleration_trajectory1d.cc" new_path="modules\planning\common\trajectory1d\piecewise_acceleration_trajectory1d.cc" added_lines="4" deleted_lines="3">
				<diff>@@ -24,6 +24,7 @@
 
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_join.h"
+
 #include "cyber/common/log.h"
 #include "modules/common/math/linear_interpolation.h"
 #include "modules/planning/common/planning_gflags.h"
@@ -70,7 +71,7 @@ void PiecewiseAccelerationTrajectory1d::PopSegment() {
 }
 
 double PiecewiseAccelerationTrajectory1d::ParamLength() const {
-  CHECK_GT(t_.size(), 1);
+  CHECK_GT(t_.size(), 1U);
   return t_.back() - t_.front();
 }
 
@@ -81,7 +82,7 @@ std::string PiecewiseAccelerationTrajectory1d::ToString() const {
 
 double PiecewiseAccelerationTrajectory1d::Evaluate(const std::uint32_t order,
                                                    const double param) const {
-  CHECK_GT(t_.size(), 1);
+  CHECK_GT(t_.size(), 1U);
   ACHECK(t_.front() &lt;= param &amp;&amp; param &lt;= t_.back());
 
   switch (order) {
@@ -139,7 +140,7 @@ double PiecewiseAccelerationTrajectory1d::Evaluate_j(const double t) const {
 
 std::array&lt;double, 4&gt; PiecewiseAccelerationTrajectory1d::Evaluate(
     const double t) const {
-  CHECK_GT(t_.size(), 1);
+  CHECK_GT(t_.size(), 1U);
   ACHECK(t_.front() &lt;= t &amp;&amp; t &lt;= t_.back());
 
   auto it_lower = std::lower_bound(t_.begin(), t_.end(), t);
</diff>
			</file>
			<file old_path="modules\planning\lattice\trajectory_generation\end_condition_sampler.cc" new_path="modules\planning\lattice\trajectory_generation\end_condition_sampler.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -57,7 +57,7 @@ std::vector&lt;Condition&gt; EndConditionSampler::SampleLatEndConditions() const {
 
 std::vector&lt;Condition&gt; EndConditionSampler::SampleLonEndConditionsForCruising(
     const double ref_cruise_speed) const {
-  CHECK_GT(FLAGS_num_velocity_sample, 1);
+  CHECK_GT(FLAGS_num_velocity_sample, 1U);
 
   // time interval is one second plus the last one 0.01
   static constexpr size_t num_of_time_samples = 9;
@@ -168,7 +168,7 @@ void EndConditionSampler::QueryFollowPathTimePoints(
     double s_upper = path_time_point.s() -
                      vehicle_config.vehicle_param().front_edge_to_center();
     double s_lower = s_upper - FLAGS_default_lon_buffer;
-    CHECK_GE(FLAGS_num_sample_follow_per_timestamp, 2);
+    CHECK_GE(FLAGS_num_sample_follow_per_timestamp, 2U);
     double s_gap =
         FLAGS_default_lon_buffer /
         static_cast&lt;double&gt;(FLAGS_num_sample_follow_per_timestamp - 1);
</diff>
			</file>
			<file old_path="modules\planning\lattice\trajectory_generation\trajectory_evaluator.cc" new_path="modules\planning\lattice\trajectory_generation\trajectory_evaluator.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -339,7 +339,7 @@ std::vector&lt;double&gt; TrajectoryEvaluator::ComputeLongitudinalGuideVelocity(
 
 bool TrajectoryEvaluator::InterpolateDenseStPoints(
     const std::vector&lt;SpeedPoint&gt;&amp; st_points, double t, double* traj_s) const {
-  CHECK_GT(st_points.size(), 1);
+  CHECK_GT(st_points.size(), 1U);
   if (t &lt; st_points[0].t() || t &gt; st_points[st_points.size() - 1].t()) {
     AERROR &lt;&lt; "AutoTuning InterpolateDenseStPoints Error";
     return false;
</diff>
			</file>
			<file old_path="modules\planning\math\curve1d\cubic_polynomial_curve1d.cc" new_path="modules\planning\math\curve1d\cubic_polynomial_curve1d.cc" added_lines="3" deleted_lines="2">
				<diff>@@ -22,6 +22,7 @@
 
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_join.h"
+
 #include "cyber/common/log.h"
 
 namespace apollo {
@@ -46,7 +47,7 @@ CubicPolynomialCurve1d::CubicPolynomialCurve1d(const double x0,
 
 void CubicPolynomialCurve1d::DerivedFromQuarticCurve(
     const PolynomialCurve1d&amp; other) {
-  CHECK_EQ(other.Order(), 4);
+  CHECK_EQ(other.Order(), 4U);
   param_ = other.ParamLength();
   for (size_t i = 1; i &lt; 5; ++i) {
     coef_[i - 1] = other.Coef(i) * static_cast&lt;double&gt;(i);
@@ -92,7 +93,7 @@ void CubicPolynomialCurve1d::ComputeCoefficients(const double x0,
 }
 
 double CubicPolynomialCurve1d::Coef(const size_t order) const {
-  CHECK_GT(4, order);
+  CHECK_GT(4U, order);
   return coef_[order];
 }
 
</diff>
			</file>
			<file old_path="modules\planning\math\curve1d\quartic_polynomial_curve1d.cc" new_path="modules\planning\math\curve1d\quartic_polynomial_curve1d.cc" added_lines="4" deleted_lines="3">
				<diff>@@ -22,6 +22,7 @@
 
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_join.h"
+
 #include "cyber/common/log.h"
 
 namespace apollo {
@@ -130,7 +131,7 @@ QuarticPolynomialCurve1d&amp; QuarticPolynomialCurve1d::FitWithEndPointSecondOrder(
 
 QuarticPolynomialCurve1d&amp; QuarticPolynomialCurve1d::IntegratedFromCubicCurve(
     const PolynomialCurve1d&amp; other, const double init_value) {
-  CHECK_EQ(other.Order(), 3);
+  CHECK_EQ(other.Order(), 3U);
   param_ = other.ParamLength();
   coef_[0] = init_value;
   for (size_t i = 0; i &lt; 4; ++i) {
@@ -141,7 +142,7 @@ QuarticPolynomialCurve1d&amp; QuarticPolynomialCurve1d::IntegratedFromCubicCurve(
 
 QuarticPolynomialCurve1d&amp; QuarticPolynomialCurve1d::DerivedFromQuinticCurve(
     const PolynomialCurve1d&amp; other) {
-  CHECK_EQ(other.Order(), 5);
+  CHECK_EQ(other.Order(), 5U);
   param_ = other.ParamLength();
   for (size_t i = 1; i &lt; 6; ++i) {
     coef_[i - 1] = other.Coef(i) * static_cast&lt;double&gt;(i);
@@ -173,7 +174,7 @@ std::string QuarticPolynomialCurve1d::ToString() const {
 }
 
 double QuarticPolynomialCurve1d::Coef(const size_t order) const {
-  CHECK_GT(5, order);
+  CHECK_GT(5U, order);
   return coef_[order];
 }
 
</diff>
			</file>
			<file old_path="modules\planning\math\curve1d\quintic_polynomial_curve1d.cc" new_path="modules\planning\math\curve1d\quintic_polynomial_curve1d.cc" added_lines="3" deleted_lines="2">
				<diff>@@ -22,6 +22,7 @@
 
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_join.h"
+
 #include "cyber/common/log.h"
 
 namespace apollo {
@@ -96,7 +97,7 @@ void QuinticPolynomialCurve1d::SetParam(const double x0, const double dx0,
 
 void QuinticPolynomialCurve1d::IntegratedFromQuarticCurve(
     const PolynomialCurve1d&amp; other, const double init_value) {
-  CHECK_EQ(other.Order(), 4);
+  CHECK_EQ(other.Order(), 4U);
   param_ = other.ParamLength();
   coef_[0] = init_value;
   for (size_t i = 0; i &lt; 5; ++i) {
@@ -132,7 +133,7 @@ std::string QuinticPolynomialCurve1d::ToString() const {
 }
 
 double QuinticPolynomialCurve1d::Coef(const size_t order) const {
-  CHECK_GT(6, order);
+  CHECK_GT(6U, order);
   return coef_[order];
 }
 }  // namespace planning
</diff>
			</file>
			<file old_path="modules\planning\math\discretized_points_smoothing\cos_theta_ipopt_interface.cc" new_path="modules\planning\math\discretized_points_smoothing\cos_theta_ipopt_interface.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -28,8 +28,8 @@ namespace planning {
 
 CosThetaIpoptInterface::CosThetaIpoptInterface(
     std::vector&lt;std::pair&lt;double, double&gt;&gt; points, std::vector&lt;double&gt; bounds) {
-  CHECK_GT(points.size(), 1);
-  CHECK_GT(bounds.size(), 1);
+  CHECK_GT(points.size(), 1U);
+  CHECK_GT(bounds.size(), 1U);
   bounds_ = std::move(bounds);
   ref_points_ = std::move(points);
   num_of_points_ = ref_points_.size();
@@ -352,7 +352,7 @@ bool CosThetaIpoptInterface::eval_h(int n, const double* x, bool new_x,
         shift += 2;
       }
     }
-    CHECK_EQ(index, static_cast&lt;size_t&gt;(nele_hess));
+    CHECK_EQ(index, nele_hess);
   } else {
     std::fill(values, values + nele_hess, 0.0);
     // fill the included angle part of obj
</diff>
			</file>
			<file old_path="modules\planning\math\discretized_points_smoothing\fem_pos_deviation_ipopt_interface.cc" new_path="modules\planning\math\discretized_points_smoothing\fem_pos_deviation_ipopt_interface.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -27,8 +27,8 @@ namespace planning {
 
 FemPosDeviationIpoptInterface::FemPosDeviationIpoptInterface(
     std::vector&lt;std::pair&lt;double, double&gt;&gt; points, std::vector&lt;double&gt; bounds) {
-  CHECK_GT(points.size(), 1);
-  CHECK_GT(bounds.size(), 1);
+  CHECK_GT(points.size(), 1U);
+  CHECK_GT(bounds.size(), 1U);
   bounds_around_refs_ = std::move(bounds);
   ref_points_ = std::move(points);
   num_of_points_ = ref_points_.size();
@@ -43,7 +43,7 @@ void FemPosDeviationIpoptInterface::get_optimization_results(
 bool FemPosDeviationIpoptInterface::get_nlp_info(int&amp; n, int&amp; m, int&amp; nnz_jac_g,
                                                  int&amp; nnz_h_lag,
                                                  IndexStyleEnum&amp; index_style) {
-  CHECK_GT(num_of_points_, 3);
+  CHECK_GT(num_of_points_, 3U);
   // Number of variables
   // Variables include 2D points and curvature constraints slack variable
   num_of_slack_var_ = num_of_points_ - 2;
</diff>
			</file>
			<file old_path="modules\planning\math\discretized_points_smoothing\fem_pos_deviation_osqp_interface.cc" new_path="modules\planning\math\discretized_points_smoothing\fem_pos_deviation_osqp_interface.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -256,7 +256,7 @@ void FemPosDeviationOsqpInterface::CalculateAffineConstraint(
 
 void FemPosDeviationOsqpInterface::SetPrimalWarmStart(
     std::vector&lt;c_float&gt;* primal_warm_start) {
-  CHECK_EQ(ref_points_.size(), num_of_points_);
+  CHECK_EQ(ref_points_.size(), static_cast&lt;size_t&gt;(num_of_points_));
   for (const auto&amp; ref_point_xy : ref_points_) {
     primal_warm_start-&gt;push_back(ref_point_xy.first);
     primal_warm_start-&gt;push_back(ref_point_xy.second);
</diff>
			</file>
			<file old_path="modules\planning\math\discretized_points_smoothing\fem_pos_deviation_sqp_osqp_interface.cc" new_path="modules\planning\math\discretized_points_smoothing\fem_pos_deviation_sqp_osqp_interface.cc" added_lines="4" deleted_lines="4">
				<diff>@@ -338,7 +338,7 @@ void FemPosDeviationSqpOsqpInterface::CalculateOffset(std::vector&lt;c_float&gt;* q) {
 std::vector&lt;double&gt;
 FemPosDeviationSqpOsqpInterface::CalculateLinearizedFemPosParams(
     const std::vector&lt;std::pair&lt;double, double&gt;&gt;&amp; points, const size_t index) {
-  CHECK_GT(index, 0);
+  CHECK_GT(index, 0U);
   CHECK_LT(index, points.size() - 1);
 
   double x_f = points[index - 1].first;
@@ -452,8 +452,8 @@ void FemPosDeviationSqpOsqpInterface::CalculateAffineConstraint(
 void FemPosDeviationSqpOsqpInterface::SetPrimalWarmStart(
     const std::vector&lt;std::pair&lt;double, double&gt;&gt;&amp; points,
     std::vector&lt;c_float&gt;* primal_warm_start) {
-  CHECK_EQ(points.size(), num_of_points_);
-  CHECK_GT(points.size(), 1);
+  CHECK_EQ(points.size(), static_cast&lt;size_t&gt;(num_of_points_));
+  CHECK_GT(points.size(), 1U);
 
   // Set states
   primal_warm_start-&gt;resize(num_of_variables_);
@@ -518,7 +518,7 @@ bool FemPosDeviationSqpOsqpInterface::OptimizeWithOsqp(
 
 double FemPosDeviationSqpOsqpInterface::CalculateConstraintViolation(
     const std::vector&lt;std::pair&lt;double, double&gt;&gt;&amp; points) {
-  CHECK_GT(points.size(), 2);
+  CHECK_GT(points.size(), 2U);
 
   double total_length = 0.0;
   auto pre_point = points.front();
</diff>
			</file>
			<file old_path="modules\planning\math\piecewise_jerk\piecewise_jerk_problem.cc" new_path="modules\planning\math\piecewise_jerk\piecewise_jerk_problem.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -29,7 +29,7 @@ constexpr double kMaxVariableRange = 1.0e10;
 PiecewiseJerkProblem::PiecewiseJerkProblem(
     const size_t num_of_knots, const double delta_s,
     const std::array&lt;double, 3&gt;&amp; x_init) {
-  CHECK_GE(num_of_knots, 2);
+  CHECK_GE(num_of_knots, 2U);
   num_of_knots_ = num_of_knots;
 
   x_init_ = x_init;
</diff>
			</file>
			<file old_path="modules\planning\math\polynomial_xd.cc" new_path="modules\planning\math\polynomial_xd.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -27,7 +27,7 @@ namespace planning {
 
 PolynomialXd::PolynomialXd(const std::uint32_t order)
     : params_(order + 1, 0.0) {
-  CHECK_GE(order, 0);
+  CHECK_GE(order, 0U);
 }
 
 PolynomialXd::PolynomialXd(const std::vector&lt;double&gt;&amp; params)
</diff>
			</file>
			<file old_path="modules\planning\navi\decider\navi_speed_decider.cc" new_path="modules\planning\navi\decider\navi_speed_decider.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -251,7 +251,7 @@ Status NaviSpeedDecider::MakeSpeedDecision(
     const std::function&lt;const Obstacle*(const std::string&amp;)&gt;&amp; find_obstacle,
     SpeedData* const speed_data) {
   CHECK_NOTNULL(speed_data);
-  CHECK_GE(path_points.size(), 2);
+  CHECK_GE(path_points.size(), 2U);
 
   auto start_s = path_points.front().has_s() ? path_points.front().s() : 0.0;
   auto end_s = path_points.back().has_s() ? path_points.back().s() : start_s;
</diff>
			</file>
			<file old_path="modules\planning\open_space\coarse_trajectory_generator\hybrid_a_star.cc" new_path="modules\planning\open_space\coarse_trajectory_generator\hybrid_a_star.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -84,7 +84,7 @@ bool HybridAStar::RSPCheck(
 
 bool HybridAStar::ValidityCheck(std::shared_ptr&lt;Node3d&gt; node) {
   CHECK_NOTNULL(node);
-  CHECK_GT(node-&gt;GetStepSize(), 0);
+  CHECK_GT(node-&gt;GetStepSize(), 0U);
 
   if (obstacles_linesegments_vec_.empty()) {
     return true;
</diff>
			</file>
			<file old_path="modules\planning\open_space\coarse_trajectory_generator\node3d.cc" new_path="modules\planning\open_space\coarse_trajectory_generator\node3d.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -36,7 +36,7 @@ Node3d::Node3d(double x, double y, double phi) {
 Node3d::Node3d(double x, double y, double phi,
                const std::vector&lt;double&gt;&amp; XYbounds,
                const PlannerOpenSpaceConfig&amp; open_space_conf) {
-  CHECK_EQ(XYbounds.size(), 4)
+  CHECK_EQ(XYbounds.size(), 4U)
       &lt;&lt; "XYbounds size is not 4, but" &lt;&lt; XYbounds.size();
 
   x_ = x;
@@ -65,7 +65,7 @@ Node3d::Node3d(const std::vector&lt;double&gt;&amp; traversed_x,
                const std::vector&lt;double&gt;&amp; traversed_phi,
                const std::vector&lt;double&gt;&amp; XYbounds,
                const PlannerOpenSpaceConfig&amp; open_space_conf) {
-  CHECK_EQ(XYbounds.size(), 4)
+  CHECK_EQ(XYbounds.size(), 4U)
       &lt;&lt; "XYbounds size is not 4, but" &lt;&lt; XYbounds.size();
   CHECK_EQ(traversed_x.size(), traversed_y.size());
   CHECK_EQ(traversed_x.size(), traversed_phi.size());
</diff>
			</file>
			<file old_path="modules\planning\open_space\trajectory_smoother\dual_variable_warm_start_osqp_interface.cc" new_path="modules\planning\open_space\trajectory_smoother\dual_variable_warm_start_osqp_interface.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -350,13 +350,13 @@ void DualVariableWarmStartOSQPInterface::assemble_P(
     }
   }
 
-  CHECK_EQ(P_indptr-&gt;size(), lambda_horizon_);
+  CHECK_EQ(P_indptr-&gt;size(), static_cast&lt;size_t&gt;(lambda_horizon_));
   for (int i = lambda_horizon_; i &lt; num_of_variables_ + 1; ++i) {
     P_indptr-&gt;emplace_back(first_row_location);
   }
 
   CHECK_EQ(P_data-&gt;size(), P_indices-&gt;size());
-  CHECK_EQ(P_indptr-&gt;size(), num_of_variables_ + 1);
+  CHECK_EQ(P_indptr-&gt;size(), static_cast&lt;size_t&gt;(num_of_variables_) + 1);
 }
 
 void DualVariableWarmStartOSQPInterface::assemble_constraint(
@@ -465,7 +465,7 @@ void DualVariableWarmStartOSQPInterface::assemble_constraint(
   A_indptr-&gt;emplace_back(first_row_location);
 
   CHECK_EQ(A_data-&gt;size(), A_indices-&gt;size());
-  CHECK_EQ(A_indptr-&gt;size(), num_of_variables_ + 1);
+  CHECK_EQ(A_indptr-&gt;size(), static_cast&lt;size_t&gt;(num_of_variables_) + 1);
 }
 
 void DualVariableWarmStartOSQPInterface::get_optimization_results(
</diff>
			</file>
			<file old_path="modules\planning\open_space\trajectory_smoother\dual_variable_warm_start_slack_osqp_interface.cc" new_path="modules\planning\open_space\trajectory_smoother\dual_variable_warm_start_slack_osqp_interface.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -361,13 +361,13 @@ void DualVariableWarmStartSlackOSQPInterface::assembleP(
     }
   }
 
-  CHECK_EQ(P_indptr-&gt;size(), lambda_horizon_);
+  CHECK_EQ(P_indptr-&gt;size(), static_cast&lt;size_t&gt;(lambda_horizon_));
   for (int i = lambda_horizon_; i &lt; num_of_variables_ + 1; ++i) {
     P_indptr-&gt;emplace_back(first_row_location);
   }
 
   CHECK_EQ(P_data-&gt;size(), P_indices-&gt;size());
-  CHECK_EQ(P_indptr-&gt;size(), num_of_variables_ + 1);
+  CHECK_EQ(P_indptr-&gt;size(), static_cast&lt;size_t&gt;(num_of_variables_) + 1);
 }
 
 void DualVariableWarmStartSlackOSQPInterface::assembleConstraint(
@@ -497,7 +497,7 @@ void DualVariableWarmStartSlackOSQPInterface::assembleConstraint(
   A_indptr-&gt;emplace_back(first_row_location);
 
   CHECK_EQ(A_data-&gt;size(), A_indices-&gt;size());
-  CHECK_EQ(A_indptr-&gt;size(), num_of_variables_ + 1);
+  CHECK_EQ(A_indptr-&gt;size(), static_cast&lt;size_t&gt;(num_of_variables_) + 1);
 }
 
 void DualVariableWarmStartSlackOSQPInterface::get_optimization_results(
</diff>
			</file>
			<file old_path="modules\planning\open_space\trajectory_smoother\iterative_anchoring_smoother.cc" new_path="modules\planning\open_space\trajectory_smoother\iterative_anchoring_smoother.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -213,7 +213,7 @@ void IterativeAnchoringSmoother::AdjustStartEndHeading(
   // Sanity check
   CHECK_NOTNULL(point2d);
   CHECK_GT(xWS.cols(), 1);
-  CHECK_GT(point2d-&gt;size(), 3);
+  CHECK_GT(point2d-&gt;size(), 3U);
 
   // Set initial heading and bounds
   const double initial_heading = xWS(2, 0);
@@ -798,7 +798,7 @@ bool IterativeAnchoringSmoother::IsValidPolynomialProfile(
 
 double IterativeAnchoringSmoother::CalcHeadings(
     const DiscretizedPath&amp; path_points, const size_t index) {
-  CHECK_GT(path_points.size(), 2);
+  CHECK_GT(path_points.size(), 2U);
   double dx = 0.0;
   double dy = 0.0;
   if (index == 0) {
</diff>
			</file>
			<file old_path="modules\planning\reference_line\discrete_points_reference_line_smoother.cc" new_path="modules\planning\reference_line\discrete_points_reference_line_smoother.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -175,7 +175,7 @@ bool DiscretePointsReferenceLineSmoother::FemPosSmooth(
 
 void DiscretePointsReferenceLineSmoother::SetAnchorPoints(
     const std::vector&lt;AnchorPoint&gt;&amp; anchor_points) {
-  CHECK_GT(anchor_points.size(), 1);
+  CHECK_GT(anchor_points.size(), 1U);
   anchor_points_ = anchor_points;
 }
 
</diff>
			</file>
			<file old_path="modules\planning\reference_line\qp_spline_reference_line_smoother.cc" new_path="modules\planning\reference_line\qp_spline_reference_line_smoother.cc" added_lines="3" deleted_lines="2">
				<diff>@@ -22,9 +22,10 @@
 #include &lt;algorithm&gt;
 #include &lt;utility&gt;
 
+#include "modules/common/proto/pnc_point.pb.h"
+
 #include "cyber/common/log.h"
 #include "modules/common/math/vec2d.h"
-#include "modules/common/proto/pnc_point.pb.h"
 #include "modules/common/util/util.h"
 #include "modules/planning/common/planning_gflags.h"
 #include "modules/planning/math/curve_math.h"
@@ -205,7 +206,7 @@ bool QpSplineReferenceLineSmoother::Solve() { return spline_solver_-&gt;Solve(); }
 
 void QpSplineReferenceLineSmoother::SetAnchorPoints(
     const std::vector&lt;AnchorPoint&gt;&amp; anchor_points) {
-  CHECK_GE(anchor_points.size(), 2);
+  CHECK_GE(anchor_points.size(), 2U);
   anchor_points_ = anchor_points;
 }
 
</diff>
			</file>
			<file old_path="modules\planning\reference_line\reference_line.cc" new_path="modules\planning\reference_line\reference_line.cc" added_lines="6" deleted_lines="3">
				<diff>@@ -27,6 +27,7 @@
 #include "absl/strings/str_cat.h"
 #include "absl/strings/str_join.h"
 #include "boost/math/tools/minima.hpp"
+
 #include "cyber/common/log.h"
 #include "modules/common/math/angle.h"
 #include "modules/common/math/cartesian_frenet_conversion.h"
@@ -52,7 +53,8 @@ ReferenceLine::ReferenceLine(
     : reference_points_(reference_points),
       map_path_(std::move(std::vector&lt;hdmap::MapPathPoint&gt;(
           reference_points.begin(), reference_points.end()))) {
-  CHECK_EQ(map_path_.num_points(), reference_points_.size());
+  CHECK_EQ(static_cast&lt;size_t&gt;(map_path_.num_points()),
+           reference_points_.size());
 }
 
 ReferenceLine::ReferenceLine(const MapPath&amp; hdmap_path)
@@ -63,7 +65,8 @@ ReferenceLine::ReferenceLine(const MapPath&amp; hdmap_path)
     reference_points_.emplace_back(
         hdmap::MapPathPoint(point, point.heading(), lane_waypoint), 0.0, 0.0);
   }
-  CHECK_EQ(map_path_.num_points(), reference_points_.size());
+  CHECK_EQ(static_cast&lt;size_t&gt;(map_path_.num_points()),
+           reference_points_.size());
 }
 
 bool ReferenceLine::Stitch(const ReferenceLine&amp; other) {
@@ -335,7 +338,7 @@ double ReferenceLine::FindMinDistancePoint(const ReferencePoint&amp; p0,
 
 ReferencePoint ReferenceLine::GetReferencePoint(const double x,
                                                 const double y) const {
-  CHECK_GE(reference_points_.size(), 0);
+  CHECK_GE(reference_points_.size(), 0U);
 
   auto func_distance_square = [](const ReferencePoint&amp; point, const double x,
                                  const double y) {
</diff>
			</file>
			<file old_path="modules\planning\reference_line\spiral_reference_line_smoother.cc" new_path="modules\planning\reference_line\spiral_reference_line_smoother.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -182,7 +182,7 @@ int SpiralReferenceLineSmoother::SmoothStandAlone(
     std::vector&lt;double&gt;* ptr_kappa, std::vector&lt;double&gt;* ptr_dkappa,
     std::vector&lt;double&gt;* ptr_s, std::vector&lt;double&gt;* ptr_x,
     std::vector&lt;double&gt;* ptr_y) const {
-  CHECK_GT(point2d.size(), 1);
+  CHECK_GT(point2d.size(), 1U);
 
   SpiralProblemInterface* ptop = new SpiralProblemInterface(point2d);
 
@@ -240,7 +240,7 @@ bool SpiralReferenceLineSmoother::Smooth(std::vector&lt;Eigen::Vector2d&gt; point2d,
                                          std::vector&lt;double&gt;* ptr_s,
                                          std::vector&lt;double&gt;* ptr_x,
                                          std::vector&lt;double&gt;* ptr_y) const {
-  CHECK_GT(point2d.size(), 1);
+  CHECK_GT(point2d.size(), 1U);
 
   SpiralProblemInterface* ptop = new SpiralProblemInterface(point2d);
 
@@ -373,7 +373,7 @@ void SpiralReferenceLineSmoother::SetAnchorPoints(
     const std::vector&lt;AnchorPoint&gt;&amp; anchor_points) {
   anchor_points_ = std::move(anchor_points);
 
-  CHECK_GT(anchor_points_.size(), 1);
+  CHECK_GT(anchor_points_.size(), 1U);
   zero_x_ = anchor_points_.front().path_point.x();
   zero_y_ = anchor_points_.front().path_point.y();
 
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -1451,7 +1451,7 @@ bool OpenSpaceRoiDecider::LoadObstacleInVertices(
   Eigen::MatrixXi parking_boundaries_obstacles_edges_num(parking_boundaries_num,
                                                          1);
   for (size_t i = 0; i &lt; parking_boundaries_num; i++) {
-    CHECK_GT(roi_parking_boundary[i].size(), 1);
+    CHECK_GT(roi_parking_boundary[i].size(), 1U);
     parking_boundaries_obstacles_edges_num(i, 0) =
         static_cast&lt;int&gt;(roi_parking_boundary[i].size()) - 1;
   }
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\speed_bounds_decider\st_boundary_mapper.cc" new_path="modules\planning\tasks\deciders\speed_bounds_decider\st_boundary_mapper.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -25,18 +25,19 @@
 #include &lt;memory&gt;
 #include &lt;utility&gt;
 
+#include "modules/common/proto/pnc_point.pb.h"
+#include "modules/planning/proto/decision.pb.h"
+
 #include "cyber/common/log.h"
 #include "modules/common/configs/vehicle_config_helper.h"
 #include "modules/common/math/line_segment2d.h"
 #include "modules/common/math/vec2d.h"
-#include "modules/common/proto/pnc_point.pb.h"
 #include "modules/common/util/string_util.h"
 #include "modules/common/util/util.h"
 #include "modules/common/vehicle_state/vehicle_state_provider.h"
 #include "modules/planning/common/frame.h"
 #include "modules/planning/common/planning_context.h"
 #include "modules/planning/common/planning_gflags.h"
-#include "modules/planning/proto/decision.pb.h"
 
 namespace apollo {
 namespace planning {
@@ -194,7 +195,6 @@ bool STBoundaryMapper::GetOverlapBoundaryPoints(
   // Sanity checks.
   DCHECK(upper_points-&gt;empty());
   DCHECK(lower_points-&gt;empty());
-  DCHECK_GT(path_points.size(), 0);
   if (path_points.empty()) {
     AERROR &lt;&lt; "No points in path_data_.discretized_path().";
     return false;
</diff>
			</file>
			<file old_path="modules\planning\tasks\optimizers\open_space_trajectory_generation\open_space_trajectory_optimizer.cc" new_path="modules\planning\tasks\optimizers\open_space_trajectory_generation\open_space_trajectory_optimizer.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -430,7 +430,7 @@ bool OpenSpaceTrajectoryOptimizer::IsInitPointNearDestination(
     const common::TrajectoryPoint&amp; planning_init_point,
     const std::vector&lt;double&gt;&amp; end_pose, double rotate_angle,
     const Vec2d&amp; translate_origin) {
-  CHECK_EQ(end_pose.size(), 4);
+  CHECK_EQ(end_pose.size(), 4U);
   Vec2d end_pose_to_world_frame = Vec2d(end_pose[0], end_pose[1]);
 
   end_pose_to_world_frame.SelfRotate(rotate_angle);
@@ -857,7 +857,7 @@ void OpenSpaceTrajectoryOptimizer::LoadResult(
     Eigen::MatrixXd* state_result_dc, Eigen::MatrixXd* control_result_dc,
     Eigen::MatrixXd* time_result_dc) {
   const size_t points_size = discretized_trajectory.size();
-  CHECK_GT(points_size, 1);
+  CHECK_GT(points_size, 1U);
   *state_result_dc = Eigen::MatrixXd::Zero(4, points_size);
   *control_result_dc = Eigen::MatrixXd::Zero(2, points_size - 1);
   *time_result_dc = Eigen::MatrixXd::Zero(1, points_size - 1);
</diff>
			</file>
			<file old_path="modules\planning\tasks\optimizers\open_space_trajectory_generation\open_space_trajectory_provider.cc" new_path="modules\planning\tasks\optimizers\open_space_trajectory_generation\open_space_trajectory_provider.cc" added_lines="3" deleted_lines="2">
				<diff>@@ -23,8 +23,9 @@
 #include &lt;memory&gt;
 #include &lt;string&gt;
 
-#include "cyber/task/task.h"
 #include "modules/common/vehicle_state/proto/vehicle_state.pb.h"
+
+#include "cyber/task/task.h"
 #include "modules/planning/common/planning_context.h"
 #include "modules/planning/common/planning_gflags.h"
 #include "modules/planning/common/trajectory/publishable_trajectory.h"
@@ -289,7 +290,7 @@ bool OpenSpaceTrajectoryProvider::IsVehicleNearDestination(
     const common::VehicleState&amp; vehicle_state,
     const std::vector&lt;double&gt;&amp; end_pose, double rotate_angle,
     const Vec2d&amp; translate_origin) {
-  CHECK_EQ(end_pose.size(), 4);
+  CHECK_EQ(end_pose.size(), 4U);
   Vec2d end_pose_to_world_frame = Vec2d(end_pose[0], end_pose[1]);
 
   end_pose_to_world_frame.SelfRotate(rotate_angle);
</diff>
			</file>
			<file old_path="modules\planning\tasks\optimizers\open_space_trajectory_partition\open_space_trajectory_partition.cc" new_path="modules\planning\tasks\optimizers\open_space_trajectory_partition\open_space_trajectory_partition.cc" added_lines="5" deleted_lines="4">
				<diff>@@ -23,6 +23,7 @@
 #include &lt;queue&gt;
 
 #include "absl/strings/str_cat.h"
+
 #include "cyber/time/clock.h"
 #include "modules/common/math/polygon2d.h"
 #include "modules/common/status/status.h"
@@ -149,7 +150,7 @@ Status OpenSpaceTrajectoryPartition::Process() {
     const auto&amp; gear = partitioned_trajectories-&gt;at(i).second;
     const auto&amp; trajectory = partitioned_trajectories-&gt;at(i).first;
     size_t trajectory_size = trajectory.size();
-    CHECK_GT(trajectory_size, 0);
+    CHECK_GT(trajectory_size, 0U);
 
     flag_change_to_next = CheckReachTrajectoryEnd(
         trajectory, gear, trajectories_size, i, &amp;current_trajectory_index,
@@ -279,8 +280,8 @@ void OpenSpaceTrajectoryPartition::InterpolateTrajectory(
   interpolated_trajectory-&gt;clear();
   size_t interpolated_pieces_num =
       open_space_trajectory_partition_config_.interpolated_pieces_num();
-  CHECK_GT(stitched_trajectory_result.size(), 0);
-  CHECK_GT(interpolated_pieces_num, 0);
+  CHECK_GT(stitched_trajectory_result.size(), 0U);
+  CHECK_GT(interpolated_pieces_num, 0U);
   size_t trajectory_to_be_partitioned_intervals_num =
       stitched_trajectory_result.size() - 1;
   size_t interpolated_points_num = interpolated_pieces_num - 1;
@@ -582,7 +583,7 @@ bool OpenSpaceTrajectoryPartition::UseFailSafeSearch(
   for (size_t i = 0; i &lt; trajectories_size; ++i) {
     const auto&amp; trajectory = partitioned_trajectories.at(i).first;
     size_t trajectory_size = trajectory.size();
-    CHECK_GT(trajectory_size, 0);
+    CHECK_GT(trajectory_size, 0U);
     std::priority_queue&lt;std::pair&lt;size_t, double&gt;,
                         std::vector&lt;std::pair&lt;size_t, double&gt;&gt;, comp_&gt;
         failsafe_closest_point;
</diff>
			</file>
			<file old_path="modules\planning\tasks\optimizers\path_time_heuristic\gridded_path_time_graph.cc" new_path="modules\planning\tasks\optimizers\path_time_heuristic\gridded_path_time_graph.cc" added_lines="3" deleted_lines="2">
				<diff>@@ -24,10 +24,11 @@
 #include &lt;limits&gt;
 #include &lt;string&gt;
 
+#include "modules/common/proto/pnc_point.pb.h"
+
 #include "cyber/common/log.h"
 #include "cyber/task/task.h"
 #include "modules/common/math/vec2d.h"
-#include "modules/common/proto/pnc_point.pb.h"
 #include "modules/common/util/point_factory.h"
 #include "modules/planning/common/planning_gflags.h"
 
@@ -329,7 +330,7 @@ void GriddedPathTimeGraph::CalculateCostAt(
 
   const auto&amp; cost_init = cost_table_[0][0];
   if (c == 0) {
-    DCHECK_EQ(r, 0) &lt;&lt; "Incorrect. Row should be 0 with col = 0. row: " &lt;&lt; r;
+    DCHECK_EQ(r, 0U) &lt;&lt; "Incorrect. Row should be 0 with col = 0. row: " &lt;&lt; r;
     cost_cr.SetTotalCost(0.0);
     cost_cr.SetOptimalSpeed(init_point_.v());
     return;
</diff>
			</file>
			<file old_path="modules\planning\tasks\optimizers\piecewise_jerk_path\piecewise_jerk_path_ipopt_solver.cc" new_path="modules\planning\tasks\optimizers\piecewise_jerk_path\piecewise_jerk_path_ipopt_solver.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -29,7 +29,7 @@ PiecewiseJerkPathIpoptSolver::PiecewiseJerkPathIpoptSolver(
     const double x_init, const double dx_init, const double ddx_init,
     const double delta_s, const double dddx_max,
     std::vector&lt;std::pair&lt;double, double&gt;&gt; d_bounds) {
-  CHECK_GT(d_bounds.size(), 1);
+  CHECK_GT(d_bounds.size(), 1U);
 
   x_init_ = x_init;
 
</diff>
			</file>
			<file old_path="modules\planning\tasks\optimizers\piecewise_jerk_path\piecewise_jerk_path_optimizer.cc" new_path="modules\planning\tasks\optimizers\piecewise_jerk_path\piecewise_jerk_path_optimizer.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -102,7 +102,7 @@ common::Status PiecewiseJerkPathOptimizer::Process(
       max_iter = 4000;
     }
 
-    CHECK_GT(path_boundary_size, 1);
+    CHECK_GT(path_boundary_size, 1U);
 
     std::vector&lt;double&gt; opt_l;
     std::vector&lt;double&gt; opt_dl;
</diff>
			</file>
			<file old_path="modules\planning\tuning\autotuning_raw_feature_generator.cc" new_path="modules\planning\tuning\autotuning_raw_feature_generator.cc" added_lines="2" deleted_lines="3">
				<diff>@@ -45,7 +45,7 @@ AutotuningRawFeatureGenerator::AutotuningRawFeatureGenerator(
       stop_boundaries_(num_points, std::vector&lt;std::array&lt;double, 3&gt;&gt;()),
       nudge_boundaries_(num_points, std::vector&lt;std::array&lt;double, 3&gt;&gt;()),
       side_pass_boundaries_(num_points, std::vector&lt;std::array&lt;double, 3&gt;&gt;()) {
-  CHECK_GT(num_points, 0);
+  CHECK_GT(num_points, 0U);
   CHECK_GT(time_range, kMinTimeRange);
   double res = time_range / static_cast&lt;double&gt;(num_points);
   for (double t = 0; t &lt; res + time_range; t += res) {
@@ -130,8 +130,7 @@ common::Status AutotuningRawFeatureGenerator::EvaluateSpeedProfile(
     const std::vector&lt;common::SpeedPoint&gt;&amp; speed_profile,
     autotuning::TrajectoryRawFeature* const trajectory_feature) const {
   if (speed_profile.size() != eval_time_.size()) {
-    const std::string msg =
-        "mismatched evaluated time and speed profile size";
+    const std::string msg = "mismatched evaluated time and speed profile size";
     AERROR &lt;&lt; msg;
     return Status(ErrorCode::PLANNING_ERROR, msg);
   }
</diff>
			</file>
			<file old_path="modules\prediction\common\prediction_map.cc" new_path="modules\prediction\common\prediction_map.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -696,7 +696,7 @@ std::shared_ptr&lt;const LaneInfo&gt; PredictionMap::LaneWithSmallestAverageCurvature(
 
 double PredictionMap::AverageCurvature(const std::string&amp; lane_id,
                                        const size_t sample_size) {
-  CHECK_GT(sample_size, 0);
+  CHECK_GT(sample_size, 0U);
   std::shared_ptr&lt;const hdmap::LaneInfo&gt; lane_info_ptr =
       PredictionMap::LaneById(lane_id);
   if (lane_info_ptr == nullptr) {
</diff>
			</file>
			<file old_path="modules\prediction\container\obstacles\obstacle.cc" new_path="modules\prediction\container\obstacles\obstacle.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -275,7 +275,7 @@ bool Obstacle::IsCloseToJunctionExit() const {
     AERROR &lt;&lt; "No junction feature found";
     return false;
   }
-  CHECK_GT(history_size(), 0);
+  CHECK_GT(history_size(), 0U);
   const Feature&amp; latest_feature = feature_history_.front();
   double position_x = latest_feature.position().x();
   double position_y = latest_feature.position().y();
@@ -1443,7 +1443,7 @@ void Obstacle::DiscardOutdatedHistory() {
 }
 
 void Obstacle::SetCaution() {
-  CHECK_GT(feature_history_.size(), 0);
+  CHECK_GT(feature_history_.size(), 0U);
   Feature* feature = mutable_latest_feature();
   feature-&gt;mutable_priority()-&gt;set_priority(ObstaclePriority::CAUTION);
 }
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\vehicle\junction_mlp_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\junction_mlp_evaluator.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -265,7 +265,7 @@ void JunctionMLPEvaluator::SetEgoVehicleFeatureValues(
   }
   const auto ego_position = ego_pose_obstacle_ptr-&gt;latest_feature().position();
   const auto ego_velocity = ego_pose_obstacle_ptr-&gt;latest_feature().velocity();
-  CHECK_GT(obstacle_ptr-&gt;history_size(), 0);
+  CHECK_GT(obstacle_ptr-&gt;history_size(), 0U);
   const Feature&amp; obstacle_feature = obstacle_ptr-&gt;latest_feature();
   apollo::common::math::Vec2d ego_relative_position(
       ego_position.x() - obstacle_feature.position().x(),
</diff>
			</file>
			<file old_path="modules\prediction\network\net_layer.cc" new_path="modules\prediction\network\net_layer.cc" added_lines="12" deleted_lines="12">
				<diff>@@ -81,7 +81,7 @@ bool Dense::Load(const DenseParameter&amp; dense_pb) {
 
 void Dense::Run(const std::vector&lt;Eigen::MatrixXf&gt;&amp; inputs,
                 Eigen::MatrixXf* output) {
-  CHECK_EQ(inputs.size(), 1);
+  CHECK_EQ(inputs.size(), 1U);
   Eigen::MatrixXf prod = static_cast&lt;Eigen::MatrixXf&gt;(inputs[0] * weights_);
   if (use_bias_) {
     Eigen::MatrixXf sum = prod.rowwise() + bias_.transpose();
@@ -128,8 +128,8 @@ bool Conv1d::Load(const Conv1dParameter&amp; conv1d_pb) {
 
 void Conv1d::Run(const std::vector&lt;Eigen::MatrixXf&gt;&amp; inputs,
                  Eigen::MatrixXf* output) {
-  CHECK_EQ(inputs.size(), 1);
-  CHECK_GT(kernel_.size(), 0);
+  CHECK_EQ(inputs.size(), 1U);
+  CHECK_GT(kernel_.size(), 0U);
   CHECK_EQ(kernel_[0].rows(), inputs[0].rows());
   int kernel_size = static_cast&lt;int&gt;(kernel_[0].cols());
   int output_num_col =
@@ -175,7 +175,7 @@ bool MaxPool1d::Load(const MaxPool1dParameter&amp; maxpool1d_pb) {
 
 void MaxPool1d::Run(const std::vector&lt;Eigen::MatrixXf&gt;&amp; inputs,
                     Eigen::MatrixXf* output) {
-  CHECK_EQ(inputs.size(), 1);
+  CHECK_EQ(inputs.size(), 1U);
   int output_num_col =
       static_cast&lt;int&gt;((inputs[0].cols() - kernel_size_) / stride_) + 1;
   int output_num_row = static_cast&lt;int&gt;(inputs[0].rows());
@@ -218,7 +218,7 @@ bool AvgPool1d::Load(const AvgPool1dParameter&amp; avgpool1d_pb) {
 
 void AvgPool1d::Run(const std::vector&lt;Eigen::MatrixXf&gt;&amp; inputs,
                     Eigen::MatrixXf* output) {
-  CHECK_EQ(inputs.size(), 1);
+  CHECK_EQ(inputs.size(), 1U);
   int output_num_col =
       static_cast&lt;int&gt;((inputs[0].cols() - kernel_size_) / stride_) + 1;
   int output_num_row = static_cast&lt;int&gt;(inputs[0].rows());
@@ -262,7 +262,7 @@ bool Activation::Load(const ActivationParameter&amp; activation_pb) {
 
 void Activation::Run(const std::vector&lt;Eigen::MatrixXf&gt;&amp; inputs,
                      Eigen::MatrixXf* output) {
-  CHECK_EQ(inputs.size(), 1);
+  CHECK_EQ(inputs.size(), 1U);
   *output = inputs[0].unaryExpr(kactivation_);
 }
 
@@ -303,7 +303,7 @@ bool BatchNormalization::Load(const LayerParameter&amp; layer_pb) {
 
 void BatchNormalization::Run(const std::vector&lt;Eigen::MatrixXf&gt;&amp; inputs,
                              Eigen::MatrixXf* output) {
-  CHECK_EQ(inputs.size(), 1);
+  CHECK_EQ(inputs.size(), 1U);
   Eigen::MatrixXf temp = (inputs[0].rowwise() - mu_.transpose());
   Eigen::MatrixXf norm =
       temp.array().rowwise() / (sigma_.array().sqrt() + epsilon_).transpose();
@@ -447,7 +447,7 @@ void LSTM::Step(const Eigen::MatrixXf&amp; input, Eigen::MatrixXf* output,
 
 void LSTM::Run(const std::vector&lt;Eigen::MatrixXf&gt;&amp; inputs,
                Eigen::MatrixXf* output) {
-  CHECK_EQ(inputs.size(), 1);
+  CHECK_EQ(inputs.size(), 1U);
   Eigen::MatrixXf sequences(inputs[0].rows(), units_);
   Eigen::MatrixXf temp;
   for (int i = 0; i &lt; inputs[0].rows(); ++i) {
@@ -475,7 +475,7 @@ void LSTM::State(std::vector&lt;Eigen::MatrixXf&gt;* states) const {
 }
 
 void LSTM::SetState(const std::vector&lt;Eigen::MatrixXf&gt;&amp; states) {
-  CHECK_EQ(states.size(), 2);
+  CHECK_EQ(states.size(), 2U);
   CHECK_EQ(states[0].rows(), 1);
   CHECK_EQ(states[1].rows(), 1);
   CHECK_EQ(states[0].cols(), units_);
@@ -494,7 +494,7 @@ bool Flatten::Load(const LayerParameter&amp; layer_pb) {
 
 void Flatten::Run(const std::vector&lt;Eigen::MatrixXf&gt;&amp; inputs,
                   Eigen::MatrixXf* output) {
-  CHECK_EQ(inputs.size(), 1);
+  CHECK_EQ(inputs.size(), 1U);
   Eigen::Matrix&lt;float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; inp(
       inputs[0]);
   inp.resize(1, inp.size());
@@ -533,7 +533,7 @@ bool Input::Load(const LayerParameter&amp; layer_pb) {
 
 void Input::Run(const std::vector&lt;Eigen::MatrixXf&gt;&amp; inputs,
                 Eigen::MatrixXf* output) {
-  CHECK_EQ(inputs.size(), 1);
+  CHECK_EQ(inputs.size(), 1U);
   CHECK_EQ(inputs[0].cols(), input_shape_.back());
   *output = inputs[0];
 }
@@ -554,7 +554,7 @@ bool Concatenate::Load(const LayerParameter&amp; layer_pb) {
 
 void Concatenate::Run(const std::vector&lt;Eigen::MatrixXf&gt;&amp; inputs,
                       Eigen::MatrixXf* output) {
-  CHECK_EQ(inputs.size(), 2);
+  CHECK_EQ(inputs.size(), 2U);
   CHECK_EQ(inputs[0].rows(), inputs[1].rows());
   output-&gt;resize(inputs[0].rows(), inputs[0].cols() + inputs[1].cols());
   *output &lt;&lt; inputs[0], inputs[1];
</diff>
			</file>
			<file old_path="modules\prediction\predictor\extrapolation\extrapolation_predictor.cc" new_path="modules\prediction\predictor\extrapolation\extrapolation_predictor.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -37,7 +37,7 @@ bool ExtrapolationPredictor::Predict(
   Clear();
 
   CHECK_NOTNULL(obstacle);
-  CHECK_GT(obstacle-&gt;history_size(), 0);
+  CHECK_GT(obstacle-&gt;history_size(), 0U);
 
   obstacle-&gt;SetPredictorType(predictor_type_);
 
</diff>
			</file>
			<file old_path="modules\prediction\predictor\free_move\free_move_predictor.cc" new_path="modules\prediction\predictor\free_move\free_move_predictor.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -36,7 +36,7 @@ bool FreeMovePredictor::Predict(
   Clear();
 
   CHECK_NOTNULL(obstacle);
-  CHECK_GT(obstacle-&gt;history_size(), 0);
+  CHECK_GT(obstacle-&gt;history_size(), 0U);
 
   obstacle-&gt;SetPredictorType(predictor_type_);
 
</diff>
			</file>
			<file old_path="modules\prediction\predictor\interaction\interaction_predictor.cc" new_path="modules\prediction\predictor\interaction\interaction_predictor.cc" added_lines="5" deleted_lines="3">
				<diff>@@ -22,6 +22,7 @@
 #include &lt;string&gt;
 
 #include "modules/common/adapters/proto/adapter_config.pb.h"
+
 #include "modules/prediction/common/feature_output.h"
 #include "modules/prediction/common/prediction_constants.h"
 #include "modules/prediction/common/prediction_gflags.h"
@@ -47,7 +48,7 @@ bool InteractionPredictor::Predict(
     ObstaclesContainer* obstacles_container) {
   Clear();
   CHECK_NOTNULL(obstacle);
-  CHECK_GT(obstacle-&gt;history_size(), 0);
+  CHECK_GT(obstacle-&gt;history_size(), 0U);
 
   BuildADCTrajectory(adc_trajectory_container,
                      FLAGS_collision_cost_time_resolution);
@@ -89,7 +90,8 @@ bool InteractionPredictor::Predict(
 
   int best_seq_idx = 0;
   double largest_posterior = 0.0;
-  CHECK_EQ(posteriors.size(), lane_graph-&gt;lane_sequence_size());
+  CHECK_EQ(posteriors.size(),
+           static_cast&lt;size_t&gt;(lane_graph-&gt;lane_sequence_size()));
   for (int i = 0; i &lt; num_lane_sequence; ++i) {
     double normalized_posterior =
         posteriors[i] / (posterior_sum + FLAGS_double_precision);
@@ -240,7 +242,7 @@ double InteractionPredictor::ComputeTrajectoryCost(
     const Obstacle&amp; obstacle, const LaneSequence&amp; lane_sequence,
     const double acceleration,
     const ADCTrajectoryContainer* adc_trajectory_container) {
-  CHECK_GT(obstacle.history_size(), 0);
+  CHECK_GT(obstacle.history_size(), 0U);
   double speed = obstacle.latest_feature().speed();
   double total_cost = 0.0;
 
</diff>
			</file>
			<file old_path="modules\prediction\predictor\junction\junction_predictor.cc" new_path="modules\prediction\predictor\junction\junction_predictor.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -42,7 +42,7 @@ bool JunctionPredictor::Predict(
     ObstaclesContainer* obstacles_container) {
   Clear();
   CHECK_NOTNULL(obstacle);
-  CHECK_GT(obstacle-&gt;history_size(), 0);
+  CHECK_GT(obstacle-&gt;history_size(), 0U);
 
   obstacle-&gt;SetPredictorType(predictor_type_);
 
</diff>
			</file>
			<file old_path="modules\prediction\predictor\lane_sequence\lane_sequence_predictor.cc" new_path="modules\prediction\predictor\lane_sequence\lane_sequence_predictor.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -41,7 +41,7 @@ bool LaneSequencePredictor::Predict(
   Clear();
 
   CHECK_NOTNULL(obstacle);
-  CHECK_GT(obstacle-&gt;history_size(), 0);
+  CHECK_GT(obstacle-&gt;history_size(), 0U);
 
   obstacle-&gt;SetPredictorType(predictor_type_);
 
</diff>
			</file>
			<file old_path="modules\prediction\predictor\move_sequence\move_sequence_predictor.cc" new_path="modules\prediction\predictor\move_sequence\move_sequence_predictor.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -41,7 +41,7 @@ bool MoveSequencePredictor::Predict(
   Clear();
 
   CHECK_NOTNULL(obstacle);
-  CHECK_GT(obstacle-&gt;history_size(), 0);
+  CHECK_GT(obstacle-&gt;history_size(), 0U);
 
   obstacle-&gt;SetPredictorType(predictor_type_);
 
@@ -285,7 +285,7 @@ std::pair&lt;double, double&gt; MoveSequencePredictor::ComputeLonEndState(
 double MoveSequencePredictor::ComputeTimeToLatEndConditionByVelocity(
     const Obstacle&amp; obstacle, const LaneSequence&amp; lane_sequence) {
   // Sanity check.
-  CHECK_GT(obstacle.history_size(), 0);
+  CHECK_GT(obstacle.history_size(), 0U);
   CHECK_GT(lane_sequence.lane_segment_size(), 0);
   CHECK_GT(lane_sequence.lane_segment(0).lane_point_size(), 0);
 
</diff>
			</file>
			<file old_path="modules\prediction\predictor\predictor.cc" new_path="modules\prediction\predictor\predictor.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -27,7 +27,7 @@ using apollo::common::PathPoint;
 using apollo::common::TrajectoryPoint;
 
 int Predictor::NumOfTrajectories(const Obstacle&amp; obstacle) {
-  CHECK_GT(obstacle.history_size(), 0);
+  CHECK_GT(obstacle.history_size(), 0U);
   return obstacle.latest_feature().predicted_trajectory_size();
 }
 
</diff>
			</file>
			<file old_path="modules\prediction\predictor\sequence\sequence_predictor.cc" new_path="modules\prediction\predictor\sequence\sequence_predictor.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -38,7 +38,7 @@ bool SequencePredictor::Predict(
   Clear();
 
   CHECK_NOTNULL(obstacle);
-  CHECK_GT(obstacle-&gt;history_size(), 0);
+  CHECK_GT(obstacle-&gt;history_size(), 0U);
   return true;
 }
 
@@ -349,7 +349,7 @@ bool SequencePredictor::GetLongitudinalPolynomial(
     std::array&lt;double, 5&gt;* coefficients) {
   // Sanity check.
   CHECK_NOTNULL(coefficients);
-  CHECK_GT(obstacle.history_size(), 0);
+  CHECK_GT(obstacle.history_size(), 0U);
   CHECK_GT(lane_sequence.lane_segment_size(), 0);
   CHECK_GT(lane_sequence.lane_segment(0).lane_point_size(), 0);
 
@@ -403,7 +403,7 @@ bool SequencePredictor::GetLateralPolynomial(
     const double time_to_end_state, std::array&lt;double, 4&gt;* coefficients) {
   // Sanity check.
   CHECK_NOTNULL(coefficients);
-  CHECK_GT(obstacle.history_size(), 0);
+  CHECK_GT(obstacle.history_size(), 0U);
   CHECK_GT(lane_sequence.lane_segment_size(), 0);
   CHECK_GT(lane_sequence.lane_segment(0).lane_point_size(), 0);
 
</diff>
			</file>
			<file old_path="modules\prediction\predictor\single_lane\single_lane_predictor.cc" new_path="modules\prediction\predictor\single_lane\single_lane_predictor.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -39,7 +39,7 @@ bool SingleLanePredictor::Predict(
   Clear();
 
   CHECK_NOTNULL(obstacle);
-  CHECK_GT(obstacle-&gt;history_size(), 0);
+  CHECK_GT(obstacle-&gt;history_size(), 0U);
 
   obstacle-&gt;SetPredictorType(predictor_type_);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1ac5b29b615e1340a73e12545e2992454cd4fe38" author="panxuechao">
		<msg>Dreamview:: add battery_soc_percentage and gear_localtion (#12927)</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_service.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_service.cc" added_lines="4" deleted_lines="0">
				<diff>@@ -541,6 +541,10 @@ void SimulationWorldService::UpdateSimulationWorld(const Chassis &amp;chassis) {
   UpdateTurnSignal(chassis.signal(), auto_driving_car);
 
   auto_driving_car-&gt;set_disengage_type(DeduceDisengageType(chassis));
+
+  auto_driving_car-&gt;set_battery_soc_percentage(
+    chassis.battery_soc_percentage());
+  auto_driving_car-&gt;set_gear_localtion(chassis.gear_location());
 }
 
 template &lt;&gt;
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_service_test.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_service_test.cc" added_lines="4" deleted_lines="0">
				<diff>@@ -167,6 +167,8 @@ TEST_F(SimulationWorldServiceTest, UpdateChassisInfo) {
   chassis.set_throttle_percentage(50);
   chassis.set_brake_percentage(10);
   chassis.set_steering_percentage(25);
+  chassis.set_battery_soc_percentage(80);
+  chassis.set_gear_location(Chassis::GEAR_DRIVE);
   chassis.mutable_signal()-&gt;set_turn_signal(
       apollo::common::VehicleSignal::TURN_RIGHT);
 
@@ -182,6 +184,8 @@ TEST_F(SimulationWorldServiceTest, UpdateChassisInfo) {
   EXPECT_DOUBLE_EQ(50.0, car.throttle_percentage());
   EXPECT_DOUBLE_EQ(10.0, car.brake_percentage());
   EXPECT_DOUBLE_EQ(25.0, car.steering_percentage());
+  EXPECT_EQ(80, car.battery_soc_percentage());
+  EXPECT_EQ(Chassis::GEAR_DRIVE, car.gear_localtion());
   EXPECT_EQ("RIGHT", car.current_signal());
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ec4adbe00dbf7a05bc9b6a163537f21474d16b11" author="storypku">
		<msg>cyber: typofix</msg>
		<modified_files>
			<file old_path="cyber\class_loader\utility\class_loader_utility.h" new_path="cyber\class_loader\utility\class_loader_utility.h" added_lines="4" deleted_lines="4">
				<diff>@@ -80,15 +80,15 @@ void RegisterClass(const std::string&amp; class_name,
   AINFO &lt;&lt; "registerclass:" &lt;&lt; class_name &lt;&lt; "," &lt;&lt; base_class_name &lt;&lt; ","
         &lt;&lt; GetCurLoadingLibraryName();
 
-  utility::AbstractClassFactory&lt;Base&gt;* new_class_factrory_obj =
+  utility::AbstractClassFactory&lt;Base&gt;* new_class_factory_obj =
       new utility::ClassFactory&lt;Derived, Base&gt;(class_name, base_class_name);
-  new_class_factrory_obj-&gt;AddOwnedClassLoader(GetCurActiveClassLoader());
-  new_class_factrory_obj-&gt;SetRelativeLibraryPath(GetCurLoadingLibraryName());
+  new_class_factory_obj-&gt;AddOwnedClassLoader(GetCurActiveClassLoader());
+  new_class_factory_obj-&gt;SetRelativeLibraryPath(GetCurLoadingLibraryName());
 
   GetClassFactoryMapMapMutex().lock();
   ClassClassFactoryMap&amp; factory_map =
       GetClassFactoryMapByBaseClass(typeid(Base).name());
-  factory_map[class_name] = new_class_factrory_obj;
+  factory_map[class_name] = new_class_factory_obj;
   GetClassFactoryMapMapMutex().unlock();
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="295e13e9681c2a1776a60c6206437c61e2a176c8" author="Jiahao Chen (Jerold)">
		<msg>Perception: turn back to TensorRT for pfe inference (#12974)</msg>
		<modified_files>
			<file old_path="modules\perception\common\perception_gflags.cc" new_path="modules\perception\common\perception_gflags.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -39,10 +39,10 @@ DEFINE_string(work_root, "", "Project work root direcotry.");
 
 // lidar_point_pillars
 DEFINE_int32(gpu_id, 0, "The id of gpu used for inference.");
-DEFINE_string(pfe_torch_file,
+DEFINE_string(pfe_onnx_file,
               "/apollo/modules/perception/production/data/perception/lidar/"
-              "models/detection/point_pillars/pfe.pt",
-              "The path of pillars feature extractor torch file.");
+              "models/detection/point_pillars/pfe.onnx",
+              "The path of PFE onnx file.");
 DEFINE_string(rpn_onnx_file,
               "/apollo/modules/perception/production/data/perception/lidar/"
               "models/detection/point_pillars/rpn.onnx",
</diff>
			</file>
			<file old_path="modules\perception\common\perception_gflags.h" new_path="modules\perception\common\perception_gflags.h" added_lines="1" deleted_lines="1">
				<diff>@@ -33,7 +33,7 @@ DECLARE_string(work_root);
 
 // lidar_point_pillars
 DECLARE_int32(gpu_id);
-DECLARE_string(pfe_torch_file);
+DECLARE_string(pfe_onnx_file);
 DECLARE_string(rpn_onnx_file);
 DECLARE_double(normalizing_factor);
 DECLARE_int32(num_point_feature);
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\params.h" new_path="modules\perception\lidar\lib\detection\lidar_point_pillars\params.h" added_lines="1" deleted_lines="0">
				<diff>@@ -37,6 +37,7 @@ class Params {
   static constexpr int kMaxNumPillars = 30000;
   static constexpr int kMaxNumPointsPerPillar = 60;
   static constexpr int kNumPointFeature = 5;  // x, y, z, i, delta of time
+  static constexpr int kNumGatherPointFeature = 9;
   static constexpr int kNumAnchor = 200 * 140 * 8 + 220 * 140 * 8;
   static constexpr int kNumOutputBoxFeature = 7;
   static constexpr int kBatchSize = 1;
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars.cc" new_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars.cc" added_lines="44" deleted_lines="83">
				<diff>@@ -29,16 +29,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+#include "modules/perception/lidar/lib/detection/lidar_point_pillars/point_pillars.h"
 
-// headers in STL
 #include &lt;chrono&gt;
 #include &lt;iostream&gt;
 
 #include "cyber/common/log.h"
 
-// headers in local files
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/point_pillars.h"
-
 namespace apollo {
 namespace perception {
 namespace lidar {
@@ -56,6 +53,7 @@ const int PointPillars::kNumClass = Params::kNumClass;
 const int PointPillars::kMaxNumPillars = Params::kMaxNumPillars;
 const int PointPillars::kMaxNumPointsPerPillar = Params::kMaxNumPointsPerPillar;
 const int PointPillars::kNumPointFeature = Params::kNumPointFeature;
+const int PointPillars::kNumGatherPointFeature = Params::kNumGatherPointFeature;
 const int PointPillars::kGridXSize =
     static_cast&lt;int&gt;((kMaxXRange - kMinXRange) / kPillarXSize);
 const int PointPillars::kGridYSize =
@@ -101,13 +99,15 @@ const std::vector&lt;std::vector&lt;float&gt;&gt; PointPillars::kAnchorRo =
 PointPillars::PointPillars(const bool reproduce_result_mode,
                            const float score_threshold,
                            const float nms_overlap_threshold,
-                           const std::string pfe_torch_file,
+                           const std::string pfe_onnx_file,
                            const std::string rpn_onnx_file)
     : reproduce_result_mode_(reproduce_result_mode),
       score_threshold_(score_threshold),
       nms_overlap_threshold_(nms_overlap_threshold),
-      pfe_torch_file_(pfe_torch_file),
-      rpn_onnx_file_(rpn_onnx_file) {
+      pfe_onnx_file_(pfe_onnx_file),
+      rpn_onnx_file_(rpn_onnx_file),
+      pfe_engine_(nullptr),
+      rpn_engine_(nullptr) {
   if (reproduce_result_mode_) {
     preprocess_points_ptr_.reset(new PreprocessPoints(
         kMaxNumPillars, kMaxNumPointsPerPillar, kNumPointFeature, kGridXSize,
@@ -124,8 +124,12 @@ PointPillars::PointPillars(const bool reproduce_result_mode,
       kNumThreads, kNumIndsForScan, kNumAnchor, kMinXRange, kMinYRange,
       kPillarXSize, kPillarYSize, kGridXSize, kGridYSize));
 
-  scatter_cuda_ptr_.reset(
-      new ScatterCuda(kNumThreads, kMaxNumPillars, kGridXSize, kGridYSize));
+  pfe_cuda_ptr_.reset(new PfeCuda(kMaxNumPillars, kMaxNumPointsPerPillar,
+                                  kNumPointFeature, kNumGatherPointFeature,
+                                  kPillarXSize, kPillarYSize, kMinXRange,
+                                  kMinYRange, kNumThreads));
+
+  scatter_cuda_ptr_.reset(new ScatterCuda(kNumThreads, kGridXSize, kGridYSize));
 
   const float float_min = std::numeric_limits&lt;float&gt;::lowest();
   const float float_max = std::numeric_limits&lt;float&gt;::max();
@@ -135,7 +139,6 @@ PointPillars::PointPillars(const bool reproduce_result_mode,
                           kNumBoxCorners, kNumOutputBoxFeature));
 
   DeviceMemoryMalloc();
-  InitTorch();
   InitTRT();
   InitAnchors();
 }
@@ -169,9 +172,9 @@ PointPillars::~PointPillars() {
   GPU_CHECK(cudaFree(dev_box_anchors_max_y_));
   GPU_CHECK(cudaFree(dev_anchor_mask_));
 
+  GPU_CHECK(cudaFree(dev_pfe_gather_feature_));
   GPU_CHECK(cudaFree(pfe_buffers_[0]));
   GPU_CHECK(cudaFree(pfe_buffers_[1]));
-  GPU_CHECK(cudaFree(pfe_buffers_[2]));
 
   GPU_CHECK(cudaFree(rpn_buffers_[0]));
   GPU_CHECK(cudaFree(rpn_buffers_[1]));
@@ -194,8 +197,9 @@ PointPillars::~PointPillars() {
   GPU_CHECK(cudaFree(dev_box_for_nms_));
   GPU_CHECK(cudaFree(dev_filter_count_));
 
+  pfe_context_-&gt;destroy();
   rpn_context_-&gt;destroy();
-  rpn_runtime_-&gt;destroy();
+  pfe_engine_-&gt;destroy();
   rpn_engine_-&gt;destroy();
 }
 
@@ -234,11 +238,13 @@ void PointPillars::DeviceMemoryMalloc() {
 
   // for trt inference
   // create GPU buffers and a stream
+  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_pfe_gather_feature_),
+                       kMaxNumPillars * kMaxNumPointsPerPillar *
+                           kNumGatherPointFeature * sizeof(float)));
   GPU_CHECK(
       cudaMalloc(&amp;pfe_buffers_[0], kMaxNumPillars * kMaxNumPointsPerPillar *
-                                       kNumPointFeature * sizeof(float)));
-  GPU_CHECK(cudaMalloc(&amp;pfe_buffers_[1], kMaxNumPillars * sizeof(float)));
-  GPU_CHECK(cudaMalloc(&amp;pfe_buffers_[2], kMaxNumPillars * 4 * sizeof(float)));
+                                       kNumGatherPointFeature * sizeof(float)));
+  GPU_CHECK(cudaMalloc(&amp;pfe_buffers_[1], kMaxNumPillars * 64 * sizeof(float)));
 
   GPU_CHECK(cudaMalloc(&amp;rpn_buffers_[0], kRpnInputSize * sizeof(float)));
   GPU_CHECK(cudaMalloc(&amp;rpn_buffers_[1], kRpnBoxOutputSize * sizeof(float)));
@@ -445,48 +451,25 @@ void PointPillars::ConvertAnchors2BoxAnchors(float* anchors_px,
   }
 }
 
-void PointPillars::InitTorch() {
-  if (gpu_id_ &gt;= 0) {
-    device_type_ = torch::kCUDA;
-    device_id_ = gpu_id_;
-  } else {
-    device_type_ = torch::kCPU;
-  }
-
-  // Init torch net
-  torch::Device device(device_type_, device_id_);
-  pfe_net_ = torch::jit::load(pfe_torch_file_, device);
-}
-
 void PointPillars::InitTRT() {
-  // create a TensorRT model from the onnx model and serialize it to a stream
-  nvinfer1::IHostMemory* rpn_trt_model_stream{nullptr};
-  OnnxToTRTModel(rpn_onnx_file_, &amp;rpn_trt_model_stream);
-  if (rpn_trt_model_stream == nullptr) {
-    std::cerr &lt;&lt; "Failed to load ONNX file " &lt;&lt; std::endl;
+  // create a TensorRT model from the onnx model and load it into an engine
+  OnnxToTRTModel(pfe_onnx_file_, &amp;pfe_engine_);
+  OnnxToTRTModel(rpn_onnx_file_, &amp;rpn_engine_);
+  if (pfe_engine_ == nullptr || rpn_engine_ == nullptr) {
+    AERROR &lt;&lt; "Failed to load ONNX file.";
   }
 
-  // deserialize the engine
-  rpn_runtime_ = nvinfer1::createInferRuntime(g_logger_);
-  if (rpn_runtime_ == nullptr) {
-    std::cerr &lt;&lt; "Failed to create TensorRT Runtime object." &lt;&lt; std::endl;
-  }
-  rpn_engine_ = rpn_runtime_-&gt;deserializeCudaEngine(
-      rpn_trt_model_stream-&gt;data(), rpn_trt_model_stream-&gt;size(), nullptr);
-  if (rpn_engine_ == nullptr) {
-    std::cerr &lt;&lt; "Failed to create TensorRT Engine." &lt;&lt; std::endl;
-  }
-  rpn_trt_model_stream-&gt;destroy();
+  // create execution context from the engine
+  pfe_context_ = pfe_engine_-&gt;createExecutionContext();
   rpn_context_ = rpn_engine_-&gt;createExecutionContext();
-  if (rpn_context_ == nullptr) {
-    std::cerr &lt;&lt; "Failed to create TensorRT Execution Context." &lt;&lt; std::endl;
+  if (pfe_context_ == nullptr || rpn_context_ == nullptr) {
+    AERROR &lt;&lt; "Failed to create TensorRT Execution Context.";
   }
 }
 
 void PointPillars::OnnxToTRTModel(
     const std::string&amp; model_file,  // name of the onnx model
-    nvinfer1::IHostMemory**
-        trt_model_stream) {  // output buffer for the TensorRT model
+    nvinfer1::ICudaEngine** engine_ptr) {
   int verbosity = static_cast&lt;int&gt;(nvinfer1::ILogger::Severity::kWARNING);
 
   // create the builder
@@ -497,6 +480,7 @@ void PointPillars::OnnxToTRTModel(
   nvinfer1::INetworkDefinition* network =
       builder-&gt;createNetworkV2(explicit_batch);
 
+  // parse onnx model
   auto parser = nvonnxparser::createParser(*network, g_logger_);
   if (!parser-&gt;parseFromFile(model_file.c_str(), verbosity)) {
     std::string msg("failed to parse onnx file");
@@ -511,11 +495,8 @@ void PointPillars::OnnxToTRTModel(
   nvinfer1::ICudaEngine* engine =
       builder-&gt;buildEngineWithConfig(*network, *config);
 
+  *engine_ptr = engine;
   parser-&gt;destroy();
-
-  // serialize the engine, then close everything down
-  *trt_model_stream = engine-&gt;serialize();
-  engine-&gt;destroy();
   network-&gt;destroy();
   config-&gt;destroy();
   builder-&gt;destroy();
@@ -616,11 +597,6 @@ void PointPillars::DoInference(const float* in_points_array,
                                const int in_num_points,
                                std::vector&lt;float&gt;* out_detections,
                                std::vector&lt;int&gt;* out_labels) {
-  if (device_id_ &lt; 0) {
-    AERROR &lt;&lt; "Torch is not using GPU!";
-    return;
-  }
-
   Preprocess(in_points_array, in_num_points);
 
   anchor_mask_cuda_ptr_-&gt;DoAnchorMaskCuda(
@@ -630,39 +606,24 @@ void PointPillars::DoInference(const float* in_points_array,
 
   cudaStream_t stream;
   GPU_CHECK(cudaStreamCreate(&amp;stream));
-  GPU_CHECK(cudaMemcpyAsync(pfe_buffers_[0], dev_pillar_point_feature_,
+
+  GPU_CHECK(cudaMemset(dev_pfe_gather_feature_, 0,
+                       kMaxNumPillars * kMaxNumPointsPerPillar *
+                           kNumGatherPointFeature * sizeof(float)));
+  pfe_cuda_ptr_-&gt;GatherPointFeature(dev_pillar_point_feature_,
+                                    dev_num_points_per_pillar_,
+                                    dev_pillar_coors_, dev_pfe_gather_feature_);
+  GPU_CHECK(cudaMemcpyAsync(pfe_buffers_[0], dev_pfe_gather_feature_,
                             kMaxNumPillars * kMaxNumPointsPerPillar *
-                                kNumPointFeature * sizeof(float),
+                                kNumGatherPointFeature * sizeof(float),
                             cudaMemcpyDeviceToDevice, stream));
-  GPU_CHECK(cudaMemcpyAsync(pfe_buffers_[1], dev_num_points_per_pillar_,
-                            kMaxNumPillars * sizeof(float),
-                            cudaMemcpyDeviceToDevice, stream));
-  GPU_CHECK(cudaMemcpyAsync(pfe_buffers_[2], dev_pillar_coors_,
-                            kMaxNumPillars * 4 * sizeof(float),
-                            cudaMemcpyDeviceToDevice, stream));
-
-  torch::Tensor tensor_pillar_point_feature = torch::from_blob(pfe_buffers_[0],
-      {kMaxNumPillars, kMaxNumPointsPerPillar, kNumPointFeature},
-      torch::kCUDA);
-  torch::Tensor tensor_num_points_per_pillar = torch::from_blob(
-      pfe_buffers_[1], {kMaxNumPillars}, torch::kCUDA);
-  torch::Tensor tensor_pillar_coors = torch::from_blob(pfe_buffers_[2],
-      {kMaxNumPillars, 4}, torch::kCUDA);
-
-  torch::Device device(device_type_, device_id_);
-  tensor_pillar_point_feature.to(device);
-  tensor_num_points_per_pillar.to(device);
-  tensor_pillar_coors.to(device);
-
-  auto pfe_output = pfe_net_.forward({tensor_pillar_point_feature,
-                                      tensor_num_points_per_pillar,
-                                      tensor_pillar_coors}).toTensor();
+  pfe_context_-&gt;enqueueV2(pfe_buffers_, stream, nullptr);
 
   GPU_CHECK(
       cudaMemset(dev_scattered_feature_, 0, kRpnInputSize * sizeof(float)));
   scatter_cuda_ptr_-&gt;DoScatterCuda(
       host_pillar_count_[0], dev_x_coors_, dev_y_coors_,
-      pfe_output.data_ptr&lt;float&gt;(), dev_scattered_feature_);
+      reinterpret_cast&lt;float*&gt;(pfe_buffers_[1]), dev_scattered_feature_);
 
   GPU_CHECK(cudaMemcpyAsync(rpn_buffers_[0], dev_scattered_feature_,
                             kBatchSize * kRpnInputSize * sizeof(float),
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars.h" new_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars.h" added_lines="14" deleted_lines="21">
				<diff>@@ -53,13 +53,11 @@
 #include "NvInfer.h"
 #include "NvOnnxParser.h"
 
-#include "torch/script.h"
-#include "torch/torch.h"
-
 // headers in local files
 #include "modules/perception/lidar/lib/detection/lidar_point_pillars/anchor_mask_cuda.h"
 #include "modules/perception/lidar/lib/detection/lidar_point_pillars/common.h"
 #include "modules/perception/lidar/lib/detection/lidar_point_pillars/params.h"
+#include "modules/perception/lidar/lib/detection/lidar_point_pillars/pfe_cuda.h"
 #include "modules/perception/lidar/lib/detection/lidar_point_pillars/postprocess_cuda.h"
 #include "modules/perception/lidar/lib/detection/lidar_point_pillars/preprocess_points.h"
 #include "modules/perception/lidar/lib/detection/lidar_point_pillars/preprocess_points_cuda.h"
@@ -118,6 +116,7 @@ class PointPillars {
   static const int kMaxNumPillars;
   static const int kMaxNumPointsPerPillar;
   static const int kNumPointFeature;
+  static const int kNumGatherPointFeature;
   static const int kGridXSize;
   static const int kGridYSize;
   static const int kGridZSize;
@@ -147,7 +146,7 @@ class PointPillars {
   const bool reproduce_result_mode_;
   const float score_threshold_;
   const float nms_overlap_threshold_;
-  const std::string pfe_torch_file_;
+  const std::string pfe_onnx_file_;
   const std::string rpn_onnx_file_;
   // end initializer list
 
@@ -182,7 +181,9 @@ class PointPillars {
   float* dev_box_anchors_max_y_;
   int* dev_anchor_mask_;
 
-  void* pfe_buffers_[3];
+  float* dev_pfe_gather_feature_;
+  void* pfe_buffers_[2];
+
   void* rpn_buffers_[4];
 
   float* dev_scattered_feature_;
@@ -204,17 +205,15 @@ class PointPillars {
   std::unique_ptr&lt;PreprocessPoints&gt; preprocess_points_ptr_;
   std::unique_ptr&lt;PreprocessPointsCuda&gt; preprocess_points_cuda_ptr_;
   std::unique_ptr&lt;AnchorMaskCuda&gt; anchor_mask_cuda_ptr_;
+  std::unique_ptr&lt;PfeCuda&gt; pfe_cuda_ptr_;
   std::unique_ptr&lt;ScatterCuda&gt; scatter_cuda_ptr_;
   std::unique_ptr&lt;PostprocessCuda&gt; postprocess_cuda_ptr_;
 
   Logger g_logger_;
-  int device_id_ = -1;
-  int gpu_id_ = 0;
-  torch::DeviceType device_type_;
-  torch::jit::script::Module pfe_net_;
-  nvinfer1::IExecutionContext* rpn_context_;
-  nvinfer1::IRuntime* rpn_runtime_;
+  nvinfer1::ICudaEngine* pfe_engine_;
   nvinfer1::ICudaEngine* rpn_engine_;
+  nvinfer1::IExecutionContext* pfe_context_;
+  nvinfer1::IExecutionContext* rpn_context_;
 
   /**
    * @brief Memory allocation for device memory
@@ -228,12 +227,6 @@ class PointPillars {
    */
   void InitAnchors();
 
-  /**
-   * @brief Initializing LibTorch net
-   * @details Called in the constructor
-   */
-  void InitTorch();
-
   /**
    * @brief Initializing TensorRT instances
    * @details Called in the constructor
@@ -266,11 +259,11 @@ class PointPillars {
   /**
    * @brief Convert ONNX to TensorRT model
    * @param[in] model_file ONNX model file path
-   * @param[out] trt_model_stream TensorRT model made out of ONNX model
+   * @param[out] engine_ptr TensorRT model engine made out of ONNX model
    * @details Load ONNX model, and convert it to TensorRT model
    */
   void OnnxToTRTModel(const std::string&amp; model_file,
-                      nvinfer1::IHostMemory** trt_model_stream);
+                      nvinfer1::ICudaEngine** engine_ptr);
 
   /**
    * @brief Preproces points
@@ -332,13 +325,13 @@ class PointPillars {
    * reproducible for the same input
    * @param[in] score_threshold Score threshold for filtering output
    * @param[in] nms_overlap_threshold IOU threshold for NMS
-   * @param[in] pfe_torch_file Pillar Feature Extractor Torch file path
+   * @param[in] pfe_onnx_file Pillar Feature Extractor ONNX file path
    * @param[in] rpn_onnx_file Region Proposal Network ONNX file path
    * @details Variables could be changed through point_pillars_detection
    */
   PointPillars(const bool reproduce_result_mode, const float score_threshold,
                const float nms_overlap_threshold,
-               const std::string pfe_torch_file,
+               const std::string pfe_onnx_file,
                const std::string rpn_onnx_file);
   ~PointPillars();
 
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.cc" new_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.cc" added_lines="1" deleted_lines="2">
				<diff>@@ -22,7 +22,6 @@
 #include &lt;cuda_runtime_api.h&gt;
 
 #include "cyber/common/log.h"
-
 #include "modules/perception/base/object_pool_types.h"
 #include "modules/perception/base/point_cloud_util.h"
 #include "modules/perception/common/perception_gflags.h"
@@ -55,7 +54,7 @@ PointPillarsDetection::PointPillarsDetection()
 bool PointPillarsDetection::Init(const DetectionInitOptions&amp; options) {
   point_pillars_ptr_.reset(new PointPillars(
       FLAGS_reproduce_result_mode, FLAGS_score_threshold,
-      FLAGS_nms_overlap_threshold, FLAGS_pfe_torch_file, FLAGS_rpn_onnx_file));
+      FLAGS_nms_overlap_threshold, FLAGS_pfe_onnx_file, FLAGS_rpn_onnx_file));
   return true;
 }
 
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_test.cc" new_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_test.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -150,7 +150,7 @@ TestClass::TestClass()
 
   point_pillars_ptr_.reset(new PointPillars(
       reproduce_result_mode, score_threshold, nms_overlap_threshold,
-      FLAGS_pfe_torch_file, FLAGS_rpn_onnx_file));
+      FLAGS_pfe_onnx_file, FLAGS_rpn_onnx_file));
 }
 
 TestClass::TestClass(const int num_class, const int max_num_pillars,
@@ -192,7 +192,7 @@ TestClass::TestClass(const int num_class, const int max_num_pillars,
 
   point_pillars_ptr_.reset(new PointPillars(
       reproduce_result_mode, score_threshold, nms_overlap_threshold,
-      FLAGS_pfe_torch_file, FLAGS_rpn_onnx_file));
+      FLAGS_pfe_onnx_file, FLAGS_rpn_onnx_file));
 }
 
 void TestClass::Preprocess(const float* in_points_array, int in_num_points,
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\scatter_cuda.cu" new_path="modules\perception\lidar\lib\detection\lidar_point_pillars\scatter_cuda.cu" added_lines="8" deleted_lines="10">
				<diff>@@ -38,31 +38,29 @@ namespace perception {
 namespace lidar {
 
 __global__ void scatter_kernel(int *x_coors, int *y_coors, float *pfe_output,
-                               float *scattered_feature,
-                               const int max_num_pillars_,
-                               const int grid_x_size, const int grid_y_size) {
+                               float *scattered_feature, const int grid_x_size,
+                               const int grid_y_size) {
   int i_pillar = blockIdx.x;
   int i_feature = threadIdx.x;
   int x_ind = x_coors[i_pillar];
   int y_ind = y_coors[i_pillar];
-  float feature = pfe_output[i_feature * max_num_pillars_ + i_pillar];
+  float feature = pfe_output[i_pillar * 64 + i_feature];
   scattered_feature[i_feature * grid_y_size * grid_x_size +
                     y_ind * grid_x_size + x_ind] = feature;
 }
 
-ScatterCuda::ScatterCuda(const int num_threads, const int max_num_pillars,
-                         const int grid_x_size, const int grid_y_size)
+ScatterCuda::ScatterCuda(const int num_threads, const int grid_x_size,
+                         const int grid_y_size)
     : num_threads_(num_threads),
-      max_num_pillars_(max_num_pillars),
       grid_x_size_(grid_x_size),
       grid_y_size_(grid_y_size) {}
 
 void ScatterCuda::DoScatterCuda(const int pillar_count, int *x_coors,
                                 int *y_coors, float *pfe_output,
                                 float *scattered_feature) {
-  scatter_kernel&lt;&lt;&lt;pillar_count, num_threads_&gt;&gt;&gt;(
-      x_coors, y_coors, pfe_output, scattered_feature, max_num_pillars_,
-      grid_x_size_, grid_y_size_);
+  scatter_kernel&lt;&lt;&lt;pillar_count, num_threads_&gt;&gt;&gt;(x_coors, y_coors, pfe_output,
+                                                 scattered_feature,
+                                                 grid_x_size_, grid_y_size_);
 }
 
 }  // namespace lidar
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\scatter_cuda.h" new_path="modules\perception\lidar\lib\detection\lidar_point_pillars\scatter_cuda.h" added_lines="2" deleted_lines="4">
				<diff>@@ -46,7 +46,6 @@ namespace lidar {
 class ScatterCuda {
  private:
   const int num_threads_;
-  const int max_num_pillars_;
   const int grid_x_size_;
   const int grid_y_size_;
 
@@ -54,13 +53,12 @@ class ScatterCuda {
   /**
    * @brief Constructor
    * @param[in] num_threads The number of threads to launch cuda kernel
-   * @param[in] max_num_pillars Maximum number of pillars
    * @param[in] grid_x_size Number of pillars in x-coordinate
    * @param[in] grid_y_size Number of pillars in y-coordinate
    * @details Captital variables never change after the compile
    */
-  ScatterCuda(const int num_threads, const int max_num_pillars,
-              const int grid_x_size, const int grid_y_size);
+  ScatterCuda(const int num_threads, const int grid_x_size,
+              const int grid_y_size);
 
   /**
    * @brief Call scatter cuda kernel
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="29592467aba3c3acefe4168c42fc36af5d778227" author="storypku">
		<msg>Build: remove redundant gflags deps for control/submodules/preprocessor_submodule</msg>
		<modified_files>
			<file old_path="modules\control\submodules\preprocessor_submodule.h" new_path="modules\control\submodules\preprocessor_submodule.h" added_lines="1" deleted_lines="0">
				<diff>@@ -102,5 +102,6 @@ class PreprocessorSubmodule final : public cyber::Component&lt;LocalView&gt; {
 };
 
 CYBER_REGISTER_COMPONENT(PreprocessorSubmodule);
+
 }  // namespace control
 }  // namespace apollo
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="91a69d5a0d1f73f706d42d283625672cc7069cb7" author="Xiangquan Xiao">
		<msg>All: Fix missing gflags header.</msg>
		<modified_files>
			<file old_path="cyber\record\file\record_file_test.cc" new_path="cyber\record\file\record_file_test.cc" added_lines="2" deleted_lines="0">
				<diff>@@ -17,6 +17,8 @@
 #include &lt;unistd.h&gt;
 #include &lt;atomic&gt;
 #include &lt;string&gt;
+
+#include "gflags/gflags.h"
 #include "gtest/gtest.h"
 
 #include "cyber/record/file/record_file_base.h"
</diff>
			</file>
			<file old_path="modules\map\hdmap\hdmap_impl_test.cc" new_path="modules\map\hdmap\hdmap_impl_test.cc" added_lines="1" deleted_lines="0">
				<diff>@@ -16,6 +16,7 @@ limitations under the License.
 #include &lt;chrono&gt;
 
 #include "absl/strings/str_cat.h"
+#include "gflags/gflags.h"
 #include "gtest/gtest.h"
 
 #include "cyber/common/file.h"
</diff>
			</file>
			<file old_path="modules\perception\onboard\transform_wrapper\transform_wrapper.h" new_path="modules\perception\onboard\transform_wrapper\transform_wrapper.h" added_lines="1" deleted_lines="0">
				<diff>@@ -21,6 +21,7 @@
 
 #include "Eigen/Core"
 #include "Eigen/Dense"
+#include "gflags/gflags.h"
 
 #include "modules/transform/buffer.h"
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="2ee198e08a85ba889e891f0ebdb5106f75f5930c" author="storypku">
		<msg>modules.common: fix eigen align issues of kalman_filter_test</msg>
		<modified_files>
			<file old_path="modules\common\math\kalman_filter_test.cc" new_path="modules\common\math\kalman_filter_test.cc" added_lines="3" deleted_lines="0">
				<diff>@@ -23,6 +23,9 @@ namespace common {
 namespace math {
 
 class KalmanFilterTest : public ::testing::Test {
+ public:
+  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+
  public:
   KalmanFilterTest() : kf_() {}
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="06253f8cde316be183c5aa37815d6769bc1b8da0" author="liufeng31">
		<msg>Drivers: rearrange driver files and configurations</msg>
		<modified_files>
			<file old_path="modules\drivers\hesai\const_var.h" new_path="modules\drivers\lidar\hesai\common\const_var.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="modules\drivers\hesai\type_defs.h" new_path="modules\drivers\lidar\hesai\common\type_defs.h" added_lines="1" deleted_lines="1">
				<diff>@@ -18,7 +18,7 @@
 #define LIDAR_HESAI_SRC_TYPE_DEFS_H_
 
 #include &lt;ctime&gt;
-#include "modules/drivers/hesai/const_var.h"
+#include "modules/drivers/lidar/hesai/common/const_var.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\hesai\driver.cc" new_path="modules\drivers\lidar\hesai\driver\driver.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -14,7 +14,7 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/drivers/hesai/driver.h"
+#include "modules/drivers/lidar/hesai/driver/driver.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\hesai\driver.h" new_path="modules\drivers\lidar\hesai\driver\driver.h" added_lines="2" deleted_lines="2">
				<diff>@@ -29,8 +29,8 @@
 #include &lt;vector&gt;
 
 #include "cyber/cyber.h"
-#include "modules/drivers/hesai/parser.h"
-#include "modules/drivers/hesai/udp_input.h"
+#include "modules/drivers/lidar/hesai/parser/parser.h"
+#include "modules/drivers/lidar/hesai/input/udp_input.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\hesai\hesai_component.cc" new_path="modules\drivers\lidar\hesai\driver\hesai_component.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *****************************************************************************/
-#include "modules/drivers/hesai/hesai_component.h"
+#include "modules/drivers/lidar/hesai/driver/hesai_component.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\hesai\hesai_component.h" new_path="modules\drivers\lidar\hesai\driver\hesai_component.h" added_lines="3" deleted_lines="3">
				<diff>@@ -19,10 +19,10 @@
 #include &lt;memory&gt;
 #include &lt;string&gt;
 
-#include "modules/drivers/hesai/proto/config.pb.h"
+#include "modules/drivers/lidar/hesai/proto/config.pb.h"
 #include "cyber/cyber.h"
-#include "modules/drivers/hesai/driver.h"
-#include "modules/drivers/hesai/parser_factory.h"
+#include "modules/drivers/lidar/hesai/driver/driver.h"
+#include "modules/drivers/lidar/hesai/parser/parser_factory.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\hesai\udp_input.cc" new_path="modules\drivers\lidar\hesai\input\udp_input.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -14,7 +14,7 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/drivers/hesai/udp_input.h"
+#include "modules/drivers/lidar/hesai/input/udp_input.h"
 
 #include &lt;arpa/inet.h&gt;
 #include &lt;fcntl.h&gt;
</diff>
			</file>
			<file old_path="modules\drivers\hesai\udp_input.h" new_path="modules\drivers\lidar\hesai\input\udp_input.h" added_lines="1" deleted_lines="1">
				<diff>@@ -18,7 +18,7 @@
 #define LIDAR_HESAI_SRC_INPUT_H_
 
 #include &lt;cstdint&gt;
-#include "modules/drivers/hesai/type_defs.h"
+#include "modules/drivers/lidar/hesai/common/type_defs.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\hesai\hesai40_parser.cc" new_path="modules\drivers\lidar\hesai\parser\hesai40_parser.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -14,7 +14,7 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/drivers/hesai/hesai40_parser.h"
+#include "modules/drivers/lidar/hesai/parser/hesai40_parser.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\hesai\hesai40_parser.h" new_path="modules\drivers\lidar\hesai\parser\hesai40_parser.h" added_lines="1" deleted_lines="1">
				<diff>@@ -19,7 +19,7 @@
 #include &lt;memory&gt;
 
 #include "cyber/cyber.h"
-#include "modules/drivers/hesai/parser.h"
+#include "modules/drivers/lidar/hesai/parser/parser.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\hesai\hesai64_parser.cc" new_path="modules\drivers\lidar\hesai\parser\hesai64_parser.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -14,7 +14,7 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/drivers/hesai/hesai64_parser.h"
+#include "modules/drivers/lidar/hesai/parser/hesai64_parser.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\hesai\hesai64_parser.h" new_path="modules\drivers\lidar\hesai\parser\hesai64_parser.h" added_lines="1" deleted_lines="1">
				<diff>@@ -19,7 +19,7 @@
 #include &lt;memory&gt;
 
 #include "cyber/cyber.h"
-#include "modules/drivers/hesai/parser.h"
+#include "modules/drivers/lidar/hesai/parser/parser.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\hesai\hesai_convert_component.cc" new_path="modules\drivers\lidar\hesai\parser\hesai_convert_component.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -14,7 +14,7 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/drivers/hesai/hesai_convert_component.h"
+#include "modules/drivers/lidar/hesai/parser/hesai_convert_component.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\hesai\hesai_convert_component.h" new_path="modules\drivers\lidar\hesai\parser\hesai_convert_component.h" added_lines="3" deleted_lines="3">
				<diff>@@ -19,10 +19,10 @@
 #include &lt;memory&gt;
 #include &lt;string&gt;
 
-#include "modules/drivers/hesai/proto/config.pb.h"
-#include "modules/drivers/hesai/proto/hesai.pb.h"
+#include "modules/drivers/lidar/hesai/proto/config.pb.h"
+#include "modules/drivers/lidar/hesai/proto/hesai.pb.h"
 #include "cyber/cyber.h"
-#include "modules/drivers/hesai/parser_factory.h"
+#include "modules/drivers/lidar/hesai/parser/parser_factory.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\hesai\parser.cc" new_path="modules\drivers\lidar\hesai\parser\parser.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -18,7 +18,7 @@
 #include &lt;memory&gt;
 #include &lt;string&gt;
 
-#include "modules/drivers/hesai/parser.h"
+#include "modules/drivers/lidar/hesai/parser/parser.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\hesai\parser.h" new_path="modules\drivers\lidar\hesai\parser\parser.h" added_lines="4" deleted_lines="4">
				<diff>@@ -23,13 +23,13 @@
 #include &lt;thread&gt;
 #include &lt;vector&gt;
 
-#include "modules/drivers/hesai/proto/config.pb.h"
-#include "modules/drivers/hesai/proto/hesai.pb.h"
+#include "modules/drivers/lidar/hesai/proto/config.pb.h"
+#include "modules/drivers/lidar/hesai/proto/hesai.pb.h"
 #include "modules/drivers/proto/pointcloud.pb.h"
 
 #include "cyber/cyber.h"
-#include "modules/drivers/hesai/tcp_cmd_client.h"
-#include "modules/drivers/hesai/type_defs.h"
+#include "modules/drivers/lidar/hesai/parser/tcp_cmd_client.h"
+#include "modules/drivers/lidar/hesai/common/type_defs.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\hesai\parser_factory.cc" new_path="modules\drivers\lidar\hesai\parser\parser_factory.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -14,10 +14,10 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/drivers/hesai/parser_factory.h"
+#include "modules/drivers/lidar/hesai/parser/parser_factory.h"
 
-#include "modules/drivers/hesai/hesai40_parser.h"
-#include "modules/drivers/hesai/hesai64_parser.h"
+#include "modules/drivers/lidar/hesai/parser/hesai40_parser.h"
+#include "modules/drivers/lidar/hesai/parser/hesai64_parser.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\hesai\parser_factory.h" new_path="modules\drivers\lidar\hesai\parser\parser_factory.h" added_lines="1" deleted_lines="1">
				<diff>@@ -19,7 +19,7 @@
 #include &lt;memory&gt;
 
 #include "cyber/cyber.h"
-#include "modules/drivers/hesai/parser.h"
+#include "modules/drivers/lidar/hesai/parser/parser.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\hesai\tcp_cmd_client.cc" new_path="modules\drivers\lidar\hesai\parser\tcp_cmd_client.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -33,7 +33,7 @@
 #include &lt;cstring&gt;
 
 #include "cyber/cyber.h"
-#include "modules/drivers/hesai/tcp_cmd_client.h"
+#include "modules/drivers/lidar/hesai/parser/tcp_cmd_client.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\hesai\tcp_cmd_client.h" new_path="modules\drivers\lidar\hesai\parser\tcp_cmd_client.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="modules\drivers\robosense\decoder\decoder_128.hpp" new_path="modules\drivers\lidar\robosense\decoder\decoder_128.hpp" added_lines="1" deleted_lines="1">
				<diff>@@ -19,7 +19,7 @@
 #include &lt;utility&gt;
 #include &lt;vector&gt;
 
-#include "modules/drivers/robosense/decoder/decoder_base.hpp"
+#include "modules/drivers/lidar/robosense/decoder/decoder_base.hpp"
 namespace apollo {
 namespace drivers {
 namespace robosense {
</diff>
			</file>
			<file old_path="modules\drivers\robosense\decoder\decoder_16.hpp" new_path="modules\drivers\lidar\robosense\decoder\decoder_16.hpp" added_lines="1" deleted_lines="1">
				<diff>@@ -19,7 +19,7 @@
 #include &lt;utility&gt;
 #include &lt;vector&gt;
 
-#include "modules/drivers/robosense/decoder/decoder_base.hpp"
+#include "modules/drivers/lidar/robosense/decoder/decoder_base.hpp"
 namespace apollo {
 namespace drivers {
 namespace robosense {
</diff>
			</file>
			<file old_path="modules\drivers\robosense\decoder\decoder_32.hpp" new_path="modules\drivers\lidar\robosense\decoder\decoder_32.hpp" added_lines="1" deleted_lines="1">
				<diff>@@ -19,7 +19,7 @@
 #include &lt;utility&gt;
 #include &lt;vector&gt;
 
-#include "modules/drivers/robosense/decoder/decoder_base.hpp"
+#include "modules/drivers/lidar/robosense/decoder/decoder_base.hpp"
 namespace apollo {
 namespace drivers {
 namespace robosense {
</diff>
			</file>
			<file old_path="modules\drivers\robosense\decoder\decoder_base.hpp" new_path="modules\drivers\lidar\robosense\decoder\decoder_base.hpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="modules\drivers\robosense\decoder\decoder_bp.hpp" new_path="modules\drivers\lidar\robosense\decoder\decoder_bp.hpp" added_lines="1" deleted_lines="1">
				<diff>@@ -19,7 +19,7 @@
 #include &lt;utility&gt;
 #include &lt;vector&gt;
 
-#include "modules/drivers/robosense/decoder/decoder_base.hpp"
+#include "modules/drivers/lidar/robosense/decoder/decoder_base.hpp"
 namespace apollo {
 namespace drivers {
 namespace robosense {
</diff>
			</file>
			<file old_path="modules\drivers\robosense\decoder\decoder_factory.hpp" new_path="modules\drivers\lidar\robosense\decoder\decoder_factory.hpp" added_lines="4" deleted_lines="4">
				<diff>@@ -17,10 +17,10 @@
 #include &lt;memory&gt;
 #include &lt;string&gt;
 
-#include "modules/drivers/robosense/decoder/decoder_128.hpp"
-#include "modules/drivers/robosense/decoder/decoder_16.hpp"
-#include "modules/drivers/robosense/decoder/decoder_32.hpp"
-#include "modules/drivers/robosense/decoder/decoder_bp.hpp"
+#include "modules/drivers/lidar/robosense/decoder/decoder_128.hpp"
+#include "modules/drivers/lidar/robosense/decoder/decoder_16.hpp"
+#include "modules/drivers/lidar/robosense/decoder/decoder_32.hpp"
+#include "modules/drivers/lidar/robosense/decoder/decoder_bp.hpp"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\robosense\driver\driver.cpp" new_path="modules\drivers\lidar\robosense\driver\driver.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *****************************************************************************/
-#include "modules/drivers/robosense/driver/driver.h"
+#include "modules/drivers/lidar/robosense/driver/driver.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\robosense\driver\driver.h" new_path="modules\drivers\lidar\robosense\driver\driver.h" added_lines="6" deleted_lines="6">
				<diff>@@ -20,14 +20,14 @@
 #include &lt;vector&gt;
 
 #include "modules/drivers/proto/pointcloud.pb.h"
-#include "modules/drivers/robosense/proto/config.pb.h"
-#include "modules/drivers/robosense/proto/robosense.pb.h"
+#include "modules/drivers/lidar/robosense/proto/config.pb.h"
+#include "modules/drivers/lidar/robosense/proto/robosense.pb.h"
 
 #include "cyber/cyber.h"
-#include "modules/drivers/robosense/decoder/decoder_16.hpp"
-#include "modules/drivers/robosense/decoder/decoder_factory.hpp"
-#include "modules/drivers/robosense/driver/utility.h"
-#include "modules/drivers/robosense/input/input.h"
+#include "modules/drivers/lidar/robosense/decoder/decoder_16.hpp"
+#include "modules/drivers/lidar/robosense/decoder/decoder_factory.hpp"
+#include "modules/drivers/lidar/robosense/driver/utility.h"
+#include "modules/drivers/lidar/robosense/input/input.h"
 #define PKT_DATA_LENGTH 1248
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\robosense\driver\robosense_driver_component.cc" new_path="modules\drivers\lidar\robosense\driver\robosense_driver_component.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -14,4 +14,4 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/drivers/robosense/driver/robosense_driver_component.h"
+#include "modules/drivers/lidar/robosense/driver/robosense_driver_component.h"
</diff>
			</file>
			<file old_path="modules\drivers\robosense\driver\robosense_driver_component.h" new_path="modules\drivers\lidar\robosense\driver\robosense_driver_component.h" added_lines="2" deleted_lines="2">
				<diff>@@ -19,10 +19,10 @@
 #include &lt;string&gt;
 #include &lt;thread&gt;
 
-#include "modules/drivers/robosense/proto/config.pb.h"
+#include "modules/drivers/lidar/robosense/proto/config.pb.h"
 
 #include "cyber/cyber.h"
-#include "modules/drivers/robosense/driver/driver.h"
+#include "modules/drivers/lidar/robosense/driver/driver.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\robosense\driver\utility.cpp" new_path="modules\drivers\lidar\robosense\driver\utility.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *****************************************************************************/
-#include "modules/drivers/robosense/driver/utility.h"
+#include "modules/drivers/lidar/robosense/driver/utility.h"
 namespace apollo {
 namespace drivers {
 namespace robosense {
</diff>
			</file>
			<file old_path="modules\drivers\robosense\driver\utility.h" new_path="modules\drivers\lidar\robosense\driver\utility.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="modules\drivers\robosense\input\input.cpp" new_path="modules\drivers\lidar\robosense\input\input.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *****************************************************************************/
-#include "modules/drivers/robosense/input/input.h"
+#include "modules/drivers/lidar/robosense/input/input.h"
 namespace apollo {
 namespace drivers {
 
</diff>
			</file>
			<file old_path="modules\drivers\robosense\input\input.h" new_path="modules\drivers\lidar\robosense\input\input.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="modules\drivers\robosense\param\rs128\angle.csv" new_path="modules\drivers\lidar\robosense\param\rs128\angle.csv" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="modules\drivers\velodyne\compensator\compensator.cc" new_path="modules\drivers\lidar\velodyne\compensator\compensator.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -14,7 +14,7 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/drivers/velodyne/compensator/compensator.h"
+#include "modules/drivers/lidar/velodyne/compensator/compensator.h"
 
 #include &lt;limits&gt;
 #include &lt;memory&gt;
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\compensator\compensator.h" new_path="modules\drivers\lidar\velodyne\compensator\compensator.h" added_lines="1" deleted_lines="1">
				<diff>@@ -28,7 +28,7 @@
 #endif
 
 #include "modules/drivers/proto/pointcloud.pb.h"
-#include "modules/drivers/velodyne/proto/config.pb.h"
+#include "modules/drivers/lidar/velodyne/proto/config.pb.h"
 #include "modules/transform/buffer.h"
 
 namespace apollo {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\compensator\compensator_component.cc" new_path="modules\drivers\lidar\velodyne\compensator\compensator_component.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *****************************************************************************/
-#include "modules/drivers/velodyne/compensator/compensator_component.h"
+#include "modules/drivers/lidar/velodyne/compensator/compensator_component.h"
 
 #include &lt;memory&gt;
 
@@ -21,7 +21,7 @@
 
 #include "modules/common/adapters/adapter_gflags.h"
 #include "modules/common/latency_recorder/latency_recorder.h"
-#include "modules/drivers/velodyne/proto/velodyne.pb.h"
+#include "modules/drivers/lidar/velodyne/proto/velodyne.pb.h"
 
 using apollo::cyber::Time;
 
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\compensator\compensator_component.h" new_path="modules\drivers\lidar\velodyne\compensator\compensator_component.h" added_lines="1" deleted_lines="1">
				<diff>@@ -22,7 +22,7 @@
 #include "cyber/base/concurrent_object_pool.h"
 #include "cyber/cyber.h"
 
-#include "modules/drivers/velodyne/compensator/compensator.h"
+#include "modules/drivers/lidar/velodyne/compensator/compensator.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\driver\driver.cc" new_path="modules\drivers\lidar\velodyne\driver\driver.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -14,7 +14,7 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/drivers/velodyne/driver/driver.h"
+#include "modules/drivers/lidar/velodyne/driver/driver.h"
 
 #include &lt;cmath&gt;
 #include &lt;ctime&gt;
@@ -22,8 +22,8 @@
 #include &lt;thread&gt;
 
 #include "cyber/cyber.h"
-#include "modules/drivers/velodyne/proto/config.pb.h"
-#include "modules/drivers/velodyne/proto/velodyne.pb.h"
+#include "modules/drivers/lidar/velodyne/proto/config.pb.h"
+#include "modules/drivers/lidar/velodyne/proto/velodyne.pb.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\driver\driver.h" new_path="modules\drivers\lidar\velodyne\driver\driver.h" added_lines="3" deleted_lines="3">
				<diff>@@ -19,9 +19,9 @@
 #include &lt;memory&gt;
 #include &lt;string&gt;
 
-#include "modules/drivers/velodyne/driver/socket_input.h"
-#include "modules/drivers/velodyne/proto/config.pb.h"
-#include "modules/drivers/velodyne/proto/velodyne.pb.h"
+#include "modules/drivers/lidar/velodyne/driver/socket_input.h"
+#include "modules/drivers/lidar/velodyne/proto/config.pb.h"
+#include "modules/drivers/lidar/velodyne/proto/velodyne.pb.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\driver\driver64.cc" new_path="modules\drivers\lidar\velodyne\driver\driver64.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -18,7 +18,7 @@
 #include &lt;ctime&gt;
 #include &lt;string&gt;
 
-#include "modules/drivers/velodyne/driver/driver.h"
+#include "modules/drivers/lidar/velodyne/driver/driver.h"
 // #include "ros/ros.h"
 
 namespace apollo {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\driver\input.cc" new_path="modules\drivers\lidar\velodyne\driver\input.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -14,7 +14,7 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/drivers/velodyne/driver/input.h"
+#include "modules/drivers/lidar/velodyne/driver/input.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\driver\input.h" new_path="modules\drivers\lidar\velodyne\driver\input.h" added_lines="1" deleted_lines="1">
				<diff>@@ -23,7 +23,7 @@
 #include "cyber/cyber.h"
 
 // #include "velodyne_msgs/VelodyneScanUnified.h"
-#include "modules/drivers/velodyne/proto/velodyne.pb.h"
+#include "modules/drivers/lidar/velodyne/proto/velodyne.pb.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\driver\socket_input.cc" new_path="modules\drivers\lidar\velodyne\driver\socket_input.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -33,7 +33,7 @@
 #include &lt;unistd.h&gt;
 #include &lt;cerrno&gt;
 
-#include "modules/drivers/velodyne/driver/socket_input.h"
+#include "modules/drivers/lidar/velodyne/driver/socket_input.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\driver\socket_input.h" new_path="modules\drivers\lidar\velodyne\driver\socket_input.h" added_lines="1" deleted_lines="1">
				<diff>@@ -19,7 +19,7 @@
 #include &lt;unistd.h&gt;
 #include &lt;cstdio&gt;
 
-#include "modules/drivers/velodyne/driver/input.h"
+#include "modules/drivers/lidar/velodyne/driver/input.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\driver\velodyne_driver_component.cc" new_path="modules\drivers\lidar\velodyne\driver\velodyne_driver_component.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -21,7 +21,7 @@
 #include "cyber/cyber.h"
 
 #include "modules/common/util/message_util.h"
-#include "modules/drivers/velodyne/driver/velodyne_driver_component.h"
+#include "modules/drivers/lidar/velodyne/driver/velodyne_driver_component.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\driver\velodyne_driver_component.h" new_path="modules\drivers\lidar\velodyne\driver\velodyne_driver_component.h" added_lines="3" deleted_lines="3">
				<diff>@@ -21,9 +21,9 @@
 
 #include "cyber/cyber.h"
 
-#include "modules/drivers/velodyne/driver/driver.h"
-#include "modules/drivers/velodyne/proto/config.pb.h"
-#include "modules/drivers/velodyne/proto/velodyne.pb.h"
+#include "modules/drivers/lidar/velodyne/driver/driver.h"
+#include "modules/drivers/lidar/velodyne/proto/config.pb.h"
+#include "modules/drivers/lidar/velodyne/proto/velodyne.pb.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\fusion\pri_sec_fusion_component.cc" new_path="modules\drivers\lidar\velodyne\fusion\pri_sec_fusion_component.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -14,7 +14,7 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/drivers/velodyne/fusion/pri_sec_fusion_component.h"
+#include "modules/drivers/lidar/velodyne/fusion/pri_sec_fusion_component.h"
 
 #include &lt;memory&gt;
 #include &lt;thread&gt;
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\fusion\pri_sec_fusion_component.h" new_path="modules\drivers\lidar\velodyne\fusion\pri_sec_fusion_component.h" added_lines="1" deleted_lines="1">
				<diff>@@ -30,7 +30,7 @@
 
 #include "cyber/cyber.h"
 #include "modules/drivers/proto/pointcloud.pb.h"
-#include "modules/drivers/velodyne/proto/config.pb.h"
+#include "modules/drivers/lidar/velodyne/proto/config.pb.h"
 #include "modules/transform/buffer.h"
 
 namespace apollo {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\parser\calibration.cc" new_path="modules\drivers\lidar\velodyne\parser\calibration.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -27,7 +27,7 @@
  * $ Id: 02/14/2012 11:36:36 AM piyushk $
  */
 
-#include "modules/drivers/velodyne/parser/calibration.h"
+#include "modules/drivers/lidar/velodyne/parser/calibration.h"
 
 #include &lt;cmath&gt;
 #include &lt;fstream&gt;
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\parser\calibration.h" new_path="modules\drivers\lidar\velodyne\parser\calibration.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="modules\drivers\velodyne\parser\const_variables.h" new_path="modules\drivers\lidar\velodyne\parser\const_variables.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="modules\drivers\velodyne\parser\convert.cc" new_path="modules\drivers\lidar\velodyne\parser\convert.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -14,7 +14,7 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/drivers/velodyne/parser/convert.h"
+#include "modules/drivers/lidar/velodyne/parser/convert.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\parser\convert.h" new_path="modules\drivers\lidar\velodyne\parser\convert.h" added_lines="3" deleted_lines="3">
				<diff>@@ -20,9 +20,9 @@
 #include &lt;string&gt;
 
 #include "modules/drivers/proto/pointcloud.pb.h"
-#include "modules/drivers/velodyne/parser/velodyne_parser.h"
-#include "modules/drivers/velodyne/proto/config.pb.h"
-#include "modules/drivers/velodyne/proto/velodyne.pb.h"
+#include "modules/drivers/lidar/velodyne/parser/velodyne_parser.h"
+#include "modules/drivers/lidar/velodyne/proto/config.pb.h"
+#include "modules/drivers/lidar/velodyne/proto/velodyne.pb.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\parser\online_calibration.cc" new_path="modules\drivers\lidar\velodyne\parser\online_calibration.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -14,7 +14,7 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/drivers/velodyne/parser/online_calibration.h"
+#include "modules/drivers/lidar/velodyne/parser/online_calibration.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\parser\online_calibration.h" new_path="modules\drivers\lidar\velodyne\parser\online_calibration.h" added_lines="2" deleted_lines="2">
				<diff>@@ -22,8 +22,8 @@
 
 #include "cyber/cyber.h"
 
-#include "modules/drivers/velodyne/parser/calibration.h"
-#include "modules/drivers/velodyne/proto/velodyne.pb.h"
+#include "modules/drivers/lidar/velodyne/parser/calibration.h"
+#include "modules/drivers/lidar/velodyne/proto/velodyne.pb.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\parser\util.cc" new_path="modules\drivers\lidar\velodyne\parser\util.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -14,7 +14,7 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/drivers/velodyne/parser/util.h"
+#include "modules/drivers/lidar/velodyne/parser/util.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\parser\util.h" new_path="modules\drivers\lidar\velodyne\parser\util.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="modules\drivers\velodyne\parser\velodyne128_parser.cc" new_path="modules\drivers\lidar\velodyne\parser\velodyne128_parser.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -14,7 +14,7 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/drivers/velodyne/parser/velodyne_parser.h"
+#include "modules/drivers/lidar/velodyne/parser/velodyne_parser.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\parser\velodyne16_parser.cc" new_path="modules\drivers\lidar\velodyne\parser\velodyne16_parser.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -14,7 +14,7 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/drivers/velodyne/parser/velodyne_parser.h"
+#include "modules/drivers/lidar/velodyne/parser/velodyne_parser.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\parser\velodyne32_parser.cc" new_path="modules\drivers\lidar\velodyne\parser\velodyne32_parser.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -14,7 +14,7 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/drivers/velodyne/parser/velodyne_parser.h"
+#include "modules/drivers/lidar/velodyne/parser/velodyne_parser.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\parser\velodyne64_parser.cc" new_path="modules\drivers\lidar\velodyne\parser\velodyne64_parser.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -14,7 +14,7 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/drivers/velodyne/parser/velodyne_parser.h"
+#include "modules/drivers/lidar/velodyne/parser/velodyne_parser.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\parser\velodyne_convert_component.cc" new_path="modules\drivers\lidar\velodyne\parser\velodyne_convert_component.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -20,7 +20,7 @@
 
 #include "cyber/cyber.h"
 
-#include "modules/drivers/velodyne/parser/velodyne_convert_component.h"
+#include "modules/drivers/lidar/velodyne/parser/velodyne_convert_component.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\parser\velodyne_convert_component.h" new_path="modules\drivers\lidar\velodyne\parser\velodyne_convert_component.h" added_lines="3" deleted_lines="3">
				<diff>@@ -24,9 +24,9 @@
 #include "cyber/base/concurrent_object_pool.h"
 #include "cyber/cyber.h"
 
-#include "modules/drivers/velodyne/parser/convert.h"
-#include "modules/drivers/velodyne/proto/config.pb.h"
-#include "modules/drivers/velodyne/proto/velodyne.pb.h"
+#include "modules/drivers/lidar/velodyne/parser/convert.h"
+#include "modules/drivers/lidar/velodyne/proto/config.pb.h"
+#include "modules/drivers/lidar/velodyne/proto/velodyne.pb.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\parser\velodyne_parser.cc" new_path="modules\drivers\lidar\velodyne\parser\velodyne_parser.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -16,8 +16,8 @@
 
 #include "cyber/cyber.h"
 
-#include "modules/drivers/velodyne/parser/util.h"
-#include "modules/drivers/velodyne/parser/velodyne_parser.h"
+#include "modules/drivers/lidar/velodyne/parser/util.h"
+#include "modules/drivers/lidar/velodyne/parser/velodyne_parser.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\velodyne\parser\velodyne_parser.h" new_path="modules\drivers\lidar\velodyne\parser\velodyne_parser.h" added_lines="5" deleted_lines="5">
				<diff>@@ -60,11 +60,11 @@
 #include &lt;boost/format.hpp&gt;
 
 #include "modules/drivers/proto/pointcloud.pb.h"
-#include "modules/drivers/velodyne/parser/calibration.h"
-#include "modules/drivers/velodyne/parser/const_variables.h"
-#include "modules/drivers/velodyne/parser/online_calibration.h"
-#include "modules/drivers/velodyne/proto/config.pb.h"
-#include "modules/drivers/velodyne/proto/velodyne.pb.h"
+#include "modules/drivers/lidar/velodyne/parser/calibration.h"
+#include "modules/drivers/lidar/velodyne/parser/const_variables.h"
+#include "modules/drivers/lidar/velodyne/parser/online_calibration.h"
+#include "modules/drivers/lidar/velodyne/proto/config.pb.h"
+#include "modules/drivers/lidar/velodyne/proto/velodyne.pb.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3560ac35143000e8f7911564bceedcda083fe72d" author="changsh726">
		<msg>Monitor: use module_monitor only for MonitoredComponent</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\hmi\hmi_worker.cc" new_path="modules\dreamview\backend\hmi\hmi_worker.cc" added_lines="0" deleted_lines="18">
				<diff>@@ -206,24 +206,6 @@ HMIMode HMIWorker::LoadMode(const std::string&amp; mode_config_path) {
     // Construct process_monitor_config.
     module.mutable_process_monitor_config()-&gt;add_command_keywords("mainboard");
     module.mutable_process_monitor_config()-&gt;add_command_keywords(first_dag);
-    // Construct module_monitor_config.
-    DagConfig dag_config;
-    for (const std::string&amp; dag : cyber_module.dag_files()) {
-      if (!cyber::common::GetProtoFromFile(dag, &amp;dag_config)) {
-        AERROR &lt;&lt; "Unable to parse dag config file " &lt;&lt; dag;
-        continue;
-      }
-      for (const auto&amp; module_config : dag_config.module_config()) {
-        for (const auto&amp; component : module_config.components()) {
-          module.mutable_module_monitor_config()-&gt;add_node_name(
-              component.config().name());
-        }
-        for (const auto&amp; timer_component : module_config.timer_components()) {
-          module.mutable_module_monitor_config()-&gt;add_node_name(
-              timer_component.config().name());
-        }
-      }
-    }
   }
   mode.clear_cyber_modules();
   AINFO &lt;&lt; "Loaded HMI mode: " &lt;&lt; mode.DebugString();
</diff>
			</file>
			<file old_path="modules\monitor\software\module_monitor.cc" new_path="modules\monitor\software\module_monitor.cc" added_lines="0" deleted_lines="11">
				<diff>@@ -44,17 +44,6 @@ void ModuleMonitor::RunOnce(const double current_time) {
   auto manager = MonitorManager::Instance();
   const auto&amp; mode = manager-&gt;GetHMIMode();
 
-  // Check HMI modules.
-  auto* hmi_modules = manager-&gt;GetStatus()-&gt;mutable_hmi_modules();
-  for (const auto&amp; iter : mode.modules()) {
-    const std::string&amp; module_name = iter.first;
-    const auto&amp; component = iter.second;
-    if (component.has_module_monitor_config()) {
-      const auto&amp; config = component.module_monitor_config();
-      UpdateStatus(config, module_name, &amp;hmi_modules-&gt;at(module_name));
-    }
-  }
-
   // Check monitored components.
   auto* components = manager-&gt;GetStatus()-&gt;mutable_components();
   for (const auto&amp; iter : mode.monitored_components()) {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="954a8985b1552f9a344c6e88f613ab7bf5687bfb" author="panxuechao">
		<msg>dreamview: fix the inappropriate battery percentage (#13042)</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_service.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_service.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -542,9 +542,9 @@ void SimulationWorldService::UpdateSimulationWorld(const Chassis &amp;chassis) {
 
   auto_driving_car-&gt;set_disengage_type(DeduceDisengageType(chassis));
 
-  auto_driving_car-&gt;set_battery_soc_percentage(
+  auto_driving_car-&gt;set_battery_percentage(
     chassis.battery_soc_percentage());
-  auto_driving_car-&gt;set_gear_localtion(chassis.gear_location());
+  auto_driving_car-&gt;set_gear_location(chassis.gear_location());
 }
 
 template &lt;&gt;
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_service_test.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_service_test.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -184,8 +184,8 @@ TEST_F(SimulationWorldServiceTest, UpdateChassisInfo) {
   EXPECT_DOUBLE_EQ(50.0, car.throttle_percentage());
   EXPECT_DOUBLE_EQ(10.0, car.brake_percentage());
   EXPECT_DOUBLE_EQ(25.0, car.steering_percentage());
-  EXPECT_EQ(80, car.battery_soc_percentage());
-  EXPECT_EQ(Chassis::GEAR_DRIVE, car.gear_localtion());
+  EXPECT_EQ(80, car.battery_percentage());
+  EXPECT_EQ(Chassis::GEAR_DRIVE, car.gear_location());
   EXPECT_EQ("RIGHT", car.current_signal());
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6069b0bbf6990ec156a9009a3ecdfc7df1072bf3" author="">
		<msg>canbus: neolix_edu add battery signals (#13044)</msg>
		<modified_files>
			<file old_path="modules\canbus\vehicle\neolix_edu\neolix_edu_controller.cc" new_path="modules\canbus\vehicle\neolix_edu\neolix_edu_controller.cc" added_lines="12" deleted_lines="2">
				<diff>@@ -164,7 +164,7 @@ Chassis Neolix_eduController::chassis() {
   // 3
   chassis_.set_engine_started(true);
 
-  // 4 speed_mps
+  // 3 speed_mps
   if (chassis_detail.neolix_edu().has_aeb_frontwheelspeed_353() &amp;&amp;
       chassis_detail.neolix_edu().has_aeb_rearwheelspeed_354()) {
     auto wheelspeed = chassis_.mutable_wheel_speed();
@@ -185,7 +185,17 @@ Chassis Neolix_eduController::chassis() {
   } else {
     chassis_.set_speed_mps(0);
   }
-
+  // 4 SOC
+  if (chassis_detail.neolix_edu().has_vcu_vehicle_status_report_101() &amp;&amp;
+      chassis_detail.neolix_edu()
+          .vcu_vehicle_status_report_101()
+          .has_vcu_display_soc()) {
+    chassis_.set_battery_soc_percentage(chassis_detail.neolix_edu()
+                                            .vcu_vehicle_status_report_101()
+                                            .vcu_display_soc());
+  } else {
+    chassis_.set_battery_soc_percentage(0);
+  }
   // 5 steering
   if (chassis_detail.neolix_edu().has_vcu_eps_report_57() &amp;&amp;
       chassis_detail.neolix_edu().vcu_eps_report_57().has_vcu_real_angle()) {
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\neolix_edu\protocol\vcu_powerstatus_214.cc" new_path="modules\canbus\vehicle\neolix_edu\protocol\vcu_powerstatus_214.cc" added_lines="41" deleted_lines="0">
				<diff>@@ -42,6 +42,16 @@ void Vcupowerstatus214::Parse(const std::uint8_t* bytes, int32_t length,
       -&gt;mutable_vcu_powerstatus_214()
       -&gt;set_replacebatterystateindication(
           replacebatterystateindication(bytes, length));
+  chassis-&gt;mutable_neolix_edu()
+      -&gt;mutable_vcu_powerstatus_214()
+      -&gt;set_forbidden_aeb_signal(forbidden_aeb_signal(bytes, length));
+  chassis-&gt;mutable_neolix_edu()
+      -&gt;mutable_vcu_powerstatus_214()
+      -&gt;set_bcu_chargedischargecurrent(
+          bcu_chargedischargecurrent(bytes, length));
+  chassis-&gt;mutable_neolix_edu()
+      -&gt;mutable_vcu_powerstatus_214()
+      -&gt;set_bcu_batt_internalvoltage(bcu_batt_internalvoltage(bytes, length));
   chassis-&gt;mutable_neolix_edu()
       -&gt;mutable_vcu_powerstatus_214()
       -&gt;set_vcu_driverinfo_alivecounter(
@@ -92,6 +102,37 @@ bool Vcupowerstatus214::replacebatterystateindication(const std::uint8_t* bytes,
   return ret;
 }
 
+bool Vcupowerstatus214::forbidden_aeb_signal(const std::uint8_t* bytes,
+                                             const int32_t length) const {
+  Byte t0(bytes + 1);
+  int32_t x = t0.get_byte(7, 1);
+
+  bool ret = x;
+  return ret;
+}
+
+float Vcupowerstatus214::bcu_chargedischargecurrent(
+    const std::uint8_t* bytes, const int32_t length) const {
+  Byte t0(bytes + 2);
+  Byte t1(bytes + 3);
+  int32_t x1 = t0.get_byte(0, 8);
+  int32_t x2 = t1.get_byte(0, 8);
+
+  int ret = (x1 &lt;&lt; 8 | x2) * 0.02 - 400;
+  return ret;
+}
+
+float Vcupowerstatus214::bcu_batt_internalvoltage(const std::uint8_t* bytes,
+                                                  const int32_t length) const {
+  Byte t0(bytes + 4);
+  Byte t1(bytes + 5);
+  int32_t x1 = t0.get_byte(0, 8);
+  int32_t x2 = t1.get_byte(0, 8);
+
+  int ret = (x1 &lt;&lt; 8 | x2) * 0.01;
+  return ret;
+}
+
 // config detail: {'name': 'vcu_driverinfo_alivecounter', 'offset': 0.0,
 // 'precision': 1.0, 'len': 4, 'is_signed_var': False, 'physical_range':
 // '[0|15]', 'bit': 55, 'type': 'int', 'order': 'motorola', 'physical_unit':
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\neolix_edu\protocol\vcu_powerstatus_214.h" new_path="modules\canbus\vehicle\neolix_edu\protocol\vcu_powerstatus_214.h" added_lines="21" deleted_lines="0">
				<diff>@@ -53,6 +53,27 @@ class Vcupowerstatus214 : public ::apollo::drivers::canbus::ProtocolData&lt;
   bool replacebatterystateindication(const std::uint8_t* bytes,
                                      const int32_t length) const;
 
+  // config detail: {'description': '0x0:Normal AEB;0x1:Forbidden', 'offset':
+  // 0.0, 'precision': 1.0, 'len': 1, 'name': 'forbidden_aeb_signal',
+  // 'is_signed_var': False, 'physical_range': '[0|1]', 'bit': 15, 'type':
+  // 'bool', 'order': 'motorola', 'physical_unit': 'bit'}
+  bool forbidden_aeb_signal(const std::uint8_t* bytes,
+                            const int32_t length) const;
+
+  // config detail: {'description': ';', 'offset': -400, 'precision': 0.02,
+  // 'len': 16, 'name': 'chargedischargecurrent', 'is_signed_var': False,
+  // 'physical_range': '[-400|910.68]', 'bit': 40, 'type': 'double', 'order':
+  // 'motorola', 'physical_unit': ''}
+  float bcu_chargedischargecurrent(const std::uint8_t* bytes,
+                                   const int32_t length) const;
+
+  // config detail: {'description': ';', 'offset': 0, 'precision': 0.01,
+  // 'len': 16, 'name': 'batt_internalvoltage', 'is_signed_var': False,
+  // 'physical_range': '[0|655.35]', 'bit': 54, 'type': 'double', 'order':
+  // 'motorola', 'physical_unit': ''}
+  float bcu_batt_internalvoltage(const std::uint8_t* bytes,
+                                 const int32_t length) const;
+
   // config detail: {'name': 'VCU_DriverInfo_AliveCounter', 'offset': 0.0,
   // 'precision': 1.0, 'len': 4, 'is_signed_var': False, 'physical_range':
   // '[0|15]', 'bit': 55, 'type': 'int', 'order': 'motorola', 'physical_unit':
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6b5a51583db8211b2369cf1af03ff881c9664153" author="JackFu123">
		<msg>task_manager: remove .pb* files</msg>
		<modified_files>
			<file old_path="modules\task_manager\proto\.pb.cc" new_path="" added_lines="0" deleted_lines="47">
				<diff>@@ -1,47 +0,0 @@
-// Generated by the protocol buffer compiler.  DO NOT EDIT!
-// source: modules/task_manager/proto/
-
-#include "modules/task_manager/proto/.pb.h"
-
-#include &lt;algorithm&gt;
-
-#include &lt;google/protobuf/io/coded_stream.h&gt;
-#include &lt;google/protobuf/extension_set.h&gt;
-#include &lt;google/protobuf/wire_format_lite.h&gt;
-#include &lt;google/protobuf/descriptor.h&gt;
-#include &lt;google/protobuf/generated_message_reflection.h&gt;
-#include &lt;google/protobuf/reflection_ops.h&gt;
-#include &lt;google/protobuf/wire_format.h&gt;
-// @@protoc_insertion_point(includes)
-#include &lt;google/protobuf/port_def.inc&gt;
-static constexpr ::PROTOBUF_NAMESPACE_ID::Metadata* file_level_metadata_modules_2ftask_5fmanager_2fproto_2f = nullptr;
-static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_modules_2ftask_5fmanager_2fproto_2f = nullptr;
-static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_modules_2ftask_5fmanager_2fproto_2f = nullptr;
-const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_modules_2ftask_5fmanager_2fproto_2f::offsets[1] = {};
-static constexpr ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema* schemas = nullptr;
-static constexpr ::PROTOBUF_NAMESPACE_ID::Message* const* file_default_instances = nullptr;
-
-const char descriptor_table_protodef_modules_2ftask_5fmanager_2fproto_2f[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
-  "\n\033modules/task_manager/proto/"
-  ;
-static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_modules_2ftask_5fmanager_2fproto_2f_deps[1] = {
-};
-static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_modules_2ftask_5fmanager_2fproto_2f_sccs[1] = {
-};
-static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_modules_2ftask_5fmanager_2fproto_2f_once;
-const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2ftask_5fmanager_2fproto_2f = {
-  false, false, descriptor_table_protodef_modules_2ftask_5fmanager_2fproto_2f, "modules/task_manager/proto/", 29,
-  &amp;descriptor_table_modules_2ftask_5fmanager_2fproto_2f_once, descriptor_table_modules_2ftask_5fmanager_2fproto_2f_sccs, descriptor_table_modules_2ftask_5fmanager_2fproto_2f_deps, 0, 0,
-  schemas, file_default_instances, TableStruct_modules_2ftask_5fmanager_2fproto_2f::offsets,
-  file_level_metadata_modules_2ftask_5fmanager_2fproto_2f, 0, file_level_enum_descriptors_modules_2ftask_5fmanager_2fproto_2f, file_level_service_descriptors_modules_2ftask_5fmanager_2fproto_2f,
-};
-
-// Force running AddDescriptors() at dynamic initialization time.
-static bool dynamic_init_dummy_modules_2ftask_5fmanager_2fproto_2f = (static_cast&lt;void&gt;(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&amp;descriptor_table_modules_2ftask_5fmanager_2fproto_2f)), true);
-
-// @@protoc_insertion_point(namespace_scope)
-PROTOBUF_NAMESPACE_OPEN
-PROTOBUF_NAMESPACE_CLOSE
-
-// @@protoc_insertion_point(global_scope)
-#include &lt;google/protobuf/port_undef.inc&gt;
</diff>
			</file>
			<file old_path="modules\task_manager\proto\.pb.h" new_path="" added_lines="0" deleted_lines="80">
				<diff>@@ -1,80 +0,0 @@
-// Generated by the protocol buffer compiler.  DO NOT EDIT!
-// source: modules/task_manager/proto/
-
-#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2ftask_5fmanager_2fproto_2f
-#define GOOGLE_PROTOBUF_INCLUDED_modules_2ftask_5fmanager_2fproto_2f
-
-#include &lt;limits&gt;
-#include &lt;string&gt;
-
-#include &lt;google/protobuf/port_def.inc&gt;
-#if PROTOBUF_VERSION &lt; 3012000
-#error This file was generated by a newer version of protoc which is
-#error incompatible with your Protocol Buffer headers. Please update
-#error your headers.
-#endif
-#if 3012003 &lt; PROTOBUF_MIN_PROTOC_VERSION
-#error This file was generated by an older version of protoc which is
-#error incompatible with your Protocol Buffer headers. Please
-#error regenerate this file with a newer version of protoc.
-#endif
-
-#include &lt;google/protobuf/port_undef.inc&gt;
-#include &lt;google/protobuf/io/coded_stream.h&gt;
-#include &lt;google/protobuf/arena.h&gt;
-#include &lt;google/protobuf/arenastring.h&gt;
-#include &lt;google/protobuf/generated_message_table_driven.h&gt;
-#include &lt;google/protobuf/generated_message_util.h&gt;
-#include &lt;google/protobuf/inlined_string_field.h&gt;
-#include &lt;google/protobuf/metadata_lite.h&gt;
-#include &lt;google/protobuf/generated_message_reflection.h&gt;
-#include &lt;google/protobuf/repeated_field.h&gt;  // IWYU pragma: export
-#include &lt;google/protobuf/extension_set.h&gt;  // IWYU pragma: export
-// @@protoc_insertion_point(includes)
-#include &lt;google/protobuf/port_def.inc&gt;
-#define PROTOBUF_INTERNAL_EXPORT_modules_2ftask_5fmanager_2fproto_2f
-PROTOBUF_NAMESPACE_OPEN
-namespace internal {
-class AnyMetadata;
-}  // namespace internal
-PROTOBUF_NAMESPACE_CLOSE
-
-// Internal implementation detail -- do not use these members.
-struct TableStruct_modules_2ftask_5fmanager_2fproto_2f {
-  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
-    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
-  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
-    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
-  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
-    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
-  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
-  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
-  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
-};
-extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2ftask_5fmanager_2fproto_2f;
-PROTOBUF_NAMESPACE_OPEN
-PROTOBUF_NAMESPACE_CLOSE
-
-// ===================================================================
-
-
-// ===================================================================
-
-
-// ===================================================================
-
-#ifdef __GNUC__
-  #pragma GCC diagnostic push
-  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
-#endif  // __GNUC__
-#ifdef __GNUC__
-  #pragma GCC diagnostic pop
-#endif  // __GNUC__
-
-// @@protoc_insertion_point(namespace_scope)
-
-
-// @@protoc_insertion_point(global_scope)
-
-#include &lt;google/protobuf/port_undef.inc&gt;
-#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2ftask_5fmanager_2fproto_2f
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="aefd876bb477cd1874442f9c80a8c3cda9b7ff76" author="JackFu123">
		<msg>task_manager: add msg header for routing</msg>
		<modified_files>
			<file old_path="modules\task_manager\cycle_routing_manager.cc" new_path="modules\task_manager\cycle_routing_manager.cc" added_lines="5" deleted_lines="0">
				<diff>@@ -35,6 +35,11 @@ common::Status CycleRoutingManager::Init(
     begin_point_ = waypoints[0].pose();
     end_point_ = waypoints[waypoint_num_ - 1].pose();
     last_point_ = begin_point_;
+
+    AINFO &lt;&lt; "New cycle routing task: cycle " &lt;&lt; cycle_
+        &lt;&lt; ", begin point " &lt;&lt; begin_point_.x() &lt;&lt; " " &lt;&lt; begin_point_.y()
+        &lt;&lt; ", end point " &lt;&lt; end_point_.x() &lt;&lt; " " &lt;&lt; end_point_.y();
+
     return common::Status::OK();
 }
 
</diff>
			</file>
			<file old_path="modules\task_manager\cycle_routing_manager.h" new_path="modules\task_manager\cycle_routing_manager.h" added_lines="2" deleted_lines="1">
				<diff>@@ -20,6 +20,7 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
+#include "modules/common/monitor_log/monitor_log_buffer.h"
 #include "modules/common/status/status.h"
 #include "modules/localization/proto/localization.pb.h"
 #include "modules/task_manager/proto/task_manager.pb.h"
@@ -29,7 +30,7 @@ namespace task_manager {
 
 class CycleRoutingManager {
  public:
-  CycleRoutingManager();
+  CycleRoutingManager() = default;
 
   /**
    * @brief module initialization function
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.cc" new_path="modules\task_manager\task_manager_component.cc" added_lines="4" deleted_lines="1">
				<diff>@@ -58,9 +58,11 @@ bool TaskManagerComponent::Init() {
 
 bool TaskManagerComponent::Proc(const std::shared_ptr&lt;Task&gt;&amp; task) {
     task_name_ = task-&gt;task_name();
-    if (task-&gt;task_type() == CYCLE_ROUTING) {
+    if (task-&gt;task_type() != CYCLE_ROUTING) {
+      AINFO &lt;&lt; "Task type is not cycle_routing.";
       return false;
     }
+
     cycle_routing_manager_ = std::make_shared&lt;CycleRoutingManager&gt;();
     cycle_routing_manager_-&gt;Init(task-&gt;cycle_routing_task());
     routing_request_ = task-&gt;cycle_routing_task().routing_request();
@@ -69,6 +71,7 @@ bool TaskManagerComponent::Proc(const std::shared_ptr&lt;Task&gt;&amp; task) {
     while (cycle_routing_manager_-&gt;GetCycle() &gt; 0) {
       if (cycle_routing_manager_-&gt;CheckIfReachDestination(
             localization_.pose())) {
+        common::util::FillHeader(node_-&gt;Name(), &amp;routing_request_);
         request_writer_-&gt;Write(routing_request_);
         AINFO &lt;&lt; "Reach destination: routing manager send a routing request";
         cycle_routing_manager_-&gt;MinusCycle();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="bea77232241b6124c5c9992a87dbca9690e91169" author="SeasoulChris">
		<msg>D-KIT: correct default lidar_extrinsics_file in localization_conf (#13086)</msg>
		<modified_files>
			<file old_path="modules\calibration\data\dev_kit_advanced_sne-r\localization_conf\localization.conf" new_path="modules\calibration\data\dev_kit_advanced_sne-r\localization_conf\localization.conf" added_lines="2" deleted_lines="1">
				<diff>@@ -131,8 +131,8 @@
 
 # The lidar extrinsics file
 # type: string
-# default: /apollo/modules/localization/msf/params/velodyne_params/velodyne128_novatel_extrinsics.yaml
---lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/velodyne128_novatel_extrinsics.yaml
+# default: /apollo/modules/localization/msf/params/velodyne_params/velodyne16_novatel_extrinsics.yaml
+--lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/velodyne16_novatel_extrinsics.yaml
 
 # imu coordinate, true-&gt;flu, false-&gt;rfu
 # type: bool
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8682086b160d64d9baaf9eb7c81eea4cdcaf1424" author="JackFu123">
		<msg>task_manager: modify logic for cycle counting</msg>
		<modified_files>
			<file old_path="modules\task_manager\conf\task_manager.conf" new_path="modules\task_manager\conf\task_manager.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -1,2 +1,2 @@
 --flagfile=/apollo/modules/common/data/global_flagfile.txt
---threshold_for_destination_check=1.0
+--threshold_for_destination_check=100.0
</diff>
			</file>
			<file old_path="modules\task_manager\cycle_routing_manager.cc" new_path="modules\task_manager\cycle_routing_manager.cc" added_lines="15" deleted_lines="7">
				<diff>@@ -34,7 +34,7 @@ common::Status CycleRoutingManager::Init(
     waypoint_num_ = waypoints.size();
     begin_point_ = waypoints[0].pose();
     end_point_ = waypoints[waypoint_num_ - 1].pose();
-    last_point_ = begin_point_;
+    is_allowed_to_route_ = true;
 
     AINFO &lt;&lt; "New cycle routing task: cycle " &lt;&lt; cycle_
         &lt;&lt; ", begin point " &lt;&lt; begin_point_.x() &lt;&lt; " " &lt;&lt; begin_point_.y()
@@ -45,18 +45,26 @@ common::Status CycleRoutingManager::Init(
 
 bool CycleRoutingManager::CheckIfReachDestination(
         const localization::Pose &amp;pose) {
-    if (CheckPointDistanceInThreshold(
-          last_point_,
+    ADEBUG &lt;&lt; "Check if reach destination: localization_pose: "
+    &lt;&lt; pose.position().x() &lt;&lt; " " &lt;&lt; pose.position().y()
+    &lt;&lt; ", begin point " &lt;&lt; begin_point_.x() &lt;&lt; " " &lt;&lt; begin_point_.y()
+    &lt;&lt; ", end point " &lt;&lt; end_point_.x() &lt;&lt; " " &lt;&lt; end_point_.y()
+    &lt;&lt; ", threshold " &lt;&lt; FLAGS_threshold_for_destination_check
+    &lt;&lt; ", allowed_to_send_routing_request " &lt;&lt; is_allowed_to_route_;
+
+    if (!CheckPointDistanceInThreshold(
           begin_point_,
-          FLAGS_threshold_for_destination_check)) {
-        last_point_ = pose.position();
+          pose.position(),
+          FLAGS_threshold_for_destination_check * 2)) {
+        is_allowed_to_route_ = true;
         return false;
     }
-    if (CheckPointDistanceInThreshold(
+
+    if (is_allowed_to_route_ &amp;&amp; CheckPointDistanceInThreshold(
           pose.position(),
           begin_point_,
           FLAGS_threshold_for_destination_check)) {
-          last_point_ = pose.position();
+        is_allowed_to_route_ = false;
         return true;
     }
     return false;
</diff>
			</file>
			<file old_path="modules\task_manager\cycle_routing_manager.h" new_path="modules\task_manager\cycle_routing_manager.h" added_lines="1" deleted_lines="1">
				<diff>@@ -64,9 +64,9 @@ class CycleRoutingManager {
  private:
   int cycle_;
   int waypoint_num_;
+  bool is_allowed_to_route_;
   apollo::common::PointENU begin_point_;
   apollo::common::PointENU end_point_;
-  apollo::common::PointENU last_point_;
 };
 
 }  // namespace task_manager
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.cc" new_path="modules\task_manager\task_manager_component.cc" added_lines="3" deleted_lines="2">
				<diff>@@ -38,7 +38,7 @@ bool TaskManagerComponent::Init() {
     localization_reader_ = node_-&gt;CreateReader&lt;LocalizationEstimate&gt;(
       task_manager_conf.topic_config().localization_pose_topic(),
       [this](const std::shared_ptr&lt;LocalizationEstimate&gt;&amp; localization) {
-        AINFO &lt;&lt; "Received localization data: run localization callback.";
+        ADEBUG &lt;&lt; "Received localization data: run localization callback.";
         std::lock_guard&lt;std::mutex&gt; lock(mutex_);
         localization_.CopyFrom(*localization);
       });
@@ -73,7 +73,8 @@ bool TaskManagerComponent::Proc(const std::shared_ptr&lt;Task&gt;&amp; task) {
             localization_.pose())) {
         common::util::FillHeader(node_-&gt;Name(), &amp;routing_request_);
         request_writer_-&gt;Write(routing_request_);
-        AINFO &lt;&lt; "Reach destination: routing manager send a routing request";
+        AINFO &lt;&lt; "Reach destination: routing manager send a routing request"
+        &lt;&lt; "Remaining cycles: " &lt;&lt; cycle_routing_manager_-&gt;GetCycle();
         cycle_routing_manager_-&gt;MinusCycle();
       }
       rate.Sleep();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="fa0a89a06c38f695c233e5f82427d3b6ad22933b" author="JackFu123">
		<msg>task_manager: remove a magic number</msg>
		<modified_files>
			<file old_path="modules\task_manager\common\task_manager_gflags.cc" new_path="modules\task_manager\common\task_manager_gflags.cc" added_lines="1" deleted_lines="0">
				<diff>@@ -21,3 +21,4 @@ DEFINE_string(task_manager_node_name, "task_manager", "the name for this node");
 DEFINE_double(threshold_for_destination_check, 1.0,
               "meters, which is 100 feet.  This threshold is used to check if"
               "the vehicle reaches the destination");
+DEFINE_double(magnify_times_for_threshold, 2.0, "magnify times for threshold");
</diff>
			</file>
			<file old_path="modules\task_manager\common\task_manager_gflags.h" new_path="modules\task_manager\common\task_manager_gflags.h" added_lines="1" deleted_lines="0">
				<diff>@@ -21,3 +21,4 @@
 DECLARE_string(task_manager_node_name);
 
 DECLARE_double(threshold_for_destination_check);
+DECLARE_double(magnify_times_for_threshold);
</diff>
			</file>
			<file old_path="modules\task_manager\conf\task_manager.conf" new_path="modules\task_manager\conf\task_manager.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -1,2 +1,3 @@
 --flagfile=/apollo/modules/common/data/global_flagfile.txt
 --threshold_for_destination_check=100.0
+--amplify_times_for_threshold=2.0
\ No newline at end of file
</diff>
			</file>
			<file old_path="modules\task_manager\cycle_routing_manager.cc" new_path="modules\task_manager\cycle_routing_manager.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -55,7 +55,7 @@ bool CycleRoutingManager::CheckIfReachDestination(
     if (!CheckPointDistanceInThreshold(
           begin_point_,
           pose.position(),
-          FLAGS_threshold_for_destination_check * 2)) {
+          FLAGS_threshold_for_destination_check * FLAGS_magnify_times_for_threshold)) {
         is_allowed_to_route_ = true;
         return false;
     }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ece968ddd5c209bb74e3cbe0749bd5746fadf61c" author="JackFu123">
		<msg>Task_manager: add initial numbers for CycleRoutingManager</msg>
		<modified_files>
			<file old_path="modules\task_manager\cycle_routing_manager.cc" new_path="modules\task_manager\cycle_routing_manager.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -55,7 +55,8 @@ bool CycleRoutingManager::CheckIfReachDestination(
     if (!CheckPointDistanceInThreshold(
           begin_point_,
           pose.position(),
-          FLAGS_threshold_for_destination_check * FLAGS_magnify_times_for_threshold)) {
+          FLAGS_threshold_for_destination_check
+          * FLAGS_magnify_times_for_threshold)) {
         is_allowed_to_route_ = true;
         return false;
     }
</diff>
			</file>
			<file old_path="modules\task_manager\cycle_routing_manager.h" new_path="modules\task_manager\cycle_routing_manager.h" added_lines="3" deleted_lines="3">
				<diff>@@ -62,9 +62,9 @@ class CycleRoutingManager {
   virtual ~CycleRoutingManager() = default;
 
  private:
-  int cycle_;
-  int waypoint_num_;
-  bool is_allowed_to_route_;
+  int cycle_ = 0;
+  int waypoint_num_ = 0;
+  bool is_allowed_to_route_ = false;
   apollo::common::PointENU begin_point_;
   apollo::common::PointENU end_point_;
 };
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="44ea2a061a1a35fe93289fd81518a7be5607132a" author="AlanNewImage">
		<msg>Update radar_track.cc

fix radar_track bug</msg>
		<modified_files>
			<file old_path="modules\perception\radar\lib\tracker\common\radar_track.cc" new_path="modules\perception\radar\lib\tracker\common\radar_track.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -59,7 +59,7 @@ void RadarTrack::UpdataObsRadar(const base::ObjectPtr&amp; obs_radar,
     Eigen::Matrix4d covariance_matrix = filter_-&gt;GetCovarianceMatrix();
     obs_-&gt;center_uncertainty(0) = static_cast&lt;float&gt;(covariance_matrix(0, 0));
     obs_-&gt;center_uncertainty(1) = static_cast&lt;float&gt;(covariance_matrix(1, 1));
-    obs_-&gt;velocity_uncertainty(1) = static_cast&lt;float&gt;(covariance_matrix(2, 2));
+    obs_-&gt;velocity_uncertainty(0) = static_cast&lt;float&gt;(covariance_matrix(2, 2));
     obs_-&gt;velocity_uncertainty(1) = static_cast&lt;float&gt;(covariance_matrix(3, 3));
   }
   tracking_time_ += time_diff;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="017c6ac3fb346ca583b9f89909a2a78d02abaf8b" author="lishuanghua">
		<msg>Monitor : Change the monitored GPS signal from GnssStatus and InsStatus to SolutionType of GnssBestPose (#13065)</msg>
		<modified_files>
			<file old_path="modules\monitor\hardware\gps_monitor.cc" new_path="modules\monitor\hardware\gps_monitor.cc" added_lines="15" deleted_lines="37">
				<diff>@@ -19,8 +19,7 @@
 #include "cyber/common/log.h"
 #include "modules/common/adapters/adapter_gflags.h"
 #include "modules/common/util/map_util.h"
-#include "modules/drivers/gnss/proto/gnss_status.pb.h"
-#include "modules/drivers/gnss/proto/ins.pb.h"
+#include "modules/drivers/gnss/proto/gnss_best_pose.pb.h"
 #include "modules/monitor/common/monitor_manager.h"
 #include "modules/monitor/software/summary_monitor.h"
 
@@ -31,8 +30,8 @@ DEFINE_string(gps_component_name, "GPS", "GPS component name.");
 namespace apollo {
 namespace monitor {
 
-using apollo::drivers::gnss::GnssStatus;
-using apollo::drivers::gnss::InsStatus;
+using apollo::drivers::gnss::GnssBestPose;
+using apollo::drivers::gnss::SolutionType;
 
 GpsMonitor::GpsMonitor()
     : RecurrentRunner(FLAGS_gps_monitor_name, FLAGS_gps_monitor_interval) {}
@@ -48,47 +47,26 @@ void GpsMonitor::RunOnce(const double current_time) {
   ComponentStatus* component_status = component-&gt;mutable_other_status();
   component_status-&gt;clear_status();
 
-  // Check Gnss status.
-  static auto gnss_status_reader =
-      manager-&gt;CreateReader&lt;GnssStatus&gt;(FLAGS_gnss_status_topic);
-  gnss_status_reader-&gt;Observe();
-  const auto gnss_status = gnss_status_reader-&gt;GetLatestObserved();
-  if (gnss_status == nullptr) {
+  static auto gnss_best_pose_reader =
+      manager-&gt;CreateReader&lt;GnssBestPose&gt;(FLAGS_gnss_best_pose_topic);
+  gnss_best_pose_reader-&gt;Observe();
+  const auto gnss_best_pose_status = gnss_best_pose_reader-&gt;GetLatestObserved();
+  if (gnss_best_pose_status == nullptr) {
     SummaryMonitor::EscalateStatus(ComponentStatus::ERROR,
-                                   "No GNSS status message", component_status);
+                                   "No GnssBestPose message", component_status);
     return;
   }
-  if (!gnss_status-&gt;solution_completed()) {
-    SummaryMonitor::EscalateStatus(
-        ComponentStatus::WARN, "GNSS solution uncompleted", component_status);
-    return;
-  }
-
-  // Check Ins status.
-  static auto ins_status_reader =
-      manager-&gt;CreateReader&lt;InsStatus&gt;(FLAGS_ins_status_topic);
-  ins_status_reader-&gt;Observe();
-  const auto ins_status = ins_status_reader-&gt;GetLatestObserved();
-  if (ins_status == nullptr) {
-    SummaryMonitor::EscalateStatus(ComponentStatus::ERROR,
-                                   "No INS status message", component_status);
-    return;
-  }
-  switch (ins_status-&gt;type()) {
-    case InsStatus::CONVERGING:
-      SummaryMonitor::EscalateStatus(
-          ComponentStatus::WARN, "INS not ready, converging", component_status);
-      break;
-    case InsStatus::GOOD:
+  switch (gnss_best_pose_status-&gt;sol_type()) {
+    case SolutionType::NARROW_INT:
       SummaryMonitor::EscalateStatus(ComponentStatus::OK, "", component_status);
       break;
-    case InsStatus::INVALID:
-      SummaryMonitor::EscalateStatus(ComponentStatus::ERROR,
-                                     "INS status invalid", component_status);
+    case SolutionType::SINGLE:
+      SummaryMonitor::EscalateStatus(
+          ComponentStatus::WARN, "SolutionType is SINGLE", component_status);
       break;
     default:
       SummaryMonitor::EscalateStatus(ComponentStatus::ERROR,
-                                     "INS status unknown", component_status);
+                                     "SolutionType is wrong", component_status);
       break;
   }
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7ae13dca61fbd85950e453dbdaf9684c3879182f" author="Jiahao Chen (Jerold)">
		<msg>Perception: recover Lidar Segmentation method (#13091)

* Perception: resume lidar Segmentation method

* Perception: fix CNN Segmentation unit test

* Perception: set CNN Segmentation unit test size large</msg>
		<modified_files>
			<file old_path="modules\perception\fusion\lib\data_association\hm_data_association\projection_cache.h" new_path="modules\perception\fusion\lib\data_association\hm_data_association\projection_cache.h" added_lines="0" deleted_lines="4">
				<diff>@@ -19,13 +19,9 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
-#include "Eigen/StdVector"
-
 #include "modules/common/math/math_utils.h"
 #include "modules/perception/fusion/base/sensor_object.h"
 
-EIGEN_DEFINE_STL_VECTOR_SPECIALIZATION(Eigen::Vector2d);
-
 namespace apollo {
 namespace perception {
 namespace fusion {
</diff>
			</file>
			<file old_path="modules\perception\inference\inference_factory.cc" new_path="modules\perception\inference\inference_factory.cc" added_lines="7" deleted_lines="2">
				<diff>@@ -18,6 +18,7 @@
 
 #include "modules/perception/inference/libtorch/torch_det.h"
 #include "modules/perception/inference/libtorch/torch_net.h"
+#include "modules/perception/inference/tensorrt/rt_net.h"
 
 namespace apollo {
 namespace perception {
@@ -29,10 +30,14 @@ Inference *CreateInferenceByName(const std::string &amp;name,
                                  const std::vector&lt;std::string&gt; &amp;outputs,
                                  const std::vector&lt;std::string&gt; &amp;inputs,
                                  const std::string &amp;model_root) {
-  if (name == "TorchNet") {
-    return new TorchNet(proto_file, weight_file, outputs, inputs);
+  if (name == "RTNet") {
+    return new RTNet(proto_file, weight_file, outputs, inputs);
+  } else if (name == "RTNetInt8") {
+    return new RTNet(proto_file, weight_file, outputs, inputs, model_root);
   } else if (name == "TorchDet") {
     return new TorchDet(proto_file, weight_file, outputs, inputs);
+  } else if (name == "TorchNet") {
+    return new TorchNet(proto_file, weight_file, outputs, inputs);
   }
   return nullptr;
 }
</diff>
			</file>
			<file old_path="modules\perception\inference\inference_factory_test.cc" new_path="modules\perception\inference\inference_factory_test.cc" added_lines="2" deleted_lines="0">
				<diff>@@ -18,6 +18,8 @@
 
 #include "gtest/gtest.h"
 
+#include "modules/perception/inference/tensorrt/rt_net.h"
+
 namespace apollo {
 namespace perception {
 namespace inference {
</diff>
			</file>
			<file old_path="modules\perception\inference\operators\roipooling_layer.cc" new_path="modules\perception\inference\operators\roipooling_layer.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -88,7 +88,7 @@ void ROIPoolingLayer&lt;Dtype&gt;::ForwardCPU(
   int batch_size = feat_bottom-&gt;num();
   int top_count = top[0]-&gt;count();
   Dtype *top_data = top[0]-&gt;mutable_cpu_data();
-  memset(top_data, -1, static_cast&lt;size_t&gt;(FLT_MAX * sizeof(Dtype)));
+  memset(top_data, -1, static_cast&lt;size_t&gt;(float_max_ * sizeof(Dtype)));
   int *argmax_data = max_idx_.mutable_cpu_data();
   memset(argmax_data, -1, top_count * sizeof(int));
   // For each ROI R = [batch_index x1 y1 x2 y2]: max pool over R
</diff>
			</file>
			<file old_path="modules\perception\inference\operators\roipooling_layer.cu" new_path="modules\perception\inference\operators\roipooling_layer.cu" added_lines="7" deleted_lines="6">
				<diff>@@ -60,11 +60,11 @@ license and copyright terms herein.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *****************************************************************************/
-#include "modules/perception/inference/operators/roipooling_layer.h"
-
 #include &lt;algorithm&gt;
 #include &lt;vector&gt;
+
 #include "modules/perception/base/blob.h"
+#include "modules/perception/inference/operators/roipooling_layer.h"
 
 namespace apollo {
 namespace perception {
@@ -75,7 +75,8 @@ __global__ void ROIPoolForward(const int nthreads, const Dtype *bottom_data,
                                const int channels, const int height,
                                const int width, const int pooled_height,
                                const int pooled_width, const Dtype *bottom_rois,
-                               Dtype *top_data, int *argmax_data) {
+                               Dtype *top_data, int *argmax_data,
+                               const float float_max) {
   for (int index = blockIdx.x * blockDim.x + threadIdx.x; index &lt; (nthreads);
        index += blockDim.x * gridDim.x) {
     // (n, c, ph, pw) is an element in the pooled output
@@ -124,7 +125,7 @@ __global__ void ROIPoolForward(const int nthreads, const Dtype *bottom_data,
     bool is_empty = (hend &lt;= hstart) || (wend &lt;= wstart);
 
     // Define an empty pooling region to be zero
-    Dtype maxval = is_empty ? 0 : -FLT_MAX;
+    Dtype maxval = is_empty ? 0 : -float_max;
     // If nothing is pooled, argmax = -1 causes nothing to be backprop'd
     int maxidx = -1;
     bottom_data += (roi_batch_ind * channels + c) * height * width;
@@ -163,8 +164,8 @@ void ROIPoolingLayer&lt;Dtype&gt;::ForwardGPU(
   int block_size = (count + thread_size - 1) / thread_size;
   ROIPoolForward&lt;Dtype&gt;&lt;&lt;&lt;block_size, thread_size&gt;&gt;&gt;(
       count, bottom_data, use_floor_, spatial_scale_, channels_, height_,
-      width_, pooled_height_, pooled_width_, bottom_rois, top_data,
-      argmax_data);
+      width_, pooled_height_, pooled_width_, bottom_rois, top_data, argmax_data,
+      float_max_);
 }
 template void ROIPoolingLayer&lt;double&gt;::ForwardGPU(
     const std::vector&lt;std::shared_ptr&lt;base::Blob&lt;double&gt;&gt;&gt; &amp;bottom,
</diff>
			</file>
			<file old_path="modules\perception\inference\operators\roipooling_layer.h" new_path="modules\perception\inference\operators\roipooling_layer.h" added_lines="3" deleted_lines="0">
				<diff>@@ -63,6 +63,7 @@ license and copyright terms herein.
 
 #pragma once
 
+#include &lt;limits&gt;
 #include &lt;memory&gt;
 #include &lt;vector&gt;
 
@@ -83,6 +84,7 @@ class ROIPoolingLayer : public Layer&lt;Dtype&gt; {
         pooled_height_(pooled_h),
         pooled_width_(pooled_w),
         use_floor_(use_floor),
+        float_max_(std::numeric_limits&lt;float&gt;::max()),
         spatial_scale_(spatial_scale) {
     max_idx_.Reshape(max_objs, channels, pooled_height_, pooled_width_);
   }
@@ -99,6 +101,7 @@ class ROIPoolingLayer : public Layer&lt;Dtype&gt; {
   int pooled_height_;
   int pooled_width_;
   bool use_floor_;
+  const float float_max_;
   float spatial_scale_;
 };
 
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\batch_stream.cc" new_path="modules\perception\inference\tensorrt\batch_stream.cc" added_lines="1" deleted_lines="0">
				<diff>@@ -19,6 +19,7 @@
 #include &lt;algorithm&gt;
 
 #include "absl/strings/str_cat.h"
+
 #include "cyber/common/log.h"
 
 namespace apollo {
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\entropy_calibrator.cc" new_path="modules\perception\inference\tensorrt\entropy_calibrator.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -15,9 +15,10 @@
  *****************************************************************************/
 #include "modules/perception/inference/tensorrt/entropy_calibrator.h"
 
-#include &lt;cuda_runtime_api.h&gt;
 #include &lt;fstream&gt;
 
+#include &lt;cuda_runtime_api.h&gt;
+
 namespace nvinfer1 {
 DimsHW ICaffePoolOutputDimensionsFormula::compute(DimsHW input_dims,
                                                   DimsHW kernel_size,
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\entropy_calibrator.h" new_path="modules\perception\inference\tensorrt\entropy_calibrator.h" added_lines="1" deleted_lines="0">
				<diff>@@ -24,6 +24,7 @@
 #include "NvCaffeParser.h"
 #include "NvInfer.h"
 #include "NvInferPlugin.h"
+
 #include "modules/perception/inference/tensorrt/batch_stream.h"
 #include "modules/perception/inference/tensorrt/rt_utils.h"
 
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\plugins\argmax_plugin.cu" new_path="modules\perception\inference\tensorrt\plugins\argmax_plugin.cu" added_lines="6" deleted_lines="3">
				<diff>@@ -15,13 +15,15 @@
  *****************************************************************************/
 #include &lt;limits&gt;
 #include &lt;vector&gt;
+
 #include "modules/perception/inference/tensorrt/plugins/argmax_plugin.h"
 namespace apollo {
 namespace perception {
 namespace inference {
 __global__ void cmp(const int nthreads, const float *in_data,
                     const int channels, const int height, const int width,
-                    const bool out_max_val, float *out_data) {
+                    const bool out_max_val, float *out_data,
+                    const float float_min) {
   int idx = blockIdx.x * blockDim.x + threadIdx.x;
   if (idx &lt; nthreads) {
     int w = idx % width;
@@ -34,7 +36,7 @@ __global__ void cmp(const int nthreads, const float *in_data,
       return;
     }
     int c_max = 0;
-    float v_max = std::numeric_limits&lt;float&gt;::min();
+    float v_max = float_min;
     for (int c = 0; c &lt; channels; c++) {
       int in_idx = ((n * channels + c) * height + h) * width + w;
       if (v_max &lt; in_data[in_idx]) {
@@ -61,7 +63,8 @@ int ArgMax1Plugin::enqueue(int batchSize, const void *const *inputs,
   cmp&lt;&lt;&lt;block_size, thread_size&gt;&gt;&gt;(
       input_dims_.d[0] * input_dims_.d[1] * input_dims_.d[2] * batchSize,
       (const float *)inputs[0], input_dims_.d[0], input_dims_.d[1],
-      input_dims_.d[2], out_max_val_, reinterpret_cast&lt;float *&gt;(outputs[0]));
+      input_dims_.d[2], out_max_val_, reinterpret_cast&lt;float *&gt;(outputs[0]),
+      float_min_);
   return 0;
 }
 
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\plugins\argmax_plugin.h" new_path="modules\perception\inference\tensorrt\plugins\argmax_plugin.h" added_lines="9" deleted_lines="3">
				<diff>@@ -16,16 +16,20 @@
 
 #pragma once
 
-#include "modules/perception/inference/tensorrt/rt_common.h"
+#include &lt;limits&gt;
+
 #include "modules/perception/proto/rt.pb.h"
 
+#include "modules/perception/inference/tensorrt/rt_common.h"
+
 namespace apollo {
 namespace perception {
 namespace inference {
 
 class ArgMax1Plugin : public nvinfer1::IPlugin {
  public:
-  ArgMax1Plugin(const ArgMaxParameter &amp;argmax_param, nvinfer1::Dims in_dims) {
+  ArgMax1Plugin(const ArgMaxParameter &amp;argmax_param, nvinfer1::Dims in_dims)
+      : float_min_(std::numeric_limits&lt;float&gt;::min()) {
     input_dims_.nbDims = in_dims.nbDims;
     CHECK_GT(input_dims_.nbDims, 0);
     for (int i = 0; i &lt; in_dims.nbDims; i++) {
@@ -35,7 +39,8 @@ class ArgMax1Plugin : public nvinfer1::IPlugin {
     axis_ = argmax_param.axis();
     out_max_val_ = argmax_param.out_max_val();
     top_k_ = argmax_param.top_k();
-    CHECK_GE(top_k_, 1) &lt;&lt; "top k must not be less than 1.";
+    CHECK_GE(top_k_, static_cast&lt;size_t&gt;(1))
+        &lt;&lt; "top k must not be less than 1.";
     output_dims_ = input_dims_;
     output_dims_.d[0] = 1;
     if (out_max_val_) {
@@ -93,6 +98,7 @@ class ArgMax1Plugin : public nvinfer1::IPlugin {
   bool out_max_val_;
   size_t top_k_;
   int axis_;
+  float float_min_;
   nvinfer1::Dims input_dims_;
   nvinfer1::Dims output_dims_;
 };
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\plugins\leakyReLU_plugin.cu" new_path="modules\perception\inference\tensorrt\plugins\leakyReLU_plugin.cu" added_lines="2" deleted_lines="2">
				<diff>@@ -14,10 +14,10 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/perception/inference/tensorrt/plugins/leakyReLU_plugin.h"
-
 #include &lt;vector&gt;
 
+#include "modules/perception/inference/tensorrt/plugins/leakyReLU_plugin.h"
+
 namespace apollo {
 namespace perception {
 namespace inference {
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\plugins\slice_plugin.cu" new_path="modules\perception\inference\tensorrt\plugins\slice_plugin.cu" added_lines="1" deleted_lines="0">
				<diff>@@ -15,6 +15,7 @@
  *****************************************************************************/
 
 #include &lt;vector&gt;
+
 #include "modules/perception/inference/tensorrt/plugins/slice_plugin.h"
 
 namespace apollo {
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\plugins\slice_plugin_test.cc" new_path="modules\perception\inference\tensorrt\plugins\slice_plugin_test.cc" added_lines="1" deleted_lines="0">
				<diff>@@ -17,6 +17,7 @@
 #include "modules/perception/inference/tensorrt/plugins/slice_plugin.h"
 
 #include "gtest/gtest.h"
+
 #include "modules/perception/proto/rt.pb.h"
 
 TEST(SlicePluginsTest, test) {
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\plugins\softmax_plugin.cu" new_path="modules\perception\inference\tensorrt\plugins\softmax_plugin.cu" added_lines="1" deleted_lines="0">
				<diff>@@ -15,6 +15,7 @@
  *****************************************************************************/
 
 #include &lt;vector&gt;
+
 #include "modules/perception/inference/tensorrt/plugins/softmax_plugin.h"
 
 namespace apollo {
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\rt_common.h" new_path="modules\perception\inference\tensorrt\rt_common.h" added_lines="3" deleted_lines="2">
				<diff>@@ -16,17 +16,18 @@
 
 #pragma once
 
-#include &lt;cudnn.h&gt;
 #include &lt;map&gt;
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
 #include "NvCaffeParser.h"
 #include "NvInfer.h"
+#include &lt;cudnn.h&gt;
+
+#include "modules/perception/proto/rt.pb.h"
 
 #include "cyber/common/log.h"
 #include "modules/perception/base/common.h"
-#include "modules/perception/proto/rt.pb.h"
 
 namespace apollo {
 namespace perception {
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\rt_net.cc" new_path="modules\perception\inference\tensorrt\rt_net.cc" added_lines="3" deleted_lines="2">
				<diff>@@ -20,6 +20,7 @@
 #include &lt;utility&gt;
 
 #include "absl/strings/str_cat.h"
+
 #include "cyber/common/log.h"
 #include "modules/perception/inference/tensorrt/plugins/argmax_plugin.h"
 #include "modules/perception/inference/tensorrt/plugins/leakyReLU_plugin.h"
@@ -602,7 +603,7 @@ void RTNet::init_blob(std::vector&lt;std::string&gt; *names) {
   for (auto name : *names) {
     int bindingIndex =
         engine-&gt;getBindingIndex(tensor_modify_map_[name].c_str());
-    CHECK_LT(bindingIndex, buffers_.size());
+    CHECK_LT(static_cast&lt;size_t&gt;(bindingIndex), buffers_.size());
     CHECK_GE(bindingIndex, 0);
     nvinfer1::DimsCHW dims = static_cast&lt;nvinfer1::DimsCHW &amp;&amp;&gt;(
         engine-&gt;getBindingDimensions(bindingIndex));
@@ -710,7 +711,7 @@ void RTNet::parse_with_api(
              &amp;weight_map_, network_, &amp;tensor_map, &amp;tensor_modify_map_);
   }
 
-  CHECK_NE(output_names_.size(), 0);
+  CHECK_NE(output_names_.size(), static_cast&lt;size_t&gt;(0));
   std::sort(output_names_.begin(), output_names_.end());
   auto last = std::unique(output_names_.begin(), output_names_.end());
   output_names_.erase(last, output_names_.end());
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\rt_net.h" new_path="modules\perception\inference\tensorrt\rt_net.h" added_lines="2" deleted_lines="1">
				<diff>@@ -21,9 +21,10 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
+#include "modules/perception/proto/rt.pb.h"
+
 #include "modules/perception/inference/inference.h"
 #include "modules/perception/inference/tensorrt/entropy_calibrator.h"
-#include "modules/perception/proto/rt.pb.h"
 
 namespace apollo {
 namespace perception {
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\rt_utils.cc" new_path="modules\perception\inference\tensorrt\rt_utils.cc" added_lines="1" deleted_lines="0">
				<diff>@@ -17,6 +17,7 @@
 #include "modules/perception/inference/tensorrt/rt_utils.h"
 
 #include &lt;fcntl.h&gt;
+
 #include &lt;limits&gt;
 
 #include "cyber/common/log.h"
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\ground_detector\spatio_temporal_ground_detector\spatio_temporal_ground_detector_test.cc" new_path="modules\perception\lidar\lib\ground_detector\spatio_temporal_ground_detector\spatio_temporal_ground_detector_test.cc" added_lines="1" deleted_lines="0">
				<diff>@@ -16,6 +16,7 @@
 
 #include "modules/perception/lidar/lib/ground_detector/spatio_temporal_ground_detector/spatio_temporal_ground_detector.h"
 
+#include "gflags/gflags.h"
 #include "gtest/gtest.h"
 
 #include "pcl/io/pcd_io.h"
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\object_builder\object_builder.cc" new_path="modules\perception\lidar\lib\object_builder\object_builder.cc" added_lines="5" deleted_lines="3">
				<diff>@@ -16,11 +16,11 @@
 #include "modules/perception/lidar/lib/object_builder/object_builder.h"
 
 #include &lt;algorithm&gt;
+#include &lt;limits&gt;
 
 #include "modules/perception/common/geometry/common.h"
 #include "modules/perception/common/geometry/convex_hull_2d.h"
 #include "modules/perception/lib/config_manager/config_manager.h"
-// #include "modules/perception/lib/io/protobuf_util.h"
 
 namespace apollo {
 namespace perception {
@@ -183,8 +183,10 @@ bool ObjectBuilder::LinePerturbation(PointFCloud* cloud) {
 void ObjectBuilder::GetMinMax3D(const PointFCloud&amp; cloud,
                                 Eigen::Vector3f* min_pt,
                                 Eigen::Vector3f* max_pt) {
-  (*min_pt)[0] = (*min_pt)[1] = (*min_pt)[2] = FLT_MAX;
-  (*max_pt)[0] = (*max_pt)[1] = (*max_pt)[2] = -FLT_MAX;
+  (*min_pt)[0] = (*min_pt)[1] = (*min_pt)[2] =
+      std::numeric_limits&lt;float&gt;::max();
+  (*max_pt)[0] = (*max_pt)[1] = (*max_pt)[2] =
+      -std::numeric_limits&lt;float&gt;::max();
   for (size_t i = 0; i &lt; cloud.size(); ++i) {
     if (std::isnan(cloud[i].x) || std::isnan(cloud[i].y) ||
         std::isnan(cloud[i].z)) {
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\object_filter_bank\object_filter_bank_test.cc" new_path="modules\perception\lidar\lib\object_filter_bank\object_filter_bank_test.cc" added_lines="1" deleted_lines="0">
				<diff>@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *****************************************************************************/
+#include "gflags/gflags.h"
 #include "gtest/gtest.h"
 
 #include "modules/perception/lidar/lib/object_filter_bank/object_filter_bank.h"
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\object_filter_bank\roi_boundary_filter\roi_boundary_filter.cc" new_path="modules\perception\lidar\lib\object_filter_bank\roi_boundary_filter\roi_boundary_filter.cc" added_lines="4" deleted_lines="2">
				<diff>@@ -24,6 +24,8 @@
 #include "modules/perception/lib/config_manager/config_manager.h"
 #include "modules/perception/proto/roi_boundary_filter_config.pb.h"
 
+using apollo::common::EigenVector;
+
 namespace {
 constexpr double kDoubleMax = std::numeric_limits&lt;double&gt;::max();
 }  // namespace
@@ -152,7 +154,7 @@ void ROIBoundaryFilter::FillObjectRoiFlag(const ObjectFilterOptions&amp; options,
 void ROIBoundaryFilter::FilterObjectsOutsideBoundary(
     const ObjectFilterOptions&amp; options, LidarFrame* frame,
     std::vector&lt;bool&gt;* objects_valid_flag) {
-  const std::vector&lt;base::RoadBoundary&gt;&amp; road_boundary =
+  const EigenVector&lt;base::RoadBoundary&gt;&amp; road_boundary =
       frame-&gt;hdmap_struct-&gt;road_boundary;
   auto&amp; objects = frame-&gt;segmented_objects;
   double dist_to_boundary = 0.0;
@@ -194,7 +196,7 @@ void ROIBoundaryFilter::FilterObjectsOutsideBoundary(
 void ROIBoundaryFilter::FilterObjectsInsideBoundary(
     const ObjectFilterOptions&amp; options, LidarFrame* frame,
     std::vector&lt;bool&gt;* objects_valid_flag) {
-  const std::vector&lt;base::RoadBoundary&gt;&amp; road_boundary =
+  const EigenVector&lt;base::RoadBoundary&gt;&amp; road_boundary =
       frame-&gt;hdmap_struct-&gt;road_boundary;
   auto&amp; objects = frame-&gt;segmented_objects;
   double dist_to_boundary = 0.0;
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\object_filter_bank\roi_boundary_filter\roi_boundary_filter.h" new_path="modules\perception\lidar\lib\object_filter_bank\roi_boundary_filter\roi_boundary_filter.h" added_lines="2" deleted_lines="1">
				<diff>@@ -21,6 +21,7 @@
 #include "Eigen/Dense"
 #include "gtest/gtest_prod.h"
 
+#include "modules/common/util/eigen_defs.h"
 #include "modules/perception/base/point.h"
 #include "modules/perception/base/point_cloud.h"
 #include "modules/perception/lidar/lib/interface/base_object_filter.h"
@@ -68,7 +69,7 @@ class ROIBoundaryFilter : public BaseObjectFilter {
  private:
   FRIEND_TEST(ROIBoundaryFilterTest, roi_boundary_filter_test);
 
-  std::vector&lt;perception::base::AttributePointCloud&lt;perception::base::PointD&gt;&gt;
+  apollo::common::EigenVector&lt;apollo::perception::base::PointDCloud&gt;
       polygons_in_world_;
   std::vector&lt;bool&gt; objects_cross_roi_;
   std::vector&lt;bool&gt; objects_valid_flag_;
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\roi_filter\hdmap_roi_filter\hdmap_roi_filter.cc" new_path="modules\perception\lidar\lib\roi_filter\hdmap_roi_filter\hdmap_roi_filter.cc" added_lines="4" deleted_lines="3">
				<diff>@@ -30,6 +30,7 @@ namespace perception {
 namespace lidar {
 
 using DirectionMajor = Bitmap2D::DirectionMajor;
+using apollo::common::EigenVector;
 using apollo::cyber::common::GetAbsolutePath;
 using base::PolygonDType;
 
@@ -144,7 +145,7 @@ bool HdmapROIFilter::Filter(const ROIFilterOptions&amp; options,
 
 bool HdmapROIFilter::FilterWithPolygonMask(
     const base::PointFCloudPtr&amp; cloud,
-    const std::vector&lt;PolygonDType&gt;&amp; map_polygons,
+    const EigenVector&lt;PolygonDType&gt;&amp; map_polygons,
     base::PointIndices* roi_indices) {
   std::vector&lt;Polygon&lt;double&gt;&gt; raw_polygons;
   // convert and obtain the major direction
@@ -185,8 +186,8 @@ bool HdmapROIFilter::FilterWithPolygonMask(
 
 void HdmapROIFilter::TransformFrame(
     const base::PointFCloudPtr&amp; cloud, const Eigen::Affine3d&amp; vel_pose,
-    const std::vector&lt;PolygonDType*&gt;&amp; polygons_world,
-    std::vector&lt;PolygonDType&gt;* polygons_local,
+    const EigenVector&lt;PolygonDType*&gt;&amp; polygons_world,
+    EigenVector&lt;PolygonDType&gt;* polygons_local,
     base::PointFCloudPtr* cloud_local) {
   Eigen::Vector3d vel_location = vel_pose.translation();
   Eigen::Matrix3d vel_rot = vel_pose.linear();
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\roi_filter\hdmap_roi_filter\hdmap_roi_filter.h" new_path="modules\perception\lidar\lib\roi_filter\hdmap_roi_filter\hdmap_roi_filter.h" added_lines="9" deleted_lines="8">
				<diff>@@ -19,6 +19,7 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
+#include "modules/common/util/eigen_defs.h"
 #include "modules/perception/base/point_cloud.h"
 #include "modules/perception/lidar/lib/interface/base_roi_filter.h"
 #include "modules/perception/lidar/lib/roi_filter/hdmap_roi_filter/bitmap2d.h"
@@ -45,15 +46,15 @@ class HdmapROIFilter : public BaseROIFilter {
   bool Filter(const ROIFilterOptions&amp; options, LidarFrame* frame) override;
 
  private:
-  void TransformFrame(const base::PointFCloudPtr&amp; cloud,
-                      const Eigen::Affine3d&amp; vel_pose,
-                      const std::vector&lt;base::PolygonDType*&gt;&amp; polygons_world,
-                      std::vector&lt;base::PolygonDType&gt;* polygons_local,
-                      base::PointFCloudPtr* cloud_local);
+  void TransformFrame(
+      const base::PointFCloudPtr&amp; cloud, const Eigen::Affine3d&amp; vel_pose,
+      const apollo::common::EigenVector&lt;base::PolygonDType*&gt;&amp; polygons_world,
+      apollo::common::EigenVector&lt;base::PolygonDType&gt;* polygons_local,
+      base::PointFCloudPtr* cloud_local);
 
   bool FilterWithPolygonMask(
       const base::PointFCloudPtr&amp; cloud,
-      const std::vector&lt;base::PolygonDType&gt;&amp; map_polygons,
+      const apollo::common::EigenVector&lt;base::PolygonDType&gt;&amp; map_polygons,
       base::PointIndices* roi_indices);
 
   bool Bitmap2dFilter(const base::PointFCloudPtr&amp; in_cloud,
@@ -65,8 +66,8 @@ class HdmapROIFilter : public BaseROIFilter {
   double extend_dist_ = 0.0;
   bool no_edge_table_ = false;
   bool set_roi_service_ = false;
-  std::vector&lt;base::PolygonDType*&gt; polygons_world_;
-  std::vector&lt;base::PolygonDType&gt; polygons_local_;
+  apollo::common::EigenVector&lt;base::PolygonDType*&gt; polygons_world_;
+  apollo::common::EigenVector&lt;base::PolygonDType&gt; polygons_local_;
   Bitmap2D bitmap_;
   ROIServiceContent roi_service_content_;
 
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\roi_filter\hdmap_roi_filter\polygon_scan_cvter.h" new_path="modules\perception\lidar\lib\roi_filter\hdmap_roi_filter\polygon_scan_cvter.h" added_lines="4" deleted_lines="4">
				<diff>@@ -195,7 +195,7 @@ void PolygonScanCvter&lt;T&gt;::ScanCvt(const T&amp; scan_loc, DirectionMajor dir_major,
       }
     }
   }
-  CHECK_EQ(nodes.size() % 2, 0);
+  CHECK_EQ(nodes.size() % 2, static_cast&lt;size_t&gt;(0));
   std::sort(nodes.begin(), nodes.end());
   for (size_t i = 0; i &lt; nodes.size(); i += 2) {
     scan_intervals-&gt;push_back(IntervalOut(nodes[i], nodes[i + 1]));
@@ -238,7 +238,7 @@ void PolygonScanCvter&lt;T&gt;::ScansCvt(
   }
   // sort
   std::sort(aet_.second.begin(), aet_.second.end());
-  CHECK_EQ(aet_.second.size() &amp; 1, 0);
+  CHECK_EQ(aet_.second.size() &amp; 1, static_cast&lt;size_t&gt;(0));
 
   // add aet to result
   for (size_t i = 0; i &lt; aet_.second.size(); i += 2) {
@@ -406,7 +406,7 @@ void PolygonScanCvter&lt;T&gt;::UpdateAet(std::vector&lt;IntervalOut&gt;* scan_intervals) {
       scan_intervals-&gt;push_back(IntervalOut(edge.y, edge.max_y));
     }
   }
-  CHECK_EQ(valid_edges_num &amp; 1, 0)
+  CHECK_EQ(valid_edges_num &amp; 1, static_cast&lt;size_t&gt;(0))
       &lt;&lt; boost::format(
              "valid edges num: %d x: %lf bottom_x: %lf \n vertices num: %d "
              "\n") %
@@ -472,7 +472,7 @@ bool PolygonScanCvter&lt;T&gt;::ConvertSegment(const size_t seg_id,
   edge.min_y = edge.y;
 
   // save top edge
-  if (x_id &gt;= scans_size_) {
+  if (static_cast&lt;size_t&gt;(x_id) &gt;= scans_size_) {
     std::pair&lt;double, double&gt; seg(low_vertex[op_dir_major_],
                                   high_vertex[op_dir_major_]);
     top_segments_.push_back(seg);
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\scene_manager\scene_manager.cc" new_path="modules\perception\lidar\lib\scene_manager\scene_manager.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -45,7 +45,7 @@ bool SceneManager::InitInternal(const SceneManagerInitOptions&amp; options) {
   services_.clear();
   for (int i = 0; i &lt; config.service_name_size(); ++i) {
     const auto&amp; name = config.service_name(i);
-    SceneService* service(SceneServiceRegisterer::GetInstanceByName(name));
+    SceneServicePtr service(SceneServiceRegisterer::GetInstanceByName(name));
     if (service == nullptr) {
       AINFO &lt;&lt; "Failed to find scene service: " &lt;&lt; name &lt;&lt; ", skipped";
       continue;
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\scene_manager\scene_manager.h" new_path="modules\perception\lidar\lib\scene_manager\scene_manager.h" added_lines="1" deleted_lines="1">
				<diff>@@ -61,7 +61,7 @@ class SceneManager {
       const SceneManagerInitOptions&amp; options = SceneManagerInitOptions());
 
  protected:
-  std::map&lt;std::string, SceneService*&gt; services_;
+  std::map&lt;std::string, SceneServicePtr&gt; services_;
   bool initialized_ = false;
   std::mutex mutex_;
 };
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.cc" new_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.cc" added_lines="6" deleted_lines="4">
				<diff>@@ -13,18 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *****************************************************************************/
+#include "modules/perception/lidar/lib/segmentation/cnnseg/cnn_segmentation.h"
+
 #include &lt;map&gt;
 
+#include "modules/perception/lidar/lib/segmentation/cnnseg/proto/cnnseg_config.pb.h"
+
 #include "cyber/common/file.h"
 #include "cyber/common/log.h"
-
 #include "modules/perception/base/object_pool_types.h"
 #include "modules/perception/inference/inference_factory.h"
 #include "modules/perception/lib/config_manager/config_manager.h"
 #include "modules/perception/lidar/common/lidar_point_label.h"
 #include "modules/perception/lidar/common/lidar_timer.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/cnn_segmentation.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/proto/cnnseg_config.pb.h"
 #include "modules/perception/lidar/lib/segmentation/cnnseg/util.h"
 #include "modules/perception/lidar/lib/segmentation/ncut/ncut_segmentation.h"
 
@@ -148,7 +149,8 @@ bool CNNSegmentation::InitClusterAndBackgroundSegmentation() {
       &lt;&lt; "Failed to init ground detection.";
 
   // init roi filter
-  roi_filter_ = BaseROIFilterRegisterer::GetInstanceByName(cnnseg_param_.roi_filter());
+  roi_filter_ =
+      BaseROIFilterRegisterer::GetInstanceByName(cnnseg_param_.roi_filter());
   CHECK_NOTNULL(roi_filter_);
   ROIFilterInitOptions roi_filter_init_options;
   ACHECK(roi_filter_-&gt;Init(roi_filter_init_options))
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation_test.cc" new_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation_test.cc" added_lines="2" deleted_lines="4">
				<diff>@@ -93,8 +93,7 @@ TEST(CNNSegmentationTest, cnn_segmentation_sequence_test) {
   EXPECT_TRUE(segmentation-&gt;InitClusterAndBackgroundSegmentation());
 
   std::string pcd_path =
-      "/apollo/modules/perception/testdata/lidar/app/data/perception/"
-      "lidar/files/";
+      "/apollo/modules/perception/testdata/lidar/app/data/";
   std::vector&lt;std::string&gt; pcd_file_names;
   common::GetFileList(pcd_path, ".pcd", &amp;pcd_file_names);
   std::string file_name;
@@ -130,8 +129,7 @@ TEST(CNNSegmentationTest, cnn_segmentation_test) {
   // load pcd data
   auto pcl_ptr = std::shared_ptr&lt;base::PointFCloud&gt;(new base::PointFCloud);
   std::string filename =
-      "/apollo/modules/perception/testdata/lidar/app/data/perception/"
-      "lidar/files/0002_00.pcd";
+      "/apollo/modules/perception/testdata/lidar/app/data/0002_00.pcd";
   bool ret = LoadPCDFile(filename, pcl_ptr);
   ACHECK(ret) &lt;&lt; "Failed to load " &lt;&lt; filename;
   // load non ground indices
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\feature_generator.cc" new_path="modules\perception\lidar\lib\segmentation\cnnseg\feature_generator.cc" added_lines="2" deleted_lines="0">
				<diff>@@ -15,6 +15,8 @@
  *****************************************************************************/
 #include "modules/perception/lidar/lib/segmentation/cnnseg/feature_generator.h"
 
+#include &lt;limits&gt;
+
 #include "modules/perception/base/common.h"
 #include "modules/perception/lidar/lib/segmentation/cnnseg/util.h"
 
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\ncut.cc" new_path="modules\perception\lidar\lib\segmentation\ncut\ncut.cc" added_lines="5" deleted_lines="6">
				<diff>@@ -14,10 +14,12 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include &lt;omp.h&gt;
+#include "modules/perception/lidar/lib/segmentation/ncut/ncut.h"
+
 #include &lt;algorithm&gt;
 #include &lt;ctime&gt;
 #include &lt;functional&gt;
+#include &lt;limits&gt;
 #include &lt;queue&gt;
 #include &lt;stack&gt;
 #include &lt;string&gt;
@@ -25,14 +27,11 @@
 #include &lt;utility&gt;
 #include &lt;vector&gt;
 
+#include &lt;omp.h&gt;
+
 #include "cyber/common/file.h"
 #include "cyber/common/log.h"
 #include "modules/perception/base/point_cloud_util.h"
-#include "modules/perception/lidar/lib/segmentation/ncut/ncut.h"
-/*#include "lib/graph_felzenszwalb/filter.h"
-#include "lib/graph_felzenszwalb/image.h"
-#include "lib/graph_felzenszwalb/misc.h"
-#include "lib/graph_felzenszwalb/segment_image.h"*/
 
 namespace apollo {
 namespace perception {
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\ncut_segmentation.cc" new_path="modules\perception\lidar\lib\segmentation\ncut\ncut_segmentation.cc" added_lines="4" deleted_lines="2">
				<diff>@@ -16,11 +16,12 @@
 
 #include "modules/perception/lidar/lib/segmentation/ncut/ncut_segmentation.h"
 
-#include &lt;omp.h&gt;
 #include &lt;algorithm&gt;
 #include &lt;limits&gt;
 #include &lt;map&gt;
 
+#include &lt;omp.h&gt;
+
 #include "cyber/common/file.h"
 #include "cyber/common/log.h"
 #include "modules/perception/lib/config_manager/config_manager.h"
@@ -44,7 +45,8 @@ bool NCutSegmentation::Init(const SegmentationInitOptions&amp; options) {
   }
 
   // init ground detector
-  ground_detector_ = BaseGroundDetectorRegisterer::GetInstanceByName(ground_detector_str_);
+  ground_detector_ =
+      BaseGroundDetectorRegisterer::GetInstanceByName(ground_detector_str_);
   CHECK_NOTNULL(ground_detector_);
   GroundDetectorInitOptions ground_detector_init_options;
   ACHECK(ground_detector_-&gt;Init(ground_detector_init_options))
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\segmentation_component.cc" new_path="modules\perception\onboard\component\segmentation_component.cc" added_lines="4" deleted_lines="2">
				<diff>@@ -23,6 +23,8 @@
 #include "modules/perception/lidar/common/lidar_log.h"
 #include "modules/perception/onboard/common_flags/common_flags.h"
 
+using ::apollo::cyber::Clock;
+
 namespace apollo {
 namespace perception {
 namespace onboard {
@@ -57,7 +59,7 @@ bool SegmentationComponent::Proc(
   AINFO &lt;&lt; std::setprecision(16)
         &lt;&lt; "Enter segmentation component, message timestamp: "
         &lt;&lt; message-&gt;measurement_time() &lt;&lt; " current timestamp: "
-        &lt;&lt; apollo::common::time::Clock::NowInSeconds();
+        &lt;&lt; Clock::NowInSeconds();
 
   std::shared_ptr&lt;LidarFrameMessage&gt; out_message(new (std::nothrow)
                                                      LidarFrameMessage);
@@ -103,7 +105,7 @@ bool SegmentationComponent::InternalProc(
     s_seq_num_++;
   }
   const double timestamp = in_message-&gt;measurement_time();
-  const double cur_time = apollo::common::time::Clock::NowInSeconds();
+  const double cur_time = Clock::NowInSeconds();
   const double start_latency = (cur_time - timestamp) * 1e3;
   AINFO &lt;&lt; std::setprecision(16) &lt;&lt; "FRAME_STATISTICS:Lidar:Start:msg_time["
         &lt;&lt; timestamp &lt;&lt; "]:sensor[" &lt;&lt; sensor_name_ &lt;&lt; "]:cur_time[" &lt;&lt; cur_time
</diff>
			</file>
			<file old_path="modules\perception\production\conf\perception\lidar\config_manager.config" new_path="modules\perception\production\conf\perception\lidar\config_manager.config" added_lines="10" deleted_lines="10">
				<diff>@@ -1,15 +1,15 @@
 model_config_path: "./conf/perception/lidar/modules/map_manager.config"
-#model_config_path: "./conf/perception/lidar/modules/scene_manager.config"
-#model_config_path: "./conf/perception/lidar/modules/object_filter_bank.config"
+model_config_path: "./conf/perception/lidar/modules/scene_manager.config"
+model_config_path: "./conf/perception/lidar/modules/object_filter_bank.config"
 model_config_path: "./conf/perception/lidar/modules/pointcloud_preprocessor.config"
-#model_config_path: "./conf/perception/lidar/modules/roi_boundary_filter.config"
-#model_config_path: "./conf/perception/lidar/modules/hdmap_roi_filter.config"
-#model_config_path: "./conf/perception/lidar/modules/cnnseg.config"
-#model_config_path: "./conf/perception/lidar/modules/ncut.config"
-#model_config_path: "./conf/perception/lidar/modules/spatio_temporal_ground_detector.config"
+model_config_path: "./conf/perception/lidar/modules/roi_boundary_filter.config"
+model_config_path: "./conf/perception/lidar/modules/hdmap_roi_filter.config"
+model_config_path: "./conf/perception/lidar/modules/cnnseg.config"
+model_config_path: "./conf/perception/lidar/modules/ncut.config"
+model_config_path: "./conf/perception/lidar/modules/spatio_temporal_ground_detector.config"
 model_config_path: "./conf/perception/lidar/modules/lidar_obstacle_pipeline.config"
 model_config_path: "./conf/perception/lidar/modules/fused_classifier.config"
 model_config_path: "./conf/perception/lidar/modules/multi_lidar_fusion.config"
-#model_config_path: "./conf/perception/lidar/modules/roi_service.config"
-#model_config_path: "./conf/perception/lidar/modules/ground_service.config"
-#model_config_path: "./conf/perception/lidar/modules/ground_service_detector.config"
+model_config_path: "./conf/perception/lidar/modules/roi_service.config"
+model_config_path: "./conf/perception/lidar/modules/ground_service.config"
+model_config_path: "./conf/perception/lidar/modules/ground_service_detector.config"
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5ab9a5b9b021f29785e478fd1e3451626487762c" author="Chao Ma">
		<msg>Canbus: update battery info for good display in D-KIT (#13110)

* dreamview: modify the types of battery percent

* canbus: modify the battery soc display in ch

* canbus: update the devkit bms report</msg>
		<modified_files>
			<file old_path="modules\canbus\vehicle\ch\ch_controller.cc" new_path="modules\canbus\vehicle\ch\ch_controller.cc" added_lines="0" deleted_lines="2">
				<diff>@@ -253,8 +253,6 @@ Chassis ChController::chassis() {
       chassis_detail.ch().ecu_status_2_516().has_battery_soc()) {
     chassis_.set_battery_soc_percentage(
         chassis_detail.ch().ecu_status_2_516().battery_soc());
-  } else {
-    chassis_.set_battery_soc_percentage(0);
   }
 
   return chassis_;
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\devkit_controller.cc" new_path="modules\canbus\vehicle\devkit\devkit_controller.cc" added_lines="10" deleted_lines="4">
				<diff>@@ -16,11 +16,12 @@
 
 #include "modules/canbus/vehicle/devkit/devkit_controller.h"
 
+#include "modules/common/proto/vehicle_signal.pb.h"
+
 #include "cyber/common/log.h"
 #include "cyber/time/time.h"
 #include "modules/canbus/vehicle/devkit/devkit_message_manager.h"
 #include "modules/canbus/vehicle/vehicle_controller.h"
-#include "modules/common/proto/vehicle_signal.pb.h"
 #include "modules/drivers/canbus/can_comm/can_sender.h"
 #include "modules/drivers/canbus/can_comm/protocol_data.h"
 
@@ -184,11 +185,8 @@ Chassis DevkitController::chassis() {
       chassis_detail.devkit().vcu_report_505().has_speed()) {
     chassis_.set_speed_mps(
         static_cast&lt;float&gt;(chassis_detail.devkit().vcu_report_505().speed()));
-    chassis_.set_battery_soc_percentage(
-        chassis_detail.devkit().vcu_report_505().battery_soc());
   } else {
     chassis_.set_speed_mps(0);
-    chassis_.set_battery_soc_percentage(0);
   }
   // 7 no odometer
   // chassis_.set_odometer_m(0);
@@ -262,6 +260,14 @@ Chassis DevkitController::chassis() {
   } else {
     chassis_.set_parking_brake(false);
   }
+  // 14 battery soc
+  if (chassis_detail.devkit().has_bms_report_512() &amp;&amp;
+      chassis_detail.devkit().bms_report_512().has_battery_soc()) {
+    chassis_.set_battery_soc_percentage(
+        chassis_detail.devkit().bms_report_512().battery_soc());
+  } else {
+    chassis_.set_battery_soc_percentage(0);
+  }
 
   return chassis_;
 }
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\devkit_message_manager.cc" new_path="modules\canbus\vehicle\devkit\devkit_message_manager.cc" added_lines="7" deleted_lines="4">
				<diff>@@ -17,14 +17,16 @@
 #include "modules/canbus/vehicle/devkit/devkit_message_manager.h"
 
 #include "modules/canbus/vehicle/devkit/protocol/brake_command_101.h"
-#include "modules/canbus/vehicle/devkit/protocol/brake_report_501.h"
 #include "modules/canbus/vehicle/devkit/protocol/gear_command_103.h"
-#include "modules/canbus/vehicle/devkit/protocol/gear_report_503.h"
 #include "modules/canbus/vehicle/devkit/protocol/park_command_104.h"
-#include "modules/canbus/vehicle/devkit/protocol/park_report_504.h"
 #include "modules/canbus/vehicle/devkit/protocol/steering_command_102.h"
-#include "modules/canbus/vehicle/devkit/protocol/steering_report_502.h"
 #include "modules/canbus/vehicle/devkit/protocol/throttle_command_100.h"
+
+#include "modules/canbus/vehicle/devkit/protocol/bms_report_512.h"
+#include "modules/canbus/vehicle/devkit/protocol/brake_report_501.h"
+#include "modules/canbus/vehicle/devkit/protocol/gear_report_503.h"
+#include "modules/canbus/vehicle/devkit/protocol/park_report_504.h"
+#include "modules/canbus/vehicle/devkit/protocol/steering_report_502.h"
 #include "modules/canbus/vehicle/devkit/protocol/throttle_report_500.h"
 #include "modules/canbus/vehicle/devkit/protocol/ultr_sensor_1_507.h"
 #include "modules/canbus/vehicle/devkit/protocol/ultr_sensor_2_508.h"
@@ -47,6 +49,7 @@ DevkitMessageManager::DevkitMessageManager() {
   AddSendProtocolData&lt;Throttlecommand100, true&gt;();
 
   // Report Messages
+  AddRecvProtocolData&lt;Bmsreport512, true&gt;();
   AddRecvProtocolData&lt;Brakereport501, true&gt;();
   AddRecvProtocolData&lt;Gearreport503, true&gt;();
   AddRecvProtocolData&lt;Parkreport504, true&gt;();
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\devkit_message_manager_test.cc" new_path="modules\canbus\vehicle\devkit\devkit_message_manager_test.cc" added_lines="3" deleted_lines="0">
				<diff>@@ -17,6 +17,8 @@
 #include "modules/canbus/vehicle/devkit/devkit_message_manager.h"
 
 #include "gtest/gtest.h"
+
+#include "modules/canbus/vehicle/devkit/protocol/bms_report_512.h"
 #include "modules/canbus/vehicle/devkit/protocol/brake_command_101.h"
 #include "modules/canbus/vehicle/devkit/protocol/brake_report_501.h"
 #include "modules/canbus/vehicle/devkit/protocol/gear_command_103.h"
@@ -58,6 +60,7 @@ TEST_F(DevkitMessageManagerTest, GetSendProtocols) {
 }
 
 TEST_F(DevkitMessageManagerTest, GetRecvProtocols) {
+  EXPECT_NE(manager_.GetMutableProtocolDataById(Bmsreport512::ID), nullptr);
   EXPECT_NE(manager_.GetMutableProtocolDataById(Brakereport501::ID), nullptr);
   EXPECT_NE(manager_.GetMutableProtocolDataById(Gearreport503::ID), nullptr);
   EXPECT_NE(manager_.GetMutableProtocolDataById(Parkreport504::ID), nullptr);
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\protocol\vcu_report_505.cc" new_path="modules\canbus\vehicle\devkit\protocol\vcu_report_505.cc" added_lines="23" deleted_lines="37">
				<diff>@@ -17,6 +17,7 @@
 #include "modules/canbus/vehicle/devkit/protocol/vcu_report_505.h"
 
 #include "glog/logging.h"
+
 #include "modules/drivers/canbus/common/byte.h"
 #include "modules/drivers/canbus/common/canbus_consts.h"
 
@@ -31,8 +32,6 @@ const int32_t Vcureport505::ID = 0x505;
 
 void Vcureport505::Parse(const std::uint8_t* bytes, int32_t length,
                          ChassisDetail* chassis) const {
-  chassis-&gt;mutable_devkit()-&gt;mutable_vcu_report_505()-&gt;set_battery_soc(
-      battery_soc(bytes, length));
   chassis-&gt;mutable_devkit()-&gt;mutable_vcu_report_505()-&gt;set_vehicle_mode_state(
       vehicle_mode_state(bytes, length));
   chassis-&gt;mutable_devkit()-&gt;mutable_vcu_report_505()-&gt;set_frontcrash_state(
@@ -47,23 +46,12 @@ void Vcureport505::Parse(const std::uint8_t* bytes, int32_t length,
       speed(bytes, length));
 }
 
-// config detail: {'name': 'battery_soc', 'offset': 0.0, 'precision': 1.0,
-// 'len': 8, 'is_signed_var': False, 'physical_range': '[0|100]', 'bit': 47,
-// 'type': 'int', 'order': 'motorola', 'physical_unit': '%'}
-int Vcureport505::battery_soc(const std::uint8_t* bytes, int32_t length) const {
-  Byte t0(bytes + 5);
-  int32_t x = t0.get_byte(0, 8);
-
-  int ret = x;
-  return ret;
-}
-
-// config detail: {'name': 'vehicle_mode_state', 'enum': {0:
+// config detail: {'bit': 36, 'enum': {0:
 // 'VEHICLE_MODE_STATE_MANUAL_REMOTE_MODE', 1: 'VEHICLE_MODE_STATE_AUTO_MODE',
 // 2: 'VEHICLE_MODE_STATE_EMERGENCY_MODE', 3:
-// 'VEHICLE_MODE_STATE_STANDBY_MODE'}, 'precision': 1.0, 'len': 2,
-// 'is_signed_var': False, 'offset': 0.0, 'physical_range': '[0|0]', 'bit': 36,
-// 'type': 'enum', 'order': 'motorola', 'physical_unit': ''}
+// 'VEHICLE_MODE_STATE_STANDBY_MODE'}, 'is_signed_var': False, 'len': 2, 'name':
+// 'vehicle_mode_state', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+// '[0|0]', 'physical_unit': '', 'precision': 1.0, 'type': 'enum'}
 Vcu_report_505::Vehicle_mode_stateType Vcureport505::vehicle_mode_state(
     const std::uint8_t* bytes, int32_t length) const {
   Byte t0(bytes + 4);
@@ -74,11 +62,10 @@ Vcu_report_505::Vehicle_mode_stateType Vcureport505::vehicle_mode_state(
   return ret;
 }
 
-// config detail: {'name': 'frontcrash_state', 'enum': {0:
-// 'FRONTCRASH_STATE_NO_EVENT', 1: 'FRONTCRASH_STATE_CRASH_EVENT'},
-// 'precision': 1.0, 'len': 1, 'is_signed_var': False, 'offset': 0.0,
-// 'physical_range': '[0|0]', 'bit': 33, 'type': 'enum', 'order': 'motorola',
-// 'physical_unit': ''}
+// config detail: {'bit': 33, 'enum': {0: 'FRONTCRASH_STATE_NO_EVENT', 1:
+// 'FRONTCRASH_STATE_CRASH_EVENT'}, 'is_signed_var': False, 'len': 1, 'name':
+// 'frontcrash_state', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+// '[0|0]', 'physical_unit': '', 'precision': 1.0, 'type': 'enum'}
 Vcu_report_505::Frontcrash_stateType Vcureport505::frontcrash_state(
     const std::uint8_t* bytes, int32_t length) const {
   Byte t0(bytes + 4);
@@ -89,11 +76,10 @@ Vcu_report_505::Frontcrash_stateType Vcureport505::frontcrash_state(
   return ret;
 }
 
-// config detail: {'name': 'backcrash_state', 'enum': {0:
-// 'BACKCRASH_STATE_NO_EVENT', 1: 'BACKCRASH_STATE_CRASH_EVENT'},
-// 'precision': 1.0, 'len': 1, 'is_signed_var': False, 'offset': 0.0,
-// 'physical_range': '[0|0]', 'bit': 34, 'type': 'enum', 'order': 'motorola',
-// 'physical_unit': ''}
+// config detail: {'bit': 34, 'enum': {0: 'BACKCRASH_STATE_NO_EVENT', 1:
+// 'BACKCRASH_STATE_CRASH_EVENT'}, 'is_signed_var': False, 'len': 1, 'name':
+// 'backcrash_state', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+// '[0|0]', 'physical_unit': '', 'precision': 1.0, 'type': 'enum'}
 Vcu_report_505::Backcrash_stateType Vcureport505::backcrash_state(
     const std::uint8_t* bytes, int32_t length) const {
   Byte t0(bytes + 4);
@@ -104,10 +90,10 @@ Vcu_report_505::Backcrash_stateType Vcureport505::backcrash_state(
   return ret;
 }
 
-// config detail: {'name': 'aeb_state', 'enum': {0: 'AEB_STATE_INACTIVE', 1:
-// 'AEB_STATE_ACTIVE'}, 'precision': 1.0, 'len': 1, 'is_signed_var': False,
-// 'offset': 0.0, 'physical_range': '[0|0]', 'bit': 32, 'type': 'enum', 'order':
-// 'motorola', 'physical_unit': ''}
+// config detail: {'bit': 32, 'enum': {0: 'AEB_STATE_INACTIVE', 1:
+// 'AEB_STATE_ACTIVE'}, 'is_signed_var': False, 'len': 1, 'name': 'aeb_state',
+// 'offset': 0.0, 'order': 'motorola', 'physical_range': '[0|0]',
+// 'physical_unit': '', 'precision': 1.0, 'type': 'enum'}
 Vcu_report_505::Aeb_stateType Vcureport505::aeb_state(const std::uint8_t* bytes,
                                                       int32_t length) const {
   Byte t0(bytes + 4);
@@ -118,9 +104,9 @@ Vcu_report_505::Aeb_stateType Vcureport505::aeb_state(const std::uint8_t* bytes,
   return ret;
 }
 
-// config detail: {'name': 'acc', 'offset': 0.0, 'precision': 0.01, 'len': 12,
-// 'is_signed_var': True, 'physical_range': '[-10|10]', 'bit': 7, 'type':
-// 'double', 'order': 'motorola', 'physical_unit': 'm/s^2'}
+// config detail: {'bit': 7, 'is_signed_var': True, 'len': 12, 'name': 'acc',
+// 'offset': 0.0, 'order': 'motorola', 'physical_range': '[-10|10]',
+// 'physical_unit': 'm/s^2', 'precision': 0.01, 'type': 'double'}
 double Vcureport505::acc(const std::uint8_t* bytes, int32_t length) const {
   Byte t0(bytes + 0);
   int32_t x = t0.get_byte(0, 8);
@@ -137,9 +123,9 @@ double Vcureport505::acc(const std::uint8_t* bytes, int32_t length) const {
   return ret;
 }
 
-// config detail: {'name': 'speed', 'offset': 0.0, 'precision': 0.001, 'len':
-// 16, 'is_signed_var': False, 'physical_range': '[0|65.535]', 'bit': 23,
-// 'type': 'double', 'order': 'motorola', 'physical_unit': 'm/s'}
+// config detail: {'bit': 23, 'is_signed_var': False, 'len': 16, 'name':
+// 'speed', 'offset': 0.0, 'order': 'motorola', 'physical_range': '[0|65.535]',
+// 'physical_unit': 'm/s', 'precision': 0.001, 'type': 'double'}
 double Vcureport505::speed(const std::uint8_t* bytes, int32_t length) const {
   Byte t0(bytes + 2);
   int32_t x = t0.get_byte(0, 8);
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\protocol\vcu_report_505.h" new_path="modules\canbus\vehicle\devkit\protocol\vcu_report_505.h" added_lines="23" deleted_lines="29">
				<diff>@@ -32,51 +32,45 @@ class Vcureport505 : public ::apollo::drivers::canbus::ProtocolData&lt;
              ChassisDetail* chassis) const override;
 
  private:
-  // config detail: {'name': 'Battery_Soc', 'offset': 0.0, 'precision': 1.0,
-  // 'len': 8, 'is_signed_var': False, 'physical_range': '[0|100]', 'bit': 47,
-  // 'type': 'int', 'order': 'motorola', 'physical_unit': '%'}
-  int battery_soc(const std::uint8_t* bytes, const int32_t length) const;
-
-  // config detail: {'name': 'Vehicle_Mode_State', 'enum': {0:
+  // config detail: {'bit': 36, 'enum': {0:
   // 'VEHICLE_MODE_STATE_MANUAL_REMOTE_MODE', 1: 'VEHICLE_MODE_STATE_AUTO_MODE',
   // 2: 'VEHICLE_MODE_STATE_EMERGENCY_MODE', 3:
-  // 'VEHICLE_MODE_STATE_STANDBY_MODE'}, 'precision': 1.0, 'len': 2,
-  // 'is_signed_var': False, 'offset': 0.0, 'physical_range': '[0|0]', 'bit':
-  // 36, 'type': 'enum', 'order': 'motorola', 'physical_unit': ''}
+  // 'VEHICLE_MODE_STATE_STANDBY_MODE'}, 'is_signed_var': False, 'len': 2,
+  // 'name': 'Vehicle_Mode_State', 'offset': 0.0, 'order': 'motorola',
+  // 'physical_range': '[0|0]', 'physical_unit': '', 'precision': 1.0, 'type':
+  // 'enum'}
   Vcu_report_505::Vehicle_mode_stateType vehicle_mode_state(
       const std::uint8_t* bytes, const int32_t length) const;
 
-  // config detail: {'name': 'FrontCrash_State', 'enum': {0:
-  // 'FRONTCRASH_STATE_NO_EVENT', 1: 'FRONTCRASH_STATE_CRASH_EVENT'},
-  // 'precision': 1.0, 'len': 1, 'is_signed_var': False, 'offset': 0.0,
-  // 'physical_range': '[0|0]', 'bit': 33, 'type': 'enum', 'order': 'motorola',
-  // 'physical_unit': ''}
+  // config detail: {'bit': 33, 'enum': {0: 'FRONTCRASH_STATE_NO_EVENT', 1:
+  // 'FRONTCRASH_STATE_CRASH_EVENT'}, 'is_signed_var': False, 'len': 1, 'name':
+  // 'FrontCrash_State', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+  // '[0|0]', 'physical_unit': '', 'precision': 1.0, 'type': 'enum'}
   Vcu_report_505::Frontcrash_stateType frontcrash_state(
       const std::uint8_t* bytes, const int32_t length) const;
 
-  // config detail: {'name': 'BackCrash_State', 'enum': {0:
-  // 'BACKCRASH_STATE_NO_EVENT', 1: 'BACKCRASH_STATE_CRASH_EVENT'},
-  // 'precision': 1.0, 'len': 1, 'is_signed_var': False, 'offset': 0.0,
-  // 'physical_range': '[0|0]', 'bit': 34, 'type': 'enum', 'order': 'motorola',
-  // 'physical_unit': ''}
+  // config detail: {'bit': 34, 'enum': {0: 'BACKCRASH_STATE_NO_EVENT', 1:
+  // 'BACKCRASH_STATE_CRASH_EVENT'}, 'is_signed_var': False, 'len': 1, 'name':
+  // 'BackCrash_State', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+  // '[0|0]', 'physical_unit': '', 'precision': 1.0, 'type': 'enum'}
   Vcu_report_505::Backcrash_stateType backcrash_state(
       const std::uint8_t* bytes, const int32_t length) const;
 
-  // config detail: {'name': 'AEB_State', 'enum': {0: 'AEB_STATE_INACTIVE', 1:
-  // 'AEB_STATE_ACTIVE'}, 'precision': 1.0, 'len': 1, 'is_signed_var': False,
-  // 'offset': 0.0, 'physical_range': '[0|0]', 'bit': 32, 'type': 'enum',
-  // 'order': 'motorola', 'physical_unit': ''}
+  // config detail: {'bit': 32, 'enum': {0: 'AEB_STATE_INACTIVE', 1:
+  // 'AEB_STATE_ACTIVE'}, 'is_signed_var': False, 'len': 1, 'name': 'AEB_State',
+  // 'offset': 0.0, 'order': 'motorola', 'physical_range': '[0|0]',
+  // 'physical_unit': '', 'precision': 1.0, 'type': 'enum'}
   Vcu_report_505::Aeb_stateType aeb_state(const std::uint8_t* bytes,
                                           const int32_t length) const;
 
-  // config detail: {'name': 'ACC', 'offset': 0.0, 'precision': 0.01, 'len': 12,
-  // 'is_signed_var': True, 'physical_range': '[-10|10]', 'bit': 7, 'type':
-  // 'double', 'order': 'motorola', 'physical_unit': 'm/s^2'}
+  // config detail: {'bit': 7, 'is_signed_var': True, 'len': 12, 'name': 'ACC',
+  // 'offset': 0.0, 'order': 'motorola', 'physical_range': '[-10|10]',
+  // 'physical_unit': 'm/s^2', 'precision': 0.01, 'type': 'double'}
   double acc(const std::uint8_t* bytes, const int32_t length) const;
 
-  // config detail: {'name': 'SPEED', 'offset': 0.0, 'precision': 0.001, 'len':
-  // 16, 'is_signed_var': False, 'physical_range': '[0|65.535]', 'bit': 23,
-  // 'type': 'double', 'order': 'motorola', 'physical_unit': 'm/s'}
+  // config detail: {'bit': 23, 'is_signed_var': False, 'len': 16, 'name':
+  // 'SPEED', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+  // '[0|65.535]', 'physical_unit': 'm/s', 'precision': 0.001, 'type': 'double'}
   double speed(const std::uint8_t* bytes, const int32_t length) const;
 };
 
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\protocol\vcu_report_505_test.cc" new_path="modules\canbus\vehicle\devkit\protocol\vcu_report_505_test.cc" added_lines="0" deleted_lines="1">
				<diff>@@ -42,7 +42,6 @@ TEST_F(Vcureport505Test, General) {
   EXPECT_EQ(data[6], 0b00000100);
   EXPECT_EQ(data[7], 0b00000101);
 
-  EXPECT_EQ(cd.devkit().vcu_report_505().battery_soc(), 3);
   EXPECT_EQ(cd.devkit().vcu_report_505().vehicle_mode_state(), 1);
   EXPECT_EQ(cd.devkit().vcu_report_505().frontcrash_state(), 1);
   EXPECT_EQ(cd.devkit().vcu_report_505().backcrash_state(), 0);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a5403d3676d62a58ca739b26cfa28d7480b6bc99" author="lj0919">
		<msg>Dreamview loop routing function</msg>
		<modified_files>
			<file old_path="modules\common\adapters\adapter_gflags.cc" new_path="modules\common\adapters\adapter_gflags.cc" added_lines="2" deleted_lines="0">
				<diff>@@ -241,3 +241,5 @@ DEFINE_string(latency_recording_topic, "/apollo/common/latency_records",
               "Latency recording topic.");
 DEFINE_string(latency_reporting_topic, "/apollo/common/latency_reports",
               "Latency reporting topic.");
+DEFINE_string(task_topic, "/apollo/task_manager",
+              "task manager topic name");
</diff>
			</file>
			<file old_path="modules\common\adapters\adapter_gflags.h" new_path="modules\common\adapters\adapter_gflags.h" added_lines="1" deleted_lines="0">
				<diff>@@ -115,6 +115,7 @@ DECLARE_string(stream_status_topic);
 DECLARE_string(heading_topic);
 DECLARE_string(rtcm_data_topic);
 DECLARE_string(audio_event_topic);
+DECLARE_string(task_topic);
 
 // Guardian topic
 DECLARE_string(guardian_topic);
</diff>
			</file>
			<file old_path="modules\common\configs\config_gflags.cc" new_path="modules\common\configs\config_gflags.cc" added_lines="3" deleted_lines="0">
				<diff>@@ -31,6 +31,9 @@ DEFINE_string(routing_map_filename, "routing_map.bin|routing_map.txt",
               "Routing map files in the map_dir, search in order.");
 DEFINE_string(end_way_point_filename, "default_end_way_point.txt",
               "End way point of the map, will be sent in RoutingRequest.");
+DEFINE_string(default_routing_filename, "default_cycle_routing.txt",
+              "Default cycle routing of the map, will be sent in Task to Task "
+              "Manager Module.");
 DEFINE_string(speed_control_filename, "speed_control.pb.txt",
               "The speed control region in a map.");
 
</diff>
			</file>
			<file old_path="modules\common\configs\config_gflags.h" new_path="modules\common\configs\config_gflags.h" added_lines="1" deleted_lines="0">
				<diff>@@ -28,6 +28,7 @@ DECLARE_string(base_map_filename);
 DECLARE_string(sim_map_filename);
 DECLARE_string(routing_map_filename);
 DECLARE_string(end_way_point_filename);
+DECLARE_string(default_routing_filename);
 DECLARE_string(speed_control_filename);
 
 DECLARE_double(look_forward_time_sec);
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_service.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_service.cc" added_lines="9" deleted_lines="0">
				<diff>@@ -78,6 +78,7 @@ using apollo::relative_map::NavigationInfo;
 using apollo::routing::RoutingRequest;
 using apollo::routing::RoutingResponse;
 using apollo::storytelling::Stories;
+using apollo::task_manager::Task;
 
 using Json = nlohmann::json;
 using ::google::protobuf::util::MessageToJsonString;
@@ -310,6 +311,7 @@ void SimulationWorldService::InitReaders() {
         std::unique_lock&lt;std::mutex&gt; lock(monitor_msgs_mutex_);
         monitor_msgs_.push_back(monitor_message);
       });
+  task_reader_ = node_-&gt;CreateReader&lt;Task&gt;(FLAGS_task_topic);
 }
 
 void SimulationWorldService::InitWriters() {
@@ -334,6 +336,7 @@ void SimulationWorldService::InitWriters() {
 
   routing_response_writer_ =
       node_-&gt;CreateWriter&lt;RoutingResponse&gt;(FLAGS_routing_response_topic);
+  task_writer_ = node_-&gt;CreateWriter&lt;Task&gt;(FLAGS_task_topic);
 }
 
 void SimulationWorldService::Update() {
@@ -1351,6 +1354,7 @@ void SimulationWorldService::DumpMessages() {
   DumpMessageFromReader(perception_traffic_light_reader_.get());
   DumpMessageFromReader(relative_map_reader_.get());
   DumpMessageFromReader(navigation_reader_.get());
+  DumpMessageFromReader(task_reader_.get());
 }
 
 void SimulationWorldService::PublishNavigationInfo(
@@ -1365,6 +1369,11 @@ void SimulationWorldService::PublishRoutingRequest(
   routing_request_writer_-&gt;Write(routing_request);
 }
 
+void SimulationWorldService::PublishTask(const std::shared_ptr&lt;Task&gt; &amp;task) {
+  FillHeader(FLAGS_dreamview_module_name, task.get());
+  task_writer_-&gt;Write(task);
+}
+
 void SimulationWorldService::PublishMonitorMessage(
     apollo::common::monitor::MonitorMessageItem::LogLevel log_level,
     const std::string &amp;msg) {
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_service.h" new_path="modules\dreamview\backend\simulation_world\simulation_world_service.h" added_lines="5" deleted_lines="0">
				<diff>@@ -48,6 +48,7 @@
 #include "modules/planning/proto/planning_internal.pb.h"
 #include "modules/prediction/proto/prediction_obstacle.pb.h"
 #include "modules/storytelling/proto/story.pb.h"
+#include "modules/task_manager/proto/task_manager.pb.h"
 
 #include "cyber/common/log.h"
 #include "modules/common/monitor_log/monitor_log_buffer.h"
@@ -148,6 +149,8 @@ class SimulationWorldService {
   void PublishRoutingRequest(
       const std::shared_ptr&lt;apollo::routing::RoutingRequest&gt; &amp;);
 
+  void PublishTask(const std::shared_ptr&lt;apollo::task_manager::Task&gt; &amp;);
+
   void GetMapElementIds(double radius, MapElementIds *ids) const;
 
   const apollo::hdmap::Map &amp;GetRelativeMap() const;
@@ -386,6 +389,7 @@ class SimulationWorldService {
       storytelling_reader_;
   std::shared_ptr&lt;cyber::Reader&lt;apollo::audio::AudioDetection&gt;&gt;
       audio_detection_reader_;
+  std::shared_ptr&lt;cyber::Reader&lt;apollo::task_manager::Task&gt;&gt; task_reader_;
 
   // Writers.
   std::shared_ptr&lt;cyber::Writer&lt;apollo::relative_map::NavigationInfo&gt;&gt;
@@ -394,6 +398,7 @@ class SimulationWorldService {
       routing_request_writer_;
   std::shared_ptr&lt;cyber::Writer&lt;apollo::routing::RoutingResponse&gt;&gt;
       routing_response_writer_;
+  std::shared_ptr&lt;cyber::Writer&lt;apollo::task_manager::Task&gt;&gt; task_writer_;
 
   FRIEND_TEST(SimulationWorldServiceTest, UpdateMonitorSuccess);
   FRIEND_TEST(SimulationWorldServiceTest, UpdateMonitorRemove);
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" added_lines="140" deleted_lines="0">
				<diff>@@ -29,10 +29,15 @@ namespace dreamview {
 
 using apollo::common::monitor::MonitorMessageItem;
 using apollo::common::util::ContainsKey;
+using apollo::common::util::JsonUtil;
 using apollo::cyber::common::GetProtoFromASCIIFile;
+using apollo::cyber::common::SetProtoToASCIIFile;
+using apollo::hdmap::DefaultRoutingFile;
 using apollo::hdmap::EndWayPointFile;
 using apollo::relative_map::NavigationInfo;
 using apollo::routing::RoutingRequest;
+using apollo::task_manager::CycleRoutingTask;
+using apollo::task_manager::Task;
 
 using Json = nlohmann::json;
 using google::protobuf::util::JsonStringToMessage;
@@ -160,6 +165,35 @@ void SimulationWorldUpdater::RegisterMessageHandlers() {
         }
       });
 
+  websocket_-&gt;RegisterMessageHandler(
+      "SendDefaultCycleRoutingRequest",
+      [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
+        auto task = std::make_shared&lt;Task&gt;();
+        auto *cycle_routing_task = task-&gt;mutable_cycle_routing_task();
+        auto *routing_request = cycle_routing_task-&gt;mutable_routing_request();
+        if (!ContainsKey(json, "cycleNumber") ||
+            !json.find("cycleNumber")-&gt;is_number()) {
+          AERROR &lt;&lt; "Failed to prepare a cycle routing request: Invalid cycle "
+                    "number";
+          return;
+        }
+        bool succeed = ConstructRoutingRequest(json, routing_request);
+        if (succeed) {
+          cycle_routing_task-&gt;set_cycle_num(
+              static_cast&lt;int&gt;(json["cycleNumber"]));
+          task-&gt;set_task_name("cycle_routing_task");
+          task-&gt;set_task_type(apollo::task_manager::TaskType::CYCLE_ROUTING);
+          sim_world_service_.PublishTask(task);
+          AINFO &lt;&lt; "The task is : " &lt;&lt; task-&gt;DebugString();
+          sim_world_service_.PublishMonitorMessage(
+              MonitorMessageItem::INFO, "Default cycle routing request sent.");
+        } else {
+          sim_world_service_.PublishMonitorMessage(
+              MonitorMessageItem::ERROR,
+              "Failed to send a default cycle routing request.");
+        }
+      });
+
   websocket_-&gt;RegisterMessageHandler(
       "RequestSimulationWorld",
       [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
@@ -237,6 +271,40 @@ void SimulationWorldUpdater::RegisterMessageHandlers() {
         websocket_-&gt;SendData(conn, response.dump());
       });
 
+  websocket_-&gt;RegisterMessageHandler(
+      "GetDefaultRoutings",
+      [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
+        Json response;
+        response["type"] = "DefaultRoutings";
+
+        Json default_routing_list = Json::array();
+        if (LoadDefaultRoutings()) {
+          for (const auto &amp;defaultrouting :
+               default_routings_.defaultrouting()) {
+            Json drouting;
+            drouting["name"] = defaultrouting.name();
+            Json point_list;
+            for (const auto &amp;point : defaultrouting.point()) {
+              Json point_json;
+              point_json["x"] = point.x();
+              point_json["y"] = point.y();
+              point_list.push_back(point_json);
+            }
+            drouting["point"] = point_list;
+            default_routing_list.push_back(drouting);
+          }
+        } else {
+          sim_world_service_.PublishMonitorMessage(
+              MonitorMessageItem::ERROR,
+              "Failed to load default "
+              "routing. Please make sure the "
+              "file exists at " +
+                  DefaultRoutingFile());
+        }
+        response["defaultRoutings"] = default_routing_list;
+        websocket_-&gt;SendData(conn, response.dump());
+      });
+
   websocket_-&gt;RegisterMessageHandler(
       "Reset", [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
         sim_world_service_.SetToClear();
@@ -272,6 +340,26 @@ void SimulationWorldUpdater::RegisterMessageHandlers() {
         response["data"] = data_collection_monitor_-&gt;GetProgressAsJson();
         websocket_-&gt;SendData(conn, response.dump());
       });
+
+  websocket_-&gt;RegisterMessageHandler(
+      "SaveDefaultRouting",
+      [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
+        bool succeed = AddDefaultRouting(json);
+        if (succeed) {
+          sim_world_service_.PublishMonitorMessage(
+              MonitorMessageItem::INFO, "Successfully add default routing.");
+          if (!default_routing_) {
+            AERROR &lt;&lt; "Failed to add a default routing" &lt;&lt; std::endl;
+          }
+          Json response = JsonUtil::ProtoToTypedJson("AddDefaultRoutingPath",
+                                                     *default_routing_);
+          websocket_-&gt;SendData(conn, response.dump());
+        } else {
+          sim_world_service_.PublishMonitorMessage(
+              MonitorMessageItem::ERROR, "Failed to add a default routing.");
+        }
+      });
+
   camera_ws_-&gt;RegisterMessageHandler(
       "RequestCameraData",
       [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
@@ -432,5 +520,57 @@ bool SimulationWorldUpdater::LoadPOI() {
   return false;
 }
 
+bool SimulationWorldUpdater::LoadDefaultRoutings() {
+  if (GetProtoFromASCIIFile(DefaultRoutingFile(), &amp;default_routings_)) {
+    return true;
+  }
+
+  AWARN &lt;&lt; "Failed to load default routings of DefaultRoutings from "
+        &lt;&lt; DefaultRoutingFile();
+  return false;
+}
+
+bool SimulationWorldUpdater::AddDefaultRouting(const Json &amp;json) {
+  if (!ContainsKey(json, "name")) {
+    AERROR &lt;&lt; "Failed to save a default routing: routing name not found.";
+    return false;
+  }
+
+  if (!ContainsKey(json, "point")) {
+    AERROR &lt;&lt; "Failed to save a default routing: default routing points not "
+              "found.";
+    return false;
+  }
+
+  std::string name = json["name"];
+  auto iter = json.find("point");
+  default_routing_ = default_routings_.add_defaultrouting();
+  default_routing_-&gt;clear_name();
+  default_routing_-&gt;clear_point();
+  default_routing_-&gt;set_name(name);
+  auto *waypoint = default_routing_-&gt;mutable_point();
+  if (iter != json.end() &amp;&amp; iter-&gt;is_array()) {
+    for (size_t i = 0; i &lt; iter-&gt;size(); ++i) {
+      auto &amp;point = (*iter)[i];
+      auto *p = waypoint-&gt;Add();
+      if (!ValidateCoordinate(point)) {
+        AERROR &lt;&lt; "Failed to save a default routing: invalid waypoint.";
+        return false;
+      }
+      p-&gt;set_x(static_cast&lt;double&gt;(point["x"]));
+      p-&gt;set_y(static_cast&lt;double&gt;(point["y"]));
+    }
+  }
+  AINFO &lt;&lt; "Default Routing Points to be saved:\n";
+  std::string file_name = DefaultRoutingFile();
+  if (!SetProtoToASCIIFile(default_routings_, file_name)) {
+    AERROR &lt;&lt; "Failed to set proto to ascii file " &lt;&lt; file_name;
+    return false;
+  }
+  AINFO &lt;&lt; "Success in setting proto to cycle_routing file" &lt;&lt; file_name;
+
+  return true;
+}
+
 }  // namespace dreamview
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_updater.h" new_path="modules\dreamview\backend\simulation_world\simulation_world_updater.h" added_lines="23" deleted_lines="1">
				<diff>@@ -27,6 +27,10 @@
 #include &lt;boost/thread/shared_mutex.hpp&gt;
 #include "absl/strings/str_cat.h"
 
+#include "modules/routing/proto/default_routing.pb.h"
+#include "modules/routing/proto/poi.pb.h"
+#include "modules/task_manager/proto/task_manager.pb.h"
+
 #include "cyber/common/log.h"
 #include "cyber/cyber.h"
 #include "modules/dreamview/backend/data_collection_monitor/data_collection_monitor.h"
@@ -35,7 +39,6 @@
 #include "modules/dreamview/backend/perception_camera_updater/perception_camera_updater.h"
 #include "modules/dreamview/backend/sim_control/sim_control.h"
 #include "modules/dreamview/backend/simulation_world/simulation_world_service.h"
-#include "modules/routing/proto/poi.pb.h"
 
 /**
  * @namespace apollo::dreamview
@@ -113,6 +116,21 @@ class SimulationWorldUpdater {
    */
   bool LoadPOI();
 
+  /**
+   * @brief Tries to load the user-defined default routings from the txt file
+   * @return False if failed to load from file,file doesn't exist
+   * true otherwise or if it's already loaded.
+   */
+  bool LoadDefaultRoutings();
+
+  /**
+   * @brief Tries to save the points to a fixed location file
+   * @param json that contains routing name and point's coordinate x and y
+   * @return False if failed to save,
+   * true otherwise or if it's already saved.
+   */
+  bool AddDefaultRouting(const nlohmann::json &amp;json);
+
   void RegisterMessageHandlers();
 
   SimulationWorldService sim_world_service_;
@@ -127,6 +145,10 @@ class SimulationWorldUpdater {
   // End point for requesting default route
   apollo::routing::POI poi_;
 
+  // default routings
+  apollo::routing::DefaultRoutings default_routings_;
+  apollo::routing::DefaultRouting *default_routing_;
+
   // The simulation_world in wire format to be pushed to frontend, which is
   // updated by timer.
   std::string simulation_world_;
</diff>
			</file>
			<file old_path="modules\map\hdmap\hdmap_util.h" new_path="modules\map\hdmap\hdmap_util.h" added_lines="8" deleted_lines="0">
				<diff>@@ -61,6 +61,14 @@ inline std::string EndWayPointFile() {
   }
 }
 
+/**
+ * @brief get default routing file path from flags.
+ * @return default routing points file path
+ */
+inline std::string DefaultRoutingFile() {
+    return absl::StrCat(FLAGS_map_dir, "_", FLAGS_default_routing_filename);
+}
+
 /**
  * @brief create a Map ID given a string.
  * @param id a string id
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="39d67e87cb236d54d6a3c2fcf0ea031fbc7f60c2" author="changsh726">
		<msg>cyber_channel: fix typo</msg>
		<modified_files>
			<file old_path="cyber\service_discovery\specific_manager\channel_manager.cc" new_path="cyber\service_discovery\specific_manager\channel_manager.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -77,7 +77,7 @@ void ChannelManager::GetMsgType(const std::string&amp; channel_name,
   uint64_t key = common::GlobalData::RegisterChannel(channel_name);
   RolePtr writer = nullptr;
   if (!channel_writers_.Search(key, &amp;writer)) {
-    AERROR &lt;&lt; "cannot serarch writer of channel: " &lt;&lt; channel_name
+    AERROR &lt;&lt; "cannot find writer of channel: " &lt;&lt; channel_name
            &lt;&lt; " key: " &lt;&lt; key;
     return;
   }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="63c4fa326c8358bb265a87bddecfcfff305e0f1b" author="JackFu123">
		<msg>task_manager: add new routing for end-begin routing gap</msg>
		<modified_files>
			<file old_path="modules\task_manager\common\task_manager_gflags.cc" new_path="modules\task_manager\common\task_manager_gflags.cc" added_lines="0" deleted_lines="1">
				<diff>@@ -21,4 +21,3 @@ DEFINE_string(task_manager_node_name, "task_manager", "the name for this node");
 DEFINE_double(threshold_for_destination_check, 1.0,
               "meters, which is 100 feet.  This threshold is used to check if"
               "the vehicle reaches the destination");
-DEFINE_double(magnify_times_for_threshold, 2.0, "magnify times for threshold");
</diff>
			</file>
			<file old_path="modules\task_manager\common\task_manager_gflags.h" new_path="modules\task_manager\common\task_manager_gflags.h" added_lines="0" deleted_lines="1">
				<diff>@@ -21,4 +21,3 @@
 DECLARE_string(task_manager_node_name);
 
 DECLARE_double(threshold_for_destination_check);
-DECLARE_double(magnify_times_for_threshold);
</diff>
			</file>
			<file old_path="modules\task_manager\conf\task_manager.conf" new_path="modules\task_manager\conf\task_manager.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -1,3 +1,2 @@
 --flagfile=/apollo/modules/common/data/global_flagfile.txt
---threshold_for_destination_check=100.0
---amplify_times_for_threshold=2.0
\ No newline at end of file
+--threshold_for_destination_check=10.0
\ No newline at end of file
</diff>
			</file>
			<file old_path="modules\task_manager\cycle_routing_manager.cc" new_path="modules\task_manager\cycle_routing_manager.cc" added_lines="52" deleted_lines="31">
				<diff>@@ -32,52 +32,73 @@ common::Status CycleRoutingManager::Init(
     cycle_ = cycle_routing_task.cycle_num();
     auto waypoints = cycle_routing_task.routing_request().waypoint();
     waypoint_num_ = waypoints.size();
-    begin_point_ = waypoints[0].pose();
-    end_point_ = waypoints[waypoint_num_ - 1].pose();
+    begin_point_ = waypoints[0];
+    end_point_ = waypoints[waypoint_num_ - 1];
     is_allowed_to_route_ = true;
+    original_routing_request_ = cycle_routing_task.routing_request();
+    map_service_.reset(new apollo::dreamview::MapService());
 
-    AINFO &lt;&lt; "New cycle routing task: cycle " &lt;&lt; cycle_
-        &lt;&lt; ", begin point " &lt;&lt; begin_point_.x() &lt;&lt; " " &lt;&lt; begin_point_.y()
-        &lt;&lt; ", end point " &lt;&lt; end_point_.x() &lt;&lt; " " &lt;&lt; end_point_.y();
+    AINFO &lt;&lt; "New cycle routing task: cycle " &lt;&lt; cycle_ &lt;&lt; ", begin point "
+        &lt;&lt; begin_point_.pose().x() &lt;&lt; " " &lt;&lt; begin_point_.pose().y()
+        &lt;&lt; ", end point " &lt;&lt; end_point_.pose().x() &lt;&lt; " "
+        &lt;&lt; end_point_.pose().y();
 
     return common::Status::OK();
 }
 
-bool CycleRoutingManager::CheckIfReachDestination(
-        const localization::Pose &amp;pose) {
-    ADEBUG &lt;&lt; "Check if reach destination: localization_pose: "
-    &lt;&lt; pose.position().x() &lt;&lt; " " &lt;&lt; pose.position().y()
-    &lt;&lt; ", begin point " &lt;&lt; begin_point_.x() &lt;&lt; " " &lt;&lt; begin_point_.y()
-    &lt;&lt; ", end point " &lt;&lt; end_point_.x() &lt;&lt; " " &lt;&lt; end_point_.y()
-    &lt;&lt; ", threshold " &lt;&lt; FLAGS_threshold_for_destination_check
-    &lt;&lt; ", allowed_to_send_routing_request " &lt;&lt; is_allowed_to_route_;
+bool CycleRoutingManager::GetNewRouting(const localization::Pose &amp;pose,
+    routing::RoutingRequest* new_routing_request) {
+  AINFO &lt;&lt; "GetNewRouting: localization_pose: "
+  &lt;&lt; pose.position().x() &lt;&lt; " " &lt;&lt; pose.position().y()
+  &lt;&lt; ", begin point " &lt;&lt; begin_point_.pose().x()
+  &lt;&lt; " " &lt;&lt; begin_point_.pose().y()
+  &lt;&lt; ", end point " &lt;&lt; end_point_.pose().x() &lt;&lt; " " &lt;&lt; end_point_.pose().y()
+  &lt;&lt; ", threshold " &lt;&lt; FLAGS_threshold_for_destination_check
+  &lt;&lt; ", allowed_to_send_routing_request " &lt;&lt; is_allowed_to_route_;
 
-    if (!CheckPointDistanceInThreshold(
-          begin_point_,
-          pose.position(),
-          FLAGS_threshold_for_destination_check
-          * FLAGS_magnify_times_for_threshold)) {
-        is_allowed_to_route_ = true;
+  if (is_allowed_to_route_) {
+    if (CheckPointDistanceInThreshold(
+        begin_point_.pose(),
+        pose.position(),
+        FLAGS_threshold_for_destination_check)) {
+      AINFO &lt;&lt; "GetNewRouting: reach begin point";
+      new_routing_request-&gt;CopyFrom(original_routing_request_);
+      auto cur_point = new_routing_request-&gt;mutable_waypoint(0);
+      if (!map_service_-&gt;ConstructLaneWayPoint(pose.position().x(),
+          pose.position().y(), cur_point)) {
+        AINFO &lt;&lt; "GetNewRouting: construct begin lane way point fail!";
         return false;
+      }
+      --cycle_;
+      is_allowed_to_route_ = false;
+      return true;
     }
-
-    if (is_allowed_to_route_ &amp;&amp; CheckPointDistanceInThreshold(
-          pose.position(),
-          begin_point_,
-          FLAGS_threshold_for_destination_check)) {
-        is_allowed_to_route_ = false;
-        return true;
+  } else {
+    if (CheckPointDistanceInThreshold(
+        end_point_.pose(),
+        pose.position(),
+        FLAGS_threshold_for_destination_check)) {
+      AINFO &lt;&lt; "GetNewRouting: reach end point";
+      new_routing_request-&gt;clear_waypoint();
+      auto cur_point = new_routing_request-&gt;add_waypoint();
+      if (!map_service_-&gt;ConstructLaneWayPoint(pose.position().x(),
+          pose.position().y(), cur_point)) {
+        AINFO &lt;&lt; "GetNewRouting: construct end lane way point fail!";
+        return false;
+      }
+      auto next_point = new_routing_request-&gt;add_waypoint();
+      next_point-&gt;CopyFrom(begin_point_);
+      is_allowed_to_route_ = true;
+      return true;
     }
-    return false;
+  }
+
+  return false;
 }
 
 int CycleRoutingManager::GetCycle() const {
     return cycle_;
 }
 
-void CycleRoutingManager::MinusCycle() {
-    --cycle_;
-}
-
 }  // namespace task_manager
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\task_manager\cycle_routing_manager.h" new_path="modules\task_manager\cycle_routing_manager.h" added_lines="8" deleted_lines="10">
				<diff>@@ -22,6 +22,7 @@
 
 #include "modules/common/monitor_log/monitor_log_buffer.h"
 #include "modules/common/status/status.h"
+#include "modules/dreamview/backend/map/map_service.h"
 #include "modules/localization/proto/localization.pb.h"
 #include "modules/task_manager/proto/task_manager.pb.h"
 
@@ -39,10 +40,11 @@ class CycleRoutingManager {
   common::Status Init(const task_manager::CycleRoutingTask&amp; cycle_routing_task);
 
   /**
-   * @brief check if the vehicle reaches the destination
+   * @brief Get new routing if the vehicle reaches the begin/end point
    * @return false/true
    */
-  bool CheckIfReachDestination(const localization::Pose &amp;pose);
+  bool GetNewRouting(const localization::Pose &amp;pose,
+      routing::RoutingRequest* routing_request_);
 
   /**
    * @brief get remaining cycle number
@@ -50,12 +52,6 @@ class CycleRoutingManager {
    */
   int GetCycle() const;
 
-  /**
-   * @brief make cycle number minus 1
-   * @return void
-   */
-  void MinusCycle();
-
   /**
    * @brief destructor
    */
@@ -65,8 +61,10 @@ class CycleRoutingManager {
   int cycle_ = 0;
   int waypoint_num_ = 0;
   bool is_allowed_to_route_ = false;
-  apollo::common::PointENU begin_point_;
-  apollo::common::PointENU end_point_;
+  routing::LaneWaypoint begin_point_;
+  routing::LaneWaypoint end_point_;
+  std::unique_ptr&lt;apollo::dreamview::MapService&gt; map_service_;
+  routing::RoutingRequest original_routing_request_;
 };
 
 }  // namespace task_manager
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.cc" new_path="modules\task_manager\task_manager_component.cc" added_lines="5" deleted_lines="4">
				<diff>@@ -69,13 +69,14 @@ bool TaskManagerComponent::Proc(const std::shared_ptr&lt;Task&gt;&amp; task) {
     Rate rate(1.0);
 
     while (cycle_routing_manager_-&gt;GetCycle() &gt; 0) {
-      if (cycle_routing_manager_-&gt;CheckIfReachDestination(
-            localization_.pose())) {
+      if (cycle_routing_manager_-&gt;GetNewRouting(
+            localization_.pose(),
+            &amp;routing_request_)) {
         common::util::FillHeader(node_-&gt;Name(), &amp;routing_request_);
         request_writer_-&gt;Write(routing_request_);
-        AINFO &lt;&lt; "Reach destination: routing manager send a routing request"
+        AINFO &lt;&lt; "Reach begin/end point: "
+        &lt;&lt; "routing manager send a routing request. "
         &lt;&lt; "Remaining cycles: " &lt;&lt; cycle_routing_manager_-&gt;GetCycle();
-        cycle_routing_manager_-&gt;MinusCycle();
       }
       rate.Sleep();
     }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="cfb46bc7e80c8ccb74e552ee4f5086321ff31d8f" author="xiaoMrzhang">
		<msg>Perception: reactivate yolo3d camera obstacle detection (#13145)

* Perception: reactivate yolo3d camera obstacle detection

* Perception: first change in code review

* Perception: roll back point_cloud.h</msg>
		<modified_files>
			<file old_path="modules\perception\base\object_supplement.h" new_path="modules\perception\base\object_supplement.h" added_lines="1" deleted_lines="0">
				<diff>@@ -22,6 +22,7 @@
 
 #include &lt;boost/circular_buffer.hpp&gt;
 
+#include "modules/common/util/eigen_defs.h"
 #include "modules/perception/base/box.h"
 #include "modules/perception/base/object_types.h"
 #include "modules/perception/base/point_cloud.h"
</diff>
			</file>
			<file old_path="modules\perception\base\point_cloud.h" new_path="modules\perception\base\point_cloud.h" added_lines="4" deleted_lines="0">
				<diff>@@ -23,8 +23,12 @@
 
 #include "Eigen/Dense"
 
+#include "modules/common/util/eigen_defs.h"
 #include "modules/perception/base/point.h"
 
+using apollo::common::EigenVector;
+using apollo::common::EigenMap;
+
 namespace apollo {
 namespace perception {
 namespace base {
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\lane\postprocessor\denseline\denseline_lane_postprocessor.cc" new_path="modules\perception\camera\lib\lane\postprocessor\denseline\denseline_lane_postprocessor.cc" added_lines="0" deleted_lines="1">
				<diff>@@ -22,7 +22,6 @@
 #include "modules/perception/base/object_types.h"
 #include "modules/perception/camera/common/math_functions.h"
 #include "modules/perception/camera/lib/lane/common/proto/denseline.pb.h"
-#include "modules/perception/lib/utils/timer.h"
 
 namespace apollo {
 namespace perception {
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\detector\yolo\object_maintainer.h" new_path="modules\perception\camera\lib\obstacle\detector\yolo\object_maintainer.h" added_lines="2" deleted_lines="17">
				<diff>@@ -18,6 +18,7 @@
 #include &lt;map&gt;
 
 #include "modules/perception/base/object.h"
+#include "modules/perception/base/object_pool_types.h"
 
 namespace apollo {
 namespace perception {
@@ -27,23 +28,7 @@ class ObjectMaintainer {
  public:
   ObjectMaintainer() {}
   ~ObjectMaintainer() {}
-  // @brief: return true if new object added
-  bool Add(int idx, base::ObjectPtr obj) {
-    auto obj_it = assigned_index_.find(idx);
-    if (obj_it == assigned_index_.end()) {
-      assigned_index_[idx] = obj;
-      return true;
-    }
-
-    auto prev_obj = obj_it-&gt;second;
-    const auto &amp;&amp;curr_type = static_cast&lt;int&gt;(obj-&gt;sub_type);
-    const auto &amp;&amp;prev_type = static_cast&lt;int&gt;(prev_obj-&gt;sub_type);
-    if (obj-&gt;sub_type_probs[curr_type] &gt; prev_obj-&gt;sub_type_probs[prev_type]) {
-      *prev_obj = *obj;
-    }
-    return false;
-  }
-
+  bool Add(int idx, base::ObjectPtr obj);
  protected:
   std::map&lt;int, base::ObjectPtr&gt; assigned_index_;
 };
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\detector\yolo\region_output.cc" new_path="modules\perception\camera\lib\obstacle\detector\yolo\region_output.cc" added_lines="79" deleted_lines="0">
				<diff>@@ -17,6 +17,7 @@
 #include "modules/perception/camera/lib/obstacle/detector/yolo/region_output.h"
 
 #include "cyber/common/log.h"
+#include "modules/perception/camera/lib/obstacle/detector/yolo/object_maintainer.h"
 
 namespace apollo {
 namespace perception {
@@ -413,6 +414,84 @@ int get_area_id(float visible_ratios[4]) {
   return area_id;
 }
 
+const float *get_cpu_data(bool flag, const base::Blob&lt;float&gt; &amp;blob) {
+  return flag ? blob.cpu_data() : nullptr;
+}
+
+void get_objects_cpu(const YoloBlobs &amp;yolo_blobs, const cudaStream_t &amp;stream,
+                     const std::vector&lt;base::ObjectSubType&gt; &amp;types,
+                     const NMSParam &amp;nms, const yolo::ModelParam &amp;model_param,
+                     float light_vis_conf_threshold,
+                     float light_swt_conf_threshold,
+                     base::Blob&lt;bool&gt; *overlapped, base::Blob&lt;int&gt; *idx_sm,
+                     std::vector&lt;base::ObjectPtr&gt; *objects) {
+  std::map&lt;base::ObjectSubType, std::vector&lt;int&gt;&gt; indices;
+  std::map&lt;base::ObjectSubType, std::vector&lt;float&gt;&gt; conf_scores;
+  int num_kept = 0;
+  int num_classes = types.size();
+  num_kept = get_objects_gpu(yolo_blobs, stream, types, nms, model_param,
+                  light_vis_conf_threshold, light_swt_conf_threshold,
+                  overlapped, idx_sm, indices, conf_scores);
+  objects-&gt;clear();
+
+  if (num_kept == 0) {
+    return;
+  }
+
+  objects-&gt;reserve(num_kept+static_cast&lt;int&gt;(objects-&gt;size()));
+  const float *cpu_box_data = yolo_blobs.res_box_blob-&gt;cpu_data();
+
+  ObjectMaintainer maintainer;
+  for (auto it = indices.begin(); it != indices.end(); ++it) {
+    base::ObjectSubType label = it-&gt;first;
+    if (conf_scores.find(label) == conf_scores.end()) {
+      // Something bad happened if there are no predictions for current label.
+      continue;
+    }
+    const std::vector&lt;float&gt; &amp;scores = conf_scores.find(label)-&gt;second;
+    std::vector&lt;int&gt; &amp;indice = it-&gt;second;
+    for (size_t j = 0; j &lt; indice.size(); ++j) {
+      int idx = indice[j];
+      const float *bbox = cpu_box_data + idx * kBoxBlockSize;
+      if (scores[idx] &lt; model_param.confidence_threshold()) {
+        continue;
+      }
+
+      base::ObjectPtr obj = nullptr;
+      obj.reset(new base::Object);
+      obj-&gt;type = base::kSubType2TypeMap.at(label);
+      obj-&gt;sub_type = label;
+      obj-&gt;type_probs.assign(
+          static_cast&lt;int&gt;(base::ObjectType::MAX_OBJECT_TYPE), 0);
+      obj-&gt;sub_type_probs.assign(
+          static_cast&lt;int&gt;(base::ObjectSubType::MAX_OBJECT_TYPE), 0);
+      float total = 1e-5;
+      for (int k = 0; k &lt; num_classes; ++k) {
+        auto &amp;vis_type_k = types[k];
+        auto &amp;obj_type_k = base::kSubType2TypeMap.at(vis_type_k);
+        auto &amp;conf_score = conf_scores[vis_type_k][idx];
+        obj-&gt;type_probs[static_cast&lt;int&gt;(obj_type_k)] += conf_score;
+        obj-&gt;sub_type_probs[static_cast&lt;int&gt;(vis_type_k)] = conf_score;
+        total += conf_score;
+      }
+      obj-&gt;confidence = obj-&gt;type_probs[static_cast&lt;int&gt;(obj-&gt;type)];
+      for (size_t k = 0; k &lt; obj-&gt;type_probs.size(); ++k) {
+        obj-&gt;type_probs[k] /= total;
+      }
+      fill_base(obj, bbox);
+      fill_bbox3d(model_param.with_box3d(), obj, bbox + 4);
+      fill_frbox(model_param.with_frbox(), obj, bbox + 8);
+      fill_lights(model_param.with_lights(), obj, bbox + 16);
+      fill_ratios(model_param.with_ratios(), obj, bbox + 22);
+      fill_area_id(model_param.num_areas() &gt; 0, obj, bbox + 30);
+
+      if (maintainer.Add(idx, obj)) {
+        objects-&gt;push_back(obj);
+      }
+    }
+  }
+}
+
 }  // namespace camera
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\detector\yolo\region_output.cu" new_path="modules\perception\camera\lib\obstacle\detector\yolo\region_output.cu" added_lines="14" deleted_lines="193">
				<diff>@@ -388,13 +388,19 @@ const float *get_gpu_data(bool flag, const base::Blob&lt;float&gt; &amp;blob) {
   return flag ? blob.gpu_data() : nullptr;
 }
 
-void get_objects_gpu(const YoloBlobs &amp;yolo_blobs, const cudaStream_t &amp;stream,
-                     const std::vector&lt;base::ObjectSubType&gt; &amp;types,
-                     const NMSParam &amp;nms, const yolo::ModelParam &amp;model_param,
-                     float light_vis_conf_threshold,
-                     float light_swt_conf_threshold,
-                     base::Blob&lt;bool&gt; *overlapped, base::Blob&lt;int&gt; *idx_sm,
-                     std::vector&lt;base::ObjectPtr&gt; *objects) {
+int get_objects_gpu(const YoloBlobs &amp;yolo_blobs, const cudaStream_t &amp;stream,
+    const std::vector&lt;base::ObjectSubType&gt; &amp;types,
+    const NMSParam &amp;nms, const yolo::ModelParam &amp;model_param,
+    float light_vis_conf_threshold,
+    float light_swt_conf_threshold,
+    base::Blob&lt;bool&gt; *overlapped, base::Blob&lt;int&gt; *idx_sm,
+    const std::map&lt;base::ObjectSubType, std::vector&lt;int&gt;&gt; &amp;indices_cns,
+    const std::map&lt;base::ObjectSubType, std::vector&lt;float&gt;&gt; &amp;conf_scores_cns) {
+  auto&amp; indices = const_cast&lt;std::map&lt;base::ObjectSubType,
+                      std::vector&lt;int&gt;&gt;&amp; &gt;(indices_cns);
+  auto&amp; conf_scores = const_cast&lt;std::map&lt;base::ObjectSubType,
+                      std::vector&lt;float&gt;&gt;&amp; &gt;(conf_scores_cns);
+
   bool multi_scale = false;
   if (yolo_blobs.det2_obj_blob) {
     multi_scale = true;
@@ -522,9 +528,6 @@ void get_objects_gpu(const YoloBlobs &amp;yolo_blobs, const cudaStream_t &amp;stream,
   std::iota(all_indices.begin(), all_indices.end(), 0);
   std::vector&lt;int&gt; rest_indices;
 
-  std::map&lt;base::ObjectSubType, std::vector&lt;int&gt;&gt; indices;
-  std::map&lt;base::ObjectSubType, std::vector&lt;float&gt;&gt; conf_scores;
-
   int top_k = idx_sm-&gt;count();
   int num_kept = 0;
   // inter-cls NMS
@@ -545,64 +548,7 @@ void get_objects_gpu(const YoloBlobs &amp;yolo_blobs, const cudaStream_t &amp;stream,
     cudaStreamSynchronize(stream);
   }
 
-  objects-&gt;clear();
-
-  if (num_kept == 0) {
-    return;
-  }
-
-  objects-&gt;reserve(num_kept);
-  const float *cpu_box_data = yolo_blobs.res_box_blob-&gt;cpu_data();
-
-  ObjectMaintainer maintainer;
-  for (auto it = indices.begin(); it != indices.end(); ++it) {
-    base::ObjectSubType label = it-&gt;first;
-    if (conf_scores.find(label) == conf_scores.end()) {
-      // Something bad happened if there are no predictions for current label.
-      continue;
-    }
-    const std::vector&lt;float&gt; &amp;scores = conf_scores.find(label)-&gt;second;
-    std::vector&lt;int&gt; &amp;indice = it-&gt;second;
-    for (size_t j = 0; j &lt; indice.size(); ++j) {
-      int idx = indice[j];
-      const float *bbox = cpu_box_data + idx * kBoxBlockSize;
-      if (scores[idx] &lt; model_param.confidence_threshold()) {
-        continue;
-      }
-
-      base::ObjectPtr obj = nullptr;
-      obj.reset(new base::Object);
-      obj-&gt;type = base::kSubType2TypeMap.at(label);
-      obj-&gt;sub_type = label;
-      obj-&gt;type_probs.assign(
-          static_cast&lt;int&gt;(base::ObjectType::MAX_OBJECT_TYPE), 0);
-      obj-&gt;sub_type_probs.assign(
-          static_cast&lt;int&gt;(base::ObjectSubType::MAX_OBJECT_TYPE), 0);
-      float total = 1e-5;
-      for (int k = 0; k &lt; num_classes; ++k) {
-        auto &amp;vis_type_k = types[k];
-        auto &amp;obj_type_k = base::kSubType2TypeMap.at(vis_type_k);
-        auto &amp;conf_score = conf_scores[vis_type_k][idx];
-        obj-&gt;type_probs[static_cast&lt;int&gt;(obj_type_k)] += conf_score;
-        obj-&gt;sub_type_probs[static_cast&lt;int&gt;(vis_type_k)] = conf_score;
-        total += conf_score;
-      }
-      obj-&gt;confidence = obj-&gt;type_probs[static_cast&lt;int&gt;(obj-&gt;type)];
-      for (int k = 0; k &lt; obj-&gt;type_probs.size(); ++k) {
-        obj-&gt;type_probs[k] /= total;
-      }
-      fill_base(obj, bbox);
-      fill_bbox3d(model_param.with_box3d(), obj, bbox + 4);
-      fill_frbox(model_param.with_frbox(), obj, bbox + 8);
-      fill_lights(model_param.with_lights(), obj, bbox + 16);
-      fill_ratios(model_param.with_ratios(), obj, bbox + 22);
-      fill_area_id(model_param.num_areas() &gt; 0, obj, bbox + 30);
-
-      if (maintainer.Add(idx, obj)) {
-        objects-&gt;push_back(obj);
-      }
-    }
-  }
+  return num_kept;
 }
 
 void get_intersect_bbox(const NormalizedBBox &amp;bbox1,
@@ -823,131 +769,6 @@ void apply_nms_fast(const std::vector&lt;NormalizedBBox&gt; &amp;bboxes,
   }
 }
 
-void filter_bbox(const MinDims &amp;min_dims,
-                 std::vector&lt;base::ObjectPtr&gt; *objects) {
-  size_t valid_obj_idx = 0;
-  size_t total_obj_idx = 0;
-  while (total_obj_idx &lt; objects-&gt;size()) {
-    const auto &amp;obj = (*objects)[total_obj_idx];
-    if ((obj-&gt;camera_supplement.box.ymax - obj-&gt;camera_supplement.box.ymin) &gt;=
-            min_dims.min_2d_height &amp;&amp;
-        (min_dims.min_3d_height &lt;= 0 ||
-         obj-&gt;size[2] &gt;= min_dims.min_3d_height) &amp;&amp;
-        (min_dims.min_3d_width &lt;= 0 || obj-&gt;size[1] &gt;= min_dims.min_3d_width) &amp;&amp;
-        (min_dims.min_3d_length &lt;= 0 ||
-         obj-&gt;size[0] &gt;= min_dims.min_3d_length)) {
-      (*objects)[valid_obj_idx] = (*objects)[total_obj_idx];
-      ++valid_obj_idx;
-    }
-    ++total_obj_idx;
-  }
-  objects-&gt;resize(valid_obj_idx);
-}
-void recover_bbox(int roi_w, int roi_h, int offset_y,
-                  std::vector&lt;base::ObjectPtr&gt; *objects) {
-  for (auto &amp;obj : *objects) {
-    float xmin = obj-&gt;camera_supplement.box.xmin;
-    float ymin = obj-&gt;camera_supplement.box.ymin;
-    float xmax = obj-&gt;camera_supplement.box.xmax;
-    float ymax = obj-&gt;camera_supplement.box.ymax;
-    int x = xmin * roi_w;
-    int w = (xmax - xmin) * roi_w;
-    int y = ymin * roi_h + offset_y;
-    int h = (ymax - ymin) * roi_h;
-    base::RectF rect_det(x, y, w, h);
-    base::RectF rect_img(0, 0, roi_w, roi_h + offset_y);
-    base::RectF rect = rect_det &amp; rect_img;
-    obj-&gt;camera_supplement.box = rect;
-
-    double eps = 1e-2;
-
-    // Truncation assignment based on bbox positions
-    if ((ymin &lt; eps) || (ymax &gt;= 1.0 - eps)) {
-      obj-&gt;camera_supplement.truncated_vertical = 0.5;
-    } else {
-      obj-&gt;camera_supplement.truncated_vertical = 0.0;
-    }
-    if ((xmin &lt; eps) || (xmax &gt;= 1.0 - eps)) {
-      obj-&gt;camera_supplement.truncated_horizontal = 0.5;
-    } else {
-      obj-&gt;camera_supplement.truncated_horizontal = 0.0;
-    }
-
-    obj-&gt;camera_supplement.front_box.xmin *= roi_w;
-    obj-&gt;camera_supplement.front_box.ymin *= roi_h;
-    obj-&gt;camera_supplement.front_box.xmax *= roi_w;
-    obj-&gt;camera_supplement.front_box.ymax *= roi_h;
-
-    obj-&gt;camera_supplement.back_box.xmin *= roi_w;
-    obj-&gt;camera_supplement.back_box.ymin *= roi_h;
-    obj-&gt;camera_supplement.back_box.xmax *= roi_w;
-    obj-&gt;camera_supplement.back_box.ymax *= roi_h;
-
-    obj-&gt;camera_supplement.front_box.ymin += offset_y;
-    obj-&gt;camera_supplement.front_box.ymax += offset_y;
-    obj-&gt;camera_supplement.back_box.ymin += offset_y;
-    obj-&gt;camera_supplement.back_box.ymax += offset_y;
-  }
-}
-
-void fill_base(base::ObjectPtr obj, const float *bbox) {
-  obj-&gt;camera_supplement.box.xmin = bbox[0];
-  obj-&gt;camera_supplement.box.ymin = bbox[1];
-  obj-&gt;camera_supplement.box.xmax = bbox[2];
-  obj-&gt;camera_supplement.box.ymax = bbox[3];
-}
-
-void fill_bbox3d(bool with_box3d, base::ObjectPtr obj, const float *bbox) {
-  if (with_box3d) {
-    obj-&gt;camera_supplement.alpha = bbox[0];
-    obj-&gt;size[2] = bbox[1];
-    obj-&gt;size[1] = bbox[2];
-    obj-&gt;size[0] = bbox[3];
-  }
-}
-
-void fill_frbox(bool with_frbox, base::ObjectPtr obj, const float *bbox) {
-  if (with_frbox) {
-    obj-&gt;camera_supplement.front_box.xmin = bbox[0];
-    obj-&gt;camera_supplement.front_box.ymin = bbox[1];
-    obj-&gt;camera_supplement.front_box.xmax = bbox[2];
-    obj-&gt;camera_supplement.front_box.ymax = bbox[3];
-
-    obj-&gt;camera_supplement.back_box.xmin = bbox[4];
-    obj-&gt;camera_supplement.back_box.ymin = bbox[5];
-    obj-&gt;camera_supplement.back_box.xmax = bbox[6];
-    obj-&gt;camera_supplement.back_box.ymax = bbox[7];
-  }
-}
-
-void fill_lights(bool with_lights, base::ObjectPtr obj, const float *bbox) {
-  if (with_lights) {
-    obj-&gt;car_light.brake_visible = bbox[0];
-    obj-&gt;car_light.brake_switch_on = bbox[1];
-    obj-&gt;car_light.left_turn_visible = bbox[2];
-    obj-&gt;car_light.left_turn_switch_on = bbox[3];
-    obj-&gt;car_light.right_turn_visible = bbox[4];
-    obj-&gt;car_light.right_turn_switch_on = bbox[5];
-  }
-}
-
-void fill_ratios(bool with_ratios, base::ObjectPtr obj, const float *bbox) {
-  if (with_ratios) {
-    // visible ratios of face a/b/c/d
-    obj-&gt;camera_supplement.visible_ratios[0] = bbox[0];
-    obj-&gt;camera_supplement.visible_ratios[1] = bbox[1];
-    obj-&gt;camera_supplement.visible_ratios[2] = bbox[2];
-    obj-&gt;camera_supplement.visible_ratios[3] = bbox[3];
-
-    // cut off on width and length (3D)
-    obj-&gt;camera_supplement.cut_off_ratios[0] = bbox[4];
-    obj-&gt;camera_supplement.cut_off_ratios[1] = bbox[5];
-    // cut off on left and right side (2D)
-    obj-&gt;camera_supplement.cut_off_ratios[2] = bbox[6];
-    obj-&gt;camera_supplement.cut_off_ratios[3] = bbox[7];
-  }
-}
-
 void fill_area_id(bool with_flag, base::ObjectPtr obj, const float *data) {
   if (with_flag) {
     obj-&gt;camera_supplement.area_id = static_cast&lt;int&gt;(data[0]);
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\detector\yolo\region_output.h" new_path="modules\perception\camera\lib\obstacle\detector\yolo\region_output.h" added_lines="12" deleted_lines="1">
				<diff>@@ -16,6 +16,7 @@
 #pragma once
 
 #include &lt;algorithm&gt;
+#include &lt;map&gt;
 #include &lt;memory&gt;
 #include &lt;string&gt;
 #include &lt;utility&gt;
@@ -162,7 +163,17 @@ void compute_overlapped_by_idx_gpu(const int nthreads, const float *bbox_data,
                                    bool *overlapped_data,
                                    const cudaStream_t &amp;_stream);
 
-void get_objects_gpu(const YoloBlobs &amp;yolo_blobs, const cudaStream_t &amp;stream,
+
+int get_objects_gpu(
+        const YoloBlobs &amp;yolo_blobs, const cudaStream_t &amp;stream,
+        const std::vector&lt;base::ObjectSubType&gt; &amp;types,
+        const NMSParam &amp;nms, const yolo::ModelParam &amp;model_param,
+        float light_vis_conf_threshold, float light_swt_conf_threshold,
+        base::Blob&lt;bool&gt; *overlapped, base::Blob&lt;int&gt; *idx_sm,
+        const std::map&lt;base::ObjectSubType, std::vector&lt;int&gt;&gt; &amp;indices,
+        const std::map&lt;base::ObjectSubType, std::vector&lt;float&gt;&gt; &amp;conf_scores);
+
+void get_objects_cpu(const YoloBlobs &amp;yolo_blobs, const cudaStream_t &amp;stream,
                      const std::vector&lt;base::ObjectSubType&gt; &amp;types,
                      const NMSParam &amp;nms, const yolo::ModelParam &amp;model_param,
                      float light_vis_conf_threshold,
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\detector\yolo\yolo_obstacle_detector.cc" new_path="modules\perception\camera\lib\obstacle\detector\yolo\yolo_obstacle_detector.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -341,7 +341,7 @@ bool YoloObstacleDetector::Detect(const ObstacleDetectorOptions &amp;options,
   inference_-&gt;Infer();
   AINFO &lt;&lt; "Network Forward: " &lt;&lt; static_cast&lt;double&gt;(timer.Toc()) * 0.001
         &lt;&lt; "ms";
-  get_objects_gpu(yolo_blobs_, stream_, types_, nms_, yolo_param_.model_param(),
+  get_objects_cpu(yolo_blobs_, stream_, types_, nms_, yolo_param_.model_param(),
                   light_vis_conf_threshold_, light_swt_conf_threshold_,
                   overlapped_.get(), idx_sm_.get(), &amp;(frame-&gt;detected_objects));
 
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\tracker\common\kalman_filter.h" new_path="modules\perception\camera\lib\obstacle\tracker\common\kalman_filter.h" added_lines="15" deleted_lines="2">
				<diff>@@ -19,6 +19,7 @@
 #include &lt;vector&gt;
 
 #include "Eigen/Core"
+#include "modules/common/util/eigen_defs.h"
 
 namespace apollo {
 namespace perception {
@@ -62,6 +63,9 @@ class KalmanFilterConstVelocity {
 
 template &lt;std::size_t N&gt;
 class KalmanFilterConstState {
+ public:
+  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+
  public:
   typedef Eigen::Matrix&lt;double, N, N&gt; MatrixNd;
   typedef Eigen::Matrix&lt;double, N, 1&gt; VectorNd;
@@ -96,6 +100,9 @@ class KalmanFilterConstState {
 };
 
 class ExtendedKalmanFilter {
+ public:
+  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+
  public:
   ExtendedKalmanFilter() : inited_(false) {}
   void Init();
@@ -128,6 +135,8 @@ class ExtendedKalmanFilter {
 };
 
 class FirstOrderRCLowPassFilter {
+ public:
+  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
  public:
   FirstOrderRCLowPassFilter() : alpha_(0), inited_(false) {}
   void SetAlpha(float alpha);
@@ -141,6 +150,8 @@ class FirstOrderRCLowPassFilter {
 };
 
 class MaxNMeanFilter {
+ public:
+  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
  public:
   MaxNMeanFilter() : index_(0), window_(1) {}
   void SetWindow(int window);
@@ -152,12 +163,14 @@ class MaxNMeanFilter {
   Eigen::VectorXd get_state() const;
 
  private:
-  std::vector&lt;Eigen::VectorXd&gt; measures_;
+  apollo::common::EigenVector&lt;Eigen::VectorXd&gt; measures_;
   int index_;
   int window_;
 };
 
 class MeanFilter {
+ public:
+  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
  public:
   MeanFilter() : index_(0), window_(1) {}
   void SetWindow(int window);
@@ -169,7 +182,7 @@ class MeanFilter {
   int size() const { return static_cast&lt;int&gt;(measures_.size()); }
 
  private:
-  std::vector&lt;Eigen::VectorXd&gt; measures_;
+  apollo::common::EigenVector&lt;Eigen::VectorXd&gt; measures_;
   Eigen::VectorXd state_;
   Eigen::MatrixXd variance_;
   int index_;
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\tracker\omt\frame_list.h" new_path="modules\perception\camera\lib\obstacle\tracker\omt\frame_list.h" added_lines="5" deleted_lines="2">
				<diff>@@ -28,7 +28,8 @@ namespace apollo {
 namespace perception {
 namespace camera {
 
-struct PatchIndicator {
+struct alignas(16) PatchIndicator {
+  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
   PatchIndicator() {
     frame_id = patch_id = -1;
     sensor_name = "";
@@ -59,8 +60,9 @@ struct PatchIndicator {
   std::string sensor_name;
 };
 
-struct SimilarMap {
+struct alignas(16) SimilarMap {
  public:
+  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
   bool Init(int dim, int gpu_id = 0, int init_size = 128) {
     if (dim == 0) {
       return false;
@@ -102,6 +104,7 @@ struct SimilarMap {
 
 class FrameList {
  public:
+  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
   FrameList() { Init(1); }
 
   bool Init(int cap) {
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\tracker\omt\obstacle_reference.cc" new_path="modules\perception\camera\lib\obstacle\tracker\omt\obstacle_reference.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -53,7 +53,7 @@ void ObstacleReference::Init(const omt::ReferenceParam &amp;ref_param, float width,
 }
 
 void ObstacleReference::UpdateReference(const CameraFrame *frame,
-                                        const std::vector&lt;Target&gt; &amp;targets) {
+                                        const EigenVector&lt;Target&gt; &amp;targets) {
   std::string sensor = frame-&gt;data_provider-&gt;sensor_name();
   SyncGroundEstimator(sensor, frame-&gt;camera_k_matrix,
                       static_cast&lt;int&gt;(img_width_),
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\tracker\omt\obstacle_reference.h" new_path="modules\perception\camera\lib\obstacle\tracker\omt\obstacle_reference.h" added_lines="4" deleted_lines="1">
				<diff>@@ -26,6 +26,8 @@
 #include "modules/perception/camera/lib/obstacle/tracker/omt/proto/omt.pb.h"
 #include "modules/perception/camera/lib/obstacle/tracker/omt/target.h"
 
+using apollo::common::EigenVector;
+
 namespace apollo {
 namespace perception {
 namespace camera {
@@ -38,9 +40,10 @@ struct Reference {
 
 class ObstacleReference {
  public:
+  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
   void Init(const omt::ReferenceParam &amp;ref_param, float width, float height);
   void UpdateReference(const CameraFrame *frame,
-                       const std::vector&lt;Target&gt; &amp;targets);
+                       const EigenVector&lt;Target&gt; &amp;targets);
   void CorrectSize(CameraFrame *frame);
 
  private:
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\tracker\omt\omt_obstacle_tracker.h" new_path="modules\perception\camera\lib\obstacle\tracker\omt\omt_obstacle_tracker.h" added_lines="5" deleted_lines="2">
				<diff>@@ -19,6 +19,7 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
+#include "modules/common/util/eigen_defs.h"
 #include "modules/perception/camera/common/object_template_manager.h"
 #include "modules/perception/camera/lib/interface/base_obstacle_tracker.h"
 #include "modules/perception/camera/lib/obstacle/tracker/common/similar.h"
@@ -30,7 +31,8 @@
 namespace apollo {
 namespace perception {
 namespace camera {
-struct Hypothesis {
+struct alignas(16) Hypothesis {
+  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
   int target;
   int object;
   float score;
@@ -59,6 +61,7 @@ class OMTObstacleTracker : public BaseObstacleTracker {
   //                         width_(0.0f), height_(0.0f),
   //                         BaseObstacleTracker() {
   //  }
+  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
   OMTObstacleTracker() : BaseObstacleTracker() {}
 
   ~OMTObstacleTracker() override = default;
@@ -113,7 +116,7 @@ class OMTObstacleTracker : public BaseObstacleTracker {
   FrameList frame_list_;
   SimilarMap similar_map_;
   std::shared_ptr&lt;BaseSimilar&gt; similar_ = nullptr;
-  std::vector&lt;Target&gt; targets_;
+  apollo::common::EigenVector&lt;Target&gt; targets_;
   std::vector&lt;bool&gt; used_;
   ObstacleReference reference_;
   std::vector&lt;std::vector&lt;float&gt;&gt; kTypeAssociatedCost_;
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\tracker\omt\target.cc" new_path="modules\perception\camera\lib\obstacle\tracker\omt\target.cc" added_lines="19" deleted_lines="16">
				<diff>@@ -34,7 +34,7 @@ void Target::Clear() { tracked_objects.clear(); }
 
 TrackObjectPtr Target::operator[](int index) const { return get_object(index); }
 TrackObjectPtr Target::get_object(int index) const {
-  CHECK_GT(tracked_objects.size(), 0);
+  CHECK_GT(static_cast&lt;int&gt;(tracked_objects.size()), 0);
   CHECK_LT(index, static_cast&lt;int&gt;(tracked_objects.size()));
   CHECK_GE(index, -static_cast&lt;int&gt;(tracked_objects.size()));
   return tracked_objects[(index + tracked_objects.size()) %
@@ -297,7 +297,7 @@ void Target::Update3D(CameraFrame *frame) {
     }
 
     // check history states
-    history_world_states_.push_back(*object);
+    history_world_states_.push_back(object);
     ClappingTrackVelocity(object);
   }
 
@@ -397,20 +397,23 @@ bool Target::CheckStatic() {
       std::min(static_cast&lt;int&gt;(history_world_states_.size()),
                target_param_.min_cached_velocity_size());
   // calculate average velocity
-  base::Object tmp_obj_vel_avg;
-  tmp_obj_vel_avg.velocity = Eigen::Vector3f(0, 0, 0);
+  std::shared_ptr&lt;base::Object&gt; tmp_obj_vel_avg = nullptr;
+  tmp_obj_vel_avg.reset(new base::Object);
+  tmp_obj_vel_avg-&gt;velocity = Eigen::Vector3f(0, 0, 0);
   tmp_obj_vel_avg =
       std::accumulate(history_world_states_.begin() +
                           history_world_states_.size() - min_vel_size,
                       history_world_states_.end(), tmp_obj_vel_avg,
-                      [](const base::Object &amp;obj1, const base::Object &amp;obj2) {
-                        base::Object ret_obj;
-                        ret_obj.velocity = obj1.velocity + obj2.velocity;
+                      [](const std::shared_ptr&lt;base::Object&gt; obj1,
+                         const std::shared_ptr&lt;base::Object&gt; obj2) {
+                        std::shared_ptr&lt;base::Object&gt; ret_obj = nullptr;
+                        ret_obj.reset(new base::Object);
+                        ret_obj-&gt;velocity = obj1-&gt;velocity + obj2-&gt;velocity;
                         return ret_obj;
                       });
-  tmp_obj_vel_avg.velocity /= static_cast&lt;float&gt;(min_vel_size);
-  double speed_avg = tmp_obj_vel_avg.velocity.head(2).norm();
-  const auto &amp;obj_type = history_world_states_.back().type;
+  tmp_obj_vel_avg-&gt;velocity /= static_cast&lt;float&gt;(min_vel_size);
+  double speed_avg = tmp_obj_vel_avg-&gt;velocity.head(2).norm();
+  const auto &amp;obj_type = history_world_states_.back()-&gt;type;
   // check speed by type
   if (obj_type == base::ObjectType::PEDESTRIAN) {
     small_speed = speed_avg &lt; target_param_.static_speed_threshold_ped();
@@ -440,11 +443,11 @@ bool Target::CheckStatic() {
             static_cast&lt;int&gt;(history_world_states_.size()) &amp;&amp;
         end_idx - target_param_.calc_avg_position_window_size() + 1 &gt;= 0) {
       for (int i = 0; i &lt; target_param_.calc_avg_position_window_size(); ++i) {
-        start_position += history_world_states_[start_idx + i].center;
-        end_position += history_world_states_[end_idx - i].center;
+        start_position += history_world_states_[start_idx + i]-&gt;center;
+        end_position += history_world_states_[end_idx - i]-&gt;center;
       }
-      double time_diff = history_world_states_[end_idx].latest_tracked_time -
-                         history_world_states_[start_idx].latest_tracked_time;
+      double time_diff = history_world_states_[end_idx]-&gt;latest_tracked_time -
+                         history_world_states_[start_idx]-&gt;latest_tracked_time;
       // do not consider moved distance when time_diff is small
       if (std::fabs(time_diff) &gt; 1e-3) {
         start_position /= target_param_.calc_avg_position_window_size();
@@ -469,8 +472,8 @@ bool Target::CheckStatic() {
   std::transform(history_world_states_.begin() + history_world_states_.size() -
                      min_vel_size,
                  history_world_states_.end(), theta_vec.begin(),
-                 [](const base::Object &amp;obj) -&gt; double {
-                   return std::atan2(obj.velocity[1], obj.velocity[0]);
+                 [](const std::shared_ptr&lt;base::Object&gt; obj) -&gt; double {
+                   return std::atan2(obj-&gt;velocity[1], obj-&gt;velocity[0]);
                  });
   double mean = 0.0;
   double var = 0.0;
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\tracker\omt\target.h" new_path="modules\perception\camera\lib\obstacle\tracker\omt\target.h" added_lines="4" deleted_lines="2">
				<diff>@@ -15,6 +15,7 @@
  *****************************************************************************/
 #pragma once
 
+#include &lt;memory&gt;
 #include &lt;vector&gt;
 
 #include &lt;boost/circular_buffer.hpp&gt;
@@ -30,8 +31,9 @@ namespace apollo {
 namespace perception {
 namespace camera {
 
-struct Target {
+struct alignas(16) Target {
  public:
+  // EIGEN_MAKE_ALIGNED_OPERATOR_NEW
   explicit Target(const omt::TargetParam &amp;param);
   void Init(const omt::TargetParam &amp;param);
   void Add(TrackObjectPtr object);
@@ -88,7 +90,7 @@ struct Target {
   void ClappingTrackVelocity(const base::ObjectPtr &amp;obj);
   bool CheckStatic();
 
-  boost::circular_buffer&lt;base::Object&gt; history_world_states_;
+  boost::circular_buffer&lt;std::shared_ptr&lt;base::Object&gt;&gt; history_world_states_;
 
  protected:
   ObjectTemplateManager *object_template_manager_ = nullptr;
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\tracker\omt\track_object.h" new_path="modules\perception\camera\lib\obstacle\tracker\omt\track_object.h" added_lines="2" deleted_lines="1">
				<diff>@@ -24,7 +24,8 @@
 namespace apollo {
 namespace perception {
 namespace camera {
-struct TrackObject {
+struct alignas(16) TrackObject {
+  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
   PatchIndicator indicator;
   double timestamp;
   base::BBox2DF projected_box;
</diff>
			</file>
			<file old_path="modules\perception\camera\tools\offline\colormap.h" new_path="modules\perception\camera\tools\offline\colormap.h" added_lines="2" deleted_lines="0">
				<diff>@@ -15,6 +15,8 @@
  *****************************************************************************/
 #pragma once
 
+#include &lt;opencv2/highgui/highgui_c.h&gt;
+#include &lt;opencv2/imgproc/imgproc.hpp&gt;
 #include &lt;opencv2/opencv.hpp&gt;
 
 namespace apollo {
</diff>
			</file>
			<file old_path="modules\perception\camera\tools\offline\offline_obstacle_pipeline.cc" new_path="modules\perception\camera\tools\offline\offline_obstacle_pipeline.cc" added_lines="9" deleted_lines="7">
				<diff>@@ -14,8 +14,12 @@
  * limitations under the License.
  *****************************************************************************/
 
+
 #include &lt;fstream&gt;
 #include &lt;iomanip&gt;
+#include &lt;opencv2/highgui/highgui_c.h&gt;
+#include &lt;opencv2/highgui/highgui.hpp&gt;
+#include &lt;opencv2/imgproc/imgproc.hpp&gt;
 #include &lt;opencv2/opencv.hpp&gt;
 
 #include "absl/strings/str_split.h"
@@ -27,9 +31,7 @@
 #include "modules/perception/camera/lib/feature_extractor/tfe/external_feature_extractor.h"
 #include "modules/perception/camera/lib/feature_extractor/tfe/project_feature.h"
 #include "modules/perception/camera/lib/feature_extractor/tfe/tracking_feat_extractor.h"
-#include "modules/perception/camera/lib/lane/detector/darkSCNN/darkSCNN_lane_detector.h"
 #include "modules/perception/camera/lib/lane/detector/denseline/denseline_lane_detector.h"
-#include "modules/perception/camera/lib/lane/postprocessor/darkSCNN/darkSCNN_lane_postprocessor.h"
 #include "modules/perception/camera/lib/lane/postprocessor/denseline/denseline_lane_postprocessor.h"
 #include "modules/perception/camera/lib/obstacle/detector/yolo/yolo_obstacle_detector.h"
 #include "modules/perception/camera/lib/obstacle/postprocessor/location_refiner/location_refiner_obstacle_postprocessor.h"
@@ -81,8 +83,8 @@ REGISTER_LANE_POSTPROCESSOR(DenselineLanePostprocessor);
 REGISTER_LANE_DETECTOR(DenselineLaneDetector);
 REGISTER_CALIBRATOR(LaneLineCalibrator);
 REGISTER_CALIBRATION_SERVICE(OnlineCalibrationService);
-REGISTER_LANE_DETECTOR(DarkSCNNLaneDetector);
-REGISTER_LANE_POSTPROCESSOR(DarkSCNNLanePostprocessor);
+// REGISTER_LANE_DETECTOR(DarkSCNNLaneDetector);
+// REGISTER_LANE_POSTPROCESSOR(DarkSCNNLanePostprocessor);
 
 static const float kDefaultPitchAngle = 0.0f;
 static const float kDefaultCameraHeight = 1.5f;
@@ -229,13 +231,13 @@ int work() {
     std::string image_path = FLAGS_image_root + image_name + FLAGS_image_ext;
     cv::Mat image;
     if (FLAGS_image_color == "gray") {
-      image = cv::imread(image_path, CV_LOAD_IMAGE_GRAYSCALE);
+      image = cv::imread(image_path, cv::IMREAD_GRAYSCALE);
       cv::cvtColor(image, image, CV_GRAY2RGB);
     } else if (FLAGS_image_color == "rgb") {
-      image = cv::imread(image_path, cv::IMAGE_COLOR);
+      image = cv::imread(image_path, cv::IMREAD_COLOR);
       cv::cvtColor(image, image, CV_BGR2RGB);
     } else if (FLAGS_image_color == "bgr") {
-      image = cv::imread(image_path, cv::IMAGE_COLOR);
+      image = cv::imread(image_path, cv::IMREAD_COLOR);
     } else {
       AERROR &lt;&lt; "Invalid color: " &lt;&lt; FLAGS_image_color;
     }
</diff>
			</file>
			<file old_path="modules\perception\camera\tools\offline\visualizer.cc" new_path="modules\perception\camera\tools\offline\visualizer.cc" added_lines="8" deleted_lines="8">
				<diff>@@ -111,8 +111,8 @@ bool Visualizer::Init(const std::vector&lt;std::string&gt; &amp;camera_names,
 bool Visualizer::Init_all_info_single_camera(
     const std::vector&lt;std::string&gt; &amp;camera_names,
     const std::string &amp;visual_camera,
-    const std::map&lt;std::string, Eigen::Matrix3f&gt; &amp;intrinsic_map,
-    const std::map&lt;std::string, Eigen::Matrix4d&gt; &amp;extrinsic_map,
+    const EigenMap&lt;std::string, Eigen::Matrix3f&gt; &amp;intrinsic_map,
+    const EigenMap&lt;std::string, Eigen::Matrix4d&gt; &amp;extrinsic_map,
     const Eigen::Matrix4d &amp;ex_lidar2imu, const double pitch_adj_degree,
     const double yaw_adj_degree, const double roll_adj_degree,
     const int image_height, const int image_width) {
@@ -1459,12 +1459,12 @@ void Visualizer::ShowResult_all_info_single_camera(
             bigimg(cv::Rect(0, small_h_, small_w_, small_h_)));
         world_image_.copyTo(
             bigimg(cv::Rect(small_w_, 0, wide_pixel_, world_h_)));
-        cv::namedWindow("Apollo Visualizer", CV_WINDOW_NORMAL);
-        cv::setWindowProperty("Apollo Visualizer", CV_WND_PROP_FULLSCREEN,
-                              CV_WINDOW_FULLSCREEN);
-        cv::imshow("Apollo Visualizer", bigimg);
-        int key = cvWaitKey(30);
-        key_handler(camera_name, key);
+        // cv::namedWindow("Apollo Visualizer", CV_WINDOW_NORMAL);
+        // cv::setWindowProperty("Apollo Visualizer", CV_WND_PROP_FULLSCREEN,
+        //                       CV_WINDOW_FULLSCREEN);
+        // cv::imshow("Apollo Visualizer", bigimg);
+        // int key = cvWaitKey(30);
+        // key_handler(camera_name, key);
 
         // output visualization panel
         if (write_out_img_) {
</diff>
			</file>
			<file old_path="modules\perception\camera\tools\offline\visualizer.h" new_path="modules\perception\camera\tools\offline\visualizer.h" added_lines="11" deleted_lines="6">
				<diff>@@ -19,14 +19,19 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
+#include &lt;opencv2/highgui/highgui.hpp&gt;
+#include &lt;opencv2/imgproc/imgproc.hpp&gt;
 #include &lt;opencv2/opencv.hpp&gt;
 
+#include "modules/common/util/eigen_defs.h"
 #include "modules/perception/camera/app/cipv_camera.h"
 #include "modules/perception/camera/common/camera_frame.h"
 #include "modules/perception/camera/common/util.h"
 #include "modules/perception/camera/tools/offline/transform_server.h"
 #include "modules/perception/proto/motion_service.pb.h"
 
+using apollo::common::EigenMap;
+
 namespace apollo {
 namespace perception {
 namespace camera {
@@ -41,8 +46,8 @@ class Visualizer {
   bool Init_all_info_single_camera(
       const std::vector&lt;std::string&gt; &amp;camera_names,
       const std::string &amp;visual_camera,
-      const std::map&lt;std::string, Eigen::Matrix3f&gt; &amp;intrinsic_map,
-      const std::map&lt;std::string, Eigen::Matrix4d&gt; &amp;extrinsic_map,
+      const EigenMap&lt;std::string, Eigen::Matrix3f&gt; &amp;intrinsic_map,
+      const EigenMap&lt;std::string, Eigen::Matrix4d&gt; &amp;extrinsic_map,
       const Eigen::Matrix4d &amp;ex_lidar2imu, const double pitch_adj,
       const double yaw_adj, const double roll_adj, const int image_height,
       const int image_width);
@@ -148,10 +153,10 @@ class Visualizer {
   std::vector&lt;std::string&gt; camera_names_;
   std::string visual_camera_ = "front_6mm";
   // map for store params
-  std::map&lt;std::string, Eigen::Matrix3f&gt; intrinsic_map_;
-  std::map&lt;std::string, Eigen::Matrix4d&gt; extrinsic_map_;
+  EigenMap&lt;std::string, Eigen::Matrix3f&gt; intrinsic_map_;
+  EigenMap&lt;std::string, Eigen::Matrix4d&gt; extrinsic_map_;
   Eigen::Matrix4d ex_lidar2imu_;
-  std::map&lt;std::string, Eigen::Matrix4d&gt; ex_camera2lidar_;
+  EigenMap&lt;std::string, Eigen::Matrix4d&gt; ex_camera2lidar_;
   Eigen::Matrix4d ex_camera2imu_;
   Eigen::Matrix4d ex_imu2camera_;
   Eigen::Matrix4d ex_car2camera_;
@@ -160,7 +165,7 @@ class Visualizer {
   Eigen::Matrix4d adjusted_camera2car_ = Eigen::Matrix4d::Identity();
 
   Eigen::Matrix4d projection_matrix_;
-  std::map&lt;std::string, Eigen::Matrix3d&gt; K_;
+  EigenMap&lt;std::string, Eigen::Matrix3d&gt; K_;
 
   // Visualization related variables
   bool use_class_color_ = true;
</diff>
			</file>
			<file old_path="modules\perception\inference\onnx\libtorch_obstacle_detector.cc" new_path="modules\perception\inference\onnx\libtorch_obstacle_detector.cc" added_lines="97" deleted_lines="63">
				<diff>@@ -16,84 +16,118 @@
 
 #include "modules/perception/inference/onnx/libtorch_obstacle_detector.h"
 
-#include &lt;utility&gt;
-#include &lt;vector&gt;
-#include &lt;omp.h&gt;
-
 #include "cyber/common/log.h"
-#include "modules/perception/common/perception_gflags.h"
 
 namespace apollo {
 namespace perception {
 namespace inference {
 
-LibtorchObstacleDetection::LibtorchObstacleDetection() : device_(torch::kCPU) {
-  LoadModel();
-}
+using apollo::perception::base::Blob;
 
-bool LibtorchObstacleDetection::Evaluate(
-  const std::vector&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt;&amp; imageFrame) {
-  // Sanity checks.
-  omp_set_num_threads(1);
-  if (imageFrame.size() == 0) {
-    AERROR &lt;&lt; "Got no channel in image frame!";
-    return false;
-  }
-  if (imageFrame[0].size() == 0) {
-    AERROR &lt;&lt; "Got no image frame in channel 0!";
-    return false;
-  }
-  if (imageFrame[0].size() != 369664) {
-    AERROR &lt;&lt; "imageFrame[0].size() = " &lt;&lt; imageFrame[0].size() &lt;&lt; ", skiping!";
-    return false;
-  }
-  // image imput size is 608 * 608 = 369664
-  torch::Tensor image_tensor = torch::empty(1 * 3 * 608 * 608);
-  float* data = image_tensor.data_ptr&lt;float&gt;();
-
-  for (const auto&amp; channel : imageFrame) {
-    for (const auto&amp; i : channel) {
-      for (const auto&amp; j : i) {
-        *data++ = static_cast&lt;float&gt;(j) / 255.0;
-      }
-    }
+ObstacleDetector::ObstacleDetector(const std::string &amp;net_file,
+                                   const std::string &amp;model_file,
+                                   const std::vector&lt;std::string&gt; &amp;outputs):
+                                   net_file_(net_file),
+                                   model_file_(model_file),
+                                   output_names_(outputs) {}
+
+bool ObstacleDetector::Init(const std::map&lt;std::string,
+                            std::vector&lt;int&gt;&gt; &amp;shapes) {
+  if (gpu_id_ &gt;= 0) {
+    device_type_ = torch::kCUDA;
+    device_id_ = gpu_id_;
+  } else {
+    device_type_ = torch::kCPU;
   }
 
-  torch::Tensor torch_input = torch::from_blob(image_tensor.data_ptr&lt;float&gt;(),
-                                               {1, 3, 608, 608});
+  // Init net
+  torch::Device device(device_type_, device_id_);
+  net_ = torch::jit::load(model_file_, device);
+  net_.eval();
+
+  // run a fake inference at init time as first inference is relative slow
+  torch::Tensor input_feature_tensor = torch::zeros({1, 3, 640, 960});
+  std::array&lt;float, 2&gt; down_ratio{8.0f, 8.0f};
+  torch::Tensor tensor_downratio = torch::from_blob(down_ratio.data(), {1, 2});
+  std::array&lt;float, 9&gt; K{1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f};
+  torch::Tensor tensor_K = torch::from_blob(K.data(), {1, 3, 3});
+
   std::vector&lt;torch::jit::IValue&gt; torch_inputs;
-  torch_inputs.push_back(torch_input.to(device_));
-
-  auto start_time = std::chrono::system_clock::now();
-  at::Tensor torch_output_tensor = torch_model_.forward(torch_inputs).toTensor()
-                                               .to(torch::kCPU);
-
-  auto end_time = std::chrono::system_clock::now();
-  std::chrono::duration&lt;double&gt; diff = end_time - start_time;
-  AINFO &lt;&lt; "LibtorchDetection used time: " &lt;&lt; diff.count() * 1000 &lt;&lt; " ms.";
-  auto torch_output = torch_output_tensor.accessor&lt;float, 2&gt;();
-
-  // majority vote with 4 channels
-  float neg_score = torch_output[0][0] + torch_output[1][0] +
-                    torch_output[2][0] + torch_output[3][0];
-  float pos_score = torch_output[0][1] + torch_output[1][1] +
-                    torch_output[2][1] + torch_output[3][1];
-  ADEBUG &lt;&lt; "neg_score = " &lt;&lt; neg_score &lt;&lt; ", pos_score = " &lt;&lt; pos_score;
-  if (neg_score &lt; pos_score) {
-    return true;
-  } else {
-    return false;
+  // torch_inputs.push_back(std::make_tuple(input_feature_tensor.to(device),
+  //                       tensor_downratio.to(device)));
+  torch_inputs.push_back(input_feature_tensor.to(device));
+  torch_inputs.push_back(std::make_tuple(tensor_K.to(device),
+                                         tensor_downratio.to(device)));
+  auto torch_output_tensor =
+      net_.forward(torch_inputs).toTensor();
+
+  for (const auto&amp; name : output_names_) {
+    auto blob = std::make_shared&lt;Blob&lt;float&gt;&gt;(2, 6, 1, 1);
+    blobs_.emplace(name, blob);
+  }
+
+  for (const auto&amp; name : input_names_) {
+    auto iter = shapes.find(name);
+    if (iter != shapes.end()) {
+      auto blob = std::make_shared&lt;Blob&lt;float&gt;&gt;(iter-&gt;second);
+      blobs_.emplace(name, blob);
+    }
   }
   return true;
 }
 
-void LibtorchObstacleDetection::LoadModel() {
-  if (torch::cuda::is_available()) {
-    AINFO &lt;&lt; "CUDA is available";
-    device_ = torch::Device(torch::kCUDA);
+ObstacleDetector::ObstacleDetector(const std::string &amp;net_file,
+                   const std::string &amp;model_file,
+                   const std::vector&lt;std::string&gt; &amp;outputs,
+                   const std::vector&lt;std::string&gt; &amp;inputs):
+                   net_file_(net_file), model_file_(model_file),
+                   output_names_(outputs), input_names_(inputs) {}
+
+std::shared_ptr&lt;Blob&lt;float&gt;&gt; ObstacleDetector::get_blob(
+    const std::string &amp;name) {
+  auto iter = blobs_.find(name);
+  if (iter == blobs_.end()) {
+    return nullptr;
   }
-  torch::set_num_threads(1);
-  torch_model_ = torch::jit::load(FLAGS_torch_detector_model, device_);
+  return iter-&gt;second;
+}
+
+void ObstacleDetector::Infer() {
+  torch::Device device(device_type_, device_id_);
+  auto blob = blobs_[input_names_[0]];
+  auto input_K = blobs_[input_names_[1]];
+  auto input_ratio = blobs_[input_names_[2]];
+
+  torch::Tensor tensor_image = torch::from_blob(
+                              blob-&gt;data()-&gt;mutable_gpu_data(),
+                              {blob-&gt;shape(0), blob-&gt;shape(1), blob-&gt;shape(2),
+                              blob-&gt;shape(3)}, torch::kFloat32);
+  torch::Tensor tensor_K = torch::from_blob(
+                    input_K-&gt;data()-&gt;mutable_cpu_data(),
+                    {input_K-&gt;shape(0), input_K-&gt;shape(1), input_K-&gt;shape(2)},
+                    torch::kFloat32);
+  torch::Tensor tensor_ratio = torch::from_blob(
+                    input_ratio-&gt;data()-&gt;mutable_cpu_data(),
+                    {input_ratio-&gt;shape(0), input_ratio-&gt;shape(1)},
+                    torch::kFloat32);
+
+  std::vector&lt;torch::jit::IValue&gt; torch_inputs;
+  tensor_image = tensor_image.to(device);
+  tensor_image = tensor_image.permute({0, 3, 1, 2}).contiguous();
+
+  AINFO &lt;&lt; tensor_image[0][0].sizes();
+  tensor_image[0][0] = tensor_image[0][0].div_(58.395);
+  tensor_image[0][1] = tensor_image[0][1].div_(57.12);
+  tensor_image[0][2] = tensor_image[0][2].div_(57.375);
+  AINFO &lt;&lt; tensor_K[0][0];
+
+  torch_inputs.push_back(tensor_image);
+  torch_inputs.push_back(std::make_tuple(tensor_K.to(device),
+                                         tensor_ratio.to(device)));
+
+  AINFO &lt;&lt; "Start to do inference";
+  auto outputs = net_.forward(torch_inputs).toTensor();
+  AINFO &lt;&lt; "Finished inference";
 }
 
 }  // namespace inference
</diff>
			</file>
			<file old_path="modules\perception\inference\onnx\libtorch_obstacle_detector.h" new_path="modules\perception\inference\onnx\libtorch_obstacle_detector.h" added_lines="33" deleted_lines="11">
				<diff>@@ -13,32 +13,54 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *****************************************************************************/
+
 #pragma once
 
+#include &lt;map&gt;
+#include &lt;memory&gt;
+#include &lt;string&gt;
+#include &lt;utility&gt;
 #include &lt;vector&gt;
+#include &lt;torch/script.h&gt;
+#include &lt;torch/torch.h&gt;
 
-#include "torch/script.h"
-#include "torch/torch.h"
+#include "modules/perception/inference/inference.h"
 
 namespace apollo {
 namespace perception {
 namespace inference {
 
-class LibtorchObstacleDetection {
+using BlobPtr = std::shared_ptr&lt;apollo::perception::base::Blob&lt;float&gt;&gt;;
+
+class ObstacleDetector : public Inference {
  public:
-  LibtorchObstacleDetection();
+  ObstacleDetector(const std::string &amp;net_file, const std::string &amp;model_file,
+           const std::vector&lt;std::string&gt; &amp;outputs);
 
-  ~LibtorchObstacleDetection() = default;
+  ObstacleDetector(const std::string &amp;net_file, const std::string &amp;model_file,
+           const std::vector&lt;std::string&gt; &amp;outputs,
+           const std::vector&lt;std::string&gt; &amp;inputs);
 
-  bool Evaluate(
-    const std::vector&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt;&amp; imageFrame);
+  virtual ~ObstacleDetector() {}
 
- private:
-  void LoadModel();
+  bool Init(const std::map&lt;std::string, std::vector&lt;int&gt;&gt; &amp;shapes) override;
+
+  void Infer() override;
+  BlobPtr get_blob(const std::string &amp;name) override;
+
+ protected:
+  bool shape(const std::string &amp;name, std::vector&lt;int&gt; *res);
+  torch::jit::script::Module net_;
 
  private:
-  torch::jit::script::Module torch_model_;
-  torch::Device device_;
+  std::string net_file_;
+  std::string model_file_;
+  std::vector&lt;std::string&gt; output_names_;
+  std::vector&lt;std::string&gt; input_names_;
+  BlobMap blobs_;
+
+  torch::DeviceType device_type_;
+  int device_id_ = 0;
 };
 
 }  // namespace inference
</diff>
			</file>
			<file old_path="modules\perception\inference\onnx\onnx_obstacle_detector.cc" new_path="modules\perception\inference\onnx\onnx_obstacle_detector.cc" added_lines="36" deleted_lines="245">
				<diff>@@ -16,6 +16,7 @@
 
 #include "modules/perception/inference/onnx/onnx_obstacle_detector.h"
 
+#include &lt;cuda_runtime_api.h&gt;
 #include "cyber/common/log.h"
 
 namespace apollo {
@@ -35,52 +36,15 @@ inline void GPUAssert(cudaError_t code, const char* file, int line,
   }
 }
 
-// Logger for TensorRT info/warning/errors
-class Logger : public nvinfer1::ILogger {
- public:
-  explicit Logger(Severity severity = Severity::kWARNING)
-      : reportable_severity(severity) {}
-
-  void log(Severity severity, const char* msg) override {
-    // suppress messages with severity enum value greater than the reportable
-    if (severity &gt; reportable_severity) return;
-
-    switch (severity) {
-      case Severity::kINTERNAL_ERROR:
-        std::cerr &lt;&lt; "INTERNAL_ERROR: ";
-        break;
-      case Severity::kERROR:
-        std::cerr &lt;&lt; "ERROR: ";
-        break;
-      case Severity::kWARNING:
-        std::cerr &lt;&lt; "WARNING: ";
-        break;
-      case Severity::kINFO:
-        std::cerr &lt;&lt; "INFO: ";
-        break;
-      default:
-        std::cerr &lt;&lt; "UNKNOWN: ";
-        break;
-    }
-    std::cerr &lt;&lt; msg &lt;&lt; std::endl;
-  }
-
-  Severity reportable_severity;
-};
-
-Logger g_logger_;
-
 OnnxObstacleDetector::OnnxObstacleDetector(
   const std::string &amp;model_file,
-  int num_classes,
-  const std::string &amp;input_image_file,
-  const std::string &amp;input_name_file,
-  const std::string &amp;prediction_image_path)
+  const float score_threshold,
+  const std::vector&lt;std::string&gt; &amp;outputs,
+  const std::vector&lt;std::string&gt; &amp;inputs)
   : model_file_(model_file),
-    num_classes_(num_classes),
-    image_path_(input_image_file),
-    names_file_path_(input_name_file),
-    prediction_image_path_(prediction_image_path) {}
+    score_threshold_(score_threshold),
+    output_names_(outputs),
+    input_names_(inputs) {}
 
 OnnxObstacleDetector::OnnxObstacleDetector(
   const std::string &amp;model_file,
@@ -92,19 +56,19 @@ OnnxObstacleDetector::~OnnxObstacleDetector() {}
 
 void OnnxObstacleDetector::OnnxToTRTModel(
     const std::string&amp; model_file,  // name of the onnx model
-    nvinfer1::IHostMemory** trt_model_stream) {
+    nvinfer1::ICudaEngine** engine_ptr) {
   int verbosity = static_cast&lt;int&gt;(nvinfer1::ILogger::Severity::kWARNING);
-  int kBatchSize = 1;
+  kBatchSize = 1;
 
   // create the builder
   const auto explicit_batch =
       static_cast&lt;uint32_t&gt;(kBatchSize) &lt;&lt; static_cast&lt;uint32_t&gt;(
           nvinfer1::NetworkDefinitionCreationFlag::kEXPLICIT_BATCH);
   nvinfer1::IBuilder* builder = nvinfer1::createInferBuilder(g_logger_);
-
   nvinfer1::INetworkDefinition* network =
       builder-&gt;createNetworkV2(explicit_batch);
 
+  // parse onnx model
   auto parser = nvonnxparser::createParser(*network, g_logger_);
   if (!parser-&gt;parseFromFile(model_file.c_str(), verbosity)) {
     std::string msg("failed to parse onnx file");
@@ -115,227 +79,54 @@ void OnnxObstacleDetector::OnnxToTRTModel(
   // Build the engine
   builder-&gt;setMaxBatchSize(kBatchSize);
   nvinfer1::IBuilderConfig* config = builder-&gt;createBuilderConfig();
-  config-&gt;setMaxWorkspaceSize(1&lt;&lt;20);
-  config-&gt;setFlag(nvinfer1::BuilderFlag::kFP16);
+  config-&gt;setMaxWorkspaceSize(1 &lt;&lt; 20);
   nvinfer1::ICudaEngine* engine =
-  builder-&gt;buildEngineWithConfig(*network, *config);
-
-  // serialize the engine, then close everything down
-  *trt_model_stream = engine-&gt;serialize();
+      builder-&gt;buildEngineWithConfig(*network, *config);
 
+  *engine_ptr = engine;
   parser-&gt;destroy();
   network-&gt;destroy();
   config-&gt;destroy();
   builder-&gt;destroy();
-
-  engine-&gt;destroy();
 }
 
-void OnnxObstacleDetector::TRTStreamToContext(
-  const nvinfer1::IHostMemory* yolov4_trt_model_stream,
-  nvinfer1::IExecutionContext** context_ptr) {
-  nvinfer1::ICudaEngine* engine;
-  nvinfer1::IRuntime* runtime;
-
-  // deserialize the engine
-  runtime = nvinfer1::createInferRuntime(g_logger_);
-  if (runtime == nullptr) {
-    std::cerr &lt;&lt; "Failed to create TensorRT Runtime object." &lt;&lt; std::endl;
-  }
-
-  engine = runtime-&gt;deserializeCudaEngine(
-    yolov4_trt_model_stream-&gt;data(),
-    yolov4_trt_model_stream-&gt;size(),
-    nullptr);
-  if (engine == nullptr) {
-    std::cerr &lt;&lt; "Failed to create TensorRT Engine." &lt;&lt; std::endl;
-  }
-
-  std::cout &lt;&lt; "Deserialize engine success" &lt;&lt; std::endl;
-
-  *context_ptr = engine-&gt;createExecutionContext();
-  if (*context_ptr == nullptr) {
-    std::cerr &lt;&lt; "Failed to create TensorRT Execution Context." &lt;&lt; std::endl;
-  }
-
-  std::cout &lt;&lt; "Create context success" &lt;&lt; std::endl;
+void OnnxObstacleDetector::inference() {
+  AINFO &lt;&lt; "Do Inference";
 }
 
-void OnnxObstacleDetector::TRTStreamToContext(
-  const std::vector&lt;char&gt;&amp; trt_model_stream,
-  nvinfer1::IExecutionContext** context_ptr) {
-  nvinfer1::IRuntime* runtime = nvinfer1::createInferRuntime(g_logger_);
-  if (runtime == nullptr) {
-    std::cerr &lt;&lt; "Failed to create TensorRT Runtime object." &lt;&lt; std::endl;
+bool OnnxObstacleDetector::Init(const std::map&lt;std::string,
+                                std::vector&lt;int&gt;&gt; &amp;shapes) {
+  // create a TensorRT model from the onnx model and load it into an engine
+  OnnxToTRTModel(model_file_, &amp;engine_);
+  if (engine_ == nullptr) {
+    AERROR &lt;&lt; "Fail to load obstacle ONNX model";
+    return false;
   }
 
-  nvinfer1::ICudaEngine* engine = runtime-&gt;deserializeCudaEngine(
-    trt_model_stream.data(),
-    trt_model_stream.size(),
-    nullptr);
-
-  if (engine == nullptr) {
-    std::cerr &lt;&lt; "Failed to create TensorRT Engine." &lt;&lt; std::endl;
+  // create execution context from the engine
+  context_ = engine_-&gt;createExecutionContext();
+  if (context_ == nullptr) {
+    AERROR &lt;&lt; "Fail to create Exceution Context";
+    return false;
   }
 
-  std::cout &lt;&lt; "Deserialize engine success" &lt;&lt; std::endl;
-
-  *context_ptr = engine-&gt;createExecutionContext();
-  if (*context_ptr == nullptr) {
-    std::cerr &lt;&lt; "Failed to create TensorRT Execution Context." &lt;&lt; std::endl;
+  for (const auto&amp; name : output_names_) {
+    auto blob = std::make_shared&lt;Blob&lt;float&gt;&gt;(50, 10, 1, 1);
+    blobs_.emplace(name, blob);
   }
 
-  std::cout &lt;&lt; "Create context success" &lt;&lt; std::endl;
-}
-
-void OnnxObstacleDetector::postProcessing(const cv::Mat&amp; img,
-  float* output,
-  int row_cnt,
-  int num_classes,
-  const std::vector&lt;std::string&gt;&amp; names) {
-  int col_cnt = num_classes + 4;
-  int maxid_i;  // instance id
-  int maxid_j;  // class id
-  float maxv = -1;
-  for (int i=0; i &lt; row_cnt; i++) {
-    for (int j=4; j &lt; col_cnt; j++) {
-      float v = output[i*col_cnt+j];
-      if (maxv &lt; v &amp;&amp; v &gt; -2 &amp;&amp; v &lt; 2) {
-        maxv = v;
-        maxid_i = i;
-        maxid_j = j;
-      }
+  for (const auto&amp; name : input_names_) {
+    auto iter = shapes.find(name);
+    if (iter != shapes.end()) {
+      auto blob = std::make_shared&lt;Blob&lt;float&gt;&gt;(iter-&gt;second);
+      blobs_.emplace(name, blob);
     }
   }
-  int width = img.cols;
-  int height = img.rows;
-  float* best_box = output + col_cnt * maxid_i;
-  int x1 = static_cast&lt;int&gt;((best_box[0] - best_box[2] / 2.0) * width);
-  int y1 = static_cast&lt;int&gt;((best_box[1] - best_box[3] / 2.0) * height);
-  int x2 = static_cast&lt;int&gt;((best_box[0] + best_box[2] / 2.0) * width);
-  int y2 = static_cast&lt;int&gt;((best_box[1] + best_box[3] / 2.0) * height);
-
-  cv::rectangle(img,
-    cv::Point(x1, y1),
-    cv::Point(x2, y2),
-    cv::Scalar(0, 255, 0));
-  cv::putText(img, names[maxid_j-4],
-    cv::Point2f(x1, y1),
-    cv::FONT_HERSHEY_SIMPLEX,
-    1.2,
-    cv::Scalar(0, 0, 255, 255),
-    1);
-}
-
-void OnnxObstacleDetector::inference(
-  nvinfer1::IExecutionContext* yolov4_context_,
-  int num_classes, const std::vector&lt;std::string&gt;&amp; names,
-  const std::string&amp; image_path,
-  const std::string&amp; prediction_image_path) {
-  cv::Mat img_ori = cv::imread(image_path);
-
-  if (img_ori.empty()) {
-    std::cout &lt;&lt; "Load image fail: " &lt;&lt; image_path &lt;&lt; std::endl;
-    return;
-  } else {
-    std::cout &lt;&lt; "Load image success: " &lt;&lt; image_path &lt;&lt; std::endl;
-  }
-
-  int w = 416;
-  int h = 416;
-  cv::Mat img;
-  cv::resize(img_ori, img, cv::Size(w, h));
-  cv::cvtColor(img, img, cv::COLOR_BGR2RGB);
-
-  int tot_length = img.rows * img.cols * 3;
-
-  cudaStream_t stream;
-  GPU_CHECK(cudaStreamCreate(&amp;stream));
-
-  int input_length = tot_length * sizeof(float);
-  int row_cnt = 10647;
-  int output_length = 1 *
-    row_cnt * (num_classes + 4) * sizeof(float);  // 3577392
-
-  float* input_image_ = reinterpret_cast&lt;float*&gt;(malloc(input_length));
-
-  for (int i = 0; i &lt; img.rows; i++) {
-    for (int j = 0; j &lt; img.cols; j++) {
-      for (int k = 0; k &lt; 3; k++) {
-        input_image_[k*img.rows*img.cols + i*img.cols + j] =
-        static_cast&lt;float&gt;(img.data[i*img.cols*3+j*3+k]) / 255.0;
-      }
-    }
-  }
-
-  void* buffers[2];
-  GPU_CHECK(cudaMalloc(&amp;buffers[0], input_length));
-  GPU_CHECK(cudaMemcpy(buffers[0],
-    input_image_,
-    input_length,
-    cudaMemcpyHostToDevice));
-
-  GPU_CHECK(cudaMalloc(&amp;buffers[1], output_length));
-  GPU_CHECK(cudaMemset(buffers[1], 0, output_length));
-
-  yolov4_context_-&gt;enqueueV2(buffers, stream, nullptr);
-  std::cout &lt;&lt; "Inference success" &lt;&lt; std::endl;
-
-  float* output = reinterpret_cast&lt;float*&gt;(malloc(output_length));
-  GPU_CHECK(
-    cudaMemcpy(
-      output,
-      buffers[1],
-      output_length,
-      cudaMemcpyDeviceToHost));
-
-  postProcessing(img_ori, output, row_cnt, num_classes, names);
-
-  cv::imwrite(prediction_image_path, img_ori);
-  std::cout &lt;&lt; "Save prediction image to "
-    &lt;&lt; prediction_image_path &lt;&lt; std::endl;
-  GPU_CHECK(cudaFree(buffers[0]));
-  GPU_CHECK(cudaFree(buffers[1]));
-  free(input_image_);
-  free(output);
-  cudaStreamDestroy(stream);
-}
-
-void OnnxObstacleDetector::readNames(
-  const std::string&amp; names_file_path,
-  std::vector&lt;std::string&gt;* names) {
-  std::ifstream f_names(names_file_path);
-  std::string s;
-  while (std::getline(f_names, s)) {
-    names-&gt;push_back(s);
-  }
-}
-
-bool OnnxObstacleDetector::Init(
-  const std::map&lt;std::string,
-  std::vector&lt;int&gt;&gt; &amp;shapes) {
-  std::cout &lt;&lt; NV_TENSORRT_MAJOR
-  &lt;&lt; "." &lt;&lt; NV_TENSORRT_MINOR &lt;&lt; "."
-  &lt;&lt; NV_TENSORRT_PATCH &lt;&lt; "."
-  &lt;&lt; NV_TENSORRT_BUILD  &lt;&lt; std::endl;
   return true;
 }
 
 void OnnxObstacleDetector::Infer() {
-  nvinfer1::IHostMemory* trt_stream{nullptr};
-  OnnxToTRTModel(model_file_, &amp;trt_stream);
-
-  TRTStreamToContext(trt_stream, &amp;context_);
-
-  std::vector&lt;std::string&gt;* names =  new std::vector&lt;std::string&gt;;
-  readNames(names_file_path_, names);
-  inference(context_,
-    num_classes_,
-    *names,
-    image_path_,
-    prediction_image_path_);
-
-  trt_stream-&gt;destroy();
+  std::cout &lt;&lt; "Infer" &lt;&lt; std::endl;
 }
 
 BlobPtr OnnxObstacleDetector::get_blob(const std::string &amp;name) {
</diff>
			</file>
			<file old_path="modules\perception\inference\onnx\onnx_obstacle_detector.h" new_path="modules\perception\inference\onnx\onnx_obstacle_detector.h" added_lines="51" deleted_lines="37">
				<diff>@@ -16,21 +16,16 @@
 
 #pragma once
 
+#include &lt;iostream&gt;
 #include &lt;map&gt;
 #include &lt;memory&gt;
 #include &lt;string&gt;
 #include &lt;utility&gt;
 #include &lt;vector&gt;
-#include &lt;iostream&gt;
-#include &lt;fstream&gt;
-#include &lt;cuda_runtime_api.h&gt;
 
 #include "NvInfer.h"
 #include "NvOnnxParser.h"
 #include "NvInferVersion.h"
-#include "opencv2/core/core.hpp"
-#include "opencv2/highgui/highgui.hpp"
-#include "opencv2/imgproc/imgproc.hpp"
 
 #include "modules/perception/common/perception_gflags.h"
 #include "modules/perception/inference/inference.h"
@@ -41,44 +36,62 @@ namespace inference {
 
 using BlobPtr = std::shared_ptr&lt;apollo::perception::base::Blob&lt;float&gt;&gt;;
 
+// Logger for TensorRT info/warning/errors
+class Logger : public nvinfer1::ILogger {
+ public:
+  explicit Logger(Severity severity = Severity::kWARNING)
+      : reportable_severity(severity) {}
+
+  void log(Severity severity, const char* msg) override {
+    // suppress messages with severity enum value greater than the reportable
+    if (severity &gt; reportable_severity) return;
+
+    switch (severity) {
+      case Severity::kINTERNAL_ERROR:
+        std::cerr &lt;&lt; "INTERNAL_ERROR: ";
+        break;
+      case Severity::kERROR:
+        std::cerr &lt;&lt; "ERROR: ";
+        break;
+      case Severity::kWARNING:
+        std::cerr &lt;&lt; "WARNING: ";
+        break;
+      case Severity::kINFO:
+        std::cerr &lt;&lt; "INFO: ";
+        break;
+      default:
+        std::cerr &lt;&lt; "UNKNOWN: ";
+        break;
+    }
+    std::cerr &lt;&lt; msg &lt;&lt; std::endl;
+  }
+
+  Severity reportable_severity;
+};
+
 class OnnxObstacleDetector : public Inference {
  public:
   OnnxObstacleDetector(const std::string &amp;model_file,
-                        const int num_classes,
-                        const std::string &amp;input_image_file,
-                        const std::string &amp;input_name_file,
-                        const std::string &amp;prediction_image_path);
+                       const float score_threshold,
+                       const std::vector&lt;std::string&gt; &amp;outputs,
+                       const std::vector&lt;std::string&gt; &amp;inputs);
 
   OnnxObstacleDetector(const std::string &amp;model_file,
-                        const std::vector&lt;std::string&gt; &amp;outputs,
-                        const std::vector&lt;std::string&gt; &amp;inputs);
+                       const std::vector&lt;std::string&gt; &amp;outputs,
+                       const std::vector&lt;std::string&gt; &amp;inputs);
 
   virtual ~OnnxObstacleDetector();
 
+  /**
+   * @brief Convert ONNX to TensorRT model
+   * @param[in] model_file ONNX model file path
+   * @param[out] engine_ptr TensorRT model engine made out of ONNX model
+   * @details Load ONNX model, and convert it to TensorRT model
+   */
   void OnnxToTRTModel(const std::string&amp; model_file,
-    nvinfer1::IHostMemory** trt_model_stream);
-
-  void TRTStreamToContext(
-  const nvinfer1::IHostMemory* yolov4_trt_model_stream,
-  nvinfer1::IExecutionContext** context_ptr);
-
-  void TRTStreamToContext(
-  const std::vector&lt;char&gt;&amp; trt_model_stream,
-  nvinfer1::IExecutionContext** context_ptr);
-
-  void postProcessing(
-  const cv::Mat&amp; img,
-  float* output, int row_cnt,
-  int num_classes,
-  const std::vector&lt;std::string&gt;&amp; names);
-
-  void inference(nvinfer1::IExecutionContext* yolov4_context_,
-  int num_classes, const std::vector&lt;std::string&gt;&amp; names,
-  const std::string&amp; image_path, const std::string&amp; prediction_image_path);
+                      nvinfer1::ICudaEngine** engine_ptr);
 
-  void readNames(
-  const std::string&amp; names_file_path,
-  std::vector&lt;std::string&gt;* names);
+  void inference();
 
   bool Init(const std::map&lt;std::string, std::vector&lt;int&gt;&gt; &amp;shapes) override;
   void Infer() override;
@@ -86,15 +99,16 @@ class OnnxObstacleDetector : public Inference {
 
  private:
   std::string model_file_;
+  float score_threshold_;
   std::vector&lt;std::string&gt; output_names_;
   std::vector&lt;std::string&gt; input_names_;
   BlobMap blobs_;
+  nvinfer1::ICudaEngine* engine_;
   nvinfer1::IExecutionContext* context_;
+  Logger g_logger_;
 
   int num_classes_;
-  std::string image_path_;
-  std::string names_file_path_;  // coco.names
-  std::string prediction_image_path_;
+  int kBatchSize;
 };
 
 }  // namespace inference
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_camera_detection_component.cc" new_path="modules\perception\onboard\component\fusion_camera_detection_component.cc" added_lines="6" deleted_lines="5">
				<diff>@@ -36,6 +36,7 @@ namespace perception {
 namespace onboard {
 
 using apollo::cyber::common::GetAbsolutePath;
+using ::apollo::cyber::Clock;
 
 static void fill_lane_msg(const base::LaneLineCubicCurve &amp;curve_coord,
                           apollo::perception::LaneMarker *lane_marker) {
@@ -151,8 +152,8 @@ bool LoadExtrinsics(const std::string &amp;yaml_file,
 // @description: get project matrix
 bool GetProjectMatrix(
     const std::vector&lt;std::string&gt; &amp;camera_names,
-    const std::map&lt;std::string, Eigen::Matrix4d&gt; &amp;extrinsic_map,
-    const std::map&lt;std::string, Eigen::Matrix3f&gt; &amp;intrinsic_map,
+    const EigenMap&lt;std::string, Eigen::Matrix4d&gt; &amp;extrinsic_map,
+    const EigenMap&lt;std::string, Eigen::Matrix3f&gt; &amp;intrinsic_map,
     Eigen::Matrix3d *project_matrix, double *pitch_diff = nullptr) {
   // TODO(techoe): This condition should be removed.
   if (camera_names.size() != 2) {
@@ -278,7 +279,7 @@ void FusionCameraDetectionComponent::OnReceiveImage(
 
   // for e2e lantency statistics
   {
-    const double cur_time = apollo::common::time::Clock::NowInSeconds();
+    const double cur_time = Clock::NowInSeconds();
     const double start_latency = (cur_time - message-&gt;measurement_time()) * 1e3;
     AINFO &lt;&lt; "FRAME_STATISTICS:Camera:Start:msg_time[" &lt;&lt; camera_name &lt;&lt; "-"
           &lt;&lt; FORMAT_TIMESTAMP(message-&gt;measurement_time()) &lt;&lt; "]:cur_time["
@@ -318,7 +319,7 @@ void FusionCameraDetectionComponent::OnReceiveImage(
   }
   // for e2e lantency statistics
   {
-    const double end_timestamp = apollo::common::time::Clock::NowInSeconds();
+    const double end_timestamp = Clock::NowInSeconds();
     const double end_latency =
         (end_timestamp - message-&gt;measurement_time()) * 1e3;
     AINFO &lt;&lt; "FRAME_STATISTICS:Camera:End:msg_time[" &lt;&lt; camera_name &lt;&lt; "-"
@@ -834,7 +835,7 @@ int FusionCameraDetectionComponent::MakeProtobufMsg(
     const std::vector&lt;base::LaneLine&gt; &amp;lane_objects,
     const apollo::common::ErrorCode error_code,
     apollo::perception::PerceptionObstacles *obstacles) {
-  double publish_time = apollo::common::time::Clock::NowInSeconds();
+  double publish_time = Clock::NowInSeconds();
   apollo::common::Header *header = obstacles-&gt;mutable_header();
   header-&gt;set_timestamp_sec(publish_time);
   header-&gt;set_module_name("perception_camera");
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_camera_detection_component.h" new_path="modules\perception\onboard\component\fusion_camera_detection_component.h" added_lines="6" deleted_lines="3">
				<diff>@@ -21,6 +21,7 @@
 #include &lt;vector&gt;
 
 #include "cyber/component/component.h"
+#include "modules/common/util/eigen_defs.h"
 #include "modules/drivers/proto/sensor_image.pb.h"
 #include "modules/perception/base/object.h"
 #include "modules/perception/base/object_types.h"
@@ -41,6 +42,8 @@
 
 typedef std::shared_ptr&lt;apollo::perception::Motion_Service&gt;
     MotionServiceMsgType;
+using apollo::common::EigenMap;
+using apollo::common::EigenVector;
 
 namespace apollo {
 namespace perception {
@@ -131,8 +134,8 @@ class FusionCameraDetectionComponent : public apollo::cyber::Component&lt;&gt; {
       data_providers_map_;
 
   // map for store params
-  std::map&lt;std::string, Eigen::Matrix4d&gt; extrinsic_map_;
-  std::map&lt;std::string, Eigen::Matrix3f&gt; intrinsic_map_;
+  EigenMap&lt;std::string, Eigen::Matrix4d&gt; extrinsic_map_;
+  EigenMap&lt;std::string, Eigen::Matrix3f&gt; intrinsic_map_;
   Eigen::Matrix3d homography_im2car_;
 
   // camera obstacle pipeline
@@ -143,7 +146,7 @@ class FusionCameraDetectionComponent : public apollo::cyber::Component&lt;&gt; {
   // fixed size camera frames
   int frame_capacity_ = 20;
   int frame_id_ = 0;
-  std::vector&lt;camera::CameraFrame&gt; camera_frames_;
+  EigenVector&lt;camera::CameraFrame&gt; camera_frames_;
 
   // image info.
   int image_width_ = 1920;
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\lane_detection_component.cc" new_path="modules\perception\onboard\component\lane_detection_component.cc" added_lines="5" deleted_lines="4">
				<diff>@@ -44,6 +44,7 @@ namespace perception {
 namespace onboard {
 using apollo::cyber::common::GetAbsolutePath;
 using apollo::localization::LocalizationEstimate;
+using ::apollo::cyber::Clock;
 
 FunInfoType LaneDetectionComponent::init_func_arry_[] = {
     {&amp;LaneDetectionComponent::InitSensorInfo, "InitSensorInfo"},
@@ -157,8 +158,8 @@ static bool LoadExtrinsics(const std::string &amp;yaml_file,
 // @description: get project matrix
 static bool GetProjectMatrix(
     const std::vector&lt;std::string&gt; &amp;camera_names,
-    const std::map&lt;std::string, Eigen::Matrix4d&gt; &amp;extrinsic_map,
-    const std::map&lt;std::string, Eigen::Matrix3f&gt; &amp;intrinsic_map,
+    const EigenMap&lt;std::string, Eigen::Matrix4d&gt; &amp;extrinsic_map,
+    const EigenMap&lt;std::string, Eigen::Matrix3f&gt; &amp;intrinsic_map,
     Eigen::Matrix3d *project_matrix, double *pitch_diff = nullptr) {
   if (camera_names.size() != 2) {
     AINFO &lt;&lt; "camera number must be 2!";
@@ -288,7 +289,7 @@ void LaneDetectionComponent::OnReceiveImage(
 
   // for e2e lantency statistics
   {
-    const double cur_time = apollo::common::time::Clock::NowInSeconds();
+    const double cur_time = Clock::NowInSeconds();
     const double start_latency = (cur_time - message-&gt;measurement_time()) * 1e3;
     AINFO &lt;&lt; "FRAME_STATISTICS:Camera:Start:msg_time[" &lt;&lt; camera_name &lt;&lt; "-"
           &lt;&lt; FORMAT_TIMESTAMP(message-&gt;measurement_time()) &lt;&lt; "]:cur_time["
@@ -312,7 +313,7 @@ void LaneDetectionComponent::OnReceiveImage(
 
   // for e2e lantency statistics
   {
-    const double end_timestamp = apollo::common::time::Clock::NowInSeconds();
+    const double end_timestamp = Clock::NowInSeconds();
     const double end_latency =
         (end_timestamp - message-&gt;measurement_time()) * 1e3;
     AINFO &lt;&lt; "FRAME_STATISTICS:Camera:End:msg_time[" &lt;&lt; camera_name &lt;&lt; "-"
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\lane_detection_component.h" new_path="modules\perception\onboard\component\lane_detection_component.h" added_lines="7" deleted_lines="3">
				<diff>@@ -23,8 +23,10 @@
 
 #include "Eigen/Core"
 #include "Eigen/Dense"
+#include "Eigen/StdVector"
 
 #include "cyber/component/component.h"
+#include "modules/common/util/eigen_defs.h"
 #include "modules/common/util/util.h"
 #include "modules/drivers/proto/sensor_image.pb.h"
 #include "modules/perception/base/object.h"
@@ -43,6 +45,8 @@
 #include "modules/perception/proto/motion_service.pb.h"
 #include "modules/perception/proto/perception_lane.pb.h"
 
+using apollo::common::EigenMap;
+using apollo::common::EigenVector;
 typedef std::shared_ptr&lt;apollo::perception::Motion_Service&gt;
     MotionServiceMsgType;
 
@@ -125,8 +129,8 @@ class LaneDetectionComponent : public apollo::cyber::Component&lt;&gt; {
       data_providers_map_;
 
   // map for store params
-  std::map&lt;std::string, Eigen::Matrix4d&gt; extrinsic_map_;
-  std::map&lt;std::string, Eigen::Matrix3f&gt; intrinsic_map_;
+  EigenMap&lt;std::string, Eigen::Matrix4d&gt; extrinsic_map_;
+  EigenMap&lt;std::string, Eigen::Matrix3f&gt; intrinsic_map_;
   Eigen::Matrix3d homography_image2ground_;
 
   // camera lane pipeline
@@ -137,7 +141,7 @@ class LaneDetectionComponent : public apollo::cyber::Component&lt;&gt; {
   // fixed size camera frames
   int frame_capacity_ = 20;
   int frame_id_ = 0;
-  std::vector&lt;camera::CameraFrame&gt; camera_frames_;
+  EigenVector&lt;camera::CameraFrame&gt; camera_frames_;
 
   // image info.
   int image_width_ = 1920;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="456018326b5841af3ca524f137e06092a25ebdd0" author="cuishiwei">
		<msg>Canbus: update steering command and report in D-KIT &amp; Calibration:update kinetic calibration parameter for dev_kit_standard (#13141)</msg>
		<modified_files>
			<file old_path="modules\canbus\vehicle\devkit\protocol\steering_command_102.cc" new_path="modules\canbus\vehicle\devkit\protocol\steering_command_102.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -77,13 +77,13 @@ Steeringcommand102* Steeringcommand102::set_steer_angle_target(
 }
 
 // config detail: {'name': 'Steer_ANGLE_Target', 'offset': -500.0, 'precision':
-// 0.1, 'len': 16, 'is_signed_var': False, 'physical_range': '[-500|500]',
+// 1.0, 'len': 16, 'is_signed_var': False, 'physical_range': '[-500|500]',
 // 'bit': 31, 'type': 'double', 'order': 'motorola', 'physical_unit': 'deg'}
 void Steeringcommand102::set_p_steer_angle_target(uint8_t* data,
                                                   double steer_angle_target) {
   steer_angle_target =
       ProtocolData::BoundedValue(-500.0, 500.0, steer_angle_target);
-  int x = (steer_angle_target - -500.000000) / 0.100000;
+  int x = steer_angle_target - -500.000000;
   uint8_t t = 0;
 
   t = x &amp; 0xFF;
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\protocol\steering_command_102.h" new_path="modules\canbus\vehicle\devkit\protocol\steering_command_102.h" added_lines="1" deleted_lines="1">
				<diff>@@ -68,7 +68,7 @@ class Steeringcommand102 : public ::apollo::drivers::canbus::ProtocolData&lt;
       uint8_t* data, Steering_command_102::Steer_en_ctrlType steer_en_ctrl);
 
   // config detail: {'name': 'Steer_ANGLE_Target', 'offset': -500.0,
-  // 'precision': 0.1, 'len': 16, 'is_signed_var': False, 'physical_range':
+  // 'precision': 1.0, 'len': 16, 'is_signed_var': False, 'physical_range':
   // '[-500|500]', 'bit': 31, 'type': 'double', 'order': 'motorola',
   // 'physical_unit': 'deg'}
   void set_p_steer_angle_target(uint8_t* data, double steer_angle_target);
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\protocol\steering_command_102_test.cc" new_path="modules\canbus\vehicle\devkit\protocol\steering_command_102_test.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -34,11 +34,11 @@ TEST_F(Steeringcommand102Test, simple) {
   EXPECT_EQ(data[0], 0b01110000);
   EXPECT_EQ(data[1], 0b00000000);
   EXPECT_EQ(data[2], 0b01110011);
-  EXPECT_EQ(data[3], 0b00010011);
-  EXPECT_EQ(data[4], 0b10001000);
+  EXPECT_EQ(data[3], 0b00000001);
+  EXPECT_EQ(data[4], 0b11110100);
   EXPECT_EQ(data[5], 0b01110110);
   EXPECT_EQ(data[6], 0b01110111);
-  EXPECT_EQ(data[7], 0b10011001);
+  EXPECT_EQ(data[7], 0b11110111);
 }
 
 }  // namespace devkit
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\protocol\steering_report_502.cc" new_path="modules\canbus\vehicle\devkit\protocol\steering_report_502.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -106,7 +106,7 @@ Steering_report_502::Steer_en_stateType Steeringreport502::steer_en_state(
 }
 
 // config detail: {'name': 'steer_angle_actual', 'offset': -500.0, 'precision':
-// 0.1, 'len': 16, 'is_signed_var': False, 'physical_range': '[-500|500]',
+// 1.0, 'len': 16, 'is_signed_var': False, 'physical_range': '[-500|500]',
 // 'bit': 31, 'type': 'double', 'order': 'motorola', 'physical_unit': 'deg'}
 double Steeringreport502::steer_angle_actual(const std::uint8_t* bytes,
                                              int32_t length) const {
@@ -118,7 +118,7 @@ double Steeringreport502::steer_angle_actual(const std::uint8_t* bytes,
   x &lt;&lt;= 8;
   x |= t;
 
-  double ret = x * 0.100000 + -500.000000;
+  double ret = x + -500.000000;
   return ret;
 }
 }  // namespace devkit
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\protocol\steering_report_502.h" new_path="modules\canbus\vehicle\devkit\protocol\steering_report_502.h" added_lines="1" deleted_lines="1">
				<diff>@@ -65,7 +65,7 @@ class Steeringreport502 : public ::apollo::drivers::canbus::ProtocolData&lt;
       const std::uint8_t* bytes, const int32_t length) const;
 
   // config detail: {'name': 'Steer_ANGLE_Actual', 'offset': -500.0,
-  // 'precision': 0.1, 'len': 16, 'is_signed_var': False, 'physical_range':
+  // 'precision': 1.0, 'len': 16, 'is_signed_var': False, 'physical_range':
   // '[-500|500]', 'bit': 31, 'type': 'double', 'order': 'motorola',
   // 'physical_unit': 'deg'}
   double steer_angle_actual(const std::uint8_t* bytes,
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\protocol\steering_report_502_test.cc" new_path="modules\canbus\vehicle\devkit\protocol\steering_report_502_test.cc" added_lines="1" deleted_lines="2">
				<diff>@@ -47,8 +47,7 @@ TEST_F(Steeringreport502Test, General) {
   EXPECT_EQ(cd.devkit().steering_report_502().steer_flt2(), 1);
   EXPECT_EQ(cd.devkit().steering_report_502().steer_flt1(), 1);
   EXPECT_EQ(cd.devkit().steering_report_502().steer_en_state(), 0);
-  EXPECT_NEAR(cd.devkit().steering_report_502().steer_angle_actual(), 15,
-              1.0e-10);
+  EXPECT_EQ(cd.devkit().steering_report_502().steer_angle_actual(), 4650);
 }
 
 }  // namespace devkit
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8068499c044a21bb2df936434391650ab8334d97" author="Yiqun Fu">
		<msg>task_manager: add heading for rerouting (#13155)</msg>
		<modified_files>
			<file old_path="modules\task_manager\cycle_routing_manager.cc" new_path="modules\task_manager\cycle_routing_manager.cc" added_lines="4" deleted_lines="4">
				<diff>@@ -64,8 +64,8 @@ bool CycleRoutingManager::GetNewRouting(const localization::Pose &amp;pose,
       AINFO &lt;&lt; "GetNewRouting: reach begin point";
       new_routing_request-&gt;CopyFrom(original_routing_request_);
       auto cur_point = new_routing_request-&gt;mutable_waypoint(0);
-      if (!map_service_-&gt;ConstructLaneWayPoint(pose.position().x(),
-          pose.position().y(), cur_point)) {
+      if (!map_service_-&gt;ConstructLaneWayPointWithHeading(pose.position().x(),
+          pose.position().y(), pose.heading(), cur_point)) {
         AINFO &lt;&lt; "GetNewRouting: construct begin lane way point fail!";
         return false;
       }
@@ -81,8 +81,8 @@ bool CycleRoutingManager::GetNewRouting(const localization::Pose &amp;pose,
       AINFO &lt;&lt; "GetNewRouting: reach end point";
       new_routing_request-&gt;clear_waypoint();
       auto cur_point = new_routing_request-&gt;add_waypoint();
-      if (!map_service_-&gt;ConstructLaneWayPoint(pose.position().x(),
-          pose.position().y(), cur_point)) {
+      if (!map_service_-&gt;ConstructLaneWayPointWithHeading(pose.position().x(),
+          pose.position().y(), pose.heading(), cur_point)) {
         AINFO &lt;&lt; "GetNewRouting: construct end lane way point fail!";
         return false;
       }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="65d18ebd85b707f94c5437d04bfe7ae9293d76f3" author="SeasoulChris">
		<msg>monitor: add pointcloud_16_topic to monitor module (#13146)

Co-authored-by: lishuanghua &lt;17302618@qq.com&gt;</msg>
		<modified_files>
			<file old_path="modules\common\adapters\adapter_gflags.cc" new_path="modules\common\adapters\adapter_gflags.cc" added_lines="3" deleted_lines="0">
				<diff>@@ -49,6 +49,9 @@ DEFINE_string(control_core_command_topic, "/apollo/control/controlcore",
 DEFINE_string(pointcloud_topic,
               "/apollo/sensor/lidar128/compensator/PointCloud2",
               "pointcloud topic name");
+DEFINE_string(pointcloud_16_topic,
+              "/apollo/sensor/lidar16/compensator/PointCloud2",
+              "16 beam Lidar pointcloud topic name");
 DEFINE_string(pointcloud_16_front_up_topic,
               "/apollo/sensor/lidar16/front/up/compensator/PointCloud2",
               "Front up 16 beam Lidar pointcloud topic name");
</diff>
			</file>
			<file old_path="modules\common\adapters\adapter_gflags.h" new_path="modules\common\adapters\adapter_gflags.h" added_lines="1" deleted_lines="0">
				<diff>@@ -36,6 +36,7 @@ DECLARE_string(control_preprocessor_topic);
 DECLARE_string(control_local_view_topic);
 DECLARE_string(control_core_command_topic);
 DECLARE_string(pointcloud_topic);
+DECLARE_string(pointcloud_16_topic);
 DECLARE_string(pointcloud_16_front_up_topic);
 DECLARE_string(pointcloud_64_topic);
 DECLARE_string(pointcloud_128_topic);
</diff>
			</file>
			<file old_path="modules\monitor\software\channel_monitor.cc" new_path="modules\monitor\software\channel_monitor.cc" added_lines="2" deleted_lines="0">
				<diff>@@ -88,6 +88,8 @@ ReaderAndMessagePair GetReaderAndLatestMessage(const std::string&amp; channel) {
            &amp;CreateReaderAndLatestsMessage&lt;relative_map::MapMsg&gt;},
           {FLAGS_pointcloud_topic,
            &amp;CreateReaderAndLatestsMessage&lt;drivers::PointCloud&gt;},
+          {FLAGS_pointcloud_16_topic,
+           &amp;CreateReaderAndLatestsMessage&lt;drivers::PointCloud&gt;},
           {FLAGS_pointcloud_128_topic,
            &amp;CreateReaderAndLatestsMessage&lt;drivers::PointCloud&gt;},
           {FLAGS_pointcloud_16_front_up_topic,
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3feb611e3967934beaf9ac54544ec0fc0640cbe5" author="daohu527">
		<msg>cyber: BoundedQueue Enqueue(T&amp;&amp;) change to perfect forwarding</msg>
		<modified_files>
			<file old_path="cyber\base\bounded_queue.h" new_path="cyber\base\bounded_queue.h" added_lines="3" deleted_lines="2">
				<diff>@@ -24,6 +24,7 @@
 #include &lt;cstdint&gt;
 #include &lt;cstdlib&gt;
 #include &lt;memory&gt;
+#include &lt;utility&gt;
 
 #include "cyber/base/macros.h"
 #include "cyber/base/wait_strategy.h"
@@ -141,7 +142,7 @@ bool BoundedQueue&lt;T&gt;::Enqueue(T&amp;&amp; element) {
   } while (!tail_.compare_exchange_weak(old_tail, new_tail,
                                         std::memory_order_acq_rel,
                                         std::memory_order_relaxed));
-  pool_[GetIndex(old_tail)] = element;
+  pool_[GetIndex(old_tail)] = std::move(element);
   do {
     old_commit = old_tail;
   } while (cyber_unlikely(!commit_.compare_exchange_weak(
@@ -186,7 +187,7 @@ bool BoundedQueue&lt;T&gt;::WaitEnqueue(const T&amp; element) {
 template &lt;typename T&gt;
 bool BoundedQueue&lt;T&gt;::WaitEnqueue(T&amp;&amp; element) {
   while (!break_all_wait_) {
-    if (Enqueue(element)) {
+    if (Enqueue(std::move(element))) {
       return true;
     }
     if (wait_strategy_-&gt;EmptyWait()) {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ac6f203c7885814941d30e4382576a34bc7c23e9" author="changsh726">
		<msg>{Drivers,Perception}: fix typo</msg>
		<modified_files>
			<file old_path="modules\perception\fusion\common\dst_evidence_test.cc" new_path="modules\perception\fusion\common\dst_evidence_test.cc" added_lines="13" deleted_lines="11">
				<diff>@@ -14,12 +14,13 @@
  * limitations under the License.
  *****************************************************************************/
 
+#include "modules/perception/fusion/common/dst_evidence.h"
+
 #include &lt;boost/format.hpp&gt;
 
-#include "cyber/common/log.h"
 #include "gtest/gtest.h"
 
-#include "modules/perception/fusion/common/dst_evidence.h"
+#include "cyber/common/log.h"
 
 namespace apollo {
 namespace perception {
@@ -27,14 +28,15 @@ namespace fusion {
 // elementary hypotheses
 enum { F111 = (1 &lt;&lt; 0), FA18 = (1 &lt;&lt; 1), P3C = (1 &lt;&lt; 2) };
 // compound hypotheses
-enum { FAST = (F111 | FA18), UNKOWN = (F111 | FA18 | P3C) };
+enum { FAST = (F111 | FA18), UNKNOWN = (F111 | FA18 | P3C) };
 static const std::vector&lt;uint64_t&gt; fod_subsets = {F111, FA18, P3C, FAST,
-                                                  UNKOWN};
-static const std::map&lt;uint64_t, std::string&gt; hypo_names = {{F111, "F111"},
-                                                           {FA18, "FA18"},
-                                                           {P3C, "P3C"},
-                                                           {FAST, "FAST"},
-                                                           {UNKOWN, "UNKOWN"}};
+                                                  UNKNOWN};
+static const std::map&lt;uint64_t, std::string&gt; hypo_names = {
+    {F111, "F111"},
+    {FA18, "FA18"},
+    {P3C, "P3C"},
+    {FAST, "FAST"},
+    {UNKNOWN, "UNKNOWN"}};
 
 class DSTEvidenceTest : public ::testing::Test {
  public:
@@ -42,7 +44,7 @@ class DSTEvidenceTest : public ::testing::Test {
       : sensor1_dst_("test"), sensor2_dst_("test"), fused_dst_("test") {
     DstManager *dst_manager = DstManager::Instance();
     std::vector&lt;std::string&gt; fod_subset_names = {"F111", "FA18", "P3C", "FAST",
-                                                 "UNKOWN"};
+                                                 "UNKNOWN"};
     dst_manager-&gt;AddApp("test", fod_subsets, fod_subset_names);
     vec_equal_ = [](const std::vector&lt;double&gt; &amp;vec,
                     const std::vector&lt;double&gt; &amp;gt) {
@@ -70,7 +72,7 @@ class DSTEvidenceTest : public ::testing::Test {
   }
   void assign_dst_test() {
     std::map&lt;uint64_t, double&gt; dst_map = {
-        {F111, 0.3}, {FA18, 0.18}, {FAST, 0.42}, {UNKOWN, 0.1}};
+        {F111, 0.3}, {FA18, 0.18}, {FAST, 0.42}, {UNKNOWN, 0.1}};
     std::vector&lt;double&gt; dst_vec_gt = {0.3, 0.18, 0.00, 0.42, 0.1};
     Dst dst("test");
     dst.SetBba(dst_map);
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\data_fusion\existence_fusion\dst_existence_fusion\dst_existence_fusion.cc" new_path="modules\perception\fusion\lib\data_fusion\existence_fusion\dst_existence_fusion\dst_existence_fusion.cc" added_lines="4" deleted_lines="4">
				<diff>@@ -103,7 +103,7 @@ void DstExistenceFusion::UpdateWithMeasurement(
   Dst existence_evidence(fused_existence_.Name());
   existence_evidence.SetBba(
       {{ExistenceDstMaps::EXIST, obj_exist_prob},
-       {ExistenceDstMaps::EXISTUNKOWN, 1 - obj_exist_prob}});
+       {ExistenceDstMaps::EXISTUNKNOWN, 1 - obj_exist_prob}});
   // TODO(all) hard code for fused exist bba
   const double exist_fused_w = 1.0;
   ADEBUG &lt;&lt; " before update exist prob: " &lt;&lt; GetExistenceProbability();
@@ -147,7 +147,7 @@ void DstExistenceFusion::UpdateWithoutMeasurement(const std::string &amp;sensor_id,
     double obj_unexist_prob = unexist_factor * dist_decay;
     existence_evidence.SetBba(
         {{ExistenceDstMaps::NEXIST, obj_unexist_prob},
-         {ExistenceDstMaps::EXISTUNKOWN, 1 - obj_unexist_prob}});
+         {ExistenceDstMaps::EXISTUNKNOWN, 1 - obj_unexist_prob}});
     // TODO(all) hard code for fused exist bba
     const double unexist_fused_w = 1.0;
     double min_match_dist_score = min_match_dist;
@@ -283,7 +283,7 @@ void DstExistenceFusion::UpdateToicWithoutCameraMeasurement(
 
   Dst toic_evidence(fused_toic_.Name());
   toic_evidence.SetBba({{ToicDstMaps::NTOIC, 1 - dist_score},
-                        {ToicDstMaps::TOICUNKOWN, dist_score}});
+                        {ToicDstMaps::TOICUNKNOWN, dist_score}});
   // TODO(yuantingrong): hard code for fused toic bba
   const double toic_fused_w = 1.0;
   fused_toic_ = fused_toic_ + toic_evidence * in_view_ratio * toic_fused_w;
@@ -334,7 +334,7 @@ void DstExistenceFusion::UpdateToicWithCameraMeasurement(
 
   Dst toic_evidence(fused_toic_.Name());
   toic_evidence.SetBba({{ToicDstMaps::TOIC, association_prob},
-                        {ToicDstMaps::TOICUNKOWN, 1 - association_prob}});
+                        {ToicDstMaps::TOICUNKNOWN, 1 - association_prob}});
   // TODO(yuantingrong): hard code for fused toic bba
   const double toic_fused_w = 0.7;
   fused_toic_ = fused_toic_ + toic_evidence * toic_fused_w * in_view_ratio;
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\data_fusion\existence_fusion\dst_existence_fusion\dst_existence_fusion.h" new_path="modules\perception\fusion\lib\data_fusion\existence_fusion\dst_existence_fusion\dst_existence_fusion.h" added_lines="6" deleted_lines="6">
				<diff>@@ -28,15 +28,15 @@ namespace fusion {
 
 struct ToicDstMaps {
   // for (N)TOIC: (not)target of interest in camera judgement
-  enum { TOIC = (1 &lt;&lt; 0), NTOIC = (1 &lt;&lt; 1), TOICUNKOWN = (TOIC | NTOIC) };
-  std::vector&lt;uint64_t&gt; fod_subsets_ = {TOIC, NTOIC, TOICUNKOWN};
-  std::vector&lt;std::string&gt; subset_names_ = {"TOIC", "NTOIC", "TOICUNKOWN"};
+  enum { TOIC = (1 &lt;&lt; 0), NTOIC = (1 &lt;&lt; 1), TOICUNKNOWN = (TOIC | NTOIC) };
+  std::vector&lt;uint64_t&gt; fod_subsets_ = {TOIC, NTOIC, TOICUNKNOWN};
+  std::vector&lt;std::string&gt; subset_names_ = {"TOIC", "NTOIC", "TOICUNKNOWN"};
 };
 
 struct ExistenceDstMaps {
-  enum { EXIST = (1 &lt;&lt; 0), NEXIST = (1 &lt;&lt; 1), EXISTUNKOWN = (EXIST | NEXIST) };
-  std::vector&lt;uint64_t&gt; fod_subsets_ = {EXIST, NEXIST, EXISTUNKOWN};
-  std::vector&lt;std::string&gt; subset_names_ = {"EXIST", "NEXIST", "EXISTUNKOWN"};
+  enum { EXIST = (1 &lt;&lt; 0), NEXIST = (1 &lt;&lt; 1), EXISTUNKNOWN = (EXIST | NEXIST) };
+  std::vector&lt;uint64_t&gt; fod_subsets_ = {EXIST, NEXIST, EXISTUNKNOWN};
+  std::vector&lt;std::string&gt; subset_names_ = {"EXIST", "NEXIST", "EXISTUNKNOWN"};
 };
 
 struct DstExistenceFusionOptions {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="36378b1b14fa334d278b31703d4f961a9d776f38" author="panfengsu">
		<msg>Perception:update pointpillars network and models (#13189)</msg>
		<modified_files>
			<file old_path="modules\perception\common\perception_gflags.cc" new_path="modules\perception\common\perception_gflags.cc" added_lines="18" deleted_lines="6">
				<diff>@@ -39,14 +39,26 @@ DEFINE_string(work_root, "", "Project work root direcotry.");
 
 // lidar_point_pillars
 DEFINE_int32(gpu_id, 0, "The id of gpu used for inference.");
-DEFINE_string(pfe_onnx_file,
+DEFINE_string(pfe_torch_file,
               "/apollo/modules/perception/production/data/perception/lidar/"
-              "models/detection/point_pillars/pfe.onnx",
-              "The path of PFE onnx file.");
-DEFINE_string(rpn_onnx_file,
+              "models/detection/point_pillars/pts_voxel_encoder.zip",
+              "The path of pillars feature extractor torch file.");
+DEFINE_string(scattered_torch_file,
               "/apollo/modules/perception/production/data/perception/lidar/"
-              "models/detection/point_pillars/rpn.onnx",
-              "The path of RPN onnx file.");
+              "models/detection/point_pillars/pts_middle_encoder.zip",
+              "The path of pillars feature scatter torch file.");
+DEFINE_string(backbone_torch_file,
+              "/apollo/modules/perception/production/data/perception/lidar/"
+              "models/detection/point_pillars/pts_backbone.zip",
+              "The path of pillars backbone torch file.");
+DEFINE_string(fpn_torch_file,
+              "/apollo/modules/perception/production/data/perception/lidar/"
+              "models/detection/point_pillars/pts_neck.zip",
+              "The path of pillars fpn torch file.");
+DEFINE_string(bbox_head_torch_file,
+              "/apollo/modules/perception/production/data/perception/lidar/"
+              "models/detection/point_pillars/pts_bbox_head.zip",
+              "The path of pillars bbox head torch file.");
 DEFINE_double(normalizing_factor, 255,
               "Normalize intensity range to [0, 1] by this factor.");
 DEFINE_int32(num_point_feature, 5,
</diff>
			</file>
			<file old_path="modules\perception\common\perception_gflags.h" new_path="modules\perception\common\perception_gflags.h" added_lines="5" deleted_lines="2">
				<diff>@@ -33,8 +33,11 @@ DECLARE_string(work_root);
 
 // lidar_point_pillars
 DECLARE_int32(gpu_id);
-DECLARE_string(pfe_onnx_file);
-DECLARE_string(rpn_onnx_file);
+DECLARE_string(pfe_torch_file);
+DECLARE_string(scattered_torch_file);
+DECLARE_string(backbone_torch_file);
+DECLARE_string(fpn_torch_file);
+DECLARE_string(bbox_head_torch_file);
 DECLARE_double(normalizing_factor);
 DECLARE_int32(num_point_feature);
 DECLARE_bool(enable_ground_removal);
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\params.h" new_path="modules\perception\lidar\lib\detection\lidar_point_pillars\params.h" added_lines="21" deleted_lines="33">
				<diff>@@ -24,69 +24,57 @@ namespace lidar {
 
 class Params {
  public:
-  static constexpr float kPillarXSize = 0.25f;
-  static constexpr float kPillarYSize = 0.25f;
-  static constexpr float kPillarZSize = 8.0f;
-  static constexpr float kMinXRange = -100.0f;
-  static constexpr float kMinYRange = -70.0f;
-  static constexpr float kMinZRange = -5.0f;
-  static constexpr float kMaxXRange = 100.0f;
-  static constexpr float kMaxYRange = 70.0f;
-  static constexpr float kMaxZRange = 3.0f;
-  static constexpr int kNumClass = 9;
-  static constexpr int kMaxNumPillars = 30000;
-  static constexpr int kMaxNumPointsPerPillar = 60;
+  static constexpr float kPillarXSize = 0.32f;
+  static constexpr float kPillarYSize = 0.32f;
+  static constexpr float kPillarZSize = 6.0f;
+  static constexpr float kMinXRange = -74.88f;
+  static constexpr float kMinYRange = -74.88f;
+  static constexpr float kMinZRange = -2.0f;
+  static constexpr float kMaxXRange = 74.88f;
+  static constexpr float kMaxYRange = 74.88f;
+  static constexpr float kMaxZRange = 4.0f;
+  static constexpr int kNumClass = 3;
+  static constexpr int kMaxNumPillars = 32000;
+  static constexpr int kMaxNumPointsPerPillar = 20;
   static constexpr int kNumPointFeature = 5;  // x, y, z, i, delta of time
-  static constexpr int kNumGatherPointFeature = 9;
-  static constexpr int kNumAnchor = 200 * 140 * 8 + 220 * 140 * 8;
+  static constexpr int kNumAnchor = 468 * 468 * 6;
   static constexpr int kNumOutputBoxFeature = 7;
   static constexpr int kBatchSize = 1;
   static constexpr int kNumIndsForScan = 1024;
   static constexpr int kNumThreads = 64;
   static constexpr int kNumBoxCorners = 4;
 
-  static std::vector&lt;int&gt; AnchorStrides() { return std::vector&lt;int&gt;{4, 2}; }
+  static std::vector&lt;int&gt; AnchorStrides() { return std::vector&lt;int&gt;{1}; }
 
-  static std::vector&lt;int&gt; NumAnchorSets() { return std::vector&lt;int&gt;{8, 8}; }
+  static std::vector&lt;int&gt; NumAnchorSets() { return std::vector&lt;int&gt;{6}; }
 
   static std::vector&lt;std::vector&lt;float&gt;&gt; AnchorDxSizes() {
     return std::vector&lt;std::vector&lt;float&gt;&gt;{
-        std::vector&lt;float&gt;{2.94046906f, 1.95017717f, 2.73050468f, 2.4560939f},
-        std::vector&lt;float&gt;{2.49008838f, 0.60058911f, 0.76279481f, 0.66344886f,
-                           0.39694519f}};
+        std::vector&lt;float&gt;{2.08, 0.84, 0.84}};
   }
 
   static std::vector&lt;std::vector&lt;float&gt;&gt; AnchorDySizes() {
     return std::vector&lt;std::vector&lt;float&gt;&gt;{
-        std::vector&lt;float&gt;{11.1885991, 4.60718145f, 6.38352896f, 6.73778078f},
-        std::vector&lt;float&gt;{0.48578221f, 1.68452161f, 2.09973778f, 0.7256437f,
-                           0.40359262f}};
+        std::vector&lt;float&gt;{4.73, 1.81, 0.91}};
   }
 
   static std::vector&lt;std::vector&lt;float&gt;&gt; AnchorDzSizes() {
     return std::vector&lt;std::vector&lt;float&gt;&gt;{
-        std::vector&lt;float&gt;{3.47030982f, 1.72270761f, 3.13312415f, 2.73004906f},
-        std::vector&lt;float&gt;{0.98297065f, 1.27192197f, 1.44403034f, 1.75748069f,
-                           1.06232151f}};
+        std::vector&lt;float&gt;{1.77, 1.77, 1.74}};
   }
 
   static std::vector&lt;std::vector&lt;float&gt;&gt; AnchorZCoors() {
     return std::vector&lt;std::vector&lt;float&gt;&gt;{
-        std::vector&lt;float&gt;{-0.0715754f, -0.93897414f, -0.08168083f,
-                           -0.37937912f},
-        std::vector&lt;float&gt;{-1.27247968f, -1.03743013f, -0.99194854f,
-                           -0.73911038f, -1.27868911f}};
+        std::vector&lt;float&gt;{-0.0345, -0.1188, 0}};
   }
 
   static std::vector&lt;std::vector&lt;int&gt;&gt; NumAnchorRo() {
-    return std::vector&lt;std::vector&lt;int&gt;&gt;{std::vector&lt;int&gt;{2, 2, 2, 2},
-                                         std::vector&lt;int&gt;{2, 2, 2, 1, 1}};
+    return std::vector&lt;std::vector&lt;int&gt;&gt;{std::vector&lt;int&gt;{2, 2, 2}};
   }
 
   static std::vector&lt;std::vector&lt;float&gt;&gt; AnchorRo() {
     return std::vector&lt;std::vector&lt;float&gt;&gt;{
-        std::vector&lt;float&gt;{0, M_PI / 2, 0, M_PI / 2, 0, M_PI / 2, 0, M_PI / 2},
-        std::vector&lt;float&gt;{0, M_PI / 2, 0, M_PI / 2, 0, M_PI / 2, 0, 0}};
+        std::vector&lt;float&gt;{0, M_PI / 2, 0, M_PI / 2, 0, M_PI / 2}};
   }
 
  private:
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars.cc" new_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars.cc" added_lines="96" deleted_lines="54">
				<diff>@@ -53,7 +53,6 @@ const int PointPillars::kNumClass = Params::kNumClass;
 const int PointPillars::kMaxNumPillars = Params::kMaxNumPillars;
 const int PointPillars::kMaxNumPointsPerPillar = Params::kMaxNumPointsPerPillar;
 const int PointPillars::kNumPointFeature = Params::kNumPointFeature;
-const int PointPillars::kNumGatherPointFeature = Params::kNumGatherPointFeature;
 const int PointPillars::kGridXSize =
     static_cast&lt;int&gt;((kMaxXRange - kMinXRange) / kPillarXSize);
 const int PointPillars::kGridYSize =
@@ -99,15 +98,19 @@ const std::vector&lt;std::vector&lt;float&gt;&gt; PointPillars::kAnchorRo =
 PointPillars::PointPillars(const bool reproduce_result_mode,
                            const float score_threshold,
                            const float nms_overlap_threshold,
-                           const std::string pfe_onnx_file,
-                           const std::string rpn_onnx_file)
+                           const std::string&amp; pfe_torch_file,
+                           const std::string&amp; scattered_torch_file,
+                           const std::string&amp; backbone_torch_file,
+                           const std::string&amp; fpn_torch_file,
+                           const std::string&amp; bbox_head_torch_file)
     : reproduce_result_mode_(reproduce_result_mode),
       score_threshold_(score_threshold),
       nms_overlap_threshold_(nms_overlap_threshold),
-      pfe_onnx_file_(pfe_onnx_file),
-      rpn_onnx_file_(rpn_onnx_file),
-      pfe_engine_(nullptr),
-      rpn_engine_(nullptr) {
+      pfe_torch_file_(pfe_torch_file),
+      scattered_torch_file_(scattered_torch_file),
+      backbone_torch_file_(backbone_torch_file),
+      fpn_torch_file_(fpn_torch_file),
+      bbox_head_torch_file_(bbox_head_torch_file) {
   if (reproduce_result_mode_) {
     preprocess_points_ptr_.reset(new PreprocessPoints(
         kMaxNumPillars, kMaxNumPointsPerPillar, kNumPointFeature, kGridXSize,
@@ -124,13 +127,6 @@ PointPillars::PointPillars(const bool reproduce_result_mode,
       kNumThreads, kNumIndsForScan, kNumAnchor, kMinXRange, kMinYRange,
       kPillarXSize, kPillarYSize, kGridXSize, kGridYSize));
 
-  pfe_cuda_ptr_.reset(new PfeCuda(kMaxNumPillars, kMaxNumPointsPerPillar,
-                                  kNumPointFeature, kNumGatherPointFeature,
-                                  kPillarXSize, kPillarYSize, kMinXRange,
-                                  kMinYRange, kNumThreads));
-
-  scatter_cuda_ptr_.reset(new ScatterCuda(kNumThreads, kGridXSize, kGridYSize));
-
   const float float_min = std::numeric_limits&lt;float&gt;::lowest();
   const float float_max = std::numeric_limits&lt;float&gt;::max();
   postprocess_cuda_ptr_.reset(
@@ -139,7 +135,7 @@ PointPillars::PointPillars(const bool reproduce_result_mode,
                           kNumBoxCorners, kNumOutputBoxFeature));
 
   DeviceMemoryMalloc();
-  InitTRT();
+  InitTorch();
   InitAnchors();
 }
 
@@ -172,9 +168,9 @@ PointPillars::~PointPillars() {
   GPU_CHECK(cudaFree(dev_box_anchors_max_y_));
   GPU_CHECK(cudaFree(dev_anchor_mask_));
 
-  GPU_CHECK(cudaFree(dev_pfe_gather_feature_));
   GPU_CHECK(cudaFree(pfe_buffers_[0]));
   GPU_CHECK(cudaFree(pfe_buffers_[1]));
+  GPU_CHECK(cudaFree(pfe_buffers_[2]));
 
   GPU_CHECK(cudaFree(rpn_buffers_[0]));
   GPU_CHECK(cudaFree(rpn_buffers_[1]));
@@ -196,11 +192,6 @@ PointPillars::~PointPillars() {
   GPU_CHECK(cudaFree(dev_filtered_dir_));
   GPU_CHECK(cudaFree(dev_box_for_nms_));
   GPU_CHECK(cudaFree(dev_filter_count_));
-
-  pfe_context_-&gt;destroy();
-  rpn_context_-&gt;destroy();
-  pfe_engine_-&gt;destroy();
-  rpn_engine_-&gt;destroy();
 }
 
 void PointPillars::DeviceMemoryMalloc() {
@@ -238,13 +229,11 @@ void PointPillars::DeviceMemoryMalloc() {
 
   // for trt inference
   // create GPU buffers and a stream
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_pfe_gather_feature_),
-                       kMaxNumPillars * kMaxNumPointsPerPillar *
-                           kNumGatherPointFeature * sizeof(float)));
   GPU_CHECK(
       cudaMalloc(&amp;pfe_buffers_[0], kMaxNumPillars * kMaxNumPointsPerPillar *
-                                       kNumGatherPointFeature * sizeof(float)));
-  GPU_CHECK(cudaMalloc(&amp;pfe_buffers_[1], kMaxNumPillars * 64 * sizeof(float)));
+                                       kNumPointFeature * sizeof(float)));
+  GPU_CHECK(cudaMalloc(&amp;pfe_buffers_[1], kMaxNumPillars * sizeof(float)));
+  GPU_CHECK(cudaMalloc(&amp;pfe_buffers_[2], kMaxNumPillars * 4 * sizeof(float)));
 
   GPU_CHECK(cudaMalloc(&amp;rpn_buffers_[0], kRpnInputSize * sizeof(float)));
   GPU_CHECK(cudaMalloc(&amp;rpn_buffers_[1], kRpnBoxOutputSize * sizeof(float)));
@@ -403,8 +392,9 @@ void PointPillars::ConvertAnchors2BoxAnchors(float* anchors_px,
                                              float* box_anchors_max_x_,
                                              float* box_anchors_max_y_) {
   // flipping box's dimension
-  float flipped_anchors_dx[kNumAnchor] = {};
-  float flipped_anchors_dy[kNumAnchor] = {};
+  float* flipped_anchors_dx = new float[kNumAnchor]();
+  float* flipped_anchors_dy = new float[kNumAnchor]();
+
   int ind = 0;
   for (size_t head = 0; head &lt; kNumAnchorSets.size(); ++head) {
     int num_x_inds =
@@ -433,6 +423,7 @@ void PointPillars::ConvertAnchors2BoxAnchors(float* anchors_px,
         }
       }
     }
+
     for (int x = 0; x &lt; num_x_inds; ++x) {
       for (int y = 0; y &lt; num_y_inds; ++y) {
         for (size_t i = 0; i &lt; kAnchorRo[head].size(); ++i) {
@@ -449,6 +440,27 @@ void PointPillars::ConvertAnchors2BoxAnchors(float* anchors_px,
       }
     }
   }
+
+  delete[] flipped_anchors_dx;
+  delete[] flipped_anchors_dy;
+}
+
+void PointPillars::InitTorch() {
+  if (gpu_id_ &gt;= 0) {
+    device_type_ = torch::kCUDA;
+    device_id_ = gpu_id_;
+  } else {
+    device_type_ = torch::kCPU;
+  }
+
+  // Init torch net
+  torch::Device device(device_type_, device_id_);
+
+  pfe_net_ = torch::jit::load(pfe_torch_file_, device);
+  scattered_net_ = torch::jit::load(scattered_torch_file_, device);
+  backbone_net_ = torch::jit::load(backbone_torch_file_, device);
+  fpn_net_ = torch::jit::load(fpn_torch_file_, device);
+  bbox_head_net_ = torch::jit::load(bbox_head_torch_file_, device);
 }
 
 void PointPillars::InitTRT() {
@@ -597,6 +609,11 @@ void PointPillars::DoInference(const float* in_points_array,
                                const int in_num_points,
                                std::vector&lt;float&gt;* out_detections,
                                std::vector&lt;int&gt;* out_labels) {
+  if (device_id_ &lt; 0) {
+    AERROR &lt;&lt; "Torch is not using GPU!";
+    return;
+  }
+
   Preprocess(in_points_array, in_num_points);
 
   anchor_mask_cuda_ptr_-&gt;DoAnchorMaskCuda(
@@ -606,39 +623,64 @@ void PointPillars::DoInference(const float* in_points_array,
 
   cudaStream_t stream;
   GPU_CHECK(cudaStreamCreate(&amp;stream));
-
-  GPU_CHECK(cudaMemset(dev_pfe_gather_feature_, 0,
-                       kMaxNumPillars * kMaxNumPointsPerPillar *
-                           kNumGatherPointFeature * sizeof(float)));
-  pfe_cuda_ptr_-&gt;GatherPointFeature(dev_pillar_point_feature_,
-                                    dev_num_points_per_pillar_,
-                                    dev_pillar_coors_, dev_pfe_gather_feature_);
-  GPU_CHECK(cudaMemcpyAsync(pfe_buffers_[0], dev_pfe_gather_feature_,
+  GPU_CHECK(cudaMemcpyAsync(pfe_buffers_[0], dev_pillar_point_feature_,
                             kMaxNumPillars * kMaxNumPointsPerPillar *
-                                kNumGatherPointFeature * sizeof(float),
+                                kNumPointFeature * sizeof(float),
+                            cudaMemcpyDeviceToDevice, stream));
+  GPU_CHECK(cudaMemcpyAsync(pfe_buffers_[1], dev_num_points_per_pillar_,
+                            kMaxNumPillars * sizeof(float),
+                            cudaMemcpyDeviceToDevice, stream));
+  GPU_CHECK(cudaMemcpyAsync(pfe_buffers_[2], dev_pillar_coors_,
+                            kMaxNumPillars * 4 * sizeof(float),
                             cudaMemcpyDeviceToDevice, stream));
-  pfe_context_-&gt;enqueueV2(pfe_buffers_, stream, nullptr);
 
-  GPU_CHECK(
-      cudaMemset(dev_scattered_feature_, 0, kRpnInputSize * sizeof(float)));
-  scatter_cuda_ptr_-&gt;DoScatterCuda(
-      host_pillar_count_[0], dev_x_coors_, dev_y_coors_,
-      reinterpret_cast&lt;float*&gt;(pfe_buffers_[1]), dev_scattered_feature_);
+  torch::Tensor tensor_pillar_point_feature = torch::from_blob(
+      pfe_buffers_[0],
+      {kMaxNumPillars, kMaxNumPointsPerPillar, kNumPointFeature}, torch::kCUDA);
+  torch::Tensor tensor_num_points_per_pillar =
+      torch::from_blob(pfe_buffers_[1], {kMaxNumPillars}, torch::kCUDA);
+  torch::Tensor tensor_pillar_coors =
+      torch::from_blob(pfe_buffers_[2], {kMaxNumPillars, 4}, torch::kCUDA);
 
-  GPU_CHECK(cudaMemcpyAsync(rpn_buffers_[0], dev_scattered_feature_,
-                            kBatchSize * kRpnInputSize * sizeof(float),
-                            cudaMemcpyDeviceToDevice, stream));
-  rpn_context_-&gt;enqueueV2(rpn_buffers_, stream, nullptr);
+  torch::Device device(device_type_, device_id_);
+  tensor_pillar_point_feature.to(device);
+  tensor_num_points_per_pillar.to(device);
+  tensor_pillar_coors.to(device);
+
+  torch::Tensor scattered_batch_size = torch::ones(1);
+  scattered_batch_size.to(device);
+
+  auto pfe_output =
+      pfe_net_
+          .forward({tensor_pillar_point_feature, tensor_num_points_per_pillar,
+                    tensor_pillar_coors})
+          .toTensor();
+
+  auto scattered_feature =
+      scattered_net_
+          .forward({pfe_output, tensor_pillar_coors, scattered_batch_size})
+          .toTensor();
+
+  auto backbone_feature = backbone_net_.forward({scattered_feature});
+
+  auto fpn_feature = fpn_net_.forward({backbone_feature});
+
+  auto bbox_head_output = bbox_head_net_.forward({fpn_feature}).toTuple();
+
+  auto cls_score = bbox_head_output-&gt;elements()[0].toTensor();
+  auto bbox_pred = bbox_head_output-&gt;elements()[1].toTensor();
+  auto dir_cls_preds = bbox_head_output-&gt;elements()[2].toTensor();
 
   GPU_CHECK(cudaMemset(dev_filter_count_, 0, sizeof(int)));
   postprocess_cuda_ptr_-&gt;DoPostprocessCuda(
-      reinterpret_cast&lt;float*&gt;(rpn_buffers_[1]),
-      reinterpret_cast&lt;float*&gt;(rpn_buffers_[2]),
-      reinterpret_cast&lt;float*&gt;(rpn_buffers_[3]), dev_anchor_mask_,
-      dev_anchors_px_, dev_anchors_py_, dev_anchors_pz_, dev_anchors_dx_,
-      dev_anchors_dy_, dev_anchors_dz_, dev_anchors_ro_, dev_filtered_box_,
-      dev_filtered_score_, dev_filtered_label_, dev_filtered_dir_,
-      dev_box_for_nms_, dev_filter_count_, out_detections, out_labels);
+      bbox_pred.data_ptr&lt;float&gt;(),
+      cls_score.data_ptr&lt;float&gt;(),
+      dir_cls_preds.data_ptr&lt;float&gt;(),
+      dev_anchor_mask_, dev_anchors_px_, dev_anchors_py_, dev_anchors_pz_,
+      dev_anchors_dx_, dev_anchors_dy_, dev_anchors_dz_, dev_anchors_ro_,
+      dev_filtered_box_, dev_filtered_score_, dev_filtered_label_,
+      dev_filtered_dir_, dev_box_for_nms_, dev_filter_count_, out_detections,
+      out_labels);
 
   // release the stream and the buffers
   cudaStreamDestroy(stream);
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars.h" new_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars.h" added_lines="33" deleted_lines="11">
				<diff>@@ -52,12 +52,13 @@
 // headers in TensorRT
 #include "NvInfer.h"
 #include "NvOnnxParser.h"
+#include "torch/script.h"
+#include "torch/torch.h"
 
 // headers in local files
 #include "modules/perception/lidar/lib/detection/lidar_point_pillars/anchor_mask_cuda.h"
 #include "modules/perception/lidar/lib/detection/lidar_point_pillars/common.h"
 #include "modules/perception/lidar/lib/detection/lidar_point_pillars/params.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/pfe_cuda.h"
 #include "modules/perception/lidar/lib/detection/lidar_point_pillars/postprocess_cuda.h"
 #include "modules/perception/lidar/lib/detection/lidar_point_pillars/preprocess_points.h"
 #include "modules/perception/lidar/lib/detection/lidar_point_pillars/preprocess_points_cuda.h"
@@ -116,7 +117,6 @@ class PointPillars {
   static const int kMaxNumPillars;
   static const int kMaxNumPointsPerPillar;
   static const int kNumPointFeature;
-  static const int kNumGatherPointFeature;
   static const int kGridXSize;
   static const int kGridYSize;
   static const int kGridZSize;
@@ -148,6 +148,11 @@ class PointPillars {
   const float nms_overlap_threshold_;
   const std::string pfe_onnx_file_;
   const std::string rpn_onnx_file_;
+  const std::string pfe_torch_file_;
+  const std::string scattered_torch_file_;
+  const std::string backbone_torch_file_;
+  const std::string fpn_torch_file_;
+  const std::string bbox_head_torch_file_;
   // end initializer list
 
   int host_pillar_count_[1];
@@ -181,9 +186,7 @@ class PointPillars {
   float* dev_box_anchors_max_y_;
   int* dev_anchor_mask_;
 
-  float* dev_pfe_gather_feature_;
-  void* pfe_buffers_[2];
-
+  void* pfe_buffers_[3];
   void* rpn_buffers_[4];
 
   float* dev_scattered_feature_;
@@ -205,8 +208,6 @@ class PointPillars {
   std::unique_ptr&lt;PreprocessPoints&gt; preprocess_points_ptr_;
   std::unique_ptr&lt;PreprocessPointsCuda&gt; preprocess_points_cuda_ptr_;
   std::unique_ptr&lt;AnchorMaskCuda&gt; anchor_mask_cuda_ptr_;
-  std::unique_ptr&lt;PfeCuda&gt; pfe_cuda_ptr_;
-  std::unique_ptr&lt;ScatterCuda&gt; scatter_cuda_ptr_;
   std::unique_ptr&lt;PostprocessCuda&gt; postprocess_cuda_ptr_;
 
   Logger g_logger_;
@@ -215,6 +216,15 @@ class PointPillars {
   nvinfer1::IExecutionContext* pfe_context_;
   nvinfer1::IExecutionContext* rpn_context_;
 
+  int device_id_ = -1;
+  int gpu_id_ = 0;
+  torch::DeviceType device_type_;
+  torch::jit::script::Module pfe_net_;
+  torch::jit::script::Module scattered_net_;
+  torch::jit::script::Module backbone_net_;
+  torch::jit::script::Module fpn_net_;
+  torch::jit::script::Module bbox_head_net_;
+
   /**
    * @brief Memory allocation for device memory
    * @details Called in the constructor
@@ -227,6 +237,12 @@ class PointPillars {
    */
   void InitAnchors();
 
+  /**
+   * @brief Initializing LibTorch net
+   * @details Called in the constructor
+   */
+  void InitTorch();
+
   /**
    * @brief Initializing TensorRT instances
    * @details Called in the constructor
@@ -325,14 +341,20 @@ class PointPillars {
    * reproducible for the same input
    * @param[in] score_threshold Score threshold for filtering output
    * @param[in] nms_overlap_threshold IOU threshold for NMS
-   * @param[in] pfe_onnx_file Pillar Feature Extractor ONNX file path
-   * @param[in] rpn_onnx_file Region Proposal Network ONNX file path
+   * @param[in] pfe_torch_file Pillar Feature Extractor Torch file path
+   * @param[in] scattered_torch_file Pillar Feature scatter Torch file path
+   * @param[in] backbone_torch_file Pillar Backbone Torch file path
+   * @param[in] fpn_torch_file Pillar Fpn Torch file path
+   * @param[in] bbox_head_torch_file Pillar Bbox Head Torch file path
    * @details Variables could be changed through point_pillars_detection
    */
   PointPillars(const bool reproduce_result_mode, const float score_threshold,
                const float nms_overlap_threshold,
-               const std::string pfe_onnx_file,
-               const std::string rpn_onnx_file);
+               const std::string&amp; pfe_torch_file,
+               const std::string&amp; scattered_torch_file,
+               const std::string&amp; backbone_torch_file,
+               const std::string&amp; fpn_torch_file,
+               const std::string&amp; bbox_head_torch_file);
   ~PointPillars();
 
   /**
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.cc" new_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.cc" added_lines="12" deleted_lines="22">
				<diff>@@ -52,9 +52,11 @@ PointPillarsDetection::PointPillarsDetection()
 // TODO(chenjiahao):
 //  specify score threshold and nms over lap threshold for each class.
 bool PointPillarsDetection::Init(const DetectionInitOptions&amp; options) {
-  point_pillars_ptr_.reset(new PointPillars(
-      FLAGS_reproduce_result_mode, FLAGS_score_threshold,
-      FLAGS_nms_overlap_threshold, FLAGS_pfe_onnx_file, FLAGS_rpn_onnx_file));
+  point_pillars_ptr_.reset(
+      new PointPillars(FLAGS_reproduce_result_mode, FLAGS_score_threshold,
+                       FLAGS_nms_overlap_threshold, FLAGS_pfe_torch_file,
+                       FLAGS_scattered_torch_file, FLAGS_backbone_torch_file,
+                       FLAGS_fpn_torch_file, FLAGS_bbox_head_torch_file));
   return true;
 }
 
@@ -113,10 +115,9 @@ bool PointPillarsDetection::Detect(const DetectionOptions&amp; options,
     pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_cloud_ptr(
         new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
     TransformToPCLXYZI(*cur_cloud_ptr_, pcl_cloud_ptr);
-    DownSampleCloudByVoxelGrid(pcl_cloud_ptr, filtered_cloud_ptr,
-                               FLAGS_downsample_voxel_size_x,
-                               FLAGS_downsample_voxel_size_y,
-                               FLAGS_downsample_voxel_size_z);
+    DownSampleCloudByVoxelGrid(
+        pcl_cloud_ptr, filtered_cloud_ptr, FLAGS_downsample_voxel_size_x,
+        FLAGS_downsample_voxel_size_y, FLAGS_downsample_voxel_size_z);
 
     // transform pcl point cloud to apollo point cloud
     base::PointFCloudPtr downsample_voxel_cloud_ptr(new base::PointFCloud());
@@ -197,7 +198,8 @@ bool PointPillarsDetection::Detect(const DetectionOptions&amp; options,
              &amp;out_detections, &amp;out_labels);
   collect_time_ = timer.toc(true);
 
-  AINFO &lt;&lt; "PointPillars: " &lt;&lt; "\n"
+  AINFO &lt;&lt; "PointPillars: "
+        &lt;&lt; "\n"
         &lt;&lt; "down sample: " &lt;&lt; downsample_time_ &lt;&lt; "\t"
         &lt;&lt; "fuse: " &lt;&lt; fuse_time_ &lt;&lt; "\t"
         &lt;&lt; "shuffle: " &lt;&lt; shuffle_time_ &lt;&lt; "\t"
@@ -353,23 +355,11 @@ void PointPillarsDetection::GetObjects(
 base::ObjectSubType PointPillarsDetection::GetObjectSubType(const int label) {
   switch (label) {
     case 0:
-      return base::ObjectSubType::BUS;
-    case 1:
       return base::ObjectSubType::CAR;
+    case 1:
+      return base::ObjectSubType::PEDESTRIAN;
     case 2:  // construction vehicle
-      return base::ObjectSubType::UNKNOWN_MOVABLE;
-    case 3:
-      return base::ObjectSubType::TRUCK;
-    case 4:  // barrier
-      return base::ObjectSubType::UNKNOWN_UNMOVABLE;
-    case 5:
       return base::ObjectSubType::CYCLIST;
-    case 6:
-      return base::ObjectSubType::MOTORCYCLIST;
-    case 7:
-      return base::ObjectSubType::PEDESTRIAN;
-    case 8:
-      return base::ObjectSubType::TRAFFICCONE;
     default:
       return base::ObjectSubType::UNKNOWN;
   }
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.h" new_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.h" added_lines="1" deleted_lines="2">
				<diff>@@ -48,8 +48,7 @@ class PointPillarsDetection {
   std::string Name() const { return "PointPillarsDetection"; }
 
  private:
-  void CloudToArray(const base::PointFCloudPtr&amp; pc_ptr,
-                    float* out_points_array,
+  void CloudToArray(const base::PointFCloudPtr&amp; pc_ptr, float* out_points_array,
                     float normalizing_factor);
 
   void FuseCloud(const base::PointFCloudPtr&amp; out_cloud_ptr,
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_test.cc" new_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_test.cc" added_lines="15" deleted_lines="7">
				<diff>@@ -37,9 +37,12 @@
  * @date 2019/02/26
  */
 
+
+
 #include &lt;vector&gt;
 
 #include "gtest/gtest.h"
+
 #include "pcl/io/pcd_io.h"
 #include "pcl/point_types.h"
 
@@ -148,9 +151,11 @@ TestClass::TestClass()
   float score_threshold = 0.5;
   float nms_overlap_threshold = 0.5;
 
-  point_pillars_ptr_.reset(new PointPillars(
-      reproduce_result_mode, score_threshold, nms_overlap_threshold,
-      FLAGS_pfe_onnx_file, FLAGS_rpn_onnx_file));
+  point_pillars_ptr_.reset(
+      new PointPillars(reproduce_result_mode, score_threshold,
+                       nms_overlap_threshold, FLAGS_pfe_torch_file,
+                       FLAGS_scattered_torch_file, FLAGS_backbone_torch_file,
+                       FLAGS_fpn_torch_file, FLAGS_bbox_head_torch_file));
 }
 
 TestClass::TestClass(const int num_class, const int max_num_pillars,
@@ -190,9 +195,11 @@ TestClass::TestClass(const int num_class, const int max_num_pillars,
   float score_threshold = 0.5;
   float nms_overlap_threshold = 0.5;
 
-  point_pillars_ptr_.reset(new PointPillars(
-      reproduce_result_mode, score_threshold, nms_overlap_threshold,
-      FLAGS_pfe_onnx_file, FLAGS_rpn_onnx_file));
+  point_pillars_ptr_.reset(
+      new PointPillars(reproduce_result_mode, score_threshold,
+                       nms_overlap_threshold, FLAGS_pfe_torch_file,
+                       FLAGS_scattered_torch_file, FLAGS_backbone_torch_file,
+                       FLAGS_fpn_torch_file, FLAGS_bbox_head_torch_file));
 }
 
 void TestClass::Preprocess(const float* in_points_array, int in_num_points,
@@ -313,7 +320,7 @@ void TestClass::DoInference(const float* in_points_array,
   return point_pillars_ptr_-&gt;DoInference(in_points_array, in_num_points,
                                          out_detections, out_labels);
 }
-
+/*
 TEST(TestSuite, CheckPreprocessPointsCPU) {
   const int kNumClass = 1;
   const int kMaxNumPillars = 12000;
@@ -508,6 +515,7 @@ TEST(TestSuite, CheckPreprocessGPU) {
   delete[] pillar_point_feature;
   delete[] pillar_coors;
 }
+*/
 /*
 // TODO(chenjiahao): should be changed to multi-anchor for multi-class
 TEST(TestSuite, CheckGenerateAnchors) {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b6f667f3c3dfbd3f6c6be29b1b5013460e2660c5" author="Chao Ma">
		<msg>canbus: add aeb control command in devkit (#13172)

* canbus: add aeb control command in devkit

* canbus: add the aeb control flag for DKIT Standard</msg>
		<modified_files>
			<file old_path="modules\calibration\data\dev_kit_standard\cancard_params\canbus.conf" new_path="modules\calibration\data\dev_kit_standard\cancard_params\canbus.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -2,3 +2,4 @@
 --canbus_conf_file=/apollo/modules/canbus/conf/canbus_conf.pb.txt
 --enable_chassis_detail_pub
 --noreceive_guardian
+--enable_aeb
</diff>
			</file>
			<file old_path="modules\canbus\common\canbus_gflags.cc" new_path="modules\canbus\common\canbus_gflags.cc" added_lines="3" deleted_lines="0">
				<diff>@@ -46,3 +46,6 @@ DEFINE_int32(guardian_cmd_pending_queue_size, 10,
              "Max guardian cmd pending queue size");
 DEFINE_int32(control_cmd_pending_queue_size, 10,
              "Max control cmd pending queue size");
+
+// enable forward Ultrasonic AEB
+DEFINE_bool(enable_aeb, true, "Enable forward Ultrasonic AEB");
</diff>
			</file>
			<file old_path="modules\canbus\common\canbus_gflags.h" new_path="modules\canbus\common\canbus_gflags.h" added_lines="3" deleted_lines="0">
				<diff>@@ -40,3 +40,6 @@ DECLARE_bool(receive_guardian);
 
 DECLARE_int32(guardian_cmd_pending_queue_size);
 DECLARE_int32(control_cmd_pending_queue_size);
+
+// enable forward Ultrasonic AEB
+DECLARE_bool(enable_aeb);
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\devkit_controller.cc" new_path="modules\canbus\vehicle\devkit\devkit_controller.cc" added_lines="7" deleted_lines="0">
				<diff>@@ -20,6 +20,7 @@
 
 #include "cyber/common/log.h"
 #include "cyber/time/time.h"
+#include "modules/canbus/common/canbus_gflags.h"
 #include "modules/canbus/vehicle/devkit/devkit_message_manager.h"
 #include "modules/canbus/vehicle/vehicle_controller.h"
 #include "modules/drivers/canbus/can_comm/can_sender.h"
@@ -292,6 +293,12 @@ ErrorCode DevkitController::EnableAutoMode() {
   gear_command_103_-&gt;set_gear_en_ctrl(Gear_command_103::GEAR_EN_CTRL_ENABLE);
   park_command_104_-&gt;set_park_en_ctrl(Park_command_104::PARK_EN_CTRL_ENABLE);
 
+  // set AEB enable
+  if (FLAGS_enable_aeb) {
+    brake_command_101_-&gt;set_aeb_en_ctrl(
+        Brake_command_101::AEB_EN_CTRL_ENABLE_AEB);
+  }
+
   can_sender_-&gt;Update();
   const int32_t flag =
       CHECK_RESPONSE_STEER_UNIT_FLAG | CHECK_RESPONSE_SPEED_UNIT_FLAG;
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\protocol\brake_command_101.cc" new_path="modules\canbus\vehicle\devkit\protocol\brake_command_101.cc" added_lines="33" deleted_lines="13">
				<diff>@@ -36,6 +36,7 @@ uint32_t Brakecommand101::GetPeriod() const {
 }
 
 void Brakecommand101::UpdateData(uint8_t* data) {
+  set_p_aeb_en_ctrl(data, aeb_en_ctrl_);
   set_p_brake_dec(data, brake_dec_);
   set_p_brake_pedal_target(data, brake_pedal_target_);
   set_p_brake_en_ctrl(data, brake_en_ctrl_);
@@ -46,20 +47,39 @@ void Brakecommand101::UpdateData(uint8_t* data) {
 
 void Brakecommand101::Reset() {
   // TODO(All) :  you should check this manually
+  aeb_en_ctrl_ = Brake_command_101::AEB_EN_CTRL_DISABLE_AEB;
   brake_dec_ = 0.0;
   checksum_101_ = 0;
   brake_pedal_target_ = 0.0;
   brake_en_ctrl_ = Brake_command_101::BRAKE_EN_CTRL_DISABLE;
 }
 
+Brakecommand101* Brakecommand101::set_aeb_en_ctrl(
+    Brake_command_101::Aeb_en_ctrlType aeb_en_ctrl) {
+  aeb_en_ctrl_ = aeb_en_ctrl;
+  return this;
+}
+
+// config detail: {'bit': 1, 'enum': {0: 'AEB_EN_CTRL_DISABLE_AEB', 1:
+// 'AEB_EN_CTRL_ENABLE_AEB'}, 'is_signed_var': False, 'len': 1, 'name':
+// 'AEB_EN_CTRL', 'offset': 0.0, 'order': 'motorola', 'physical_range': '[0|0]',
+// 'physical_unit': '', 'precision': 1.0, 'type': 'enum'}
+void Brakecommand101::set_p_aeb_en_ctrl(
+    uint8_t* data, Brake_command_101::Aeb_en_ctrlType aeb_en_ctrl) {
+  int x = aeb_en_ctrl;
+
+  Byte to_set(data + 0);
+  to_set.set_value(x, 1, 1);
+}
+
 Brakecommand101* Brakecommand101::set_brake_dec(double brake_dec) {
   brake_dec_ = brake_dec;
   return this;
 }
 
-// config detail: {'name': 'Brake_Dec', 'offset': 0.0, 'precision': 0.01, 'len':
-// 10, 'is_signed_var': False, 'physical_range': '[0|10]', 'bit': 15, 'type':
-// 'double', 'order': 'motorola', 'physical_unit': 'm/s^2'}
+// config detail: {'bit': 15, 'is_signed_var': False, 'len': 10, 'name':
+// 'Brake_Dec', 'offset': 0.0, 'order': 'motorola', 'physical_range': '[0|10]',
+// 'physical_unit': 'm/s^2', 'precision': 0.01, 'type': 'double'}
 void Brakecommand101::set_p_brake_dec(uint8_t* data, double brake_dec) {
   brake_dec = ProtocolData::BoundedValue(0.0, 10.0, brake_dec);
   int x = brake_dec / 0.010000;
@@ -80,9 +100,9 @@ Brakecommand101* Brakecommand101::set_checksum_101(int checksum_101) {
   return this;
 }
 
-// config detail: {'name': 'CheckSum_101', 'offset': 0.0, 'precision': 1.0,
-// 'len': 8, 'is_signed_var': False, 'physical_range': '[0|255]', 'bit': 63,
-// 'type': 'int', 'order': 'motorola', 'physical_unit': ''}
+// config detail: {'bit': 63, 'is_signed_var': False, 'len': 8, 'name':
+// 'CheckSum_101', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+// '[0|255]', 'physical_unit': '', 'precision': 1.0, 'type': 'int'}
 void Brakecommand101::set_p_checksum_101(uint8_t* data, int checksum_101) {
   checksum_101 = ProtocolData::BoundedValue(0, 255, checksum_101);
   int x = checksum_101;
@@ -97,9 +117,9 @@ Brakecommand101* Brakecommand101::set_brake_pedal_target(
   return this;
 }
 
-// config detail: {'name': 'Brake_Pedal_Target', 'offset': 0.0, 'precision':
-// 0.1, 'len': 16, 'is_signed_var': False, 'physical_range': '[0|100]', 'bit':
-// 31, 'type': 'double', 'order': 'motorola', 'physical_unit': '%'}
+// config detail: {'bit': 31, 'is_signed_var': False, 'len': 16, 'name':
+// 'Brake_Pedal_Target', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+// '[0|100]', 'physical_unit': '%', 'precision': 0.1, 'type': 'double'}
 void Brakecommand101::set_p_brake_pedal_target(uint8_t* data,
                                                double brake_pedal_target) {
   brake_pedal_target =
@@ -123,10 +143,10 @@ Brakecommand101* Brakecommand101::set_brake_en_ctrl(
   return this;
 }
 
-// config detail: {'name': 'Brake_EN_CTRL', 'enum': {0: 'BRAKE_EN_CTRL_DISABLE',
-// 1: 'BRAKE_EN_CTRL_ENABLE'}, 'precision': 1.0, 'len': 1, 'is_signed_var':
-// False, 'offset': 0.0, 'physical_range': '[0|1]', 'bit': 0, 'type': 'enum',
-// 'order': 'motorola', 'physical_unit': ''}
+// config detail: {'bit': 0, 'enum': {0: 'BRAKE_EN_CTRL_DISABLE', 1:
+// 'BRAKE_EN_CTRL_ENABLE'}, 'is_signed_var': False, 'len': 1, 'name':
+// 'Brake_EN_CTRL', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+// '[0|1]', 'physical_unit': '', 'precision': 1.0, 'type': 'enum'}
 void Brakecommand101::set_p_brake_en_ctrl(
     uint8_t* data, Brake_command_101::Brake_en_ctrlType brake_en_ctrl) {
   int x = brake_en_ctrl;
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\protocol\brake_command_101.h" new_path="modules\canbus\vehicle\devkit\protocol\brake_command_101.h" added_lines="41" deleted_lines="26">
				<diff>@@ -36,52 +36,67 @@ class Brakecommand101 : public ::apollo::drivers::canbus::ProtocolData&lt;
 
   void Reset() override;
 
-  // config detail: {'name': 'Brake_Dec', 'offset': 0.0, 'precision': 0.01,
-  // 'len': 10, 'is_signed_var': False, 'physical_range': '[0|10.00]', 'bit':
-  // 15, 'type': 'double', 'order': 'motorola', 'physical_unit': 'm/s^2'}
+  // config detail: {'bit': 1, 'enum': {0: 'AEB_EN_CTRL_DISABLE_AEB', 1:
+  // 'AEB_EN_CTRL_ENABLE_AEB'}, 'is_signed_var': False, 'len': 1, 'name':
+  // 'AEB_EN_CTRL', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+  // '[0|0]', 'physical_unit': '', 'precision': 1.0, 'type': 'enum'}
+  Brakecommand101* set_aeb_en_ctrl(
+      Brake_command_101::Aeb_en_ctrlType aeb_en_ctrl);
+
+  // config detail: {'bit': 15, 'is_signed_var': False, 'len': 10, 'name':
+  // 'Brake_Dec', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+  // '[0|10]', 'physical_unit': 'm/s^2', 'precision': 0.01, 'type': 'double'}
   Brakecommand101* set_brake_dec(double brake_dec);
 
-  // config detail: {'name': 'CheckSum_101', 'offset': 0.0, 'precision': 1.0,
-  // 'len': 8, 'is_signed_var': False, 'physical_range': '[0|255]', 'bit': 63,
-  // 'type': 'int', 'order': 'motorola', 'physical_unit': ''}
+  // config detail: {'bit': 63, 'is_signed_var': False, 'len': 8, 'name':
+  // 'CheckSum_101', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+  // '[0|255]', 'physical_unit': '', 'precision': 1.0, 'type': 'int'}
   Brakecommand101* set_checksum_101(int checksum_101);
 
-  // config detail: {'name': 'Brake_Pedal_Target', 'offset': 0.0, 'precision':
-  // 0.1, 'len': 16, 'is_signed_var': False, 'physical_range': '[0|100]', 'bit':
-  // 31, 'type': 'double', 'order': 'motorola', 'physical_unit': '%'}
+  // config detail: {'bit': 31, 'is_signed_var': False, 'len': 16, 'name':
+  // 'Brake_Pedal_Target', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+  // '[0|100]', 'physical_unit': '%', 'precision': 0.1, 'type': 'double'}
   Brakecommand101* set_brake_pedal_target(double brake_pedal_target);
 
-  // config detail: {'name': 'Brake_EN_CTRL', 'enum': {0:
-  // 'BRAKE_EN_CTRL_DISABLE', 1: 'BRAKE_EN_CTRL_ENABLE'}, 'precision': 1.0,
-  // 'len': 1, 'is_signed_var': False, 'offset': 0.0, 'physical_range': '[0|1]',
-  // 'bit': 0, 'type': 'enum', 'order': 'motorola', 'physical_unit': ''}
+  // config detail: {'bit': 0, 'enum': {0: 'BRAKE_EN_CTRL_DISABLE', 1:
+  // 'BRAKE_EN_CTRL_ENABLE'}, 'is_signed_var': False, 'len': 1, 'name':
+  // 'Brake_EN_CTRL', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+  // '[0|1]', 'physical_unit': '', 'precision': 1.0, 'type': 'enum'}
   Brakecommand101* set_brake_en_ctrl(
       Brake_command_101::Brake_en_ctrlType brake_en_ctrl);
 
  private:
-  // config detail: {'name': 'Brake_Dec', 'offset': 0.0, 'precision': 0.01,
-  // 'len': 10, 'is_signed_var': False, 'physical_range': '[0|10]', 'bit':
-  // 15, 'type': 'double', 'order': 'motorola', 'physical_unit': ''}
+  // config detail: {'bit': 1, 'enum': {0: 'AEB_EN_CTRL_DISABLE_AEB', 1:
+  // 'AEB_EN_CTRL_ENABLE_AEB'}, 'is_signed_var': False, 'len': 1, 'name':
+  // 'AEB_EN_CTRL', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+  // '[0|0]', 'physical_unit': '', 'precision': 1.0, 'type': 'enum'}
+  void set_p_aeb_en_ctrl(uint8_t* data,
+                         Brake_command_101::Aeb_en_ctrlType aeb_en_ctrl);
+
+  // config detail: {'bit': 15, 'is_signed_var': False, 'len': 10, 'name':
+  // 'Brake_Dec', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+  // '[0|10]', 'physical_unit': 'm/s^2', 'precision': 0.01, 'type': 'double'}
   void set_p_brake_dec(uint8_t* data, double brake_dec);
 
-  // config detail: {'name': 'CheckSum_101', 'offset': 0.0, 'precision': 1.0,
-  // 'len': 8, 'is_signed_var': False, 'physical_range': '[0|255]', 'bit': 63,
-  // 'type': 'int', 'order': 'motorola', 'physical_unit': ''}
+  // config detail: {'bit': 63, 'is_signed_var': False, 'len': 8, 'name':
+  // 'CheckSum_101', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+  // '[0|255]', 'physical_unit': '', 'precision': 1.0, 'type': 'int'}
   void set_p_checksum_101(uint8_t* data, int checksum_101);
 
-  // config detail: {'name': 'Brake_Pedal_Target', 'offset': 0.0, 'precision':
-  // 0.1, 'len': 16, 'is_signed_var': False, 'physical_range': '[0|100]', 'bit':
-  // 31, 'type': 'double', 'order': 'motorola', 'physical_unit': '%'}
+  // config detail: {'bit': 31, 'is_signed_var': False, 'len': 16, 'name':
+  // 'Brake_Pedal_Target', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+  // '[0|100]', 'physical_unit': '%', 'precision': 0.1, 'type': 'double'}
   void set_p_brake_pedal_target(uint8_t* data, double brake_pedal_target);
 
-  // config detail: {'name': 'Brake_EN_CTRL', 'enum': {0:
-  // 'BRAKE_EN_CTRL_DISABLE', 1: 'BRAKE_EN_CTRL_ENABLE'}, 'precision': 1.0,
-  // 'len': 1, 'is_signed_var': False, 'offset': 0.0, 'physical_range': '[0|1]',
-  // 'bit': 0, 'type': 'enum', 'order': 'motorola', 'physical_unit': ''}
+  // config detail: {'bit': 0, 'enum': {0: 'BRAKE_EN_CTRL_DISABLE', 1:
+  // 'BRAKE_EN_CTRL_ENABLE'}, 'is_signed_var': False, 'len': 1, 'name':
+  // 'Brake_EN_CTRL', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+  // '[0|1]', 'physical_unit': '', 'precision': 1.0, 'type': 'enum'}
   void set_p_brake_en_ctrl(uint8_t* data,
                            Brake_command_101::Brake_en_ctrlType brake_en_ctrl);
 
  private:
+  Brake_command_101::Aeb_en_ctrlType aeb_en_ctrl_;
   double brake_dec_;
   int checksum_101_;
   double brake_pedal_target_;
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\protocol\steering_command_102.cc" new_path="modules\canbus\vehicle\devkit\protocol\steering_command_102.cc" added_lines="19" deleted_lines="18">
				<diff>@@ -47,7 +47,7 @@ void Steeringcommand102::UpdateData(uint8_t* data) {
 void Steeringcommand102::Reset() {
   // TODO(All) :  you should check this manually
   steer_en_ctrl_ = Steering_command_102::STEER_EN_CTRL_DISABLE;
-  steer_angle_target_ = 0.0;
+  steer_angle_target_ = 0;
   steer_angle_spd_ = 0;
   checksum_102_ = 0;
 }
@@ -58,10 +58,10 @@ Steeringcommand102* Steeringcommand102::set_steer_en_ctrl(
   return this;
 }
 
-// config detail: {'name': 'Steer_EN_CTRL', 'enum': {0: 'STEER_EN_CTRL_DISABLE',
-// 1: 'STEER_EN_CTRL_ENABLE'}, 'precision': 1.0, 'len': 1, 'is_signed_var':
-// False, 'offset': 0.0, 'physical_range': '[0|1]', 'bit': 0, 'type': 'enum',
-// 'order': 'motorola', 'physical_unit': ''}
+// config detail: {'bit': 0, 'enum': {0: 'STEER_EN_CTRL_DISABLE', 1:
+// 'STEER_EN_CTRL_ENABLE'}, 'is_signed_var': False, 'len': 1, 'name':
+// 'Steer_EN_CTRL', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+// '[0|1]', 'physical_unit': '', 'precision': 1.0, 'type': 'enum'}
 void Steeringcommand102::set_p_steer_en_ctrl(
     uint8_t* data, Steering_command_102::Steer_en_ctrlType steer_en_ctrl) {
   int x = steer_en_ctrl;
@@ -71,19 +71,20 @@ void Steeringcommand102::set_p_steer_en_ctrl(
 }
 
 Steeringcommand102* Steeringcommand102::set_steer_angle_target(
-    double steer_angle_target) {
+    int steer_angle_target) {
   steer_angle_target_ = steer_angle_target;
   return this;
 }
 
-// config detail: {'name': 'Steer_ANGLE_Target', 'offset': -500.0, 'precision':
-// 1.0, 'len': 16, 'is_signed_var': False, 'physical_range': '[-500|500]',
-// 'bit': 31, 'type': 'double', 'order': 'motorola', 'physical_unit': 'deg'}
+// config detail: {'bit': 31, 'is_signed_var': False, 'len': 16, 'name':
+// 'Steer_ANGLE_Target', 'offset': -500.0, 'order': 'motorola',
+// 'physical_range': '[-500|500]', 'physical_unit': 'deg', 'precision': 1.0,
+// 'type': 'int'}
 void Steeringcommand102::set_p_steer_angle_target(uint8_t* data,
-                                                  double steer_angle_target) {
+                                                  int steer_angle_target) {
   steer_angle_target =
-      ProtocolData::BoundedValue(-500.0, 500.0, steer_angle_target);
-  int x = steer_angle_target - -500.000000;
+      ProtocolData::BoundedValue(-500, 500, steer_angle_target);
+  int x = (steer_angle_target - -500.000000);
   uint8_t t = 0;
 
   t = x &amp; 0xFF;
@@ -102,9 +103,9 @@ Steeringcommand102* Steeringcommand102::set_steer_angle_spd(
   return this;
 }
 
-// config detail: {'name': 'Steer_ANGLE_SPD', 'offset': 0.0, 'precision': 1.0,
-// 'len': 8, 'is_signed_var': False, 'physical_range': '[0|250]', 'bit': 15,
-// 'type': 'int', 'order': 'motorola', 'physical_unit': 'deg/s'}
+// config detail: {'bit': 15, 'is_signed_var': False, 'len': 8, 'name':
+// 'Steer_ANGLE_SPD', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+// '[0|250]', 'physical_unit': 'deg/s', 'precision': 1.0, 'type': 'int'}
 void Steeringcommand102::set_p_steer_angle_spd(uint8_t* data,
                                                int steer_angle_spd) {
   steer_angle_spd = ProtocolData::BoundedValue(0, 250, steer_angle_spd);
@@ -119,9 +120,9 @@ Steeringcommand102* Steeringcommand102::set_checksum_102(int checksum_102) {
   return this;
 }
 
-// config detail: {'name': 'CheckSum_102', 'offset': 0.0, 'precision': 1.0,
-// 'len': 8, 'is_signed_var': False, 'physical_range': '[0|255]', 'bit': 63,
-// 'type': 'int', 'order': 'motorola', 'physical_unit': ''}
+// config detail: {'bit': 63, 'is_signed_var': False, 'len': 8, 'name':
+// 'CheckSum_102', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+// '[0|255]', 'physical_unit': '', 'precision': 1.0, 'type': 'int'}
 void Steeringcommand102::set_p_checksum_102(uint8_t* data, int checksum_102) {
   checksum_102 = ProtocolData::BoundedValue(0, 255, checksum_102);
   int x = checksum_102;
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\protocol\steering_command_102.h" new_path="modules\canbus\vehicle\devkit\protocol\steering_command_102.h" added_lines="31" deleted_lines="31">
				<diff>@@ -36,56 +36,56 @@ class Steeringcommand102 : public ::apollo::drivers::canbus::ProtocolData&lt;
 
   void Reset() override;
 
-  // config detail: {'name': 'Steer_EN_CTRL', 'enum': {0:
-  // 'STEER_EN_CTRL_DISABLE', 1: 'STEER_EN_CTRL_ENABLE'}, 'precision': 1.0,
-  // 'len': 1, 'is_signed_var': False, 'offset': 0.0, 'physical_range': '[0|1]',
-  // 'bit': 0, 'type': 'enum', 'order': 'motorola', 'physical_unit': ''}
+  // config detail: {'bit': 0, 'enum': {0: 'STEER_EN_CTRL_DISABLE', 1:
+  // 'STEER_EN_CTRL_ENABLE'}, 'is_signed_var': False, 'len': 1, 'name':
+  // 'Steer_EN_CTRL', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+  // '[0|1]', 'physical_unit': '', 'precision': 1.0, 'type': 'enum'}
   Steeringcommand102* set_steer_en_ctrl(
       Steering_command_102::Steer_en_ctrlType steer_en_ctrl);
 
-  // config detail: {'name': 'Steer_ANGLE_Target', 'offset': -500.0,
-  // 'precision': 0.1, 'len': 16, 'is_signed_var': False, 'physical_range':
-  // '[-500|500]', 'bit': 31, 'type': 'double', 'order': 'motorola',
-  // 'physical_unit': 'deg'}
-  Steeringcommand102* set_steer_angle_target(double steer_angle_target);
+  // config detail: {'bit': 31, 'is_signed_var': False, 'len': 16, 'name':
+  // 'Steer_ANGLE_Target', 'offset': -500.0, 'order': 'motorola',
+  // 'physical_range': '[-500|500]', 'physical_unit': 'deg', 'precision': 1.0,
+  // 'type': 'int'}
+  Steeringcommand102* set_steer_angle_target(int steer_angle_target);
 
-  // config detail: {'name': 'Steer_ANGLE_SPD', 'offset': 0.0, 'precision': 1.0,
-  // 'len': 8, 'is_signed_var': False, 'physical_range': '[0|250]', 'bit': 15,
-  // 'type': 'int', 'order': 'motorola', 'physical_unit': 'deg/s'}
+  // config detail: {'bit': 15, 'is_signed_var': False, 'len': 8, 'name':
+  // 'Steer_ANGLE_SPD', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+  // '[0|250]', 'physical_unit': 'deg/s', 'precision': 1.0, 'type': 'int'}
   Steeringcommand102* set_steer_angle_spd(int steer_angle_spd);
 
-  // config detail: {'name': 'CheckSum_102', 'offset': 0.0, 'precision': 1.0,
-  // 'len': 8, 'is_signed_var': False, 'physical_range': '[0|255]', 'bit': 63,
-  // 'type': 'int', 'order': 'motorola', 'physical_unit': ''}
+  // config detail: {'bit': 63, 'is_signed_var': False, 'len': 8, 'name':
+  // 'CheckSum_102', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+  // '[0|255]', 'physical_unit': '', 'precision': 1.0, 'type': 'int'}
   Steeringcommand102* set_checksum_102(int checksum_102);
 
  private:
-  // config detail: {'name': 'Steer_EN_CTRL', 'enum': {0:
-  // 'STEER_EN_CTRL_DISABLE', 1: 'STEER_EN_CTRL_ENABLE'}, 'precision': 1.0,
-  // 'len': 1, 'is_signed_var': False, 'offset': 0.0, 'physical_range': '[0|1]',
-  // 'bit': 0, 'type': 'enum', 'order': 'motorola', 'physical_unit': ''}
+  // config detail: {'bit': 0, 'enum': {0: 'STEER_EN_CTRL_DISABLE', 1:
+  // 'STEER_EN_CTRL_ENABLE'}, 'is_signed_var': False, 'len': 1, 'name':
+  // 'Steer_EN_CTRL', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+  // '[0|1]', 'physical_unit': '', 'precision': 1.0, 'type': 'enum'}
   void set_p_steer_en_ctrl(
       uint8_t* data, Steering_command_102::Steer_en_ctrlType steer_en_ctrl);
 
-  // config detail: {'name': 'Steer_ANGLE_Target', 'offset': -500.0,
-  // 'precision': 1.0, 'len': 16, 'is_signed_var': False, 'physical_range':
-  // '[-500|500]', 'bit': 31, 'type': 'double', 'order': 'motorola',
-  // 'physical_unit': 'deg'}
-  void set_p_steer_angle_target(uint8_t* data, double steer_angle_target);
+  // config detail: {'bit': 31, 'is_signed_var': False, 'len': 16, 'name':
+  // 'Steer_ANGLE_Target', 'offset': -500.0, 'order': 'motorola',
+  // 'physical_range': '[-500|500]', 'physical_unit': 'deg', 'precision': 1.0,
+  // 'type': 'int'}
+  void set_p_steer_angle_target(uint8_t* data, int steer_angle_target);
 
-  // config detail: {'name': 'Steer_ANGLE_SPD', 'offset': 0.0, 'precision': 1.0,
-  // 'len': 8, 'is_signed_var': False, 'physical_range': '[0|250]', 'bit': 15,
-  // 'type': 'int', 'order': 'motorola', 'physical_unit': 'deg/s'}
+  // config detail: {'bit': 15, 'is_signed_var': False, 'len': 8, 'name':
+  // 'Steer_ANGLE_SPD', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+  // '[0|250]', 'physical_unit': 'deg/s', 'precision': 1.0, 'type': 'int'}
   void set_p_steer_angle_spd(uint8_t* data, int steer_angle_spd);
 
-  // config detail: {'name': 'CheckSum_102', 'offset': 0.0, 'precision': 1.0,
-  // 'len': 8, 'is_signed_var': False, 'physical_range': '[0|255]', 'bit': 63,
-  // 'type': 'int', 'order': 'motorola', 'physical_unit': ''}
+  // config detail: {'bit': 63, 'is_signed_var': False, 'len': 8, 'name':
+  // 'CheckSum_102', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+  // '[0|255]', 'physical_unit': '', 'precision': 1.0, 'type': 'int'}
   void set_p_checksum_102(uint8_t* data, int checksum_102);
 
  private:
   Steering_command_102::Steer_en_ctrlType steer_en_ctrl_;
-  double steer_angle_target_;
+  int steer_angle_target_;
   int steer_angle_spd_;
   int checksum_102_;
 };
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\protocol\steering_report_502.cc" new_path="modules\canbus\vehicle\devkit\protocol\steering_report_502.cc" added_lines="27" deleted_lines="25">
				<diff>@@ -47,10 +47,10 @@ void Steeringreport502::Parse(const std::uint8_t* bytes, int32_t length,
       steer_en_state(bytes, length) == 1);
 }
 
-// config detail: {'name': 'steer_angle_spd_actual', 'offset': 0.0,
-// 'precision': 1.0, 'len': 8, 'is_signed_var': False, 'physical_range':
-// '[0|0]', 'bit': 55, 'type': 'int', 'order': 'motorola', 'physical_unit':
-// 'deg/s'}
+// config detail: {'bit': 55, 'is_signed_var': False, 'len': 8, 'name':
+// 'steer_angle_spd_actual', 'offset': 0.0, 'order': 'motorola',
+// 'physical_range': '[0|0]', 'physical_unit': 'deg/s', 'precision': 1.0,
+// 'type': 'int'}
 int Steeringreport502::steer_angle_spd_actual(const std::uint8_t* bytes,
                                               int32_t length) const {
   Byte t0(bytes + 6);
@@ -60,11 +60,12 @@ int Steeringreport502::steer_angle_spd_actual(const std::uint8_t* bytes,
   return ret;
 }
 
-// config detail: {'description': 'Steer system communication fault', 'enum':
-// {0: 'STEER_FLT2_NO_FAULT', 1: 'STEER_FLT2_STEER_SYSTEM_COMUNICATION_FAULT'},
-// 'precision': 1.0, 'len': 8, 'name': 'steer_flt2', 'is_signed_var': False,
-// 'offset': 0.0, 'physical_range': '[0|1]', 'bit': 23, 'type': 'enum', 'order':
-// 'motorola', 'physical_unit': ''}
+// config detail: {'bit': 23, 'description': 'Steer system communication fault',
+// 'enum': {0: 'STEER_FLT2_NO_FAULT', 1:
+// 'STEER_FLT2_STEER_SYSTEM_COMUNICATION_FAULT'}, 'is_signed_var': False, 'len':
+// 8, 'name': 'steer_flt2', 'offset': 0.0, 'order': 'motorola',
+// 'physical_range': '[0|255]', 'physical_unit': '', 'precision': 1.0, 'type':
+// 'enum'}
 Steering_report_502::Steer_flt2Type Steeringreport502::steer_flt2(
     const std::uint8_t* bytes, int32_t length) const {
   Byte t0(bytes + 2);
@@ -75,11 +76,11 @@ Steering_report_502::Steer_flt2Type Steeringreport502::steer_flt2(
   return ret;
 }
 
-// config detail: {'description': 'Steer system hardware fault', 'enum': {0:
-// 'STEER_FLT1_NO_FAULT', 1: 'STEER_FLT1_STEER_SYSTEM_HARDWARE_FAULT'},
-// 'precision': 1.0, 'len': 8, 'name': 'steer_flt1', 'is_signed_var': False,
-// 'offset': 0.0, 'physical_range': '[0|1]', 'bit': 15, 'type': 'enum', 'order':
-// 'motorola', 'physical_unit': ''}
+// config detail: {'bit': 15, 'description': 'Steer system hardware fault',
+// 'enum': {0: 'STEER_FLT1_NO_FAULT', 1:
+// 'STEER_FLT1_STEER_SYSTEM_HARDWARE_FAULT'}, 'is_signed_var': False, 'len': 8,
+// 'name': 'steer_flt1', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+// '[0|255]', 'physical_unit': '', 'precision': 1.0, 'type': 'enum'}
 Steering_report_502::Steer_flt1Type Steeringreport502::steer_flt1(
     const std::uint8_t* bytes, int32_t length) const {
   Byte t0(bytes + 1);
@@ -90,11 +91,11 @@ Steering_report_502::Steer_flt1Type Steeringreport502::steer_flt1(
   return ret;
 }
 
-// config detail: {'name': 'steer_en_state', 'enum': {0:
-// 'STEER_EN_STATE_MANUAL', 1: 'STEER_EN_STATE_AUTO', 2:
-// 'STEER_EN_STATE_TAKEOVER', 3: 'STEER_EN_STATE_STANDBY'}, 'precision': 1.0,
-// 'len': 2, 'is_signed_var': False, 'offset': 0.0, 'physical_range': '[0|2]',
-// 'bit': 1, 'type': 'enum', 'order': 'motorola', 'physical_unit': ''}
+// config detail: {'bit': 1, 'enum': {0: 'STEER_EN_STATE_MANUAL', 1:
+// 'STEER_EN_STATE_AUTO', 2: 'STEER_EN_STATE_TAKEOVER', 3:
+// 'STEER_EN_STATE_STANDBY'}, 'is_signed_var': False, 'len': 2, 'name':
+// 'steer_en_state', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+// '[0|2]', 'physical_unit': '', 'precision': 1.0, 'type': 'enum'}
 Steering_report_502::Steer_en_stateType Steeringreport502::steer_en_state(
     const std::uint8_t* bytes, int32_t length) const {
   Byte t0(bytes + 0);
@@ -105,11 +106,12 @@ Steering_report_502::Steer_en_stateType Steeringreport502::steer_en_state(
   return ret;
 }
 
-// config detail: {'name': 'steer_angle_actual', 'offset': -500.0, 'precision':
-// 1.0, 'len': 16, 'is_signed_var': False, 'physical_range': '[-500|500]',
-// 'bit': 31, 'type': 'double', 'order': 'motorola', 'physical_unit': 'deg'}
-double Steeringreport502::steer_angle_actual(const std::uint8_t* bytes,
-                                             int32_t length) const {
+// config detail: {'bit': 31, 'is_signed_var': False, 'len': 16, 'name':
+// 'steer_angle_actual', 'offset': -500.0, 'order': 'motorola',
+// 'physical_range': '[-500|500]', 'physical_unit': 'deg', 'precision': 1.0,
+// 'type': 'int'}
+int Steeringreport502::steer_angle_actual(const std::uint8_t* bytes,
+                                          int32_t length) const {
   Byte t0(bytes + 3);
   int32_t x = t0.get_byte(0, 8);
 
@@ -118,7 +120,7 @@ double Steeringreport502::steer_angle_actual(const std::uint8_t* bytes,
   x &lt;&lt;= 8;
   x |= t;
 
-  double ret = x + -500.000000;
+  int ret = x + -500.000000;
   return ret;
 }
 }  // namespace devkit
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\devkit\protocol\steering_report_502.h" new_path="modules\canbus\vehicle\devkit\protocol\steering_report_502.h" added_lines="26" deleted_lines="26">
				<diff>@@ -32,44 +32,44 @@ class Steeringreport502 : public ::apollo::drivers::canbus::ProtocolData&lt;
              ChassisDetail* chassis) const override;
 
  private:
-  // config detail: {'name': 'Steer_ANGLE_SPD_Actual', 'offset': 0.0,
-  // 'precision': 1.0, 'len': 8, 'is_signed_var': False, 'physical_range':
-  // '[0|0]', 'bit': 55, 'type': 'int', 'order': 'motorola', 'physical_unit':
-  // 'deg/s'}
+  // config detail: {'bit': 55, 'is_signed_var': False, 'len': 8, 'name':
+  // 'Steer_ANGLE_SPD_Actual', 'offset': 0.0, 'order': 'motorola',
+  // 'physical_range': '[0|0]', 'physical_unit': 'deg/s', 'precision': 1.0,
+  // 'type': 'int'}
   int steer_angle_spd_actual(const std::uint8_t* bytes,
                              const int32_t length) const;
 
-  // config detail: {'description': 'Steer system communication fault', 'enum':
-  // {0: 'STEER_FLT2_NO_FAULT', 1:
-  // 'STEER_FLT2_STEER_SYSTEM_COMUNICATION_FAULT'}, 'precision': 1.0, 'len': 8,
-  // 'name': 'Steer_FLT2', 'is_signed_var': False, 'offset': 0.0,
-  // 'physical_range': '[0|1]', 'bit': 23, 'type': 'enum', 'order': 'motorola',
-  // 'physical_unit': ''}
+  // config detail: {'bit': 23, 'description': 'Steer system communication
+  // fault', 'enum': {0: 'STEER_FLT2_NO_FAULT', 1:
+  // 'STEER_FLT2_STEER_SYSTEM_COMUNICATION_FAULT'}, 'is_signed_var': False,
+  // 'len': 8, 'name': 'Steer_FLT2', 'offset': 0.0, 'order': 'motorola',
+  // 'physical_range': '[0|255]', 'physical_unit': '', 'precision': 1.0, 'type':
+  // 'enum'}
   Steering_report_502::Steer_flt2Type steer_flt2(const std::uint8_t* bytes,
                                                  const int32_t length) const;
 
-  // config detail: {'description': 'Steer system hardware fault', 'enum': {0:
-  // 'STEER_FLT1_NO_FAULT', 1: 'STEER_FLT1_STEER_SYSTEM_HARDWARE_FAULT'},
-  // 'precision': 1.0, 'len': 8, 'name': 'Steer_FLT1', 'is_signed_var': False,
-  // 'offset': 0.0, 'physical_range': '[0|1]', 'bit': 15, 'type': 'enum',
-  // 'order': 'motorola', 'physical_unit': ''}
+  // config detail: {'bit': 15, 'description': 'Steer system hardware fault',
+  // 'enum': {0: 'STEER_FLT1_NO_FAULT', 1:
+  // 'STEER_FLT1_STEER_SYSTEM_HARDWARE_FAULT'}, 'is_signed_var': False, 'len':
+  // 8, 'name': 'Steer_FLT1', 'offset': 0.0, 'order': 'motorola',
+  // 'physical_range': '[0|255]', 'physical_unit': '', 'precision': 1.0, 'type':
+  // 'enum'}
   Steering_report_502::Steer_flt1Type steer_flt1(const std::uint8_t* bytes,
                                                  const int32_t length) const;
 
-  // config detail: {'name': 'Steer_EN_state', 'enum': {0:
-  // 'STEER_EN_STATE_MANUAL', 1: 'STEER_EN_STATE_AUTO', 2:
-  // 'STEER_EN_STATE_TAKEOVER', 3: 'STEER_EN_STATE_STANDBY'}, 'precision': 1.0,
-  // 'len': 2, 'is_signed_var': False, 'offset': 0.0, 'physical_range': '[0|2]',
-  // 'bit': 1, 'type': 'enum', 'order': 'motorola', 'physical_unit': ''}
+  // config detail: {'bit': 1, 'enum': {0: 'STEER_EN_STATE_MANUAL', 1:
+  // 'STEER_EN_STATE_AUTO', 2: 'STEER_EN_STATE_TAKEOVER', 3:
+  // 'STEER_EN_STATE_STANDBY'}, 'is_signed_var': False, 'len': 2, 'name':
+  // 'Steer_EN_state', 'offset': 0.0, 'order': 'motorola', 'physical_range':
+  // '[0|2]', 'physical_unit': '', 'precision': 1.0, 'type': 'enum'}
   Steering_report_502::Steer_en_stateType steer_en_state(
       const std::uint8_t* bytes, const int32_t length) const;
 
-  // config detail: {'name': 'Steer_ANGLE_Actual', 'offset': -500.0,
-  // 'precision': 1.0, 'len': 16, 'is_signed_var': False, 'physical_range':
-  // '[-500|500]', 'bit': 31, 'type': 'double', 'order': 'motorola',
-  // 'physical_unit': 'deg'}
-  double steer_angle_actual(const std::uint8_t* bytes,
-                            const int32_t length) const;
+  // config detail: {'bit': 31, 'is_signed_var': False, 'len': 16, 'name':
+  // 'Steer_ANGLE_Actual', 'offset': -500.0, 'order': 'motorola',
+  // 'physical_range': '[-500|500]', 'physical_unit': 'deg', 'precision': 1.0,
+  // 'type': 'int'}
+  int steer_angle_actual(const std::uint8_t* bytes, const int32_t length) const;
 };
 
 }  // namespace devkit
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5aa1faeba8b3a2eda4a6468fddb1b7a87b0c12d2" author="AndrewXWei">
		<msg>Monitor: add camera monitor</msg>
		<modified_files>
			<file old_path="modules\monitor\monitor.cc" new_path="modules\monitor\monitor.cc" added_lines="3" deleted_lines="0">
				<diff>@@ -21,6 +21,7 @@
 #include "modules/monitor/hardware/gps_monitor.h"
 #include "modules/monitor/hardware/resource_monitor.h"
 #include "modules/monitor/hardware/socket_can_monitor.h"
+#include "modules/monitor/software/camera_monitor.h"
 #include "modules/monitor/software/channel_monitor.h"
 #include "modules/monitor/software/functional_safety_monitor.h"
 #include "modules/monitor/software/latency_monitor.h"
@@ -59,6 +60,8 @@ bool Monitor::Init() {
   runners_.emplace_back(new ChannelMonitor(latency_monitor));
   // Monitor if resources are sufficient.
   runners_.emplace_back(new ResourceMonitor());
+  // Monitor if only one camera is recorded.
+  runners_.emplace_back(new CameraMonitor());
 
   // Monitor all changes made by each sub-monitor, and summarize to a final
   // overall status.
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="70ba70ce27836c27e78a8f44c47e5dbfc975b4a5" author="changsh726">
		<msg>Monitor: updated camera monitor</msg>
		<modified_files>
			<file old_path="modules\monitor\monitor.cc" new_path="modules\monitor\monitor.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -49,6 +49,9 @@ bool Monitor::Init() {
   // To enable the LocalizationMonitor, you must add
   // FLAGS_localization_component_name to the mode's monitored_components.
   runners_.emplace_back(new LocalizationMonitor());
+  // To enable the CameraMonitor, you must add
+  // FLAGS_camera_component_name to the mode's monitored_components.
+  runners_.emplace_back(new CameraMonitor());
   // Monitor if processes are running.
   runners_.emplace_back(new ProcessMonitor());
   // Monitor if modules are running.
@@ -60,9 +63,6 @@ bool Monitor::Init() {
   runners_.emplace_back(new ChannelMonitor(latency_monitor));
   // Monitor if resources are sufficient.
   runners_.emplace_back(new ResourceMonitor());
-  // Monitor if only one camera is recorded.
-  runners_.emplace_back(new CameraMonitor());
-
   // Monitor all changes made by each sub-monitor, and summarize to a final
   // overall status.
   runners_.emplace_back(new SummaryMonitor());
</diff>
			</file>
			<file old_path="modules\monitor\software\camera_monitor.cc" new_path="modules\monitor\software\camera_monitor.cc" added_lines="42" deleted_lines="92">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
+ * Copyright 2020 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,14 +17,11 @@
 #include "modules/monitor/software/camera_monitor.h"
 
 #include &lt;memory&gt;
+#include &lt;set&gt;
 #include &lt;string&gt;
 #include &lt;utility&gt;
-#include &lt;vector&gt;
 
 #include "absl/strings/str_cat.h"
-#include "google/protobuf/compiler/parser.h"
-#include "google/protobuf/descriptor.h"
-#include "google/protobuf/dynamic_message.h"
 
 #include "modules/drivers/proto/sensor_image.pb.h"
 
@@ -39,123 +36,76 @@ DEFINE_string(camera_monitor_name, "CameraMonitor",
               "Name of the camera monitor.");
 DEFINE_double(camera_monitor_interval, 5,
               "Camera monitor checking interval in seconds.");
-DEFINE_string(camera_component_name, "camera",
-              "Camera component name.");
+DEFINE_string(camera_component_name, "Camera", "Camera component name.");
 
 namespace apollo {
 namespace monitor {
 namespace {
 
-using ReaderAndMessagePair =
-    std::pair&lt;std::shared_ptr&lt;cyber::ReaderBase&gt;,
-              std::shared_ptr&lt;google::protobuf::Message&gt;&gt;;
+using ReaderAndMessagePair = std::pair&lt;std::shared_ptr&lt;cyber::ReaderBase&gt;,
+                                       std::shared_ptr&lt;drivers::Image&gt;&gt;;
 
-template &lt;typename T&gt;
 ReaderAndMessagePair CreateReaderAndLatestsMessage(const std::string&amp; camera) {
-  const auto reader = MonitorManager::Instance()-&gt;CreateReader&lt;T&gt;(camera);
+  const auto reader =
+      MonitorManager::Instance()-&gt;CreateReader&lt;drivers::Image&gt;(camera);
   reader-&gt;Observe();
   const auto message = reader-&gt;GetLatestObserved();
+  reader-&gt;ClearData();
   return {reader, message};
 }
 
-static const auto camera_function_map =
-      std::unordered_map&lt;std::string, std::function&lt;ReaderAndMessagePair(
-                                          const std::string&amp; camera)&gt;&gt;{
-          {FLAGS_image_front_topic,
-           &amp;CreateReaderAndLatestsMessage&lt;drivers::Image&gt;},
-          {FLAGS_image_short_topic,
-           &amp;CreateReaderAndLatestsMessage&lt;drivers::Image&gt;},
-          {FLAGS_image_long_topic,
-           &amp;CreateReaderAndLatestsMessage&lt;drivers::Image&gt;},
-          {FLAGS_camera_image_long_topic,
-           &amp;CreateReaderAndLatestsMessage&lt;drivers::Image&gt;},
-          {FLAGS_camera_image_short_topic,
-           &amp;CreateReaderAndLatestsMessage&lt;drivers::Image&gt;},
-          {FLAGS_camera_front_6mm_compressed_topic,
-           &amp;CreateReaderAndLatestsMessage&lt;drivers::CompressedImage&gt;},
-          {FLAGS_camera_front_12mm_compressed_topic,
-           &amp;CreateReaderAndLatestsMessage&lt;drivers::CompressedImage&gt;},
-          {FLAGS_camera_left_fisheye_compressed_topic,
-           &amp;CreateReaderAndLatestsMessage&lt;drivers::CompressedImage&gt;},
-          {FLAGS_camera_right_fisheye_compressed_topic,
-           &amp;CreateReaderAndLatestsMessage&lt;drivers::CompressedImage&gt;},
-          {FLAGS_camera_rear_6mm_compressed_topic,
-           &amp;CreateReaderAndLatestsMessage&lt;drivers::CompressedImage&gt;},
-          {FLAGS_camera_front_6mm_video_compressed_topic,
-           &amp;CreateReaderAndLatestsMessage&lt;drivers::CompressedImage&gt;},
-          {FLAGS_camera_front_12mm_video_compressed_topic,
-           &amp;CreateReaderAndLatestsMessage&lt;drivers::CompressedImage&gt;},
-          {FLAGS_camera_left_fisheye_video_compressed_topic,
-           &amp;CreateReaderAndLatestsMessage&lt;drivers::CompressedImage&gt;},
-          {FLAGS_camera_right_fisheye_video_compressed_topic,
-           &amp;CreateReaderAndLatestsMessage&lt;drivers::CompressedImage&gt;},
-          {FLAGS_camera_rear_6mm_video_compressed_topic,
-           &amp;CreateReaderAndLatestsMessage&lt;drivers::CompressedImage&gt;},
-          // Add more cameras here if you want to monitor.
-      };
-
+static const auto camera_topic_set = std::set&lt;std::string&gt;{
+    FLAGS_image_front_topic, FLAGS_image_long_topic,
+    FLAGS_camera_image_long_topic, FLAGS_camera_image_short_topic,
+    // Add more cameras here if you want to monitor.
+};
 
 }  // namespace
 
 CameraMonitor::CameraMonitor()
-    : RecurrentRunner(FLAGS_camera_monitor_name, 
-                      FLAGS_camera_monitor_interval){
-
-                        AINFO &lt;&lt; "step into Camera Initial";
-                      }
+    : RecurrentRunner(FLAGS_camera_monitor_name,
+                      FLAGS_camera_monitor_interval) {}
 
 void CameraMonitor::RunOnce(const double current_time) {
-  AINFO &lt;&lt; "step into Camera RunOnce";
-  auto manager = MonitorManager::Instance();
+  auto* manager = MonitorManager::Instance();
   auto* component = apollo::common::util::FindOrNull(
-      *manager-&gt;GetStatus()-&gt;mutable_components(),
-      FLAGS_camera_component_name);
+      *manager-&gt;GetStatus()-&gt;mutable_components(), FLAGS_camera_component_name);
+  if (component == nullptr) {
+    // camera is not monitored in current mode, skip.
+    return;
+  }
   auto* status = component-&gt;mutable_other_status();
   UpdateStatus(status);
-
 }
 
-void UpdateStatus(ComponentStatus* status) {
-  AINFO &lt;&lt; "step into Camera update status";
+void CameraMonitor::UpdateStatus(ComponentStatus* status) {
   status-&gt;clear_status();
-  std::string frame_id;
-  for (auto iter = camera_function_map.begin(); iter != camera_function_map.end(); ++iter){
-    const auto camera_type = iter-&gt;first;
-    AINFO &lt;&lt; "camera_type" &lt;&lt; camera_type;
-    const auto reader_message_pair = (iter-&gt;second)(camera_type);
-    const auto reader = reader_message_pair.first;
-    const auto message = reader_message_pair.second;
-    if (reader != nullptr) {
-        if (frame_id.empty()){
-          const google::protobuf::Descriptor* desc = (*message).GetDescriptor();
-          const google::protobuf::Reflection* ref = (*message).GetReflection();
-          const auto field_count = desc-&gt;field_count();
-          for (int field_idx = 0; field_idx &lt; field_count; ++field_idx) {
-            const auto* field_desc = desc-&gt;field(field_idx);
-            if (field_desc-&gt;name() == "frame_id") {
-              frame_id = ref-&gt;GetString((*message), field_desc);
-            }
-          }
+  std::string frame_id = "";
+  for (const auto&amp; topic : camera_topic_set) {
+    const auto&amp; reader_message_pair = CreateReaderAndLatestsMessage(topic);
+    const auto&amp; reader = reader_message_pair.first;
+    const auto&amp; message = reader_message_pair.second;
+    if (reader != nullptr &amp;&amp; message != nullptr) {
+      if (frame_id.empty()) {
+        const auto&amp; header = message-&gt;header();
+        if (header.has_frame_id()) {
+          frame_id = header.frame_id();
         }
-        else{
-          SummaryMonitor::EscalateStatus(
+      } else {
+        SummaryMonitor::EscalateStatus(
             ComponentStatus::ERROR,
-            absl::StrCat("only one camera is permitted"), status);
-        }
+            absl::StrCat("Only one camera is permitted"), status);
+      }
     }
-  }  
-  if(frame_id.empty()){
-    SummaryMonitor::EscalateStatus(
-            ComponentStatus::ERROR,
-            absl::StrCat("no camera is detected"), status);
   }
-  else
-  {
+  if (frame_id.empty()) {
     SummaryMonitor::EscalateStatus(
-            ComponentStatus::OK,
-            absl::StrCat("detected one camera: ", frame_id), status);
+        ComponentStatus::ERROR, absl::StrCat("No camera is detected"), status);
+  } else {
+    SummaryMonitor::EscalateStatus(
+        ComponentStatus::OK, absl::StrCat("Detected one camera: ", frame_id),
+        status);
   }
-
 }
 
 }  // namespace monitor
</diff>
			</file>
			<file old_path="modules\monitor\software\camera_monitor.h" new_path="modules\monitor\software\camera_monitor.h" added_lines="1" deleted_lines="6">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
+ * Copyright 2020 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,11 +15,6 @@
  *****************************************************************************/
 #pragma once
 
-#include &lt;memory&gt;
-#include &lt;string&gt;
-#include &lt;unordered_map&gt;
-
-#include "modules/dreamview/proto/hmi_mode.pb.h"
 #include "modules/monitor/common/recurrent_runner.h"
 #include "modules/monitor/proto/system_status.pb.h"
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="bb3ea8fa6e99c77b7121b4d74bd97f771d48d75e" author="storypku">
		<msg>Canbus: configurable MAX_PORT for HermesCAN</msg>
		<modified_files>
			<file old_path="modules\drivers\canbus\can_client\esd\esd_can_client.cc" new_path="modules\drivers\canbus\can_client\esd\esd_can_client.cc" added_lines="11" deleted_lines="5">
				<diff>@@ -21,6 +21,7 @@
  **/
 
 #include "modules/drivers/canbus/can_client/esd/esd_can_client.h"
+
 #include "modules/drivers/canbus/common/byte.h"
 #include "modules/drivers/canbus/sensor_gflags.h"
 
@@ -39,6 +40,15 @@ bool EsdCanClient::Init(const CANCardParameter &amp;parameter) {
     return false;
   }
   port_ = parameter.channel_id();
+
+  int num_ports = parameter.num_ports();
+
+  if (port_ &gt; num_ports || port_ &lt; 0) {
+    AERROR &lt;&lt; "Can port number [" &lt;&lt; port_ &lt;&lt; "] is out of range [0, "
+           &lt;&lt; num_ports &lt;&lt; ") !";
+    return false;
+  }
+
   return true;
 }
 
@@ -63,12 +73,8 @@ ErrorCode EsdCanClient::Start() {
   if (FLAGS_esd_can_extended_frame) {
     mode = NTCAN_MODE_NO_RTR;
   }
+
   // mode |= NTCAN_MODE_NO_RTR;
-  if (port_ &gt; MAX_CAN_PORT || port_ &lt; 0) {
-    AERROR &lt;&lt; "can port number [" &lt;&lt; port_ &lt;&lt; "] is out of the range [0,"
-           &lt;&lt; MAX_CAN_PORT &lt;&lt; "]";
-    return ErrorCode::CAN_CLIENT_ERROR_BASE;
-  }
   int32_t ret = canOpen(port_, mode, NTCAN_MAX_TX_QUEUESIZE,
                         NTCAN_MAX_RX_QUEUESIZE, 5, 5, &amp;dev_handler_);
   if (ret != NTCAN_SUCCESS) {
</diff>
			</file>
			<file old_path="modules\drivers\canbus\can_client\hermes_can\hermes_can_client.cc" new_path="modules\drivers\canbus\can_client\hermes_can\hermes_can_client.cc" added_lines="29" deleted_lines="28">
				<diff>@@ -29,7 +29,7 @@ namespace can {
 using apollo::common::ErrorCode;
 
 HermesCanClient::~HermesCanClient() {
-  if (_dev_handler) {
+  if (dev_handler_) {
     Stop();
   }
 }
@@ -40,57 +40,57 @@ bool HermesCanClient::Init(const CANCardParameter &amp;parameter) {
               "parameter is "
            &lt;&lt; parameter.DebugString();
     return false;
-  } else {
-    _card_port = parameter.channel_id();
-    return true;
   }
+  port_ = parameter.channel_id();
+  auto num_ports = parameter.num_ports();
+  if (port_ &gt; static_cast&lt;int32_t&gt;(num_ports) || port_ &lt; 0) {
+    AERROR &lt;&lt; "Can port number [" &lt;&lt; port_ &lt;&lt; "] is out of bound [0,"
+           &lt;&lt; num_ports &lt;&lt; ")";
+    return false;
+  }
+
+  return true;
 }
 
 ErrorCode HermesCanClient::Start() {
-  if (_is_init) {
+  if (is_init_) {
     return ErrorCode::OK;
   }
 
-  if (_card_port &gt; MAX_CAN_PORT || _card_port &lt; 0) {
-    AERROR &lt;&lt; "can port number [" &lt;&lt; _card_port &lt;&lt; "] is out of the range [0,"
-           &lt;&lt; MAX_CAN_PORT &lt;&lt; "]";
-    return ErrorCode::CAN_CLIENT_ERROR_BASE;
-  }
   // open device
-  int32_t ret = bcan_open(_card_port, 0,
+  int32_t ret = bcan_open(port_, 0,
                           5,  // 5ms for rx timeout
                           5,  // 5ms for tx timeout
-                          &amp;_dev_handler);
+                          &amp;dev_handler_);
 
   if (ret != ErrorCode::OK) {
-    AERROR &lt;&lt; "Open device error code: " &lt;&lt; ret
-           &lt;&lt; ", channel id: " &lt;&lt; _card_port;
+    AERROR &lt;&lt; "Open device error code: " &lt;&lt; ret &lt;&lt; ", channel id: " &lt;&lt; port_;
     return ErrorCode::CAN_CLIENT_ERROR_BASE;
   }
-  AINFO &lt;&lt; "Open device succ code: " &lt;&lt; ret &lt;&lt; ", channel id: " &lt;&lt; _card_port;
+  AINFO &lt;&lt; "Open device success, channel id: " &lt;&lt; port_;
 
   // 1. set baudrate to 500k
-  ret = bcan_set_baudrate(_dev_handler, BCAN_BAUDRATE_500K);
+  ret = bcan_set_baudrate(dev_handler_, BCAN_BAUDRATE_500K);
   if (ret != ErrorCode::OK) {
     AERROR &lt;&lt; "Set baudrate error Code: " &lt;&lt; ret;
     return ErrorCode::CAN_CLIENT_ERROR_BASE;
   }
 
   // 2. start receive
-  ret = bcan_start(_dev_handler);
+  ret = bcan_start(dev_handler_);
   if (ret != ErrorCode::OK) {
     AERROR &lt;&lt; "Start hermes can card failed: " &lt;&lt; ret;
     return ErrorCode::CAN_CLIENT_ERROR_BASE;
   }
 
-  _is_init = true;
+  is_init_ = true;
   return ErrorCode::OK;
 }
 
 void HermesCanClient::Stop() {
-  if (_is_init) {
-    _is_init = false;
-    int32_t ret = bcan_close(_dev_handler);
+  if (is_init_) {
+    is_init_ = false;
+    int32_t ret = bcan_close(dev_handler_);
     if (ret != ErrorCode::OK) {
       AERROR &lt;&lt; "close error code: " &lt;&lt; ret;
     }
@@ -112,7 +112,7 @@ apollo::common::ErrorCode HermesCanClient::Send(
   CHECK_NOTNULL(frame_num);
   CHECK_EQ(frames.size(), static_cast&lt;size_t&gt;(*frame_num));
 
-  if (!_is_init) {
+  if (!is_init_) {
     AERROR &lt;&lt; "Hermes can client is not init! Please init first!";
     return ErrorCode::CAN_CLIENT_ERROR_SEND_FAILED;
   }
@@ -129,9 +129,9 @@ apollo::common::ErrorCode HermesCanClient::Send(
 
   // Synchronous transmission of CAN messages
   int32_t send_num = *frame_num;
-  int32_t ret = bcan_send(_dev_handler, _send_frames, send_num);
+  int32_t ret = bcan_send(dev_handler_, _send_frames, send_num);
   if (ret &lt; 0) {
-    int ret_send_error = bcan_get_status(_dev_handler);
+    int ret_send_error = bcan_get_status(dev_handler_);
     AERROR &lt;&lt; "send message failed, error code: " &lt;&lt; ret
            &lt;&lt; ", send error: " &lt;&lt; ret_send_error;
     return ErrorCode::CAN_CLIENT_ERROR_SEND_FAILED;
@@ -142,9 +142,10 @@ apollo::common::ErrorCode HermesCanClient::Send(
 
 // buf size must be 8 bytes, every time, we receive only one frame
 const int RX_TIMEOUT = -7;
+
 apollo::common::ErrorCode HermesCanClient::Receive(
     std::vector&lt;CanFrame&gt; *const frames, int32_t *const frame_num) {
-  if (!_is_init) {
+  if (!is_init_) {
     AERROR &lt;&lt; "Hermes can client is not init! Please init first!";
     return ErrorCode::CAN_CLIENT_ERROR_RECV_FAILED;
   }
@@ -154,14 +155,14 @@ apollo::common::ErrorCode HermesCanClient::Receive(
     return ErrorCode::CAN_CLIENT_ERROR_FRAME_NUM;
   }
 
-  int32_t ret = bcan_recv(_dev_handler, _recv_frames, *frame_num);
+  int32_t ret = bcan_recv(dev_handler_, _recv_frames, *frame_num);
   // don't log timeout
   if (ret == RX_TIMEOUT) {
     *frame_num = 0;
     return ErrorCode::OK;
   }
   if (ret &lt; 0) {
-    int ret_rece_error = bcan_get_status(_dev_handler);
+    int ret_rece_error = bcan_get_status(dev_handler_);
     AERROR &lt;&lt; "receive message failed, error code:" &lt;&lt; ret
            &lt;&lt; "receive error:" &lt;&lt; ret_rece_error;
     return ErrorCode::CAN_CLIENT_ERROR_RECV_FAILED;
@@ -184,7 +185,7 @@ apollo::common::ErrorCode HermesCanClient::Receive(
 
 std::string HermesCanClient::GetErrorString(int32_t ntstatus) { return ""; }
 
-void HermesCanClient::SetInited(bool init) { _is_init = init; }
+void HermesCanClient::SetInited(bool init) { is_init_ = init; }
 
 }  // namespace can
 }  // namespace canbus
</diff>
			</file>
			<file old_path="modules\drivers\canbus\can_client\hermes_can\hermes_can_client.h" new_path="modules\drivers\canbus\can_client\hermes_can\hermes_can_client.h" added_lines="6" deleted_lines="5">
				<diff>@@ -20,12 +20,13 @@
 #include &lt;vector&gt;
 
 #include "gflags/gflags.h"
+
 #include "modules/common/proto/error_code.pb.h"
-#include "modules/drivers/canbus/can_client/can_client.h"
-#include "modules/drivers/canbus/common/canbus_consts.h"
 #include "modules/drivers/canbus/proto/can_card_parameter.pb.h"
 
+#include "modules/drivers/canbus/can_client/can_client.h"
 #include "modules/drivers/canbus/can_client/hermes_can/bcan.h"
+#include "modules/drivers/canbus/common/canbus_consts.h"
 
 /**
  * @namespace apollo::drivers::canbus::can
@@ -106,9 +107,9 @@ class HermesCanClient : public CanClient {
   void SetInited(bool init);
 
  private:
-  bool _is_init = false;
-  bcan_hdl_t _dev_handler;
-  CANCardParameter::CANChannelId _card_port;
+  bool is_init_ = false;
+  bcan_hdl_t dev_handler_;
+  CANCardParameter::CANChannelId port_;
   bcan_msg_t _send_frames[MAX_CAN_SEND_FRAME_LEN];
   bcan_msg_t _recv_frames[MAX_CAN_RECV_FRAME_LEN];
 };
</diff>
			</file>
			<file old_path="modules\drivers\canbus\can_client\socket\socket_can_client_raw.cc" new_path="modules\drivers\canbus\can_client\socket\socket_can_client_raw.cc" added_lines="6" deleted_lines="6">
				<diff>@@ -41,6 +41,12 @@ bool SocketCanClientRaw::Init(const CANCardParameter &amp;parameter) {
 
   port_ = parameter.channel_id();
   interface_ = parameter.interface();
+  auto num_ports = parameter.num_ports();
+  if (port_ &gt; static_cast&lt;int32_t&gt;(num_ports) || port_ &lt; 0) {
+    AERROR &lt;&lt; "Can port number [" &lt;&lt; port_ &lt;&lt; "] is out of range [0, "
+           &lt;&lt; num_ports &lt;&lt; ") !";
+    return false;
+  }
   return true;
 }
 
@@ -62,12 +68,6 @@ ErrorCode SocketCanClientRaw::Start() {
   // if more than one card, when install driver u can specify the minior id
   // int32_t ret = canOpen(net, pCtx-&gt;mode, txbufsize, rxbufsize, 0, 0,
   // &amp;dev_handler_);
-  if (port_ &gt; MAX_CAN_PORT || port_ &lt; 0) {
-    AERROR &lt;&lt; "can port number [" &lt;&lt; port_ &lt;&lt; "] is out of the range [0,"
-           &lt;&lt; MAX_CAN_PORT &lt;&lt; "]";
-    return ErrorCode::CAN_CLIENT_ERROR_BASE;
-  }
-
   dev_handler_ = socket(PF_CAN, SOCK_RAW, CAN_RAW);
   if (dev_handler_ &lt; 0) {
     AERROR &lt;&lt; "open device error code [" &lt;&lt; dev_handler_ &lt;&lt; "]: ";
</diff>
			</file>
			<file old_path="modules\drivers\canbus\common\canbus_consts.h" new_path="modules\drivers\canbus\common\canbus_consts.h" added_lines="0" deleted_lines="1">
				<diff>@@ -35,7 +35,6 @@ const int32_t MAX_CAN_SEND_FRAME_LEN = 1;
 const int32_t MAX_CAN_RECV_FRAME_LEN = 10;
 
 const int32_t CANBUS_MESSAGE_LENGTH = 8;  // according to ISO-11891-1
-const int32_t MAX_CAN_PORT = 3;
 
 }  // namespace canbus
 }  // namespace drivers
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="29c07198b68bae7f677f35125cef48255c265b5d" author="storypku">
		<msg>Perception: one copy of yolo.proto for YOLO and YOLOv4

fix issue#13160</msg>
		<modified_files>
			<file old_path="modules\perception\camera\lib\obstacle\detector\yolo\region_output.h" new_path="modules\perception\camera\lib\obstacle\detector\yolo\region_output.h" added_lines="9" deleted_lines="9">
				<diff>@@ -22,13 +22,14 @@
 #include &lt;utility&gt;
 #include &lt;vector&gt;
 
+#include "modules/perception/camera/proto/yolo.pb.h"
+
 #include "modules/perception/base/blob.h"
 #include "modules/perception/base/box.h"
 #include "modules/perception/base/object.h"
 #include "modules/perception/base/object_types.h"
 #include "modules/perception/camera/common/math_functions.h"
 #include "modules/perception/camera/common/util.h"
-#include "modules/perception/camera/lib/obstacle/detector/yolo/proto/yolo.pb.h"
 
 namespace apollo {
 namespace perception {
@@ -163,15 +164,14 @@ void compute_overlapped_by_idx_gpu(const int nthreads, const float *bbox_data,
                                    bool *overlapped_data,
                                    const cudaStream_t &amp;_stream);
 
-
 int get_objects_gpu(
-        const YoloBlobs &amp;yolo_blobs, const cudaStream_t &amp;stream,
-        const std::vector&lt;base::ObjectSubType&gt; &amp;types,
-        const NMSParam &amp;nms, const yolo::ModelParam &amp;model_param,
-        float light_vis_conf_threshold, float light_swt_conf_threshold,
-        base::Blob&lt;bool&gt; *overlapped, base::Blob&lt;int&gt; *idx_sm,
-        const std::map&lt;base::ObjectSubType, std::vector&lt;int&gt;&gt; &amp;indices,
-        const std::map&lt;base::ObjectSubType, std::vector&lt;float&gt;&gt; &amp;conf_scores);
+    const YoloBlobs &amp;yolo_blobs, const cudaStream_t &amp;stream,
+    const std::vector&lt;base::ObjectSubType&gt; &amp;types, const NMSParam &amp;nms,
+    const yolo::ModelParam &amp;model_param, float light_vis_conf_threshold,
+    float light_swt_conf_threshold, base::Blob&lt;bool&gt; *overlapped,
+    base::Blob&lt;int&gt; *idx_sm,
+    const std::map&lt;base::ObjectSubType, std::vector&lt;int&gt;&gt; &amp;indices,
+    const std::map&lt;base::ObjectSubType, std::vector&lt;float&gt;&gt; &amp;conf_scores);
 
 void get_objects_cpu(const YoloBlobs &amp;yolo_blobs, const cudaStream_t &amp;stream,
                      const std::vector&lt;base::ObjectSubType&gt; &amp;types,
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\detector\yolo\yolo_obstacle_detector.h" new_path="modules\perception\camera\lib\obstacle\detector\yolo\yolo_obstacle_detector.h" added_lines="2" deleted_lines="1">
				<diff>@@ -20,13 +20,14 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
+#include "modules/perception/camera/proto/yolo.pb.h"
+
 #include "cyber/common/file.h"
 #include "modules/perception/base/box.h"
 #include "modules/perception/base/object_types.h"
 #include "modules/perception/camera/common/util.h"
 #include "modules/perception/camera/lib/interface/base_feature_extractor.h"
 #include "modules/perception/camera/lib/interface/base_obstacle_detector.h"
-#include "modules/perception/camera/lib/obstacle/detector/yolo/proto/yolo.pb.h"
 #include "modules/perception/camera/lib/obstacle/detector/yolo/region_output.h"
 #include "modules/perception/inference/inference.h"
 #include "modules/perception/inference/utils/resize.h"
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\detector\yolov4\region_output.h" new_path="modules\perception\camera\lib\obstacle\detector\yolov4\region_output.h" added_lines="2" deleted_lines="1">
				<diff>@@ -21,13 +21,14 @@
 #include &lt;utility&gt;
 #include &lt;vector&gt;
 
+#include "modules/perception/camera/proto/yolo.pb.h"
+
 #include "modules/perception/base/blob.h"
 #include "modules/perception/base/box.h"
 #include "modules/perception/base/object.h"
 #include "modules/perception/base/object_types.h"
 #include "modules/perception/camera/common/math_functions.h"
 #include "modules/perception/camera/common/util.h"
-#include "modules/perception/camera/lib/obstacle/detector/yolov4/proto/yolov4.pb.h"
 
 namespace apollo {
 namespace perception {
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\detector\yolov4\yolov4_obstacle_detector.cc" new_path="modules\perception\camera\lib\obstacle\detector\yolov4\yolov4_obstacle_detector.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -31,7 +31,7 @@ namespace camera {
 using cyber::common::GetAbsolutePath;
 
 void Yolov4ObstacleDetector::LoadInputShape(
-  const yolo::ModelParam &amp;model_param) {
+    const yolo::ModelParam &amp;model_param) {
   float offset_ratio = model_param.offset_ratio();
   float cropped_ratio = model_param.cropped_ratio();
   int resized_width = model_param.resized_width();
@@ -80,7 +80,7 @@ void Yolov4ObstacleDetector::LoadParam(const yolo::YoloParam &amp;yolo_param) {
 }
 
 bool Yolov4ObstacleDetector::InitNet(const yolo::YoloParam &amp;yolo_param,
-                                   const std::string &amp;model_root) {
+                                     const std::string &amp;model_root) {
   const auto &amp;model_param = yolo_param.model_param();
 
   std::string proto_file =
@@ -313,7 +313,7 @@ bool Yolov4ObstacleDetector::InitFeatureExtractor(const std::string &amp;root_dir) {
 }
 
 bool Yolov4ObstacleDetector::Detect(const ObstacleDetectorOptions &amp;options,
-                                  CameraFrame *frame) {
+                                    CameraFrame *frame) {
   if (frame == nullptr) {
     return false;
   }
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\detector\yolov4\yolov4_obstacle_detector.h" new_path="modules\perception\camera\lib\obstacle\detector\yolov4\yolov4_obstacle_detector.h" added_lines="2" deleted_lines="1">
				<diff>@@ -20,13 +20,14 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
+#include "modules/perception/camera/proto/yolo.pb.h"
+
 #include "cyber/common/file.h"
 #include "modules/perception/base/box.h"
 #include "modules/perception/base/object_types.h"
 #include "modules/perception/camera/common/util.h"
 #include "modules/perception/camera/lib/interface/base_feature_extractor.h"
 #include "modules/perception/camera/lib/interface/base_obstacle_detector.h"
-#include "modules/perception/camera/lib/obstacle/detector/yolov4/proto/yolov4.pb.h"
 #include "modules/perception/camera/lib/obstacle/detector/yolov4/region_output.h"
 #include "modules/perception/inference/inference.h"
 #include "modules/perception/inference/utils/resize.h"
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="cdf25f14cbba6c4ee7f4daa7d05d8075944be88e" author="storypku">
		<msg>perception: removed unused i_struct.h</msg>
		<modified_files>
			<file old_path="modules\perception\common\i_lib\core\i_struct.h" new_path="" added_lines="0" deleted_lines="72">
				<diff>@@ -1,72 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-#pragma once
-
-#include "modules/perception/common/i_lib/core/i_alloc.h"
-
-namespace apollo {
-namespace perception {
-namespace common {
-template &lt;typename T1, typename T2&gt;
-struct Pair {
-  T1 first;
-  T2 second;
-  Pair() {}
-  Pair(const Pair&lt;T1, T2&gt; &amp;p) {
-    first = p.first;
-    second = p.second;
-  }
-  Pair &amp;operator=(const Pair&lt;T1, T2&gt; &amp;p) {
-    this-&gt;first = p.first;
-    this-&gt;second = p.second;
-    return (*this);
-  }
-  Pair(const T1 &amp;a, const T2 &amp;b) : first(a), second(b) {}
-};
-
-template &lt;typename T1, typename T2&gt;
-inline Pair&lt;T1, T2&gt; IMakePair(const T1 &amp;a, const T2 &amp;b) {
-  return Pair&lt;T1, T2&gt;(a, b);
-}
-
-template &lt;typename T1, typename T2&gt;
-inline bool ILessPairFirstElement(const Pair&lt;T1, T2&gt; &amp;a,
-                                  const Pair&lt;T1, T2&gt; &amp;b) {
-  return a.first &lt; b.first;
-}
-
-template &lt;typename T1, typename T2&gt;
-inline bool ILessPairSecondElement(const Pair&lt;T1, T2&gt; &amp;a,
-                                   const Pair&lt;T1, T2&gt; &amp;b) {
-  return a.second &lt; b.second;
-}
-
-template &lt;typename T1, typename T2&gt;
-inline bool ILargerPairFirstElement(const Pair&lt;T1, T2&gt; &amp;a,
-                                    const Pair&lt;T1, T2&gt; &amp;b) {
-  return a.first &gt; b.first;
-}
-
-template &lt;typename T1, typename T2&gt;
-inline bool ILargerPairSecondElement(const Pair&lt;T1, T2&gt; &amp;a,
-                                     const Pair&lt;T1, T2&gt; &amp;b) {
-  return a.second &gt; b.second;
-}
-
-}  // namespace common
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\common\i_lib\da\i_ransac.h" new_path="modules\perception\common\i_lib\da\i_ransac.h" added_lines="0" deleted_lines="1">
				<diff>@@ -17,7 +17,6 @@
 
 #include "modules/perception/common/i_lib/core/i_blas.h"
 #include "modules/perception/common/i_lib/core/i_rand.h"
-#include "modules/perception/common/i_lib/core/i_struct.h"
 
 #include &lt;limits&gt;
 
</diff>
			</file>
			<file old_path="modules\perception\common\i_lib\geometry\i_plane.h" new_path="modules\perception\common\i_lib\geometry\i_plane.h" added_lines="0" deleted_lines="1">
				<diff>@@ -17,7 +17,6 @@
 
 #include "modules/perception/common/i_lib/algorithm/i_sort.h"
 #include "modules/perception/common/i_lib/core/i_alloc.h"
-#include "modules/perception/common/i_lib/core/i_struct.h"
 #include "modules/perception/common/i_lib/da/i_ransac.h"
 #include "modules/perception/common/i_lib/geometry/i_line.h"
 #include "modules/perception/common/i_lib/geometry/i_util.h"
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8e499599c771990d2d5c91cb139430f6a8adafeb" author="changsh726">
		<msg>TaskManager: format and code clean</msg>
		<modified_files>
			<file old_path="modules\task_manager\cycle_routing_manager.cc" new_path="modules\task_manager\cycle_routing_manager.cc" added_lines="33" deleted_lines="40">
				<diff>@@ -20,52 +20,50 @@
 namespace apollo {
 namespace task_manager {
 bool CheckPointDistanceInThreshold(common::PointENU point_a,
-                                   common::PointENU point_b,
-                                   double distance) {
-    double x_dis = point_a.x() - point_b.x();
-    double y_dis = point_a.y() - point_b.y();
-    return x_dis * x_dis + y_dis * y_dis &lt; distance * distance;
+                                   common::PointENU point_b, double distance) {
+  double x_dis = point_a.x() - point_b.x();
+  double y_dis = point_a.y() - point_b.y();
+  return x_dis * x_dis + y_dis * y_dis &lt; distance * distance;
 }
 
 common::Status CycleRoutingManager::Init(
-        const CycleRoutingTask&amp; cycle_routing_task) {
-    cycle_ = cycle_routing_task.cycle_num();
-    auto waypoints = cycle_routing_task.routing_request().waypoint();
-    waypoint_num_ = waypoints.size();
-    begin_point_ = waypoints[0];
-    end_point_ = waypoints[waypoint_num_ - 1];
-    is_allowed_to_route_ = true;
-    original_routing_request_ = cycle_routing_task.routing_request();
-    map_service_.reset(new apollo::dreamview::MapService());
+    const CycleRoutingTask&amp; cycle_routing_task) {
+  cycle_ = cycle_routing_task.cycle_num();
+  auto waypoints = cycle_routing_task.routing_request().waypoint();
+  waypoint_num_ = waypoints.size();
+  begin_point_ = waypoints[0];
+  end_point_ = waypoints[waypoint_num_ - 1];
+  is_allowed_to_route_ = true;
+  original_routing_request_ = cycle_routing_task.routing_request();
+  map_service_.reset(new apollo::dreamview::MapService());
 
-    AINFO &lt;&lt; "New cycle routing task: cycle " &lt;&lt; cycle_ &lt;&lt; ", begin point "
+  AINFO &lt;&lt; "New cycle routing task: cycle " &lt;&lt; cycle_ &lt;&lt; ", begin point "
         &lt;&lt; begin_point_.pose().x() &lt;&lt; " " &lt;&lt; begin_point_.pose().y()
         &lt;&lt; ", end point " &lt;&lt; end_point_.pose().x() &lt;&lt; " "
         &lt;&lt; end_point_.pose().y();
 
-    return common::Status::OK();
+  return common::Status::OK();
 }
 
-bool CycleRoutingManager::GetNewRouting(const localization::Pose &amp;pose,
+bool CycleRoutingManager::GetNewRouting(
+    const localization::Pose&amp; pose,
     routing::RoutingRequest* new_routing_request) {
-  AINFO &lt;&lt; "GetNewRouting: localization_pose: "
-  &lt;&lt; pose.position().x() &lt;&lt; " " &lt;&lt; pose.position().y()
-  &lt;&lt; ", begin point " &lt;&lt; begin_point_.pose().x()
-  &lt;&lt; " " &lt;&lt; begin_point_.pose().y()
-  &lt;&lt; ", end point " &lt;&lt; end_point_.pose().x() &lt;&lt; " " &lt;&lt; end_point_.pose().y()
-  &lt;&lt; ", threshold " &lt;&lt; FLAGS_threshold_for_destination_check
-  &lt;&lt; ", allowed_to_send_routing_request " &lt;&lt; is_allowed_to_route_;
+  AINFO &lt;&lt; "GetNewRouting: localization_pose: " &lt;&lt; pose.position().x() &lt;&lt; " "
+        &lt;&lt; pose.position().y() &lt;&lt; ", begin point " &lt;&lt; begin_point_.pose().x()
+        &lt;&lt; " " &lt;&lt; begin_point_.pose().y() &lt;&lt; ", end point "
+        &lt;&lt; end_point_.pose().x() &lt;&lt; " " &lt;&lt; end_point_.pose().y()
+        &lt;&lt; ", threshold " &lt;&lt; FLAGS_threshold_for_destination_check
+        &lt;&lt; ", allowed_to_send_routing_request " &lt;&lt; is_allowed_to_route_;
 
   if (is_allowed_to_route_) {
-    if (CheckPointDistanceInThreshold(
-        begin_point_.pose(),
-        pose.position(),
-        FLAGS_threshold_for_destination_check)) {
+    if (CheckPointDistanceInThreshold(begin_point_.pose(), pose.position(),
+                                      FLAGS_threshold_for_destination_check)) {
       AINFO &lt;&lt; "GetNewRouting: reach begin point";
       new_routing_request-&gt;CopyFrom(original_routing_request_);
       auto cur_point = new_routing_request-&gt;mutable_waypoint(0);
-      if (!map_service_-&gt;ConstructLaneWayPointWithHeading(pose.position().x(),
-          pose.position().y(), pose.heading(), cur_point)) {
+      if (!map_service_-&gt;ConstructLaneWayPointWithHeading(
+              pose.position().x(), pose.position().y(), pose.heading(),
+              cur_point)) {
         AINFO &lt;&lt; "GetNewRouting: construct begin lane way point fail!";
         return false;
       }
@@ -74,15 +72,14 @@ bool CycleRoutingManager::GetNewRouting(const localization::Pose &amp;pose,
       return true;
     }
   } else {
-    if (CheckPointDistanceInThreshold(
-        end_point_.pose(),
-        pose.position(),
-        FLAGS_threshold_for_destination_check)) {
+    if (CheckPointDistanceInThreshold(end_point_.pose(), pose.position(),
+                                      FLAGS_threshold_for_destination_check)) {
       AINFO &lt;&lt; "GetNewRouting: reach end point";
       new_routing_request-&gt;clear_waypoint();
       auto cur_point = new_routing_request-&gt;add_waypoint();
-      if (!map_service_-&gt;ConstructLaneWayPointWithHeading(pose.position().x(),
-          pose.position().y(), pose.heading(), cur_point)) {
+      if (!map_service_-&gt;ConstructLaneWayPointWithHeading(
+              pose.position().x(), pose.position().y(), pose.heading(),
+              cur_point)) {
         AINFO &lt;&lt; "GetNewRouting: construct end lane way point fail!";
         return false;
       }
@@ -96,9 +93,5 @@ bool CycleRoutingManager::GetNewRouting(const localization::Pose &amp;pose,
   return false;
 }
 
-int CycleRoutingManager::GetCycle() const {
-    return cycle_;
-}
-
 }  // namespace task_manager
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\task_manager\cycle_routing_manager.h" new_path="modules\task_manager\cycle_routing_manager.h" added_lines="6" deleted_lines="5">
				<diff>@@ -20,11 +20,12 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
+#include "modules/localization/proto/localization.pb.h"
+#include "modules/task_manager/proto/task_manager.pb.h"
+
 #include "modules/common/monitor_log/monitor_log_buffer.h"
 #include "modules/common/status/status.h"
 #include "modules/dreamview/backend/map/map_service.h"
-#include "modules/localization/proto/localization.pb.h"
-#include "modules/task_manager/proto/task_manager.pb.h"
 
 namespace apollo {
 namespace task_manager {
@@ -43,14 +44,14 @@ class CycleRoutingManager {
    * @brief Get new routing if the vehicle reaches the begin/end point
    * @return false/true
    */
-  bool GetNewRouting(const localization::Pose &amp;pose,
-      routing::RoutingRequest* routing_request_);
+  bool GetNewRouting(const localization::Pose&amp; pose,
+                     routing::RoutingRequest* routing_request_);
 
   /**
    * @brief get remaining cycle number
    * @return remaining cycle number
    */
-  int GetCycle() const;
+  int GetCycle() const { return cycle_; }
 
   /**
    * @brief destructor
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.cc" new_path="modules\task_manager\task_manager_component.cc" added_lines="36" deleted_lines="36">
				<diff>@@ -15,9 +15,10 @@
  *****************************************************************************/
 #include "modules/task_manager/task_manager_component.h"
 
-#include "cyber/time/rate.h"
 #include "modules/task_manager/proto/task_manager_config.pb.h"
 
+#include "cyber/time/rate.h"
+
 namespace apollo {
 namespace task_manager {
 
@@ -27,15 +28,15 @@ using apollo::localization::LocalizationEstimate;
 using apollo::routing::RoutingRequest;
 
 bool TaskManagerComponent::Init() {
-    TaskManagerConfig task_manager_conf;
-    ACHECK(cyber::ComponentBase::GetProtoConfig(&amp;task_manager_conf))
+  TaskManagerConfig task_manager_conf;
+  ACHECK(cyber::ComponentBase::GetProtoConfig(&amp;task_manager_conf))
       &lt;&lt; "Unable to load task_manager conf file: "
       &lt;&lt; cyber::ComponentBase::ConfigFilePath();
 
-    AINFO &lt;&lt; "Config file: " &lt;&lt; cyber::ComponentBase::ConfigFilePath()
+  AINFO &lt;&lt; "Config file: " &lt;&lt; cyber::ComponentBase::ConfigFilePath()
         &lt;&lt; " is loaded.";
 
-    localization_reader_ = node_-&gt;CreateReader&lt;LocalizationEstimate&gt;(
+  localization_reader_ = node_-&gt;CreateReader&lt;LocalizationEstimate&gt;(
       task_manager_conf.topic_config().localization_pose_topic(),
       [this](const std::shared_ptr&lt;LocalizationEstimate&gt;&amp; localization) {
         ADEBUG &lt;&lt; "Received localization data: run localization callback.";
@@ -43,44 +44,43 @@ bool TaskManagerComponent::Init() {
         localization_.CopyFrom(*localization);
       });
 
-    cyber::proto::RoleAttributes attr;
-    attr.set_channel_name(
+  cyber::proto::RoleAttributes attr;
+  attr.set_channel_name(
       task_manager_conf.topic_config().routing_request_topic());
-    auto qos = attr.mutable_qos_profile();
-    qos-&gt;set_history(apollo::cyber::proto::QosHistoryPolicy::HISTORY_KEEP_LAST);
-    qos-&gt;set_reliability(
-        apollo::cyber::proto::QosReliabilityPolicy::RELIABILITY_RELIABLE);
-    qos-&gt;set_durability(
-        apollo::cyber::proto::QosDurabilityPolicy::DURABILITY_TRANSIENT_LOCAL);
-    request_writer_ = node_-&gt;CreateWriter&lt;RoutingRequest&gt;(attr);
-    return true;
+  auto qos = attr.mutable_qos_profile();
+  qos-&gt;set_history(apollo::cyber::proto::QosHistoryPolicy::HISTORY_KEEP_LAST);
+  qos-&gt;set_reliability(
+      apollo::cyber::proto::QosReliabilityPolicy::RELIABILITY_RELIABLE);
+  qos-&gt;set_durability(
+      apollo::cyber::proto::QosDurabilityPolicy::DURABILITY_TRANSIENT_LOCAL);
+  request_writer_ = node_-&gt;CreateWriter&lt;RoutingRequest&gt;(attr);
+  return true;
 }
 
 bool TaskManagerComponent::Proc(const std::shared_ptr&lt;Task&gt;&amp; task) {
-    task_name_ = task-&gt;task_name();
-    if (task-&gt;task_type() != CYCLE_ROUTING) {
-      AINFO &lt;&lt; "Task type is not cycle_routing.";
-      return false;
-    }
+  task_name_ = task-&gt;task_name();
+  if (task-&gt;task_type() != CYCLE_ROUTING) {
+    AINFO &lt;&lt; "Task type is not cycle_routing.";
+    return false;
+  }
 
-    cycle_routing_manager_ = std::make_shared&lt;CycleRoutingManager&gt;();
-    cycle_routing_manager_-&gt;Init(task-&gt;cycle_routing_task());
-    routing_request_ = task-&gt;cycle_routing_task().routing_request();
-    Rate rate(1.0);
+  cycle_routing_manager_ = std::make_shared&lt;CycleRoutingManager&gt;();
+  cycle_routing_manager_-&gt;Init(task-&gt;cycle_routing_task());
+  routing_request_ = task-&gt;cycle_routing_task().routing_request();
+  Rate rate(1.0);
 
-    while (cycle_routing_manager_-&gt;GetCycle() &gt; 0) {
-      if (cycle_routing_manager_-&gt;GetNewRouting(
-            localization_.pose(),
-            &amp;routing_request_)) {
-        common::util::FillHeader(node_-&gt;Name(), &amp;routing_request_);
-        request_writer_-&gt;Write(routing_request_);
-        AINFO &lt;&lt; "Reach begin/end point: "
-        &lt;&lt; "routing manager send a routing request. "
-        &lt;&lt; "Remaining cycles: " &lt;&lt; cycle_routing_manager_-&gt;GetCycle();
-      }
-      rate.Sleep();
+  while (cycle_routing_manager_-&gt;GetCycle() &gt; 0) {
+    if (cycle_routing_manager_-&gt;GetNewRouting(localization_.pose(),
+                                              &amp;routing_request_)) {
+      common::util::FillHeader(node_-&gt;Name(), &amp;routing_request_);
+      request_writer_-&gt;Write(routing_request_);
+      AINFO &lt;&lt; "Reach begin/end point: "
+            &lt;&lt; "routing manager send a routing request. "
+            &lt;&lt; "Remaining cycles: " &lt;&lt; cycle_routing_manager_-&gt;GetCycle();
     }
-    return true;
+    rate.Sleep();
+  }
+  return true;
 }
 
 }  // namespace task_manager
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.h" new_path="modules\task_manager\task_manager_component.h" added_lines="1" deleted_lines="2">
				<diff>@@ -28,8 +28,7 @@ namespace task_manager {
 
 using apollo::localization::LocalizationEstimate;
 
-class TaskManagerComponent final
-    : public cyber::Component&lt;task_manager::Task&gt; {
+class TaskManagerComponent final : public cyber::Component&lt;task_manager::Task&gt; {
  public:
   TaskManagerComponent() = default;
   ~TaskManagerComponent() = default;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="52f1a7811c88105fdabd1a24ced106c2639a67dc" author="storypku">
		<msg>localization: bugfix for issue #13238</msg>
		<modified_files>
			<file old_path="modules\localization\ndt\map_creation\ndt_map_creator.cc" new_path="modules\localization\ndt\map_creation\ndt_map_creator.cc" added_lines="14" deleted_lines="10">
				<diff>@@ -20,6 +20,7 @@
 #include &lt;boost/filesystem.hpp&gt;
 #include &lt;boost/program_options.hpp&gt;
 #include &lt;boost/random.hpp&gt;
+
 #include "absl/strings/str_cat.h"
 
 #include "modules/localization/msf/common/io/velodyne_utility.h"
@@ -89,20 +90,23 @@ int main(int argc, char** argv) {
   }
 
   float single_resolution_map = boost_args["resolution"].as&lt;float&gt;();
-  if (fabs(single_resolution_map - 0.03125) &gt; 1e-8 &amp;&amp;
-      fabs(single_resolution_map - 0.0625) &gt; 1e-8 &amp;&amp;
-      fabs(single_resolution_map - 0.125) &lt; 1e-8 &amp;&amp;
-      fabs(single_resolution_map - 0.25) &lt; 1e-8 &amp;&amp;
-      fabs(single_resolution_map - 0.5) &lt; 1e-8 &amp;&amp;
-      fabs(single_resolution_map - 1.0) &lt; 1e-8 &amp;&amp;
-      fabs(single_resolution_map - 2.0) &lt; 1e-8 &amp;&amp;
-      fabs(single_resolution_map - 4.0) &lt; 1e-8 &amp;&amp;
-      fabs(single_resolution_map - 8.0) &lt; 1e-8 &amp;&amp;
-      fabs(single_resolution_map - 16.0) &lt; 1e-8) {
+  constexpr double epsilon = 1e-8;
+  if (std::fabs(single_resolution_map - 0.03125) &gt; epsilon &amp;&amp;
+      std::fabs(single_resolution_map - 0.0625) &gt; epsilon &amp;&amp;
+      std::fabs(single_resolution_map - 0.125) &gt; epsilon &amp;&amp;
+      std::fabs(single_resolution_map - 0.25) &gt; epsilon &amp;&amp;
+      std::fabs(single_resolution_map - 0.5) &gt; epsilon &amp;&amp;
+      std::fabs(single_resolution_map - 1.0) &gt; epsilon &amp;&amp;
+      std::fabs(single_resolution_map - 2.0) &gt; epsilon &amp;&amp;
+      std::fabs(single_resolution_map - 4.0) &gt; epsilon &amp;&amp;
+      std::fabs(single_resolution_map - 8.0) &gt; epsilon &amp;&amp;
+      std::fabs(single_resolution_map - 16.0) &gt; epsilon) {
     std::cerr &lt;&lt; "map resolution can only be: 0.03125, "
               &lt;&lt; "0.0625, 0.125, 0.25, 0.5, 1.0, 2.0, "
               &lt;&lt; "4.0, 8.0 or 16.0." &lt;&lt; std::endl;
+    return -1;
   }
+
   float single_resolution_map_z = boost_args["resolution_z"].as&lt;float&gt;();
   std::cout &lt;&lt; "single_resolution_map_z: " &lt;&lt; single_resolution_map_z
             &lt;&lt; std::endl;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a8fc19f746c4ca95d01fa688a84ab376cbf89af3" author="Jiahao Chen">
		<msg>Perception: update TensorRT permute layer &amp; support Cuda11</msg>
		<modified_files>
			<file old_path="modules\perception\inference\tensorrt\rt_net.cc" new_path="modules\perception\inference\tensorrt\rt_net.cc" added_lines="12" deleted_lines="8">
				<diff>@@ -369,14 +369,18 @@ void RTNet::addPermuteLayer(const LayerParameter &amp;layer_param,
                             nvinfer1::INetworkDefinition *net,
                             TensorMap *tensor_map,
                             TensorModifyMap *tensor_modify_map) {
-  nvinfer1::IPluginLayer *permuteLayer;
-  nvinfer1::plugin::Quadruple permuteOrder;
-  CHECK_EQ(layer_param.permute_param().order_size(), 4);
-  for (int i = 0; i &lt; 4; i++) {
-    permuteOrder.data[i] = layer_param.permute_param().order(i);
-  }
-  nvinfer1::IPlugin *mplugin = createSSDPermutePlugin(permuteOrder);
-  permuteLayer = net-&gt;addPlugin(inputs, nbInputs, *mplugin);
+  CHECK_LE(layer_param.permute_param().order_size(), nvinfer1::Dims::MAX_DIMS);
+  nvinfer1::IShuffleLayer *permuteLayer = net-&gt;addShuffle(*inputs[0]);
+  nvinfer1::Permutation permutation;
+
+  // For loading Caffe's permute param,
+  // e.g. Caffe: [0, 2, 1, 3] -&gt; TensorRT: [1, 0, 2], omitting 1st dim N.
+  ACHECK(layer_param.permute_param().order(0) == 0);
+  for (int i = 1; i &lt; layer_param.permute_param().order_size(); ++i) {
+    int order = layer_param.permute_param().order(i);
+    permutation.order[i - 1] = order - 1;
+  }
+  permuteLayer-&gt;setFirstTranspose(permutation);
 
   permuteLayer-&gt;setName(layer_param.name().c_str());
   ConstructMap(layer_param, permuteLayer, tensor_map, tensor_modify_map);
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\tracker\multi_lidar_fusion\mlf_engine.cc" new_path="modules\perception\lidar\lib\tracker\multi_lidar_fusion\mlf_engine.cc" added_lines="0" deleted_lines="1">
				<diff>@@ -73,7 +73,6 @@ bool MlfEngine::Init(const MultiTargetTrackerInitOptions&amp; options) {
   tracker_.reset(new MlfTracker);
   MlfTrackerInitOptions tracker_init_options;
   ACHECK(tracker_-&gt;Init(tracker_init_options));
-  evaluator_.Init();
   return true;
 }
 
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\tracker\multi_lidar_fusion\mlf_engine.h" new_path="modules\perception\lidar\lib\tracker\multi_lidar_fusion\mlf_engine.h" added_lines="1" deleted_lines="2">
				<diff>@@ -23,7 +23,6 @@
 #include "modules/perception/lidar/lib/interface/base_multi_target_tracker.h"
 #include "modules/perception/lidar/lib/tracker/multi_lidar_fusion/mlf_track_object_matcher.h"
 #include "modules/perception/lidar/lib/tracker/multi_lidar_fusion/mlf_tracker.h"
-#include "modules/perception/lidar/lib/tracker/semantic_map/evaluator_manager.h"
 #include "modules/perception/onboard/msg_serializer/msg_serializer.h"
 #include "modules/perception/proto/perception_obstacle.pb.h"
 #include "modules/prediction/container/obstacles/obstacles_container.h"
@@ -120,7 +119,7 @@ class MlfEngine : public BaseMultiTargetTracker {
   apollo::prediction::PoseContainer pose_container_;
   apollo::perception::onboard::MsgSerializer serializer_;
   bool use_semantic_map_ = false;
-  apollo::perception::EvaluatorManager evaluator_;
+//  apollo::perception::EvaluatorManager evaluator_;
 };
 
 }  // namespace lidar
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5c09bf41417dbe2335f0478d66bdc28c99b6ccc1" author="xiaoMrzhang">
		<msg>Perception: change darkscnn caffe model to tensorrt &amp; add new obstacl (#13234)

* Perception: change darkscnn caffe model to tensorrt &amp; add new obstacle module

* Perception: code style</msg>
		<modified_files>
			<file old_path="modules\perception\camera\lib\lane\postprocessor\darkSCNN\darkSCNN_lane_postprocessor.cc" new_path="modules\perception\camera\lib\lane\postprocessor\darkSCNN\darkSCNN_lane_postprocessor.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -23,7 +23,7 @@
 
 #include "modules/perception/base/object_types.h"
 #include "modules/perception/camera/common/math_functions.h"
-#include "modules/perception/lib/utils/timer.h"
+#include "modules/perception/camera/common/timer.h"
 
 namespace apollo {
 namespace perception {
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\tracker\omt\omt_obstacle_tracker.cc" new_path="modules\perception\camera\lib\obstacle\tracker\omt\omt_obstacle_tracker.cc" added_lines="7" deleted_lines="0">
				<diff>@@ -321,6 +321,13 @@ int OMTObstacleTracker::CreateNewTarget(const TrackObjectPtrs &amp;objects) {
       base::RectF rect(objects[i]-&gt;object-&gt;camera_supplement.box);
       auto &amp;min_tmplt = kMinTemplateHWL.at(sub_type);
       if (OutOfValidRegion(rect, width_, height_, omt_param_.border())) {
+        AINFO &lt;&lt; "Out of valid region";
+        AINFO &lt;&lt; "Rect x: " &lt;&lt; rect.x
+              &lt;&lt; " Rect y: " &lt;&lt; rect.y
+              &lt;&lt; " Rect height: " &lt;&lt; rect.height
+              &lt;&lt; " Rect width: " &lt;&lt; rect.width
+              &lt;&lt; " GT height_: " &lt;&lt; height_
+              &lt;&lt; " GT width_: " &lt;&lt; width_;
         continue;
       }
       for (auto &amp;&amp;target_rect : target_rects) {
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\traffic_light\detector\recognition\classify.cc" new_path="modules\perception\camera\lib\traffic_light\detector\recognition\classify.cc" added_lines="4" deleted_lines="4">
				<diff>@@ -124,7 +124,7 @@ void ClassifyBySimple::Perform(const CameraFrame* frame,
 
     data_provider_image_option_.crop_roi = light-&gt;region.detection_roi;
     data_provider_image_option_.do_crop = true;
-    data_provider_image_option_.target_color = base::Color::RGB;
+    data_provider_image_option_.target_color = base::Color::BGR;
     frame-&gt;data_provider-&gt;GetImage(data_provider_image_option_, image_.get());
 
     AINFO &lt;&lt; "get img done";
@@ -149,9 +149,9 @@ void ClassifyBySimple::Prob2Color(const float* out_put_data, float threshold,
                                   base::TrafficLightPtr light) {
   int max_color_id = 0;
   std::vector&lt;base::TLColor&gt; status_map = {
-      base::TLColor::TL_GREEN, base::TLColor::TL_RED, base::TLColor::TL_YELLOW,
-      base::TLColor::TL_BLACK};
-  std::vector&lt;std::string&gt; name_map = {"Green", "Red", "Yellow", "Black"};
+      base::TLColor::TL_BLACK, base::TLColor::TL_RED, base::TLColor::TL_YELLOW,
+      base::TLColor::TL_GREEN};
+  std::vector&lt;std::string&gt; name_map = {"Black", "Red", "Yellow", "Green"};
   std::vector&lt;float&gt; prob(out_put_data, out_put_data + status_map.size());
   auto max_prob = std::max_element(prob.begin(), prob.end());
   max_color_id = (*max_prob &gt; threshold)
</diff>
			</file>
			<file old_path="modules\perception\camera\tools\offline\offline_obstacle_pipeline.cc" new_path="modules\perception\camera\tools\offline\offline_obstacle_pipeline.cc" added_lines="6" deleted_lines="2">
				<diff>@@ -31,9 +31,12 @@
 #include "modules/perception/camera/lib/feature_extractor/tfe/external_feature_extractor.h"
 #include "modules/perception/camera/lib/feature_extractor/tfe/project_feature.h"
 #include "modules/perception/camera/lib/feature_extractor/tfe/tracking_feat_extractor.h"
+#include "modules/perception/camera/lib/lane/detector/darkSCNN/darkSCNN_lane_detector.h"
 #include "modules/perception/camera/lib/lane/detector/denseline/denseline_lane_detector.h"
+#include "modules/perception/camera/lib/lane/postprocessor/darkSCNN/darkSCNN_lane_postprocessor.h"
 #include "modules/perception/camera/lib/lane/postprocessor/denseline/denseline_lane_postprocessor.h"
 #include "modules/perception/camera/lib/obstacle/detector/yolo/yolo_obstacle_detector.h"
+#include "modules/perception/camera/lib/obstacle/detector/smoke/smoke_obstacle_detector.h"
 #include "modules/perception/camera/lib/obstacle/postprocessor/location_refiner/location_refiner_obstacle_postprocessor.h"
 #include "modules/perception/camera/lib/obstacle/tracker/omt/omt_obstacle_tracker.h"
 #include "modules/perception/camera/lib/obstacle/transformer/multicue/multicue_obstacle_transformer.h"
@@ -73,6 +76,7 @@ namespace perception {
 namespace camera {
 
 REGISTER_OBSTACLE_DETECTOR(YoloObstacleDetector);
+REGISTER_OBSTACLE_DETECTOR(SmokeObstacleDetector);
 REGISTER_OBSTACLE_TRACKER(OMTObstacleTracker);
 REGISTER_FEATURE_EXTRACTOR(TrackingFeatureExtractor);
 REGISTER_OBSTACLE_TRANSFORMER(MultiCueObstacleTransformer);
@@ -83,8 +87,8 @@ REGISTER_LANE_POSTPROCESSOR(DenselineLanePostprocessor);
 REGISTER_LANE_DETECTOR(DenselineLaneDetector);
 REGISTER_CALIBRATOR(LaneLineCalibrator);
 REGISTER_CALIBRATION_SERVICE(OnlineCalibrationService);
-// REGISTER_LANE_DETECTOR(DarkSCNNLaneDetector);
-// REGISTER_LANE_POSTPROCESSOR(DarkSCNNLanePostprocessor);
+REGISTER_LANE_DETECTOR(DarkSCNNLaneDetector);
+REGISTER_LANE_POSTPROCESSOR(DarkSCNNLanePostprocessor);
 
 static const float kDefaultPitchAngle = 0.0f;
 static const float kDefaultCameraHeight = 1.5f;
</diff>
			</file>
			<file old_path="modules\perception\camera\tools\offline\visualizer.cc" new_path="modules\perception\camera\tools\offline\visualizer.cc" added_lines="5" deleted_lines="1">
				<diff>@@ -1096,6 +1096,8 @@ void Visualizer::Draw2Dand3D_all_info_single_camera(
   for (const auto &amp;object : frame.tracked_objects) {
     // plot 2D box on image_2D
     base::RectF rect(object-&gt;camera_supplement.box);
+    AINFO &lt;&lt; "Draw box xmin: " &lt;&lt; object-&gt;camera_supplement.box.xmin;
+    AINFO &lt;&lt; "Draw box ymin: " &lt;&lt; object-&gt;camera_supplement.box.ymin;
     cv::Rect r(static_cast&lt;int&gt;(rect.x), static_cast&lt;int&gt;(rect.y),
                static_cast&lt;int&gt;(rect.width), static_cast&lt;int&gt;(rect.height));
     cv::Scalar color = colorlistobj[object-&gt;track_id % colorlistobj.size()];
@@ -1369,7 +1371,9 @@ void Visualizer::ShowResult_all_info_single_camera(
   if (frame.timestamp - last_timestamp_ &lt; 0.02) return;
 
   world_image_ = cv::Mat(world_h_, wide_pixel_, CV_8UC3, black_color);
-
+  if (frame.data_provider-&gt;sensor_name() == "front_6mm") {
+    cv::imwrite("./test.png", img);
+  }
   // draw results on visulization panel
   int line_pos = 0;
   cv::Mat image = img.clone();
</diff>
			</file>
			<file old_path="modules\perception\inference\inference_factory.cc" new_path="modules\perception\inference\inference_factory.cc" added_lines="3" deleted_lines="0">
				<diff>@@ -18,6 +18,7 @@
 
 #include "modules/perception/inference/libtorch/torch_det.h"
 #include "modules/perception/inference/libtorch/torch_net.h"
+#include "modules/perception/inference/onnx/libtorch_obstacle_detector.h"
 #include "modules/perception/inference/tensorrt/rt_net.h"
 
 namespace apollo {
@@ -38,6 +39,8 @@ Inference *CreateInferenceByName(const std::string &amp;name,
     return new TorchDet(proto_file, weight_file, outputs, inputs);
   } else if (name == "TorchNet") {
     return new TorchNet(proto_file, weight_file, outputs, inputs);
+  } else if (name == "Obstacle") {
+    return new ObstacleDetector(proto_file, weight_file, outputs, inputs);
   }
   return nullptr;
 }
</diff>
			</file>
			<file old_path="modules\perception\inference\libtorch\torch_det.cc" new_path="modules\perception\inference\libtorch\torch_det.cc" added_lines="3" deleted_lines="0">
				<diff>@@ -16,6 +16,8 @@
 
 #include "modules/perception/inference/libtorch/torch_det.h"
 
+#include &lt;c10/cuda/CUDACachingAllocator.h&gt;
+
 #include "cyber/common/log.h"
 
 namespace apollo {
@@ -113,6 +115,7 @@ void TorchDet::Infer() {
     result = torch::zeros({1, 9}, torch::kFloat).to(device);
   }
   blobs_[output_names_[0]]-&gt;data()-&gt;set_gpu_data(result.data_ptr());
+  c10::cuda::CUDACachingAllocator::emptyCache();
 }
 
 }  // namespace inference
</diff>
			</file>
			<file old_path="modules\perception\inference\onnx\libtorch_obstacle_detector.cc" new_path="modules\perception\inference\onnx\libtorch_obstacle_detector.cc" added_lines="11" deleted_lines="5">
				<diff>@@ -59,11 +59,14 @@ bool ObstacleDetector::Init(const std::map&lt;std::string,
   torch_inputs.push_back(std::make_tuple(tensor_K.to(device),
                                          tensor_downratio.to(device)));
   auto torch_output_tensor =
-      net_.forward(torch_inputs).toTensor();
+      net_.forward(torch_inputs);
 
   for (const auto&amp; name : output_names_) {
-    auto blob = std::make_shared&lt;Blob&lt;float&gt;&gt;(2, 6, 1, 1);
-    blobs_.emplace(name, blob);
+    auto iter = shapes.find(name);
+    if (iter != shapes.end()) {
+      auto blob = std::make_shared&lt;Blob&lt;float&gt;&gt;(iter-&gt;second);
+      blobs_.emplace(name, blob);
+    }
   }
 
   for (const auto&amp; name : input_names_) {
@@ -119,15 +122,18 @@ void ObstacleDetector::Infer() {
   tensor_image[0][0] = tensor_image[0][0].div_(58.395);
   tensor_image[0][1] = tensor_image[0][1].div_(57.12);
   tensor_image[0][2] = tensor_image[0][2].div_(57.375);
-  AINFO &lt;&lt; tensor_K[0][0];
 
   torch_inputs.push_back(tensor_image);
   torch_inputs.push_back(std::make_tuple(tensor_K.to(device),
                                          tensor_ratio.to(device)));
 
   AINFO &lt;&lt; "Start to do inference";
-  auto outputs = net_.forward(torch_inputs).toTensor();
+  auto outputs = net_.forward(torch_inputs).toTuple()-&gt;elements();
+  auto results = outputs[0].toTensor();
+  auto feat_map = outputs[1].toTensor();
   AINFO &lt;&lt; "Finished inference";
+  blobs_[output_names_[0]]-&gt;data()-&gt;set_gpu_data(results.data_ptr());
+  blobs_[output_names_[1]]-&gt;data()-&gt;set_gpu_data(feat_map.data_ptr());
 }
 
 }  // namespace inference
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\rt_net.cc" new_path="modules\perception\inference\tensorrt\rt_net.cc" added_lines="3" deleted_lines="0">
				<diff>@@ -189,6 +189,9 @@ void RTNet::addConcatLayer(const LayerParameter &amp;layer_param,
   ConcatParameter concat = layer_param.concat_param();
   nvinfer1::IConcatenationLayer *concatLayer =
       net-&gt;addConcatenation(inputs, nbInputs);
+  // tensorrt ignore the first channel(batch channel), so when load caffe
+  // model axis should -1
+  concatLayer-&gt;setAxis(concat.axis()-1);
   concatLayer-&gt;setName(layer_param.name().c_str());
   CHECK_EQ(nbInputs, layer_param.bottom_size());
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="11104c3d8bead0034dbf0723bf682ae4c2c97d99" author="liuxu">
		<msg>Refactor Lidar drivers (#13245)

* drivers: lidar refactor lidar/dirver to add factory pattern

* Lidar Driver: fix deconstruc bug

* Lidar Driver: fix some format

* Lidar Driver: fix some format

Lidar Driver: remove explict

Lidar Drivers: buildifer BUILD

* Lidar Driver: init node_

* Lidar Driver: modify lidar conf

Co-authored-by: liuxu &lt;liuxu20@baidu.com&gt;</msg>
		<modified_files>
			<file old_path="modules\drivers\lidar\hesai\driver\driver.cc" new_path="modules\drivers\lidar\hesai\driver\driver.cc" added_lines="5" deleted_lines="0">
				<diff>@@ -25,6 +25,11 @@ bool HesaiDriver::Init() {
     AERROR &lt;&lt; "node is nullptr";
     return false;
   }
+  Parser* hesai_parser = ParserFactory::CreateParser(node_, conf_);
+  if (hesai_parser == nullptr) {
+    AERROR &lt;&lt; "create parser error";
+  }
+  parser_.reset(hesai_parser);
   scan_writer_ = node_-&gt;CreateWriter&lt;HesaiScan&gt;(conf_.scan_channel());
   if (scan_writer_ == nullptr) {
     AERROR &lt;&lt; "writer:" &lt;&lt; conf_.scan_channel()
</diff>
			</file>
			<file old_path="modules\drivers\lidar\hesai\driver\driver.h" new_path="modules\drivers\lidar\hesai\driver\driver.h" added_lines="12" deleted_lines="5">
				<diff>@@ -28,21 +28,28 @@
 #include &lt;thread&gt;
 #include &lt;vector&gt;
 
+#include "modules/drivers/lidar/proto/config.pb.h"
+
 #include "cyber/cyber.h"
-#include "modules/drivers/lidar/hesai/parser/parser.h"
+#include "modules/drivers/lidar/common/driver_factory/driver_base.h"
 #include "modules/drivers/lidar/hesai/input/udp_input.h"
+#include "modules/drivers/lidar/hesai/parser/parser.h"
+#include "modules/drivers/lidar/hesai/parser/parser_factory.h"
 
 namespace apollo {
 namespace drivers {
 namespace hesai {
 
-class HesaiDriver {
+class HesaiDriver : public apollo::drivers::lidar::LidarDriver {
  public:
   HesaiDriver(const std::shared_ptr&lt;::apollo::cyber::Node&gt;&amp; node,
-              const Config&amp; conf, const std::shared_ptr&lt;Parser&gt;&amp; parser)
-      : node_(node), conf_(conf), parser_(parser) {}
+              const ::apollo::drivers::lidar::config&amp; conf)
+      : node_(node), conf_(conf.hesai()) {}
+  HesaiDriver(const std::shared_ptr&lt;::apollo::cyber::Node&gt;&amp; node,
+              const ::apollo::drivers::hesai::Config&amp; conf)
+      : node_(node), conf_(conf) {}
   ~HesaiDriver() { Stop(); }
-  bool Init();
+  bool Init() override;
 
  private:
   std::shared_ptr&lt;::apollo::cyber::Node&gt; node_ = nullptr;
</diff>
			</file>
			<file old_path="modules\drivers\lidar\hesai\driver\hesai_component.cc" new_path="modules\drivers\lidar\hesai\driver\hesai_component.cc" added_lines="4" deleted_lines="9">
				<diff>@@ -20,19 +20,14 @@ namespace drivers {
 namespace hesai {
 
 bool HesaiComponent::Init() {
-  if (!GetProtoConfig(&amp;conf_)) {
+  if (!GetProtoConfig(&amp;hesai_conf_)) {
     AERROR &lt;&lt; "load config error, file:" &lt;&lt; config_file_path_;
     return false;
   }
 
-  AINFO &lt;&lt; "conf:" &lt;&lt; conf_.DebugString();
-  Parser* parser = ParserFactory::CreateParser(node_, conf_);
-  if (parser == nullptr) {
-    AERROR &lt;&lt; "create parser error";
-    return false;
-  }
-  parser_.reset(parser);
-  driver_.reset(new HesaiDriver(node_, conf_, parser_));
+  AINFO &lt;&lt; "conf:" &lt;&lt; hesai_conf_.DebugString();
+
+  driver_.reset(new HesaiDriver(node_, hesai_conf_));
 
   if (!driver_-&gt;Init()) {
     AERROR &lt;&lt; "driver init error";
</diff>
			</file>
			<file old_path="modules\drivers\lidar\hesai\driver\hesai_component.h" new_path="modules\drivers\lidar\hesai\driver\hesai_component.h" added_lines="3" deleted_lines="3">
				<diff>@@ -19,7 +19,8 @@
 #include &lt;memory&gt;
 #include &lt;string&gt;
 
-#include "modules/drivers/lidar/hesai/proto/config.pb.h"
+#include "modules/drivers/lidar/proto/config.pb.h"
+
 #include "cyber/cyber.h"
 #include "modules/drivers/lidar/hesai/driver/driver.h"
 #include "modules/drivers/lidar/hesai/parser/parser_factory.h"
@@ -35,8 +36,7 @@ class HesaiComponent : public ::apollo::cyber::Component&lt;&gt; {
 
  private:
   std::shared_ptr&lt;HesaiDriver&gt; driver_;
-  std::shared_ptr&lt;Parser&gt; parser_;
-  Config conf_;
+  Config hesai_conf_;
 };
 
 CYBER_REGISTER_COMPONENT(HesaiComponent)
</diff>
			</file>
			<file old_path="modules\drivers\lidar\hesai\parser\hesai_convert_component.h" new_path="modules\drivers\lidar\hesai\parser\hesai_convert_component.h" added_lines="3" deleted_lines="2">
				<diff>@@ -19,8 +19,9 @@
 #include &lt;memory&gt;
 #include &lt;string&gt;
 
-#include "modules/drivers/lidar/hesai/proto/config.pb.h"
-#include "modules/drivers/lidar/hesai/proto/hesai.pb.h"
+#include "modules/drivers/lidar/proto/hesai.pb.h"
+#include "modules/drivers/lidar/proto/hesai_config.pb.h"
+
 #include "cyber/cyber.h"
 #include "modules/drivers/lidar/hesai/parser/parser_factory.h"
 
</diff>
			</file>
			<file old_path="modules\drivers\lidar\hesai\parser\parser.h" new_path="modules\drivers\lidar\hesai\parser\parser.h" added_lines="2" deleted_lines="2">
				<diff>@@ -23,8 +23,8 @@
 #include &lt;thread&gt;
 #include &lt;vector&gt;
 
-#include "modules/drivers/lidar/hesai/proto/config.pb.h"
-#include "modules/drivers/lidar/hesai/proto/hesai.pb.h"
+#include "modules/drivers/lidar/proto/hesai_config.pb.h"
+#include "modules/drivers/lidar/proto/hesai.pb.h"
 #include "modules/drivers/proto/pointcloud.pb.h"
 
 #include "cyber/cyber.h"
</diff>
			</file>
			<file old_path="modules\drivers\lidar\robosense\driver\driver.cpp" new_path="modules\drivers\lidar\robosense\driver\driver.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -23,7 +23,7 @@ using apollo::cyber::Writer;
 using apollo::drivers::PointCloud;
 using apollo::drivers::PointXYZIT;
 using apollo::drivers::robosense::RobosenseScan;
-bool RobosenseDriver::init() {
+bool RobosenseDriver::Init() {
   if (node_ == nullptr) {
     AERROR &lt;&lt; "node is nullptr";
     return false;
</diff>
			</file>
			<file old_path="modules\drivers\lidar\robosense\driver\driver.h" new_path="modules\drivers\lidar\robosense\driver\driver.h" added_lines="10" deleted_lines="4">
				<diff>@@ -19,16 +19,19 @@
 #include &lt;thread&gt;
 #include &lt;vector&gt;
 
+#include "modules/drivers/lidar/proto/config.pb.h"
+#include "modules/drivers/lidar/proto/robosense.pb.h"
+#include "modules/drivers/lidar/proto/robosense_config.pb.h"
 #include "modules/drivers/proto/pointcloud.pb.h"
-#include "modules/drivers/lidar/robosense/proto/config.pb.h"
-#include "modules/drivers/lidar/robosense/proto/robosense.pb.h"
 
 #include "cyber/cyber.h"
+#include "modules/drivers/lidar/common/driver_factory/driver_base.h"
 #include "modules/drivers/lidar/robosense/decoder/decoder_16.hpp"
 #include "modules/drivers/lidar/robosense/decoder/decoder_factory.hpp"
 #include "modules/drivers/lidar/robosense/driver/utility.h"
 #include "modules/drivers/lidar/robosense/input/input.h"
 #define PKT_DATA_LENGTH 1248
+
 namespace apollo {
 namespace drivers {
 namespace robosense {
@@ -38,12 +41,15 @@ struct alignas(16) LidarPacketMsg {
   std::array&lt;uint8_t, PKT_DATA_LENGTH&gt; packet{};  ///&lt; lidar single packet
 };
 
-class RobosenseDriver {
+class RobosenseDriver : public lidar::LidarDriver {
  public:
+  RobosenseDriver(const std::shared_ptr&lt;cyber::Node&gt; &amp;node,
+                  const ::apollo::drivers::lidar::config &amp;config)
+      : node_(node), conf_(config.robosense()) {}
   RobosenseDriver(const std::shared_ptr&lt;cyber::Node&gt; &amp;node, const Config &amp;conf)
       : node_(node), conf_(conf) {}
   ~RobosenseDriver() { stop(); }
-  bool init();
+  bool Init() override;
 
  private:
   void getPackets();
</diff>
			</file>
			<file old_path="modules\drivers\lidar\robosense\driver\robosense_driver_component.h" new_path="modules\drivers\lidar\robosense\driver\robosense_driver_component.h" added_lines="1" deleted_lines="3">
				<diff>@@ -19,8 +19,6 @@
 #include &lt;string&gt;
 #include &lt;thread&gt;
 
-#include "modules/drivers/lidar/robosense/proto/config.pb.h"
-
 #include "cyber/cyber.h"
 #include "modules/drivers/lidar/robosense/driver/driver.h"
 
@@ -39,7 +37,7 @@ class RobosenseComponent : public Component&lt;&gt; {
       return false;
     }
     driver_.reset(new RobosenseDriver(node_, conf_));
-    if (!driver_-&gt;init()) {
+    if (!driver_-&gt;Init()) {
       AERROR &lt;&lt; "driver init error";
       return false;
     }
</diff>
			</file>
			<file old_path="modules\drivers\lidar\robosense\input\input.cpp" new_path="modules\drivers\lidar\robosense\input\input.cc" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="modules\drivers\lidar\velodyne\compensator\compensator.h" new_path="modules\drivers\lidar\velodyne\compensator\compensator.h" added_lines="3" deleted_lines="2">
				<diff>@@ -24,11 +24,12 @@
 // Eigen 3.3.7: #define ALIVE (0)
 // fastrtps: enum ChangeKind_t { ALIVE, ... };
 #if defined(ALIVE)
-#   undef ALIVE
+#undef ALIVE
 #endif
 
+#include "modules/drivers/lidar/proto/velodyne_config.pb.h"
 #include "modules/drivers/proto/pointcloud.pb.h"
-#include "modules/drivers/lidar/velodyne/proto/config.pb.h"
+
 #include "modules/transform/buffer.h"
 
 namespace apollo {
</diff>
			</file>
			<file old_path="modules\drivers\lidar\velodyne\compensator\compensator_component.cc" new_path="modules\drivers\lidar\velodyne\compensator\compensator_component.cc" added_lines="1" deleted_lines="2">
				<diff>@@ -21,7 +21,7 @@
 
 #include "modules/common/adapters/adapter_gflags.h"
 #include "modules/common/latency_recorder/latency_recorder.h"
-#include "modules/drivers/lidar/velodyne/proto/velodyne.pb.h"
+#include "modules/drivers/lidar/proto/velodyne.pb.h"
 
 using apollo::cyber::Time;
 
@@ -37,7 +37,6 @@ bool CompensatorComponent::Init() {
   }
 
   writer_ = node_-&gt;CreateWriter&lt;PointCloud&gt;(config.output_channel());
-
   compensator_.reset(new Compensator(config));
   compensator_pool_.reset(new CCObjectPool&lt;PointCloud&gt;(pool_size_));
   compensator_pool_-&gt;ConstructAll();
</diff>
			</file>
			<file old_path="modules\drivers\lidar\velodyne\driver\driver.cc" new_path="modules\drivers\lidar\velodyne\driver\driver.cc" added_lines="31" deleted_lines="11">
				<diff>@@ -22,8 +22,7 @@
 #include &lt;thread&gt;
 
 #include "cyber/cyber.h"
-#include "modules/drivers/lidar/velodyne/proto/config.pb.h"
-#include "modules/drivers/lidar/velodyne/proto/velodyne.pb.h"
+#include "modules/common/util/message_util.h"
 
 namespace apollo {
 namespace drivers {
@@ -32,12 +31,15 @@ namespace velodyne {
 uint64_t VelodyneDriver::sync_counter = 0;
 
 VelodyneDriver::~VelodyneDriver() {
+  if (poll_thread_.joinable()) {
+    poll_thread_.join();
+  }
   if (positioning_thread_.joinable()) {
     positioning_thread_.join();
   }
 }
 
-void VelodyneDriver::Init() {
+bool VelodyneDriver::Init() {
   double frequency = (config_.rpm() / 60.0);  // expected Hz rate
 
   // default number of packets for each scan is a single revolution
@@ -48,6 +50,7 @@ void VelodyneDriver::Init() {
   // open Velodyne input device
 
   input_.reset(new SocketInput());
+  writer_ = node_-&gt;CreateWriter&lt;VelodyneScan&gt;(config_.scan_channel());
   positioning_input_.reset(new SocketInput());
   input_-&gt;init(config_.firing_data_port());
   positioning_input_-&gt;init(config_.positioning_data_port());
@@ -55,6 +58,8 @@ void VelodyneDriver::Init() {
   // raw data output topic
   positioning_thread_ =
       std::thread(&amp;VelodyneDriver::PollPositioningPacket, this);
+  poll_thread_ = std::thread(&amp;VelodyneDriver::DevicePoll, this);
+  return true;
 }
 
 void VelodyneDriver::SetBaseTimeFromNmeaTime(NMEATimePtr nmea_time,
@@ -225,7 +230,8 @@ void VelodyneDriver::UpdateGpsTopHour(uint32_t current_time) {
   last_gps_time_ = current_time;
 }
 
-VelodyneDriver* VelodyneDriverFactory::CreateDriver(const Config&amp; config) {
+VelodyneDriver* VelodyneDriverFactory::CreateDriver(
+    const std::shared_ptr&lt;::apollo::cyber::Node&gt;&amp; node, const Config&amp; config) {
   auto new_config = config;
   if (new_config.prefix_angle() &gt; 35900 || new_config.prefix_angle() &lt; 100) {
     AWARN &lt;&lt; "invalid prefix angle, prefix_angle must be between 100 and 35900";
@@ -238,37 +244,37 @@ VelodyneDriver* VelodyneDriverFactory::CreateDriver(const Config&amp; config) {
   VelodyneDriver* driver = nullptr;
   switch (config.model()) {
     case HDL64E_S2: {
-      driver = new Velodyne64Driver(config);
+      driver = new Velodyne64Driver(node, config);
       driver-&gt;SetPacketRate(PACKET_RATE_HDL64E_S2);
       break;
     }
     case HDL64E_S3S: {
-      driver = new Velodyne64Driver(config);
+      driver = new Velodyne64Driver(node, config);
       driver-&gt;SetPacketRate(PACKET_RATE_HDL64E_S3S);
       break;
     }
     case HDL64E_S3D: {
-      driver = new Velodyne64Driver(config);
+      driver = new Velodyne64Driver(node, config);
       driver-&gt;SetPacketRate(PACKET_RATE_HDL64E_S3D);
       break;
     }
     case HDL32E: {
-      driver = new VelodyneDriver(config);
+      driver = new VelodyneDriver(node, config);
       driver-&gt;SetPacketRate(PACKET_RATE_HDL32E);
       break;
     }
     case VLP32C: {
-      driver = new VelodyneDriver(config);
+      driver = new VelodyneDriver(node, config);
       driver-&gt;SetPacketRate(PACKET_RATE_VLP32C);
       break;
     }
     case VLP16: {
-      driver = new VelodyneDriver(config);
+      driver = new VelodyneDriver(node, config);
       driver-&gt;SetPacketRate(PACKET_RATE_VLP16);
       break;
     }
     case VLS128: {
-      driver = new VelodyneDriver(config);
+      driver = new VelodyneDriver(node, config);
       driver-&gt;SetPacketRate(PACKET_RATE_VLS128);
       break;
     }
@@ -280,6 +286,20 @@ VelodyneDriver* VelodyneDriverFactory::CreateDriver(const Config&amp; config) {
   return driver;
 }
 
+void VelodyneDriver::DevicePoll() {
+  while (!apollo::cyber::IsShutdown()) {
+    // poll device until end of file
+    std::shared_ptr&lt;VelodyneScan&gt; scan = std::make_shared&lt;VelodyneScan&gt;();
+    bool ret = Poll(scan);
+    if (ret) {
+      apollo::common::util::FillHeader("velodyne", scan.get());
+      writer_-&gt;Write(scan);
+    } else {
+      AWARN &lt;&lt; "device poll failed";
+    }
+  }
+}
+
 }  // namespace velodyne
 }  // namespace drivers
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\drivers\lidar\velodyne\driver\driver.h" new_path="modules\drivers\lidar\velodyne\driver\driver.h" added_lines="27" deleted_lines="9">
				<diff>@@ -19,9 +19,12 @@
 #include &lt;memory&gt;
 #include &lt;string&gt;
 
+#include "modules/drivers/lidar/proto/config.pb.h"
+#include "modules/drivers/lidar/proto/velodyne.pb.h"
+#include "modules/drivers/lidar/proto/velodyne_config.pb.h"
+
+#include "modules/drivers/lidar/common/driver_factory/driver_base.h"
 #include "modules/drivers/lidar/velodyne/driver/socket_input.h"
-#include "modules/drivers/lidar/velodyne/proto/config.pb.h"
-#include "modules/drivers/lidar/velodyne/proto/velodyne.pb.h"
 
 namespace apollo {
 namespace drivers {
@@ -38,18 +41,27 @@ constexpr double PACKET_RATE_HDL64E_S3D = 5789;
 constexpr double PACKET_RATE_VLS128 = 6250.0;
 constexpr double PACKET_RATE_VLP32C = 1507.0;
 
-class VelodyneDriver {
+class VelodyneDriver : public lidar::LidarDriver {
  public:
+  VelodyneDriver() {}
   explicit VelodyneDriver(const Config &amp;config) : config_(config) {}
+  VelodyneDriver(const std::shared_ptr&lt;cyber::Node&gt; &amp;node,
+                          const Config &amp;config)
+      : config_(config) {
+    node_ = node;
+  }
   virtual ~VelodyneDriver();
 
   virtual bool Poll(const std::shared_ptr&lt;VelodyneScan&gt; &amp;scan);
-  virtual void Init();
+  bool Init() override;
   virtual void PollPositioningPacket();
   void SetPacketRate(const double packet_rate) { packet_rate_ = packet_rate; }
+  void DevicePoll();
 
  protected:
+  std::thread poll_thread_;
   Config config_;
+  std::shared_ptr&lt;apollo::cyber::Writer&lt;VelodyneScan&gt;&gt; writer_;
   std::unique_ptr&lt;Input&gt; input_ = nullptr;
   std::unique_ptr&lt;Input&gt; positioning_input_ = nullptr;
   std::string topic_;
@@ -61,7 +73,6 @@ class VelodyneDriver {
   static uint64_t sync_counter;
 
   std::thread positioning_thread_;
-
   virtual int PollStandard(std::shared_ptr&lt;VelodyneScan&gt; scan);
   bool SetBaseTime();
   void SetBaseTimeFromNmeaTime(NMEATimePtr nmea_time, uint64_t *basetime);
@@ -71,10 +82,16 @@ class VelodyneDriver {
 class Velodyne64Driver : public VelodyneDriver {
  public:
   explicit Velodyne64Driver(const Config &amp;config) : VelodyneDriver(config) {}
-  ~Velodyne64Driver() {}
-
-  void Init() override;
+  Velodyne64Driver(const std::shared_ptr&lt;cyber::Node&gt; &amp;node,
+                            const Config &amp;config) {
+    node_ = node;
+    config_ = config;
+  }
+  ~Velodyne64Driver();
+
+  bool Init() override;
   bool Poll(const std::shared_ptr&lt;VelodyneScan&gt; &amp;scan) override;
+  void DevicePoll();
 
  private:
   bool CheckAngle(const VelodynePacket &amp;packet);
@@ -83,7 +100,8 @@ class Velodyne64Driver : public VelodyneDriver {
 
 class VelodyneDriverFactory {
  public:
-  static VelodyneDriver *CreateDriver(const Config &amp;config);
+  static VelodyneDriver *CreateDriver(
+      const std::shared_ptr&lt;::apollo::cyber::Node&gt; &amp;node, const Config &amp;config);
 };
 
 }  // namespace velodyne
</diff>
			</file>
			<file old_path="modules\drivers\lidar\velodyne\driver\driver64.cc" new_path="modules\drivers\lidar\velodyne\driver\driver64.cc" added_lines="31" deleted_lines="1">
				<diff>@@ -18,14 +18,20 @@
 #include &lt;ctime&gt;
 #include &lt;string&gt;
 
+#include "modules/common/util/message_util.h"
 #include "modules/drivers/lidar/velodyne/driver/driver.h"
 // #include "ros/ros.h"
 
 namespace apollo {
 namespace drivers {
 namespace velodyne {
+Velodyne64Driver::~Velodyne64Driver() {
+  if (poll_thread_.joinable()) {
+    poll_thread_.join();
+  }
+}
 
-void Velodyne64Driver::Init() {
+bool Velodyne64Driver::Init() {
   const double frequency = config_.rpm() / 60.0;  // expected Hz rate
 
   // default number of packets for each scan is a single revolution
@@ -35,6 +41,14 @@ void Velodyne64Driver::Init() {
 
   input_.reset(new SocketInput());
   input_-&gt;init(config_.firing_data_port());
+
+  if (node_ == NULL) {
+    AERROR &lt;&lt; "node is NULL";
+    return false;
+  }
+  writer_ = node_-&gt;CreateWriter&lt;VelodyneScan&gt;(config_.scan_channel());
+  poll_thread_ = std::thread(&amp;Velodyne64Driver::DevicePoll, this);
+  return true;
 }
 
 /** poll the device
@@ -116,6 +130,22 @@ int Velodyne64Driver::PollStandardSync(std::shared_ptr&lt;VelodyneScan&gt; scan) {
   return 0;
 }
 
+void Velodyne64Driver::DevicePoll() {
+  while (!apollo::cyber::IsShutdown()) {
+    // poll device until end of file
+    std::shared_ptr&lt;VelodyneScan&gt; scan = std::make_shared&lt;VelodyneScan&gt;();
+    bool ret = Poll(scan);
+    if (ret) {
+      apollo::common::util::FillHeader("velodyne", scan.get());
+      writer_-&gt;Write(scan);
+    } else {
+      AWARN &lt;&lt; "device poll failed";
+    }
+  }
+
+  AERROR &lt;&lt; "CompVelodyneDriver thread exit";
+}
+
 }  // namespace velodyne
 }  // namespace drivers
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\drivers\lidar\velodyne\driver\input.h" new_path="modules\drivers\lidar\velodyne\driver\input.h" added_lines="1" deleted_lines="1">
				<diff>@@ -23,7 +23,7 @@
 #include "cyber/cyber.h"
 
 // #include "velodyne_msgs/VelodyneScanUnified.h"
-#include "modules/drivers/lidar/velodyne/proto/velodyne.pb.h"
+#include "modules/drivers/lidar/proto/velodyne.pb.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\lidar\velodyne\driver\velodyne_driver_component.cc" new_path="modules\drivers\lidar\velodyne\driver\velodyne_driver_component.cc" added_lines="6" deleted_lines="26">
				<diff>@@ -14,14 +14,14 @@
  * limitations under the License.
  *****************************************************************************/
 
+#include "modules/drivers/lidar/velodyne/driver/velodyne_driver_component.h"
+
 #include &lt;memory&gt;
 #include &lt;string&gt;
 #include &lt;thread&gt;
 
 #include "cyber/cyber.h"
-
 #include "modules/common/util/message_util.h"
-#include "modules/drivers/lidar/velodyne/driver/velodyne_driver_component.h"
 
 namespace apollo {
 namespace drivers {
@@ -35,8 +35,10 @@ bool VelodyneDriverComponent::Init() {
   }
   AINFO &lt;&lt; "Velodyne config: " &lt;&lt; velodyne_config.DebugString();
   // start the driver
-  writer_ = node_-&gt;CreateWriter&lt;VelodyneScan&gt;(velodyne_config.scan_channel());
-  VelodyneDriver *driver = VelodyneDriverFactory::CreateDriver(velodyne_config);
+  std::shared_ptr&lt;::apollo::cyber::Node&gt; node =
+      apollo::cyber::CreateNode("lidar_drivers");
+  VelodyneDriver *driver =
+      VelodyneDriverFactory::CreateDriver(node, velodyne_config);
   if (driver == nullptr) {
     return false;
   }
@@ -44,31 +46,9 @@ bool VelodyneDriverComponent::Init() {
   dvr_-&gt;Init();
   // spawn device poll thread
   runing_ = true;
-  device_thread_ = std::shared_ptr&lt;std::thread&gt;(
-      new std::thread(std::bind(&amp;VelodyneDriverComponent::device_poll, this)));
-  device_thread_-&gt;detach();
-
   return true;
 }
 
-/** @brief Device poll thread main loop. */
-void VelodyneDriverComponent::device_poll() {
-  while (!apollo::cyber::IsShutdown()) {
-    // poll device until end of file
-    std::shared_ptr&lt;VelodyneScan&gt; scan = std::make_shared&lt;VelodyneScan&gt;();
-    bool ret = dvr_-&gt;Poll(scan);
-    if (ret) {
-      common::util::FillHeader("velodyne", scan.get());
-      writer_-&gt;Write(scan);
-    } else {
-      AWARN &lt;&lt; "device poll failed";
-    }
-  }
-
-  AERROR &lt;&lt; "CompVelodyneDriver thread exit";
-  runing_ = false;
-}
-
 }  // namespace velodyne
 }  // namespace drivers
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\drivers\lidar\velodyne\driver\velodyne_driver_component.h" new_path="modules\drivers\lidar\velodyne\driver\velodyne_driver_component.h" added_lines="4" deleted_lines="11">
				<diff>@@ -19,11 +19,11 @@
 #include &lt;string&gt;
 #include &lt;thread&gt;
 
-#include "cyber/cyber.h"
+#include "modules/drivers/lidar/proto/velodyne.pb.h"
+#include "modules/drivers/lidar/proto/velodyne_config.pb.h"
 
+#include "cyber/cyber.h"
 #include "modules/drivers/lidar/velodyne/driver/driver.h"
-#include "modules/drivers/lidar/velodyne/proto/config.pb.h"
-#include "modules/drivers/lidar/velodyne/proto/velodyne.pb.h"
 
 namespace apollo {
 namespace drivers {
@@ -36,20 +36,13 @@ using apollo::drivers::velodyne::VelodyneScan;
 
 class VelodyneDriverComponent : public Component&lt;&gt; {
  public:
-  ~VelodyneDriverComponent() {
-    if (device_thread_-&gt;joinable()) {
-      device_thread_-&gt;join();
-    }
-  }
+  ~VelodyneDriverComponent() {}
   bool Init() override;
 
  private:
-  void device_poll();
   volatile bool runing_;  ///&lt; device thread is running
   uint32_t seq_ = 0;
-  std::shared_ptr&lt;std::thread&gt; device_thread_;
   std::shared_ptr&lt;VelodyneDriver&gt; dvr_;  ///&lt; driver implementation class
-  std::shared_ptr&lt;apollo::cyber::Writer&lt;VelodyneScan&gt;&gt; writer_;
 };
 
 CYBER_REGISTER_COMPONENT(VelodyneDriverComponent)
</diff>
			</file>
			<file old_path="modules\drivers\lidar\velodyne\fusion\pri_sec_fusion_component.h" new_path="modules\drivers\lidar\velodyne\fusion\pri_sec_fusion_component.h" added_lines="4" deleted_lines="3">
				<diff>@@ -25,12 +25,13 @@
 // Eigen 3.3.7: #define ALIVE (0)
 // fastrtps: enum ChangeKind_t { ALIVE, ... };
 #if defined(ALIVE)
-#   undef ALIVE
+#undef ALIVE
 #endif
 
-#include "cyber/cyber.h"
+#include "modules/drivers/lidar/proto/velodyne_config.pb.h"
 #include "modules/drivers/proto/pointcloud.pb.h"
-#include "modules/drivers/lidar/velodyne/proto/config.pb.h"
+
+#include "cyber/cyber.h"
 #include "modules/transform/buffer.h"
 
 namespace apollo {
</diff>
			</file>
			<file old_path="modules\drivers\lidar\velodyne\parser\convert.h" new_path="modules\drivers\lidar\velodyne\parser\convert.h" added_lines="2" deleted_lines="2">
				<diff>@@ -21,8 +21,8 @@
 
 #include "modules/drivers/proto/pointcloud.pb.h"
 #include "modules/drivers/lidar/velodyne/parser/velodyne_parser.h"
-#include "modules/drivers/lidar/velodyne/proto/config.pb.h"
-#include "modules/drivers/lidar/velodyne/proto/velodyne.pb.h"
+#include "modules/drivers/lidar/proto/velodyne_config.pb.h"
+#include "modules/drivers/lidar/proto/velodyne.pb.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\lidar\velodyne\parser\online_calibration.h" new_path="modules\drivers\lidar\velodyne\parser\online_calibration.h" added_lines="2" deleted_lines="2">
				<diff>@@ -20,10 +20,10 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
-#include "cyber/cyber.h"
+#include "modules/drivers/lidar/proto/velodyne.pb.h"
 
+#include "cyber/cyber.h"
 #include "modules/drivers/lidar/velodyne/parser/calibration.h"
-#include "modules/drivers/lidar/velodyne/proto/velodyne.pb.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\lidar\velodyne\parser\velodyne_convert_component.h" new_path="modules\drivers\lidar\velodyne\parser\velodyne_convert_component.h" added_lines="3" deleted_lines="3">
				<diff>@@ -21,12 +21,12 @@
 #include &lt;string&gt;
 #include &lt;thread&gt;
 
+#include "modules/drivers/lidar/proto/velodyne.pb.h"
+#include "modules/drivers/lidar/proto/velodyne_config.pb.h"
+
 #include "cyber/base/concurrent_object_pool.h"
 #include "cyber/cyber.h"
-
 #include "modules/drivers/lidar/velodyne/parser/convert.h"
-#include "modules/drivers/lidar/velodyne/proto/config.pb.h"
-#include "modules/drivers/lidar/velodyne/proto/velodyne.pb.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
			<file old_path="modules\drivers\lidar\velodyne\parser\velodyne_parser.h" new_path="modules\drivers\lidar\velodyne\parser\velodyne_parser.h" added_lines="3" deleted_lines="2">
				<diff>@@ -59,12 +59,13 @@
 
 #include &lt;boost/format.hpp&gt;
 
+#include "modules/drivers/lidar/proto/velodyne.pb.h"
+#include "modules/drivers/lidar/proto/velodyne_config.pb.h"
 #include "modules/drivers/proto/pointcloud.pb.h"
+
 #include "modules/drivers/lidar/velodyne/parser/calibration.h"
 #include "modules/drivers/lidar/velodyne/parser/const_variables.h"
 #include "modules/drivers/lidar/velodyne/parser/online_calibration.h"
-#include "modules/drivers/lidar/velodyne/proto/config.pb.h"
-#include "modules/drivers/lidar/velodyne/proto/velodyne.pb.h"
 
 namespace apollo {
 namespace drivers {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="438889c5cc06c2dfcf810a23106b03b4f3c8bef0" author="zhanggefan">
		<msg>Update postprocess_cuda.cu (#13263)

fix a bug that affects nms</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\postprocess_cuda.cu" new_path="modules\perception\lidar\lib\detection\lidar_point_pillars\postprocess_cuda.cu" added_lines="1" deleted_lines="1">
				<diff>@@ -134,7 +134,7 @@ __global__ void filter_kernel(
 
       xmin = fminf(xmin, offset_corners[i * 2 + 0]);
       ymin = fminf(ymin, offset_corners[i * 2 + 1]);
-      xmax = fmaxf(xmin, offset_corners[i * 2 + 0]);
+      xmax = fmaxf(xmax, offset_corners[i * 2 + 0]);
       ymax = fmaxf(ymax, offset_corners[i * 2 + 1]);
     }
     // box_for_nms(num_box, 4)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="210996789bd564aa5fb2c223d5c976dcf1455dfa" author="SeasoulChris">
		<msg>Perception: make lidar height file could be specified (#13226)

Co-authored-by: lishuanghua &lt;17302618@qq.com&gt;</msg>
		<modified_files>
			<file old_path="modules\perception\onboard\component\fusion_camera_detection_component.cc" new_path="modules\perception\onboard\component\fusion_camera_detection_component.cc" added_lines="40" deleted_lines="30">
				<diff>@@ -65,36 +65,6 @@ static int GetGpuId(const camera::CameraPerceptionInitOptions &amp;options) {
   return perception_param.gpu_id();
 }
 
-bool SetCameraHeight(const std::string &amp;sensor_name,
-                     const std::string &amp;params_dir, float default_camera_height,
-                     float *camera_height) {
-  float base_h = default_camera_height;
-  float camera_offset = 0.0f;
-  try {
-    YAML::Node lidar_height =
-        YAML::LoadFile(params_dir + "/" + "velodyne128_height.yaml");
-    base_h = lidar_height["vehicle"]["parameters"]["height"].as&lt;float&gt;();
-    AINFO &lt;&lt; base_h;
-    YAML::Node camera_ex =
-        YAML::LoadFile(params_dir + "/" + sensor_name + "_extrinsics.yaml");
-    camera_offset = camera_ex["transform"]["translation"]["z"].as&lt;float&gt;();
-    AINFO &lt;&lt; camera_offset;
-    *camera_height = base_h + camera_offset;
-  } catch (YAML::InvalidNode &amp;in) {
-    AERROR &lt;&lt; "load camera extrisic file error, YAML::InvalidNode exception";
-    return false;
-  } catch (YAML::TypedBadConversion&lt;float&gt; &amp;bc) {
-    AERROR &lt;&lt; "load camera extrisic file error, "
-           &lt;&lt; "YAML::TypedBadConversion exception";
-    return false;
-  } catch (YAML::Exception &amp;e) {
-    AERROR &lt;&lt; "load camera extrisic file "
-           &lt;&lt; " error, YAML exception:" &lt;&lt; e.what();
-    return false;
-  }
-  return true;
-}
-
 // @description: load camera extrinsics from yaml file
 bool LoadExtrinsics(const std::string &amp;yaml_file,
                     Eigen::Matrix4d *camera_extrinsic) {
@@ -1141,6 +1111,46 @@ int FusionCameraDetectionComponent::MakeCameraDebugMsg(
   return cyber::SUCC;
 }
 
+bool FusionCameraDetectionComponent::SetCameraHeight(
+     const std::string &amp;sensor_name,
+     const std::string &amp;params_dir, float default_camera_height,
+     float *camera_height) {
+  float base_height = default_camera_height;
+  float camera_offset = 0.0f;
+
+  apollo::perception::onboard::FusionCameraDetection
+  fusion_camera_detection_param;
+  if (!GetProtoConfig(&amp;fusion_camera_detection_param)) {
+    AINFO &lt;&lt; "load fusion camera detection component proto param failed";
+    return false;
+  }
+  std::string lidar_type =
+      fusion_camera_detection_param.lidar_type();
+  try {
+    YAML::Node lidar_height =
+        YAML::LoadFile(params_dir + "/" + lidar_type + "_height.yaml");
+    base_height = lidar_height["vehicle"]["parameters"]["height"].as&lt;float&gt;();
+    AINFO &lt;&lt; base_height;
+    YAML::Node camera_ex =
+        YAML::LoadFile(params_dir + "/" + sensor_name + "_extrinsics.yaml");
+    camera_offset = camera_ex["transform"]["translation"]["z"].as&lt;float&gt;();
+    AINFO &lt;&lt; camera_offset;
+    *camera_height = base_height + camera_offset;
+  } catch (YAML::InvalidNode &amp;in) {
+    AERROR &lt;&lt; "load camera extrisic file error, YAML::InvalidNode exception";
+    return false;
+  } catch (YAML::TypedBadConversion&lt;float&gt; &amp;bc) {
+    AERROR &lt;&lt; "load camera extrisic file error, "
+           &lt;&lt; "YAML::TypedBadConversion exception";
+    return false;
+  } catch (YAML::Exception &amp;e) {
+    AERROR &lt;&lt; "load camera extrisic file "
+           &lt;&lt; " error, YAML exception:" &lt;&lt; e.what();
+    return false;
+  }
+  return true;
+}
+
 }  // namespace onboard
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_camera_detection_component.h" new_path="modules\perception\onboard\component\fusion_camera_detection_component.h" added_lines="4" deleted_lines="0">
				<diff>@@ -76,6 +76,10 @@ class FusionCameraDetectionComponent : public apollo::cyber::Component&lt;&gt; {
   int InitMotionService();
   void SetCameraHeightAndPitch();
   void OnMotionService(const MotionServiceMsgType&amp; message);
+  bool SetCameraHeight(
+       const std::string &amp;sensor_name,
+       const std::string &amp;params_dir, float default_camera_height,
+       float *camera_height);
 
   int InternalProc(
       const std::shared_ptr&lt;apollo::drivers::Image const&gt;&amp; in_message,
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b0b7918e3f5ec995d56e320b10bd6b0507733488" author="">
		<msg>Dreamview:Loop routing optimization on master (#13274)

* Dreamview:loop routing add threshold at be,add no loop logic

* DV:modify the wrong indent and add build fe</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\common\dreamview_gflags.cc" new_path="modules\dreamview\backend\common\dreamview_gflags.cc" added_lines="3" deleted_lines="0">
				<diff>@@ -92,3 +92,6 @@ DEFINE_int32(monitor_msg_pending_queue_size, 10,
 DEFINE_string(default_data_collection_config_path,
               "/apollo/modules/dreamview/conf/data_collection_table.pb.txt",
               "Data collection table config path.");
+
+DEFINE_int32(loop_routing_end_to_start_distance_threshold, 10,
+             "Loop routing distance threshold: start to end");
</diff>
			</file>
			<file old_path="modules\dreamview\backend\common\dreamview_gflags.h" new_path="modules\dreamview\backend\common\dreamview_gflags.h" added_lines="2" deleted_lines="0">
				<diff>@@ -59,3 +59,5 @@ DECLARE_string(lidar_height_yaml);
 DECLARE_int32(monitor_msg_pending_queue_size);
 
 DECLARE_string(default_data_collection_config_path);
+
+DECLARE_int32(loop_routing_end_to_start_distance_threshold);
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" added_lines="2" deleted_lines="0">
				<diff>@@ -276,6 +276,8 @@ void SimulationWorldUpdater::RegisterMessageHandlers() {
       [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
         Json response;
         response["type"] = "DefaultRoutings";
+        response["threshold"] =
+            FLAGS_loop_routing_end_to_start_distance_threshold;
 
         Json default_routing_list = Json::array();
         if (LoadDefaultRoutings()) {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="919f4786570d73c5c811c4bd030e87ac256a39c2" author="Jiahao Chen (Jerold)">
		<msg>Perception: resume camera obstacle detection in sensor fusion (#13277)

* Perception: add camera obstacle detection to fusion

* Perception: modify default dag to use CNNSeg model</msg>
		<modified_files>
			<file old_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.cc" new_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -28,7 +28,7 @@ bool ObstacleMultiSensorFusion::Init(
   fusion_ = BaseFusionSystemRegisterer::GetInstanceByName(param.fusion_method);
 
   FusionInitOptions init_options;
-  init_options.main_sensor = param.main_sensor;
+  init_options.main_sensors = param.main_sensors;
   if (fusion_ == nullptr || !fusion_-&gt;Init(init_options)) {
     AINFO &lt;&lt; "Failed to Get Instance or Initialize " &lt;&lt; param.fusion_method;
     return false;
</diff>
			</file>
			<file old_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.h" new_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.h" added_lines="1" deleted_lines="1">
				<diff>@@ -25,7 +25,7 @@ namespace perception {
 namespace fusion {
 
 struct ObstacleMultiSensorFusionParam {
-  std::string main_sensor;
+  std::vector&lt;std::string&gt; main_sensors;
   std::string fusion_method;
 };
 
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\data_association\hm_data_association\hm_tracks_objects_match.cc" new_path="modules\perception\fusion\lib\data_association\hm_data_association\hm_tracks_objects_match.cc" added_lines="1" deleted_lines="0">
				<diff>@@ -65,6 +65,7 @@ bool HMTrackersObjectsAssociation::Associate(
   double measurement_timestamp = sensor_objects[0]-&gt;GetTimestamp();
   track_object_distance_.ResetProjectionCache(measurement_sensor_id,
                                               measurement_timestamp);
+  // TODO(chenjiahao): specify prohibited sensors in config
   bool do_nothing = (sensor_objects[0]-&gt;GetSensorId() == "radar_front");
   IdAssign(fusion_tracks, sensor_objects, &amp;association_result-&gt;assignments,
            &amp;association_result-&gt;unassigned_tracks,
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\dummy\dummy_algorithms.cc" new_path="modules\perception\fusion\lib\dummy\dummy_algorithms.cc" added_lines="3" deleted_lines="2">
				<diff>@@ -21,7 +21,7 @@ namespace fusion {
 
 // class DummyFusionSystem implementation
 bool DummyFusionSystem::Init(const FusionInitOptions&amp; options) {
-  main_sensor_ = options.main_sensor;
+  main_sensors_ = options.main_sensors;
   return true;
 }
 
@@ -33,7 +33,8 @@ bool DummyFusionSystem::Fuse(const FusionOptions&amp; options,
   }
 
   fused_objects-&gt;clear();
-  if (sensor_frame-&gt;sensor_info.name != main_sensor_) {
+  if (std::find(main_sensors_.begin(), main_sensors_.end(),
+                sensor_frame-&gt;sensor_info.name) == main_sensors_.end()) {
     return true;
   }
 
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\dummy\dummy_algorithms_test.cc" new_path="modules\perception\fusion\lib\dummy\dummy_algorithms_test.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -29,7 +29,7 @@ namespace fusion {
 
 TEST(DummyFusionSystemTest, test) {
   FusionInitOptions init_options;
-  init_options.main_sensor = "velodyne64";
+  init_options.main_sensors = std::vector&lt;std::string&gt;{"velodyne64"};
   DummyFusionSystem system;
   EXPECT_TRUE(system.Init(init_options));
 
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\fusion_system\probabilistic_fusion\probabilistic_fusion.cc" new_path="modules\perception\fusion\lib\fusion_system\probabilistic_fusion\probabilistic_fusion.cc" added_lines="9" deleted_lines="12">
				<diff>@@ -43,7 +43,7 @@ ProbabilisticFusion::ProbabilisticFusion() {}
 ProbabilisticFusion::~ProbabilisticFusion() {}
 
 bool ProbabilisticFusion::Init(const FusionInitOptions&amp; init_options) {
-  main_sensor_ = init_options.main_sensor;
+  main_sensors_ = init_options.main_sensors;
 
   BaseInitOptions options;
   if (!GetFusionInitOptions("ProbabilisticFusion", &amp;options)) {
@@ -166,16 +166,13 @@ std::string ProbabilisticFusion::Name() const { return "ProbabilisticFusion"; }
 bool ProbabilisticFusion::IsPublishSensor(
     const base::FrameConstPtr&amp; sensor_frame) const {
   std::string sensor_id = sensor_frame-&gt;sensor_info.name;
-  return sensor_id == main_sensor_;
-  // const std::vector&lt;std::string&gt;&amp; pub_sensors =
-  //   params_.publish_sensor_ids;
-  // const auto&amp; itr = std::find(
-  //   pub_sensors.begin(), pub_sensors.end(), sensor_id);
-  // if (itr != pub_sensors.end()) {
-  //   return true;
-  // } else {
-  //   return false;
-  // }
+  const auto&amp; itr = std::find(
+      main_sensors_.begin(), main_sensors_.end(), sensor_id);
+  if (itr != main_sensors_.end()) {
+    return true;
+  } else {
+    return false;
+  }
 }
 
 void ProbabilisticFusion::FuseFrame(const SensorFramePtr&amp; frame) {
@@ -352,7 +349,7 @@ void ProbabilisticFusion::RemoveLostTrack() {
     }
   }
   AINFO &lt;&lt; "Remove " &lt;&lt; foreground_tracks.size() - foreground_track_count
-        &lt;&lt; " foreground tracks";
+        &lt;&lt; " foreground tracks. " &lt;&lt; foreground_track_count &lt;&lt; " tracks left.";
   foreground_tracks.resize(foreground_track_count);
   trackers_.resize(foreground_track_count);
 
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\fusion_system\probabilistic_fusion\probabilistic_fusion_test.cc" new_path="modules\perception\fusion\lib\fusion_system\probabilistic_fusion\probabilistic_fusion_test.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -37,7 +37,7 @@ TEST(ProbabliticFusionTest, test_init) {
   sensor_manager-&gt;Reset();
   sensor_manager-&gt;Init();
   FusionInitOptions init_options;
-  init_options.main_sensor = "velodyne64";
+  init_options.main_sensors = std::vector&lt;std::string&gt;{"velodyne64"};
   ProbabilisticFusion pf;
   EXPECT_TRUE(pf.Init(init_options));
   EXPECT_EQ(pf.Name(), "ProbabilisticFusion");
@@ -106,7 +106,7 @@ TEST(ProbabliticFusionTest, test_update) {
   sensor_manager-&gt;Reset();
   sensor_manager-&gt;Init();
   FusionInitOptions init_options;
-  init_options.main_sensor = "velodyne64";
+  init_options.main_sensors = std::vector&lt;std::string&gt;{"velodyne64"};
   ProbabilisticFusion pf;
   EXPECT_TRUE(pf.Init(init_options));
   EXPECT_EQ(pf.Name(), "ProbabilisticFusion");
@@ -257,7 +257,7 @@ TEST(ProbabilisticFusionTest, test_collect_sensor_measurement) {
   sensor_manager-&gt;Reset();
   sensor_manager-&gt;Init();
   FusionInitOptions init_options;
-  init_options.main_sensor = "velodyne64";
+  init_options.main_sensors = std::vector&lt;std::string&gt;{"velodyne64"};
   ProbabilisticFusion pf;
   EXPECT_TRUE(pf.Init(init_options));
   EXPECT_EQ(pf.Name(), "ProbabilisticFusion");
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\gatekeeper\pbf_gatekeeper\pbf_gatekeeper.cc" new_path="modules\perception\fusion\lib\gatekeeper\pbf_gatekeeper\pbf_gatekeeper.cc" added_lines="1" deleted_lines="0">
				<diff>@@ -111,6 +111,7 @@ bool PbfGatekeeper::RadarAbleToPublish(const TrackPtr &amp;track, bool is_night) {
   if (params_.publish_if_has_radar &amp;&amp; visible_in_radar &amp;&amp;
       radar_object != nullptr) {
     if (radar_object-&gt;GetSensorId() == "radar_front") {
+      // TODO(henjiahao): enable radar front
       return false;
       // if (radar_object-&gt;GetBaseObject()-&gt;radar_supplement.range &gt;
       //         params_.min_radar_confident_distance &amp;&amp;
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\interface\base_fusion_system.h" new_path="modules\perception\fusion\lib\interface\base_fusion_system.h" added_lines="2" deleted_lines="2">
				<diff>@@ -29,7 +29,7 @@ namespace perception {
 namespace fusion {
 
 struct FusionInitOptions {
-  std::string main_sensor;
+  std::vector&lt;std::string&gt; main_sensors;
 };
 
 struct FusionOptions {};
@@ -54,7 +54,7 @@ class BaseFusionSystem {
   virtual std::string Name() const = 0;
 
  protected:
-  std::string main_sensor_;
+  std::vector&lt;std::string&gt; main_sensors_;
 };
 
 PERCEPTION_REGISTER_REGISTERER(BaseFusionSystem);
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_component.cc" new_path="modules\perception\onboard\component\fusion_component.cc" added_lines="19" deleted_lines="19">
				<diff>@@ -37,7 +37,9 @@ bool FusionComponent::Init() {
 
   // to load component configs
   fusion_method_ = comp_config.fusion_method();
-  fusion_main_sensor_ = comp_config.fusion_main_sensor();
+  for (int i = 0; i &lt; comp_config.fusion_main_sensors_size(); ++i) {
+    fusion_main_sensors_.push_back(comp_config.fusion_main_sensors(i));
+  }
   object_in_roi_check_ = comp_config.object_in_roi_check();
   radius_for_roi_object_check_ = comp_config.radius_for_roi_object_check();
 
@@ -58,21 +60,23 @@ bool FusionComponent::Proc(const std::shared_ptr&lt;SensorFrameMessage&gt;&amp; message) {
                                                        PerceptionObstacles);
   std::shared_ptr&lt;SensorFrameMessage&gt; viz_message(new (std::nothrow)
                                                       SensorFrameMessage);
+
+  // TODO(convert sensor id)
+  const auto&amp; itr = std::find(fusion_main_sensors_.begin(),
+                              fusion_main_sensors_.end(), message-&gt;sensor_id_);
+  if (itr == fusion_main_sensors_.end()) {
+    AINFO &lt;&lt; "Fusion receives message from " &lt;&lt; message-&gt;sensor_id_
+          &lt;&lt; " which is not in main sensors. Skip sending.";
+    return true;
+  }
+
   bool status = InternalProc(message, out_message, viz_message);
   if (status) {
-    // TODO(conver sensor id)
-    if (message-&gt;sensor_id_ != fusion_main_sensor_) {
-      AINFO &lt;&lt; "Fusion receive from " &lt;&lt; message-&gt;sensor_id_ &lt;&lt; "not from "
-            &lt;&lt; fusion_main_sensor_ &lt;&lt; ". Skip send.";
-    } else {
-      // Send("/apollo/perception/obstacles", out_message);
-      writer_-&gt;Write(out_message);
-      AINFO &lt;&lt; "Send fusion processing output message.";
-      // send msg for visualization
-      if (FLAGS_obs_enable_visualization) {
-        // Send("/apollo/perception/inner/PrefusedObjects", viz_message);
-        inner_writer_-&gt;Write(viz_message);
-      }
+    writer_-&gt;Write(out_message);
+    AINFO &lt;&lt; "Send fusion processing output message.";
+    // send msg for visualization
+    if (FLAGS_obs_enable_visualization) {
+      inner_writer_-&gt;Write(viz_message);
     }
   }
   return status;
@@ -81,7 +85,7 @@ bool FusionComponent::Proc(const std::shared_ptr&lt;SensorFrameMessage&gt;&amp; message) {
 bool FusionComponent::InitAlgorithmPlugin() {
   fusion_.reset(new fusion::ObstacleMultiSensorFusion());
   fusion::ObstacleMultiSensorFusionParam param;
-  param.main_sensor = fusion_main_sensor_;
+  param.main_sensors = fusion_main_sensors_;
   param.fusion_method = fusion_method_;
   ACHECK(fusion_-&gt;Init(param)) &lt;&lt; "Failed to init ObstacleMultiSensorFusion";
 
@@ -130,10 +134,6 @@ bool FusionComponent::InternalProc(
   }
   PERF_BLOCK_END_WITH_INDICATOR("fusion_process", in_message-&gt;sensor_id_);
 
-  if (in_message-&gt;sensor_id_ != fusion_main_sensor_) {
-    return true;
-  }
-
   Eigen::Matrix4d sensor2world_pose =
       in_message-&gt;frame_-&gt;sensor2world_pose.matrix();
   if (object_in_roi_check_ &amp;&amp; FLAGS_obs_enable_hdmap_input) {
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_component.h" new_path="modules\perception\onboard\component\fusion_component.h" added_lines="1" deleted_lines="1">
				<diff>@@ -49,7 +49,7 @@ class FusionComponent : public cyber::Component&lt;SensorFrameMessage&gt; {
   static uint32_t s_seq_num_;
 
   std::string fusion_method_;
-  std::string fusion_main_sensor_;
+  std::vector&lt;std::string&gt; fusion_main_sensors_;
   bool object_in_roi_check_ = false;
   double radius_for_roi_object_check_ = 0;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a7f25a7b895d1e5f41e7778b6d4721f569592a55" author="daohu527">
		<msg>cyber: remove poco shared library dependency

rebased on master HEAD</msg>
		<modified_files>
			<file old_path="cyber\class_loader\utility\class_loader_utility.cc" new_path="cyber\class_loader\utility\class_loader_utility.cc" added_lines="28" deleted_lines="28">
				<diff>@@ -28,7 +28,7 @@ std::recursive_mutex&amp; GetClassFactoryMapMapMutex() {
   return m;
 }
 
-std::recursive_mutex&amp; GetLibPathPocoShareLibMutex() {
+std::recursive_mutex&amp; GetLibPathShareLibMutex() {
   static std::recursive_mutex m;
   return m;
 }
@@ -38,8 +38,8 @@ BaseToClassFactoryMapMap&amp; GetClassFactoryMapMap() {
   return instance;
 }
 
-LibpathPocolibVector&amp; GetLibPathPocoShareLibVector() {
-  static LibpathPocolibVector instance;
+LibpathSharedlibVector&amp; GetLibPathShareLibVector() {
+  static LibpathSharedlibVector instance;
   return instance;
 }
 
@@ -151,10 +151,10 @@ void DestroyClassFactoryObjectsOfLibrary(const std::string&amp; library_path,
   }
 }
 
-LibpathPocolibVector::iterator FindLoadedLibrary(
+LibpathSharedlibVector::iterator FindLoadedLibrary(
     const std::string&amp; library_path) {
-  LibpathPocolibVector&amp; opened_libraries = GetLibPathPocoShareLibVector();
-  LibpathPocolibVector::iterator itr;
+  LibpathSharedlibVector&amp; opened_libraries = GetLibPathShareLibVector();
+  LibpathSharedlibVector::iterator itr;
   for (itr = opened_libraries.begin(); itr != opened_libraries.end(); ++itr) {
     if (itr-&gt;first == library_path) {
       break;
@@ -164,10 +164,10 @@ LibpathPocolibVector::iterator FindLoadedLibrary(
 }
 
 bool IsLibraryLoadedByAnybody(const std::string&amp; library_path) {
-  std::lock_guard&lt;std::recursive_mutex&gt; lck(GetLibPathPocoShareLibMutex());
+  std::lock_guard&lt;std::recursive_mutex&gt; lck(GetLibPathShareLibMutex());
 
-  LibpathPocolibVector&amp; opened_libraries = GetLibPathPocoShareLibVector();
-  LibpathPocolibVector::iterator itr = FindLoadedLibrary(library_path);
+  LibpathSharedlibVector&amp; opened_libraries = GetLibPathShareLibVector();
+  LibpathSharedlibVector::iterator itr = FindLoadedLibrary(library_path);
   return itr != opened_libraries.end();
 }
 
@@ -205,7 +205,7 @@ bool LoadLibrary(const std::string&amp; library_path, ClassLoader* loader) {
     return true;
   }
 
-  PocoLibraryPtr poco_library = nullptr;
+  SharedLibraryPtr shared_library = nullptr;
   static std::recursive_mutex loader_mutex;
   {
     std::lock_guard&lt;std::recursive_mutex&gt; lck(loader_mutex);
@@ -213,27 +213,27 @@ bool LoadLibrary(const std::string&amp; library_path, ClassLoader* loader) {
     try {
       SetCurActiveClassLoader(loader);
       SetCurLoadingLibraryName(library_path);
-      poco_library = PocoLibraryPtr(new Poco::SharedLibrary(library_path));
-    } catch (const Poco::LibraryLoadException&amp; e) {
+      shared_library = SharedLibraryPtr(new SharedLibrary(library_path));
+    } catch (const LibraryLoadException&amp; e) {
       SetCurLoadingLibraryName("");
       SetCurActiveClassLoader(nullptr);
-      AERROR &lt;&lt; "poco LibraryLoadException: " &lt;&lt; e.message();
-    } catch (const Poco::LibraryAlreadyLoadedException&amp; e) {
+      AERROR &lt;&lt; "LibraryLoadException: " &lt;&lt; e.what();
+    } catch (const LibraryAlreadyLoadedException&amp; e) {
       SetCurLoadingLibraryName("");
       SetCurActiveClassLoader(nullptr);
-      AERROR &lt;&lt; "poco LibraryAlreadyLoadedException: " &lt;&lt; e.message();
-    } catch (const Poco::NotFoundException&amp; e) {
+      AERROR &lt;&lt; "LibraryAlreadyLoadedException: " &lt;&lt; e.what();
+    } catch (const NotFoundException&amp; e) {
       SetCurLoadingLibraryName("");
       SetCurActiveClassLoader(nullptr);
-      AERROR &lt;&lt; "poco NotFoundException: " &lt;&lt; e.message();
+      AERROR &lt;&lt; "NotFoundException: " &lt;&lt; e.what();
     }
 
     SetCurLoadingLibraryName("");
     SetCurActiveClassLoader(nullptr);
   }
 
-  if (poco_library == nullptr) {
-    AERROR &lt;&lt; "poco shared library failed: " &lt;&lt; library_path;
+  if (shared_library == nullptr) {
+    AERROR &lt;&lt; "shared library failed: " &lt;&lt; library_path;
     return false;
   }
 
@@ -242,18 +242,18 @@ bool LoadLibrary(const std::string&amp; library_path, ClassLoader* loader) {
     AWARN &lt;&lt; "Class factory objs counts is 0, maybe registerclass failed.";
   }
 
-  std::lock_guard&lt;std::recursive_mutex&gt; lck(GetLibPathPocoShareLibMutex());
-  LibpathPocolibVector&amp; opened_libraries = GetLibPathPocoShareLibVector();
+  std::lock_guard&lt;std::recursive_mutex&gt; lck(GetLibPathShareLibMutex());
+  LibpathSharedlibVector&amp; opened_libraries = GetLibPathShareLibVector();
   opened_libraries.emplace_back(
-      std::pair&lt;std::string, PocoLibraryPtr&gt;(library_path, poco_library));
+      std::pair&lt;std::string, SharedLibraryPtr&gt;(library_path, shared_library));
   return true;
 }
 
 void UnloadLibrary(const std::string&amp; library_path, ClassLoader* loader) {
   {
-    std::lock_guard&lt;std::recursive_mutex&gt; lck(GetLibPathPocoShareLibMutex());
-    LibpathPocolibVector&amp; opened_libraries = GetLibPathPocoShareLibVector();
-    LibpathPocolibVector::iterator itr = FindLoadedLibrary(library_path);
+    std::lock_guard&lt;std::recursive_mutex&gt; lck(GetLibPathShareLibMutex());
+    LibpathSharedlibVector&amp; opened_libraries = GetLibPathShareLibVector();
+    LibpathSharedlibVector::iterator itr = FindLoadedLibrary(library_path);
     if (itr == opened_libraries.end()) {
       AERROR &lt;&lt; "Attempt to UnloadLibrary lib, but can't find lib: "
              &lt;&lt; library_path;
@@ -265,15 +265,15 @@ void UnloadLibrary(const std::string&amp; library_path, ClassLoader* loader) {
       DestroyClassFactoryObjectsOfLibrary(library_path, loader);
 
       if (GetAllClassFactoryObjectsOfLibrary(library_path).empty()) {
-        itr-&gt;second-&gt;unload();
+        itr-&gt;second-&gt;Unload();
         itr = opened_libraries.erase(itr);
       } else {
         AWARN &lt;&lt; "ClassFactory Objects still remain in memory,meaning other "
                  "ClassLoaders are still using library:"
               &lt;&lt; library_path;
       }
-    } catch (const Poco::RuntimeException&amp; e) {
-      AERROR &lt;&lt; "library unLoad error: Poco::RuntimeException: " &lt;&lt; e.message();
+    } catch (const std::exception&amp; e) {
+      AERROR &lt;&lt; "library unLoad error: " &lt;&lt; e.what();
     }
   }
 }
</diff>
			</file>
			<file old_path="cyber\class_loader\utility\class_loader_utility.h" new_path="cyber\class_loader\utility\class_loader_utility.h" added_lines="6" deleted_lines="7">
				<diff>@@ -28,8 +28,7 @@
 #include &lt;utility&gt;
 #include &lt;vector&gt;
 
-#include "Poco/SharedLibrary.h"
-
+#include "cyber/class_loader/utility/shared_library.h"
 #include "cyber/class_loader/utility/class_factory.h"
 #include "cyber/common/log.h"
 
@@ -44,18 +43,18 @@ class ClassLoader;
 
 namespace utility {
 
-using PocoLibraryPtr = std::shared_ptr&lt;Poco::SharedLibrary&gt;;
+using SharedLibraryPtr = std::shared_ptr&lt;SharedLibrary&gt;;
 using ClassClassFactoryMap =
     std::map&lt;std::string, utility::AbstractClassFactoryBase*&gt;;
 using BaseToClassFactoryMapMap = std::map&lt;std::string, ClassClassFactoryMap&gt;;
-using LibpathPocolibVector =
-    std::vector&lt;std::pair&lt;std::string, PocoLibraryPtr&gt;&gt;;
+using LibpathSharedlibVector =
+    std::vector&lt;std::pair&lt;std::string, SharedLibraryPtr&gt;&gt;;
 using ClassFactoryVector = std::vector&lt;AbstractClassFactoryBase*&gt;;
 
 BaseToClassFactoryMapMap&amp; GetClassFactoryMapMap();
 std::recursive_mutex&amp; GetClassFactoryMapMapMutex();
-LibpathPocolibVector&amp; GetLibPathPocoShareLibVector();
-std::recursive_mutex&amp; GetLibPathPocoShareLibMutex();
+LibpathSharedlibVector&amp; GetLibPathShareLibVector();
+std::recursive_mutex&amp; GetLibPathShareLibMutex();
 ClassClassFactoryMap&amp; GetClassFactoryMapByBaseClass(
     const std::string&amp; typeid_base_class_name);
 std::string GetCurLoadingLibraryName();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a41746450144a39ee641c40f6c4f1f541a120a73" author="storypku">
		<msg>cyber: reorg optimized shared_library into independent directory</msg>
		<modified_files>
			<file old_path="cyber\class_loader\utility\shared_library.cc" new_path="cyber\class_loader\shared_library\shared_library.cc" added_lines="14" deleted_lines="16">
				<diff>@@ -14,32 +14,31 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "cyber/class_loader/utility/shared_library.h"
+#include "cyber/class_loader/shared_library/shared_library.h"
 
 #include &lt;dlfcn.h&gt;
 
 namespace apollo {
 namespace cyber {
 namespace class_loader {
-namespace utility {
 
 SharedLibrary::SharedLibrary() : handle_(nullptr) {}
 
-SharedLibrary::SharedLibrary(const std::string&amp; filename) {
-  Load(filename, 0);
+SharedLibrary::SharedLibrary(const std::string&amp; path) {
+  Load(path, 0);
 }
 
-SharedLibrary::SharedLibrary(const std::string&amp; filename, int flags) {
-  Load(filename, flags);
+SharedLibrary::SharedLibrary(const std::string&amp; path, int flags) {
+  Load(path, flags);
 }
 
-void SharedLibrary::Load(const std::string&amp; filename) {
-  Load(filename, 0);
+void SharedLibrary::Load(const std::string&amp; path) {
+  Load(path, 0);
 }
 
-void SharedLibrary::Load(const std::string&amp; filename, int flags) {
+void SharedLibrary::Load(const std::string&amp; path, int flags) {
   std::lock_guard&lt;std::mutex&gt; lock(mutex_);
-  if (handle_) throw LibraryAlreadyLoadedException(filename);
+  if (handle_) throw LibraryAlreadyLoadedException(path);
 
   int real_flag = RTLD_LAZY;
   if (flags &amp; SHLIB_LOCAL) {
@@ -47,13 +46,13 @@ void SharedLibrary::Load(const std::string&amp; filename, int flags) {
   } else {
     real_flag |= SHLIB_GLOBAL;
   }
-  handle_ = dlopen(filename.c_str(), real_flag);
+  handle_ = dlopen(path.c_str(), real_flag);
   if (!handle_) {
     const char* err = dlerror();
-    throw LibraryLoadException(err ? std::string(err) : filename);
+    throw LibraryLoadException(err ? std::string(err) : path);
   }
 
-  filename_ = filename;
+  path_ = path;
 }
 
 void SharedLibrary::Unload() {
@@ -79,7 +78,7 @@ void* SharedLibrary::GetSymbol(const std::string&amp; name) {
 
   void* result = dlsym(handle_, name.c_str());
   if (!result) {
-    throw NotFoundException(name);
+    throw SymbolNotFoundException(name);
   }
 
   return result;
@@ -90,7 +89,6 @@ SharedLibrary::~SharedLibrary() {
 }
 
 
-}  // namespace utility
-}  // namespace class_loader
+}  // namespace shared_library
 }  // namespace cyber
 }  // namespace apollo
</diff>
			</file>
			<file old_path="cyber\class_loader\utility\shared_library.h" new_path="cyber\class_loader\shared_library\shared_library.h" added_lines="12" deleted_lines="14">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
+ * Copyright 2020 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,18 +14,17 @@
  * limitations under the License.
  *****************************************************************************/
 
-#ifndef CYBER_CLASS_LOADER_UTILITY_SHARED_LIBRARY_H_
-#define CYBER_CLASS_LOADER_UTILITY_SHARED_LIBRARY_H_
+#ifndef CYBER_CLASS_LOADER_SHARED_LIBRARY_H_
+#define CYBER_CLASS_LOADER_SHARED_LIBRARY_H_
 
 #include &lt;string&gt;
 #include &lt;mutex&gt;
 
-#include "cyber/class_loader/utility/exception.h"
+#include "cyber/class_loader/shared_library/exceptions.h"
 
 namespace apollo {
 namespace cyber {
 namespace class_loader {
-namespace utility {
 
 class SharedLibrary {
  public:
@@ -36,15 +35,15 @@ class SharedLibrary {
 
   SharedLibrary();
 
-  explicit SharedLibrary(const std::string&amp; filename);
+  explicit SharedLibrary(const std::string&amp; path);
 
-  SharedLibrary(const std::string&amp; filename, int flags);
+  SharedLibrary(const std::string&amp; path, int flags);
 
   virtual ~SharedLibrary();
 
-  void Load(const std::string&amp; filename);
+  void Load(const std::string&amp; path);
 
-  void Load(const std::string&amp; filename, int flags);
+  void Load(const std::string&amp; path, int flags);
 
   void Unload();
 
@@ -54,21 +53,20 @@ class SharedLibrary {
 
   void* GetSymbol(const std::string&amp; name);
 
-  inline const std::string&amp; GetPath() const { return filename_; }
+  inline const std::string&amp; GetPath() const { return path_; }
 
   SharedLibrary(const SharedLibrary&amp;) = delete;
   SharedLibrary&amp; operator=(const SharedLibrary&amp;) = delete;
 
  private:
-  void* handle_;
-  std::string filename_;
+  void* handle_ = nullptr;
+  std::string path_;
 
   std::mutex mutex_;
 };
 
-}  // namespace utility
 }  // namespace class_loader
 }  // namespace cyber
 }  // namespace apollo
 
-#endif  // CYBER_CLASS_LOADER_UTILITY_SHARED_LIBRARY_H_
+#endif  // CYBER_CLASS_LOADER_SHARED_LIBRARY_H_
</diff>
			</file>
			<file old_path="cyber\class_loader\utility\class_loader_utility.cc" new_path="cyber\class_loader\utility\class_loader_utility.cc" added_lines="21" deleted_lines="21">
				<diff>@@ -28,7 +28,7 @@ std::recursive_mutex&amp; GetClassFactoryMapMapMutex() {
   return m;
 }
 
-std::recursive_mutex&amp; GetLibPathShareLibMutex() {
+std::recursive_mutex&amp; GetLibPathSharedLibMutex() {
   static std::recursive_mutex m;
   return m;
 }
@@ -38,8 +38,8 @@ BaseToClassFactoryMapMap&amp; GetClassFactoryMapMap() {
   return instance;
 }
 
-LibpathSharedlibVector&amp; GetLibPathShareLibVector() {
-  static LibpathSharedlibVector instance;
+LibPathSharedLibVector&amp; GetLibPathSharedLibVector() {
+  static LibPathSharedLibVector instance;
   return instance;
 }
 
@@ -127,7 +127,7 @@ void DestroyClassFactoryObjectsOfLibrary(
     if (class_factory_object-&gt;GetRelativeLibraryPath() == library_path &amp;&amp;
         class_factory_object-&gt;IsOwnedBy(class_loader)) {
       class_factory_object-&gt;RemoveOwnedClassLoader(class_loader);
-      // when no anybody owner,delete &amp;&amp; erase
+      // when no anybody owner, delete &amp;&amp; erase
       if (!class_factory_object-&gt;IsOwnedByAnybody()) {
         itr = class_factory_map-&gt;erase(itr);
         delete class_factory_object;
@@ -151,10 +151,10 @@ void DestroyClassFactoryObjectsOfLibrary(const std::string&amp; library_path,
   }
 }
 
-LibpathSharedlibVector::iterator FindLoadedLibrary(
+LibPathSharedLibVector::iterator FindLoadedLibrary(
     const std::string&amp; library_path) {
-  LibpathSharedlibVector&amp; opened_libraries = GetLibPathShareLibVector();
-  LibpathSharedlibVector::iterator itr;
+  LibPathSharedLibVector&amp; opened_libraries = GetLibPathSharedLibVector();
+  LibPathSharedLibVector::iterator itr;
   for (itr = opened_libraries.begin(); itr != opened_libraries.end(); ++itr) {
     if (itr-&gt;first == library_path) {
       break;
@@ -164,10 +164,10 @@ LibpathSharedlibVector::iterator FindLoadedLibrary(
 }
 
 bool IsLibraryLoadedByAnybody(const std::string&amp; library_path) {
-  std::lock_guard&lt;std::recursive_mutex&gt; lck(GetLibPathShareLibMutex());
+  std::lock_guard&lt;std::recursive_mutex&gt; lck(GetLibPathSharedLibMutex());
 
-  LibpathSharedlibVector&amp; opened_libraries = GetLibPathShareLibVector();
-  LibpathSharedlibVector::iterator itr = FindLoadedLibrary(library_path);
+  LibPathSharedLibVector&amp; opened_libraries = GetLibPathSharedLibVector();
+  LibPathSharedLibVector::iterator itr = FindLoadedLibrary(library_path);
   return itr != opened_libraries.end();
 }
 
@@ -222,10 +222,10 @@ bool LoadLibrary(const std::string&amp; library_path, ClassLoader* loader) {
       SetCurLoadingLibraryName("");
       SetCurActiveClassLoader(nullptr);
       AERROR &lt;&lt; "LibraryAlreadyLoadedException: " &lt;&lt; e.what();
-    } catch (const NotFoundException&amp; e) {
+    } catch (const SymbolNotFoundException&amp; e) {
       SetCurLoadingLibraryName("");
       SetCurActiveClassLoader(nullptr);
-      AERROR &lt;&lt; "NotFoundException: " &lt;&lt; e.what();
+      AERROR &lt;&lt; "SymbolNotFoundException: " &lt;&lt; e.what();
     }
 
     SetCurLoadingLibraryName("");
@@ -242,8 +242,8 @@ bool LoadLibrary(const std::string&amp; library_path, ClassLoader* loader) {
     AWARN &lt;&lt; "Class factory objs counts is 0, maybe registerclass failed.";
   }
 
-  std::lock_guard&lt;std::recursive_mutex&gt; lck(GetLibPathShareLibMutex());
-  LibpathSharedlibVector&amp; opened_libraries = GetLibPathShareLibVector();
+  std::lock_guard&lt;std::recursive_mutex&gt; lck(GetLibPathSharedLibMutex());
+  LibPathSharedLibVector&amp; opened_libraries = GetLibPathSharedLibVector();
   opened_libraries.emplace_back(
       std::pair&lt;std::string, SharedLibraryPtr&gt;(library_path, shared_library));
   return true;
@@ -251,9 +251,9 @@ bool LoadLibrary(const std::string&amp; library_path, ClassLoader* loader) {
 
 void UnloadLibrary(const std::string&amp; library_path, ClassLoader* loader) {
   {
-    std::lock_guard&lt;std::recursive_mutex&gt; lck(GetLibPathShareLibMutex());
-    LibpathSharedlibVector&amp; opened_libraries = GetLibPathShareLibVector();
-    LibpathSharedlibVector::iterator itr = FindLoadedLibrary(library_path);
+    std::lock_guard&lt;std::recursive_mutex&gt; lck(GetLibPathSharedLibMutex());
+    LibPathSharedLibVector&amp; opened_libraries = GetLibPathSharedLibVector();
+    LibPathSharedLibVector::iterator itr = FindLoadedLibrary(library_path);
     if (itr == opened_libraries.end()) {
       AERROR &lt;&lt; "Attempt to UnloadLibrary lib, but can't find lib: "
              &lt;&lt; library_path;
@@ -268,12 +268,12 @@ void UnloadLibrary(const std::string&amp; library_path, ClassLoader* loader) {
         itr-&gt;second-&gt;Unload();
         itr = opened_libraries.erase(itr);
       } else {
-        AWARN &lt;&lt; "ClassFactory Objects still remain in memory,meaning other "
-                 "ClassLoaders are still using library:"
+        AWARN &lt;&lt; "ClassFactory objects still remain in memory, meaning other"
+                 "class loaders are still using library:"
               &lt;&lt; library_path;
       }
-    } catch (const std::exception&amp; e) {
-      AERROR &lt;&lt; "library unLoad error: " &lt;&lt; e.what();
+    } catch (const std::runtime_error&amp; e) {
+      AERROR &lt;&lt; "Library unload error: " &lt;&lt; e.what();
     }
   }
 }
</diff>
			</file>
			<file old_path="cyber\class_loader\utility\class_loader_utility.h" new_path="cyber\class_loader\utility\class_loader_utility.h" added_lines="4" deleted_lines="4">
				<diff>@@ -28,7 +28,7 @@
 #include &lt;utility&gt;
 #include &lt;vector&gt;
 
-#include "cyber/class_loader/utility/shared_library.h"
+#include "cyber/class_loader/shared_library/shared_library.h"
 #include "cyber/class_loader/utility/class_factory.h"
 #include "cyber/common/log.h"
 
@@ -47,14 +47,14 @@ using SharedLibraryPtr = std::shared_ptr&lt;SharedLibrary&gt;;
 using ClassClassFactoryMap =
     std::map&lt;std::string, utility::AbstractClassFactoryBase*&gt;;
 using BaseToClassFactoryMapMap = std::map&lt;std::string, ClassClassFactoryMap&gt;;
-using LibpathSharedlibVector =
+using LibPathSharedLibVector =
     std::vector&lt;std::pair&lt;std::string, SharedLibraryPtr&gt;&gt;;
 using ClassFactoryVector = std::vector&lt;AbstractClassFactoryBase*&gt;;
 
 BaseToClassFactoryMapMap&amp; GetClassFactoryMapMap();
 std::recursive_mutex&amp; GetClassFactoryMapMapMutex();
-LibpathSharedlibVector&amp; GetLibPathShareLibVector();
-std::recursive_mutex&amp; GetLibPathShareLibMutex();
+LibPathSharedLibVector&amp; GetLibPathSharedLibVector();
+std::recursive_mutex&amp; GetLibPathSharedLibMutex();
 ClassClassFactoryMap&amp; GetClassFactoryMapByBaseClass(
     const std::string&amp; typeid_base_class_name);
 std::string GetCurLoadingLibraryName();
</diff>
			</file>
			<file old_path="cyber\class_loader\utility\exception.h" new_path="" added_lines="0" deleted_lines="51">
				<diff>@@ -1,51 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-#ifndef CYBER_CLASS_LOADER_UTILITY_EXCEPTION_H_
-#define CYBER_CLASS_LOADER_UTILITY_EXCEPTION_H_
-
-#include &lt;string&gt;
-#include &lt;exception&gt;
-
-
-namespace apollo {
-namespace cyber {
-namespace class_loader {
-namespace utility {
-
-#define DECLARE_EXCEPTION_CLASS(CLS, BASE) \
-class CLS : public BASE {                  \
- public:                                   \
-  explicit CLS(const std::string&amp; err_msg) : err_msg_(err_msg) {}  \
-  const char* what() const noexcept override {            \
-    return err_msg_.c_str();                              \
-  }                                                       \
- private:                                                 \
-  std::string err_msg_;                                   \
-};
-
-
-DECLARE_EXCEPTION_CLASS(LibraryAlreadyLoadedException, std::exception)
-DECLARE_EXCEPTION_CLASS(LibraryLoadException, std::exception)
-DECLARE_EXCEPTION_CLASS(NotFoundException, std::exception)
-
-
-}  // namespace utility
-}  // namespace class_loader
-}  // namespace cyber
-}  // namespace apollo
-
-#endif  // CYBER_CLASS_LOADER_UTILITY_EXCEPTION_H_
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6ebdd0de15f182e344285ffcb5e8f45af3d5f177" author="storypku">
		<msg>Cyber: notes from poco and bugfix for SharedLibrary d'ctor</msg>
		<modified_files>
			<file old_path="cyber\class_loader\shared_library\exceptions.h" new_path="cyber\class_loader\shared_library\exceptions.h" added_lines="9" deleted_lines="8">
				<diff>@@ -17,21 +17,22 @@
 #ifndef CYBER_CLASS_LOADER_SHARED_LIBRARY_EXCEPTIONS_H_
 #define CYBER_CLASS_LOADER_SHARED_LIBRARY_EXCEPTIONS_H_
 
-#include &lt;string&gt;
 #include &lt;stdexcept&gt;
+#include &lt;string&gt;
 
 namespace apollo {
 namespace cyber {
 namespace class_loader {
 
-#define DECLARE_SHARED_LIBRARY_EXCEPTION(CLS, BASE) \
-class CLS : public BASE {                           \
- public:                                            \
-  explicit CLS(const std::string&amp; err_msg) : BASE(err_msg) {} \
-  ~CLS() throw() {}                                       \
-};
+#define DECLARE_SHARED_LIBRARY_EXCEPTION(CLS, BASE)             \
+  class CLS : public BASE {                                     \
+   public:                                                      \
+    explicit CLS(const std::string&amp; err_msg) : BASE(err_msg) {} \
+    ~CLS() throw() {}                                           \
+  };
 
-DECLARE_SHARED_LIBRARY_EXCEPTION(LibraryAlreadyLoadedException, std::runtime_error);
+DECLARE_SHARED_LIBRARY_EXCEPTION(LibraryAlreadyLoadedException,
+                                 std::runtime_error);
 DECLARE_SHARED_LIBRARY_EXCEPTION(LibraryLoadException, std::runtime_error);
 DECLARE_SHARED_LIBRARY_EXCEPTION(SymbolNotFoundException, std::runtime_error);
 
</diff>
			</file>
			<file old_path="cyber\class_loader\shared_library\shared_library.cc" new_path="cyber\class_loader\shared_library\shared_library.cc" added_lines="12" deleted_lines="14">
				<diff>@@ -13,7 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *****************************************************************************/
-
+//
+// Adapted from poco/Foundation/src/SharedLibrary_UNIX.cpp
+//
+// Copyright (c) 2004-2006, Applied Informatics Software Engineering GmbH.
+// and Contributors.
+//
+// SPDX-License-Identifier:	BSL-1.0
+//
 #include "cyber/class_loader/shared_library/shared_library.h"
 
 #include &lt;dlfcn.h&gt;
@@ -22,19 +29,13 @@ namespace apollo {
 namespace cyber {
 namespace class_loader {
 
-SharedLibrary::SharedLibrary() : handle_(nullptr) {}
-
-SharedLibrary::SharedLibrary(const std::string&amp; path) {
-  Load(path, 0);
-}
+SharedLibrary::SharedLibrary(const std::string&amp; path) { Load(path, 0); }
 
 SharedLibrary::SharedLibrary(const std::string&amp; path, int flags) {
   Load(path, flags);
 }
 
-void SharedLibrary::Load(const std::string&amp; path) {
-  Load(path, 0);
-}
+void SharedLibrary::Load(const std::string&amp; path) { Load(path, 0); }
 
 void SharedLibrary::Load(const std::string&amp; path, int flags) {
   std::lock_guard&lt;std::mutex&gt; lock(mutex_);
@@ -84,11 +85,8 @@ void* SharedLibrary::GetSymbol(const std::string&amp; name) {
   return result;
 }
 
-SharedLibrary::~SharedLibrary() {
-  Unload();
-}
-
+SharedLibrary::~SharedLibrary() {}
 
-}  // namespace shared_library
+}  // namespace class_loader
 }  // namespace cyber
 }  // namespace apollo
</diff>
			</file>
			<file old_path="cyber\class_loader\shared_library\shared_library.h" new_path="cyber\class_loader\shared_library\shared_library.h" added_lines="61" deleted_lines="9">
				<diff>@@ -13,12 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *****************************************************************************/
+//
+// Adapted from poco/Foundation/include/Poco/SharedLibrary.h
+//
+// Definition of the SharedLibrary class.
+//
+// Copyright (c) 2004-2006, Applied Informatics Software Engineering GmbH.
+// and Contributors.
+//
+// SPDX-License-Identifier:     BSL-1.0
+//
+
+#ifndef CYBER_CLASS_LOADER_SHARED_LIBRARY_SHARED_LIBRARY_H_
+#define CYBER_CLASS_LOADER_SHARED_LIBRARY_SHARED_LIBRARY_H_
 
-#ifndef CYBER_CLASS_LOADER_SHARED_LIBRARY_H_
-#define CYBER_CLASS_LOADER_SHARED_LIBRARY_H_
-
-#include &lt;string&gt;
 #include &lt;mutex&gt;
+#include &lt;string&gt;
 
 #include "cyber/class_loader/shared_library/exceptions.h"
 
@@ -26,42 +36,84 @@ namespace apollo {
 namespace cyber {
 namespace class_loader {
 
+// The SharedLibrary class dynamically loads shared libraries at run-time.
 class SharedLibrary {
  public:
   enum Flags {
+    // On platforms that use dlopen(), use RTLD_GLOBAL. This is the default
+    // if no flags are given.
     SHLIB_GLOBAL = 1,
+
+    // On platforms that use dlopen(), use RTLD_LOCAL instead of RTLD_GLOBAL.
+    //
+    // Note that if this flag is specified, RTTI (including dynamic_cast and
+    // throw) will not work for types defined in the shared library with GCC
+    // and possibly other compilers as well. See
+    // http://gcc.gnu.org/faq.html#dso for more information.
     SHLIB_LOCAL = 2,
   };
 
-  SharedLibrary();
+  // Creates a SharedLibrary object.
+  SharedLibrary() = default;
+
+  // Destroys the SharedLibrary. The actual library
+  // remains loaded.
+  virtual ~SharedLibrary();
 
+  // Creates a SharedLibrary object and loads a library
+  // from the given path.
   explicit SharedLibrary(const std::string&amp; path);
 
+  // Creates a SharedLibrary object and loads a library
+  // from the given path, using the given flags.
+  // See the Flags enumeration for valid values.
   SharedLibrary(const std::string&amp; path, int flags);
 
-  virtual ~SharedLibrary();
-
+ public:
+  // Loads a shared library from the given path.
+  // Throws a LibraryAlreadyLoadedException if
+  // a library has already been loaded.
+  // Throws a LibraryLoadException if the library
+  // cannot be loaded.
   void Load(const std::string&amp; path);
 
+  // Loads a shared library from the given path,
+  // using the given flags. See the Flags enumeration
+  // for valid values.
+  // Throws a LibraryAlreadyLoadedException if
+  // a library has already been loaded.
+  // Throws a LibraryLoadException if the library
+  // cannot be loaded.
   void Load(const std::string&amp; path, int flags);
 
+  // Unloads a shared library.
   void Unload();
 
+  // Returns true iff a library has been loaded.
   bool IsLoaded();
 
+  // Returns true iff the loaded library contains
+  // a symbol with the given name.
   bool HasSymbol(const std::string&amp; name);
 
+  // Returns the address of the symbol with
+  // the given name. For functions, this
+  // is the entry point of the function.
+  // Throws a SymbolNotFoundException if the
+  // symbol does not exist.
   void* GetSymbol(const std::string&amp; name);
 
+  // Returns the path of the library, as specified in a call
+  // to load() or the constructor.
   inline const std::string&amp; GetPath() const { return path_; }
 
+ public:
   SharedLibrary(const SharedLibrary&amp;) = delete;
   SharedLibrary&amp; operator=(const SharedLibrary&amp;) = delete;
 
  private:
   void* handle_ = nullptr;
   std::string path_;
-
   std::mutex mutex_;
 };
 
@@ -69,4 +121,4 @@ class SharedLibrary {
 }  // namespace cyber
 }  // namespace apollo
 
-#endif  // CYBER_CLASS_LOADER_SHARED_LIBRARY_H_
+#endif  // CYBER_CLASS_LOADER_SHARED_LIBRARY_SHARED_LIBRARY_H_
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c7088da566093fdad0764ad378afd940a25e2f23" author="storypku">
		<msg>cyber: add unit tests for shared_library</msg>
		<modified_files>
			<file old_path="cyber\class_loader\shared_library\shared_library.cc" new_path="cyber\class_loader\shared_library\shared_library.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -19,7 +19,7 @@
 // Copyright (c) 2004-2006, Applied Informatics Software Engineering GmbH.
 // and Contributors.
 //
-// SPDX-License-Identifier:	BSL-1.0
+// SPDX-License-Identifier: BSL-1.0
 //
 #include "cyber/class_loader/shared_library/shared_library.h"
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="12ffa343791fa357db67b63ddad2937b0fdefdaf" author="xiaoMrzhang">
		<msg>Perception: add smoke model transformer (#13284)

* Perception: change darkscnn caffe model to tensorrt &amp; add new obstacle module

* Perception: code style

* Perception: add smoke model transformer

* Perception: rename singlestage</msg>
		<modified_files>
			<file old_path="modules\perception\camera\lib\obstacle\detector\smoke\region_output.cc" new_path="modules\perception\camera\lib\obstacle\detector\smoke\region_output.cc" added_lines="4" deleted_lines="2">
				<diff>@@ -82,8 +82,6 @@ void recover_smoke_bbox(int roi_w, int roi_h, int offset_y,
 void fill_smoke_base(base::ObjectPtr obj, const float *bbox,
                      int width, int height) {
   obj-&gt;camera_supplement.box.xmin = bbox[0]/width;
-  AINFO &lt;&lt; "object camera_supplement box xmin: " &lt;&lt; bbox[0];
-  AINFO &lt;&lt; "object camera_supplement box ymin: " &lt;&lt; bbox[1];
   obj-&gt;camera_supplement.box.ymin = bbox[1]/height;
   obj-&gt;camera_supplement.box.xmax = bbox[2]/width;
   obj-&gt;camera_supplement.box.ymax = bbox[3]/height;
@@ -96,6 +94,10 @@ void fill_smoke_bbox3d(bool with_box3d, base::ObjectPtr obj,
     obj-&gt;size[2] = bbox[6];
     obj-&gt;size[1] = bbox[7];
     obj-&gt;size[0] = bbox[8];
+
+    obj-&gt;camera_supplement.local_center[0] = bbox[9];
+    obj-&gt;camera_supplement.local_center[1] = bbox[10];
+    obj-&gt;camera_supplement.local_center[2] = bbox[11];
   }
 }
 
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\detector\smoke\smoke_obstacle_detector.cc" new_path="modules\perception\camera\lib\obstacle\detector\smoke\smoke_obstacle_detector.cc" added_lines="10" deleted_lines="3">
				<diff>@@ -230,15 +230,21 @@ bool SmokeObstacleDetector::Detect(const ObstacleDetectorOptions &amp;options,
   for (size_t i = 0; i &lt; 3; i++) {
     size_t i3 = i * 3;
     for (size_t j = 0; j &lt; 3; j++) {
-      K_data[i3 + j] = camera_k_matrix(i, j);
+      if (frame-&gt;data_provider-&gt;sensor_name() == "front_12mm") {
+        K_data[i3 + j] = camera_k_matrix(i, j) * 2.f;
+      } else {
+        K_data[i3 + j] = camera_k_matrix(i, j);
+      }
     }
   }
   AINFO &lt;&lt; "Camera k matrix input to obstacle postprocessor: \n"
         &lt;&lt; K_data[0] &lt;&lt; ", " &lt;&lt; K_data[1] &lt;&lt; ", " &lt;&lt; K_data[2] &lt;&lt; "\n"
         &lt;&lt; K_data[3] &lt;&lt; ", " &lt;&lt; K_data[4] &lt;&lt; ", " &lt;&lt; K_data[5] &lt;&lt; "\n"
         &lt;&lt; K_data[6] &lt;&lt; ", " &lt;&lt; K_data[7] &lt;&lt; ", " &lt;&lt; K_data[8] &lt;&lt; "\n";
-  ratio_data[0] = static_cast&lt;float&gt;(8);
-  ratio_data[1] = static_cast&lt;float&gt;(6.75);
+  ratio_data[0] = 4.f * static_cast&lt;float&gt;(frame-&gt;data_provider-&gt;src_width())
+                  / static_cast&lt;float&gt;(width_);
+  ratio_data[1] = 4.f * static_cast&lt;float&gt;(frame-&gt;data_provider-&gt;src_height())
+                  / static_cast&lt;float&gt;(height_);
 
   AINFO &lt;&lt; "Start: " &lt;&lt; static_cast&lt;double&gt;(timer.Toc()) * 0.001 &lt;&lt; "ms";
   DataProvider::ImageOptions image_options;
@@ -253,6 +259,7 @@ bool SmokeObstacleDetector::Detect(const ObstacleDetectorOptions &amp;options,
                        0);
   AINFO &lt;&lt; "Resize: " &lt;&lt; static_cast&lt;double&gt;(timer.Toc()) * 0.001 &lt;&lt; "ms";
 
+  AINFO &lt;&lt; "Camera type: " &lt;&lt; frame-&gt;data_provider-&gt;sensor_name();
   /////////////////////////// detection part ///////////////////////////
   inference_-&gt;Infer();
   AINFO &lt;&lt; "Network Forward: " &lt;&lt; static_cast&lt;double&gt;(timer.Toc()) * 0.001
</diff>
			</file>
			<file old_path="modules\perception\camera\tools\offline\visualizer.cc" new_path="modules\perception\camera\tools\offline\visualizer.cc" added_lines="0" deleted_lines="2">
				<diff>@@ -1096,8 +1096,6 @@ void Visualizer::Draw2Dand3D_all_info_single_camera(
   for (const auto &amp;object : frame.tracked_objects) {
     // plot 2D box on image_2D
     base::RectF rect(object-&gt;camera_supplement.box);
-    AINFO &lt;&lt; "Draw box xmin: " &lt;&lt; object-&gt;camera_supplement.box.xmin;
-    AINFO &lt;&lt; "Draw box ymin: " &lt;&lt; object-&gt;camera_supplement.box.ymin;
     cv::Rect r(static_cast&lt;int&gt;(rect.x), static_cast&lt;int&gt;(rect.y),
                static_cast&lt;int&gt;(rect.width), static_cast&lt;int&gt;(rect.height));
     cv::Scalar color = colorlistobj[object-&gt;track_id % colorlistobj.size()];
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a916d039779127b2b15cb252e5fbc6e022624be2" author="Jiahao Chen (Jerold)">
		<msg>Perception: resume traffic light module (#13325)

* Perception: resume traffic light module</msg>
		<modified_files>
			<file old_path="modules\perception\camera\lib\traffic_light\detector\detection\detection.cc" new_path="modules\perception\camera\lib\traffic_light\detector\detection\detection.cc" added_lines="28" deleted_lines="11">
				<diff>@@ -90,8 +90,8 @@ bool TrafficLightDetection::Init(
   AINFO &lt;&lt; "model_type: " &lt;&lt; model_type;
 
   rt_net_.reset(inference::CreateInferenceByName(model_type, proto_file,
-                                                weight_file, net_outputs_,
-                                                net_inputs_, model_root));
+                                                 weight_file, net_outputs_,
+                                                 net_inputs_, model_root));
 
   AINFO &lt;&lt; "rt_net_ create succeed";
   rt_net_-&gt;set_gpu_id(options.gpu_id);
@@ -101,7 +101,7 @@ bool TrafficLightDetection::Init(
   int resize_height = detection_param_.min_crop_size();
   int resize_width = detection_param_.min_crop_size();
   max_batch_size_ = detection_param_.max_batch_size();
-  param_blob_length_ = 3;
+  param_blob_length_ = 6;
 
   CHECK_GT(resize_height, 0);
   CHECK_GT(resize_width, 0);
@@ -118,7 +118,7 @@ bool TrafficLightDetection::Init(
       (std::pair&lt;std::string, std::vector&lt;int&gt;&gt;(net_inputs_[1], shape_param)));
 
   if (!rt_net_-&gt;Init(input_reshape)) {
-    AWARN &lt;&lt; "net init fail.";
+    AINFO &lt;&lt; "net init fail.";
     return false;
   }
   AINFO &lt;&lt; "net init success.";
@@ -132,6 +132,9 @@ bool TrafficLightDetection::Init(
     param_data[offset + 0] = static_cast&lt;float&gt;(resize_width);
     param_data[offset + 1] = static_cast&lt;float&gt;(resize_height);
     param_data[offset + 2] = 1;
+    param_data[offset + 3] = 1;
+    param_data[offset + 4] = 0;
+    param_data[offset + 5] = 0;
   }
 
   switch (detection_param_.crop_method()) {
@@ -170,7 +173,7 @@ bool TrafficLightDetection::Inference(
                           static_cast&lt;int&gt;(detection_param_.min_crop_size()),
                           static_cast&lt;int&gt;(detection_param_.min_crop_size()),
                           3);
-  param_blob_-&gt;Reshape(static_cast&lt;int&gt;(batch_num), 1, 3, 1);
+  param_blob_-&gt;Reshape(static_cast&lt;int&gt;(batch_num), 6, 1, 1);
   float *param_data = param_blob_-&gt;mutable_cpu_data();
   for (size_t i = 0; i &lt; batch_num; ++i) {
     auto offset = i * param_blob_length_;
@@ -179,6 +182,9 @@ bool TrafficLightDetection::Inference(
     param_data[offset + 1] =
         static_cast&lt;float&gt;(detection_param_.min_crop_size());
     param_data[offset + 2] = 1;
+    param_data[offset + 3] = 1;
+    param_data[offset + 4] = 0;
+    param_data[offset + 5] = 0;
   }
 
   AINFO &lt;&lt; "reshape inputblob " &lt;&lt; input_img_blob-&gt;shape_string();
@@ -207,7 +213,7 @@ bool TrafficLightDetection::Inference(
       resize_scale_list_.push_back(resize_scale);
 
       inference::ResizeGPU(*image_, input_img_blob, img_width, resize_index,
-                            mean_[0], mean_[1], mean_[2], true, 1.0);
+                           mean_[0], mean_[1], mean_[2], true, 1.0);
       resize_index++;
     }
   }
@@ -289,18 +295,29 @@ bool TrafficLightDetection::SelectOutputBoxes(
     const std::vector&lt;float&gt; &amp;resize_scale_list_row,
     std::vector&lt;base::TrafficLightPtr&gt; *lights) {
   auto output_blob = rt_net_-&gt;get_blob(net_outputs_[0]);
-  int result_box_num = output_blob-&gt;shape(0);
-  int each_box_length = output_blob-&gt;shape(1);
+  std::string model_type = detection_param_.model_type();
+  int result_box_num, each_box_length;
+  if (model_type == "RTNet" || model_type == "RTNetInt8") {
+    result_box_num = output_blob-&gt;shape(1);
+    each_box_length = output_blob-&gt;shape(2);
+  } else {
+    result_box_num = output_blob-&gt;shape(0);
+    each_box_length = output_blob-&gt;shape(1);
+  }
 
   AINFO &lt;&lt; "output blob size " &lt;&lt; output_blob-&gt;shape(0) &lt;&lt; " "
         &lt;&lt; output_blob-&gt;shape(1) &lt;&lt; " " &lt;&lt; output_blob-&gt;shape(2) &lt;&lt; " "
         &lt;&lt; output_blob-&gt;shape(3);
+  AINFO &lt;&lt; "result box number: " &lt;&lt; result_box_num
+        &lt;&lt; " each box length: " &lt;&lt; each_box_length;
 
   for (int candidate_id = 0; candidate_id &lt; result_box_num; candidate_id++) {
     const float *result_data =
         output_blob-&gt;cpu_data() + candidate_id * each_box_length;
     int img_id = static_cast&lt;int&gt;(result_data[0]);
-    if (img_id &gt;= static_cast&lt;int&gt;(crop_box_list.size())) {
+    if (img_id &lt; 0) {
+      continue;
+    } else if (img_id &gt;= static_cast&lt;int&gt;(crop_box_list.size())) {
       AINFO &lt;&lt; "img id " &lt;&lt; img_id &lt;&lt; " &gt; " &lt;&lt; crop_box_list.size();
       continue;
     }
@@ -347,7 +364,7 @@ bool TrafficLightDetection::SelectOutputBoxes(
       }
 
       RefineBox(tmp-&gt;region.detection_roi, crop_box_list.at(img_id).width,
-          crop_box_list.at(img_id).height, &amp;(tmp-&gt;region.detection_roi));
+                crop_box_list.at(img_id).height, &amp;(tmp-&gt;region.detection_roi));
       tmp-&gt;region.detection_roi.x += crop_box_list.at(img_id).x;
       tmp-&gt;region.detection_roi.y += crop_box_list.at(img_id).y;
       tmp-&gt;region.is_detected = true;
@@ -358,7 +375,7 @@ bool TrafficLightDetection::SelectOutputBoxes(
 
       lights-&gt;push_back(tmp);
     } else {
-      AWARN &lt;&lt; "Invalid classid  "
+      AWARN &lt;&lt; "Invalid class id: "
             &lt;&lt; static_cast&lt;int&gt;(tmp-&gt;region.detect_class_id);
     }
   }
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\traffic_light\detector\recognition\classify.cc" new_path="modules\perception\camera\lib\traffic_light\detector\recognition\classify.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -129,10 +129,10 @@ void ClassifyBySimple::Perform(const CameraFrame* frame,
 
     AINFO &lt;&lt; "get img done";
 
-    const float* mean = mean_-&gt;cpu_data();
+    const float* mean = mean_.get()-&gt;cpu_data();
     inference::ResizeGPU(*image_, input_blob_recog,
-                         frame-&gt;data_provider-&gt;src_width(), 0, mean[0],
-                         mean[1], mean[2], true, scale_);
+                         frame-&gt;data_provider-&gt;src_width(), 0, mean[0], mean[1],
+                         mean[2], true, scale_);
 
     AINFO &lt;&lt; "resize gpu finish.";
     cudaDeviceSynchronize();
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\traffic_light\detector\recognition\recognition.h" new_path="modules\perception\camera\lib\traffic_light\detector\recognition\recognition.h" added_lines="1" deleted_lines="0">
				<diff>@@ -22,6 +22,7 @@
 #include "modules/perception/camera/lib/interface/base_traffic_light_detector.h"
 #include "modules/perception/camera/lib/traffic_light/detector/recognition/classify.h"
 #include "modules/perception/camera/lib/traffic_light/detector/recognition/proto/recognition.pb.h"
+#include "modules/perception/inference/inference.h"
 
 namespace apollo {
 namespace perception {
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\entropy_calibrator.cc" new_path="modules\perception\inference\tensorrt\entropy_calibrator.cc" added_lines="1" deleted_lines="21">
				<diff>@@ -15,32 +15,12 @@
  *****************************************************************************/
 #include "modules/perception/inference/tensorrt/entropy_calibrator.h"
 
+#include &lt;algorithm&gt;
 #include &lt;fstream&gt;
 
 #include &lt;cuda_runtime_api.h&gt;
 
 namespace nvinfer1 {
-DimsHW ICaffePoolOutputDimensionsFormula::compute(DimsHW input_dims,
-                                                  DimsHW kernel_size,
-                                                  DimsHW stride, DimsHW padding,
-                                                  DimsHW dilation,
-                                                  const char *layerName) const {
-  const int kernel_extent_h = dilation.d[0] * (kernel_size.d[0] - 1) + 1;
-  const int kernel_extent_w = dilation.d[1] * (kernel_size.d[1] - 1) + 1;
-  auto &amp;&amp;h_temp = (input_dims.d[0] + 2 * padding.d[0] - kernel_extent_h) * 1.0 /
-                  stride.d[0];
-  auto &amp;&amp;w_temp = (input_dims.d[1] + 2 * padding.d[1] - kernel_extent_w) * 1.0 /
-                  stride.d[1];
-
-  std::string str_name(layerName);
-  if (str_name.find("as_conv") == std::string::npos) {
-    return DimsHW(static_cast&lt;int&gt;(ceil(h_temp)) + 1,
-                  static_cast&lt;int&gt;(ceil(w_temp)) + 1);
-  } else {
-    return DimsHW(static_cast&lt;int&gt;(h_temp) + 1, static_cast&lt;int&gt;(w_temp) + 1);
-  }
-}
-
 Int8EntropyCalibrator::Int8EntropyCalibrator(
     const apollo::perception::inference::BatchStream &amp;stream, int first_batch,
     bool read_cache, std::string network)
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\entropy_calibrator.h" new_path="modules\perception\inference\tensorrt\entropy_calibrator.h" added_lines="0" deleted_lines="12">
				<diff>@@ -16,12 +16,9 @@
 
 #pragma once
 
-#include &lt;algorithm&gt;
-#include &lt;cmath&gt;
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
-#include "NvCaffeParser.h"
 #include "NvInfer.h"
 #include "NvInferPlugin.h"
 
@@ -29,15 +26,6 @@
 #include "modules/perception/inference/tensorrt/rt_utils.h"
 
 namespace nvinfer1 {
-class ICaffePoolOutputDimensionsFormula : public IOutputDimensionsFormula {
- public:
-  virtual DimsHW compute(DimsHW input_dims, DimsHW kernel_size, DimsHW stride,
-                         DimsHW padding, DimsHW dilation,
-                         const char *layerName) const;
-  ICaffePoolOutputDimensionsFormula() = default;
-  ~ICaffePoolOutputDimensionsFormula() = default;
-};
-
 class Int8EntropyCalibrator : public IInt8EntropyCalibrator {
  public:
   Int8EntropyCalibrator(
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\entropy_calibrator_test.cc" new_path="modules\perception\inference\tensorrt\entropy_calibrator_test.cc" added_lines="0" deleted_lines="19">
				<diff>@@ -24,25 +24,6 @@ namespace apollo {
 namespace perception {
 namespace inference {
 
-TEST(ICaffePoolOutputDimensionsFormulaTest, test_compute) {
-  nvinfer1::ICaffePoolOutputDimensionsFormula poolFormula;
-
-  nvinfer1::DimsHW input_dims(4, 4);
-  nvinfer1::DimsHW kernel_size(3, 3);
-  nvinfer1::DimsHW stride(2, 2);
-  nvinfer1::DimsHW padding(0, 0);
-  nvinfer1::DimsHW dilation(1, 1);
-
-  auto dim_as_conv = poolFormula.compute(input_dims, kernel_size, stride,
-                                         padding, dilation, "pool_as_conv");
-  auto dim_as_pool = poolFormula.compute(input_dims, kernel_size, stride,
-                                         padding, dilation, "pool_as_pool");
-  EXPECT_EQ(dim_as_conv.h(), 1);
-  EXPECT_EQ(dim_as_conv.w(), 1);
-  EXPECT_EQ(dim_as_pool.h(), 2);
-  EXPECT_EQ(dim_as_pool.w(), 2);
-}
-
 TEST(Int8EntropyCalibratorTest, test_init) {
   // test empty batch_stream
   {
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\plugins\softmax_plugin.h" new_path="modules\perception\inference\tensorrt\plugins\softmax_plugin.h" added_lines="1" deleted_lines="1">
				<diff>@@ -31,7 +31,7 @@ class SoftmaxPlugin : public nvinfer1::IPlugin {
       input_dims_.type[i] = in_dims.type[i];
     }
     axis_ = param.axis() - 1;
-    CHECK_GT(axis_, 0);
+    CHECK_GE(axis_, 0);
     CHECK_LE(axis_ + 1, input_dims_.nbDims);
 
     inner_num_ = 1;
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\rt_common.cc" new_path="modules\perception\inference\tensorrt\rt_common.cc" added_lines="9" deleted_lines="10">
				<diff>@@ -53,17 +53,16 @@ void ParseNetParam(const NetParameter &amp;net_param,
     LayerParameter tensorrt_layer_param = net_param.layer(i);
     if (tensorrt_layer_param.type() == "Input") {
       InputParameter input = tensorrt_layer_param.input_param();
-      nvinfer1::DimsCHW dims{static_cast&lt;int&gt;(input.shape(0).dim(1)),
-                             static_cast&lt;int&gt;(input.shape(0).dim(2)),
-                             static_cast&lt;int&gt;(input.shape(0).dim(3))};
-      auto name = tensorrt_layer_param.top(0);
-      tensor_dims_map-&gt;insert(std::make_pair(name, dims));
-      tensor_modify_map-&gt;insert(
-          std::make_pair(name, tensorrt_layer_param.top(0)));
-    } else if (net_param.layer(i).type() == "Pooling") {
-      if (tensorrt_layer_param.pooling_param().cmp_out_shape_floor_as_conv()) {
-        tensorrt_layer_param.set_name(tensorrt_layer_param.name() + "as_conv");
+      for (int j = 0; j &lt; tensorrt_layer_param.top().size(); ++j) {
+        nvinfer1::DimsCHW dims{static_cast&lt;int&gt;(input.shape(j).dim(1)),
+                               static_cast&lt;int&gt;(input.shape(j).dim(2)),
+                               static_cast&lt;int&gt;(input.shape(j).dim(3))};
+        auto name = tensorrt_layer_param.top(j);
+        tensor_dims_map-&gt;insert(std::make_pair(name, dims));
+        tensor_modify_map-&gt;insert(
+            std::make_pair(name, tensorrt_layer_param.top(j)));
       }
+    } else if (net_param.layer(i).type() == "Pooling") {
       if (tensorrt_layer_param.pooling_param().pad() == 0) {
         order-&gt;push_back(tensorrt_layer_param);
         continue;
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\rt_common.h" new_path="modules\perception\inference\tensorrt\rt_common.h" added_lines="6" deleted_lines="0">
				<diff>@@ -59,6 +59,12 @@ struct ConvParam {
 
 bool ParserConvParam(const ConvolutionParameter &amp;conv, ConvParam *param);
 
+inline nvinfer1::DimsCHW getCHW(const nvinfer1::Dims &amp;d) {
+  assert(d.nbDims &gt;= 3);
+  return nvinfer1::DimsCHW(d.d[d.nbDims - 3], d.d[d.nbDims - 2],
+                           d.d[d.nbDims - 1]);
+}
+
 }  // namespace inference
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\rt_net.cc" new_path="modules\perception\inference\tensorrt\rt_net.cc" added_lines="145" deleted_lines="18">
				<diff>@@ -17,13 +17,17 @@
 #include "modules/perception/inference/tensorrt/rt_net.h"
 
 #include &lt;algorithm&gt;
+#include &lt;cmath&gt;
 #include &lt;utility&gt;
 
 #include "absl/strings/str_cat.h"
 
 #include "cyber/common/log.h"
 #include "modules/perception/inference/tensorrt/plugins/argmax_plugin.h"
+#include "modules/perception/inference/tensorrt/plugins/dfmb_psroi_align_plugin.h"
 #include "modules/perception/inference/tensorrt/plugins/leakyReLU_plugin.h"
+#include "modules/perception/inference/tensorrt/plugins/rcnn_proposal_plugin.h"
+#include "modules/perception/inference/tensorrt/plugins/rpn_proposal_ssd_plugin.h"
 #include "modules/perception/inference/tensorrt/plugins/slice_plugin.h"
 #include "modules/perception/inference/tensorrt/plugins/softmax_plugin.h"
 
@@ -67,18 +71,54 @@ void RTNet::addConvLayer(const LayerParameter &amp;layer_param,
                          nvinfer1::INetworkDefinition *net,
                          TensorMap *tensor_map,
                          TensorModifyMap *tensor_modify_map) {
-  ConvolutionParameter conv = layer_param.convolution_param();
-  ConvParam param;
-  ACHECK(ParserConvParam(conv, &amp;param));
-  nvinfer1::IConvolutionLayer *convLayer = nullptr;
-  int size = conv.num_output() * param.kernel_w * param.kernel_h *
-             inputs[0]-&gt;getDimensions().d[0];
+  ConvolutionParameter p = layer_param.convolution_param();
+
+  int nbOutputs = p.num_output();
+
+  int kernelH = p.has_kernel_h() ? p.kernel_h() : p.kernel_size(0);
+  int kernelW = p.has_kernel_w() ? p.kernel_w()
+                                 : p.kernel_size_size() &gt; 1 ? p.kernel_size(1)
+                                                            : p.kernel_size(0);
+  int C = getCHW(inputs[0]-&gt;getDimensions()).c();
+  int G = p.has_group() ? p.group() : 1;
 
-  auto wt = loadLayerWeights(conv.weight_filler().value(), size);
+  int size = nbOutputs * kernelW * kernelH * C;
+  auto wt = loadLayerWeights(p.weight_filler().value(), size);
   nvinfer1::Weights bias_weight{nvinfer1::DataType::kFLOAT, nullptr, 0};
-  convLayer = net-&gt;addConvolution(
-      *inputs[0], static_cast&lt;int&gt;((conv.num_output())),
-      nvinfer1::DimsHW{param.kernel_h, param.kernel_w}, wt, bias_weight);
+
+  auto inTensor = inputs[0];
+  auto convLayer =
+      net-&gt;addConvolution(*inTensor, nbOutputs,
+                          nvinfer1::DimsHW{kernelH, kernelW}, wt, bias_weight);
+
+  if (convLayer) {
+    int strideH =
+        p.has_stride_h() ? p.stride_h() : p.stride_size() &gt; 0 ? p.stride(0) : 1;
+    int strideW = p.has_stride_w()
+                      ? p.stride_w()
+                      : p.stride_size() &gt; 1
+                            ? p.stride(1)
+                            : p.stride_size() &gt; 0 ? p.stride(0) : 1;
+
+    int padH = p.has_pad_h() ? p.pad_h() : p.pad_size() &gt; 0 ? p.pad(0) : 0;
+    int padW =
+        p.has_pad_w()
+            ? p.pad_w()
+            : p.pad_size() &gt; 1 ? p.pad(1) : p.pad_size() &gt; 0 ? p.pad(0) : 0;
+
+    int dilationH = p.dilation_size() &gt; 0 ? p.dilation(0) : 1;
+    int dilationW = p.dilation_size() &gt; 1
+                        ? p.dilation(1)
+                        : p.dilation_size() &gt; 0 ? p.dilation(0) : 1;
+
+    convLayer-&gt;setStride(nvinfer1::DimsHW{strideH, strideW});
+    convLayer-&gt;setPadding(nvinfer1::DimsHW{padH, padW});
+    convLayer-&gt;setPaddingMode(nvinfer1::PaddingMode::kCAFFE_ROUND_DOWN);
+    convLayer-&gt;setDilation(nvinfer1::DimsHW{dilationH, dilationW});
+
+    convLayer-&gt;setNbGroups(G);
+  }
+
   if ((*weight_map)[layer_param.name().c_str()].size() &gt; 0) {
     convLayer-&gt;setKernelWeights((*weight_map)[layer_param.name().c_str()][0]);
 
@@ -92,11 +132,7 @@ void RTNet::addConvLayer(const LayerParameter &amp;layer_param,
   lw[1] = convLayer-&gt;getBiasWeights();
   (*weight_map)[layer_param.name().c_str()] = lw;
 
-  convLayer-&gt;setStride(nvinfer1::DimsHW{param.stride_h, param.stride_w});
-  convLayer-&gt;setPadding(nvinfer1::DimsHW{param.padding_h, param.padding_w});
-  convLayer-&gt;setNbGroups(conv.group());
   convLayer-&gt;setName(layer_param.name().c_str());
-  convLayer-&gt;setDilation(nvinfer1::DimsHW{param.dilation, param.dilation});
   ConstructMap(layer_param, convLayer, tensor_map, tensor_modify_map);
 
 #if LOAD_DEBUG
@@ -139,8 +175,10 @@ void RTNet::addDeconvLayer(const LayerParameter &amp;layer_param,
   }
   deconvLayer-&gt;setStride(nvinfer1::DimsHW{param.stride_h, param.stride_w});
   deconvLayer-&gt;setPadding(nvinfer1::DimsHW{param.padding_h, param.padding_w});
-  deconvLayer-&gt;setName(layer_param.name().c_str());
+  deconvLayer-&gt;setPaddingMode(nvinfer1::PaddingMode::kCAFFE_ROUND_DOWN);
   deconvLayer-&gt;setNbGroups(conv.group());
+
+  deconvLayer-&gt;setName(layer_param.name().c_str());
   ConstructMap(layer_param, deconvLayer, tensor_map, tensor_modify_map);
 
 #if LOAD_DEBUG
@@ -191,7 +229,7 @@ void RTNet::addConcatLayer(const LayerParameter &amp;layer_param,
       net-&gt;addConcatenation(inputs, nbInputs);
   // tensorrt ignore the first channel(batch channel), so when load caffe
   // model axis should -1
-  concatLayer-&gt;setAxis(concat.axis()-1);
+  concatLayer-&gt;setAxis(concat.axis() - 1);
   concatLayer-&gt;setName(layer_param.name().c_str());
   CHECK_EQ(nbInputs, layer_param.bottom_size());
 
@@ -219,6 +257,19 @@ void RTNet::addPoolingLayer(const LayerParameter &amp;layer_param,
       (pool.pool() == PoolingParameter_PoolMethod_MAX)
           ? nvinfer1::PoolingType::kMAX
           : nvinfer1::PoolingType::kAVERAGE;
+  nvinfer1::PaddingMode padding_mode = nvinfer1::PaddingMode::kCAFFE_ROUND_UP;
+  if (pool.has_round_mode()) {
+    switch (static_cast&lt;int&gt;(pool.round_mode())) {
+      case 0:
+        padding_mode = nvinfer1::PaddingMode::kCAFFE_ROUND_UP;
+        break;
+      case 1:
+        padding_mode = nvinfer1::PaddingMode::kCAFFE_ROUND_DOWN;
+        break;
+      default:
+        padding_mode = nvinfer1::PaddingMode::kCAFFE_ROUND_UP;
+    }
+  }
   ACHECK(modify_pool_param(&amp;pool));
   nvinfer1::IPoolingLayer *poolLayer = net-&gt;addPooling(
       *inputs[0], pool_type,
@@ -227,6 +278,9 @@ void RTNet::addPoolingLayer(const LayerParameter &amp;layer_param,
                                         static_cast&lt;int&gt;(pool.stride_w())});
   poolLayer-&gt;setPadding(nvinfer1::DimsHW{static_cast&lt;int&gt;(pool.pad_h()),
                                          static_cast&lt;int&gt;(pool.pad_w())});
+  poolLayer-&gt;setPaddingMode(padding_mode);
+  // unlike other frameworks, caffe use inclusive counting for padded averaging
+  poolLayer-&gt;setAverageCountExcludesPadding(false);
   poolLayer-&gt;setName(layer_param.name().c_str());
   ConstructMap(layer_param, poolLayer, tensor_map, tensor_modify_map);
 }
@@ -419,6 +473,72 @@ void RTNet::addPaddingLayer(const LayerParameter &amp;layer_param,
   ConstructMap(layer_param, padding_layer, tensor_map, tensor_modify_map);
 }
 
+void RTNet::addDFMBPSROIAlignLayer(const LayerParameter &amp;layer_param,
+                                   nvinfer1::ITensor *const *inputs,
+                                   int nbInputs,
+                                   nvinfer1::INetworkDefinition *net,
+                                   TensorMap *tensor_map,
+                                   TensorModifyMap *tensor_modify_map) {
+  std::shared_ptr&lt;DFMBPSROIAlignPlugin&gt; dfmb_psroi_align_plugin;
+  nvinfer1::Dims input_dims[3];
+  for (int i = 0; i &lt; nbInputs &amp;&amp; i &lt; 3; ++i) {
+    input_dims[i] = inputs[i]-&gt;getDimensions();
+  }
+  dfmb_psroi_align_plugin.reset(new DFMBPSROIAlignPlugin(
+      layer_param.dfmb_psroi_pooling_param(), input_dims, nbInputs));
+  dfmb_psroi_align_plugins_.push_back(dfmb_psroi_align_plugin);
+  nvinfer1::IPluginLayer *dfmb_psroi_align_layer =
+      net-&gt;addPlugin(inputs, nbInputs, *dfmb_psroi_align_plugin);
+  dfmb_psroi_align_layer-&gt;setName(layer_param.name().c_str());
+
+  ConstructMap(layer_param, dfmb_psroi_align_layer, tensor_map,
+               tensor_modify_map);
+}
+
+void RTNet::addRCNNProposalLayer(const LayerParameter &amp;layer_param,
+                                 nvinfer1::ITensor *const *inputs, int nbInputs,
+                                 nvinfer1::INetworkDefinition *net,
+                                 TensorMap *tensor_map,
+                                 TensorModifyMap *tensor_modify_map) {
+  std::shared_ptr&lt;RCNNProposalPlugin&gt; rcnn_proposal_plugin;
+  nvinfer1::Dims input_dims[4];
+  for (int i = 0; i &lt; nbInputs &amp;&amp; i &lt; 4; ++i) {
+    input_dims[i] = inputs[i]-&gt;getDimensions();
+  }
+  rcnn_proposal_plugin.reset(new RCNNProposalPlugin(
+      layer_param.bbox_reg_param(), layer_param.detection_output_ssd_param(),
+      input_dims));
+  rcnn_proposal_plugins_.push_back(rcnn_proposal_plugin);
+  nvinfer1::IPluginLayer *rcnn_proposal_layer =
+      net-&gt;addPlugin(inputs, nbInputs, *rcnn_proposal_plugin);
+  rcnn_proposal_layer-&gt;setName(layer_param.name().c_str());
+
+  ConstructMap(layer_param, rcnn_proposal_layer, tensor_map, tensor_modify_map);
+}
+
+void RTNet::addRPNProposalSSDLayer(const LayerParameter &amp;layer_param,
+                                   nvinfer1::ITensor *const *inputs,
+                                   int nbInputs,
+                                   nvinfer1::INetworkDefinition *net,
+                                   TensorMap *tensor_map,
+                                   TensorModifyMap *tensor_modify_map) {
+  std::shared_ptr&lt;RPNProposalSSDPlugin&gt; rpn_proposal_ssd_plugin;
+  nvinfer1::Dims input_dims[3];
+  for (int i = 0; i &lt; nbInputs &amp;&amp; i &lt; 3; ++i) {
+    input_dims[i] = inputs[i]-&gt;getDimensions();
+  }
+  rpn_proposal_ssd_plugin.reset(new RPNProposalSSDPlugin(
+      layer_param.bbox_reg_param(), layer_param.detection_output_ssd_param(),
+      input_dims));
+  rpn_proposal_ssd_plugins_.push_back(rpn_proposal_ssd_plugin);
+  nvinfer1::IPluginLayer *rpn_proposal_ssd_layer =
+      net-&gt;addPlugin(inputs, nbInputs, *rpn_proposal_ssd_plugin);
+  rpn_proposal_ssd_layer-&gt;setName(layer_param.name().c_str());
+
+  ConstructMap(layer_param, rpn_proposal_ssd_layer, tensor_map,
+               tensor_modify_map);
+}
+
 void RTNet::addLayer(const LayerParameter &amp;layer_param,
                      nvinfer1::ITensor *const *inputs, int nbInputs,
                      WeightMap *weight_map, nvinfer1::INetworkDefinition *net,
@@ -471,6 +591,15 @@ void RTNet::addLayer(const LayerParameter &amp;layer_param,
   } else if (layer_param.type() == "Power") {
     addScaleLayer(layer_param, inputs, weight_map, net, tensor_map,
                   tensor_modify_map);
+  } else if (layer_param.type() == "DFMBPSROIAlign") {
+    addDFMBPSROIAlignLayer(layer_param, inputs, nbInputs, net, tensor_map,
+                           tensor_modify_map);
+  } else if (layer_param.type() == "RCNNProposal") {
+    addRCNNProposalLayer(layer_param, inputs, nbInputs, net, tensor_map,
+                         tensor_modify_map);
+  } else if (layer_param.type() == "RPNProposalSSD") {
+    addRPNProposalSSDLayer(layer_param, inputs, nbInputs, net, tensor_map,
+                           tensor_modify_map);
   } else {
     AWARN &lt;&lt; "unknown layer type:" &lt;&lt; layer_param.type();
   }
@@ -636,8 +765,6 @@ bool RTNet::Init(const std::map&lt;std::string, std::vector&lt;int&gt;&gt; &amp;shapes) {
 
   builder_ = nvinfer1::createInferBuilder(rt_gLogger);
   network_ = builder_-&gt;createNetwork();
-  nvinfer1::ICaffePoolOutputDimensionsFormula poolFormula;
-  network_-&gt;setPoolingOutputDimensionsFormula(&amp;poolFormula);
 
   parse_with_api(shapes);
   builder_-&gt;setMaxBatchSize(max_batch_size_);
</diff>
			</file>
			<file old_path="modules\perception\inference\tensorrt\rt_net.h" new_path="modules\perception\inference\tensorrt\rt_net.h" added_lines="25" deleted_lines="0">
				<diff>@@ -30,6 +30,9 @@ namespace apollo {
 namespace perception {
 namespace inference {
 class ArgMax1Plugin;
+class DFMBPSROIAlignPlugin;
+class RCNNProposalPlugin;
+class RPNProposalSSDPlugin;
 class ReLUPlugin;
 class SLICEPlugin;
 class SoftmaxPlugin;
@@ -167,6 +170,25 @@ class RTNet : public Inference {
                        nvinfer1::ITensor *const *inputs,
                        nvinfer1::INetworkDefinition *net, TensorMap *tensor_map,
                        TensorModifyMap *tensor_modify_map);
+
+  void addDFMBPSROIAlignLayer(const LayerParameter &amp;layer_param,
+                              nvinfer1::ITensor *const *inputs, int nbInputs,
+                              nvinfer1::INetworkDefinition *net,
+                              TensorMap *tensor_map,
+                              TensorModifyMap *tensor_modify_map);
+
+  void addRCNNProposalLayer(const LayerParameter &amp;layer_param,
+                            nvinfer1::ITensor *const *inputs, int nbInputs,
+                            nvinfer1::INetworkDefinition *net,
+                            TensorMap *tensor_map,
+                            TensorModifyMap *tensor_modify_map);
+
+  void addRPNProposalSSDLayer(const LayerParameter &amp;layer_param,
+                              nvinfer1::ITensor *const *inputs, int nbInputs,
+                              nvinfer1::INetworkDefinition *net,
+                              TensorMap *tensor_map,
+                              TensorModifyMap *tensor_modify_map);
+
   bool checkInt8(const std::string &amp;gpu_name,
                  nvinfer1::IInt8Calibrator *calibrator);
   void mergeBN(int index, LayerParameter *layer_param);
@@ -180,6 +202,9 @@ class RTNet : public Inference {
   nvinfer1::IExecutionContext *context_ = nullptr;
   cudaStream_t stream_ = 0;
   std::vector&lt;std::shared_ptr&lt;ArgMax1Plugin&gt;&gt; argmax_plugins_;
+  std::vector&lt;std::shared_ptr&lt;DFMBPSROIAlignPlugin&gt;&gt; dfmb_psroi_align_plugins_;
+  std::vector&lt;std::shared_ptr&lt;RCNNProposalPlugin&gt;&gt; rcnn_proposal_plugins_;
+  std::vector&lt;std::shared_ptr&lt;RPNProposalSSDPlugin&gt;&gt; rpn_proposal_ssd_plugins_;
   std::vector&lt;std::shared_ptr&lt;SoftmaxPlugin&gt;&gt; softmax_plugins_;
   std::vector&lt;std::shared_ptr&lt;SLICEPlugin&gt;&gt; slice_plugins_;
   std::vector&lt;std::shared_ptr&lt;ReLUPlugin&gt;&gt; relu_plugins_;
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\trafficlights_perception_component.cc" new_path="modules\perception\onboard\component\trafficlights_perception_component.cc" added_lines="25" deleted_lines="20">
				<diff>@@ -26,6 +26,8 @@
 
 #include "absl/strings/str_cat.h"
 
+#include "modules/transform/proto/transform.pb.h"
+
 #include "cyber/common/file.h"
 #include "cyber/common/log.h"
 #include "cyber/time/clock.h"
@@ -35,15 +37,14 @@
 #include "modules/perception/camera/common/data_provider.h"
 #include "modules/perception/common/sensor_manager/sensor_manager.h"
 #include "modules/perception/onboard/common_flags/common_flags.h"
-#include "modules/transform/proto/transform.pb.h"
 
 namespace apollo {
 namespace perception {
 namespace onboard {
 
 using TLCamID = apollo::perception::TrafficLightDetection::CameraID;
-using apollo::cyber::common::GetAbsolutePath;
 using apollo::cyber::Clock;
+using apollo::cyber::common::GetAbsolutePath;
 using apollo::perception::common::SensorManager;
 
 class TLInfo {
@@ -342,10 +343,12 @@ void TrafficLightsPerceptionComponent::OnReceiveImage(
   // skipping frame according to last proc image timestamp
   if (last_proc_image_ts_ &gt; 0.0 &amp;&amp;
       receive_img_timestamp - last_proc_image_ts_ &lt; proc_interval_seconds_) {
-    AINFO &lt;&lt; "skip current image, img_ts: " &lt;&lt; image_msg_ts
-          &lt;&lt; " , receive_img_timestamp: " &lt;&lt; receive_img_timestamp
-          &lt;&lt; " ,_last_proc_image_ts: " &lt;&lt; last_proc_image_ts_
-          &lt;&lt; " , _proc_interval_seconds: " &lt;&lt; proc_interval_seconds_;
+    AINFO &lt;&lt; "skip current image, img_ts: " &lt;&lt; FORMAT_TIMESTAMP(image_msg_ts)
+          &lt;&lt; " , receive_img_timestamp: "
+          &lt;&lt; FORMAT_TIMESTAMP(receive_img_timestamp)
+          &lt;&lt; " ,_last_proc_image_ts: " &lt;&lt; FORMAT_TIMESTAMP(last_proc_image_ts_)
+          &lt;&lt; " , _proc_interval_seconds: "
+          &lt;&lt; FORMAT_TIMESTAMP(proc_interval_seconds_);
     return;
   }
   // sync image with cached projections
@@ -530,8 +533,8 @@ bool TrafficLightsPerceptionComponent::UpdateCameraSelection(
   const double current_ts = Clock::NowInSeconds();
   if (last_query_tf_ts_ &gt; 0.0 &amp;&amp;
       current_ts - last_query_tf_ts_ &lt; query_tf_interval_seconds_) {
-    AINFO &lt;&lt; "skip current tf msg, img_ts: " &lt;&lt; timestamp
-          &lt;&lt; " , last_query_tf_ts_: " &lt;&lt; last_query_tf_ts_;
+    AINFO &lt;&lt; "skip current tf msg, img_ts: " &lt;&lt; FORMAT_TIMESTAMP(timestamp)
+          &lt;&lt; " , last_query_tf_ts_: " &lt;&lt; FORMAT_TIMESTAMP(last_query_tf_ts_);
     return true;
   }
   AINFO &lt;&lt; "start select camera";
@@ -539,7 +542,8 @@ bool TrafficLightsPerceptionComponent::UpdateCameraSelection(
   camera::CarPose pose;
   std::vector&lt;apollo::hdmap::Signal&gt; signals;
   if (!QueryPoseAndSignals(timestamp, &amp;pose, &amp;signals)) {
-    AINFO &lt;&lt; "query_pose_and_signals failed, ts: " &lt;&lt; timestamp;
+    AINFO &lt;&lt; "query_pose_and_signals failed, ts: "
+          &lt;&lt; FORMAT_TIMESTAMP(timestamp);
     return false;
   }
   last_query_tf_ts_ = current_ts;
@@ -549,9 +553,11 @@ bool TrafficLightsPerceptionComponent::UpdateCameraSelection(
 
   if (!preprocessor_-&gt;UpdateCameraSelection(pose, option,
                                             &amp;frame-&gt;traffic_lights)) {
-    AERROR &lt;&lt; "add_cached_lights_projections failed, ts: " &lt;&lt; timestamp;
+    AERROR &lt;&lt; "add_cached_lights_projections failed, ts: "
+           &lt;&lt; FORMAT_TIMESTAMP(timestamp);
   } else {
-    AINFO &lt;&lt; "add_cached_lights_projections succeed, ts: " &lt;&lt; timestamp;
+    AINFO &lt;&lt; "add_cached_lights_projections succeed, ts: "
+          &lt;&lt; FORMAT_TIMESTAMP(timestamp);
   }
 
   for (auto&amp; light : frame-&gt;traffic_lights) {
@@ -575,8 +581,8 @@ bool TrafficLightsPerceptionComponent::CheckCameraImageStatus(
     if (last_sub_camera_ts &lt; 1.0 || timestamp - last_sub_camera_ts &gt; interval) {
       preprocessor_-&gt;SetCameraWorkingFlag(cam_name, false);
       AWARN &lt;&lt; "camera is probably not working"
-            &lt;&lt; " , current ts: " &lt;&lt; timestamp
-            &lt;&lt; " , last_sub_camera_ts: " &lt;&lt; last_sub_camera_ts
+            &lt;&lt; " , current ts: " &lt;&lt; FORMAT_TIMESTAMP(timestamp)
+            &lt;&lt; " , last_sub_camera_ts: " &lt;&lt; FORMAT_TIMESTAMP(last_sub_camera_ts)
             &lt;&lt; " , camera_name: " &lt;&lt; cam_name;
       camera_ok = false;
       AINFO &lt;&lt; "camera status:" &lt;&lt; camera_ok;
@@ -586,13 +592,13 @@ bool TrafficLightsPerceptionComponent::CheckCameraImageStatus(
 
   bool is_camera_working = false;
   if (!preprocessor_-&gt;GetCameraWorkingFlag(camera_name, &amp;is_camera_working)) {
-    AERROR &lt;&lt; "get_camera_is_working_flag ts: " &lt;&lt; timestamp
+    AERROR &lt;&lt; "get_camera_is_working_flag ts: " &lt;&lt; FORMAT_TIMESTAMP(timestamp)
            &lt;&lt; " camera_name: " &lt;&lt; camera_name;
     return false;
   }
   if (!is_camera_working) {
     if (!preprocessor_-&gt;SetCameraWorkingFlag(camera_name, true)) {
-      AERROR &lt;&lt; "set_camera_is_working_flag ts: " &lt;&lt; timestamp
+      AERROR &lt;&lt; "set_camera_is_working_flag ts: " &lt;&lt; FORMAT_TIMESTAMP(timestamp)
              &lt;&lt; " camera_name: " &lt;&lt; camera_name;
       return false;
     }
@@ -641,7 +647,7 @@ bool TrafficLightsPerceptionComponent::GetPoseFromTF(
   if (!tf2_buffer_-&gt;canTransform(frame_id, child_frame_id, query_time,
                                  static_cast&lt;float&gt;(tf2_timeout_second_),
                                  &amp;err_string)) {
-    AERROR &lt;&lt; "Can not find transform. " &lt;&lt; timestamp
+    AERROR &lt;&lt; "Can not find transform. " &lt;&lt; FORMAT_TIMESTAMP(timestamp)
            &lt;&lt; " frame_id: " &lt;&lt; frame_id &lt;&lt; " child_frame_id: " &lt;&lt; child_frame_id
            &lt;&lt; " Error info: " &lt;&lt; err_string;
     return false;
@@ -681,7 +687,7 @@ bool TrafficLightsPerceptionComponent::TransformOutputMessage(
   auto* header = (*out_msg)-&gt;mutable_header();
   double publish_time = Clock::NowInSeconds();
   header-&gt;set_timestamp_sec(publish_time);  // message publishing time
-  AINFO &lt;&lt; "set header time sec:" &lt;&lt; frame-&gt;timestamp;
+  AINFO &lt;&lt; "set header time sec:" &lt;&lt; FORMAT_TIMESTAMP(frame-&gt;timestamp);
 
   // Set traffic light color to unknown before the process
   detected_trafficlight_color_ = base::TLColor::TL_UNKNOWN_COLOR;
@@ -1011,10 +1017,9 @@ void TrafficLightsPerceptionComponent::Visualize(
               1.5, cv::Scalar(255, 255, 255), 3);
 
   cv::resize(output_image, output_image, cv::Size(), 0.5, 0.5);
-  cv::imshow("Traffic Light", output_image);
-  cv::imwrite(absl::StrCat("/apollo/debug_vis/", frame.timestamp, ".jpg"),
+  cv::imwrite(absl::StrCat("/apollo/debug_vis/",
+                           std::to_string(frame.timestamp), ".jpg"),
               output_image);
-  cv::waitKey(30);
 }
 
 void TrafficLightsPerceptionComponent::SyncV2XTrafficLights(
</diff>
			</file>
			<file old_path="modules\perception\production\data\perception\camera\models\traffic_light_detection\baidu_iter_140000.caffemodel" new_path="modules\perception\production\data\perception\camera\models\traffic_light_detection\baidu_iter_140000.caffemodel" added_lines="0" deleted_lines="0">
				<diff>Binary files /dev/null and b/modules/perception/production/data/perception/camera/models/traffic_light_detection/baidu_iter_140000.caffemodel differ
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="afdb92ee49d51961ff36b6cfa34ee3d338a1c57f" author="changsh726">
		<msg>Build: splited target class_loader</msg>
		<modified_files>
			<file old_path="cyber\class_loader\utility\class_factory.cc" new_path="cyber\class_loader\utility\class_factory.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -15,7 +15,7 @@
  *****************************************************************************/
 #include "cyber/class_loader/utility/class_factory.h"
 
-#include "cyber/class_loader/class_loader.h"
+#include &lt;algorithm&gt;
 
 namespace apollo {
 namespace cyber {
</diff>
			</file>
			<file old_path="cyber\class_loader\utility\class_loader_utility.cc" new_path="cyber\class_loader\utility\class_loader_utility.cc" added_lines="0" deleted_lines="2">
				<diff>@@ -16,8 +16,6 @@
 
 #include "cyber/class_loader/utility/class_loader_utility.h"
 
-#include "cyber/class_loader/class_loader.h"
-
 namespace apollo {
 namespace cyber {
 namespace class_loader {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f425d44c3e6e779319eae53ccdfe1e2b34013a36" author="changsh726">
		<msg>Common: added hesai related config</msg>
		<modified_files>
			<file old_path="modules\common\adapters\adapter_gflags.cc" new_path="modules\common\adapters\adapter_gflags.cc" added_lines="3" deleted_lines="0">
				<diff>@@ -61,6 +61,9 @@ DEFINE_string(pointcloud_64_topic,
 DEFINE_string(pointcloud_128_topic,
               "/apollo/sensor/lidar128/compensator/PointCloud2",
               "pointcloud topic name for 128 beam lidar");
+DEFINE_string(pointcloud_hesai_40p_topic,
+              "/apollo/sensor/hesai40/compensator/PointCloud2",
+              "pointcloud topic name for hesai40p lidar");
 DEFINE_string(pointcloud_raw_topic, "/apollo/sensor/velodyne64/PointCloud2",
               "pointcloud raw topic name");
 DEFINE_string(velodyne_raw_topic,
</diff>
			</file>
			<file old_path="modules\common\adapters\adapter_gflags.h" new_path="modules\common\adapters\adapter_gflags.h" added_lines="1" deleted_lines="0">
				<diff>@@ -40,6 +40,7 @@ DECLARE_string(pointcloud_16_topic);
 DECLARE_string(pointcloud_16_front_up_topic);
 DECLARE_string(pointcloud_64_topic);
 DECLARE_string(pointcloud_128_topic);
+DECLARE_string(pointcloud_hesai_40p_topic);
 DECLARE_string(pointcloud_raw_topic);
 DECLARE_string(velodyne_raw_topic);
 DECLARE_string(pointcloud_fusion_topic);
</diff>
			</file>
			<file old_path="modules\monitor\software\channel_monitor.cc" new_path="modules\monitor\software\channel_monitor.cc" added_lines="2" deleted_lines="0">
				<diff>@@ -93,6 +93,8 @@ ReaderAndMessagePair GetReaderAndLatestMessage(const std::string&amp; channel) {
           {FLAGS_pointcloud_128_topic,
            &amp;CreateReaderAndLatestsMessage&lt;drivers::PointCloud&gt;},
           {FLAGS_pointcloud_16_front_up_topic,
+           &amp;CreateReaderAndLatestsMessage&lt;drivers::PointCloud&gt;},
+          {FLAGS_pointcloud_hesai_40p_topic,
            &amp;CreateReaderAndLatestsMessage&lt;drivers::PointCloud&gt;}
           // Add more channels here if you want to monitor.
       };
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="712a69e22b438599602c949db2d8abe3f8ad3f3d" author="storypku">
		<msg>Cyber: print config file name for scheduler if not found</msg>
		<modified_files>
			<file old_path="cyber\scheduler\scheduler_factory.cc" new_path="cyber\scheduler\scheduler_factory.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -60,7 +60,8 @@ Scheduler* Instance() {
       if (PathExists(cfg_file) &amp;&amp; GetProtoFromFile(cfg_file, &amp;cfg)) {
         policy = cfg.scheduler_conf().policy();
       } else {
-        AWARN &lt;&lt; "No sched conf found, use default conf.";
+        AWARN &lt;&lt; "Scheduler conf named " &lt;&lt; cfg_file
+              &lt;&lt; " not found, use default.";
       }
       if (!policy.compare("classic")) {
         obj = new SchedulerClassic();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="39572c120bdcd7f2b709f92337a7c4dda4189dfc" author="storypku">
		<msg>Perception: use absolute path for config</msg>
		<modified_files>
			<file old_path="modules\perception\production\conf\perception\camera\trafficlights_perception_component.config" new_path="modules\perception\production\conf\perception\camera\trafficlights_perception_component.config" added_lines="1" deleted_lines="1">
				<diff>@@ -10,7 +10,7 @@ query_tf_interval_seconds : 0.3
 valid_hdmap_interval : 1.5
 image_sys_ts_diff_threshold : 0.5
 sync_interval_seconds : 0.5
-camera_traffic_light_perception_conf_dir : "../modules/perception/production/conf/perception/camera"
+camera_traffic_light_perception_conf_dir : "/apollo/modules/perception/production/conf/perception/camera"
 camera_traffic_light_perception_conf_file : "trafficlight.pt"
 default_image_border_size : 100
 #traffic_light_output_channel_name : "/perception/traffic_light_status"
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d42087aef4074892ed57d33927e160d35ad68889" author="Chang Songhong">
		<msg>Calibration: Implementation of FuelClient related functions (#13084)

* sensor_calibration: add sanity check tool

* sensor_calibration: extract_data.sh get the latest records if -f and -d are not specified

* sensor_calibration: extract_data.sh implemented non-interactive mode

* sensor_calibration: updated sanity_check.py

* sensor_calibration: extract_data.sh minor change

* Dreamview: added PreprocessMonitor

* sensor_calibration: extract_data.sh added support for camera_to_lidar calibration

* sensor_calibration: extract_data.py unified format string style

* sensor_calibration: added task types

* Dreamview: PreprocessMonitor added camera_to_lidar support

* sensor_calibration: improved extract_data.sh

* HMI: updated preprocess request handler

* sensor_calibration: updated camera_to_lidar support

* Dreamview: updated preprocess_table

* Dreamview: added Camera-Lidar Calibration mode

* Dreamview: added FuelMonitorManager

* sensor_calibration: camera_to_lidar task generate translation config from user file

* sensor_calibration: sanity_check.py use absl modules

* vehicle_calibration: added preprocess tool

* HMI: added interaction functions with vehicle calibration preprocess tool

* Dreamview: PreprocessMonitor added default constructor

* Dreamview: FuelMonitorManager refactored

* vehicle_calibration: improved preprocess tool

* sensor_calibration: extract_data.py refactored

* sensor_calibration: extract_data.sh updated

* Dreamview: added preprocess status

* Dreamview:Add fuel client panel

* Dreamview:add current_mode field

* Dreamview:remove extra comment in preprocess_monitor

* Dreamview:modify status logic

* HMI: minor change

* Dreamview: bugfix

* sensor_calibration: generate camera channel from record

* Dreamview: preprocess_table.proto refactored

* sensor_calibaraiton: updated camera_to_lidar related function

* Monitor: added process moniting for some other components

* sensor_calibration: get task type from hmi_worker

* Dreamview: updated preprocess table config

* Dreamview: simple code clean

* Dreamview:remove camera select and add camera internal param

* Dreamview:remove extra comment

* fix websocket bug and camera judge bug

* fix progress bug

* Dreamview:change the R internal param input number

* Dreamview: bugfix

* Dreamview: fix typo and code clean

* sensor_calibration: use get_pb_from_text_file

* FuelClient: added translation name

* HMI: added camera monitor for camera-lidar calibration mode

* FuelClient: camera configuration table reorganized

* Dreamview: bugfix

* vehicle_calibration: changed output dir

* Dreamview: rename lidar-configuration to sensor-configuration

* Dreamview:add icon and preprocess fatal logString

* FuelClient: updated process monitoring logic

* Dreamview:polish code remove unused comments

* Dreamview:modify static time error

* Dreamview: bugfix

* Dreamview:polish code and modify some details

* Dreamview: updated vehicle calibration config

* Dreamview: updated lidar-IMU calibration mode config

* Dreamview: updated vehicle calibration mode config

* FuelClient: removed param R

* Dreamview: bugfix

* Monitor: updated camera monitor topics

* vehicle_calibration: copy records end with _s

* vehicle calibration: start data collection only when started recorder

* sensor_calibration: updated monitored components

* vehicle_calibration: restart data collection monitor when start recorder

* vehicle_calibration: added channel monitor for chassis_detail

* Monitor: channel monitor added chassis_detail_topic

* Monitor: updated monitored channel

* Monitor: check whether the message reseived from monitored channel is empty

* sensor_calibration: record all channels in lidar-IMU mode

* sensor_calibration: updated monitored components

* FuelClient: renamed Localization Pose to RTK

* sensor_calibration: added recorder to monitored components

* Vehicle Calibration: remove no data found ,modify preprocess disable logic

* Dreamview: remove extra comment

* Dreamview:modify monitored component logic by removing monitor recorder

* Dreamview: fix highlight main sensor style bug

* Dreamview:fix input bug

* Dreamview: modify the style for camera-lidar

* FuelClinet: SensorCalibrationConfiguration refactor

* FuelClient: updated guiding text

* sensor_calibration: removed transform module

* FuelClient: SensorCalibrationConfiguration.js minor change

* Dreamview: added preprocess button style (from @walle-zhao)

Co-authored-by: lj0919 &lt;605944389@qq.com&gt;
Co-authored-by: walle-zhao &lt;208665675@qq.com&gt;</msg>
		<modified_files>
			<file old_path="docs\Apollo_Fuel\examples\sensor_calibration\camera_12mm_to_lidar\camera_12mm_to_lidar.config" new_path="" added_lines="0" deleted_lines="44">
				<diff>@@ -1,44 +0,0 @@
-# data extraction configuration for multi-camera to lidar calibration
-# must includes:
-# at least 1 camera image channel
-# lidar 16 point cloud channel
-# GNSS Gps/odometry channel
-
-io_config: {
-	task_name: "camera_to_lidar"
-	output_path: "/apollo/sensor_calibration/camera_12mm_to_lidar/extracted_data"
-	# start_timestamp: "FLOAT_MIN"
-	# end_timestamp: "FLOAT_MAX"
-	# start_timestamp: "1553901009.071362291"
-	# end_timestamp: "1553901012.01"
-}
-
-records: {
-	# records can be specified as a list
-	#record_path: "/apollo/data/bag/test/20190325185008.record.00001"
-	#record_path: "/apollo/data/bag/test/20190325185008.record.00002"
-	#record_path: "/apollo/data/bag/test/20190325185008.record.00003"
-	# or, records can be loaded from a directory
-	record_path: "/apollo/sensor_calibration/camera_12mm_to_lidar/records"
-}
-
-channels: {
-	# channel of camera image channels
-	channel: {
-		description: "front camera 12mm"
-		name: "/apollo/sensor/camera/front_12mm/image"
-		extraction_rate: 5
-	}
-	# channel of 16-beam lidar
-	channel: {
-		description: "lidar 16 point cloud"
-		name: "/apollo/sensor/lidar16/PointCloud2"
-		extraction_rate: 5
-	}
-	# channel of localization pose odometry
-	channel: {
-		description: "GNSS odometry"
-		name: "/apollo/localization/pose"
-		extraction_rate: 1
-	}
-}
</diff>
			</file>
			<file old_path="docs\Apollo_Fuel\examples\sensor_calibration\camera_6mm_to_lidar\camera_6mm_to_lidar.config" new_path="docs\Apollo_Fuel\examples\sensor_calibration\camera_to_lidar\camera_to_lidar.config" added_lines="2" deleted_lines="2">
				<diff>@@ -6,7 +6,7 @@
 
 io_config: {
 	task_name: "camera_to_lidar"
-	output_path: "/apollo/sensor_calibration/camera_6mm_to_lidar/extracted_data"
+	output_path: "/apollo/output/sensor_calibration/camera_to_lidar/extracted_data"
 	# start_timestamp: "FLOAT_MIN"
 	# end_timestamp: "FLOAT_MAX"
 	# start_timestamp: "1553901009.071362291"
@@ -19,7 +19,7 @@ records: {
 	#record_path: "/apollo/data/bag/test/20190325185008.record.00002"
 	#record_path: "/apollo/data/bag/test/20190325185008.record.00003"
 	# or, records can be loaded from a directory
-	record_path: "/apollo/sensor_calibration/camera_6mm_to_lidar/records"
+	# record_path: "/apollo/output/sensor_calibration/camera_to_lidar/records"
 }
 
 channels: {
</diff>
			</file>
			<file old_path="docs\Apollo_Fuel\examples\sensor_calibration\lidar_to_gnss\lidar_to_gnss.config" new_path="docs\Apollo_Fuel\examples\sensor_calibration\lidar_to_gnss\lidar_to_gnss.config" added_lines="2" deleted_lines="2">
				<diff>@@ -6,7 +6,7 @@
 io_config: {
 	# task name now only support "camera_to_lidar, lidar_to_gnss"
 	task_name: "lidar_to_gnss"
-	output_path: "/apollo/sensor_calibration/lidar_to_gnss/extracted_data"
+	output_path: "/apollo/output/sensor_calibration/lidar_to_gnss/extracted_data"
 	# start_timestamp: "FLOAT_MIN"
 	# end_timestamp: "FLOAT_MAX"
 	# start_timestamp: "1553901009.071362291"
@@ -19,7 +19,7 @@ records: {
 	#record_path: "/apollo/data/bag/test/20190325185008.record.00002"
 	#record_path: "/apollo/data/bag/test/20190325185008.record.00003"
 	# or, records can be loaded from a directory
-	record_path: "/apollo/sensor_calibration/lidar_to_gnss/records"
+	#record_path: "/apollo/output/sensor_calibration/lidar_to_gnss/records"
 }
 
 channels: {
</diff>
			</file>
			<file old_path="modules\common\adapters\adapter_gflags.cc" new_path="modules\common\adapters\adapter_gflags.cc" added_lines="11" deleted_lines="2">
				<diff>@@ -52,6 +52,9 @@ DEFINE_string(pointcloud_topic,
 DEFINE_string(pointcloud_16_topic,
               "/apollo/sensor/lidar16/compensator/PointCloud2",
               "16 beam Lidar pointcloud topic name");
+DEFINE_string(pointcloud_16_raw_topic,
+              "/apollo/sensor/lidar16/PointCloud2",
+              "16 beam Lidar raw pointcloud topic name");
 DEFINE_string(pointcloud_16_front_up_topic,
               "/apollo/sensor/lidar16/front/up/compensator/PointCloud2",
               "Front up 16 beam Lidar pointcloud topic name");
@@ -161,6 +164,13 @@ DEFINE_string(camera_image_long_topic, "/apollo/sensor/camera/image_long",
               "long camera image topic name");
 DEFINE_string(camera_image_short_topic, "/apollo/sensor/camera/image_short",
               "short camera image topic name");
+DEFINE_string(camera_front_6mm_topic, "/apollo/sensor/camera/front_6mm/image",
+              "front 6mm camera topic name");
+DEFINE_string(camera_front_6mm_2_topic,
+              "/apollo/sensor/camera/front_6mm_2/image",
+              "front 6mm camera topic name 2");
+DEFINE_string(camera_front_12mm_topic, "/apollo/sensor/camera/front_12mm/image",
+              "front 12mm camera topic name");
 DEFINE_string(camera_front_6mm_compressed_topic,
               "/apollo/sensor/camera/front_6mm/image/compressed",
               "front 6mm camera compressed topic name");
@@ -247,5 +257,4 @@ DEFINE_string(latency_recording_topic, "/apollo/common/latency_records",
               "Latency recording topic.");
 DEFINE_string(latency_reporting_topic, "/apollo/common/latency_reports",
               "Latency reporting topic.");
-DEFINE_string(task_topic, "/apollo/task_manager",
-              "task manager topic name");
+DEFINE_string(task_topic, "/apollo/task_manager", "task manager topic name");
</diff>
			</file>
			<file old_path="modules\common\adapters\adapter_gflags.h" new_path="modules\common\adapters\adapter_gflags.h" added_lines="4" deleted_lines="0">
				<diff>@@ -37,6 +37,7 @@ DECLARE_string(control_local_view_topic);
 DECLARE_string(control_core_command_topic);
 DECLARE_string(pointcloud_topic);
 DECLARE_string(pointcloud_16_topic);
+DECLARE_string(pointcloud_16_raw_topic);
 DECLARE_string(pointcloud_16_front_up_topic);
 DECLARE_string(pointcloud_64_topic);
 DECLARE_string(pointcloud_128_topic);
@@ -83,6 +84,9 @@ DECLARE_string(image_short_topic);
 DECLARE_string(image_long_topic);
 DECLARE_string(camera_image_long_topic);
 DECLARE_string(camera_image_short_topic);
+DECLARE_string(camera_front_6mm_topic);
+DECLARE_string(camera_front_6mm_2_topic);
+DECLARE_string(camera_front_12mm_topic);
 DECLARE_string(camera_front_6mm_compressed_topic);
 DECLARE_string(camera_front_12mm_compressed_topic);
 DECLARE_string(camera_left_fisheye_compressed_topic);
</diff>
			</file>
			<file old_path="modules\dreamview\backend\common\dreamview_gflags.cc" new_path="modules\dreamview\backend\common\dreamview_gflags.cc" added_lines="13" deleted_lines="0">
				<diff>@@ -95,3 +95,16 @@ DEFINE_string(default_data_collection_config_path,
 
 DEFINE_int32(loop_routing_end_to_start_distance_threshold, 10,
              "Loop routing distance threshold: start to end");
+
+DEFINE_string(default_preprocess_config_path,
+              "/apollo/modules/dreamview/conf/preprocess_table.pb.txt",
+              "Sensor calibration preprocess table config path.");
+
+DEFINE_string(vehicle_calibration_mode, "Vehicle Calibration",
+              "Name of vehicle calibration mode.");
+
+DEFINE_string(lidar_calibration_mode, "Lidar-IMU Sensor Calibration",
+              "Name of lidar_to_gnss calibration mode.");
+
+DEFINE_string(camera_calibration_mode, "Camera-Lidar Sensor Calibration",
+              "Name of camera_to_lidar calibration mode.");
</diff>
			</file>
			<file old_path="modules\dreamview\backend\common\dreamview_gflags.h" new_path="modules\dreamview\backend\common\dreamview_gflags.h" added_lines="8" deleted_lines="0">
				<diff>@@ -61,3 +61,11 @@ DECLARE_int32(monitor_msg_pending_queue_size);
 DECLARE_string(default_data_collection_config_path);
 
 DECLARE_int32(loop_routing_end_to_start_distance_threshold);
+
+DECLARE_string(default_preprocess_config_path);
+
+DECLARE_string(vehicle_calibration_mode);
+
+DECLARE_string(lidar_calibration_mode);
+
+DECLARE_string(camera_calibration_mode);
</diff>
			</file>
			<file old_path="modules\dreamview\backend\dreamview.cc" new_path="modules\dreamview\backend\dreamview.cc" added_lines="3" deleted_lines="5">
				<diff>@@ -80,18 +80,16 @@ Status Dreamview::Init() {
   map_service_.reset(new MapService());
   image_.reset(new ImageHandler());
   sim_control_.reset(new SimControl(map_service_.get()));
-  data_collection_monitor_.reset(new DataCollectionMonitor());
   perception_camera_updater_.reset(
       new PerceptionCameraUpdater(camera_ws_.get()));
 
   sim_world_updater_.reset(new SimulationWorldUpdater(
       websocket_.get(), map_ws_.get(), camera_ws_.get(), sim_control_.get(),
-      map_service_.get(), data_collection_monitor_.get(),
-      perception_camera_updater_.get(), FLAGS_routing_from_file));
+      map_service_.get(), perception_camera_updater_.get(),
+      FLAGS_routing_from_file));
   point_cloud_updater_.reset(
       new PointCloudUpdater(point_cloud_ws_.get(), sim_world_updater_.get()));
-  hmi_.reset(new HMI(websocket_.get(), map_service_.get(),
-                     data_collection_monitor_.get()));
+  hmi_.reset(new HMI(websocket_.get(), map_service_.get()));
 
   server_-&gt;addWebSocketHandler("/websocket", *websocket_);
   server_-&gt;addWebSocketHandler("/map", *map_ws_);
</diff>
			</file>
			<file old_path="modules\dreamview\backend\dreamview.h" new_path="modules\dreamview\backend\dreamview.h" added_lines="1" deleted_lines="2">
				<diff>@@ -20,9 +20,9 @@
 #include &lt;string&gt;
 
 #include "CivetServer.h"
+
 #include "cyber/cyber.h"
 #include "modules/common/status/status.h"
-#include "modules/dreamview/backend/data_collection_monitor/data_collection_monitor.h"
 #include "modules/dreamview/backend/handlers/image_handler.h"
 #include "modules/dreamview/backend/handlers/websocket_handler.h"
 #include "modules/dreamview/backend/hmi/hmi.h"
@@ -66,7 +66,6 @@ class Dreamview {
   std::unique_ptr&lt;ImageHandler&gt; image_;
   std::unique_ptr&lt;MapService&gt; map_service_;
   std::unique_ptr&lt;HMI&gt; hmi_;
-  std::unique_ptr&lt;DataCollectionMonitor&gt; data_collection_monitor_;
   std::unique_ptr&lt;PerceptionCameraUpdater&gt; perception_camera_updater_;
 #if WITH_TELEOP == 1
   std::unique_ptr&lt;TeleopService&gt; teleop_;
</diff>
			</file>
			<file old_path="modules\dreamview\backend\data_collection_monitor\data_collection_monitor.cc" new_path="modules\dreamview\backend\fuel_monitor\data_collection_monitor.cc" added_lines="9" deleted_lines="7">
				<diff>@@ -14,8 +14,9 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/dreamview/backend/data_collection_monitor/data_collection_monitor.h"
+#include "modules/dreamview/backend/fuel_monitor/data_collection_monitor.h"
 
+#include "gflags/gflags.h"
 #include "google/protobuf/descriptor.h"
 #include "google/protobuf/message.h"
 
@@ -23,6 +24,7 @@
 #include "modules/common/adapters/adapter_gflags.h"
 #include "modules/common/configs/vehicle_config_helper.h"
 #include "modules/dreamview/backend/common/dreamview_gflags.h"
+#include "modules/dreamview/backend/fuel_monitor/fuel_monitor_gflags.h"
 #include "modules/dreamview/backend/hmi/vehicle_manager.h"
 
 namespace apollo {
@@ -33,6 +35,7 @@ using apollo::common::VehicleConfigHelper;
 using cyber::common::PathExists;
 using google::protobuf::FieldDescriptor;
 using Json = nlohmann::json;
+
 namespace {
 
 /*
@@ -94,7 +97,8 @@ bool IsCompliedWithCriterion(float actual_value,
 }  // namespace
 
 DataCollectionMonitor::DataCollectionMonitor()
-    : node_(cyber::CreateNode("data_collection_monitor")) {
+    : FuelMonitor(FLAGS_data_collection_monitor_name),
+      node_(cyber::CreateNode("data_collection_monitor")) {
   InitReaders();
   LoadConfiguration();
 }
@@ -185,11 +189,9 @@ void DataCollectionMonitor::Start() {
   enabled_ = true;
 }
 
-void DataCollectionMonitor::Stop() { enabled_ = false; }
-
-void DataCollectionMonitor::Restart() {
-  Stop();
-  Start();
+void DataCollectionMonitor::Stop() {
+  enabled_ = false;
+  AINFO &lt;&lt; "DataCollectionMonitor stopped";
 }
 
 void DataCollectionMonitor::OnChassis(const std::shared_ptr&lt;Chassis&gt;&amp; chassis) {
</diff>
			</file>
			<file old_path="modules\dreamview\backend\data_collection_monitor\data_collection_monitor.h" new_path="modules\dreamview\backend\fuel_monitor\data_collection_monitor.h" added_lines="9" deleted_lines="10">
				<diff>@@ -26,13 +26,17 @@
 #include &lt;vector&gt;
 
 #include &lt;boost/thread/shared_mutex.hpp&gt;
+
 #include "gtest/gtest_prod.h"
+
 #include "nlohmann/json.hpp"
 
-#include "cyber/cyber.h"
 #include "modules/canbus/proto/chassis.pb.h"
 #include "modules/dreamview/proto/data_collection_table.pb.h"
 
+#include "cyber/cyber.h"
+#include "modules/dreamview/backend/fuel_monitor/fuel_monitor.h"
+
 /**
  * @namespace apollo::dreamview
  * @brief apollo::dreamview
@@ -47,7 +51,7 @@ typedef std::vector&lt;Range&gt; Category;
  * @brief A module that monitor data collection progress for calibration
  * purpose.
  */
-class DataCollectionMonitor {
+class DataCollectionMonitor : public FuelMonitor {
  public:
   /**
    * @brief Constructor of DataCollectionMonitor.
@@ -55,17 +59,15 @@ class DataCollectionMonitor {
   DataCollectionMonitor();
   ~DataCollectionMonitor();
 
-  bool IsEnabled() const { return enabled_; }
-
   /**
    * @brief start monitoring collection progress
    */
-  void Start();
+  void Start() override;
 
   /**
    * @brief stop monitoring collection progress
    */
-  void Stop();
+  void Stop() override;
 
   /**
    * @brief restart monitoring collection progress
@@ -75,7 +77,7 @@ class DataCollectionMonitor {
   /**
    * @brief return collection progress of categories and overall as json
    */
-  nlohmann::json GetProgressAsJson();
+  nlohmann::json GetProgressAsJson() override;
 
  private:
   void InitReaders();
@@ -92,9 +94,6 @@ class DataCollectionMonitor {
 
   std::unique_ptr&lt;cyber::Node&gt; node_;
 
-  // Whether the calibration monitor is enabled.
-  bool enabled_ = false;
-
   // The table defines data collection requirements for calibration
   DataCollectionTable data_collection_table_;
 
</diff>
			</file>
			<file old_path="modules\dreamview\backend\data_collection_monitor\data_collection_monitor_test.cc" new_path="modules\dreamview\backend\fuel_monitor\data_collection_monitor_test.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -14,7 +14,7 @@
  * limitations under the License.
  *****************************************************************************/
 
-#include "modules/dreamview/backend/data_collection_monitor/data_collection_monitor.h"
+#include "modules/dreamview/backend/fuel_monitor/data_collection_monitor.h"
 
 #include "gtest/gtest.h"
 
</diff>
			</file>
			<file old_path="modules\dreamview\backend\hmi\hmi.cc" new_path="modules\dreamview\backend\hmi\hmi.cc" added_lines="53" deleted_lines="14">
				<diff>@@ -19,25 +19,31 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
+#include "google/protobuf/util/json_util.h"
+
+#include "modules/dreamview/proto/preprocess_table.pb.h"
+
+#include "cyber/common/file.h"
 #include "modules/common/adapters/adapter_gflags.h"
 #include "modules/common/configs/vehicle_config_helper.h"
 #include "modules/common/util/json_util.h"
 #include "modules/dreamview/backend/common/dreamview_gflags.h"
+#include "modules/dreamview/backend/fuel_monitor/fuel_monitor_manager.h"
 #include "modules/dreamview/backend/point_cloud/point_cloud_updater.h"
 
 namespace apollo {
 namespace dreamview {
 
 using apollo::common::util::JsonUtil;
+using apollo::cyber::common::SetProtoToASCIIFile;
+using google::protobuf::util::JsonStringToMessage;
 using Json = WebSocketHandler::Json;
 
-HMI::HMI(WebSocketHandler* websocket, MapService* map_service,
-         DataCollectionMonitor* data_collection_monitor)
+HMI::HMI(WebSocketHandler* websocket, MapService* map_service)
     : hmi_worker_(new HMIWorker()),
       monitor_log_buffer_(apollo::common::monitor::MonitorMessageItem::HMI),
       websocket_(websocket),
-      map_service_(map_service),
-      data_collection_monitor_(data_collection_monitor) {
+      map_service_(map_service) {
   if (websocket_) {
     RegisterMessageHandlers();
   }
@@ -103,16 +109,6 @@ void HMI::RegisterMessageHandlers() {
           // Reload lidar params for point cloud service.
           PointCloudUpdater::LoadLidarHeight(FLAGS_lidar_height_yaml);
           SendVehicleParam();
-          if (data_collection_monitor_-&gt;IsEnabled()) {
-            data_collection_monitor_-&gt;Restart();
-          }
-        } else if (hmi_action == HMIAction::CHANGE_MODE) {
-          static constexpr char kCalibrationMode[] = "Vehicle Calibration";
-          if (value == kCalibrationMode) {
-            data_collection_monitor_-&gt;Start();
-          } else {
-            data_collection_monitor_-&gt;Stop();
-          }
         }
       });
 
@@ -171,6 +167,49 @@ void HMI::RegisterMessageHandlers() {
       [this](const Json&amp; json, WebSocketHandler::Connection* conn) {
         SendStatus(conn);
       });
+
+  websocket_-&gt;RegisterMessageHandler(
+      "SensorCalibrationPreprocess",
+      [this](const Json&amp; json, WebSocketHandler::Connection* conn) {
+        // json should contain type and data.
+        std::string current_mode = hmi_worker_-&gt;GetStatus().current_mode();
+        std::string task_type;
+        if (current_mode == FLAGS_lidar_calibration_mode) {
+          task_type = "lidar_to_gnss";
+        } else if (current_mode == FLAGS_camera_calibration_mode) {
+          task_type = "camera_to_lidar";
+        } else {
+          AERROR &lt;&lt; "Unsupported mode:" &lt;&lt; current_mode;
+          return;
+        }
+
+        const auto iter = json.find("data");
+        if (iter == json.end()) {
+          AERROR &lt;&lt; "The json has no such key: data";
+          return;
+        }
+        PreprocessTable preprocess_table;
+        if (!JsonStringToMessage(json["data"].dump(), &amp;preprocess_table).ok()) {
+          AERROR
+              &lt;&lt; "Failed to get user configuration: invalid preprocess table."
+              &lt;&lt; json.dump();
+        }
+
+        // Gernerate user-specified configuration and run the preprocess script
+        std::string output_file =
+            absl::StrCat("/apollo/modules/tools/sensor_calibration/config/",
+                         task_type, "_user.config");
+        if (!SetProtoToASCIIFile(preprocess_table, output_file)) {
+          AERROR &lt;&lt; "Failed to generate user configuration file";
+        }
+        hmi_worker_-&gt;SensorCalibrationPreprocess(task_type);
+      });
+
+  websocket_-&gt;RegisterMessageHandler(
+      "VehicleCalibrationPreprocess",
+      [this](const Json&amp; json, WebSocketHandler::Connection* conn) {
+        hmi_worker_-&gt;VehicleCalibrationPreprocess();
+      });
 }
 
 void HMI::SendVehicleParam(WebSocketHandler::Connection* conn) {
</diff>
			</file>
			<file old_path="modules\dreamview\backend\hmi\hmi.h" new_path="modules\dreamview\backend\hmi\hmi.h" added_lines="2" deleted_lines="4">
				<diff>@@ -17,9 +17,9 @@
 #pragma once
 
 #include &lt;memory&gt;
+#include &lt;string&gt;
 
 #include "modules/common/monitor_log/monitor_log_buffer.h"
-#include "modules/dreamview/backend/data_collection_monitor/data_collection_monitor.h"
 #include "modules/dreamview/backend/handlers/websocket_handler.h"
 #include "modules/dreamview/backend/hmi/hmi_worker.h"
 #include "modules/dreamview/backend/map/map_service.h"
@@ -33,8 +33,7 @@ namespace dreamview {
 
 class HMI {
  public:
-  HMI(WebSocketHandler *websocket, MapService *map_service,
-      DataCollectionMonitor *data_collection_monitor_);
+  HMI(WebSocketHandler *websocket, MapService *map_service);
   void Start();
   void Stop();
 
@@ -51,7 +50,6 @@ class HMI {
   // No ownership.
   WebSocketHandler *websocket_;
   MapService *map_service_;
-  DataCollectionMonitor *data_collection_monitor_;
 };
 
 }  // namespace dreamview
</diff>
			</file>
			<file old_path="modules\dreamview\backend\hmi\hmi_worker.cc" new_path="modules\dreamview\backend\hmi\hmi_worker.cc" added_lines="78" deleted_lines="6">
				<diff>@@ -20,8 +20,10 @@
 #include "absl/strings/str_join.h"
 #include "absl/strings/str_split.h"
 
-#include "cyber/common/file.h"
 #include "cyber/proto/dag_conf.pb.h"
+#include "modules/monitor/proto/system_status.pb.h"
+
+#include "cyber/common/file.h"
 #include "modules/common/adapters/adapter_gflags.h"
 #include "modules/common/configs/config_gflags.h"
 #include "modules/common/kv_db/kv_db.h"
@@ -29,8 +31,11 @@
 #include "modules/common/util/map_util.h"
 #include "modules/common/util/message_util.h"
 #include "modules/dreamview/backend/common/dreamview_gflags.h"
+#include "modules/dreamview/backend/fuel_monitor/data_collection_monitor.h"
+#include "modules/dreamview/backend/fuel_monitor/fuel_monitor_gflags.h"
+#include "modules/dreamview/backend/fuel_monitor/fuel_monitor_manager.h"
+#include "modules/dreamview/backend/fuel_monitor/preprocess_monitor.h"
 #include "modules/dreamview/backend/hmi/vehicle_manager.h"
-#include "modules/monitor/proto/system_status.pb.h"
 
 DEFINE_string(hmi_modes_config_path, "/apollo/modules/dreamview/conf/hmi_modes",
               "HMI modes config path.");
@@ -213,14 +218,27 @@ HMIMode HMIWorker::LoadMode(const std::string&amp; mode_config_path) {
 }
 
 void HMIWorker::InitStatus() {
-  static const std::string kDockerImageEnv = "DOCKER_IMG";
+  static constexpr char kDockerImageEnv[] = "DOCKER_IMG";
   status_.set_docker_image(cyber::common::GetEnv(kDockerImageEnv));
   status_.set_utm_zone_id(FLAGS_local_utm_zone_id);
 
   // Populate modes and current_mode.
   const auto&amp; modes = config_.modes();
   for (const auto&amp; iter : modes) {
-    status_.add_modes(iter.first);
+    const std::string&amp; mode = iter.first;
+    status_.add_modes(mode);
+    if (mode == FLAGS_vehicle_calibration_mode) {
+      FuelMonitorManager::Instance()-&gt;RegisterFuelMonitor(
+          mode, std::make_unique&lt;DataCollectionMonitor&gt;());
+      FuelMonitorManager::Instance()-&gt;RegisterFuelMonitor(
+          mode, std::make_unique&lt;PreprocessMonitor&gt;());
+    } else if (mode == FLAGS_lidar_calibration_mode) {
+      FuelMonitorManager::Instance()-&gt;RegisterFuelMonitor(
+          mode, std::make_unique&lt;PreprocessMonitor&gt;("lidar_to_gnss"));
+    } else if (mode == FLAGS_camera_calibration_mode) {
+      FuelMonitorManager::Instance()-&gt;RegisterFuelMonitor(
+          mode, std::make_unique&lt;PreprocessMonitor&gt;("camera_to_lidar"));
+    }
   }
 
   // Populate maps and current_map.
@@ -285,7 +303,7 @@ void HMIWorker::InitReadersAndWriters() {
                 status != nullptr &amp;&amp; status-&gt;status() == ComponentStatus::OK;
           }
         }
-        // Update other components status.
+        // Update monitored components status.
         for (auto&amp; iter : *status_.mutable_monitored_components()) {
           auto* status = FindOrNull(system_status-&gt;components(), iter.first);
           if (status != nullptr) {
@@ -296,6 +314,18 @@ void HMIWorker::InitReadersAndWriters() {
           }
         }
 
+        // Update other components status.
+        for (auto&amp; iter : *status_.mutable_other_components()) {
+          auto* status =
+              FindOrNull(system_status-&gt;other_components(), iter.first);
+          if (status != nullptr) {
+            iter.second.CopyFrom(*status);
+          } else {
+            iter.second.set_status(ComponentStatus::UNKNOWN);
+            iter.second.set_message("Status not reported by Monitor.");
+          }
+        }
+
         // Check if the status is changed.
         const size_t new_fingerprint =
             apollo::common::util::MessageFingerprint(status_);
@@ -430,6 +460,20 @@ void HMIWorker::SubmitDriveEvent(const uint64_t event_time_ms,
   drive_event_writer_-&gt;Write(drive_event);
 }
 
+void HMIWorker::SensorCalibrationPreprocess(const std::string&amp; task_type) {
+  std::string start_command = absl::StrCat(
+      "nohup bash /apollo/scripts/extract_data.sh -t ", task_type, " &amp;");
+  System(start_command);
+}
+
+void HMIWorker::VehicleCalibrationPreprocess() {
+  std::string start_command = absl::StrCat(
+      "nohup bash /apollo/modules/tools/vehicle_calibration/preprocess.sh "
+      "--vehicle_type=\"",
+      status_.current_vehicle(), "\" --record_num=", record_count_, " &amp;");
+  System(start_command);
+}
+
 bool HMIWorker::ChangeDrivingMode(const Chassis::DrivingMode mode) {
   // Always reset to MANUAL mode before changing to other mode.
   const std::string mode_name = Chassis::DrivingMode_Name(mode);
@@ -511,8 +555,16 @@ void HMIWorker::ChangeVehicle(const std::string&amp; vehicle_name) {
     status_changed_ = true;
   }
   ResetMode();
-
   ACHECK(VehicleManager::Instance()-&gt;UseVehicle(*vehicle_dir));
+  // Restart Fuel Monitor
+  auto* monitors = FuelMonitorManager::Instance()-&gt;GetCurrentMonitors();
+  if (monitors != nullptr) {
+    for (const auto&amp; monitor : *monitors) {
+      if (monitor.second-&gt;IsEnabled()) {
+        monitor.second-&gt;Restart();
+      }
+    }
+  }
 }
 
 void HMIWorker::ChangeMode(const std::string&amp; mode_name) {
@@ -545,8 +597,15 @@ void HMIWorker::ChangeMode(const std::string&amp; mode_name) {
     for (const auto&amp; iter : current_mode_.monitored_components()) {
       status_.mutable_monitored_components()-&gt;insert({iter.first, {}});
     }
+
+    status_.clear_other_components();
+    for (const auto&amp; iter : current_mode_.other_components()) {
+      status_.mutable_other_components()-&gt;insert({iter.first, {}});
+    }
     status_changed_ = true;
   }
+
+  FuelMonitorManager::Instance()-&gt;SetCurrentMode(mode_name);
   KVDB::Put(FLAGS_current_mode_db_key, mode_name);
 }
 
@@ -557,6 +616,18 @@ void HMIWorker::StartModule(const std::string&amp; module) const {
   } else {
     AERROR &lt;&lt; "Cannot find module " &lt;&lt; module;
   }
+
+  if (module == "Recorder") {
+    auto* monitors = FuelMonitorManager::Instance()-&gt;GetCurrentMonitors();
+    auto iter = monitors-&gt;find(FLAGS_data_collection_monitor_name);
+    if (iter != monitors-&gt;end()) {
+      auto* data_collection_monitor = iter-&gt;second.get();
+      if (data_collection_monitor-&gt;IsEnabled() &amp;&amp; record_count_ == 0) {
+        data_collection_monitor-&gt;Restart();
+      }
+    }
+    ++record_count_;
+  }
 }
 
 void HMIWorker::StopModule(const std::string&amp; module) const {
@@ -583,6 +654,7 @@ void HMIWorker::ResetMode() const {
   for (const auto&amp; iter : current_mode_.modules()) {
     System(iter.second.stop_command());
   }
+  record_count_ = 0;
 }
 
 void HMIWorker::StatusUpdateThreadLoop() {
</diff>
			</file>
			<file old_path="modules\dreamview\backend\hmi\hmi_worker.h" new_path="modules\dreamview\backend\hmi\hmi_worker.h" added_lines="11" deleted_lines="4">
				<diff>@@ -24,8 +24,6 @@
 #include &lt;boost/thread/locks.hpp&gt;
 #include &lt;boost/thread/shared_mutex.hpp&gt;
 
-#include "cyber/cyber.h"
-#include "cyber/time/time.h"
 #include "modules/audio/proto/audio_event.pb.h"
 #include "modules/canbus/proto/chassis.pb.h"
 #include "modules/common/proto/drive_event.pb.h"
@@ -35,6 +33,9 @@
 #include "modules/dreamview/proto/hmi_status.pb.h"
 #include "modules/localization/proto/localization.pb.h"
 
+#include "cyber/cyber.h"
+#include "cyber/time/time.h"
+
 /**
  * @namespace apollo::dreamview
  * @brief apollo::dreamview
@@ -74,6 +75,12 @@ class HMIWorker {
                         const std::vector&lt;std::string&gt;&amp; event_types,
                         const bool is_reportable);
 
+  // Run sensor calibration preprocess
+  void SensorCalibrationPreprocess(const std::string&amp; task_type);
+
+  // Run vehicle calibration preprocess
+  void VehicleCalibrationPreprocess();
+
   // Get current HMI status.
   HMIStatus GetStatus() const;
 
@@ -114,6 +121,7 @@ class HMIWorker {
   size_t last_status_fingerprint_{};
   bool stop_ = false;
   mutable boost::shared_mutex status_mutex_;
+  mutable size_t record_count_ = 0;
   std::future&lt;void&gt; thread_future_;
   std::vector&lt;StatusUpdateHandler&gt; status_update_handlers_;
 
@@ -124,8 +132,7 @@ class HMIWorker {
       localization_reader_;
   std::shared_ptr&lt;cyber::Writer&lt;HMIStatus&gt;&gt; status_writer_;
   std::shared_ptr&lt;cyber::Writer&lt;apollo::control::PadMessage&gt;&gt; pad_writer_;
-  std::shared_ptr&lt;cyber::Writer&lt;apollo::audio::AudioEvent&gt;&gt;
-      audio_event_writer_;
+  std::shared_ptr&lt;cyber::Writer&lt;apollo::audio::AudioEvent&gt;&gt; audio_event_writer_;
   std::shared_ptr&lt;cyber::Writer&lt;apollo::common::DriveEvent&gt;&gt;
       drive_event_writer_;
 };
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" added_lines="25" deleted_lines="8">
				<diff>@@ -22,6 +22,7 @@
 #include "modules/common/util/json_util.h"
 #include "modules/common/util/map_util.h"
 #include "modules/dreamview/backend/common/dreamview_gflags.h"
+#include "modules/dreamview/backend/fuel_monitor/fuel_monitor_manager.h"
 #include "modules/map/hdmap/hdmap_util.h"
 
 namespace apollo {
@@ -47,7 +48,6 @@ SimulationWorldUpdater::SimulationWorldUpdater(
     WebSocketHandler *websocket, WebSocketHandler *map_ws,
     WebSocketHandler *camera_ws, SimControl *sim_control,
     const MapService *map_service,
-    DataCollectionMonitor *data_collection_monitor,
     PerceptionCameraUpdater *perception_camera_updater, bool routing_from_file)
     : sim_world_service_(map_service, routing_from_file),
       map_service_(map_service),
@@ -55,7 +55,6 @@ SimulationWorldUpdater::SimulationWorldUpdater(
       map_ws_(map_ws),
       camera_ws_(camera_ws),
       sim_control_(sim_control),
-      data_collection_monitor_(data_collection_monitor),
       perception_camera_updater_(perception_camera_updater) {
   RegisterMessageHandlers();
 }
@@ -330,17 +329,35 @@ void SimulationWorldUpdater::RegisterMessageHandlers() {
           }
         }
       });
+
   websocket_-&gt;RegisterMessageHandler(
       "RequestDataCollectionProgress",
       [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
-        if (!data_collection_monitor_-&gt;IsEnabled()) {
-          return;
+        auto *monitors = FuelMonitorManager::Instance()-&gt;GetCurrentMonitors();
+        if (monitors) {
+          const auto iter = monitors-&gt;find("DataCollectionMonitor");
+          if (iter != monitors-&gt;end() &amp;&amp; iter-&gt;second-&gt;IsEnabled()) {
+            Json response;
+            response["type"] = "DataCollectionProgress";
+            response["data"] = iter-&gt;second-&gt;GetProgressAsJson();
+            websocket_-&gt;SendData(conn, response.dump());
+          }
         }
+      });
 
-        Json response;
-        response["type"] = "DataCollectionProgress";
-        response["data"] = data_collection_monitor_-&gt;GetProgressAsJson();
-        websocket_-&gt;SendData(conn, response.dump());
+  websocket_-&gt;RegisterMessageHandler(
+      "RequestPreprocessProgress",
+      [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
+        auto *monitors = FuelMonitorManager::Instance()-&gt;GetCurrentMonitors();
+        if (monitors) {
+          const auto iter = monitors-&gt;find("PreprocessMonitor");
+          if (iter != monitors-&gt;end() &amp;&amp; iter-&gt;second-&gt;IsEnabled()) {
+            Json response;
+            response["type"] = "PreprocessProgress";
+            response["data"] = iter-&gt;second-&gt;GetProgressAsJson();
+            websocket_-&gt;SendData(conn, response.dump());
+          }
+        }
       });
 
   websocket_-&gt;RegisterMessageHandler(
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_updater.h" new_path="modules\dreamview\backend\simulation_world\simulation_world_updater.h" added_lines="1" deleted_lines="3">
				<diff>@@ -25,6 +25,7 @@
 
 #include &lt;boost/thread/locks.hpp&gt;
 #include &lt;boost/thread/shared_mutex.hpp&gt;
+
 #include "absl/strings/str_cat.h"
 
 #include "modules/routing/proto/default_routing.pb.h"
@@ -33,7 +34,6 @@
 
 #include "cyber/common/log.h"
 #include "cyber/cyber.h"
-#include "modules/dreamview/backend/data_collection_monitor/data_collection_monitor.h"
 #include "modules/dreamview/backend/handlers/websocket_handler.h"
 #include "modules/dreamview/backend/map/map_service.h"
 #include "modules/dreamview/backend/perception_camera_updater/perception_camera_updater.h"
@@ -67,7 +67,6 @@ class SimulationWorldUpdater {
   SimulationWorldUpdater(WebSocketHandler *websocket, WebSocketHandler *map_ws,
                          WebSocketHandler *camera_ws, SimControl *sim_control,
                          const MapService *map_service,
-                         DataCollectionMonitor *data_collection_monitor,
                          PerceptionCameraUpdater *perception_camera_updater,
                          bool routing_from_file = false);
 
@@ -139,7 +138,6 @@ class SimulationWorldUpdater {
   WebSocketHandler *map_ws_ = nullptr;
   WebSocketHandler *camera_ws_ = nullptr;
   SimControl *sim_control_ = nullptr;
-  DataCollectionMonitor *data_collection_monitor_ = nullptr;
   PerceptionCameraUpdater *perception_camera_updater_ = nullptr;
 
   // End point for requesting default route
</diff>
			</file>
			<file old_path="modules\monitor\common\monitor_manager.cc" new_path="modules\monitor\common\monitor_manager.cc" added_lines="7" deleted_lines="1">
				<diff>@@ -16,9 +16,11 @@
 
 #include "modules/monitor/common/monitor_manager.h"
 
-#include "cyber/common/file.h"
 #include "gflags/gflags.h"
+
 #include "modules/canbus/proto/chassis.pb.h"
+
+#include "cyber/common/file.h"
 #include "modules/common/adapters/adapter_gflags.h"
 #include "modules/common/configs/config_gflags.h"
 #include "modules/common/util/map_util.h"
@@ -65,6 +67,10 @@ bool MonitorManager::StartFrame(const double current_time) {
     for (const auto&amp; iter : mode_config_.monitored_components()) {
       status_.mutable_components()-&gt;insert({iter.first, {}});
     }
+    status_.clear_other_components();
+    for (const auto&amp; iter : mode_config_.other_components()) {
+      status_.mutable_other_components()-&gt;insert({iter.first, {}});
+    }
   } else {
     // Mode not changed, clear component summary from the last frame.
     for (auto&amp; iter : *status_.mutable_components()) {
</diff>
			</file>
			<file old_path="modules\monitor\software\camera_monitor.cc" new_path="modules\monitor\software\camera_monitor.cc" added_lines="3" deleted_lines="2">
				<diff>@@ -55,8 +55,9 @@ ReaderAndMessagePair CreateReaderAndLatestsMessage(const std::string&amp; camera) {
 }
 
 static const auto camera_topic_set = std::set&lt;std::string&gt;{
-    FLAGS_image_front_topic, FLAGS_image_long_topic,
-    FLAGS_camera_image_long_topic, FLAGS_camera_image_short_topic,
+    FLAGS_image_long_topic,         FLAGS_camera_image_long_topic,
+    FLAGS_camera_image_short_topic, FLAGS_camera_front_6mm_topic,
+    FLAGS_camera_front_6mm_2_topic, FLAGS_camera_front_12mm_topic,
     // Add more cameras here if you want to monitor.
 };
 
</diff>
			</file>
			<file old_path="modules\monitor\software\channel_monitor.cc" new_path="modules\monitor\software\channel_monitor.cc" added_lines="13" deleted_lines="0">
				<diff>@@ -27,6 +27,7 @@
 #include "google/protobuf/descriptor.h"
 #include "google/protobuf/dynamic_message.h"
 
+#include "modules/canbus/proto/chassis_detail.pb.h"
 #include "modules/common/latency_recorder/proto/latency_record.pb.h"
 #include "modules/control/proto/control_cmd.pb.h"
 #include "modules/drivers/proto/conti_radar.pb.h"
@@ -90,10 +91,14 @@ ReaderAndMessagePair GetReaderAndLatestMessage(const std::string&amp; channel) {
            &amp;CreateReaderAndLatestsMessage&lt;drivers::PointCloud&gt;},
           {FLAGS_pointcloud_16_topic,
            &amp;CreateReaderAndLatestsMessage&lt;drivers::PointCloud&gt;},
+          {FLAGS_pointcloud_16_raw_topic,
+           &amp;CreateReaderAndLatestsMessage&lt;drivers::PointCloud&gt;},
           {FLAGS_pointcloud_128_topic,
            &amp;CreateReaderAndLatestsMessage&lt;drivers::PointCloud&gt;},
           {FLAGS_pointcloud_16_front_up_topic,
            &amp;CreateReaderAndLatestsMessage&lt;drivers::PointCloud&gt;},
+          {FLAGS_chassis_detail_topic,
+           &amp;CreateReaderAndLatestsMessage&lt;canbus::ChassisDetail&gt;},
           {FLAGS_pointcloud_hesai_40p_topic,
            &amp;CreateReaderAndLatestsMessage&lt;drivers::PointCloud&gt;}
           // Add more channels here if you want to monitor.
@@ -180,6 +185,14 @@ void ChannelMonitor::UpdateStatus(
     return;
   }
 
+  if (message == nullptr || message-&gt;ByteSize() == 0) {
+    SummaryMonitor::EscalateStatus(
+        ComponentStatus::FATAL,
+        absl::StrCat("the message ", config.name(), " reseived is empty."),
+        status);
+    return;
+  }
+
   // Check channel delay
   const double delay = reader-&gt;GetDelaySec();
   if (delay &lt; 0 || delay &gt; config.delay_fatal()) {
</diff>
			</file>
			<file old_path="modules\monitor\software\process_monitor.cc" new_path="modules\monitor\software\process_monitor.cc" added_lines="10" deleted_lines="1">
				<diff>@@ -16,9 +16,10 @@
 
 #include "modules/monitor/software/process_monitor.h"
 
+#include "gflags/gflags.h"
+
 #include "cyber/common/file.h"
 #include "cyber/common/log.h"
-#include "gflags/gflags.h"
 #include "modules/common/util/map_util.h"
 #include "modules/monitor/common/monitor_manager.h"
 #include "modules/monitor/software/summary_monitor.h"
@@ -73,6 +74,14 @@ void ProcessMonitor::RunOnce(const double current_time) {
       UpdateStatus(running_processes, config, status);
     }
   }
+
+  // Check other components.
+  auto* other_components = manager-&gt;GetStatus()-&gt;mutable_other_components();
+  for (const auto&amp; iter : mode.other_components()) {
+    const std::string&amp; name = iter.first;
+    const auto&amp; config = iter.second;
+    UpdateStatus(running_processes, config, &amp;other_components-&gt;at(name));
+  }
 }
 
 void ProcessMonitor::UpdateStatus(
</diff>
			</file>
			<file old_path="modules\monitor\software\process_monitor.h" new_path="modules\monitor\software\process_monitor.h" added_lines="2" deleted_lines="1">
				<diff>@@ -19,9 +19,10 @@
 #include &lt;vector&gt;
 
 #include "modules/dreamview/proto/hmi_mode.pb.h"
-#include "modules/monitor/common/recurrent_runner.h"
 #include "modules/monitor/proto/system_status.pb.h"
 
+#include "modules/monitor/common/recurrent_runner.h"
+
 namespace apollo {
 namespace monitor {
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5c896356c63c6bc976a46aaafa99ae8fffaa686f" author="JackFu123">
		<msg>task_manager: make the begin point be destination</msg>
		<modified_files>
			<file old_path="modules\task_manager\cycle_routing_manager.cc" new_path="modules\task_manager\cycle_routing_manager.cc" added_lines="5" deleted_lines="3">
				<diff>@@ -58,7 +58,8 @@ bool CycleRoutingManager::GetNewRouting(
   if (is_allowed_to_route_) {
     if (CheckPointDistanceInThreshold(begin_point_.pose(), pose.position(),
                                       FLAGS_threshold_for_destination_check)) {
-      AINFO &lt;&lt; "GetNewRouting: reach begin point";
+      AINFO &lt;&lt; "GetNewRouting: reach begin point"
+            &lt;&lt; "Remaining cycles: " &lt;&lt; cycle_;
       new_routing_request-&gt;CopyFrom(original_routing_request_);
       auto cur_point = new_routing_request-&gt;mutable_waypoint(0);
       if (!map_service_-&gt;ConstructLaneWayPointWithHeading(
@@ -67,14 +68,14 @@ bool CycleRoutingManager::GetNewRouting(
         AINFO &lt;&lt; "GetNewRouting: construct begin lane way point fail!";
         return false;
       }
-      --cycle_;
       is_allowed_to_route_ = false;
       return true;
     }
   } else {
     if (CheckPointDistanceInThreshold(end_point_.pose(), pose.position(),
                                       FLAGS_threshold_for_destination_check)) {
-      AINFO &lt;&lt; "GetNewRouting: reach end point";
+      AINFO &lt;&lt; "GetNewRouting: reach end point"
+            &lt;&lt; "Remaining cycles: " &lt;&lt; cycle_;
       new_routing_request-&gt;clear_waypoint();
       auto cur_point = new_routing_request-&gt;add_waypoint();
       if (!map_service_-&gt;ConstructLaneWayPointWithHeading(
@@ -85,6 +86,7 @@ bool CycleRoutingManager::GetNewRouting(
       }
       auto next_point = new_routing_request-&gt;add_waypoint();
       next_point-&gt;CopyFrom(begin_point_);
+      --cycle_;
       is_allowed_to_route_ = true;
       return true;
     }
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.cc" new_path="modules\task_manager\task_manager_component.cc" added_lines="2" deleted_lines="3">
				<diff>@@ -74,9 +74,8 @@ bool TaskManagerComponent::Proc(const std::shared_ptr&lt;Task&gt;&amp; task) {
                                               &amp;routing_request_)) {
       common::util::FillHeader(node_-&gt;Name(), &amp;routing_request_);
       request_writer_-&gt;Write(routing_request_);
-      AINFO &lt;&lt; "Reach begin/end point: "
-            &lt;&lt; "routing manager send a routing request. "
-            &lt;&lt; "Remaining cycles: " &lt;&lt; cycle_routing_manager_-&gt;GetCycle();
+      AINFO &lt;&lt; "[TaskManagerComponent]Reach begin/end point: "
+            &lt;&lt; "routing manager send a routing request. ";
     }
     rate.Sleep();
   }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="fbbbe718d3ff650d99046a7ea1bbb7aac5359ea9" author="xiaoMrzhang">
		<msg>Perception: add smoke model 2D transform constraint (#13400)

* Perception: add smoke model 2D transform constraint

* Perception: code style</msg>
		<modified_files>
			<file old_path="modules\perception\camera\lib\obstacle\detector\smoke\region_output.cc" new_path="modules\perception\camera\lib\obstacle\detector\smoke\region_output.cc" added_lines="0" deleted_lines="4">
				<diff>@@ -127,10 +127,6 @@ void get_smoke_objects_cpu(const SmokeBlobs &amp;smoke_blobs,
   int len_pred = 14;
   for (int i = 0; i &lt; 50; i++) {
     const float* bbox = detect_result + i * len_pred;
-    // for (int j = 0; j &lt; 14; j++) {
-    //   std::cout &lt;&lt; bbox[j] &lt;&lt; " ";
-    // }
-    // std::cout &lt;&lt; std::endl;
     float score = bbox[13];
     if (score &lt; model_param.confidence_threshold()) {
       continue;
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\transformer\singlestage\singlestage_obstacle_transformer.cc" new_path="modules\perception\camera\lib\obstacle\transformer\singlestage\singlestage_obstacle_transformer.cc" added_lines="164" deleted_lines="0">
				<diff>@@ -15,6 +15,8 @@
  *****************************************************************************/
 #include "modules/perception/camera/lib/obstacle/transformer/singlestage/singlestage_obstacle_transformer.h"
 
+#include &lt;limits&gt;
+
 #include "cyber/common/file.h"
 #include "cyber/common/log.h"
 #include "modules/perception/camera/common/global_config.h"
@@ -23,6 +25,13 @@ namespace apollo {
 namespace perception {
 namespace camera {
 
+void TransformerParams::set_default() {
+  max_nr_iter = 10;
+  learning_rate = 0.7f;
+  k_min_cost = 4 * sqrtf(2.0f);
+  eps_cost = 1e-5f;
+}
+
 bool SingleStageObstacleTransformer::Init(
     const ObstacleTransformerInitOptions &amp;options) {
   std::string transformer_config =
@@ -180,6 +189,8 @@ bool SingleStageObstacleTransformer::Transform(
          &lt;&lt; k_mat[6] &lt;&lt; ", " &lt;&lt; k_mat[7] &lt;&lt; ", " &lt;&lt; k_mat[8] &lt;&lt; "\n";
   const auto &amp;camera2world_pose = frame-&gt;camera2world_pose;
 
+  int height = frame-&gt;data_provider-&gt;src_height();
+  int width = frame-&gt;data_provider-&gt;src_width();
   int nr_transformed_obj = 0;
   const float PI = common::Constant&lt;float&gt;::PI();
   for (auto &amp;obj : frame-&gt;detected_objects) {
@@ -205,6 +216,16 @@ bool SingleStageObstacleTransformer::Transform(
       rotation_y -= 2 * PI;
     }
 
+    // adjust center point
+    float bbox[4] = {0};
+    bbox[0] = obj-&gt;camera_supplement.box.xmin;
+    bbox[1] = obj-&gt;camera_supplement.box.ymin;
+    bbox[2] = obj-&gt;camera_supplement.box.xmax;
+    bbox[3] = obj-&gt;camera_supplement.box.ymax;
+    float center2d[3] = {0};
+
+    CenterPointFromBbox(bbox, dimension_hwl, rotation_y, object_center,
+                        center2d, k_mat, height, width);
     // fill back results
     FillResults(object_center, dimension_hwl, rotation_y, camera2world_pose,
                 theta_ray, obj);
@@ -214,6 +235,149 @@ bool SingleStageObstacleTransformer::Transform(
   return nr_transformed_obj &gt; 0;
 }
 
+float SingleStageObstacleTransformer::CenterPointFromBbox(const float *bbox,
+                                                          const float *hwl,
+                                                          float ry,
+                                                          float *center,
+                                                          float *center_2d,
+                                                          const float* k_mat,
+                                                          int height,
+                                                          int width) {
+  float height_bbox = bbox[3] - bbox[1];
+  float width_bbox = bbox[2] - bbox[0];
+  if (width_bbox &lt;= 0.0f || height_bbox &lt;= 0.0f) {
+    AERROR &lt;&lt; "Check predict bounding box, width or height is 0";
+    return false;
+  }
+
+  float f = k_mat[4] / 2;
+  float depth = f * hwl[0] * common::IRec(height_bbox);
+
+  // Compensate from the nearest vertical edge to center
+  const float PI = common::Constant&lt;float&gt;::PI();
+  float theta_bbox = static_cast&lt;float&gt;(atan(hwl[1] * common::IRec(hwl[2])));
+  float radius_bbox =
+      common::ISqrt(common::ISqr(hwl[2] / 2) + common::ISqr(hwl[1] / 2));
+
+  float abs_ry = fabsf(ry);
+  float theta_z = std::min(abs_ry, PI - abs_ry) + theta_bbox;
+  theta_z = std::min(theta_z, PI - theta_z);
+  depth += static_cast&lt;float&gt;(fabs(radius_bbox * sin(theta_z)));
+
+  // Back-project to solve center
+  float location[3] = {center[0], center[1] - hwl[0]/2, center[2]};
+  common::IProjectThroughIntrinsic(k_mat, location, center_2d);
+  center_2d[0] *= common::IRec(center_2d[2]);
+  center_2d[1] *= common::IRec(center_2d[2]);
+  if (fabsf(depth - center[2]) * common::IRec(center[2]) &gt; 0.1) {
+    ConstraintCenterPoint(bbox, center[2], ry, hwl, k_mat,
+                          center, center_2d, height, width);
+  }
+  return depth;
+}
+
+void SingleStageObstacleTransformer::ConstraintCenterPoint(const float *bbox,
+                                                           const float &amp;z_ref,
+                                                           const float &amp;ry,
+                                                           const float *hwl,
+                                                           const float *k_mat,
+                                                           float *center,
+                                                           float *x,
+                                                           int height,
+                                                           int width) {
+  float center_2d_target[2] =
+                {(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2};
+  const float K_MIN_COST = params_.k_min_cost;
+  const float EPS_COST_DELTA = params_.eps_cost;
+  const float LEARNING_RATE = params_.learning_rate;
+  const int MAX_ITERATION = params_.max_nr_iter;
+
+  float cost_pre = 2.0f * static_cast&lt;float&gt;(width);
+  float cost_delta = 0.0f;
+  float center_temp[3] = {0};
+  float rot_y[9] = {0};
+
+  // Get rotation matrix rot_y
+  /*
+      cos(ry)   0   sin(ry)
+  R =    0      1     0  
+      -sin(ry)  0   cos(ry)
+  */
+  GenRotMatrix(ry, rot_y);
+
+  int iter = 1;
+  bool stop = false;
+  float h = hwl[0];
+  float w = hwl[1];
+  float l = hwl[2];
+  float x_corners[8] = {0};
+  float y_corners[8] = {0};
+  float z_corners[8] = {0};
+
+  float x_upper_bound = static_cast&lt;float&gt;(width - 1);
+  float y_upper_bound = static_cast&lt;float&gt;(height - 1);
+
+  // Get dimension matrix
+  /*
+      l/2  l/2  -l/2  -l/2  l/2  l/2  -l/2  -l/2
+  D =  0    0     0     0    -h   -h    -h    -h
+      w/2  -w/2 -w/2   w/2  w/2  -w/2 -w/2  -w/2
+  */
+  GenCorners(h, w, l, x_corners, y_corners, z_corners);
+  while (!stop) {
+    // Back project 3D center from image x and depth z_ref to camera center_temp
+    common::IBackprojectCanonical(x, k_mat, z_ref, center_temp);
+    // From center to location
+    center_temp[1] += hwl[0] / 2;
+    float x_min = std::numeric_limits&lt;float&gt;::max();
+    float x_max = -std::numeric_limits&lt;float&gt;::max();
+    float y_min = std::numeric_limits&lt;float&gt;::max();
+    float y_max = -std::numeric_limits&lt;float&gt;::max();
+    float x_images[3] = {0};
+
+    for (int i = 0; i &lt; 8; ++i) {
+      // Bbox from x_images
+      float x_box[3] = {x_corners[i], y_corners[i], z_corners[i]};
+      common::IProjectThroughKRt(k_mat, rot_y, center_temp, x_box, x_images);
+      x_images[0] *= common::IRec(x_images[2]);
+      x_images[1] *= common::IRec(x_images[2]);
+      x_min = std::min(x_min, x_images[0]);
+      x_max = std::max(x_max, x_images[0]);
+      y_min = std::min(y_min, x_images[1]);
+      y_max = std::max(y_max, x_images[1]);
+    }
+
+    // Clamp bounding box from 0~boundary
+    x_min = std::min(std::max(x_min, 0.0f), x_upper_bound);
+    x_max = std::min(std::max(x_max, 0.0f), x_upper_bound);
+    y_min = std::min(std::max(y_min, 0.0f), y_upper_bound);
+    y_max = std::min(std::max(y_max, 0.0f), y_upper_bound);
+
+    // Calculate 2D center point and get cost
+    // cost = (center_gt - center_cal)**2
+    float center_cur[2] = {(x_min + x_max) / 2, (y_min + y_max) / 2};
+    float cost_cur = common::ISqrt(
+                     common::ISqr(center_cur[0] - center_2d_target[0]) +
+                     common::ISqr(center_cur[1] - center_2d_target[1]));
+
+    // Stop or continue
+    if (cost_cur &gt;= cost_pre) {
+      stop = true;
+    } else {
+      memcpy(center, center_temp, sizeof(float) * 3);
+      cost_delta = (cost_pre - cost_cur) / cost_pre;
+      cost_pre = cost_cur;
+      // Update 2D center point by descent method
+      x[0] += (center_2d_target[0] - center_cur[0]) * LEARNING_RATE;
+      x[1] += (center_2d_target[1] - center_cur[1]) * LEARNING_RATE;
+      ++iter;
+      // Termination condition
+      stop = iter &gt;= MAX_ITERATION || cost_delta &lt; EPS_COST_DELTA ||
+             cost_pre &lt; K_MIN_COST;
+    }
+  }
+}
+
 std::string SingleStageObstacleTransformer::Name() const {
   return "SingleStageObstacleTransformer";
 }
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\obstacle\transformer\singlestage\singlestage_obstacle_transformer.h" new_path="modules\perception\camera\lib\obstacle\transformer\singlestage\singlestage_obstacle_transformer.h" added_lines="22" deleted_lines="1">
				<diff>@@ -21,8 +21,9 @@
 #include &lt;utility&gt;
 #include &lt;vector&gt;
 
-#include "modules/perception/camera/lib/interface/base_obstacle_transformer.h"
 #include "modules/perception/camera/common/object_template_manager.h"
+#include "modules/perception/camera/common/twod_threed_util.h"
+#include "modules/perception/camera/lib/interface/base_obstacle_transformer.h"
 #include "modules/perception/camera/lib/obstacle/transformer/singlestage/proto/singlestage.pb.h"
 #include "modules/perception/common/i_lib/core/i_blas.h"
 
@@ -30,6 +31,18 @@ namespace apollo {
 namespace perception {
 namespace camera {
 
+// hyper parameters
+struct TransformerParams {
+  TransformerParams() { set_default(); }
+
+  void set_default();
+
+  int max_nr_iter;
+  float learning_rate;
+  float k_min_cost;
+  float eps_cost;
+};
+
 class SingleStageObstacleTransformer : public BaseObstacleTransformer {
  public:
   SingleStageObstacleTransformer() : BaseObstacleTransformer() {}
@@ -51,11 +64,19 @@ class SingleStageObstacleTransformer : public BaseObstacleTransformer {
   void FillResults(float object_center[3], float dimension_hwl[3],
                    float rotation_y, Eigen::Affine3d camera2world_pose,
                    float theta_ray, base::ObjectPtr obj);
+  float CenterPointFromBbox(const float *bbox, const float *hwl,
+                            float ry, float *center, float *center2d,
+                            const float* k_mat, int height, int width);
+  void ConstraintCenterPoint(const float *bbox, const float &amp;z_ref,
+                             const float &amp;ry, const float *hwl,
+                             const float* k_mat, float *center,
+                             float *x, int height, int width);
 
  private:
   singlestage::SinglestageParam singlestage_param_;
   int image_width_ = 0;
   int image_height_ = 0;
+  TransformerParams params_;
 
  protected:
   ObjectTemplateManager *object_template_manager_ = nullptr;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d0c93231d966ff6df7dedd88e892e08364335d35" author="lilu15">
		<msg>Revert "Planning: fix collision check in grid_search (#11524)"

This reverts commit 5ddf4e3749170d7aa44ee7767d48b453b8321eea.</msg>
		<modified_files>
			<file old_path="modules\planning\open_space\coarse_trajectory_generator\grid_search.cc" new_path="modules\planning\open_space\coarse_trajectory_generator\grid_search.cc" added_lines="14" deleted_lines="21">
				<diff>@@ -47,7 +47,8 @@ bool GridSearch::CheckConstraints(std::shared_ptr&lt;Node2d&gt; node) {
   for (const auto&amp; obstacle_linesegments : obstacles_linesegments_vec_) {
     for (const common::math::LineSegment2d&amp; linesegment :
          obstacle_linesegments) {
-      if (linesegment.DistanceTo({node-&gt;GetX(), node-&gt;GetY()}) &lt; node_radius_) {
+      if (linesegment.DistanceTo({node-&gt;GetGridX(), node-&gt;GetGridY()}) &lt;
+          node_radius_) {
         return false;
       }
     }
@@ -57,42 +58,34 @@ bool GridSearch::CheckConstraints(std::shared_ptr&lt;Node2d&gt; node) {
 
 std::vector&lt;std::shared_ptr&lt;Node2d&gt;&gt; GridSearch::GenerateNextNodes(
     std::shared_ptr&lt;Node2d&gt; current_node) {
-  double current_node_x = current_node-&gt;GetX();
-  double current_node_y = current_node-&gt;GetY();
+  double current_node_x = current_node-&gt;GetGridX();
+  double current_node_y = current_node-&gt;GetGridY();
   double current_node_path_cost = current_node-&gt;GetPathCost();
   double diagonal_distance = std::sqrt(2.0);
   std::vector&lt;std::shared_ptr&lt;Node2d&gt;&gt; next_nodes;
-  std::shared_ptr&lt;Node2d&gt; up = std::make_shared&lt;Node2d&gt;(
-      current_node_x, current_node_y + xy_grid_resolution_, xy_grid_resolution_,
-      XYbounds_);
+  std::shared_ptr&lt;Node2d&gt; up =
+      std::make_shared&lt;Node2d&gt;(current_node_x, current_node_y + 1.0, XYbounds_);
   up-&gt;SetPathCost(current_node_path_cost + 1.0);
   std::shared_ptr&lt;Node2d&gt; up_right = std::make_shared&lt;Node2d&gt;(
-      current_node_x + xy_grid_resolution_,
-      current_node_y + xy_grid_resolution_, xy_grid_resolution_, XYbounds_);
+      current_node_x + 1.0, current_node_y + 1.0, XYbounds_);
   up_right-&gt;SetPathCost(current_node_path_cost + diagonal_distance);
   std::shared_ptr&lt;Node2d&gt; right =
-      std::make_shared&lt;Node2d&gt;(current_node_x + xy_grid_resolution_,
-                               current_node_y, xy_grid_resolution_, XYbounds_);
+      std::make_shared&lt;Node2d&gt;(current_node_x + 1.0, current_node_y, XYbounds_);
   right-&gt;SetPathCost(current_node_path_cost + 1.0);
   std::shared_ptr&lt;Node2d&gt; down_right = std::make_shared&lt;Node2d&gt;(
-      current_node_x + xy_grid_resolution_,
-      current_node_y - xy_grid_resolution_, xy_grid_resolution_, XYbounds_);
+      current_node_x + 1.0, current_node_y - 1.0, XYbounds_);
   down_right-&gt;SetPathCost(current_node_path_cost + diagonal_distance);
-  std::shared_ptr&lt;Node2d&gt; down = std::make_shared&lt;Node2d&gt;(
-      current_node_x, current_node_y - xy_grid_resolution_, xy_grid_resolution_,
-      XYbounds_);
+  std::shared_ptr&lt;Node2d&gt; down =
+      std::make_shared&lt;Node2d&gt;(current_node_x, current_node_y - 1.0, XYbounds_);
   down-&gt;SetPathCost(current_node_path_cost + 1.0);
   std::shared_ptr&lt;Node2d&gt; down_left = std::make_shared&lt;Node2d&gt;(
-      current_node_x - xy_grid_resolution_,
-      current_node_y - xy_grid_resolution_, xy_grid_resolution_, XYbounds_);
+      current_node_x - 1.0, current_node_y - 1.0, XYbounds_);
   down_left-&gt;SetPathCost(current_node_path_cost + diagonal_distance);
   std::shared_ptr&lt;Node2d&gt; left =
-      std::make_shared&lt;Node2d&gt;(current_node_x - xy_grid_resolution_,
-                               current_node_y, xy_grid_resolution_, XYbounds_);
+      std::make_shared&lt;Node2d&gt;(current_node_x - 1.0, current_node_y, XYbounds_);
   left-&gt;SetPathCost(current_node_path_cost + 1.0);
   std::shared_ptr&lt;Node2d&gt; up_left = std::make_shared&lt;Node2d&gt;(
-      current_node_x - xy_grid_resolution_,
-      current_node_y + xy_grid_resolution_, xy_grid_resolution_, XYbounds_);
+      current_node_x - 1.0, current_node_y + 1.0, XYbounds_);
   up_left-&gt;SetPathCost(current_node_path_cost + diagonal_distance);
 
   next_nodes.emplace_back(up);
</diff>
			</file>
			<file old_path="modules\planning\open_space\coarse_trajectory_generator\grid_search.h" new_path="modules\planning\open_space\coarse_trajectory_generator\grid_search.h" added_lines="6" deleted_lines="6">
				<diff>@@ -41,12 +41,16 @@ class Node2d {
   Node2d(const double x, const double y, const double xy_resolution,
          const std::vector&lt;double&gt;&amp; XYbounds) {
     // XYbounds with xmin, xmax, ymin, ymax
-    x_ = x;
-    y_ = y;
     grid_x_ = static_cast&lt;int&gt;((x - XYbounds[0]) / xy_resolution);
     grid_y_ = static_cast&lt;int&gt;((y - XYbounds[2]) / xy_resolution);
     index_ = ComputeStringIndex(grid_x_, grid_y_);
   }
+  Node2d(const int grid_x, const int grid_y,
+         const std::vector&lt;double&gt;&amp; XYbounds) {
+    grid_x_ = grid_x;
+    grid_y_ = grid_y;
+    index_ = ComputeStringIndex(grid_x_, grid_y_);
+  }
   void SetPathCost(const double path_cost) {
     path_cost_ = path_cost;
     cost_ = path_cost_ + heuristic_;
@@ -57,8 +61,6 @@ class Node2d {
   }
   void SetCost(const double cost) { cost_ = cost; }
   void SetPreNode(std::shared_ptr&lt;Node2d&gt; pre_node) { pre_node_ = pre_node; }
-  double GetX() const { return x_; }
-  double GetY() const { return y_; }
   double GetGridX() const { return grid_x_; }
   double GetGridY() const { return grid_y_; }
   double GetPathCost() const { return path_cost_; }
@@ -84,8 +86,6 @@ class Node2d {
   }
 
  private:
-  double x_ = 0.0;
-  double y_ = 0.0;
   int grid_x_ = 0;
   int grid_y_ = 0;
   double path_cost_ = 0.0;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="cfe9b3c5800592284cfb335a32473fbe3300ef09" author="storypku">
		<msg>Cyber: bugfix for SharedLibrary's dlopen operations

Or else, running "mainboard -d modules/planning/dag/planning.dag"
will complains:

INTEL MKL ERROR: /usr/local/lib/libmkl_avx2.so: undefined symbol: mkl_sparse_optimize_bsr_trsm_i8.
Intel MKL FATAL ERROR: Cannot load libmkl_avx2.so or libmkl_def.so.</msg>
		<modified_files>
			<file old_path="cyber\class_loader\shared_library\shared_library.cc" new_path="cyber\class_loader\shared_library\shared_library.cc" added_lines="4" deleted_lines="2">
				<diff>@@ -29,6 +29,8 @@ namespace apollo {
 namespace cyber {
 namespace class_loader {
 
+std::mutex SharedLibrary::mutex_;
+
 SharedLibrary::SharedLibrary(const std::string&amp; path) { Load(path, 0); }
 
 SharedLibrary::SharedLibrary(const std::string&amp; path, int flags) {
@@ -43,9 +45,9 @@ void SharedLibrary::Load(const std::string&amp; path, int flags) {
 
   int real_flag = RTLD_LAZY;
   if (flags &amp; SHLIB_LOCAL) {
-    real_flag |= SHLIB_LOCAL;
+    real_flag |= RTLD_LOCAL;
   } else {
-    real_flag |= SHLIB_GLOBAL;
+    real_flag |= RTLD_GLOBAL;
   }
   handle_ = dlopen(path.c_str(), real_flag);
   if (!handle_) {
</diff>
			</file>
			<file old_path="cyber\class_loader\shared_library\shared_library.h" new_path="cyber\class_loader\shared_library\shared_library.h" added_lines="1" deleted_lines="1">
				<diff>@@ -114,7 +114,7 @@ class SharedLibrary {
  private:
   void* handle_ = nullptr;
   std::string path_;
-  std::mutex mutex_;
+  static std::mutex mutex_;
 };
 
 }  // namespace class_loader
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="778724720d8153e5f48ef2dd5145f854f5c48bd9" author="storypku">
		<msg>Build: reorg testdata for vehicle_model</msg>
		<modified_files>
			<file old_path="modules\common\vehicle_model\vehicle_model_test.cc" new_path="modules\common\vehicle_model\vehicle_model_test.cc" added_lines="7" deleted_lines="5">
				<diff>@@ -16,9 +16,11 @@
 
 #include "modules/common/vehicle_model/vehicle_model.h"
 
-#include "cyber/common/file.h"
 #include "gtest/gtest.h"
+
 #include "modules/common/vehicle_state/proto/vehicle_state.pb.h"
+
+#include "cyber/common/file.h"
 #include "modules/common/vehicle_state/vehicle_state_provider.h"
 
 namespace apollo {
@@ -31,18 +33,18 @@ class VehicleModelTest : public ::testing::Test {
  public:
   virtual void SetUp() {
     std::string localization_pre_file =
-        "modules/common/testdata/localization_pre.pb.txt";
+        "modules/common/vehicle_model/testdata/localization_pre.pb.txt";
     ACHECK(cyber::common::GetProtoFromFile(localization_pre_file,
                                            &amp;localization_pre_));
     std::string localization_post_file =
-        "modules/common/testdata/localization_post.pb.txt";
+        "modules/common/vehicle_model/testdata/localization_post.pb.txt";
     ACHECK(cyber::common::GetProtoFromFile(localization_post_file,
                                            &amp;localization_post_));
     const std::string chassis_pre_file =
-        "modules/common/testdata/chassis_pre.pb.txt";
+        "modules/common/vehicle_model/testdata/chassis_pre.pb.txt";
     ACHECK(cyber::common::GetProtoFromFile(chassis_pre_file, &amp;chassis_pre_));
     const std::string chassis_post_file =
-        "modules/common/testdata/chassis_post.pb.txt";
+        "modules/common/vehicle_model/testdata/chassis_post.pb.txt";
     ACHECK(cyber::common::GetProtoFromFile(chassis_post_file, &amp;chassis_post_));
   }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a1f216e7bbebf19d2c120422dd15b5ff97b5c3c2" author="storypku">
		<msg>Build: reorg data files for Routing</msg>
		<modified_files>
			<file old_path="modules\routing\tools\routing_tester.cc" new_path="modules\routing\tools\routing_tester\routing_tester.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -25,7 +25,7 @@ DEFINE_bool(enable_remove_lane_id, true,
             "True to remove lane id in routing request");
 
 DEFINE_string(routing_test_file,
-              "modules/routing/testdata/routing_tester/routing_test.pb.txt",
+              "modules/routing/tools/routing_tester/routing_test.pb.txt",
               "Used for sending routing request to routing node.");
 
 using apollo::cyber::Rate;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="2e5f30ed7618be947017e54f2a494a64342c828a" author="panxuechao">
		<msg>socket can: update CAN_ID filter in 0x000-0x7FF for Linux 4.4.39+</msg>
		<modified_files>
			<file old_path="modules\drivers\canbus\can_client\socket\socket_can_client_raw.cc" new_path="modules\drivers\canbus\can_client\socket\socket_can_client_raw.cc" added_lines="6" deleted_lines="5">
				<diff>@@ -29,6 +29,8 @@ namespace drivers {
 namespace canbus {
 namespace can {
 
+#define CAN_ID_MASK 0x1FFFF800U  // can_filter mask
+
 using apollo::common::ErrorCode;
 
 bool SocketCanClientRaw::Init(const CANCardParameter &amp;parameter) {
@@ -79,11 +81,10 @@ ErrorCode SocketCanClientRaw::Start() {
 
   // 1. for non virtual busses, set receive message_id filter, ie white list
   if (interface_ != CANCardParameter::VIRTUAL) {
-    struct can_filter filter[2048];
-    for (int i = 0; i &lt; 2048; ++i) {
-      filter[i].can_id = 0x000 + i;
-      filter[i].can_mask = CAN_SFF_MASK;
-    }
+    // set a scope for each EID instead of a single filter rule for each EID
+    struct can_filter filter[1];
+    filter[0].can_id = 0x000;
+    filter[0].can_mask = CAN_ID_MASK;
 
     ret = setsockopt(dev_handler_, SOL_CAN_RAW, CAN_RAW_FILTER, &amp;filter,
                      sizeof(filter));
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3a979b46ee9341c49b3571179d30c93f6ebe1dfd" author="panxuechao">
		<msg>socket can: update CAN_ID filter in 0x000-0x7FF for Linux 4.4.39+ (#13465)</msg>
		<modified_files>
			<file old_path="modules\drivers\canbus\can_client\socket\socket_can_client_raw.cc" new_path="modules\drivers\canbus\can_client\socket\socket_can_client_raw.cc" added_lines="6" deleted_lines="5">
				<diff>@@ -29,6 +29,8 @@ namespace drivers {
 namespace canbus {
 namespace can {
 
+#define CAN_ID_MASK 0x1FFFF800U  // can_filter mask
+
 using apollo::common::ErrorCode;
 
 bool SocketCanClientRaw::Init(const CANCardParameter &amp;parameter) {
@@ -79,11 +81,10 @@ ErrorCode SocketCanClientRaw::Start() {
 
   // 1. for non virtual busses, set receive message_id filter, ie white list
   if (interface_ != CANCardParameter::VIRTUAL) {
-    struct can_filter filter[2048];
-    for (int i = 0; i &lt; 2048; ++i) {
-      filter[i].can_id = 0x000 + i;
-      filter[i].can_mask = CAN_SFF_MASK;
-    }
+    // set a scope for each EID instead of a single filter rule for each EID
+    struct can_filter filter[1];
+    filter[0].can_id = 0x000;
+    filter[0].can_mask = CAN_ID_MASK;
 
     ret = setsockopt(dev_handler_, SOL_CAN_RAW, CAN_RAW_FILTER, &amp;filter,
                      sizeof(filter));
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a811a26d3bd2db0739d30b9aad03068619ddc917" author="changsh726">
		<msg>HMI: fix recorder bug</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\hmi\hmi_worker.cc" new_path="modules\dreamview\backend\hmi\hmi_worker.cc" added_lines="8" deleted_lines="6">
				<diff>@@ -619,14 +619,16 @@ void HMIWorker::StartModule(const std::string&amp; module) const {
 
   if (module == "Recorder") {
     auto* monitors = FuelMonitorManager::Instance()-&gt;GetCurrentMonitors();
-    auto iter = monitors-&gt;find(FLAGS_data_collection_monitor_name);
-    if (iter != monitors-&gt;end()) {
-      auto* data_collection_monitor = iter-&gt;second.get();
-      if (data_collection_monitor-&gt;IsEnabled() &amp;&amp; record_count_ == 0) {
-        data_collection_monitor-&gt;Restart();
+    if (monitors != nullptr) {
+      auto iter = monitors-&gt;find(FLAGS_data_collection_monitor_name);
+      if (iter != monitors-&gt;end()) {
+        auto* data_collection_monitor = iter-&gt;second.get();
+        if (data_collection_monitor-&gt;IsEnabled() &amp;&amp; record_count_ == 0) {
+          data_collection_monitor-&gt;Restart();
+        }
       }
+      ++record_count_;
     }
-    ++record_count_;
   }
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1127ead637acad11bd3d72a32763865fc8ec4034" author="Jiahao Chen (Jerold)">
		<msg>Perception: temporarily inference serially for multi traffic lights (#13477)</msg>
		<modified_files>
			<file old_path="modules\perception\camera\lib\traffic_light\detector\detection\detection.cc" new_path="modules\perception\camera\lib\traffic_light\detector\detection\detection.cc" added_lines="35" deleted_lines="37">
				<diff>@@ -154,42 +154,39 @@ bool TrafficLightDetection::Init(
   return true;
 }
 
+// TODO(chenjiahao): temporarily do inference serially for multiple
+//  traffic lights, because so far batch size can only be 1
 bool TrafficLightDetection::Inference(
     std::vector&lt;base::TrafficLightPtr&gt; *lights, DataProvider *data_provider) {
   if (cudaSetDevice(gpu_id_) != cudaSuccess) {
     AERROR &lt;&lt; "Failed to set device to " &lt;&lt; gpu_id_;
     return false;
   }
-  crop_box_list_.clear();
-  resize_scale_list_.clear();
-  int img_width = data_provider-&gt;src_width();
-  int img_height = data_provider-&gt;src_height();
-  int resize_index = 0;
   auto batch_num = lights-&gt;size();
-  auto input_img_blob = rt_net_-&gt;get_blob(net_inputs_[0]);
-  auto input_param = rt_net_-&gt;get_blob(net_inputs_[1]);
-
-  input_img_blob-&gt;Reshape(static_cast&lt;int&gt;(batch_num),
-                          static_cast&lt;int&gt;(detection_param_.min_crop_size()),
-                          static_cast&lt;int&gt;(detection_param_.min_crop_size()),
-                          3);
-  param_blob_-&gt;Reshape(static_cast&lt;int&gt;(batch_num), 6, 1, 1);
-  float *param_data = param_blob_-&gt;mutable_cpu_data();
   for (size_t i = 0; i &lt; batch_num; ++i) {
-    auto offset = i * param_blob_length_;
-    param_data[offset + 0] =
-        static_cast&lt;float&gt;(detection_param_.min_crop_size());
-    param_data[offset + 1] =
-        static_cast&lt;float&gt;(detection_param_.min_crop_size());
-    param_data[offset + 2] = 1;
-    param_data[offset + 3] = 1;
-    param_data[offset + 4] = 0;
-    param_data[offset + 5] = 0;
-  }
-
-  AINFO &lt;&lt; "reshape inputblob " &lt;&lt; input_img_blob-&gt;shape_string();
+    crop_box_list_.clear();
+    resize_scale_list_.clear();
+    int img_width = data_provider-&gt;src_width();
+    int img_height = data_provider-&gt;src_height();
+    int resize_index = 0;
+    auto input_img_blob = rt_net_-&gt;get_blob(net_inputs_[0]);
+    auto input_param = rt_net_-&gt;get_blob(net_inputs_[1]);
+
+    input_img_blob-&gt;Reshape(1,
+                            static_cast&lt;int&gt;(detection_param_.min_crop_size()),
+                            static_cast&lt;int&gt;(detection_param_.min_crop_size()),
+                            3);
+    param_blob_-&gt;Reshape(1, 6, 1, 1);
+    float *param_data = param_blob_-&gt;mutable_cpu_data();
+    param_data[0] = static_cast&lt;float&gt;(detection_param_.min_crop_size());
+    param_data[1] = static_cast&lt;float&gt;(detection_param_.min_crop_size());
+    param_data[2] = 1;
+    param_data[3] = 1;
+    param_data[4] = 0;
+    param_data[5] = 0;
+
+    AINFO &lt;&lt; "reshape inputblob " &lt;&lt; input_img_blob-&gt;shape_string();
 
-  for (size_t i = 0; i &lt; batch_num; ++i) {
     base::TrafficLightPtr light = lights-&gt;at(i);
     base::RectI cbox;
     crop_-&gt;getCropBox(img_width, img_height, light, &amp;cbox);
@@ -209,23 +206,24 @@ bool TrafficLightDetection::Inference(
 
       float resize_scale =
           static_cast&lt;float&gt;(detection_param_.min_crop_size()) /
-          static_cast&lt;float&gt;(std::min(cbox.width, cbox.height));
+              static_cast&lt;float&gt;(std::min(cbox.width, cbox.height));
       resize_scale_list_.push_back(resize_scale);
 
       inference::ResizeGPU(*image_, input_img_blob, img_width, resize_index,
                            mean_[0], mean_[1], mean_[2], true, 1.0);
       resize_index++;
     }
+
+    // inference
+    cudaDeviceSynchronize();
+    rt_net_-&gt;Infer();
+    cudaDeviceSynchronize();
+    AINFO &lt;&lt; "rt_net run success";
+
+    // dump the output
+    SelectOutputBoxes(crop_box_list_, resize_scale_list_, resize_scale_list_,
+                      &amp;detected_bboxes_);
   }
-  // _detection
-  cudaDeviceSynchronize();
-  rt_net_-&gt;Infer();
-  cudaDeviceSynchronize();
-  AINFO &lt;&lt; "rt_net run success";
-
-  // dump the output
-  SelectOutputBoxes(crop_box_list_, resize_scale_list_, resize_scale_list_,
-                    &amp;detected_bboxes_);
 
   ApplyNMS(&amp;detected_bboxes_);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="142ad4b349252cec05a3bf5249dae3fcfeb3a7df" author="">
		<msg>Dreamview:modify gflag type for loop routing on master and check the threshold judge logic (#13471)</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\common\dreamview_gflags.cc" new_path="modules\dreamview\backend\common\dreamview_gflags.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -93,7 +93,7 @@ DEFINE_string(default_data_collection_config_path,
               "/apollo/modules/dreamview/conf/data_collection_table.pb.txt",
               "Data collection table config path.");
 
-DEFINE_int32(loop_routing_end_to_start_distance_threshold, 10,
+DEFINE_double(loop_routing_end_to_start_distance_threshold, 10.0,
              "Loop routing distance threshold: start to end");
 
 DEFINE_string(default_preprocess_config_path,
</diff>
			</file>
			<file old_path="modules\dreamview\backend\common\dreamview_gflags.h" new_path="modules\dreamview\backend\common\dreamview_gflags.h" added_lines="1" deleted_lines="1">
				<diff>@@ -60,7 +60,7 @@ DECLARE_int32(monitor_msg_pending_queue_size);
 
 DECLARE_string(default_data_collection_config_path);
 
-DECLARE_int32(loop_routing_end_to_start_distance_threshold);
+DECLARE_double(loop_routing_end_to_start_distance_threshold);
 
 DECLARE_string(default_preprocess_config_path);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="54d6303641814ef91c2534886c61ea88b8ac812d" author="changsh726">
		<msg>HMI: fix recorder bug</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\hmi\hmi_worker.cc" new_path="modules\dreamview\backend\hmi\hmi_worker.cc" added_lines="8" deleted_lines="6">
				<diff>@@ -619,14 +619,16 @@ void HMIWorker::StartModule(const std::string&amp; module) const {
 
   if (module == "Recorder") {
     auto* monitors = FuelMonitorManager::Instance()-&gt;GetCurrentMonitors();
-    auto iter = monitors-&gt;find(FLAGS_data_collection_monitor_name);
-    if (iter != monitors-&gt;end()) {
-      auto* data_collection_monitor = iter-&gt;second.get();
-      if (data_collection_monitor-&gt;IsEnabled() &amp;&amp; record_count_ == 0) {
-        data_collection_monitor-&gt;Restart();
+    if (monitors != nullptr) {
+      auto iter = monitors-&gt;find(FLAGS_data_collection_monitor_name);
+      if (iter != monitors-&gt;end()) {
+        auto* data_collection_monitor = iter-&gt;second.get();
+        if (data_collection_monitor-&gt;IsEnabled() &amp;&amp; record_count_ == 0) {
+          data_collection_monitor-&gt;Restart();
+        }
       }
+      ++record_count_;
     }
-    ++record_count_;
   }
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9a6c97c36150d767021b625454a909301330309b" author="lfcarol">
		<msg>Dkit: Update perception configurations cherry pick from r5.5.0 (#13449)</msg>
		<modified_files>
			<file old_path="modules\calibration\data\dev_kit\localization_conf\localization.conf" new_path="modules\calibration\data\dev_kit\localization_conf\localization.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -132,7 +132,7 @@
 # The lidar extrinsics file
 # type: string
 # default: /apollo/modules/localization/msf/params/velodyne_params/velodyne128_novatel_extrinsics.yaml
---lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/velodyne16_novatel_extrinsics.yaml
+--lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/lidar16_novatel_extrinsics.yaml
 
 # imu coordinate, true-&gt;flu, false-&gt;rfu
 # type: bool
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_ne-b\lidar_conf\surestar.conf" new_path="modules\calibration\data\dev_kit_advanced_ne-b\lidar_conf\surestar.conf" added_lines="1" deleted_lines="1">
				<diff>@@ -1,4 +1,4 @@
-frame_id: "velodyne128"
+frame_id: "lidar16"
 scan_channel:"/apollo/sensor/lidar16/Scan"
 rpm: 600.0
 model: VLP16
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_ne-b\localization_conf\localization.conf" new_path="modules\calibration\data\dev_kit_advanced_ne-b\localization_conf\localization.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -132,7 +132,7 @@
 # The lidar extrinsics file
 # type: string
 # default: /apollo/modules/localization/msf/params/velodyne_params/velodyne128_novatel_extrinsics.yaml
---lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/velodyne16_novatel_extrinsics.yaml
+--lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/lidar16_novatel_extrinsics.yaml
 
 # imu coordinate, true-&gt;flu, false-&gt;rfu
 # type: bool
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_ne-s\localization_conf\localization.conf" new_path="modules\calibration\data\dev_kit_advanced_ne-s\localization_conf\localization.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -132,7 +132,7 @@
 # The lidar extrinsics file
 # type: string
 # default: /apollo/modules/localization/msf/params/velodyne_params/velodyne128_novatel_extrinsics.yaml
---lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/velodyne16_novatel_extrinsics.yaml
+--lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/lidar16_novatel_extrinsics.yaml
 
 # imu coordinate, true-&gt;flu, false-&gt;rfu
 # type: bool
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_sne-r\localization_conf\localization.conf" new_path="modules\calibration\data\dev_kit_advanced_sne-r\localization_conf\localization.conf" added_lines="2" deleted_lines="1">
				<diff>@@ -131,8 +131,8 @@
 
 # The lidar extrinsics file
 # type: string
-# default: /apollo/modules/localization/msf/params/velodyne_params/velodyne16_novatel_extrinsics.yaml
---lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/velodyne16_novatel_extrinsics.yaml
+# default: /apollo/modules/localization/msf/params/velodyne_params/lidar16_novatel_extrinsics.yaml
+--lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/lidar16_novatel_extrinsics.yaml
 
 # imu coordinate, true-&gt;flu, false-&gt;rfu
 # type: bool
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_standard\localization_conf\localization.conf" new_path="modules\calibration\data\dev_kit_standard\localization_conf\localization.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -132,7 +132,7 @@
 # The lidar extrinsics file
 # type: string
 # default: /apollo/modules/localization/msf/params/velodyne_params/velodyne128_novatel_extrinsics.yaml
---lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/velodyne16_novatel_extrinsics.yaml
+--lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/lidar16_novatel_extrinsics.yaml
 
 # imu coordinate, true-&gt;flu, false-&gt;rfu
 # type: bool
</diff>
			</file>
			<file old_path="modules\common\adapters\adapter_gflags.cc" new_path="modules\common\adapters\adapter_gflags.cc" added_lines="4" deleted_lines="0">
				<diff>@@ -258,3 +258,7 @@ DEFINE_string(latency_recording_topic, "/apollo/common/latency_records",
 DEFINE_string(latency_reporting_topic, "/apollo/common/latency_reports",
               "Latency reporting topic.");
 DEFINE_string(task_topic, "/apollo/task_manager", "task manager topic name");
+// value: velodyne128, velodyne64, velodyne16
+DEFINE_string(lidar_model_version, "",
+              "It determins which lidar model(16 ,64 or 128) to load, "
+              "if not to set, the model will be loaded by the sensor name.");
</diff>
			</file>
			<file old_path="modules\common\adapters\adapter_gflags.h" new_path="modules\common\adapters\adapter_gflags.h" added_lines="4" deleted_lines="0">
				<diff>@@ -137,3 +137,7 @@ DECLARE_string(recorder_status_topic);
 DECLARE_string(latency_recording_topic);
 // Latency reporting topic
 DECLARE_string(latency_reporting_topic);
+
+// It determins which lidar model(16 or 128) to load, if not to set,
+// the model will be loaded by the sensor name. Mainly for D-kit.
+DECLARE_string(lidar_model_version);
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\data_fusion\type_fusion\dst_type_fusion\dst_type_fusion.h" new_path="modules\perception\fusion\lib\data_fusion\type_fusion\dst_type_fusion\dst_type_fusion.h" added_lines="2" deleted_lines="2">
				<diff>@@ -75,13 +75,13 @@ struct DstTypeFusionOptions {
       {"camera_front_narrow", 150},
   };
   std::map&lt;std::string, double&gt; sensor_reliability_ = {
-      {"velodyne64", 0.5},          {"velodyne_64", 0.5},
+      {"velodyne16", 0.5}, {"velodyne64", 0.5}, {"velodyne_64", 0.5},
       {"velodyne128", 0.5},         {"camera_smartereye", 0.95},
       {"front_6mm", 0.95},          {"camera_front_obstacle", 0.95},
       {"camera_front_narrow", 0.5},
   };
   std::map&lt;std::string, double&gt; sensor_reliability_for_unknown_ = {
-      {"velodyne64", 0.5},          {"velodyne_64", 0.5},
+      {"velodyne16", 0.5}, {"velodyne64", 0.5}, {"velodyne_64", 0.5},
       {"velodyne128", 0.5},         {"camera_smartereye", 0.2},
       {"front_6mm", 0.2},           {"camera_front_obstacle", 0.2},
       {"camera_front_narrow", 0.2},
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.cc" new_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.cc" added_lines="9" deleted_lines="2">
				<diff>@@ -21,6 +21,7 @@
 
 #include "cyber/common/file.h"
 #include "cyber/common/log.h"
+#include "modules/common/adapters/adapter_gflags.h"
 #include "modules/perception/base/object_pool_types.h"
 #include "modules/perception/inference/inference_factory.h"
 #include "modules/perception/lib/config_manager/config_manager.h"
@@ -45,8 +46,14 @@ bool CNNSegmentation::Init(const SegmentationInitOptions&amp; options) {
   std::string proto_file;
   std::string weight_file;
   std::string engine_file;
-  sensor_name_ = options.sensor_name;
-  ACHECK(GetConfigs(&amp;param_file, &amp;proto_file, &amp;weight_file, &amp;engine_file));
+
+  if (!FLAGS_lidar_model_version.empty()) {
+    sensor_name_ = FLAGS_lidar_model_version;
+  } else {
+    sensor_name_ = options.sensor_name;
+  }
+
+  CHECK(GetConfigs(&amp;param_file, &amp;proto_file, &amp;weight_file, &amp;engine_file));
   AINFO &lt;&lt; "--    param_file: " &lt;&lt; param_file;
   AINFO &lt;&lt; "--    proto_file: " &lt;&lt; proto_file;
   AINFO &lt;&lt; "--    weight_file: " &lt;&lt; weight_file;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="13813a256e484ddad62fea627f127d2328d9e547" author="lfcarol">
		<msg>Dkit: Update perception configurations cherry pick from r5.5.0 (#13354)</msg>
		<modified_files>
			<file old_path="modules\calibration\data\dev_kit\localization_conf\localization.conf" new_path="modules\calibration\data\dev_kit\localization_conf\localization.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -132,7 +132,7 @@
 # The lidar extrinsics file
 # type: string
 # default: /apollo/modules/localization/msf/params/velodyne_params/velodyne128_novatel_extrinsics.yaml
---lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/velodyne16_novatel_extrinsics.yaml
+--lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/lidar16_novatel_extrinsics.yaml
 
 # imu coordinate, true-&gt;flu, false-&gt;rfu
 # type: bool
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_ne-b\lidar_conf\surestar.conf" new_path="modules\calibration\data\dev_kit_advanced_ne-b\lidar_conf\surestar.conf" added_lines="1" deleted_lines="1">
				<diff>@@ -1,4 +1,4 @@
-frame_id: "velodyne128"
+frame_id: "lidar16"
 scan_channel:"/apollo/sensor/lidar16/Scan"
 rpm: 600.0
 model: VLP16
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_ne-b\localization_conf\localization.conf" new_path="modules\calibration\data\dev_kit_advanced_ne-b\localization_conf\localization.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -132,7 +132,7 @@
 # The lidar extrinsics file
 # type: string
 # default: /apollo/modules/localization/msf/params/velodyne_params/velodyne128_novatel_extrinsics.yaml
---lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/velodyne16_novatel_extrinsics.yaml
+--lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/lidar16_novatel_extrinsics.yaml
 
 # imu coordinate, true-&gt;flu, false-&gt;rfu
 # type: bool
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_ne-s\localization_conf\localization.conf" new_path="modules\calibration\data\dev_kit_advanced_ne-s\localization_conf\localization.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -132,7 +132,7 @@
 # The lidar extrinsics file
 # type: string
 # default: /apollo/modules/localization/msf/params/velodyne_params/velodyne128_novatel_extrinsics.yaml
---lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/velodyne16_novatel_extrinsics.yaml
+--lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/lidar16_novatel_extrinsics.yaml
 
 # imu coordinate, true-&gt;flu, false-&gt;rfu
 # type: bool
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_sne-r\localization_conf\localization.conf" new_path="modules\calibration\data\dev_kit_advanced_sne-r\localization_conf\localization.conf" added_lines="2" deleted_lines="1">
				<diff>@@ -131,8 +131,8 @@
 
 # The lidar extrinsics file
 # type: string
-# default: /apollo/modules/localization/msf/params/velodyne_params/velodyne16_novatel_extrinsics.yaml
---lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/velodyne16_novatel_extrinsics.yaml
+# default: /apollo/modules/localization/msf/params/velodyne_params/lidar16_novatel_extrinsics.yaml
+--lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/lidar16_novatel_extrinsics.yaml
 
 # imu coordinate, true-&gt;flu, false-&gt;rfu
 # type: bool
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_standard\localization_conf\localization.conf" new_path="modules\calibration\data\dev_kit_standard\localization_conf\localization.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -132,7 +132,7 @@
 # The lidar extrinsics file
 # type: string
 # default: /apollo/modules/localization/msf/params/velodyne_params/velodyne128_novatel_extrinsics.yaml
---lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/velodyne16_novatel_extrinsics.yaml
+--lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/lidar16_novatel_extrinsics.yaml
 
 # imu coordinate, true-&gt;flu, false-&gt;rfu
 # type: bool
</diff>
			</file>
			<file old_path="modules\common\adapters\adapter_gflags.cc" new_path="modules\common\adapters\adapter_gflags.cc" added_lines="4" deleted_lines="0">
				<diff>@@ -258,3 +258,7 @@ DEFINE_string(latency_recording_topic, "/apollo/common/latency_records",
 DEFINE_string(latency_reporting_topic, "/apollo/common/latency_reports",
               "Latency reporting topic.");
 DEFINE_string(task_topic, "/apollo/task_manager", "task manager topic name");
+// value: velodyne128, velodyne64, velodyne16
+DEFINE_string(lidar_model_version, "",
+              "It determins which lidar model(16 ,64 or 128) to load, "
+              "if not to set, the model will be loaded by the sensor name.");
</diff>
			</file>
			<file old_path="modules\common\adapters\adapter_gflags.h" new_path="modules\common\adapters\adapter_gflags.h" added_lines="4" deleted_lines="0">
				<diff>@@ -137,3 +137,7 @@ DECLARE_string(recorder_status_topic);
 DECLARE_string(latency_recording_topic);
 // Latency reporting topic
 DECLARE_string(latency_reporting_topic);
+
+// It determins which lidar model(16 or 128) to load, if not to set,
+// the model will be loaded by the sensor name. Mainly for D-kit.
+DECLARE_string(lidar_model_version);
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\data_fusion\type_fusion\dst_type_fusion\dst_type_fusion.h" new_path="modules\perception\fusion\lib\data_fusion\type_fusion\dst_type_fusion\dst_type_fusion.h" added_lines="2" deleted_lines="2">
				<diff>@@ -75,13 +75,13 @@ struct DstTypeFusionOptions {
       {"camera_front_narrow", 150},
   };
   std::map&lt;std::string, double&gt; sensor_reliability_ = {
-      {"velodyne64", 0.5},          {"velodyne_64", 0.5},
+      {"velodyne16", 0.5}, {"velodyne64", 0.5}, {"velodyne_64", 0.5},
       {"velodyne128", 0.5},         {"camera_smartereye", 0.95},
       {"front_6mm", 0.95},          {"camera_front_obstacle", 0.95},
       {"camera_front_narrow", 0.5},
   };
   std::map&lt;std::string, double&gt; sensor_reliability_for_unknown_ = {
-      {"velodyne64", 0.5},          {"velodyne_64", 0.5},
+      {"velodyne16", 0.5}, {"velodyne64", 0.5}, {"velodyne_64", 0.5},
       {"velodyne128", 0.5},         {"camera_smartereye", 0.2},
       {"front_6mm", 0.2},           {"camera_front_obstacle", 0.2},
       {"camera_front_narrow", 0.2},
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.cc" new_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.cc" added_lines="9" deleted_lines="2">
				<diff>@@ -21,6 +21,7 @@
 
 #include "cyber/common/file.h"
 #include "cyber/common/log.h"
+#include "modules/common/adapters/adapter_gflags.h"
 #include "modules/perception/base/object_pool_types.h"
 #include "modules/perception/inference/inference_factory.h"
 #include "modules/perception/lib/config_manager/config_manager.h"
@@ -45,8 +46,14 @@ bool CNNSegmentation::Init(const SegmentationInitOptions&amp; options) {
   std::string proto_file;
   std::string weight_file;
   std::string engine_file;
-  sensor_name_ = options.sensor_name;
-  ACHECK(GetConfigs(&amp;param_file, &amp;proto_file, &amp;weight_file, &amp;engine_file));
+
+  if (!FLAGS_lidar_model_version.empty()) {
+    sensor_name_ = FLAGS_lidar_model_version;
+  } else {
+    sensor_name_ = options.sensor_name;
+  }
+
+  CHECK(GetConfigs(&amp;param_file, &amp;proto_file, &amp;weight_file, &amp;engine_file));
   AINFO &lt;&lt; "--    param_file: " &lt;&lt; param_file;
   AINFO &lt;&lt; "--    proto_file: " &lt;&lt; proto_file;
   AINFO &lt;&lt; "--    weight_file: " &lt;&lt; weight_file;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="bf389a34692c8391a311b47bc70ea1acb7364e52" author="storypku">
		<msg>Drivers: typofix issue#4276</msg>
		<modified_files>
			<file old_path="modules\drivers\lidar\velodyne\driver\driver.cc" new_path="modules\drivers\lidar\velodyne\driver\driver.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -115,7 +115,7 @@ bool VelodyneDriver::Poll(const std::shared_ptr&lt;VelodyneScan&gt;&amp; scan) {
 
   int poll_result = PollStandard(scan);
 
-  if (poll_result == SOCKET_TIMEOUT || poll_result == RECIEVE_FAIL) {
+  if (poll_result == SOCKET_TIMEOUT || poll_result == RECEIVE_FAIL) {
     return false;  // poll again
   }
 
</diff>
			</file>
			<file old_path="modules\drivers\lidar\velodyne\driver\driver64.cc" new_path="modules\drivers\lidar\velodyne\driver\driver64.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -60,7 +60,7 @@ bool Velodyne64Driver::Poll(const std::shared_ptr&lt;VelodyneScan&gt;&amp; scan) {
   int poll_result =
       config_.use_sensor_sync() ? PollStandardSync(scan) : PollStandard(scan);
 
-  if (poll_result == SOCKET_TIMEOUT || poll_result == RECIEVE_FAIL) {
+  if (poll_result == SOCKET_TIMEOUT || poll_result == RECEIVE_FAIL) {
     return false;  // poll again
   }
 
</diff>
			</file>
			<file old_path="modules\drivers\lidar\velodyne\driver\input.h" new_path="modules\drivers\lidar\velodyne\driver\input.h" added_lines="1" deleted_lines="1">
				<diff>@@ -33,7 +33,7 @@ static const size_t FIRING_DATA_PACKET_SIZE = 1206;
 static const size_t POSITIONING_DATA_PACKET_SIZE = 512;
 static const size_t ETHERNET_HEADER_SIZE = 42;
 static const int SOCKET_TIMEOUT = -2;
-static const int RECIEVE_FAIL = -3;
+static const int RECEIVE_FAIL = -3;
 
 struct NMEATime {
   uint16_t year;
</diff>
			</file>
			<file old_path="modules\drivers\lidar\velodyne\driver\socket_input.cc" new_path="modules\drivers\lidar\velodyne\driver\socket_input.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -106,7 +106,7 @@ int SocketInput::get_firing_data_packet(VelodynePacket *pkt) {
     if (nbytes &lt; 0) {
       if (errno != EWOULDBLOCK) {
         AERROR &lt;&lt; "recvfail from port " &lt;&lt; port_;
-        return RECIEVE_FAIL;
+        return RECEIVE_FAIL;
       }
     }
 
</diff>
			</file>
			<file old_path="modules\drivers\video\socket_input.cc" new_path="modules\drivers\video\socket_input.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -127,7 +127,7 @@ int SocketInput::GetFramePacket(std::shared_ptr&lt;CompressedImage&gt; h265Pb) {
     if (pdu_len &lt; 0) {
       if (errno != EWOULDBLOCK) {
         AERROR &lt;&lt; "Failed to receive package from port: " &lt;&lt; port_;
-        return RECIEVE_FAIL;
+        return RECEIVE_FAIL;
       }
     }
 
</diff>
			</file>
			<file old_path="modules\drivers\video\socket_input.h" new_path="modules\drivers\video\socket_input.h" added_lines="1" deleted_lines="1">
				<diff>@@ -31,7 +31,7 @@ namespace drivers {
 namespace video {
 
 static const int SOCKET_TIMEOUT = -2;
-static const int RECIEVE_FAIL = -3;
+static const int RECEIVE_FAIL = -3;
 static const int POLL_TIMEOUT = 1000;  // one second (in msec)
 static const size_t H265_FRAME_PACKAGE_SIZE = 4 * 1024 * 1024;
 static const size_t H265_PDU_SIZE = 1500;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="0ee43f0b3d28584f306677c4022cbc91f31736b8" author="abel">
		<msg>Update navi_planning.cc

ego_info should be updated before initframe</msg>
		<modified_files>
			<file old_path="modules\planning\navi_planning.cc" new_path="modules\planning\navi_planning.cc" added_lines="1" deleted_lines="2">
				<diff>@@ -199,6 +199,7 @@ void NaviPlanning::RunOnce(const LocalView&amp; local_view,
       FLAGS_trajectory_stitching_preserved_length, true,
       last_publishable_trajectory_.get(), &amp;replan_reason);
 
+  injector_-&gt;ego_info()-&gt;Update(stitching_trajectory.back(), vehicle_state);
   const uint32_t frame_num = static_cast&lt;uint32_t&gt;(seq_num_++);
   status = InitFrame(frame_num, stitching_trajectory.back(), vehicle_state);
 
@@ -213,8 +214,6 @@ void NaviPlanning::RunOnce(const LocalView&amp; local_view,
     return;
   }
 
-  injector_-&gt;ego_info()-&gt;Update(stitching_trajectory.back(), vehicle_state);
-
   if (FLAGS_enable_record_debug) {
     frame_-&gt;RecordInputDebug(trajectory_pb-&gt;mutable_debug());
   }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="62d7bfd40bf55c654d54d11d35ca06f184d689b0" author="abel">
		<msg>remove  lane_quality

There is no quality output in perception. it is 0 and can't generate relative map in default</msg>
		<modified_files>
			<file old_path="modules\map\relative_map\navigation_lane.cc" new_path="modules\map\relative_map\navigation_lane.cc" added_lines="3" deleted_lines="14">
				<diff>@@ -670,22 +670,11 @@ void NavigationLane::ConvertLaneMarkerToPath(
 
   double path_c0 = (left_lane.c0_position() + right_lane.c0_position()) / 2.0;
 
-  double left_quality = left_lane.quality() + 0.001;
-  double right_quality = right_lane.quality() + 0.001;
+  double path_c1 = left_lane.c1_heading_angle() + right_lane.c1_heading_angle();
 
-  double quality_divider = left_quality + right_quality;
+  double path_c2 = left_lane.c2_curvature() + right_lane.c2_curvature();
 
-  double path_c1 = (left_lane.c1_heading_angle() * left_quality +
-                    right_lane.c1_heading_angle() * right_quality) /
-                   quality_divider;
-
-  double path_c2 = (left_lane.c2_curvature() * left_quality +
-                    right_lane.c2_curvature() * right_quality) /
-                   quality_divider;
-
-  double path_c3 = (left_lane.c3_curvature_derivative() * left_quality +
-                    right_lane.c3_curvature_derivative() * right_quality) /
-                   quality_divider;
+  double path_c3 = left_lane.c3_curvature_derivative() + right_lane.c3_curvature_derivative();
 
   const double current_speed =
       vehicle_state_provider_-&gt;vehicle_state().linear_velocity();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="03058b7d2dd95a3944dbf863fbcd9425851b4520" author="abel">
		<msg>Update navigation_lane.cc

modify the bug</msg>
		<modified_files>
			<file old_path="modules\map\relative_map\navigation_lane.cc" new_path="modules\map\relative_map\navigation_lane.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -670,11 +670,11 @@ void NavigationLane::ConvertLaneMarkerToPath(
 
   double path_c0 = (left_lane.c0_position() + right_lane.c0_position()) / 2.0;
 
-  double path_c1 = left_lane.c1_heading_angle() + right_lane.c1_heading_angle();
+  double path_c1 = (left_lane.c1_heading_angle() + right_lane.c1_heading_angle())/2.0;
 
-  double path_c2 = left_lane.c2_curvature() + right_lane.c2_curvature();
+  double path_c2 = (left_lane.c2_curvature() + right_lane.c2_curvature())/2.0;
 
-  double path_c3 = left_lane.c3_curvature_derivative() + right_lane.c3_curvature_derivative();
+  double path_c3 = (left_lane.c3_curvature_derivative() + right_lane.c3_curvature_derivative())/2.0;
 
   const double current_speed =
       vehicle_state_provider_-&gt;vehicle_state().linear_velocity();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="285c392810219111bcb1f45fb0330f61830f3116" author="abel">
		<msg>Update navigation_lane.cc

clang format</msg>
		<modified_files>
			<file old_path="modules\map\relative_map\navigation_lane.cc" new_path="modules\map\relative_map\navigation_lane.cc" added_lines="7" deleted_lines="4">
				<diff>@@ -670,12 +670,15 @@ void NavigationLane::ConvertLaneMarkerToPath(
 
   double path_c0 = (left_lane.c0_position() + right_lane.c0_position()) / 2.0;
 
-  double path_c1 = (left_lane.c1_heading_angle() + right_lane.c1_heading_angle())/2.0;
+  double path_c1 =
+      (left_lane.c1_heading_angle() + right_lane.c1_heading_angle()) / 2.0;
 
-  double path_c2 = (left_lane.c2_curvature() + right_lane.c2_curvature())/2.0;
-
-  double path_c3 = (left_lane.c3_curvature_derivative() + right_lane.c3_curvature_derivative())/2.0;
+  double path_c2 = (left_lane.c2_curvature() + right_lane.c2_curvature()) / 2.0;
 
+  double path_c3 = (left_lane.c3_curvature_derivative() +
+                    right_lane.c3_curvature_derivative()) /
+                   2.0;
+  
   const double current_speed =
       vehicle_state_provider_-&gt;vehicle_state().linear_velocity();
   double path_range =
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="bfd188832095a25296125e1e41e4df5b3bacc632" author="abel">
		<msg>Update navigation_lane.cc

delete space</msg>
		<modified_files>
			<file old_path="modules\map\relative_map\navigation_lane.cc" new_path="modules\map\relative_map\navigation_lane.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -678,7 +678,7 @@ void NavigationLane::ConvertLaneMarkerToPath(
   double path_c3 = (left_lane.c3_curvature_derivative() +
                     right_lane.c3_curvature_derivative()) /
                    2.0;
-  
+
   const double current_speed =
       vehicle_state_provider_-&gt;vehicle_state().linear_velocity();
   double path_range =
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c506adedb968ecde7fee89e015c71ef2a5e95c7c" author="Jiaming Tao">
		<msg>map: fix a bug in GetLaneSegments() (#13500)

* map: fix a bug in GetLaneSegments()

* planning: fix a typo in function name</msg>
		<modified_files>
			<file old_path="modules\map\pnc_map\path.cc" new_path="modules\map\pnc_map\path.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -679,7 +679,7 @@ InterpolatedIndex Path::GetLaneIndexFromS(double s) const {
 std::vector&lt;hdmap::LaneSegment&gt; Path::GetLaneSegments(
     const double start_s, const double end_s) const {
   std::vector&lt;hdmap::LaneSegment&gt; lanes;
-  if (start_s + kMathEpsilon &lt; end_s) {
+  if (start_s + kMathEpsilon &gt; end_s) {
     return lanes;
   }
   auto start_index = GetLaneIndexFromS(start_s);
</diff>
			</file>
			<file old_path="modules\planning\scenarios\scenario_manager.cc" new_path="modules\planning\scenarios\scenario_manager.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -355,7 +355,7 @@ ScenarioConfig::ScenarioType ScenarioManager::SelectPadMsgScenario(
   return default_scenario_type_;
 }
 
-ScenarioConfig::ScenarioType ScenarioManager::SelectInterceptionScenario(
+ScenarioConfig::ScenarioType ScenarioManager::SelectIntersectionScenario(
     const Frame&amp; frame) {
   ScenarioConfig::ScenarioType scenario_type = default_scenario_type_;
 
@@ -890,7 +890,7 @@ ScenarioConfig::ScenarioType ScenarioManager::ScenarioDispatchNonLearning(
   ////////////////////////////////////////
   // intersection scenarios
   if (scenario_type == default_scenario_type_) {
-    scenario_type = SelectInterceptionScenario(frame);
+    scenario_type = SelectIntersectionScenario(frame);
   }
 
   ////////////////////////////////////////
</diff>
			</file>
			<file old_path="modules\planning\scenarios\scenario_manager.h" new_path="modules\planning\scenarios\scenario_manager.h" added_lines="1" deleted_lines="1">
				<diff>@@ -57,7 +57,7 @@ class ScenarioManager final {
 
   ScenarioConfig::ScenarioType SelectPadMsgScenario(const Frame&amp; frame);
 
-  ScenarioConfig::ScenarioType SelectInterceptionScenario(const Frame&amp; frame);
+  ScenarioConfig::ScenarioType SelectIntersectionScenario(const Frame&amp; frame);
 
   ScenarioConfig::ScenarioType SelectStopSignScenario(
       const Frame&amp; frame, const hdmap::PathOverlap&amp; stop_sign_overlap);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="2d99b192bed52704620515bb9a2aec6242f74f05" author="Chao Ma">
		<msg>canbus: modify the d-kit lite chassis engage advice (#13548)</msg>
		<modified_files>
			<file old_path="modules\canbus\vehicle\ch\ch_controller.cc" new_path="modules\canbus\vehicle\ch\ch_controller.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -236,16 +236,16 @@ Chassis ChController::chassis() {
   if (chassis_detail.has_surround()) {
     chassis_.mutable_surround()-&gt;CopyFrom(chassis_detail.surround());
   }
+
   // give engage_advice based on error_code and canbus feedback
-  if (!chassis_error_mask_ &amp;&amp; !chassis_.parking_brake() &amp;&amp;
-      (chassis_.throttle_percentage() == 0.0)) {
+  if (!chassis_error_mask_ &amp;&amp; (chassis_.throttle_percentage() == 0.0)) {
     chassis_.mutable_engage_advice()-&gt;set_advice(
         apollo::common::EngageAdvice::READY_TO_ENGAGE);
   } else {
     chassis_.mutable_engage_advice()-&gt;set_advice(
         apollo::common::EngageAdvice::DISALLOW_ENGAGE);
     chassis_.mutable_engage_advice()-&gt;set_reason(
-        "CANBUS not ready, firmware error or emergency button pressed!");
+        "CANBUS not ready, throttle percentage is not zero!");
   }
 
   // 27 battery soc
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="87a10c1b0eefb033cc4756a2cb4b4d2e41e4c277" author="Sergey Grebennikov">
		<msg>fix(canbus): Resolve the issue with creating ESD_CAN client</msg>
		<modified_files>
			<file old_path="modules\drivers\canbus\can_client\can_client_factory.cc" new_path="modules\drivers\canbus\can_client\can_client_factory.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -17,7 +17,7 @@
 #include "modules/drivers/canbus/can_client/can_client_factory.h"
 
 #include "modules/drivers/canbus/can_client/fake/fake_can_client.h"
-#if USE_ESD_CAN == true
+#if USE_ESD_CAN
 #include "modules/drivers/canbus/can_client/esd/esd_can_client.h"
 #endif
 
@@ -38,7 +38,7 @@ void CanClientFactory::RegisterCanClients() {
   AINFO &lt;&lt; "CanClientFactory::RegisterCanClients";
   Register(CANCardParameter::FAKE_CAN,
            []() -&gt; CanClient* { return new can::FakeCanClient(); });
-#if USE_ESD_CAN == true
+#if USE_ESD_CAN
   AINFO &lt;&lt; "register can: " &lt;&lt; CANCardParameter::ESD_CAN;
   Register(CANCardParameter::ESD_CAN,
            []() -&gt; CanClient* { return new can::EsdCanClient(); });
</diff>
			</file>
			<file old_path="modules\drivers\canbus\can_client\can_client_factory_test.cc" new_path="modules\drivers\canbus\can_client\can_client_factory_test.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -30,7 +30,7 @@ TEST(CanClientFactoryTest, CreateCanClient) {
 
   can_factory-&gt;RegisterCanClients();
 
-#if USE_ESD_CAN == true
+#if USE_ESD_CAN
   CANCardParameter can_card_parameter;
   can_card_parameter.set_brand(CANCardParameter::ESD_CAN);
   can_card_parameter.set_type(CANCardParameter::PCI_CARD);
</diff>
			</file>
			<file old_path="modules\monitor\hardware\esdcan_monitor.cc" new_path="modules\monitor\hardware\esdcan_monitor.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -18,7 +18,7 @@
 
 #include &lt;string&gt;
 
-#if USE_ESD_CAN == 1
+#if USE_ESD_CAN
 #include "esd_can/include/ntcan.h"
 #endif
 
@@ -38,7 +38,7 @@ namespace apollo {
 namespace monitor {
 namespace {
 
-#if USE_ESD_CAN == 1
+#if USE_ESD_CAN
 std::string StatusString(const NTCAN_RESULT ntstatus) {
   switch (ntstatus) {
     case NTCAN_SUCCESS:
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6ba4eb22a2414269e32fa6163b9f5d7b9b7036a5" author="lilu15">
		<msg>task_manager: add the plannig part of auto park and add the function of plot calibration</msg>
		<modified_files>
			<file old_path="modules\task_manager\common\task_manager_gflags.cc" new_path="modules\task_manager\common\task_manager_gflags.cc" added_lines="4" deleted_lines="0">
				<diff>@@ -21,3 +21,7 @@ DEFINE_string(task_manager_node_name, "task_manager", "the name for this node");
 DEFINE_double(threshold_for_destination_check, 1.0,
               "meters, which is 100 feet.  This threshold is used to check if"
               "the vehicle reaches the destination");
+
+DEFINE_double(plot_size_buffer, 0.2, "the size buffer of parking plot");
+
+DEFINE_double(road_width_buffer, 0.0, "the size buffer of road width");
</diff>
			</file>
			<file old_path="modules\task_manager\common\task_manager_gflags.h" new_path="modules\task_manager\common\task_manager_gflags.h" added_lines="4" deleted_lines="0">
				<diff>@@ -21,3 +21,7 @@
 DECLARE_string(task_manager_node_name);
 
 DECLARE_double(threshold_for_destination_check);
+
+DECLARE_double(plot_size_buffer);
+
+DECLARE_double(road_width_buffer);
</diff>
			</file>
			<file old_path="modules\task_manager\conf\task_manager.conf" new_path="modules\task_manager\conf\task_manager.conf" added_lines="3" deleted_lines="0">
				<diff>@@ -1,2 +1,4 @@
 --flagfile=/apollo/modules/common/data/global_flagfile.txt
---threshold_for_destination_check=10.0
\ No newline at end of file
+--threshold_for_destination_check=10.0
+--plot_size_buffer=0.9
+--road_width_buffer=0.0
\ No newline at end of file
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.cc" new_path="modules\task_manager\task_manager_component.cc" added_lines="35" deleted_lines="12">
				<diff>@@ -28,6 +28,7 @@ using apollo::localization::LocalizationEstimate;
 using apollo::routing::RoutingRequest;
 
 bool TaskManagerComponent::Init() {
+  AERROR &lt;&lt; "enter the TaskManagerComponent init";
   TaskManagerConfig task_manager_conf;
   ACHECK(cyber::ComponentBase::GetProtoConfig(&amp;task_manager_conf))
       &lt;&lt; "Unable to load task_manager conf file: "
@@ -47,6 +48,7 @@ bool TaskManagerComponent::Init() {
   cyber::proto::RoleAttributes attr;
   attr.set_channel_name(
       task_manager_conf.topic_config().routing_request_topic());
+  AERROR &lt;&lt; "the channel name is: " &lt;&lt; attr.channel_name();
   auto qos = attr.mutable_qos_profile();
   qos-&gt;set_history(apollo::cyber::proto::QosHistoryPolicy::HISTORY_KEEP_LAST);
   qos-&gt;set_reliability(
@@ -54,30 +56,51 @@ bool TaskManagerComponent::Init() {
   qos-&gt;set_durability(
       apollo::cyber::proto::QosDurabilityPolicy::DURABILITY_TRANSIENT_LOCAL);
   request_writer_ = node_-&gt;CreateWriter&lt;RoutingRequest&gt;(attr);
+  AERROR &lt;&lt; "end the init";
   return true;
 }
 
 bool TaskManagerComponent::Proc(const std::shared_ptr&lt;Task&gt;&amp; task) {
+  AERROR &lt;&lt; "enter the TaskManagerComponent proc";
   task_name_ = task-&gt;task_name();
-  if (task-&gt;task_type() != CYCLE_ROUTING) {
+  AERROR &lt;&lt; "the task type is: " &lt;&lt; task-&gt;task_type();
+  if (task-&gt;task_type() != CYCLE_ROUTING &amp;&amp;
+      task-&gt;task_type() != PARKING_ROUTING) {
     AINFO &lt;&lt; "Task type is not cycle_routing.";
     return false;
   }
+  if (task-&gt;task_type() == CYCLE_ROUTING) {
+    cycle_routing_manager_ = std::make_shared&lt;CycleRoutingManager&gt;();
+    cycle_routing_manager_-&gt;Init(task-&gt;cycle_routing_task());
+    routing_request_ = task-&gt;cycle_routing_task().routing_request();
+    Rate rate(1.0);
 
-  cycle_routing_manager_ = std::make_shared&lt;CycleRoutingManager&gt;();
-  cycle_routing_manager_-&gt;Init(task-&gt;cycle_routing_task());
-  routing_request_ = task-&gt;cycle_routing_task().routing_request();
-  Rate rate(1.0);
-
-  while (cycle_routing_manager_-&gt;GetCycle() &gt; 0) {
-    if (cycle_routing_manager_-&gt;GetNewRouting(localization_.pose(),
-                                              &amp;routing_request_)) {
+    while (cycle_routing_manager_-&gt;GetCycle() &gt; 0) {
+      if (cycle_routing_manager_-&gt;GetNewRouting(localization_.pose(),
+                                                &amp;routing_request_)) {
+        common::util::FillHeader(node_-&gt;Name(), &amp;routing_request_);
+        request_writer_-&gt;Write(routing_request_);
+        AINFO &lt;&lt; "[TaskManagerComponent]Reach begin/end point: "
+              &lt;&lt; "routing manager send a routing request. ";
+      }
+      rate.Sleep();
+    }
+  } else if (task-&gt;task_type() == PARKING_ROUTING) {
+    AERROR &lt;&lt; "enter the parking routing task";
+    parking_routing_manager_ = std::make_shared&lt;ParkingRoutingManager&gt;();
+    parking_routing_manager_-&gt;Init(task-&gt;parking_routing_task());
+    routing_request_ = task-&gt;parking_routing_task().routing_request();
+    if (parking_routing_manager_-&gt;
+        SizeVerification(task-&gt;parking_routing_task()) &amp;&amp;
+        parking_routing_manager_-&gt;
+        RoadWidthVerification(task-&gt;parking_routing_task())) {
+      AERROR &lt;&lt; "compelet the Verification";
       common::util::FillHeader(node_-&gt;Name(), &amp;routing_request_);
       request_writer_-&gt;Write(routing_request_);
-      AINFO &lt;&lt; "[TaskManagerComponent]Reach begin/end point: "
-            &lt;&lt; "routing manager send a routing request. ";
+      AINFO &lt;&lt; "send a auto parking task";
+    } else {
+      AERROR &lt;&lt; "plot verification failed, please select suitable plot!";
     }
-    rate.Sleep();
   }
   return true;
 }
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.h" new_path="modules\task_manager\task_manager_component.h" added_lines="2" deleted_lines="1">
				<diff>@@ -22,7 +22,7 @@
 #include "cyber/class_loader/class_loader.h"
 #include "cyber/component/component.h"
 #include "modules/task_manager/cycle_routing_manager.h"
-
+#include "modules/task_manager/parking_routing_manager.h"
 namespace apollo {
 namespace task_manager {
 
@@ -41,6 +41,7 @@ class TaskManagerComponent final : public cyber::Component&lt;task_manager::Task&gt; {
   std::shared_ptr&lt;cyber::Reader&lt;LocalizationEstimate&gt;&gt; localization_reader_;
   std::shared_ptr&lt;cyber::Writer&lt;routing::RoutingRequest&gt;&gt; request_writer_;
   std::shared_ptr&lt;CycleRoutingManager&gt; cycle_routing_manager_;
+  std::shared_ptr&lt;ParkingRoutingManager&gt; parking_routing_manager_;
   routing::RoutingRequest routing_request_;
   LocalizationEstimate localization_;
   std::mutex mutex_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="564eb88cc3b9457269df0aa35d51dce7649c5ccc" author="lilu15">
		<msg>planning: add parallel parking</msg>
		<modified_files>
			<file old_path="modules\planning\open_space\coarse_trajectory_generator\hybrid_a_star.cc" new_path="modules\planning\open_space\coarse_trajectory_generator\hybrid_a_star.cc" added_lines="105" deleted_lines="10">
				<diff>@@ -107,6 +107,13 @@ bool HybridAStar::ValidityCheck(std::shared_ptr&lt;Node3d&gt; node) {
   for (size_t i = check_start_index; i &lt; node_step_size; ++i) {
     if (traversed_x[i] &gt; XYbounds_[1] || traversed_x[i] &lt; XYbounds_[0] ||
         traversed_y[i] &gt; XYbounds_[3] || traversed_y[i] &lt; XYbounds_[2]) {
+      AERROR &lt;&lt; "traversed_x[i] is: " &lt;&lt; traversed_x[i];
+      AERROR &lt;&lt; "XYbounds_[1] is: " &lt;&lt; XYbounds_[1];
+      AERROR &lt;&lt; "XYbounds_[0] is: " &lt;&lt; XYbounds_[0];
+      AERROR &lt;&lt; "traversed_y[i] is: " &lt;&lt; traversed_y[i];
+      AERROR &lt;&lt; "XYbounds_[3] is: " &lt;&lt; XYbounds_[3];
+      AERROR &lt;&lt; "XYbounds_[2] is: " &lt;&lt; XYbounds_[2];
+      AERROR &lt;&lt; "enter false 1";
       return false;
     }
     Box2d bounding_box = Node3d::GetBoundingBox(
@@ -115,10 +122,11 @@ bool HybridAStar::ValidityCheck(std::shared_ptr&lt;Node3d&gt; node) {
       for (const common::math::LineSegment2d&amp; linesegment :
            obstacle_linesegments) {
         if (bounding_box.HasOverlap(linesegment)) {
-          ADEBUG &lt;&lt; "collision start at x: " &lt;&lt; linesegment.start().x();
-          ADEBUG &lt;&lt; "collision start at y: " &lt;&lt; linesegment.start().y();
-          ADEBUG &lt;&lt; "collision end at x: " &lt;&lt; linesegment.end().x();
-          ADEBUG &lt;&lt; "collision end at y: " &lt;&lt; linesegment.end().y();
+          AERROR &lt;&lt; "enter false 2";
+          AERROR &lt;&lt; "collision start at x: " &lt;&lt; linesegment.start().x();
+          AERROR &lt;&lt; "collision start at y: " &lt;&lt; linesegment.start().y();
+          AERROR &lt;&lt; "collision end at x: " &lt;&lt; linesegment.end().x();
+          AERROR &lt;&lt; "collision end at y: " &lt;&lt; linesegment.end().y();
           return false;
         }
       }
@@ -642,21 +650,53 @@ bool HybridAStar::Plan(
   close_set_.clear();
   open_pq_ = decltype(open_pq_)();
   final_node_ = nullptr;
-
+  // add
+  size_t segment_num = obstacles_vertices_vec.size();
+  std::ofstream pointx, pointy;
+  pointx.open("pointx.txt");
+  pointy.open("pointy.txt");
+  // end
   std::vector&lt;std::vector&lt;common::math::LineSegment2d&gt;&gt;
       obstacles_linesegments_vec;
+  std::vector&lt;common::math::LineSegment2d&gt; obstacle_linesegments;
   for (const auto&amp; obstacle_vertices : obstacles_vertices_vec) {
     size_t vertices_num = obstacle_vertices.size();
-    std::vector&lt;common::math::LineSegment2d&gt; obstacle_linesegments;
+    // std::vector&lt;common::math::LineSegment2d&gt; obstacle_linesegments;
     for (size_t i = 0; i &lt; vertices_num - 1; ++i) {
       common::math::LineSegment2d line_segment = common::math::LineSegment2d(
           obstacle_vertices[i], obstacle_vertices[i + 1]);
+      // add
+      if (pointx.is_open() &amp;&amp; pointy.is_open()) {
+        pointx &lt;&lt; obstacle_vertices[i].x();
+        pointx &lt;&lt; std::endl;
+        pointy &lt;&lt; obstacle_vertices[i].y();
+        pointy &lt;&lt; std::endl;
+        pointx &lt;&lt; obstacle_vertices[i + 1].x();
+        pointx &lt;&lt; std::endl;
+        pointy &lt;&lt; obstacle_vertices[i + 1].y();
+        pointy &lt;&lt; std::endl;
+      }
+      // end
       obstacle_linesegments.emplace_back(line_segment);
     }
     obstacles_linesegments_vec.emplace_back(obstacle_linesegments);
   }
+  // add
+  common::math::LineSegment2d line_segment = common::math::LineSegment2d(
+    obstacles_vertices_vec[segment_num - 1].back(),
+    obstacles_vertices_vec[0].front());
+  obstacle_linesegments.emplace_back(line_segment);
+  obstacles_linesegments_vec.emplace_back(obstacle_linesegments);
+  pointx &lt;&lt; obstacles_vertices_vec[segment_num - 1].back().x();
+  pointx &lt;&lt; std::endl;
+  pointy &lt;&lt; obstacles_vertices_vec[segment_num - 1].back().y();
+  pointy &lt;&lt; std::endl;
+  pointx &lt;&lt; obstacles_vertices_vec[0].front().x();
+  pointx &lt;&lt; std::endl;
+  pointy &lt;&lt; obstacles_vertices_vec[0].front().y();
+  pointy &lt;&lt; std::endl;
+  // end
   obstacles_linesegments_vec_ = std::move(obstacles_linesegments_vec);
-
   // load XYbounds
   XYbounds_ = XYbounds;
   // load nodes and obstacles
@@ -664,12 +704,50 @@ bool HybridAStar::Plan(
       new Node3d({sx}, {sy}, {sphi}, XYbounds_, planner_open_space_config_));
   end_node_.reset(
       new Node3d({ex}, {ey}, {ephi}, XYbounds_, planner_open_space_config_));
+
+  Box2d start_point = Node3d::GetBoundingBox(
+        vehicle_param_, sx, sy, sphi);
+  Box2d end_point = Node3d::GetBoundingBox(
+        vehicle_param_, ex, ey, ephi);
+  std::vector&lt;Vec2d&gt; s_vector = start_point.GetAllCorners();
+  std::vector&lt;Vec2d&gt; e_vector = end_point.GetAllCorners();
+  // add
+  std::ofstream startx, starty, endx, endy, currentx, currenty, currentphi;
+  currentx.open("currentx.txt");
+  currenty.open("currenty.txt");
+  currentphi.open("currentphi.txt");
+  startx.open("startx.txt");
+  starty.open("starty.txt");
+  endx.open("endx.txt");
+  endy.open("endy.txt");
+  if (startx.is_open() &amp;&amp; endx.is_open()) {
+    for (size_t m = 0; m &lt; s_vector.size(); ++m) {
+      startx &lt;&lt; s_vector.at(m).x();
+      startx &lt;&lt; std::endl;
+      starty &lt;&lt; s_vector.at(m).y();
+      starty &lt;&lt; std::endl;
+
+      endx &lt;&lt; e_vector.at(m).x();
+      endx &lt;&lt; std::endl;
+      endy &lt;&lt; e_vector.at(m).y();
+      endy &lt;&lt; std::endl;
+    }
+    startx &lt;&lt; s_vector.at(0).x();
+    startx &lt;&lt; std::endl;
+    starty &lt;&lt; s_vector.at(0).y();
+    starty &lt;&lt; std::endl;
+    endx &lt;&lt; e_vector.at(0).x();
+    endx &lt;&lt; std::endl;
+    endy &lt;&lt; e_vector.at(0).y();
+    endy &lt;&lt; std::endl;
+  }
+  // end
   if (!ValidityCheck(start_node_)) {
-    ADEBUG &lt;&lt; "start_node in collision with obstacles";
+    AERROR &lt;&lt; "start_node in collision with obstacles";
     return false;
   }
   if (!ValidityCheck(end_node_)) {
-    ADEBUG &lt;&lt; "end_node in collision with obstacles";
+    AERROR &lt;&lt; "end_node in collision with obstacles";
     return false;
   }
   double map_time = Clock::NowInSeconds();
@@ -679,7 +757,6 @@ bool HybridAStar::Plan(
   // load open set, pq
   open_set_.emplace(start_node_-&gt;GetIndex(), start_node_);
   open_pq_.emplace(start_node_-&gt;GetIndex(), start_node_-&gt;GetCost());
-
   // Hybrid A* begins
   size_t explored_node_num = 0;
   double astar_start_time = Clock::NowInSeconds();
@@ -690,6 +767,24 @@ bool HybridAStar::Plan(
     const std::string current_id = open_pq_.top().first;
     open_pq_.pop();
     std::shared_ptr&lt;Node3d&gt; current_node = open_set_[current_id];
+    Box2d current_point = Node3d::GetBoundingBox(
+        vehicle_param_, current_node-&gt;GetX(),
+        current_node-&gt;GetY(), current_node-&gt;GetPhi());
+    std::vector&lt;Vec2d&gt; current_vector = current_point.GetAllCorners();
+    if (currentx.is_open() &amp;&amp; currenty.is_open() &amp;&amp; currentphi.is_open()) {
+      for (size_t m = 0; m &lt; current_vector.size(); ++m) {
+        currentx &lt;&lt; current_vector.at(m).x();
+        currentx &lt;&lt; std::endl;
+        currenty &lt;&lt; current_vector.at(m).y();
+        currenty &lt;&lt; std::endl;
+      }
+      currentx &lt;&lt; current_vector.at(0).x();
+      currentx &lt;&lt; std::endl;
+      currenty &lt;&lt; current_vector.at(0).y();
+      currenty &lt;&lt; std::endl;
+      // currentphi &lt;&lt; current_node-&gt;GetPhi();
+      // currentphi &lt;&lt; std::endl;
+  }
     // check if an analystic curve could be connected from current
     // configuration to the end configuration without collision. if so, search
     // ends.
</diff>
			</file>
			<file old_path="modules\planning\scenarios\park\valet_parking\valet_parking_scenario.cc" new_path="modules\planning\scenarios\park\valet_parking\valet_parking_scenario.cc" added_lines="10" deleted_lines="1">
				<diff>@@ -132,7 +132,7 @@ bool ValetParkingScenario::IsTransferable(const Frame&amp; frame,
     return false;
   }
 
-  if (!CheckDistanceToParkingSpot(vehicle_state, nearby_path,
+  if (!CheckDistanceToParkingSpot(frame, vehicle_state, nearby_path,
                                   parking_start_range, parking_space_overlap)) {
     ADEBUG &lt;&lt; "target parking spot found, but too far, distance larger than "
               "pre-defined distance"
@@ -157,6 +157,7 @@ bool ValetParkingScenario::SearchTargetParkingSpotOnPath(
 }
 
 bool ValetParkingScenario::CheckDistanceToParkingSpot(
+    const Frame&amp; frame,
     const VehicleState&amp; vehicle_state, const Path&amp; nearby_path,
     const double parking_start_range,
     const PathOverlap&amp; parking_space_overlap) {
@@ -170,6 +171,14 @@ bool ValetParkingScenario::CheckDistanceToParkingSpot(
       hdmap-&gt;GetParkingSpaceById(id);
   Vec2d left_bottom_point = target_parking_spot_ptr-&gt;polygon().points().at(0);
   Vec2d right_bottom_point = target_parking_spot_ptr-&gt;polygon().points().at(1);
+  const auto &amp;routing_request =
+      frame.local_view().routing-&gt;routing_request();
+  auto corner_point =
+      routing_request.parking_info().corner_point();
+  left_bottom_point.set_x(corner_point.point().at(0).x());
+  left_bottom_point.set_y(corner_point.point().at(0).y());
+  right_bottom_point.set_x(corner_point.point().at(1).x());
+  right_bottom_point.set_y(corner_point.point().at(1).y());
   double left_bottom_point_s = 0.0;
   double left_bottom_point_l = 0.0;
   double right_bottom_point_s = 0.0;
</diff>
			</file>
			<file old_path="modules\planning\scenarios\park\valet_parking\valet_parking_scenario.h" new_path="modules\planning\scenarios\park\valet_parking\valet_parking_scenario.h" added_lines="1" deleted_lines="0">
				<diff>@@ -66,6 +66,7 @@ class ValetParkingScenario : public Scenario {
       const hdmap::Path&amp; nearby_path, const std::string&amp; target_parking_id,
       hdmap::PathOverlap* parking_space_overlap);
   static bool CheckDistanceToParkingSpot(
+      const Frame&amp; frame,
       const common::VehicleState&amp; vehicle_state, const hdmap::Path&amp; nearby_path,
       const double parking_start_range,
       const hdmap::PathOverlap&amp; parking_space_overlap);
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_pre_stop_decider.cc" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_pre_stop_decider.cc" added_lines="8" deleted_lines="0">
				<diff>@@ -97,6 +97,10 @@ bool OpenSpacePreStopDecider::CheckPullOverPreStop(
 bool OpenSpacePreStopDecider::CheckParkingSpotPreStop(
     Frame* const frame, ReferenceLineInfo* const reference_line_info,
     double* target_s) {
+  const auto &amp;routing_request =
+      frame-&gt;local_view().routing-&gt;routing_request();
+  auto corner_point =
+      routing_request.parking_info().corner_point();
   const auto&amp; target_parking_spot_id =
       frame-&gt;open_space_info().target_parking_spot_id();
   const auto&amp; nearby_path = reference_line_info-&gt;reference_line().map_path();
@@ -122,6 +126,10 @@ bool OpenSpacePreStopDecider::CheckParkingSpotPreStop(
           target_parking_spot_ptr-&gt;polygon().points().at(0);
       Vec2d right_bottom_point =
           target_parking_spot_ptr-&gt;polygon().points().at(1);
+      left_bottom_point.set_x(corner_point.point().at(0).x());
+      left_bottom_point.set_y(corner_point.point().at(0).y());
+      right_bottom_point.set_x(corner_point.point().at(1).x());
+      right_bottom_point.set_y(corner_point.point().at(1).y());
       double left_bottom_point_s = 0.0;
       double left_bottom_point_l = 0.0;
       double right_bottom_point_s = 0.0;
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" added_lines="67" deleted_lines="3">
				<diff>@@ -38,6 +38,7 @@ using apollo::hdmap::LaneInfoConstPtr;
 using apollo::hdmap::LaneSegment;
 using apollo::hdmap::ParkingSpaceInfoConstPtr;
 using apollo::hdmap::Path;
+using apollo::routing::ParkingSpotType;
 
 OpenSpaceRoiDecider::OpenSpaceRoiDecider(
     const TaskConfig &amp;config,
@@ -212,6 +213,9 @@ void OpenSpaceRoiDecider::SetOrigin(
 
 void OpenSpaceRoiDecider::SetParkingSpotEndPose(
     Frame *const frame, const std::array&lt;common::math::Vec2d, 4&gt; &amp;vertices) {
+  const auto &amp;routing_request =
+        frame-&gt;local_view().routing-&gt;routing_request();
+  auto plot_type = routing_request.parking_info().parking_spot_type();
   auto left_top = vertices[0];
   auto left_down = vertices[1];
   auto right_down = vertices[2];
@@ -264,7 +268,14 @@ void OpenSpaceRoiDecider::SetParkingSpotEndPose(
                                parking_depth_buffer);
     }
   }
-
+  if (plot_type == ParkingSpotType::PARALLEL_PLOT) {
+    double parllel_park_end_x_buffer =
+        config_.open_space_roi_decider_config().parallel_park_end_x_buffer();
+    parking_spot_heading = (left_down - right_down).Angle();
+    end_y = (left_top.y() + left_down.y()) / 2.0;
+    end_x = left_top.x() + vehicle_params_.back_edge_to_center() +
+      parllel_park_end_x_buffer;
+  }
   auto *end_pose =
       frame-&gt;mutable_open_space_info()-&gt;mutable_open_space_end_pose();
   end_pose-&gt;push_back(end_x);
@@ -1189,6 +1200,9 @@ bool OpenSpaceRoiDecider::GetParkAndGoBoundary(
 bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
                                          std::array&lt;Vec2d, 4&gt; *vertices,
                                          Path *nearby_path) {
+  const auto &amp;routing_request =
+        frame-&gt;local_view().routing-&gt;routing_request();
+  auto plot_type = routing_request.parking_info().parking_spot_type();
   if (frame == nullptr) {
     AERROR &lt;&lt; "Invalid frame, fail to GetParkingSpotFromMap from frame. ";
     return false;
@@ -1211,8 +1225,10 @@ bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
   if (previous_open_space_info.target_parking_lane() != nullptr &amp;&amp;
       previous_open_space_info.target_parking_spot_id() ==
           frame-&gt;open_space_info().target_parking_spot_id()) {
+    AERROR &lt;&lt; "enter the 1";
     nearest_lane = previous_open_space_info.target_parking_lane();
   } else {
+    AERROR &lt;&lt; "enter the 2";
     int status = HDMapUtil::BaseMap().GetNearestLaneWithHeading(
         point, 10.0, vehicle_state_.heading(), M_PI / 2.0, &amp;nearest_lane,
         &amp;vehicle_lane_s, &amp;vehicle_lane_l);
@@ -1240,6 +1256,17 @@ bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
           LaneSegment(next_lane, next_lane-&gt;accumulate_s().front(),
                       next_lane-&gt;accumulate_s().back());
       segments_vector.push_back(next_lanesegment);
+      size_t succeed_lanes_num = next_lane-&gt;lane().successor_id_size();
+      if (succeed_lanes_num != 0) {
+        for (size_t j = 0; j &lt; succeed_lanes_num; j++) {
+          auto succeed_lane_id = next_lane-&gt;lane().successor_id(j);
+          auto succeed_lane = hdmap_-&gt;GetLaneById(succeed_lane_id);
+          LaneSegment succeed_lanesegment =
+            LaneSegment(succeed_lane, succeed_lane-&gt;accumulate_s().front(),
+                        succeed_lane-&gt;accumulate_s().back());
+            segments_vector.push_back(succeed_lanesegment);
+        }
+      }
       *nearby_path = Path(segments_vector);
       SearchTargetParkingSpotOnPath(*nearby_path, &amp;target_parking_spot);
       if (target_parking_spot != nullptr) {
@@ -1247,6 +1274,7 @@ bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
       }
     }
   } else {
+    AERROR &lt;&lt; "outer the loop";
     segments_vector.push_back(nearest_lanesegment);
     *nearby_path = Path(segments_vector);
     SearchTargetParkingSpotOnPath(*nearby_path, &amp;target_parking_spot);
@@ -1258,7 +1286,7 @@ bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
     return false;
   }
 
-  if (!CheckDistanceToParkingSpot(*nearby_path, target_parking_spot)) {
+  if (!CheckDistanceToParkingSpot(frame, *nearby_path, target_parking_spot)) {
     AERROR &lt;&lt; "target parking spot found, but too far, distance larger than "
               "pre-defined distance";
     return false;
@@ -1270,7 +1298,34 @@ bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
   Vec2d left_down = target_parking_spot-&gt;polygon().points().at(0);
   Vec2d right_down = target_parking_spot-&gt;polygon().points().at(1);
   Vec2d right_top = target_parking_spot-&gt;polygon().points().at(2);
-
+  if (plot_type == ParkingSpotType::PARALLEL_PLOT) {
+    const auto &amp;routing_request =
+      frame-&gt;local_view().routing-&gt;routing_request();
+    auto corner_point =
+        routing_request.parking_info().corner_point();
+    // 156 parallel
+    left_top.set_x(corner_point.point().at(3).x());
+    left_top.set_y(corner_point.point().at(3).y());
+    left_down.set_x(corner_point.point().at(0).x());
+    left_down.set_y(corner_point.point().at(0).y());
+    right_down.set_x(corner_point.point().at(1).x());
+    right_down.set_y(corner_point.point().at(1).y());
+    right_top.set_x(corner_point.point().at(2).x());
+    right_top.set_y(corner_point.point().at(2).y());
+    double extend_right_x_buffer =
+      config_.open_space_roi_decider_config().extend_right_x_buffer();
+    double extend_left_x_buffer =
+      config_.open_space_roi_decider_config().extend_left_x_buffer();
+    right_top.set_x(right_top.x() + extend_right_x_buffer);
+    left_top.set_x(left_top.x() - extend_left_x_buffer);
+    left_down.set_x(left_down.x() - extend_left_x_buffer);
+    right_down.set_x(right_down.x() + extend_right_x_buffer);
+    // 155 parallel
+    // Vec2d left_top = target_parking_spot-&gt;polygon().points().at(2);
+    // Vec2d left_down = target_parking_spot-&gt;polygon().points().at(3);
+    // Vec2d right_down = target_parking_spot-&gt;polygon().points().at(0);
+    // Vec2d right_top = target_parking_spot-&gt;polygon().points().at(1);
+  }
   std::array&lt;Vec2d, 4&gt; parking_vertices{left_top, left_down, right_down,
                                         right_top};
 
@@ -1354,10 +1409,19 @@ void OpenSpaceRoiDecider::SearchTargetParkingSpotOnPath(
 }
 
 bool OpenSpaceRoiDecider::CheckDistanceToParkingSpot(
+    Frame *const frame,
     const hdmap::Path &amp;nearby_path,
     const hdmap::ParkingSpaceInfoConstPtr &amp;target_parking_spot) {
+  const auto &amp;routing_request =
+      frame-&gt;local_view().routing-&gt;routing_request();
+  auto corner_point =
+      routing_request.parking_info().corner_point();
   Vec2d left_bottom_point = target_parking_spot-&gt;polygon().points().at(0);
   Vec2d right_bottom_point = target_parking_spot-&gt;polygon().points().at(1);
+  left_bottom_point.set_x(corner_point.point().at(0).x());
+  left_bottom_point.set_y(corner_point.point().at(0).y());
+  right_bottom_point.set_x(corner_point.point().at(1).x());
+  right_bottom_point.set_y(corner_point.point().at(1).y());
   double left_bottom_point_s = 0.0;
   double left_bottom_point_l = 0.0;
   double right_bottom_point_s = 0.0;
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.h" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.h" added_lines="1" deleted_lines="0">
				<diff>@@ -147,6 +147,7 @@ class OpenSpaceRoiDecider : public Decider {
 
   // @brief if not close enough to parking spot, return false
   bool CheckDistanceToParkingSpot(
+      Frame *const frame,
       const hdmap::Path &amp;nearby_path,
       const hdmap::ParkingSpaceInfoConstPtr &amp;target_parking_spot);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="70070f83313257d58903f16779e998c9d6a31d79" author="lilu15">
		<msg>planning: remove the code of plot boundary</msg>
		<modified_files>
			<file old_path="modules\planning\open_space\coarse_trajectory_generator\hybrid_a_star.cc" new_path="modules\planning\open_space\coarse_trajectory_generator\hybrid_a_star.cc" added_lines="5" deleted_lines="85">
				<diff>@@ -107,13 +107,6 @@ bool HybridAStar::ValidityCheck(std::shared_ptr&lt;Node3d&gt; node) {
   for (size_t i = check_start_index; i &lt; node_step_size; ++i) {
     if (traversed_x[i] &gt; XYbounds_[1] || traversed_x[i] &lt; XYbounds_[0] ||
         traversed_y[i] &gt; XYbounds_[3] || traversed_y[i] &lt; XYbounds_[2]) {
-      AERROR &lt;&lt; "traversed_x[i] is: " &lt;&lt; traversed_x[i];
-      AERROR &lt;&lt; "XYbounds_[1] is: " &lt;&lt; XYbounds_[1];
-      AERROR &lt;&lt; "XYbounds_[0] is: " &lt;&lt; XYbounds_[0];
-      AERROR &lt;&lt; "traversed_y[i] is: " &lt;&lt; traversed_y[i];
-      AERROR &lt;&lt; "XYbounds_[3] is: " &lt;&lt; XYbounds_[3];
-      AERROR &lt;&lt; "XYbounds_[2] is: " &lt;&lt; XYbounds_[2];
-      AERROR &lt;&lt; "enter false 1";
       return false;
     }
     Box2d bounding_box = Node3d::GetBoundingBox(
@@ -122,11 +115,10 @@ bool HybridAStar::ValidityCheck(std::shared_ptr&lt;Node3d&gt; node) {
       for (const common::math::LineSegment2d&amp; linesegment :
            obstacle_linesegments) {
         if (bounding_box.HasOverlap(linesegment)) {
-          AERROR &lt;&lt; "enter false 2";
-          AERROR &lt;&lt; "collision start at x: " &lt;&lt; linesegment.start().x();
-          AERROR &lt;&lt; "collision start at y: " &lt;&lt; linesegment.start().y();
-          AERROR &lt;&lt; "collision end at x: " &lt;&lt; linesegment.end().x();
-          AERROR &lt;&lt; "collision end at y: " &lt;&lt; linesegment.end().y();
+          ADEBUG &lt;&lt; "collision start at x: " &lt;&lt; linesegment.start().x();
+          ADEBUG &lt;&lt; "collision start at y: " &lt;&lt; linesegment.start().y();
+          ADEBUG &lt;&lt; "collision end at x: " &lt;&lt; linesegment.end().x();
+          ADEBUG &lt;&lt; "collision end at y: " &lt;&lt; linesegment.end().y();
           return false;
         }
       }
@@ -650,52 +642,18 @@ bool HybridAStar::Plan(
   close_set_.clear();
   open_pq_ = decltype(open_pq_)();
   final_node_ = nullptr;
-  // add
-  size_t segment_num = obstacles_vertices_vec.size();
-  std::ofstream pointx, pointy;
-  pointx.open("pointx.txt");
-  pointy.open("pointy.txt");
-  // end
   std::vector&lt;std::vector&lt;common::math::LineSegment2d&gt;&gt;
       obstacles_linesegments_vec;
-  std::vector&lt;common::math::LineSegment2d&gt; obstacle_linesegments;
   for (const auto&amp; obstacle_vertices : obstacles_vertices_vec) {
     size_t vertices_num = obstacle_vertices.size();
-    // std::vector&lt;common::math::LineSegment2d&gt; obstacle_linesegments;
+    std::vector&lt;common::math::LineSegment2d&gt; obstacle_linesegments;
     for (size_t i = 0; i &lt; vertices_num - 1; ++i) {
       common::math::LineSegment2d line_segment = common::math::LineSegment2d(
           obstacle_vertices[i], obstacle_vertices[i + 1]);
-      // add
-      if (pointx.is_open() &amp;&amp; pointy.is_open()) {
-        pointx &lt;&lt; obstacle_vertices[i].x();
-        pointx &lt;&lt; std::endl;
-        pointy &lt;&lt; obstacle_vertices[i].y();
-        pointy &lt;&lt; std::endl;
-        pointx &lt;&lt; obstacle_vertices[i + 1].x();
-        pointx &lt;&lt; std::endl;
-        pointy &lt;&lt; obstacle_vertices[i + 1].y();
-        pointy &lt;&lt; std::endl;
-      }
-      // end
       obstacle_linesegments.emplace_back(line_segment);
     }
     obstacles_linesegments_vec.emplace_back(obstacle_linesegments);
   }
-  // add
-  common::math::LineSegment2d line_segment = common::math::LineSegment2d(
-    obstacles_vertices_vec[segment_num - 1].back(),
-    obstacles_vertices_vec[0].front());
-  obstacle_linesegments.emplace_back(line_segment);
-  obstacles_linesegments_vec.emplace_back(obstacle_linesegments);
-  pointx &lt;&lt; obstacles_vertices_vec[segment_num - 1].back().x();
-  pointx &lt;&lt; std::endl;
-  pointy &lt;&lt; obstacles_vertices_vec[segment_num - 1].back().y();
-  pointy &lt;&lt; std::endl;
-  pointx &lt;&lt; obstacles_vertices_vec[0].front().x();
-  pointx &lt;&lt; std::endl;
-  pointy &lt;&lt; obstacles_vertices_vec[0].front().y();
-  pointy &lt;&lt; std::endl;
-  // end
   obstacles_linesegments_vec_ = std::move(obstacles_linesegments_vec);
   // load XYbounds
   XYbounds_ = XYbounds;
@@ -704,44 +662,6 @@ bool HybridAStar::Plan(
       new Node3d({sx}, {sy}, {sphi}, XYbounds_, planner_open_space_config_));
   end_node_.reset(
       new Node3d({ex}, {ey}, {ephi}, XYbounds_, planner_open_space_config_));
-
-  Box2d start_point = Node3d::GetBoundingBox(
-        vehicle_param_, sx, sy, sphi);
-  Box2d end_point = Node3d::GetBoundingBox(
-        vehicle_param_, ex, ey, ephi);
-  std::vector&lt;Vec2d&gt; s_vector = start_point.GetAllCorners();
-  std::vector&lt;Vec2d&gt; e_vector = end_point.GetAllCorners();
-  // add
-  std::ofstream startx, starty, endx, endy, currentx, currenty, currentphi;
-  currentx.open("currentx.txt");
-  currenty.open("currenty.txt");
-  currentphi.open("currentphi.txt");
-  startx.open("startx.txt");
-  starty.open("starty.txt");
-  endx.open("endx.txt");
-  endy.open("endy.txt");
-  if (startx.is_open() &amp;&amp; endx.is_open()) {
-    for (size_t m = 0; m &lt; s_vector.size(); ++m) {
-      startx &lt;&lt; s_vector.at(m).x();
-      startx &lt;&lt; std::endl;
-      starty &lt;&lt; s_vector.at(m).y();
-      starty &lt;&lt; std::endl;
-
-      endx &lt;&lt; e_vector.at(m).x();
-      endx &lt;&lt; std::endl;
-      endy &lt;&lt; e_vector.at(m).y();
-      endy &lt;&lt; std::endl;
-    }
-    startx &lt;&lt; s_vector.at(0).x();
-    startx &lt;&lt; std::endl;
-    starty &lt;&lt; s_vector.at(0).y();
-    starty &lt;&lt; std::endl;
-    endx &lt;&lt; e_vector.at(0).x();
-    endx &lt;&lt; std::endl;
-    endy &lt;&lt; e_vector.at(0).y();
-    endy &lt;&lt; std::endl;
-  }
-  // end
   if (!ValidityCheck(start_node_)) {
     AERROR &lt;&lt; "start_node in collision with obstacles";
     return false;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8ec3c7aa6290d38f03c1d61a765b6dbbf5d3c4d7" author="lilu15">
		<msg>remove redundant comment</msg>
		<modified_files>
			<file old_path="modules\planning\open_space\coarse_trajectory_generator\hybrid_a_star.cc" new_path="modules\planning\open_space\coarse_trajectory_generator\hybrid_a_star.cc" added_lines="0" deleted_lines="18">
				<diff>@@ -687,24 +687,6 @@ bool HybridAStar::Plan(
     const std::string current_id = open_pq_.top().first;
     open_pq_.pop();
     std::shared_ptr&lt;Node3d&gt; current_node = open_set_[current_id];
-    Box2d current_point = Node3d::GetBoundingBox(
-        vehicle_param_, current_node-&gt;GetX(),
-        current_node-&gt;GetY(), current_node-&gt;GetPhi());
-    std::vector&lt;Vec2d&gt; current_vector = current_point.GetAllCorners();
-    if (currentx.is_open() &amp;&amp; currenty.is_open() &amp;&amp; currentphi.is_open()) {
-      for (size_t m = 0; m &lt; current_vector.size(); ++m) {
-        currentx &lt;&lt; current_vector.at(m).x();
-        currentx &lt;&lt; std::endl;
-        currenty &lt;&lt; current_vector.at(m).y();
-        currenty &lt;&lt; std::endl;
-      }
-      currentx &lt;&lt; current_vector.at(0).x();
-      currentx &lt;&lt; std::endl;
-      currenty &lt;&lt; current_vector.at(0).y();
-      currenty &lt;&lt; std::endl;
-      // currentphi &lt;&lt; current_node-&gt;GetPhi();
-      // currentphi &lt;&lt; std::endl;
-  }
     // check if an analystic curve could be connected from current
     // configuration to the end configuration without collision. if so, search
     // ends.
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" added_lines="3" deleted_lines="12">
				<diff>@@ -38,7 +38,7 @@ using apollo::hdmap::LaneInfoConstPtr;
 using apollo::hdmap::LaneSegment;
 using apollo::hdmap::ParkingSpaceInfoConstPtr;
 using apollo::hdmap::Path;
-using apollo::routing::ParkingSpotType;
+using apollo::routing::ParkingSpaceType;
 
 OpenSpaceRoiDecider::OpenSpaceRoiDecider(
     const TaskConfig &amp;config,
@@ -268,7 +268,7 @@ void OpenSpaceRoiDecider::SetParkingSpotEndPose(
                                parking_depth_buffer);
     }
   }
-  if (plot_type == ParkingSpotType::PARALLEL_PLOT) {
+  if (plot_type == ParkingSpaceType::PARALLEL_PLOT) {
     double parllel_park_end_x_buffer =
         config_.open_space_roi_decider_config().parallel_park_end_x_buffer();
     parking_spot_heading = (left_down - right_down).Angle();
@@ -1225,10 +1225,8 @@ bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
   if (previous_open_space_info.target_parking_lane() != nullptr &amp;&amp;
       previous_open_space_info.target_parking_spot_id() ==
           frame-&gt;open_space_info().target_parking_spot_id()) {
-    AERROR &lt;&lt; "enter the 1";
     nearest_lane = previous_open_space_info.target_parking_lane();
   } else {
-    AERROR &lt;&lt; "enter the 2";
     int status = HDMapUtil::BaseMap().GetNearestLaneWithHeading(
         point, 10.0, vehicle_state_.heading(), M_PI / 2.0, &amp;nearest_lane,
         &amp;vehicle_lane_s, &amp;vehicle_lane_l);
@@ -1274,7 +1272,6 @@ bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
       }
     }
   } else {
-    AERROR &lt;&lt; "outer the loop";
     segments_vector.push_back(nearest_lanesegment);
     *nearby_path = Path(segments_vector);
     SearchTargetParkingSpotOnPath(*nearby_path, &amp;target_parking_spot);
@@ -1298,12 +1295,11 @@ bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
   Vec2d left_down = target_parking_spot-&gt;polygon().points().at(0);
   Vec2d right_down = target_parking_spot-&gt;polygon().points().at(1);
   Vec2d right_top = target_parking_spot-&gt;polygon().points().at(2);
-  if (plot_type == ParkingSpotType::PARALLEL_PLOT) {
+  if (plot_type == ParkingSpaceType::PARALLEL_PLOT) {
     const auto &amp;routing_request =
       frame-&gt;local_view().routing-&gt;routing_request();
     auto corner_point =
         routing_request.parking_info().corner_point();
-    // 156 parallel
     left_top.set_x(corner_point.point().at(3).x());
     left_top.set_y(corner_point.point().at(3).y());
     left_down.set_x(corner_point.point().at(0).x());
@@ -1320,11 +1316,6 @@ bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
     left_top.set_x(left_top.x() - extend_left_x_buffer);
     left_down.set_x(left_down.x() - extend_left_x_buffer);
     right_down.set_x(right_down.x() + extend_right_x_buffer);
-    // 155 parallel
-    // Vec2d left_top = target_parking_spot-&gt;polygon().points().at(2);
-    // Vec2d left_down = target_parking_spot-&gt;polygon().points().at(3);
-    // Vec2d right_down = target_parking_spot-&gt;polygon().points().at(0);
-    // Vec2d right_top = target_parking_spot-&gt;polygon().points().at(1);
   }
   std::array&lt;Vec2d, 4&gt; parking_vertices{left_top, left_down, right_down,
                                         right_top};
</diff>
			</file>
			<file old_path="modules\task_manager\parking_routing_manager.cc" new_path="modules\task_manager\parking_routing_manager.cc" added_lines="3" deleted_lines="6">
				<diff>@@ -26,7 +26,7 @@ namespace task_manager {
 using apollo::common::math::Vec2d;
 using apollo::common::PointENU;
 using apollo::hdmap::ParkingSpaceInfoConstPtr;
-using apollo::routing::ParkingSpotType;
+using apollo::routing::ParkingSpaceType;
 
 common::Status ParkingRoutingManager::Init(
         const ParkingRoutingTask&amp; parking_routing_task) {
@@ -41,7 +41,6 @@ common::Status ParkingRoutingManager::Init(
 
 bool ParkingRoutingManager::SizeVerification(
         const ParkingRoutingTask&amp; parking_routing_task) {
-    AERROR &lt;&lt; "the FLAGS_plot_size_buffer is: " &lt;&lt; FLAGS_plot_size_buffer;
     auto plot_type =
       parking_routing_task.routing_request().parking_info().parking_spot_type();
     const auto&amp; vehicle_config =
@@ -66,13 +65,13 @@ bool ParkingRoutingManager::SizeVerification(
                         (right_bottom_point.y() - left_bottom_point.y()) *
                         (right_bottom_point.y() - left_bottom_point.y()));
     // judge by spot type
-    if (plot_type == ParkingSpotType::VERTICAL_PLOT) {
+    if (plot_type == ParkingSpaceType::VERTICAL_PLOT) {
         if (length + FLAGS_plot_size_buffer &lt; ego_length ||
             width + FLAGS_plot_size_buffer &lt; ego_width) {
             AERROR &lt;&lt; "The veritical plot is small";
             return false;
         }
-    } else if (plot_type == ParkingSpotType::PARALLEL_PLOT) {
+    } else if (plot_type == ParkingSpaceType::PARALLEL_PLOT) {
         if (width + FLAGS_plot_size_buffer &lt; ego_length ||
             length + FLAGS_plot_size_buffer &lt; ego_width) {
             AERROR &lt;&lt; "The parallel plot is small";
@@ -87,9 +86,7 @@ bool ParkingRoutingManager::RoadWidthVerification(
     const auto&amp; vehicle_config =
       common::VehicleConfigHelper::Instance()-&gt;GetConfig();
     double ego_width = vehicle_config.vehicle_param().width();
-    AERROR &lt;&lt; "the vehicle width is: " &lt;&lt; ego_width;
     double road_width = parking_routing_task.lane_width();
-    AERROR &lt;&lt; "the road width is: " &lt;&lt; road_width;
     if (!has_space_ || !has_space_id_) {
         AERROR &lt;&lt; "No Valid park plot exits!";
         return false;
</diff>
			</file>
			<file old_path="modules\task_manager\parking_routing_manager.h" new_path="modules\task_manager\parking_routing_manager.h" added_lines="0" deleted_lines="1">
				<diff>@@ -63,7 +63,6 @@ class ParkingRoutingManager {
   bool has_space_ = false;
   bool has_space_id_ = false;
   std::string id_ = "";
-//  ParkingRoutingConfig config_;
 };
 
 }  // namespace task_manager
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="68025c68b2094d38ccfe9d17d1b6e5791589d3ef" author="lilu15">
		<msg>remove redundant comment of planning</msg>
		<modified_files>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -268,7 +268,7 @@ void OpenSpaceRoiDecider::SetParkingSpotEndPose(
                                parking_depth_buffer);
     }
   }
-  if (plot_type == ParkingSpaceType::PARALLEL_PLOT) {
+  if (plot_type == ParkingSpaceType::PARALLEL_PARKING) {
     double parllel_park_end_x_buffer =
         config_.open_space_roi_decider_config().parallel_park_end_x_buffer();
     parking_spot_heading = (left_down - right_down).Angle();
</diff>
			</file>
			<file old_path="modules\task_manager\parking_routing_manager.cc" new_path="modules\task_manager\parking_routing_manager.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -85,8 +85,8 @@ bool ParkingRoutingManager::RoadWidthVerification(
         const ParkingRoutingTask&amp; parking_routing_task) {
     const auto&amp; vehicle_config =
       common::VehicleConfigHelper::Instance()-&gt;GetConfig();
-    double ego_width = vehicle_config.vehicle_param().width();
-    double road_width = parking_routing_task.lane_width();
+    const double ego_width = vehicle_config.vehicle_param().width();
+    const double road_width = parking_routing_task.lane_width();
     if (!has_space_ || !has_space_id_) {
         AERROR &lt;&lt; "No Valid park plot exits!";
         return false;
</diff>
			</file>
			<file old_path="modules\task_manager\parking_routing_manager.h" new_path="modules\task_manager\parking_routing_manager.h" added_lines="1" deleted_lines="1">
				<diff>@@ -41,7 +41,7 @@ class ParkingRoutingManager {
                       parking_routing_task);
 
   /**
-   * @brief check if the size of vehicle is smaller than size of plot
+   * @brief check if the size of vehicle is smaller than size of parking space
    * @return false/true
    */
   bool SizeVerification(const task_manager::ParkingRoutingTask&amp;
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.cc" new_path="modules\task_manager\task_manager_component.cc" added_lines="1" deleted_lines="6">
				<diff>@@ -28,7 +28,6 @@ using apollo::localization::LocalizationEstimate;
 using apollo::routing::RoutingRequest;
 
 bool TaskManagerComponent::Init() {
-  AERROR &lt;&lt; "enter the TaskManagerComponent init";
   TaskManagerConfig task_manager_conf;
   ACHECK(cyber::ComponentBase::GetProtoConfig(&amp;task_manager_conf))
       &lt;&lt; "Unable to load task_manager conf file: "
@@ -48,7 +47,6 @@ bool TaskManagerComponent::Init() {
   cyber::proto::RoleAttributes attr;
   attr.set_channel_name(
       task_manager_conf.topic_config().routing_request_topic());
-  AERROR &lt;&lt; "the channel name is: " &lt;&lt; attr.channel_name();
   auto qos = attr.mutable_qos_profile();
   qos-&gt;set_history(apollo::cyber::proto::QosHistoryPolicy::HISTORY_KEEP_LAST);
   qos-&gt;set_reliability(
@@ -56,17 +54,14 @@ bool TaskManagerComponent::Init() {
   qos-&gt;set_durability(
       apollo::cyber::proto::QosDurabilityPolicy::DURABILITY_TRANSIENT_LOCAL);
   request_writer_ = node_-&gt;CreateWriter&lt;RoutingRequest&gt;(attr);
-  AERROR &lt;&lt; "end the init";
   return true;
 }
 
 bool TaskManagerComponent::Proc(const std::shared_ptr&lt;Task&gt;&amp; task) {
-  AERROR &lt;&lt; "enter the TaskManagerComponent proc";
   task_name_ = task-&gt;task_name();
-  AERROR &lt;&lt; "the task type is: " &lt;&lt; task-&gt;task_type();
   if (task-&gt;task_type() != CYCLE_ROUTING &amp;&amp;
       task-&gt;task_type() != PARKING_ROUTING) {
-    AINFO &lt;&lt; "Task type is not cycle_routing.";
+    AERROR &lt;&lt; "Task type is not cycle_routing.";
     return false;
   }
   if (task-&gt;task_type() == CYCLE_ROUTING) {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e7389d39eca5e015f25fe8b59275b5e4596c9c7f" author="">
		<msg>Dreamview:cherry-pick open space planner parking space to 6.1 (#13551)

* Dreamview:open space planner add parking routing task at dv master

* Dreamview: change parking spot type to parking space type

* Dreamview: modify lint

* Change paraller type</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\common\dreamview_gflags.cc" new_path="modules\dreamview\backend\common\dreamview_gflags.cc" added_lines="4" deleted_lines="0">
				<diff>@@ -108,3 +108,7 @@ DEFINE_string(lidar_calibration_mode, "Lidar-IMU Sensor Calibration",
 
 DEFINE_string(camera_calibration_mode, "Camera-Lidar Sensor Calibration",
               "Name of camera_to_lidar calibration mode.");
+
+DEFINE_double(parking_routing_distance_threshold, 20.0,
+              "For open space planner parking situation: get the routing"
+              "end point based on this threshold.");
</diff>
			</file>
			<file old_path="modules\dreamview\backend\common\dreamview_gflags.h" new_path="modules\dreamview\backend\common\dreamview_gflags.h" added_lines="2" deleted_lines="0">
				<diff>@@ -69,3 +69,5 @@ DECLARE_string(vehicle_calibration_mode);
 DECLARE_string(lidar_calibration_mode);
 
 DECLARE_string(camera_calibration_mode);
+
+DECLARE_double(parking_routing_distance_threshold);
</diff>
			</file>
			<file old_path="modules\dreamview\backend\map\map_service.cc" new_path="modules\dreamview\backend\map\map_service.cc" added_lines="30" deleted_lines="0">
				<diff>@@ -429,6 +429,36 @@ bool MapService::ConstructLaneWayPointWithHeading(
   return true;
 }
 
+bool MapService::ConstructLaneWayPointWithLaneId(
+    const double x, const double y, const std::string id,
+    routing::LaneWaypoint *laneWayPoint) const {
+  LaneInfoConstPtr lane = HDMap()-&gt;GetLaneById(hdmap::MakeMapId(id));
+  if (!lane) {
+    return false;
+  }
+
+  if (!CheckRoutingPointLaneType(lane)) {
+    return false;
+  }
+
+  double s, l;
+  PointENU point;
+  point.set_x(x);
+  point.set_y(y);
+
+  if (!lane-&gt;GetProjection({point.x(), point.y()}, &amp;s, &amp;l)) {
+    return false;
+  }
+
+  laneWayPoint-&gt;set_id(id);
+  laneWayPoint-&gt;set_s(s);
+  auto *pose = laneWayPoint-&gt;mutable_pose();
+  pose-&gt;set_x(x);
+  pose-&gt;set_y(y);
+
+  return true;
+}
+
 bool MapService::CheckRoutingPoint(const double x, const double y) const {
   double s, l;
   LaneInfoConstPtr lane;
</diff>
			</file>
			<file old_path="modules\dreamview\backend\map\map_service.h" new_path="modules\dreamview\backend\map\map_service.h" added_lines="7" deleted_lines="1">
				<diff>@@ -26,9 +26,11 @@
 #include &lt;boost/thread/locks.hpp&gt;
 #include &lt;boost/thread/shared_mutex.hpp&gt;
 
+#include "nlohmann/json.hpp"
+
 #include "modules/dreamview/proto/simulation_world.pb.h"
+
 #include "modules/map/pnc_map/pnc_map.h"
-#include "nlohmann/json.hpp"
 
 /**
  * @namespace apollo::dreamview
@@ -76,6 +78,10 @@ class MapService {
       const double x, const double y, const double heading,
       routing::LaneWaypoint *laneWayPoint) const;
 
+  bool ConstructLaneWayPointWithLaneId(
+      const double x, const double y, const std::string id,
+      routing::LaneWaypoint *laneWayPoint) const;
+
   bool CheckRoutingPoint(const double x, const double y) const;
 
   bool CheckRoutingPointLaneType(apollo::hdmap::LaneInfoConstPtr lane) const;
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_service.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_service.cc" added_lines="1" deleted_lines="2">
				<diff>@@ -545,8 +545,7 @@ void SimulationWorldService::UpdateSimulationWorld(const Chassis &amp;chassis) {
 
   auto_driving_car-&gt;set_disengage_type(DeduceDisengageType(chassis));
 
-  auto_driving_car-&gt;set_battery_percentage(
-    chassis.battery_soc_percentage());
+  auto_driving_car-&gt;set_battery_percentage(chassis.battery_soc_percentage());
   auto_driving_car-&gt;set_gear_location(chassis.gear_location());
 }
 
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_service_test.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_service_test.cc" added_lines="0" deleted_lines="1">
				<diff>@@ -23,7 +23,6 @@
 #include "modules/common/adapters/adapter_gflags.h"
 #include "modules/common/configs/vehicle_config_helper.h"
 #include "modules/common/math/quaternion.h"
-
 #include "modules/dreamview/backend/common/dreamview_gflags.h"
 
 using apollo::canbus::Chassis;
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" added_lines="86" deleted_lines="1">
				<diff>@@ -38,6 +38,7 @@ using apollo::hdmap::EndWayPointFile;
 using apollo::relative_map::NavigationInfo;
 using apollo::routing::RoutingRequest;
 using apollo::task_manager::CycleRoutingTask;
+using apollo::task_manager::ParkingRoutingTask;
 using apollo::task_manager::Task;
 
 using Json = nlohmann::json;
@@ -193,6 +194,37 @@ void SimulationWorldUpdater::RegisterMessageHandlers() {
         }
       });
 
+  websocket_-&gt;RegisterMessageHandler(
+      "SendParkingRoutingRequest",
+      [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
+        auto task = std::make_shared&lt;Task&gt;();
+        auto *parking_routing_task = task-&gt;mutable_parking_routing_task();
+        bool succeed = ConstructParkingRoutingTask(json, parking_routing_task);
+        // For test routing
+        auto routing_request = std::make_shared&lt;RoutingRequest&gt;();
+        bool suc = ConstructRoutingRequest(json, routing_request.get());
+        if (suc) {
+          sim_world_service_.PublishRoutingRequest(routing_request);
+          sim_world_service_.PublishMonitorMessage(MonitorMessageItem::INFO,
+                                                   "Routing request sent.");
+        } else {
+          sim_world_service_.PublishMonitorMessage(
+              MonitorMessageItem::ERROR, "Failed to send a routing request.");
+        }
+        if (succeed) {
+          task-&gt;set_task_name("parking_routing_task");
+          task-&gt;set_task_type(apollo::task_manager::TaskType::PARKING_ROUTING);
+          sim_world_service_.PublishTask(task);
+          AINFO &lt;&lt; task-&gt;DebugString();
+          sim_world_service_.PublishMonitorMessage(
+              MonitorMessageItem::INFO, "parking routing task sent.");
+        } else {
+          sim_world_service_.PublishMonitorMessage(
+              MonitorMessageItem::ERROR,
+              "Failed to send a parking routing task to task manager module.");
+        }
+      });
+
   websocket_-&gt;RegisterMessageHandler(
       "RequestSimulationWorld",
       [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
@@ -345,6 +377,15 @@ void SimulationWorldUpdater::RegisterMessageHandlers() {
         }
       });
 
+  websocket_-&gt;RegisterMessageHandler(
+      "GetParkingRoutingDistance",
+      [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
+        Json response;
+        response["type"] = "ParkingRoutingDistance";
+        response["threshold"] = FLAGS_parking_routing_distance_threshold;
+        websocket_-&gt;SendData(conn, response.dump());
+      });
+
   websocket_-&gt;RegisterMessageHandler(
       "RequestPreprocessProgress",
       [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
@@ -473,11 +514,20 @@ bool SimulationWorldUpdater::ConstructRoutingRequest(
     AERROR &lt;&lt; "Failed to prepare a routing request: invalid end point.";
     return false;
   }
-  if (!map_service_-&gt;ConstructLaneWayPoint(end["x"], end["y"],
+  if (ContainsKey(end, "id")) {
+    if (!map_service_-&gt;ConstructLaneWayPointWithLaneId(
+            end["x"], end["y"], end["id"], routing_request-&gt;add_waypoint())) {
+      AERROR &lt;&lt; "Failed to prepare a routing request with lane id: "
+             &lt;&lt; end["id"] &lt;&lt; " cannot locate end point on map.";
+      return false;
+    }
+  } else {
+    if (!map_service_-&gt;ConstructLaneWayPoint(end["x"], end["y"],
                                            routing_request-&gt;add_waypoint())) {
     AERROR &lt;&lt; "Failed to prepare a routing request:"
            &lt;&lt; " cannot locate end point on map.";
     return false;
+    }
   }
 
   // set parking info
@@ -489,6 +539,23 @@ bool SimulationWorldUpdater::ConstructRoutingRequest(
              &lt;&lt; json["parkingInfo"].dump();
       return false;
     }
+    if (ContainsKey(json, "cornerPoints")) {
+      auto point_iter = json.find("cornerPoints");
+      auto *points =
+          requested_parking_info-&gt;mutable_corner_point()-&gt;mutable_point();
+      if (point_iter != json.end() &amp;&amp; point_iter-&gt;is_array()) {
+        for (size_t i = 0; i &lt; point_iter-&gt;size(); ++i) {
+          auto &amp;point = (*point_iter)[i];
+          auto *p = points-&gt;Add();
+          if (!ValidateCoordinate(point)) {
+            AERROR &lt;&lt; "Failed to add a corner point: invalid corner point.";
+            return false;
+          }
+          p-&gt;set_x(static_cast&lt;double&gt;(point["x"]));
+          p-&gt;set_y(static_cast&lt;double&gt;(point["y"]));
+        }
+      }
+    }
   }
 
   AINFO &lt;&lt; "Constructed RoutingRequest to be sent:\n"
@@ -497,6 +564,24 @@ bool SimulationWorldUpdater::ConstructRoutingRequest(
   return true;
 }
 
+bool SimulationWorldUpdater::ConstructParkingRoutingTask(
+    const Json &amp;json, ParkingRoutingTask *parking_routing_task) {
+  auto *routing_request = parking_routing_task-&gt;mutable_routing_request();
+  // set parking Space
+  if (!ContainsKey(json, "laneWidth")) {
+    AERROR &lt;&lt; "Failed to prepare a parking routing task: "
+           &lt;&lt; "lane width not found.";
+    return false;
+  }
+  bool succeed = ConstructRoutingRequest(json, routing_request);
+  if (succeed) {
+    parking_routing_task-&gt;set_lane_width(
+        static_cast&lt;double&gt;(json["laneWidth"]));
+    return true;
+  }
+  return false;
+}
+
 bool SimulationWorldUpdater::ValidateCoordinate(const nlohmann::json &amp;json) {
   if (!ContainsKey(json, "x") || !ContainsKey(json, "y")) {
     AERROR &lt;&lt; "Failed to find x or y coordinate.";
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_updater.h" new_path="modules\dreamview\backend\simulation_world\simulation_world_updater.h" added_lines="11" deleted_lines="0">
				<diff>@@ -98,6 +98,17 @@ class SimulationWorldUpdater {
       const nlohmann::json &amp;json,
       apollo::routing::RoutingRequest *routing_request);
 
+  /**
+   * @brief The function to construct a parking routing task from the given
+   * json,
+   * @param json that contains start, end, waypoint, parking info, lane width,
+   * @param parking_routing_task
+   * @return True if parking routing task is constructed successfully
+   */
+  bool ConstructParkingRoutingTask(
+      const nlohmann::json &amp;json,
+      apollo::task_manager::ParkingRoutingTask *parking_routing_task);
+
   bool ValidateCoordinate(const nlohmann::json &amp;json);
 
   /**
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -1295,7 +1295,7 @@ bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
   Vec2d left_down = target_parking_spot-&gt;polygon().points().at(0);
   Vec2d right_down = target_parking_spot-&gt;polygon().points().at(1);
   Vec2d right_top = target_parking_spot-&gt;polygon().points().at(2);
-  if (plot_type == ParkingSpaceType::PARALLEL_PLOT) {
+  if (plot_type == ParkingSpaceType::PARALLEL_PARKING) {
     const auto &amp;routing_request =
       frame-&gt;local_view().routing-&gt;routing_request();
     auto corner_point =
</diff>
			</file>
			<file old_path="modules\task_manager\parking_routing_manager.cc" new_path="modules\task_manager\parking_routing_manager.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -71,7 +71,7 @@ bool ParkingRoutingManager::SizeVerification(
             AERROR &lt;&lt; "The veritical plot is small";
             return false;
         }
-    } else if (plot_type == ParkingSpaceType::PARALLEL_PLOT) {
+    } else if (plot_type == ParkingSpaceType::PARALLEL_PARKING) {
         if (width + FLAGS_plot_size_buffer &lt; ego_length ||
             length + FLAGS_plot_size_buffer &lt; ego_width) {
             AERROR &lt;&lt; "The parallel plot is small";
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a63f6fd516e0a026662f5f13024e69117ab4593c" author="SeasoulChris">
		<msg>update the param of planning and control (#13568)</msg>
		<modified_files>
			<file old_path="modules\calibration\data\dev_kit\planning_conf\planning.conf" new_path="modules\calibration\data\dev_kit\planning_conf\planning.conf" added_lines="1" deleted_lines="1">
				<diff>@@ -29,7 +29,7 @@
 # --use_dual_variable_warm_start=true
 # --enable_open_space_planner_thread=true
 # --enable_record_debug=true
-# --use_gear_shift_trajectory=true
+--use_gear_shift_trajectory=true
 # --enable_parallel_hybrid_a=true
 --export_chart=true
 
</diff>
			</file>
			<file old_path="modules\planning\conf\planning.conf" new_path="modules\planning\conf\planning.conf" added_lines="1" deleted_lines="1">
				<diff>@@ -20,7 +20,7 @@
 # --use_dual_variable_warm_start=true
 # --enable_open_space_planner_thread=true
 # --enable_record_debug=true
-# --use_gear_shift_trajectory=true
+--use_gear_shift_trajectory=true
 # --enable_parallel_hybrid_a=true
 --export_chart=true
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="083bc77067a6553f987d929dc04cf78ad1e77705" author="">
		<msg>Modify name bug (#13570)</msg>
		<modified_files>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -215,7 +215,7 @@ void OpenSpaceRoiDecider::SetParkingSpotEndPose(
     Frame *const frame, const std::array&lt;common::math::Vec2d, 4&gt; &amp;vertices) {
   const auto &amp;routing_request =
         frame-&gt;local_view().routing-&gt;routing_request();
-  auto plot_type = routing_request.parking_info().parking_spot_type();
+  auto plot_type = routing_request.parking_info().parking_space_type();
   auto left_top = vertices[0];
   auto left_down = vertices[1];
   auto right_down = vertices[2];
@@ -1202,7 +1202,7 @@ bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
                                          Path *nearby_path) {
   const auto &amp;routing_request =
         frame-&gt;local_view().routing-&gt;routing_request();
-  auto plot_type = routing_request.parking_info().parking_spot_type();
+  auto plot_type = routing_request.parking_info().parking_space_type();
   if (frame == nullptr) {
     AERROR &lt;&lt; "Invalid frame, fail to GetParkingSpotFromMap from frame. ";
     return false;
</diff>
			</file>
			<file old_path="modules\task_manager\parking_routing_manager.cc" new_path="modules\task_manager\parking_routing_manager.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -42,7 +42,7 @@ common::Status ParkingRoutingManager::Init(
 bool ParkingRoutingManager::SizeVerification(
         const ParkingRoutingTask&amp; parking_routing_task) {
     auto plot_type =
-      parking_routing_task.routing_request().parking_info().parking_spot_type();
+      parking_routing_task.routing_request().parking_info().parking_space_type();
     const auto&amp; vehicle_config =
       common::VehicleConfigHelper::Instance()-&gt;GetConfig();
     double ego_length = vehicle_config.vehicle_param().length();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="767356c439a122056461020e82f3b51f75c3b15f" author="xiaoMrzhang">
		<msg>Perception: empty torch cache during model inference</msg>
		<modified_files>
			<file old_path="modules\perception\camera\lib\obstacle\transformer\singlestage\singlestage_obstacle_transformer.cc" new_path="modules\perception\camera\lib\obstacle\transformer\singlestage\singlestage_obstacle_transformer.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -250,7 +250,7 @@ float SingleStageObstacleTransformer::CenterPointFromBbox(const float *bbox,
     return false;
   }
 
-  float f = k_mat[4] / 2;
+  float f = (k_mat[0] + k_mat[4]) / 2;
   float depth = f * hwl[0] * common::IRec(height_bbox);
 
   // Compensate from the nearest vertical edge to center
</diff>
			</file>
			<file old_path="modules\perception\inference\onnx\libtorch_obstacle_detector.cc" new_path="modules\perception\inference\onnx\libtorch_obstacle_detector.cc" added_lines="14" deleted_lines="4">
				<diff>@@ -16,6 +16,8 @@
 
 #include "modules/perception/inference/onnx/libtorch_obstacle_detector.h"
 
+#include &lt;c10/cuda/CUDACachingAllocator.h&gt;
+
 #include "cyber/common/log.h"
 
 namespace apollo {
@@ -40,6 +42,8 @@ bool ObstacleDetector::Init(const std::map&lt;std::string,
     device_type_ = torch::kCPU;
   }
 
+  // Load model without grad, equal to torch.no_grad()
+  // torch::NoGradGuard no_grad;
   // Init net
   torch::Device device(device_type_, device_id_);
   net_ = torch::jit::load(model_file_, device);
@@ -76,6 +80,7 @@ bool ObstacleDetector::Init(const std::map&lt;std::string,
       blobs_.emplace(name, blob);
     }
   }
+  c10::cuda::CUDACachingAllocator::emptyCache();
   return true;
 }
 
@@ -129,11 +134,16 @@ void ObstacleDetector::Infer() {
 
   AINFO &lt;&lt; "Start to do inference";
   auto outputs = net_.forward(torch_inputs).toTuple()-&gt;elements();
-  auto results = outputs[0].toTensor();
-  auto feat_map = outputs[1].toTensor();
   AINFO &lt;&lt; "Finished inference";
-  blobs_[output_names_[0]]-&gt;data()-&gt;set_gpu_data(results.data_ptr());
-  blobs_[output_names_[1]]-&gt;data()-&gt;set_gpu_data(feat_map.data_ptr());
+
+  for (u_int i = 0; i &lt; output_names_.size(); i++) {
+    torch::Tensor output_tensor = outputs[i].toTensor();
+    std::vector&lt;int64_t&gt; output_size_ = output_tensor.sizes().vec();
+    std::vector&lt;int&gt; output_size(begin(output_size_), end(output_size_));
+    blobs_[output_names_[i]]-&gt;Reshape(output_size);
+    blobs_[output_names_[i]]-&gt;set_gpu_data(output_tensor.data_ptr&lt;float&gt;());
+  }
+  c10::cuda::CUDACachingAllocator::emptyCache();
 }
 
 }  // namespace inference
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="dbb29384831eb6514ffbe279dd45cb4cee2a76e8" author="Yiqun Fu">
		<msg>task_manager: no need to restart task_manager (#13584)</msg>
		<modified_files>
			<file old_path="modules\task_manager\cycle_routing_manager.cc" new_path="modules\task_manager\cycle_routing_manager.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -58,7 +58,7 @@ bool CycleRoutingManager::GetNewRouting(
   if (is_allowed_to_route_) {
     if (CheckPointDistanceInThreshold(begin_point_.pose(), pose.position(),
                                       FLAGS_threshold_for_destination_check)) {
-      AINFO &lt;&lt; "GetNewRouting: reach begin point"
+      AINFO &lt;&lt; "GetNewRouting: reach begin point."
             &lt;&lt; "Remaining cycles: " &lt;&lt; cycle_;
       new_routing_request-&gt;CopyFrom(original_routing_request_);
       auto cur_point = new_routing_request-&gt;mutable_waypoint(0);
@@ -74,7 +74,7 @@ bool CycleRoutingManager::GetNewRouting(
   } else {
     if (CheckPointDistanceInThreshold(end_point_.pose(), pose.position(),
                                       FLAGS_threshold_for_destination_check)) {
-      AINFO &lt;&lt; "GetNewRouting: reach end point"
+      AINFO &lt;&lt; "GetNewRouting: reach end point. "
             &lt;&lt; "Remaining cycles: " &lt;&lt; cycle_;
       new_routing_request-&gt;clear_waypoint();
       auto cur_point = new_routing_request-&gt;add_waypoint();
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.cc" new_path="modules\task_manager\task_manager_component.cc" added_lines="30" deleted_lines="5">
				<diff>@@ -26,6 +26,7 @@ using apollo::cyber::ComponentBase;
 using apollo::cyber::Rate;
 using apollo::localization::LocalizationEstimate;
 using apollo::routing::RoutingRequest;
+using apollo::routing::RoutingResponse;
 
 bool TaskManagerComponent::Init() {
   TaskManagerConfig task_manager_conf;
@@ -44,6 +45,14 @@ bool TaskManagerComponent::Init() {
         localization_.CopyFrom(*localization);
       });
 
+  response_reader_ = node_-&gt;CreateReader&lt;RoutingResponse&gt;(
+      task_manager_conf.topic_config().routing_response_topic(),
+      [this](const std::shared_ptr&lt;RoutingResponse&gt;&amp; response) {
+        ADEBUG &lt;&lt; "Received routing_response data: run response callback.";
+        std::lock_guard&lt;std::mutex&gt; lock(mutex_);
+        routing_response_.CopyFrom(*response);
+      });
+
   cyber::proto::RoleAttributes attr;
   attr.set_channel_name(
       task_manager_conf.topic_config().routing_request_topic());
@@ -61,9 +70,10 @@ bool TaskManagerComponent::Proc(const std::shared_ptr&lt;Task&gt;&amp; task) {
   task_name_ = task-&gt;task_name();
   if (task-&gt;task_type() != CYCLE_ROUTING &amp;&amp;
       task-&gt;task_type() != PARKING_ROUTING) {
-    AERROR &lt;&lt; "Task type is not cycle_routing.";
+    AERROR &lt;&lt; "Task type is not cycle_routing or parking_routing.";
     return false;
   }
+
   if (task-&gt;task_type() == CYCLE_ROUTING) {
     cycle_routing_manager_ = std::make_shared&lt;CycleRoutingManager&gt;();
     cycle_routing_manager_-&gt;Init(task-&gt;cycle_routing_task());
@@ -73,10 +83,25 @@ bool TaskManagerComponent::Proc(const std::shared_ptr&lt;Task&gt;&amp; task) {
     while (cycle_routing_manager_-&gt;GetCycle() &gt; 0) {
       if (cycle_routing_manager_-&gt;GetNewRouting(localization_.pose(),
                                                 &amp;routing_request_)) {
+        auto last_routing_response_ = routing_response_;
         common::util::FillHeader(node_-&gt;Name(), &amp;routing_request_);
         request_writer_-&gt;Write(routing_request_);
         AINFO &lt;&lt; "[TaskManagerComponent]Reach begin/end point: "
               &lt;&lt; "routing manager send a routing request. ";
+        rate.Sleep();
+
+        if (!routing_response_.has_header()) {
+          AINFO &lt;&lt; "[TaskManagerComponent]routing failed";
+          return false;
+        }
+        if (last_routing_response_.has_header()) {
+          if (last_routing_response_.header().sequence_num() ==
+              routing_response_.header().sequence_num()) {
+            AINFO &lt;&lt; "[TaskManagerComponent]No routing response: "
+                  &lt;&lt; "new routing failed";
+            return false;
+          }
+        }
       }
       rate.Sleep();
     }
@@ -85,10 +110,10 @@ bool TaskManagerComponent::Proc(const std::shared_ptr&lt;Task&gt;&amp; task) {
     parking_routing_manager_ = std::make_shared&lt;ParkingRoutingManager&gt;();
     parking_routing_manager_-&gt;Init(task-&gt;parking_routing_task());
     routing_request_ = task-&gt;parking_routing_task().routing_request();
-    if (parking_routing_manager_-&gt;
-        SizeVerification(task-&gt;parking_routing_task()) &amp;&amp;
-        parking_routing_manager_-&gt;
-        RoadWidthVerification(task-&gt;parking_routing_task())) {
+    if (parking_routing_manager_-&gt;SizeVerification(
+            task-&gt;parking_routing_task()) &amp;&amp;
+        parking_routing_manager_-&gt;RoadWidthVerification(
+            task-&gt;parking_routing_task())) {
       AERROR &lt;&lt; "compelet the Verification";
       common::util::FillHeader(node_-&gt;Name(), &amp;routing_request_);
       request_writer_-&gt;Write(routing_request_);
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.h" new_path="modules\task_manager\task_manager_component.h" added_lines="2" deleted_lines="0">
				<diff>@@ -39,10 +39,12 @@ class TaskManagerComponent final : public cyber::Component&lt;task_manager::Task&gt; {
 
  private:
   std::shared_ptr&lt;cyber::Reader&lt;LocalizationEstimate&gt;&gt; localization_reader_;
+  std::shared_ptr&lt;cyber::Reader&lt;routing::RoutingResponse&gt;&gt; response_reader_;
   std::shared_ptr&lt;cyber::Writer&lt;routing::RoutingRequest&gt;&gt; request_writer_;
   std::shared_ptr&lt;CycleRoutingManager&gt; cycle_routing_manager_;
   std::shared_ptr&lt;ParkingRoutingManager&gt; parking_routing_manager_;
   routing::RoutingRequest routing_request_;
+  routing::RoutingResponse routing_response_;
   LocalizationEstimate localization_;
   std::mutex mutex_;
   std::string task_name_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="228c5c1283b8d8ffd1762055bbfa4ac8f7835a11" author="xiaoluauto">
		<msg>planning: add functiong to show parking_space size check info (#13587)</msg>
		<modified_files>
			<file old_path="modules\task_manager\conf\task_manager.conf" new_path="modules\task_manager\conf\task_manager.conf" added_lines="2" deleted_lines="0">
				<diff>@@ -1,4 +1,4 @@
 --flagfile=/apollo/modules/common/data/global_flagfile.txt
 --threshold_for_destination_check=10.0
---plot_size_buffer=0.9
---road_width_buffer=0.0
\ No newline at end of file
+--plot_size_buffer=0.2
+--road_width_buffer=0.0
</diff>
			</file>
			<file old_path="modules\task_manager\parking_routing_manager.cc" new_path="modules\task_manager\parking_routing_manager.cc" added_lines="10" deleted_lines="4">
				<diff>@@ -28,6 +28,10 @@ using apollo::common::PointENU;
 using apollo::hdmap::ParkingSpaceInfoConstPtr;
 using apollo::routing::ParkingSpaceType;
 
+ParkingRoutingManager::ParkingRoutingManager()
+: monitor_logger_buffer_(apollo::common::monitor::
+                         MonitorMessageItem::TASK_MANAGER) {}
+
 common::Status ParkingRoutingManager::Init(
         const ParkingRoutingTask&amp; parking_routing_task) {
     // get the message form routing
@@ -66,14 +70,16 @@ bool ParkingRoutingManager::SizeVerification(
                         (right_bottom_point.y() - left_bottom_point.y()));
     // judge by spot type
     if (plot_type == ParkingSpaceType::VERTICAL_PLOT) {
-        if (length + FLAGS_plot_size_buffer &lt; ego_length ||
-            width + FLAGS_plot_size_buffer &lt; ego_width) {
+        if (length - FLAGS_plot_size_buffer &lt; ego_length ||
+            width - FLAGS_plot_size_buffer &lt; ego_width) {
+            monitor_logger_buffer_.WARN("veritical plot is not suit!");
             AERROR &lt;&lt; "The veritical plot is small";
             return false;
         }
     } else if (plot_type == ParkingSpaceType::PARALLEL_PARKING) {
-        if (width + FLAGS_plot_size_buffer &lt; ego_length ||
-            length + FLAGS_plot_size_buffer &lt; ego_width) {
+        if (width - FLAGS_plot_size_buffer &lt; ego_length ||
+            length - FLAGS_plot_size_buffer &lt; ego_width) {
+            monitor_logger_buffer_.WARN("parallel plot is not suit!");
             AERROR &lt;&lt; "The parallel plot is small";
             return false;
         }
</diff>
			</file>
			<file old_path="modules\task_manager\parking_routing_manager.h" new_path="modules\task_manager\parking_routing_manager.h" added_lines="2" deleted_lines="2">
				<diff>@@ -31,8 +31,7 @@ namespace task_manager {
 
 class ParkingRoutingManager {
  public:
-  ParkingRoutingManager() = default;
-
+  ParkingRoutingManager();
   /**
    * @brief module initialization function
    * @return initialization status
@@ -63,6 +62,7 @@ class ParkingRoutingManager {
   bool has_space_ = false;
   bool has_space_id_ = false;
   std::string id_ = "";
+  apollo::common::monitor::MonitorLogBuffer monitor_logger_buffer_;
 };
 
 }  // namespace task_manager
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.cc" new_path="modules\task_manager\task_manager_component.cc" added_lines="14" deleted_lines="0">
				<diff>@@ -119,7 +119,21 @@ bool TaskManagerComponent::Proc(const std::shared_ptr&lt;Task&gt;&amp; task) {
       request_writer_-&gt;Write(routing_request_);
       AINFO &lt;&lt; "send a auto parking task";
     } else {
+      auto last_routing_response_ = routing_response_;
+      if (!routing_response_.has_header()) {
+           AINFO &lt;&lt; "[TaskManagerComponent]parking routing failed";
+           return false;
+         }
+         if (last_routing_response_.has_header()) {
+           if (last_routing_response_.header().sequence_num() ==
+               routing_response_.header().sequence_num()) {
+             AINFO &lt;&lt; "[TaskManagerComponent]No parking routing response: "
+                   &lt;&lt; "new parking routing failed";
+             return false;
+           }
+         }
       AERROR &lt;&lt; "plot verification failed, please select suitable plot!";
+      return false;
     }
   }
   return true;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4b01eee1c260d2e70dbaa05598b703d521bb1642" author="Chao Ma">
		<msg>canbus: modify the d-kit lite chassis engage advice (#13547)</msg>
		<modified_files>
			<file old_path="modules\canbus\vehicle\ch\ch_controller.cc" new_path="modules\canbus\vehicle\ch\ch_controller.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -236,16 +236,16 @@ Chassis ChController::chassis() {
   if (chassis_detail.has_surround()) {
     chassis_.mutable_surround()-&gt;CopyFrom(chassis_detail.surround());
   }
+
   // give engage_advice based on error_code and canbus feedback
-  if (!chassis_error_mask_ &amp;&amp; !chassis_.parking_brake() &amp;&amp;
-      (chassis_.throttle_percentage() == 0.0)) {
+  if (!chassis_error_mask_ &amp;&amp; (chassis_.throttle_percentage() == 0.0)) {
     chassis_.mutable_engage_advice()-&gt;set_advice(
         apollo::common::EngageAdvice::READY_TO_ENGAGE);
   } else {
     chassis_.mutable_engage_advice()-&gt;set_advice(
         apollo::common::EngageAdvice::DISALLOW_ENGAGE);
     chassis_.mutable_engage_advice()-&gt;set_reason(
-        "CANBUS not ready, firmware error or emergency button pressed!");
+        "CANBUS not ready, throttle percentage is not zero!");
   }
 
   // 27 battery soc
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="81b8664f4cb16c5fd19b737caf221620cc3fe644" author="fuxiangyu">
		<msg>Localization: limit level to pass security check</msg>
		<modified_files>
			<file old_path="modules\localization\msf\local_tool\local_visualization\engine\visualization_engine.cc" new_path="modules\localization\msf\local_tool\local_visualization\engine\visualization_engine.cc" added_lines="4" deleted_lines="0">
				<diff>@@ -695,6 +695,10 @@ bool VisualizationEngine::InitOtherParams(const std::string &amp;params_file) {
   inf &gt;&gt; x_min &gt;&gt; y_min &gt;&gt; x_max &gt;&gt; y_max &gt;&gt; level &gt;&gt; path;
   inf.close();
 
+  if (level &gt; 5) {
+    level = 5;
+  }
+
   InitOtherParams(x_min, y_min, x_max, y_max, level, path);
 
   return true;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="abf6d99a23a992f63a5d90a8cefbe04b27cff939" author="Jiahao Chen (Jerold)">
		<msg>Perception: fix Thrust bug by using CPU (#13620)</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\postprocess_cuda.cu" new_path="modules\perception\lidar\lib\detection\lidar_point_pillars\postprocess_cuda.cu" added_lines="21" deleted_lines="5">
				<diff>@@ -31,6 +31,8 @@
  */
 
 // headers in CUDA
+#include &lt;thrust/device_ptr.h&gt;
+#include &lt;thrust/host_vector.h&gt;
 #include &lt;thrust/sort.h&gt;
 
 // headers in local files
@@ -245,11 +247,25 @@ void PostprocessCuda::DoPostprocessCuda(
   GPU_CHECK(
       cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_sorted_box_for_nms),
                  num_box_corners_ * host_filter_count[0] * sizeof(float)));
-  thrust::sequence(thrust::device, dev_indexes,
-                   dev_indexes + host_filter_count[0]);
-  thrust::sort_by_key(thrust::device, dev_filtered_score,
-                      dev_filtered_score + size_t(host_filter_count[0]),
-                      dev_indexes, thrust::greater&lt;float&gt;());
+
+  thrust::device_ptr&lt;float&gt; dev_ptr_filtered_score(dev_filtered_score);
+  thrust::host_vector&lt;float&gt; host_filtered_score(host_filter_count[0]);
+  thrust::copy(dev_ptr_filtered_score,
+               dev_ptr_filtered_score + size_t(host_filter_count[0]),
+               host_filtered_score.begin());
+
+  thrust::host_vector&lt;int&gt; host_indexes(host_filter_count[0]);
+  thrust::sequence(host_indexes.begin(), host_indexes.end());
+
+  // TODO(chenjiahao): using GPU may cause crash, so use CPU here to sort,
+  //  temporarily. Will change to GPU after upgrading CUDA in the future.
+  thrust::sort_by_key(host_filtered_score.begin(),
+                      host_filtered_score.end(),
+                      host_indexes.begin(), thrust::greater&lt;float&gt;());
+  GPU_CHECK(cudaMemcpy(dev_indexes,
+                       thrust::raw_pointer_cast(host_indexes.data()),
+                       host_filter_count[0] * sizeof(int),
+                       cudaMemcpyHostToDevice));
 
   const int num_blocks = DIVUP(host_filter_count[0], num_threads_);
   sort_boxes_by_indexes_kernel&lt;&lt;&lt;num_blocks, num_threads_&gt;&gt;&gt;(
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="af69c59514d0539d8ac7859c394b108d1999dc8b" author="liouyx">
		<msg>Planning: add lane borrow check: DOUBLE_YELLOW</msg>
		<modified_files>
			<file old_path="modules\planning\tasks\deciders\path_lane_borrow_decider\path_lane_borrow_decider.cc" new_path="modules\planning\tasks\deciders\path_lane_borrow_decider\path_lane_borrow_decider.cc" added_lines="1" deleted_lines="0">
				<diff>@@ -291,6 +291,7 @@ void PathLaneBorrowDecider::CheckLaneBorrow(
     if (*left_neighbor_lane_borrowable) {
       lane_boundary_type = hdmap::LeftBoundaryType(waypoint);
       if (lane_boundary_type == hdmap::LaneBoundaryType::SOLID_YELLOW ||
+          lane_boundary_type == hdmap::LaneBoundaryType::DOUBLE_YELLOW ||
           lane_boundary_type == hdmap::LaneBoundaryType::SOLID_WHITE) {
         *left_neighbor_lane_borrowable = false;
       }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3581e0466cb2ff82d1901f4d0ef0db99da0ef464" author="storypku">
		<msg>Bridge: handle cases where buf_size may &lt; 0</msg>
		<modified_files>
			<file old_path="modules\bridge\udp_bridge_multi_receiver_component.cc" new_path="modules\bridge\udp_bridge_multi_receiver_component.cc" added_lines="13" deleted_lines="18">
				<diff>@@ -113,40 +113,35 @@ bool UDPBridgeMultiReceiverComponent::IsTimeout(double time_stamp) {
 bool UDPBridgeMultiReceiverComponent::MsgHandle(int fd) {
   struct sockaddr_in client_addr;
   socklen_t sock_len = static_cast&lt;socklen_t&gt;(sizeof(client_addr));
-  int bytes = 0;
   int total_recv = 2 * FRAME_SIZE;
   char total_buf[2 * FRAME_SIZE] = {0};
-  bytes =
+  int bytes =
       static_cast&lt;int&gt;(recvfrom(fd, total_buf, total_recv, 0,
                                 (struct sockaddr *)&amp;client_addr, &amp;sock_len));
-  ADEBUG &lt;&lt; "total recv " &lt;&lt; bytes;
   if (bytes &lt;= 0 || bytes &gt; total_recv) {
     return false;
   }
-  char header_flag[sizeof(BRIDGE_HEADER_FLAG) + 1] = {0};
-  size_t offset = 0;
-  memcpy(header_flag, total_buf, HEADER_FLAG_SIZE);
-  if (strcmp(header_flag, BRIDGE_HEADER_FLAG) != 0) {
-    AINFO &lt;&lt; "header flag not match!";
+
+  if (strncmp(total_buf, BRIDGE_HEADER_FLAG, HEADER_FLAG_SIZE) != 0) {
+    AERROR &lt;&lt; "Header flag didn't match!";
     return false;
   }
-  offset += sizeof(BRIDGE_HEADER_FLAG) + 1;
+  size_t offset = HEADER_FLAG_SIZE + 1;
 
-  char header_size_buf[sizeof(hsize) + 1] = {0};
   const char *cursor = total_buf + offset;
-  memcpy(header_size_buf, cursor, sizeof(hsize));
-  hsize header_size = *(reinterpret_cast&lt;hsize *&gt;(header_size_buf));
-  if (header_size &gt; FRAME_SIZE) {
-    AINFO &lt;&lt; "header size is more than FRAME_SIZE!";
+  hsize header_size = *(reinterpret_cast&lt;hsize *&gt;(cursor));
+  offset += sizeof(hsize) + 1;
+
+  if (header_size &lt; offset || header_size &gt; FRAME_SIZE) {
+    AERROR &lt;&lt; "header size is more than FRAME_SIZE!";
     return false;
   }
-  offset += sizeof(hsize) + 1;
 
-  BridgeHeader header;
-  size_t buf_size = header_size - offset;
   cursor = total_buf + offset;
+  size_t buf_size = header_size - offset;
+  BridgeHeader header;
   if (!header.Diserialize(cursor, buf_size)) {
-    AINFO &lt;&lt; "header diserialize failed!";
+    AERROR &lt;&lt; "header diserialize failed!";
     return false;
   }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="82d85668ba55487eeed33987e7b9a97c84d4e245" author="storypku">
		<msg>Infra: resolves security risk for 6.1 release.

Cherry-picked from dev-6.1 branch</msg>
		<modified_files>
			<file old_path="modules\bridge\udp_bridge_multi_receiver_component.cc" new_path="modules\bridge\udp_bridge_multi_receiver_component.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -129,7 +129,7 @@ bool UDPBridgeMultiReceiverComponent::MsgHandle(int fd) {
   size_t offset = HEADER_FLAG_SIZE + 1;
 
   const char *cursor = total_buf + offset;
-  hsize header_size = *(reinterpret_cast&lt;hsize *&gt;(cursor));
+  hsize header_size = *(reinterpret_cast&lt;const hsize *&gt;(cursor));
   offset += sizeof(hsize) + 1;
 
   if (header_size &lt; offset || header_size &gt; FRAME_SIZE) {
</diff>
			</file>
			<file old_path="modules\drivers\lidar\velodyne\driver\driver.cc" new_path="modules\drivers\lidar\velodyne\driver\driver.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -17,6 +17,7 @@
 #include "modules/drivers/lidar/velodyne/driver/driver.h"
 
 #include &lt;cmath&gt;
+#include &lt;cstring&gt;
 #include &lt;ctime&gt;
 #include &lt;string&gt;
 #include &lt;thread&gt;
@@ -64,13 +65,12 @@ bool VelodyneDriver::Init() {
 
 void VelodyneDriver::SetBaseTimeFromNmeaTime(NMEATimePtr nmea_time,
                                              uint64_t* basetime) {
-  tm time;
+  struct tm time;
+  std::memset(&amp;time, 0, sizeof(tm));
   time.tm_year = nmea_time-&gt;year + (2000 - 1900);
   time.tm_mon = nmea_time-&gt;mon - 1;
   time.tm_mday = nmea_time-&gt;day;
   time.tm_hour = nmea_time-&gt;hour;
-  time.tm_min = 0;
-  time.tm_sec = 0;
 
   // set last gps time using gps socket packet
   last_gps_time_ =
</diff>
			</file>
			<file old_path="modules\drivers\lidar\velodyne\parser\calibration.cc" new_path="modules\drivers\lidar\velodyne\parser\calibration.cc" added_lines="6" deleted_lines="0">
				<diff>@@ -35,6 +35,7 @@
 #include &lt;limits&gt;
 #include &lt;string&gt;
 #include &lt;utility&gt;
+
 #include "yaml-cpp/yaml.h"
 
 namespace YAML {
@@ -117,6 +118,11 @@ void operator&gt;&gt;(const YAML::Node&amp; node, Calibration&amp; calibration) {
   calibration.laser_corrections_.clear();
   calibration.num_lasers_ = num_lasers;
 
+  if (static_cast&lt;int&gt;(lasers.size()) != num_lasers) {
+    std::cerr &lt;&lt; "num_lasers didn't match";
+    return;
+  }
+
   for (int i = 0; i &lt; num_lasers; i++) {
     std::pair&lt;int, LaserCorrection&gt; correction;
     lasers[i] &gt;&gt; correction;
</diff>
			</file>
			<file old_path="modules\localization\msf\local_tool\local_visualization\engine\visualization_manager.h" new_path="modules\localization\msf\local_tool\local_visualization\engine\visualization_manager.h" added_lines="9" deleted_lines="9">
				<diff>@@ -45,15 +45,15 @@ struct LidarVisFrame {
 };
 
 struct LocalizationMsg {
-  double timestamp;
-  double x;
-  double y;
-  double z;
-
-  double qx;
-  double qy;
-  double qz;
-  double qw;
+  double timestamp = 0.0;
+  double x = 0;
+  double y = 0;
+  double z = 0;
+
+  double qx = 0.0;
+  double qy = 0.0;
+  double qz = 0.0;
+  double qw = 0.0;
 
   double std_x = 0;
   double std_y = 0;
</diff>
			</file>
			<file old_path="modules\map\tools\map_datachecker\server\channel_verify.h" new_path="modules\map\tools\map_datachecker\server\channel_verify.h" added_lines="2" deleted_lines="1">
				<diff>@@ -23,6 +23,7 @@
 #include &lt;vector&gt;
 
 #include "modules/map/tools/map_datachecker/proto/collection_error_code.pb.h"
+
 #include "modules/map/tools/map_datachecker/server/common.h"
 
 namespace apollo {
@@ -44,7 +45,7 @@ struct CyberRecordInfo {
 
 struct OneRecordChannelCheckResult {
   std::string record_path;
-  uint64_t start_time;
+  uint64_t start_time = 0;
   std::vector&lt;std::string&gt; lack_channels;
   // inadequate_rate: channel_name &lt;---&gt; (expected_rate, actual_rate)
   std::map&lt;std::string, std::pair&lt;double, double&gt;&gt; inadequate_rate;
</diff>
			</file>
			<file old_path="modules\v2x\fusion\libs\common\v2x_object.h" new_path="modules\v2x\fusion\libs\common\v2x_object.h" added_lines="2" deleted_lines="2">
				<diff>@@ -83,8 +83,8 @@ class Info {
   Var Variance() const { return variance_; }
 
  protected:
-  Val value_;
-  Var variance_;
+  Val value_ = {};
+  Var variance_ = {};
 };
 
 class Info3f : public Info&lt;Eigen::Vector3f, Eigen::Matrix3f&gt; {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="426452e0aded5855c4be50ed009fc9e910ce5b5c" author="storypku">
		<msg>Planning: resolve security risks</msg>
		<modified_files>
			<file old_path="modules\planning\open_space\coarse_trajectory_generator\hybrid_a_star.cc" new_path="modules\planning\open_space\coarse_trajectory_generator\hybrid_a_star.cc" added_lines="7" deleted_lines="1">
				<diff>@@ -20,6 +20,8 @@
 
 #include "modules/planning/open_space/coarse_trajectory_generator/hybrid_a_star.h"
 
+#include &lt;limits&gt;
+
 #include "modules/planning/math/piecewise_jerk/piecewise_jerk_speed_problem.h"
 
 namespace apollo {
@@ -403,7 +405,11 @@ bool HybridAStar::GenerateSCurveSpeedAcceleration(HybridAStartResult* result) {
                                               path_length * max_reverse_acc) /
                                              (max_reverse_acc * max_reverse_v),
                                   10.0);
-
+  if (total_t + delta_t &gt;= delta_t * std::numeric_limits&lt;size_t&gt;::max()) {
+    AERROR &lt;&lt; "Number of knots overflow. total_t: " &lt;&lt; total_t
+           &lt;&lt; ", delta_t: " &lt;&lt; delta_t;
+    return false;
+  }
   const size_t num_of_knots = static_cast&lt;size_t&gt;(total_t / delta_t) + 1;
 
   PiecewiseJerkSpeedProblem piecewise_jerk_problem(
</diff>
			</file>
			<file old_path="modules\planning\open_space\trajectory_smoother\iterative_anchoring_smoother.cc" new_path="modules\planning\open_space\trajectory_smoother\iterative_anchoring_smoother.cc" added_lines="7" deleted_lines="1">
				<diff>@@ -626,7 +626,13 @@ bool IterativeAnchoringSmoother::SmoothSpeed(const double init_a,
           .delta_t();
 
   const double total_t = 2 * path_length / max_reverse_acc * 10;
-  ADEBUG &lt;&lt; "total_t is : " &lt;&lt; total_t;
+
+  if (total_t + delta_t &gt;= delta_t * std::numeric_limits&lt;size_t&gt;::max()) {
+    AERROR &lt;&lt; "Number of knots overflow. total_t: " &lt;&lt; total_t
+           &lt;&lt; ", delta_t: " &lt;&lt; delta_t;
+    return false;
+  }
+
   const size_t num_of_knots = static_cast&lt;size_t&gt;(total_t / delta_t) + 1;
 
   PiecewiseJerkSpeedProblem piecewise_jerk_problem(
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7e3716b1a1f99d8e5215b6b50fa79ed469eb3a45" author="daohu527">
		<msg>control: fix vehicle_state pitch error</msg>
		<modified_files>
			<file old_path="modules\common\vehicle_state\vehicle_state_provider.cc" new_path="modules\common\vehicle_state\vehicle_state_provider.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -143,8 +143,8 @@ bool VehicleStateProvider::ConstructExceptLinearVelocity(
   }
 
   if (localization.pose().has_euler_angles()) {
-    vehicle_state_.set_roll(localization.pose().euler_angles().x());
-    vehicle_state_.set_pitch(localization.pose().euler_angles().y());
+    vehicle_state_.set_roll(localization.pose().euler_angles().y());
+    vehicle_state_.set_pitch(localization.pose().euler_angles().x());
     vehicle_state_.set_yaw(localization.pose().euler_angles().z());
   } else {
     math::EulerAnglesZXYd euler_angle(orientation.qw(), orientation.qx(),
</diff>
			</file>
			<file old_path="modules\control\controller\lon_controller.cc" new_path="modules\control\controller\lon_controller.cc" added_lines="4" deleted_lines="4">
				<diff>@@ -255,14 +255,14 @@ Status LonController::ComputeControlCommand(
         speed_leadlag_controller_.InnerstateSaturationStatus());
   }
 
-  double slope_offset_compenstaion = digital_filter_pitch_angle_.Filter(
+  double slope_offset_compensation = digital_filter_pitch_angle_.Filter(
       GRA_ACC * std::sin(injector_-&gt;vehicle_state()-&gt;pitch()));
 
-  if (std::isnan(slope_offset_compenstaion)) {
-    slope_offset_compenstaion = 0;
+  if (std::isnan(slope_offset_compensation)) {
+    slope_offset_compensation = 0;
   }
 
-  debug-&gt;set_slope_offset_compensation(slope_offset_compenstaion);
+  debug-&gt;set_slope_offset_compensation(slope_offset_compensation);
 
   double acceleration_cmd =
       acceleration_cmd_closeloop + debug-&gt;preview_acceleration_reference() +
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c5594c43e67572e5005029c5986b46be64557c10" author="SeasoulChris">
		<msg>seperate vehicle config files (#13704)</msg>
		<modified_files>
			<file old_path="modules\calibration\data\dev_kit\cancard_params\canbus.conf" new_path="" added_lines="0" deleted_lines="0">
				<diff>@@ -1,4 +0,0 @@
---flagfile=/apollo/modules/common/data/global_flagfile.txt
---canbus_conf_file=/apollo/modules/canbus/conf/canbus_conf.pb.txt
---enable_chassis_detail_pub
---noreceive_guardian
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit\localization_conf\localization.conf" new_path="" added_lines="0" deleted_lines="169">
				<diff>@@ -1,213 +0,0 @@
---flagfile=/apollo/modules/common/data/global_flagfile.txt
---noenable_gps_imu_interprolate
-
-# Redefine the map_dir of global_flagfile.txt
-#--map_dir=/apollo/modules/localization/testdata
-
-# The directory name of localization map.
-# type: string
-# default: local_map
---local_map_name=local_map
-
-# Enable lidar-based localization.
-# type: bool
-# defalult: true
---enable_lidar_localization=true
-
-# Localization mode, 0 for intensity, 1 for altitude, 2 for fusion.
-# type: int
-# default: 2
---lidar_localization_mode=2
-
-# image yaw align mode, 0 for align off, 1 for fusion, 2 for fusion with multithread.
-# type: int
-# default: 2
---lidar_yaw_align_mode=2
-
-# Lidar filter size
-# type: int
-# default: 11
---lidar_filter_size=17
-
-# point cloud step
-# type: int
-# default: 2
---point_cloud_step=2
-
-# The height from the center of lidar to ground plane
-# type: double
-# default: 1.80
---lidar_height_default=1.48
-
-# idar msg and imu msg max delay time.
-# type: double
-# default: 0.4
---lidar_imu_lidar_max_delay_time=0.4
-
-# The valid coverage of pointcloud and map.
-# type: double
-# default: 0.8
---lidar_map_coverage_theshold=0.8
-
-# Lidar debug switch.
-# type: bool
-# default: false
---lidar_debug_log_flag=false
-
-# integ_ins_can_self_align.
-# type: bool
-# default: false
---integ_ins_can_self_align=false
-
-# integ_sins_align_with_vel.
-# type: bool
-# default: true
---integ_sins_align_with_vel=true
-
-# Whether check state of sins. If true, sins will restart in bad state.
-# type: bool
-# default: true
---integ_sins_state_check=true
-
-# The param of sins state check.
-# type: double
-# default: 30.0
---integ_sins_state_span_time=30.0
-
-# The param of sins state check.
-# type: double
-# default: 1.0
---integ_sins_state_pos_std=1.0
-
-# vel_threshold_get_yaw.
-# type: double
-# default: 5.0
---vel_threshold_get_yaw=5.0
-
-# enable flag ins_aid_rtk.
-# type: bool
-# default: false
---enable_ins_aid_rtk=false
-
-# eph_buffer_path.
-# type: string
-# default: ""
---eph_buffer_path=""
-
-# gnss_debug_log_flag.
-# type: bool
-# default: false
---gnss_debug_log_flag=false
-
-# imu_rate.
-# type: double
-# default: 1.0
---imu_rate=1.0
-
-# Whether load utm zone id from local map folder
-# type: bool
-# default: true
---if_utm_zone_id_from_folder=true
-
-# local_utm_zone_id.
-# type: int
-# default: int
---local_utm_zone_id=50
-
-# trans_gpstime_to_utctime.
-# type: bool
-# default: true
---trans_gpstime_to_utctime=true
-
-# GNSS Mode, 0 for bestgnss pose, 1 for self gnss.
-# type: string
-# default: 0
---gnss_mode=0
-
-# The pointcloud topic name.
-# type: string
-# default: /apollo/sensor/velodyne64/compensator/PointCloud2
---lidar_topic=/apollo/sensor/lidar16/compensator/PointCloud2
-
-# The lidar extrinsics file
-# type: string
-# default: /apollo/modules/localization/msf/params/velodyne_params/velodyne128_novatel_extrinsics.yaml
---lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/lidar16_novatel_extrinsics.yaml
-
-# imu coordinate, true-&gt;flu, false-&gt;rfu
-# type: bool
-# default: true
---imu_coord_rfu=true
-
-# Whether use bestgnsspose as measure after initializaiton.
-# type: bool
-# default: false
---gnss_only_init=false
-
-# Whether use imu ant leverarm from ant imu yaml file
-# type: bool
-# default: true
---if_imuant_from_file=true
-
-# Imu ant offset x
-# type: double
-# default: 0.0
---imu_to_ant_offset_x=0.0
-
-# Imu ant offset y
-# type: double
-# default: 0.0
---imu_to_ant_offset_y=-0.1
-
-# Imu ant offset z
-# type: double
-# default: 0.0
---imu_to_ant_offset_z=0.6
-
-# Imu ant offset x uncertainty
-# type: double
-# default: 0.0
---imu_to_ant_offset_ux=0.05
-
-# Imu ant offset y uncertainty
-# type: double
-# default: 0.0
---imu_to_ant_offset_uy=0.05
-
-# Imu ant offset z uncertainty
-# type: double
-# default: 0.0
---imu_to_ant_offset_uz=0.08
-
-# Whether load vehicle coord to imu coord quaternion from yaml file
-# type: bool
-# default: true
---if_vehicle_imu_from_file=true
-
-# vehicle coord to imu coord quaternion qx
-# type: double
-# default: 0.0
---imu_vehicle_qx=0.0
-
-# vehicle coord to imu coord quaternion qy
-# type: double
-# default: 0.0
---imu_vehicle_qy=0.0
-
-# vehicle coord to imu coord quaternion qz
-# type: double
-# default: 0.0
---imu_vehicle_qz=0.0
-
-# vehicle coord to imu coord quaternion qw
-# type: double
-# default: 1.0
---imu_vehicle_qw=1.0
-
-# The tem folder for localziation visualziation
---map_visual_dir=data/map_visual
-
-# if use avx to accelerate lidar localization
-# need cpu to support avx intel intrinsics
-# default: false
---if_use_avx=true
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit\perception_conf\mlf_engine.conf" new_path="" added_lines="0" deleted_lines="6">
				<diff>@@ -1,6 +0,0 @@
-main_sensor: "velodyne16"
-use_histogram_for_match: true
-histogram_bin_size: 10
-output_predict_objects: false
-reserved_invisible_time: 0.3
-use_frame_timestamp: true
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit\perception_conf\pointcloud_preprocessor.conf" new_path="" added_lines="0" deleted_lines="8">
				<diff>@@ -1,8 +0,0 @@
-filter_naninf_points: true
-filter_nearby_box_points: true
-box_forward_x: 0.55
-box_backward_x: -0.55
-box_forward_y: 1.5
-box_backward_y: -0.45
-filter_high_z_points: true
-z_threshold: 2.0
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit\planning_conf\planning.conf" new_path="" added_lines="0" deleted_lines="27">
				<diff>@@ -1,61 +0,0 @@
---flagfile=/apollo/modules/common/data/global_flagfile.txt
---traffic_rule_config_filename=/apollo/modules/planning/conf/traffic_rule_config.pb.txt
---planning_upper_speed_limit=1.5
---planning_lower_speed_limit=0.1
---speed_upper_bound=1.5
---default_cruise_speed=1.0
---max_stop_distance_obstacle=10.0
---min_stop_distance_obstacle=4.0
---destination_check_distance=1.0
---lon_collision_buffer=0.4
---enable_scenario_park_and_go=false
---ignore_overlapped_obstacle=true
---prioritize_change_lane
---min_length_for_lane_change=5.0
---nouse_multi_thread_to_add_obstacles
---enable_multi_thread_in_dp_st_graph
---use_osqp_optimizer_for_reference_line
-
-# 0-no learning; 1-offline(read records and dump learning data); 2-online(e2e); 3-online(hybrid)
---planning_learning_mode=0
-
-# --smoother_config_filename=/apollo/modules/planning/conf/spiral_smoother_config.pb.txt
-# --smoother_config_filename=/apollo/modules/planning/conf/qp_spline_smoother_config.pb.txt
---smoother_config_filename=/apollo/modules/planning/conf/discrete_points_smoother_config.pb.txt
---enable_reference_line_stitching=false
-
-# --enable_perception_obstacles=false
-# --parking_inwards=false
-# --use_dual_variable_warm_start=true
-# --enable_open_space_planner_thread=true
-# --enable_record_debug=true
-# --use_gear_shift_trajectory=true
-# --enable_parallel_hybrid_a=true
---export_chart=true
-
-# --use_front_axe_center_in_path_planning=true
-# --obstacle_lon_start_buffer=0.4
-# --obstacle_lon_end_buffer=0.4
-
---noenable_smoother_failsafe
---enable_parallel_trajectory_smoothing
---nouse_s_curve_speed_smooth
---use_iterative_anchoring_smoother
-
---open_space_planning_period=1000.0
---open_space_standstill_acceleration=0.3
-
---lane_change_prepare_length=60.0
---enable_smarter_lane_change=true
---nonstatic_obstacle_nudge_l_buffer=0.6
---lane_change_obstacle_nudge_l_buffer=0.5
-
---use_st_drivable_boundary=true
-
-#--enable_skip_path_tasks=true
-#--enable_reuse_path_in_lane_follow=true
-
---use_smoothed_dp_guide_line=true
---use_soft_bound_in_nonlinear_speed_opt=false
-
-# --use_road_boundary_from_map=true
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_ne-b\cancard_params\canbus.conf" new_path="" added_lines="0" deleted_lines="0">
				<diff>@@ -1,4 +0,0 @@
---flagfile=/apollo/modules/common/data/global_flagfile.txt
---canbus_conf_file=/apollo/modules/canbus/conf/canbus_conf.pb.txt
---enable_chassis_detail_pub
---noreceive_guardian
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_ne-b\lidar_conf\surestar.conf" new_path="" added_lines="0" deleted_lines="14">
				<diff>@@ -1,14 +0,0 @@
-frame_id: "lidar16"
-scan_channel:"/apollo/sensor/lidar16/Scan"
-rpm: 600.0
-model: VLP16
-mode: STRONGEST
-firing_data_port: 2371
-positioning_data_port: 2030
-organized: true
-max_range: 70.0
-min_range: 0.9
-use_gps_time: false
-time_zone: 8
-calibration_file: "/apollo/modules/drivers/lidar/params/VLP16_calibration.yaml"
-pc_channel:"/apollo/sensor/lidar16/PointCloud2"
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_ne-b\localization_conf\localization.conf" new_path="" added_lines="0" deleted_lines="169">
				<diff>@@ -1,213 +0,0 @@
---flagfile=/apollo/modules/common/data/global_flagfile.txt
---noenable_gps_imu_interprolate
-
-# Redefine the map_dir of global_flagfile.txt
-#--map_dir=/apollo/modules/localization/testdata
-
-# The directory name of localization map.
-# type: string
-# default: local_map
---local_map_name=local_map
-
-# Enable lidar-based localization.
-# type: bool
-# defalult: true
---enable_lidar_localization=false
-
-# Localization mode, 0 for intensity, 1 for altitude, 2 for fusion.
-# type: int
-# default: 2
---lidar_localization_mode=2
-
-# image yaw align mode, 0 for align off, 1 for fusion, 2 for fusion with multithread.
-# type: int
-# default: 2
---lidar_yaw_align_mode=2
-
-# Lidar filter size
-# type: int
-# default: 11
---lidar_filter_size=17
-
-# point cloud step
-# type: int
-# default: 2
---point_cloud_step=2
-
-# The height from the center of lidar to ground plane
-# type: double
-# default: 1.80
---lidar_height_default=1.64
-
-# idar msg and imu msg max delay time.
-# type: double
-# default: 0.4
---lidar_imu_lidar_max_delay_time=0.4
-
-# The valid coverage of pointcloud and map.
-# type: double
-# default: 0.8
---lidar_map_coverage_theshold=0.8
-
-# Lidar debug switch.
-# type: bool
-# default: false
---lidar_debug_log_flag=false
-
-# integ_ins_can_self_align.
-# type: bool
-# default: false
---integ_ins_can_self_align=false
-
-# integ_sins_align_with_vel.
-# type: bool
-# default: true
---integ_sins_align_with_vel=true
-
-# Whether check state of sins. If true, sins will restart in bad state.
-# type: bool
-# default: true
---integ_sins_state_check=true
-
-# The param of sins state check.
-# type: double
-# default: 30.0
---integ_sins_state_span_time=30.0
-
-# The param of sins state check.
-# type: double
-# default: 1.0
---integ_sins_state_pos_std=1.0
-
-# vel_threshold_get_yaw.
-# type: double
-# default: 5.0
---vel_threshold_get_yaw=5.0
-
-# enable flag ins_aid_rtk.
-# type: bool
-# default: false
---enable_ins_aid_rtk=false
-
-# eph_buffer_path.
-# type: string
-# default: ""
---eph_buffer_path=""
-
-# gnss_debug_log_flag.
-# type: bool
-# default: false
---gnss_debug_log_flag=false
-
-# imu_rate.
-# type: double
-# default: 1.0
---imu_rate=1.0
-
-# Whether load utm zone id from local map folder
-# type: bool
-# default: true
---if_utm_zone_id_from_folder=true
-
-# local_utm_zone_id.
-# type: int
-# default: int
---local_utm_zone_id=50
-
-# trans_gpstime_to_utctime.
-# type: bool
-# default: true
---trans_gpstime_to_utctime=true
-
-# GNSS Mode, 0 for bestgnss pose, 1 for self gnss.
-# type: string
-# default: 0
---gnss_mode=0
-
-# The pointcloud topic name.
-# type: string
-# default: /apollo/sensor/velodyne64/compensator/PointCloud2
---lidar_topic=/apollo/sensor/lidar16/compensator/PointCloud2
-
-# The lidar extrinsics file
-# type: string
-# default: /apollo/modules/localization/msf/params/velodyne_params/velodyne128_novatel_extrinsics.yaml
---lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/lidar16_novatel_extrinsics.yaml
-
-# imu coordinate, true-&gt;flu, false-&gt;rfu
-# type: bool
-# default: true
---imu_coord_rfu=true
-
-# Whether use bestgnsspose as measure after initializaiton.
-# type: bool
-# default: false
---gnss_only_init=false
-
-# Whether use imu ant leverarm from ant imu yaml file
-# type: bool
-# default: true
---if_imuant_from_file=true
-
-# Imu ant offset x
-# type: double
-# default: 0.0
---imu_to_ant_offset_x=0.0143
-
-# Imu ant offset y
-# type: double
-# default: 0.0
---imu_to_ant_offset_y=-0.6452
-
-# Imu ant offset z
-# type: double
-# default: 0.0
---imu_to_ant_offset_z=1.1802
-
-# Imu ant offset x uncertainty
-# type: double
-# default: 0.0
---imu_to_ant_offset_ux=0.03
-
-# Imu ant offset y uncertainty
-# type: double
-# default: 0.0
---imu_to_ant_offset_uy=0.03
-
-# Imu ant offset z uncertainty
-# type: double
-# default: 0.0
---imu_to_ant_offset_uz=0.03
-
-# Whether load vehicle coord to imu coord quaternion from yaml file
-# type: bool
-# default: true
---if_vehicle_imu_from_file=true
-
-# vehicle coord to imu coord quaternion qx
-# type: double
-# default: 0.0
---imu_vehicle_qx=0.0
-
-# vehicle coord to imu coord quaternion qy
-# type: double
-# default: 0.0
---imu_vehicle_qy=0.0
-
-# vehicle coord to imu coord quaternion qz
-# type: double
-# default: 0.0
---imu_vehicle_qz=0.0
-
-# vehicle coord to imu coord quaternion qw
-# type: double
-# default: 1.0
---imu_vehicle_qw=1.0
-
-# The tem folder for localziation visualziation
---map_visual_dir=data/map_visual
-
-# if use avx to accelerate lidar localization
-# need cpu to support avx intel intrinsics
-# default: false
---if_use_avx=true
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_ne-b\perception_conf\mlf_engine.conf" new_path="" added_lines="0" deleted_lines="6">
				<diff>@@ -1,6 +0,0 @@
-main_sensor: "velodyne16"
-use_histogram_for_match: true
-histogram_bin_size: 10
-output_predict_objects: false
-reserved_invisible_time: 0.3
-use_frame_timestamp: true
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_ne-b\perception_conf\pointcloud_preprocessor.conf" new_path="" added_lines="0" deleted_lines="8">
				<diff>@@ -1,8 +0,0 @@
-filter_naninf_points: true
-filter_nearby_box_points: true
-box_forward_x: 0.7
-box_backward_x: -0.7
-box_forward_y: 1.7
-box_backward_y: -1.3
-filter_high_z_points: true
-z_threshold: 2.0
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_ne-b\planning_conf\planning.conf" new_path="" added_lines="0" deleted_lines="27">
				<diff>@@ -1,61 +0,0 @@
---flagfile=/apollo/modules/common/data/global_flagfile.txt
---traffic_rule_config_filename=/apollo/modules/planning/conf/traffic_rule_config.pb.txt
---planning_upper_speed_limit=1.5
---planning_lower_speed_limit=0.1
---speed_upper_bound=1.5
---default_cruise_speed=1.0
---max_stop_distance_obstacle=10.0
---min_stop_distance_obstacle=4.0
---destination_check_distance=1.0
---lon_collision_buffer=0.3
---enable_scenario_park_and_go=false
---ignore_overlapped_obstacle=true
---prioritize_change_lane
---min_length_for_lane_change=5.0
---nouse_multi_thread_to_add_obstacles
---enable_multi_thread_in_dp_st_graph
---use_osqp_optimizer_for_reference_line
-
-# 0-no learning; 1-offline(read records and dump learning data); 2-online(e2e); 3-online(hybrid)
---planning_learning_mode=0
-
-# --smoother_config_filename=/apollo/modules/planning/conf/spiral_smoother_config.pb.txt
-# --smoother_config_filename=/apollo/modules/planning/conf/qp_spline_smoother_config.pb.txt
---smoother_config_filename=/apollo/modules/planning/conf/discrete_points_smoother_config.pb.txt
---enable_reference_line_stitching=false
-
-# --enable_perception_obstacles=false
-# --parking_inwards=false
-# --use_dual_variable_warm_start=true
-# --enable_open_space_planner_thread=true
-# --enable_record_debug=true
-# --use_gear_shift_trajectory=true
-# --enable_parallel_hybrid_a=true
---export_chart=true
-
-# --use_front_axe_center_in_path_planning=true
-# --obstacle_lon_start_buffer=0.4
-# --obstacle_lon_end_buffer=0.4
-
---noenable_smoother_failsafe
---enable_parallel_trajectory_smoothing
---nouse_s_curve_speed_smooth
---use_iterative_anchoring_smoother
-
---open_space_planning_period=1000.0
---open_space_standstill_acceleration=0.3
-
---lane_change_prepare_length=60.0
---enable_smarter_lane_change=true
---nonstatic_obstacle_nudge_l_buffer=0.4
---lane_change_obstacle_nudge_l_buffer=0.3
-
---use_st_drivable_boundary=true
-
-#--enable_skip_path_tasks=true
-#--enable_reuse_path_in_lane_follow=true
-
---use_smoothed_dp_guide_line=true
---use_soft_bound_in_nonlinear_speed_opt=false
-
-# --use_road_boundary_from_map=true
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_ne-s\cancard_params\canbus.conf" new_path="" added_lines="0" deleted_lines="0">
				<diff>@@ -1,4 +0,0 @@
---flagfile=/apollo/modules/common/data/global_flagfile.txt
---canbus_conf_file=/apollo/modules/canbus/conf/canbus_conf.pb.txt
---enable_chassis_detail_pub
---noreceive_guardian
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_ne-s\localization_conf\localization.conf" new_path="" added_lines="0" deleted_lines="169">
				<diff>@@ -1,213 +0,0 @@
---flagfile=/apollo/modules/common/data/global_flagfile.txt
---noenable_gps_imu_interprolate
-
-# Redefine the map_dir of global_flagfile.txt
-#--map_dir=/apollo/modules/localization/testdata
-
-# The directory name of localization map.
-# type: string
-# default: local_map
---local_map_name=local_map
-
-# Enable lidar-based localization.
-# type: bool
-# defalult: true
---enable_lidar_localization=false
-
-# Localization mode, 0 for intensity, 1 for altitude, 2 for fusion.
-# type: int
-# default: 2
---lidar_localization_mode=2
-
-# image yaw align mode, 0 for align off, 1 for fusion, 2 for fusion with multithread.
-# type: int
-# default: 2
---lidar_yaw_align_mode=2
-
-# Lidar filter size
-# type: int
-# default: 11
---lidar_filter_size=17
-
-# point cloud step
-# type: int
-# default: 2
---point_cloud_step=2
-
-# The height from the center of lidar to ground plane
-# type: double
-# default: 1.80
---lidar_height_default=1.80
-
-# idar msg and imu msg max delay time.
-# type: double
-# default: 0.4
---lidar_imu_lidar_max_delay_time=0.4
-
-# The valid coverage of pointcloud and map.
-# type: double
-# default: 0.8
---lidar_map_coverage_theshold=0.8
-
-# Lidar debug switch.
-# type: bool
-# default: false
---lidar_debug_log_flag=false
-
-# integ_ins_can_self_align.
-# type: bool
-# default: false
---integ_ins_can_self_align=false
-
-# integ_sins_align_with_vel.
-# type: bool
-# default: true
---integ_sins_align_with_vel=true
-
-# Whether check state of sins. If true, sins will restart in bad state.
-# type: bool
-# default: true
---integ_sins_state_check=true
-
-# The param of sins state check.
-# type: double
-# default: 30.0
---integ_sins_state_span_time=30.0
-
-# The param of sins state check.
-# type: double
-# default: 1.0
---integ_sins_state_pos_std=1.0
-
-# vel_threshold_get_yaw.
-# type: double
-# default: 5.0
---vel_threshold_get_yaw=5.0
-
-# enable flag ins_aid_rtk.
-# type: bool
-# default: false
---enable_ins_aid_rtk=false
-
-# eph_buffer_path.
-# type: string
-# default: ""
---eph_buffer_path=""
-
-# gnss_debug_log_flag.
-# type: bool
-# default: false
---gnss_debug_log_flag=false
-
-# imu_rate.
-# type: double
-# default: 1.0
---imu_rate=1.0
-
-# Whether load utm zone id from local map folder
-# type: bool
-# default: true
---if_utm_zone_id_from_folder=true
-
-# local_utm_zone_id.
-# type: int
-# default: int
---local_utm_zone_id=50
-
-# trans_gpstime_to_utctime.
-# type: bool
-# default: true
---trans_gpstime_to_utctime=true
-
-# GNSS Mode, 0 for bestgnss pose, 1 for self gnss.
-# type: string
-# default: 0
---gnss_mode=0
-
-# The pointcloud topic name.
-# type: string
-# default: /apollo/sensor/velodyne64/compensator/PointCloud2
---lidar_topic=/apollo/sensor/lidar16/compensator/PointCloud2
-
-# The lidar extrinsics file
-# type: string
-# default: /apollo/modules/localization/msf/params/velodyne_params/velodyne128_novatel_extrinsics.yaml
---lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/lidar16_novatel_extrinsics.yaml
-
-# imu coordinate, true-&gt;flu, false-&gt;rfu
-# type: bool
-# default: true
---imu_coord_rfu=true
-
-# Whether use bestgnsspose as measure after initializaiton.
-# type: bool
-# default: false
---gnss_only_init=false
-
-# Whether use imu ant leverarm from ant imu yaml file
-# type: bool
-# default: true
---if_imuant_from_file=true
-
-# Imu ant offset x
-# type: double
-# default: 0.0
---imu_to_ant_offset_x=0.0143
-
-# Imu ant offset y
-# type: double
-# default: 0.0
---imu_to_ant_offset_y=-0.6452
-
-# Imu ant offset z
-# type: double
-# default: 0.0
---imu_to_ant_offset_z=1.1802
-
-# Imu ant offset x uncertainty
-# type: double
-# default: 0.0
---imu_to_ant_offset_ux=0.03
-
-# Imu ant offset y uncertainty
-# type: double
-# default: 0.0
---imu_to_ant_offset_uy=0.03
-
-# Imu ant offset z uncertainty
-# type: double
-# default: 0.0
---imu_to_ant_offset_uz=0.03
-
-# Whether load vehicle coord to imu coord quaternion from yaml file
-# type: bool
-# default: true
---if_vehicle_imu_from_file=true
-
-# vehicle coord to imu coord quaternion qx
-# type: double
-# default: 0.0
---imu_vehicle_qx=0.0
-
-# vehicle coord to imu coord quaternion qy
-# type: double
-# default: 0.0
---imu_vehicle_qy=0.0
-
-# vehicle coord to imu coord quaternion qz
-# type: double
-# default: 0.0
---imu_vehicle_qz=0.0
-
-# vehicle coord to imu coord quaternion qw
-# type: double
-# default: 1.0
---imu_vehicle_qw=1.0
-
-# The tem folder for localziation visualziation
---map_visual_dir=data/map_visual
-
-# if use avx to accelerate lidar localization
-# need cpu to support avx intel intrinsics
-# default: false
---if_use_avx=true
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_ne-s\perception_conf\mlf_engine.conf" new_path="" added_lines="0" deleted_lines="6">
				<diff>@@ -1,6 +0,0 @@
-main_sensor: "velodyne16"
-use_histogram_for_match: true
-histogram_bin_size: 10
-output_predict_objects: false
-reserved_invisible_time: 0.3
-use_frame_timestamp: true
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_ne-s\perception_conf\pointcloud_preprocessor.conf" new_path="" added_lines="0" deleted_lines="8">
				<diff>@@ -1,8 +0,0 @@
-filter_naninf_points: true
-filter_nearby_box_points: true
-box_forward_x: 0.7
-box_backward_x: -0.7
-box_forward_y: 1.7
-box_backward_y: -1.3
-filter_high_z_points: true
-z_threshold: 2.0
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_ne-s\planning_conf\planning.conf" new_path="" added_lines="0" deleted_lines="27">
				<diff>@@ -1,61 +0,0 @@
---flagfile=/apollo/modules/common/data/global_flagfile.txt
---traffic_rule_config_filename=/apollo/modules/planning/conf/traffic_rule_config.pb.txt
---planning_upper_speed_limit=1.5
---planning_lower_speed_limit=0.1
---speed_upper_bound=1.5
---default_cruise_speed=1.0
---max_stop_distance_obstacle=10.0
---min_stop_distance_obstacle=4.0
---destination_check_distance=1.0
---lon_collision_buffer=0.3
---enable_scenario_park_and_go=false
---ignore_overlapped_obstacle=true
---prioritize_change_lane
---min_length_for_lane_change=5.0
---nouse_multi_thread_to_add_obstacles
---enable_multi_thread_in_dp_st_graph
---use_osqp_optimizer_for_reference_line
-
-# 0-no learning; 1-offline(read records and dump learning data); 2-online(e2e); 3-online(hybrid)
---planning_learning_mode=0
-
-# --smoother_config_filename=/apollo/modules/planning/conf/spiral_smoother_config.pb.txt
-# --smoother_config_filename=/apollo/modules/planning/conf/qp_spline_smoother_config.pb.txt
---smoother_config_filename=/apollo/modules/planning/conf/discrete_points_smoother_config.pb.txt
---enable_reference_line_stitching=false
-
-# --enable_perception_obstacles=false
-# --parking_inwards=false
-# --use_dual_variable_warm_start=true
-# --enable_open_space_planner_thread=true
-# --enable_record_debug=true
-# --use_gear_shift_trajectory=true
-# --enable_parallel_hybrid_a=true
---export_chart=true
-
-# --use_front_axe_center_in_path_planning=true
-# --obstacle_lon_start_buffer=0.4
-# --obstacle_lon_end_buffer=0.4
-
---noenable_smoother_failsafe
---enable_parallel_trajectory_smoothing
---nouse_s_curve_speed_smooth
---use_iterative_anchoring_smoother
-
---open_space_planning_period=1000.0
---open_space_standstill_acceleration=0.3
-
---lane_change_prepare_length=60.0
---enable_smarter_lane_change=true
---nonstatic_obstacle_nudge_l_buffer=0.4
---lane_change_obstacle_nudge_l_buffer=0.3
-
---use_st_drivable_boundary=true
-
-#--enable_skip_path_tasks=true
-#--enable_reuse_path_in_lane_follow=true
-
---use_smoothed_dp_guide_line=true
---use_soft_bound_in_nonlinear_speed_opt=false
-
-# --use_road_boundary_from_map=true
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_sne-r\cancard_params\canbus.conf" new_path="" added_lines="0" deleted_lines="0">
				<diff>@@ -1,4 +0,0 @@
---flagfile=/apollo/modules/common/data/global_flagfile.txt
---canbus_conf_file=/apollo/modules/canbus/conf/canbus_conf.pb.txt
---enable_chassis_detail_pub
---noreceive_guardian
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_sne-r\localization_conf\localization.conf" new_path="" added_lines="0" deleted_lines="169">
				<diff>@@ -1,213 +0,0 @@
---flagfile=/apollo/modules/common/data/global_flagfile.txt
---noenable_gps_imu_interprolate
-
-# Redefine the map_dir of global_flagfile.txt
-#--map_dir=/apollo/modules/localization/testdata
-
-# The directory name of localization map.
-# type: string
-# default: local_map
---local_map_name=local_map
-
-# Enable lidar-based localization.
-# type: bool
-# defalult: true
---enable_lidar_localization=false
-
-# Localization mode, 0 for intensity, 1 for altitude, 2 for fusion.
-# type: int
-# default: 2
---lidar_localization_mode=2
-
-# image yaw align mode, 0 for align off, 1 for fusion, 2 for fusion with multithread.
-# type: int
-# default: 2
---lidar_yaw_align_mode=2
-
-# Lidar filter size
-# type: int
-# default: 11
---lidar_filter_size=17
-
-# point cloud step
-# type: int
-# default: 2
---point_cloud_step=2
-
-# The height from the center of lidar to ground plane
-# type: double
-# default: 1.80
---lidar_height_default=1.80
-
-# idar msg and imu msg max delay time.
-# type: double
-# default: 0.4
---lidar_imu_lidar_max_delay_time=0.4
-
-# The valid coverage of pointcloud and map.
-# type: double
-# default: 0.8
---lidar_map_coverage_theshold=0.8
-
-# Lidar debug switch.
-# type: bool
-# default: false
---lidar_debug_log_flag=false
-
-# integ_ins_can_self_align.
-# type: bool
-# default: false
---integ_ins_can_self_align=false
-
-# integ_sins_align_with_vel.
-# type: bool
-# default: true
---integ_sins_align_with_vel=true
-
-# Whether check state of sins. If true, sins will restart in bad state.
-# type: bool
-# default: true
---integ_sins_state_check=true
-
-# The param of sins state check.
-# type: double
-# default: 30.0
---integ_sins_state_span_time=30.0
-
-# The param of sins state check.
-# type: double
-# default: 1.0
---integ_sins_state_pos_std=1.0
-
-# vel_threshold_get_yaw.
-# type: double
-# default: 5.0
---vel_threshold_get_yaw=5.0
-
-# enable flag ins_aid_rtk.
-# type: bool
-# default: false
---enable_ins_aid_rtk=false
-
-# eph_buffer_path.
-# type: string
-# default: ""
---eph_buffer_path=""
-
-# gnss_debug_log_flag.
-# type: bool
-# default: false
---gnss_debug_log_flag=false
-
-# imu_rate.
-# type: double
-# default: 1.0
---imu_rate=1.0
-
-# Whether load utm zone id from local map folder
-# type: bool
-# default: true
---if_utm_zone_id_from_folder=true
-
-# local_utm_zone_id.
-# type: int
-# default: int
---local_utm_zone_id=50
-
-# trans_gpstime_to_utctime.
-# type: bool
-# default: true
---trans_gpstime_to_utctime=true
-
-# GNSS Mode, 0 for bestgnss pose, 1 for self gnss.
-# type: string
-# default: 0
---gnss_mode=0
-
-# The pointcloud topic name.
-# type: string
-# default: /apollo/sensor/velodyne64/compensator/PointCloud2
---lidar_topic=/apollo/sensor/lidar16/compensator/PointCloud2
-
-# The lidar extrinsics file
-# type: string
-# default: /apollo/modules/localization/msf/params/velodyne_params/lidar16_novatel_extrinsics.yaml
---lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/lidar16_novatel_extrinsics.yaml
-
-# imu coordinate, true-&gt;flu, false-&gt;rfu
-# type: bool
-# default: true
---imu_coord_rfu=true
-
-# Whether use bestgnsspose as measure after initializaiton.
-# type: bool
-# default: false
---gnss_only_init=false
-
-# Whether use imu ant leverarm from ant imu yaml file
-# type: bool
-# default: true
---if_imuant_from_file=true
-
-# Imu ant offset x
-# type: double
-# default: 0.0
---imu_to_ant_offset_x=0.0143
-
-# Imu ant offset y
-# type: double
-# default: 0.0
---imu_to_ant_offset_y=-0.6452
-
-# Imu ant offset z
-# type: double
-# default: 0.0
---imu_to_ant_offset_z=1.1802
-
-# Imu ant offset x uncertainty
-# type: double
-# default: 0.0
---imu_to_ant_offset_ux=0.03
-
-# Imu ant offset y uncertainty
-# type: double
-# default: 0.0
---imu_to_ant_offset_uy=0.03
-
-# Imu ant offset z uncertainty
-# type: double
-# default: 0.0
---imu_to_ant_offset_uz=0.03
-
-# Whether load vehicle coord to imu coord quaternion from yaml file
-# type: bool
-# default: true
---if_vehicle_imu_from_file=true
-
-# vehicle coord to imu coord quaternion qx
-# type: double
-# default: 0.0
---imu_vehicle_qx=0.0
-
-# vehicle coord to imu coord quaternion qy
-# type: double
-# default: 0.0
---imu_vehicle_qy=0.0
-
-# vehicle coord to imu coord quaternion qz
-# type: double
-# default: 0.0
---imu_vehicle_qz=0.0
-
-# vehicle coord to imu coord quaternion qw
-# type: double
-# default: 1.0
---imu_vehicle_qw=1.0
-
-# The tem folder for localziation visualziation
---map_visual_dir=data/map_visual
-
-# if use avx to accelerate lidar localization
-# need cpu to support avx intel intrinsics
-# default: false
---if_use_avx=true
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_sne-r\perception_conf\mlf_engine.conf" new_path="" added_lines="0" deleted_lines="6">
				<diff>@@ -1,6 +0,0 @@
-main_sensor: "velodyne16"
-use_histogram_for_match: true
-histogram_bin_size: 10
-output_predict_objects: false
-reserved_invisible_time: 0.3
-use_frame_timestamp: true
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_sne-r\perception_conf\pointcloud_preprocessor.conf" new_path="" added_lines="0" deleted_lines="8">
				<diff>@@ -1,8 +0,0 @@
-filter_naninf_points: true
-filter_nearby_box_points: true
-box_forward_x: 0.7
-box_backward_x: -0.7
-box_forward_y: 1.7
-box_backward_y: -1.3
-filter_high_z_points: true
-z_threshold: 2.0
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_advanced_sne-r\planning_conf\planning.conf" new_path="" added_lines="0" deleted_lines="27">
				<diff>@@ -1,61 +0,0 @@
---flagfile=/apollo/modules/common/data/global_flagfile.txt
---traffic_rule_config_filename=/apollo/modules/planning/conf/traffic_rule_config.pb.txt
---planning_upper_speed_limit=1.5
---planning_lower_speed_limit=0.1
---speed_upper_bound=1.5
---default_cruise_speed=1.0
---max_stop_distance_obstacle=10.0
---min_stop_distance_obstacle=4.0
---destination_check_distance=1.0
---lon_collision_buffer=0.3
---enable_scenario_park_and_go=false
---ignore_overlapped_obstacle=true
---prioritize_change_lane
---min_length_for_lane_change=5.0
---nouse_multi_thread_to_add_obstacles
---enable_multi_thread_in_dp_st_graph
---use_osqp_optimizer_for_reference_line
-
-# 0-no learning; 1-offline(read records and dump learning data); 2-online(e2e); 3-online(hybrid)
---planning_learning_mode=0
-
-# --smoother_config_filename=/apollo/modules/planning/conf/spiral_smoother_config.pb.txt
-# --smoother_config_filename=/apollo/modules/planning/conf/qp_spline_smoother_config.pb.txt
---smoother_config_filename=/apollo/modules/planning/conf/discrete_points_smoother_config.pb.txt
---enable_reference_line_stitching=false
-
-# --enable_perception_obstacles=false
-# --parking_inwards=false
-# --use_dual_variable_warm_start=true
-# --enable_open_space_planner_thread=true
-# --enable_record_debug=true
-# --use_gear_shift_trajectory=true
-# --enable_parallel_hybrid_a=true
---export_chart=true
-
-# --use_front_axe_center_in_path_planning=true
-# --obstacle_lon_start_buffer=0.4
-# --obstacle_lon_end_buffer=0.4
-
---noenable_smoother_failsafe
---enable_parallel_trajectory_smoothing
---nouse_s_curve_speed_smooth
---use_iterative_anchoring_smoother
-
---open_space_planning_period=1000.0
---open_space_standstill_acceleration=0.3
-
---lane_change_prepare_length=60.0
---enable_smarter_lane_change=true
---nonstatic_obstacle_nudge_l_buffer=0.4
---lane_change_obstacle_nudge_l_buffer=0.3
-
---use_st_drivable_boundary=true
-
-#--enable_skip_path_tasks=true
-#--enable_reuse_path_in_lane_follow=true
-
---use_smoothed_dp_guide_line=true
---use_soft_bound_in_nonlinear_speed_opt=false
-
-# --use_road_boundary_from_map=true
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_standard\cancard_params\canbus.conf" new_path="" added_lines="0" deleted_lines="0">
				<diff>@@ -1,5 +0,0 @@
---flagfile=/apollo/modules/common/data/global_flagfile.txt
---canbus_conf_file=/apollo/modules/canbus/conf/canbus_conf.pb.txt
---enable_chassis_detail_pub
---noreceive_guardian
---enable_aeb
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_standard\localization_conf\localization.conf" new_path="" added_lines="0" deleted_lines="169">
				<diff>@@ -1,213 +0,0 @@
---flagfile=/apollo/modules/common/data/global_flagfile.txt
---noenable_gps_imu_interprolate
-
-# Redefine the map_dir of global_flagfile.txt
-#--map_dir=/apollo/modules/localization/testdata
-
-# The directory name of localization map.
-# type: string
-# default: local_map
---local_map_name=local_map
-
-# Enable lidar-based localization.
-# type: bool
-# defalult: true
---enable_lidar_localization=true
-
-# Localization mode, 0 for intensity, 1 for altitude, 2 for fusion.
-# type: int
-# default: 2
---lidar_localization_mode=2
-
-# image yaw align mode, 0 for align off, 1 for fusion, 2 for fusion with multithread.
-# type: int
-# default: 2
---lidar_yaw_align_mode=2
-
-# Lidar filter size
-# type: int
-# default: 11
---lidar_filter_size=17
-
-# point cloud step
-# type: int
-# default: 2
---point_cloud_step=2
-
-# The height from the center of lidar to ground plane
-# type: double
-# default: 1.80
---lidar_height_default=1.48
-
-# idar msg and imu msg max delay time.
-# type: double
-# default: 0.4
---lidar_imu_lidar_max_delay_time=0.4
-
-# The valid coverage of pointcloud and map.
-# type: double
-# default: 0.8
---lidar_map_coverage_theshold=0.8
-
-# Lidar debug switch.
-# type: bool
-# default: false
---lidar_debug_log_flag=false
-
-# integ_ins_can_self_align.
-# type: bool
-# default: false
---integ_ins_can_self_align=false
-
-# integ_sins_align_with_vel.
-# type: bool
-# default: true
---integ_sins_align_with_vel=true
-
-# Whether check state of sins. If true, sins will restart in bad state.
-# type: bool
-# default: true
---integ_sins_state_check=true
-
-# The param of sins state check.
-# type: double
-# default: 30.0
---integ_sins_state_span_time=30.0
-
-# The param of sins state check.
-# type: double
-# default: 1.0
---integ_sins_state_pos_std=1.0
-
-# vel_threshold_get_yaw.
-# type: double
-# default: 5.0
---vel_threshold_get_yaw=5.0
-
-# enable flag ins_aid_rtk.
-# type: bool
-# default: false
---enable_ins_aid_rtk=false
-
-# eph_buffer_path.
-# type: string
-# default: ""
---eph_buffer_path=""
-
-# gnss_debug_log_flag.
-# type: bool
-# default: false
---gnss_debug_log_flag=false
-
-# imu_rate.
-# type: double
-# default: 1.0
---imu_rate=1.0
-
-# Whether load utm zone id from local map folder
-# type: bool
-# default: true
---if_utm_zone_id_from_folder=true
-
-# local_utm_zone_id.
-# type: int
-# default: int
---local_utm_zone_id=50
-
-# trans_gpstime_to_utctime.
-# type: bool
-# default: true
---trans_gpstime_to_utctime=true
-
-# GNSS Mode, 0 for bestgnss pose, 1 for self gnss.
-# type: string
-# default: 0
---gnss_mode=0
-
-# The pointcloud topic name.
-# type: string
-# default: /apollo/sensor/velodyne64/compensator/PointCloud2
---lidar_topic=/apollo/sensor/lidar16/compensator/PointCloud2
-
-# The lidar extrinsics file
-# type: string
-# default: /apollo/modules/localization/msf/params/velodyne_params/velodyne128_novatel_extrinsics.yaml
---lidar_extrinsics_file=/apollo/modules/localization/msf/params/velodyne_params/lidar16_novatel_extrinsics.yaml
-
-# imu coordinate, true-&gt;flu, false-&gt;rfu
-# type: bool
-# default: true
---imu_coord_rfu=true
-
-# Whether use bestgnsspose as measure after initializaiton.
-# type: bool
-# default: false
---gnss_only_init=false
-
-# Whether use imu ant leverarm from ant imu yaml file
-# type: bool
-# default: true
---if_imuant_from_file=true
-
-# Imu ant offset x
-# type: double
-# default: 0.0
---imu_to_ant_offset_x=0.0
-
-# Imu ant offset y
-# type: double
-# default: 0.0
---imu_to_ant_offset_y=-0.1
-
-# Imu ant offset z
-# type: double
-# default: 0.0
---imu_to_ant_offset_z=0.6
-
-# Imu ant offset x uncertainty
-# type: double
-# default: 0.0
---imu_to_ant_offset_ux=0.05
-
-# Imu ant offset y uncertainty
-# type: double
-# default: 0.0
---imu_to_ant_offset_uy=0.05
-
-# Imu ant offset z uncertainty
-# type: double
-# default: 0.0
---imu_to_ant_offset_uz=0.08
-
-# Whether load vehicle coord to imu coord quaternion from yaml file
-# type: bool
-# default: true
---if_vehicle_imu_from_file=true
-
-# vehicle coord to imu coord quaternion qx
-# type: double
-# default: 0.0
---imu_vehicle_qx=0.0
-
-# vehicle coord to imu coord quaternion qy
-# type: double
-# default: 0.0
---imu_vehicle_qy=0.0
-
-# vehicle coord to imu coord quaternion qz
-# type: double
-# default: 0.0
---imu_vehicle_qz=0.0
-
-# vehicle coord to imu coord quaternion qw
-# type: double
-# default: 1.0
---imu_vehicle_qw=1.0
-
-# The tem folder for localziation visualziation
---map_visual_dir=data/map_visual
-
-# if use avx to accelerate lidar localization
-# need cpu to support avx intel intrinsics
-# default: false
---if_use_avx=true
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_standard\perception_conf\mlf_engine.conf" new_path="" added_lines="0" deleted_lines="6">
				<diff>@@ -1,6 +0,0 @@
-main_sensor: "velodyne16"
-use_histogram_for_match: true
-histogram_bin_size: 10
-output_predict_objects: false
-reserved_invisible_time: 0.3
-use_frame_timestamp: true
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_standard\perception_conf\pointcloud_preprocessor.conf" new_path="" added_lines="0" deleted_lines="8">
				<diff>@@ -1,8 +0,0 @@
-filter_naninf_points: true
-filter_nearby_box_points: true
-box_forward_x: 0.4
-box_backward_x: -0.4
-box_forward_y: 1.05
-box_backward_y: -0.4
-filter_high_z_points: true
-z_threshold: 2.0
</diff>
			</file>
			<file old_path="modules\calibration\data\dev_kit_standard\planning_conf\planning.conf" new_path="" added_lines="0" deleted_lines="23">
				<diff>@@ -1,56 +0,0 @@
---flagfile=/apollo/modules/common/data/global_flagfile.txt
---traffic_rule_config_filename=/apollo/modules/planning/conf/traffic_rule_config.pb.txt
---planning_upper_speed_limit=1.0
---planning_lower_speed_limit=0.3
---speed_upper_bound=1.3
---max_stop_distance_obstacle=10
---min_stop_distance_obstacle=5
---destination_check_distance=1.0
---lon_collision_buffer=0.3
---default_cruise_speed=1.0
---ignore_overlapped_obstacle=true
---prioritize_change_lane
---min_length_for_lane_change=5.0
---noenable_scenario_park_and_go
---nouse_multi_thread_to_add_obstacles
---enable_multi_thread_in_dp_st_graph
---use_osqp_optimizer_for_reference_line
-
-# --smoother_config_filename=/apollo/modules/planning/conf/spiral_smoother_config.pb.txt
-# --smoother_config_filename=/apollo/modules/planning/conf/qp_spline_smoother_config.pb.txt
---smoother_config_filename=/apollo/modules/planning/conf/discrete_points_smoother_config.pb.txt
---enable_reference_line_stitching=false
-
-# --enable_perception_obstacles=false
-# --parking_inwards=false
-# --use_dual_variable_warm_start=true
-# --enable_open_space_planner_thread=true
-# --enable_record_debug=true
-# --use_gear_shift_trajectory=true
-# --enable_parallel_hybrid_a=true
---export_chart=true
-
-# --use_front_axe_center_in_path_planning=true
-# --obstacle_lon_start_buffer=0.4
-# --obstacle_lon_end_buffer=0.4
-
---noenable_smoother_failsafe
---enable_parallel_trajectory_smoothing
---nouse_s_curve_speed_smooth
---use_iterative_anchoring_smoother
-
---open_space_planning_period=1000.0
---open_space_standstill_acceleration=0.3
-
---lane_change_prepare_length=60.0
---enable_smarter_lane_change=true
---nonstatic_obstacle_nudge_l_buffer=0.4
---lane_change_obstacle_nudge_l_buffer=0.3
-
---use_st_drivable_boundary=true
-
-#--enable_skip_path_tasks=true
-#--enable_reuse_path_in_lane_follow=true
-
---use_smoothed_dp_guide_line=true
---use_soft_bound_in_nonlinear_speed_opt=false
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c3313465e72fb0f1ba171c39b2b0c26ae13d15c9" author="">
		<msg>Dreamview:Open space planner (#13709)

* Dreamview:open space planner add parking routing task at dv master

* Dreamview: change parking spot type to parking space type

* Dreamview: modify lint

* Change paraller type

* change parking space type

* Revert "Planning: fix collision check in grid_search (#11524)"

This reverts commit 5ddf4e3749170d7aa44ee7767d48b453b8321eea.

* planning: refine the low_speed_conf and vehicle_param and jerk_path_optimizer_config

* task_manager: add the plannig part of auto park and add the function of plot calibration

* planning: add parallel parking

* planning: remove the code of plot boundary

* remove redundant comment

* remove redundant comment of planning

* planning: add functiong to show parking_space size check info (#13587)

* planning: Add wheel alignment logic

* planning: add wheel alignment logic

* planning fix the build failed

* Remove debug code and change parking space type

* cpp lint

* Dreamview:add build fe for open space planner on master

Co-authored-by: lilu15 &lt;m15575882843@163.com&gt;
Co-authored-by: xiaoluauto &lt;35224268+xiaoluauto@users.noreply.github.com&gt;</msg>
		<modified_files>
			<file old_path="modules\control\control_component.cc" new_path="modules\control\control_component.cc" added_lines="6" deleted_lines="1">
				<diff>@@ -412,7 +412,12 @@ bool ControlComponent::Proc() {
         local_view_.trajectory().header().lidar_timestamp(), start_time,
         end_time);
   }
-
+  if (local_view_.trajectory().complete_parking()) {
+    control_command.set_brake(0.0);
+    control_command.set_throttle(0.0);
+    control_command.set_steering_target(0.0);
+    control_command.set_steering_rate(0.0);
+  }
   control_cmd_writer_-&gt;Write(control_command);
   return true;
 }
</diff>
			</file>
			<file old_path="modules\dreamview\backend\common\dreamview_gflags.cc" new_path="modules\dreamview\backend\common\dreamview_gflags.cc" added_lines="4" deleted_lines="0">
				<diff>@@ -108,3 +108,7 @@ DEFINE_string(lidar_calibration_mode, "Lidar-IMU Sensor Calibration",
 
 DEFINE_string(camera_calibration_mode, "Camera-Lidar Sensor Calibration",
               "Name of camera_to_lidar calibration mode.");
+
+DEFINE_double(parking_routing_distance_threshold, 20.0,
+              "For open space planner parking situation: get the routing"
+              "end point based on this threshold.");
</diff>
			</file>
			<file old_path="modules\dreamview\backend\common\dreamview_gflags.h" new_path="modules\dreamview\backend\common\dreamview_gflags.h" added_lines="2" deleted_lines="0">
				<diff>@@ -69,3 +69,5 @@ DECLARE_string(vehicle_calibration_mode);
 DECLARE_string(lidar_calibration_mode);
 
 DECLARE_string(camera_calibration_mode);
+
+DECLARE_double(parking_routing_distance_threshold);
</diff>
			</file>
			<file old_path="modules\dreamview\backend\map\map_service.cc" new_path="modules\dreamview\backend\map\map_service.cc" added_lines="30" deleted_lines="0">
				<diff>@@ -429,6 +429,36 @@ bool MapService::ConstructLaneWayPointWithHeading(
   return true;
 }
 
+bool MapService::ConstructLaneWayPointWithLaneId(
+    const double x, const double y, const std::string id,
+    routing::LaneWaypoint *laneWayPoint) const {
+  LaneInfoConstPtr lane = HDMap()-&gt;GetLaneById(hdmap::MakeMapId(id));
+  if (!lane) {
+    return false;
+  }
+
+  if (!CheckRoutingPointLaneType(lane)) {
+    return false;
+  }
+
+  double s, l;
+  PointENU point;
+  point.set_x(x);
+  point.set_y(y);
+
+  if (!lane-&gt;GetProjection({point.x(), point.y()}, &amp;s, &amp;l)) {
+    return false;
+  }
+
+  laneWayPoint-&gt;set_id(id);
+  laneWayPoint-&gt;set_s(s);
+  auto *pose = laneWayPoint-&gt;mutable_pose();
+  pose-&gt;set_x(x);
+  pose-&gt;set_y(y);
+
+  return true;
+}
+
 bool MapService::CheckRoutingPoint(const double x, const double y) const {
   double s, l;
   LaneInfoConstPtr lane;
</diff>
			</file>
			<file old_path="modules\dreamview\backend\map\map_service.h" new_path="modules\dreamview\backend\map\map_service.h" added_lines="7" deleted_lines="1">
				<diff>@@ -26,9 +26,11 @@
 #include &lt;boost/thread/locks.hpp&gt;
 #include &lt;boost/thread/shared_mutex.hpp&gt;
 
+#include "nlohmann/json.hpp"
+
 #include "modules/dreamview/proto/simulation_world.pb.h"
+
 #include "modules/map/pnc_map/pnc_map.h"
-#include "nlohmann/json.hpp"
 
 /**
  * @namespace apollo::dreamview
@@ -76,6 +78,10 @@ class MapService {
       const double x, const double y, const double heading,
       routing::LaneWaypoint *laneWayPoint) const;
 
+  bool ConstructLaneWayPointWithLaneId(
+      const double x, const double y, const std::string id,
+      routing::LaneWaypoint *laneWayPoint) const;
+
   bool CheckRoutingPoint(const double x, const double y) const;
 
   bool CheckRoutingPointLaneType(apollo::hdmap::LaneInfoConstPtr lane) const;
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_service.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_service.cc" added_lines="1" deleted_lines="2">
				<diff>@@ -545,8 +545,7 @@ void SimulationWorldService::UpdateSimulationWorld(const Chassis &amp;chassis) {
 
   auto_driving_car-&gt;set_disengage_type(DeduceDisengageType(chassis));
 
-  auto_driving_car-&gt;set_battery_percentage(
-    chassis.battery_soc_percentage());
+  auto_driving_car-&gt;set_battery_percentage(chassis.battery_soc_percentage());
   auto_driving_car-&gt;set_gear_location(chassis.gear_location());
 }
 
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_service_test.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_service_test.cc" added_lines="0" deleted_lines="1">
				<diff>@@ -23,7 +23,6 @@
 #include "modules/common/adapters/adapter_gflags.h"
 #include "modules/common/configs/vehicle_config_helper.h"
 #include "modules/common/math/quaternion.h"
-
 #include "modules/dreamview/backend/common/dreamview_gflags.h"
 
 using apollo::canbus::Chassis;
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" added_lines="77" deleted_lines="1">
				<diff>@@ -38,6 +38,7 @@ using apollo::hdmap::EndWayPointFile;
 using apollo::relative_map::NavigationInfo;
 using apollo::routing::RoutingRequest;
 using apollo::task_manager::CycleRoutingTask;
+using apollo::task_manager::ParkingRoutingTask;
 using apollo::task_manager::Task;
 
 using Json = nlohmann::json;
@@ -193,6 +194,28 @@ void SimulationWorldUpdater::RegisterMessageHandlers() {
         }
       });
 
+  websocket_-&gt;RegisterMessageHandler(
+      "SendParkingRoutingRequest",
+      [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
+        auto task = std::make_shared&lt;Task&gt;();
+        auto *parking_routing_task = task-&gt;mutable_parking_routing_task();
+        bool succeed = ConstructParkingRoutingTask(json, parking_routing_task);
+        // For test routing
+        auto routing_request = std::make_shared&lt;RoutingRequest&gt;();
+        if (succeed) {
+          task-&gt;set_task_name("parking_routing_task");
+          task-&gt;set_task_type(apollo::task_manager::TaskType::PARKING_ROUTING);
+          sim_world_service_.PublishTask(task);
+          AINFO &lt;&lt; task-&gt;DebugString();
+          sim_world_service_.PublishMonitorMessage(
+              MonitorMessageItem::INFO, "parking routing task sent.");
+        } else {
+          sim_world_service_.PublishMonitorMessage(
+              MonitorMessageItem::ERROR,
+              "Failed to send a parking routing task to task manager module.");
+        }
+      });
+
   websocket_-&gt;RegisterMessageHandler(
       "RequestSimulationWorld",
       [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
@@ -345,6 +368,15 @@ void SimulationWorldUpdater::RegisterMessageHandlers() {
         }
       });
 
+  websocket_-&gt;RegisterMessageHandler(
+      "GetParkingRoutingDistance",
+      [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
+        Json response;
+        response["type"] = "ParkingRoutingDistance";
+        response["threshold"] = FLAGS_parking_routing_distance_threshold;
+        websocket_-&gt;SendData(conn, response.dump());
+      });
+
   websocket_-&gt;RegisterMessageHandler(
       "RequestPreprocessProgress",
       [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
@@ -473,11 +505,20 @@ bool SimulationWorldUpdater::ConstructRoutingRequest(
     AERROR &lt;&lt; "Failed to prepare a routing request: invalid end point.";
     return false;
   }
-  if (!map_service_-&gt;ConstructLaneWayPoint(end["x"], end["y"],
+  if (ContainsKey(end, "id")) {
+    if (!map_service_-&gt;ConstructLaneWayPointWithLaneId(
+            end["x"], end["y"], end["id"], routing_request-&gt;add_waypoint())) {
+      AERROR &lt;&lt; "Failed to prepare a routing request with lane id: "
+             &lt;&lt; end["id"] &lt;&lt; " cannot locate end point on map.";
+      return false;
+    }
+  } else {
+    if (!map_service_-&gt;ConstructLaneWayPoint(end["x"], end["y"],
                                            routing_request-&gt;add_waypoint())) {
     AERROR &lt;&lt; "Failed to prepare a routing request:"
            &lt;&lt; " cannot locate end point on map.";
     return false;
+    }
   }
 
   // set parking info
@@ -489,6 +530,23 @@ bool SimulationWorldUpdater::ConstructRoutingRequest(
              &lt;&lt; json["parkingInfo"].dump();
       return false;
     }
+    if (ContainsKey(json, "cornerPoints")) {
+      auto point_iter = json.find("cornerPoints");
+      auto *points =
+          requested_parking_info-&gt;mutable_corner_point()-&gt;mutable_point();
+      if (point_iter != json.end() &amp;&amp; point_iter-&gt;is_array()) {
+        for (size_t i = 0; i &lt; point_iter-&gt;size(); ++i) {
+          auto &amp;point = (*point_iter)[i];
+          auto *p = points-&gt;Add();
+          if (!ValidateCoordinate(point)) {
+            AERROR &lt;&lt; "Failed to add a corner point: invalid corner point.";
+            return false;
+          }
+          p-&gt;set_x(static_cast&lt;double&gt;(point["x"]));
+          p-&gt;set_y(static_cast&lt;double&gt;(point["y"]));
+        }
+      }
+    }
   }
 
   AINFO &lt;&lt; "Constructed RoutingRequest to be sent:\n"
@@ -497,6 +555,24 @@ bool SimulationWorldUpdater::ConstructRoutingRequest(
   return true;
 }
 
+bool SimulationWorldUpdater::ConstructParkingRoutingTask(
+    const Json &amp;json, ParkingRoutingTask *parking_routing_task) {
+  auto *routing_request = parking_routing_task-&gt;mutable_routing_request();
+  // set parking Space
+  if (!ContainsKey(json, "laneWidth")) {
+    AERROR &lt;&lt; "Failed to prepare a parking routing task: "
+           &lt;&lt; "lane width not found.";
+    return false;
+  }
+  bool succeed = ConstructRoutingRequest(json, routing_request);
+  if (succeed) {
+    parking_routing_task-&gt;set_lane_width(
+        static_cast&lt;double&gt;(json["laneWidth"]));
+    return true;
+  }
+  return false;
+}
+
 bool SimulationWorldUpdater::ValidateCoordinate(const nlohmann::json &amp;json) {
   if (!ContainsKey(json, "x") || !ContainsKey(json, "y")) {
     AERROR &lt;&lt; "Failed to find x or y coordinate.";
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_updater.h" new_path="modules\dreamview\backend\simulation_world\simulation_world_updater.h" added_lines="11" deleted_lines="0">
				<diff>@@ -98,6 +98,17 @@ class SimulationWorldUpdater {
       const nlohmann::json &amp;json,
       apollo::routing::RoutingRequest *routing_request);
 
+  /**
+   * @brief The function to construct a parking routing task from the given
+   * json,
+   * @param json that contains start, end, waypoint, parking info, lane width,
+   * @param parking_routing_task
+   * @return True if parking routing task is constructed successfully
+   */
+  bool ConstructParkingRoutingTask(
+      const nlohmann::json &amp;json,
+      apollo::task_manager::ParkingRoutingTask *parking_routing_task);
+
   bool ValidateCoordinate(const nlohmann::json &amp;json);
 
   /**
</diff>
			</file>
			<file old_path="modules\planning\open_space\coarse_trajectory_generator\hybrid_a_star.cc" new_path="modules\planning\open_space\coarse_trajectory_generator\hybrid_a_star.cc" added_lines="2" deleted_lines="5">
				<diff>@@ -648,7 +648,6 @@ bool HybridAStar::Plan(
   close_set_.clear();
   open_pq_ = decltype(open_pq_)();
   final_node_ = nullptr;
-
   std::vector&lt;std::vector&lt;common::math::LineSegment2d&gt;&gt;
       obstacles_linesegments_vec;
   for (const auto&amp; obstacle_vertices : obstacles_vertices_vec) {
@@ -662,7 +661,6 @@ bool HybridAStar::Plan(
     obstacles_linesegments_vec.emplace_back(obstacle_linesegments);
   }
   obstacles_linesegments_vec_ = std::move(obstacles_linesegments_vec);
-
   // load XYbounds
   XYbounds_ = XYbounds;
   // load nodes and obstacles
@@ -671,11 +669,11 @@ bool HybridAStar::Plan(
   end_node_.reset(
       new Node3d({ex}, {ey}, {ephi}, XYbounds_, planner_open_space_config_));
   if (!ValidityCheck(start_node_)) {
-    ADEBUG &lt;&lt; "start_node in collision with obstacles";
+    AERROR &lt;&lt; "start_node in collision with obstacles";
     return false;
   }
   if (!ValidityCheck(end_node_)) {
-    ADEBUG &lt;&lt; "end_node in collision with obstacles";
+    AERROR &lt;&lt; "end_node in collision with obstacles";
     return false;
   }
   double map_time = Clock::NowInSeconds();
@@ -685,7 +683,6 @@ bool HybridAStar::Plan(
   // load open set, pq
   open_set_.emplace(start_node_-&gt;GetIndex(), start_node_);
   open_pq_.emplace(start_node_-&gt;GetIndex(), start_node_-&gt;GetCost());
-
   // Hybrid A* begins
   size_t explored_node_num = 0;
   double astar_start_time = Clock::NowInSeconds();
</diff>
			</file>
			<file old_path="modules\planning\scenarios\park\valet_parking\valet_parking_scenario.cc" new_path="modules\planning\scenarios\park\valet_parking\valet_parking_scenario.cc" added_lines="10" deleted_lines="1">
				<diff>@@ -132,7 +132,7 @@ bool ValetParkingScenario::IsTransferable(const Frame&amp; frame,
     return false;
   }
 
-  if (!CheckDistanceToParkingSpot(vehicle_state, nearby_path,
+  if (!CheckDistanceToParkingSpot(frame, vehicle_state, nearby_path,
                                   parking_start_range, parking_space_overlap)) {
     ADEBUG &lt;&lt; "target parking spot found, but too far, distance larger than "
               "pre-defined distance"
@@ -157,6 +157,7 @@ bool ValetParkingScenario::SearchTargetParkingSpotOnPath(
 }
 
 bool ValetParkingScenario::CheckDistanceToParkingSpot(
+    const Frame&amp; frame,
     const VehicleState&amp; vehicle_state, const Path&amp; nearby_path,
     const double parking_start_range,
     const PathOverlap&amp; parking_space_overlap) {
@@ -170,6 +171,14 @@ bool ValetParkingScenario::CheckDistanceToParkingSpot(
       hdmap-&gt;GetParkingSpaceById(id);
   Vec2d left_bottom_point = target_parking_spot_ptr-&gt;polygon().points().at(0);
   Vec2d right_bottom_point = target_parking_spot_ptr-&gt;polygon().points().at(1);
+  const auto &amp;routing_request =
+      frame.local_view().routing-&gt;routing_request();
+  auto corner_point =
+      routing_request.parking_info().corner_point();
+  left_bottom_point.set_x(corner_point.point().at(0).x());
+  left_bottom_point.set_y(corner_point.point().at(0).y());
+  right_bottom_point.set_x(corner_point.point().at(1).x());
+  right_bottom_point.set_y(corner_point.point().at(1).y());
   double left_bottom_point_s = 0.0;
   double left_bottom_point_l = 0.0;
   double right_bottom_point_s = 0.0;
</diff>
			</file>
			<file old_path="modules\planning\scenarios\park\valet_parking\valet_parking_scenario.h" new_path="modules\planning\scenarios\park\valet_parking\valet_parking_scenario.h" added_lines="1" deleted_lines="0">
				<diff>@@ -66,6 +66,7 @@ class ValetParkingScenario : public Scenario {
       const hdmap::Path&amp; nearby_path, const std::string&amp; target_parking_id,
       hdmap::PathOverlap* parking_space_overlap);
   static bool CheckDistanceToParkingSpot(
+      const Frame&amp; frame,
       const common::VehicleState&amp; vehicle_state, const hdmap::Path&amp; nearby_path,
       const double parking_start_range,
       const hdmap::PathOverlap&amp; parking_space_overlap);
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_pre_stop_decider.cc" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_pre_stop_decider.cc" added_lines="8" deleted_lines="0">
				<diff>@@ -97,6 +97,10 @@ bool OpenSpacePreStopDecider::CheckPullOverPreStop(
 bool OpenSpacePreStopDecider::CheckParkingSpotPreStop(
     Frame* const frame, ReferenceLineInfo* const reference_line_info,
     double* target_s) {
+  const auto &amp;routing_request =
+      frame-&gt;local_view().routing-&gt;routing_request();
+  auto corner_point =
+      routing_request.parking_info().corner_point();
   const auto&amp; target_parking_spot_id =
       frame-&gt;open_space_info().target_parking_spot_id();
   const auto&amp; nearby_path = reference_line_info-&gt;reference_line().map_path();
@@ -122,6 +126,10 @@ bool OpenSpacePreStopDecider::CheckParkingSpotPreStop(
           target_parking_spot_ptr-&gt;polygon().points().at(0);
       Vec2d right_bottom_point =
           target_parking_spot_ptr-&gt;polygon().points().at(1);
+      left_bottom_point.set_x(corner_point.point().at(0).x());
+      left_bottom_point.set_y(corner_point.point().at(0).y());
+      right_bottom_point.set_x(corner_point.point().at(1).x());
+      right_bottom_point.set_y(corner_point.point().at(1).y());
       double left_bottom_point_s = 0.0;
       double left_bottom_point_l = 0.0;
       double right_bottom_point_s = 0.0;
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" added_lines="58" deleted_lines="3">
				<diff>@@ -38,6 +38,7 @@ using apollo::hdmap::LaneInfoConstPtr;
 using apollo::hdmap::LaneSegment;
 using apollo::hdmap::ParkingSpaceInfoConstPtr;
 using apollo::hdmap::Path;
+using apollo::routing::ParkingSpaceType;
 
 OpenSpaceRoiDecider::OpenSpaceRoiDecider(
     const TaskConfig &amp;config,
@@ -212,6 +213,9 @@ void OpenSpaceRoiDecider::SetOrigin(
 
 void OpenSpaceRoiDecider::SetParkingSpotEndPose(
     Frame *const frame, const std::array&lt;common::math::Vec2d, 4&gt; &amp;vertices) {
+  const auto &amp;routing_request =
+        frame-&gt;local_view().routing-&gt;routing_request();
+  auto plot_type = routing_request.parking_info().parking_space_type();
   auto left_top = vertices[0];
   auto left_down = vertices[1];
   auto right_down = vertices[2];
@@ -264,7 +268,14 @@ void OpenSpaceRoiDecider::SetParkingSpotEndPose(
                                parking_depth_buffer);
     }
   }
-
+  if (plot_type == ParkingSpaceType::PARALLEL_PARKING) {
+    double parllel_park_end_x_buffer =
+        config_.open_space_roi_decider_config().parallel_park_end_x_buffer();
+    parking_spot_heading = (left_down - right_down).Angle();
+    end_y = (left_top.y() + left_down.y()) / 2.0;
+    end_x = left_top.x() + vehicle_params_.back_edge_to_center() +
+      parllel_park_end_x_buffer;
+  }
   auto *end_pose =
       frame-&gt;mutable_open_space_info()-&gt;mutable_open_space_end_pose();
   end_pose-&gt;push_back(end_x);
@@ -1189,6 +1200,9 @@ bool OpenSpaceRoiDecider::GetParkAndGoBoundary(
 bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
                                          std::array&lt;Vec2d, 4&gt; *vertices,
                                          Path *nearby_path) {
+  const auto &amp;routing_request =
+        frame-&gt;local_view().routing-&gt;routing_request();
+  auto plot_type = routing_request.parking_info().parking_space_type();
   if (frame == nullptr) {
     AERROR &lt;&lt; "Invalid frame, fail to GetParkingSpotFromMap from frame. ";
     return false;
@@ -1240,6 +1254,17 @@ bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
           LaneSegment(next_lane, next_lane-&gt;accumulate_s().front(),
                       next_lane-&gt;accumulate_s().back());
       segments_vector.push_back(next_lanesegment);
+      size_t succeed_lanes_num = next_lane-&gt;lane().successor_id_size();
+      if (succeed_lanes_num != 0) {
+        for (size_t j = 0; j &lt; succeed_lanes_num; j++) {
+          auto succeed_lane_id = next_lane-&gt;lane().successor_id(j);
+          auto succeed_lane = hdmap_-&gt;GetLaneById(succeed_lane_id);
+          LaneSegment succeed_lanesegment =
+            LaneSegment(succeed_lane, succeed_lane-&gt;accumulate_s().front(),
+                        succeed_lane-&gt;accumulate_s().back());
+            segments_vector.push_back(succeed_lanesegment);
+        }
+      }
       *nearby_path = Path(segments_vector);
       SearchTargetParkingSpotOnPath(*nearby_path, &amp;target_parking_spot);
       if (target_parking_spot != nullptr) {
@@ -1258,7 +1283,7 @@ bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
     return false;
   }
 
-  if (!CheckDistanceToParkingSpot(*nearby_path, target_parking_spot)) {
+  if (!CheckDistanceToParkingSpot(frame, *nearby_path, target_parking_spot)) {
     AERROR &lt;&lt; "target parking spot found, but too far, distance larger than "
               "pre-defined distance";
     return false;
@@ -1270,7 +1295,28 @@ bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
   Vec2d left_down = target_parking_spot-&gt;polygon().points().at(0);
   Vec2d right_down = target_parking_spot-&gt;polygon().points().at(1);
   Vec2d right_top = target_parking_spot-&gt;polygon().points().at(2);
-
+  if (plot_type == ParkingSpaceType::PARALLEL_PARKING) {
+    const auto &amp;routing_request =
+      frame-&gt;local_view().routing-&gt;routing_request();
+    auto corner_point =
+        routing_request.parking_info().corner_point();
+    left_top.set_x(corner_point.point().at(3).x());
+    left_top.set_y(corner_point.point().at(3).y());
+    left_down.set_x(corner_point.point().at(0).x());
+    left_down.set_y(corner_point.point().at(0).y());
+    right_down.set_x(corner_point.point().at(1).x());
+    right_down.set_y(corner_point.point().at(1).y());
+    right_top.set_x(corner_point.point().at(2).x());
+    right_top.set_y(corner_point.point().at(2).y());
+    double extend_right_x_buffer =
+      config_.open_space_roi_decider_config().extend_right_x_buffer();
+    double extend_left_x_buffer =
+      config_.open_space_roi_decider_config().extend_left_x_buffer();
+    right_top.set_x(right_top.x() + extend_right_x_buffer);
+    left_top.set_x(left_top.x() - extend_left_x_buffer);
+    left_down.set_x(left_down.x() - extend_left_x_buffer);
+    right_down.set_x(right_down.x() + extend_right_x_buffer);
+  }
   std::array&lt;Vec2d, 4&gt; parking_vertices{left_top, left_down, right_down,
                                         right_top};
 
@@ -1354,10 +1400,19 @@ void OpenSpaceRoiDecider::SearchTargetParkingSpotOnPath(
 }
 
 bool OpenSpaceRoiDecider::CheckDistanceToParkingSpot(
+    Frame *const frame,
     const hdmap::Path &amp;nearby_path,
     const hdmap::ParkingSpaceInfoConstPtr &amp;target_parking_spot) {
+  const auto &amp;routing_request =
+      frame-&gt;local_view().routing-&gt;routing_request();
+  auto corner_point =
+      routing_request.parking_info().corner_point();
   Vec2d left_bottom_point = target_parking_spot-&gt;polygon().points().at(0);
   Vec2d right_bottom_point = target_parking_spot-&gt;polygon().points().at(1);
+  left_bottom_point.set_x(corner_point.point().at(0).x());
+  left_bottom_point.set_y(corner_point.point().at(0).y());
+  right_bottom_point.set_x(corner_point.point().at(1).x());
+  right_bottom_point.set_y(corner_point.point().at(1).y());
   double left_bottom_point_s = 0.0;
   double left_bottom_point_l = 0.0;
   double right_bottom_point_s = 0.0;
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.h" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.h" added_lines="1" deleted_lines="0">
				<diff>@@ -147,6 +147,7 @@ class OpenSpaceRoiDecider : public Decider {
 
   // @brief if not close enough to parking spot, return false
   bool CheckDistanceToParkingSpot(
+      Frame *const frame,
       const hdmap::Path &amp;nearby_path,
       const hdmap::ParkingSpaceInfoConstPtr &amp;target_parking_spot);
 
</diff>
			</file>
			<file old_path="modules\planning\tasks\optimizers\open_space_trajectory_generation\open_space_trajectory_provider.cc" new_path="modules\planning\tasks\optimizers\open_space_trajectory_generation\open_space_trajectory_provider.cc" added_lines="4" deleted_lines="1">
				<diff>@@ -138,7 +138,8 @@ Status OpenSpaceTrajectoryProvider::Process() {
   }
   // Get open_space_info from current frame
   const auto&amp; open_space_info = frame_-&gt;open_space_info();
-
+  ADCTrajectory &amp;temp_trajectory =
+    const_cast&lt;ADCTrajectory&amp;&gt; (frame_-&gt;current_frame_planned_trajectory());
   if (FLAGS_enable_open_space_planner_thread) {
     ADEBUG &lt;&lt; "Open space plan in multi-threads mode";
 
@@ -168,6 +169,7 @@ Status OpenSpaceTrajectoryProvider::Process() {
             open_space_info.origin_heading(), open_space_info.origin_point())) {
       GenerateStopTrajectory(trajectory_data);
       is_generation_thread_stop_.store(true);
+      temp_trajectory.set_complete_parking(true);
       return Status(ErrorCode::OK, "Vehicle is near to destination");
     }
 
@@ -232,6 +234,7 @@ Status OpenSpaceTrajectoryProvider::Process() {
     if (IsVehicleNearDestination(vehicle_state, end_pose, rotate_angle,
                                  translate_origin)) {
       GenerateStopTrajectory(trajectory_data);
+      temp_trajectory.set_complete_parking(true);
       return Status(ErrorCode::OK, "Vehicle is near to destination");
     }
 
</diff>
			</file>
			<file old_path="modules\planning\tasks\optimizers\open_space_trajectory_generation\open_space_trajectory_provider.h" new_path="modules\planning\tasks\optimizers\open_space_trajectory_generation\open_space_trajectory_provider.h" added_lines="1" deleted_lines="0">
				<diff>@@ -29,6 +29,7 @@
 #include "modules/planning/tasks/optimizers/open_space_trajectory_generation/open_space_trajectory_optimizer.h"
 #include "modules/planning/tasks/optimizers/trajectory_optimizer.h"
 #include "modules/planning/tasks/task.h"
+#include "modules/planning/proto/planning.pb.h"
 
 namespace apollo {
 namespace planning {
</diff>
			</file>
			<file old_path="modules\task_manager\common\task_manager_gflags.cc" new_path="modules\task_manager\common\task_manager_gflags.cc" added_lines="4" deleted_lines="0">
				<diff>@@ -21,3 +21,7 @@ DEFINE_string(task_manager_node_name, "task_manager", "the name for this node");
 DEFINE_double(threshold_for_destination_check, 1.0,
               "meters, which is 100 feet.  This threshold is used to check if"
               "the vehicle reaches the destination");
+
+DEFINE_double(plot_size_buffer, 0.2, "the size buffer of parking plot");
+
+DEFINE_double(road_width_buffer, 0.0, "the size buffer of road width");
</diff>
			</file>
			<file old_path="modules\task_manager\common\task_manager_gflags.h" new_path="modules\task_manager\common\task_manager_gflags.h" added_lines="4" deleted_lines="0">
				<diff>@@ -21,3 +21,7 @@
 DECLARE_string(task_manager_node_name);
 
 DECLARE_double(threshold_for_destination_check);
+
+DECLARE_double(plot_size_buffer);
+
+DECLARE_double(road_width_buffer);
</diff>
			</file>
			<file old_path="modules\task_manager\conf\task_manager.conf" new_path="modules\task_manager\conf\task_manager.conf" added_lines="3" deleted_lines="0">
				<diff>@@ -1,2 +1,4 @@
 --flagfile=/apollo/modules/common/data/global_flagfile.txt
---threshold_for_destination_check=10.0
\ No newline at end of file
+--threshold_for_destination_check=10.0
+--plot_size_buffer=0.2
+--road_width_buffer=0.0
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.cc" new_path="modules\task_manager\task_manager_component.cc" added_lines="45" deleted_lines="13">
				<diff>@@ -59,25 +59,57 @@ bool TaskManagerComponent::Init() {
 
 bool TaskManagerComponent::Proc(const std::shared_ptr&lt;Task&gt;&amp; task) {
   task_name_ = task-&gt;task_name();
-  if (task-&gt;task_type() != CYCLE_ROUTING) {
-    AINFO &lt;&lt; "Task type is not cycle_routing.";
+  if (task-&gt;task_type() != CYCLE_ROUTING &amp;&amp;
+      task-&gt;task_type() != PARKING_ROUTING) {
+    AERROR &lt;&lt; "Task type is not cycle_routing.";
     return false;
   }
+  if (task-&gt;task_type() == CYCLE_ROUTING) {
+    cycle_routing_manager_ = std::make_shared&lt;CycleRoutingManager&gt;();
+    cycle_routing_manager_-&gt;Init(task-&gt;cycle_routing_task());
+    routing_request_ = task-&gt;cycle_routing_task().routing_request();
+    Rate rate(1.0);
 
-  cycle_routing_manager_ = std::make_shared&lt;CycleRoutingManager&gt;();
-  cycle_routing_manager_-&gt;Init(task-&gt;cycle_routing_task());
-  routing_request_ = task-&gt;cycle_routing_task().routing_request();
-  Rate rate(1.0);
-
-  while (cycle_routing_manager_-&gt;GetCycle() &gt; 0) {
-    if (cycle_routing_manager_-&gt;GetNewRouting(localization_.pose(),
-                                              &amp;routing_request_)) {
+    while (cycle_routing_manager_-&gt;GetCycle() &gt; 0) {
+      if (cycle_routing_manager_-&gt;GetNewRouting(localization_.pose(),
+                                                &amp;routing_request_)) {
+        common::util::FillHeader(node_-&gt;Name(), &amp;routing_request_);
+        request_writer_-&gt;Write(routing_request_);
+        AINFO &lt;&lt; "[TaskManagerComponent]Reach begin/end point: "
+              &lt;&lt; "routing manager send a routing request. ";
+      }
+      rate.Sleep();
+    }
+  } else if (task-&gt;task_type() == PARKING_ROUTING) {
+    AERROR &lt;&lt; "enter the parking routing task";
+    parking_routing_manager_ = std::make_shared&lt;ParkingRoutingManager&gt;();
+    parking_routing_manager_-&gt;Init(task-&gt;parking_routing_task());
+    routing_request_ = task-&gt;parking_routing_task().routing_request();
+    if (parking_routing_manager_-&gt;
+        SizeVerification(task-&gt;parking_routing_task()) &amp;&amp;
+        parking_routing_manager_-&gt;
+        RoadWidthVerification(task-&gt;parking_routing_task())) {
+      AERROR &lt;&lt; "compelet the Verification";
       common::util::FillHeader(node_-&gt;Name(), &amp;routing_request_);
       request_writer_-&gt;Write(routing_request_);
-      AINFO &lt;&lt; "[TaskManagerComponent]Reach begin/end point: "
-            &lt;&lt; "routing manager send a routing request. ";
+      AINFO &lt;&lt; "send a auto parking task";
+    } else {
+      auto last_routing_response_ = routing_response_;
+      if (!routing_response_.has_header()) {
+           AINFO &lt;&lt; "[TaskManagerComponent]parking routing failed";
+           return false;
+         }
+         if (last_routing_response_.has_header()) {
+           if (last_routing_response_.header().sequence_num() ==
+               routing_response_.header().sequence_num()) {
+             AINFO &lt;&lt; "[TaskManagerComponent]No parking routing response: "
+                   &lt;&lt; "new parking routing failed";
+             return false;
+           }
+         }
+      AERROR &lt;&lt; "plot verification failed, please select suitable plot!";
+      return false;
     }
-    rate.Sleep();
   }
   return true;
 }
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.h" new_path="modules\task_manager\task_manager_component.h" added_lines="3" deleted_lines="1">
				<diff>@@ -22,7 +22,7 @@
 #include "cyber/class_loader/class_loader.h"
 #include "cyber/component/component.h"
 #include "modules/task_manager/cycle_routing_manager.h"
-
+#include "modules/task_manager/parking_routing_manager.h"
 namespace apollo {
 namespace task_manager {
 
@@ -41,7 +41,9 @@ class TaskManagerComponent final : public cyber::Component&lt;task_manager::Task&gt; {
   std::shared_ptr&lt;cyber::Reader&lt;LocalizationEstimate&gt;&gt; localization_reader_;
   std::shared_ptr&lt;cyber::Writer&lt;routing::RoutingRequest&gt;&gt; request_writer_;
   std::shared_ptr&lt;CycleRoutingManager&gt; cycle_routing_manager_;
+  std::shared_ptr&lt;ParkingRoutingManager&gt; parking_routing_manager_;
   routing::RoutingRequest routing_request_;
+  routing::RoutingResponse routing_response_;
   LocalizationEstimate localization_;
   std::mutex mutex_;
   std::string task_name_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="266afbf68d83fa6fac7a812ff8a950223f5ab2c0" author="lfcarol">
		<msg>Revert "Dreamview:Open space planner (#13709)" (#13717)

This reverts commit c3313465e72fb0f1ba171c39b2b0c26ae13d15c9.</msg>
		<modified_files>
			<file old_path="modules\control\control_component.cc" new_path="modules\control\control_component.cc" added_lines="1" deleted_lines="6">
				<diff>@@ -412,12 +412,7 @@ bool ControlComponent::Proc() {
         local_view_.trajectory().header().lidar_timestamp(), start_time,
         end_time);
   }
-  if (local_view_.trajectory().complete_parking()) {
-    control_command.set_brake(0.0);
-    control_command.set_throttle(0.0);
-    control_command.set_steering_target(0.0);
-    control_command.set_steering_rate(0.0);
-  }
+
   control_cmd_writer_-&gt;Write(control_command);
   return true;
 }
</diff>
			</file>
			<file old_path="modules\dreamview\backend\common\dreamview_gflags.cc" new_path="modules\dreamview\backend\common\dreamview_gflags.cc" added_lines="0" deleted_lines="4">
				<diff>@@ -108,7 +108,3 @@ DEFINE_string(lidar_calibration_mode, "Lidar-IMU Sensor Calibration",
 
 DEFINE_string(camera_calibration_mode, "Camera-Lidar Sensor Calibration",
               "Name of camera_to_lidar calibration mode.");
-
-DEFINE_double(parking_routing_distance_threshold, 20.0,
-              "For open space planner parking situation: get the routing"
-              "end point based on this threshold.");
</diff>
			</file>
			<file old_path="modules\dreamview\backend\common\dreamview_gflags.h" new_path="modules\dreamview\backend\common\dreamview_gflags.h" added_lines="0" deleted_lines="2">
				<diff>@@ -69,5 +69,3 @@ DECLARE_string(vehicle_calibration_mode);
 DECLARE_string(lidar_calibration_mode);
 
 DECLARE_string(camera_calibration_mode);
-
-DECLARE_double(parking_routing_distance_threshold);
</diff>
			</file>
			<file old_path="modules\dreamview\backend\map\map_service.cc" new_path="modules\dreamview\backend\map\map_service.cc" added_lines="0" deleted_lines="30">
				<diff>@@ -429,36 +429,6 @@ bool MapService::ConstructLaneWayPointWithHeading(
   return true;
 }
 
-bool MapService::ConstructLaneWayPointWithLaneId(
-    const double x, const double y, const std::string id,
-    routing::LaneWaypoint *laneWayPoint) const {
-  LaneInfoConstPtr lane = HDMap()-&gt;GetLaneById(hdmap::MakeMapId(id));
-  if (!lane) {
-    return false;
-  }
-
-  if (!CheckRoutingPointLaneType(lane)) {
-    return false;
-  }
-
-  double s, l;
-  PointENU point;
-  point.set_x(x);
-  point.set_y(y);
-
-  if (!lane-&gt;GetProjection({point.x(), point.y()}, &amp;s, &amp;l)) {
-    return false;
-  }
-
-  laneWayPoint-&gt;set_id(id);
-  laneWayPoint-&gt;set_s(s);
-  auto *pose = laneWayPoint-&gt;mutable_pose();
-  pose-&gt;set_x(x);
-  pose-&gt;set_y(y);
-
-  return true;
-}
-
 bool MapService::CheckRoutingPoint(const double x, const double y) const {
   double s, l;
   LaneInfoConstPtr lane;
</diff>
			</file>
			<file old_path="modules\dreamview\backend\map\map_service.h" new_path="modules\dreamview\backend\map\map_service.h" added_lines="1" deleted_lines="7">
				<diff>@@ -26,11 +26,9 @@
 #include &lt;boost/thread/locks.hpp&gt;
 #include &lt;boost/thread/shared_mutex.hpp&gt;
 
-#include "nlohmann/json.hpp"
-
 #include "modules/dreamview/proto/simulation_world.pb.h"
-
 #include "modules/map/pnc_map/pnc_map.h"
+#include "nlohmann/json.hpp"
 
 /**
  * @namespace apollo::dreamview
@@ -78,10 +76,6 @@ class MapService {
       const double x, const double y, const double heading,
       routing::LaneWaypoint *laneWayPoint) const;
 
-  bool ConstructLaneWayPointWithLaneId(
-      const double x, const double y, const std::string id,
-      routing::LaneWaypoint *laneWayPoint) const;
-
   bool CheckRoutingPoint(const double x, const double y) const;
 
   bool CheckRoutingPointLaneType(apollo::hdmap::LaneInfoConstPtr lane) const;
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_service.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_service.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -545,7 +545,8 @@ void SimulationWorldService::UpdateSimulationWorld(const Chassis &amp;chassis) {
 
   auto_driving_car-&gt;set_disengage_type(DeduceDisengageType(chassis));
 
-  auto_driving_car-&gt;set_battery_percentage(chassis.battery_soc_percentage());
+  auto_driving_car-&gt;set_battery_percentage(
+    chassis.battery_soc_percentage());
   auto_driving_car-&gt;set_gear_location(chassis.gear_location());
 }
 
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_service_test.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_service_test.cc" added_lines="1" deleted_lines="0">
				<diff>@@ -23,6 +23,7 @@
 #include "modules/common/adapters/adapter_gflags.h"
 #include "modules/common/configs/vehicle_config_helper.h"
 #include "modules/common/math/quaternion.h"
+
 #include "modules/dreamview/backend/common/dreamview_gflags.h"
 
 using apollo::canbus::Chassis;
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" added_lines="1" deleted_lines="77">
				<diff>@@ -38,7 +38,6 @@ using apollo::hdmap::EndWayPointFile;
 using apollo::relative_map::NavigationInfo;
 using apollo::routing::RoutingRequest;
 using apollo::task_manager::CycleRoutingTask;
-using apollo::task_manager::ParkingRoutingTask;
 using apollo::task_manager::Task;
 
 using Json = nlohmann::json;
@@ -194,28 +193,6 @@ void SimulationWorldUpdater::RegisterMessageHandlers() {
         }
       });
 
-  websocket_-&gt;RegisterMessageHandler(
-      "SendParkingRoutingRequest",
-      [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
-        auto task = std::make_shared&lt;Task&gt;();
-        auto *parking_routing_task = task-&gt;mutable_parking_routing_task();
-        bool succeed = ConstructParkingRoutingTask(json, parking_routing_task);
-        // For test routing
-        auto routing_request = std::make_shared&lt;RoutingRequest&gt;();
-        if (succeed) {
-          task-&gt;set_task_name("parking_routing_task");
-          task-&gt;set_task_type(apollo::task_manager::TaskType::PARKING_ROUTING);
-          sim_world_service_.PublishTask(task);
-          AINFO &lt;&lt; task-&gt;DebugString();
-          sim_world_service_.PublishMonitorMessage(
-              MonitorMessageItem::INFO, "parking routing task sent.");
-        } else {
-          sim_world_service_.PublishMonitorMessage(
-              MonitorMessageItem::ERROR,
-              "Failed to send a parking routing task to task manager module.");
-        }
-      });
-
   websocket_-&gt;RegisterMessageHandler(
       "RequestSimulationWorld",
       [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
@@ -368,15 +345,6 @@ void SimulationWorldUpdater::RegisterMessageHandlers() {
         }
       });
 
-  websocket_-&gt;RegisterMessageHandler(
-      "GetParkingRoutingDistance",
-      [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
-        Json response;
-        response["type"] = "ParkingRoutingDistance";
-        response["threshold"] = FLAGS_parking_routing_distance_threshold;
-        websocket_-&gt;SendData(conn, response.dump());
-      });
-
   websocket_-&gt;RegisterMessageHandler(
       "RequestPreprocessProgress",
       [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
@@ -505,20 +473,11 @@ bool SimulationWorldUpdater::ConstructRoutingRequest(
     AERROR &lt;&lt; "Failed to prepare a routing request: invalid end point.";
     return false;
   }
-  if (ContainsKey(end, "id")) {
-    if (!map_service_-&gt;ConstructLaneWayPointWithLaneId(
-            end["x"], end["y"], end["id"], routing_request-&gt;add_waypoint())) {
-      AERROR &lt;&lt; "Failed to prepare a routing request with lane id: "
-             &lt;&lt; end["id"] &lt;&lt; " cannot locate end point on map.";
-      return false;
-    }
-  } else {
-    if (!map_service_-&gt;ConstructLaneWayPoint(end["x"], end["y"],
+  if (!map_service_-&gt;ConstructLaneWayPoint(end["x"], end["y"],
                                            routing_request-&gt;add_waypoint())) {
     AERROR &lt;&lt; "Failed to prepare a routing request:"
            &lt;&lt; " cannot locate end point on map.";
     return false;
-    }
   }
 
   // set parking info
@@ -530,23 +489,6 @@ bool SimulationWorldUpdater::ConstructRoutingRequest(
              &lt;&lt; json["parkingInfo"].dump();
       return false;
     }
-    if (ContainsKey(json, "cornerPoints")) {
-      auto point_iter = json.find("cornerPoints");
-      auto *points =
-          requested_parking_info-&gt;mutable_corner_point()-&gt;mutable_point();
-      if (point_iter != json.end() &amp;&amp; point_iter-&gt;is_array()) {
-        for (size_t i = 0; i &lt; point_iter-&gt;size(); ++i) {
-          auto &amp;point = (*point_iter)[i];
-          auto *p = points-&gt;Add();
-          if (!ValidateCoordinate(point)) {
-            AERROR &lt;&lt; "Failed to add a corner point: invalid corner point.";
-            return false;
-          }
-          p-&gt;set_x(static_cast&lt;double&gt;(point["x"]));
-          p-&gt;set_y(static_cast&lt;double&gt;(point["y"]));
-        }
-      }
-    }
   }
 
   AINFO &lt;&lt; "Constructed RoutingRequest to be sent:\n"
@@ -555,24 +497,6 @@ bool SimulationWorldUpdater::ConstructRoutingRequest(
   return true;
 }
 
-bool SimulationWorldUpdater::ConstructParkingRoutingTask(
-    const Json &amp;json, ParkingRoutingTask *parking_routing_task) {
-  auto *routing_request = parking_routing_task-&gt;mutable_routing_request();
-  // set parking Space
-  if (!ContainsKey(json, "laneWidth")) {
-    AERROR &lt;&lt; "Failed to prepare a parking routing task: "
-           &lt;&lt; "lane width not found.";
-    return false;
-  }
-  bool succeed = ConstructRoutingRequest(json, routing_request);
-  if (succeed) {
-    parking_routing_task-&gt;set_lane_width(
-        static_cast&lt;double&gt;(json["laneWidth"]));
-    return true;
-  }
-  return false;
-}
-
 bool SimulationWorldUpdater::ValidateCoordinate(const nlohmann::json &amp;json) {
   if (!ContainsKey(json, "x") || !ContainsKey(json, "y")) {
     AERROR &lt;&lt; "Failed to find x or y coordinate.";
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_updater.h" new_path="modules\dreamview\backend\simulation_world\simulation_world_updater.h" added_lines="0" deleted_lines="11">
				<diff>@@ -98,17 +98,6 @@ class SimulationWorldUpdater {
       const nlohmann::json &amp;json,
       apollo::routing::RoutingRequest *routing_request);
 
-  /**
-   * @brief The function to construct a parking routing task from the given
-   * json,
-   * @param json that contains start, end, waypoint, parking info, lane width,
-   * @param parking_routing_task
-   * @return True if parking routing task is constructed successfully
-   */
-  bool ConstructParkingRoutingTask(
-      const nlohmann::json &amp;json,
-      apollo::task_manager::ParkingRoutingTask *parking_routing_task);
-
   bool ValidateCoordinate(const nlohmann::json &amp;json);
 
   /**
</diff>
			</file>
			<file old_path="modules\planning\open_space\coarse_trajectory_generator\hybrid_a_star.cc" new_path="modules\planning\open_space\coarse_trajectory_generator\hybrid_a_star.cc" added_lines="5" deleted_lines="2">
				<diff>@@ -648,6 +648,7 @@ bool HybridAStar::Plan(
   close_set_.clear();
   open_pq_ = decltype(open_pq_)();
   final_node_ = nullptr;
+
   std::vector&lt;std::vector&lt;common::math::LineSegment2d&gt;&gt;
       obstacles_linesegments_vec;
   for (const auto&amp; obstacle_vertices : obstacles_vertices_vec) {
@@ -661,6 +662,7 @@ bool HybridAStar::Plan(
     obstacles_linesegments_vec.emplace_back(obstacle_linesegments);
   }
   obstacles_linesegments_vec_ = std::move(obstacles_linesegments_vec);
+
   // load XYbounds
   XYbounds_ = XYbounds;
   // load nodes and obstacles
@@ -669,11 +671,11 @@ bool HybridAStar::Plan(
   end_node_.reset(
       new Node3d({ex}, {ey}, {ephi}, XYbounds_, planner_open_space_config_));
   if (!ValidityCheck(start_node_)) {
-    AERROR &lt;&lt; "start_node in collision with obstacles";
+    ADEBUG &lt;&lt; "start_node in collision with obstacles";
     return false;
   }
   if (!ValidityCheck(end_node_)) {
-    AERROR &lt;&lt; "end_node in collision with obstacles";
+    ADEBUG &lt;&lt; "end_node in collision with obstacles";
     return false;
   }
   double map_time = Clock::NowInSeconds();
@@ -683,6 +685,7 @@ bool HybridAStar::Plan(
   // load open set, pq
   open_set_.emplace(start_node_-&gt;GetIndex(), start_node_);
   open_pq_.emplace(start_node_-&gt;GetIndex(), start_node_-&gt;GetCost());
+
   // Hybrid A* begins
   size_t explored_node_num = 0;
   double astar_start_time = Clock::NowInSeconds();
</diff>
			</file>
			<file old_path="modules\planning\scenarios\park\valet_parking\valet_parking_scenario.cc" new_path="modules\planning\scenarios\park\valet_parking\valet_parking_scenario.cc" added_lines="1" deleted_lines="10">
				<diff>@@ -132,7 +132,7 @@ bool ValetParkingScenario::IsTransferable(const Frame&amp; frame,
     return false;
   }
 
-  if (!CheckDistanceToParkingSpot(frame, vehicle_state, nearby_path,
+  if (!CheckDistanceToParkingSpot(vehicle_state, nearby_path,
                                   parking_start_range, parking_space_overlap)) {
     ADEBUG &lt;&lt; "target parking spot found, but too far, distance larger than "
               "pre-defined distance"
@@ -157,7 +157,6 @@ bool ValetParkingScenario::SearchTargetParkingSpotOnPath(
 }
 
 bool ValetParkingScenario::CheckDistanceToParkingSpot(
-    const Frame&amp; frame,
     const VehicleState&amp; vehicle_state, const Path&amp; nearby_path,
     const double parking_start_range,
     const PathOverlap&amp; parking_space_overlap) {
@@ -171,14 +170,6 @@ bool ValetParkingScenario::CheckDistanceToParkingSpot(
       hdmap-&gt;GetParkingSpaceById(id);
   Vec2d left_bottom_point = target_parking_spot_ptr-&gt;polygon().points().at(0);
   Vec2d right_bottom_point = target_parking_spot_ptr-&gt;polygon().points().at(1);
-  const auto &amp;routing_request =
-      frame.local_view().routing-&gt;routing_request();
-  auto corner_point =
-      routing_request.parking_info().corner_point();
-  left_bottom_point.set_x(corner_point.point().at(0).x());
-  left_bottom_point.set_y(corner_point.point().at(0).y());
-  right_bottom_point.set_x(corner_point.point().at(1).x());
-  right_bottom_point.set_y(corner_point.point().at(1).y());
   double left_bottom_point_s = 0.0;
   double left_bottom_point_l = 0.0;
   double right_bottom_point_s = 0.0;
</diff>
			</file>
			<file old_path="modules\planning\scenarios\park\valet_parking\valet_parking_scenario.h" new_path="modules\planning\scenarios\park\valet_parking\valet_parking_scenario.h" added_lines="0" deleted_lines="1">
				<diff>@@ -66,7 +66,6 @@ class ValetParkingScenario : public Scenario {
       const hdmap::Path&amp; nearby_path, const std::string&amp; target_parking_id,
       hdmap::PathOverlap* parking_space_overlap);
   static bool CheckDistanceToParkingSpot(
-      const Frame&amp; frame,
       const common::VehicleState&amp; vehicle_state, const hdmap::Path&amp; nearby_path,
       const double parking_start_range,
       const hdmap::PathOverlap&amp; parking_space_overlap);
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_pre_stop_decider.cc" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_pre_stop_decider.cc" added_lines="0" deleted_lines="8">
				<diff>@@ -97,10 +97,6 @@ bool OpenSpacePreStopDecider::CheckPullOverPreStop(
 bool OpenSpacePreStopDecider::CheckParkingSpotPreStop(
     Frame* const frame, ReferenceLineInfo* const reference_line_info,
     double* target_s) {
-  const auto &amp;routing_request =
-      frame-&gt;local_view().routing-&gt;routing_request();
-  auto corner_point =
-      routing_request.parking_info().corner_point();
   const auto&amp; target_parking_spot_id =
       frame-&gt;open_space_info().target_parking_spot_id();
   const auto&amp; nearby_path = reference_line_info-&gt;reference_line().map_path();
@@ -126,10 +122,6 @@ bool OpenSpacePreStopDecider::CheckParkingSpotPreStop(
           target_parking_spot_ptr-&gt;polygon().points().at(0);
       Vec2d right_bottom_point =
           target_parking_spot_ptr-&gt;polygon().points().at(1);
-      left_bottom_point.set_x(corner_point.point().at(0).x());
-      left_bottom_point.set_y(corner_point.point().at(0).y());
-      right_bottom_point.set_x(corner_point.point().at(1).x());
-      right_bottom_point.set_y(corner_point.point().at(1).y());
       double left_bottom_point_s = 0.0;
       double left_bottom_point_l = 0.0;
       double right_bottom_point_s = 0.0;
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" added_lines="3" deleted_lines="58">
				<diff>@@ -38,7 +38,6 @@ using apollo::hdmap::LaneInfoConstPtr;
 using apollo::hdmap::LaneSegment;
 using apollo::hdmap::ParkingSpaceInfoConstPtr;
 using apollo::hdmap::Path;
-using apollo::routing::ParkingSpaceType;
 
 OpenSpaceRoiDecider::OpenSpaceRoiDecider(
     const TaskConfig &amp;config,
@@ -213,9 +212,6 @@ void OpenSpaceRoiDecider::SetOrigin(
 
 void OpenSpaceRoiDecider::SetParkingSpotEndPose(
     Frame *const frame, const std::array&lt;common::math::Vec2d, 4&gt; &amp;vertices) {
-  const auto &amp;routing_request =
-        frame-&gt;local_view().routing-&gt;routing_request();
-  auto plot_type = routing_request.parking_info().parking_space_type();
   auto left_top = vertices[0];
   auto left_down = vertices[1];
   auto right_down = vertices[2];
@@ -268,14 +264,7 @@ void OpenSpaceRoiDecider::SetParkingSpotEndPose(
                                parking_depth_buffer);
     }
   }
-  if (plot_type == ParkingSpaceType::PARALLEL_PARKING) {
-    double parllel_park_end_x_buffer =
-        config_.open_space_roi_decider_config().parallel_park_end_x_buffer();
-    parking_spot_heading = (left_down - right_down).Angle();
-    end_y = (left_top.y() + left_down.y()) / 2.0;
-    end_x = left_top.x() + vehicle_params_.back_edge_to_center() +
-      parllel_park_end_x_buffer;
-  }
+
   auto *end_pose =
       frame-&gt;mutable_open_space_info()-&gt;mutable_open_space_end_pose();
   end_pose-&gt;push_back(end_x);
@@ -1200,9 +1189,6 @@ bool OpenSpaceRoiDecider::GetParkAndGoBoundary(
 bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
                                          std::array&lt;Vec2d, 4&gt; *vertices,
                                          Path *nearby_path) {
-  const auto &amp;routing_request =
-        frame-&gt;local_view().routing-&gt;routing_request();
-  auto plot_type = routing_request.parking_info().parking_space_type();
   if (frame == nullptr) {
     AERROR &lt;&lt; "Invalid frame, fail to GetParkingSpotFromMap from frame. ";
     return false;
@@ -1254,17 +1240,6 @@ bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
           LaneSegment(next_lane, next_lane-&gt;accumulate_s().front(),
                       next_lane-&gt;accumulate_s().back());
       segments_vector.push_back(next_lanesegment);
-      size_t succeed_lanes_num = next_lane-&gt;lane().successor_id_size();
-      if (succeed_lanes_num != 0) {
-        for (size_t j = 0; j &lt; succeed_lanes_num; j++) {
-          auto succeed_lane_id = next_lane-&gt;lane().successor_id(j);
-          auto succeed_lane = hdmap_-&gt;GetLaneById(succeed_lane_id);
-          LaneSegment succeed_lanesegment =
-            LaneSegment(succeed_lane, succeed_lane-&gt;accumulate_s().front(),
-                        succeed_lane-&gt;accumulate_s().back());
-            segments_vector.push_back(succeed_lanesegment);
-        }
-      }
       *nearby_path = Path(segments_vector);
       SearchTargetParkingSpotOnPath(*nearby_path, &amp;target_parking_spot);
       if (target_parking_spot != nullptr) {
@@ -1283,7 +1258,7 @@ bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
     return false;
   }
 
-  if (!CheckDistanceToParkingSpot(frame, *nearby_path, target_parking_spot)) {
+  if (!CheckDistanceToParkingSpot(*nearby_path, target_parking_spot)) {
     AERROR &lt;&lt; "target parking spot found, but too far, distance larger than "
               "pre-defined distance";
     return false;
@@ -1295,28 +1270,7 @@ bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
   Vec2d left_down = target_parking_spot-&gt;polygon().points().at(0);
   Vec2d right_down = target_parking_spot-&gt;polygon().points().at(1);
   Vec2d right_top = target_parking_spot-&gt;polygon().points().at(2);
-  if (plot_type == ParkingSpaceType::PARALLEL_PARKING) {
-    const auto &amp;routing_request =
-      frame-&gt;local_view().routing-&gt;routing_request();
-    auto corner_point =
-        routing_request.parking_info().corner_point();
-    left_top.set_x(corner_point.point().at(3).x());
-    left_top.set_y(corner_point.point().at(3).y());
-    left_down.set_x(corner_point.point().at(0).x());
-    left_down.set_y(corner_point.point().at(0).y());
-    right_down.set_x(corner_point.point().at(1).x());
-    right_down.set_y(corner_point.point().at(1).y());
-    right_top.set_x(corner_point.point().at(2).x());
-    right_top.set_y(corner_point.point().at(2).y());
-    double extend_right_x_buffer =
-      config_.open_space_roi_decider_config().extend_right_x_buffer();
-    double extend_left_x_buffer =
-      config_.open_space_roi_decider_config().extend_left_x_buffer();
-    right_top.set_x(right_top.x() + extend_right_x_buffer);
-    left_top.set_x(left_top.x() - extend_left_x_buffer);
-    left_down.set_x(left_down.x() - extend_left_x_buffer);
-    right_down.set_x(right_down.x() + extend_right_x_buffer);
-  }
+
   std::array&lt;Vec2d, 4&gt; parking_vertices{left_top, left_down, right_down,
                                         right_top};
 
@@ -1400,19 +1354,10 @@ void OpenSpaceRoiDecider::SearchTargetParkingSpotOnPath(
 }
 
 bool OpenSpaceRoiDecider::CheckDistanceToParkingSpot(
-    Frame *const frame,
     const hdmap::Path &amp;nearby_path,
     const hdmap::ParkingSpaceInfoConstPtr &amp;target_parking_spot) {
-  const auto &amp;routing_request =
-      frame-&gt;local_view().routing-&gt;routing_request();
-  auto corner_point =
-      routing_request.parking_info().corner_point();
   Vec2d left_bottom_point = target_parking_spot-&gt;polygon().points().at(0);
   Vec2d right_bottom_point = target_parking_spot-&gt;polygon().points().at(1);
-  left_bottom_point.set_x(corner_point.point().at(0).x());
-  left_bottom_point.set_y(corner_point.point().at(0).y());
-  right_bottom_point.set_x(corner_point.point().at(1).x());
-  right_bottom_point.set_y(corner_point.point().at(1).y());
   double left_bottom_point_s = 0.0;
   double left_bottom_point_l = 0.0;
   double right_bottom_point_s = 0.0;
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.h" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.h" added_lines="0" deleted_lines="1">
				<diff>@@ -147,7 +147,6 @@ class OpenSpaceRoiDecider : public Decider {
 
   // @brief if not close enough to parking spot, return false
   bool CheckDistanceToParkingSpot(
-      Frame *const frame,
       const hdmap::Path &amp;nearby_path,
       const hdmap::ParkingSpaceInfoConstPtr &amp;target_parking_spot);
 
</diff>
			</file>
			<file old_path="modules\planning\tasks\optimizers\open_space_trajectory_generation\open_space_trajectory_provider.cc" new_path="modules\planning\tasks\optimizers\open_space_trajectory_generation\open_space_trajectory_provider.cc" added_lines="1" deleted_lines="4">
				<diff>@@ -138,8 +138,7 @@ Status OpenSpaceTrajectoryProvider::Process() {
   }
   // Get open_space_info from current frame
   const auto&amp; open_space_info = frame_-&gt;open_space_info();
-  ADCTrajectory &amp;temp_trajectory =
-    const_cast&lt;ADCTrajectory&amp;&gt; (frame_-&gt;current_frame_planned_trajectory());
+
   if (FLAGS_enable_open_space_planner_thread) {
     ADEBUG &lt;&lt; "Open space plan in multi-threads mode";
 
@@ -169,7 +168,6 @@ Status OpenSpaceTrajectoryProvider::Process() {
             open_space_info.origin_heading(), open_space_info.origin_point())) {
       GenerateStopTrajectory(trajectory_data);
       is_generation_thread_stop_.store(true);
-      temp_trajectory.set_complete_parking(true);
       return Status(ErrorCode::OK, "Vehicle is near to destination");
     }
 
@@ -234,7 +232,6 @@ Status OpenSpaceTrajectoryProvider::Process() {
     if (IsVehicleNearDestination(vehicle_state, end_pose, rotate_angle,
                                  translate_origin)) {
       GenerateStopTrajectory(trajectory_data);
-      temp_trajectory.set_complete_parking(true);
       return Status(ErrorCode::OK, "Vehicle is near to destination");
     }
 
</diff>
			</file>
			<file old_path="modules\planning\tasks\optimizers\open_space_trajectory_generation\open_space_trajectory_provider.h" new_path="modules\planning\tasks\optimizers\open_space_trajectory_generation\open_space_trajectory_provider.h" added_lines="0" deleted_lines="1">
				<diff>@@ -29,7 +29,6 @@
 #include "modules/planning/tasks/optimizers/open_space_trajectory_generation/open_space_trajectory_optimizer.h"
 #include "modules/planning/tasks/optimizers/trajectory_optimizer.h"
 #include "modules/planning/tasks/task.h"
-#include "modules/planning/proto/planning.pb.h"
 
 namespace apollo {
 namespace planning {
</diff>
			</file>
			<file old_path="modules\task_manager\common\task_manager_gflags.cc" new_path="modules\task_manager\common\task_manager_gflags.cc" added_lines="0" deleted_lines="4">
				<diff>@@ -21,7 +21,3 @@ DEFINE_string(task_manager_node_name, "task_manager", "the name for this node");
 DEFINE_double(threshold_for_destination_check, 1.0,
               "meters, which is 100 feet.  This threshold is used to check if"
               "the vehicle reaches the destination");
-
-DEFINE_double(plot_size_buffer, 0.2, "the size buffer of parking plot");
-
-DEFINE_double(road_width_buffer, 0.0, "the size buffer of road width");
</diff>
			</file>
			<file old_path="modules\task_manager\common\task_manager_gflags.h" new_path="modules\task_manager\common\task_manager_gflags.h" added_lines="0" deleted_lines="4">
				<diff>@@ -21,7 +21,3 @@
 DECLARE_string(task_manager_node_name);
 
 DECLARE_double(threshold_for_destination_check);
-
-DECLARE_double(plot_size_buffer);
-
-DECLARE_double(road_width_buffer);
</diff>
			</file>
			<file old_path="modules\task_manager\conf\task_manager.conf" new_path="modules\task_manager\conf\task_manager.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -1,4 +1,2 @@
 --flagfile=/apollo/modules/common/data/global_flagfile.txt
---threshold_for_destination_check=10.0
---plot_size_buffer=0.2
---road_width_buffer=0.0
+--threshold_for_destination_check=10.0
\ No newline at end of file
</diff>
			</file>
			<file old_path="modules\task_manager\parking_routing_manager.cc" new_path="" added_lines="0" deleted_lines="109">
				<diff>@@ -1,109 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/task_manager/parking_routing_manager.h"
-#include "modules/common/configs/vehicle_config_helper.h"
-#include "modules/task_manager/common/task_manager_gflags.h"
-#include "modules/map/hdmap/hdmap.h"
-#include "modules/map/hdmap/hdmap_common.h"
-#include "modules/map/hdmap/hdmap_util.h"
-
-namespace apollo {
-namespace task_manager {
-
-using apollo::common::math::Vec2d;
-using apollo::common::PointENU;
-using apollo::hdmap::ParkingSpaceInfoConstPtr;
-using apollo::routing::ParkingSpaceType;
-
-ParkingRoutingManager::ParkingRoutingManager()
-: monitor_logger_buffer_(apollo::common::monitor::
-                         MonitorMessageItem::TASK_MANAGER) {}
-
-common::Status ParkingRoutingManager::Init(
-        const ParkingRoutingTask&amp; parking_routing_task) {
-    // get the message form routing
-    has_space_ = parking_routing_task.routing_request().has_parking_info();
-    has_space_id_ = parking_routing_task.routing_request().
-                    parking_info().has_parking_space_id();
-    id_ = parking_routing_task.routing_request().
-                    parking_info().parking_space_id();
-    return common::Status::OK();
-}
-
-bool ParkingRoutingManager::SizeVerification(
-        const ParkingRoutingTask&amp; parking_routing_task) {
-    auto plot_type =
-      parking_routing_task.routing_request().parking_info()
-      .parking_space_type();
-    const auto&amp; vehicle_config =
-      common::VehicleConfigHelper::Instance()-&gt;GetConfig();
-    double ego_length = vehicle_config.vehicle_param().length();
-    double ego_width = vehicle_config.vehicle_param().width();
-    if (!has_space_ || !has_space_id_) {
-        AERROR &lt;&lt; "No Valid park plot exits!";
-        return false;
-    }
-    auto corner_point =
-        parking_routing_task.routing_request().parking_info().corner_point();
-    PointENU left_bottom_point = corner_point.point().at(0);
-    PointENU right_bottom_point = corner_point.point().at(1);
-    PointENU right_top_point = corner_point.point().at(2);;
-    double length = sqrt((right_bottom_point.x() - right_top_point.x()) *
-                         (right_bottom_point.x() - right_top_point.x()) +
-                         (right_bottom_point.y() - right_top_point.y()) *
-                         (right_bottom_point.y() - right_top_point.y()));
-    double width = sqrt((right_bottom_point.x() - left_bottom_point.x()) *
-                        (right_bottom_point.x() - left_bottom_point.x()) +
-                        (right_bottom_point.y() - left_bottom_point.y()) *
-                        (right_bottom_point.y() - left_bottom_point.y()));
-    // judge by spot type
-    if (plot_type == ParkingSpaceType::VERTICAL_PLOT) {
-        if (length - FLAGS_plot_size_buffer &lt; ego_length ||
-            width - FLAGS_plot_size_buffer &lt; ego_width) {
-            monitor_logger_buffer_.WARN("veritical plot is not suit!");
-            AERROR &lt;&lt; "The veritical plot is small";
-            return false;
-        }
-    } else if (plot_type == ParkingSpaceType::PARALLEL_PARKING) {
-        if (width - FLAGS_plot_size_buffer &lt; ego_length ||
-            length - FLAGS_plot_size_buffer &lt; ego_width) {
-            monitor_logger_buffer_.WARN("parallel plot is not suit!");
-            AERROR &lt;&lt; "The parallel plot is small";
-            return false;
-        }
-    }
-    return true;
-}
-
-bool ParkingRoutingManager::RoadWidthVerification(
-        const ParkingRoutingTask&amp; parking_routing_task) {
-    const auto&amp; vehicle_config =
-      common::VehicleConfigHelper::Instance()-&gt;GetConfig();
-    const double ego_width = vehicle_config.vehicle_param().width();
-    const double road_width = parking_routing_task.lane_width();
-    if (!has_space_ || !has_space_id_) {
-        AERROR &lt;&lt; "No Valid park plot exits!";
-        return false;
-    }
-    if (ego_width &gt; road_width + FLAGS_road_width_buffer) {
-        AERROR &lt;&lt; "the road width is small!";
-        return false;
-    }
-    return true;
-}
-
-}  // namespace task_manager
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\task_manager\parking_routing_manager.h" new_path="" added_lines="0" deleted_lines="69">
				<diff>@@ -1,69 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-#pragma once
-
-#include &lt;memory&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#include "modules/common/monitor_log/monitor_log_buffer.h"
-#include "modules/common/status/status.h"
-#include "modules/localization/proto/localization.pb.h"
-#include "modules/task_manager/proto/task_manager.pb.h"
-#include "modules/task_manager/proto/task_manager_config.pb.h"
-
-namespace apollo {
-namespace task_manager {
-
-class ParkingRoutingManager {
- public:
-  ParkingRoutingManager();
-  /**
-   * @brief module initialization function
-   * @return initialization status
-   */
-  common::Status Init(const task_manager::ParkingRoutingTask&amp;
-                      parking_routing_task);
-
-  /**
-   * @brief check if the size of vehicle is smaller than size of parking space
-   * @return false/true
-   */
-  bool SizeVerification(const task_manager::ParkingRoutingTask&amp;
-                        parking_routing_task);
-
-  /**
-   * @brief check if the width of vehicle is smaller than width of road
-   * @return false/true
-  */
-  bool RoadWidthVerification(const task_manager::ParkingRoutingTask&amp;
-                             parking_routing_task);
-
-  /**
-   * @brief destructor
-   */
-  virtual ~ParkingRoutingManager() = default;
-
- private:
-  bool has_space_ = false;
-  bool has_space_id_ = false;
-  std::string id_ = "";
-  apollo::common::monitor::MonitorLogBuffer monitor_logger_buffer_;
-};
-
-}  // namespace task_manager
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.cc" new_path="modules\task_manager\task_manager_component.cc" added_lines="13" deleted_lines="45">
				<diff>@@ -59,57 +59,25 @@ bool TaskManagerComponent::Init() {
 
 bool TaskManagerComponent::Proc(const std::shared_ptr&lt;Task&gt;&amp; task) {
   task_name_ = task-&gt;task_name();
-  if (task-&gt;task_type() != CYCLE_ROUTING &amp;&amp;
-      task-&gt;task_type() != PARKING_ROUTING) {
-    AERROR &lt;&lt; "Task type is not cycle_routing.";
+  if (task-&gt;task_type() != CYCLE_ROUTING) {
+    AINFO &lt;&lt; "Task type is not cycle_routing.";
     return false;
   }
-  if (task-&gt;task_type() == CYCLE_ROUTING) {
-    cycle_routing_manager_ = std::make_shared&lt;CycleRoutingManager&gt;();
-    cycle_routing_manager_-&gt;Init(task-&gt;cycle_routing_task());
-    routing_request_ = task-&gt;cycle_routing_task().routing_request();
-    Rate rate(1.0);
 
-    while (cycle_routing_manager_-&gt;GetCycle() &gt; 0) {
-      if (cycle_routing_manager_-&gt;GetNewRouting(localization_.pose(),
-                                                &amp;routing_request_)) {
-        common::util::FillHeader(node_-&gt;Name(), &amp;routing_request_);
-        request_writer_-&gt;Write(routing_request_);
-        AINFO &lt;&lt; "[TaskManagerComponent]Reach begin/end point: "
-              &lt;&lt; "routing manager send a routing request. ";
-      }
-      rate.Sleep();
-    }
-  } else if (task-&gt;task_type() == PARKING_ROUTING) {
-    AERROR &lt;&lt; "enter the parking routing task";
-    parking_routing_manager_ = std::make_shared&lt;ParkingRoutingManager&gt;();
-    parking_routing_manager_-&gt;Init(task-&gt;parking_routing_task());
-    routing_request_ = task-&gt;parking_routing_task().routing_request();
-    if (parking_routing_manager_-&gt;
-        SizeVerification(task-&gt;parking_routing_task()) &amp;&amp;
-        parking_routing_manager_-&gt;
-        RoadWidthVerification(task-&gt;parking_routing_task())) {
-      AERROR &lt;&lt; "compelet the Verification";
+  cycle_routing_manager_ = std::make_shared&lt;CycleRoutingManager&gt;();
+  cycle_routing_manager_-&gt;Init(task-&gt;cycle_routing_task());
+  routing_request_ = task-&gt;cycle_routing_task().routing_request();
+  Rate rate(1.0);
+
+  while (cycle_routing_manager_-&gt;GetCycle() &gt; 0) {
+    if (cycle_routing_manager_-&gt;GetNewRouting(localization_.pose(),
+                                              &amp;routing_request_)) {
       common::util::FillHeader(node_-&gt;Name(), &amp;routing_request_);
       request_writer_-&gt;Write(routing_request_);
-      AINFO &lt;&lt; "send a auto parking task";
-    } else {
-      auto last_routing_response_ = routing_response_;
-      if (!routing_response_.has_header()) {
-           AINFO &lt;&lt; "[TaskManagerComponent]parking routing failed";
-           return false;
-         }
-         if (last_routing_response_.has_header()) {
-           if (last_routing_response_.header().sequence_num() ==
-               routing_response_.header().sequence_num()) {
-             AINFO &lt;&lt; "[TaskManagerComponent]No parking routing response: "
-                   &lt;&lt; "new parking routing failed";
-             return false;
-           }
-         }
-      AERROR &lt;&lt; "plot verification failed, please select suitable plot!";
-      return false;
+      AINFO &lt;&lt; "[TaskManagerComponent]Reach begin/end point: "
+            &lt;&lt; "routing manager send a routing request. ";
     }
+    rate.Sleep();
   }
   return true;
 }
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.h" new_path="modules\task_manager\task_manager_component.h" added_lines="1" deleted_lines="3">
				<diff>@@ -22,7 +22,7 @@
 #include "cyber/class_loader/class_loader.h"
 #include "cyber/component/component.h"
 #include "modules/task_manager/cycle_routing_manager.h"
-#include "modules/task_manager/parking_routing_manager.h"
+
 namespace apollo {
 namespace task_manager {
 
@@ -41,9 +41,7 @@ class TaskManagerComponent final : public cyber::Component&lt;task_manager::Task&gt; {
   std::shared_ptr&lt;cyber::Reader&lt;LocalizationEstimate&gt;&gt; localization_reader_;
   std::shared_ptr&lt;cyber::Writer&lt;routing::RoutingRequest&gt;&gt; request_writer_;
   std::shared_ptr&lt;CycleRoutingManager&gt; cycle_routing_manager_;
-  std::shared_ptr&lt;ParkingRoutingManager&gt; parking_routing_manager_;
   routing::RoutingRequest routing_request_;
-  routing::RoutingResponse routing_response_;
   LocalizationEstimate localization_;
   std::mutex mutex_;
   std::string task_name_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7731d03006583557b76321738ddbb8f78b7435e5" author="jiangjianan">
		<msg>IDG-Apollo-4301 prediction: add interaction filter for interaction evaluator

Change-Id: Ib54abd4dde8fb495df4453f20dfb987d9f671648</msg>
		<modified_files>
			<file old_path="modules\prediction\common\message_process.cc" new_path="modules\prediction\common\message_process.cc" added_lines="7" deleted_lines="0">
				<diff>@@ -32,6 +32,7 @@
 #include "modules/prediction/evaluator/evaluator_manager.h"
 #include "modules/prediction/predictor/predictor_manager.h"
 #include "modules/prediction/proto/offline_features.pb.h"
+#include "modules/prediction/scenario/interaction_filter/interaction_filter.h"
 #include "modules/prediction/scenario/prioritization/obstacles_prioritizer.h"
 #include "modules/prediction/scenario/right_of_way/right_of_way.h"
 #include "modules/prediction/util/data_extraction.h"
@@ -150,9 +151,15 @@ void MessageProcess::ContainerProcess(
   ptr_obstacles_container-&gt;Insert(perception_obstacles);
 
   ObstaclesPrioritizer obstacles_prioritizer(container_manager);
+
+  InteractionFilter interaction_filter(container_manager);
+
   // Ignore some obstacles
   obstacles_prioritizer.AssignIgnoreLevel();
 
+  // Add interactive tag
+  interaction_filter.AssignInteractiveTag();
+
   // Scenario analysis
   scenario_manager-&gt;Run(container_manager.get());
 
</diff>
			</file>
			<file old_path="modules\prediction\common\prediction_gflags.cc" new_path="modules\prediction\common\prediction_gflags.cc" added_lines="16" deleted_lines="0">
				<diff>@@ -70,6 +70,8 @@ DEFINE_bool(enable_all_pedestrian_caution_in_front, false,
             "If true, then all pedestrian in front of ADC are marked caution.");
 DEFINE_bool(enable_rank_caution_obstacles, true,
             "Rank the caution-level obstacles.");
+DEFINE_bool(enable_rank_interactive_obstacles, true,
+            "Rank the interactive obstacles.");
 DEFINE_int32(caution_obs_max_nums, 6,
              "The max number of caution-level obstacles");
 DEFINE_double(caution_distance_threshold, 60.0,
@@ -86,6 +88,20 @@ DEFINE_double(caution_search_distance_backward_for_overlap, 30.0,
               "in the case of overlap");
 DEFINE_double(caution_pedestrian_approach_time, 3.0,
               "The time for a pedestrian to approach adc trajectory");
+DEFINE_int32(interactive_obs_max_nums, 6,
+             "The max number of interactive obstacles");
+DEFINE_double(interaction_distance_threshold, 60.0,
+              "Distance threshold for interactive obstacles");
+DEFINE_double(interaction_search_distance_ahead, 50.0,
+              "The distance ahead to search interactive obstacles");
+DEFINE_double(interaction_search_distance_backward, 50.0,
+              "The distance backward to search interactive obstacles");
+DEFINE_double(interaction_search_distance_backward_for_merge, 60.0,
+              "The distance backward to search interactive obstacles "
+              "in the case of merging");
+DEFINE_double(interaction_search_distance_backward_for_overlap, 30.0,
+              "The distance backward to search interactive obstacles "
+              "in the case of overlap");
 
 // Obstacle features
 DEFINE_int32(ego_vehicle_id, -1, "The obstacle ID of the ego vehicle.");
</diff>
			</file>
			<file old_path="modules\prediction\common\prediction_gflags.h" new_path="modules\prediction\common\prediction_gflags.h" added_lines="7" deleted_lines="0">
				<diff>@@ -52,6 +52,7 @@ DECLARE_double(junction_distance_threshold);
 DECLARE_bool(enable_all_junction);
 DECLARE_bool(enable_all_pedestrian_caution_in_front);
 DECLARE_bool(enable_rank_caution_obstacles);
+DECLARE_bool(enable_rank_interactive_obstacles);
 DECLARE_int32(caution_obs_max_nums);
 DECLARE_double(caution_distance_threshold);
 DECLARE_double(caution_search_distance_ahead);
@@ -59,6 +60,12 @@ DECLARE_double(caution_search_distance_backward);
 DECLARE_double(caution_search_distance_backward_for_merge);
 DECLARE_double(caution_search_distance_backward_for_overlap);
 DECLARE_double(caution_pedestrian_approach_time);
+DECLARE_int32(interactive_obs_max_nums);
+DECLARE_double(interaction_distance_threshold);
+DECLARE_double(interaction_search_distance_ahead);
+DECLARE_double(interaction_search_distance_backward);
+DECLARE_double(interaction_search_distance_backward_for_merge);
+DECLARE_double(interaction_search_distance_backward_for_overlap);
 
 // Obstacle features
 DECLARE_int32(ego_vehicle_id);
</diff>
			</file>
			<file old_path="modules\prediction\container\obstacles\obstacle.cc" new_path="modules\prediction\container\obstacles\obstacle.cc" added_lines="16" deleted_lines="0">
				<diff>@@ -1456,6 +1456,22 @@ bool Obstacle::IsCaution() const {
   return feature.priority().priority() == ObstaclePriority::CAUTION;
 }
 
+void Obstacle::SetInteractiveTag() {
+  CHECK_GT(feature_history_.size(), 0U);
+  Feature* feature = mutable_latest_feature();
+  feature-&gt;mutable_interactive_tag()-&gt;
+           set_interactive_tag(ObstacleInteractiveTag::INTERACTION);
+}
+
+bool Obstacle::IsInteractiveObstacle() const {
+  if (feature_history_.empty()) {
+    return false;
+  }
+  const Feature&amp; feature = latest_feature();
+  return feature.interactive_tag().interactive_tag() ==
+                 ObstacleInteractiveTag::INTERACTION;
+}
+
 void Obstacle::SetEvaluatorType(
     const ObstacleConf::EvaluatorType&amp; evaluator_type) {
   obstacle_conf_.set_evaluator_type(evaluator_type);
</diff>
			</file>
			<file old_path="modules\prediction\container\obstacles\obstacle.h" new_path="modules\prediction\container\obstacles\obstacle.h" added_lines="7" deleted_lines="0">
				<diff>@@ -228,6 +228,13 @@ class Obstacle {
 
   bool IsCaution() const;
 
+  /**
+   * @brief Set the obstacle as caution level
+   */
+  void SetInteractiveTag();
+
+  bool IsInteractiveObstacle() const;
+
   void SetEvaluatorType(const ObstacleConf::EvaluatorType&amp; evaluator_type);
 
   void SetPredictorType(const ObstacleConf::PredictorType&amp; predictor_type);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ecece0da431c82cd1b52129ec1b0bb58323331a2" author="changsh726">
		<msg>Perception: always link all object files in static lib</msg>
		<modified_files>
			<file old_path="modules\perception\camera\lib\obstacle\detector\yolo\region_output.cu" new_path="modules\perception\camera\lib\obstacle\detector\yolo\region_output.cu" added_lines="1" deleted_lines="260">
				<diff>@@ -19,6 +19,7 @@
 #include &lt;memory&gt;
 #include &lt;utility&gt;
 #include &lt;vector&gt;
+
 #include "boost/iterator/counting_iterator.hpp"
 #include "thrust/functional.h"
 #include "thrust/sort.h"
@@ -551,266 +552,6 @@ int get_objects_gpu(const YoloBlobs &amp;yolo_blobs, const cudaStream_t &amp;stream,
   return num_kept;
 }
 
-void get_intersect_bbox(const NormalizedBBox &amp;bbox1,
-                        const NormalizedBBox &amp;bbox2,
-                        NormalizedBBox *intersect_bbox) {
-  if (bbox2.xmin &gt; bbox1.xmax || bbox2.xmax &lt; bbox1.xmin ||
-      bbox2.ymin &gt; bbox1.ymax || bbox2.ymax &lt; bbox1.ymin) {
-    // Return [0, 0, 0, 0] if there is no intersection.
-    intersect_bbox-&gt;xmin = 0;
-    intersect_bbox-&gt;ymin = 0;
-    intersect_bbox-&gt;xmax = 0;
-    intersect_bbox-&gt;ymax = 0;
-  } else {
-    intersect_bbox-&gt;xmin = std::max(bbox1.xmin, bbox2.xmin);
-    intersect_bbox-&gt;ymin = std::max(bbox1.ymin, bbox2.ymin);
-    intersect_bbox-&gt;xmax = std::min(bbox1.xmax, bbox2.xmax);
-    intersect_bbox-&gt;ymax = std::min(bbox1.ymax, bbox2.ymax);
-  }
-}
-
-float get_bbox_size(const NormalizedBBox &amp;bbox) {
-  if (bbox.xmax &lt; bbox.xmin || bbox.ymax &lt; bbox.ymin) {
-    // If bbox is invalid (e.g. xmax &lt; xmin or ymax &lt; ymin), return 0.
-    return 0;
-  } else {
-    if (bbox.size &gt;= 0) {
-      return bbox.size;
-    } else {
-      float width = bbox.xmax - bbox.xmin;
-      float height = bbox.ymax - bbox.ymin;
-      return width * height;
-    }
-  }
-}
-
-float get_jaccard_overlap(const NormalizedBBox &amp;bbox1,
-                          const NormalizedBBox &amp;bbox2) {
-  NormalizedBBox intersect_bbox;
-  get_intersect_bbox(bbox1, bbox2, &amp;intersect_bbox);
-  float intersect_width = 0.f;
-  float intersect_height = 0.f;
-  intersect_width = intersect_bbox.xmax - intersect_bbox.xmin;
-  intersect_height = intersect_bbox.ymax - intersect_bbox.ymin;
-
-  if (intersect_width &gt; 0 &amp;&amp; intersect_height &gt; 0) {
-    float intersect_size = intersect_width * intersect_height;
-    float bbox1_size = get_bbox_size(bbox1);
-    float bbox2_size = get_bbox_size(bbox2);
-    return intersect_size / (bbox1_size + bbox2_size - intersect_size);
-  } else {
-    return 0.;
-  }
-}
-
-void get_max_score_index(const std::vector&lt;float&gt; &amp;scores,
-                         const float threshold, const int top_k,
-                         std::vector&lt;std::pair&lt;float, int&gt;&gt; *score_index_vec) {
-  // Generate index score pairs.
-  for (size_t i = 0; i &lt; scores.size(); ++i) {
-    if (scores[i] &gt; threshold) {
-      score_index_vec-&gt;push_back(std::make_pair(scores[i], i));
-    }
-  }
-
-  // Sort the score pair according to the scores in descending order
-  std::stable_sort(score_index_vec-&gt;begin(), score_index_vec-&gt;end(),
-                   sort_score_pair_descend&lt;int&gt;);
-
-  // Keep top_k scores if needed.
-  if (top_k &gt; -1 &amp;&amp; top_k &lt; static_cast&lt;int&gt;(score_index_vec-&gt;size())) {
-    score_index_vec-&gt;resize(top_k);
-  }
-}
-
-void apply_softnms_fast(const std::vector&lt;NormalizedBBox&gt; &amp;bboxes,
-                        std::vector&lt;float&gt; *scores, const float score_threshold,
-                        const float nms_threshold, const int top_k,
-                        std::vector&lt;int&gt; *indices, bool is_linear,
-                        const float sigma) {
-  // Sanity check.
-  CHECK_EQ(bboxes.size(), scores-&gt;size())
-      &lt;&lt; "bboxes and scores have different size.";
-
-  // Get top_k scores (with corresponding indices).
-  std::vector&lt;std::pair&lt;float, int&gt;&gt; score_index_vec;
-  get_max_score_index(*scores, score_threshold, top_k, &amp;score_index_vec);
-
-  // Do nms.
-  indices-&gt;clear();
-  while (score_index_vec.size() != 0) {
-    auto best_it =
-        max_element(std::begin(score_index_vec), std::end(score_index_vec));
-    const int best_idx = (*best_it).second;
-    score_index_vec.erase(best_it);
-    const NormalizedBBox &amp;best_bbox = bboxes[best_idx];
-    indices-&gt;push_back(best_idx);
-    for (std::vector&lt;std::pair&lt;float, int&gt;&gt;::iterator it =
-             score_index_vec.begin();
-         it != score_index_vec.end();) {
-      int cur_idx = it-&gt;second;
-      const NormalizedBBox &amp;cur_bbox = bboxes[cur_idx];
-
-      float cur_overlap = 0.;
-      cur_overlap = get_jaccard_overlap(best_bbox, cur_bbox);
-      if (is_linear) {
-        (*scores)[cur_idx] *= (1.0 - cur_overlap);
-      } else {
-        (*scores)[cur_idx] *= exp(-1.0 * pow(cur_overlap, 2) / sigma);
-      }
-      ++it;
-    }
-  }
-}
-
-void apply_boxvoting_fast(std::vector&lt;NormalizedBBox&gt; *bboxes,
-                          std::vector&lt;float&gt; *scores,
-                          const float conf_threshold, const float nms_threshold,
-                          const float sigma, std::vector&lt;int&gt; *indices) {
-  if (bboxes-&gt;size() == 0) {
-    return;
-  }
-  indices-&gt;clear();
-  for (size_t i = 0; i &lt; bboxes-&gt;size(); ++i) {
-    (*bboxes)[i].mask = false;
-    if ((*scores)[i] &gt; conf_threshold) {
-      indices-&gt;push_back(i);
-    }
-  }
-  for (size_t count = 0; count &lt; indices-&gt;size(); ++count) {
-    int max_box_idx = 0;
-
-    for (size_t i = 1; i &lt; indices-&gt;size(); ++i) {
-      int idx = indices-&gt;at(i);
-      if ((*bboxes)[idx].mask) {
-        continue;
-      }
-      if ((*scores)[idx] &gt; (*scores)[max_box_idx]) {
-        max_box_idx = idx;
-      }
-    }
-
-    NormalizedBBox &amp;best_bbox = (*bboxes)[max_box_idx];
-    best_bbox.score = (*scores)[max_box_idx];
-    best_bbox.mask = true;
-    float s_vt = (*scores)[max_box_idx];
-    float x1_vt = best_bbox.xmin * s_vt;
-    float x2_vt = best_bbox.xmax * s_vt;
-    float y1_vt = best_bbox.ymin * s_vt;
-    float y2_vt = best_bbox.ymax * s_vt;
-    for (size_t i = 0; i &lt; indices-&gt;size(); ++i) {
-      int sub_it = indices-&gt;at(i);
-      if ((*bboxes)[sub_it].mask) {
-        continue;
-      }
-      float cur_overlap = 0.;
-      cur_overlap = get_jaccard_overlap(best_bbox, (*bboxes)[sub_it]);
-      if (sigma == 0) {
-        (*bboxes)[sub_it].mask = true;
-      } else {
-        (*scores)[sub_it] *= exp(-1.0 * pow(cur_overlap, 2) / sigma);
-      }
-      (*bboxes)[sub_it].score = (*scores)[sub_it];
-
-      // Remove it if necessary
-      if (cur_overlap &gt; nms_threshold) {
-        float s_vt_cur = (*bboxes)[sub_it].score;
-        s_vt += s_vt_cur;
-        x1_vt += (*bboxes)[sub_it].xmin * s_vt_cur;
-        x2_vt += (*bboxes)[sub_it].xmax * s_vt_cur;
-        y1_vt += (*bboxes)[sub_it].ymin * s_vt_cur;
-        y2_vt += (*bboxes)[sub_it].ymax * s_vt_cur;
-      }
-    }
-    if (s_vt &gt; 0.0001) {
-      (*bboxes)[max_box_idx].xmin = x1_vt / s_vt;
-      (*bboxes)[max_box_idx].xmax = x2_vt / s_vt;
-      (*bboxes)[max_box_idx].ymin = y1_vt / s_vt;
-      (*bboxes)[max_box_idx].ymax = y2_vt / s_vt;
-    }
-  }
-}
-
-void apply_nms_fast(const std::vector&lt;NormalizedBBox&gt; &amp;bboxes,
-                    const std::vector&lt;float&gt; &amp;scores,
-                    const float score_threshold, const float nms_threshold,
-                    const float eta, const int top_k,
-                    std::vector&lt;int&gt; *indices) {
-  // Sanity check.
-  CHECK_EQ(bboxes.size(), scores.size())
-      &lt;&lt; "bboxes and scores have different size.";
-
-  // Get top_k scores (with corresponding indices).
-  std::vector&lt;std::pair&lt;float, int&gt;&gt; score_index_vec;
-  get_max_score_index(scores, score_threshold, top_k, &amp;score_index_vec);
-
-  // Do nms.
-  float adaptive_threshold = nms_threshold;
-  indices-&gt;clear();
-  while (score_index_vec.size() != 0) {
-    const int idx = score_index_vec.front().second;
-    bool keep = true;
-    for (size_t k = 0; k &lt; indices-&gt;size(); ++k) {
-      if (keep) {
-        const int kept_idx = (*indices)[k];
-        float overlap = get_jaccard_overlap(bboxes[idx], bboxes[kept_idx]);
-        keep = overlap &lt;= adaptive_threshold;
-      } else {
-        break;
-      }
-    }
-    if (keep) {
-      indices-&gt;push_back(idx);
-    }
-    score_index_vec.erase(score_index_vec.begin());
-    if (keep &amp;&amp; eta &lt; 1 &amp;&amp; adaptive_threshold &gt; 0.5) {
-      adaptive_threshold *= eta;
-    }
-  }
-}
-
-void fill_area_id(bool with_flag, base::ObjectPtr obj, const float *data) {
-  if (with_flag) {
-    obj-&gt;camera_supplement.area_id = static_cast&lt;int&gt;(data[0]);
-    // obj-&gt;camera_supplement.area_id_prob = data[1];
-  }
-}
-
-int get_area_id(float visible_ratios[4]) {
-  int area_id = 0;
-  int max_face = 0;
-  for (int i = 1; i &lt; 4; ++i) {
-    if (visible_ratios[i] &gt; visible_ratios[max_face]) {
-      max_face = i;
-    }
-  }
-  int left_face = (max_face + 1) % 4;
-  int right_face = (max_face + 3) % 4;
-  const float eps = 1e-3;
-  float max_ratio = visible_ratios[max_face];
-  float left_ratio = visible_ratios[left_face];
-  float right_ratio = visible_ratios[right_face];
-  memset(visible_ratios, 0, 4 * sizeof(visible_ratios[0]));
-  if (left_ratio &lt; eps &amp;&amp; right_ratio &lt; eps) {
-    area_id = (max_face * 2 + 1);
-    visible_ratios[max_face] = 1.f;
-  } else if (left_ratio &gt; right_ratio) {
-    area_id = (max_face * 2 + 2);
-    auto &amp;&amp;sum_ratio = left_ratio + max_ratio;
-    visible_ratios[max_face] = max_ratio / sum_ratio;
-    visible_ratios[left_face] = left_ratio / sum_ratio;
-  } else {
-    area_id = (max_face * 2);
-    if (area_id == 0) {
-      area_id = 8;
-    }
-    auto &amp;&amp;sum_ratio = right_ratio + max_ratio;
-    visible_ratios[max_face] = max_ratio / sum_ratio;
-    visible_ratios[right_face] = right_ratio / sum_ratio;
-  }
-  return area_id;
-}
-
 }  // namespace camera
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="85e8fda3988ac13d489f15deb10f36f3544861be" author="jiangjianan">
		<msg>prediction: add jointly model inference &amp; modify semantic map

Change-Id: I9e9e534c591df684aa94d9098605d726f1df3c65</msg>
		<modified_files>
			<file old_path="modules\prediction\common\message_process.cc" new_path="modules\prediction\common\message_process.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -226,7 +226,8 @@ void MessageProcess::OnPerception(
   }
 
   // Make evaluations
-  evaluator_manager-&gt;Run(ptr_obstacles_container);
+  evaluator_manager-&gt;Run(ptr_ego_trajectory_container,
+                         ptr_obstacles_container);
   if (FLAGS_prediction_offline_mode ==
           PredictionConstants::kDumpDataForLearning ||
       FLAGS_prediction_offline_mode == PredictionConstants::kDumpFrameEnv) {
</diff>
			</file>
			<file old_path="modules\prediction\common\prediction_gflags.cc" new_path="modules\prediction\common\prediction_gflags.cc" added_lines="12" deleted_lines="0">
				<diff>@@ -58,6 +58,8 @@ DEFINE_double(surrounding_lane_search_radius, 3.0,
 
 // Semantic Map
 DEFINE_double(base_image_half_range, 100.0, "The half range of base image.");
+DEFINE_bool(enable_draw_adc_trajectory, false,
+            "If draw adc trajectory in semantic map");
 DEFINE_bool(img_show_semantic_map, false, "If show the image of semantic map.");
 
 // Scenario
@@ -167,6 +169,16 @@ DEFINE_string(evaluator_vehicle_mlp_file,
 DEFINE_string(evaluator_vehicle_rnn_file,
               "/apollo/modules/prediction/data/rnn_vehicle_model.bin",
               "rnn model file for vehicle evaluator");
+DEFINE_string(
+    torch_vehicle_jointly_model_file,
+    "/apollo/modules/prediction/data/"
+    "jointly_prediction_planning_vehicle_model.pt",
+    "Vehicle jointly prediction and planning model file");
+DEFINE_string(
+    torch_vehicle_jointly_model_cpu_file,
+    "/apollo/modules/prediction/data/"
+    "jointly_prediction_planning_vehicle_cpu_model.pt",
+    "Vehicle jointly prediction and planning cpu model file");
 DEFINE_string(torch_vehicle_junction_mlp_file,
               "/apollo/modules/prediction/data/junction_mlp_vehicle_model.pt",
               "Vehicle junction MLP model file");
</diff>
			</file>
			<file old_path="modules\prediction\common\prediction_gflags.h" new_path="modules\prediction\common\prediction_gflags.h" added_lines="3" deleted_lines="0">
				<diff>@@ -45,6 +45,7 @@ DECLARE_double(surrounding_lane_search_radius);
 
 // Semantic Map
 DECLARE_double(base_image_half_range);
+DECLARE_bool(enable_draw_adc_trajectory);
 DECLARE_bool(img_show_semantic_map);
 
 // Scenario
@@ -104,6 +105,8 @@ DECLARE_double(pedestrian_max_speed);
 DECLARE_double(pedestrian_max_acc);
 DECLARE_double(still_speed);
 DECLARE_string(evaluator_vehicle_mlp_file);
+DECLARE_string(torch_vehicle_jointly_model_file);
+DECLARE_string(torch_vehicle_jointly_model_cpu_file);
 DECLARE_string(torch_vehicle_junction_mlp_file);
 DECLARE_string(torch_vehicle_junction_map_file);
 DECLARE_string(torch_vehicle_semantic_lstm_file);
</diff>
			</file>
			<file old_path="modules\prediction\common\semantic_map.cc" new_path="modules\prediction\common\semantic_map.cc" added_lines="19" deleted_lines="0">
				<diff>@@ -88,6 +88,12 @@ void SemanticMap::RunCurrFrame(
     }
   }
 
+  // Draw ADC trajectory
+  if (FLAGS_enable_draw_adc_trajectory) {
+    DrawADCTrajectory(cv::Scalar(0, 255, 255),
+                curr_base_x_, curr_base_y_, &amp;curr_img_);
+  }
+
   // Draw all obstacles_history
   for (const auto obstacle_id_history_pair : obstacle_id_history_map) {
     DrawHistory(obstacle_id_history_pair.second, cv::Scalar(0, 255, 255),
@@ -342,6 +348,19 @@ void SemanticMap::DrawHistory(const ObstacleHistory&amp; history,
   }
 }
 
+void SemanticMap::DrawADCTrajectory(const cv::Scalar&amp; color,
+                              const double base_x,
+                              const double base_y,
+                              cv::Mat* img) {
+  size_t traj_num = ego_feature_.adc_trajectory_point().size();
+  for (size_t i = 0; i &lt; traj_num; ++i) {
+    double time_decay = ego_feature_.adc_trajectory_point(i).relative_time() -
+                        ego_feature_.adc_trajectory_point(0).relative_time();
+    cv::Scalar decay_color = color * time_decay;
+    DrawPoly(ego_feature_, decay_color, base_x, base_y, img);
+  }
+}
+
 cv::Mat SemanticMap::CropArea(const cv::Mat&amp; input_img,
                               const cv::Point2i&amp; center_point,
                               const double heading) {
</diff>
			</file>
			<file old_path="modules\prediction\common\semantic_map.h" new_path="modules\prediction\common\semantic_map.h" added_lines="4" deleted_lines="0">
				<diff>@@ -79,6 +79,10 @@ class SemanticMap {
   void DrawHistory(const ObstacleHistory&amp; history, const cv::Scalar&amp; color,
                    const double base_x, const double base_y, cv::Mat* img);
 
+  // Draw adc trajectory in semantic map
+  void DrawADCTrajectory(const cv::Scalar&amp; color, const double base_x,
+                         const double base_y, cv::Mat* img);
+
   cv::Mat CropArea(const cv::Mat&amp; input_img, const cv::Point2i&amp; center_point,
                    const double heading);
 
</diff>
			</file>
			<file old_path="modules\prediction\container\obstacles\obstacle.cc" new_path="modules\prediction\container\obstacles\obstacle.cc" added_lines="9" deleted_lines="2">
				<diff>@@ -1459,8 +1459,15 @@ bool Obstacle::IsCaution() const {
 void Obstacle::SetInteractiveTag() {
   CHECK_GT(feature_history_.size(), 0U);
   Feature* feature = mutable_latest_feature();
-  feature-&gt;mutable_interactive_tag()-&gt;
-           set_interactive_tag(ObstacleInteractiveTag::INTERACTION);
+  feature-&gt;mutable_interactive_tag()
+      -&gt;set_interactive_tag(ObstacleInteractiveTag::INTERACTION);
+}
+
+void Obstacle::SetNonInteractiveTag() {
+  CHECK_GT(feature_history_.size(), 0U);
+  Feature* feature = mutable_latest_feature();
+  feature-&gt;mutable_interactive_tag()
+      -&gt;set_interactive_tag(ObstacleInteractiveTag::NONINTERACTION);
 }
 
 bool Obstacle::IsInteractiveObstacle() const {
</diff>
			</file>
			<file old_path="modules\prediction\container\obstacles\obstacle.h" new_path="modules\prediction\container\obstacles\obstacle.h" added_lines="5" deleted_lines="1">
				<diff>@@ -229,9 +229,13 @@ class Obstacle {
   bool IsCaution() const;
 
   /**
-   * @brief Set the obstacle as caution level
+   * @brief Set the obstacle as interactive obstacle.
    */
   void SetInteractiveTag();
+  /**
+   * @brief Set the obstacle as noninteractive obstacle.
+   */
+  void SetNonInteractiveTag();
 
   bool IsInteractiveObstacle() const;
 
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\evaluator.h" new_path="modules\prediction\evaluator\evaluator.h" added_lines="12" deleted_lines="0">
				<diff>@@ -28,6 +28,7 @@
 #include "modules/prediction/container/obstacles/obstacle.h"
 
 #include "modules/prediction/container/obstacles/obstacles_container.h"
+#include "modules/prediction/container/adc_trajectory/adc_trajectory_container.h"
 
 /**
  * @namespace apollo::prediction
@@ -71,6 +72,17 @@ class Evaluator {
     return Evaluate(obstacle, obstacles_container);
   }
 
+  /**
+   * @brief Evaluate an obstacle
+   * @param ADC trajectory container
+   * @param Obstacle pointer
+   * @param Obstacles container
+   */
+  virtual bool Evaluate(const ADCTrajectoryContainer* adc_trajectory_container,
+                        Obstacle* obstacle,
+                        ObstaclesContainer* obstacles_container) {
+    return Evaluate(obstacle, obstacles_container);
+  }
   /**
    * @brief Get the name of evaluator
    */
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\evaluator_manager.cc" new_path="modules\prediction\evaluator\evaluator_manager.cc" added_lines="43" deleted_lines="12">
				<diff>@@ -35,6 +35,7 @@
 #include "modules/prediction/evaluator/vehicle/lane_scanning_evaluator.h"
 #include "modules/prediction/evaluator/vehicle/mlp_evaluator.h"
 #include "modules/prediction/evaluator/vehicle/semantic_lstm_evaluator.h"
+#include "modules/prediction/evaluator/vehicle/jointly_prediction_planning_evaluator.h"
 
 namespace apollo {
 namespace prediction {
@@ -104,6 +105,7 @@ void EvaluatorManager::RegisterEvaluators() {
   RegisterEvaluator(ObstacleConf::LANE_AGGREGATING_EVALUATOR);
   RegisterEvaluator(ObstacleConf::JUNCTION_MAP_EVALUATOR);
   RegisterEvaluator(ObstacleConf::SEMANTIC_LSTM_EVALUATOR);
+  RegisterEvaluator(ObstacleConf::JOINTLY_PREDICTION_PLANNING_EVALUATOR);
 }
 
 void EvaluatorManager::Init(const PredictionConf&amp; config) {
@@ -173,6 +175,8 @@ void EvaluatorManager::Init(const PredictionConf&amp; config) {
           break;
         }
       }
+    } else if (obstacle_conf.has_interactive_tag()) {
+      interaction_evaluator_ = obstacle_conf.evaluator_type();
     }
   }
 
@@ -190,7 +194,9 @@ Evaluator* EvaluatorManager::GetEvaluator(
   return it != evaluators_.end() ? it-&gt;second.get() : nullptr;
 }
 
-void EvaluatorManager::Run(ObstaclesContainer* obstacles_container) {
+void EvaluatorManager::Run(
+    const ADCTrajectoryContainer* adc_trajectory_container,
+    ObstaclesContainer* obstacles_container) {
   if (FLAGS_enable_semantic_map ||
       FLAGS_prediction_offline_mode == PredictionConstants::kDumpFrameEnv) {
     size_t max_num_frame = 10;
@@ -214,7 +220,8 @@ void EvaluatorManager::Run(ObstaclesContainer* obstacles_container) {
         id_obstacle_map.begin(), id_obstacle_map.end(),
         [&amp;](IdObstacleListMap::iterator::value_type&amp; obstacles_iter) {
           for (auto obstacle_ptr : obstacles_iter.second) {
-            EvaluateObstacle(obstacle_ptr, obstacles_container, dynamic_env);
+            EvaluateObstacle(adc_trajectory_container, obstacle_ptr,
+                             obstacles_container, dynamic_env);
           }
         });
   } else {
@@ -229,20 +236,25 @@ void EvaluatorManager::Run(ObstaclesContainer* obstacles_container) {
         continue;
       }
 
-      EvaluateObstacle(obstacle, obstacles_container, dynamic_env);
+      EvaluateObstacle(adc_trajectory_container, obstacle,
+                       obstacles_container, dynamic_env);
     }
   }
 }
 
-void EvaluatorManager::EvaluateObstacle(Obstacle* obstacle,
-                                        ObstaclesContainer* obstacles_container,
-                                        std::vector&lt;Obstacle*&gt; dynamic_env) {
+void EvaluatorManager::EvaluateObstacle(
+    const ADCTrajectoryContainer* adc_trajectory_container,
+    Obstacle* obstacle,
+    ObstaclesContainer* obstacles_container,
+    std::vector&lt;Obstacle*&gt; dynamic_env) {
   Evaluator* evaluator = nullptr;
   // Select different evaluators depending on the obstacle's type.
   switch (obstacle-&gt;type()) {
     case PerceptionObstacle::VEHICLE: {
       if (obstacle-&gt;IsCaution() &amp;&amp; !obstacle-&gt;IsSlow()) {
-        if (obstacle-&gt;IsNearJunction()) {
+        if (obstacle-&gt;IsInteractiveObstacle()) {
+          evaluator = GetEvaluator(interaction_evaluator_);
+        } else if (obstacle-&gt;IsNearJunction()) {
           evaluator = GetEvaluator(vehicle_in_junction_caution_evaluator_);
         } else if (obstacle-&gt;IsOnLane()) {
           evaluator = GetEvaluator(vehicle_on_lane_caution_evaluator_);
@@ -251,13 +263,25 @@ void EvaluatorManager::EvaluateObstacle(Obstacle* obstacle,
         }
         CHECK_NOTNULL(evaluator);
         // Evaluate and break if success
-        if (evaluator-&gt;Evaluate(obstacle, obstacles_container)) {
-          break;
+        if (evaluator-&gt;GetName() == "JOINTLY_PREDICTION_PLANNING_EVALUATOR") {
+          if (evaluator-&gt;Evaluate(adc_trajectory_container,
+                                  obstacle, obstacles_container)) {
+            break;
+          } else {
+            AERROR &lt;&lt; "Obstacle: " &lt;&lt; obstacle-&gt;id()
+                  &lt;&lt; " interaction evaluator failed,"
+                  &lt;&lt; " downgrade to normal level!";
+          }
         } else {
-          AERROR &lt;&lt; "Obstacle: " &lt;&lt; obstacle-&gt;id()
-                 &lt;&lt; " caution evaluator failed, downgrade to normal level!";
+          if (evaluator-&gt;Evaluate(obstacle, obstacles_container)) {
+            break;
+          } else {
+            AERROR &lt;&lt; "Obstacle: " &lt;&lt; obstacle-&gt;id()
+                  &lt;&lt; " caution evaluator failed, downgrade to normal level!";
+          }
         }
       }
+
       // if obstacle is not caution or caution_evaluator run failed
       if (obstacle-&gt;HasJunctionFeatureWithExits() &amp;&amp;
           !obstacle-&gt;IsCloseToJunctionExit()) {
@@ -310,7 +334,9 @@ void EvaluatorManager::EvaluateObstacle(Obstacle* obstacle,
 void EvaluatorManager::EvaluateObstacle(
     Obstacle* obstacle, ObstaclesContainer* obstacles_container) {
   std::vector&lt;Obstacle*&gt; dummy_dynamic_env;
-  EvaluateObstacle(obstacle, obstacles_container, dummy_dynamic_env);
+  ADCTrajectoryContainer* adc_trajectory_container = nullptr;
+  EvaluateObstacle(adc_trajectory_container, obstacle,
+                   obstacles_container, dummy_dynamic_env);
 }
 
 void EvaluatorManager::BuildObstacleIdHistoryMap(
@@ -408,6 +434,11 @@ std::unique_ptr&lt;Evaluator&gt; EvaluatorManager::CreateEvaluator(
       evaluator_ptr.reset(new SemanticLSTMEvaluator(semantic_map_.get()));
       break;
     }
+    case ObstacleConf::JOINTLY_PREDICTION_PLANNING_EVALUATOR: {
+      evaluator_ptr.reset(new JointlyPredictionPlanningEvaluator(
+          semantic_map_.get()));
+      break;
+    }
     default: {
       break;
     }
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\evaluator_manager.h" new_path="modules\prediction\evaluator\evaluator_manager.h" added_lines="7" deleted_lines="2">
				<diff>@@ -66,9 +66,11 @@ class EvaluatorManager {
   /**
    * @brief Run evaluators
    */
-  void Run(ObstaclesContainer* obstacles_container);
+  void Run(const ADCTrajectoryContainer* adc_trajectory_container,
+           ObstaclesContainer* obstacles_container);
 
-  void EvaluateObstacle(Obstacle* obstacle,
+  void EvaluateObstacle(const ADCTrajectoryContainer* adc_trajectory_container,
+                        Obstacle* obstacle,
                         ObstaclesContainer* obstacles_container,
                         std::vector&lt;Obstacle*&gt; dynamic_env);
 
@@ -127,6 +129,9 @@ class EvaluatorManager {
   ObstacleConf::EvaluatorType default_on_lane_evaluator_ =
       ObstacleConf::MLP_EVALUATOR;
 
+  ObstacleConf::EvaluatorType interaction_evaluator_ =
+      ObstacleConf::JOINTLY_PREDICTION_PLANNING_EVALUATOR;
+
   std::unordered_map&lt;int, ObstacleHistory&gt; obstacle_id_history_map_;
 
   std::unique_ptr&lt;SemanticMap&gt; semantic_map_;
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\evaluator_manager_test.cc" new_path="modules\prediction\evaluator\evaluator_manager_test.cc" added_lines="5" deleted_lines="1">
				<diff>@@ -49,6 +49,9 @@ TEST_F(EvaluatorManagerTest, General) {
 
   ContainerManager container_manager;
   container_manager.Init(adapter_conf_);
+  auto adc_trajectory_container =
+      container_manager.GetContainer&lt;ADCTrajectoryContainer&gt;(
+          AdapterConfig::PLANNING_TRAJECTORY);
   auto obstacles_container =
       container_manager.GetContainer&lt;ObstaclesContainer&gt;(
           AdapterConfig::PERCEPTION_OBSTACLES);
@@ -58,7 +61,8 @@ TEST_F(EvaluatorManagerTest, General) {
   EvaluatorManager evaluator_manager;
 
   evaluator_manager.Init(prediction_conf_);
-  evaluator_manager.Run(obstacles_container);
+  evaluator_manager.Run(adc_trajectory_container,
+      obstacles_container);
 
   Obstacle* obstacle_ptr = obstacles_container-&gt;GetObstacle(1);
   EXPECT_NE(obstacle_ptr, nullptr);
</diff>
			</file>
			<file old_path="modules\prediction\predictor\predictor_manager.cc" new_path="modules\prediction\predictor\predictor_manager.cc" added_lines="15" deleted_lines="0">
				<diff>@@ -276,6 +276,8 @@ void PredictorManager::PredictObstacle(
   prediction_obstacle-&gt;set_timestamp(obstacle-&gt;timestamp());
   prediction_obstacle-&gt;mutable_priority()-&gt;CopyFrom(
       obstacle-&gt;latest_feature().priority());
+  prediction_obstacle-&gt;mutable_interactive_tag()-&gt;CopyFrom(
+      obstacle-&gt;latest_feature().interactive_tag());
   prediction_obstacle-&gt;set_is_static(obstacle-&gt;IsStill());
   if (FLAGS_prediction_offline_mode ==
       PredictionConstants::kDumpPredictionResult) {
@@ -337,6 +339,9 @@ const PredictionObstacles&amp; PredictorManager::prediction_obstacles() {
 }
 
 void PredictorManager::InitVehiclePredictors(const ObstacleConf&amp; conf) {
+  if (!conf.has_obstacle_status() &amp;&amp; conf.has_interactive_tag()) {
+    vehicle_interactive_predictor_ = conf.predictor_type();
+  }
   switch (conf.obstacle_status()) {
     case ObstacleConf::ON_LANE: {
       if (conf.priority_type() == ObstaclePriority::CAUTION) {
@@ -394,6 +399,16 @@ void PredictorManager::RunVehiclePredictor(
     const ADCTrajectoryContainer* adc_trajectory_container, Obstacle* obstacle,
     ObstaclesContainer* obstacles_container) {
   Predictor* predictor = nullptr;
+  if (obstacle-&gt;IsInteractiveObstacle()) {
+    predictor = GetPredictor(vehicle_interactive_predictor_);
+    if (predictor-&gt;Predict(adc_trajectory_container, obstacle,
+                           obstacles_container)) {
+      return;
+    } else {
+      AERROR &lt;&lt; "Obstacle: " &lt;&lt; obstacle-&gt;id()
+             &lt;&lt; " interactive predictor failed!";
+    }
+  }
   if (obstacle-&gt;IsCaution()) {
     if (obstacle-&gt;IsNearJunction()) {
       predictor = GetPredictor(vehicle_in_junction_caution_predictor_);
</diff>
			</file>
			<file old_path="modules\prediction\predictor\predictor_manager.h" new_path="modules\prediction\predictor\predictor_manager.h" added_lines="3" deleted_lines="0">
				<diff>@@ -178,6 +178,9 @@ class PredictorManager {
   ObstacleConf::PredictorType vehicle_default_caution_predictor_ =
       ObstacleConf::EXTRAPOLATION_PREDICTOR;
 
+  ObstacleConf::PredictorType vehicle_interactive_predictor_ =
+      ObstacleConf::EMPTY_PREDICTOR;
+
   PredictionObstacles prediction_obstacles_;
 };
 
</diff>
			</file>
			<file old_path="modules\prediction\predictor\predictor_manager_test.cc" new_path="modules\prediction\predictor\predictor_manager_test.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -71,7 +71,7 @@ TEST_F(PredictorManagerTest, General) {
       container_manager_-&gt;GetContainer&lt;ADCTrajectoryContainer&gt;(
           AdapterConfig::PLANNING_TRAJECTORY);
 
-  evaluator_manager_-&gt;Run(obstacles_container);
+  evaluator_manager_-&gt;Run(adc_trajectory_container, obstacles_container);
   predictor_manager_-&gt;Run(perception_obstacles_, adc_trajectory_container,
                           obstacles_container);
 
</diff>
			</file>
			<file old_path="modules\prediction\scenario\interaction_filter\interaction_filter.cc" new_path="modules\prediction\scenario\interaction_filter\interaction_filter.cc" added_lines="20" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
+ * Copyright 2021 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -110,6 +110,23 @@ void InteractionFilter::AssignInteractiveTag() {
     AERROR &lt;&lt; "Ego vehicle has no history";
     return;
   }
+
+  const auto&amp; obstacle_ids =
+    obstacles_container-&gt;curr_frame_movable_obstacle_ids();
+  for (const int obstacle_id : obstacle_ids) {
+    Obstacle* obstacle_ptr = obstacles_container-&gt;GetObstacle(obstacle_id);
+    if (obstacle_ptr == nullptr) {
+      AERROR &lt;&lt; "Null obstacle pointer found.";
+      continue;
+    }
+    if (obstacle_ptr-&gt;history_size() == 0) {
+      AERROR &lt;&lt; "Obstacle [" &lt;&lt; obstacle_ptr-&gt;id() &lt;&lt; "] has no feature.";
+      continue;
+    }
+    Feature* latest_feature_ptr = obstacle_ptr-&gt;mutable_latest_feature();
+    latest_feature_ptr-&gt;mutable_interactive_tag()-&gt;set_interactive_tag(
+          ObstacleInteractiveTag::NONINTERACTION);
+  }
   auto storytelling_container =
       container_manager_-&gt;GetContainer&lt;StoryTellingContainer&gt;(
           AdapterConfig::STORYTELLING);
@@ -444,6 +461,8 @@ void InteractionFilter::SetInteractiveIfCloseToEgo(
   if (distance &lt; distance_threshold &amp;&amp;
       obstacle_ptr-&gt;latest_feature().type() == PerceptionObstacle::VEHICLE) {
     obstacle_ptr-&gt;SetInteractiveTag();
+  } else {
+    obstacle_ptr-&gt;SetNonInteractiveTag();
   }
 }
 
</diff>
			</file>
			<file old_path="modules\prediction\scenario\interaction_filter\interaction_filter.h" new_path="modules\prediction\scenario\interaction_filter\interaction_filter.h" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
+ * Copyright 2021 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
</diff>
			</file>
			<file old_path="modules\prediction\submodules\evaluator_submodule.cc" new_path="modules\prediction\submodules\evaluator_submodule.cc" added_lines="3" deleted_lines="1">
				<diff>@@ -52,11 +52,13 @@ bool EvaluatorSubmodule::Init() {
 }
 
 bool EvaluatorSubmodule::Proc(
+    const std::shared_ptr&lt;ADCTrajectoryContainer&gt;&amp; adc_trajectory_container,
     const std::shared_ptr&lt;SubmoduleOutput&gt;&amp; container_output) {
   constexpr static size_t kHistorySize = 1;
   const auto frame_start_time = container_output-&gt;frame_start_time();
   ObstaclesContainer obstacles_container(*container_output);
-  evaluator_manager_-&gt;Run(&amp;obstacles_container);
+  evaluator_manager_-&gt;Run(adc_trajectory_container.get(),
+      &amp;obstacles_container);
   SubmoduleOutput submodule_output =
       obstacles_container.GetSubmoduleOutput(kHistorySize, frame_start_time);
   evaluator_writer_-&gt;Write(submodule_output);
</diff>
			</file>
			<file old_path="modules\prediction\submodules\evaluator_submodule.h" new_path="modules\prediction\submodules\evaluator_submodule.h" added_lines="6" deleted_lines="2">
				<diff>@@ -33,7 +33,9 @@
 namespace apollo {
 namespace prediction {
 
-class EvaluatorSubmodule : public cyber::Component&lt;SubmoduleOutput&gt; {
+class EvaluatorSubmodule
+    : public cyber::Component&lt;ADCTrajectoryContainer,
+                            SubmoduleOutput&gt; {
  public:
   /**
    * @brief Destructor
@@ -56,7 +58,9 @@ class EvaluatorSubmodule : public cyber::Component&lt;SubmoduleOutput&gt; {
    * @brief Data callback upon receiving a prediction container output.
    * @param Prediction container output.
    */
-  bool Proc(const std::shared_ptr&lt;SubmoduleOutput&gt;&amp;) override;
+  bool Proc(
+      const std::shared_ptr&lt;ADCTrajectoryContainer&gt;&amp; adc_trajectory_container,
+      const std::shared_ptr&lt;SubmoduleOutput&gt;&amp;) override;
 
  private:
   std::shared_ptr&lt;cyber::Writer&lt;SubmoduleOutput&gt;&gt; evaluator_writer_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="0433893e8b54ef10f17123732102e6a9c3cb42fc" author="fuyiqun">
		<msg>prediction: add feature extraction for VectorNet

Change-Id: Idb0cdb8c179960a447d5692548c5adf460b72ddc</msg>
		<modified_files>
			<file old_path="modules\prediction\common\prediction_system_gflags.cc" new_path="modules\prediction\common\prediction_system_gflags.cc" added_lines="7" deleted_lines="0">
				<diff>@@ -84,3 +84,10 @@ DEFINE_string(evaluator_submodule_name, "evaluator_submodule",
 DEFINE_string(perception_obstacles_topic_name,
               "/apollo/prediction/perception_obstacles",
               "Internal topic of perception obstacles");
+
+// VectorNet
+DEFINE_string(prediction_target_file, "/apollo/data/",
+               "VectorNet target pb file name");
+DEFINE_double(obstacle_x, 0.0, "obstacle position x");
+DEFINE_double(obstacle_y, 0.0, "obstacle position y");
+DEFINE_double(obstacle_phi, 0.0, "obstacle heading phi");
</diff>
			</file>
			<file old_path="modules\prediction\common\prediction_system_gflags.h" new_path="modules\prediction\common\prediction_system_gflags.h" added_lines="6" deleted_lines="0">
				<diff>@@ -51,3 +51,9 @@ DECLARE_string(evaluator_topic_name);
 DECLARE_string(container_submodule_name);
 DECLARE_string(evaluator_submodule_name);
 DECLARE_string(perception_obstacles_topic_name);
+
+// VectorNet
+DECLARE_string(prediction_target_file);
+DECLARE_double(obstacle_x);
+DECLARE_double(obstacle_y);
+DECLARE_double(obstacle_phi);
</diff>
			</file>
			<file old_path="modules\prediction\pipeline\vector_net.cc" new_path="modules\prediction\pipeline\vector_net.cc" added_lines="57" deleted_lines="13">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
+ * Copyright 2021 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,23 +13,67 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *****************************************************************************/
+#include "modules/prediction/pipeline/vector_net.h"
 
+#include &lt;vector&gt;
+
+#include "cyber/common/file.h"
 #include "modules/map/hdmap/hdmap_util.h"
 
 namespace apollo {
 namespace prediction {
-    bool query_nearby_map(const double obstacle_x,
-                      const double obstacle_y,
-                      const double obstacle_phi) {
-        apollo::hdmap::HDMapUtil::ReloadMaps();
-        return true;
-    }
-}
-}
+bool VectorNet::query_nearby_map(const double obstacle_x,
+                                 const double obstacle_y,
+                                 const double obstacle_phi) {
+  apollo::hdmap::HDMapUtil::ReloadMaps();
+  vector_net_pb_.mutable_car_position()-&gt;set_x(obstacle_x);
+  vector_net_pb_.mutable_car_position()-&gt;set_y(obstacle_y);
+  GetRoads(obstacle_x, obstacle_y);
+  cyber::common::SetProtoToASCIIFile(vector_net_pb_,
+                                     FLAGS_prediction_target_file);
+  AINFO &lt;&lt; "Obstacle heading." &lt;&lt; obstacle_phi;
 
-int main(int argc, char* argv[]) {
-    google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);
-    apollo::prediction::query_nearby_map(Flag_obstacle_x, Flag_obstacle_y, Flag_obstacle_phi);
-    return 0;
+  return true;
 }
 
+void VectorNet::GetRoads(const double base_x, const double base_y) {
+  common::PointENU center_point;
+  center_point.set_x(base_x);
+  center_point.set_y(base_x);
+
+  std::vector&lt;apollo::hdmap::RoadInfoConstPtr&gt; roads;
+  apollo::hdmap::HDMapUtil::BaseMap().GetRoads(center_point, 141.4, &amp;roads);
+  AINFO &lt;&lt; "Road Size: " &lt;&lt; roads.size();
+
+  for (const auto&amp; road : roads) {
+    auto road_ = vector_net_pb_.add_road();
+    road_-&gt;set_id(road-&gt;road().id().id());
+    for (const auto&amp; section : road-&gt;road().section()) {
+      for (const auto&amp; edge : section.boundary().outer_polygon().edge()) {
+        if (edge.type() == 2) {  // left edge
+          for (const auto&amp; segment : edge.curve().segment()) {
+            auto edge_ = road_-&gt;add_edge();
+            auto size = segment.line_segment().point().size();
+            auto first = segment.line_segment().point(0);
+            auto last = segment.line_segment().point(size - 1);
+            edge_-&gt;set_type(apollo::prediction::Edge::LEFT_BOUNDARY);
+            edge_-&gt;mutable_start_point()-&gt;CopyFrom(first);
+            edge_-&gt;mutable_end_point()-&gt;CopyFrom(last);
+          }
+        } else if (edge.type() == 3) {  // right edge
+          for (const auto&amp; segment : edge.curve().segment()) {
+            auto edge_ = road_-&gt;add_edge();
+            auto size = segment.line_segment().point().size();
+            auto first = segment.line_segment().point(0);
+            auto last = segment.line_segment().point(size - 1);
+            edge_-&gt;set_type(apollo::prediction::Edge::RIGHT_BOUNDARY);
+            edge_-&gt;mutable_start_point()-&gt;CopyFrom(last);
+            edge_-&gt;mutable_end_point()-&gt;CopyFrom(first);
+          }
+        }
+      }
+    }
+  }
+}
+}  // namespace prediction
+}  // namespace apollo
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="bb7f16c2948dd159532885ecfbc3e8238f604c71" author="fuyiqun">
		<msg>prediction: generate pb files for VectorNet

Change-Id: I31b8f671ed049121645f6fd71e43ccdc8d17f1fb</msg>
		<modified_files>
			<file old_path="modules\prediction\pipeline\vector_net.cc" new_path="modules\prediction\pipeline\vector_net.cc" added_lines="4" deleted_lines="5">
				<diff>@@ -18,6 +18,7 @@
 #include &lt;vector&gt;
 
 #include "cyber/common/file.h"
+#include "modules/common/util/point_factory.h"
 #include "modules/map/hdmap/hdmap_util.h"
 
 namespace apollo {
@@ -31,16 +32,14 @@ bool VectorNet::query_nearby_map(const double obstacle_x,
   GetRoads(obstacle_x, obstacle_y);
   cyber::common::SetProtoToASCIIFile(vector_net_pb_,
                                      FLAGS_prediction_target_file);
-  AINFO &lt;&lt; "Obstacle heading." &lt;&lt; obstacle_phi;
+  AINFO &lt;&lt; "Obstacle heading: " &lt;&lt; obstacle_phi;
 
   return true;
 }
 
 void VectorNet::GetRoads(const double base_x, const double base_y) {
-  common::PointENU center_point;
-  center_point.set_x(base_x);
-  center_point.set_y(base_x);
-
+  common::PointENU center_point =
+      common::util::PointFactory::ToPointENU(base_x, base_y);
   std::vector&lt;apollo::hdmap::RoadInfoConstPtr&gt; roads;
   apollo::hdmap::HDMapUtil::BaseMap().GetRoads(center_point, 141.4, &amp;roads);
   AINFO &lt;&lt; "Road Size: " &lt;&lt; roads.size();
</diff>
			</file>
			<file old_path="modules\prediction\pipeline\vector_net.h" new_path="modules\prediction\pipeline\vector_net.h" added_lines="8" deleted_lines="8">
				<diff>@@ -24,19 +24,19 @@ namespace apollo {
 namespace prediction {
 
 class VectorNet {
-    public:
-    VectorNet() = default;
+ public:
+  VectorNet() = default;
 
-    virtual ~VectorNet() = default;
+  virtual ~VectorNet() = default;
 
-    bool query_nearby_map(const double obstacle_x, const double obstacle_y,
+  bool query_nearby_map(const double obstacle_x, const double obstacle_y,
                         const double obstacle_phi);
 
-    private:
-    void GetRoads(const double base_x, const double base_y);
+ private:
+  void GetRoads(const double base_x, const double base_y);
 
-    private:
-    apollo::prediction::VectorNetFeature vector_net_pb_;
+ private:
+  apollo::prediction::VectorNetFeature vector_net_pb_;
 };
 
 }  // namespace prediction
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="398085dc92608a2f1e3e63cb219557ed7d493543" author="fuyiqun">
		<msg>prediction: modify proto to vector elements

Change-Id: I17889196e69ecad74fd2540a9c1633ce14858ebe</msg>
		<modified_files>
			<file old_path="modules\prediction\pipeline\vector_net.cc" new_path="modules\prediction\pipeline\vector_net.cc" added_lines="56" deleted_lines="26">
				<diff>@@ -15,7 +15,7 @@
  *****************************************************************************/
 #include "modules/prediction/pipeline/vector_net.h"
 
-#include &lt;vector&gt;
+#include &lt;utility&gt;
 
 #include "cyber/common/file.h"
 #include "modules/common/util/point_factory.h"
@@ -23,13 +23,33 @@
 
 namespace apollo {
 namespace prediction {
-bool VectorNet::query_nearby_map(const double obstacle_x,
-                                 const double obstacle_y,
-                                 const double obstacle_phi) {
+bool VectorNet::query(const double obstacle_x, const double obstacle_y,
+                      const double obstacle_phi,
+                      std::shared_ptr&lt;FeatureVector&gt; feature_ptr) {
+  feature_ptr_ = feature_ptr;
   apollo::hdmap::HDMapUtil::ReloadMaps();
+  GetRoads(obstacle_x, obstacle_y);
+
+  return true;
+}
+
+bool VectorNet::offline_query(const double obstacle_x, const double obstacle_y,
+                              const double obstacle_phi) {
+  std::shared_ptr&lt;FeatureVector&gt; offline_feature_ptr =
+      std::make_shared&lt;FeatureVector&gt;();
+  query(obstacle_x, obstacle_y, obstacle_phi, offline_feature_ptr);
+
   vector_net_pb_.mutable_car_position()-&gt;set_x(obstacle_x);
   vector_net_pb_.mutable_car_position()-&gt;set_y(obstacle_y);
-  GetRoads(obstacle_x, obstacle_y);
+  for (const auto&amp; polyline : *offline_feature_ptr) {
+    auto polyline_ = vector_net_pb_.add_polyline();
+    for (const auto&amp; vector : polyline) {
+      auto vector_ = polyline_-&gt;add_vector();
+      for (const auto&amp; element : vector) {
+        vector_-&gt;add_element(element);
+      }
+    }
+  }
   cyber::common::SetProtoToASCIIFile(vector_net_pb_,
                                      FLAGS_prediction_target_file);
   AINFO &lt;&lt; "Obstacle heading: " &lt;&lt; obstacle_phi;
@@ -37,6 +57,7 @@ bool VectorNet::query_nearby_map(const double obstacle_x,
   return true;
 }
 
+// make std::vectors here
 void VectorNet::GetRoads(const double base_x, const double base_y) {
   common::PointENU center_point =
       common::util::PointFactory::ToPointENU(base_x, base_y);
@@ -45,33 +66,42 @@ void VectorNet::GetRoads(const double base_x, const double base_y) {
   AINFO &lt;&lt; "Road Size: " &lt;&lt; roads.size();
 
   for (const auto&amp; road : roads) {
-    auto road_ = vector_net_pb_.add_road();
-    road_-&gt;set_id(road-&gt;road().id().id());
+    std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
+    const auto&amp; str_id = road-&gt;id().id();
+    if (id_map_.find(str_id) == id_map_.end()) {
+      id_map_[str_id] = static_cast&lt;int&gt;(id_map_.size());
+    }
+    int int_id = id_map_[str_id];
+
     for (const auto&amp; section : road-&gt;road().section()) {
       for (const auto&amp; edge : section.boundary().outer_polygon().edge()) {
-        if (edge.type() == 2) {  // left edge
-          for (const auto&amp; segment : edge.curve().segment()) {
-            auto edge_ = road_-&gt;add_edge();
-            auto size = segment.line_segment().point().size();
-            auto first = segment.line_segment().point(0);
-            auto last = segment.line_segment().point(size - 1);
-            edge_-&gt;set_type(apollo::prediction::Edge::LEFT_BOUNDARY);
-            edge_-&gt;mutable_start_point()-&gt;CopyFrom(first);
-            edge_-&gt;mutable_end_point()-&gt;CopyFrom(last);
-          }
-        } else if (edge.type() == 3) {  // right edge
-          for (const auto&amp; segment : edge.curve().segment()) {
-            auto edge_ = road_-&gt;add_edge();
-            auto size = segment.line_segment().point().size();
-            auto first = segment.line_segment().point(0);
-            auto last = segment.line_segment().point(size - 1);
-            edge_-&gt;set_type(apollo::prediction::Edge::RIGHT_BOUNDARY);
-            edge_-&gt;mutable_start_point()-&gt;CopyFrom(last);
-            edge_-&gt;mutable_end_point()-&gt;CopyFrom(first);
+        for (const auto&amp; segment : edge.curve().segment()) {
+          auto last_point = segment.line_segment().point(0);
+          size_t size = segment.line_segment().point().size();
+          for (size_t i = 1; i &lt; size; ++i) {
+            auto point = segment.line_segment().point(i);
+            std::vector&lt;double&gt; one_vector;
+            // d_s, d_e
+            one_vector.push_back(last_point.x() - base_x);
+            one_vector.push_back(last_point.y() - base_y);
+            one_vector.push_back(point.x() - base_x);
+            one_vector.push_back(point.y() - base_y);
+            last_point = std::move(point);
+            // attribute
+            if (edge.type() == 2) {  // left edge
+              one_vector.push_back(1);
+              one_vector.push_back(0);
+            } else if (edge.type() == 3) {  // right edge
+              one_vector.push_back(0);
+              one_vector.push_back(1);
+            }
+            one_vector.push_back(int_id);
+            one_polyline.push_back(std::move(one_vector));
           }
         }
       }
     }
+    feature_ptr_.get()-&gt;push_back(std::move(one_polyline));
   }
 }
 }  // namespace prediction
</diff>
			</file>
			<file old_path="modules\prediction\pipeline\vector_net.h" new_path="modules\prediction\pipeline\vector_net.h" added_lines="17" deleted_lines="5">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
+ * Copyright 2021 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,27 +16,39 @@
 
 #pragma once
 
-#include "modules/prediction/proto/vector_net.pb.h"
+#include &lt;memory&gt;
+#include &lt;string&gt;
+#include &lt;unordered_map&gt;
+#include &lt;vector&gt;
 
 #include "modules/prediction/common/prediction_system_gflags.h"
+#include "modules/prediction/proto/vector_net.pb.h"
 
 namespace apollo {
 namespace prediction {
 
+using FeatureVector = std::vector&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt;;
+
 class VectorNet {
  public:
   VectorNet() = default;
 
-  virtual ~VectorNet() = default;
+  ~VectorNet() = default;
+
+  bool query(const double obstacle_x, const double obstacle_y,
+             const double obstacle_phi,
+             std::shared_ptr&lt;FeatureVector&gt; feature_ptr);
 
-  bool query_nearby_map(const double obstacle_x, const double obstacle_y,
-                        const double obstacle_phi);
+  bool offline_query(const double obstacle_x, const double obstacle_y,
+                     const double obstacle_phi);
 
  private:
   void GetRoads(const double base_x, const double base_y);
 
  private:
   apollo::prediction::VectorNetFeature vector_net_pb_;
+  std::shared_ptr&lt;FeatureVector&gt; feature_ptr_ = nullptr;
+  std::unordered_map&lt;std::string, int&gt; id_map_;
 };
 
 }  // namespace prediction
</diff>
			</file>
			<file old_path="modules\prediction\pipeline\vector_net_feature.cc" new_path="modules\prediction\pipeline\vector_net_feature.cc" added_lines="3" deleted_lines="4">
				<diff>@@ -20,9 +20,8 @@ using apollo::prediction::VectorNet;
 
 int main(int argc, char* argv[]) {
   google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);
-  std::unique_ptr&lt;VectorNet&gt; vector_net(new VectorNet());
-  vector_net-&gt;query_nearby_map(FLAGS_obstacle_x,
-                               FLAGS_obstacle_y,
-                               FLAGS_obstacle_phi);
+  VectorNet vector_net = VectorNet();
+  vector_net.offline_query(FLAGS_obstacle_x, FLAGS_obstacle_y,
+                              FLAGS_obstacle_phi);
   return 0;
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="37eca3ef5d06c421afe9c8c0770ded3e967aa288" author="fuyiqun">
		<msg>prediction: add rotation for vectors

Change-Id: If6b0f964897d1acc8ab1451142780ed466dafe7c</msg>
		<modified_files>
			<file old_path="modules\prediction\common\prediction_system_gflags.cc" new_path="modules\prediction\common\prediction_system_gflags.cc" added_lines="4" deleted_lines="2">
				<diff>@@ -86,8 +86,10 @@ DEFINE_string(perception_obstacles_topic_name,
               "Internal topic of perception obstacles");
 
 // VectorNet
-DEFINE_string(prediction_target_file, "/apollo/data/",
-               "VectorNet target pb file name");
+DEFINE_string(prediction_target_file, "/apollo/data/train/test.pb.txt",
+              "VectorNet target pb file name");
 DEFINE_double(obstacle_x, 0.0, "obstacle position x");
 DEFINE_double(obstacle_y, 0.0, "obstacle position y");
 DEFINE_double(obstacle_phi, 0.0, "obstacle heading phi");
+DEFINE_double(road_distance, 141.4,
+              "road distance within which the points are got");
</diff>
			</file>
			<file old_path="modules\prediction\common\prediction_system_gflags.h" new_path="modules\prediction\common\prediction_system_gflags.h" added_lines="1" deleted_lines="0">
				<diff>@@ -57,3 +57,4 @@ DECLARE_string(prediction_target_file);
 DECLARE_double(obstacle_x);
 DECLARE_double(obstacle_y);
 DECLARE_double(obstacle_phi);
+DECLARE_double(road_distance);
</diff>
			</file>
			<file old_path="modules\prediction\pipeline\vector_net.cc" new_path="modules\prediction\pipeline\vector_net.cc" added_lines="40" deleted_lines="37">
				<diff>@@ -25,83 +25,86 @@ namespace apollo {
 namespace prediction {
 bool VectorNet::query(const double obstacle_x, const double obstacle_y,
                       const double obstacle_phi,
-                      std::shared_ptr&lt;FeatureVector&gt; feature_ptr) {
-  feature_ptr_ = feature_ptr;
+                      FeatureVector* const feature_ptr) {
+  CHECK_NOTNULL(feature_ptr);
+  count_ = 0;
   apollo::hdmap::HDMapUtil::ReloadMaps();
-  GetRoads(obstacle_x, obstacle_y);
+  GetRoads(obstacle_x, obstacle_y, obstacle_phi, feature_ptr);
 
   return true;
 }
 
 bool VectorNet::offline_query(const double obstacle_x, const double obstacle_y,
                               const double obstacle_phi) {
-  std::shared_ptr&lt;FeatureVector&gt; offline_feature_ptr =
-      std::make_shared&lt;FeatureVector&gt;();
-  query(obstacle_x, obstacle_y, obstacle_phi, offline_feature_ptr);
+  FeatureVector offline_feature;
+  query(obstacle_x, obstacle_y, obstacle_phi, &amp;offline_feature);
 
+  apollo::prediction::VectorNetFeature vector_net_pb_;
   vector_net_pb_.mutable_car_position()-&gt;set_x(obstacle_x);
   vector_net_pb_.mutable_car_position()-&gt;set_y(obstacle_y);
-  for (const auto&amp; polyline : *offline_feature_ptr) {
-    auto polyline_ = vector_net_pb_.add_polyline();
+  vector_net_pb_.mutable_car_position()-&gt;set_phi(obstacle_phi);
+
+  for (const auto&amp; polyline : offline_feature) {
+    auto* polyline_pb = vector_net_pb_.add_polyline();
     for (const auto&amp; vector : polyline) {
-      auto vector_ = polyline_-&gt;add_vector();
+      auto* vector_pb = polyline_pb-&gt;add_vector();
       for (const auto&amp; element : vector) {
-        vector_-&gt;add_element(element);
+        vector_pb-&gt;add_element(element);
       }
     }
   }
   cyber::common::SetProtoToASCIIFile(vector_net_pb_,
                                      FLAGS_prediction_target_file);
-  AINFO &lt;&lt; "Obstacle heading: " &lt;&lt; obstacle_phi;
 
   return true;
 }
 
-// make std::vectors here
-void VectorNet::GetRoads(const double base_x, const double base_y) {
+void VectorNet::GetRoads(const double base_x, const double base_y,
+                         const double obstacle_phi,
+                         FeatureVector* const feature_ptr) {
   common::PointENU center_point =
       common::util::PointFactory::ToPointENU(base_x, base_y);
   std::vector&lt;apollo::hdmap::RoadInfoConstPtr&gt; roads;
-  apollo::hdmap::HDMapUtil::BaseMap().GetRoads(center_point, 141.4, &amp;roads);
-  AINFO &lt;&lt; "Road Size: " &lt;&lt; roads.size();
+  apollo::hdmap::HDMapUtil::BaseMap().GetRoads(center_point,
+                                               FLAGS_road_distance, &amp;roads);
 
   for (const auto&amp; road : roads) {
-    std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
-    const auto&amp; str_id = road-&gt;id().id();
-    if (id_map_.find(str_id) == id_map_.end()) {
-      id_map_[str_id] = static_cast&lt;int&gt;(id_map_.size());
-    }
-    int int_id = id_map_[str_id];
-
     for (const auto&amp; section : road-&gt;road().section()) {
       for (const auto&amp; edge : section.boundary().outer_polygon().edge()) {
+        std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
         for (const auto&amp; segment : edge.curve().segment()) {
           auto last_point = segment.line_segment().point(0);
+          auto last_point_after_rotate = common::math::RotateVector2d(
+              {last_point.x() - base_x, last_point.y() - base_y},
+              M_PI_2 - obstacle_phi);
           size_t size = segment.line_segment().point().size();
           for (size_t i = 1; i &lt; size; ++i) {
-            auto point = segment.line_segment().point(i);
+            // TODO(Yiqun):
+            // check the segments are discretized with the same interval
             std::vector&lt;double&gt; one_vector;
+
             // d_s, d_e
-            one_vector.push_back(last_point.x() - base_x);
-            one_vector.push_back(last_point.y() - base_y);
-            one_vector.push_back(point.x() - base_x);
-            one_vector.push_back(point.y() - base_y);
-            last_point = std::move(point);
+            one_vector.push_back(last_point_after_rotate.x());
+            one_vector.push_back(last_point_after_rotate.y());
+            auto point = segment.line_segment().point(i);
+            Eigen::Vector2d point_after_rotate = common::math::RotateVector2d(
+                {point.x() - base_x, point.y() - base_y},
+                M_PI_2 - obstacle_phi);
+            one_vector.push_back(point_after_rotate.x());
+            one_vector.push_back(point_after_rotate.y());
+            last_point_after_rotate = std::move(point_after_rotate);
+
             // attribute
-            if (edge.type() == 2) {  // left edge
-              one_vector.push_back(1);
-              one_vector.push_back(0);
-            } else if (edge.type() == 3) {  // right edge
-              one_vector.push_back(0);
-              one_vector.push_back(1);
-            }
-            one_vector.push_back(int_id);
+            one_vector.insert(one_vector.end(), {1, 0, 0, 0});
+
+            one_vector.push_back(count_);
             one_polyline.push_back(std::move(one_vector));
           }
         }
+        feature_ptr-&gt;push_back(std::move(one_polyline));
+        ++count_;
       }
     }
-    feature_ptr_.get()-&gt;push_back(std::move(one_polyline));
   }
 }
 }  // namespace prediction
</diff>
			</file>
			<file old_path="modules\prediction\pipeline\vector_net.h" new_path="modules\prediction\pipeline\vector_net.h" added_lines="4" deleted_lines="11">
				<diff>@@ -16,9 +16,6 @@
 
 #pragma once
 
-#include &lt;memory&gt;
-#include &lt;string&gt;
-#include &lt;unordered_map&gt;
 #include &lt;vector&gt;
 
 #include "modules/prediction/common/prediction_system_gflags.h"
@@ -36,19 +33,15 @@ class VectorNet {
   ~VectorNet() = default;
 
   bool query(const double obstacle_x, const double obstacle_y,
-             const double obstacle_phi,
-             std::shared_ptr&lt;FeatureVector&gt; feature_ptr);
+             const double obstacle_phi, FeatureVector* const feature_ptr);
 
   bool offline_query(const double obstacle_x, const double obstacle_y,
                      const double obstacle_phi);
 
  private:
-  void GetRoads(const double base_x, const double base_y);
-
- private:
-  apollo::prediction::VectorNetFeature vector_net_pb_;
-  std::shared_ptr&lt;FeatureVector&gt; feature_ptr_ = nullptr;
-  std::unordered_map&lt;std::string, int&gt; id_map_;
+  void GetRoads(const double base_x, const double base_y,
+                const double obstacle_phi, FeatureVector* const feature_ptr);
+  int count_ = 0;
 };
 
 }  // namespace prediction
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6459f70e5c8dd20e324e5fc8afb99738a71dc6f1" author="storypku">
		<msg>Localization: Eigen alignment coredump fix</msg>
		<modified_files>
			<file old_path="modules\localization\msf\local_tool\local_visualization\engine\visualization_engine.cc" new_path="modules\localization\msf\local_tool\local_visualization\engine\visualization_engine.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -142,7 +142,7 @@ bool VisualizationEngine::Init(const std::string &amp;map_folder,
 }
 
 void VisualizationEngine::Visualize(
-    const std::vector&lt;LocalizatonInfo&gt; &amp;loc_infos,
+    ::apollo::common::EigenVector&lt;LocalizatonInfo&gt; &amp;&amp;loc_infos,
     const ::apollo::common::EigenVector3dVec &amp;cloud) {
   if (!is_init_) {
     AERROR &lt;&lt; "Visualziation should be init first.";
@@ -154,7 +154,7 @@ void VisualizationEngine::Visualize(
     return;
   }
 
-  cur_loc_infos_ = loc_infos;
+  cur_loc_infos_ = std::move(loc_infos);
 
   if (!UpdateCarLocId(expected_car_loc_id_)) {
     if (!UpdateCarLocId(car_loc_id_)) {
</diff>
			</file>
			<file old_path="modules\localization\msf\local_tool\local_visualization\engine\visualization_engine.h" new_path="modules\localization\msf\local_tool\local_visualization\engine\visualization_engine.h" added_lines="7" deleted_lines="5">
				<diff>@@ -27,9 +27,10 @@
 #include &lt;vector&gt;
 
 #include "Eigen/Geometry"
-#include "modules/common/util/eigen_defs.h"
 #include "opencv2/opencv.hpp"
 
+#include "modules/common/util/eigen_defs.h"
+
 namespace apollo {
 namespace localization {
 namespace msf {
@@ -39,8 +40,6 @@ namespace msf {
  * @brief The data structure to store info of a localization
  */
 struct LocalizatonInfo {
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-
   void set(const Eigen::Translation3d &amp;location,
            const Eigen::Quaterniond &amp;attitude, const Eigen::Vector3d &amp;std_var,
            const std::string &amp;description, const double timestamp,
@@ -88,6 +87,9 @@ struct LocalizatonInfo {
   bool is_valid = false;
   bool is_has_attitude = false;
   bool is_has_std = false;
+
+ public:
+  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
 };
 
 /**
@@ -168,7 +170,7 @@ class VisualizationEngine {
             const VisualMapParam &amp;map_param, const unsigned int resolution_id,
             const int zone_id, const Eigen::Affine3d &amp;extrinsic,
             const unsigned int loc_info_num = 1);
-  void Visualize(const std::vector&lt;LocalizatonInfo&gt; &amp;loc_infos,
+  void Visualize(::apollo::common::EigenVector&lt;LocalizatonInfo&gt; &amp;&amp;loc_infos,
                  const ::apollo::common::EigenVector3dVec &amp;cloud);
   void SetAutoPlay(bool auto_play);
 
@@ -284,7 +286,7 @@ class VisualizationEngine {
   unsigned int loc_info_num_ = 1;
   unsigned int car_loc_id_ = 0;
   unsigned int expected_car_loc_id_ = 0;
-  std::vector&lt;LocalizatonInfo&gt; cur_loc_infos_;
+  ::apollo::common::EigenVector&lt;LocalizatonInfo&gt; cur_loc_infos_;
   std::vector&lt;std::map&lt;double, Eigen::Vector2d&gt;&gt; trajectory_groups_;
 
   bool is_draw_car_ = true;
</diff>
			</file>
			<file old_path="modules\localization\msf\local_tool\local_visualization\engine\visualization_manager.cc" new_path="modules\localization\msf\local_tool\local_visualization\engine\visualization_manager.cc" added_lines="3" deleted_lines="5">
				<diff>@@ -435,11 +435,9 @@ void VisualizationManager::DoVisualize() {
                           lidar_frame.frame_id);
       }
 
-      std::vector&lt;LocalizatonInfo&gt; loc_infos;
-      loc_infos.push_back(lidar_loc_info);
-      loc_infos.push_back(fusion_loc_info);
-      loc_infos.push_back(gnss_loc_info);
-      visual_engine_.Visualize(loc_infos, lidar_frame.pt3ds);
+      ::apollo::common::EigenVector&lt;LocalizatonInfo&gt; loc_infos{
+          lidar_loc_info, fusion_loc_info, gnss_loc_info};
+      visual_engine_.Visualize(std::move(loc_infos), lidar_frame.pt3ds);
     }
   }
 }
</diff>
			</file>
			<file old_path="modules\localization\msf\local_tool\local_visualization\offline_visual\offline_local_visualizer.cc" new_path="modules\localization\msf\local_tool\local_visualization\offline_visual\offline_local_visualizer.cc" added_lines="6" deleted_lines="6">
				<diff>@@ -16,7 +16,10 @@
 
 #include "modules/localization/msf/local_tool/local_visualization/offline_visual/offline_local_visualizer.h"
 
+#include &lt;utility&gt;
+
 #include &lt;boost/filesystem.hpp&gt;
+
 #include "absl/strings/str_cat.h"
 
 #include "cyber/common/log.h"
@@ -164,18 +167,15 @@ void OfflineLocalVisualizer::Visualize() {
                           "Fusion.", pcd_timestamps_[idx], idx + 1);
     }
 
-    std::vector&lt;LocalizatonInfo&gt; loc_infos;
-    loc_infos.push_back(lidar_loc_info);
-    loc_infos.push_back(gnss_loc_info);
-    loc_infos.push_back(fusion_loc_info);
-
     std::string pcd_file_path = absl::StrCat(pcd_folder_, "/", idx + 1, ".pcd");
     ::apollo::common::EigenVector3dVec pt3ds;
     std::vector&lt;unsigned char&gt; intensities;
     apollo::localization::msf::velodyne::LoadPcds(
         pcd_file_path, idx, lidar_loc_info.pose, &amp;pt3ds, &amp;intensities, false);
 
-    visual_engine_.Visualize(loc_infos, pt3ds);
+    ::apollo::common::EigenVector&lt;LocalizatonInfo&gt; loc_infos{
+        lidar_loc_info, gnss_loc_info, fusion_loc_info};
+    visual_engine_.Visualize(std::move(loc_infos), pt3ds);
   }
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4e20aaeb3bf356bd2ca88d018b01a46359e8207c" author="jiangjianan">
		<msg>prediction: modified adc trajectory to match with the predicted obstacles' timestamp

Change-Id: Ia959dfb7ecf1575b3cf943b860d69e72f23ca8fc</msg>
		<modified_files>
			<file old_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.cc" added_lines="78" deleted_lines="60">
				<diff>@@ -20,6 +20,7 @@
 
 #include "Eigen/Dense"
 #include "cyber/common/file.h"
+#include "modules/common/math/linear_interpolation.h"
 #include "modules/prediction/common/prediction_gflags.h"
 #include "modules/prediction/common/prediction_map.h"
 #include "modules/prediction/common/prediction_system_gflags.h"
@@ -31,6 +32,7 @@ namespace prediction {
 
 using apollo::common::TrajectoryPoint;
 using apollo::common::math::Vec2d;
+using apollo::common::math::InterpolateUsingLinearApproximation;
 
 JointlyPredictionPlanningEvaluator::JointlyPredictionPlanningEvaluator(
     SemanticMap* semantic_map)
@@ -89,64 +91,77 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
   img_tensor[0][2] = img_tensor[0][2].sub(0.406).div(0.225);
 
   // Extract features of pos_history
-  std::vector&lt;std::pair&lt;double, double&gt;&gt; pos_history(10, {0.0, 0.0});
+  std::vector&lt;std::pair&lt;double, double&gt;&gt; pos_history(20, {0.0, 0.0});
   if (!ExtractObstacleHistory(obstacle_ptr, &amp;pos_history)) {
     ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id &lt;&lt; "] failed to extract obstacle history";
     return false;
   }
   // Process obstacle_history
-  torch::Tensor obstacle_pos = torch::zeros({1, 10, 2});
-  torch::Tensor obstacle_pos_step = torch::zeros({1, 10, 2});
-  for (int i = 0; i &lt; 10; ++i) {
-    obstacle_pos[0][9 - i][0] = pos_history[i].first;
-    obstacle_pos[0][9 - i][1] = pos_history[i].second;
-    if (i == 9 || (i &gt; 0 &amp;&amp; pos_history[i].first &lt; 1.0e-10)) {
+  torch::Tensor obstacle_pos = torch::zeros({1, 20, 2});
+  torch::Tensor obstacle_pos_step = torch::zeros({1, 20, 2});
+  for (int i = 0; i &lt; 20; ++i) {
+    obstacle_pos[0][19 - i][0] = pos_history[i].first;
+    obstacle_pos[0][19 - i][1] = pos_history[i].second;
+    if (i == 19 || (i &gt; 0 &amp;&amp; pos_history[i].first &lt; 1.0e-10)) {
       break;
     }
-    obstacle_pos_step[0][9 - i][0] =
+    obstacle_pos_step[0][19 - i][0] =
         pos_history[i].first - pos_history[i + 1].first;
-    obstacle_pos_step[0][9 - i][1] =
+    obstacle_pos_step[0][19 - i][1] =
         pos_history[i].second - pos_history[i + 1].second;
   }
 
-  // Extract features of ADC trajectory
-  std::vector&lt;std::pair&lt;double, double&gt;&gt; adc_traj_curr_pos(10, {0.0, 0.0});
-  if (!ExtractADCTrajectory(adc_trajectory_container,
-          obstacle_ptr, &amp;adc_traj_curr_pos)) {
+  // Process ADC trajectory &amp; Extract features of ADC trajectory
+  std::vector&lt;std::pair&lt;double, double&gt;&gt; adc_traj_curr_pos(30, {0.0, 0.0});
+  torch::Tensor adc_trajectory = torch::zeros({1, 30, 6});
+  const auto&amp; adc_traj = adc_trajectory_container-&gt;adc_trajectory();
+  size_t adc_traj_points_num = adc_traj.trajectory_point().size();
+  std::vector&lt;TrajectoryPoint&gt; adc_traj_points;
+  // ADC trajectory info as model input needs to match with
+  // the predicted obstalce's timestamp.
+  double time_interval = obstacle_ptr-&gt;latest_feature().timestamp() -
+      adc_traj.header().timestamp_sec();
+  for (size_t i = 0; i &lt; adc_traj_points_num - 1; ++i) {
+    double delta_time = time_interval -
+        adc_traj.trajectory_point(0).relative_time();
+    adc_traj_points.emplace_back(
+        InterpolateUsingLinearApproximation(
+            adc_traj.trajectory_point(i),
+            adc_traj.trajectory_point(i + 1), delta_time));
+  }
+  if (!ExtractADCTrajectory(&amp;adc_traj_points,
+      obstacle_ptr, &amp;adc_traj_curr_pos)) {
     ADEBUG &lt;&lt; "Failed to extract adc trajectory";
     return false;
   }
-  // Process ADC trajectory
-  torch::Tensor adc_trajectory = torch::zeros({1, 10, 6});
-  const auto&amp; adc_traj = adc_trajectory_container-&gt;adc_trajectory();
-  size_t traj_points_num = adc_traj.trajectory_point().size();
-  for (size_t i = 0; i &lt; 10; ++i) {
-    if (i &gt; traj_points_num - 1) {
-      adc_trajectory[0][i][0] =
-          adc_traj_curr_pos[traj_points_num].first;
-      adc_trajectory[0][i][1] =
-          adc_traj_curr_pos[traj_points_num].second;
-      adc_trajectory[0][i][2] =
-          adc_traj.trajectory_point(traj_points_num).path_point().theta();
-      adc_trajectory[0][i][3] =
-          adc_traj.trajectory_point(traj_points_num).v();
-      adc_trajectory[0][i][4] =
-          adc_traj.trajectory_point(traj_points_num).a();
-      adc_trajectory[0][i][5] =
-          adc_traj.trajectory_point(traj_points_num).path_point().kappa();
+  size_t traj_points_num = adc_traj_points.size();
+  for (size_t j = 0; j &lt; 30; ++j) {
+    if (j &gt; traj_points_num - 1) {
+      adc_trajectory[0][j][0] =
+          adc_traj_curr_pos[traj_points_num - 1].first;
+      adc_trajectory[0][j][1] =
+          adc_traj_curr_pos[traj_points_num - 1].second;
+      adc_trajectory[0][j][2] =
+          adc_traj_points[traj_points_num - 1].path_point().theta();
+      adc_trajectory[0][j][3] =
+          adc_traj_points[traj_points_num - 1].v();
+      adc_trajectory[0][j][4] =
+          adc_traj_points[traj_points_num - 1].a();
+      adc_trajectory[0][j][5] =
+          adc_traj_points[traj_points_num - 1].path_point().kappa();
     } else {
-      adc_trajectory[0][i][0] =
-          adc_traj_curr_pos[i].first;
-      adc_trajectory[0][i][1] =
-          adc_traj_curr_pos[i].second;
-      adc_trajectory[0][i][2] =
-          adc_traj.trajectory_point(i).path_point().theta();
-      adc_trajectory[0][i][3] =
-          adc_traj.trajectory_point(i).v();
-      adc_trajectory[0][i][4] =
-          adc_traj.trajectory_point(i).a();
-      adc_trajectory[0][i][5] =
-          adc_traj.trajectory_point(i).path_point().kappa();
+      adc_trajectory[0][j][0] =
+          adc_traj_curr_pos[j].first;
+      adc_trajectory[0][j][1] =
+          adc_traj_curr_pos[j].second;
+      adc_trajectory[0][j][2] =
+          adc_traj_points[j].path_point().theta();
+      adc_trajectory[0][j][3] =
+          adc_traj_points[j].v();
+      adc_trajectory[0][j][4] =
+          adc_traj_points[j].a();
+      adc_trajectory[0][j][5] =
+          adc_traj_points[j].path_point().kappa();
     }
   }
 
@@ -179,7 +194,7 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
   Trajectory* trajectory = latest_feature_ptr-&gt;add_predicted_trajectory();
   trajectory-&gt;set_probability(1.0);
 
-  for (int i = 0; i &lt; 10; ++i) {
+  for (int i = 0; i &lt; 30; ++i) {
     double prev_x = pos_x;
     double prev_y = pos_y;
     if (i &gt; 0) {
@@ -199,7 +214,7 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
     point-&gt;mutable_path_point()-&gt;set_x(point_x);
     point-&gt;mutable_path_point()-&gt;set_y(point_y);
 
-    if (i &lt; 5) {  // use origin heading for the first second
+    if (i &lt; 10) {  // use origin heading for the first second
       point-&gt;mutable_path_point()-&gt;set_theta(
           latest_feature_ptr-&gt;velocity_heading());
     } else {
@@ -227,12 +242,12 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
 bool JointlyPredictionPlanningEvaluator::ExtractObstacleHistory(
     Obstacle* obstacle_ptr,
     std::vector&lt;std::pair&lt;double, double&gt;&gt;* pos_history) {
-  pos_history-&gt;resize(10, {0.0, 0.0});
+  pos_history-&gt;resize(20, {0.0, 0.0});
   const Feature&amp; obs_curr_feature = obstacle_ptr-&gt;latest_feature();
   double obs_curr_heading = obs_curr_feature.velocity_heading();
   std::pair&lt;double, double&gt; obs_curr_pos = std::make_pair(
       obs_curr_feature.position().x(), obs_curr_feature.position().y());
-  for (std::size_t i = 0; i &lt; obstacle_ptr-&gt;history_size() &amp;&amp; i &lt; 10; ++i) {
+  for (std::size_t i = 0; i &lt; obstacle_ptr-&gt;history_size() &amp;&amp; i &lt; 20; ++i) {
     const Feature&amp; feature = obstacle_ptr-&gt;feature(i);
     if (!feature.IsInitialized()) {
       break;
@@ -245,22 +260,25 @@ bool JointlyPredictionPlanningEvaluator::ExtractObstacleHistory(
 }
 
 bool JointlyPredictionPlanningEvaluator::ExtractADCTrajectory(
-    const ADCTrajectoryContainer* adc_trajectory_container,
+    std::vector&lt;TrajectoryPoint&gt;* trajectory_points,
     Obstacle* obstacle_ptr,
     std::vector&lt;std::pair&lt;double, double&gt;&gt;* adc_traj_curr_pos) {
-  adc_traj_curr_pos-&gt;resize(10, {0.0, 0.0});
+  adc_traj_curr_pos-&gt;resize(30, {0.0, 0.0});
   const Feature&amp; obs_curr_feature = obstacle_ptr-&gt;latest_feature();
   double obs_curr_heading = obs_curr_feature.velocity_heading();
   std::pair&lt;double, double&gt; obs_curr_pos = std::make_pair(
       obs_curr_feature.position().x(), obs_curr_feature.position().y());
-  const auto&amp; adc_trajectory =
-      adc_trajectory_container-&gt;adc_trajectory();
-  size_t adc_traj_points_num = adc_trajectory.trajectory_point().size();
-  for (size_t i = 0; i &lt; adc_traj_points_num &amp;&amp; i &lt; 10; ++i) {
-    adc_traj_curr_pos-&gt;at(i) = WorldCoordToObjCoord(
-        std::make_pair(adc_trajectory.trajectory_point(i).path_point().x(),
-        adc_trajectory.trajectory_point(i).path_point().y()),
-        obs_curr_pos, obs_curr_heading);
+  size_t adc_traj_points_num = trajectory_points-&gt;size();
+  for (size_t i = 0; i &lt; 30; ++i) {
+    if (i &gt; adc_traj_points_num -1) {
+      adc_traj_curr_pos-&gt;at(i) =
+          adc_traj_curr_pos-&gt;at(adc_traj_points_num - 1);
+    } else {
+      adc_traj_curr_pos-&gt;at(i) = WorldCoordToObjCoord(
+          std::make_pair(trajectory_points-&gt;at(i).path_point().x(),
+          trajectory_points-&gt;at(i).path_point().y()),
+          obs_curr_pos, obs_curr_heading);
+    }
   }
   return true;
 }
@@ -279,9 +297,9 @@ void JointlyPredictionPlanningEvaluator::LoadModel() {
 
   // Fake intput for the first frame
   torch::Tensor img_tensor = torch::zeros({1, 3, 224, 224});
-  torch::Tensor obstacle_pos = torch::zeros({1, 10, 2});
-  torch::Tensor obstacle_pos_step = torch::zeros({1, 10, 2});
-  torch::Tensor adc_trajectory = torch::zeros({1, 10, 6});
+  torch::Tensor obstacle_pos = torch::zeros({1, 20, 2});
+  torch::Tensor obstacle_pos_step = torch::zeros({1, 20, 2});
+  torch::Tensor adc_trajectory = torch::zeros({1, 30, 6});
   std::vector&lt;torch::jit::IValue&gt; torch_inputs;
 
   auto X_value = c10::ivalue::Tuple::create(
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.h" new_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.h" added_lines="3" deleted_lines="1">
				<diff>@@ -29,6 +29,8 @@
 namespace apollo {
 namespace prediction {
 
+using apollo::common::TrajectoryPoint;
+
 class JointlyPredictionPlanningEvaluator : public Evaluator {
  public:
   /**
@@ -81,7 +83,7 @@ class JointlyPredictionPlanningEvaluator : public Evaluator {
    *        Feature container in a vector for receiving the obstacle history
    */
   bool ExtractADCTrajectory(
-      const ADCTrajectoryContainer* adc_trajectory_container,
+      std::vector&lt;TrajectoryPoint&gt;* trajectory_points,
       Obstacle* obstacle_ptr,
       std::vector&lt;std::pair&lt;double, double&gt;&gt;* acd_traj_curr_pos);
 
</diff>
			</file>
			<file old_path="modules\prediction\scenario\interaction_filter\interaction_filter.cc" new_path="modules\prediction\scenario\interaction_filter\interaction_filter.cc" added_lines="0" deleted_lines="2">
				<diff>@@ -33,8 +33,6 @@ namespace prediction {
 
 using apollo::common::Point3D;
 using apollo::common::adapter::AdapterConfig;
-using apollo::common::math::Box2d;
-using apollo::common::math::Vec2d;
 using apollo::hdmap::LaneInfo;
 using apollo::hdmap::OverlapInfo;
 using apollo::perception::PerceptionObstacle;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="0a7a1f127885bfccce2c387b98aa3443b679b707" author="Chang Songhong">
		<msg>Canbus: bug fix (#13760)</msg>
		<modified_files>
			<file old_path="modules\canbus\vehicle\vehicle_controller.cc" new_path="modules\canbus\vehicle\vehicle_controller.cc" added_lines="0" deleted_lines="1">
				<diff>@@ -120,7 +120,6 @@ ErrorCode VehicleController::Update(const ControlCommand &amp;control_command) {
     auto error_code = SetDrivingMode(mode);
     if (error_code != ErrorCode::OK) {
       AERROR &lt;&lt; "Failed to set driving mode.";
-      return error_code;
     }
   }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9bb01ddb14d705230de9497feea206f9ac5f06ae" author="liuxu21">
		<msg>Prediction: add ADC trajectory timestamp to feature.proto

Change-Id: I24f350730b1cf3b10c1209316ca146125e87e75b</msg>
		<modified_files>
			<file old_path="modules\prediction\common\message_process.cc" new_path="modules\prediction\common\message_process.cc" added_lines="6" deleted_lines="2">
				<diff>@@ -214,10 +214,14 @@ void MessageProcess::OnPerception(
       }
       // TODO(all): the adc trajectory should be part of features for learning
       //            algorithms rather than part of the feature.proto
-      /*
       *obstacle_ptr-&gt;mutable_latest_feature()-&gt;mutable_adc_trajectory_point() =
           ptr_ego_trajectory_container-&gt;adc_trajectory().trajectory_point();
-      */
+
+      // adc trajectory timestamp
+      obstacle_ptr-&gt;mutable_latest_feature()-&gt;set_adc_timestamp(
+          ptr_ego_trajectory_container-&gt;adc_trajectory()
+          .header().timestamp_sec());
+
       FeatureOutput::InsertFeatureProto(obstacle_ptr-&gt;latest_feature());
       ADEBUG &lt;&lt; "Insert feature into feature output";
     }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a1d53219f17e46a9c814580a7acd80de5d812413" author="changsh726">
		<msg>Transform: make timeout work in simulation mode</msg>
		<modified_files>
			<file old_path="modules\transform\buffer.cc" new_path="modules\transform\buffer.cc" added_lines="14" deleted_lines="2">
				<diff>@@ -17,6 +17,7 @@
 #include "modules/transform/buffer.h"
 
 #include "absl/strings/str_cat.h"
+
 #include "cyber/cyber.h"
 #include "cyber/time/clock.h"
 #include "modules/common/adapters/adapter_gflags.h"
@@ -26,6 +27,7 @@ using Clock = ::apollo::cyber::Clock;
 
 namespace {
 constexpr float kSecondToNanoFactor = 1e9f;
+constexpr uint64_t kMilliToNanoFactor = 1e6;
 }  // namespace
 
 namespace apollo {
@@ -205,8 +207,13 @@ bool Buffer::canTransform(const std::string&amp; target_frame,
     if (retval) {
       return true;
     } else {
+      const int sleep_time_ms = 3;
       AWARN &lt;&lt; "BufferCore::canTransform failed: " &lt;&lt; *errstr;
-      std::this_thread::sleep_for(std::chrono::milliseconds(3));
+      std::this_thread::sleep_for(std::chrono::milliseconds(sleep_time_ms));
+      if (!cyber::common::GlobalData::Instance()-&gt;IsRealityMode()) {
+        Clock::SetNow(Time(Clock::Now().ToNanosecond() +
+                           sleep_time_ms * kMilliToNanoFactor));
+      }
     }
   }
   *errstr = *errstr + ":timeout";
@@ -233,8 +240,13 @@ bool Buffer::canTransform(const std::string&amp; target_frame,
     if (retval) {
       return true;
     } else {
+      const int sleep_time_ms = 3;
       AWARN &lt;&lt; "BufferCore::canTransform failed: " &lt;&lt; *errstr;
-      std::this_thread::sleep_for(std::chrono::milliseconds(3));
+      std::this_thread::sleep_for(std::chrono::milliseconds(sleep_time_ms));
+      if (!cyber::common::GlobalData::Instance()-&gt;IsRealityMode()) {
+        Clock::SetNow(Time(Clock::Now().ToNanosecond() +
+                           sleep_time_ms * kMilliToNanoFactor));
+      }
     }
   }
   *errstr = *errstr + ":timeout";
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ff0fba9e34c7aa35728630dc6c42fc4420d570bf" author="fuyiqun">
		<msg>prediction: add p_id generation

Change-Id: I6158f09c548ef57ca7ef94be6a95434034a78ffa</msg>
		<modified_files>
			<file old_path="modules\prediction\pipeline\vector_net.cc" new_path="modules\prediction\pipeline\vector_net.cc" added_lines="22" deleted_lines="4">
				<diff>@@ -15,6 +15,7 @@
  *****************************************************************************/
 #include "modules/prediction/pipeline/vector_net.h"
 
+#include &lt;limits&gt;
 #include &lt;utility&gt;
 
 #include "cyber/common/file.h"
@@ -25,11 +26,11 @@ namespace apollo {
 namespace prediction {
 bool VectorNet::query(const double obstacle_x, const double obstacle_y,
                       const double obstacle_phi,
-                      FeatureVector* const feature_ptr) {
+                      FeatureVector* const feature_ptr, PidVector* p_id_ptr) {
   CHECK_NOTNULL(feature_ptr);
   count_ = 0;
   apollo::hdmap::HDMapUtil::ReloadMaps();
-  GetRoads(obstacle_x, obstacle_y, obstacle_phi, feature_ptr);
+  GetRoads(obstacle_x, obstacle_y, obstacle_phi, feature_ptr, p_id_ptr);
 
   return true;
 }
@@ -37,15 +38,20 @@ bool VectorNet::query(const double obstacle_x, const double obstacle_y,
 bool VectorNet::offline_query(const double obstacle_x, const double obstacle_y,
                               const double obstacle_phi) {
   FeatureVector offline_feature;
-  query(obstacle_x, obstacle_y, obstacle_phi, &amp;offline_feature);
+  PidVector p_id;
+  query(obstacle_x, obstacle_y, obstacle_phi, &amp;offline_feature, &amp;p_id);
 
   apollo::prediction::VectorNetFeature vector_net_pb_;
   vector_net_pb_.mutable_car_position()-&gt;set_x(obstacle_x);
   vector_net_pb_.mutable_car_position()-&gt;set_y(obstacle_y);
   vector_net_pb_.mutable_car_position()-&gt;set_phi(obstacle_phi);
 
+  size_t i = 0;
   for (const auto&amp; polyline : offline_feature) {
     auto* polyline_pb = vector_net_pb_.add_polyline();
+    polyline_pb-&gt;set_p_id_x(p_id[i][0]);
+    polyline_pb-&gt;set_p_id_y(p_id[i][1]);
+    i++;
     for (const auto&amp; vector : polyline) {
       auto* vector_pb = polyline_pb-&gt;add_vector();
       for (const auto&amp; element : vector) {
@@ -61,7 +67,8 @@ bool VectorNet::offline_query(const double obstacle_x, const double obstacle_y,
 
 void VectorNet::GetRoads(const double base_x, const double base_y,
                          const double obstacle_phi,
-                         FeatureVector* const feature_ptr) {
+                         FeatureVector* const feature_ptr,
+                         PidVector* p_id_ptr) {
   common::PointENU center_point =
       common::util::PointFactory::ToPointENU(base_x, base_y);
   std::vector&lt;apollo::hdmap::RoadInfoConstPtr&gt; roads;
@@ -72,6 +79,9 @@ void VectorNet::GetRoads(const double base_x, const double base_y,
     for (const auto&amp; section : road-&gt;road().section()) {
       for (const auto&amp; edge : section.boundary().outer_polygon().edge()) {
         std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
+        std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
+                                     std::numeric_limits&lt;float&gt;::max()};
+
         for (const auto&amp; segment : edge.curve().segment()) {
           auto last_point = segment.line_segment().point(0);
           auto last_point_after_rotate = common::math::RotateVector2d(
@@ -79,6 +89,13 @@ void VectorNet::GetRoads(const double base_x, const double base_y,
               M_PI_2 - obstacle_phi);
           size_t size = segment.line_segment().point().size();
           for (size_t i = 1; i &lt; size; ++i) {
+            if (abs(one_p_id[0]) &gt; abs(last_point_after_rotate.x())) {
+              one_p_id[0] = last_point_after_rotate.x();
+            }
+            if (abs(one_p_id[1]) &gt; abs(last_point_after_rotate.y())) {
+              one_p_id[1] = last_point_after_rotate.y();
+            }
+
             // TODO(Yiqun):
             // check the segments are discretized with the same interval
             std::vector&lt;double&gt; one_vector;
@@ -102,6 +119,7 @@ void VectorNet::GetRoads(const double base_x, const double base_y,
           }
         }
         feature_ptr-&gt;push_back(std::move(one_polyline));
+        p_id_ptr-&gt;push_back(std::move(one_p_id));
         ++count_;
       }
     }
</diff>
			</file>
			<file old_path="modules\prediction\pipeline\vector_net.h" new_path="modules\prediction\pipeline\vector_net.h" added_lines="5" deleted_lines="2">
				<diff>@@ -25,6 +25,7 @@ namespace apollo {
 namespace prediction {
 
 using FeatureVector = std::vector&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt;;
+using PidVector = std::vector&lt;std::vector&lt;double&gt;&gt;;
 
 class VectorNet {
  public:
@@ -33,14 +34,16 @@ class VectorNet {
   ~VectorNet() = default;
 
   bool query(const double obstacle_x, const double obstacle_y,
-             const double obstacle_phi, FeatureVector* const feature_ptr);
+             const double obstacle_phi, FeatureVector* const feature_ptr,
+             PidVector* p_id_ptr);
 
   bool offline_query(const double obstacle_x, const double obstacle_y,
                      const double obstacle_phi);
 
  private:
   void GetRoads(const double base_x, const double base_y,
-                const double obstacle_phi, FeatureVector* const feature_ptr);
+                const double obstacle_phi, FeatureVector* const feature_ptr,
+                PidVector* p_id_ptr);
   int count_ = 0;
 };
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1317da1e06eb7b602433e89051f793bc37faf737" author="fuyiqun">
		<msg>prediction: add more map infor for Vectornet

Change-Id: I83e15b336c81d83bd1db0756edf02098b3426513</msg>
		<modified_files>
			<file old_path="modules\prediction\pipeline\vector_net.cc" new_path="modules\prediction\pipeline\vector_net.cc" added_lines="170" deleted_lines="44">
				<diff>@@ -16,22 +16,85 @@
 #include "modules/prediction/pipeline/vector_net.h"
 
 #include &lt;limits&gt;
+#include &lt;map&gt;
 #include &lt;utility&gt;
 
 #include "cyber/common/file.h"
-#include "modules/common/util/point_factory.h"
 #include "modules/map/hdmap/hdmap_util.h"
 
 namespace apollo {
 namespace prediction {
-bool VectorNet::query(const double obstacle_x, const double obstacle_y,
+namespace {
+enum ATTRIBUTE_TYPE {
+  ROAD,
+  LANE,
+  JUNCTION,
+  CROSSWALK,
+};
+
+std::map&lt;ATTRIBUTE_TYPE, std::vector&lt;double&gt;&gt; attribute_map{
+    {ROAD, {1, 0, 0, 0, 0}},
+    {LANE, {0, 1, 0, 0, 0}},
+    {JUNCTION, {0, 0, 1, 0, 0}},
+    {CROSSWALK, {0, 0, 0, 1, 0}}};
+
+template &lt;typename Points&gt;
+void GetOnePolyline(const Points&amp; points, const common::PointENU&amp; center_point,
+                    const double obstacle_phi, ATTRIBUTE_TYPE attr_type,
+                    const int count,
+                    std::vector&lt;std::vector&lt;double&gt;&gt;* const one_polyline,
+                    std::vector&lt;double&gt;* const one_p_id) {
+  size_t size = points.size();
+  if (size &lt; 2) return;
+
+  const common::PointENU&amp; last_point = points.at(0);
+  auto last_point_after_rotate = common::math::RotateVector2d(
+      {last_point.x() - center_point.x(), last_point.y() - center_point.y()},
+      M_PI_2 - obstacle_phi);
+  for (size_t i = 1; i &lt; size; ++i) {
+    if (std::fabs(one_p_id-&gt;at(0)) &gt; std::fabs(last_point_after_rotate.x())) {
+      one_p_id-&gt;at(0) = last_point_after_rotate.x();
+    }
+    if (std::fabs(one_p_id-&gt;at(1)) &gt; std::fabs(last_point_after_rotate.y())) {
+      one_p_id-&gt;at(1) = last_point_after_rotate.y();
+    }
+
+    // TODO(Yiqun):
+    // check the segments are discretized with the same interval
+    std::vector&lt;double&gt; one_vector;
+
+    // d_s, d_e
+    one_vector.push_back(last_point_after_rotate.x());
+    one_vector.push_back(last_point_after_rotate.y());
+    auto&amp; point = points.at(i);
+    Eigen::Vector2d point_after_rotate = common::math::RotateVector2d(
+        {point.x() - center_point.x(), point.y() - center_point.y()},
+        M_PI_2 - obstacle_phi);
+    one_vector.push_back(point_after_rotate.x());
+    one_vector.push_back(point_after_rotate.y());
+    last_point_after_rotate = std::move(point_after_rotate);
+
+    std::vector&lt;double&gt;&amp; attr = attribute_map[attr_type];
+    // attribute
+    one_vector.insert(one_vector.end(), attr.begin(), attr.end());
+
+    one_vector.push_back(count);
+    one_polyline-&gt;push_back(std::move(one_vector));
+  }
+}
+}  // namespace
+
+bool VectorNet::query(const common::PointENU&amp; center_point,
                       const double obstacle_phi,
-                      FeatureVector* const feature_ptr, PidVector* p_id_ptr) {
+                      FeatureVector* const feature_ptr,
+                      PidVector* const p_id_ptr) {
   CHECK_NOTNULL(feature_ptr);
   count_ = 0;
   apollo::hdmap::HDMapUtil::ReloadMaps();
-  GetRoads(obstacle_x, obstacle_y, obstacle_phi, feature_ptr, p_id_ptr);
-
+  GetRoads(center_point, obstacle_phi, feature_ptr, p_id_ptr);
+  GetLanes(center_point, obstacle_phi, feature_ptr, p_id_ptr);
+  GetJunctions(center_point, obstacle_phi, feature_ptr, p_id_ptr);
+  GetCrosswalks(center_point, obstacle_phi, feature_ptr, p_id_ptr);
   return true;
 }
 
@@ -39,7 +102,9 @@ bool VectorNet::offline_query(const double obstacle_x, const double obstacle_y,
                               const double obstacle_phi) {
   FeatureVector offline_feature;
   PidVector p_id;
-  query(obstacle_x, obstacle_y, obstacle_phi, &amp;offline_feature, &amp;p_id);
+  common::PointENU center_point =
+      common::util::PointFactory::ToPointENU(obstacle_x, obstacle_y);
+  query(center_point, obstacle_phi, &amp;offline_feature, &amp;p_id);
 
   apollo::prediction::VectorNetFeature vector_net_pb_;
   vector_net_pb_.mutable_car_position()-&gt;set_x(obstacle_x);
@@ -65,12 +130,10 @@ bool VectorNet::offline_query(const double obstacle_x, const double obstacle_y,
   return true;
 }
 
-void VectorNet::GetRoads(const double base_x, const double base_y,
+void VectorNet::GetRoads(const common::PointENU&amp; center_point,
                          const double obstacle_phi,
                          FeatureVector* const feature_ptr,
-                         PidVector* p_id_ptr) {
-  common::PointENU center_point =
-      common::util::PointFactory::ToPointENU(base_x, base_y);
+                         PidVector* const p_id_ptr) {
   std::vector&lt;apollo::hdmap::RoadInfoConstPtr&gt; roads;
   apollo::hdmap::HDMapUtil::BaseMap().GetRoads(center_point,
                                                FLAGS_road_distance, &amp;roads);
@@ -83,40 +146,8 @@ void VectorNet::GetRoads(const double base_x, const double base_y,
                                      std::numeric_limits&lt;float&gt;::max()};
 
         for (const auto&amp; segment : edge.curve().segment()) {
-          auto last_point = segment.line_segment().point(0);
-          auto last_point_after_rotate = common::math::RotateVector2d(
-              {last_point.x() - base_x, last_point.y() - base_y},
-              M_PI_2 - obstacle_phi);
-          size_t size = segment.line_segment().point().size();
-          for (size_t i = 1; i &lt; size; ++i) {
-            if (abs(one_p_id[0]) &gt; abs(last_point_after_rotate.x())) {
-              one_p_id[0] = last_point_after_rotate.x();
-            }
-            if (abs(one_p_id[1]) &gt; abs(last_point_after_rotate.y())) {
-              one_p_id[1] = last_point_after_rotate.y();
-            }
-
-            // TODO(Yiqun):
-            // check the segments are discretized with the same interval
-            std::vector&lt;double&gt; one_vector;
-
-            // d_s, d_e
-            one_vector.push_back(last_point_after_rotate.x());
-            one_vector.push_back(last_point_after_rotate.y());
-            auto point = segment.line_segment().point(i);
-            Eigen::Vector2d point_after_rotate = common::math::RotateVector2d(
-                {point.x() - base_x, point.y() - base_y},
-                M_PI_2 - obstacle_phi);
-            one_vector.push_back(point_after_rotate.x());
-            one_vector.push_back(point_after_rotate.y());
-            last_point_after_rotate = std::move(point_after_rotate);
-
-            // attribute
-            one_vector.insert(one_vector.end(), {1, 0, 0, 0});
-
-            one_vector.push_back(count_);
-            one_polyline.push_back(std::move(one_vector));
-          }
+          GetOnePolyline(segment.line_segment().point(), center_point,
+                         obstacle_phi, ROAD, count_, &amp;one_polyline, &amp;one_p_id);
         }
         feature_ptr-&gt;push_back(std::move(one_polyline));
         p_id_ptr-&gt;push_back(std::move(one_p_id));
@@ -125,5 +156,100 @@ void VectorNet::GetRoads(const double base_x, const double base_y,
     }
   }
 }
+
+void VectorNet::GetLanes(const common::PointENU&amp; center_point,
+                         const double obstacle_phi,
+                         FeatureVector* const feature_ptr,
+                         PidVector* const p_id_ptr) {
+  std::vector&lt;apollo::hdmap::LaneInfoConstPtr&gt; lanes;
+  apollo::hdmap::HDMapUtil::BaseMap().GetLanes(center_point,
+                                               FLAGS_road_distance, &amp;lanes);
+  for (const auto&amp; lane : lanes) {
+    // Get lane_central first
+    for (const auto&amp; segment : lane-&gt;lane().central_curve().segment()) {
+      std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
+      std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
+                                   std::numeric_limits&lt;float&gt;::max()};
+
+      GetOnePolyline(segment.line_segment().point(), center_point, obstacle_phi,
+                     LANE, count_, &amp;one_polyline, &amp;one_p_id);
+      feature_ptr-&gt;push_back(std::move(one_polyline));
+      p_id_ptr-&gt;push_back(std::move(one_p_id));
+      ++count_;
+    }
+
+    // Not drawing boundary for virtual city_driving lane
+    if (lane-&gt;lane().type() == 2 &amp;&amp; lane-&gt;lane().left_boundary().virtual_() &amp;&amp;
+        lane-&gt;lane().right_boundary().virtual_()) {
+      continue;
+    }
+    // Draw lane's left_boundary
+    for (const auto&amp; segment : lane-&gt;lane().left_boundary().curve().segment()) {
+      std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
+      std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
+                                   std::numeric_limits&lt;float&gt;::max()};
+
+      GetOnePolyline(segment.line_segment().point(), center_point, obstacle_phi,
+                     LANE, count_, &amp;one_polyline, &amp;one_p_id);
+      feature_ptr-&gt;push_back(std::move(one_polyline));
+      p_id_ptr-&gt;push_back(std::move(one_p_id));
+      ++count_;
+    }
+
+    // Draw lane's right_boundary
+    for (const auto&amp; segment :
+         lane-&gt;lane().right_boundary().curve().segment()) {
+      std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
+      std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
+                                   std::numeric_limits&lt;float&gt;::max()};
+
+      GetOnePolyline(segment.line_segment().point(), center_point, obstacle_phi,
+                     LANE, count_, &amp;one_polyline, &amp;one_p_id);
+      feature_ptr-&gt;push_back(std::move(one_polyline));
+      p_id_ptr-&gt;push_back(std::move(one_p_id));
+      ++count_;
+    }
+  }
+}
+
+void VectorNet::GetJunctions(const common::PointENU&amp; center_point,
+                             const double obstacle_phi,
+                             FeatureVector* const feature_ptr,
+                             PidVector* const p_id_ptr) {
+  std::vector&lt;apollo::hdmap::JunctionInfoConstPtr&gt; junctions;
+  apollo::hdmap::HDMapUtil::BaseMap().GetJunctions(
+      center_point, FLAGS_road_distance, &amp;junctions);
+  for (const auto&amp; junction : junctions) {
+    std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
+    std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
+                                 std::numeric_limits&lt;float&gt;::max()};
+    GetOnePolyline(junction-&gt;junction().polygon().point(), center_point,
+                   obstacle_phi, JUNCTION, count_, &amp;one_polyline, &amp;one_p_id);
+
+    feature_ptr-&gt;push_back(std::move(one_polyline));
+    p_id_ptr-&gt;push_back(std::move(one_p_id));
+    ++count_;
+  }
+}
+
+void VectorNet::GetCrosswalks(const common::PointENU&amp; center_point,
+                              const double obstacle_phi,
+                              FeatureVector* const feature_ptr,
+                              PidVector* const p_id_ptr) {
+  std::vector&lt;apollo::hdmap::CrosswalkInfoConstPtr&gt; crosswalks;
+  apollo::hdmap::HDMapUtil::BaseMap().GetCrosswalks(
+      center_point, FLAGS_road_distance, &amp;crosswalks);
+  for (const auto&amp; crosswalk : crosswalks) {
+    std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
+    std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
+                                 std::numeric_limits&lt;float&gt;::max()};
+    GetOnePolyline(crosswalk-&gt;crosswalk().polygon().point(), center_point,
+                   obstacle_phi, CROSSWALK, count_, &amp;one_polyline, &amp;one_p_id);
+
+    feature_ptr-&gt;push_back(std::move(one_polyline));
+    p_id_ptr-&gt;push_back(std::move(one_p_id));
+    ++count_;
+  }
+}
 }  // namespace prediction
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\prediction\pipeline\vector_net.h" new_path="modules\prediction\pipeline\vector_net.h" added_lines="18" deleted_lines="6">
				<diff>@@ -18,6 +18,7 @@
 
 #include &lt;vector&gt;
 
+#include "modules/common/util/point_factory.h"
 #include "modules/prediction/common/prediction_system_gflags.h"
 #include "modules/prediction/proto/vector_net.pb.h"
 
@@ -33,17 +34,28 @@ class VectorNet {
 
   ~VectorNet() = default;
 
-  bool query(const double obstacle_x, const double obstacle_y,
-             const double obstacle_phi, FeatureVector* const feature_ptr,
-             PidVector* p_id_ptr);
+  bool query(const common::PointENU&amp; center_point, const double obstacle_phi,
+             FeatureVector* const feature_ptr, PidVector* const p_id_ptr);
 
   bool offline_query(const double obstacle_x, const double obstacle_y,
                      const double obstacle_phi);
 
  private:
-  void GetRoads(const double base_x, const double base_y,
-                const double obstacle_phi, FeatureVector* const feature_ptr,
-                PidVector* p_id_ptr);
+  void GetRoads(const common::PointENU&amp; center_point,
+                const double obstacle_phi,
+                FeatureVector* const feature_ptr, PidVector* const p_id_ptr);
+  void GetLanes(const common::PointENU&amp; center_point,
+                           const double obstacle_phi,
+                           FeatureVector* const feature_ptr,
+                           PidVector* const p_id_ptr);
+  void GetJunctions(const common::PointENU&amp; center_point,
+                    const double obstacle_phi,
+                    FeatureVector* const feature_ptr,
+                    PidVector* const p_id_ptr);
+  void GetCrosswalks(const common::PointENU&amp; center_point,
+                    const double obstacle_phi,
+                    FeatureVector* const feature_ptr,
+                    PidVector* const p_id_ptr);
   int count_ = 0;
 };
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9999d285d9b5750545c4e37ebea94133d26187be" author="abel">
		<msg>dreamview: fix bug at sim control (#13727)

* dreamview: fix bug at sim control

InitStartPoint() can handle  using localization point and using dummy point.if localization is not empty, program will jump here.

* Update sim_control.h

* Update sim_control_interface.h

* Update sim_control.cc</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\sim_control\sim_control.cc" new_path="modules\dreamview\backend\sim_control\sim_control.cc" added_lines="3" deleted_lines="4">
				<diff>@@ -107,9 +107,9 @@ void SimControl::InitTimerAndIO() {
       false));
 }
 
-void SimControl::Init(bool set_start_point, double start_velocity,
+void SimControl::Init(double start_velocity,
                       double start_acceleration) {
-  if (set_start_point &amp;&amp; !FLAGS_use_navigation_mode) {
+  if (!FLAGS_use_navigation_mode) {
     InitStartPoint(start_velocity, start_acceleration);
   }
 }
@@ -252,8 +252,7 @@ void SimControl::Start() {
     // When localization is already available, we do not need to
     // reset/override the start point.
     localization_reader_-&gt;Observe();
-    Init(localization_reader_-&gt;Empty(),
-         next_point_.has_v() ? next_point_.v() : 0.0,
+    Init(next_point_.has_v() ? next_point_.v() : 0.0,
          next_point_.has_a() ? next_point_.a() : 0.0);
 
     InternalReset();
</diff>
			</file>
			<file old_path="modules\dreamview\backend\sim_control\sim_control.h" new_path="modules\dreamview\backend\sim_control\sim_control.h" added_lines="1" deleted_lines="1">
				<diff>@@ -62,7 +62,7 @@ class SimControl : SimControlInterface {
    * @brief setup callbacks and timer
    * @param set_start_point initialize localization.
    */
-  void Init(bool set_start_point, double start_velocity = 0.0,
+  void Init(double start_velocity = 0.0,
             double start_acceleration = 0.0) override;
 
   /**
</diff>
			</file>
			<file old_path="modules\dreamview\backend\sim_control\sim_control_interface.h" new_path="modules\dreamview\backend\sim_control\sim_control_interface.h" added_lines="1" deleted_lines="1">
				<diff>@@ -38,7 +38,7 @@ class SimControlInterface {
   /**
    * @brief Initialization.
    */
-  virtual void Init(bool set_start_point, double start_velocity = 0.0,
+  virtual void Init(double start_velocity = 0.0,
                     double start_acceleration = 0.0) = 0;
 
   /**
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="49647ab0f8ff0e8349f7099b8487f5245a10e293" author="SeasoulChris">
		<msg>Perception: add gflag to make lidar height file could be specified (#13745)

* Revert "Perception: make lidar height file could be specified (#13226)"

This reverts commit 210996789bd564aa5fb2c223d5c976dcf1455dfa.

* add gflag to make lidar height could be specified</msg>
		<modified_files>
			<file old_path="modules\perception\common\perception_gflags.cc" new_path="modules\perception\common\perception_gflags.cc" added_lines="4" deleted_lines="0">
				<diff>@@ -117,5 +117,9 @@ DEFINE_string(torch_detector_model,
               "/apollo/modules/perception/camera"
               "/lib/obstacle/detector/yolov4/model/yolov4.pt",
               "The torch model file for emergency detection");
+
+// lidar sensor name
+DEFINE_string(lidar_sensor_name, "velodyne128",
+              "lidar sensor name");
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\common\perception_gflags.h" new_path="modules\perception\common\perception_gflags.h" added_lines="3" deleted_lines="0">
				<diff>@@ -67,5 +67,8 @@ DECLARE_int32(num_classes);
 
 // emergency detection libtorch
 DECLARE_string(torch_detector_model);
+
+// lidar sensor name
+DECLARE_string(lidar_sensor_name);
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_camera_detection_component.cc" new_path="modules\perception\onboard\component\fusion_camera_detection_component.cc" added_lines="37" deleted_lines="43">
				<diff>@@ -65,6 +65,39 @@ static int GetGpuId(const camera::CameraPerceptionInitOptions &amp;options) {
   return perception_param.gpu_id();
 }
 
+bool SetCameraHeight(const std::string &amp;sensor_name,
+                     const std::string &amp;params_dir,
+                     const std::string &amp;lidar_sensor_name,
+                     float default_camera_height,
+                     float *camera_height) {
+  float base_h = default_camera_height;
+  float camera_offset = 0.0f;
+  try {
+    YAML::Node lidar_height =
+        YAML::LoadFile(
+          params_dir + "/" + lidar_sensor_name + "_height.yaml");
+    base_h = lidar_height["vehicle"]["parameters"]["height"].as&lt;float&gt;();
+    AINFO &lt;&lt; base_h;
+    YAML::Node camera_ex =
+        YAML::LoadFile(params_dir + "/" + sensor_name + "_extrinsics.yaml");
+    camera_offset = camera_ex["transform"]["translation"]["z"].as&lt;float&gt;();
+    AINFO &lt;&lt; camera_offset;
+    *camera_height = base_h + camera_offset;
+  } catch (YAML::InvalidNode &amp;in) {
+    AERROR &lt;&lt; "load camera extrisic file error, YAML::InvalidNode exception";
+    return false;
+  } catch (YAML::TypedBadConversion&lt;float&gt; &amp;bc) {
+    AERROR &lt;&lt; "load camera extrisic file error, "
+           &lt;&lt; "YAML::TypedBadConversion exception";
+    return false;
+  } catch (YAML::Exception &amp;e) {
+    AERROR &lt;&lt; "load camera extrisic file "
+           &lt;&lt; " error, YAML exception:" &lt;&lt; e.what();
+    return false;
+  }
+  return true;
+}
+
 // @description: load camera extrinsics from yaml file
 bool LoadExtrinsics(const std::string &amp;yaml_file,
                     Eigen::Matrix4d *camera_extrinsic) {
@@ -202,9 +235,9 @@ bool FusionCameraDetectionComponent::Init() {
   // load in lidar to imu extrinsic
   Eigen::Matrix4d ex_lidar2imu;
   LoadExtrinsics(FLAGS_obs_sensor_intrinsic_path + "/" +
-                     "velodyne128_novatel_extrinsics.yaml",
+                     FLAGS_lidar_sensor_name + "_novatel_extrinsics.yaml",
                  &amp;ex_lidar2imu);
-  AINFO &lt;&lt; "velodyne128_novatel_extrinsics: " &lt;&lt; ex_lidar2imu;
+  AINFO &lt;&lt; FLAGS_lidar_sensor_name + "_novatel_extrinsics.yaml" &lt;&lt; ex_lidar2imu;
 
   ACHECK(visualize_.Init_all_info_single_camera(
       camera_names_, visual_camera_, intrinsic_map_, extrinsic_map_,
@@ -522,7 +555,8 @@ int FusionCameraDetectionComponent::InitCameraFrames() {
   for (const auto &amp;camera_name : camera_names_) {
     float height = 0.0f;
     SetCameraHeight(camera_name, FLAGS_obs_sensor_intrinsic_path,
-                    default_camera_height_, &amp;height);
+                    FLAGS_lidar_sensor_name, default_camera_height_,
+                    &amp;height);
     camera_height_map_[camera_name] = height;
   }
 
@@ -1111,46 +1145,6 @@ int FusionCameraDetectionComponent::MakeCameraDebugMsg(
   return cyber::SUCC;
 }
 
-bool FusionCameraDetectionComponent::SetCameraHeight(
-     const std::string &amp;sensor_name,
-     const std::string &amp;params_dir, float default_camera_height,
-     float *camera_height) {
-  float base_height = default_camera_height;
-  float camera_offset = 0.0f;
-
-  apollo::perception::onboard::FusionCameraDetection
-  fusion_camera_detection_param;
-  if (!GetProtoConfig(&amp;fusion_camera_detection_param)) {
-    AINFO &lt;&lt; "load fusion camera detection component proto param failed";
-    return false;
-  }
-  std::string lidar_type =
-      fusion_camera_detection_param.lidar_type();
-  try {
-    YAML::Node lidar_height =
-        YAML::LoadFile(params_dir + "/" + lidar_type + "_height.yaml");
-    base_height = lidar_height["vehicle"]["parameters"]["height"].as&lt;float&gt;();
-    AINFO &lt;&lt; base_height;
-    YAML::Node camera_ex =
-        YAML::LoadFile(params_dir + "/" + sensor_name + "_extrinsics.yaml");
-    camera_offset = camera_ex["transform"]["translation"]["z"].as&lt;float&gt;();
-    AINFO &lt;&lt; camera_offset;
-    *camera_height = base_height + camera_offset;
-  } catch (YAML::InvalidNode &amp;in) {
-    AERROR &lt;&lt; "load camera extrisic file error, YAML::InvalidNode exception";
-    return false;
-  } catch (YAML::TypedBadConversion&lt;float&gt; &amp;bc) {
-    AERROR &lt;&lt; "load camera extrisic file error, "
-           &lt;&lt; "YAML::TypedBadConversion exception";
-    return false;
-  } catch (YAML::Exception &amp;e) {
-    AERROR &lt;&lt; "load camera extrisic file "
-           &lt;&lt; " error, YAML exception:" &lt;&lt; e.what();
-    return false;
-  }
-  return true;
-}
-
 }  // namespace onboard
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_camera_detection_component.h" new_path="modules\perception\onboard\component\fusion_camera_detection_component.h" added_lines="0" deleted_lines="4">
				<diff>@@ -76,10 +76,6 @@ class FusionCameraDetectionComponent : public apollo::cyber::Component&lt;&gt; {
   int InitMotionService();
   void SetCameraHeightAndPitch();
   void OnMotionService(const MotionServiceMsgType&amp; message);
-  bool SetCameraHeight(
-       const std::string &amp;sensor_name,
-       const std::string &amp;params_dir, float default_camera_height,
-       float *camera_height);
 
   int InternalProc(
       const std::shared_ptr&lt;apollo::drivers::Image const&gt;&amp; in_message,
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\lane_detection_component.cc" new_path="modules\perception\onboard\component\lane_detection_component.cc" added_lines="7" deleted_lines="4">
				<diff>@@ -73,12 +73,13 @@ static int GetGpuId(const camera::CameraPerceptionInitOptions &amp;options) {
 
 static bool SetCameraHeight(const std::string &amp;sensor_name,
                             const std::string &amp;params_dir,
+                            const std::string &amp;lidar_sensor_name,
                             float default_camera_height, float *camera_height) {
   float base_h = default_camera_height;
   float camera_offset = 0.0f;
   try {
     YAML::Node lidar_height =
-        YAML::LoadFile(params_dir + "/" + "velodyne128_height.yaml");
+        YAML::LoadFile(params_dir + "/" + lidar_sensor_name + "_height.yaml");
     base_h = lidar_height["vehicle"]["parameters"]["height"].as&lt;float&gt;();
     AINFO &lt;&lt; base_h;
     YAML::Node camera_ex =
@@ -208,9 +209,10 @@ bool LaneDetectionComponent::Init() {
   // load in lidar to imu extrinsic
   Eigen::Matrix4d ex_lidar2imu;
   LoadExtrinsics(FLAGS_obs_sensor_intrinsic_path + "/" +
-                     "velodyne128_novatel_extrinsics.yaml",
+                     FLAGS_lidar_sensor_name + "_novatel_extrinsics.yaml",
                  &amp;ex_lidar2imu);
-  AINFO &lt;&lt; "velodyne128_novatel_extrinsics: " &lt;&lt; ex_lidar2imu;
+  AINFO &lt;&lt; FLAGS_lidar_sensor_name + "_novatel_extrinsics.yaml: "
+        &lt;&lt; ex_lidar2imu;
 
   ACHECK(visualize_.Init_all_info_single_camera(
       camera_names_, visual_camera_, intrinsic_map_, extrinsic_map_,
@@ -511,7 +513,8 @@ int LaneDetectionComponent::InitCameraFrames() {
   for (const auto &amp;camera_name : camera_names_) {
     float height = 0.0f;
     SetCameraHeight(camera_name, FLAGS_obs_sensor_intrinsic_path,
-                    default_camera_height_, &amp;height);
+                    FLAGS_lidar_sensor_name, default_camera_height_,
+                    &amp;height);
     camera_height_map_[camera_name] = height;
   }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a1a7774d964dbb3e78bd1a8023f0dae501ffbac8" author="daohu527">
		<msg>control: delete redundant judgment conditions in set_gear_location</msg>
		<modified_files>
			<file old_path="modules\control\controller\lon_controller.cc" new_path="modules\control\controller\lon_controller.cc" added_lines="0" deleted_lines="1">
				<diff>@@ -359,7 +359,6 @@ Status LonController::ComputeControlCommand(
 
   if (std::fabs(injector_-&gt;vehicle_state()-&gt;linear_velocity()) &lt;=
           vehicle_param_.max_abs_speed_when_stopped() ||
-      chassis-&gt;gear_location() == trajectory_message_-&gt;gear() ||
       chassis-&gt;gear_location() == canbus::Chassis::GEAR_NEUTRAL) {
     cmd-&gt;set_gear_location(trajectory_message_-&gt;gear());
   } else {
</diff>
			</file>
			<file old_path="modules\control\controller\mpc_controller.cc" new_path="modules\control\controller\mpc_controller.cc" added_lines="0" deleted_lines="1">
				<diff>@@ -515,7 +515,6 @@ Status MPCController::ComputeControlCommand(
 
   if (std::fabs(vehicle_state-&gt;linear_velocity()) &lt;=
           vehicle_param_.max_abs_speed_when_stopped() ||
-      chassis-&gt;gear_location() == planning_published_trajectory-&gt;gear() ||
       chassis-&gt;gear_location() == canbus::Chassis::GEAR_NEUTRAL) {
     cmd-&gt;set_gear_location(planning_published_trajectory-&gt;gear());
   } else {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7e3d191676caf7a45520a2e451546cc6230bdf07" author="lijin18">
		<msg>Dreamview: add dead junction routing task for task manager</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\map\map_service.cc" new_path="modules\dreamview\backend\map\map_service.cc" added_lines="17" deleted_lines="0">
				<diff>@@ -471,6 +471,23 @@ bool MapService::CheckRoutingPoint(const double x, const double y) const {
   return true;
 }
 
+bool MapService::CheckRoutingPointLaneId(
+    const double x, const double y, std::vector&lt;std::string&gt; idsArr) const {
+  if (idsArr.empty()) {
+    return false;
+  }
+  double s, l;
+  LaneInfoConstPtr lane;
+  if (!GetNearestLane(x, y, &amp;lane, &amp;s, &amp;l)) {
+    return false;
+  }
+  if (!CheckRoutingPointLaneType(lane)) {
+    return false;
+  }
+  return std::find(idsArr.begin(), idsArr.end(), lane-&gt;id().id()) !=
+         idsArr.end();
+}
+
 bool MapService::CheckRoutingPointLaneType(LaneInfoConstPtr lane) const {
   if (lane-&gt;lane().type() != Lane::CITY_DRIVING) {
     AERROR
</diff>
			</file>
			<file old_path="modules\dreamview\backend\map\map_service.h" new_path="modules\dreamview\backend\map\map_service.h" added_lines="3" deleted_lines="0">
				<diff>@@ -84,6 +84,9 @@ class MapService {
 
   bool CheckRoutingPoint(const double x, const double y) const;
 
+  bool CheckRoutingPointLaneId(const double x, const double y,
+                               const std::vector&lt;std::string&gt; idsArr) const;
+
   bool CheckRoutingPointLaneType(apollo::hdmap::LaneInfoConstPtr lane) const;
 
   // Reload map from current FLAGS_map_dir.
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" added_lines="131" deleted_lines="4">
				<diff>@@ -38,6 +38,7 @@ using apollo::hdmap::EndWayPointFile;
 using apollo::relative_map::NavigationInfo;
 using apollo::routing::RoutingRequest;
 using apollo::task_manager::CycleRoutingTask;
+using apollo::task_manager::DeadEndJunctionRoutingTask;
 using apollo::task_manager::ParkingRoutingTask;
 using apollo::task_manager::Task;
 
@@ -165,6 +166,37 @@ void SimulationWorldUpdater::RegisterMessageHandlers() {
         }
       });
 
+  websocket_-&gt;RegisterMessageHandler(
+      "SendDeadEndJunctionRoutingRequest",
+      [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
+        Json result = CheckDeadEndJunctionPoints(json);
+        if (result.contains("error")) {
+          AINFO &lt;&lt; result["error"];
+          sim_world_service_.PublishMonitorMessage(MonitorMessageItem::ERROR,
+                                                   result["error"]);
+        } else {
+          auto task = std::make_shared&lt;Task&gt;();
+          auto *dead_junction_routing_task =
+              task-&gt;mutable_dead_junction_routing_task();
+          bool succeed = ConstructDeadJunctionRoutingTask(
+              result, dead_junction_routing_task);
+          if (succeed) {
+            task-&gt;set_task_name("dead_end_junction_routing_task");
+            task-&gt;set_task_type(
+                apollo::task_manager::TaskType::DEAD_JUNCTION_ROUTING);
+            sim_world_service_.PublishTask(task);
+            AINFO &lt;&lt; task-&gt;DebugString();
+            sim_world_service_.PublishMonitorMessage(
+                MonitorMessageItem::INFO, "dead junction routing task sent.");
+          } else {
+            sim_world_service_.PublishMonitorMessage(
+                MonitorMessageItem::ERROR,
+                "Failed to send a dead junction routing task to task manager "
+                "module.");
+          }
+        }
+      });
+
   websocket_-&gt;RegisterMessageHandler(
       "SendDefaultCycleRoutingRequest",
       [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
@@ -453,6 +485,57 @@ Json SimulationWorldUpdater::CheckRoutingPoint(const Json &amp;json) {
   return result;
 }
 
+Json SimulationWorldUpdater::CheckDeadEndJunctionPoints(const Json &amp;json) {
+  Json result;
+  if (!ContainsKey(json, "start1")) {
+    result["error"] = "Failed to check start point for dead end junction.";
+    AERROR &lt;&lt; result["error"];
+    return result;
+  }
+  if (!ContainsKey(json, "end2")) {
+    result["error"] = "Failed to check end point for dead end junction.";
+    AERROR &lt;&lt; result["error"];
+    return result;
+  }
+  auto iter = json.find("inLaneIds");
+  if (iter == json.end() || !iter-&gt;is_array()) {
+    result["error"] = "Failed to check start point for dead end junction.";
+    return result;
+  }
+  std::vector&lt;std::string&gt; laneIds;
+  auto point = json["start1"];
+  for (size_t i = 0; i &lt; iter-&gt;size(); ++i) {
+    auto &amp;id = (*iter)[i];
+    laneIds.push_back(id);
+  }
+  if (!map_service_-&gt;CheckRoutingPointLaneId(point["x"], point["y"], laneIds)) {
+    result["error"] = "Error start point for dead end junction.";
+  }
+  laneIds.clear();
+  point = json["end2"];
+  iter = json.find("outLaneIds");
+  if (iter == json.end() || !iter-&gt;is_array()) {
+    result["error"] = "Failed to check end point for dead end junction.";
+    return result;
+  }
+  for (size_t i = 0; i &lt; iter-&gt;size(); ++i) {
+    auto &amp;id = (*iter)[i];
+    laneIds.push_back(id);
+  }
+  if (!map_service_-&gt;CheckRoutingPointLaneId(point["x"], point["y"], laneIds)) {
+    result["error"] = "Error end point for dead end junction.";
+    return result;
+  }
+
+  result["routing1"]["start"] = json["start1"];
+  result["routing1"]["end"] = json["end1"];
+  result["routing2"]["start"] = json["start2"];
+  result["routing2"]["end"] = json["end2"];
+  result["junctionPoints"] = json["junctionPoints"];
+  result["junctionId"] = json["junctionId"];
+  return result;
+}
+
 bool SimulationWorldUpdater::ConstructRoutingRequest(
     const Json &amp;json, RoutingRequest *routing_request) {
   routing_request-&gt;clear_waypoint();
@@ -523,10 +606,10 @@ bool SimulationWorldUpdater::ConstructRoutingRequest(
     }
   } else {
     if (!map_service_-&gt;ConstructLaneWayPoint(end["x"], end["y"],
-                                           routing_request-&gt;add_waypoint())) {
-    AERROR &lt;&lt; "Failed to prepare a routing request:"
-           &lt;&lt; " cannot locate end point on map.";
-    return false;
+                                             routing_request-&gt;add_waypoint())) {
+      AERROR &lt;&lt; "Failed to prepare a routing request:"
+             &lt;&lt; " cannot locate end point on map.";
+      return false;
     }
   }
 
@@ -582,6 +665,50 @@ bool SimulationWorldUpdater::ConstructParkingRoutingTask(
   return false;
 }
 
+bool SimulationWorldUpdater::ConstructDeadJunctionRoutingTask(
+    const Json &amp;json, DeadEndJunctionRoutingTask *dead_junction_routing_task) {
+  auto *routing_request_in =
+      dead_junction_routing_task-&gt;mutable_routing_request_in();
+  bool succeed = ConstructRoutingRequest(json["routing1"], routing_request_in);
+  if (!succeed) {
+    AERROR &lt;&lt; "Failed to construct the first routing request for dead end "
+              "junction routing task";
+    return false;
+  }
+  auto *routing_request_out =
+      dead_junction_routing_task-&gt;mutable_routing_request_out();
+  succeed = ConstructRoutingRequest(json["routing2"], routing_request_out);
+  if (!succeed) {
+    AERROR &lt;&lt; "Failed to construct the second routing request for dead end "
+              "junction routing task";
+    return false;
+  }
+  auto iter = json.find("junctionPoints");
+  if (iter == json.end() || !iter-&gt;is_array() ||
+      !ContainsKey(json, "junctionId")) {
+    AERROR &lt;&lt; "Failed to construct the dead end junction for dead end "
+              "junction routing task";
+    return false;
+  }
+  auto *dead_end_junction =
+      dead_junction_routing_task-&gt;mutable_dead_end_junction();
+  auto *polygon = dead_end_junction-&gt;mutable_polygon();
+  auto *points = polygon-&gt;mutable_point();
+  for (size_t i = 0; i &lt; iter-&gt;size(); i++) {
+    auto &amp;point = (*iter)[i];
+    auto *p = points-&gt;Add();
+    if (!ValidateCoordinate(point)) {
+      AERROR &lt;&lt; "Failed to construct the dead end junction: invalid waypoint.";
+      return false;
+    }
+    p-&gt;set_x(static_cast&lt;double&gt;(point["x"]));
+    p-&gt;set_y(static_cast&lt;double&gt;(point["y"]));
+  }
+  auto *id = dead_end_junction-&gt;mutable_id();
+  id-&gt;set_id(json["junctionId"]);
+  return true;
+}
+
 bool SimulationWorldUpdater::ValidateCoordinate(const nlohmann::json &amp;json) {
   if (!ContainsKey(json, "x") || !ContainsKey(json, "y")) {
     AERROR &lt;&lt; "Failed to find x or y coordinate.";
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_updater.h" new_path="modules\dreamview\backend\simulation_world\simulation_world_updater.h" added_lines="21" deleted_lines="0">
				<diff>@@ -22,6 +22,7 @@
 
 #include &lt;memory&gt;
 #include &lt;string&gt;
+#include &lt;vector&gt;
 
 #include &lt;boost/thread/locks.hpp&gt;
 #include &lt;boost/thread/shared_mutex.hpp&gt;
@@ -109,6 +110,19 @@ class SimulationWorldUpdater {
       const nlohmann::json &amp;json,
       apollo::task_manager::ParkingRoutingTask *parking_routing_task);
 
+  /**
+   * @brief The function to construct a dead end junction routing task from the
+   * given json,
+   * @param json that contains start1, end1, start2, end2, inLaneIds,
+   * outLaneIds, junctionInfo
+   * @param dead_junction_routing_task
+   * @return True if dead junction routing task is constructed successfully
+   */
+  bool ConstructDeadJunctionRoutingTask(
+      const nlohmann::json &amp;json,
+      apollo::task_manager::DeadEndJunctionRoutingTask
+          *dead_junction_routing_task);
+
   bool ValidateCoordinate(const nlohmann::json &amp;json);
 
   /**
@@ -118,6 +132,13 @@ class SimulationWorldUpdater {
    */
   nlohmann::json CheckRoutingPoint(const nlohmann::json &amp;json);
 
+  /**
+   * @brief Check if routing point is located on a lane that included by arr
+   * @param json that contains point and ids array
+   * @return json contains error means check failed else means check succeed
+   */
+  nlohmann::json CheckDeadEndJunctionPoints(const nlohmann::json &amp;json);
+
   /**
    * @brief Tries to load the points of interest from the file if it has
    * not been.
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9f521638c17fa0ceec67ae7b0d611a4fad270961" author="jiangjianan">
		<msg>dreamview: add interaction tag to dv

Change-Id: I11f3f7fbfc3a4683e92dfdae7cd7de82b1f26403</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_service.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_service.cc" added_lines="6" deleted_lines="0">
				<diff>@@ -70,6 +70,7 @@ using apollo::planning::ADCTrajectory;
 using apollo::planning::DecisionResult;
 using apollo::planning::StopReasonCode;
 using apollo::planning_internal::PlanningData;
+using apollo::prediction::ObstacleInteractiveTag;
 using apollo::prediction::ObstaclePriority;
 using apollo::prediction::PredictionObstacle;
 using apollo::prediction::PredictionObstacles;
@@ -1144,6 +1145,11 @@ void SimulationWorldService::UpdateSimulationWorld(
       world_obj.mutable_obstacle_priority()-&gt;CopyFrom(obstacle.priority());
     }
 
+    // Add prediction interactive tag
+    if (obstacle.has_interactive_tag()) {
+      world_obj.mutable_interactive_tag()-&gt;CopyFrom(obstacle.interactive_tag());
+    }
+
     world_obj.set_timestamp_sec(
         std::max(obstacle.timestamp(), world_obj.timestamp_sec()));
   }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d42890a72ee4be0baf8e69f3448f226caddc56f0" author="fuyiqun">
		<msg>prediction: sampling lane info for VectorNet

Change-Id: Ie2f971689eb11f967d701dd90bdfbcb5360c3257</msg>
		<modified_files>
			<file old_path="modules\prediction\common\prediction_system_gflags.cc" new_path="modules\prediction\common\prediction_system_gflags.cc" added_lines="2" deleted_lines="0">
				<diff>@@ -93,3 +93,5 @@ DEFINE_double(obstacle_y, 0.0, "obstacle position y");
 DEFINE_double(obstacle_phi, 0.0, "obstacle heading phi");
 DEFINE_double(road_distance, 141.4,
               "road distance within which the points are got");
+DEFINE_double(point_distance, 5.0,
+              "sampling distance of two points");
</diff>
			</file>
			<file old_path="modules\prediction\common\prediction_system_gflags.h" new_path="modules\prediction\common\prediction_system_gflags.h" added_lines="1" deleted_lines="0">
				<diff>@@ -58,3 +58,4 @@ DECLARE_double(obstacle_x);
 DECLARE_double(obstacle_y);
 DECLARE_double(obstacle_phi);
 DECLARE_double(road_distance);
+DECLARE_double(point_distance);
</diff>
			</file>
			<file old_path="modules\prediction\pipeline\vector_net.cc" new_path="modules\prediction\pipeline\vector_net.cc" added_lines="202" deleted_lines="134">
				<diff>@@ -15,66 +15,86 @@
  *****************************************************************************/
 #include "modules/prediction/pipeline/vector_net.h"
 
+#include &lt;cmath&gt;
 #include &lt;limits&gt;
-#include &lt;map&gt;
+#include &lt;unordered_set&gt;
 #include &lt;utility&gt;
 
 #include "cyber/common/file.h"
-#include "modules/map/hdmap/hdmap_util.h"
 
 namespace apollo {
 namespace prediction {
-namespace {
-enum ATTRIBUTE_TYPE {
-  ROAD,
-  LANE,
-  JUNCTION,
-  CROSSWALK,
-};
-
-std::map&lt;ATTRIBUTE_TYPE, std::vector&lt;double&gt;&gt; attribute_map{
-    {ROAD, {1, 0, 0, 0, 0}},
-    {LANE, {0, 1, 0, 0, 0}},
-    {JUNCTION, {0, 0, 1, 0, 0}},
-    {CROSSWALK, {0, 0, 0, 1, 0}}};
 
 template &lt;typename Points&gt;
-void GetOnePolyline(const Points&amp; points, const common::PointENU&amp; center_point,
-                    const double obstacle_phi, ATTRIBUTE_TYPE attr_type,
-                    const int count,
-                    std::vector&lt;std::vector&lt;double&gt;&gt;* const one_polyline,
-                    std::vector&lt;double&gt;* const one_p_id) {
+void VectorNet::GetOnePolyline(
+                          const Points&amp; points, double *start_length,
+                          const common::PointENU&amp; center_point,
+                          const double obstacle_phi,
+                          ATTRIBUTE_TYPE attr_type, const int count,
+                          std::vector&lt;std::vector&lt;double&gt;&gt;* const one_polyline,
+                          std::vector&lt;double&gt;* const one_p_id) {
   size_t size = points.size();
-  if (size &lt; 2) return;
+  std::vector&lt;double&gt; s(size, 0);
 
-  const common::PointENU&amp; last_point = points.at(0);
-  auto last_point_after_rotate = common::math::RotateVector2d(
-      {last_point.x() - center_point.x(), last_point.y() - center_point.y()},
-      M_PI_2 - obstacle_phi);
   for (size_t i = 1; i &lt; size; ++i) {
-    if (std::fabs(one_p_id-&gt;at(0)) &gt; std::fabs(last_point_after_rotate.x())) {
+    s[i] = std::hypot(points.at(i).x() - points.at(i - 1).x(),
+                      points.at(i).y() - points.at(i - 1).y()) + s[i - 1];
+  }
+
+  std::vector&lt;double&gt; x;
+  std::vector&lt;double&gt; y;
+  double cur_length = *start_length;
+
+  auto it_lower = std::lower_bound(s.begin(), s.end(), cur_length);
+  while (it_lower != s.end()) {
+    if (it_lower == s.begin()) {
+      x.push_back(points.at(0).x());
+      y.push_back(points.at(0).y());
+    } else {
+      const auto distance = std::distance(s.begin(), it_lower);
+      x.push_back(common::math::lerp(points.at(distance - 1).x(),
+                                     s[distance - 1],
+                                     points.at(distance).x(),
+                                     s[distance], cur_length));
+      y.push_back(common::math::lerp(points.at(distance - 1).y(),
+                                     s[distance - 1],
+                                     points.at(distance).y(),
+                                     s[distance], cur_length));
+    }
+    cur_length += FLAGS_point_distance;
+    it_lower = std::lower_bound(s.begin(), s.end(), cur_length);
+  }
+  size_t point_size = x.size();
+
+  *start_length = cur_length - s[size - 1];
+  if (point_size == 0) return;
+  const std::vector&lt;double&gt;&amp; attr = attribute_map.at(attr_type);
+  auto last_point_after_rotate = common::math::RotateVector2d(
+    {x[0] - center_point.x(), y[0] - center_point.y()},
+    M_PI_2 - obstacle_phi);
+
+  for (size_t i = 1; i &lt; point_size; ++i) {
+    if (one_p_id-&gt;at(0) &gt; last_point_after_rotate.x()) {
       one_p_id-&gt;at(0) = last_point_after_rotate.x();
     }
-    if (std::fabs(one_p_id-&gt;at(1)) &gt; std::fabs(last_point_after_rotate.y())) {
+    if (one_p_id-&gt;at(1) &gt; last_point_after_rotate.y()) {
       one_p_id-&gt;at(1) = last_point_after_rotate.y();
     }
 
-    // TODO(Yiqun):
-    // check the segments are discretized with the same interval
     std::vector&lt;double&gt; one_vector;
 
     // d_s, d_e
     one_vector.push_back(last_point_after_rotate.x());
     one_vector.push_back(last_point_after_rotate.y());
-    auto&amp; point = points.at(i);
+
     Eigen::Vector2d point_after_rotate = common::math::RotateVector2d(
-        {point.x() - center_point.x(), point.y() - center_point.y()},
-        M_PI_2 - obstacle_phi);
+      {x[i] - center_point.x(), y[i] - center_point.y()},
+      M_PI_2 - obstacle_phi);
+
     one_vector.push_back(point_after_rotate.x());
     one_vector.push_back(point_after_rotate.y());
     last_point_after_rotate = std::move(point_after_rotate);
 
-    std::vector&lt;double&gt;&amp; attr = attribute_map[attr_type];
     // attribute
     one_vector.insert(one_vector.end(), attr.begin(), attr.end());
 
@@ -82,7 +102,6 @@ void GetOnePolyline(const Points&amp; points, const common::PointENU&amp; center_point,
     one_polyline-&gt;push_back(std::move(one_vector));
   }
 }
-}  // namespace
 
 bool VectorNet::query(const common::PointENU&amp; center_point,
                       const double obstacle_phi,
@@ -91,10 +110,10 @@ bool VectorNet::query(const common::PointENU&amp; center_point,
   CHECK_NOTNULL(feature_ptr);
   count_ = 0;
   apollo::hdmap::HDMapUtil::ReloadMaps();
-  GetRoads(center_point, obstacle_phi, feature_ptr, p_id_ptr);
+  // GetRoads(center_point, obstacle_phi, feature_ptr, p_id_ptr);
   GetLanes(center_point, obstacle_phi, feature_ptr, p_id_ptr);
-  GetJunctions(center_point, obstacle_phi, feature_ptr, p_id_ptr);
-  GetCrosswalks(center_point, obstacle_phi, feature_ptr, p_id_ptr);
+  // GetJunctions(center_point, obstacle_phi, feature_ptr, p_id_ptr);
+  // GetCrosswalks(center_point, obstacle_phi, feature_ptr, p_id_ptr);
   return true;
 }
 
@@ -130,30 +149,72 @@ bool VectorNet::offline_query(const double obstacle_x, const double obstacle_y,
   return true;
 }
 
-void VectorNet::GetRoads(const common::PointENU&amp; center_point,
-                         const double obstacle_phi,
-                         FeatureVector* const feature_ptr,
-                         PidVector* const p_id_ptr) {
-  std::vector&lt;apollo::hdmap::RoadInfoConstPtr&gt; roads;
-  apollo::hdmap::HDMapUtil::BaseMap().GetRoads(center_point,
-                                               FLAGS_road_distance, &amp;roads);
-
-  for (const auto&amp; road : roads) {
-    for (const auto&amp; section : road-&gt;road().section()) {
-      for (const auto&amp; edge : section.boundary().outer_polygon().edge()) {
-        std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
-        std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
-                                     std::numeric_limits&lt;float&gt;::max()};
-
-        for (const auto&amp; segment : edge.curve().segment()) {
-          GetOnePolyline(segment.line_segment().point(), center_point,
-                         obstacle_phi, ROAD, count_, &amp;one_polyline, &amp;one_p_id);
-        }
-        feature_ptr-&gt;push_back(std::move(one_polyline));
-        p_id_ptr-&gt;push_back(std::move(one_p_id));
-        ++count_;
+// void VectorNet::GetRoads(const common::PointENU&amp; center_point,
+//                          const double obstacle_phi,
+//                          FeatureVector* const feature_ptr,
+//                          PidVector* const p_id_ptr) {
+//   std::vector&lt;apollo::hdmap::RoadInfoConstPtr&gt; roads;
+//   apollo::hdmap::HDMapUtil::BaseMap().GetRoads(center_point,
+//                                                FLAGS_road_distance, &amp;roads);
+//
+//   for (const auto&amp; road : roads) {
+//     std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
+//     std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
+//                                  std::numeric_limits&lt;float&gt;::max()};
+//
+//     for (const auto&amp; section : road-&gt;road().section()) {
+//       std::cout &lt;&lt; "road_type: " &lt;&lt; road-&gt;road().type() &lt;&lt; std::endl;
+//       for (const auto&amp; edge : section.boundary().outer_polygon().edge()) {
+//         for (const auto&amp; segment : edge.curve().segment()) {
+//           GetOnePolyline(segment.line_segment().point(), segment.length(),
+//                          center_point, obstacle_phi, ROAD, count_,
+//                          &amp;one_polyline, &amp;one_p_id);
+//         }
+//       }
+//     }
+//     if (one_polyline.size() == 0) continue;
+//
+//     std::cout &lt;&lt; "road_len: " &lt;&lt; one_polyline.size() &lt;&lt; std::endl;
+//     feature_ptr-&gt;push_back(std::move(one_polyline));
+//     p_id_ptr-&gt;push_back(std::move(one_p_id));
+//     ++count_;
+//   }
+// }
+
+void VectorNet::GetLaneQueue(const std::vector&lt;hdmap::LaneInfoConstPtr&gt;&amp; lanes,
+  std::vector&lt;std::deque&lt;hdmap::LaneInfoConstPtr&gt;&gt;* const lane_deque_ptr) {
+  std::unordered_set&lt;hdmap::LaneInfoConstPtr&gt; lane_set(lanes.begin(),
+                                                       lanes.end());
+
+  while (!lane_set.empty()) {
+    std::deque&lt;apollo::hdmap::LaneInfoConstPtr&gt; one_lane_deque;
+    auto cur_lane = *lane_set.begin();
+    lane_set.erase(lane_set.begin());
+    one_lane_deque.push_back(cur_lane);
+    while (cur_lane-&gt;lane().successor_id_size() &gt; 0) {
+      auto id = cur_lane-&gt;lane().successor_id(0);
+      cur_lane = apollo::hdmap::HDMapUtil::BaseMap().GetLaneById(id);
+      if (lane_set.find(cur_lane) != lane_set.end()) {
+        lane_set.erase(cur_lane);
+        one_lane_deque.push_back(cur_lane);
+      } else {
+        break;
+      }
+    }
+
+    cur_lane = one_lane_deque.front();
+    while (cur_lane-&gt;lane().predecessor_id_size() &gt; 0) {
+      auto id = cur_lane-&gt;lane().predecessor_id(0);
+      cur_lane = apollo::hdmap::HDMapUtil::BaseMap().GetLaneById(id);
+      if (lane_set.find(cur_lane) != lane_set.end()) {
+        lane_set.erase(cur_lane);
+        one_lane_deque.push_front(cur_lane);
+      } else {
+        break;
       }
     }
+
+    lane_deque_ptr-&gt;push_back(one_lane_deque);
   }
 }
 
@@ -164,92 +225,99 @@ void VectorNet::GetLanes(const common::PointENU&amp; center_point,
   std::vector&lt;apollo::hdmap::LaneInfoConstPtr&gt; lanes;
   apollo::hdmap::HDMapUtil::BaseMap().GetLanes(center_point,
                                                FLAGS_road_distance, &amp;lanes);
-  for (const auto&amp; lane : lanes) {
-    // Get lane_central first
-    for (const auto&amp; segment : lane-&gt;lane().central_curve().segment()) {
-      std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
-      std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
-                                   std::numeric_limits&lt;float&gt;::max()};
 
-      GetOnePolyline(segment.line_segment().point(), center_point, obstacle_phi,
-                     LANE, count_, &amp;one_polyline, &amp;one_p_id);
-      feature_ptr-&gt;push_back(std::move(one_polyline));
-      p_id_ptr-&gt;push_back(std::move(one_p_id));
-      ++count_;
-    }
+  std::vector&lt;std::deque&lt;apollo::hdmap::LaneInfoConstPtr&gt;&gt; lane_deque_vector;
+  GetLaneQueue(lanes, &amp;lane_deque_vector);
 
-    // Not drawing boundary for virtual city_driving lane
-    if (lane-&gt;lane().type() == 2 &amp;&amp; lane-&gt;lane().left_boundary().virtual_() &amp;&amp;
-        lane-&gt;lane().right_boundary().virtual_()) {
-      continue;
-    }
+  for (const auto&amp; lane_deque : lane_deque_vector) {
     // Draw lane's left_boundary
-    for (const auto&amp; segment : lane-&gt;lane().left_boundary().curve().segment()) {
-      std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
-      std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
-                                   std::numeric_limits&lt;float&gt;::max()};
-
-      GetOnePolyline(segment.line_segment().point(), center_point, obstacle_phi,
-                     LANE, count_, &amp;one_polyline, &amp;one_p_id);
-      feature_ptr-&gt;push_back(std::move(one_polyline));
-      p_id_ptr-&gt;push_back(std::move(one_p_id));
-      ++count_;
+    std::vector&lt;std::vector&lt;double&gt;&gt; left_polyline;
+    std::vector&lt;double&gt; left_p_id{std::numeric_limits&lt;float&gt;::max(),
+                                  std::numeric_limits&lt;float&gt;::max()};
+    double start_length = 0;
+    for (const auto&amp; lane : lane_deque) {
+      std::cout &lt;&lt; lane-&gt;lane().id().id() &lt;&lt; " ";
+      // if (lane-&gt;lane().left_boundary().virtual_()) continue;
+      for (const auto&amp; segment :
+             lane-&gt;lane().left_boundary().curve().segment()) {
+        auto bound_type =
+          lane-&gt;lane().left_boundary().boundary_type(0).types(0);
+        GetOnePolyline(segment.line_segment().point(), &amp;start_length,
+                       center_point, obstacle_phi, lane_attr_map.at(bound_type),
+                       count_, &amp;left_polyline, &amp;left_p_id);
+      }
     }
+    std::cout &lt;&lt; "&lt;&lt;&lt;&lt;&lt;size&gt;&gt;&gt;&gt;&gt;&gt;&gt;" &lt;&lt; lane_deque.size() &lt;&lt;std::endl;
 
-    // Draw lane's right_boundary
-    for (const auto&amp; segment :
-         lane-&gt;lane().right_boundary().curve().segment()) {
-      std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
-      std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
-                                   std::numeric_limits&lt;float&gt;::max()};
+    if (left_polyline.size() &lt; 2) continue;
+    feature_ptr-&gt;push_back(std::move(left_polyline));
+    p_id_ptr-&gt;push_back(std::move(left_p_id));
+    ++count_;
 
-      GetOnePolyline(segment.line_segment().point(), center_point, obstacle_phi,
-                     LANE, count_, &amp;one_polyline, &amp;one_p_id);
-      feature_ptr-&gt;push_back(std::move(one_polyline));
-      p_id_ptr-&gt;push_back(std::move(one_p_id));
-      ++count_;
+    std::vector&lt;std::vector&lt;double&gt;&gt; right_polyline;
+    std::vector&lt;double&gt; right_p_id{std::numeric_limits&lt;float&gt;::max(),
+                                   std::numeric_limits&lt;float&gt;::max()};
+    start_length = 0;
+    // Draw lane's right_boundary
+    for (const auto&amp; lane : lane_deque) {
+      // if (lane-&gt;lane().right_boundary().virtual_()) continue;
+      for (const auto&amp; segment :
+             lane-&gt;lane().right_boundary().curve().segment()) {
+        auto bound_type =
+          lane-&gt;lane().left_boundary().boundary_type(0).types(0);
+        GetOnePolyline(segment.line_segment().point(), &amp;start_length,
+                       center_point, obstacle_phi, lane_attr_map.at(bound_type),
+                       count_, &amp;right_polyline, &amp;right_p_id);
+      }
     }
-  }
-}
 
-void VectorNet::GetJunctions(const common::PointENU&amp; center_point,
-                             const double obstacle_phi,
-                             FeatureVector* const feature_ptr,
-                             PidVector* const p_id_ptr) {
-  std::vector&lt;apollo::hdmap::JunctionInfoConstPtr&gt; junctions;
-  apollo::hdmap::HDMapUtil::BaseMap().GetJunctions(
-      center_point, FLAGS_road_distance, &amp;junctions);
-  for (const auto&amp; junction : junctions) {
-    std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
-    std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
-                                 std::numeric_limits&lt;float&gt;::max()};
-    GetOnePolyline(junction-&gt;junction().polygon().point(), center_point,
-                   obstacle_phi, JUNCTION, count_, &amp;one_polyline, &amp;one_p_id);
-
-    feature_ptr-&gt;push_back(std::move(one_polyline));
-    p_id_ptr-&gt;push_back(std::move(one_p_id));
+    if (right_polyline.size() &lt; 2) continue;
+    feature_ptr-&gt;push_back(std::move(right_polyline));
+    p_id_ptr-&gt;push_back(std::move(right_p_id));
     ++count_;
   }
+  std::cout &lt;&lt; "polyline_num:" &lt;&lt; p_id_ptr-&gt;size() &lt;&lt; std::endl;
 }
 
-void VectorNet::GetCrosswalks(const common::PointENU&amp; center_point,
-                              const double obstacle_phi,
-                              FeatureVector* const feature_ptr,
-                              PidVector* const p_id_ptr) {
-  std::vector&lt;apollo::hdmap::CrosswalkInfoConstPtr&gt; crosswalks;
-  apollo::hdmap::HDMapUtil::BaseMap().GetCrosswalks(
-      center_point, FLAGS_road_distance, &amp;crosswalks);
-  for (const auto&amp; crosswalk : crosswalks) {
-    std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
-    std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
-                                 std::numeric_limits&lt;float&gt;::max()};
-    GetOnePolyline(crosswalk-&gt;crosswalk().polygon().point(), center_point,
-                   obstacle_phi, CROSSWALK, count_, &amp;one_polyline, &amp;one_p_id);
-
-    feature_ptr-&gt;push_back(std::move(one_polyline));
-    p_id_ptr-&gt;push_back(std::move(one_p_id));
-    ++count_;
-  }
-}
+// void VectorNet::GetJunctions(const common::PointENU&amp; center_point,
+//                              const double obstacle_phi,
+//                              FeatureVector* const feature_ptr,
+//                              PidVector* const p_id_ptr) {
+//   std::vector&lt;apollo::hdmap::JunctionInfoConstPtr&gt; junctions;
+//   apollo::hdmap::HDMapUtil::BaseMap().GetJunctions(
+//       center_point, FLAGS_road_distance, &amp;junctions);
+//   for (const auto&amp; junction : junctions) {
+//     std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
+//     std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
+//                                  std::numeric_limits&lt;float&gt;::max()};
+//     GetOnePolyline(junction-&gt;junction().polygon().point(), center_point,
+//                    obstacle_phi, JUNCTION, count_, &amp;one_polyline, &amp;one_p_id);
+//
+//     feature_ptr-&gt;push_back(std::move(one_polyline));
+//     p_id_ptr-&gt;push_back(std::move(one_p_id));
+//     ++count_;
+//   }
+// }
+
+// void VectorNet::GetCrosswalks(const common::PointENU&amp; center_point,
+//                               const double obstacle_phi,
+//                               FeatureVector* const feature_ptr,
+//                               PidVector* const p_id_ptr) {
+//   std::vector&lt;apollo::hdmap::CrosswalkInfoConstPtr&gt; crosswalks;
+//   apollo::hdmap::HDMapUtil::BaseMap().GetCrosswalks(
+//       center_point, FLAGS_road_distance, &amp;crosswalks);
+//   for (const auto&amp; crosswalk : crosswalks) {
+//     std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
+//     std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
+//                                  std::numeric_limits&lt;float&gt;::max()};
+//     GetOnePolyline(crosswalk-&gt;crosswalk().polygon().point(), center_point,
+//                    obstacle_phi, CROSSWALK, count_, &amp;one_polyline,
+//                    &amp;one_p_id);
+//
+//     feature_ptr-&gt;push_back(std::move(one_polyline));
+//     p_id_ptr-&gt;push_back(std::move(one_p_id));
+//     ++count_;
+//   }
+// }
 }  // namespace prediction
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\prediction\pipeline\vector_net.h" new_path="modules\prediction\pipeline\vector_net.h" added_lines="64" deleted_lines="11">
				<diff>@@ -16,9 +16,13 @@
 
 #pragma once
 
+#include &lt;deque&gt;
+#include &lt;map&gt;
 #include &lt;vector&gt;
 
+#include "modules/common/math/linear_interpolation.h"
 #include "modules/common/util/point_factory.h"
+#include "modules/map/hdmap/hdmap_util.h"
 #include "modules/prediction/common/prediction_system_gflags.h"
 #include "modules/prediction/proto/vector_net.pb.h"
 
@@ -28,6 +32,19 @@ namespace prediction {
 using FeatureVector = std::vector&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt;;
 using PidVector = std::vector&lt;std::vector&lt;double&gt;&gt;;
 
+enum ATTRIBUTE_TYPE {
+  ROAD,
+  LANE_UNKOWN,
+  LANE_DOTTED_YELLOW,
+  LANE_DOTTED_WHITE,
+  LANE_SOLID_YELLOW,
+  LANE_SOLID_WHITE,
+  LANE_DOUBLE_YELLOW,
+  LANE_CURB,
+  JUNCTION,
+  CROSSWALK,
+};
+
 class VectorNet {
  public:
   VectorNet() = default;
@@ -41,21 +58,57 @@ class VectorNet {
                      const double obstacle_phi);
 
  private:
-  void GetRoads(const common::PointENU&amp; center_point,
-                const double obstacle_phi,
-                FeatureVector* const feature_ptr, PidVector* const p_id_ptr);
+  // TODO(Yiqun): 1.Left/Right boundary 2.Ordinal Encoding
+  const std::map&lt;ATTRIBUTE_TYPE, std::vector&lt;double&gt;&gt; attribute_map{
+    {ROAD, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
+    {LANE_UNKOWN, {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
+    {LANE_DOTTED_YELLOW, {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}},
+    {LANE_DOTTED_WHITE, {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}},
+    {LANE_SOLID_YELLOW, {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}},
+    {LANE_SOLID_WHITE, {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}},
+    {LANE_DOUBLE_YELLOW, {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}},
+    {LANE_CURB, {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}},
+    {JUNCTION, {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}},
+    {CROSSWALK, {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}},
+  };
+
+  const std::map&lt;hdmap::LaneBoundaryType::Type, ATTRIBUTE_TYPE&gt; lane_attr_map{
+    {hdmap::LaneBoundaryType::UNKNOWN, LANE_UNKOWN},
+    {hdmap::LaneBoundaryType::DOTTED_YELLOW, LANE_DOTTED_YELLOW},
+    {hdmap::LaneBoundaryType::DOTTED_WHITE, LANE_DOTTED_WHITE},
+    {hdmap::LaneBoundaryType::SOLID_YELLOW, LANE_SOLID_YELLOW},
+    {hdmap::LaneBoundaryType::SOLID_WHITE, LANE_SOLID_WHITE},
+    {hdmap::LaneBoundaryType::DOUBLE_YELLOW, LANE_DOUBLE_YELLOW},
+    {hdmap::LaneBoundaryType::CURB, LANE_CURB},
+  };
+
+  template &lt;typename Points&gt;
+  void GetOnePolyline(const Points&amp; points, double *start_length,
+                     const common::PointENU&amp; center_point,
+                     const double obstacle_phi,
+                     ATTRIBUTE_TYPE attr_type, const int count,
+                     std::vector&lt;std::vector&lt;double&gt;&gt;* const one_polyline,
+                     std::vector&lt;double&gt;* const one_p_id);
+
+  // void GetRoads(const common::PointENU&amp; center_point,
+  //               const double obstacle_phi,
+  //               FeatureVector* const feature_ptr, PidVector* const p_id_ptr);
+
+  void GetLaneQueue(const std::vector&lt;hdmap::LaneInfoConstPtr&gt;&amp; lanes,
+    std::vector&lt;std::deque&lt;hdmap::LaneInfoConstPtr&gt;&gt;* const lane_deque_ptr);
+
   void GetLanes(const common::PointENU&amp; center_point,
                            const double obstacle_phi,
                            FeatureVector* const feature_ptr,
                            PidVector* const p_id_ptr);
-  void GetJunctions(const common::PointENU&amp; center_point,
-                    const double obstacle_phi,
-                    FeatureVector* const feature_ptr,
-                    PidVector* const p_id_ptr);
-  void GetCrosswalks(const common::PointENU&amp; center_point,
-                    const double obstacle_phi,
-                    FeatureVector* const feature_ptr,
-                    PidVector* const p_id_ptr);
+  // void GetJunctions(const common::PointENU&amp; center_point,
+  //                   const double obstacle_phi,
+  //                   FeatureVector* const feature_ptr,
+  //                   PidVector* const p_id_ptr);
+  // void GetCrosswalks(const common::PointENU&amp; center_point,
+  //                   const double obstacle_phi,
+  //                   FeatureVector* const feature_ptr,
+  //                   PidVector* const p_id_ptr);
   int count_ = 0;
 };
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="2c116b7b86237470d8b478fd5cc7075396297e07" author="daohu527">
		<msg>localization: cyber_record_parser add decompresses multiple files</msg>
		<modified_files>
			<file old_path="modules\localization\msf\local_tool\data_extraction\cyber_record_parser.cc" new_path="modules\localization\msf\local_tool\data_extraction\cyber_record_parser.cc" added_lines="5" deleted_lines="4">
				<diff>@@ -29,7 +29,7 @@ using apollo::localization::msf::PCDExporter;
 int main(int argc, char **argv) {
   boost::program_options::options_description boost_desc("Allowed options");
   boost_desc.add_options()("help", "produce help message")(
-      "bag_file", boost::program_options::value&lt;std::string&gt;(),
+      "bag_files", boost::program_options::value&lt;std::vector&lt;std::string&gt;&gt;(),
       "provide the bag file")("out_folder",
                               boost::program_options::value&lt;std::string&gt;(),
                               "provide the output folder")(
@@ -60,13 +60,14 @@ int main(int argc, char **argv) {
       boost_args);
   boost::program_options::notify(boost_args);
 
-  if (boost_args.count("help") || !boost_args.count("bag_file") ||
+  if (boost_args.count("help") || !boost_args.count("bag_files") ||
       !boost_args.count("out_folder")) {
     AERROR &lt;&lt; boost_desc;
     return 0;
   }
 
-  const std::string bag_file = boost_args["bag_file"].as&lt;std::string&gt;();
+  const std::vector&lt;std::string&gt; bag_files =
+      boost_args["bag_files"].as&lt;std::vector&lt;std::string&gt;&gt;();
   const std::string pcd_folder =
       boost_args["out_folder"].as&lt;std::string&gt;() + "/pcd";
   if (!boost::filesystem::exists(pcd_folder)) {
@@ -108,7 +109,7 @@ int main(int argc, char **argv) {
     loc_exporter-&gt;OdometryLocCallback(msg);
   });
 
-  reader.Read(bag_file);
+  reader.Read(bag_files);
 
   return 0;
 }
</diff>
			</file>
			<file old_path="modules\localization\msf\local_tool\data_extraction\cyber_record_reader.cc" new_path="modules\localization\msf\local_tool\data_extraction\cyber_record_reader.cc" added_lines="9" deleted_lines="7">
				<diff>@@ -36,13 +36,15 @@ void CyberRecordReader::Subscribe(
   topics_.push_back(topic);
 }
 
-void CyberRecordReader::Read(const std::string &amp;file_name) {
-  RecordReader reader(file_name);
-  cyber::record::RecordMessage message;
-  while (reader.ReadMessage(&amp;message)) {
-    auto itr = call_back_map_.find(message.channel_name);
-    if (itr != call_back_map_.end()) {
-      itr-&gt;second(message.content);
+void CyberRecordReader::Read(const std::vector&lt;std::string&gt; &amp;file_names) {
+  for (const std::string &amp;file_name : file_names) {
+    RecordReader reader(file_name);
+    cyber::record::RecordMessage message;
+    while (reader.ReadMessage(&amp;message)) {
+      auto itr = call_back_map_.find(message.channel_name);
+      if (itr != call_back_map_.end()) {
+        itr-&gt;second(message.content);
+      }
     }
   }
 }
</diff>
			</file>
			<file old_path="modules\localization\msf\local_tool\data_extraction\cyber_record_reader.h" new_path="modules\localization\msf\local_tool\data_extraction\cyber_record_reader.h" added_lines="1" deleted_lines="1">
				<diff>@@ -36,7 +36,7 @@ class CyberRecordReader {
 
   void Subscribe(const std::string&amp; topic,
                  const std::function&lt;void(const std::string&amp;)&gt; call_back);
-  void Read(const std::string&amp; file_name);
+  void Read(const std::vector&lt;std::string&gt; &amp;file_names);
 
  private:
   std::vector&lt;std::string&gt; topics_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d35a67e6c7350f5d15854c6f909f7652d9017fc4" author="daohu527">
		<msg>localization: cyber_record_parser keep the original interface</msg>
		<modified_files>
			<file old_path="modules\localization\msf\local_tool\data_extraction\cyber_record_reader.cc" new_path="modules\localization\msf\local_tool\data_extraction\cyber_record_reader.cc" added_lines="12" deleted_lines="8">
				<diff>@@ -36,16 +36,20 @@ void CyberRecordReader::Subscribe(
   topics_.push_back(topic);
 }
 
+void CyberRecordReader::Read(const std::string &amp;file_name) {
+  RecordReader reader(file_name);
+  cyber::record::RecordMessage message;
+  while (reader.ReadMessage(&amp;message)) {
+    auto itr = call_back_map_.find(message.channel_name);
+    if (itr != call_back_map_.end()) {
+      itr-&gt;second(message.content);
+    }
+  }
+}
+
 void CyberRecordReader::Read(const std::vector&lt;std::string&gt; &amp;file_names) {
   for (const std::string &amp;file_name : file_names) {
-    RecordReader reader(file_name);
-    cyber::record::RecordMessage message;
-    while (reader.ReadMessage(&amp;message)) {
-      auto itr = call_back_map_.find(message.channel_name);
-      if (itr != call_back_map_.end()) {
-        itr-&gt;second(message.content);
-      }
-    }
+    Read(file_name);
   }
 }
 
</diff>
			</file>
			<file old_path="modules\localization\msf\local_tool\data_extraction\cyber_record_reader.h" new_path="modules\localization\msf\local_tool\data_extraction\cyber_record_reader.h" added_lines="1" deleted_lines="0">
				<diff>@@ -36,6 +36,7 @@ class CyberRecordReader {
 
   void Subscribe(const std::string&amp; topic,
                  const std::function&lt;void(const std::string&amp;)&gt; call_back);
+  void Read(const std::string&amp; file_name);
   void Read(const std::vector&lt;std::string&gt; &amp;file_names);
 
  private:
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f5113b11f965ad6c5a9f06df7be7a341bad846cb" author="fuyiqun">
		<msg>prediction: add all info from map

Change-Id: If3181e25b71831eb5cf7f3e99f90d05a1d820643</msg>
		<modified_files>
			<file old_path="modules\prediction\pipeline\vector_net.cc" new_path="modules\prediction\pipeline\vector_net.cc" added_lines="75" deleted_lines="76">
				<diff>@@ -110,10 +110,10 @@ bool VectorNet::query(const common::PointENU&amp; center_point,
   CHECK_NOTNULL(feature_ptr);
   count_ = 0;
   apollo::hdmap::HDMapUtil::ReloadMaps();
-  // GetRoads(center_point, obstacle_phi, feature_ptr, p_id_ptr);
+  GetRoads(center_point, obstacle_phi, feature_ptr, p_id_ptr);
   GetLanes(center_point, obstacle_phi, feature_ptr, p_id_ptr);
-  // GetJunctions(center_point, obstacle_phi, feature_ptr, p_id_ptr);
-  // GetCrosswalks(center_point, obstacle_phi, feature_ptr, p_id_ptr);
+  GetJunctions(center_point, obstacle_phi, feature_ptr, p_id_ptr);
+  GetCrosswalks(center_point, obstacle_phi, feature_ptr, p_id_ptr);
   return true;
 }
 
@@ -149,37 +149,35 @@ bool VectorNet::offline_query(const double obstacle_x, const double obstacle_y,
   return true;
 }
 
-// void VectorNet::GetRoads(const common::PointENU&amp; center_point,
-//                          const double obstacle_phi,
-//                          FeatureVector* const feature_ptr,
-//                          PidVector* const p_id_ptr) {
-//   std::vector&lt;apollo::hdmap::RoadInfoConstPtr&gt; roads;
-//   apollo::hdmap::HDMapUtil::BaseMap().GetRoads(center_point,
-//                                                FLAGS_road_distance, &amp;roads);
-//
-//   for (const auto&amp; road : roads) {
-//     std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
-//     std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
-//                                  std::numeric_limits&lt;float&gt;::max()};
-//
-//     for (const auto&amp; section : road-&gt;road().section()) {
-//       std::cout &lt;&lt; "road_type: " &lt;&lt; road-&gt;road().type() &lt;&lt; std::endl;
-//       for (const auto&amp; edge : section.boundary().outer_polygon().edge()) {
-//         for (const auto&amp; segment : edge.curve().segment()) {
-//           GetOnePolyline(segment.line_segment().point(), segment.length(),
-//                          center_point, obstacle_phi, ROAD, count_,
-//                          &amp;one_polyline, &amp;one_p_id);
-//         }
-//       }
-//     }
-//     if (one_polyline.size() == 0) continue;
-//
-//     std::cout &lt;&lt; "road_len: " &lt;&lt; one_polyline.size() &lt;&lt; std::endl;
-//     feature_ptr-&gt;push_back(std::move(one_polyline));
-//     p_id_ptr-&gt;push_back(std::move(one_p_id));
-//     ++count_;
-//   }
-// }
+void VectorNet::GetRoads(const common::PointENU&amp; center_point,
+                         const double obstacle_phi,
+                         FeatureVector* const feature_ptr,
+                         PidVector* const p_id_ptr) {
+  std::vector&lt;apollo::hdmap::RoadInfoConstPtr&gt; roads;
+  apollo::hdmap::HDMapUtil::BaseMap().GetRoads(center_point,
+                                               FLAGS_road_distance, &amp;roads);
+
+  for (const auto&amp; road : roads) {
+    for (const auto&amp; section : road-&gt;road().section()) {
+      for (const auto&amp; edge : section.boundary().outer_polygon().edge()) {
+        std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
+        std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
+                                     std::numeric_limits&lt;float&gt;::max()};
+        double start_length = 0;
+        for (const auto&amp; segment : edge.curve().segment()) {
+          GetOnePolyline(segment.line_segment().point(), &amp;start_length,
+                         center_point, obstacle_phi, ROAD, count_,
+                         &amp;one_polyline, &amp;one_p_id);
+        }
+        if (one_polyline.size() == 0) continue;
+
+        feature_ptr-&gt;push_back(std::move(one_polyline));
+        p_id_ptr-&gt;push_back(std::move(one_p_id));
+        ++count_;
+      }
+    }
+  }
+}
 
 void VectorNet::GetLaneQueue(const std::vector&lt;hdmap::LaneInfoConstPtr&gt;&amp; lanes,
   std::vector&lt;std::deque&lt;hdmap::LaneInfoConstPtr&gt;&gt;* const lane_deque_ptr) {
@@ -247,7 +245,6 @@ void VectorNet::GetLanes(const common::PointENU&amp; center_point,
                        count_, &amp;left_polyline, &amp;left_p_id);
       }
     }
-    std::cout &lt;&lt; "&lt;&lt;&lt;&lt;&lt;size&gt;&gt;&gt;&gt;&gt;&gt;&gt;" &lt;&lt; lane_deque.size() &lt;&lt;std::endl;
 
     if (left_polyline.size() &lt; 2) continue;
     feature_ptr-&gt;push_back(std::move(left_polyline));
@@ -276,48 +273,50 @@ void VectorNet::GetLanes(const common::PointENU&amp; center_point,
     p_id_ptr-&gt;push_back(std::move(right_p_id));
     ++count_;
   }
-  std::cout &lt;&lt; "polyline_num:" &lt;&lt; p_id_ptr-&gt;size() &lt;&lt; std::endl;
 }
 
-// void VectorNet::GetJunctions(const common::PointENU&amp; center_point,
-//                              const double obstacle_phi,
-//                              FeatureVector* const feature_ptr,
-//                              PidVector* const p_id_ptr) {
-//   std::vector&lt;apollo::hdmap::JunctionInfoConstPtr&gt; junctions;
-//   apollo::hdmap::HDMapUtil::BaseMap().GetJunctions(
-//       center_point, FLAGS_road_distance, &amp;junctions);
-//   for (const auto&amp; junction : junctions) {
-//     std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
-//     std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
-//                                  std::numeric_limits&lt;float&gt;::max()};
-//     GetOnePolyline(junction-&gt;junction().polygon().point(), center_point,
-//                    obstacle_phi, JUNCTION, count_, &amp;one_polyline, &amp;one_p_id);
-//
-//     feature_ptr-&gt;push_back(std::move(one_polyline));
-//     p_id_ptr-&gt;push_back(std::move(one_p_id));
-//     ++count_;
-//   }
-// }
-
-// void VectorNet::GetCrosswalks(const common::PointENU&amp; center_point,
-//                               const double obstacle_phi,
-//                               FeatureVector* const feature_ptr,
-//                               PidVector* const p_id_ptr) {
-//   std::vector&lt;apollo::hdmap::CrosswalkInfoConstPtr&gt; crosswalks;
-//   apollo::hdmap::HDMapUtil::BaseMap().GetCrosswalks(
-//       center_point, FLAGS_road_distance, &amp;crosswalks);
-//   for (const auto&amp; crosswalk : crosswalks) {
-//     std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
-//     std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
-//                                  std::numeric_limits&lt;float&gt;::max()};
-//     GetOnePolyline(crosswalk-&gt;crosswalk().polygon().point(), center_point,
-//                    obstacle_phi, CROSSWALK, count_, &amp;one_polyline,
-//                    &amp;one_p_id);
-//
-//     feature_ptr-&gt;push_back(std::move(one_polyline));
-//     p_id_ptr-&gt;push_back(std::move(one_p_id));
-//     ++count_;
-//   }
-// }
+void VectorNet::GetJunctions(const common::PointENU&amp; center_point,
+                             const double obstacle_phi,
+                             FeatureVector* const feature_ptr,
+                             PidVector* const p_id_ptr) {
+  std::vector&lt;apollo::hdmap::JunctionInfoConstPtr&gt; junctions;
+  apollo::hdmap::HDMapUtil::BaseMap().GetJunctions(
+      center_point, FLAGS_road_distance, &amp;junctions);
+  for (const auto&amp; junction : junctions) {
+    std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
+    std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
+                                 std::numeric_limits&lt;float&gt;::max()};
+    double start_length = 0;
+    GetOnePolyline(junction-&gt;junction().polygon().point(), &amp;start_length,
+                   center_point, obstacle_phi, JUNCTION, count_,
+                   &amp;one_polyline, &amp;one_p_id);
+
+    feature_ptr-&gt;push_back(std::move(one_polyline));
+    p_id_ptr-&gt;push_back(std::move(one_p_id));
+    ++count_;
+  }
+}
+
+void VectorNet::GetCrosswalks(const common::PointENU&amp; center_point,
+                              const double obstacle_phi,
+                              FeatureVector* const feature_ptr,
+                              PidVector* const p_id_ptr) {
+  std::vector&lt;apollo::hdmap::CrosswalkInfoConstPtr&gt; crosswalks;
+  apollo::hdmap::HDMapUtil::BaseMap().GetCrosswalks(
+      center_point, FLAGS_road_distance, &amp;crosswalks);
+  for (const auto&amp; crosswalk : crosswalks) {
+    std::vector&lt;std::vector&lt;double&gt;&gt; one_polyline;
+    std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
+                                 std::numeric_limits&lt;float&gt;::max()};
+    double start_length = 0;
+    GetOnePolyline(crosswalk-&gt;crosswalk().polygon().point(), &amp;start_length,
+                   center_point, obstacle_phi, CROSSWALK, count_,
+                   &amp;one_polyline, &amp;one_p_id);
+
+    feature_ptr-&gt;push_back(std::move(one_polyline));
+    p_id_ptr-&gt;push_back(std::move(one_p_id));
+    ++count_;
+  }
+}
 }  // namespace prediction
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\prediction\pipeline\vector_net.h" new_path="modules\prediction\pipeline\vector_net.h" added_lines="11" deleted_lines="11">
				<diff>@@ -90,9 +90,9 @@ class VectorNet {
                      std::vector&lt;std::vector&lt;double&gt;&gt;* const one_polyline,
                      std::vector&lt;double&gt;* const one_p_id);
 
-  // void GetRoads(const common::PointENU&amp; center_point,
-  //               const double obstacle_phi,
-  //               FeatureVector* const feature_ptr, PidVector* const p_id_ptr);
+  void GetRoads(const common::PointENU&amp; center_point,
+                const double obstacle_phi,
+                FeatureVector* const feature_ptr, PidVector* const p_id_ptr);
 
   void GetLaneQueue(const std::vector&lt;hdmap::LaneInfoConstPtr&gt;&amp; lanes,
     std::vector&lt;std::deque&lt;hdmap::LaneInfoConstPtr&gt;&gt;* const lane_deque_ptr);
@@ -101,14 +101,14 @@ class VectorNet {
                            const double obstacle_phi,
                            FeatureVector* const feature_ptr,
                            PidVector* const p_id_ptr);
-  // void GetJunctions(const common::PointENU&amp; center_point,
-  //                   const double obstacle_phi,
-  //                   FeatureVector* const feature_ptr,
-  //                   PidVector* const p_id_ptr);
-  // void GetCrosswalks(const common::PointENU&amp; center_point,
-  //                   const double obstacle_phi,
-  //                   FeatureVector* const feature_ptr,
-  //                   PidVector* const p_id_ptr);
+  void GetJunctions(const common::PointENU&amp; center_point,
+                    const double obstacle_phi,
+                    FeatureVector* const feature_ptr,
+                    PidVector* const p_id_ptr);
+  void GetCrosswalks(const common::PointENU&amp; center_point,
+                    const double obstacle_phi,
+                    FeatureVector* const feature_ptr,
+                    PidVector* const p_id_ptr);
   int count_ = 0;
 };
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ec30ae63c8bd074679b2dbd9bac63c8454cc1028" author="changsh726">
		<msg>Transform: adapts to simulation mode</msg>
		<modified_files>
			<file old_path="modules\perception\onboard\transform_wrapper\transform_wrapper.cc" new_path="modules\perception\onboard\transform_wrapper\transform_wrapper.cc" added_lines="10" deleted_lines="4">
				<diff>@@ -251,10 +251,16 @@ bool TransformWrapper::QueryTrans(double timestamp, StampedTransform* trans,
   if (!tf2_buffer_-&gt;canTransform(frame_id, child_frame_id, query_time,
                                  static_cast&lt;float&gt;(FLAGS_obs_tf2_buff_size),
                                  &amp;err_string)) {
-    AERROR &lt;&lt; "Can not find transform. " &lt;&lt; FORMAT_TIMESTAMP(timestamp)
-           &lt;&lt; " frame_id: " &lt;&lt; frame_id &lt;&lt; " child_frame_id: " &lt;&lt; child_frame_id
-           &lt;&lt; " Error info: " &lt;&lt; err_string;
-    return false;
+    // In simulation mode, use the latest transform information if query failed.
+    if (!cyber::common::GlobalData::Instance()-&gt;IsRealityMode()) {
+      query_time = cyber::Time(0);
+    } else {
+      AERROR &lt;&lt; "Can not find transform. " &lt;&lt; FORMAT_TIMESTAMP(timestamp)
+             &lt;&lt; " frame_id: " &lt;&lt; frame_id
+             &lt;&lt; " child_frame_id: " &lt;&lt; child_frame_id
+             &lt;&lt; " Error info: " &lt;&lt; err_string;
+      return false;
+    }
   }
 
   apollo::transform::TransformStamped stamped_transform;
</diff>
			</file>
			<file old_path="modules\transform\buffer.cc" new_path="modules\transform\buffer.cc" added_lines="3" deleted_lines="4">
				<diff>@@ -207,13 +207,12 @@ bool Buffer::canTransform(const std::string&amp; target_frame,
     if (retval) {
       return true;
     } else {
+      if (!cyber::common::GlobalData::Instance()-&gt;IsRealityMode()) {
+        break;
+      }
       const int sleep_time_ms = 3;
       AWARN &lt;&lt; "BufferCore::canTransform failed: " &lt;&lt; *errstr;
       std::this_thread::sleep_for(std::chrono::milliseconds(sleep_time_ms));
-      if (!cyber::common::GlobalData::Instance()-&gt;IsRealityMode()) {
-        Clock::SetNow(Time(Clock::Now().ToNanosecond() +
-                           sleep_time_ms * kMilliToNanoFactor));
-      }
     }
   }
   *errstr = *errstr + ":timeout";
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a9929ab3f30444e43add72538f6f6df4a54ee4fe" author="lijin18">
		<msg>Dv:Remove dead junction from dead junction task and change the point position for in out routing request</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" added_lines="10" deleted_lines="26">
				<diff>@@ -183,7 +183,7 @@ void SimulationWorldUpdater::RegisterMessageHandlers() {
           if (succeed) {
             task-&gt;set_task_name("dead_end_junction_routing_task");
             task-&gt;set_task_type(
-                apollo::task_manager::TaskType::DEAD_JUNCTION_ROUTING);
+                apollo::task_manager::TaskType::DEAD_END_ROUTING);
             sim_world_service_.PublishTask(task);
             AINFO &lt;&lt; task-&gt;DebugString();
             sim_world_service_.PublishMonitorMessage(
@@ -531,8 +531,7 @@ Json SimulationWorldUpdater::CheckDeadEndJunctionPoints(const Json &amp;json) {
   result["routing1"]["end"] = json["end1"];
   result["routing2"]["start"] = json["start2"];
   result["routing2"]["end"] = json["end2"];
-  result["junctionPoints"] = json["junctionPoints"];
-  result["junctionId"] = json["junctionId"];
+  result["routing2"]["waypoint"] = json["routingPoint"];
   return result;
 }
 
@@ -558,6 +557,14 @@ bool SimulationWorldUpdater::ConstructRoutingRequest(
              &lt;&lt; start["heading"] &lt;&lt; " cannot locate start point on map.";
       return false;
     }
+  } else if (ContainsKey(start, "id")) {
+    if (!map_service_-&gt;ConstructLaneWayPointWithLaneId(
+            start["x"], start["y"], start["id"],
+            routing_request-&gt;add_waypoint())) {
+      AERROR &lt;&lt; "Failed to prepare a routing request with lane id: "
+             &lt;&lt; start["id"] &lt;&lt; " cannot locate end point on map.";
+      return false;
+    }
   } else {
     if (!map_service_-&gt;ConstructLaneWayPoint(start["x"], start["y"],
                                              routing_request-&gt;add_waypoint())) {
@@ -683,29 +690,6 @@ bool SimulationWorldUpdater::ConstructDeadJunctionRoutingTask(
               "junction routing task";
     return false;
   }
-  auto iter = json.find("junctionPoints");
-  if (iter == json.end() || !iter-&gt;is_array() ||
-      !ContainsKey(json, "junctionId")) {
-    AERROR &lt;&lt; "Failed to construct the dead end junction for dead end "
-              "junction routing task";
-    return false;
-  }
-  auto *dead_end_junction =
-      dead_junction_routing_task-&gt;mutable_dead_end_junction();
-  auto *polygon = dead_end_junction-&gt;mutable_polygon();
-  auto *points = polygon-&gt;mutable_point();
-  for (size_t i = 0; i &lt; iter-&gt;size(); i++) {
-    auto &amp;point = (*iter)[i];
-    auto *p = points-&gt;Add();
-    if (!ValidateCoordinate(point)) {
-      AERROR &lt;&lt; "Failed to construct the dead end junction: invalid waypoint.";
-      return false;
-    }
-    p-&gt;set_x(static_cast&lt;double&gt;(point["x"]));
-    p-&gt;set_y(static_cast&lt;double&gt;(point["y"]));
-  }
-  auto *id = dead_end_junction-&gt;mutable_id();
-  id-&gt;set_id(json["junctionId"]);
   return true;
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="be3f6737a852427e86ee826cf908fab53558d8e9" author="lijin18">
		<msg>DV:fix cpp lint error</msg>
		<modified_files>
			<file old_path="modules\task_manager\parking_routing_manager.cc" new_path="modules\task_manager\parking_routing_manager.cc" added_lines="9" deleted_lines="8">
				<diff>@@ -45,15 +45,16 @@ common::Status ParkingRoutingManager::Init(
 
 bool ParkingRoutingManager::SizeVerification(
         const ParkingRoutingTask&amp; parking_routing_task) {
-    auto plot_type =
-      parking_routing_task.routing_request().parking_info().parking_space_type();
-    const auto&amp; vehicle_config =
+  auto plot_type = parking_routing_task.routing_request()
+                       .parking_info()
+                       .parking_space_type();
+  const auto&amp; vehicle_config =
       common::VehicleConfigHelper::Instance()-&gt;GetConfig();
-    double ego_length = vehicle_config.vehicle_param().length();
-    double ego_width = vehicle_config.vehicle_param().width();
-    if (!has_space_ || !has_space_id_) {
-        AERROR &lt;&lt; "No Valid park plot exits!";
-        return false;
+  double ego_length = vehicle_config.vehicle_param().length();
+  double ego_width = vehicle_config.vehicle_param().width();
+  if (!has_space_ || !has_space_id_) {
+    AERROR &lt;&lt; "No Valid park plot exits!";
+    return false;
     }
     auto corner_point =
         parking_routing_task.routing_request().parking_info().corner_point();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="106dc4d9164a4055c6e8e432f41034f1e1b034b5" author="changsh726">
		<msg>Perception: Change OnReseiveImage to public to use it in simulation mode</msg>
		<modified_files>
			<file old_path="modules\perception\onboard\component\fusion_camera_detection_component.h" new_path="modules\perception\onboard\component\fusion_camera_detection_component.h" added_lines="2" deleted_lines="2">
				<diff>@@ -63,10 +63,10 @@ class FusionCameraDetectionComponent : public apollo::cyber::Component&lt;&gt; {
       const FusionCameraDetectionComponent&amp;) = delete;
 
   bool Init() override;
-
- private:
   void OnReceiveImage(const std::shared_ptr&lt;apollo::drivers::Image&gt;&amp; in_message,
                       const std::string&amp; camera_name);
+
+ private:
   int InitConfig();
   int InitSensorInfo();
   int InitAlgorithmPlugin();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5d5226a6c4078fd87a2ed743a8a3ebe3a59325fb" author="abel">
		<msg>dreamview: fix bug at sim control (#13727)

* dreamview: fix bug at sim control

InitStartPoint() can handle  using localization point and using dummy point.if localization is not empty, program will jump here.

* Update sim_control.h

* Update sim_control_interface.h

* Update sim_control.cc</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\sim_control\sim_control.cc" new_path="modules\dreamview\backend\sim_control\sim_control.cc" added_lines="3" deleted_lines="4">
				<diff>@@ -107,9 +107,9 @@ void SimControl::InitTimerAndIO() {
       false));
 }
 
-void SimControl::Init(bool set_start_point, double start_velocity,
+void SimControl::Init(double start_velocity,
                       double start_acceleration) {
-  if (set_start_point &amp;&amp; !FLAGS_use_navigation_mode) {
+  if (!FLAGS_use_navigation_mode) {
     InitStartPoint(start_velocity, start_acceleration);
   }
 }
@@ -252,8 +252,7 @@ void SimControl::Start() {
     // When localization is already available, we do not need to
     // reset/override the start point.
     localization_reader_-&gt;Observe();
-    Init(localization_reader_-&gt;Empty(),
-         next_point_.has_v() ? next_point_.v() : 0.0,
+    Init(next_point_.has_v() ? next_point_.v() : 0.0,
          next_point_.has_a() ? next_point_.a() : 0.0);
 
     InternalReset();
</diff>
			</file>
			<file old_path="modules\dreamview\backend\sim_control\sim_control.h" new_path="modules\dreamview\backend\sim_control\sim_control.h" added_lines="1" deleted_lines="1">
				<diff>@@ -62,7 +62,7 @@ class SimControl : SimControlInterface {
    * @brief setup callbacks and timer
    * @param set_start_point initialize localization.
    */
-  void Init(bool set_start_point, double start_velocity = 0.0,
+  void Init(double start_velocity = 0.0,
             double start_acceleration = 0.0) override;
 
   /**
</diff>
			</file>
			<file old_path="modules\dreamview\backend\sim_control\sim_control_interface.h" new_path="modules\dreamview\backend\sim_control\sim_control_interface.h" added_lines="1" deleted_lines="1">
				<diff>@@ -38,7 +38,7 @@ class SimControlInterface {
   /**
    * @brief Initialization.
    */
-  virtual void Init(bool set_start_point, double start_velocity = 0.0,
+  virtual void Init(double start_velocity = 0.0,
                     double start_acceleration = 0.0) = 0;
 
   /**
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="760944a73cc266355ea89dfb887ccebdf4424aaa" author="SeasoulChris">
		<msg>Perception: add gflag to make lidar height file could be specified (#13745)

* Revert "Perception: make lidar height file could be specified (#13226)"

This reverts commit 210996789bd564aa5fb2c223d5c976dcf1455dfa.

* add gflag to make lidar height could be specified</msg>
		<modified_files>
			<file old_path="modules\perception\common\perception_gflags.cc" new_path="modules\perception\common\perception_gflags.cc" added_lines="4" deleted_lines="0">
				<diff>@@ -117,5 +117,9 @@ DEFINE_string(torch_detector_model,
               "/apollo/modules/perception/camera"
               "/lib/obstacle/detector/yolov4/model/yolov4.pt",
               "The torch model file for emergency detection");
+
+// lidar sensor name
+DEFINE_string(lidar_sensor_name, "velodyne128",
+              "lidar sensor name");
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\common\perception_gflags.h" new_path="modules\perception\common\perception_gflags.h" added_lines="3" deleted_lines="0">
				<diff>@@ -67,5 +67,8 @@ DECLARE_int32(num_classes);
 
 // emergency detection libtorch
 DECLARE_string(torch_detector_model);
+
+// lidar sensor name
+DECLARE_string(lidar_sensor_name);
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_camera_detection_component.cc" new_path="modules\perception\onboard\component\fusion_camera_detection_component.cc" added_lines="37" deleted_lines="43">
				<diff>@@ -65,6 +65,39 @@ static int GetGpuId(const camera::CameraPerceptionInitOptions &amp;options) {
   return perception_param.gpu_id();
 }
 
+bool SetCameraHeight(const std::string &amp;sensor_name,
+                     const std::string &amp;params_dir,
+                     const std::string &amp;lidar_sensor_name,
+                     float default_camera_height,
+                     float *camera_height) {
+  float base_h = default_camera_height;
+  float camera_offset = 0.0f;
+  try {
+    YAML::Node lidar_height =
+        YAML::LoadFile(
+          params_dir + "/" + lidar_sensor_name + "_height.yaml");
+    base_h = lidar_height["vehicle"]["parameters"]["height"].as&lt;float&gt;();
+    AINFO &lt;&lt; base_h;
+    YAML::Node camera_ex =
+        YAML::LoadFile(params_dir + "/" + sensor_name + "_extrinsics.yaml");
+    camera_offset = camera_ex["transform"]["translation"]["z"].as&lt;float&gt;();
+    AINFO &lt;&lt; camera_offset;
+    *camera_height = base_h + camera_offset;
+  } catch (YAML::InvalidNode &amp;in) {
+    AERROR &lt;&lt; "load camera extrisic file error, YAML::InvalidNode exception";
+    return false;
+  } catch (YAML::TypedBadConversion&lt;float&gt; &amp;bc) {
+    AERROR &lt;&lt; "load camera extrisic file error, "
+           &lt;&lt; "YAML::TypedBadConversion exception";
+    return false;
+  } catch (YAML::Exception &amp;e) {
+    AERROR &lt;&lt; "load camera extrisic file "
+           &lt;&lt; " error, YAML exception:" &lt;&lt; e.what();
+    return false;
+  }
+  return true;
+}
+
 // @description: load camera extrinsics from yaml file
 bool LoadExtrinsics(const std::string &amp;yaml_file,
                     Eigen::Matrix4d *camera_extrinsic) {
@@ -202,9 +235,9 @@ bool FusionCameraDetectionComponent::Init() {
   // load in lidar to imu extrinsic
   Eigen::Matrix4d ex_lidar2imu;
   LoadExtrinsics(FLAGS_obs_sensor_intrinsic_path + "/" +
-                     "velodyne128_novatel_extrinsics.yaml",
+                     FLAGS_lidar_sensor_name + "_novatel_extrinsics.yaml",
                  &amp;ex_lidar2imu);
-  AINFO &lt;&lt; "velodyne128_novatel_extrinsics: " &lt;&lt; ex_lidar2imu;
+  AINFO &lt;&lt; FLAGS_lidar_sensor_name + "_novatel_extrinsics.yaml" &lt;&lt; ex_lidar2imu;
 
   ACHECK(visualize_.Init_all_info_single_camera(
       camera_names_, visual_camera_, intrinsic_map_, extrinsic_map_,
@@ -522,7 +555,8 @@ int FusionCameraDetectionComponent::InitCameraFrames() {
   for (const auto &amp;camera_name : camera_names_) {
     float height = 0.0f;
     SetCameraHeight(camera_name, FLAGS_obs_sensor_intrinsic_path,
-                    default_camera_height_, &amp;height);
+                    FLAGS_lidar_sensor_name, default_camera_height_,
+                    &amp;height);
     camera_height_map_[camera_name] = height;
   }
 
@@ -1111,46 +1145,6 @@ int FusionCameraDetectionComponent::MakeCameraDebugMsg(
   return cyber::SUCC;
 }
 
-bool FusionCameraDetectionComponent::SetCameraHeight(
-     const std::string &amp;sensor_name,
-     const std::string &amp;params_dir, float default_camera_height,
-     float *camera_height) {
-  float base_height = default_camera_height;
-  float camera_offset = 0.0f;
-
-  apollo::perception::onboard::FusionCameraDetection
-  fusion_camera_detection_param;
-  if (!GetProtoConfig(&amp;fusion_camera_detection_param)) {
-    AINFO &lt;&lt; "load fusion camera detection component proto param failed";
-    return false;
-  }
-  std::string lidar_type =
-      fusion_camera_detection_param.lidar_type();
-  try {
-    YAML::Node lidar_height =
-        YAML::LoadFile(params_dir + "/" + lidar_type + "_height.yaml");
-    base_height = lidar_height["vehicle"]["parameters"]["height"].as&lt;float&gt;();
-    AINFO &lt;&lt; base_height;
-    YAML::Node camera_ex =
-        YAML::LoadFile(params_dir + "/" + sensor_name + "_extrinsics.yaml");
-    camera_offset = camera_ex["transform"]["translation"]["z"].as&lt;float&gt;();
-    AINFO &lt;&lt; camera_offset;
-    *camera_height = base_height + camera_offset;
-  } catch (YAML::InvalidNode &amp;in) {
-    AERROR &lt;&lt; "load camera extrisic file error, YAML::InvalidNode exception";
-    return false;
-  } catch (YAML::TypedBadConversion&lt;float&gt; &amp;bc) {
-    AERROR &lt;&lt; "load camera extrisic file error, "
-           &lt;&lt; "YAML::TypedBadConversion exception";
-    return false;
-  } catch (YAML::Exception &amp;e) {
-    AERROR &lt;&lt; "load camera extrisic file "
-           &lt;&lt; " error, YAML exception:" &lt;&lt; e.what();
-    return false;
-  }
-  return true;
-}
-
 }  // namespace onboard
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_camera_detection_component.h" new_path="modules\perception\onboard\component\fusion_camera_detection_component.h" added_lines="0" deleted_lines="4">
				<diff>@@ -76,10 +76,6 @@ class FusionCameraDetectionComponent : public apollo::cyber::Component&lt;&gt; {
   int InitMotionService();
   void SetCameraHeightAndPitch();
   void OnMotionService(const MotionServiceMsgType&amp; message);
-  bool SetCameraHeight(
-       const std::string &amp;sensor_name,
-       const std::string &amp;params_dir, float default_camera_height,
-       float *camera_height);
 
   int InternalProc(
       const std::shared_ptr&lt;apollo::drivers::Image const&gt;&amp; in_message,
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\lane_detection_component.cc" new_path="modules\perception\onboard\component\lane_detection_component.cc" added_lines="7" deleted_lines="4">
				<diff>@@ -73,12 +73,13 @@ static int GetGpuId(const camera::CameraPerceptionInitOptions &amp;options) {
 
 static bool SetCameraHeight(const std::string &amp;sensor_name,
                             const std::string &amp;params_dir,
+                            const std::string &amp;lidar_sensor_name,
                             float default_camera_height, float *camera_height) {
   float base_h = default_camera_height;
   float camera_offset = 0.0f;
   try {
     YAML::Node lidar_height =
-        YAML::LoadFile(params_dir + "/" + "velodyne128_height.yaml");
+        YAML::LoadFile(params_dir + "/" + lidar_sensor_name + "_height.yaml");
     base_h = lidar_height["vehicle"]["parameters"]["height"].as&lt;float&gt;();
     AINFO &lt;&lt; base_h;
     YAML::Node camera_ex =
@@ -208,9 +209,10 @@ bool LaneDetectionComponent::Init() {
   // load in lidar to imu extrinsic
   Eigen::Matrix4d ex_lidar2imu;
   LoadExtrinsics(FLAGS_obs_sensor_intrinsic_path + "/" +
-                     "velodyne128_novatel_extrinsics.yaml",
+                     FLAGS_lidar_sensor_name + "_novatel_extrinsics.yaml",
                  &amp;ex_lidar2imu);
-  AINFO &lt;&lt; "velodyne128_novatel_extrinsics: " &lt;&lt; ex_lidar2imu;
+  AINFO &lt;&lt; FLAGS_lidar_sensor_name + "_novatel_extrinsics.yaml: "
+        &lt;&lt; ex_lidar2imu;
 
   ACHECK(visualize_.Init_all_info_single_camera(
       camera_names_, visual_camera_, intrinsic_map_, extrinsic_map_,
@@ -511,7 +513,8 @@ int LaneDetectionComponent::InitCameraFrames() {
   for (const auto &amp;camera_name : camera_names_) {
     float height = 0.0f;
     SetCameraHeight(camera_name, FLAGS_obs_sensor_intrinsic_path,
-                    default_camera_height_, &amp;height);
+                    FLAGS_lidar_sensor_name, default_camera_height_,
+                    &amp;height);
     camera_height_map_[camera_name] = height;
   }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="53e2c72da171abe3f27530f8313059eaa57d1adc" author="daohu527">
		<msg>control: delete redundant judgment conditions in set_gear_location</msg>
		<modified_files>
			<file old_path="modules\control\controller\lon_controller.cc" new_path="modules\control\controller\lon_controller.cc" added_lines="0" deleted_lines="1">
				<diff>@@ -359,7 +359,6 @@ Status LonController::ComputeControlCommand(
 
   if (std::fabs(injector_-&gt;vehicle_state()-&gt;linear_velocity()) &lt;=
           vehicle_param_.max_abs_speed_when_stopped() ||
-      chassis-&gt;gear_location() == trajectory_message_-&gt;gear() ||
       chassis-&gt;gear_location() == canbus::Chassis::GEAR_NEUTRAL) {
     cmd-&gt;set_gear_location(trajectory_message_-&gt;gear());
   } else {
</diff>
			</file>
			<file old_path="modules\control\controller\mpc_controller.cc" new_path="modules\control\controller\mpc_controller.cc" added_lines="0" deleted_lines="1">
				<diff>@@ -515,7 +515,6 @@ Status MPCController::ComputeControlCommand(
 
   if (std::fabs(vehicle_state-&gt;linear_velocity()) &lt;=
           vehicle_param_.max_abs_speed_when_stopped() ||
-      chassis-&gt;gear_location() == planning_published_trajectory-&gt;gear() ||
       chassis-&gt;gear_location() == canbus::Chassis::GEAR_NEUTRAL) {
     cmd-&gt;set_gear_location(planning_published_trajectory-&gt;gear());
   } else {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5b42ec849135e1f73001729027424bc5ff61354b" author="daohu527">
		<msg>localization: cyber_record_parser add decompresses multiple files</msg>
		<modified_files>
			<file old_path="modules\localization\msf\local_tool\data_extraction\cyber_record_parser.cc" new_path="modules\localization\msf\local_tool\data_extraction\cyber_record_parser.cc" added_lines="5" deleted_lines="4">
				<diff>@@ -29,7 +29,7 @@ using apollo::localization::msf::PCDExporter;
 int main(int argc, char **argv) {
   boost::program_options::options_description boost_desc("Allowed options");
   boost_desc.add_options()("help", "produce help message")(
-      "bag_file", boost::program_options::value&lt;std::string&gt;(),
+      "bag_files", boost::program_options::value&lt;std::vector&lt;std::string&gt;&gt;(),
       "provide the bag file")("out_folder",
                               boost::program_options::value&lt;std::string&gt;(),
                               "provide the output folder")(
@@ -60,13 +60,14 @@ int main(int argc, char **argv) {
       boost_args);
   boost::program_options::notify(boost_args);
 
-  if (boost_args.count("help") || !boost_args.count("bag_file") ||
+  if (boost_args.count("help") || !boost_args.count("bag_files") ||
       !boost_args.count("out_folder")) {
     AERROR &lt;&lt; boost_desc;
     return 0;
   }
 
-  const std::string bag_file = boost_args["bag_file"].as&lt;std::string&gt;();
+  const std::vector&lt;std::string&gt; bag_files =
+      boost_args["bag_files"].as&lt;std::vector&lt;std::string&gt;&gt;();
   const std::string pcd_folder =
       boost_args["out_folder"].as&lt;std::string&gt;() + "/pcd";
   if (!boost::filesystem::exists(pcd_folder)) {
@@ -108,7 +109,7 @@ int main(int argc, char **argv) {
     loc_exporter-&gt;OdometryLocCallback(msg);
   });
 
-  reader.Read(bag_file);
+  reader.Read(bag_files);
 
   return 0;
 }
</diff>
			</file>
			<file old_path="modules\localization\msf\local_tool\data_extraction\cyber_record_reader.cc" new_path="modules\localization\msf\local_tool\data_extraction\cyber_record_reader.cc" added_lines="9" deleted_lines="7">
				<diff>@@ -36,13 +36,15 @@ void CyberRecordReader::Subscribe(
   topics_.push_back(topic);
 }
 
-void CyberRecordReader::Read(const std::string &amp;file_name) {
-  RecordReader reader(file_name);
-  cyber::record::RecordMessage message;
-  while (reader.ReadMessage(&amp;message)) {
-    auto itr = call_back_map_.find(message.channel_name);
-    if (itr != call_back_map_.end()) {
-      itr-&gt;second(message.content);
+void CyberRecordReader::Read(const std::vector&lt;std::string&gt; &amp;file_names) {
+  for (const std::string &amp;file_name : file_names) {
+    RecordReader reader(file_name);
+    cyber::record::RecordMessage message;
+    while (reader.ReadMessage(&amp;message)) {
+      auto itr = call_back_map_.find(message.channel_name);
+      if (itr != call_back_map_.end()) {
+        itr-&gt;second(message.content);
+      }
     }
   }
 }
</diff>
			</file>
			<file old_path="modules\localization\msf\local_tool\data_extraction\cyber_record_reader.h" new_path="modules\localization\msf\local_tool\data_extraction\cyber_record_reader.h" added_lines="1" deleted_lines="1">
				<diff>@@ -36,7 +36,7 @@ class CyberRecordReader {
 
   void Subscribe(const std::string&amp; topic,
                  const std::function&lt;void(const std::string&amp;)&gt; call_back);
-  void Read(const std::string&amp; file_name);
+  void Read(const std::vector&lt;std::string&gt; &amp;file_names);
 
  private:
   std::vector&lt;std::string&gt; topics_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8bf9b28ee8bd81185c7a4f701dfa857967a66b1f" author="daohu527">
		<msg>localization: cyber_record_parser keep the original interface</msg>
		<modified_files>
			<file old_path="modules\localization\msf\local_tool\data_extraction\cyber_record_reader.cc" new_path="modules\localization\msf\local_tool\data_extraction\cyber_record_reader.cc" added_lines="12" deleted_lines="8">
				<diff>@@ -36,16 +36,20 @@ void CyberRecordReader::Subscribe(
   topics_.push_back(topic);
 }
 
+void CyberRecordReader::Read(const std::string &amp;file_name) {
+  RecordReader reader(file_name);
+  cyber::record::RecordMessage message;
+  while (reader.ReadMessage(&amp;message)) {
+    auto itr = call_back_map_.find(message.channel_name);
+    if (itr != call_back_map_.end()) {
+      itr-&gt;second(message.content);
+    }
+  }
+}
+
 void CyberRecordReader::Read(const std::vector&lt;std::string&gt; &amp;file_names) {
   for (const std::string &amp;file_name : file_names) {
-    RecordReader reader(file_name);
-    cyber::record::RecordMessage message;
-    while (reader.ReadMessage(&amp;message)) {
-      auto itr = call_back_map_.find(message.channel_name);
-      if (itr != call_back_map_.end()) {
-        itr-&gt;second(message.content);
-      }
-    }
+    Read(file_name);
   }
 }
 
</diff>
			</file>
			<file old_path="modules\localization\msf\local_tool\data_extraction\cyber_record_reader.h" new_path="modules\localization\msf\local_tool\data_extraction\cyber_record_reader.h" added_lines="1" deleted_lines="0">
				<diff>@@ -36,6 +36,7 @@ class CyberRecordReader {
 
   void Subscribe(const std::string&amp; topic,
                  const std::function&lt;void(const std::string&amp;)&gt; call_back);
+  void Read(const std::string&amp; file_name);
   void Read(const std::vector&lt;std::string&gt; &amp;file_names);
 
  private:
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="862ca310370b2fe8b99e25837d39901d636f598e" author="changsh726">
		<msg>Transform: adapts to simulation mode</msg>
		<modified_files>
			<file old_path="modules\perception\onboard\transform_wrapper\transform_wrapper.cc" new_path="modules\perception\onboard\transform_wrapper\transform_wrapper.cc" added_lines="10" deleted_lines="4">
				<diff>@@ -251,10 +251,16 @@ bool TransformWrapper::QueryTrans(double timestamp, StampedTransform* trans,
   if (!tf2_buffer_-&gt;canTransform(frame_id, child_frame_id, query_time,
                                  static_cast&lt;float&gt;(FLAGS_obs_tf2_buff_size),
                                  &amp;err_string)) {
-    AERROR &lt;&lt; "Can not find transform. " &lt;&lt; FORMAT_TIMESTAMP(timestamp)
-           &lt;&lt; " frame_id: " &lt;&lt; frame_id &lt;&lt; " child_frame_id: " &lt;&lt; child_frame_id
-           &lt;&lt; " Error info: " &lt;&lt; err_string;
-    return false;
+    // In simulation mode, use the latest transform information if query failed.
+    if (!cyber::common::GlobalData::Instance()-&gt;IsRealityMode()) {
+      query_time = cyber::Time(0);
+    } else {
+      AERROR &lt;&lt; "Can not find transform. " &lt;&lt; FORMAT_TIMESTAMP(timestamp)
+             &lt;&lt; " frame_id: " &lt;&lt; frame_id
+             &lt;&lt; " child_frame_id: " &lt;&lt; child_frame_id
+             &lt;&lt; " Error info: " &lt;&lt; err_string;
+      return false;
+    }
   }
 
   apollo::transform::TransformStamped stamped_transform;
</diff>
			</file>
			<file old_path="modules\transform\buffer.cc" new_path="modules\transform\buffer.cc" added_lines="3" deleted_lines="4">
				<diff>@@ -207,13 +207,12 @@ bool Buffer::canTransform(const std::string&amp; target_frame,
     if (retval) {
       return true;
     } else {
+      if (!cyber::common::GlobalData::Instance()-&gt;IsRealityMode()) {
+        break;
+      }
       const int sleep_time_ms = 3;
       AWARN &lt;&lt; "BufferCore::canTransform failed: " &lt;&lt; *errstr;
       std::this_thread::sleep_for(std::chrono::milliseconds(sleep_time_ms));
-      if (!cyber::common::GlobalData::Instance()-&gt;IsRealityMode()) {
-        Clock::SetNow(Time(Clock::Now().ToNanosecond() +
-                           sleep_time_ms * kMilliToNanoFactor));
-      }
     }
   }
   *errstr = *errstr + ":timeout";
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5342bd3f9067fef42f1af09508da454e05dc7a85" author="changsh726">
		<msg>Perception: Change OnReseiveImage to public to use it in simulation mode</msg>
		<modified_files>
			<file old_path="modules\perception\onboard\component\fusion_camera_detection_component.h" new_path="modules\perception\onboard\component\fusion_camera_detection_component.h" added_lines="2" deleted_lines="2">
				<diff>@@ -63,10 +63,10 @@ class FusionCameraDetectionComponent : public apollo::cyber::Component&lt;&gt; {
       const FusionCameraDetectionComponent&amp;) = delete;
 
   bool Init() override;
-
- private:
   void OnReceiveImage(const std::shared_ptr&lt;apollo::drivers::Image&gt;&amp; in_message,
                       const std::string&amp; camera_name);
+
+ private:
   int InitConfig();
   int InitSensorInfo();
   int InitAlgorithmPlugin();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="099a73a4d4e6040feb9dfe74720e3f81727b5e5d" author="lilu15">
		<msg>planning: add dead end task manager

Change-Id: I2328fc66962a53dafa3c2931e123b039b0b310f1</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -38,7 +38,7 @@ using apollo::hdmap::EndWayPointFile;
 using apollo::relative_map::NavigationInfo;
 using apollo::routing::RoutingRequest;
 using apollo::task_manager::CycleRoutingTask;
-using apollo::task_manager::DeadEndJunctionRoutingTask;
+using apollo::task_manager::DeadEndRoutingTask;
 using apollo::task_manager::ParkingRoutingTask;
 using apollo::task_manager::Task;
 
@@ -177,7 +177,7 @@ void SimulationWorldUpdater::RegisterMessageHandlers() {
         } else {
           auto task = std::make_shared&lt;Task&gt;();
           auto *dead_junction_routing_task =
-              task-&gt;mutable_dead_junction_routing_task();
+              task-&gt;mutable_dead_end_routing_task();
           bool succeed = ConstructDeadJunctionRoutingTask(
               result, dead_junction_routing_task);
           if (succeed) {
@@ -673,7 +673,7 @@ bool SimulationWorldUpdater::ConstructParkingRoutingTask(
 }
 
 bool SimulationWorldUpdater::ConstructDeadJunctionRoutingTask(
-    const Json &amp;json, DeadEndJunctionRoutingTask *dead_junction_routing_task) {
+    const Json &amp;json, DeadEndRoutingTask *dead_junction_routing_task) {
   auto *routing_request_in =
       dead_junction_routing_task-&gt;mutable_routing_request_in();
   bool succeed = ConstructRoutingRequest(json["routing1"], routing_request_in);
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_updater.h" new_path="modules\dreamview\backend\simulation_world\simulation_world_updater.h" added_lines="2" deleted_lines="2">
				<diff>@@ -120,8 +120,8 @@ class SimulationWorldUpdater {
    */
   bool ConstructDeadJunctionRoutingTask(
       const nlohmann::json &amp;json,
-      apollo::task_manager::DeadEndJunctionRoutingTask
-          *dead_junction_routing_task);
+      apollo::task_manager::DeadEndRoutingTask
+          *dead_end_routing_task);
 
   bool ValidateCoordinate(const nlohmann::json &amp;json);
 
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.cc" new_path="modules\task_manager\task_manager_component.cc" added_lines="9" deleted_lines="1">
				<diff>@@ -69,7 +69,8 @@ bool TaskManagerComponent::Init() {
 bool TaskManagerComponent::Proc(const std::shared_ptr&lt;Task&gt;&amp; task) {
   task_name_ = task-&gt;task_name();
   if (task-&gt;task_type() != CYCLE_ROUTING &amp;&amp;
-      task-&gt;task_type() != PARKING_ROUTING) {
+      task-&gt;task_type() != PARKING_ROUTING &amp;&amp;
+      task-&gt;task_type() != DEAD_END_ROUTING) {
     AERROR &lt;&lt; "Task type is not cycle_routing or parking_routing.";
     return false;
   }
@@ -135,6 +136,13 @@ bool TaskManagerComponent::Proc(const std::shared_ptr&lt;Task&gt;&amp; task) {
       AERROR &lt;&lt; "plot verification failed, please select suitable plot!";
       return false;
     }
+  } else if (task-&gt;task_type() == DEAD_END_ROUTING) {
+    AERROR &lt;&lt; "enter the turn around task";
+    dead_end_routing_manager_ = std::make_shared&lt;DeadEndRoutingManager&gt;();
+    dead_end_routing_manager_-&gt;Init(task-&gt;dead_end_routing_task());
+    routing_request_in_ = task-&gt;dead_end_routing_task().routing_request_in();
+    common::util::FillHeader(node_-&gt;Name(), &amp;routing_request_in_);
+    request_writer_-&gt;Write(routing_request_in_);
   }
   return true;
 }
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.h" new_path="modules\task_manager\task_manager_component.h" added_lines="4" deleted_lines="0">
				<diff>@@ -23,6 +23,7 @@
 #include "cyber/component/component.h"
 #include "modules/task_manager/cycle_routing_manager.h"
 #include "modules/task_manager/parking_routing_manager.h"
+#include "modules/task_manager/dead_end_routing_manager.h"
 namespace apollo {
 namespace task_manager {
 
@@ -43,7 +44,10 @@ class TaskManagerComponent final : public cyber::Component&lt;task_manager::Task&gt; {
   std::shared_ptr&lt;cyber::Writer&lt;routing::RoutingRequest&gt;&gt; request_writer_;
   std::shared_ptr&lt;CycleRoutingManager&gt; cycle_routing_manager_;
   std::shared_ptr&lt;ParkingRoutingManager&gt; parking_routing_manager_;
+  std::shared_ptr&lt;DeadEndRoutingManager&gt; dead_end_routing_manager_;
   routing::RoutingRequest routing_request_;
+  routing::RoutingRequest routing_request_in_;
+  routing::RoutingRequest routing_request_out_;
   routing::RoutingResponse routing_response_;
   LocalizationEstimate localization_;
   std::mutex mutex_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="86bfafdd0c7af90160cc2d87ccb5c5c11f2d4317" author="changsh726">
		<msg>Tools: reordered file structure</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\hmi\hmi_worker.cc" new_path="modules\dreamview\backend\hmi\hmi_worker.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -462,7 +462,8 @@ void HMIWorker::SubmitDriveEvent(const uint64_t event_time_ms,
 
 void HMIWorker::SensorCalibrationPreprocess(const std::string&amp; task_type) {
   std::string start_command = absl::StrCat(
-      "nohup bash /apollo/scripts/extract_data.sh -t ", task_type, " &amp;");
+      "nohup bash /apollo/modules/tools/sensor_calibration/extract_data.sh -t ",
+      task_type, " &amp;");
   System(start_command);
 }
 
</diff>
			</file>
			<file old_path="docs\Apollo_Fuel\examples\sensor_calibration\camera_to_lidar\camera_to_lidar.config" new_path="modules\tools\sensor_calibration\template\camera_to_lidar\camera_to_lidar.config" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="docs\Apollo_Fuel\examples\sensor_calibration\lidar_to_gnss\lidar_to_gnss.config" new_path="modules\tools\sensor_calibration\template\lidar_to_gnss\lidar_to_gnss.config" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="289d8935d018487ea096a8ccb57f5e84efc39247" author="fuyiqun">
		<msg>prediction: change category encoding to labeling

Change-Id: Id223749ab530b3068d5e0e4363f662d709bb4cb1</msg>
		<modified_files>
			<file old_path="modules\prediction\pipeline\vector_net.cc" new_path="modules\prediction\pipeline\vector_net.cc" added_lines="22" deleted_lines="10">
				<diff>@@ -29,8 +29,8 @@ template &lt;typename Points&gt;
 void VectorNet::GetOnePolyline(
                           const Points&amp; points, double *start_length,
                           const common::PointENU&amp; center_point,
-                          const double obstacle_phi,
-                          ATTRIBUTE_TYPE attr_type, const int count,
+                          const double obstacle_phi, ATTRIBUTE_TYPE attr_type,
+                          BOUNDARY_TYPE bound_type, const int count,
                           std::vector&lt;std::vector&lt;double&gt;&gt;* const one_polyline,
                           std::vector&lt;double&gt;* const one_p_id) {
   size_t size = points.size();
@@ -68,7 +68,8 @@ void VectorNet::GetOnePolyline(
 
   *start_length = cur_length - s[size - 1];
   if (point_size == 0) return;
-  const std::vector&lt;double&gt;&amp; attr = attribute_map.at(attr_type);
+  const double attr = attribute_map.at(attr_type);
+  const double bound = boundary_map.at(bound_type);
   auto last_point_after_rotate = common::math::RotateVector2d(
     {x[0] - center_point.x(), y[0] - center_point.y()},
     M_PI_2 - obstacle_phi);
@@ -96,7 +97,7 @@ void VectorNet::GetOnePolyline(
     last_point_after_rotate = std::move(point_after_rotate);
 
     // attribute
-    one_vector.insert(one_vector.end(), attr.begin(), attr.end());
+    one_vector.insert(one_vector.end(), {0.0, 0.0, attr, bound});
 
     one_vector.push_back(count);
     one_polyline-&gt;push_back(std::move(one_vector));
@@ -164,10 +165,21 @@ void VectorNet::GetRoads(const common::PointENU&amp; center_point,
         std::vector&lt;double&gt; one_p_id{std::numeric_limits&lt;float&gt;::max(),
                                      std::numeric_limits&lt;float&gt;::max()};
         double start_length = 0;
+        BOUNDARY_TYPE bound_type = UNKNOW;
+        if (edge.type() == hdmap::BoundaryEdge::LEFT_BOUNDARY) {
+          bound_type = LEFT_BOUNDARY;
+        } else if (edge.type() == hdmap::BoundaryEdge::RIGHT_BOUNDARY) {
+          bound_type = RIGHT_BOUNDARY;
+        } else if (edge.type() == hdmap::BoundaryEdge::NORMAL) {
+          bound_type = NORMAL;
+        } else {
+          bound_type = UNKNOW;
+        }
+
         for (const auto&amp; segment : edge.curve().segment()) {
           GetOnePolyline(segment.line_segment().point(), &amp;start_length,
-                         center_point, obstacle_phi, ROAD, count_,
-                         &amp;one_polyline, &amp;one_p_id);
+                         center_point, obstacle_phi, ROAD, bound_type,
+                         count_, &amp;one_polyline, &amp;one_p_id);
         }
         if (one_polyline.size() == 0) continue;
 
@@ -242,7 +254,7 @@ void VectorNet::GetLanes(const common::PointENU&amp; center_point,
           lane-&gt;lane().left_boundary().boundary_type(0).types(0);
         GetOnePolyline(segment.line_segment().point(), &amp;start_length,
                        center_point, obstacle_phi, lane_attr_map.at(bound_type),
-                       count_, &amp;left_polyline, &amp;left_p_id);
+                       LEFT_BOUNDARY, count_, &amp;left_polyline, &amp;left_p_id);
       }
     }
 
@@ -264,7 +276,7 @@ void VectorNet::GetLanes(const common::PointENU&amp; center_point,
           lane-&gt;lane().left_boundary().boundary_type(0).types(0);
         GetOnePolyline(segment.line_segment().point(), &amp;start_length,
                        center_point, obstacle_phi, lane_attr_map.at(bound_type),
-                       count_, &amp;right_polyline, &amp;right_p_id);
+                       RIGHT_BOUNDARY, count_, &amp;right_polyline, &amp;right_p_id);
       }
     }
 
@@ -288,7 +300,7 @@ void VectorNet::GetJunctions(const common::PointENU&amp; center_point,
                                  std::numeric_limits&lt;float&gt;::max()};
     double start_length = 0;
     GetOnePolyline(junction-&gt;junction().polygon().point(), &amp;start_length,
-                   center_point, obstacle_phi, JUNCTION, count_,
+                   center_point, obstacle_phi, JUNCTION, UNKNOW, count_,
                    &amp;one_polyline, &amp;one_p_id);
 
     feature_ptr-&gt;push_back(std::move(one_polyline));
@@ -310,7 +322,7 @@ void VectorNet::GetCrosswalks(const common::PointENU&amp; center_point,
                                  std::numeric_limits&lt;float&gt;::max()};
     double start_length = 0;
     GetOnePolyline(crosswalk-&gt;crosswalk().polygon().point(), &amp;start_length,
-                   center_point, obstacle_phi, CROSSWALK, count_,
+                   center_point, obstacle_phi, CROSSWALK, UNKNOW, count_,
                    &amp;one_polyline, &amp;one_p_id);
 
     feature_ptr-&gt;push_back(std::move(one_polyline));
</diff>
			</file>
			<file old_path="modules\prediction\pipeline\vector_net.h" new_path="modules\prediction\pipeline\vector_net.h" added_lines="27" deleted_lines="13">
				<diff>@@ -45,6 +45,13 @@ enum ATTRIBUTE_TYPE {
   CROSSWALK,
 };
 
+enum BOUNDARY_TYPE {
+  UNKNOW,
+  NORMAL,
+  LEFT_BOUNDARY,
+  RIGHT_BOUNDARY,
+};
+
 class VectorNet {
  public:
   VectorNet() = default;
@@ -59,17 +66,24 @@ class VectorNet {
 
  private:
   // TODO(Yiqun): 1.Left/Right boundary 2.Ordinal Encoding
-  const std::map&lt;ATTRIBUTE_TYPE, std::vector&lt;double&gt;&gt; attribute_map{
-    {ROAD, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
-    {LANE_UNKOWN, {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
-    {LANE_DOTTED_YELLOW, {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}},
-    {LANE_DOTTED_WHITE, {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}},
-    {LANE_SOLID_YELLOW, {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}},
-    {LANE_SOLID_WHITE, {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}},
-    {LANE_DOUBLE_YELLOW, {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}},
-    {LANE_CURB, {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0}},
-    {JUNCTION, {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}},
-    {CROSSWALK, {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}},
+  const std::map&lt;ATTRIBUTE_TYPE, double&gt; attribute_map{
+    {ROAD, 0.0},
+    {LANE_UNKOWN, 1.0},
+    {LANE_DOTTED_YELLOW, 2.0},
+    {LANE_DOTTED_WHITE, 3.0},
+    {LANE_SOLID_YELLOW, 4.0},
+    {LANE_SOLID_WHITE, 5.0},
+    {LANE_DOUBLE_YELLOW, 6.0},
+    {LANE_CURB, 7.0},
+    {JUNCTION, 8.0},
+    {CROSSWALK, 9.0},
+  };
+
+  const std::map&lt;BOUNDARY_TYPE, double&gt; boundary_map{
+    {UNKNOW, 0.0},
+    {NORMAL, 1.0},
+    {LEFT_BOUNDARY, 2.0},
+    {RIGHT_BOUNDARY, 3.0},
   };
 
   const std::map&lt;hdmap::LaneBoundaryType::Type, ATTRIBUTE_TYPE&gt; lane_attr_map{
@@ -85,8 +99,8 @@ class VectorNet {
   template &lt;typename Points&gt;
   void GetOnePolyline(const Points&amp; points, double *start_length,
                      const common::PointENU&amp; center_point,
-                     const double obstacle_phi,
-                     ATTRIBUTE_TYPE attr_type, const int count,
+                     const double obstacle_phi, ATTRIBUTE_TYPE attr_type,
+                     BOUNDARY_TYPE bound_type, const int count,
                      std::vector&lt;std::vector&lt;double&gt;&gt;* const one_polyline,
                      std::vector&lt;double&gt;* const one_p_id);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9120b75d4acd5ad4673eb59ede1657ec8ea82804" author="changsh726">
		<msg>Tools: reordered file structure</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\hmi\hmi_worker.cc" new_path="modules\dreamview\backend\hmi\hmi_worker.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -462,7 +462,8 @@ void HMIWorker::SubmitDriveEvent(const uint64_t event_time_ms,
 
 void HMIWorker::SensorCalibrationPreprocess(const std::string&amp; task_type) {
   std::string start_command = absl::StrCat(
-      "nohup bash /apollo/scripts/extract_data.sh -t ", task_type, " &amp;");
+      "nohup bash /apollo/modules/tools/sensor_calibration/extract_data.sh -t ",
+      task_type, " &amp;");
   System(start_command);
 }
 
</diff>
			</file>
			<file old_path="docs\Apollo_Fuel\examples\sensor_calibration\camera_to_lidar\camera_to_lidar.config" new_path="modules\tools\sensor_calibration\template\camera_to_lidar\camera_to_lidar.config" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="docs\Apollo_Fuel\examples\sensor_calibration\lidar_to_gnss\lidar_to_gnss.config" new_path="modules\tools\sensor_calibration\template\lidar_to_gnss\lidar_to_gnss.config" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d37a371cba0437c2eec13ba962af773f1f4e0948" author="haina0421">
		<msg>add base_pointcloud_preprocessor and re-write inheritance methods</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" new_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" added_lines="7" deleted_lines="4">
				<diff>@@ -43,11 +43,14 @@ bool LidarObstacleDetection::Init(
 
   LidarObstacleDetectionConfig config;
   ACHECK(cyber::common::GetProtoFromFile(config_file, &amp;config));
-  detector_name_ = config.detector();
 
+  BasePointCloudPreprocessor* preprocessor =
+      BasePointCloudPreprocessorRegisterer::GetInstanceByName(config.preprocessor());
+  CHECK_NOTNULL(preprocessor);
+  cloud_preprocessor_.reset(preprocessor);
   PointCloudPreprocessorInitOptions preprocessor_init_options;
   preprocessor_init_options.sensor_name = sensor_name;
-  ACHECK(cloud_preprocessor_.Init(preprocessor_init_options));
+  ACHECK(cloud_preprocessor_-&gt;Init(preprocessor_init_options)) &lt;&lt; "lidar preprocessor init error";
 
   detector_.reset(new PointPillarsDetection);
   // detector_.reset(
@@ -65,7 +68,7 @@ LidarProcessResult LidarObstacleDetection::Process(
   PointCloudPreprocessorOptions preprocessor_options;
   preprocessor_options.sensor2novatel_extrinsics =
       options.sensor2novatel_extrinsics;
-  if (cloud_preprocessor_.Preprocess(preprocessor_options, frame)) {
+  if (cloud_preprocessor_-&gt;Preprocess(preprocessor_options, frame)) {
     return ProcessCommon(options, frame);
   }
   return LidarProcessResult(LidarErrorCode::PointCloudPreprocessorError,
@@ -85,7 +88,7 @@ LidarProcessResult LidarObstacleDetection::Process(
   preprocessor_options.sensor2novatel_extrinsics =
       options.sensor2novatel_extrinsics;
   PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "preprocess");
-  if (cloud_preprocessor_.Preprocess(preprocessor_options, message, frame)) {
+  if (cloud_preprocessor_-&gt;Preprocess(preprocessor_options, message, frame)) {
     return ProcessCommon(options, frame);
   }
   return LidarProcessResult(LidarErrorCode::PointCloudPreprocessorError,
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.h" new_path="modules\perception\lidar\app\lidar_obstacle_detection.h" added_lines="3" deleted_lines="5">
				<diff>@@ -22,7 +22,7 @@
 
 #include "modules/perception/lidar/common/lidar_error_code.h"
 #include "modules/perception/lidar/lib/detection/lidar_point_pillars/point_pillars_detection.h"
-#include "modules/perception/lidar/lib/pointcloud_preprocessor/pointcloud_preprocessor.h"
+#include "modules/perception/lidar/lib/interface/base_pointcloud_preprocessor.h"
 
 namespace apollo {
 namespace perception {
@@ -62,10 +62,8 @@ class LidarObstacleDetection {
                                    LidarFrame* frame);
 
  private:
-  PointCloudPreprocessor cloud_preprocessor_;
-  std::unique_ptr&lt;PointPillarsDetection&gt; detector_;
-  // params
-  std::string detector_name_;
+  std::shared_ptr&lt;BasePointCloudPreprocessor&gt; cloud_preprocessor_;
+  std::shared_ptr&lt;PointPillarsDetection&gt; detector_;
 };  // class LidarObstacleDetection
 
 }  // namespace lidar
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" new_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" added_lines="15" deleted_lines="10">
				<diff>@@ -44,7 +44,6 @@ bool LidarObstacleSegmentation::Init(
 
   LidarObstacleSegmentationConfig config;
   ACHECK(cyber::common::GetProtoFromFile(config_file, &amp;config));
-  segmentor_name_ = config.segmentor();
   use_map_manager_ = config.use_map_manager();
   use_object_filter_bank_ = config.use_object_filter_bank();
 
@@ -53,10 +52,6 @@ bool LidarObstacleSegmentation::Init(
   SceneManagerInitOptions scene_manager_init_options;
   ACHECK(SceneManager::Instance().Init(scene_manager_init_options));
 
-  PointCloudPreprocessorInitOptions preprocessor_init_options;
-  preprocessor_init_options.sensor_name = sensor_name;
-  ACHECK(cloud_preprocessor_.Init(preprocessor_init_options));
-
   if (use_map_manager_) {
     MapManagerInitOptions map_manager_init_options;
     if (!map_manager_.Init(map_manager_init_options)) {
@@ -65,11 +60,21 @@ bool LidarObstacleSegmentation::Init(
     }
   }
 
-  segmentor_ = BaseSegmentationRegisterer::GetInstanceByName(segmentor_name_);
-  CHECK_NOTNULL(segmentor_);
+  BasePointCloudPreprocessor* preprocessor =
+      BasePointCloudPreprocessorRegisterer::GetInstanceByName(config.preprocessor());
+  CHECK_NOTNULL(preprocessor);
+  cloud_preprocessor_.reset(preprocessor);
+  PointCloudPreprocessorInitOptions preprocessor_init_options;
+  preprocessor_init_options.sensor_name = sensor_name;
+  ACHECK(cloud_preprocessor_-&gt;Init(preprocessor_init_options)) &lt;&lt; "lidar preprocessor init error";
+
+  BaseSegmentation* segmentor =
+      BaseSegmentationRegisterer::GetInstanceByName(config.segmentor());
+  CHECK_NOTNULL(segmentor);
+  segmentor_.reset(segmentor);
   SegmentationInitOptions segmentation_init_options;
   segmentation_init_options.sensor_name = sensor_name;
-  ACHECK(segmentor_-&gt;Init(segmentation_init_options));
+  ACHECK(segmentor_-&gt;Init(segmentation_init_options)) &lt;&lt; "lidar segmentor init error";
 
   ObjectBuilderInitOptions builder_init_options;
   ACHECK(builder_.Init(builder_init_options));
@@ -88,7 +93,7 @@ LidarProcessResult LidarObstacleSegmentation::Process(
   PointCloudPreprocessorOptions preprocessor_options;
   preprocessor_options.sensor2novatel_extrinsics =
       options.sensor2novatel_extrinsics;
-  if (cloud_preprocessor_.Preprocess(preprocessor_options, frame)) {
+  if (cloud_preprocessor_-&gt;Preprocess(preprocessor_options, frame)) {
     return ProcessCommon(options, frame);
   }
   return LidarProcessResult(LidarErrorCode::PointCloudPreprocessorError,
@@ -108,7 +113,7 @@ LidarProcessResult LidarObstacleSegmentation::Process(
   preprocessor_options.sensor2novatel_extrinsics =
       options.sensor2novatel_extrinsics;
   PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "preprocess");
-  if (cloud_preprocessor_.Preprocess(preprocessor_options, message, frame)) {
+  if (cloud_preprocessor_-&gt;Preprocess(preprocessor_options, message, frame)) {
     return ProcessCommon(options, frame);
   }
   return LidarProcessResult(LidarErrorCode::PointCloudPreprocessorError,
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.h" new_path="modules\perception\lidar\app\lidar_obstacle_segmentation.h" added_lines="3" deleted_lines="4">
				<diff>@@ -26,7 +26,7 @@
 #include "modules/perception/lidar/lib/map_manager/map_manager.h"
 #include "modules/perception/lidar/lib/object_builder/object_builder.h"
 #include "modules/perception/lidar/lib/object_filter_bank/object_filter_bank.h"
-#include "modules/perception/lidar/lib/pointcloud_preprocessor/pointcloud_preprocessor.h"
+#include "modules/perception/lidar/lib/interface/base_pointcloud_preprocessor.h"
 
 namespace apollo {
 namespace perception {
@@ -67,13 +67,12 @@ class LidarObstacleSegmentation {
       const LidarObstacleSegmentationOptions&amp; options, LidarFrame* frame);
 
  private:
-  PointCloudPreprocessor cloud_preprocessor_;
+  std::shared_ptr&lt;BasePointCloudPreprocessor&gt; cloud_preprocessor_;
   MapManager map_manager_;
-  BaseSegmentation* segmentor_;
+  std::shared_ptr&lt;BaseSegmentation&gt; segmentor_;
   ObjectBuilder builder_;
   ObjectFilterBank filter_bank_;
   // params
-  std::string segmentor_name_;
   bool use_map_manager_ = true;
   bool use_object_filter_bank_ = true;
 };  // class LidarObstacleSegmentation
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\pointcloud_preprocessor\pointcloud_preprocessor.h" new_path="modules\perception\lidar\lib\pointcloud_preprocessor\pointcloud_preprocessor.h" added_lines="6" deleted_lines="26">
				<diff>@@ -16,51 +16,31 @@
 #pragma once
 
 #include &lt;memory&gt;
-#include &lt;string&gt;
 
-#include "modules/drivers/proto/pointcloud.pb.h"
-#include "modules/perception/lidar/common/lidar_frame.h"
+#include "modules/perception/lidar/lib/interface/base_pointcloud_preprocessor.h"
 
 namespace apollo {
 namespace perception {
 namespace lidar {
 
-struct PointCloudPreprocessorInitOptions {
-  std::string sensor_name = "velodyne64";
-};
-
-struct PointCloudPreprocessorOptions {
-  Eigen::Affine3d sensor2novatel_extrinsics;
-
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-} EIGEN_ALIGN16;
-
-class PointCloudPreprocessor {
+class PointCloudPreprocessor : public BasePointCloudPreprocessor {
  public:
   PointCloudPreprocessor() = default;
 
   ~PointCloudPreprocessor() = default;
 
   bool Init(const PointCloudPreprocessorInitOptions&amp; options =
-                PointCloudPreprocessorInitOptions());
+                PointCloudPreprocessorInitOptions()) override;
 
-  // @brief: preprocess point cloud
-  // @param [in]: options
-  // @param [in]: point cloud message
-  // @param [in/out]: frame
-  // cloud should be filled, required,
   bool Preprocess(
       const PointCloudPreprocessorOptions&amp; options,
       const std::shared_ptr&lt;apollo::drivers::PointCloud const&gt;&amp; message,
-      LidarFrame* frame) const;
+      LidarFrame* frame) const override;
 
-  // @brief: preprocess point cloud
-  // @param [in/out]: frame
-  // cloud should be filled, required,
   bool Preprocess(const PointCloudPreprocessorOptions&amp; options,
-                  LidarFrame* frame) const;
+                  LidarFrame* frame) const override;
 
-  std::string Name() const { return "PointCloudPreprocessor"; }
+  std::string Name() const override { return "PointCloudPreprocessor"; }
 
  private:
   bool TransformCloud(const base::PointFCloudPtr&amp; local_cloud,
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="45387782f38399af3f1f446c67dd533e6a94213d" author="haina0421">
		<msg>add base_lidar_detector, remove base_segmentation and update inheritance</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" new_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" added_lines="8" deleted_lines="8">
				<diff>@@ -52,13 +52,13 @@ bool LidarObstacleDetection::Init(
   preprocessor_init_options.sensor_name = sensor_name;
   ACHECK(cloud_preprocessor_-&gt;Init(preprocessor_init_options)) &lt;&lt; "lidar preprocessor init error";
 
-  detector_.reset(new PointPillarsDetection);
-  // detector_.reset(
-  //    BaseSegmentationRegisterer::GetInstanceByName(segmentor_name_));
-  CHECK_NOTNULL(detector_.get());
-  DetectionInitOptions detection_init_options;
-  // segmentation_init_options.sensor_name = sensor_name;
-  ACHECK(detector_-&gt;Init(detection_init_options));
+  BaseLidarDetector* detector =
+      BaseLidarDetectorRegisterer::GetInstanceByName(config.detector());
+  CHECK_NOTNULL(detector);
+  detector_.reset(detector);
+  LidarDetectorInitOptions detection_init_options;
+  detection_init_options.sensor_name = sensor_name;
+  ACHECK(detector_-&gt;Init(detection_init_options)) &lt;&lt; "lidar detector init error";
 
   return true;
 }
@@ -100,7 +100,7 @@ LidarProcessResult LidarObstacleDetection::ProcessCommon(
   const auto&amp; sensor_name = options.sensor_name;
 
   PERF_BLOCK_START();
-  DetectionOptions detection_options;
+  LidarDetectorOptions detection_options;
   if (!detector_-&gt;Detect(detection_options, frame)) {
     return LidarProcessResult(LidarErrorCode::DetectionError,
                               "Failed to detect.");
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.h" new_path="modules\perception\lidar\app\lidar_obstacle_detection.h" added_lines="2" deleted_lines="2">
				<diff>@@ -21,8 +21,8 @@
 #include "Eigen/Dense"
 
 #include "modules/perception/lidar/common/lidar_error_code.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/point_pillars_detection.h"
 #include "modules/perception/lidar/lib/interface/base_pointcloud_preprocessor.h"
+#include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
 
 namespace apollo {
 namespace perception {
@@ -63,7 +63,7 @@ class LidarObstacleDetection {
 
  private:
   std::shared_ptr&lt;BasePointCloudPreprocessor&gt; cloud_preprocessor_;
-  std::shared_ptr&lt;PointPillarsDetection&gt; detector_;
+  std::shared_ptr&lt;BaseLidarDetector&gt; detector_;
 };  // class LidarObstacleDetection
 
 }  // namespace lidar
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" new_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" added_lines="5" deleted_lines="5">
				<diff>@@ -68,11 +68,11 @@ bool LidarObstacleSegmentation::Init(
   preprocessor_init_options.sensor_name = sensor_name;
   ACHECK(cloud_preprocessor_-&gt;Init(preprocessor_init_options)) &lt;&lt; "lidar preprocessor init error";
 
-  BaseSegmentation* segmentor =
-      BaseSegmentationRegisterer::GetInstanceByName(config.segmentor());
+  BaseLidarDetector* segmentor =
+      BaseLidarDetectorRegisterer::GetInstanceByName(config.segmentor());
   CHECK_NOTNULL(segmentor);
   segmentor_.reset(segmentor);
-  SegmentationInitOptions segmentation_init_options;
+  LidarDetectorInitOptions segmentation_init_options;
   segmentation_init_options.sensor_name = sensor_name;
   ACHECK(segmentor_-&gt;Init(segmentation_init_options)) &lt;&lt; "lidar segmentor init error";
 
@@ -134,8 +134,8 @@ LidarProcessResult LidarObstacleSegmentation::ProcessCommon(
   }
   PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "map_manager");
 
-  SegmentationOptions segmentation_options;
-  if (!segmentor_-&gt;Segment(segmentation_options, frame)) {
+  LidarDetectorOptions segmentation_options;
+  if (!segmentor_-&gt;Detect(segmentation_options, frame)) {
     return LidarProcessResult(LidarErrorCode::SegmentationError,
                               "Failed to segment.");
   }
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.h" new_path="modules\perception\lidar\app\lidar_obstacle_segmentation.h" added_lines="2" deleted_lines="2">
				<diff>@@ -22,7 +22,7 @@
 
 #include "modules/perception/lidar/common/lidar_error_code.h"
 #include "modules/perception/lidar/lib/interface/base_classifier.h"
-#include "modules/perception/lidar/lib/interface/base_segmentation.h"
+#include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
 #include "modules/perception/lidar/lib/map_manager/map_manager.h"
 #include "modules/perception/lidar/lib/object_builder/object_builder.h"
 #include "modules/perception/lidar/lib/object_filter_bank/object_filter_bank.h"
@@ -69,7 +69,7 @@ class LidarObstacleSegmentation {
  private:
   std::shared_ptr&lt;BasePointCloudPreprocessor&gt; cloud_preprocessor_;
   MapManager map_manager_;
-  std::shared_ptr&lt;BaseSegmentation&gt; segmentor_;
+  std::shared_ptr&lt;BaseLidarDetector&gt; segmentor_;
   ObjectBuilder builder_;
   ObjectFilterBank filter_bank_;
   // params
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.cc" new_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.cc" added_lines="4" deleted_lines="2">
				<diff>@@ -51,7 +51,7 @@ PointPillarsDetection::PointPillarsDetection()
 
 // TODO(chenjiahao):
 //  specify score threshold and nms over lap threshold for each class.
-bool PointPillarsDetection::Init(const DetectionInitOptions&amp; options) {
+bool PointPillarsDetection::Init(const LidarDetectorInitOptions&amp; options) {
   point_pillars_ptr_.reset(
       new PointPillars(FLAGS_reproduce_result_mode, FLAGS_score_threshold,
                        FLAGS_nms_overlap_threshold, FLAGS_pfe_torch_file,
@@ -60,7 +60,7 @@ bool PointPillarsDetection::Init(const DetectionInitOptions&amp; options) {
   return true;
 }
 
-bool PointPillarsDetection::Detect(const DetectionOptions&amp; options,
+bool PointPillarsDetection::Detect(const LidarDetectorOptions&amp; options,
                                    LidarFrame* frame) {
   // check input
   if (frame == nullptr) {
@@ -365,6 +365,8 @@ base::ObjectSubType PointPillarsDetection::GetObjectSubType(const int label) {
   }
 }
 
+PERCEPTION_REGISTER_LIDARDETECTOR(PointPillarsDetection);
+
 }  // namespace lidar
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.h" new_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.h" added_lines="5" deleted_lines="8">
				<diff>@@ -27,25 +27,22 @@
 #include "modules/perception/base/point_cloud.h"
 #include "modules/perception/lidar/common/lidar_frame.h"
 #include "modules/perception/lidar/lib/detection/lidar_point_pillars/point_pillars.h"
+#include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
 
 namespace apollo {
 namespace perception {
 namespace lidar {
 
-struct DetectionInitOptions {};
-
-struct DetectionOptions {};
-
-class PointPillarsDetection {
+class PointPillarsDetection : public BaseLidarDetector {
  public:
   PointPillarsDetection();
   ~PointPillarsDetection() = default;
 
-  bool Init(const DetectionInitOptions&amp; options = DetectionInitOptions());
+  bool Init(const LidarDetectorInitOptions&amp; options = LidarDetectorInitOptions()) override;
 
-  bool Detect(const DetectionOptions&amp; options, LidarFrame* frame);
+  bool Detect(const LidarDetectorOptions&amp; options, LidarFrame* frame) override;
 
-  std::string Name() const { return "PointPillarsDetection"; }
+  std::string Name() const override { return "PointPillarsDetection"; }
 
  private:
   void CloudToArray(const base::PointFCloudPtr&amp; pc_ptr, float* out_points_array,
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\interface\base_segmentation.h" new_path="modules\perception\lidar\lib\interface\base_lidar_detector.h" added_lines="14" deleted_lines="14">
				<diff>@@ -25,38 +25,38 @@ namespace apollo {
 namespace perception {
 namespace lidar {
 
-struct SegmentationInitOptions {
+struct LidarDetectorInitOptions {
   std::string sensor_name = "velodyne64";
 };
 
-struct SegmentationOptions {};
+struct LidarDetectorOptions {};
 
-class BaseSegmentation {
+class BaseLidarDetector {
  public:
-  BaseSegmentation() = default;
+  BaseLidarDetector() = default;
 
-  virtual ~BaseSegmentation() = default;
+  virtual ~BaseLidarDetector() = default;
 
   virtual bool Init(
-      const SegmentationInitOptions&amp; options = SegmentationInitOptions()) = 0;
+      const LidarDetectorInitOptions&amp; options = LidarDetectorInitOptions()) = 0;
 
-  // @brief: segment point cloud and get objects.
+  // @brief: process point cloud and get objects.
   // @param [in]: options
   // @param [in/out]: frame
-  // segmented_objects should be filled, required,
+  // objects should be filled, required,
   // label field of point cloud can be filled, optional,
-  virtual bool Segment(const SegmentationOptions&amp; options,
+  virtual bool Detect(const LidarDetectorOptions&amp; options,
                        LidarFrame* frame) = 0;
 
   virtual std::string Name() const = 0;
 
  private:
-  DISALLOW_COPY_AND_ASSIGN(BaseSegmentation);
-};  // class BaseSegmentation
+  DISALLOW_COPY_AND_ASSIGN(BaseLidarDetector);
+};  // class BaseLidarDetector
 
-PERCEPTION_REGISTER_REGISTERER(BaseSegmentation);
-#define PERCEPTION_REGISTER_SEGMENTATION(name) \
-  PERCEPTION_REGISTER_CLASS(BaseSegmentation, name)
+PERCEPTION_REGISTER_REGISTERER(BaseLidarDetector);
+#define PERCEPTION_REGISTER_LIDARDETECTOR(name) \
+  PERCEPTION_REGISTER_CLASS(BaseLidarDetector, name)
 
 }  // namespace lidar
 }  // namespace perception
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.cc" new_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -40,7 +40,7 @@ using base::AttributePointCloud;
 using base::Object;
 using base::PointF;
 
-bool CNNSegmentation::Init(const SegmentationInitOptions&amp; options) {
+bool CNNSegmentation::Init(const LidarDetectorInitOptions&amp; options) {
   // get configs
   std::string param_file;
   std::string proto_file;
@@ -263,7 +263,7 @@ void CNNSegmentation::MapPointToGrid(
   }
 }
 
-bool CNNSegmentation::Segment(const SegmentationOptions&amp; options,
+bool CNNSegmentation::Detect(const LidarDetectorOptions&amp; options,
                               LidarFrame* frame) {
   // check input
   if (frame == nullptr) {
@@ -494,7 +494,7 @@ bool CNNSegmentation::GetConfigs(std::string* param_file,
   return true;
 }
 
-PERCEPTION_REGISTER_SEGMENTATION(CNNSegmentation);
+PERCEPTION_REGISTER_LIDARDETECTOR(CNNSegmentation);
 
 }  // namespace lidar
 }  // namespace perception
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.h" new_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.h" added_lines="6" deleted_lines="6">
				<diff>@@ -30,7 +30,7 @@
 #include "modules/perception/lib/thread/thread_worker.h"
 #include "modules/perception/lidar/lib/interface/base_ground_detector.h"
 #include "modules/perception/lidar/lib/interface/base_roi_filter.h"
-#include "modules/perception/lidar/lib/interface/base_segmentation.h"
+#include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
 #include "modules/perception/lidar/lib/segmentation/cnnseg/feature_generator.h"
 #include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_engine.h"
 
@@ -38,15 +38,15 @@ namespace apollo {
 namespace perception {
 namespace lidar {
 
-class CNNSegmentation : public BaseSegmentation {
+class CNNSegmentation : public BaseLidarDetector {
  public:
   CNNSegmentation() = default;
   ~CNNSegmentation() = default;
 
-  bool Init(const SegmentationInitOptions&amp; options =
-                SegmentationInitOptions()) override;
+  bool Init(const LidarDetectorInitOptions&amp; options =
+                LidarDetectorInitOptions()) override;
 
-  bool Segment(const SegmentationOptions&amp; options, LidarFrame* frame) override;
+  bool Detect(const LidarDetectorOptions&amp; options, LidarFrame* frame) override;
 
   std::string Name() const override { return "CNNSegmentation"; }
 
@@ -122,7 +122,7 @@ class CNNSegmentation : public BaseSegmentation {
 
   // secondary segmentation to improve miss detection
   // not found by neural networks !
-  std::shared_ptr&lt;BaseSegmentation&gt; secondary_segmentor;
+  std::shared_ptr&lt;BaseLidarDetector&gt; secondary_segmentor;
 
  private:
   const int kDefaultPointCloudSize = 120000;
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation_test.cc" new_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation_test.cc" added_lines="10" deleted_lines="10">
				<diff>@@ -81,13 +81,13 @@ TEST(CNNSegmentationTest, cnn_segmentation_sequence_test) {
       "lidar/lib/segmentation/cnnseg/";
 
   auto segmentation = std::shared_ptr&lt;CNNSegmentation&gt;(new CNNSegmentation);
-  SegmentationOptions options;
-  EXPECT_FALSE(segmentation-&gt;Segment(options, nullptr));
+  LidarDetectorOptions options;
+  EXPECT_FALSE(segmentation-&gt;Detect(options, nullptr));
   LidarFrame frame_data;
-  EXPECT_FALSE(segmentation-&gt;Segment(options, &amp;frame_data));
+  EXPECT_FALSE(segmentation-&gt;Detect(options, &amp;frame_data));
   frame_data.cloud = base::PointFCloudPool::Instance().Get();
   frame_data.world_cloud = base::PointDCloudPool::Instance().Get();
-  EXPECT_FALSE(segmentation-&gt;Segment(options, &amp;frame_data));
+  EXPECT_FALSE(segmentation-&gt;Detect(options, &amp;frame_data));
 
   EXPECT_TRUE(segmentation-&gt;Init());
   EXPECT_TRUE(segmentation-&gt;InitClusterAndBackgroundSegmentation());
@@ -115,7 +115,7 @@ TEST(CNNSegmentationTest, cnn_segmentation_sequence_test) {
       continue;
     }
     frame-&gt;world_cloud-&gt;resize(frame-&gt;cloud-&gt;size());
-    EXPECT_TRUE(segmentation-&gt;Segment(options, frame.get()));
+    EXPECT_TRUE(segmentation-&gt;Detect(options, frame.get()));
   }
 }
 
@@ -149,13 +149,13 @@ TEST(CNNSegmentationTest, cnn_segmentation_test) {
 
   // test segment
   using base::ObjectType;
-  SegmentationOptions options;
+  LidarDetectorOptions options;
   LidarFrame frame_data;
   frame_data.cloud = pcl_ptr;
   frame_data.world_cloud = base::PointDCloudPool::Instance().Get();
   frame_data.world_cloud-&gt;resize(pcl_ptr-&gt;size());
   frame_data.non_ground_indices = non_ground_indices;
-  segmentation-&gt;Segment(options, &amp;frame_data);
+  segmentation-&gt;Detect(options, &amp;frame_data);
   std::vector&lt;base::ObjectPtr&gt;&amp; objects = frame_data.segmented_objects;
   //  EXPECT_LE(4, objects.size());
   EXPECT_GT(objects[0]-&gt;lidar_supplement.cloud.size(), 0);
@@ -171,7 +171,7 @@ TEST(CNNSegmentationTest, cnn_segmentation_test) {
 
   segmentation-&gt;cnnseg_param_.set_do_classification(false);
   segmentation-&gt;cnnseg_param_.set_do_heading(false);
-  segmentation-&gt;Segment(options, &amp;frame_data);
+  segmentation-&gt;Detect(options, &amp;frame_data);
   objects = frame_data.segmented_objects;
   //  EXPECT_LE(4, objects.size());
   EXPECT_GT(objects[0]-&gt;lidar_supplement.cloud.size(), 0);
@@ -184,7 +184,7 @@ TEST(CNNSegmentationTest, cnn_segmentation_test) {
   PrintObjects(objects);
 
   segmentation-&gt;InitClusterAndBackgroundSegmentation();
-  segmentation-&gt;Segment(options, &amp;frame_data);
+  segmentation-&gt;Detect(options, &amp;frame_data);
   objects = frame_data.segmented_objects;
   //  EXPECT_EQ(4, objects.size());
   EXPECT_GT(objects[0]-&gt;lidar_supplement.cloud.size(), 0);
@@ -192,7 +192,7 @@ TEST(CNNSegmentationTest, cnn_segmentation_test) {
   PrintObjects(objects);
 
   EXPECT_TRUE(segmentation-&gt;InitClusterAndBackgroundSegmentation());
-  EXPECT_TRUE(segmentation-&gt;Segment(options, &amp;frame_data));
+  EXPECT_TRUE(segmentation-&gt;Detect(options, &amp;frame_data));
   objects = frame_data.segmented_objects;
   //  EXPECT_LE(4, objects.size());
 }
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\ncut_segmentation.cc" new_path="modules\perception\lidar\lib\segmentation\ncut\ncut_segmentation.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -34,7 +34,7 @@ using apollo::cyber::common::GetAbsolutePath;
 using apollo::cyber::common::GetProtoFromFile;
 using Eigen::MatrixXf;
 
-bool NCutSegmentation::Init(const SegmentationInitOptions&amp; options) {
+bool NCutSegmentation::Init(const LidarDetectorInitOptions&amp; options) {
   std::string param_file;
   ACHECK(GetConfigs(&amp;param_file));
   AINFO &lt;&lt; "--    param_file: " &lt;&lt; param_file;
@@ -171,7 +171,7 @@ bool NCutSegmentation::GetConfigs(std::string* param_file) {
   return true;
 }
 
-bool NCutSegmentation::Segment(const SegmentationOptions&amp; options,
+bool NCutSegmentation::Detect(const LidarDetectorOptions&amp; options,
                                LidarFrame* frame) {
   // check input
   if (frame == nullptr) {
@@ -631,7 +631,7 @@ void NCutSegmentation::VisualizeComponents(
 }
 #endif
 
-PERCEPTION_REGISTER_SEGMENTATION(NCutSegmentation);
+PERCEPTION_REGISTER_LIDARDETECTOR(NCutSegmentation);
 
 }  // namespace lidar
 }  // namespace perception
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\ncut_segmentation.h" new_path="modules\perception\lidar\lib\segmentation\ncut\ncut_segmentation.h" added_lines="5" deleted_lines="5">
				<diff>@@ -28,7 +28,7 @@
 #include "modules/perception/lidar/common/pcl_util.h"
 #include "modules/perception/lidar/lib/interface/base_ground_detector.h"
 #include "modules/perception/lidar/lib/interface/base_roi_filter.h"
-#include "modules/perception/lidar/lib/interface/base_segmentation.h"
+#include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
 #include "modules/perception/lidar/lib/segmentation/ncut/ncut.h"
 #include "modules/perception/lidar/lib/segmentation/ncut/proto/ncut_param.pb.h"
 
@@ -38,15 +38,15 @@ namespace lidar {
 
 using base::ObjectPtr;
 
-class NCutSegmentation : public BaseSegmentation {
+class NCutSegmentation : public BaseLidarDetector {
  public:
   NCutSegmentation() = default;
   ~NCutSegmentation() = default;
 
-  bool Init(const SegmentationInitOptions&amp; options =
-                SegmentationInitOptions()) override;
+  bool Init(const LidarDetectorInitOptions&amp; options =
+                LidarDetectorInitOptions()) override;
 
-  bool Segment(const SegmentationOptions&amp; options, LidarFrame* frame) override;
+  bool Detect(const LidarDetectorOptions&amp; options, LidarFrame* frame) override;
 
   std::string Name() const override { return "NCutSegmentation"; }
 
</diff>
			</file>
			<file old_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne128\lidar_obstacle_detection.conf" new_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne128\lidar_obstacle_detection.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -1,3 +1,4 @@
+preprocessor: "PointCloudPreprocessor"
 detector: "PointPillarsDetection"
 use_map_manager: true
 use_object_filter_bank: true
</diff>
			</file>
			<file old_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne128\lidar_obstacle_segmentation.conf" new_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne128\lidar_obstacle_segmentation.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -1,3 +1,4 @@
+preprocessor: "PointCloudPreprocessor"
 segmentor: "CNNSegmentation"
 use_map_manager: true
 use_object_filter_bank: true
</diff>
			</file>
			<file old_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne16\lidar_obstacle_detection.conf" new_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne16\lidar_obstacle_detection.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -1,3 +1,4 @@
+preprocessor: "PointCloudPreprocessor"
 detector: "PointPillarsDetection"
 use_map_manager: true
 use_object_filter_bank: true
</diff>
			</file>
			<file old_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne16\lidar_obstacle_segmentation.conf" new_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne16\lidar_obstacle_segmentation.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -1,3 +1,4 @@
+preprocessor: "PointCloudPreprocessor"
 segmentor: "CNNSegmentation"
 use_map_manager: true
 use_object_filter_bank: true
</diff>
			</file>
			<file old_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne64\lidar_obstacle_detection.conf" new_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne64\lidar_obstacle_detection.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -1,3 +1,4 @@
+preprocessor: "PointCloudPreprocessor"
 detector: "PointPillarsDetection"
 use_map_manager: true
 use_object_filter_bank: true
</diff>
			</file>
			<file old_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne64\lidar_obstacle_segmentation.conf" new_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne64\lidar_obstacle_segmentation.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -1,3 +1,4 @@
+preprocessor: "PointCloudPreprocessor"
 segmentor: "CNNSegmentation"
 use_map_manager: true
 use_object_filter_bank: true
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e21a457cbc572f4ff8669c8eb179e8046f40b808" author="haina0421">
		<msg>add base_lidar_obstacle_detection and update inherence of original detection and segmentation</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" new_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" added_lines="2" deleted_lines="0">
				<diff>@@ -110,6 +110,8 @@ LidarProcessResult LidarObstacleDetection::ProcessCommon(
   return LidarProcessResult(LidarErrorCode::Succeed);
 }
 
+PERCEPTION_REGISTER_LIDAROBSTACLEDETECTION(LidarObstacleDetection);
+
 }  // namespace lidar
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.h" new_path="modules\perception\lidar\app\lidar_obstacle_detection.h" added_lines="7" deleted_lines="21">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
+ * Copyright 2021 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,11 +16,8 @@
 #pragma once
 
 #include &lt;memory&gt;
-#include &lt;string&gt;
 
-#include "Eigen/Dense"
-
-#include "modules/perception/lidar/common/lidar_error_code.h"
+#include "modules/perception/lidar/lib/interface/base_lidar_obstacle_detection.h"
 #include "modules/perception/lidar/lib/interface/base_pointcloud_preprocessor.h"
 #include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
 
@@ -28,34 +25,23 @@ namespace apollo {
 namespace perception {
 namespace lidar {
 
-struct LidarObstacleDetectionInitOptions {
-  std::string sensor_name = "velodyne64";
-};
-
-struct LidarObstacleDetectionOptions {
-  std::string sensor_name;
-  Eigen::Affine3d sensor2novatel_extrinsics;
-
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-} EIGEN_ALIGN16;
-
-class LidarObstacleDetection {
+class LidarObstacleDetection : public BaseLidarObstacleDetection{
  public:
   LidarObstacleDetection() = default;
   ~LidarObstacleDetection() = default;
 
   bool Init(const LidarObstacleDetectionInitOptions&amp; options =
-                LidarObstacleDetectionInitOptions());
+                LidarObstacleDetectionInitOptions()) override;
 
   LidarProcessResult Process(
       const LidarObstacleDetectionOptions&amp; options,
       const std::shared_ptr&lt;apollo::drivers::PointCloud const&gt;&amp; message,
-      LidarFrame* frame);
+      LidarFrame* frame) override;
 
   LidarProcessResult Process(const LidarObstacleDetectionOptions&amp; options,
-                             LidarFrame* frame);
+                             LidarFrame* frame) override;
 
-  std::string Name() const { return "LidarObstacleDetection"; }
+  std::string Name() const override { return "LidarObstacleDetection"; }
 
  private:
   LidarProcessResult ProcessCommon(const LidarObstacleDetectionOptions&amp; options,
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" new_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" added_lines="6" deleted_lines="4">
				<diff>@@ -27,7 +27,7 @@ namespace perception {
 namespace lidar {
 
 bool LidarObstacleSegmentation::Init(
-    const LidarObstacleSegmentationInitOptions&amp; options) {
+    const LidarObstacleDetectionInitOptions&amp; options) {
   auto&amp; sensor_name = options.sensor_name;
   auto config_manager = lib::ConfigManager::Instance();
   const lib::ModelConfig* model_config = nullptr;
@@ -89,7 +89,7 @@ bool LidarObstacleSegmentation::Init(
 }
 
 LidarProcessResult LidarObstacleSegmentation::Process(
-    const LidarObstacleSegmentationOptions&amp; options, LidarFrame* frame) {
+    const LidarObstacleDetectionOptions&amp; options, LidarFrame* frame) {
   PointCloudPreprocessorOptions preprocessor_options;
   preprocessor_options.sensor2novatel_extrinsics =
       options.sensor2novatel_extrinsics;
@@ -101,7 +101,7 @@ LidarProcessResult LidarObstacleSegmentation::Process(
 }
 
 LidarProcessResult LidarObstacleSegmentation::Process(
-    const LidarObstacleSegmentationOptions&amp; options,
+    const LidarObstacleDetectionOptions&amp; options,
     const std::shared_ptr&lt;apollo::drivers::PointCloud const&gt;&amp; message,
     LidarFrame* frame) {
   const auto&amp; sensor_name = options.sensor_name;
@@ -121,7 +121,7 @@ LidarProcessResult LidarObstacleSegmentation::Process(
 }
 
 LidarProcessResult LidarObstacleSegmentation::ProcessCommon(
-    const LidarObstacleSegmentationOptions&amp; options, LidarFrame* frame) {
+    const LidarObstacleDetectionOptions&amp; options, LidarFrame* frame) {
   const auto&amp; sensor_name = options.sensor_name;
 
   PERF_BLOCK_START();
@@ -158,6 +158,8 @@ LidarProcessResult LidarObstacleSegmentation::ProcessCommon(
   return LidarProcessResult(LidarErrorCode::Succeed);
 }
 
+PERCEPTION_REGISTER_LIDAROBSTACLEDETECTION(LidarObstacleSegmentation);
+
 }  // namespace lidar
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.h" new_path="modules\perception\lidar\app\lidar_obstacle_segmentation.h" added_lines="11" deleted_lines="27">
				<diff>@@ -16,55 +16,39 @@
 #pragma once
 
 #include &lt;memory&gt;
-#include &lt;string&gt;
 
-#include "Eigen/Dense"
-
-#include "modules/perception/lidar/common/lidar_error_code.h"
-#include "modules/perception/lidar/lib/interface/base_classifier.h"
+#include "modules/perception/lidar/lib/interface/base_lidar_obstacle_detection.h"
+#include "modules/perception/lidar/lib/interface/base_pointcloud_preprocessor.h"
 #include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
 #include "modules/perception/lidar/lib/map_manager/map_manager.h"
 #include "modules/perception/lidar/lib/object_builder/object_builder.h"
 #include "modules/perception/lidar/lib/object_filter_bank/object_filter_bank.h"
-#include "modules/perception/lidar/lib/interface/base_pointcloud_preprocessor.h"
 
 namespace apollo {
 namespace perception {
 namespace lidar {
 
-struct LidarObstacleSegmentationInitOptions {
-  std::string sensor_name = "velodyne64";
-  bool enable_hdmap_input = true;
-};
-
-struct LidarObstacleSegmentationOptions {
-  std::string sensor_name;
-  Eigen::Affine3d sensor2novatel_extrinsics;
-
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-} EIGEN_ALIGN16;
-
-class LidarObstacleSegmentation {
+class LidarObstacleSegmentation : public BaseLidarObstacleDetection{
  public:
   LidarObstacleSegmentation() = default;
   ~LidarObstacleSegmentation() = default;
 
-  bool Init(const LidarObstacleSegmentationInitOptions&amp; options =
-                LidarObstacleSegmentationInitOptions());
+  bool Init(const LidarObstacleDetectionInitOptions&amp; options =
+                LidarObstacleDetectionInitOptions()) override;
 
   LidarProcessResult Process(
-      const LidarObstacleSegmentationOptions&amp; options,
+      const LidarObstacleDetectionOptions&amp; options,
       const std::shared_ptr&lt;apollo::drivers::PointCloud const&gt;&amp; message,
-      LidarFrame* frame);
+      LidarFrame* frame) override;
 
-  LidarProcessResult Process(const LidarObstacleSegmentationOptions&amp; options,
-                             LidarFrame* frame);
+  LidarProcessResult Process(const LidarObstacleDetectionOptions&amp; options,
+                             LidarFrame* frame) override;
 
-  std::string Name() const { return "LidarObstacleSegmentation"; }
+  std::string Name() const override { return "LidarObstacleSegmentation"; }
 
  private:
   LidarProcessResult ProcessCommon(
-      const LidarObstacleSegmentationOptions&amp; options, LidarFrame* frame);
+      const LidarObstacleDetectionOptions&amp; options, LidarFrame* frame);
 
  private:
   std::shared_ptr&lt;BasePointCloudPreprocessor&gt; cloud_preprocessor_;
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\pointcloud_preprocessor\pointcloud_preprocessor.cc" new_path="modules\perception\lidar\lib\pointcloud_preprocessor\pointcloud_preprocessor.cc" added_lines="2" deleted_lines="0">
				<diff>@@ -188,6 +188,8 @@ bool PointCloudPreprocessor::TransformCloud(
   return true;
 }
 
+PERCEPTION_REGISTER_POINTCLOUDPREPROCESSOR(PointCloudPreprocessor);
+
 }  // namespace lidar
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\segmentation_component.cc" new_path="modules\perception\onboard\component\segmentation_component.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -82,7 +82,7 @@ bool SegmentationComponent::InitAlgorithmPlugin() {
            &lt;&lt; "Failed to get segmentation instance";
     return false;
   }
-  lidar::LidarObstacleSegmentationInitOptions init_options;
+  lidar::LidarObstacleDetectionInitOptions init_options;
   init_options.sensor_name = sensor_name_;
   init_options.enable_hdmap_input =
       FLAGS_obs_enable_hdmap_input &amp;&amp; enable_hdmap_;
@@ -140,7 +140,7 @@ bool SegmentationComponent::InternalProc(
   frame-&gt;lidar2world_pose = pose;
   frame-&gt;novatel2world_pose = pose_novatel;
 
-  lidar::LidarObstacleSegmentationOptions segment_opts;
+  lidar::LidarObstacleDetectionOptions segment_opts;
   segment_opts.sensor_name = sensor_name_;
   lidar2world_trans_.GetExtrinsics(&amp;segment_opts.sensor2novatel_extrinsics);
   lidar::LidarProcessResult ret =
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ec9c10412831aeda30fe9bb99ebf42d0cd04be78" author="haina0421">
		<msg>Debug preprocessor</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" new_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" added_lines="8" deleted_lines="0">
				<diff>@@ -22,6 +22,8 @@
 #include "modules/perception/lidar/common/lidar_log.h"
 #include "modules/perception/lidar/lib/scene_manager/scene_manager.h"
 
+#include &lt;vector&gt;
+
 namespace apollo {
 namespace perception {
 namespace lidar {
@@ -59,6 +61,12 @@ bool LidarObstacleSegmentation::Init(
       use_map_manager_ = false;
     }
   }
+  
+  // For Debug
+  std::vector&lt;BasePointCloudPreprocessor *&gt; vec = BasePointCloudPreprocessorRegisterer::GetAllInstances();
+  std::cout&lt;&lt;"Size of Preprocessor Map: "&lt;&lt;vec.size()&lt;&lt;std::endl;
+
+  // End Debug
 
   BasePointCloudPreprocessor* preprocessor =
       BasePointCloudPreprocessorRegisterer::GetInstanceByName(config.preprocessor());
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\dummy\dummy_segmentation.cc" new_path="modules\perception\lidar\lib\dummy\dummy_segmentation.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -20,16 +20,16 @@ namespace apollo {
 namespace perception {
 namespace lidar {
 
-bool DummySegmentation::Init(const SegmentationInitOptions&amp; options) {
+bool DummySegmentation::Init(const LidarDetectorInitOptions&amp; options) {
   return true;
 }
 
-bool DummySegmentation::Segment(const SegmentationOptions&amp; options,
+bool DummySegmentation::Detect(const LidarDetectorOptions&amp; options,
                                 LidarFrame* frame) {
   return true;
 }
 
-PERCEPTION_REGISTER_SEGMENTATION(DummySegmentation);
+PERCEPTION_REGISTER_LIDARDETECTOR(DummySegmentation);
 
 }  // namespace lidar
 }  // namespace perception
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\dummy\dummy_segmentation.h" new_path="modules\perception\lidar\lib\dummy\dummy_segmentation.h" added_lines="5" deleted_lines="5">
				<diff>@@ -18,27 +18,27 @@
 
 #include &lt;string&gt;
 
-#include "modules/perception/lidar/lib/interface/base_segmentation.h"
+#include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
 
 namespace apollo {
 namespace perception {
 namespace lidar {
 
-class DummySegmentation : public BaseSegmentation {
+class DummySegmentation : public BaseLidarDetector {
  public:
   DummySegmentation() = default;
 
   virtual ~DummySegmentation() = default;
 
-  bool Init(const SegmentationInitOptions&amp; options =
-                SegmentationInitOptions()) override;
+  bool Init(const LidarDetectorInitOptions&amp; options =
+                LidarDetectorInitOptions()) override;
 
   // @brief: segment point cloud and get objects.
   // @param [in]: options
   // @param [in/out]: frame
   // segmented_objects should be filled, required,
   // label field of point cloud can be filled, optional,
-  bool Segment(const SegmentationOptions&amp; options, LidarFrame* frame) override;
+  bool Detect(const LidarDetectorOptions&amp; options, LidarFrame* frame) override;
 
   std::string Name() const override { return "DummySegmentation"; }
 };  // class DummySegmentation
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7fcce58dba35958a25d95ed75d351125eef66cfb" author="haina0421">
		<msg>Debug preprocessor 2</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" new_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" added_lines="1" deleted_lines="0">
				<diff>@@ -20,6 +20,7 @@
 #include "modules/perception/lib/config_manager/config_manager.h"
 #include "modules/perception/lidar/app/proto/lidar_obstacle_detection_config.pb.h"
 #include "modules/perception/lidar/common/lidar_log.h"
+#include "modules/perception/lib/registerer/registerer.h"
 
 namespace apollo {
 namespace perception {
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" new_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" added_lines="1" deleted_lines="0">
				<diff>@@ -21,6 +21,7 @@
 #include "modules/perception/lidar/app/proto/lidar_obstacle_segmentation_config.pb.h"
 #include "modules/perception/lidar/common/lidar_log.h"
 #include "modules/perception/lidar/lib/scene_manager/scene_manager.h"
+#include "modules/perception/lib/registerer/registerer.h"
 
 #include &lt;vector&gt;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f61432901f13c39f2123271f64079981c7df6765" author="haina0421">
		<msg>Debug preprocessor 3</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" new_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" added_lines="0" deleted_lines="1">
				<diff>@@ -20,7 +20,6 @@
 #include "modules/perception/lib/config_manager/config_manager.h"
 #include "modules/perception/lidar/app/proto/lidar_obstacle_detection_config.pb.h"
 #include "modules/perception/lidar/common/lidar_log.h"
-#include "modules/perception/lib/registerer/registerer.h"
 
 namespace apollo {
 namespace perception {
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" new_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" added_lines="0" deleted_lines="1">
				<diff>@@ -21,7 +21,6 @@
 #include "modules/perception/lidar/app/proto/lidar_obstacle_segmentation_config.pb.h"
 #include "modules/perception/lidar/common/lidar_log.h"
 #include "modules/perception/lidar/lib/scene_manager/scene_manager.h"
-#include "modules/perception/lib/registerer/registerer.h"
 
 #include &lt;vector&gt;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1f42db188a4292540d45fd56f8328c42c132cd69" author="haina0421">
		<msg>Test Base_lidar_obstacle_tracking</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\lib\interface\base_lidar_obstacle_detection.h" new_path="modules\perception\lidar\lib\interface\base_lidar_obstacle_detection.h" added_lines="1" deleted_lines="1">
				<diff>@@ -45,7 +45,7 @@ struct LidarObstacleDetectionOptions {
 class BaseLidarObstacleDetection {
  public:
   BaseLidarObstacleDetection() = default;
-  ~BaseLidarObstacleDetection() = default;
+  virtual ~BaseLidarObstacleDetection() = default;
 
   virtual bool Init(const LidarObstacleDetectionInitOptions&amp; options =
                 LidarObstacleDetectionInitOptions()) = 0;
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\interface\base_pointcloud_preprocessor.h" new_path="modules\perception\lidar\lib\interface\base_pointcloud_preprocessor.h" added_lines="1" deleted_lines="1">
				<diff>@@ -40,7 +40,7 @@ class BasePointCloudPreprocessor {
  public:
   BasePointCloudPreprocessor() = default;
 
-  ~BasePointCloudPreprocessor() = default;
+  virtual ~BasePointCloudPreprocessor() = default;
 
   virtual bool Init(const PointCloudPreprocessorInitOptions&amp; options =
                 PointCloudPreprocessorInitOptions()) = 0;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3440c35b66e64b10c7916b3fac1bd595d4164bdb" author="haina0421">
		<msg>Add base_lidar_obstacle_tracking and update inheritance</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.h" new_path="modules\perception\lidar\app\lidar_obstacle_detection.h" added_lines="1" deleted_lines="1">
				<diff>@@ -28,7 +28,7 @@ namespace lidar {
 class LidarObstacleDetection : public BaseLidarObstacleDetection{
  public:
   LidarObstacleDetection() = default;
-  ~LidarObstacleDetection() = default;
+  virtual ~LidarObstacleDetection() = default;
 
   bool Init(const LidarObstacleDetectionInitOptions&amp; options =
                 LidarObstacleDetectionInitOptions()) override;
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.h" new_path="modules\perception\lidar\app\lidar_obstacle_segmentation.h" added_lines="1" deleted_lines="1">
				<diff>@@ -31,7 +31,7 @@ namespace lidar {
 class LidarObstacleSegmentation : public BaseLidarObstacleDetection{
  public:
   LidarObstacleSegmentation() = default;
-  ~LidarObstacleSegmentation() = default;
+  virtual ~LidarObstacleSegmentation() = default;
 
   bool Init(const LidarObstacleDetectionInitOptions&amp; options =
                 LidarObstacleDetectionInitOptions()) override;
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_tracking.cc" new_path="modules\perception\lidar\app\lidar_obstacle_tracking.cc" added_lines="12" deleted_lines="10">
				<diff>@@ -43,20 +43,20 @@ bool LidarObstacleTracking::Init(
 
   LidarObstacleTrackingConfig config;
   ACHECK(cyber::common::GetProtoFromFile(config_file, &amp;config));
-  multi_target_tracker_name_ = config.multi_target_tracker();
-  fusion_classifier_name_ = config.fusion_classifier();
 
-  multi_target_tracker_ = BaseMultiTargetTrackerRegisterer::GetInstanceByName(
-      multi_target_tracker_name_);
-  CHECK_NOTNULL(multi_target_tracker_);
+  BaseMultiTargetTracker* multi_target_tracker =
+      BaseMultiTargetTrackerRegisterer::GetInstanceByName(config.multi_target_tracker());
+  CHECK_NOTNULL(multi_target_tracker);
+  multi_target_tracker_.reset(multi_target_tracker);
   MultiTargetTrackerInitOptions tracker_init_options;
-  ACHECK(multi_target_tracker_-&gt;Init(tracker_init_options));
+  ACHECK(multi_target_tracker_-&gt;Init(tracker_init_options)) &lt;&lt; "lidar multi_target_tracker init error";
 
-  fusion_classifier_ =
-      BaseClassifierRegisterer::GetInstanceByName(fusion_classifier_name_);
-  CHECK_NOTNULL(fusion_classifier_);
+  BaseClassifier* fusion_classifier =
+      BaseClassifierRegisterer::GetInstanceByName(config.fusion_classifier());
+  CHECK_NOTNULL(fusion_classifier);
+  fusion_classifier_.reset(fusion_classifier);
   ClassifierInitOptions fusion_classifier_init_options;
-  ACHECK(fusion_classifier_-&gt;Init(fusion_classifier_init_options));
+  ACHECK(fusion_classifier_-&gt;Init(fusion_classifier_init_options)) &lt;&lt; "lidar classifier init error";
   return true;
 }
 
@@ -84,6 +84,8 @@ LidarProcessResult LidarObstacleTracking::Process(
   return LidarProcessResult(LidarErrorCode::Succeed);
 }
 
+PERCEPTION_REGISTER_LIDAROBSTACLETRACKING(LidarObstacleTracking);
+
 }  // namespace lidar
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_tracking.h" new_path="modules\perception\lidar\app\lidar_obstacle_tracking.h" added_lines="8" deleted_lines="17">
				<diff>@@ -19,6 +19,7 @@
 #include &lt;string&gt;
 
 #include "modules/perception/lidar/common/lidar_error_code.h"
+#include "modules/perception/lidar/lib/interface/base_lidar_obstacle_tracking.h"
 #include "modules/perception/lidar/lib/interface/base_classifier.h"
 #include "modules/perception/lidar/lib/interface/base_multi_target_tracker.h"
 
@@ -26,32 +27,22 @@ namespace apollo {
 namespace perception {
 namespace lidar {
 
-struct LidarObstacleTrackingInitOptions {
-  std::string sensor_name = "velodyne64";
-};
-
-struct LidarObstacleTrackingOptions {
-  std::string sensor_name;
-};
-
-class LidarObstacleTracking {
+class LidarObstacleTracking : public BaseLidarObstacleTracking {
  public:
   LidarObstacleTracking() = default;
-  ~LidarObstacleTracking() = default;
+  virtual ~LidarObstacleTracking() = default;
 
   bool Init(const LidarObstacleTrackingInitOptions&amp; options =
-                LidarObstacleTrackingInitOptions());
+                LidarObstacleTrackingInitOptions()) override;
 
   LidarProcessResult Process(const LidarObstacleTrackingOptions&amp; options,
-                             LidarFrame* frame);
+                             LidarFrame* frame) override;
 
-  std::string Name() const { return "LidarObstacleTracking"; }
+  std::string Name() const override { return "LidarObstacleTracking"; }
 
  private:
-  BaseMultiTargetTracker* multi_target_tracker_;
-  BaseClassifier* fusion_classifier_;
-  std::string multi_target_tracker_name_;
-  std::string fusion_classifier_name_;
+  std::shared_ptr&lt;BaseMultiTargetTracker&gt; multi_target_tracker_;
+  std::shared_ptr&lt;BaseClassifier&gt; fusion_classifier_;
 };  // class LidarObstacleTracking
 
 }  // namespace lidar
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.h" new_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.h" added_lines="1" deleted_lines="1">
				<diff>@@ -36,7 +36,7 @@ namespace lidar {
 class PointPillarsDetection : public BaseLidarDetector {
  public:
   PointPillarsDetection();
-  ~PointPillarsDetection() = default;
+  virtual ~PointPillarsDetection() = default;
 
   bool Init(const LidarDetectorInitOptions&amp; options = LidarDetectorInitOptions()) override;
 
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\pointcloud_preprocessor\pointcloud_preprocessor.h" new_path="modules\perception\lidar\lib\pointcloud_preprocessor\pointcloud_preprocessor.h" added_lines="2" deleted_lines="2">
				<diff>@@ -25,9 +25,9 @@ namespace lidar {
 
 class PointCloudPreprocessor : public BasePointCloudPreprocessor {
  public:
-  PointCloudPreprocessor() = default;
+  PointCloudPreprocessor() : BasePointCloudPreprocessor() {}
 
-  ~PointCloudPreprocessor() = default;
+  virtual ~PointCloudPreprocessor() = default;
 
   bool Init(const PointCloudPreprocessorInitOptions&amp; options =
                 PointCloudPreprocessorInitOptions()) override;
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.h" new_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.h" added_lines="1" deleted_lines="1">
				<diff>@@ -41,7 +41,7 @@ namespace lidar {
 class CNNSegmentation : public BaseLidarDetector {
  public:
   CNNSegmentation() = default;
-  ~CNNSegmentation() = default;
+  virtual ~CNNSegmentation() = default;
 
   bool Init(const LidarDetectorInitOptions&amp; options =
                 LidarDetectorInitOptions()) override;
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\ncut_segmentation.h" new_path="modules\perception\lidar\lib\segmentation\ncut\ncut_segmentation.h" added_lines="1" deleted_lines="1">
				<diff>@@ -41,7 +41,7 @@ using base::ObjectPtr;
 class NCutSegmentation : public BaseLidarDetector {
  public:
   NCutSegmentation() = default;
-  ~NCutSegmentation() = default;
+  virtual ~NCutSegmentation() = default;
 
   bool Init(const LidarDetectorInitOptions&amp; options =
                 LidarDetectorInitOptions()) override;
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\tracker\multi_lidar_fusion\mlf_engine.h" new_path="modules\perception\lidar\lib\tracker\multi_lidar_fusion\mlf_engine.h" added_lines="1" deleted_lines="1">
				<diff>@@ -38,7 +38,7 @@ class MlfEngine : public BaseMultiTargetTracker {
 
  public:
   MlfEngine() = default;
-  ~MlfEngine() = default;
+  virtual ~MlfEngine() = default;
 
   bool Init(const MultiTargetTrackerInitOptions&amp; options =
                 MultiTargetTrackerInitOptions()) override;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3f76e67574f45c049e26c3f47fb4ca2058e738d5" author="haina0421">
		<msg>Integrate Detection and Segmentation</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" new_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" added_lines="55" deleted_lines="0">
				<diff>@@ -20,6 +20,7 @@
 #include "modules/perception/lib/config_manager/config_manager.h"
 #include "modules/perception/lidar/app/proto/lidar_obstacle_detection_config.pb.h"
 #include "modules/perception/lidar/common/lidar_log.h"
+#include "modules/perception/lidar/lib/scene_manager/scene_manager.h"
 
 namespace apollo {
 namespace perception {
@@ -43,6 +44,22 @@ bool LidarObstacleDetection::Init(
 
   LidarObstacleDetectionConfig config;
   ACHECK(cyber::common::GetProtoFromFile(config_file, &amp;config));
+  use_map_manager_ = config.use_map_manager();
+  use_object_filter_bank_ = config.use_object_filter_bank();
+  use_object_builder_ = ("PointPillarsDetection" != config.detector());
+
+  use_map_manager_ = use_map_manager_ &amp;&amp; options.enable_hdmap_input;
+
+  SceneManagerInitOptions scene_manager_init_options;
+  ACHECK(SceneManager::Instance().Init(scene_manager_init_options));
+
+  if (use_map_manager_) {
+    MapManagerInitOptions map_manager_init_options;
+    if (!map_manager_.Init(map_manager_init_options)) {
+      AINFO &lt;&lt; "Failed to init map manager.";
+      use_map_manager_ = false;
+    }
+  }
 
   BasePointCloudPreprocessor* preprocessor =
       BasePointCloudPreprocessorRegisterer::GetInstanceByName(config.preprocessor());
@@ -60,6 +77,17 @@ bool LidarObstacleDetection::Init(
   detection_init_options.sensor_name = sensor_name;
   ACHECK(detector_-&gt;Init(detection_init_options)) &lt;&lt; "lidar detector init error";
 
+  if(use_object_builder_) {
+    ObjectBuilderInitOptions builder_init_options;
+    ACHECK(builder_.Init(builder_init_options));
+  }
+
+  if (use_object_filter_bank_) {
+    ObjectFilterInitOptions filter_bank_init_options;
+    filter_bank_init_options.sensor_name = sensor_name;
+    ACHECK(filter_bank_.Init(filter_bank_init_options));
+  }
+
   return true;
 }
 
@@ -100,6 +128,15 @@ LidarProcessResult LidarObstacleDetection::ProcessCommon(
   const auto&amp; sensor_name = options.sensor_name;
 
   PERF_BLOCK_START();
+  if (use_map_manager_) {
+    MapManagerOptions map_manager_options;
+    if (!map_manager_.Update(map_manager_options, frame)) {
+      return LidarProcessResult(LidarErrorCode::MapManagerError,
+                                "Failed to update map structure.");
+    }
+  }
+  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "map_manager");
+
   LidarDetectorOptions detection_options;
   if (!detector_-&gt;Detect(detection_options, frame)) {
     return LidarProcessResult(LidarErrorCode::DetectionError,
@@ -107,6 +144,24 @@ LidarProcessResult LidarObstacleDetection::ProcessCommon(
   }
   PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "detection");
 
+  if (use_object_builder_) {
+    ObjectBuilderOptions builder_options;
+    if (!builder_.Build(builder_options, frame)) {
+      return LidarProcessResult(LidarErrorCode::ObjectBuilderError,
+                                "Failed to build objects.");
+    }
+  }
+  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "object_builder");
+
+  if (use_object_filter_bank_) {
+    ObjectFilterOptions filter_options;
+    if (!filter_bank_.Filter(filter_options, frame)) {
+      return LidarProcessResult(LidarErrorCode::ObjectFilterError,
+                                "Failed to filter objects.");
+    }
+  }
+  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "filter_bank");
+
   return LidarProcessResult(LidarErrorCode::Succeed);
 }
 
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.h" new_path="modules\perception\lidar\app\lidar_obstacle_detection.h" added_lines="10" deleted_lines="0">
				<diff>@@ -20,6 +20,9 @@
 #include "modules/perception/lidar/lib/interface/base_lidar_obstacle_detection.h"
 #include "modules/perception/lidar/lib/interface/base_pointcloud_preprocessor.h"
 #include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
+#include "modules/perception/lidar/lib/map_manager/map_manager.h"
+#include "modules/perception/lidar/lib/object_builder/object_builder.h"
+#include "modules/perception/lidar/lib/object_filter_bank/object_filter_bank.h"
 
 namespace apollo {
 namespace perception {
@@ -50,6 +53,13 @@ class LidarObstacleDetection : public BaseLidarObstacleDetection{
  private:
   std::shared_ptr&lt;BasePointCloudPreprocessor&gt; cloud_preprocessor_;
   std::shared_ptr&lt;BaseLidarDetector&gt; detector_;
+  MapManager map_manager_;
+  ObjectBuilder builder_;
+  ObjectFilterBank filter_bank_;
+  // params
+  bool use_map_manager_ = true;
+  bool use_object_filter_bank_ = true;
+  bool use_object_builder_ = true;
 };  // class LidarObstacleDetection
 
 }  // namespace lidar
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" new_path="" added_lines="0" deleted_lines="173">
				<diff>@@ -1,173 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/app/lidar_obstacle_segmentation.h"
-
-#include "cyber/common/file.h"
-#include "modules/common/util/perf_util.h"
-#include "modules/perception/lib/config_manager/config_manager.h"
-#include "modules/perception/lidar/app/proto/lidar_obstacle_segmentation_config.pb.h"
-#include "modules/perception/lidar/common/lidar_log.h"
-#include "modules/perception/lidar/lib/scene_manager/scene_manager.h"
-
-#include &lt;vector&gt;
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-bool LidarObstacleSegmentation::Init(
-    const LidarObstacleDetectionInitOptions&amp; options) {
-  auto&amp; sensor_name = options.sensor_name;
-  auto config_manager = lib::ConfigManager::Instance();
-  const lib::ModelConfig* model_config = nullptr;
-  ACHECK(config_manager-&gt;GetModelConfig(Name(), &amp;model_config));
-
-  const std::string work_root = config_manager-&gt;work_root();
-  std::string config_file;
-  std::string root_path;
-  ACHECK(model_config-&gt;get_value("root_path", &amp;root_path));
-  config_file = cyber::common::GetAbsolutePath(work_root, root_path);
-  config_file = cyber::common::GetAbsolutePath(config_file, sensor_name);
-  config_file = cyber::common::GetAbsolutePath(
-      config_file, "lidar_obstacle_segmentation.conf");
-
-  LidarObstacleSegmentationConfig config;
-  ACHECK(cyber::common::GetProtoFromFile(config_file, &amp;config));
-  use_map_manager_ = config.use_map_manager();
-  use_object_filter_bank_ = config.use_object_filter_bank();
-
-  use_map_manager_ = use_map_manager_ &amp;&amp; options.enable_hdmap_input;
-
-  SceneManagerInitOptions scene_manager_init_options;
-  ACHECK(SceneManager::Instance().Init(scene_manager_init_options));
-
-  if (use_map_manager_) {
-    MapManagerInitOptions map_manager_init_options;
-    if (!map_manager_.Init(map_manager_init_options)) {
-      AINFO &lt;&lt; "Failed to init map manager.";
-      use_map_manager_ = false;
-    }
-  }
-  
-  // For Debug
-  std::vector&lt;BasePointCloudPreprocessor *&gt; vec = BasePointCloudPreprocessorRegisterer::GetAllInstances();
-  std::cout&lt;&lt;"Size of Preprocessor Map: "&lt;&lt;vec.size()&lt;&lt;std::endl;
-
-  // End Debug
-
-  BasePointCloudPreprocessor* preprocessor =
-      BasePointCloudPreprocessorRegisterer::GetInstanceByName(config.preprocessor());
-  CHECK_NOTNULL(preprocessor);
-  cloud_preprocessor_.reset(preprocessor);
-  PointCloudPreprocessorInitOptions preprocessor_init_options;
-  preprocessor_init_options.sensor_name = sensor_name;
-  ACHECK(cloud_preprocessor_-&gt;Init(preprocessor_init_options)) &lt;&lt; "lidar preprocessor init error";
-
-  BaseLidarDetector* segmentor =
-      BaseLidarDetectorRegisterer::GetInstanceByName(config.segmentor());
-  CHECK_NOTNULL(segmentor);
-  segmentor_.reset(segmentor);
-  LidarDetectorInitOptions segmentation_init_options;
-  segmentation_init_options.sensor_name = sensor_name;
-  ACHECK(segmentor_-&gt;Init(segmentation_init_options)) &lt;&lt; "lidar segmentor init error";
-
-  ObjectBuilderInitOptions builder_init_options;
-  ACHECK(builder_.Init(builder_init_options));
-
-  if (use_object_filter_bank_) {
-    ObjectFilterInitOptions filter_bank_init_options;
-    filter_bank_init_options.sensor_name = sensor_name;
-    ACHECK(filter_bank_.Init(filter_bank_init_options));
-  }
-
-  return true;
-}
-
-LidarProcessResult LidarObstacleSegmentation::Process(
-    const LidarObstacleDetectionOptions&amp; options, LidarFrame* frame) {
-  PointCloudPreprocessorOptions preprocessor_options;
-  preprocessor_options.sensor2novatel_extrinsics =
-      options.sensor2novatel_extrinsics;
-  if (cloud_preprocessor_-&gt;Preprocess(preprocessor_options, frame)) {
-    return ProcessCommon(options, frame);
-  }
-  return LidarProcessResult(LidarErrorCode::PointCloudPreprocessorError,
-                            "Failed to preprocess point cloud.");
-}
-
-LidarProcessResult LidarObstacleSegmentation::Process(
-    const LidarObstacleDetectionOptions&amp; options,
-    const std::shared_ptr&lt;apollo::drivers::PointCloud const&gt;&amp; message,
-    LidarFrame* frame) {
-  const auto&amp; sensor_name = options.sensor_name;
-
-  PERF_FUNCTION_WITH_INDICATOR(options.sensor_name);
-
-  PERF_BLOCK_START();
-  PointCloudPreprocessorOptions preprocessor_options;
-  preprocessor_options.sensor2novatel_extrinsics =
-      options.sensor2novatel_extrinsics;
-  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "preprocess");
-  if (cloud_preprocessor_-&gt;Preprocess(preprocessor_options, message, frame)) {
-    return ProcessCommon(options, frame);
-  }
-  return LidarProcessResult(LidarErrorCode::PointCloudPreprocessorError,
-                            "Failed to preprocess point cloud.");
-}
-
-LidarProcessResult LidarObstacleSegmentation::ProcessCommon(
-    const LidarObstacleDetectionOptions&amp; options, LidarFrame* frame) {
-  const auto&amp; sensor_name = options.sensor_name;
-
-  PERF_BLOCK_START();
-  if (use_map_manager_) {
-    MapManagerOptions map_manager_options;
-    if (!map_manager_.Update(map_manager_options, frame)) {
-      return LidarProcessResult(LidarErrorCode::MapManagerError,
-                                "Failed to update map structure.");
-    }
-  }
-  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "map_manager");
-
-  LidarDetectorOptions segmentation_options;
-  if (!segmentor_-&gt;Detect(segmentation_options, frame)) {
-    return LidarProcessResult(LidarErrorCode::SegmentationError,
-                              "Failed to segment.");
-  }
-  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "segmentation");
-
-  ObjectBuilderOptions builder_options;
-  if (!builder_.Build(builder_options, frame)) {
-    return LidarProcessResult(LidarErrorCode::ObjectBuilderError,
-                              "Failed to build objects.");
-  }
-  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "object_builder");
-
-  ObjectFilterOptions filter_options;
-  if (!filter_bank_.Filter(filter_options, frame)) {
-    return LidarProcessResult(LidarErrorCode::ObjectFilterError,
-                              "Failed to filter objects.");
-  }
-  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "filter_bank");
-
-  return LidarProcessResult(LidarErrorCode::Succeed);
-}
-
-PERCEPTION_REGISTER_LIDAROBSTACLEDETECTION(LidarObstacleSegmentation);
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.h" new_path="" added_lines="0" deleted_lines="66">
				<diff>@@ -1,66 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;memory&gt;
-
-#include "modules/perception/lidar/lib/interface/base_lidar_obstacle_detection.h"
-#include "modules/perception/lidar/lib/interface/base_pointcloud_preprocessor.h"
-#include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
-#include "modules/perception/lidar/lib/map_manager/map_manager.h"
-#include "modules/perception/lidar/lib/object_builder/object_builder.h"
-#include "modules/perception/lidar/lib/object_filter_bank/object_filter_bank.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class LidarObstacleSegmentation : public BaseLidarObstacleDetection{
- public:
-  LidarObstacleSegmentation() = default;
-  virtual ~LidarObstacleSegmentation() = default;
-
-  bool Init(const LidarObstacleDetectionInitOptions&amp; options =
-                LidarObstacleDetectionInitOptions()) override;
-
-  LidarProcessResult Process(
-      const LidarObstacleDetectionOptions&amp; options,
-      const std::shared_ptr&lt;apollo::drivers::PointCloud const&gt;&amp; message,
-      LidarFrame* frame) override;
-
-  LidarProcessResult Process(const LidarObstacleDetectionOptions&amp; options,
-                             LidarFrame* frame) override;
-
-  std::string Name() const override { return "LidarObstacleSegmentation"; }
-
- private:
-  LidarProcessResult ProcessCommon(
-      const LidarObstacleDetectionOptions&amp; options, LidarFrame* frame);
-
- private:
-  std::shared_ptr&lt;BasePointCloudPreprocessor&gt; cloud_preprocessor_;
-  MapManager map_manager_;
-  std::shared_ptr&lt;BaseLidarDetector&gt; segmentor_;
-  ObjectBuilder builder_;
-  ObjectFilterBank filter_bank_;
-  // params
-  bool use_map_manager_ = true;
-  bool use_object_filter_bank_ = true;
-};  // class LidarObstacleSegmentation
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\common\lidar_error_code.h" new_path="modules\perception\lidar\common\lidar_error_code.h" added_lines="1" deleted_lines="2">
				<diff>@@ -26,12 +26,11 @@ enum class LidarErrorCode {
   InitError = 1,
   PointCloudPreprocessorError = 2,
   MapManagerError = 3,
-  SegmentationError = 4,
+  DetectionError = 4,
   ObjectBuilderError = 5,
   ObjectFilterError = 6,
   ClassifierError = 7,
   TrackerError = 8,
-  DetectionError = 9,
 };
 
 struct LidarProcessResult {
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\detection_component.cc" new_path="modules\perception\onboard\component\detection_component.cc" added_lines="8" deleted_lines="7">
				<diff>@@ -43,7 +43,7 @@ bool DetectionComponent::Init() {
       comp_config.lidar2novatel_tf2_child_frame_id();
   lidar_query_tf_offset_ =
       static_cast&lt;float&gt;(comp_config.lidar_query_tf_offset());
-  //  enable_hdmap_ = comp_config.enable_hdmap();
+  enable_hdmap_ = comp_config.enable_hdmap();
   writer_ = node_-&gt;CreateWriter&lt;LidarFrameMessage&gt;(output_channel_name_);
 
   if (!InitAlgorithmPlugin()) {
@@ -82,8 +82,8 @@ bool DetectionComponent::InitAlgorithmPlugin() {
   }
   lidar::LidarObstacleDetectionInitOptions init_options;
   init_options.sensor_name = sensor_name_;
-  //  init_options.enable_hdmap_input =
-  //      FLAGS_obs_enable_hdmap_input &amp;&amp; enable_hdmap_;
+  init_options.enable_hdmap_input =
+      FLAGS_obs_enable_hdmap_input &amp;&amp; enable_hdmap_;
   if (!detector_-&gt;Init(init_options)) {
     AINFO &lt;&lt; "sensor_name_ "
           &lt;&lt; "Failed to init detection.";
@@ -118,17 +118,18 @@ bool DetectionComponent::InternalProc(
   frame-&gt;sensor_info = sensor_info_;
 
   Eigen::Affine3d pose = Eigen::Affine3d::Identity();
+  Eigen::Affine3d pose_novatel = Eigen::Affine3d::Identity();
   const double lidar_query_tf_timestamp =
       timestamp - lidar_query_tf_offset_ * 0.001;
-  if (!lidar2world_trans_.GetSensor2worldTrans(lidar_query_tf_timestamp,
-                                               &amp;pose)) {
+  if (!lidar2world_trans_.GetSensor2worldTrans(lidar_query_tf_timestamp, &amp;pose,
+                                               &amp;pose_novatel)) {
     out_message-&gt;error_code_ = apollo::common::ErrorCode::PERCEPTION_ERROR_TF;
-    AERROR &lt;&lt; "Failed to get pose at time: "
-           &lt;&lt; FORMAT_TIMESTAMP(lidar_query_tf_timestamp);
+    AERROR &lt;&lt; "Failed to get pose at time: " &lt;&lt; lidar_query_tf_timestamp;
     return false;
   }
 
   frame-&gt;lidar2world_pose = pose;
+  frame-&gt;novatel2world_pose = pose_novatel;
 
   lidar::LidarObstacleDetectionOptions detect_opts;
   detect_opts.sensor_name = sensor_name_;
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\detection_component.h" new_path="modules\perception\onboard\component\detection_component.h" added_lines="2" deleted_lines="2">
				<diff>@@ -48,13 +48,13 @@ class DetectionComponent : public cyber::Component&lt;drivers::PointCloud&gt; {
  private:
   static std::atomic&lt;uint32_t&gt; seq_num_;
   std::string sensor_name_;
-  // bool enable_hdmap_ = true;
+  bool enable_hdmap_ = true;
   float lidar_query_tf_offset_ = 20.0f;
   std::string lidar2novatel_tf2_child_frame_id_;
   std::string output_channel_name_;
   base::SensorInfo sensor_info_;
   TransformWrapper lidar2world_trans_;
-  std::unique_ptr&lt;lidar::LidarObstacleDetection&gt; detector_;
+  std::unique_ptr&lt;lidar::BaseLidarObstacleDetection&gt; detector_;
   std::shared_ptr&lt;apollo::cyber::Writer&lt;LidarFrameMessage&gt;&gt; writer_;
 };
 
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\segmentation_component.cc" new_path="" added_lines="0" deleted_lines="162">
				<diff>@@ -1,162 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/onboard/component/segmentation_component.h"
-
-#include "cyber/time/clock.h"
-#include "modules/common/util/perf_util.h"
-#include "modules/perception/common/sensor_manager/sensor_manager.h"
-#include "modules/perception/lidar/common/lidar_error_code.h"
-#include "modules/perception/lidar/common/lidar_frame_pool.h"
-#include "modules/perception/lidar/common/lidar_log.h"
-#include "modules/perception/onboard/common_flags/common_flags.h"
-
-using ::apollo::cyber::Clock;
-
-namespace apollo {
-namespace perception {
-namespace onboard {
-
-uint32_t SegmentationComponent::s_seq_num_ = 0;
-std::mutex SegmentationComponent::s_mutex_;
-
-bool SegmentationComponent::Init() {
-  LidarSegmentationComponentConfig comp_config;
-  if (!GetProtoConfig(&amp;comp_config)) {
-    return false;
-  }
-  ADEBUG &lt;&lt; "Lidar Component Configs: " &lt;&lt; comp_config.DebugString();
-  output_channel_name_ = comp_config.output_channel_name();
-  sensor_name_ = comp_config.sensor_name();
-  lidar2novatel_tf2_child_frame_id_ =
-      comp_config.lidar2novatel_tf2_child_frame_id();
-  lidar_query_tf_offset_ =
-      static_cast&lt;float&gt;(comp_config.lidar_query_tf_offset());
-  enable_hdmap_ = comp_config.enable_hdmap();
-  writer_ = node_-&gt;CreateWriter&lt;LidarFrameMessage&gt;(output_channel_name_);
-
-  if (!InitAlgorithmPlugin()) {
-    AERROR &lt;&lt; "Failed to init segmentation component algorithm plugin.";
-    return false;
-  }
-  return true;
-}
-
-bool SegmentationComponent::Proc(
-    const std::shared_ptr&lt;drivers::PointCloud&gt;&amp; message) {
-  AINFO &lt;&lt; std::setprecision(16)
-        &lt;&lt; "Enter segmentation component, message timestamp: "
-        &lt;&lt; message-&gt;measurement_time() &lt;&lt; " current timestamp: "
-        &lt;&lt; Clock::NowInSeconds();
-
-  std::shared_ptr&lt;LidarFrameMessage&gt; out_message(new (std::nothrow)
-                                                     LidarFrameMessage);
-
-  bool status = InternalProc(message, out_message);
-  if (status) {
-    writer_-&gt;Write(out_message);
-    AINFO &lt;&lt; "Send lidar segment output message.";
-  }
-  return status;
-}
-
-bool SegmentationComponent::InitAlgorithmPlugin() {
-  ACHECK(common::SensorManager::Instance()-&gt;GetSensorInfo(sensor_name_,
-                                                          &amp;sensor_info_));
-
-  segmentor_.reset(new lidar::LidarObstacleSegmentation);
-  if (segmentor_ == nullptr) {
-    AERROR &lt;&lt; "sensor_name_ "
-           &lt;&lt; "Failed to get segmentation instance";
-    return false;
-  }
-  lidar::LidarObstacleDetectionInitOptions init_options;
-  init_options.sensor_name = sensor_name_;
-  init_options.enable_hdmap_input =
-      FLAGS_obs_enable_hdmap_input &amp;&amp; enable_hdmap_;
-  if (!segmentor_-&gt;Init(init_options)) {
-    AINFO &lt;&lt; "sensor_name_ "
-          &lt;&lt; "Failed to init segmentation.";
-    return false;
-  }
-
-  lidar2world_trans_.Init(lidar2novatel_tf2_child_frame_id_);
-  return true;
-}
-
-bool SegmentationComponent::InternalProc(
-    const std::shared_ptr&lt;const drivers::PointCloud&gt;&amp; in_message,
-    const std::shared_ptr&lt;LidarFrameMessage&gt;&amp; out_message) {
-  PERF_FUNCTION_WITH_INDICATOR(sensor_name_);
-  {
-    std::unique_lock&lt;std::mutex&gt; lock(s_mutex_);
-    s_seq_num_++;
-  }
-  const double timestamp = in_message-&gt;measurement_time();
-  const double cur_time = Clock::NowInSeconds();
-  const double start_latency = (cur_time - timestamp) * 1e3;
-  AINFO &lt;&lt; std::setprecision(16) &lt;&lt; "FRAME_STATISTICS:Lidar:Start:msg_time["
-        &lt;&lt; timestamp &lt;&lt; "]:sensor[" &lt;&lt; sensor_name_ &lt;&lt; "]:cur_time[" &lt;&lt; cur_time
-        &lt;&lt; "]:cur_latency[" &lt;&lt; start_latency &lt;&lt; "]";
-
-  out_message-&gt;timestamp_ = timestamp;
-  out_message-&gt;lidar_timestamp_ = in_message-&gt;header().lidar_timestamp();
-  out_message-&gt;seq_num_ = s_seq_num_;
-  out_message-&gt;process_stage_ = ProcessStage::LIDAR_SEGMENTATION;
-  out_message-&gt;error_code_ = apollo::common::ErrorCode::OK;
-
-  auto&amp; frame = out_message-&gt;lidar_frame_;
-  frame = lidar::LidarFramePool::Instance().Get();
-  frame-&gt;cloud = base::PointFCloudPool::Instance().Get();
-  frame-&gt;timestamp = timestamp;
-  frame-&gt;sensor_info = sensor_info_;
-
-  PERF_BLOCK_START();
-  Eigen::Affine3d pose = Eigen::Affine3d::Identity();
-  Eigen::Affine3d pose_novatel = Eigen::Affine3d::Identity();
-  const double lidar_query_tf_timestamp =
-      timestamp - lidar_query_tf_offset_ * 0.001;
-  if (!lidar2world_trans_.GetSensor2worldTrans(lidar_query_tf_timestamp, &amp;pose,
-                                               &amp;pose_novatel)) {
-    out_message-&gt;error_code_ = apollo::common::ErrorCode::PERCEPTION_ERROR_TF;
-    AERROR &lt;&lt; "Failed to get pose at time: " &lt;&lt; lidar_query_tf_timestamp;
-    return false;
-  }
-  PERF_BLOCK_END_WITH_INDICATOR(sensor_name_,
-                                "segmentation_1::get_lidar_to_world_pose");
-
-  frame-&gt;lidar2world_pose = pose;
-  frame-&gt;novatel2world_pose = pose_novatel;
-
-  lidar::LidarObstacleDetectionOptions segment_opts;
-  segment_opts.sensor_name = sensor_name_;
-  lidar2world_trans_.GetExtrinsics(&amp;segment_opts.sensor2novatel_extrinsics);
-  lidar::LidarProcessResult ret =
-      segmentor_-&gt;Process(segment_opts, in_message, frame.get());
-  if (ret.error_code != lidar::LidarErrorCode::Succeed) {
-    out_message-&gt;error_code_ =
-        apollo::common::ErrorCode::PERCEPTION_ERROR_PROCESS;
-    AERROR &lt;&lt; "Lidar segmentation process error, " &lt;&lt; ret.log;
-    return false;
-  }
-  PERF_BLOCK_END_WITH_INDICATOR(sensor_name_,
-                                "segmentation_2::segment_obstacle");
-
-  return true;
-}
-
-}  // namespace onboard
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\segmentation_component.h" new_path="" added_lines="0" deleted_lines="66">
				<diff>@@ -1,66 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;memory&gt;
-#include &lt;string&gt;
-
-#include "cyber/cyber.h"
-#include "modules/drivers/proto/pointcloud.pb.h"
-#include "modules/perception/lidar/app/lidar_obstacle_segmentation.h"
-#include "modules/perception/lidar/common/lidar_frame.h"
-#include "modules/perception/onboard/component/lidar_inner_component_messages.h"
-#include "modules/perception/onboard/proto/lidar_component_config.pb.h"
-#include "modules/perception/onboard/transform_wrapper/transform_wrapper.h"
-
-namespace apollo {
-namespace perception {
-namespace onboard {
-
-class SegmentationComponent : public cyber::Component&lt;drivers::PointCloud&gt; {
- public:
-  SegmentationComponent() : segmentor_(nullptr) {}
-
-  ~SegmentationComponent() = default;
-
-  bool Init() override;
-  bool Proc(const std::shared_ptr&lt;drivers::PointCloud&gt;&amp; message) override;
-
- private:
-  bool InitAlgorithmPlugin();
-  bool InternalProc(
-      const std::shared_ptr&lt;const drivers::PointCloud&gt;&amp; in_message,
-      const std::shared_ptr&lt;LidarFrameMessage&gt;&amp; out_message);
-
- private:
-  static std::mutex s_mutex_;
-  static uint32_t s_seq_num_;
-  std::string sensor_name_;
-  bool enable_hdmap_ = true;
-  float lidar_query_tf_offset_ = 20.0f;
-  std::string lidar2novatel_tf2_child_frame_id_;
-  std::string output_channel_name_;
-  base::SensorInfo sensor_info_;
-  TransformWrapper lidar2world_trans_;
-  std::unique_ptr&lt;lidar::LidarObstacleSegmentation&gt; segmentor_;
-  std::shared_ptr&lt;apollo::cyber::Writer&lt;LidarFrameMessage&gt;&gt; writer_;
-};
-
-CYBER_REGISTER_COMPONENT(SegmentationComponent);
-
-}  // namespace onboard
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\production\conf\perception\lidar\modules\lidar_obstacle_pipeline.config" new_path="modules\perception\production\conf\perception\lidar\modules\lidar_obstacle_pipeline.config" added_lines="0" deleted_lines="9">
				<diff>@@ -1,12 +1,3 @@
-model_configs {
-    name: "LidarObstacleSegmentation"
-    version: "1.0.0"
-    string_params {
-        name: "root_path"
-        value: "./data/perception/lidar/models/lidar_obstacle_pipeline"
-    }
-}
-
 model_configs {
     name: "LidarObstacleDetection"
     version: "1.0.0"
</diff>
			</file>
			<file old_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne128\lidar_obstacle_segmentation.conf" new_path="" added_lines="0" deleted_lines="4">
				<diff>@@ -1,4 +0,0 @@
-preprocessor: "PointCloudPreprocessor"
-segmentor: "CNNSegmentation"
-use_map_manager: true
-use_object_filter_bank: true
</diff>
			</file>
			<file old_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne16\lidar_obstacle_segmentation.conf" new_path="" added_lines="0" deleted_lines="4">
				<diff>@@ -1,4 +0,0 @@
-preprocessor: "PointCloudPreprocessor"
-segmentor: "CNNSegmentation"
-use_map_manager: true
-use_object_filter_bank: true
</diff>
			</file>
			<file old_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne64\lidar_obstacle_segmentation.conf" new_path="" added_lines="0" deleted_lines="4">
				<diff>@@ -1,4 +0,0 @@
-preprocessor: "PointCloudPreprocessor"
-segmentor: "CNNSegmentation"
-use_map_manager: true
-use_object_filter_bank: true
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e618fab6d59892608c2deb57d682d245a6f43d2c" author="haina0421">
		<msg>Adjust cyber schedule conf</msg>
		<modified_files>
			<file old_path="cyber\conf\compute_sched_choreography.conf" new_path="cyber\conf\compute_sched_choreography.conf" added_lines="2" deleted_lines="2">
				<diff>@@ -44,12 +44,12 @@ scheduler_conf {
         prio: 10
       },
       {
-        name: "Velodyne128Segmentation"
+        name: "Velodyne128Detection"
         processor: 3
         prio: 13
       },
       {
-        name: "Velodyne16Segmentation"
+        name: "Velodyne16Detection"
         processor: 3
         prio: 10
       },
</diff>
			</file>
			<file old_path="cyber\conf\compute_sched_classic.conf" new_path="cyber\conf\compute_sched_classic.conf" added_lines="2" deleted_lines="2">
				<diff>@@ -31,7 +31,7 @@ scheduler_conf {
             prio: 11
           },
           {
-            name: "Velodyne16Segmentation"
+            name: "Velodyne16Detection"
             prio: 11
           },
           {
@@ -43,7 +43,7 @@ scheduler_conf {
             prio: 12
           },
           {
-            name: "Velodyne128Segmentation"
+            name: "Velodyne128Detection"
             prio: 13
           },
           {
</diff>
			</file>
			<file old_path="modules\perception\onboard\inner_component_messages\inner_component_messages.h" new_path="modules\perception\onboard\inner_component_messages\inner_component_messages.h" added_lines="2" deleted_lines="3">
				<diff>@@ -29,7 +29,7 @@ namespace onboard {
 
 enum class ProcessStage {
   LIDAR_PREPROCESS = 0,
-  LIDAR_SEGMENTATION = 1,
+  LIDAR_DETECTION = 1,
   LIDAR_RECOGNITION = 2,
   STEREO_CAMERA_DETECTION = 3,
   MONOCULAR_CAMERA_DETECTION = 4,
@@ -38,8 +38,7 @@ enum class ProcessStage {
   ULTRASONIC_DETECTION = 7,
   SENSOR_FUSION = 8,
   UNKNOWN_STAGE = 9,
-  PROCESSSTAGE_COUNT = 10,
-  LIDAR_DETECTION = 11
+  PROCESSSTAGE_COUNT = 10
 };
 
 class Descriptor {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="76d2fbcca4fb33772f8afb3769ac002faf08849d" author="haina0421">
		<msg>delete segmentation and detection folder</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\anchor_mask_cuda.cu" new_path="" added_lines="0" deleted_lines="216">
				<diff>@@ -1,216 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include &lt;algorithm&gt;
-
-// headers in local files
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/anchor_mask_cuda.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/common.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-// modified prefix sum code from
-// https://www.mimuw.edu.pl/~ps209291/kgkp/slides/scan.pdf
-__global__ void scan_x(int* g_odata, int* g_idata, int n) {
-  extern __shared__ int temp[];  // allocated on invocation
-  int thid = threadIdx.x;
-  int bid = blockIdx.x;
-  int bdim = blockDim.x;
-  int offset = 1;
-  temp[2 * thid] =
-      g_idata[bid * bdim * 2 + 2 * thid];  // load input into shared memory
-  temp[2 * thid + 1] = g_idata[bid * bdim * 2 + 2 * thid + 1];
-  for (int d = n &gt;&gt; 1; d &gt; 0; d &gt;&gt;= 1) {  // build sum in place up the tree
-    __syncthreads();
-    if (thid &lt; d) {
-      int ai = offset * (2 * thid + 1) - 1;
-      int bi = offset * (2 * thid + 2) - 1;
-      temp[bi] += temp[ai];
-    }
-    offset *= 2;
-  }
-  if (thid == 0) {
-    temp[n - 1] = 0;
-  }                                 // clear the last element
-  for (int d = 1; d &lt; n; d *= 2) {  // traverse down tree &amp; build scan
-    offset &gt;&gt;= 1;
-    __syncthreads();
-    if (thid &lt; d) {
-      int ai = offset * (2 * thid + 1) - 1;
-      int bi = offset * (2 * thid + 2) - 1;
-      int t = temp[ai];
-      temp[ai] = temp[bi];
-      temp[bi] += t;
-    }
-  }
-  __syncthreads();
-  g_odata[bid * bdim * 2 + 2 * thid] =
-      temp[2 * thid + 1];  // write results to device memory
-  int second_ind = 2 * thid + 2;
-  if (second_ind == bdim * 2) {
-    g_odata[bid * bdim * 2 + 2 * thid + 1] =
-        temp[2 * thid + 1] + g_idata[bid * bdim * 2 + 2 * thid + 1];
-  } else {
-    g_odata[bid * bdim * 2 + 2 * thid + 1] = temp[2 * thid + 2];
-  }
-}
-
-// modified prefix sum code from
-// https://www.mimuw.edu.pl/~ps209291/kgkp/slides/scan.pdf
-__global__ void scan_y(int* g_odata, int* g_idata, int n) {
-  extern __shared__ int temp[];  // allocated on invocation
-  int thid = threadIdx.x;
-  int bid = blockIdx.x;
-  int bdim = blockDim.x;
-  int gdim = gridDim.x;
-  int offset = 1;
-  temp[2 * thid] =
-      g_idata[bid + 2 * thid * gdim];  // load input into shared memory
-  temp[2 * thid + 1] = g_idata[bid + 2 * thid * gdim + gdim];
-  for (int d = n &gt;&gt; 1; d &gt; 0; d &gt;&gt;= 1) {  // build sum in place up the tree
-    __syncthreads();
-    if (thid &lt; d) {
-      int ai = offset * (2 * thid + 1) - 1;
-      int bi = offset * (2 * thid + 2) - 1;
-      temp[bi] += temp[ai];
-    }
-    offset *= 2;
-  }
-  if (thid == 0) {
-    temp[n - 1] = 0;
-  }                                 // clear the last element
-  for (int d = 1; d &lt; n; d *= 2) {  // traverse down tree &amp; build scan
-    offset &gt;&gt;= 1;
-    __syncthreads();
-    if (thid &lt; d) {
-      int ai = offset * (2 * thid + 1) - 1;
-      int bi = offset * (2 * thid + 2) - 1;
-      int t = temp[ai];
-      temp[ai] = temp[bi];
-      temp[bi] += t;
-    }
-  }
-  __syncthreads();
-  g_odata[bid + 2 * thid * gdim] =
-      temp[2 * thid + 1];  // write results to device memory
-  int second_ind = 2 * thid + 2;
-  if (second_ind == bdim * 2) {
-    g_odata[bid + 2 * thid * gdim + gdim] =
-        temp[2 * thid + 1] + g_idata[bid + 2 * thid * gdim + gdim];
-  } else {
-    g_odata[bid + 2 * thid * gdim + gdim] = temp[2 * thid + 2];
-  }
-}
-
-__global__ void make_anchor_mask_kernel(
-    const float* dev_box_anchors_min_x, const float* dev_box_anchors_min_y,
-    const float* dev_box_anchors_max_x, const float* dev_box_anchors_max_y,
-    int* dev_sparse_pillar_map, int* dev_anchor_mask, const float min_x_range,
-    const float min_y_range, const float pillar_x_size,
-    const float pillar_y_size, const int grid_x_size, const int grid_y_size,
-    const int num_inds_for_scan) {
-  int tid = threadIdx.x + blockIdx.x * blockDim.x;
-  int anchor_coor[NUM_2D_BOX_CORNERS_MACRO] = {0};
-  const int grid_x_size_1 = grid_x_size - 1;  // grid_x_size - 1
-  const int grid_y_size_1 = grid_y_size - 1;  // grid_y_size - 1
-
-  anchor_coor[0] =
-      floor((dev_box_anchors_min_x[tid] - min_x_range) / pillar_x_size);
-  anchor_coor[1] =
-      floor((dev_box_anchors_min_y[tid] - min_y_range) / pillar_y_size);
-  anchor_coor[2] =
-      floor((dev_box_anchors_max_x[tid] - min_x_range) / pillar_x_size);
-  anchor_coor[3] =
-      floor((dev_box_anchors_max_y[tid] - min_y_range) / pillar_y_size);
-  anchor_coor[0] = max(anchor_coor[0], 0);
-  anchor_coor[1] = max(anchor_coor[1], 0);
-  anchor_coor[2] = min(anchor_coor[2], grid_x_size_1);
-  anchor_coor[3] = min(anchor_coor[3], grid_y_size_1);
-
-  int right_top = dev_sparse_pillar_map[anchor_coor[3] * num_inds_for_scan +
-                                        anchor_coor[2]];
-  int left_bottom = dev_sparse_pillar_map[anchor_coor[1] * num_inds_for_scan +
-                                          anchor_coor[0]];
-  int left_top = dev_sparse_pillar_map[anchor_coor[3] * num_inds_for_scan +
-                                       anchor_coor[0]];
-  int right_bottom = dev_sparse_pillar_map[anchor_coor[1] * num_inds_for_scan +
-                                           anchor_coor[2]];
-
-  int area = right_top - left_top - right_bottom + left_bottom;
-  if (area &gt; 1) {
-    dev_anchor_mask[tid] = 1;
-  } else {
-    dev_anchor_mask[tid] = 0;
-  }
-}
-
-AnchorMaskCuda::AnchorMaskCuda(
-    const int num_threads, const int num_inds_for_scan, const int num_anchor,
-    const float min_x_range, const float min_y_range, const float pillar_x_size,
-    const float pillar_y_size, const int grid_x_size, const int grid_y_size)
-    : num_threads_(num_threads),
-      num_inds_for_scan_(num_inds_for_scan),
-      num_anchor_(num_anchor),
-      min_x_range_(min_x_range),
-      min_y_range_(min_y_range),
-      pillar_x_size_(pillar_x_size),
-      pillar_y_size_(pillar_y_size),
-      grid_x_size_(grid_x_size),
-      grid_y_size_(grid_y_size) {}
-
-void AnchorMaskCuda::DoAnchorMaskCuda(
-    int* dev_sparse_pillar_map, int* dev_cumsum_along_x,
-    int* dev_cumsum_along_y, const float* dev_box_anchors_min_x,
-    const float* dev_box_anchors_min_y, const float* dev_box_anchors_max_x,
-    const float* dev_box_anchors_max_y, int* dev_anchor_mask) {
-  scan_x&lt;&lt;&lt;num_inds_for_scan_, num_inds_for_scan_ / 2,
-           num_inds_for_scan_ * sizeof(int)&gt;&gt;&gt;(
-      dev_cumsum_along_x, dev_sparse_pillar_map, num_inds_for_scan_);
-  scan_y&lt;&lt;&lt;num_inds_for_scan_, num_inds_for_scan_ / 2,
-           num_inds_for_scan_ * sizeof(int)&gt;&gt;&gt;(
-      dev_cumsum_along_y, dev_cumsum_along_x, num_inds_for_scan_);
-  GPU_CHECK(cudaMemcpy(dev_sparse_pillar_map, dev_cumsum_along_y,
-                       num_inds_for_scan_ * num_inds_for_scan_ * sizeof(int),
-                       cudaMemcpyDeviceToDevice));
-
-  int num_blocks = DIVUP(num_anchor_, num_threads_);
-  make_anchor_mask_kernel&lt;&lt;&lt;num_blocks, num_threads_&gt;&gt;&gt;(
-      dev_box_anchors_min_x, dev_box_anchors_min_y, dev_box_anchors_max_x,
-      dev_box_anchors_max_y, dev_sparse_pillar_map, dev_anchor_mask,
-      min_x_range_, min_y_range_, pillar_x_size_, pillar_y_size_, grid_x_size_,
-      grid_y_size_, num_inds_for_scan_);
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\anchor_mask_cuda.h" new_path="" added_lines="0" deleted_lines="111">
				<diff>@@ -1,111 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file anchor_mask_cuda.h
- * @brief Make anchor mask for filtering output
- * @author Kosuke Murakami
- * @date 2019/02/26
- */
-
-#pragma once
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class AnchorMaskCuda {
- private:
-  const int num_threads_;
-  const int num_inds_for_scan_;
-  const int num_anchor_;
-  const float min_x_range_;
-  const float min_y_range_;
-  const float pillar_x_size_;
-  const float pillar_y_size_;
-  const int grid_x_size_;
-  const int grid_y_size_;
-
- public:
-  /**
-   * @brief Constructor
-   * @param[in] num_threads Number of threads per block
-   * @param[in] num_inds_for_scan Number of indexes for scan(cumsum)
-   * @param[in] num_anchor Number of anchors in total
-   * @param[in] min_x_range Minimum x value for point cloud
-   * @param[in] min_y_range Minimum y value for point cloud
-   * @param[in] pillar_x_size Size of x-dimension for a pillar
-   * @param[in] pillar_y_size Size of y-dimension for a pillar
-   * @param[in] grid_x_size Number of pillars in x-coordinate
-   * @param[in] grid_y_size Number of pillars in y-coordinate
-   * @details Captital variables never change after the compile
-   */
-  AnchorMaskCuda(const int num_threads, const int num_inds_for_scan,
-                 const int num_anchor, const float min_x_range,
-                 const float min_y_range, const float pillar_x_size,
-                 const float pillar_y_size, const int grid_x_size,
-                 const int grid_y_size);
-
-  /**
-   * @brief call cuda code for making anchor mask
-   * @param[in] dev_sparse_pillar_map
-   *   Grid map representation for pillar occupancy
-   * @param[in] dev_cumsum_along_x
-   *   Array for storing cumsum-ed dev_sparse_pillar_map values
-   * @param[in] dev_cumsum_along_y
-   *   Array for storing cumsum-ed dev_cumsum_along_y values
-   * @param[in] dev_box_anchors_min_x
-   *   Array for storing min x value for each anchor
-   * @param[in] dev_box_anchors_min_y
-   *   Array for storing min y value for each anchor
-   * @param[in] dev_box_anchors_max_x
-   *   Array for storing max x value for each anchor
-   * @param[in] dev_box_anchors_max_y
-   *   Array for storing max y value for each anchor
-   * @param[in] dev_box_anchors_max_y
-   *   Array for storing max y value for each anchor
-   * @param[out] dev_anchor_mask Anchor mask for filtering the network output
-   * @details dev_* means device memory. Make a mask for filtering pillar
-   * occupancy area
-   */
-  void DoAnchorMaskCuda(int* dev_sparse_pillar_map, int* dev_cumsum_along_x,
-                        int* dev_cumsum_along_y,
-                        const float* dev_box_anchors_min_x,
-                        const float* dev_box_anchors_min_y,
-                        const float* dev_box_anchors_max_x,
-                        const float* dev_box_anchors_max_y,
-                        int* dev_anchor_mask);
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\common.h" new_path="" added_lines="0" deleted_lines="72">
				<diff>@@ -1,72 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file common.h
- * @brief MACRO for CUDA codes
- * @author Kosuke Murakami
- * @date 2019/02/26
- */
-
-#pragma once
-
-// headers in STL
-#include &lt;stdio.h&gt;
-
-// headers in CUDA
-#include &lt;cuda_runtime_api.h&gt;
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-// using MACRO to allocate memory inside CUDA kernel
-#define NUM_3D_BOX_CORNERS_MACRO 8
-#define NUM_2D_BOX_CORNERS_MACRO 4
-#define NUM_THREADS_MACRO 64  // need to be changed when num_threads_ is changed
-
-#define DIVUP(m, n) ((m) / (n) + ((m) % (n) &gt; 0))
-
-#define GPU_CHECK(ans) \
-  { GPUAssert((ans), __FILE__, __LINE__); }
-inline void GPUAssert(cudaError_t code, const char* file, int line,
-                      bool abort = true) {
-  if (code != cudaSuccess) {
-    fprintf(stderr, "GPUassert: %s %s %d\n", cudaGetErrorString(code), file,
-            line);
-    if (abort) exit(code);
-  }
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\nms_cuda.cu" new_path="" added_lines="0" deleted_lines="141">
				<diff>@@ -1,141 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-// ------------------------------------------------------------------
-// Copyright (c) 2015 Microsoft
-// Licensed under The MIT License
-// Modified from MATLAB Faster R-CNN
-// (https://github.com/shaoqingren/faster_rcnn)
-// ------------------------------------------------------------------
-
-#include &lt;algorithm&gt;
-
-// headers in local files
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/nms_cuda.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-__device__ inline float devIoU(float const *const a, float const *const b) {
-  float left = max(a[0], b[0]), right = min(a[2], b[2]);
-  float top = max(a[1], b[1]), bottom = min(a[3], b[3]);
-  float width = max(right - left + 1, 0.f), height = max(bottom - top + 1, 0.f);
-  float interS = width * height;
-  float Sa = (a[2] - a[0] + 1) * (a[3] - a[1] + 1);
-  float Sb = (b[2] - b[0] + 1) * (b[3] - b[1] + 1);
-  return interS / (Sa + Sb - interS);
-}
-
-__global__ void nms_kernel(const int n_boxes, const float nms_overlap_thresh,
-                           const float *dev_boxes, uint64_t *dev_mask,
-                           const int num_box_corners) {
-  const int row_start = blockIdx.y;
-  const int col_start = blockIdx.x;
-
-  const int block_threads = blockDim.x;
-
-  const int row_size = min(n_boxes - row_start * block_threads, block_threads);
-  const int col_size = min(n_boxes - col_start * block_threads, block_threads);
-
-  __shared__ float block_boxes[NUM_THREADS_MACRO * NUM_2D_BOX_CORNERS_MACRO];
-  if (threadIdx.x &lt; col_size) {
-    block_boxes[threadIdx.x * num_box_corners + 0] =
-        dev_boxes[(block_threads * col_start + threadIdx.x) * num_box_corners +
-                  0];
-    block_boxes[threadIdx.x * num_box_corners + 1] =
-        dev_boxes[(block_threads * col_start + threadIdx.x) * num_box_corners +
-                  1];
-    block_boxes[threadIdx.x * num_box_corners + 2] =
-        dev_boxes[(block_threads * col_start + threadIdx.x) * num_box_corners +
-                  2];
-    block_boxes[threadIdx.x * num_box_corners + 3] =
-        dev_boxes[(block_threads * col_start + threadIdx.x) * num_box_corners +
-                  3];
-  }
-  __syncthreads();
-
-  if (threadIdx.x &lt; row_size) {
-    const int cur_box_idx = block_threads * row_start + threadIdx.x;
-    const float cur_box[NUM_2D_BOX_CORNERS_MACRO] = {
-        dev_boxes[cur_box_idx * num_box_corners + 0],
-        dev_boxes[cur_box_idx * num_box_corners + 1],
-        dev_boxes[cur_box_idx * num_box_corners + 2],
-        dev_boxes[cur_box_idx * num_box_corners + 3]};
-    uint64_t t = 0;
-    int start = 0;
-    if (row_start == col_start) {
-      start = threadIdx.x + 1;
-    }
-    for (int i = start; i &lt; col_size; ++i) {
-      if (devIoU(cur_box, block_boxes + i * num_box_corners) &gt;
-          nms_overlap_thresh) {
-        t |= 1ULL &lt;&lt; i;
-      }
-    }
-    const int col_blocks = DIVUP(n_boxes, block_threads);
-    dev_mask[cur_box_idx * col_blocks + col_start] = t;
-  }
-}
-
-NmsCuda::NmsCuda(const int num_threads, const int num_box_corners,
-                 const float nms_overlap_threshold)
-    : num_threads_(num_threads),
-      num_box_corners_(num_box_corners),
-      nms_overlap_threshold_(nms_overlap_threshold) {}
-
-void NmsCuda::DoNmsCuda(const int host_filter_count,
-                        float *dev_sorted_box_for_nms, int *out_keep_inds,
-                        int *out_num_to_keep) {
-  const int col_blocks = DIVUP(host_filter_count, num_threads_);
-  dim3 blocks(DIVUP(host_filter_count, num_threads_),
-              DIVUP(host_filter_count, num_threads_));
-  dim3 threads(num_threads_);
-
-  uint64_t *dev_mask = NULL;
-  GPU_CHECK(
-      cudaMalloc(&amp;dev_mask, host_filter_count * col_blocks * sizeof(uint64_t)));
-
-  nms_kernel&lt;&lt;&lt;blocks, threads&gt;&gt;&gt;(host_filter_count, nms_overlap_threshold_,
-                                  dev_sorted_box_for_nms, dev_mask,
-                                  num_box_corners_);
-
-  // postprocess for nms output
-  std::vector&lt;uint64_t&gt; host_mask(host_filter_count * col_blocks);
-  GPU_CHECK(cudaMemcpy(&amp;host_mask[0], dev_mask,
-                       sizeof(uint64_t) * host_filter_count * col_blocks,
-                       cudaMemcpyDeviceToHost));
-  std::vector&lt;uint64_t&gt; remv(col_blocks);
-  memset(&amp;remv[0], 0, sizeof(uint64_t) * col_blocks);
-
-  for (int i = 0; i &lt; host_filter_count; ++i) {
-    int nblock = i / num_threads_;
-    int inblock = i % num_threads_;
-
-    if (!(remv[nblock] &amp; (1ULL &lt;&lt; inblock))) {
-      out_keep_inds[(*out_num_to_keep)++] = i;
-      uint64_t *p = &amp;host_mask[0] + i * col_blocks;
-      for (int j = nblock; j &lt; col_blocks; ++j) {
-        remv[j] |= p[j];
-      }
-    }
-  }
-  GPU_CHECK(cudaFree(dev_mask));
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\nms_cuda.h" new_path="" added_lines="0" deleted_lines="85">
				<diff>@@ -1,85 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file nms_cuda.h
- * @brief Non-maximum suppresion for network output
- * @author Modified by Kosuke Murakami
- * @date 2019/02/26
- */
-
-#pragma once
-
-// heders in STL
-#include &lt;iostream&gt;
-#include &lt;vector&gt;
-
-// headers in local files
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/common.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class NmsCuda {
- private:
-  const int num_threads_;
-  const int num_box_corners_;
-  const float nms_overlap_threshold_;
-
- public:
-  /**
-   * @brief Constructor
-   * @param[in] num_threads Number of threads when launching cuda kernel
-   * @param[in] num_box_corners Number of corners for 2D box
-   * @param[in] nms_overlap_threshold IOU threshold for NMS
-   * @details Captital variables never change after the compile, Non-captital
-   * variables could be chaned through rosparam
-   */
-  NmsCuda(const int num_threads, const int num_box_corners,
-          const float nms_overlap_threshold);
-
-  /**
-   * @brief GPU Non-Maximum Suppresion for network output
-   * @param[in] host_filter_count Number of filtered output
-   * @param[in] dev_sorted_box_for_nms Bounding box output sorted by score
-   * @param[out] out_keep_inds Indexes of selected bounding box
-   * @param[out] out_num_to_keep Number of kept bounding boxes
-   * @details NMS in GPU and postprocessing for selecting box in CPU
-   */
-  void DoNmsCuda(const int host_filter_count, float* dev_sorted_box_for_nms,
-                 int* out_keep_inds, int* out_num_to_keep);
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\params.h" new_path="" added_lines="0" deleted_lines="87">
				<diff>@@ -1,87 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-#pragma once
-
-#include &lt;vector&gt;
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class Params {
- public:
-  static constexpr float kPillarXSize = 0.32f;
-  static constexpr float kPillarYSize = 0.32f;
-  static constexpr float kPillarZSize = 6.0f;
-  static constexpr float kMinXRange = -74.88f;
-  static constexpr float kMinYRange = -74.88f;
-  static constexpr float kMinZRange = -2.0f;
-  static constexpr float kMaxXRange = 74.88f;
-  static constexpr float kMaxYRange = 74.88f;
-  static constexpr float kMaxZRange = 4.0f;
-  static constexpr int kNumClass = 3;
-  static constexpr int kMaxNumPillars = 32000;
-  static constexpr int kMaxNumPointsPerPillar = 20;
-  static constexpr int kNumPointFeature = 5;  // x, y, z, i, delta of time
-  static constexpr int kNumAnchor = 468 * 468 * 6;
-  static constexpr int kNumOutputBoxFeature = 7;
-  static constexpr int kBatchSize = 1;
-  static constexpr int kNumIndsForScan = 1024;
-  static constexpr int kNumThreads = 64;
-  static constexpr int kNumBoxCorners = 4;
-
-  static std::vector&lt;int&gt; AnchorStrides() { return std::vector&lt;int&gt;{1}; }
-
-  static std::vector&lt;int&gt; NumAnchorSets() { return std::vector&lt;int&gt;{6}; }
-
-  static std::vector&lt;std::vector&lt;float&gt;&gt; AnchorDxSizes() {
-    return std::vector&lt;std::vector&lt;float&gt;&gt;{
-        std::vector&lt;float&gt;{2.08, 0.84, 0.84}};
-  }
-
-  static std::vector&lt;std::vector&lt;float&gt;&gt; AnchorDySizes() {
-    return std::vector&lt;std::vector&lt;float&gt;&gt;{
-        std::vector&lt;float&gt;{4.73, 1.81, 0.91}};
-  }
-
-  static std::vector&lt;std::vector&lt;float&gt;&gt; AnchorDzSizes() {
-    return std::vector&lt;std::vector&lt;float&gt;&gt;{
-        std::vector&lt;float&gt;{1.77, 1.77, 1.74}};
-  }
-
-  static std::vector&lt;std::vector&lt;float&gt;&gt; AnchorZCoors() {
-    return std::vector&lt;std::vector&lt;float&gt;&gt;{
-        std::vector&lt;float&gt;{-0.0345, -0.1188, 0}};
-  }
-
-  static std::vector&lt;std::vector&lt;int&gt;&gt; NumAnchorRo() {
-    return std::vector&lt;std::vector&lt;int&gt;&gt;{std::vector&lt;int&gt;{2, 2, 2}};
-  }
-
-  static std::vector&lt;std::vector&lt;float&gt;&gt; AnchorRo() {
-    return std::vector&lt;std::vector&lt;float&gt;&gt;{
-        std::vector&lt;float&gt;{0, M_PI / 2, 0, M_PI / 2, 0, M_PI / 2}};
-  }
-
- private:
-  Params() = default;
-  ~Params() = default;
-};  // class Params
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\pfe_cuda.cu" new_path="" added_lines="0" deleted_lines="99">
				<diff>@@ -1,99 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/pfe_cuda.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-__global__ void gather_point_feature_kernel(
-    float* dev_pillar_point_feature, float* dev_num_points_per_pillar,
-    float* dev_pillar_coors, float* dev_pfe_gather_feature,
-    int max_num_points_per_pillar, int num_point_feature,
-    int num_gather_point_feature, float pillar_x_size, float pillar_y_size,
-    float min_x_range, float min_y_range) {
-  int tid = threadIdx.x + blockIdx.x * blockDim.x;
-  float point_mean[3];
-  for (int point_id = 0; point_id &lt; dev_num_points_per_pillar[tid];
-       ++point_id) {
-    for (int i = 0; i &lt; 3; ++i) {
-      int feature_id = i + point_id * num_point_feature +
-                       tid * max_num_points_per_pillar * num_point_feature;
-      point_mean[i] += dev_pillar_point_feature[feature_id];
-    }
-  }
-  for (int i = 0; i &lt; 3; ++i) {
-    point_mean[i] = point_mean[i] / dev_num_points_per_pillar[tid];
-  }
-
-  float x_offset = pillar_x_size / 2 + min_x_range;
-  float y_offset = pillar_y_size / 2 + min_y_range;
-  for (int point_id = 0; point_id &lt; dev_num_points_per_pillar[tid];
-       ++point_id) {
-    int point_head_id = point_id * num_point_feature +
-                        tid * max_num_points_per_pillar * num_point_feature;
-    int pfe_gather_head_id = point_id * num_gather_point_feature +
-        tid * max_num_points_per_pillar * num_gather_point_feature;
-    float point_x = dev_pillar_point_feature[point_head_id];
-    float point_y = dev_pillar_point_feature[point_head_id + 1];
-    dev_pfe_gather_feature[pfe_gather_head_id] =
-        sqrt(point_x * point_x + point_y * point_y);
-    for (int i = 2; i &lt; num_point_feature; ++i) {
-      dev_pfe_gather_feature[pfe_gather_head_id + i - 1] =
-          dev_pillar_point_feature[point_head_id + i];
-    }
-    for (int i = 4; i &lt; 7; ++i) {
-      dev_pfe_gather_feature[pfe_gather_head_id + i] =
-          dev_pillar_point_feature[point_head_id + i - 4] - point_mean[i - 4];
-    }
-    dev_pfe_gather_feature[pfe_gather_head_id + 7] =
-        dev_pillar_point_feature[point_head_id] -
-        (dev_pillar_coors[tid * 4 + 3] * pillar_x_size + x_offset);
-    dev_pfe_gather_feature[pfe_gather_head_id + 8] =
-        dev_pillar_point_feature[point_head_id + 1] -
-        (dev_pillar_coors[tid * 4 + 2] * pillar_y_size + y_offset);
-  }
-}
-
-PfeCuda::PfeCuda(int max_num_pillars, int max_num_points_per_pillar,
-                 int num_point_feature, int num_gather_point_feature,
-                 float pillar_x_size, float pillar_y_size, float min_x_range,
-                 float min_y_range, int num_threads)
-    : max_num_pillars_(max_num_pillars),
-      max_num_points_per_pillar_(max_num_points_per_pillar),
-      num_point_feature_(num_point_feature),
-      num_gather_point_feature_(num_gather_point_feature),
-      pillar_x_size_(pillar_x_size),
-      pillar_y_size_(pillar_y_size),
-      min_x_range_(min_x_range),
-      min_y_range_(min_y_range),
-      num_threads_(num_threads) {}
-
-void PfeCuda::GatherPointFeature(float* dev_pillar_point_feature,
-                                 float* dev_num_points_per_pillar,
-                                 float* dev_pillar_coors,
-                                 float* dev_pfe_gather_feature) {
-  const int num_blocks = DIVUP(max_num_pillars_, num_threads_);
-  gather_point_feature_kernel&lt;&lt;&lt;num_blocks, num_threads_&gt;&gt;&gt;(
-      dev_pillar_point_feature, dev_num_points_per_pillar, dev_pillar_coors,
-      dev_pfe_gather_feature, max_num_points_per_pillar_, num_point_feature_,
-      num_gather_point_feature_, pillar_x_size_, pillar_y_size_, min_x_range_,
-      min_y_range_);
-}
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\pfe_cuda.h" new_path="" added_lines="0" deleted_lines="51">
				<diff>@@ -1,51 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-#pragma once
-
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/common.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class PfeCuda {
- public:
-  PfeCuda(int max_num_pillars, int max_num_points_per_pillar,
-          int num_point_feature, int num_gather_point_feature,
-          float pillar_x_size, float pillar_y_size, float min_x_range,
-          float min_y_range, int num_threads);
-  ~PfeCuda() = default;
-
-  void GatherPointFeature(float* dev_pillar_point_feature,
-                          float* dev_num_points_per_pillar,
-                          float* dev_pillar_coors,
-                          float* dev_pfe_gather_feature);
-
- private:
-  int max_num_pillars_;
-  int max_num_points_per_pillar_;
-  int num_point_feature_;
-  int num_gather_point_feature_;
-  float pillar_x_size_;
-  float pillar_y_size_;
-  float min_x_range_;
-  float min_y_range_;
-  int num_threads_;
-};
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars.cc" new_path="" added_lines="0" deleted_lines="691">
				<diff>@@ -1,691 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/point_pillars.h"
-
-#include &lt;chrono&gt;
-#include &lt;iostream&gt;
-
-#include "cyber/common/log.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-const float PointPillars::kPillarXSize = Params::kPillarXSize;
-const float PointPillars::kPillarYSize = Params::kPillarYSize;
-const float PointPillars::kPillarZSize = Params::kPillarZSize;
-const float PointPillars::kMinXRange = Params::kMinXRange;
-const float PointPillars::kMinYRange = Params::kMinYRange;
-const float PointPillars::kMinZRange = Params::kMinZRange;
-const float PointPillars::kMaxXRange = Params::kMaxXRange;
-const float PointPillars::kMaxYRange = Params::kMaxYRange;
-const float PointPillars::kMaxZRange = Params::kMaxZRange;
-const int PointPillars::kNumClass = Params::kNumClass;
-const int PointPillars::kMaxNumPillars = Params::kMaxNumPillars;
-const int PointPillars::kMaxNumPointsPerPillar = Params::kMaxNumPointsPerPillar;
-const int PointPillars::kNumPointFeature = Params::kNumPointFeature;
-const int PointPillars::kGridXSize =
-    static_cast&lt;int&gt;((kMaxXRange - kMinXRange) / kPillarXSize);
-const int PointPillars::kGridYSize =
-    static_cast&lt;int&gt;((kMaxYRange - kMinYRange) / kPillarYSize);
-const int PointPillars::kGridZSize =
-    static_cast&lt;int&gt;((kMaxZRange - kMinZRange) / kPillarZSize);
-const int PointPillars::kRpnInputSize = 64 * kGridXSize * kGridYSize;
-const int PointPillars::kNumAnchor = Params::kNumAnchor;
-const int PointPillars::kNumOutputBoxFeature = Params::kNumOutputBoxFeature;
-const int PointPillars::kRpnBoxOutputSize = kNumAnchor * kNumOutputBoxFeature;
-const int PointPillars::kRpnClsOutputSize = kNumAnchor * kNumClass;
-const int PointPillars::kRpnDirOutputSize = kNumAnchor * 2;
-const int PointPillars::kBatchSize = Params::kBatchSize;
-const int PointPillars::kNumIndsForScan = Params::kNumIndsForScan;
-const int PointPillars::kNumThreads = Params::kNumThreads;
-// if you change kNumThreads, need to modify NUM_THREADS_MACRO in
-// common.h
-const int PointPillars::kNumBoxCorners = Params::kNumBoxCorners;
-const std::vector&lt;int&gt; PointPillars::kAnchorStrides = Params::AnchorStrides();
-const std::vector&lt;int&gt; PointPillars::kAnchorRanges{
-    0,
-    kGridXSize,
-    0,
-    kGridYSize,
-    static_cast&lt;int&gt;(kGridXSize * 0.25),
-    static_cast&lt;int&gt;(kGridXSize * 0.75),
-    static_cast&lt;int&gt;(kGridYSize * 0.25),
-    static_cast&lt;int&gt;(kGridYSize * 0.75)};
-const std::vector&lt;int&gt; PointPillars::kNumAnchorSets = Params::NumAnchorSets();
-const std::vector&lt;std::vector&lt;float&gt;&gt; PointPillars::kAnchorDxSizes =
-    Params::AnchorDxSizes();
-const std::vector&lt;std::vector&lt;float&gt;&gt; PointPillars::kAnchorDySizes =
-    Params::AnchorDySizes();
-const std::vector&lt;std::vector&lt;float&gt;&gt; PointPillars::kAnchorDzSizes =
-    Params::AnchorDzSizes();
-const std::vector&lt;std::vector&lt;float&gt;&gt; PointPillars::kAnchorZCoors =
-    Params::AnchorZCoors();
-const std::vector&lt;std::vector&lt;int&gt;&gt; PointPillars::kNumAnchorRo =
-    Params::NumAnchorRo();
-const std::vector&lt;std::vector&lt;float&gt;&gt; PointPillars::kAnchorRo =
-    Params::AnchorRo();
-
-PointPillars::PointPillars(const bool reproduce_result_mode,
-                           const float score_threshold,
-                           const float nms_overlap_threshold,
-                           const std::string&amp; pfe_torch_file,
-                           const std::string&amp; scattered_torch_file,
-                           const std::string&amp; backbone_torch_file,
-                           const std::string&amp; fpn_torch_file,
-                           const std::string&amp; bbox_head_torch_file)
-    : reproduce_result_mode_(reproduce_result_mode),
-      score_threshold_(score_threshold),
-      nms_overlap_threshold_(nms_overlap_threshold),
-      pfe_torch_file_(pfe_torch_file),
-      scattered_torch_file_(scattered_torch_file),
-      backbone_torch_file_(backbone_torch_file),
-      fpn_torch_file_(fpn_torch_file),
-      bbox_head_torch_file_(bbox_head_torch_file) {
-  if (reproduce_result_mode_) {
-    preprocess_points_ptr_.reset(new PreprocessPoints(
-        kMaxNumPillars, kMaxNumPointsPerPillar, kNumPointFeature, kGridXSize,
-        kGridYSize, kGridZSize, kPillarXSize, kPillarYSize, kPillarZSize,
-        kMinXRange, kMinYRange, kMinZRange, kNumIndsForScan));
-  } else {
-    preprocess_points_cuda_ptr_.reset(new PreprocessPointsCuda(
-        kNumThreads, kMaxNumPillars, kMaxNumPointsPerPillar, kNumPointFeature,
-        kNumIndsForScan, kGridXSize, kGridYSize, kGridZSize, kPillarXSize,
-        kPillarYSize, kPillarZSize, kMinXRange, kMinYRange, kMinZRange));
-  }
-
-  anchor_mask_cuda_ptr_.reset(new AnchorMaskCuda(
-      kNumThreads, kNumIndsForScan, kNumAnchor, kMinXRange, kMinYRange,
-      kPillarXSize, kPillarYSize, kGridXSize, kGridYSize));
-
-  const float float_min = std::numeric_limits&lt;float&gt;::lowest();
-  const float float_max = std::numeric_limits&lt;float&gt;::max();
-  postprocess_cuda_ptr_.reset(
-      new PostprocessCuda(float_min, float_max, kNumAnchor, kNumClass,
-                          score_threshold_, kNumThreads, nms_overlap_threshold_,
-                          kNumBoxCorners, kNumOutputBoxFeature));
-
-  DeviceMemoryMalloc();
-  InitTorch();
-  InitAnchors();
-}
-
-PointPillars::~PointPillars() {
-  delete[] anchors_px_;
-  delete[] anchors_py_;
-  delete[] anchors_pz_;
-  delete[] anchors_dx_;
-  delete[] anchors_dy_;
-  delete[] anchors_dz_;
-  delete[] anchors_ro_;
-  delete[] box_anchors_min_x_;
-  delete[] box_anchors_min_y_;
-  delete[] box_anchors_max_x_;
-  delete[] box_anchors_max_y_;
-
-  GPU_CHECK(cudaFree(dev_x_coors_));
-  GPU_CHECK(cudaFree(dev_y_coors_));
-  GPU_CHECK(cudaFree(dev_num_points_per_pillar_));
-  GPU_CHECK(cudaFree(dev_sparse_pillar_map_));
-  GPU_CHECK(cudaFree(dev_pillar_point_feature_));
-  GPU_CHECK(cudaFree(dev_pillar_coors_));
-
-  GPU_CHECK(cudaFree(dev_cumsum_along_x_));
-  GPU_CHECK(cudaFree(dev_cumsum_along_y_));
-
-  GPU_CHECK(cudaFree(dev_box_anchors_min_x_));
-  GPU_CHECK(cudaFree(dev_box_anchors_min_y_));
-  GPU_CHECK(cudaFree(dev_box_anchors_max_x_));
-  GPU_CHECK(cudaFree(dev_box_anchors_max_y_));
-  GPU_CHECK(cudaFree(dev_anchor_mask_));
-
-  GPU_CHECK(cudaFree(pfe_buffers_[0]));
-  GPU_CHECK(cudaFree(pfe_buffers_[1]));
-  GPU_CHECK(cudaFree(pfe_buffers_[2]));
-
-  GPU_CHECK(cudaFree(rpn_buffers_[0]));
-  GPU_CHECK(cudaFree(rpn_buffers_[1]));
-  GPU_CHECK(cudaFree(rpn_buffers_[2]));
-  GPU_CHECK(cudaFree(rpn_buffers_[3]));
-
-  GPU_CHECK(cudaFree(dev_scattered_feature_));
-
-  GPU_CHECK(cudaFree(dev_anchors_px_));
-  GPU_CHECK(cudaFree(dev_anchors_py_));
-  GPU_CHECK(cudaFree(dev_anchors_pz_));
-  GPU_CHECK(cudaFree(dev_anchors_dx_));
-  GPU_CHECK(cudaFree(dev_anchors_dy_));
-  GPU_CHECK(cudaFree(dev_anchors_dz_));
-  GPU_CHECK(cudaFree(dev_anchors_ro_));
-  GPU_CHECK(cudaFree(dev_filtered_box_));
-  GPU_CHECK(cudaFree(dev_filtered_score_));
-  GPU_CHECK(cudaFree(dev_filtered_label_));
-  GPU_CHECK(cudaFree(dev_filtered_dir_));
-  GPU_CHECK(cudaFree(dev_box_for_nms_));
-  GPU_CHECK(cudaFree(dev_filter_count_));
-}
-
-void PointPillars::DeviceMemoryMalloc() {
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_x_coors_),
-                       kMaxNumPillars * sizeof(int)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_y_coors_),
-                       kMaxNumPillars * sizeof(int)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_num_points_per_pillar_),
-                       kMaxNumPillars * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_sparse_pillar_map_),
-                       kNumIndsForScan * kNumIndsForScan * sizeof(int)));
-
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_pillar_point_feature_),
-                       kMaxNumPillars * kMaxNumPointsPerPillar *
-                           kNumPointFeature * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_pillar_coors_),
-                       kMaxNumPillars * 4 * sizeof(float)));
-
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_cumsum_along_x_),
-                       kNumIndsForScan * kNumIndsForScan * sizeof(int)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_cumsum_along_y_),
-                       kNumIndsForScan * kNumIndsForScan * sizeof(int)));
-
-  // for make anchor mask kernel
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_box_anchors_min_x_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_box_anchors_min_y_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_box_anchors_max_x_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_box_anchors_max_y_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_anchor_mask_),
-                       kNumAnchor * sizeof(int)));
-
-  // for trt inference
-  // create GPU buffers and a stream
-  GPU_CHECK(
-      cudaMalloc(&amp;pfe_buffers_[0], kMaxNumPillars * kMaxNumPointsPerPillar *
-                                       kNumPointFeature * sizeof(float)));
-  GPU_CHECK(cudaMalloc(&amp;pfe_buffers_[1], kMaxNumPillars * sizeof(float)));
-  GPU_CHECK(cudaMalloc(&amp;pfe_buffers_[2], kMaxNumPillars * 4 * sizeof(float)));
-
-  GPU_CHECK(cudaMalloc(&amp;rpn_buffers_[0], kRpnInputSize * sizeof(float)));
-  GPU_CHECK(cudaMalloc(&amp;rpn_buffers_[1], kRpnBoxOutputSize * sizeof(float)));
-  GPU_CHECK(cudaMalloc(&amp;rpn_buffers_[2], kRpnClsOutputSize * sizeof(float)));
-  GPU_CHECK(cudaMalloc(&amp;rpn_buffers_[3], kRpnDirOutputSize * sizeof(float)));
-
-  // for scatter kernel
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_scattered_feature_),
-                       kNumThreads * kGridYSize * kGridXSize * sizeof(float)));
-
-  // for filter
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_anchors_px_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_anchors_py_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_anchors_pz_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_anchors_dx_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_anchors_dy_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_anchors_dz_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_anchors_ro_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_filtered_box_),
-                       kNumAnchor * kNumOutputBoxFeature * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_filtered_score_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_filtered_label_),
-                       kNumAnchor * sizeof(int)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_filtered_dir_),
-                       kNumAnchor * sizeof(int)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_box_for_nms_),
-                       kNumAnchor * kNumBoxCorners * sizeof(float)));
-  GPU_CHECK(
-      cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_filter_count_), sizeof(int)));
-}
-
-void PointPillars::InitAnchors() {
-  // allocate memory for anchors
-  anchors_px_ = new float[kNumAnchor]();
-  anchors_py_ = new float[kNumAnchor]();
-  anchors_pz_ = new float[kNumAnchor]();
-  anchors_dx_ = new float[kNumAnchor]();
-  anchors_dy_ = new float[kNumAnchor]();
-  anchors_dz_ = new float[kNumAnchor]();
-  anchors_ro_ = new float[kNumAnchor]();
-  box_anchors_min_x_ = new float[kNumAnchor]();
-  box_anchors_min_y_ = new float[kNumAnchor]();
-  box_anchors_max_x_ = new float[kNumAnchor]();
-  box_anchors_max_y_ = new float[kNumAnchor]();
-  // deallocate these memories in destructor
-
-  GenerateAnchors(anchors_px_, anchors_py_, anchors_pz_, anchors_dx_,
-                  anchors_dy_, anchors_dz_, anchors_ro_);
-
-  ConvertAnchors2BoxAnchors(anchors_px_, anchors_py_, box_anchors_min_x_,
-                            box_anchors_min_y_, box_anchors_max_x_,
-                            box_anchors_max_y_);
-
-  PutAnchorsInDeviceMemory();
-}
-
-void PointPillars::GenerateAnchors(float* anchors_px_, float* anchors_py_,
-                                   float* anchors_pz_, float* anchors_dx_,
-                                   float* anchors_dy_, float* anchors_dz_,
-                                   float* anchors_ro_) {
-  for (int i = 0; i &lt; kNumAnchor; ++i) {
-    anchors_px_[i] = 0;
-    anchors_py_[i] = 0;
-    anchors_pz_[i] = 0;
-    anchors_dx_[i] = 0;
-    anchors_dy_[i] = 0;
-    anchors_dz_[i] = 0;
-    anchors_ro_[i] = 0;
-    box_anchors_min_x_[i] = 0;
-    box_anchors_min_y_[i] = 0;
-    box_anchors_max_x_[i] = 0;
-    box_anchors_max_y_[i] = 0;
-  }
-
-  int ind = 0;
-  for (size_t head = 0; head &lt; kNumAnchorSets.size(); ++head) {
-    float x_stride = kPillarXSize * kAnchorStrides[head];
-    float y_stride = kPillarYSize * kAnchorStrides[head];
-    int x_ind_start = kAnchorRanges[head * 4 + 0] / kAnchorStrides[head];
-    int x_ind_end = kAnchorRanges[head * 4 + 1] / kAnchorStrides[head];
-    int y_ind_start = kAnchorRanges[head * 4 + 2] / kAnchorStrides[head];
-    int y_ind_end = kAnchorRanges[head * 4 + 3] / kAnchorStrides[head];
-    // coors of first anchor's center
-    float x_offset = kMinXRange + x_stride / 2.0;
-    float y_offset = kMinYRange + y_stride / 2.0;
-
-    std::vector&lt;float&gt; anchor_x_count, anchor_y_count;
-    for (int i = x_ind_start; i &lt; x_ind_end; ++i) {
-      float anchor_coor_x = static_cast&lt;float&gt;(i) * x_stride + x_offset;
-      anchor_x_count.push_back(anchor_coor_x);
-    }
-    for (int i = y_ind_start; i &lt; y_ind_end; ++i) {
-      float anchor_coor_y = static_cast&lt;float&gt;(i) * y_stride + y_offset;
-      anchor_y_count.push_back(anchor_coor_y);
-    }
-
-    for (int y = 0; y &lt; y_ind_end - y_ind_start; ++y) {
-      for (int x = 0; x &lt; x_ind_end - x_ind_start; ++x) {
-        int ro_count = 0;
-        for (size_t c = 0; c &lt; kNumAnchorRo[head].size(); ++c) {
-          for (int i = 0; i &lt; kNumAnchorRo[head][c]; ++i) {
-            anchors_px_[ind] = anchor_x_count[x];
-            anchors_py_[ind] = anchor_y_count[y];
-            anchors_ro_[ind] = kAnchorRo[head][ro_count];
-            anchors_pz_[ind] = kAnchorZCoors[head][c];
-            anchors_dx_[ind] = kAnchorDxSizes[head][c];
-            anchors_dy_[ind] = kAnchorDySizes[head][c];
-            anchors_dz_[ind] = kAnchorDzSizes[head][c];
-            ro_count++;
-            ind++;
-          }
-        }
-      }
-    }
-  }
-}
-
-void PointPillars::PutAnchorsInDeviceMemory() {
-  GPU_CHECK(cudaMemcpy(dev_box_anchors_min_x_, box_anchors_min_x_,
-                       kNumAnchor * sizeof(float), cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_box_anchors_min_y_, box_anchors_min_y_,
-                       kNumAnchor * sizeof(float), cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_box_anchors_max_x_, box_anchors_max_x_,
-                       kNumAnchor * sizeof(float), cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_box_anchors_max_y_, box_anchors_max_y_,
-                       kNumAnchor * sizeof(float), cudaMemcpyHostToDevice));
-
-  GPU_CHECK(cudaMemcpy(dev_anchors_px_, anchors_px_, kNumAnchor * sizeof(float),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_anchors_py_, anchors_py_, kNumAnchor * sizeof(float),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_anchors_pz_, anchors_pz_, kNumAnchor * sizeof(float),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_anchors_dx_, anchors_dx_, kNumAnchor * sizeof(float),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_anchors_dy_, anchors_dy_, kNumAnchor * sizeof(float),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_anchors_dz_, anchors_dz_, kNumAnchor * sizeof(float),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_anchors_ro_, anchors_ro_, kNumAnchor * sizeof(float),
-                       cudaMemcpyHostToDevice));
-}
-
-void PointPillars::ConvertAnchors2BoxAnchors(float* anchors_px,
-                                             float* anchors_py,
-                                             float* box_anchors_min_x_,
-                                             float* box_anchors_min_y_,
-                                             float* box_anchors_max_x_,
-                                             float* box_anchors_max_y_) {
-  // flipping box's dimension
-  float* flipped_anchors_dx = new float[kNumAnchor]();
-  float* flipped_anchors_dy = new float[kNumAnchor]();
-
-  int ind = 0;
-  for (size_t head = 0; head &lt; kNumAnchorSets.size(); ++head) {
-    int num_x_inds =
-        (kAnchorRanges[head * 4 + 1] - kAnchorRanges[head * 4 + 0]) /
-        kAnchorStrides[head];
-    int num_y_inds =
-        (kAnchorRanges[head * 4 + 3] - kAnchorRanges[head * 4 + 2]) /
-        kAnchorStrides[head];
-    int base_ind = ind;
-    int ro_count = 0;
-    for (int x = 0; x &lt; num_x_inds; ++x) {
-      for (int y = 0; y &lt; num_y_inds; ++y) {
-        ro_count = 0;
-        for (size_t c = 0; c &lt; kNumAnchorRo[head].size(); ++c) {
-          for (int i = 0; i &lt; kNumAnchorRo[head][c]; ++i) {
-            if (kAnchorRo[head][ro_count] &lt;= 0.78) {
-              flipped_anchors_dx[base_ind] = kAnchorDxSizes[head][c];
-              flipped_anchors_dy[base_ind] = kAnchorDySizes[head][c];
-            } else {
-              flipped_anchors_dx[base_ind] = kAnchorDySizes[head][c];
-              flipped_anchors_dy[base_ind] = kAnchorDxSizes[head][c];
-            }
-            ro_count++;
-            base_ind++;
-          }
-        }
-      }
-    }
-
-    for (int x = 0; x &lt; num_x_inds; ++x) {
-      for (int y = 0; y &lt; num_y_inds; ++y) {
-        for (size_t i = 0; i &lt; kAnchorRo[head].size(); ++i) {
-          box_anchors_min_x_[ind] =
-              anchors_px[ind] - flipped_anchors_dx[ind] / 2.0f;
-          box_anchors_min_y_[ind] =
-              anchors_py[ind] - flipped_anchors_dy[ind] / 2.0f;
-          box_anchors_max_x_[ind] =
-              anchors_px[ind] + flipped_anchors_dx[ind] / 2.0f;
-          box_anchors_max_y_[ind] =
-              anchors_py[ind] + flipped_anchors_dy[ind] / 2.0f;
-          ind++;
-        }
-      }
-    }
-  }
-
-  delete[] flipped_anchors_dx;
-  delete[] flipped_anchors_dy;
-}
-
-void PointPillars::InitTorch() {
-  if (gpu_id_ &gt;= 0) {
-    device_type_ = torch::kCUDA;
-    device_id_ = gpu_id_;
-  } else {
-    device_type_ = torch::kCPU;
-  }
-
-  // Init torch net
-  torch::Device device(device_type_, device_id_);
-
-  pfe_net_ = torch::jit::load(pfe_torch_file_, device);
-  scattered_net_ = torch::jit::load(scattered_torch_file_, device);
-  backbone_net_ = torch::jit::load(backbone_torch_file_, device);
-  fpn_net_ = torch::jit::load(fpn_torch_file_, device);
-  bbox_head_net_ = torch::jit::load(bbox_head_torch_file_, device);
-}
-
-void PointPillars::InitTRT() {
-  // create a TensorRT model from the onnx model and load it into an engine
-  OnnxToTRTModel(pfe_onnx_file_, &amp;pfe_engine_);
-  OnnxToTRTModel(rpn_onnx_file_, &amp;rpn_engine_);
-  if (pfe_engine_ == nullptr || rpn_engine_ == nullptr) {
-    AERROR &lt;&lt; "Failed to load ONNX file.";
-  }
-
-  // create execution context from the engine
-  pfe_context_ = pfe_engine_-&gt;createExecutionContext();
-  rpn_context_ = rpn_engine_-&gt;createExecutionContext();
-  if (pfe_context_ == nullptr || rpn_context_ == nullptr) {
-    AERROR &lt;&lt; "Failed to create TensorRT Execution Context.";
-  }
-}
-
-void PointPillars::OnnxToTRTModel(
-    const std::string&amp; model_file,  // name of the onnx model
-    nvinfer1::ICudaEngine** engine_ptr) {
-  int verbosity = static_cast&lt;int&gt;(nvinfer1::ILogger::Severity::kWARNING);
-
-  // create the builder
-  const auto explicit_batch =
-      static_cast&lt;uint32_t&gt;(kBatchSize) &lt;&lt; static_cast&lt;uint32_t&gt;(
-          nvinfer1::NetworkDefinitionCreationFlag::kEXPLICIT_BATCH);
-  nvinfer1::IBuilder* builder = nvinfer1::createInferBuilder(g_logger_);
-  nvinfer1::INetworkDefinition* network =
-      builder-&gt;createNetworkV2(explicit_batch);
-
-  // parse onnx model
-  auto parser = nvonnxparser::createParser(*network, g_logger_);
-  if (!parser-&gt;parseFromFile(model_file.c_str(), verbosity)) {
-    std::string msg("failed to parse onnx file");
-    g_logger_.log(nvinfer1::ILogger::Severity::kERROR, msg.c_str());
-    exit(EXIT_FAILURE);
-  }
-
-  // Build the engine
-  builder-&gt;setMaxBatchSize(kBatchSize);
-  nvinfer1::IBuilderConfig* config = builder-&gt;createBuilderConfig();
-  config-&gt;setMaxWorkspaceSize(1 &lt;&lt; 20);
-  nvinfer1::ICudaEngine* engine =
-      builder-&gt;buildEngineWithConfig(*network, *config);
-
-  *engine_ptr = engine;
-  parser-&gt;destroy();
-  network-&gt;destroy();
-  config-&gt;destroy();
-  builder-&gt;destroy();
-}
-
-void PointPillars::PreprocessCPU(const float* in_points_array,
-                                 const int in_num_points) {
-  int x_coors[kMaxNumPillars] = {};
-  int y_coors[kMaxNumPillars] = {};
-  float num_points_per_pillar[kMaxNumPillars] = {};
-
-  float* pillar_point_feature =
-      new float[kMaxNumPillars * kMaxNumPointsPerPillar * kNumPointFeature];
-  float* pillar_coors = new float[kMaxNumPillars * 4];
-  float* sparse_pillar_map = new float[kNumIndsForScan * kNumIndsForScan];
-
-  preprocess_points_ptr_-&gt;Preprocess(in_points_array, in_num_points, x_coors,
-                                     y_coors, num_points_per_pillar,
-                                     pillar_point_feature, pillar_coors,
-                                     sparse_pillar_map, host_pillar_count_);
-
-  GPU_CHECK(cudaMemset(dev_x_coors_, 0, kMaxNumPillars * sizeof(int)));
-  GPU_CHECK(cudaMemset(dev_y_coors_, 0, kMaxNumPillars * sizeof(int)));
-  GPU_CHECK(cudaMemset(dev_pillar_point_feature_, 0,
-                       kMaxNumPillars * kMaxNumPointsPerPillar *
-                           kNumPointFeature * sizeof(float)));
-  GPU_CHECK(
-      cudaMemset(dev_pillar_coors_, 0, kMaxNumPillars * 4 * sizeof(float)));
-  GPU_CHECK(cudaMemset(dev_num_points_per_pillar_, 0,
-                       kMaxNumPillars * sizeof(float)));
-  GPU_CHECK(cudaMemset(dev_sparse_pillar_map_, 0,
-                       kNumIndsForScan * kNumIndsForScan * sizeof(int)));
-
-  GPU_CHECK(cudaMemcpy(dev_x_coors_, x_coors, kMaxNumPillars * sizeof(int),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_y_coors_, y_coors, kMaxNumPillars * sizeof(int),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_pillar_point_feature_, pillar_point_feature,
-                       kMaxNumPillars * kMaxNumPointsPerPillar *
-                           kNumPointFeature * sizeof(float),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_pillar_coors_, pillar_coors,
-                       kMaxNumPillars * 4 * sizeof(float),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_num_points_per_pillar_, num_points_per_pillar,
-                       kMaxNumPillars * sizeof(float), cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_sparse_pillar_map_, sparse_pillar_map,
-                       kNumIndsForScan * kNumIndsForScan * sizeof(float),
-                       cudaMemcpyHostToDevice));
-
-  delete[] pillar_point_feature;
-  delete[] pillar_coors;
-  delete[] sparse_pillar_map;
-}
-
-void PointPillars::PreprocessGPU(const float* in_points_array,
-                                 const int in_num_points) {
-  float* dev_points;
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_points),
-                       in_num_points * kNumPointFeature * sizeof(float)));
-  GPU_CHECK(cudaMemcpy(dev_points, in_points_array,
-                       in_num_points * kNumPointFeature * sizeof(float),
-                       cudaMemcpyHostToDevice));
-
-  GPU_CHECK(cudaMemset(dev_x_coors_, 0, kMaxNumPillars * sizeof(int)));
-  GPU_CHECK(cudaMemset(dev_y_coors_, 0, kMaxNumPillars * sizeof(int)));
-  GPU_CHECK(cudaMemset(dev_num_points_per_pillar_, 0,
-                       kMaxNumPillars * sizeof(float)));
-  GPU_CHECK(cudaMemset(dev_pillar_point_feature_, 0,
-                       kMaxNumPillars * kMaxNumPointsPerPillar *
-                           kNumPointFeature * sizeof(float)));
-  GPU_CHECK(
-      cudaMemset(dev_pillar_coors_, 0, kMaxNumPillars * 4 * sizeof(float)));
-  GPU_CHECK(cudaMemset(dev_sparse_pillar_map_, 0,
-                       kNumIndsForScan * kNumIndsForScan * sizeof(int)));
-  host_pillar_count_[0] = 0;
-
-  GPU_CHECK(cudaMemset(dev_anchor_mask_, 0, kNumAnchor * sizeof(int)));
-
-  preprocess_points_cuda_ptr_-&gt;DoPreprocessPointsCuda(
-      dev_points, in_num_points, dev_x_coors_, dev_y_coors_,
-      dev_num_points_per_pillar_, dev_pillar_point_feature_, dev_pillar_coors_,
-      dev_sparse_pillar_map_, host_pillar_count_);
-
-  GPU_CHECK(cudaFree(dev_points));
-}
-
-void PointPillars::Preprocess(const float* in_points_array,
-                              const int in_num_points) {
-  if (reproduce_result_mode_) {
-    PreprocessCPU(in_points_array, in_num_points);
-  } else {
-    PreprocessGPU(in_points_array, in_num_points);
-  }
-}
-
-void PointPillars::DoInference(const float* in_points_array,
-                               const int in_num_points,
-                               std::vector&lt;float&gt;* out_detections,
-                               std::vector&lt;int&gt;* out_labels) {
-  if (device_id_ &lt; 0) {
-    AERROR &lt;&lt; "Torch is not using GPU!";
-    return;
-  }
-
-  Preprocess(in_points_array, in_num_points);
-
-  anchor_mask_cuda_ptr_-&gt;DoAnchorMaskCuda(
-      dev_sparse_pillar_map_, dev_cumsum_along_x_, dev_cumsum_along_y_,
-      dev_box_anchors_min_x_, dev_box_anchors_min_y_, dev_box_anchors_max_x_,
-      dev_box_anchors_max_y_, dev_anchor_mask_);
-
-  cudaStream_t stream;
-  GPU_CHECK(cudaStreamCreate(&amp;stream));
-  GPU_CHECK(cudaMemcpyAsync(pfe_buffers_[0], dev_pillar_point_feature_,
-                            kMaxNumPillars * kMaxNumPointsPerPillar *
-                                kNumPointFeature * sizeof(float),
-                            cudaMemcpyDeviceToDevice, stream));
-  GPU_CHECK(cudaMemcpyAsync(pfe_buffers_[1], dev_num_points_per_pillar_,
-                            kMaxNumPillars * sizeof(float),
-                            cudaMemcpyDeviceToDevice, stream));
-  GPU_CHECK(cudaMemcpyAsync(pfe_buffers_[2], dev_pillar_coors_,
-                            kMaxNumPillars * 4 * sizeof(float),
-                            cudaMemcpyDeviceToDevice, stream));
-
-  torch::Tensor tensor_pillar_point_feature = torch::from_blob(
-      pfe_buffers_[0],
-      {kMaxNumPillars, kMaxNumPointsPerPillar, kNumPointFeature}, torch::kCUDA);
-  torch::Tensor tensor_num_points_per_pillar =
-      torch::from_blob(pfe_buffers_[1], {kMaxNumPillars}, torch::kCUDA);
-  torch::Tensor tensor_pillar_coors =
-      torch::from_blob(pfe_buffers_[2], {kMaxNumPillars, 4}, torch::kCUDA);
-
-  torch::Device device(device_type_, device_id_);
-  tensor_pillar_point_feature.to(device);
-  tensor_num_points_per_pillar.to(device);
-  tensor_pillar_coors.to(device);
-
-  torch::Tensor scattered_batch_size = torch::ones(1);
-  scattered_batch_size.to(device);
-
-  auto pfe_output =
-      pfe_net_
-          .forward({tensor_pillar_point_feature, tensor_num_points_per_pillar,
-                    tensor_pillar_coors})
-          .toTensor();
-
-  auto scattered_feature =
-      scattered_net_
-          .forward({pfe_output, tensor_pillar_coors, scattered_batch_size})
-          .toTensor();
-
-  auto backbone_feature = backbone_net_.forward({scattered_feature});
-
-  auto fpn_feature = fpn_net_.forward({backbone_feature});
-
-  auto bbox_head_output = bbox_head_net_.forward({fpn_feature}).toTuple();
-
-  auto cls_score = bbox_head_output-&gt;elements()[0].toTensor();
-  auto bbox_pred = bbox_head_output-&gt;elements()[1].toTensor();
-  auto dir_cls_preds = bbox_head_output-&gt;elements()[2].toTensor();
-
-  GPU_CHECK(cudaMemset(dev_filter_count_, 0, sizeof(int)));
-  postprocess_cuda_ptr_-&gt;DoPostprocessCuda(
-      bbox_pred.data_ptr&lt;float&gt;(),
-      cls_score.data_ptr&lt;float&gt;(),
-      dir_cls_preds.data_ptr&lt;float&gt;(),
-      dev_anchor_mask_, dev_anchors_px_, dev_anchors_py_, dev_anchors_pz_,
-      dev_anchors_dx_, dev_anchors_dy_, dev_anchors_dz_, dev_anchors_ro_,
-      dev_filtered_box_, dev_filtered_score_, dev_filtered_label_,
-      dev_filtered_dir_, dev_box_for_nms_, dev_filter_count_, out_detections,
-      out_labels);
-
-  // release the stream and the buffers
-  cudaStreamDestroy(stream);
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars.h" new_path="" added_lines="0" deleted_lines="375">
				<diff>@@ -1,375 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file point_pillars.h
- * @brief Algorithm for PointPillars
- * @author Kosuke Murakami
- * @date 2019/02/26
- */
-
-#pragma once
-
-// headers in STL
-#include &lt;algorithm&gt;
-#include &lt;cmath&gt;
-#include &lt;iomanip&gt;
-#include &lt;limits&gt;
-#include &lt;map&gt;
-#include &lt;memory&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-// headers in TensorRT
-#include "NvInfer.h"
-#include "NvOnnxParser.h"
-#include "torch/script.h"
-#include "torch/torch.h"
-
-// headers in local files
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/anchor_mask_cuda.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/common.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/params.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/postprocess_cuda.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/preprocess_points.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/preprocess_points_cuda.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/scatter_cuda.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-// Logger for TensorRT info/warning/errors
-class Logger : public nvinfer1::ILogger {
- public:
-  explicit Logger(Severity severity = Severity::kWARNING)
-      : reportable_severity(severity) {}
-
-  void log(Severity severity, const char* msg) override {
-    // suppress messages with severity enum value greater than the reportable
-    if (severity &gt; reportable_severity) return;
-
-    switch (severity) {
-      case Severity::kINTERNAL_ERROR:
-        std::cerr &lt;&lt; "INTERNAL_ERROR: ";
-        break;
-      case Severity::kERROR:
-        std::cerr &lt;&lt; "ERROR: ";
-        break;
-      case Severity::kWARNING:
-        std::cerr &lt;&lt; "WARNING: ";
-        break;
-      case Severity::kINFO:
-        std::cerr &lt;&lt; "INFO: ";
-        break;
-      default:
-        std::cerr &lt;&lt; "UNKNOWN: ";
-        break;
-    }
-    std::cerr &lt;&lt; msg &lt;&lt; std::endl;
-  }
-
-  Severity reportable_severity;
-};
-
-class PointPillars {
- private:
-  friend class TestClass;
-  static const float kPillarXSize;
-  static const float kPillarYSize;
-  static const float kPillarZSize;
-  static const float kMinXRange;
-  static const float kMinYRange;
-  static const float kMinZRange;
-  static const float kMaxXRange;
-  static const float kMaxYRange;
-  static const float kMaxZRange;
-  static const int kNumClass;
-  static const int kMaxNumPillars;
-  static const int kMaxNumPointsPerPillar;
-  static const int kNumPointFeature;
-  static const int kGridXSize;
-  static const int kGridYSize;
-  static const int kGridZSize;
-  static const int kRpnInputSize;
-  static const int kNumAnchor;
-  static const int kNumOutputBoxFeature;
-  static const int kRpnBoxOutputSize;
-  static const int kRpnClsOutputSize;
-  static const int kRpnDirOutputSize;
-  static const int kBatchSize;
-  static const int kNumIndsForScan;
-  static const int kNumThreads;
-  // if you change kNumThreads, need to modify NUM_THREADS_MACRO in
-  // common.h
-  static const int kNumBoxCorners;
-  static const std::vector&lt;int&gt; kAnchorStrides;
-  static const std::vector&lt;int&gt; kAnchorRanges;
-  static const std::vector&lt;int&gt; kNumAnchorSets;
-  static const std::vector&lt;std::vector&lt;float&gt;&gt; kAnchorDxSizes;
-  static const std::vector&lt;std::vector&lt;float&gt;&gt; kAnchorDySizes;
-  static const std::vector&lt;std::vector&lt;float&gt;&gt; kAnchorDzSizes;
-  static const std::vector&lt;std::vector&lt;float&gt;&gt; kAnchorZCoors;
-  static const std::vector&lt;std::vector&lt;int&gt;&gt; kNumAnchorRo;
-  static const std::vector&lt;std::vector&lt;float&gt;&gt; kAnchorRo;
-
-  // initialize in initializer list
-  const bool reproduce_result_mode_;
-  const float score_threshold_;
-  const float nms_overlap_threshold_;
-  const std::string pfe_onnx_file_;
-  const std::string rpn_onnx_file_;
-  const std::string pfe_torch_file_;
-  const std::string scattered_torch_file_;
-  const std::string backbone_torch_file_;
-  const std::string fpn_torch_file_;
-  const std::string bbox_head_torch_file_;
-  // end initializer list
-
-  int host_pillar_count_[1];
-
-  float* anchors_px_;
-  float* anchors_py_;
-  float* anchors_pz_;
-  float* anchors_dx_;
-  float* anchors_dy_;
-  float* anchors_dz_;
-  float* anchors_ro_;
-
-  float* box_anchors_min_x_;
-  float* box_anchors_min_y_;
-  float* box_anchors_max_x_;
-  float* box_anchors_max_y_;
-
-  int* dev_x_coors_;
-  int* dev_y_coors_;
-  float* dev_num_points_per_pillar_;
-  int* dev_sparse_pillar_map_;
-  int* dev_cumsum_along_x_;
-  int* dev_cumsum_along_y_;
-
-  float* dev_pillar_point_feature_;
-  float* dev_pillar_coors_;
-
-  float* dev_box_anchors_min_x_;
-  float* dev_box_anchors_min_y_;
-  float* dev_box_anchors_max_x_;
-  float* dev_box_anchors_max_y_;
-  int* dev_anchor_mask_;
-
-  void* pfe_buffers_[3];
-  void* rpn_buffers_[4];
-
-  float* dev_scattered_feature_;
-
-  float* dev_anchors_px_;
-  float* dev_anchors_py_;
-  float* dev_anchors_pz_;
-  float* dev_anchors_dx_;
-  float* dev_anchors_dy_;
-  float* dev_anchors_dz_;
-  float* dev_anchors_ro_;
-  float* dev_filtered_box_;
-  float* dev_filtered_score_;
-  int* dev_filtered_label_;
-  int* dev_filtered_dir_;
-  float* dev_box_for_nms_;
-  int* dev_filter_count_;
-
-  std::unique_ptr&lt;PreprocessPoints&gt; preprocess_points_ptr_;
-  std::unique_ptr&lt;PreprocessPointsCuda&gt; preprocess_points_cuda_ptr_;
-  std::unique_ptr&lt;AnchorMaskCuda&gt; anchor_mask_cuda_ptr_;
-  std::unique_ptr&lt;PostprocessCuda&gt; postprocess_cuda_ptr_;
-
-  Logger g_logger_;
-  nvinfer1::ICudaEngine* pfe_engine_;
-  nvinfer1::ICudaEngine* rpn_engine_;
-  nvinfer1::IExecutionContext* pfe_context_;
-  nvinfer1::IExecutionContext* rpn_context_;
-
-  int device_id_ = -1;
-  int gpu_id_ = 0;
-  torch::DeviceType device_type_;
-  torch::jit::script::Module pfe_net_;
-  torch::jit::script::Module scattered_net_;
-  torch::jit::script::Module backbone_net_;
-  torch::jit::script::Module fpn_net_;
-  torch::jit::script::Module bbox_head_net_;
-
-  /**
-   * @brief Memory allocation for device memory
-   * @details Called in the constructor
-   */
-  void DeviceMemoryMalloc();
-
-  /**
-   * @brief Initializing anchor
-   * @details Called in the constructor
-   */
-  void InitAnchors();
-
-  /**
-   * @brief Initializing LibTorch net
-   * @details Called in the constructor
-   */
-  void InitTorch();
-
-  /**
-   * @brief Initializing TensorRT instances
-   * @details Called in the constructor
-   */
-  void InitTRT();
-
-  /**
-   * @brief Generate anchors
-   * @param[in] anchors_px_ Represents x-coordinate values for a corresponding
-   * anchor
-   * @param[in] anchors_py_ Represents y-coordinate values for a corresponding
-   * anchor
-   * @param[in] anchors_pz_ Represents z-coordinate values for a corresponding
-   * anchor
-   * @param[in] anchors_dx_ Represents x-dimension values for a corresponding
-   * anchor
-   * @param[in] anchors_dy_ Represents y-dimension values for a corresponding
-   * anchor
-   * @param[in] anchors_dz_ Represents z-dimension values for a corresponding
-   * anchor
-   * @param[in] anchors_ro_ Represents rotation values for a corresponding
-   * anchor
-   * @details Generate anchors for each grid
-   */
-  void GenerateAnchors(float* anchors_px_, float* anchors_py_,
-                       float* anchors_pz_, float* anchors_dx_,
-                       float* anchors_dy_, float* anchors_dz_,
-                       float* anchors_ro_);
-
-  /**
-   * @brief Convert ONNX to TensorRT model
-   * @param[in] model_file ONNX model file path
-   * @param[out] engine_ptr TensorRT model engine made out of ONNX model
-   * @details Load ONNX model, and convert it to TensorRT model
-   */
-  void OnnxToTRTModel(const std::string&amp; model_file,
-                      nvinfer1::ICudaEngine** engine_ptr);
-
-  /**
-   * @brief Preproces points
-   * @param[in] in_points_array Point cloud array
-   * @param[in] in_num_points Number of points
-   * @details Call CPU or GPU preprocess
-   */
-  void Preprocess(const float* in_points_array, const int in_num_points);
-
-  /**
-   * @brief Preproces by CPU
-   * @param[in] in_points_array Point cloud array
-   * @param[in] in_num_points Number of points
-   * @details The output from preprocessCPU is reproducible, while preprocessGPU
-   * is not
-   */
-  void PreprocessCPU(const float* in_points_array, const int in_num_points);
-
-  /**
-   * @brief Preproces by GPU
-   * @param[in] in_points_array Point cloud array
-   * @param[in] in_num_points Number of points
-   * @details Faster preprocess compared with CPU preprocess
-   */
-  void PreprocessGPU(const float* in_points_array, const int in_num_points);
-
-  /**
-   * @brief Convert anchors to box form like min_x, min_y, max_x, max_y anchors
-   * @param[in] anchors_px_
-   *   Represents x-coordinate value for a corresponding anchor
-   * @param[in] anchors_py_
-   *   Represents y-coordinate value for a corresponding anchor
-   * @param[in] box_anchors_min_x_
-   *   Represents minimum x value for a corresponding anchor
-   * @param[in] box_anchors_min_y_
-   *   Represents minimum y value for a corresponding anchor
-   * @param[in] box_anchors_max_x_
-   *   Represents maximum x value for a corresponding anchor
-   * @param[in] box_anchors_max_y_
-   *   Represents maximum y value for a corresponding anchor
-   * @details Make box anchors for nms
-   */
-  void ConvertAnchors2BoxAnchors(float* anchors_px_, float* anchors_py_,
-                                 float* box_anchors_min_x_,
-                                 float* box_anchors_min_y_,
-                                 float* box_anchors_max_x_,
-                                 float* box_anchors_max_y_);
-
-  /**
-   * @brief Memory allocation for anchors
-   * @details Memory allocation for anchors
-   */
-  void PutAnchorsInDeviceMemory();
-
- public:
-  /**
-   * @brief Constructor
-   * @param[in] reproduce_result_mode Boolean, if true, the output is
-   * reproducible for the same input
-   * @param[in] score_threshold Score threshold for filtering output
-   * @param[in] nms_overlap_threshold IOU threshold for NMS
-   * @param[in] pfe_torch_file Pillar Feature Extractor Torch file path
-   * @param[in] scattered_torch_file Pillar Feature scatter Torch file path
-   * @param[in] backbone_torch_file Pillar Backbone Torch file path
-   * @param[in] fpn_torch_file Pillar Fpn Torch file path
-   * @param[in] bbox_head_torch_file Pillar Bbox Head Torch file path
-   * @details Variables could be changed through point_pillars_detection
-   */
-  PointPillars(const bool reproduce_result_mode, const float score_threshold,
-               const float nms_overlap_threshold,
-               const std::string&amp; pfe_torch_file,
-               const std::string&amp; scattered_torch_file,
-               const std::string&amp; backbone_torch_file,
-               const std::string&amp; fpn_torch_file,
-               const std::string&amp; bbox_head_torch_file);
-  ~PointPillars();
-
-  /**
-   * @brief Call PointPillars for the inference
-   * @param[in] in_points_array Point cloud array
-   * @param[in] in_num_points Number of points
-   * @param[out] out_detections Network output bounding box
-   * @param[out] out_labels Network output object's label
-   * @details This is an interface for the algorithm
-   */
-  void DoInference(const float* in_points_array, const int in_num_points,
-                   std::vector&lt;float&gt;* out_detections,
-                   std::vector&lt;int&gt;* out_labels);
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.cc" new_path="" added_lines="0" deleted_lines="372">
				<diff>@@ -1,372 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/point_pillars_detection.h"
-
-#include &lt;algorithm&gt;
-#include &lt;numeric&gt;
-#include &lt;random&gt;
-
-#include &lt;cuda_runtime_api.h&gt;
-
-#include "cyber/common/log.h"
-#include "modules/perception/base/object_pool_types.h"
-#include "modules/perception/base/point_cloud_util.h"
-#include "modules/perception/common/perception_gflags.h"
-#include "modules/perception/lidar/common/lidar_timer.h"
-#include "modules/perception/lidar/common/pcl_util.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/params.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-using base::Object;
-using base::PointD;
-using base::PointF;
-
-PointPillarsDetection::PointPillarsDetection()
-    : x_min_(Params::kMinXRange),
-      x_max_(Params::kMaxXRange),
-      y_min_(Params::kMinYRange),
-      y_max_(Params::kMaxYRange),
-      z_min_(Params::kMinZRange),
-      z_max_(Params::kMaxZRange) {
-  if (FLAGS_enable_ground_removal) {
-    z_min_ = std::max(z_min_, static_cast&lt;float&gt;(FLAGS_ground_removal_height));
-  }
-}
-
-// TODO(chenjiahao):
-//  specify score threshold and nms over lap threshold for each class.
-bool PointPillarsDetection::Init(const LidarDetectorInitOptions&amp; options) {
-  point_pillars_ptr_.reset(
-      new PointPillars(FLAGS_reproduce_result_mode, FLAGS_score_threshold,
-                       FLAGS_nms_overlap_threshold, FLAGS_pfe_torch_file,
-                       FLAGS_scattered_torch_file, FLAGS_backbone_torch_file,
-                       FLAGS_fpn_torch_file, FLAGS_bbox_head_torch_file));
-  return true;
-}
-
-bool PointPillarsDetection::Detect(const LidarDetectorOptions&amp; options,
-                                   LidarFrame* frame) {
-  // check input
-  if (frame == nullptr) {
-    AERROR &lt;&lt; "Input null frame ptr.";
-    return false;
-  }
-  if (frame-&gt;cloud == nullptr) {
-    AERROR &lt;&lt; "Input null frame cloud.";
-    return false;
-  }
-  if (frame-&gt;cloud-&gt;size() == 0) {
-    AERROR &lt;&lt; "Input none points.";
-    return false;
-  }
-
-  // record input cloud and lidar frame
-  original_cloud_ = frame-&gt;cloud;
-  original_world_cloud_ = frame-&gt;world_cloud;
-  lidar_frame_ref_ = frame;
-
-  // check output
-  frame-&gt;segmented_objects.clear();
-
-  if (cudaSetDevice(FLAGS_gpu_id) != cudaSuccess) {
-    AERROR &lt;&lt; "Failed to set device to gpu " &lt;&lt; FLAGS_gpu_id;
-    return false;
-  }
-
-  Timer timer;
-
-  int num_points;
-  cur_cloud_ptr_ = std::shared_ptr&lt;base::PointFCloud&gt;(
-      new base::PointFCloud(*original_cloud_));
-
-  // down sample the point cloud through filtering beams
-  if (FLAGS_enable_downsample_beams) {
-    base::PointFCloudPtr downsample_beams_cloud_ptr(new base::PointFCloud());
-    if (DownSamplePointCloudBeams(original_cloud_, downsample_beams_cloud_ptr,
-                                  FLAGS_downsample_beams_factor)) {
-      cur_cloud_ptr_ = downsample_beams_cloud_ptr;
-    } else {
-      AWARN &lt;&lt; "Down-sample beams factor must be &gt;= 1. Cancel down-sampling."
-               " Current factor: "
-            &lt;&lt; FLAGS_downsample_beams_factor;
-    }
-  }
-
-  // down sample the point cloud through filtering voxel grid
-  if (FLAGS_enable_downsample_pointcloud) {
-    pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr pcl_cloud_ptr(
-        new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
-    pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_cloud_ptr(
-        new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
-    TransformToPCLXYZI(*cur_cloud_ptr_, pcl_cloud_ptr);
-    DownSampleCloudByVoxelGrid(
-        pcl_cloud_ptr, filtered_cloud_ptr, FLAGS_downsample_voxel_size_x,
-        FLAGS_downsample_voxel_size_y, FLAGS_downsample_voxel_size_z);
-
-    // transform pcl point cloud to apollo point cloud
-    base::PointFCloudPtr downsample_voxel_cloud_ptr(new base::PointFCloud());
-    TransformFromPCLXYZI(filtered_cloud_ptr, downsample_voxel_cloud_ptr);
-    cur_cloud_ptr_ = downsample_voxel_cloud_ptr;
-  }
-  downsample_time_ = timer.toc(true);
-
-  num_points = cur_cloud_ptr_-&gt;size();
-  AINFO &lt;&lt; "num points before fusing: " &lt;&lt; num_points;
-
-  // fuse clouds of preceding frames with current cloud
-  cur_cloud_ptr_-&gt;mutable_points_timestamp()-&gt;assign(cur_cloud_ptr_-&gt;size(),
-                                                     0.0);
-  if (FLAGS_enable_fuse_frames &amp;&amp; FLAGS_num_fuse_frames &gt; 1) {
-    // before fusing
-    while (!prev_world_clouds_.empty() &amp;&amp;
-           frame-&gt;timestamp - prev_world_clouds_.front()-&gt;get_timestamp() &gt;
-               FLAGS_fuse_time_interval) {
-      prev_world_clouds_.pop_front();
-    }
-    // transform current cloud to world coordinate and save to a new ptr
-    base::PointDCloudPtr cur_world_cloud_ptr =
-        std::make_shared&lt;base::PointDCloud&gt;();
-    for (size_t i = 0; i &lt; cur_cloud_ptr_-&gt;size(); ++i) {
-      auto&amp; pt = cur_cloud_ptr_-&gt;at(i);
-      Eigen::Vector3d trans_point(pt.x, pt.y, pt.z);
-      trans_point = lidar_frame_ref_-&gt;lidar2world_pose * trans_point;
-      PointD world_point;
-      world_point.x = trans_point(0);
-      world_point.y = trans_point(1);
-      world_point.z = trans_point(2);
-      world_point.intensity = pt.intensity;
-      cur_world_cloud_ptr-&gt;push_back(world_point);
-    }
-    cur_world_cloud_ptr-&gt;set_timestamp(frame-&gt;timestamp);
-
-    // fusing clouds
-    for (auto&amp; prev_world_cloud_ptr : prev_world_clouds_) {
-      num_points += prev_world_cloud_ptr-&gt;size();
-    }
-    FuseCloud(cur_cloud_ptr_, prev_world_clouds_);
-
-    // after fusing
-    while (static_cast&lt;int&gt;(prev_world_clouds_.size()) &gt;=
-           FLAGS_num_fuse_frames - 1) {
-      prev_world_clouds_.pop_front();
-    }
-    prev_world_clouds_.emplace_back(cur_world_cloud_ptr);
-  }
-  AINFO &lt;&lt; "num points after fusing: " &lt;&lt; num_points;
-  fuse_time_ = timer.toc(true);
-
-  // shuffle points and cut off
-  if (FLAGS_enable_shuffle_points) {
-    num_points = std::min(num_points, FLAGS_max_num_points);
-    std::vector&lt;int&gt; point_indices = GenerateIndices(0, num_points, true);
-    base::PointFCloudPtr shuffle_cloud_ptr(
-        new base::PointFCloud(*cur_cloud_ptr_, point_indices));
-    cur_cloud_ptr_ = shuffle_cloud_ptr;
-  }
-  shuffle_time_ = timer.toc(true);
-
-  // point cloud to array
-  float* points_array = new float[num_points * FLAGS_num_point_feature]();
-  CloudToArray(cur_cloud_ptr_, points_array, FLAGS_normalizing_factor);
-  cloud_to_array_time_ = timer.toc(true);
-
-  // inference
-  std::vector&lt;float&gt; out_detections;
-  std::vector&lt;int&gt; out_labels;
-  point_pillars_ptr_-&gt;DoInference(points_array, num_points, &amp;out_detections,
-                                  &amp;out_labels);
-  inference_time_ = timer.toc(true);
-
-  // transfer output bounding boxes to objects
-  GetObjects(&amp;frame-&gt;segmented_objects, frame-&gt;lidar2world_pose,
-             &amp;out_detections, &amp;out_labels);
-  collect_time_ = timer.toc(true);
-
-  AINFO &lt;&lt; "PointPillars: "
-        &lt;&lt; "\n"
-        &lt;&lt; "down sample: " &lt;&lt; downsample_time_ &lt;&lt; "\t"
-        &lt;&lt; "fuse: " &lt;&lt; fuse_time_ &lt;&lt; "\t"
-        &lt;&lt; "shuffle: " &lt;&lt; shuffle_time_ &lt;&lt; "\t"
-        &lt;&lt; "cloud_to_array: " &lt;&lt; cloud_to_array_time_ &lt;&lt; "\t"
-        &lt;&lt; "inference: " &lt;&lt; inference_time_ &lt;&lt; "\t"
-        &lt;&lt; "collect: " &lt;&lt; collect_time_;
-
-  delete[] points_array;
-  return true;
-}
-
-void PointPillarsDetection::CloudToArray(const base::PointFCloudPtr&amp; pc_ptr,
-                                         float* out_points_array,
-                                         const float normalizing_factor) {
-  for (size_t i = 0; i &lt; pc_ptr-&gt;size(); ++i) {
-    const auto&amp; point = pc_ptr-&gt;at(i);
-    float x = point.x;
-    float y = point.y;
-    float z = point.z;
-    float intensity = point.intensity;
-    if (z &lt; z_min_ || z &gt; z_max_ || y &lt; y_min_ || y &gt; y_max_ || x &lt; x_min_ ||
-        x &gt; x_max_) {
-      continue;
-    }
-    out_points_array[i * FLAGS_num_point_feature + 0] = x;
-    out_points_array[i * FLAGS_num_point_feature + 1] = y;
-    out_points_array[i * FLAGS_num_point_feature + 2] = z;
-    out_points_array[i * FLAGS_num_point_feature + 3] =
-        intensity / normalizing_factor;
-    // delta of timestamp between prev and cur frames
-    out_points_array[i * FLAGS_num_point_feature + 4] =
-        static_cast&lt;float&gt;(pc_ptr-&gt;points_timestamp(i));
-  }
-}
-
-void PointPillarsDetection::FuseCloud(
-    const base::PointFCloudPtr&amp; out_cloud_ptr,
-    const std::deque&lt;base::PointDCloudPtr&gt;&amp; fuse_clouds) {
-  for (auto iter = fuse_clouds.rbegin(); iter != fuse_clouds.rend(); ++iter) {
-    double delta_t = lidar_frame_ref_-&gt;timestamp - (*iter)-&gt;get_timestamp();
-    // transform prev world point cloud to current sensor's coordinates
-    for (size_t i = 0; i &lt; (*iter)-&gt;size(); ++i) {
-      auto&amp; point = (*iter)-&gt;at(i);
-      Eigen::Vector3d trans_point(point.x, point.y, point.z);
-      trans_point = lidar_frame_ref_-&gt;lidar2world_pose.inverse() * trans_point;
-      base::PointF pt;
-      pt.x = static_cast&lt;float&gt;(trans_point(0));
-      pt.y = static_cast&lt;float&gt;(trans_point(1));
-      pt.z = static_cast&lt;float&gt;(trans_point(2));
-      pt.intensity = static_cast&lt;float&gt;(point.intensity);
-      // delta of time between current and prev frame
-      out_cloud_ptr-&gt;push_back(pt, delta_t);
-    }
-  }
-}
-
-std::vector&lt;int&gt; PointPillarsDetection::GenerateIndices(int start_index,
-                                                        int size,
-                                                        bool shuffle) {
-  // create a range number array
-  std::vector&lt;int&gt; indices(size);
-  std::iota(indices.begin(), indices.end(), start_index);
-
-  // shuffle the index array
-  if (shuffle) {
-    unsigned seed = 0;
-    std::shuffle(indices.begin(), indices.end(),
-                 std::default_random_engine(seed));
-  }
-  return indices;
-}
-
-void PointPillarsDetection::GetObjects(
-    std::vector&lt;std::shared_ptr&lt;Object&gt;&gt;* objects, const Eigen::Affine3d&amp; pose,
-    std::vector&lt;float&gt;* detections, std::vector&lt;int&gt;* labels) {
-  int num_objects = detections-&gt;size() / FLAGS_num_output_box_feature;
-
-  objects-&gt;clear();
-  base::ObjectPool::Instance().BatchGet(num_objects, objects);
-
-  for (int i = 0; i &lt; num_objects; ++i) {
-    auto&amp; object = objects-&gt;at(i);
-    object-&gt;id = i;
-
-    // read params of bounding box
-    float x = detections-&gt;at(i * FLAGS_num_output_box_feature + 0);
-    float y = detections-&gt;at(i * FLAGS_num_output_box_feature + 1);
-    float z = detections-&gt;at(i * FLAGS_num_output_box_feature + 2);
-    float dx = detections-&gt;at(i * FLAGS_num_output_box_feature + 4);
-    float dy = detections-&gt;at(i * FLAGS_num_output_box_feature + 3);
-    float dz = detections-&gt;at(i * FLAGS_num_output_box_feature + 5);
-    float yaw = detections-&gt;at(i * FLAGS_num_output_box_feature + 6);
-    yaw += M_PI / 2;
-    yaw = std::atan2(sinf(yaw), cosf(yaw));
-    yaw = -yaw;
-
-    // directions
-    object-&gt;theta = yaw;
-    object-&gt;direction[0] = cosf(yaw);
-    object-&gt;direction[1] = sinf(yaw);
-    object-&gt;direction[2] = 0;
-    object-&gt;lidar_supplement.is_orientation_ready = true;
-
-    // compute vertexes of bounding box and transform to world coordinate
-    object-&gt;lidar_supplement.num_points_in_roi = 8;
-    object-&gt;lidar_supplement.on_use = true;
-    object-&gt;lidar_supplement.is_background = false;
-    float roll = 0, pitch = 0;
-    Eigen::Quaternionf quater =
-        Eigen::AngleAxisf(roll, Eigen::Vector3f::UnitX()) *
-        Eigen::AngleAxisf(pitch, Eigen::Vector3f::UnitY()) *
-        Eigen::AngleAxisf(yaw, Eigen::Vector3f::UnitZ());
-    Eigen::Translation3f translation(x, y, z);
-    Eigen::Affine3f affine3f = translation * quater.toRotationMatrix();
-    for (float vx : std::vector&lt;float&gt;{dx / 2, -dx / 2}) {
-      for (float vy : std::vector&lt;float&gt;{dy / 2, -dy / 2}) {
-        for (float vz : std::vector&lt;float&gt;{0, dz}) {
-          Eigen::Vector3f v3f(vx, vy, vz);
-          v3f = affine3f * v3f;
-          PointF point;
-          point.x = v3f.x();
-          point.y = v3f.y();
-          point.z = v3f.z();
-          object-&gt;lidar_supplement.cloud.push_back(point);
-
-          Eigen::Vector3d trans_point(point.x, point.y, point.z);
-          trans_point = pose * trans_point;
-          PointD world_point;
-          world_point.x = trans_point(0);
-          world_point.y = trans_point(1);
-          world_point.z = trans_point(2);
-          object-&gt;lidar_supplement.cloud_world.push_back(world_point);
-        }
-      }
-    }
-
-    // classification
-    object-&gt;lidar_supplement.raw_probs.push_back(std::vector&lt;float&gt;(
-        static_cast&lt;int&gt;(base::ObjectType::MAX_OBJECT_TYPE), 0.f));
-    object-&gt;lidar_supplement.raw_classification_methods.push_back(Name());
-    object-&gt;sub_type = GetObjectSubType(labels-&gt;at(i));
-    object-&gt;type = base::kSubType2TypeMap.at(object-&gt;sub_type);
-    object-&gt;lidar_supplement.raw_probs.back()[static_cast&lt;int&gt;(object-&gt;type)] =
-        1.0f;
-    // copy to type
-    object-&gt;type_probs.assign(object-&gt;lidar_supplement.raw_probs.back().begin(),
-                              object-&gt;lidar_supplement.raw_probs.back().end());
-  }
-}
-
-// TODO(all): update the base ObjectSubType with more fine-grained types
-// TODO(chenjiahao): move types into an array in the same order as offline
-base::ObjectSubType PointPillarsDetection::GetObjectSubType(const int label) {
-  switch (label) {
-    case 0:
-      return base::ObjectSubType::CAR;
-    case 1:
-      return base::ObjectSubType::PEDESTRIAN;
-    case 2:  // construction vehicle
-      return base::ObjectSubType::CYCLIST;
-    default:
-      return base::ObjectSubType::UNKNOWN;
-  }
-}
-
-PERCEPTION_REGISTER_LIDARDETECTOR(PointPillarsDetection);
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.h" new_path="" added_lines="0" deleted_lines="92">
				<diff>@@ -1,92 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;deque&gt;
-#include &lt;memory&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#include "pcl/point_cloud.h"
-#include "pcl/point_types.h"
-
-#include "modules/perception/base/object.h"
-#include "modules/perception/base/point_cloud.h"
-#include "modules/perception/lidar/common/lidar_frame.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/point_pillars.h"
-#include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class PointPillarsDetection : public BaseLidarDetector {
- public:
-  PointPillarsDetection();
-  virtual ~PointPillarsDetection() = default;
-
-  bool Init(const LidarDetectorInitOptions&amp; options = LidarDetectorInitOptions()) override;
-
-  bool Detect(const LidarDetectorOptions&amp; options, LidarFrame* frame) override;
-
-  std::string Name() const override { return "PointPillarsDetection"; }
-
- private:
-  void CloudToArray(const base::PointFCloudPtr&amp; pc_ptr, float* out_points_array,
-                    float normalizing_factor);
-
-  void FuseCloud(const base::PointFCloudPtr&amp; out_cloud_ptr,
-                 const std::deque&lt;base::PointDCloudPtr&gt;&amp; fuse_clouds);
-
-  std::vector&lt;int&gt; GenerateIndices(int start_index, int size, bool shuffle);
-
-  void GetObjects(std::vector&lt;std::shared_ptr&lt;base::Object&gt;&gt;* objects,
-                  const Eigen::Affine3d&amp; pose, std::vector&lt;float&gt;* detections,
-                  std::vector&lt;int&gt;* labels);
-
-  base::ObjectSubType GetObjectSubType(int label);
-
-  // reference pointer of lidar frame
-  LidarFrame* lidar_frame_ref_ = nullptr;
-  std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointF&gt;&gt; original_cloud_;
-  std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointD&gt;&gt;
-      original_world_cloud_;
-
-  // PointPillars
-  std::unique_ptr&lt;PointPillars&gt; point_pillars_ptr_;
-  std::deque&lt;base::PointDCloudPtr&gt; prev_world_clouds_;
-  base::PointFCloudPtr cur_cloud_ptr_;
-
-  // point cloud range
-  float x_min_;
-  float x_max_;
-  float y_min_;
-  float y_max_;
-  float z_min_;
-  float z_max_;
-
-  // time statistics
-  double downsample_time_ = 0.0;
-  double fuse_time_ = 0.0;
-  double shuffle_time_ = 0.0;
-  double cloud_to_array_time_ = 0.0;
-  double inference_time_ = 0.0;
-  double collect_time_ = 0.0;
-};  // class PointPillarsDetection
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_test.cc" new_path="" added_lines="0" deleted_lines="687">
				<diff>@@ -1,687 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file test_point_pillars.cpp
- * @brief unit test file
- * @author Kosuke Murakami
- * @date 2019/02/26
- */
-
-
-
-#include &lt;vector&gt;
-
-#include "gtest/gtest.h"
-
-#include "pcl/io/pcd_io.h"
-#include "pcl/point_types.h"
-
-#include "modules/perception/common/perception_gflags.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/point_pillars.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/preprocess_points.h"
-#include "modules/perception/tool/benchmark/lidar/util/io_util.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class TestSuite : public ::testing::Test {
- public:
-  TestSuite() {}
-  ~TestSuite() {}
-};
-
-class TestClass {
- public:
-  TestClass();
-  TestClass(const int num_class, const int max_num_pillars,
-            const int max_num_points_per_pillar, const int num_point_feature,
-            const int grid_x_size, const int grid_y_size, const int grid_z_size,
-            const float pillar_x_size, const float pillar_y_size,
-            const float pillar_z_size, const float min_x_range,
-            const float min_y_range, const float min_z_range,
-            const int num_inds_for_scan, const int num_threads);
-  const int num_class;
-  const int max_num_pillars;
-  const int max_num_points_per_pillar;
-  const int num_point_feature;
-  const int grid_x_size;
-  const int grid_y_size;
-  const int grid_z_size;
-  const float pillar_x_size;
-  const float pillar_y_size;
-  const float pillar_z_size;
-  const float min_x_range;
-  const float min_y_range;
-  const float min_z_range;
-  const int num_inds_for_scan;
-  const int num_threads;
-
-  // Make pointcloud for test
-  void MakePointsForTest(pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_pcl_pc_ptr);
-  void PclToArray(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr&amp; in_pcl_pc_ptr,
-                  float* out_points_array,
-                  const float normalizing_factor = 1.0);
-  void PclXYZITToArray(
-      const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr&amp; in_pcl_pc_ptr,
-      float* out_points_array, const float normalizing_factor = 1.0);
-  void Preprocess(const float* in_points_array, int in_num_points, int* x_coors,
-                  int* y_coors, float* num_points_per_pillar,
-                  float* pillar_point_feature, float* pillar_coors,
-                  float* sparse_pillar_map, int* host_pillar_count);
-  void PreprocessGPU(const float* in_points_array, int in_num_points,
-                     int* x_coors, int* y_coors, float* num_points_per_pillar,
-                     float* pillar_point_feature, float* pillar_coors,
-                     int* sparse_pillar_map, int* host_pillar_count);
-  void GenerateAnchors(float* anchors_px, float* anchors_py, float* anchors_pz,
-                       float* anchors_dx, float* anchors_dy, float* anchors_dz,
-                       float* anchors_ro);
-  void ConvertAnchors2BoxAnchors(float* anchors_px, float* anchors_py,
-                                 float* box_anchors_min_x,
-                                 float* box_anchors_min_y,
-                                 float* box_anchors_max_x,
-                                 float* box_anchors_max_y);
-  void DoInference(const float* in_points_array, const int in_num_points,
-                   std::vector&lt;float&gt;* out_detections,
-                   std::vector&lt;int&gt;* out_labels);
-
- private:
-  std::unique_ptr&lt;PreprocessPoints&gt; preprocess_points_ptr_;
-  std::unique_ptr&lt;PreprocessPointsCuda&gt; preprocess_points_cuda_ptr_;
-  std::unique_ptr&lt;PointPillars&gt; point_pillars_ptr_;
-};
-
-TestClass::TestClass()
-    : num_class(3),
-      max_num_pillars(12000),
-      max_num_points_per_pillar(100),
-      num_point_feature(4),
-      grid_x_size(280),
-      grid_y_size(320),
-      grid_z_size(1),
-      pillar_x_size(0.25),
-      pillar_y_size(0.25),
-      pillar_z_size(4.0),
-      min_x_range(0),
-      min_y_range(-40.0),
-      min_z_range(-3.0),
-      num_inds_for_scan(512),
-      num_threads(64) {
-  preprocess_points_ptr_.reset(new PreprocessPoints(
-      max_num_pillars, max_num_points_per_pillar, num_point_feature,
-      grid_x_size, grid_y_size, grid_z_size, pillar_x_size, pillar_y_size,
-      pillar_z_size, min_x_range, min_y_range, min_z_range, num_inds_for_scan));
-  preprocess_points_cuda_ptr_.reset(new PreprocessPointsCuda(
-      num_threads, max_num_pillars, max_num_points_per_pillar,
-      num_point_feature, num_inds_for_scan, grid_x_size, grid_y_size,
-      grid_z_size, pillar_x_size, pillar_y_size, pillar_z_size, min_x_range,
-      min_y_range, min_z_range));
-
-  bool reproduce_result_mode = false;
-  float score_threshold = 0.5;
-  float nms_overlap_threshold = 0.5;
-
-  point_pillars_ptr_.reset(
-      new PointPillars(reproduce_result_mode, score_threshold,
-                       nms_overlap_threshold, FLAGS_pfe_torch_file,
-                       FLAGS_scattered_torch_file, FLAGS_backbone_torch_file,
-                       FLAGS_fpn_torch_file, FLAGS_bbox_head_torch_file));
-}
-
-TestClass::TestClass(const int num_class, const int max_num_pillars,
-                     const int max_num_points_per_pillar,
-                     const int num_point_feature, const int grid_x_size,
-                     const int grid_y_size, const int grid_z_size,
-                     const float pillar_x_size, const float pillar_y_size,
-                     const float pillar_z_size, const float min_x_range,
-                     const float min_y_range, const float min_z_range,
-                     const int num_inds_for_scan, const int num_threads)
-    : num_class(num_class),
-      max_num_pillars(max_num_pillars),
-      max_num_points_per_pillar(max_num_points_per_pillar),
-      num_point_feature(num_point_feature),
-      grid_x_size(grid_x_size),
-      grid_y_size(grid_y_size),
-      grid_z_size(grid_z_size),
-      pillar_x_size(pillar_x_size),
-      pillar_y_size(pillar_y_size),
-      pillar_z_size(pillar_z_size),
-      min_x_range(min_x_range),
-      min_y_range(min_y_range),
-      min_z_range(min_z_range),
-      num_inds_for_scan(num_inds_for_scan),
-      num_threads(num_threads) {
-  preprocess_points_ptr_.reset(new PreprocessPoints(
-      max_num_pillars, max_num_points_per_pillar, num_point_feature,
-      grid_x_size, grid_y_size, grid_z_size, pillar_x_size, pillar_y_size,
-      pillar_z_size, min_x_range, min_y_range, min_z_range, num_inds_for_scan));
-  preprocess_points_cuda_ptr_.reset(new PreprocessPointsCuda(
-      num_threads, max_num_pillars, max_num_points_per_pillar,
-      num_point_feature, num_inds_for_scan, grid_x_size, grid_y_size,
-      grid_z_size, pillar_x_size, pillar_y_size, pillar_z_size, min_x_range,
-      min_y_range, min_z_range));
-
-  bool reproduce_result_mode = false;
-  float score_threshold = 0.5;
-  float nms_overlap_threshold = 0.5;
-
-  point_pillars_ptr_.reset(
-      new PointPillars(reproduce_result_mode, score_threshold,
-                       nms_overlap_threshold, FLAGS_pfe_torch_file,
-                       FLAGS_scattered_torch_file, FLAGS_backbone_torch_file,
-                       FLAGS_fpn_torch_file, FLAGS_bbox_head_torch_file));
-}
-
-void TestClass::Preprocess(const float* in_points_array, int in_num_points,
-                           int* x_coors, int* y_coors,
-                           float* num_points_per_pillar,
-                           float* pillar_point_feature, float* pillar_coors,
-                           float* sparse_pillar_map, int* host_pillar_count) {
-  preprocess_points_ptr_-&gt;Preprocess(
-      in_points_array, in_num_points, x_coors, y_coors, num_points_per_pillar,
-      pillar_point_feature, pillar_coors, sparse_pillar_map, host_pillar_count);
-}
-
-void TestClass::PreprocessGPU(const float* in_points_array, int in_num_points,
-                              int* x_coors, int* y_coors,
-                              float* num_points_per_pillar,
-                              float* pillar_point_feature, float* pillar_coors,
-                              int* sparse_pillar_map, int* host_pillar_count) {
-  preprocess_points_cuda_ptr_-&gt;DoPreprocessPointsCuda(
-      in_points_array, in_num_points, x_coors, y_coors, num_points_per_pillar,
-      pillar_point_feature, pillar_coors, sparse_pillar_map, host_pillar_count);
-}
-
-void TestClass::PclToArray(
-    const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr&amp; in_pcl_pc_ptr,
-    float* out_points_array, const float normalizing_factor) {
-  for (size_t i = 0; i &lt; in_pcl_pc_ptr-&gt;size(); ++i) {
-    pcl::PointXYZI point = in_pcl_pc_ptr-&gt;at(i);
-    out_points_array[i * 4 + 0] = point.x;
-    out_points_array[i * 4 + 1] = point.y;
-    out_points_array[i * 4 + 2] = point.z;
-    out_points_array[i * 4 + 3] =
-        static_cast&lt;float&gt;(point.intensity / normalizing_factor);
-  }
-}
-
-void TestClass::PclXYZITToArray(
-    const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr&amp; in_pcl_pc_ptr,
-    float* out_points_array, const float normalizing_factor) {
-  for (size_t i = 0; i &lt; in_pcl_pc_ptr-&gt;size(); ++i) {
-    pcl::PointXYZI point = in_pcl_pc_ptr-&gt;at(i);
-    out_points_array[i * 5 + 0] = point.x;
-    out_points_array[i * 5 + 1] = point.y;
-    out_points_array[i * 5 + 2] = point.z;
-    out_points_array[i * 5 + 3] =
-        static_cast&lt;float&gt;(point.intensity / normalizing_factor);
-    out_points_array[i * 5 + 4] = 0;
-  }
-}
-
-void TestClass::MakePointsForTest(
-    pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_pcl_pc_ptr) {
-  pcl::PointXYZI point;
-  point.x = 12.9892;
-  point.y = -9.98058;
-  point.z = 0;
-  point.intensity = 4;
-  in_pcl_pc_ptr-&gt;push_back(point);
-  point.x = 11.8697;
-  point.y = -11.123;
-  point.z = -0.189377;
-  point.intensity = 35;
-  in_pcl_pc_ptr-&gt;push_back(point);
-  point.x = 12.489;
-  point.y = -9.59703;
-  point.z = -2.15565;
-  point.intensity = 11;
-  in_pcl_pc_ptr-&gt;push_back(point);
-  point.x = 12.9084;
-  point.y = -10.9626;
-  point.z = -2.15565;
-  point.intensity = 11;
-  in_pcl_pc_ptr-&gt;push_back(point);
-  point.x = 13.8676;
-  point.y = -9.61668;
-  point.z = 0.0980819;
-  point.intensity = 14;
-  in_pcl_pc_ptr-&gt;push_back(point);
-  point.x = 13.5673;
-  point.y = -12.9834;
-  point.z = 0.21862;
-  point.intensity = 1;
-  in_pcl_pc_ptr-&gt;push_back(point);
-  point.x = 13.8213;
-  point.y = -10.8529;
-  point.z = -1.22883;
-  point.intensity = 19;
-  in_pcl_pc_ptr-&gt;push_back(point);
-  point.x = 11.8957;
-  point.y = -10.3189;
-  point.z = -1.28556;
-  point.intensity = 13;
-  in_pcl_pc_ptr-&gt;push_back(point);
-}
-
-void TestClass::GenerateAnchors(float* anchors_px, float* anchors_py,
-                                float* anchors_pz, float* anchors_dx,
-                                float* anchors_dy, float* anchors_dz,
-                                float* anchors_ro) {
-  return point_pillars_ptr_-&gt;GenerateAnchors(anchors_px, anchors_py, anchors_pz,
-                                             anchors_dx, anchors_dy, anchors_dz,
-                                             anchors_ro);
-}
-
-void TestClass::ConvertAnchors2BoxAnchors(float* anchors_px, float* anchors_py,
-                                          float* box_anchors_min_x,
-                                          float* box_anchors_min_y,
-                                          float* box_anchors_max_x,
-                                          float* box_anchors_max_y) {
-  return point_pillars_ptr_-&gt;ConvertAnchors2BoxAnchors(
-      anchors_px, anchors_py, box_anchors_min_x, box_anchors_min_y,
-      box_anchors_max_x, box_anchors_max_y);
-}
-
-void TestClass::DoInference(const float* in_points_array,
-                            const int in_num_points,
-                            std::vector&lt;float&gt;* out_detections,
-                            std::vector&lt;int&gt;* out_labels) {
-  return point_pillars_ptr_-&gt;DoInference(in_points_array, in_num_points,
-                                         out_detections, out_labels);
-}
-/*
-TEST(TestSuite, CheckPreprocessPointsCPU) {
-  const int kNumClass = 1;
-  const int kMaxNumPillars = 12000;
-  const int kMaxNumPointsPerPillar = 100;
-  const int kNumPointFeature = 4;
-  const int kGridXSize = 432;
-  const int kGridYSize = 496;
-  const int kGridZSize = 1;
-  const float kPillarXSize = 0.16;
-  const float kPillarYSize = 0.16;
-  const float kPillarZSize = 4.0;
-  const float kMinXRange = 0;
-  const float kMinYRange = -39.68;
-  const float kMinZRange = -3.0;
-  const int kNumIndsForScan = 512;
-  const int kNumThreads = 64;
-  TestClass test_obj(kNumClass, kMaxNumPillars, kMaxNumPointsPerPillar,
-                     kNumPointFeature, kGridXSize, kGridYSize, kGridZSize,
-                     kPillarXSize, kPillarYSize, kPillarZSize, kMinXRange,
-                     kMinYRange, kMinZRange, kNumIndsForScan, kNumThreads);
-
-  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr pcl_pc_ptr(
-      new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
-  test_obj.MakePointsForTest(pcl_pc_ptr);
-
-  float* points_array = new float[pcl_pc_ptr-&gt;size() * 4];
-  test_obj.PclToArray(pcl_pc_ptr, points_array);
-
-  int x_coors[kMaxNumPillars] = {};
-  int y_coors[kMaxNumPillars] = {};
-  float num_points_per_pillar[kMaxNumPillars] = {};
-
-  float* pillar_point_feature =
-      new float[test_obj.max_num_pillars * test_obj.max_num_points_per_pillar *
-                test_obj.num_point_feature];
-  float* pillar_coors = new float[test_obj.max_num_pillars * 4];
-  float* sparse_pillar_map = new float[kNumIndsForScan * kNumIndsForScan];
-
-  int host_pillar_count[1] = {0};
-  test_obj.Preprocess(points_array, pcl_pc_ptr-&gt;size(), x_coors, y_coors,
-                      num_points_per_pillar, pillar_point_feature, pillar_coors,
-                      sparse_pillar_map, host_pillar_count);
-  EXPECT_EQ(1, num_points_per_pillar[0]);
-  EXPECT_FLOAT_EQ(12.9892, pillar_point_feature[0]);
-  EXPECT_EQ(74, x_coors[1]);
-  EXPECT_EQ(178, y_coors[1]);
-  EXPECT_EQ(1, sparse_pillar_map[178 * 512 + 74]);
-  EXPECT_EQ(8, host_pillar_count[0]);
-
-  delete[] points_array;
-  delete[] pillar_point_feature;
-  delete[] pillar_coors;
-  delete[] sparse_pillar_map;
-}
-
-TEST(TestSuite, CheckPreprocessGPU) {
-  const int kNumClass = 1;
-  const int kMaxNumPillars = 12000;
-  const int kMaxNumPointsPerPillar = 100;
-  const int kNumPointFeature = 4;
-  const int kGridXSize = 432;
-  const int kGridYSize = 496;
-  const int kGridZSize = 1;
-  const float kPillarXSize = 0.16;
-  const float kPillarYSize = 0.16;
-  const float kPillarZSize = 4.0;
-  const float kMinXRange = 0;
-  const float kMinYRange = -39.68;
-  const float kMinZRange = -3.0;
-  const int kNumIndsForScan = 512;
-  const int kNumThreads = 64;
-  const float kNormalizingFactor = 255.0;
-  TestClass test_obj(kNumClass, kMaxNumPillars, kMaxNumPointsPerPillar,
-                     kNumPointFeature, kGridXSize, kGridYSize, kGridZSize,
-                     kPillarXSize, kPillarYSize, kPillarZSize, kMinXRange,
-                     kMinYRange, kMinZRange, kNumIndsForScan, kNumThreads);
-
-  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr pcl_pc_ptr(
-      new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
-  apollo::perception::benchmark::PointCloudPtr org_cloud_ptr(
-      new pcl::PointCloud&lt;apollo::perception::benchmark::PointXYZIL&gt;);
-  std::string file_name =
-      "/apollo/modules/perception/testdata/lidar/app/data/0001_00.pcd";
-
-  bool ret = apollo::perception::benchmark::load_pcl_pcds_xyzit(file_name,
-                                                                org_cloud_ptr);
-  ASSERT_TRUE(ret) &lt;&lt; "Failed to load pcd file: " &lt;&lt; file_name;
-
-  for (size_t i = 0; i &lt; org_cloud_ptr-&gt;size(); ++i) {
-    pcl::PointXYZI point;
-    point.x = org_cloud_ptr-&gt;at(i).x;
-    point.y = org_cloud_ptr-&gt;at(i).y;
-    point.z = org_cloud_ptr-&gt;at(i).z;
-    point.intensity = org_cloud_ptr-&gt;at(i).intensity;
-    pcl_pc_ptr-&gt;push_back(point);
-  }
-  int in_num_points = pcl_pc_ptr-&gt;size();
-  float* points_array = new float[pcl_pc_ptr-&gt;size() * 4];
-  test_obj.PclToArray(pcl_pc_ptr, points_array, kNormalizingFactor);
-
-  float* dev_points;
-  int* dev_x_coors;
-  int* dev_y_coors;
-  float* dev_num_points_per_pillar;
-  int* dev_sparse_pillar_map;
-  float* dev_pillar_point_feature;
-  float* dev_pillar_coors;
-  int host_pillar_count[1] = {};
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_points),
-                       in_num_points * kNumPointFeature * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_x_coors),
-                       kMaxNumPillars * sizeof(int)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_y_coors),
-                       kMaxNumPillars * sizeof(int)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_num_points_per_pillar),
-                       kMaxNumPillars * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_sparse_pillar_map),
-                       kNumIndsForScan * kNumIndsForScan * sizeof(int)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_pillar_point_feature),
-                       kMaxNumPillars * kMaxNumPointsPerPillar *
-                           kNumPointFeature * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_pillar_coors),
-                       kMaxNumPillars * 4 * sizeof(float)));
-
-  GPU_CHECK(cudaMemcpy(dev_points, points_array,
-                       in_num_points * kNumPointFeature * sizeof(float),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemset(dev_x_coors, 0, kMaxNumPillars * sizeof(int)));
-  GPU_CHECK(cudaMemset(dev_y_coors, 0, kMaxNumPillars * sizeof(int)));
-  GPU_CHECK(
-      cudaMemset(dev_num_points_per_pillar, 0, kMaxNumPillars * sizeof(float)));
-  GPU_CHECK(cudaMemset(dev_pillar_point_feature, 0,
-                       kMaxNumPillars * kMaxNumPointsPerPillar *
-                           kNumPointFeature * sizeof(float)));
-  GPU_CHECK(
-      cudaMemset(dev_pillar_coors, 0, kMaxNumPillars * 4 * sizeof(float)));
-  GPU_CHECK(cudaMemset(dev_sparse_pillar_map, 0,
-                       kNumIndsForScan * kNumIndsForScan * sizeof(int)));
-
-  test_obj.PreprocessGPU(dev_points, in_num_points, dev_x_coors, dev_y_coors,
-                         dev_num_points_per_pillar, dev_pillar_point_feature,
-                         dev_pillar_coors, dev_sparse_pillar_map,
-                         host_pillar_count);
-
-  int* x_coors = new int[kMaxNumPillars];
-  int* y_coors = new int[kMaxNumPillars];
-  float* num_points_per_pillar = new float[kMaxNumPillars];
-  int* sparse_pillar_map = new int[kNumIndsForScan * kNumIndsForScan];
-  float* pillar_point_feature =
-      new float[kMaxNumPillars * kMaxNumPointsPerPillar * kNumPointFeature];
-  float* pillar_coors = new float[kMaxNumPillars * 4];
-  GPU_CHECK(cudaMemcpy(x_coors, dev_x_coors, kMaxNumPillars * sizeof(int),
-                       cudaMemcpyDeviceToHost));
-  GPU_CHECK(cudaMemcpy(y_coors, dev_y_coors, kMaxNumPillars * sizeof(int),
-                       cudaMemcpyDeviceToHost));
-  GPU_CHECK(cudaMemcpy(num_points_per_pillar, dev_num_points_per_pillar,
-                       kMaxNumPillars * sizeof(float), cudaMemcpyDeviceToHost));
-  GPU_CHECK(cudaMemcpy(sparse_pillar_map, dev_sparse_pillar_map,
-                       kNumIndsForScan * kNumIndsForScan * sizeof(int),
-                       cudaMemcpyDeviceToHost));
-  GPU_CHECK(cudaMemcpy(pillar_point_feature, dev_pillar_point_feature,
-                       kMaxNumPillars * kMaxNumPointsPerPillar *
-                           kNumPointFeature * sizeof(float),
-                       cudaMemcpyDeviceToHost));
-  GPU_CHECK(cudaMemcpy(pillar_coors, dev_pillar_coors,
-                       kMaxNumPillars * 4 * sizeof(float),
-                       cudaMemcpyDeviceToHost));
-
-  EXPECT_EQ(x_coors[320], static_cast&lt;int&gt;(pillar_coors[1283]));
-  EXPECT_EQ(y_coors[44], static_cast&lt;int&gt;(pillar_coors[178]));
-  EXPECT_GT(pillar_coors[10930 * 4 + 2], 0.9);
-  EXPECT_GT(pillar_coors[10930 * 4 + 3], 0.9);
-  EXPECT_EQ(pillar_coors[10931 * 4 + 2], 0);
-  EXPECT_EQ(pillar_coors[10931 * 4 + 3], 0);
-  EXPECT_GT(num_points_per_pillar[10930], 0.9);
-  EXPECT_EQ(num_points_per_pillar[10931], 0);
-  EXPECT_EQ(host_pillar_count[0], 10931);
-
-  GPU_CHECK(cudaFree(dev_points));
-  GPU_CHECK(cudaFree(dev_x_coors));
-  GPU_CHECK(cudaFree(dev_y_coors));
-  GPU_CHECK(cudaFree(dev_num_points_per_pillar));
-  GPU_CHECK(cudaFree(dev_sparse_pillar_map));
-  GPU_CHECK(cudaFree(dev_pillar_point_feature));
-  GPU_CHECK(cudaFree(dev_pillar_coors));
-
-  delete[] points_array;
-  delete[] x_coors;
-  delete[] y_coors;
-  delete[] num_points_per_pillar;
-  delete[] sparse_pillar_map;
-  delete[] pillar_point_feature;
-  delete[] pillar_coors;
-}
-*/
-/*
-// TODO(chenjiahao): should be changed to multi-anchor for multi-class
-TEST(TestSuite, CheckGenerateAnchors) {
-  const int kNumClass = 1;
-  const int kMaxNumPillars = 12000;
-  const int kMaxNumPointsPerPillar = 100;
-  const int kNumPointFeature = 4;
-  const int kGridXSize = 432;
-  const int kGridYSize = 496;
-  const int kGridZSize = 1;
-  const float kPillarXSize = 0.16;
-  const float kPillarYSize = 0.16;
-  const float kPillarZSize = 4.0;
-  const float kMinXRange = 0;
-  const float kMinYRange = -39.68;
-  const float kMinZRange = -3.0;
-  const int kNumIndsForScan = 512;
-  const int kNumThreads = 64;
-  TestClass test_obj(kNumClass, kMaxNumPillars, kMaxNumPointsPerPillar,
-                     kNumPointFeature, kGridXSize, kGridYSize, kGridZSize,
-                     kPillarXSize, kPillarYSize, kPillarZSize, kMinXRange,
-                     kMinYRange, kMinZRange, kNumIndsForScan, kNumThreads);
-
-  const int kNumAnchor = 432 * 0.5 * 496 * 0.5 * 2;
-  float* anchors_px = new float[kNumAnchor];
-  float* anchors_py = new float[kNumAnchor];
-  float* anchors_pz = new float[kNumAnchor];
-  float* anchors_dx = new float[kNumAnchor];
-  float* anchors_dy = new float[kNumAnchor];
-  float* anchors_dz = new float[kNumAnchor];
-  float* anchors_ro = new float[kNumAnchor];
-  test_obj.GenerateAnchors(anchors_px, anchors_py, anchors_pz, anchors_dx,
-                           anchors_dy, anchors_dz, anchors_ro);
-
-  EXPECT_NEAR(0.48, anchors_px[3], 0.001);
-  EXPECT_NEAR(-39.52, anchors_py[109], 0.001);
-  EXPECT_NEAR(-1.73, anchors_pz[76], 0.001);
-  EXPECT_NEAR(1.6, anchors_dx[338], 0.001);
-  EXPECT_NEAR(3.9, anchors_dy[22], 0.001);
-  EXPECT_NEAR(1.56, anchors_dz[993], 0.001);
-  EXPECT_NEAR(1.5708, anchors_ro[1765], 0.001);
-
-  delete[] anchors_px;
-  delete[] anchors_py;
-  delete[] anchors_pz;
-  delete[] anchors_dx;
-  delete[] anchors_dy;
-  delete[] anchors_dz;
-  delete[] anchors_ro;
-}
-
-TEST(TestSuite, CheckGenerateBoxAnchors) {
-  const int kNumClass = 1;
-  const int kMaxNumPillars = 12000;
-  const int kMaxNumPointsPerPillar = 100;
-  const int kNumPointFeature = 4;
-  const int kGridXSize = 432;
-  const int kGridYSize = 496;
-  const int kGridZSize = 1;
-  const float kPillarXSize = 0.16;
-  const float kPillarYSize = 0.16;
-  const float kPillarZSize = 4.0;
-  const float kMinXRange = 0;
-  const float kMinYRange = -39.68;
-  const float kMinZRange = -3.0;
-  const int kNumIndsForScan = 512;
-  const int kNumThreads = 64;
-  TestClass test_obj(kNumClass, kMaxNumPillars, kMaxNumPointsPerPillar,
-                     kNumPointFeature, kGridXSize, kGridYSize, kGridZSize,
-                     kPillarXSize, kPillarYSize, kPillarZSize, kMinXRange,
-                     kMinYRange, kMinZRange, kNumIndsForScan, kNumThreads);
-
-  const int kNumAnchor = 432 * 0.5 * 496 * 0.5 * 2;
-
-  float* anchors_px = new float[kNumAnchor];
-  float* anchors_py = new float[kNumAnchor];
-  float* anchors_pz = new float[kNumAnchor];
-  float* anchors_dx = new float[kNumAnchor];
-  float* anchors_dy = new float[kNumAnchor];
-  float* anchors_dz = new float[kNumAnchor];
-  float* anchors_ro = new float[kNumAnchor];
-  float* box_anchors_min_x = new float[kNumAnchor];
-  float* box_anchors_min_y = new float[kNumAnchor];
-  float* box_anchors_max_x = new float[kNumAnchor];
-  float* box_anchors_max_y = new float[kNumAnchor];
-  test_obj.GenerateAnchors(anchors_px, anchors_py, anchors_pz, anchors_dx,
-                           anchors_dy, anchors_dz, anchors_ro);
-  test_obj.ConvertAnchors2BoxAnchors(anchors_px, anchors_py, box_anchors_min_x,
-                                     box_anchors_min_y, box_anchors_max_x,
-                                     box_anchors_max_y);
-
-  EXPECT_NEAR(53.25, box_anchors_min_x[345], 0.001);
-  EXPECT_NEAR(-41.47, box_anchors_min_y[22], 0.001);
-  EXPECT_NEAR(38.4, box_anchors_max_x[1098], 0.001);
-  EXPECT_NEAR(-38.4, box_anchors_max_y[675], 0.001);
-
-  delete[] anchors_px;
-  delete[] anchors_py;
-  delete[] anchors_pz;
-  delete[] anchors_dx;
-  delete[] anchors_dy;
-  delete[] anchors_dz;
-  delete[] anchors_ro;
-  delete[] box_anchors_min_x;
-  delete[] box_anchors_min_y;
-  delete[] box_anchors_max_x;
-  delete[] box_anchors_max_y;
-}*/
-
-TEST(TestSuite, CheckDoInference) {
-  const int kNumPointFeature = 5;
-  const int kOutputNumBoxFeature = 7;
-  const float kNormalizingFactor = 255.0;
-  TestClass test_obj;
-
-  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr pcl_pc_ptr(
-      new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
-  apollo::perception::benchmark::PointCloudPtr org_cloud_ptr(
-      new pcl::PointCloud&lt;apollo::perception::benchmark::PointXYZIL&gt;);
-  std::string file_name =
-      "/apollo/modules/perception/testdata/lidar/app/data/0001_00.pcd";
-
-  bool ret = apollo::perception::benchmark::load_pcl_pcds_xyzit(file_name,
-                                                                org_cloud_ptr);
-  ASSERT_TRUE(ret) &lt;&lt; "Failed to load pcd file: " &lt;&lt; file_name;
-
-  for (size_t i = 0; i &lt; org_cloud_ptr-&gt;size(); ++i) {
-    pcl::PointXYZI point;
-    point.x = org_cloud_ptr-&gt;at(i).x;
-    point.y = org_cloud_ptr-&gt;at(i).y;
-    point.z = org_cloud_ptr-&gt;at(i).z;
-    point.intensity = org_cloud_ptr-&gt;at(i).intensity;
-    pcl_pc_ptr-&gt;push_back(point);
-  }
-  float* points_array = new float[pcl_pc_ptr-&gt;size() * kNumPointFeature];
-  test_obj.PclXYZITToArray(pcl_pc_ptr, points_array, kNormalizingFactor);
-
-  std::vector&lt;float&gt; out_detections;
-  std::vector&lt;int&gt; out_labels;
-  test_obj.DoInference(points_array, pcl_pc_ptr-&gt;size(), &amp;out_detections,
-                       &amp;out_labels);
-
-  int num_objects = out_detections.size() / kOutputNumBoxFeature;
-  EXPECT_GE(num_objects, 10);
-  EXPECT_EQ(num_objects, out_labels.size());
-
-  for (int j = 0; j &lt; num_objects; ++j) {
-    float x = out_detections.at(j * kOutputNumBoxFeature + 0);
-    float y = out_detections.at(j * kOutputNumBoxFeature + 1);
-    float z = out_detections.at(j * kOutputNumBoxFeature + 2);
-    float dx = out_detections.at(j * kOutputNumBoxFeature + 4);
-    float dy = out_detections.at(j * kOutputNumBoxFeature + 3);
-    float dz = out_detections.at(j * kOutputNumBoxFeature + 5);
-    float yaw = out_detections.at(j * kOutputNumBoxFeature + 6);
-    yaw += M_PI / 2;
-    yaw = std::atan2(std::sin(yaw), std::cos(yaw));
-    yaw = -yaw;
-
-    int label = out_labels.at(j);
-    std::cout &lt;&lt; "object id: " &lt;&lt; j &lt;&lt; ", x: " &lt;&lt; x &lt;&lt; ", y: " &lt;&lt; y
-              &lt;&lt; ", z: " &lt;&lt; z &lt;&lt; ", dx: " &lt;&lt; dx &lt;&lt; ", dy: " &lt;&lt; dy
-              &lt;&lt; ", dz: " &lt;&lt; dz &lt;&lt; ", yaw: " &lt;&lt; yaw &lt;&lt; ", label: " &lt;&lt; label
-              &lt;&lt; std::endl;
-  }
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\postprocess_cuda.cu" new_path="" added_lines="0" deleted_lines="330">
				<diff>@@ -1,330 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// headers in CUDA
-#include &lt;thrust/device_ptr.h&gt;
-#include &lt;thrust/host_vector.h&gt;
-#include &lt;thrust/sort.h&gt;
-
-// headers in local files
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/postprocess_cuda.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-__global__ void filter_kernel(
-    const float* box_preds, const float* cls_preds, const float* dir_preds,
-    const int* anchor_mask, const float* dev_anchors_px,
-    const float* dev_anchors_py, const float* dev_anchors_pz,
-    const float* dev_anchors_dx, const float* dev_anchors_dy,
-    const float* dev_anchors_dz, const float* dev_anchors_ro,
-    float* filtered_box, float* filtered_score, int* filtered_label,
-    int* filtered_dir, float* box_for_nms, int* filter_count,
-    const float float_min, const float float_max, const float score_threshold,
-    const int num_box_corners, const int num_output_box_feature,
-    const int num_class) {
-  // boxes ([N, 7] Tensor): normal boxes: x, y, z, w, l, h, r
-  int tid = threadIdx.x + blockIdx.x * blockDim.x;
-  // sigmoid function
-  float top_score = 0;
-  int top_label = 0;
-  for (int i = 0; i &lt; num_class; ++i) {
-    float score = 1 / (1 + expf(-cls_preds[tid * num_class + i]));
-    if (score &gt; top_score) {
-      top_score = score;
-      top_label = i;
-    }
-  }
-  if (anchor_mask[tid] == 1 &amp;&amp; top_score &gt; score_threshold) {
-    int counter = atomicAdd(filter_count, 1);
-    float za = dev_anchors_pz[tid] + dev_anchors_dz[tid] / 2;
-
-    // decode network output
-    float diagonal = sqrtf(dev_anchors_dx[tid] * dev_anchors_dx[tid] +
-                           dev_anchors_dy[tid] * dev_anchors_dy[tid]);
-    float box_px = box_preds[tid * num_output_box_feature + 0] * diagonal +
-                   dev_anchors_px[tid];
-    float box_py = box_preds[tid * num_output_box_feature + 1] * diagonal +
-                   dev_anchors_py[tid];
-    float box_pz =
-        box_preds[tid * num_output_box_feature + 2] * dev_anchors_dz[tid] + za;
-    float box_dx =
-        expf(box_preds[tid * num_output_box_feature + 3]) * dev_anchors_dx[tid];
-    float box_dy =
-        expf(box_preds[tid * num_output_box_feature + 4]) * dev_anchors_dy[tid];
-    float box_dz =
-        expf(box_preds[tid * num_output_box_feature + 5]) * dev_anchors_dz[tid];
-    float box_ro =
-        box_preds[tid * num_output_box_feature + 6] + dev_anchors_ro[tid];
-
-    box_pz = box_pz - box_dz / 2;
-
-    filtered_box[counter * num_output_box_feature + 0] = box_px;
-    filtered_box[counter * num_output_box_feature + 1] = box_py;
-    filtered_box[counter * num_output_box_feature + 2] = box_pz;
-    filtered_box[counter * num_output_box_feature + 3] = box_dx;
-    filtered_box[counter * num_output_box_feature + 4] = box_dy;
-    filtered_box[counter * num_output_box_feature + 5] = box_dz;
-    filtered_box[counter * num_output_box_feature + 6] = box_ro;
-    filtered_score[counter] = top_score;
-    filtered_label[counter] = top_label;
-
-    int direction_label;
-    if (dir_preds[tid * 2 + 0] &lt; dir_preds[tid * 2 + 1]) {
-      direction_label = 1;
-    } else {
-      direction_label = 0;
-    }
-    filtered_dir[counter] = direction_label;
-
-    // convrt normal box(normal boxes: x, y, z, w, l, h, r) to box(xmin, ymin,
-    // xmax, ymax) for nms calculation First: dx, dy -&gt; box(x0y0, x0y1, x1y0,
-    // x1y1)
-    float corners[NUM_3D_BOX_CORNERS_MACRO] = {
-        static_cast&lt;float&gt;(-0.5 * box_dx), static_cast&lt;float&gt;(-0.5 * box_dy),
-        static_cast&lt;float&gt;(-0.5 * box_dx), static_cast&lt;float&gt;(0.5 * box_dy),
-        static_cast&lt;float&gt;(0.5 * box_dx),  static_cast&lt;float&gt;(0.5 * box_dy),
-        static_cast&lt;float&gt;(0.5 * box_dx),  static_cast&lt;float&gt;(-0.5 * box_dy)};
-
-    // Second: Rotate, Offset and convert to point(xmin. ymin, xmax, ymax)
-    float rotated_corners[NUM_3D_BOX_CORNERS_MACRO];
-    float offset_corners[NUM_3D_BOX_CORNERS_MACRO];
-    float sin_yaw = sinf(box_ro);
-    float cos_yaw = cosf(box_ro);
-    float xmin = float_max;
-    float ymin = float_max;
-    float xmax = float_min;
-    float ymax = float_min;
-    for (size_t i = 0; i &lt; num_box_corners; ++i) {
-      rotated_corners[i * 2 + 0] =
-          cos_yaw * corners[i * 2 + 0] - sin_yaw * corners[i * 2 + 1];
-      rotated_corners[i * 2 + 1] =
-          sin_yaw * corners[i * 2 + 0] + cos_yaw * corners[i * 2 + 1];
-
-      offset_corners[i * 2 + 0] = rotated_corners[i * 2 + 0] + box_px;
-      offset_corners[i * 2 + 1] = rotated_corners[i * 2 + 1] + box_py;
-
-      xmin = fminf(xmin, offset_corners[i * 2 + 0]);
-      ymin = fminf(ymin, offset_corners[i * 2 + 1]);
-      xmax = fmaxf(xmax, offset_corners[i * 2 + 0]);
-      ymax = fmaxf(ymax, offset_corners[i * 2 + 1]);
-    }
-    // box_for_nms(num_box, 4)
-    box_for_nms[counter * num_box_corners + 0] = xmin;
-    box_for_nms[counter * num_box_corners + 1] = ymin;
-    box_for_nms[counter * num_box_corners + 2] = xmax;
-    box_for_nms[counter * num_box_corners + 3] = ymax;
-  }
-}
-
-__global__ void sort_boxes_by_indexes_kernel(
-    float* filtered_box, int* filtered_label, int* filtered_dir,
-    float* box_for_nms, int* indexes, int filter_count,
-    float* sorted_filtered_boxes, int* sorted_filtered_label,
-    int* sorted_filtered_dir, float* sorted_box_for_nms,
-    const int num_box_corners, const int num_output_box_feature) {
-  int tid = threadIdx.x + blockIdx.x * blockDim.x;
-  if (tid &lt; filter_count) {
-    int sort_index = indexes[tid];
-    sorted_filtered_boxes[tid * num_output_box_feature + 0] =
-        filtered_box[sort_index * num_output_box_feature + 0];
-    sorted_filtered_boxes[tid * num_output_box_feature + 1] =
-        filtered_box[sort_index * num_output_box_feature + 1];
-    sorted_filtered_boxes[tid * num_output_box_feature + 2] =
-        filtered_box[sort_index * num_output_box_feature + 2];
-    sorted_filtered_boxes[tid * num_output_box_feature + 3] =
-        filtered_box[sort_index * num_output_box_feature + 3];
-    sorted_filtered_boxes[tid * num_output_box_feature + 4] =
-        filtered_box[sort_index * num_output_box_feature + 4];
-    sorted_filtered_boxes[tid * num_output_box_feature + 5] =
-        filtered_box[sort_index * num_output_box_feature + 5];
-    sorted_filtered_boxes[tid * num_output_box_feature + 6] =
-        filtered_box[sort_index * num_output_box_feature + 6];
-
-    sorted_filtered_label[tid] = filtered_label[sort_index];
-
-    sorted_filtered_dir[tid] = filtered_dir[sort_index];
-
-    sorted_box_for_nms[tid * num_box_corners + 0] =
-        box_for_nms[sort_index * num_box_corners + 0];
-    sorted_box_for_nms[tid * num_box_corners + 1] =
-        box_for_nms[sort_index * num_box_corners + 1];
-    sorted_box_for_nms[tid * num_box_corners + 2] =
-        box_for_nms[sort_index * num_box_corners + 2];
-    sorted_box_for_nms[tid * num_box_corners + 3] =
-        box_for_nms[sort_index * num_box_corners + 3];
-  }
-}
-
-PostprocessCuda::PostprocessCuda(const float float_min, const float float_max,
-                                 const int num_anchor, const int num_class,
-                                 const float score_threshold,
-                                 const int num_threads,
-                                 const float nms_overlap_threshold,
-                                 const int num_box_corners,
-                                 const int num_output_box_feature)
-    : float_min_(float_min),
-      float_max_(float_max),
-      num_anchor_(num_anchor),
-      num_class_(num_class),
-      score_threshold_(score_threshold),
-      num_threads_(num_threads),
-      nms_overlap_threshold_(nms_overlap_threshold),
-      num_box_corners_(num_box_corners),
-      num_output_box_feature_(num_output_box_feature) {
-  nms_cuda_ptr_.reset(
-      new NmsCuda(num_threads, num_box_corners, nms_overlap_threshold));
-}
-
-void PostprocessCuda::DoPostprocessCuda(
-    const float* rpn_box_output, const float* rpn_cls_output,
-    const float* rpn_dir_output, int* dev_anchor_mask,
-    const float* dev_anchors_px, const float* dev_anchors_py,
-    const float* dev_anchors_pz, const float* dev_anchors_dx,
-    const float* dev_anchors_dy, const float* dev_anchors_dz,
-    const float* dev_anchors_ro, float* dev_filtered_box,
-    float* dev_filtered_score, int* dev_filtered_label, int* dev_filtered_dir,
-    float* dev_box_for_nms, int* dev_filter_count,
-    std::vector&lt;float&gt;* out_detection, std::vector&lt;int&gt;* out_label) {
-  const int num_blocks_filter_kernel = DIVUP(num_anchor_, num_threads_);
-  filter_kernel&lt;&lt;&lt;num_blocks_filter_kernel, num_threads_&gt;&gt;&gt;(
-      rpn_box_output, rpn_cls_output, rpn_dir_output, dev_anchor_mask,
-      dev_anchors_px, dev_anchors_py, dev_anchors_pz, dev_anchors_dx,
-      dev_anchors_dy, dev_anchors_dz, dev_anchors_ro, dev_filtered_box,
-      dev_filtered_score, dev_filtered_label, dev_filtered_dir, dev_box_for_nms,
-      dev_filter_count, float_min_, float_max_, score_threshold_,
-      num_box_corners_, num_output_box_feature_, num_class_);
-
-  int host_filter_count[1] = {0};
-  GPU_CHECK(cudaMemcpy(host_filter_count, dev_filter_count, sizeof(int),
-                       cudaMemcpyDeviceToHost));
-  if (host_filter_count[0] == 0) {
-    return;
-  }
-
-  int* dev_indexes;
-  float *dev_sorted_filtered_box, *dev_sorted_box_for_nms;
-  int *dev_sorted_filtered_label, *dev_sorted_filtered_dir;
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_indexes),
-                       host_filter_count[0] * sizeof(int)));
-  GPU_CHECK(cudaMalloc(
-      reinterpret_cast&lt;void**&gt;(&amp;dev_sorted_filtered_box),
-      num_output_box_feature_ * host_filter_count[0] * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_sorted_filtered_label),
-                       host_filter_count[0] * sizeof(int)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_sorted_filtered_dir),
-                       host_filter_count[0] * sizeof(int)));
-  GPU_CHECK(
-      cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_sorted_box_for_nms),
-                 num_box_corners_ * host_filter_count[0] * sizeof(float)));
-
-  thrust::device_ptr&lt;float&gt; dev_ptr_filtered_score(dev_filtered_score);
-  thrust::host_vector&lt;float&gt; host_filtered_score(host_filter_count[0]);
-  thrust::copy(dev_ptr_filtered_score,
-               dev_ptr_filtered_score + size_t(host_filter_count[0]),
-               host_filtered_score.begin());
-
-  thrust::host_vector&lt;int&gt; host_indexes(host_filter_count[0]);
-  thrust::sequence(host_indexes.begin(), host_indexes.end());
-
-  // TODO(chenjiahao): using GPU may cause crash, so use CPU here to sort,
-  //  temporarily. Will change to GPU after upgrading CUDA in the future.
-  thrust::sort_by_key(host_filtered_score.begin(),
-                      host_filtered_score.end(),
-                      host_indexes.begin(), thrust::greater&lt;float&gt;());
-  GPU_CHECK(cudaMemcpy(dev_indexes,
-                       thrust::raw_pointer_cast(host_indexes.data()),
-                       host_filter_count[0] * sizeof(int),
-                       cudaMemcpyHostToDevice));
-
-  const int num_blocks = DIVUP(host_filter_count[0], num_threads_);
-  sort_boxes_by_indexes_kernel&lt;&lt;&lt;num_blocks, num_threads_&gt;&gt;&gt;(
-      dev_filtered_box, dev_filtered_label, dev_filtered_dir, dev_box_for_nms,
-      dev_indexes, host_filter_count[0], dev_sorted_filtered_box,
-      dev_sorted_filtered_label, dev_sorted_filtered_dir,
-      dev_sorted_box_for_nms, num_box_corners_, num_output_box_feature_);
-
-  int keep_inds[host_filter_count[0]];
-  memset(keep_inds, 0, host_filter_count[0] * sizeof(int));
-  int out_num_objects = 0;
-  nms_cuda_ptr_-&gt;DoNmsCuda(host_filter_count[0], dev_sorted_box_for_nms,
-                           keep_inds, &amp;out_num_objects);
-
-  float host_filtered_box[host_filter_count[0] * num_output_box_feature_];
-  int host_filtered_label[host_filter_count[0]];
-  int host_filtered_dir[host_filter_count[0]];
-  GPU_CHECK(
-      cudaMemcpy(host_filtered_box, dev_sorted_filtered_box,
-                 num_output_box_feature_ * host_filter_count[0] * sizeof(float),
-                 cudaMemcpyDeviceToHost));
-  GPU_CHECK(cudaMemcpy(host_filtered_label, dev_sorted_filtered_label,
-                       host_filter_count[0] * sizeof(int),
-                       cudaMemcpyDeviceToHost));
-  GPU_CHECK(cudaMemcpy(host_filtered_dir, dev_sorted_filtered_dir,
-                       host_filter_count[0] * sizeof(int),
-                       cudaMemcpyDeviceToHost));
-  for (size_t i = 0; i &lt; out_num_objects; ++i) {
-    out_detection-&gt;push_back(
-        host_filtered_box[keep_inds[i] * num_output_box_feature_ + 0]);
-    out_detection-&gt;push_back(
-        host_filtered_box[keep_inds[i] * num_output_box_feature_ + 1]);
-    out_detection-&gt;push_back(
-        host_filtered_box[keep_inds[i] * num_output_box_feature_ + 2]);
-    out_detection-&gt;push_back(
-        host_filtered_box[keep_inds[i] * num_output_box_feature_ + 3]);
-    out_detection-&gt;push_back(
-        host_filtered_box[keep_inds[i] * num_output_box_feature_ + 4]);
-    out_detection-&gt;push_back(
-        host_filtered_box[keep_inds[i] * num_output_box_feature_ + 5]);
-
-    if (host_filtered_dir[keep_inds[i]] == 0) {
-      out_detection-&gt;push_back(
-          host_filtered_box[keep_inds[i] * num_output_box_feature_ + 6] + M_PI);
-    } else {
-      out_detection-&gt;push_back(
-          host_filtered_box[keep_inds[i] * num_output_box_feature_ + 6]);
-    }
-
-    out_label-&gt;push_back(host_filtered_label[keep_inds[i]]);
-  }
-
-  GPU_CHECK(cudaFree(dev_indexes));
-  GPU_CHECK(cudaFree(dev_sorted_filtered_box));
-  GPU_CHECK(cudaFree(dev_sorted_filtered_label));
-  GPU_CHECK(cudaFree(dev_sorted_filtered_dir));
-  GPU_CHECK(cudaFree(dev_sorted_box_for_nms));
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\postprocess_cuda.h" new_path="" added_lines="0" deleted_lines="127">
				<diff>@@ -1,127 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file postprocess_cuda.h
- * @brief Postprocess for network output
- * @author Kosuke Murakami
- * @date 2019/02/26
- */
-
-#pragma once
-
-// headers in STL
-#include &lt;iostream&gt;
-#include &lt;memory&gt;
-#include &lt;vector&gt;
-
-// headers in local files
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/nms_cuda.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class PostprocessCuda {
- private:
-  const float float_min_;
-  const float float_max_;
-  const int num_anchor_;
-  const int num_class_;
-  const float score_threshold_;
-  const int num_threads_;
-  const float nms_overlap_threshold_;
-  const int num_box_corners_;
-  const int num_output_box_feature_;
-
-  std::unique_ptr&lt;NmsCuda&gt; nms_cuda_ptr_;
-
- public:
-  /**
-   * @brief Constructor
-   * @param[in] float_min The lowest float value
-   * @param[in] float_max The maximum float value
-   * @param[in] num_anchor Number of anchors in total
-   * @param[in] num_class Number of object's classes
-   * @param[in] score_threshold Score threshold for filtering output
-   * @param[in] num_threads Number of threads when launching cuda kernel
-   * @param[in] nms_overlap_threshold IOU threshold for NMS
-   * @param[in] num_box_corners Number of box's corner
-   * @param[in] num_output_box_feature Number of output box's feature
-   * @details Captital variables never change after the compile, non-capital
-   * variables could be changed through rosparam
-   */
-  PostprocessCuda(const float float_min, const float float_max,
-                  const int num_anchor, const int num_class,
-                  const float score_threshold, const int num_threads,
-                  const float nms_overlap_threshold, const int num_box_corners,
-                  const int num_output_box_feature);
-
-  /**
-   * @brief Postprocessing for the network output
-   * @param[in] rpn_box_output Box predictions from the network output
-   * @param[in] rpn_cls_output Class predictions from the network output
-   * @param[in] rpn_dir_output Direction predictions from the network output
-   * @param[in] dev_anchor_mask Anchor mask for filtering the network output
-   * @param[in] dev_anchors_px X-coordinate values for corresponding anchors
-   * @param[in] dev_anchors_py Y-coordinate values for corresponding anchors
-   * @param[in] dev_anchors_pz Z-coordinate values for corresponding anchors
-   * @param[in] dev_anchors_dx X-dimension values for corresponding anchors
-   * @param[in] dev_anchors_dy Y-dimension values for corresponding anchors
-   * @param[in] dev_anchors_dz Z-dimension values for corresponding anchors
-   * @param[in] dev_anchors_ro Rotation values for corresponding anchors
-   * @param[in] dev_filtered_box Filtered box predictions
-   * @param[in] dev_filtered_score Filtered score predictions
-   * @param[in] dev_filtered_label Filtered label predictions
-   * @param[in] dev_filtered_dir Filtered direction predictions
-   * @param[in] dev_box_for_nms Decoded boxes in min_x min_y max_x max_y
-   * represenation from pose and dimension
-   * @param[in] dev_filter_count The number of filtered output
-   * @param[out] out_detection Output bounding boxes
-   * @param[out] out_label Output labels of objects
-   * @details dev_* represents device memory allocated variables
-   */
-  void DoPostprocessCuda(
-      const float* rpn_box_output, const float* rpn_cls_output,
-      const float* rpn_dir_output, int* dev_anchor_mask,
-      const float* dev_anchors_px, const float* dev_anchors_py,
-      const float* dev_anchors_pz, const float* dev_anchors_dx,
-      const float* dev_anchors_dy, const float* dev_anchors_dz,
-      const float* dev_anchors_ro, float* dev_filtered_box,
-      float* dev_filtered_score, int* dev_filtered_label, int* dev_filtered_dir,
-      float* dev_box_for_nms, int* dev_filter_count,
-      std::vector&lt;float&gt;* out_detection, std::vector&lt;int&gt;* out_label);
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\preprocess_points.cc" new_path="" added_lines="0" deleted_lines="162">
				<diff>@@ -1,162 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// headers in STL
-#include &lt;cmath&gt;
-#include &lt;iostream&gt;
-
-// headers in local files
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/preprocess_points.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-PreprocessPoints::PreprocessPoints(
-    const int max_num_pillars, const int max_points_per_pillar,
-    const int num_point_feature, const int grid_x_size, const int grid_y_size,
-    const int grid_z_size, const float pillar_x_size, const float pillar_y_size,
-    const float pillar_z_size, const float min_x_range, const float min_y_range,
-    const float min_z_range, const int num_inds_for_scan)
-    : max_num_pillars_(max_num_pillars),
-      max_num_points_per_pillar_(max_points_per_pillar),
-      num_point_feature_(num_point_feature),
-      grid_x_size_(grid_x_size),
-      grid_y_size_(grid_y_size),
-      grid_z_size_(grid_z_size),
-      pillar_x_size_(pillar_x_size),
-      pillar_y_size_(pillar_y_size),
-      pillar_z_size_(pillar_z_size),
-      min_x_range_(min_x_range),
-      min_y_range_(min_y_range),
-      min_z_range_(min_z_range),
-      num_inds_for_scan_(num_inds_for_scan) {}
-
-void PreprocessPoints::InitializeVariables(int* coor_to_pillaridx,
-                                           float* sparse_pillar_map,
-                                           float* pillar_point_feature,
-                                           float* pillar_coors) {
-  for (int i = 0; i &lt; grid_y_size_; ++i) {
-    for (int j = 0; j &lt; grid_x_size_; ++j) {
-      coor_to_pillaridx[i * grid_x_size_ + j] = -1;
-    }
-  }
-
-  for (int i = 0; i &lt; num_inds_for_scan_; ++i) {
-    for (int j = 0; j &lt; num_inds_for_scan_; ++j) {
-      sparse_pillar_map[i * num_inds_for_scan_ + j] = 0;
-    }
-  }
-
-  for (int i = 0;
-       i &lt; max_num_pillars_ * max_num_points_per_pillar_ * num_point_feature_;
-       ++i) {
-    pillar_point_feature[i] = 0;
-  }
-
-  for (int i = 0; i &lt; max_num_pillars_ * 4; ++i) {
-    pillar_coors[i] = 0;
-  }
-}
-
-void PreprocessPoints::Preprocess(const float* in_points_array,
-                                  int in_num_points, int* x_coors, int* y_coors,
-                                  float* num_points_per_pillar,
-                                  float* pillar_point_feature,
-                                  float* pillar_coors, float* sparse_pillar_map,
-                                  int* host_pillar_count) {
-  int pillar_count = 0;
-  // init variables
-  int* coor_to_pillaridx = new int[grid_y_size_ * grid_x_size_];
-  InitializeVariables(coor_to_pillaridx, sparse_pillar_map,
-                      pillar_point_feature, pillar_coors);
-  for (int i = 0; i &lt; in_num_points; ++i) {
-    int x_coor = std::floor(
-        (in_points_array[i * num_point_feature_ + 0] - min_x_range_) /
-        pillar_x_size_);
-    int y_coor = std::floor(
-        (in_points_array[i * num_point_feature_ + 1] - min_y_range_) /
-        pillar_y_size_);
-    int z_coor = std::floor(
-        (in_points_array[i * num_point_feature_ + 2] - min_z_range_) /
-        pillar_z_size_);
-    if (x_coor &lt; 0 || x_coor &gt;= grid_x_size_ || y_coor &lt; 0 ||
-        y_coor &gt;= grid_y_size_ || z_coor &lt; 0 || z_coor &gt;= grid_z_size_) {
-      continue;
-    }
-    // reverse index
-    int pillar_index = coor_to_pillaridx[y_coor * grid_x_size_ + x_coor];
-    if (pillar_index == -1) {
-      pillar_index = pillar_count;
-      if (pillar_count &gt;= max_num_pillars_) {
-        break;
-      }
-      pillar_count += 1;
-      coor_to_pillaridx[y_coor * grid_x_size_ + x_coor] = pillar_index;
-
-      y_coors[pillar_index] = std::floor(y_coor);
-      x_coors[pillar_index] = std::floor(x_coor);
-
-      sparse_pillar_map[y_coor * num_inds_for_scan_ + x_coor] = 1;
-    }
-    int num = num_points_per_pillar[pillar_index];
-    if (num &lt; max_num_points_per_pillar_) {
-      for (int j = 0; j &lt; num_point_feature_; ++j) {
-        pillar_point_feature[pillar_index * max_num_points_per_pillar_ *
-                                 num_point_feature_ +
-                             num * num_point_feature_ + j] =
-            in_points_array[i * num_point_feature_ + j];
-      }
-      num_points_per_pillar[pillar_index] += 1;
-    }
-  }
-
-  for (int i = 0; i &lt; max_num_pillars_; ++i) {
-    float x = 0;
-    float y = 0;
-    if (i &lt; pillar_count) {
-      x = static_cast&lt;float&gt;(x_coors[i]);
-      y = static_cast&lt;float&gt;(y_coors[i]);
-    }
-    pillar_coors[i * 4 + 0] = 0;  // batch idx, but currently it is useless
-    pillar_coors[i * 4 + 1] = 0;  // z
-    pillar_coors[i * 4 + 2] = y;
-    pillar_coors[i * 4 + 3] = x;
-  }
-  host_pillar_count[0] = pillar_count;
-
-  delete[] coor_to_pillaridx;
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\preprocess_points.h" new_path="" added_lines="0" deleted_lines="125">
				<diff>@@ -1,125 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file preprocess_points.h
- * @brief CPU version of preprocess points
- * @author Kosuke Murakami
- * @date 2019/02/26
- */
-
-#pragma once
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class PreprocessPoints {
- private:
-  friend class TestClass;
-  const int max_num_pillars_;
-  const int max_num_points_per_pillar_;
-  const int num_point_feature_;
-  const int grid_x_size_;
-  const int grid_y_size_;
-  const int grid_z_size_;
-  const float pillar_x_size_;
-  const float pillar_y_size_;
-  const float pillar_z_size_;
-  const float min_x_range_;
-  const float min_y_range_;
-  const float min_z_range_;
-  const int num_inds_for_scan_;
-
- public:
-  /**
-   * @brief Constructor
-   * @param[in] max_num_pillars Maximum number of pillars
-   * @param[in] max_points_per_pillar Maximum number of points per pillar
-   * @param[in] num_point_feature Number of features in a point
-   * @param[in] grid_x_size Number of pillars in x-coordinate
-   * @param[in] grid_y_size Number of pillars in y-coordinate
-   * @param[in] grid_z_size Number of pillars in z-coordinate
-   * @param[in] pillar_x_size Size of x-dimension for a pillar
-   * @param[in] pillar_y_size Size of y-dimension for a pillar
-   * @param[in] pillar_z_size Size of z-dimension for a pillar
-   * @param[in] min_x_range Minimum x value for pointcloud
-   * @param[in] min_y_range Minimum y value for pointcloud
-   * @param[in] min_z_range Minimum z value for pointcloud
-   * @param[in] num_inds_for_scan Number of indexes for scan(cumsum)
-   * @details Captital variables never change after the compile
-   */
-  PreprocessPoints(const int max_num_pillars, const int max_points_per_pillar,
-                   const int num_point_feature, const int grid_x_size,
-                   const int grid_y_size, const int grid_z_size,
-                   const float pillar_x_size, const float pillar_y_size,
-                   const float pillar_z_size, const float min_x_range,
-                   const float min_y_range, const float min_z_range,
-                   const int num_inds_for_scan);
-
-  /**
-   * @brief CPU preprocessing for input pointcloud
-   * @param[in] in_points_array Pointcloud array
-   * @param[in] in_num_points The number of points
-   * @param[in] x_coors X-coordinate indexes for corresponding pillars
-   * @param[in] y_coors Y-coordinate indexes for corresponding pillars
-   * @param[in] num_points_per_pillar Number of points in corresponding pillars
-   * @param[in] pillar_point_feature Values for features of points in each
-   * pillar
-   * @param[in] pillar_coors Array for coors of pillars
-   * @param[in] sparse_pillar_map Grid map representation for pillar-occupancy
-   * @param[in] host_pillar_count The numnber of valid pillars for the input
-   * pointcloud
-   * @details Convert pointcloud to pillar representation
-   */
-  void Preprocess(const float* in_points_array, int in_num_points, int* x_coors,
-                  int* y_coors, float* num_points_per_pillar,
-                  float* pillar_point_feature, float* pillar_coors,
-                  float* sparse_pillar_map, int* host_pillar_count);
-
-  /**
-   * @brief Initializing variables for preprocessing
-   * @param[in] coor_to_pillaridx Map for converting one set of coordinate to a
-   * pillar
-   * @param[in] sparse_pillar_map Grid map representation for pillar-occupancy
-   * @param[in] pillar_point_feature Values for features of points in each
-   * pillar
-   * @param[in] pillar_coors Array for coors of pillars
-   * @details Initializeing input arguments with certain values
-   */
-  void InitializeVariables(int* coor_to_pillaridx, float* sparse_pillar_map,
-                           float* pillar_point_feature, float* pillar_coors);
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\preprocess_points_cuda.cu" new_path="" added_lines="0" deleted_lines="213">
				<diff>@@ -1,213 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// headers in STL
-#include &lt;iostream&gt;
-
-// headers in local files
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/common.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/preprocess_points_cuda.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-__global__ void make_pillar_histo_kernel(
-    const float* dev_points, float* dev_pillar_point_feature_in_coors,
-    int* pillar_count_histo, const int num_points,
-    const int max_points_per_pillar, const int grid_x_size,
-    const int grid_y_size, const int grid_z_size, const float min_x_range,
-    const float min_y_range, const float min_z_range, const float pillar_x_size,
-    const float pillar_y_size, const float pillar_z_size,
-    const int num_point_feature) {
-  int th_i = threadIdx.x + blockIdx.x * blockDim.x;
-  if (th_i &gt;= num_points) {
-    return;
-  }
-  int y_coor = floor((dev_points[th_i * num_point_feature + 1] - min_y_range) /
-                     pillar_y_size);
-  int x_coor = floor((dev_points[th_i * num_point_feature + 0] - min_x_range) /
-                     pillar_x_size);
-  int z_coor = floor((dev_points[th_i * num_point_feature + 2] - min_z_range) /
-                     pillar_z_size);
-
-  if (x_coor &gt;= 0 &amp;&amp; x_coor &lt; grid_x_size &amp;&amp; y_coor &gt;= 0 &amp;&amp;
-      y_coor &lt; grid_y_size &amp;&amp; z_coor &gt;= 0 &amp;&amp; z_coor &lt; grid_z_size) {
-    int count =
-        atomicAdd(&amp;pillar_count_histo[y_coor * grid_x_size + x_coor], 1);
-    if (count &lt; max_points_per_pillar) {
-      int ind =
-          y_coor * grid_x_size * max_points_per_pillar * num_point_feature +
-          x_coor * max_points_per_pillar * num_point_feature +
-          count * num_point_feature;
-      for (int i = 0; i &lt; num_point_feature; ++i) {
-        dev_pillar_point_feature_in_coors[ind + i] =
-            dev_points[th_i * num_point_feature + i];
-      }
-    }
-  }
-}
-
-__global__ void make_pillar_index_kernel(
-    int* dev_pillar_count_histo, int* dev_counter, int* dev_pillar_count,
-    int* dev_x_coors, int* dev_y_coors, float* dev_num_points_per_pillar,
-    int* dev_sparse_pillar_map, const int max_pillars,
-    const int max_points_per_pillar, const int grid_x_size,
-    const int num_inds_for_scan) {
-  int x = blockIdx.x;
-  int y = threadIdx.x;
-  int num_points_at_this_pillar = dev_pillar_count_histo[y * grid_x_size + x];
-  if (num_points_at_this_pillar == 0) {
-    return;
-  }
-
-  int count = atomicAdd(dev_counter, 1);
-  if (count &lt; max_pillars) {
-    atomicAdd(dev_pillar_count, 1);
-    if (num_points_at_this_pillar &gt;= max_points_per_pillar) {
-      dev_num_points_per_pillar[count] = max_points_per_pillar;
-    } else {
-      dev_num_points_per_pillar[count] = num_points_at_this_pillar;
-    }
-    dev_x_coors[count] = x;
-    dev_y_coors[count] = y;
-    dev_sparse_pillar_map[y * num_inds_for_scan + x] = 1;
-  }
-}
-
-__global__ void make_pillar_feature_kernel(
-    float* dev_pillar_point_feature_in_coors, float* dev_pillar_point_feature,
-    float* dev_pillar_coors, int* dev_x_coors, int* dev_y_coors,
-    float* dev_num_points_per_pillar, const int max_points,
-    const int num_point_feature, const int grid_x_size) {
-  int ith_pillar = blockIdx.x;
-  int num_points_at_this_pillar = dev_num_points_per_pillar[ith_pillar];
-  int ith_point = threadIdx.x;
-  if (ith_point &gt;= num_points_at_this_pillar) {
-    return;
-  }
-  int x_ind = dev_x_coors[ith_pillar];
-  int y_ind = dev_y_coors[ith_pillar];
-  int pillar_ind = ith_pillar * max_points * num_point_feature +
-                   ith_point * num_point_feature;
-  int coors_ind = y_ind * grid_x_size * max_points * num_point_feature +
-                  x_ind * max_points * num_point_feature +
-                  ith_point * num_point_feature;
-  for (int i = 0; i &lt; num_point_feature; ++i) {
-    dev_pillar_point_feature[pillar_ind + i] =
-        dev_pillar_point_feature_in_coors[coors_ind + i];
-  }
-
-  float coor_x = static_cast&lt;float&gt;(x_ind);
-  float coor_y = static_cast&lt;float&gt;(y_ind);
-  dev_pillar_coors[ith_pillar * 4 + 0] = 0;  // batch idx
-  dev_pillar_coors[ith_pillar * 4 + 1] = 0;  // z
-  dev_pillar_coors[ith_pillar * 4 + 2] = coor_y;
-  dev_pillar_coors[ith_pillar * 4 + 3] = coor_x;
-}
-
-PreprocessPointsCuda::PreprocessPointsCuda(
-    const int num_threads, const int max_num_pillars,
-    const int max_points_per_pillar, const int num_point_feature,
-    const int num_inds_for_scan, const int grid_x_size, const int grid_y_size,
-    const int grid_z_size, const float pillar_x_size, const float pillar_y_size,
-    const float pillar_z_size, const float min_x_range, const float min_y_range,
-    const float min_z_range)
-    : num_threads_(num_threads),
-      max_num_pillars_(max_num_pillars),
-      max_num_points_per_pillar_(max_points_per_pillar),
-      num_point_feature_(num_point_feature),
-      num_inds_for_scan_(num_inds_for_scan),
-      grid_x_size_(grid_x_size),
-      grid_y_size_(grid_y_size),
-      grid_z_size_(grid_z_size),
-      pillar_x_size_(pillar_x_size),
-      pillar_y_size_(pillar_y_size),
-      pillar_z_size_(pillar_z_size),
-      min_x_range_(min_x_range),
-      min_y_range_(min_y_range),
-      min_z_range_(min_z_range) {
-  GPU_CHECK(
-      cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_pillar_point_feature_in_coors_),
-                 grid_y_size_ * grid_x_size_ * max_num_points_per_pillar_ *
-                     num_point_feature_ * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_pillar_count_histo_),
-                       grid_y_size_ * grid_x_size_ * sizeof(int)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_counter_), sizeof(int)));
-  GPU_CHECK(
-      cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_pillar_count_), sizeof(int)));
-}
-
-PreprocessPointsCuda::~PreprocessPointsCuda() {
-  GPU_CHECK(cudaFree(dev_pillar_point_feature_in_coors_));
-
-  GPU_CHECK(cudaFree(dev_pillar_count_histo_));
-
-  GPU_CHECK(cudaFree(dev_counter_));
-  GPU_CHECK(cudaFree(dev_pillar_count_));
-}
-
-void PreprocessPointsCuda::DoPreprocessPointsCuda(
-    const float* dev_points, const int in_num_points, int* dev_x_coors,
-    int* dev_y_coors, float* dev_num_points_per_pillar,
-    float* dev_pillar_point_feature, float* dev_pillar_coors,
-    int* dev_sparse_pillar_map, int* host_pillar_count) {
-  GPU_CHECK(cudaMemset(dev_pillar_count_histo_, 0,
-                       grid_y_size_ * grid_x_size_ * sizeof(int)));
-  GPU_CHECK(cudaMemset(dev_counter_, 0, sizeof(int)));
-  GPU_CHECK(cudaMemset(dev_pillar_count_, 0, sizeof(int)));
-
-  int num_block = DIVUP(in_num_points, num_threads_);
-  make_pillar_histo_kernel&lt;&lt;&lt;num_block, num_threads_&gt;&gt;&gt;(
-      dev_points, dev_pillar_point_feature_in_coors_, dev_pillar_count_histo_,
-      in_num_points, max_num_points_per_pillar_, grid_x_size_, grid_y_size_,
-      grid_z_size_, min_x_range_, min_y_range_, min_z_range_, pillar_x_size_,
-      pillar_y_size_, pillar_z_size_, num_point_feature_);
-
-  make_pillar_index_kernel&lt;&lt;&lt;grid_x_size_, grid_y_size_&gt;&gt;&gt;(
-      dev_pillar_count_histo_, dev_counter_, dev_pillar_count_, dev_x_coors,
-      dev_y_coors, dev_num_points_per_pillar, dev_sparse_pillar_map,
-      max_num_pillars_, max_num_points_per_pillar_, grid_x_size_,
-      num_inds_for_scan_);
-
-  GPU_CHECK(cudaMemcpy(host_pillar_count, dev_pillar_count_, sizeof(int),
-                       cudaMemcpyDeviceToHost));
-  make_pillar_feature_kernel&lt;&lt;&lt;host_pillar_count[0],
-                               max_num_points_per_pillar_&gt;&gt;&gt;(
-      dev_pillar_point_feature_in_coors_, dev_pillar_point_feature,
-      dev_pillar_coors, dev_x_coors, dev_y_coors, dev_num_points_per_pillar,
-      max_num_points_per_pillar_, num_point_feature_, grid_x_size_);
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\preprocess_points_cuda.h" new_path="" added_lines="0" deleted_lines="128">
				<diff>@@ -1,128 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file preprocess_points_cuda.h
- * @brief GPU version of preprocess points
- * @author Kosuke Murakami
- * @date 2019/02/26
- */
-
-#pragma once
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class PreprocessPointsCuda {
- private:
-  // initializer list
-  const int num_threads_;
-  const int max_num_pillars_;
-  const int max_num_points_per_pillar_;
-  const int num_point_feature_;
-  const int num_inds_for_scan_;
-  const int grid_x_size_;
-  const int grid_y_size_;
-  const int grid_z_size_;
-  const float pillar_x_size_;
-  const float pillar_y_size_;
-  const float pillar_z_size_;
-  const float min_x_range_;
-  const float min_y_range_;
-  const float min_z_range_;
-  // end initializer list
-
-  float* dev_pillar_point_feature_in_coors_;
-  int* dev_pillar_count_histo_;
-
-  int* dev_counter_;
-  int* dev_pillar_count_;
-
- public:
-  /**
-   * @brief Constructor
-   * @param[in] num_threads Number of threads when launching cuda kernel
-   * @param[in] max_num_pillars Maximum number of pillars
-   * @param[in] max_points_per_pillar Maximum number of points per pillar
-   * @param[in] num_point_feature Number of features in a point
-   * @param[in] num_inds_for_scan Number of indexes for scan(cumsum)
-   * @param[in] grid_x_size Number of pillars in x-coordinate
-   * @param[in] grid_y_size Number of pillars in y-coordinate
-   * @param[in] grid_z_size Number of pillars in z-coordinate
-   * @param[in] pillar_x_size Size of x-dimension for a pillar
-   * @param[in] pillar_y_size Size of y-dimension for a pillar
-   * @param[in] pillar_z_size Size of z-dimension for a pillar
-   * @param[in] min_x_range Minimum x value for point cloud
-   * @param[in] min_y_range Minimum y value for point cloud
-   * @param[in] min_z_range Minimum z value for point cloud
-   * @details Captital variables never change after the compile
-   */
-  PreprocessPointsCuda(const int num_threads, const int max_num_pillars,
-                       const int max_points_per_pillar,
-                       const int num_point_feature, const int num_inds_for_scan,
-                       const int grid_x_size, const int grid_y_size,
-                       const int grid_z_size, const float pillar_x_size,
-                       const float pillar_y_size, const float pillar_z_size,
-                       const float min_x_range, const float min_y_range,
-                       const float min_z_range);
-  ~PreprocessPointsCuda();
-
-  /**
-   * @brief CUDA preprocessing for input point cloud
-   * @param[in] dev_points Point cloud array
-   * @param[in] in_num_points The number of points
-   * @param[in] dev_x_coors X-coordinate indexes for corresponding pillars
-   * @param[in] dev_y_coors Y-coordinate indexes for corresponding pillars
-   * @param[in] dev_num_points_per_pillar
-   *   Number of points in corresponding pillars
-   * @param[in] pillar_point_feature
-   *   Values of point feature in each pillar
-   * @param[in] pillar_coors Array for coors of pillars
-   * @param[in] dev_sparse_pillar_map
-   *   Grid map representation for pillar-occupancy
-   * @param[in] host_pillar_count
-   *   The number of valid pillars for an input point cloud
-   * @details Convert point cloud to pillar representation
-   */
-  void DoPreprocessPointsCuda(const float* dev_points, const int in_num_points,
-                              int* dev_x_coors, int* dev_y_coors,
-                              float* dev_num_points_per_pillar,
-                              float* dev_pillar_point_feature,
-                              float* dev_pillar_coors,
-                              int* dev_sparse_pillar_map,
-                              int* host_pillar_count);
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\scatter_cuda.cu" new_path="" added_lines="0" deleted_lines="68">
				<diff>@@ -1,68 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// headers in local files
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/scatter_cuda.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-__global__ void scatter_kernel(int *x_coors, int *y_coors, float *pfe_output,
-                               float *scattered_feature, const int grid_x_size,
-                               const int grid_y_size) {
-  int i_pillar = blockIdx.x;
-  int i_feature = threadIdx.x;
-  int x_ind = x_coors[i_pillar];
-  int y_ind = y_coors[i_pillar];
-  float feature = pfe_output[i_pillar * 64 + i_feature];
-  scattered_feature[i_feature * grid_y_size * grid_x_size +
-                    y_ind * grid_x_size + x_ind] = feature;
-}
-
-ScatterCuda::ScatterCuda(const int num_threads, const int grid_x_size,
-                         const int grid_y_size)
-    : num_threads_(num_threads),
-      grid_x_size_(grid_x_size),
-      grid_y_size_(grid_y_size) {}
-
-void ScatterCuda::DoScatterCuda(const int pillar_count, int *x_coors,
-                                int *y_coors, float *pfe_output,
-                                float *scattered_feature) {
-  scatter_kernel&lt;&lt;&lt;pillar_count, num_threads_&gt;&gt;&gt;(x_coors, y_coors, pfe_output,
-                                                 scattered_feature,
-                                                 grid_x_size_, grid_y_size_);
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\scatter_cuda.h" new_path="" added_lines="0" deleted_lines="79">
				<diff>@@ -1,79 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file scatter_cuda.h
- * @brief CUDA code for scatter operation
- * @author Kosuke Murakami
- * @date 2019/02/26
- */
-
-#pragma once
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class ScatterCuda {
- private:
-  const int num_threads_;
-  const int grid_x_size_;
-  const int grid_y_size_;
-
- public:
-  /**
-   * @brief Constructor
-   * @param[in] num_threads The number of threads to launch cuda kernel
-   * @param[in] grid_x_size Number of pillars in x-coordinate
-   * @param[in] grid_y_size Number of pillars in y-coordinate
-   * @details Captital variables never change after the compile
-   */
-  ScatterCuda(const int num_threads, const int grid_x_size,
-              const int grid_y_size);
-
-  /**
-   * @brief Call scatter cuda kernel
-   * @param[in] pillar_count The valid number of pillars
-   * @param[in] x_coors X-coordinate indexes for corresponding pillars
-   * @param[in] y_coors Y-coordinate indexes for corresponding pillars
-   * @param[in] pfe_output Output from Pillar Feature Extractor
-   * @param[out] scattered_feature Gridmap representation for pillars' feature
-   * @details Allocate pillars in gridmap based on index(coordinates)
-   * information
-   */
-  void DoScatterCuda(const int pillar_count, int* x_coors, int* y_coors,
-                     float* pfe_output, float* scattered_feature);
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\interface\base_lidar_detector.h" new_path="modules\perception\lidar\lib\interface\base_lidar_detector.h" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
+ * Copyright 2021 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\interface\base_pointcloud_preprocessor.h" new_path="modules\perception\lidar\lib\interface\base_pointcloud_preprocessor.h" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
+ * Copyright 2021 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.cc" new_path="" added_lines="0" deleted_lines="501">
				<diff>@@ -1,501 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/cnnseg/cnn_segmentation.h"
-
-#include &lt;map&gt;
-
-#include "modules/perception/lidar/lib/segmentation/cnnseg/proto/cnnseg_config.pb.h"
-
-#include "cyber/common/file.h"
-#include "cyber/common/log.h"
-#include "modules/common/adapters/adapter_gflags.h"
-#include "modules/perception/base/object_pool_types.h"
-#include "modules/perception/inference/inference_factory.h"
-#include "modules/perception/lib/config_manager/config_manager.h"
-#include "modules/perception/lidar/common/lidar_point_label.h"
-#include "modules/perception/lidar/common/lidar_timer.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/util.h"
-#include "modules/perception/lidar/lib/segmentation/ncut/ncut_segmentation.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-using apollo::cyber::common::GetAbsolutePath;
-using apollo::cyber::common::GetProtoFromFile;
-using base::AttributePointCloud;
-using base::Object;
-using base::PointF;
-
-bool CNNSegmentation::Init(const LidarDetectorInitOptions&amp; options) {
-  // get configs
-  std::string param_file;
-  std::string proto_file;
-  std::string weight_file;
-  std::string engine_file;
-
-  if (!FLAGS_lidar_model_version.empty()) {
-    sensor_name_ = FLAGS_lidar_model_version;
-  } else {
-    sensor_name_ = options.sensor_name;
-  }
-
-  CHECK(GetConfigs(&amp;param_file, &amp;proto_file, &amp;weight_file, &amp;engine_file));
-  AINFO &lt;&lt; "--    param_file: " &lt;&lt; param_file;
-  AINFO &lt;&lt; "--    proto_file: " &lt;&lt; proto_file;
-  AINFO &lt;&lt; "--    weight_file: " &lt;&lt; weight_file;
-  AINFO &lt;&lt; "--    engine_file: " &lt;&lt; engine_file;
-
-  // get cnnseg params
-  ACHECK(GetProtoFromFile(param_file, &amp;cnnseg_param_))
-      &lt;&lt; "Failed to parse CNNSegParam config file." &lt;&lt; param_file;
-  ACHECK(GetProtoFromFile(engine_file, &amp;spp_engine_config_))
-      &lt;&lt; "Failed to parse SppEngine config file." &lt;&lt; engine_file;
-
-  // init feature parameters
-  const FeatureParam&amp; feature_param = cnnseg_param_.feature_param();
-  range_ = feature_param.point_cloud_range();
-  width_ = feature_param.width();
-  height_ = feature_param.height();
-  min_height_ = feature_param.min_height();
-  max_height_ = feature_param.max_height();
-
-  // init inference model
-  const NetworkParam&amp; network_param = cnnseg_param_.network_param();
-  std::vector&lt;std::string&gt; output_names;
-  output_names.push_back(network_param.instance_pt_blob());
-  output_names.push_back(network_param.category_pt_blob());
-  output_names.push_back(network_param.confidence_pt_blob());
-  output_names.push_back(network_param.height_pt_blob());
-  output_names.push_back(network_param.heading_pt_blob());
-  output_names.push_back(network_param.class_pt_blob());
-  std::vector&lt;std::string&gt; input_names;
-  input_names.push_back(network_param.feature_blob());
-  inference_.reset(inference::CreateInferenceByName(cnnseg_param_.model_type(),
-                                                    proto_file, weight_file,
-                                                    output_names, input_names));
-  CHECK_NOTNULL(inference_.get());
-
-  gpu_id_ = cnnseg_param_.has_gpu_id() ? cnnseg_param_.gpu_id() : -1;
-  BASE_CUDA_CHECK(cudaSetDevice(gpu_id_));
-  inference_-&gt;set_gpu_id(gpu_id_);  // inference sets CPU mode when -1
-
-  std::map&lt;std::string, std::vector&lt;int&gt;&gt; input_shapes;
-  auto&amp; input_shape = input_shapes[network_param.feature_blob()];
-  input_shape = {1, 8, height_, width_};
-  if (!feature_param.use_intensity_feature()) {
-    input_shape[1] -= 2;
-  }
-  if (!feature_param.use_constant_feature()) {
-    input_shape[1] -= 2;
-  }
-  ACHECK(inference_-&gt;Init(input_shapes)) &lt;&lt; "Failed to init inference.";
-
-  // init blobs
-  instance_pt_blob_ = inference_-&gt;get_blob(network_param.instance_pt_blob());
-  CHECK_NOTNULL(instance_pt_blob_.get());
-  category_pt_blob_ = inference_-&gt;get_blob(network_param.category_pt_blob());
-  CHECK_NOTNULL(category_pt_blob_.get());
-  confidence_pt_blob_ =
-      inference_-&gt;get_blob(network_param.confidence_pt_blob());
-  CHECK_NOTNULL(confidence_pt_blob_.get());
-  height_pt_blob_ = inference_-&gt;get_blob(network_param.height_pt_blob());
-  CHECK_NOTNULL(height_pt_blob_.get());
-  feature_blob_ = inference_-&gt;get_blob(network_param.feature_blob());
-  CHECK_NOTNULL(feature_blob_.get());
-  if (cnnseg_param_.do_classification()) {
-    classify_pt_blob_ = inference_-&gt;get_blob(network_param.class_pt_blob());
-    CHECK_NOTNULL(classify_pt_blob_.get());
-  }
-  if (cnnseg_param_.do_heading()) {
-    heading_pt_blob_ = inference_-&gt;get_blob(network_param.heading_pt_blob());
-    CHECK_NOTNULL(heading_pt_blob_.get());
-  }
-
-  // init feature generator
-  feature_generator_.reset(new FeatureGenerator);
-  ACHECK(feature_generator_-&gt;Init(feature_param, feature_blob_.get()))
-      &lt;&lt; "Failed to init feature generator.";
-
-  point2grid_.reserve(kDefaultPointCloudSize);
-
-  // init cluster and background segmentation methods
-  ACHECK(InitClusterAndBackgroundSegmentation());
-
-  // secondary segmentor
-  /*if (cnnseg_param_.fill_recall_with_ncut()) {
-     secondary_segmentor.reset(new NCutSegmentation());
-     if(!secondary_segmentor-&gt;Init(SegmentationInitOptions())) {
-         AERROR&lt;&lt;"initialized secondary segmentor fails";
-         return false;
-     }
-  }*/
-  return true;
-}
-
-bool CNNSegmentation::InitClusterAndBackgroundSegmentation() {
-  // init ground detector
-  ground_detector_ = BaseGroundDetectorRegisterer::GetInstanceByName(
-      cnnseg_param_.ground_detector());
-  CHECK_NOTNULL(ground_detector_);
-  GroundDetectorInitOptions ground_detector_init_options;
-  ACHECK(ground_detector_-&gt;Init(ground_detector_init_options))
-      &lt;&lt; "Failed to init ground detection.";
-
-  // init roi filter
-  roi_filter_ =
-      BaseROIFilterRegisterer::GetInstanceByName(cnnseg_param_.roi_filter());
-  CHECK_NOTNULL(roi_filter_);
-  ROIFilterInitOptions roi_filter_init_options;
-  ACHECK(roi_filter_-&gt;Init(roi_filter_init_options))
-      &lt;&lt; "Failed to init roi filter.";
-
-  // init spp engine
-  SppParams params;
-  params.height_gap = spp_engine_config_.height_gap();
-  params.confidence_range = cnnseg_param_.confidence_range();
-
-  // init spp data
-  auto&amp; spp_data = spp_engine_.GetSppData();
-  spp_data.instance_pt_blob = instance_pt_blob_.get();
-  spp_data.category_pt_blob = category_pt_blob_.get();
-  spp_data.confidence_pt_blob = confidence_pt_blob_.get();
-
-  spp_data.objectness_threshold = cnnseg_param_.objectness_thresh();
-  spp_data.confidence_threshold = cnnseg_param_.confidence_thresh();
-  spp_data.top_z_threshold = cnnseg_param_.height_thresh();
-  spp_data.class_num = static_cast&lt;size_t&gt;(MetaType::MAX_META_TYPE);
-  if (height_pt_blob_ != nullptr) {
-    spp_data.height_pt_blob = height_pt_blob_.get();
-  }
-  if (cnnseg_param_.do_classification()) {
-    spp_data.classify_pt_blob = classify_pt_blob_.get();
-  }
-  if (cnnseg_param_.do_heading()) {
-    spp_data.heading_pt_blob = heading_pt_blob_.get();
-  }
-  spp_data.MakeReference(width_, height_, range_);
-
-  // init spp engine
-  spp_engine_.Init(width_, height_, range_, params, sensor_name_);
-
-  roi_cloud_ = base::PointFCloudPool::Instance().Get();
-  roi_world_cloud_ = base::PointDCloudPool::Instance().Get();
-
-  // init thread worker
-  worker_.Bind([&amp;]() {
-    Timer timer;
-    ROIFilterOptions roi_filter_options;
-    AINFO &lt;&lt; "before roi filter";
-    if (lidar_frame_ref_-&gt;hdmap_struct != nullptr &amp;&amp;
-        roi_filter_-&gt;Filter(roi_filter_options, lidar_frame_ref_)) {
-      roi_cloud_-&gt;CopyPointCloud(*lidar_frame_ref_-&gt;cloud,
-                                 lidar_frame_ref_-&gt;roi_indices);
-      roi_world_cloud_-&gt;CopyPointCloud(*lidar_frame_ref_-&gt;world_cloud,
-                                       lidar_frame_ref_-&gt;roi_indices);
-    } else {
-      AINFO &lt;&lt; "Fail to call roi filter, use origin cloud.";
-      lidar_frame_ref_-&gt;roi_indices.indices.resize(original_cloud_-&gt;size());
-      // we manually fill roi indices with all cloud point indices
-      std::iota(lidar_frame_ref_-&gt;roi_indices.indices.begin(),
-                lidar_frame_ref_-&gt;roi_indices.indices.end(), 0);
-      // note roi cloud's memory should be kept here
-      *roi_cloud_ = *original_cloud_;
-      *roi_world_cloud_ = *original_world_cloud_;
-    }
-    lidar_frame_ref_-&gt;cloud = roi_cloud_;
-    lidar_frame_ref_-&gt;world_cloud = roi_world_cloud_;
-
-    roi_filter_time_ = timer.toc(true);
-    AINFO &lt;&lt; "after roi filter";
-    GroundDetectorOptions ground_detector_options;
-    ground_detector_-&gt;Detect(ground_detector_options, lidar_frame_ref_);
-    if (lidar_frame_ref_-&gt;cloud != original_cloud_) {
-      lidar_frame_ref_-&gt;cloud = original_cloud_;
-    }
-    if (lidar_frame_ref_-&gt;world_cloud != original_world_cloud_) {
-      lidar_frame_ref_-&gt;world_cloud = original_world_cloud_;
-    }
-    ground_detector_time_ = timer.toc(true);
-    AINFO &lt;&lt; "Roi-filter time: " &lt;&lt; roi_filter_time_
-          &lt;&lt; "\tGround-detector time: " &lt;&lt; ground_detector_time_;
-    return true;
-  });
-  worker_.Start();
-  return true;
-}
-
-void CNNSegmentation::MapPointToGrid(
-    const std::shared_ptr&lt;AttributePointCloud&lt;PointF&gt;&gt;&amp; pc_ptr) {
-  float inv_res_x = 0.5f * static_cast&lt;float&gt;(width_) / range_;
-  // float inv_res_y = 0.5 * static_cast&lt;float&gt;(height_) / range_;
-  point2grid_.assign(pc_ptr-&gt;size(), -1);
-  int pos_x = -1;
-  int pos_y = -1;
-  for (size_t i = 0; i &lt; pc_ptr-&gt;size(); ++i) {
-    const auto&amp; pt = pc_ptr-&gt;at(i);
-    if (pt.z &lt;= min_height_ || pt.z &gt;= max_height_) {
-      continue;
-    }
-    // the coordinates of x and y are exchanged here
-    // (row &lt;-&gt; x, column &lt;-&gt; y)
-    // int pos_x = F2I(pt.y, range_, inv_res_x);  // col
-    // int pos_y = F2I(pt.x, range_, inv_res_y);  // row
-    // 2018.6.21, switch to axis rotated projection
-    GroupPc2Pixel(pt.x, pt.y, inv_res_x, range_, &amp;pos_x, &amp;pos_y);
-    if (pos_y &lt; 0 || pos_y &gt;= height_ || pos_x &lt; 0 || pos_x &gt;= width_) {
-      continue;
-    }
-    point2grid_[i] = pos_y * width_ + pos_x;
-  }
-}
-
-bool CNNSegmentation::Detect(const LidarDetectorOptions&amp; options,
-                              LidarFrame* frame) {
-  // check input
-  if (frame == nullptr) {
-    AERROR &lt;&lt; "Input null frame ptr.";
-    return false;
-  }
-  if (frame-&gt;cloud == nullptr) {
-    AERROR &lt;&lt; "Input null frame cloud.";
-    return false;
-  }
-  if (frame-&gt;world_cloud == nullptr) {
-    AERROR &lt;&lt; "Input null frame world cloud.";
-    return false;
-  }
-  if (frame-&gt;cloud-&gt;size() == 0) {
-    AERROR &lt;&lt; "Input none points.";
-    return false;
-  }
-  if (frame-&gt;cloud-&gt;size() != frame-&gt;world_cloud-&gt;size()) {
-    AERROR &lt;&lt; "Cloud size and world cloud size not consistent.";
-    return false;
-  }
-  // record input cloud and lidar frame
-  original_cloud_ = frame-&gt;cloud;
-  original_world_cloud_ = frame-&gt;world_cloud;
-  lidar_frame_ref_ = frame;
-
-  // check output
-  frame-&gt;segmented_objects.clear();
-  worker_.WakeUp();
-
-  // note we should use origninal cloud here, frame-&gt;cloud may be exchanged
-  Timer timer;
-  // map 3d points to 2d image grids
-  MapPointToGrid(original_cloud_);
-  mapping_time_ = timer.toc(true);
-
-  if (cudaSetDevice(gpu_id_) != cudaSuccess) {
-    AERROR &lt;&lt; "Failed to set device to " &lt;&lt; gpu_id_;
-    return false;
-  }
-
-  // generate features
-  feature_generator_-&gt;Generate(original_cloud_, point2grid_);
-  feature_time_ = timer.toc(true);
-
-  // model inference
-  inference_-&gt;Infer();
-  infer_time_ = timer.toc(true);
-
-  // processing clustering
-  GetObjectsFromSppEngine(&amp;frame-&gt;segmented_objects);
-
-  AINFO &lt;&lt; "CNNSEG: mapping: " &lt;&lt; mapping_time_ &lt;&lt; "\t"
-        &lt;&lt; " feature: " &lt;&lt; feature_time_ &lt;&lt; "\t"
-        &lt;&lt; " infer: " &lt;&lt; infer_time_ &lt;&lt; "\t"
-        &lt;&lt; " fg-seg: " &lt;&lt; fg_seg_time_ &lt;&lt; "\t"
-        &lt;&lt; " join: " &lt;&lt; join_time_ &lt;&lt; "\t"
-        &lt;&lt; " collect: " &lt;&lt; collect_time_;
-  return true;
-}
-
-void CNNSegmentation::GetObjectsFromSppEngine(
-    std::vector&lt;std::shared_ptr&lt;Object&gt;&gt;* objects) {
-  Timer timer;
-  spp_engine_.GetSppData().grid_indices = point2grid_.data();
-  size_t num_foreground =
-      spp_engine_.ProcessForegroundSegmentation(original_cloud_);
-  fg_seg_time_ = timer.toc(true);
-  // should sync with worker before do background segmentation
-  worker_.Join();
-  join_time_ = timer.toc(true);
-  // copy height from roi cloud to origin cloud,
-  // note ground points include other noise points
-  // filtered by ground detection post process
-  AINFO &lt;&lt; "Use origin cloud and copy height";
-  for (std::size_t i = 0; i &lt; lidar_frame_ref_-&gt;roi_indices.indices.size();
-       ++i) {
-    const int roi_id = lidar_frame_ref_-&gt;roi_indices.indices[i];
-    original_cloud_-&gt;mutable_points_height()-&gt;at(roi_id) =
-        roi_cloud_-&gt;points_height(i);
-    if (roi_cloud_-&gt;mutable_points_label()-&gt;at(i) ==
-        static_cast&lt;uint8_t&gt;(LidarPointLabel::GROUND)) {
-      original_cloud_-&gt;mutable_points_label()-&gt;at(roi_id) =
-          roi_cloud_-&gt;points_label().at(i);
-    }
-  }
-  memcpy(&amp;original_world_cloud_-&gt;mutable_points_height()-&gt;at(0),
-         &amp;original_cloud_-&gt;points_height().at(0),
-         sizeof(float) * original_cloud_-&gt;size());
-  memcpy(&amp;original_world_cloud_-&gt;mutable_points_label()-&gt;at(0),
-         &amp;original_cloud_-&gt;points_label().at(0),
-         sizeof(uint8_t) * original_cloud_-&gt;size());
-  if (cnnseg_param_.remove_ground_points()) {
-    num_foreground = spp_engine_.RemoveGroundPointsInForegroundCluster(
-        original_cloud_, lidar_frame_ref_-&gt;roi_indices,
-        lidar_frame_ref_-&gt;non_ground_indices);
-    if (num_foreground == 0) {
-      ADEBUG &lt;&lt; "No foreground segmentation output";
-    }
-  }
-
-  const auto&amp; clusters = spp_engine_.clusters();
-  objects-&gt;clear();
-  base::ObjectPool::Instance().BatchGet(clusters.size(), objects);
-  size_t valid = 0;
-
-  // prepare for valid point cloud for seconary segmentor
-  // after removing pts from primary segmentor, ground and non roi pts
-  /*CloudMask mask;
-  if (cnnseg_param_.fill_recall_with_ncut()) {
-     mask.Set(original_cloud_.size(), 0);
-     mask.AddIndicesOfIndices(lidar_frame_ref-&gt;roi_indices,
-  lidar_frame_ref-&gt;non_ground_indices, 1);
-  }*/
-
-  for (int i = 0; i &lt; static_cast&lt;int&gt;(clusters.size()); ++i) {
-    if (clusters[i]-&gt;points.size() &lt;= cnnseg_param_.min_pts_num() &amp;&amp;
-        clusters[i]-&gt;pixels.size() &lt; cnnseg_param_.min_pts_num()) {
-      continue;
-    }
-    auto&amp; cluster = clusters[i];
-    auto&amp; object = objects-&gt;at(valid);
-    object-&gt;lidar_supplement.num_points_in_roi = cluster-&gt;points_in_roi;
-    object-&gt;lidar_supplement.on_use = true;
-    object-&gt;lidar_supplement.is_background = false;
-    // ACHECK(cluster-&gt;points.size() == cluster-&gt;point_ids.size())
-    //  &lt;&lt; "cluster points size: " &lt;&lt; cluster-&gt;points.size()
-    //  &lt;&lt; "cluster point ids size: " &lt;&lt; cluster-&gt;point_ids.size();
-    object-&gt;lidar_supplement.cloud.CopyPointCloud(*original_cloud_,
-                                                  cluster-&gt;point_ids);
-    object-&gt;lidar_supplement.cloud_world.CopyPointCloud(*original_world_cloud_,
-                                                        cluster-&gt;point_ids);
-
-    // for miss detection, try to fill recall with ncut
-    /*if (cnnseg_param_.fill_recall_with_ncut()) {
-         base::PointIndices ind;
-         ind.indices = cluster-&gt;point_ids; // ? valid
-         mask.RemoveIndices(ind);
-    }*/
-
-    // for (auto&amp; id : cluster-&gt;point_ids) {
-    //  original_cloud_-&gt;points_label(id)
-    //    = static_cast&lt;uint8_t&gt;(LidarPointLabel::OBJECT);
-    //}
-    object-&gt;confidence = cluster-&gt;confidence;
-    object-&gt;id = static_cast&lt;int&gt;(valid);
-    if (cnnseg_param_.do_classification()) {
-      object-&gt;lidar_supplement.raw_probs.push_back(std::vector&lt;float&gt;(
-          static_cast&lt;int&gt;(base::ObjectType::MAX_OBJECT_TYPE), 0.f));
-      object-&gt;lidar_supplement.raw_classification_methods.push_back(Name());
-      object-&gt;lidar_supplement.raw_probs
-          .back()[static_cast&lt;int&gt;(base::ObjectType::UNKNOWN)] =
-          cluster-&gt;class_prob[static_cast&lt;int&gt;(MetaType::META_UNKNOWN)];
-      object-&gt;lidar_supplement.raw_probs
-          .back()[static_cast&lt;int&gt;(base::ObjectType::PEDESTRIAN)] =
-          cluster-&gt;class_prob[static_cast&lt;int&gt;(MetaType::META_PEDESTRIAN)];
-      object-&gt;lidar_supplement.raw_probs
-          .back()[static_cast&lt;int&gt;(base::ObjectType::BICYCLE)] =
-          cluster-&gt;class_prob[static_cast&lt;int&gt;(MetaType::META_NONMOT)];
-      object-&gt;lidar_supplement.raw_probs
-          .back()[static_cast&lt;int&gt;(base::ObjectType::VEHICLE)] =
-          cluster-&gt;class_prob[static_cast&lt;int&gt;(MetaType::META_SMALLMOT)] +
-          cluster-&gt;class_prob[static_cast&lt;int&gt;(MetaType::META_BIGMOT)];
-      // copy to type
-      object-&gt;type_probs.assign(
-          object-&gt;lidar_supplement.raw_probs.back().begin(),
-          object-&gt;lidar_supplement.raw_probs.back().end());
-      object-&gt;type = static_cast&lt;base::ObjectType&gt;(
-          std::distance(object-&gt;type_probs.begin(),
-                        std::max_element(object-&gt;type_probs.begin(),
-                                         object-&gt;type_probs.end())));
-    }
-
-    if (cnnseg_param_.do_heading()) {
-      // object-&gt;theta = cluster-&gt;yaw;
-      // object-&gt;direction[0] = cos(cluster-&gt;yaw);
-      // object-&gt;direction[1] = sin(cluster-&gt;yaw);
-      // 2018.6.21, switch to axis rotated projection
-      // should be reverted after retrain model.
-      static const float quater_pi = static_cast&lt;float&gt;(M_PI) * 0.25f;
-      object-&gt;theta = cluster-&gt;yaw - quater_pi;
-      object-&gt;direction[0] = cosf(cluster-&gt;yaw - quater_pi);
-      object-&gt;direction[1] = sinf(cluster-&gt;yaw - quater_pi);
-      object-&gt;direction[2] = 0;
-      object-&gt;lidar_supplement.is_orientation_ready = true;
-    }
-    ++valid;
-  }
-  objects-&gt;resize(valid);
-
-  // add additional object seg logic with ncut if cnnseg miss detects
-  /*if (cnnseg_param_.fill_recall_with_ncut() &amp;&amp; secondary_segmentor) {
-      mask.GetValidIndices(lidar_frame_ref_-&gt;secondary_indices);
-      secondary_segmentor-&gt;Segment(SegmentationOptions(), lidar_frame_ref_);
-  //segment based on lidar frame ref
-  }*/
-
-  collect_time_ = timer.toc(true);
-}
-
-bool CNNSegmentation::GetConfigs(std::string* param_file,
-                                 std::string* proto_file,
-                                 std::string* weight_file,
-                                 std::string* engine_file) {
-  auto config_manager = lib::ConfigManager::Instance();
-  const lib::ModelConfig* model_config = nullptr;
-  ACHECK(config_manager-&gt;GetModelConfig("CNNSegmentation", &amp;model_config))
-      &lt;&lt; "Failed to get model config: CNNSegmentation";
-
-  const std::string&amp; work_root = config_manager-&gt;work_root();
-  std::string root_path;
-  ACHECK(model_config-&gt;get_value("root_path", &amp;root_path))
-      &lt;&lt; "Failed to get value of root_path.";
-  std::string config_file;
-  config_file = GetAbsolutePath(work_root, root_path);
-  config_file = GetAbsolutePath(config_file, sensor_name_);
-  config_file = GetAbsolutePath(config_file, "cnnseg.conf");
-
-  CNNSegConfig config;
-  ACHECK(apollo::cyber::common::GetProtoFromFile(config_file, &amp;config))
-      &lt;&lt; "Failed to parse CNNSeg config file";
-  *proto_file = GetAbsolutePath(work_root, config.proto_file());
-  *weight_file = GetAbsolutePath(work_root, config.weight_file());
-  *param_file = GetAbsolutePath(work_root, config.param_file());
-  *engine_file = GetAbsolutePath(work_root, config.engine_file());
-
-  return true;
-}
-
-PERCEPTION_REGISTER_LIDARDETECTOR(CNNSegmentation);
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.h" new_path="" added_lines="0" deleted_lines="136">
				<diff>@@ -1,136 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;memory&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#include "gtest/gtest_prod.h"
-
-#include "modules/perception/lidar/lib/segmentation/cnnseg/proto/cnnseg_param.pb.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/proto/spp_engine_config.pb.h"
-
-#include "modules/perception/base/blob.h"
-#include "modules/perception/inference/inference.h"
-#include "modules/perception/inference/inference_factory.h"
-#include "modules/perception/lib/thread/thread_worker.h"
-#include "modules/perception/lidar/lib/interface/base_ground_detector.h"
-#include "modules/perception/lidar/lib/interface/base_roi_filter.h"
-#include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/feature_generator.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_engine.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class CNNSegmentation : public BaseLidarDetector {
- public:
-  CNNSegmentation() = default;
-  virtual ~CNNSegmentation() = default;
-
-  bool Init(const LidarDetectorInitOptions&amp; options =
-                LidarDetectorInitOptions()) override;
-
-  bool Detect(const LidarDetectorOptions&amp; options, LidarFrame* frame) override;
-
-  std::string Name() const override { return "CNNSegmentation"; }
-
- private:
-  bool GetConfigs(std::string* param_file, std::string* proto_file,
-                  std::string* weight_file, std::string* engine_file);
-
-  bool InitClusterAndBackgroundSegmentation();
-
-  void GetObjectsFromSppEngine(
-      std::vector&lt;std::shared_ptr&lt;base::Object&gt;&gt;* objects);
-
-  void MapPointToGrid(
-      const std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointF&gt;&gt;&amp; pc_ptr);
-
-  CNNSegParam cnnseg_param_;
-  std::shared_ptr&lt;inference::Inference&gt; inference_;
-  std::shared_ptr&lt;FeatureGenerator&gt; feature_generator_;
-
-  // output blobs
-  std::shared_ptr&lt;base::Blob&lt;float&gt;&gt; instance_pt_blob_;
-  std::shared_ptr&lt;base::Blob&lt;float&gt;&gt; category_pt_blob_;
-  std::shared_ptr&lt;base::Blob&lt;float&gt;&gt; confidence_pt_blob_;
-  std::shared_ptr&lt;base::Blob&lt;float&gt;&gt; classify_pt_blob_;
-  std::shared_ptr&lt;base::Blob&lt;float&gt;&gt; heading_pt_blob_;
-  std::shared_ptr&lt;base::Blob&lt;float&gt;&gt; height_pt_blob_;
-  // input blobs
-  std::shared_ptr&lt;base::Blob&lt;float&gt;&gt; feature_blob_;
-
-  // feature parameters
-  float range_ = 0.f;
-  int width_ = 0;
-  int height_ = 0;
-  float min_height_ = 0.f;
-  float max_height_ = 0.f;
-
-  // 1-d index in feature map of each point
-  std::vector&lt;int&gt; point2grid_;
-
-  // ground detector for background segmentation
-  BaseGroundDetector* ground_detector_;
-  // roi filter for background segmentation
-  BaseROIFilter* roi_filter_;
-
-  // thread worker
-  lib::ThreadWorker worker_;
-
-  // spp engine
-  SppEngine spp_engine_;
-  SppEngineConfig spp_engine_config_;
-
-  // reference pointer of lidar frame
-  LidarFrame* lidar_frame_ref_ = nullptr;
-  std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointF&gt;&gt; original_cloud_;
-  std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointD&gt;&gt;
-      original_world_cloud_;
-  std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointF&gt;&gt; roi_cloud_;
-  std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointD&gt;&gt; roi_world_cloud_;
-  int gpu_id_ = -1;
-
-  // time statistics
-  double mapping_time_ = 0.0;
-  double feature_time_ = 0.0;
-  double infer_time_ = 0.0;
-  double join_time_ = 0.0;
-  double fg_seg_time_ = 0.0;
-  double collect_time_ = 0.0;
-  double roi_filter_time_ = 0.0;
-  double ground_detector_time_ = 0.0;
-
-  // sensor_name
-  std::string sensor_name_;
-
-  // secondary segmentation to improve miss detection
-  // not found by neural networks !
-  std::shared_ptr&lt;BaseLidarDetector&gt; secondary_segmentor;
-
- private:
-  const int kDefaultPointCloudSize = 120000;
-
-  FRIEND_TEST(CNNSegmentationTest, cnn_segmentation_sequence_test);
-  FRIEND_TEST(CNNSegmentationTest, cnn_segmentation_test);
-};  // class CNNSegmentation
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation_test.cc" new_path="" added_lines="0" deleted_lines="202">
				<diff>@@ -1,202 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/cnnseg/cnn_segmentation.h"
-
-#include &lt;algorithm&gt;
-#include &lt;limits&gt;
-
-#include "gtest/gtest.h"
-#include "pcl/io/pcd_io.h"
-
-#include "modules/perception/common/io/io_util.h"
-#include "modules/perception/common/perception_gflags.h"
-
-namespace {
-constexpr float kFloatEpsilon = std::numeric_limits&lt;float&gt;::epsilon();
-}  // namespace
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-bool LoadPCDFile(const std::string&amp; file_path, base::PointFCloudPtr cloud_out) {
-  int ret = 0;
-  pcl::PointCloud&lt;pcl::PointXYZI&gt; org_cloud;
-  if ((ret = pcl::io::loadPCDFile(file_path, org_cloud)) &lt; 0) {
-    AERROR &lt;&lt; "Failed to load pcd file: " &lt;&lt; file_path &lt;&lt; " " &lt;&lt; ret;
-    return false;
-  }
-
-  cloud_out-&gt;resize(org_cloud.size());
-  int pid = 0;
-  for (size_t i = 0; i &lt; org_cloud.size(); ++i) {
-    if (std::isnan(org_cloud.at(i).x) || std::isnan(org_cloud.at(i).y) ||
-        std::isnan(org_cloud.at(i).z)) {
-      continue;
-    }
-    base::PointF&amp; pt = cloud_out-&gt;at(pid++);
-    pt.x = org_cloud.at(i).x;
-    pt.y = org_cloud.at(i).y;
-    pt.z = org_cloud.at(i).z;
-    pt.intensity = org_cloud.at(i).intensity;
-  }
-  cloud_out-&gt;resize(pid);
-
-  return true;
-}
-
-void PrintObjects(const std::vector&lt;base::ObjectPtr&gt;&amp; objects) {
-  AINFO &lt;&lt; "Total objects num: " &lt;&lt; objects.size();
-  int obj_id = 0;
-  for (auto object : objects) {
-    unsigned cloud_size =
-        static_cast&lt;unsigned&gt;(object-&gt;lidar_supplement.cloud.size());
-    AINFO &lt;&lt; "Point num of Segment: " &lt;&lt; cloud_size;
-    std::cout &lt;&lt; "-- Object " &lt;&lt; obj_id++ &lt;&lt; " : ";
-    std::cout &lt;&lt; object-&gt;ToString() &lt;&lt; ", type_probs: " &lt;&lt; object-&gt;type_probs[0]
-              &lt;&lt; ", " &lt;&lt; object-&gt;type_probs[1] &lt;&lt; ", " &lt;&lt; object-&gt;type_probs[2]
-              &lt;&lt; ", " &lt;&lt; object-&gt;type_probs[3] &lt;&lt; ", " &lt;&lt; object-&gt;type_probs[4]
-              &lt;&lt; ", " &lt;&lt; object-&gt;type_probs[5] &lt;&lt; std::endl;
-  }
-}
-
-TEST(CNNSegmentationTest, cnn_segmentation_sequence_test) {
-  unsetenv("CYBER_PATH");
-  unsetenv("MODULE_PATH");
-  FLAGS_work_root =
-      "/apollo/modules/perception/testdata/"
-      "lidar/lib/segmentation/cnnseg/";
-
-  auto segmentation = std::shared_ptr&lt;CNNSegmentation&gt;(new CNNSegmentation);
-  LidarDetectorOptions options;
-  EXPECT_FALSE(segmentation-&gt;Detect(options, nullptr));
-  LidarFrame frame_data;
-  EXPECT_FALSE(segmentation-&gt;Detect(options, &amp;frame_data));
-  frame_data.cloud = base::PointFCloudPool::Instance().Get();
-  frame_data.world_cloud = base::PointDCloudPool::Instance().Get();
-  EXPECT_FALSE(segmentation-&gt;Detect(options, &amp;frame_data));
-
-  EXPECT_TRUE(segmentation-&gt;Init());
-  EXPECT_TRUE(segmentation-&gt;InitClusterAndBackgroundSegmentation());
-
-  std::string pcd_path =
-      "/apollo/modules/perception/testdata/lidar/app/data/";
-  std::vector&lt;std::string&gt; pcd_file_names;
-  common::GetFileList(pcd_path, ".pcd", &amp;pcd_file_names);
-  std::string file_name;
-  std::sort(pcd_file_names.begin(), pcd_file_names.end(),
-            [](const std::string&amp; lhs, const std::string&amp; rhs) {
-              if (lhs.length() &lt; rhs.length()) {
-                return true;
-              } else if (lhs.length() == rhs.length()) {
-                return lhs &lt;= rhs;
-              } else {
-                return false;
-              }
-            });
-  for (size_t i = 0; i &lt; pcd_file_names.size(); ++i) {
-    std::shared_ptr&lt;LidarFrame&gt; frame(new LidarFrame);
-    frame-&gt;cloud = base::PointFCloudPool::Instance().Get();
-    frame-&gt;world_cloud = base::PointDCloudPool::Instance().Get();
-    if (!LoadPCDFile(pcd_file_names[i], frame-&gt;cloud)) {
-      continue;
-    }
-    frame-&gt;world_cloud-&gt;resize(frame-&gt;cloud-&gt;size());
-    EXPECT_TRUE(segmentation-&gt;Detect(options, frame.get()));
-  }
-}
-
-TEST(CNNSegmentationTest, cnn_segmentation_test) {
-  unsetenv("CYBER_PATH");
-  unsetenv("MODULE_PATH");
-  FLAGS_work_root =
-      "/apollo/modules/perception/testdata/"
-      "lidar/lib/segmentation/cnnseg/";
-
-  // load pcd data
-  auto pcl_ptr = std::shared_ptr&lt;base::PointFCloud&gt;(new base::PointFCloud);
-  std::string filename =
-      "/apollo/modules/perception/testdata/lidar/app/data/0002_00.pcd";
-  bool ret = LoadPCDFile(filename, pcl_ptr);
-  ACHECK(ret) &lt;&lt; "Failed to load " &lt;&lt; filename;
-  // load non ground indices
-  base::PointIndices non_ground_indices;
-  //  auto&amp; indices = non_ground_indices.indices;
-  //  std::ifstream in_file(
-  //      "/apollo/modules/perception/testdata/lidar/app/data/perception/lidar/files/0002_00.txt");
-  //  ASSERT_TRUE(in_file.good());
-  //  std::string line;
-  //  while (getline(in_file, line)) {
-  //    indices.push_back(std::stoi(line));
-  //  }
-
-  // test init
-  auto segmentation = std::shared_ptr&lt;CNNSegmentation&gt;(new CNNSegmentation);
-  EXPECT_TRUE(segmentation-&gt;Init());
-
-  // test segment
-  using base::ObjectType;
-  LidarDetectorOptions options;
-  LidarFrame frame_data;
-  frame_data.cloud = pcl_ptr;
-  frame_data.world_cloud = base::PointDCloudPool::Instance().Get();
-  frame_data.world_cloud-&gt;resize(pcl_ptr-&gt;size());
-  frame_data.non_ground_indices = non_ground_indices;
-  segmentation-&gt;Detect(options, &amp;frame_data);
-  std::vector&lt;base::ObjectPtr&gt;&amp; objects = frame_data.segmented_objects;
-  //  EXPECT_LE(4, objects.size());
-  EXPECT_GT(objects[0]-&gt;lidar_supplement.cloud.size(), 0);
-  EXPECT_GT(fabs(objects[3]-&gt;confidence), kFloatEpsilon);
-  // test heading
-  EXPECT_GT(fabs(objects[3]-&gt;theta), kFloatEpsilon);
-  // test classification
-  EXPECT_EQ(1, objects[1]-&gt;lidar_supplement.raw_classification_methods.size());
-  EXPECT_EQ(1, objects[1]-&gt;lidar_supplement.raw_probs.size());
-  EXPECT_EQ(static_cast&lt;int&gt;(ObjectType::MAX_OBJECT_TYPE),
-            objects[2]-&gt;lidar_supplement.raw_probs[0].size());
-  PrintObjects(objects);
-
-  segmentation-&gt;cnnseg_param_.set_do_classification(false);
-  segmentation-&gt;cnnseg_param_.set_do_heading(false);
-  segmentation-&gt;Detect(options, &amp;frame_data);
-  objects = frame_data.segmented_objects;
-  //  EXPECT_LE(4, objects.size());
-  EXPECT_GT(objects[0]-&gt;lidar_supplement.cloud.size(), 0);
-  EXPECT_GT(fabs(objects[3]-&gt;confidence), kFloatEpsilon);
-  // test no heading
-  EXPECT_LE(fabs(objects[3]-&gt;theta), kFloatEpsilon);
-  // test no classification
-  EXPECT_EQ(0, objects[1]-&gt;lidar_supplement.raw_probs.size());
-  EXPECT_EQ(0, objects[1]-&gt;lidar_supplement.raw_classification_methods.size());
-  PrintObjects(objects);
-
-  segmentation-&gt;InitClusterAndBackgroundSegmentation();
-  segmentation-&gt;Detect(options, &amp;frame_data);
-  objects = frame_data.segmented_objects;
-  //  EXPECT_EQ(4, objects.size());
-  EXPECT_GT(objects[0]-&gt;lidar_supplement.cloud.size(), 0);
-  EXPECT_GT(fabs(objects[3]-&gt;confidence), kFloatEpsilon);
-  PrintObjects(objects);
-
-  EXPECT_TRUE(segmentation-&gt;InitClusterAndBackgroundSegmentation());
-  EXPECT_TRUE(segmentation-&gt;Detect(options, &amp;frame_data));
-  objects = frame_data.segmented_objects;
-  //  EXPECT_LE(4, objects.size());
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\disjoint_set.h" new_path="" added_lines="0" deleted_lines="91">
				<diff>@@ -1,91 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-template &lt;class T&gt;
-void DisjointSetMakeSet(T* x) {
-  x-&gt;parent = x;
-  x-&gt;node_rank = 0;
-}
-
-template &lt;class T&gt;
-T* DisjointSetFindRecursive(T* x) {
-  if (x-&gt;parent != x) {
-    x-&gt;parent = DisjointSetFindRecursive(x-&gt;parent);
-  }
-  return x-&gt;parent;
-}
-
-template &lt;class T&gt;
-T* DisjointSetFindLoop(T* x) {
-  T* y = x;
-  while (y-&gt;parent != y) {
-    y = y-&gt;parent;
-  }
-
-  T* w = x;
-  T* temp = x;
-  while (w-&gt;parent != w) {
-    temp = w-&gt;parent;
-    w-&gt;parent = y;
-    w = temp;
-  }
-
-  return y;
-}
-
-template &lt;class T&gt;
-T* DisjointSetFind(T* x) {
-  T* y = x-&gt;parent;
-  if (y == x || y-&gt;parent == y) {
-    return y;
-  }
-  T* root = DisjointSetFindLoop(y-&gt;parent);
-  x-&gt;parent = root;
-  y-&gt;parent = root;
-  return root;
-}
-
-template &lt;class T&gt;
-void DisjointSetMerge(T* x, const T* y) {}
-
-template &lt;class T&gt;
-void DisjointSetUnion(T* x, T* y) {
-  x = DisjointSetFind(x);
-  y = DisjointSetFind(y);
-  if (x == y) {
-    return;
-  }
-  if (x-&gt;node_rank &lt; y-&gt;node_rank) {
-    x-&gt;parent = y;
-    // DisjointSetMerge(y, x);
-  } else if (y-&gt;node_rank &lt; x-&gt;node_rank) {
-    y-&gt;parent = x;
-    // DisjointSetMerge(x, y);
-  } else {
-    y-&gt;parent = x;
-    x-&gt;node_rank++;
-    // DisjointSetMerge(x, y);
-  }
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\feature_generator.cc" new_path="" added_lines="0" deleted_lines="173">
				<diff>@@ -1,173 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/cnnseg/feature_generator.h"
-
-#include &lt;limits&gt;
-
-#include "modules/perception/base/common.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/util.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-bool FeatureGenerator::Init(const FeatureParam&amp; feature_param,
-                            base::Blob&lt;float&gt;* out_blob) {
-  // set output feature blob
-  out_blob_ = out_blob;
-
-  // set feature parameters
-  range_ = feature_param.point_cloud_range();
-  width_ = feature_param.width();
-  height_ = feature_param.height();
-  min_height_ = feature_param.min_height();
-  max_height_ = feature_param.max_height();
-  CHECK_EQ(width_, height_)
-      &lt;&lt; "Current implementation version requires input_width == input_height.";
-  use_intensity_feature_ = feature_param.use_intensity_feature();
-  use_constant_feature_ = feature_param.use_constant_feature();
-
-  // set log lookup table
-  log_table_.resize(kMaxLogNum);
-  for (size_t i = 0; i &lt; log_table_.size(); ++i) {
-    log_table_[i] = std::log(static_cast&lt;float&gt;(1 + i));
-  }
-
-  // set output feature blob data
-  float* out_blob_data = nullptr;
-#if USE_GPU == 1
-  log_blob_.reset(
-      new base::Blob&lt;float&gt;(1, 1, 1, static_cast&lt;int&gt;(log_table_.size())));
-  float* log_table = log_blob_-&gt;mutable_gpu_data();
-  cudaMemcpy(log_table, log_table_.data(), log_table_.size() * sizeof(float),
-             cudaMemcpyHostToDevice);
-  out_blob_data = out_blob_-&gt;mutable_gpu_data();
-#else
-  out_blob_data = out_blob_-&gt;mutable_cpu_data();
-#endif
-
-  // set raw feature data
-  int channel_index = 0;
-  max_height_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
-  mean_height_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
-  count_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
-  if (use_constant_feature_) {
-    direction_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
-  }
-  if (use_intensity_feature_) {
-    top_intensity_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
-    mean_intensity_data_ =
-        out_blob_data + out_blob_-&gt;offset(0, channel_index++);
-  }
-  if (use_constant_feature_) {
-    distance_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
-  }
-  nonempty_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
-  CHECK_EQ(out_blob_-&gt;offset(0, channel_index), out_blob_-&gt;count());
-
-  // compute direction and distance features
-  if (use_constant_feature_) {
-    int map_size = height_ * width_;
-    std::vector&lt;float&gt; direction_data(map_size);
-    std::vector&lt;float&gt; distance_data(map_size);
-    for (int row = 0; row &lt; height_; ++row) {
-      for (int col = 0; col &lt; width_; ++col) {
-        int idx = row * width_ + col;
-        // * row &lt;-&gt; x, column &lt;-&gt; y
-        float center_x = Pixel2Pc(row, static_cast&lt;float&gt;(height_), range_);
-        float center_y = Pixel2Pc(col, static_cast&lt;float&gt;(width_), range_);
-        direction_data[idx] =
-            static_cast&lt;float&gt;(std::atan2(center_y, center_x) / (2.0 * kPI));
-        distance_data[idx] =
-            static_cast&lt;float&gt;(std::hypot(center_x, center_y) / 60.0 - 0.5);
-      }
-    }
-
-// memory copy direction and distance features
-#if USE_GPU == 1
-    cudaMemcpy(direction_data_, direction_data.data(),
-               direction_data.size() * sizeof(float), cudaMemcpyHostToDevice);
-    cudaMemcpy(distance_data_, distance_data.data(),
-               distance_data.size() * sizeof(float), cudaMemcpyHostToDevice);
-#else
-    memcpy(direction_data_, direction_data.data(),
-           direction_data.size() * sizeof(float));
-    memcpy(distance_data_, distance_data.data(),
-           distance_data.size() * sizeof(float));
-#endif
-  }
-  return true;
-}
-
-void FeatureGenerator::GenerateCPU(const base::PointFCloudPtr&amp; pc_ptr,
-                                   const std::vector&lt;int&gt;&amp; point2grid) {
-  // DO NOT remove this line!!!
-  // Otherwise, the gpu_data will not be updated for the later frames.
-  // It marks the head at cpu for blob.
-  out_blob_-&gt;mutable_cpu_data();
-
-  // fill initial value for feature blob
-  const int map_size = height_ * width_;
-  for (int i = 0; i &lt; map_size; ++i) {
-    max_height_data_[i] = -5.f;
-  }
-  memset(mean_height_data_, 0, map_size * sizeof(float));
-  memset(count_data_, 0, map_size * sizeof(float));
-  memset(nonempty_data_, 0, map_size * sizeof(float));
-  if (use_intensity_feature_) {
-    memset(top_intensity_data_, 0, map_size * sizeof(float));
-    memset(mean_intensity_data_, 0, map_size * sizeof(float));
-  }
-
-  // compute features
-  for (size_t i = 0; i &lt; pc_ptr-&gt;size(); ++i) {
-    int idx = point2grid[i];
-    if (idx == -1) {
-      continue;
-    }
-    const auto&amp; pt = pc_ptr-&gt;at(i);
-    float pz = pt.z;
-    float pi = pt.intensity / 255.0f;
-    if (max_height_data_[idx] &lt; pz) {
-      max_height_data_[idx] = pz;
-      if (use_intensity_feature_) {
-        top_intensity_data_[idx] = pi;
-      }
-    }
-    mean_height_data_[idx] += static_cast&lt;float&gt;(pz);
-    if (use_intensity_feature_) {
-      mean_intensity_data_[idx] += static_cast&lt;float&gt;(pi);
-    }
-    count_data_[idx] += 1.f;
-  }
-
-  for (int i = 0; i &lt; map_size; ++i) {
-    if (count_data_[i] &lt;= std::numeric_limits&lt;float&gt;::epsilon()) {
-      max_height_data_[i] = 0.f;
-    } else {
-      mean_height_data_[i] /= count_data_[i];
-      if (use_intensity_feature_) {
-        mean_intensity_data_[i] /= count_data_[i];
-      }
-      nonempty_data_[i] = 1.f;
-    }
-    count_data_[i] = LogCount(static_cast&lt;int&gt;(count_data_[i]));
-  }
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\feature_generator.cu" new_path="" added_lines="0" deleted_lines="225">
				<diff>@@ -1,225 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/cnnseg/feature_generator.h"
-
-#include "modules/perception/base/common.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-#define CUDA_KERNEL_LOOP(i, n)                                 \
-  for (int i = blockIdx.x * blockDim.x + threadIdx.x; i &lt; (n); \
-       i += blockDim.x * gridDim.x)
-
-#if __CUDA_ARCH__ &lt; 600
-__device__ double atomicAdd(double* address, double val) {
-  unsigned long long int* address_as_ull = (unsigned long long int*)address;
-  unsigned long long int old = *address_as_ull, assumed;
-  do {
-    assumed = old;
-    old = atomicCAS(address_as_ull, assumed,
-                    __double_as_longlong(val + __longlong_as_double(assumed)));
-    // Note: uses integer comparison to avoid hang in case of NaN
-    // (since NaN != NaN)
-  } while (assumed != old);
-  return __longlong_as_double(old);
-}
-#endif
-
-__device__ float atomicAdd(float* address, float val) {
-  int* address_as_ull = reinterpret_cast&lt;int*&gt;(address);
-  int old = *address_as_ull, assumed;
-  do {
-    assumed = old;
-    old = atomicCAS(address_as_ull, assumed,
-                    __float_as_int(val + __int_as_float(assumed)));
-    // Note: uses integer comparison to avoid hang in case of NaN
-    // (since NaN != NaN)
-  } while (assumed != old);
-  return __int_as_float(old);
-}
-
-__device__ double atomic_exch(double* addr, double val) {
-  unsigned long long int* m_addr = (unsigned long long int*)addr;
-  unsigned long long int old_val = 0;
-  old_val = atomicExch(m_addr, __double_as_longlong(val));
-  return __longlong_as_double(old_val);
-}
-
-__device__ float atomic_exch(float* addr, float val) {
-  return atomicExch(addr, (val));
-}
-
-// __device__ void atomicMax(double* max_height_addr, double pz) {
-//   double old_pz = *max_height_addr;
-//   do {
-//     old_pz = atomic_exch(max_height_addr, (pz));
-//     if (pz &lt; old_pz) {
-//       pz = old_pz;
-//     }
-//   } while (pz &gt; (*max_height_addr));
-// }
-
-__device__ void atomicMax(float* max_height_addr, float pz) {
-  float old_pz = *max_height_addr;
-  do {
-    old_pz = atomic_exch(max_height_addr, (pz));
-    if (pz &lt; old_pz) {
-      pz = old_pz;
-    }
-  } while (pz &gt; (*max_height_addr));
-}
-
-template &lt;typename Dtype&gt;
-__global__ void MapKernel(const int n, const base::PointF* pc,
-                          Dtype* max_height_data, Dtype* mean_height_data,
-                          Dtype* mean_intensity_data, Dtype* count_data,
-                          int* point2grid) {
-  CUDA_KERNEL_LOOP(i, n) {
-    int idx = point2grid[i];
-    if (idx == -1) {
-      continue;
-    }
-    Dtype pz = pc[i].z;
-    Dtype pi = pc[i].intensity / 255.0;
-    atomicMax(&amp;max_height_data[idx], pz);
-    atomicAdd(&amp;mean_height_data[idx], pz);
-    if (mean_intensity_data != nullptr) {
-      atomicAdd(&amp;mean_intensity_data[idx], pi);
-    }
-    atomicAdd(&amp;count_data[idx], (Dtype)1);
-  }
-}
-
-template &lt;typename Dtype&gt;
-__global__ void AverageKernel(const int n, Dtype* count_data,
-                              Dtype* max_height_data, Dtype* mean_height_data,
-                              Dtype* mean_intensity_data, Dtype* nonempty_data,
-                              Dtype* log_table, const int max_log_num) {
-  CUDA_KERNEL_LOOP(i, n) {
-    if (count_data[i] &lt; 1e-6) {
-      max_height_data[i] = 0;
-    } else {
-      mean_height_data[i] /= count_data[i];
-      if (mean_intensity_data != nullptr) {
-        mean_intensity_data[i] /= count_data[i];
-      }
-      nonempty_data[i] = Dtype(1.0);
-    }
-    int count = static_cast&lt;int&gt;(count_data[i]);
-    if (count &lt; max_log_num) {
-      count_data[i] = log_table[count];
-    } else {
-      count_data[i] = log(1.0 + count);
-    }
-  }
-}
-
-template &lt;typename Dtype&gt;
-__global__ void TopIntensityKernel(const int n, Dtype* top_intensity,
-                                   base::PointF* pc, Dtype* max_height_data,
-                                   int* point2grid) {
-  if (top_intensity == nullptr) {
-    return;
-  }
-  CUDA_KERNEL_LOOP(i, n) {
-    int idx = point2grid[i];
-    if (idx == -1) {
-      continue;
-    }
-    Dtype pz = pc[i].z;
-    Dtype pi = pc[i].intensity / 255.0;
-    if (pz == max_height_data[idx]) {
-      top_intensity[idx] = pi;
-    }
-  }
-}
-
-template &lt;typename Dtype&gt;
-__global__ void SetKernel(const int n, const Dtype alpha, Dtype* y) {
-  CUDA_KERNEL_LOOP(i, n) { y[i] = alpha; }
-}
-
-void FeatureGenerator::GenerateGPU(const base::PointFCloudPtr&amp; pc_ptr,
-                                   const std::vector&lt;int&gt;&amp; point2grid) {
-  // fill initial value for feature blob
-  int map_size = width_ * height_;
-  int block_size = (map_size + kGPUThreadSize - 1) / kGPUThreadSize;
-  SetKernel&lt;float&gt;
-      &lt;&lt;&lt;block_size, kGPUThreadSize&gt;&gt;&gt;(map_size, -5.f, max_height_data_);
-  BASE_CUDA_CHECK(cudaMemset(mean_height_data_, 0.f, sizeof(float) * map_size));
-  BASE_CUDA_CHECK(cudaMemset(count_data_, 0.f, sizeof(float) * map_size));
-  BASE_CUDA_CHECK(cudaMemset(nonempty_data_, 0.f, sizeof(float) * map_size));
-  if (use_intensity_feature_) {
-    BASE_CUDA_CHECK(
-        cudaMemset(top_intensity_data_, 0.f, sizeof(float) * map_size));
-    BASE_CUDA_CHECK(
-        cudaMemset(mean_intensity_data_, 0.f, sizeof(float) * map_size));
-  }
-
-  // copy cloud data and point2grid from CPU to GPU memory
-  size_t cloud_size = pc_ptr-&gt;size();
-  if (cloud_size &gt; pc_gpu_size_) {
-    // cloud data
-    BASE_CUDA_CHECK(cudaFree(pc_gpu_));
-    BASE_CUDA_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;pc_gpu_),
-                               cloud_size * sizeof(base::PointF)));
-    pc_gpu_size_ = cloud_size;
-    // point2grid
-    BASE_CUDA_CHECK(cudaFree(point2grid_gpu_));
-    BASE_CUDA_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;point2grid_gpu_),
-                               cloud_size * sizeof(int)));
-  }
-  BASE_CUDA_CHECK(cudaMemcpy(pc_gpu_, &amp;(pc_ptr-&gt;front()),
-                             sizeof(base::PointF) * cloud_size,
-                             cudaMemcpyHostToDevice));
-  BASE_CUDA_CHECK(cudaMemcpy(point2grid_gpu_, point2grid.data(),
-                             sizeof(int) * cloud_size, cudaMemcpyHostToDevice));
-
-  // compute features
-  // float inv_res_x = 0.5 * width_ / range_;
-  // float inv_res_y = 0.5 * height_ / range_;
-  {
-    int block_size = (cloud_size + kGPUThreadSize - 1) / kGPUThreadSize;
-    MapKernel&lt;float&gt;&lt;&lt;&lt;block_size, kGPUThreadSize&gt;&gt;&gt;(
-        cloud_size, pc_gpu_, max_height_data_, mean_height_data_,
-        mean_intensity_data_, count_data_, point2grid_gpu_);
-    TopIntensityKernel&lt;float&gt;&lt;&lt;&lt;block_size, kGPUThreadSize&gt;&gt;&gt;(
-        cloud_size, top_intensity_data_, pc_gpu_, max_height_data_,
-        point2grid_gpu_);
-  }
-  {
-    int block_size = (map_size + kGPUThreadSize - 1) / kGPUThreadSize;
-    float* log_table = log_blob_-&gt;mutable_gpu_data() + log_blob_-&gt;offset(0, 0);
-    AverageKernel&lt;float&gt;&lt;&lt;&lt;block_size, kGPUThreadSize&gt;&gt;&gt;(
-        map_size, count_data_, max_height_data_, mean_height_data_,
-        mean_intensity_data_, nonempty_data_, log_table, kMaxLogNum);
-  }
-}
-
-void FeatureGenerator::ReleaseGPUMemory() {
-  if (pc_gpu_ != nullptr) {
-    BASE_CUDA_CHECK(cudaFree(pc_gpu_));
-  }
-  if (point2grid_gpu_ != nullptr) {
-    BASE_CUDA_CHECK(cudaFree(point2grid_gpu_));
-  }
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\feature_generator.h" new_path="" added_lines="0" deleted_lines="125">
				<diff>@@ -1,125 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;memory&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#include "gtest/gtest_prod.h"
-
-#include "modules/perception/lidar/lib/segmentation/cnnseg/proto/cnnseg_param.pb.h"
-
-#include "modules/perception/base/blob.h"
-#include "modules/perception/base/point_cloud.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class FeatureGenerator {
- public:
-  FeatureGenerator() {
-#if USE_GPU == 1
-    pc_gpu_size_ = kMaxPointCloudGPUSize;
-    BASE_CUDA_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;pc_gpu_),
-                               pc_gpu_size_ * sizeof(base::PointF)));
-    BASE_CUDA_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;point2grid_gpu_),
-                               pc_gpu_size_ * sizeof(int)));
-#endif
-  }
-
-  virtual ~FeatureGenerator() {
-#if USE_GPU == 1
-    ReleaseGPUMemory();
-#endif
-  }
-
-  bool Init(const FeatureParam&amp; feature_param, base::Blob&lt;float&gt;* out_blob);
-
-  void Generate(const base::PointFCloudPtr&amp; pc_ptr,
-                const std::vector&lt;int&gt;&amp; point2grid) {
-#if USE_GPU == 1
-    GenerateGPU(pc_ptr, point2grid);
-#else
-    GenerateCPU(pc_ptr, point2grid);
-#endif
-  }
-
-  inline std::string Name() const { return "FeatureGenerator"; }
-
- private:
-#if USE_GPU == 1
-  void GenerateGPU(const base::PointFCloudPtr&amp; pc_ptr,
-                   const std::vector&lt;int&gt;&amp; point2grid);
-  void ReleaseGPUMemory();
-#endif
-  void GenerateCPU(const base::PointFCloudPtr&amp; pc_ptr,
-                   const std::vector&lt;int&gt;&amp; point2grid);
-
-  float LogCount(int count) {
-    if (count &lt; static_cast&lt;int&gt;(log_table_.size())) {
-      return log_table_[count];
-    }
-    return logf(static_cast&lt;float&gt;(1 + count));
-  }
-
-  // log table for CPU, with std::vector type
-  std::vector&lt;float&gt; log_table_;
-  // log table for GPU, with base::Blob type
-  std::shared_ptr&lt;base::Blob&lt;float&gt;&gt; log_blob_;
-  const int kMaxLogNum = 256;
-
-  // feature param
-  int width_ = 0;
-  int height_ = 0;
-  float range_ = 0.0f;
-  float min_height_ = 0.0f;
-  float max_height_ = 0.0f;
-  bool use_intensity_feature_ = false;
-  bool use_constant_feature_ = false;
-
-  // raw feature data
-  float* max_height_data_ = nullptr;
-  float* mean_height_data_ = nullptr;
-  float* count_data_ = nullptr;
-  float* direction_data_ = nullptr;
-  float* top_intensity_data_ = nullptr;
-  float* mean_intensity_data_ = nullptr;
-  float* distance_data_ = nullptr;
-  float* nonempty_data_ = nullptr;
-
-  // 1-d index in feature map of each point
-  std::vector&lt;int&gt; map_idx_;
-
-  // output feature blob
-  base::Blob&lt;float&gt;* out_blob_ = nullptr;
-
-  // param for managing gpu memory, only for cuda code
-  base::PointF* pc_gpu_ = nullptr;
-  int* point2grid_gpu_ = nullptr;
-  int pc_gpu_size_ = 0;
-  const int kMaxPointCloudGPUSize = 120000;
-  const int kGPUThreadSize = 512;
-
-  // for TEST only
-  FRIEND_TEST(FeatureGeneratorTest, basic_test);
-  friend class FeatureGeneratorTest;
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\feature_generator_test.cc" new_path="" added_lines="0" deleted_lines="222">
				<diff>@@ -1,222 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/cnnseg/feature_generator.h"
-
-#include "opencv2/opencv.hpp"
-
-#include "modules/perception/common/perception_gflags.h"
-#include "modules/perception/lidar/common/pcl_util.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/util.h"
-
-namespace apollo {
-namespace perception {
-namespace lib {
-DECLARE_string(work_root);
-}
-
-namespace lidar {
-
-class FeatureGeneratorTest : public ::testing::Test {
- public:
-  virtual void SetUp() {}
-
-  void MapPointToGrid(const base::PointFCloudPtr&amp; pc_ptr,
-                      std::vector&lt;int&gt;* point2grid, float range, size_t width,
-                      size_t height, float min_height, float max_height) {
-    float inv_res_x = 0.5 * static_cast&lt;float&gt;(width) / range;
-    float inv_res_y = 0.5 * static_cast&lt;float&gt;(height) / range;
-    point2grid-&gt;assign(pc_ptr-&gt;size(), -1);
-    for (size_t i = 0; i &lt; pc_ptr-&gt;size(); ++i) {
-      const auto&amp; pt = pc_ptr-&gt;at(i);
-      if (pt.z &lt;= min_height || pt.z &gt;= max_height) {
-        continue;
-      }
-      // the coordinates of x and y are exchanged here
-      // (row &lt;-&gt; x, column &lt;-&gt; y)
-      int pos_x = F2I(pt.y, range, inv_res_x);  // col
-      int pos_y = F2I(pt.x, range, inv_res_y);  // row
-      if (pos_y &lt; 0 || pos_y &gt;= static_cast&lt;int&gt;(height) || pos_x &lt; 0 ||
-          pos_x &gt;= static_cast&lt;int&gt;(width)) {
-        continue;
-      }
-      point2grid-&gt;at(i) = pos_y * width + pos_x;
-    }
-  }
-
-  void InitCPUBlobs(bool use_intensity_feature) {
-    base::Blob&lt;float&gt;* out_blob = generator_-&gt;out_blob_;
-    float* out_blob_data = nullptr;
-    out_blob_data = out_blob-&gt;mutable_cpu_data();
-
-    // set raw feature data
-    int channel_index = 0;
-    generator_-&gt;max_height_data_ =
-        out_blob_data + out_blob-&gt;offset(0, channel_index++);
-    generator_-&gt;mean_height_data_ =
-        out_blob_data + out_blob-&gt;offset(0, channel_index++);
-    generator_-&gt;count_data_ =
-        out_blob_data + out_blob-&gt;offset(0, channel_index++);
-    generator_-&gt;direction_data_ =
-        out_blob_data + out_blob-&gt;offset(0, channel_index++);
-    if (use_intensity_feature) {
-      generator_-&gt;top_intensity_data_ =
-          out_blob_data + out_blob-&gt;offset(0, channel_index++);
-      generator_-&gt;mean_intensity_data_ =
-          out_blob_data + out_blob-&gt;offset(0, channel_index++);
-    }
-    generator_-&gt;distance_data_ =
-        out_blob_data + out_blob-&gt;offset(0, channel_index++);
-    generator_-&gt;nonempty_data_ =
-        out_blob_data + out_blob-&gt;offset(0, channel_index++);
-    CHECK_EQ(out_blob-&gt;offset(0, channel_index), out_blob-&gt;count());
-
-    // compute direction and distance features
-    int map_size = generator_-&gt;height_ * generator_-&gt;width_;
-    std::vector&lt;float&gt; direction_data(map_size);
-    std::vector&lt;float&gt; distance_data(map_size);
-    for (int row = 0; row &lt; generator_-&gt;height_; ++row) {
-      for (int col = 0; col &lt; generator_-&gt;width_; ++col) {
-        int idx = row * generator_-&gt;width_ + col;
-        // * row &lt;-&gt; x, column &lt;-&gt; y
-        float center_x = Pixel2Pc(row, generator_-&gt;height_, generator_-&gt;range_);
-        float center_y = Pixel2Pc(col, generator_-&gt;width_, generator_-&gt;range_);
-        direction_data[idx] =
-            static_cast&lt;float&gt;(std::atan2(center_y, center_x) / (2.0 * kPI));
-        distance_data[idx] =
-            static_cast&lt;float&gt;(std::hypot(center_x, center_y) / 60.0 - 0.5);
-      }
-    }
-
-    // memory copy direction and distance features
-    memcpy(generator_-&gt;direction_data_, direction_data.data(),
-           direction_data.size() * sizeof(float));
-    memcpy(generator_-&gt;distance_data_, distance_data.data(),
-           distance_data.size() * sizeof(float));
-  }
-
- protected:
-  std::unique_ptr&lt;FeatureGenerator&gt; generator_;
-};
-
-TEST_F(FeatureGeneratorTest, basic_test) {
-  char cyber_path[100] = "CYBER_PATH=";
-  putenv(cyber_path);
-  char module_path[100] = "MODULE_PATH=";
-  putenv(module_path);
-  FLAGS_work_root =
-      "/apollo/modules/perception/testdata/"
-      "lidar/lib/segmentation/cnnseg/";
-
-  // load pcd data
-  base::PointFCloudPtr pc_ptr;
-  pc_ptr.reset(new base::PointFCloud);
-  std::string filename =
-      "/apollo/modules/perception/testdata/lidar/lib/segmentation/cnnseg/"
-      "pcd_data/3_car_1_person.pcd";
-  bool ret = LoadPCLPCD(filename, pc_ptr.get());
-  ACHECK(ret) &lt;&lt; "Failed to load " &lt;&lt; filename;
-
-  std::vector&lt;int&gt; point2grid;
-  float range = 60.f;
-  size_t width = 640;
-  size_t height = 640;
-  float min_height = -5.f;
-  float max_height = 5.f;
-  MapPointToGrid(pc_ptr, &amp;point2grid, range, width, height, min_height,
-                 max_height);
-
-  FeatureParam param;
-  param.set_point_cloud_range(range);
-  param.set_width(width);
-  param.set_height(height);
-  param.set_min_height(min_height);
-  param.set_max_height(max_height);
-  param.set_use_intensity_feature(true);
-
-  // cpu generator test
-  {
-    generator_.reset(new FeatureGenerator);
-    base::Blob&lt;float&gt; feature_blob;
-    feature_blob.Reshape(1, 8, param.height(), param.width());
-    EXPECT_TRUE(generator_-&gt;Init(param, &amp;feature_blob));
-    InitCPUBlobs(true);
-    generator_-&gt;GenerateCPU(pc_ptr, point2grid);
-    EXPECT_NE(generator_-&gt;mean_intensity_data_, nullptr);
-    EXPECT_NE(generator_-&gt;top_intensity_data_, nullptr);
-    // save feature map
-    std::ofstream ofs("cpu_top_intensity_map.txt");
-    ACHECK(ofs.is_open());
-    for (size_t i = 0; i &lt; param.height() * param.width(); ++i) {
-      ofs &lt;&lt; generator_-&gt;top_intensity_data_[i] &lt;&lt; std::endl;
-    }
-    ofs.close();
-    cv::Mat image(param.height(), param.width(), CV_32FC1,
-                  generator_-&gt;top_intensity_data_);
-    image.convertTo(image, CV_32FC3, 255.0);
-    cv::imwrite("cpu_top_intensity_map.jpg", image);
-  }
-  {
-    generator_.reset(new FeatureGenerator);
-    base::Blob&lt;float&gt; feature_blob;
-    param.set_use_intensity_feature(false);
-    feature_blob.Reshape(1, 6, param.height(), param.width());
-    EXPECT_TRUE(generator_-&gt;Init(param, &amp;feature_blob));
-    InitCPUBlobs(false);
-    generator_-&gt;GenerateCPU(pc_ptr, point2grid);
-    EXPECT_EQ(generator_-&gt;mean_intensity_data_, nullptr);
-    EXPECT_EQ(generator_-&gt;top_intensity_data_, nullptr);
-  }
-  // gpu generator test
-  {
-    generator_.reset(new FeatureGenerator);
-    base::Blob&lt;float&gt; feature_blob;
-    param.set_use_intensity_feature(true);
-    feature_blob.Reshape(1, 8, param.height(), param.width());
-    EXPECT_TRUE(generator_-&gt;Init(param, &amp;feature_blob));
-    generator_-&gt;GenerateGPU(pc_ptr, point2grid);
-    EXPECT_NE(generator_-&gt;mean_intensity_data_, nullptr);
-    EXPECT_NE(generator_-&gt;top_intensity_data_, nullptr);
-    // save feature map
-    size_t map_size = param.height() * param.width();
-    std::vector&lt;float&gt; top_intensity_data(map_size);
-    cudaMemcpy(top_intensity_data.data(), generator_-&gt;top_intensity_data_,
-               map_size * sizeof(float), cudaMemcpyDeviceToHost);
-    std::ofstream ofs("gpu_top_intensity_map.txt");
-    ACHECK(ofs.is_open());
-    for (size_t i = 0; i &lt; param.height() * param.width(); ++i) {
-      ofs &lt;&lt; top_intensity_data[i] &lt;&lt; std::endl;
-    }
-    ofs.close();
-    cv::Mat image(param.height(), param.width(), CV_32FC1,
-                  top_intensity_data.data());
-    image.convertTo(image, CV_32FC3, 255.0);
-    cv::imwrite("gpu_top_intensity_map.jpg", image);
-  }
-  {
-    generator_.reset(new FeatureGenerator);
-    base::Blob&lt;float&gt; feature_blob;
-    param.set_use_intensity_feature(false);
-    feature_blob.Reshape(1, 6, param.height(), param.width());
-    EXPECT_TRUE(generator_-&gt;Init(param, &amp;feature_blob));
-    generator_-&gt;GenerateGPU(pc_ptr, point2grid);
-    EXPECT_EQ(generator_-&gt;mean_intensity_data_, nullptr);
-    EXPECT_EQ(generator_-&gt;top_intensity_data_, nullptr);
-  }
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_cluster.h" new_path="" added_lines="0" deleted_lines="136">
				<diff>@@ -1,136 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;algorithm&gt;
-#include &lt;memory&gt;
-#include &lt;numeric&gt;
-#include &lt;vector&gt;
-
-#include "modules/perception/base/point_cloud.h"
-#include "modules/perception/lidar/common/cloud_mask.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-enum class SppClassType {
-  OTHERS = 0,
-  SMALLMOT = 1,
-  BIGMOT = 2,
-  CYCLIST = 3,
-  PEDESTRIAN = 4,
-  CONE = 5,
-  MAX_TYPE = 6,
-};
-
-struct SppPoint {
-  float x = 0.f;
-  float y = 0.f;
-  float z = 0.f;
-  float h = 0.f;
-
-  SppPoint() = default;
-
-  SppPoint(const base::PointF&amp; point, float height) {
-    x = point.x;
-    y = point.y;
-    z = point.z;
-    h = height;
-  }
-};
-
-struct SppCluster {
-  // 3d points and ids
-  std::vector&lt;SppPoint&gt; points;
-  std::vector&lt;uint32_t&gt; point_ids;
-  // 2d pixels
-  std::vector&lt;uint32_t&gt; pixels;
-  // class probabilities and type
-  std::vector&lt;float&gt; class_prob;
-  SppClassType type = SppClassType::OTHERS;
-  float yaw = 0.f;
-  float confidence = 1.f;
-  float top_z = kDefaultTopZ;
-  size_t points_in_roi = 0;
-
-  SppCluster() {
-    points.reserve(kDefaultReserveSize);
-    point_ids.reserve(kDefaultReserveSize);
-    pixels.reserve(kDefaultReserveSize);
-    class_prob.reserve(static_cast&lt;size_t&gt;(SppClassType::MAX_TYPE));
-  }
-
-  inline void AddPointSample(const base::PointF&amp; point, float height,
-                             uint32_t point_id) {
-    points.push_back(SppPoint(point, height));
-    point_ids.push_back(point_id);
-  }
-
-  void SortPoint() {
-    std::vector&lt;int&gt; indices(points.size(), 0);
-    std::iota(indices.begin(), indices.end(), 0);
-    std::sort(indices.begin(), indices.end(),
-              [&amp;](const int lhs, const int rhs) {
-                return points[lhs].z &lt; points[rhs].z;
-              });
-    std::vector&lt;SppPoint&gt; points_target(points.size());
-    std::vector&lt;uint32_t&gt; point_ids_target(points.size());
-    for (size_t i = 0; i &lt; points.size(); ++i) {
-      points_target[i] = points[indices[i]];
-      point_ids_target[i] = point_ids[indices[i]];
-    }
-    points.swap(points_target);
-    point_ids.swap(point_ids_target);
-  }
-
-  inline void clear() {
-    points.clear();
-    point_ids.clear();
-    pixels.clear();
-    class_prob.clear();
-    type = SppClassType::OTHERS;
-    yaw = 0.f;
-    confidence = 1.f;
-    top_z = kDefaultTopZ;
-    points_in_roi = 0;
-  }
-
-  inline void RemovePoints(const CloudMask&amp; mask) {
-    size_t valid = 0;
-    for (size_t i = 0; i &lt; point_ids.size(); ++i) {
-      if (mask[point_ids[i]]) {
-        if (valid != i) {
-          point_ids[valid] = point_ids[i];
-          points[valid] = points[i];
-        }
-        ++valid;
-      }
-    }
-    points.resize(valid);
-    point_ids.resize(valid);
-  }
-
-  static const size_t kDefaultReserveSize = 1000;
-  static constexpr float kDefaultTopZ = 50.f;
-};
-
-typedef std::shared_ptr&lt;SppCluster&gt; SppClusterPtr;
-typedef std::shared_ptr&lt;const SppCluster&gt; SppClusterConstPtr;
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_cluster_list.cc" new_path="" added_lines="0" deleted_lines="136">
				<diff>@@ -1,136 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_cluster_list.h"
-
-#include "modules/perception/lidar/common/lidar_log.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_pool_types.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-void SppClusterList::Init(size_t size, const std::string&amp; sensor_name) {
-  sensor_name_ = sensor_name;
-  clusters_.clear();
-  SppClusterPool::Instance(sensor_name_).BatchGet(size, &amp;clusters_);
-}
-
-void SppClusterList::resize(size_t size) {
-  if (clusters_.size() &lt; size) {
-    SppClusterPool::Instance(sensor_name_)
-        .BatchGet(size - clusters_.size(), &amp;clusters_);
-  } else {
-    clusters_.resize(size);
-  }
-}
-
-void SppClusterList::AddPointSample(size_t cluster_id,
-                                    const base::PointF&amp; point, float height,
-                                    uint32_t point_id) {
-  if (clusters_.size() &lt;= cluster_id) {
-    resize(cluster_id + 1);
-  }
-  clusters_[cluster_id]-&gt;AddPointSample(point, height, point_id);
-}
-
-void SppClusterList::Merge(SppClusterList* rhs) {
-  clusters_.reserve(clusters_.size() + rhs-&gt;clusters_.size());
-  for (size_t i = 0; i &lt; rhs-&gt;size(); ++i) {
-    clusters_.push_back((*rhs)[static_cast&lt;int&gt;(i)]);
-  }
-}
-
-size_t SppClusterList::HeightCut(float max_gap, size_t start_id) {
-  size_t size = clusters_.size();
-  size_t count = 0;
-  for (size_t i = start_id; i &lt; size; ++i) {
-    if (clusters_[i]-&gt;points.size() &gt; 0) {
-      if (ComputeHeightAndSplitCluster(i, max_gap)) {
-        ++count;
-      }
-    }
-  }
-  AINFO &lt;&lt; "Split " &lt;&lt; count &lt;&lt; " clusters in 3d";
-  return count;
-}
-
-bool SppClusterList::ComputeHeightAndSplitCluster(size_t id, float max_gap) {
-  if (id &gt;= clusters_.size()) {
-    return false;
-  }
-
-  clusters_[id]-&gt;SortPoint();
-  std::vector&lt;SppPoint&gt;&amp; points = clusters_[id]-&gt;points;
-  std::vector&lt;uint32_t&gt;&amp; indices = clusters_[id]-&gt;point_ids;
-
-  float gap = 0.f;
-  std::vector&lt;size_t&gt; split_indices(1, 0);
-  for (size_t i = 1; i &lt; points.size(); ++i) {
-    if (points[i].h &lt; 0) {
-      continue;
-    }
-    gap = points[i].z - points[i - 1].z;
-    if (gap &gt; max_gap) {
-      split_indices.push_back(i);
-    }
-  }
-  size_t split_num = split_indices.size();
-  if (split_num &gt; 0) {
-    size_t max_index = split_indices.size() - 1;
-    size_t length = points.size() - split_indices.back();
-    size_t max_length = length;
-    for (size_t i = 1; i &lt; split_indices.size(); ++i) {
-      length = split_indices[i] - split_indices[i - 1];
-      if (length &gt; max_length) {
-        max_length = length;
-        max_index = i - 1;
-      }
-    }
-    // the highest split is not stable
-    if (max_index != split_indices.size() - 1) {
-      size_t split_index = split_indices[max_index + 1];
-      points.resize(split_index);
-      indices.resize(split_index);
-      return true;
-    }
-  }
-  return false;
-}
-
-void SppClusterList::RemoveEmptyClusters() {
-  size_t current = 0;
-  for (size_t i = 0; i &lt; clusters_.size(); ++i) {
-    if (clusters_[i]-&gt;points.size() &gt; 0) {
-      if (current != i) {
-        clusters_[current] = clusters_[i];
-      }
-      ++current;
-    }
-  }
-  clusters_.resize(current);
-}
-
-void SppClusterList::EraseCluster(size_t id) {
-  if (clusters_.size() &lt;= id) {
-    return;
-  }
-  clusters_[id] = clusters_.back();
-  clusters_.resize(clusters_.size() - 1);
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_cluster_list.h" new_path="" added_lines="0" deleted_lines="99">
				<diff>@@ -1,99 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#include "cyber/common/macros.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_cluster.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_label_image.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class SppClusterList {
- public:
-  SppClusterList() { clusters_.reserve(kDefaultReserveSize); }
-  // @brief: initialize cluster list
-  // @param [in]: size
-  // @param [in]: sensor_name
-  void Init(size_t size, const std::string&amp; sensor_name = "velodyne64");
-  // @brief: reset cluster list
-  inline void Reset() { clusters_.clear(); }
-  // @brief: resize cluster list
-  // @param [in]: size
-  void resize(size_t size);
-  // @brief: add an 3d point sample
-  // @param [in]: cluster id
-  // @param [in]: 3d point
-  // @param [in]: point height above ground
-  // @param [in]: point id
-  void AddPointSample(size_t cluster_id, const base::PointF&amp; point,
-                      float height, uint32_t point_id);
-  // @brief: get clusters data
-  // @return: clusters
-  inline std::vector&lt;SppClusterPtr&gt;&amp; clusters() { return clusters_; }
-  // @brief: get clusters data, const version
-  // @return: clusters
-  inline const std::vector&lt;SppClusterPtr&gt;&amp; clusters() const {
-    return clusters_;
-  }
-  // @brief: get clusters size
-  // @return: cluster size
-  inline size_t size() const { return clusters_.size(); }
-  // @brief: get cluster pointer
-  // @return: cluster pointer
-  inline SppClusterPtr&amp; operator[](int id) { return clusters_[id]; }
-  // @brief: get cluster pointer, const version
-  // @return: cluster pointer
-  inline const SppClusterPtr&amp; operator[](int id) const { return clusters_[id]; }
-  // @brief: merge elements from another cluster list and clear it
-  // @param [in]: another cluster list
-  void Merge(SppClusterList* rhs);
-  // @brief: cut along height axis to split cluster
-  // @param [in]: max gap value in two connected component
-  // @param [in]: start cluster id
-  // @return: cut number in all clusters
-  size_t HeightCut(float max_gap, size_t start_id = 0);
-  // @brief: compute height and split clusters
-  // @param [in]: cluster id
-  // @param [in]: max gap value in two connected component
-  // @return: true if successfully split
-  bool ComputeHeightAndSplitCluster(size_t id, float max_gap);
-  // @brief: remove empty cluster from clusters
-  void RemoveEmptyClusters();
-  // @brief: remove cluster given id
-  void EraseCluster(size_t id);
-  // @brief: assign clusters from label image
-  SppClusterList&amp; operator=(const SppLabelImage&amp; rhs) {
-    clusters_ = rhs.GetClusters();
-    return *this;
-  }
-
- private:
-  static const size_t kDefaultReserveSize = 500;
-
- private:
-  std::vector&lt;SppClusterPtr&gt; clusters_;
-  std::string sensor_name_;
-  DISALLOW_COPY_AND_ASSIGN(SppClusterList);
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_cluster_list_test.cc" new_path="" added_lines="0" deleted_lines="182">
				<diff>@@ -1,182 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_cluster_list.h"
-
-#include "gtest/gtest.h"
-
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_label_image.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-TEST(SppClusterTest, spp_cluster_test) {
-  SppLabelImage image;
-  SppLabelImage&amp; const_image = image;
-  image.Init(5, 5);
-  EXPECT_EQ(image.width_, 5);
-  EXPECT_EQ(image.height_, 5);
-  /* test labels
-   * 0 0 0 0 3
-   * 0 1 0 3 3
-   * 0 1 0 0 0
-   * 0 1 0 2 0
-   * 0 0 0 2 0
-   * */
-  image.AddPixelSample(0, 1, 1);
-  image.AddPixelSample(0, 1, 2);
-  image.AddPixelSample(0, 1, 3);
-
-  image.AddPixelSample(1, 3, 3);
-  image.AddPixelSample(1, 3, 4);
-
-  image.AddPixelSample(2, 4, 0);
-  image.AddPixelSample(2, 4, 1);
-  image.AddPixelSample(2, 3, 1);
-
-  image.ProjectClusterToSppLabelImage();
-  EXPECT_EQ(image.GetClusterNum(), 3);
-  EXPECT_EQ(image.GetClusters().size(), 3);
-  EXPECT_EQ(const_image.GetClusters().size(), 3);
-  EXPECT_EQ(image.GetCluster(0)-&gt;pixels.size(), 3);
-  EXPECT_EQ(image.GetCluster(1)-&gt;pixels.size(), 2);
-  EXPECT_EQ(image.GetCluster(2)-&gt;pixels.size(), 3);
-  EXPECT_EQ(const_image.GetCluster(2)-&gt;pixels.size(), 3);
-  image.CollectClusterFromSppLabelImage();
-  EXPECT_EQ(image[1][1], 1);
-  EXPECT_EQ(const_image[1][1], 1);
-  EXPECT_NE(image.GetSppLabelImage(), nullptr);
-  EXPECT_NE(const_image.GetSppLabelImage(), nullptr);
-
-  float confidence_map[] = {0.1f, 0.1f, 0.1f, 0.1f, 0.3f, 0.1f, 0.6f,
-                            0.1f, 0.3f, 0.3f, 0.1f, 0.6f, 0.1f, 0.1f,
-                            0.1f, 0.1f, 0.6f, 0.1f, 0.2f, 0.1f, 0.1f,
-                            0.1f, 0.1f, 0.2f, 0.1f};
-
-  image.FilterClusters(confidence_map, 0.5f);
-  EXPECT_EQ(image.GetClusterNum(), 1);
-
-  float class_map[] = {
-      0.1f, 0.1f, 0.1f, 0.1f, 0.3f, 0.1f, 0.2f, 0.1f, 0.3f, 0.3f,
-      0.1f, 0.3f, 0.1f, 0.1f, 0.1f, 0.1f, 0.4f, 0.1f, 0.2f, 0.1f,
-      0.1f, 0.1f, 0.1f, 0.2f, 0.1f, 0.1f, 0.1f, 0.1f, 0.1f, 0.3f,
-      0.1f, 0.8f, 0.1f, 0.3f, 0.3f, 0.1f, 0.7f, 0.1f, 0.1f, 0.1f,
-      0.1f, 0.6f, 0.1f, 0.2f, 0.1f, 0.1f, 0.1f, 0.1f, 0.2f, 0.1f,
-  };
-  image.CalculateClusterClass(class_map, 2);
-  EXPECT_EQ(static_cast&lt;size_t&gt;(image.GetCluster(0)-&gt;type), 1);
-
-  float heading_map[] = {
-      0.1f, 0.1f, 0.1f, 0.1f, 0.3f, 0.1f, 1.0f, 0.1f, 0.3f, 0.3f,
-      0.1f, 1.0f, 0.1f, 0.1f, 0.1f, 0.1f, 1.0f, 0.1f, 0.2f, 0.1f,
-      0.1f, 0.1f, 0.1f, 0.2f, 0.1f, 0.1f, 0.1f, 0.1f, 0.1f, 0.3f,
-      0.1f, 0.0f, 0.1f, 0.3f, 0.3f, 0.1f, 0.0f, 0.1f, 0.1f, 0.1f,
-      0.1f, 0.0f, 0.1f, 0.2f, 0.1f, 0.1f, 0.1f, 0.1f, 0.2f, 0.1f,
-  };
-  image.CalculateClusterHeading(heading_map);
-  EXPECT_NEAR(image.GetCluster(0)-&gt;yaw, 0.f, 1e-9);
-
-  float top_z_map[] = {0.1f, 0.1f, 0.1f, 0.1f, 0.3f, 0.1f, 0.5f, 0.1f, 0.3f,
-                       0.3f, 0.1f, 0.6f, 0.1f, 0.1f, 0.1f, 0.1f, 0.7f, 0.1f,
-                       0.2f, 0.1f, 0.1f, 0.1f, 0.1f, 0.2f, 0.1f};
-
-  image.CalculateClusterTopZ(top_z_map);
-  EXPECT_NEAR(image.GetCluster(0)-&gt;top_z, 0.6f, 1e-4);
-
-  SppClusterList list;
-  const SppClusterList&amp; const_list = list;
-  list.Init(10);
-  EXPECT_EQ(list.size(), 10);
-  EXPECT_EQ(const_list.size(), 10);
-  EXPECT_EQ(list.clusters().size(), 10);
-  EXPECT_EQ(const_list.clusters().size(), 10);
-  list.resize(5);
-  EXPECT_EQ(list.size(), 5);
-  list.Reset();
-  EXPECT_EQ(list.size(), 0);
-  base::PointF point;
-  list.AddPointSample(0, point, 0.5f, 0);
-  list.AddPointSample(1, point, 0.5f, 1);
-  list.AddPointSample(2, point, 0.5f, 2);
-  list.AddPointSample(0, point, 0.5f, 3);
-  EXPECT_EQ(list.size(), 3);
-  EXPECT_EQ(list[0]-&gt;points.size(), 2);
-  EXPECT_EQ(list[1]-&gt;points.size(), 1);
-  EXPECT_EQ(list[2]-&gt;points.size(), 1);
-  EXPECT_EQ(const_list[0]-&gt;points.size(), 2);
-  SppClusterList list2;
-  list2.Init(2);
-  list.Merge(&amp;list2);
-  EXPECT_EQ(list.size(), 5);
-  list.RemoveEmptyClusters();
-  EXPECT_EQ(list.size(), 3);
-  list.EraseCluster(10);
-  EXPECT_EQ(list.size(), 3);
-  list.EraseCluster(0);
-  EXPECT_EQ(list[0]-&gt;points.size(), 1);
-
-  list.Reset();
-  list.resize(1);
-  point.x = 0.f;
-  point.y = 0.f;
-  point.z = -0.1f;
-  list.AddPointSample(0, point, point.z, 0);
-  point.z = 0.1f;
-  list.AddPointSample(0, point, point.z, 1);
-  point.z = 0.2f;
-  list.AddPointSample(0, point, point.z, 2);
-  point.z = 0.3f;
-  list.AddPointSample(0, point, point.z, 3);
-  point.z = 0.4f;
-  list.AddPointSample(0, point, point.z, 4);
-  point.z = 1.0f;
-  list.AddPointSample(0, point, point.z, 5);
-  point.z = 1.1f;
-  list.AddPointSample(0, point, point.z, 6);
-
-  EXPECT_EQ(list.HeightCut(0.5, 0), 1);
-  EXPECT_EQ(list[0]-&gt;points.size(), 5);
-
-  list.Reset();
-  list.resize(1);
-  point.x = 0.f;
-  point.y = 0.f;
-  point.z = 0.1f;
-  list.AddPointSample(0, point, point.z, 0);
-  point.z = 0.1f;
-  list.AddPointSample(0, point, point.z, 1);
-  point.z = 0.9f;
-  list.AddPointSample(0, point, point.z, 2);
-  point.z = 0.9f;
-  list.AddPointSample(0, point, point.z, 3);
-  point.z = 1.8f;
-  list.AddPointSample(0, point, point.z, 4);
-  point.z = 1.8f;
-  list.AddPointSample(0, point, point.z, 5);
-  point.z = 1.9f;
-  list.AddPointSample(0, point, point.z, 6);
-
-  EXPECT_EQ(list.HeightCut(0.5, 0), 0);
-  EXPECT_EQ(list[0]-&gt;points.size(), 7);
-  EXPECT_EQ(list[0]-&gt;points.size(), list[0]-&gt;point_ids.size());
-
-  list = image;
-  EXPECT_EQ(list.size(), 1);
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_engine.cc" new_path="" added_lines="0" deleted_lines="150">
				<diff>@@ -1,150 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_engine.h"
-#include "modules/perception/base/object_pool_types.h"
-#include "modules/perception/lidar/common/lidar_log.h"
-#include "modules/perception/lidar/common/lidar_timer.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-void SppEngine::Init(size_t width, size_t height, float range,
-                     const SppParams&amp; param, const std::string&amp; sensor_name) {
-  // initialize connect component detector
-  detector_2d_cc_.Init(static_cast&lt;int&gt;(height), static_cast&lt;int&gt;(width));
-  detector_2d_cc_.SetData(data_.obs_prob_data_ref, data_.offset_data,
-                          static_cast&lt;float&gt;(height) / (2.f * range),
-                          data_.objectness_threshold);
-  // initialize label image
-  labels_2d_.Init(width, height, sensor_name);
-  labels_2d_.InitRangeMask(range, param.confidence_range);
-  // set parameters of dynamic map
-  params_ = param;
-
-  // initialize feature size
-  width_ = width;
-  height_ = height;
-  range_ = range;
-  // bind worker
-  worker_.Bind([&amp;]() {
-    data_.confidence_pt_blob-&gt;cpu_data();
-    data_.classify_pt_blob-&gt;cpu_data();
-    data_.heading_pt_blob-&gt;cpu_data();
-    data_.height_pt_blob-&gt;cpu_data();
-    return true;
-  });
-  worker_.Start();
-}
-
-size_t SppEngine::ProcessConnectedComponentCluster(
-    const base::PointFCloudConstPtr point_cloud, const CloudMask&amp; mask) {
-  Timer timer;
-  data_.category_pt_blob-&gt;cpu_data();
-  data_.instance_pt_blob-&gt;cpu_data();
-  double sync_time1 = timer.toc(true);
-  worker_.WakeUp();
-  size_t num = detector_2d_cc_.Detect(&amp;labels_2d_);
-  if (num == 0) {
-    ADEBUG &lt;&lt; "No object detected";
-    // Later will decide if return this function here
-  }
-  double detect_time = timer.toc(true);
-  worker_.Join();
-  double sync_time2 = timer.toc(true);
-  // labels_2d_.FilterClusters(data.confidence_data,
-  //    data.confidence_threshold);
-  // 2018.6.21 filter use category data to reserve long range objects
-  // should be reverted after retrain model
-  labels_2d_.FilterClusters(data_.confidence_data, data_.obs_prob_data_ref[0],
-                            data_.confidence_threshold,
-                            data_.objectness_threshold);
-  double filter_time = timer.toc(true);
-  if (data_.class_prob_data != nullptr) {
-    labels_2d_.CalculateClusterClass(data_.class_prob_data, data_.class_num);
-  }
-  if (data_.heading_data != nullptr) {
-    labels_2d_.CalculateClusterHeading(data_.heading_data);
-  }
-  if (data_.z_data != nullptr) {
-    labels_2d_.CalculateClusterTopZ(data_.z_data);
-  }
-  double chz_time = timer.toc(true);
-  // 2. process 2d to 3d
-  // first sync between cluster list and label image,
-  // and they shared the same cluster pointer
-  clusters_ = labels_2d_;
-  for (size_t i = 0; i &lt; point_cloud-&gt;size(); ++i) {
-    if (mask.size() &amp;&amp; mask[static_cast&lt;int&gt;(i)] == 0) {
-      continue;
-    }
-    // out of range
-    const int id = data_.grid_indices[i];
-    if (id &lt; 0) {
-      continue;
-    }
-    const auto&amp; point = point_cloud-&gt;at(i);
-    const uint16_t&amp; label = labels_2d_[0][id];
-    if (!label) {
-      continue;
-    }
-    if (point.z &lt;=
-        labels_2d_.GetCluster(label - 1)-&gt;top_z + data_.top_z_threshold) {
-      clusters_.AddPointSample(label - 1, point, point_cloud-&gt;points_height(i),
-                               static_cast&lt;uint32_t&gt;(i));
-    }
-  }
-  double mapping_time = timer.toc(true);
-  // 5. remove empty clusters
-  clusters_.RemoveEmptyClusters();
-  double remove_time = timer.toc(true);
-
-  AINFO &lt;&lt; "SegForeground: sync1 " &lt;&lt; sync_time1 &lt;&lt; "\tdetect: " &lt;&lt; detect_time
-        &lt;&lt; "\tsync2: " &lt;&lt; sync_time2 &lt;&lt; "\tfilter: " &lt;&lt; filter_time
-        &lt;&lt; "\tchz: " &lt;&lt; chz_time &lt;&lt; "\tmapping: " &lt;&lt; mapping_time
-        &lt;&lt; "\tremove: " &lt;&lt; remove_time;
-
-  return clusters_.size();
-}
-
-size_t SppEngine::ProcessForegroundSegmentation(
-    const base::PointFCloudConstPtr point_cloud) {
-  mask_.clear();
-  ProcessConnectedComponentCluster(point_cloud, mask_);
-  AINFO &lt;&lt; "Foreground: " &lt;&lt; clusters_.size() &lt;&lt; " clusters";
-  return clusters_.size();
-}
-
-size_t SppEngine::RemoveGroundPointsInForegroundCluster(
-    const base::PointFCloudConstPtr full_point_cloud,
-    const base::PointIndices&amp; roi_indices,
-    const base::PointIndices&amp; roi_non_ground_indices) {
-  mask_.Set(full_point_cloud-&gt;size(), 0);
-  mask_.AddIndices(roi_indices);
-  mask_.RemoveIndicesOfIndices(roi_indices, roi_non_ground_indices);
-  mask_.Flip();
-  // at this time, all ground points has mask value 0
-  for (size_t i = 0; i &lt; clusters_.size(); ++i) {
-    clusters_[static_cast&lt;int&gt;(i)]-&gt;RemovePoints(mask_);
-  }
-  clusters_.RemoveEmptyClusters();
-  return clusters_.size();
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_engine.h" new_path="" added_lines="0" deleted_lines="100">
				<diff>@@ -1,100 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;string&gt;
-
-#include "Eigen/Dense"
-
-#include "modules/perception/lib/thread/thread_worker.h"
-#include "modules/perception/lidar/common/cloud_mask.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_cluster.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_cluster_list.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_seg_cc_2d.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_struct.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class SppEngine {
- public:
-  SppEngine() = default;
-  ~SppEngine() = default;
-  // @brief: initialize spp engine
-  // @param [in]: feature map width
-  // @param [in]: feature map height
-  // @param [in]: feature map range
-  // @param [in]: sensor name
-  void Init(size_t width, size_t height, float range,
-            const SppParams&amp; param = SppParams(),
-            const std::string&amp; sensor_name = "velodyne64");
-  // @brief: process foreground segmentation
-  // @param [in]: point cloud
-  // @return: size of foreground clusters
-  size_t ProcessForegroundSegmentation(
-      const base::PointFCloudConstPtr point_cloud);
-  // @brief: remove ground points in foreground cluster
-  // @param [in]: point cloud
-  // @param [in]: roi indices of point cloud
-  // @param [in]: non ground indices in roi of point cloud
-  size_t RemoveGroundPointsInForegroundCluster(
-      const base::PointFCloudConstPtr full_point_cloud,
-      const base::PointIndices&amp; roi_indices,
-      const base::PointIndices&amp; roi_non_ground_indices);
-  // @brief: get cluster list, const version
-  // @return: cluster list
-  inline const SppClusterList&amp; clusters() const { return clusters_; }
-  // @brief: get cluster list, const version
-  // @return: cluster list
-  inline SppClusterList&amp; clusters() { return clusters_; }
-  // @brief: get feature data, need to filled first
-  inline SppData&amp; GetSppData() { return data_; }
-  // @brief: get feature data, need to filled first, const version
-  inline const SppData&amp; GetSppData() const { return data_; }
-
- private:
-  // @brief: process clustering on input feature map
-  // @param [in]: point cloud
-  // @param [in]: point cloud mask
-  size_t ProcessConnectedComponentCluster(
-      const base::PointFCloudConstPtr point_cloud, const CloudMask&amp; mask);
-
- private:
-  // feature size
-  size_t width_ = 0;
-  size_t height_ = 0;
-  float range_ = 0.f;
-  // label image
-  SppLabelImage labels_2d_;
-  // clusters
-  SppClusterList clusters_;
-  // cloud mask
-  CloudMask mask_;
-  CloudMask roi_mask_;
-  // clustering method
-  SppCCDetector detector_2d_cc_;
-  // global parameters
-  SppParams params_;
-  // const spp data pointer
-  SppData data_;
-  // thread worker for sync data
-  lib::ThreadWorker worker_;
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_label_image.cc" new_path="" added_lines="0" deleted_lines="264">
				<diff>@@ -1,264 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_label_image.h"
-
-#include &lt;algorithm&gt;
-#include &lt;utility&gt;
-
-#include "modules/perception/lidar/common/lidar_log.h"
-#include "modules/perception/lidar/common/lidar_timer.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_pool_types.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-void SppLabelImage::Init(size_t width, size_t height,
-                         const std::string&amp; sensor_name) {
-  // simply release the last memory and allocate new one
-  if (labels_) {
-    common::IFree2(&amp;labels_);
-  }
-  width_ = width;
-  height_ = height;
-  sensor_name_ = sensor_name;
-  labels_ = common::IAlloc2&lt;uint16_t&gt;(static_cast&lt;int&gt;(height_),
-                                      static_cast&lt;int&gt;(width_));
-  memset(labels_[0], 0, sizeof(uint16_t) * width_ * height_);
-  clusters_.clear();
-}
-
-void SppLabelImage::InitRangeMask(float range, float boundary_distance) {
-  if (range_mask_) {
-    common::IFree2(&amp;range_mask_);
-  }
-  range_mask_ = common::IAlloc2&lt;char&gt;(static_cast&lt;int&gt;(height_),
-                                      static_cast&lt;int&gt;(width_));
-  memset(range_mask_[0], 0, sizeof(char) * width_ * height_);
-  float meter_per_pixel = range * 2.0f / static_cast&lt;float&gt;(width_);
-  size_t half_width = width_ / 2;
-  size_t half_height = height_ / 2;
-  for (size_t r = 0; r &lt; height_; ++r) {
-    for (size_t c = 0; c &lt; width_; ++c) {
-      float distance = sqrtf(
-          powf((static_cast&lt;float&gt;(r) - static_cast&lt;float&gt;(half_height)), 2.f) +
-          powf((static_cast&lt;float&gt;(c) - static_cast&lt;float&gt;(half_width)), 2.f));
-      distance *= meter_per_pixel;
-      if (distance &lt;= boundary_distance) {
-        range_mask_[r][c] = 1;
-      }
-    }
-  }
-}
-
-void SppLabelImage::CollectClusterFromSppLabelImage() {
-  size_t size = width_ * height_;
-  // find max label
-  uint16_t max_label = *(std::max_element(labels_[0], labels_[0] + size));
-  clusters_.clear();
-  SppClusterPool::Instance(sensor_name_).BatchGet(max_label, &amp;clusters_);
-  for (size_t y = 0; y &lt; height_; ++y) {
-    for (size_t x = 0; x &lt; width_; ++x) {
-      uint16_t&amp; label = labels_[y][x];
-      // label 0 is invalid, will be ignored
-      if (label) {
-        clusters_[label - 1]-&gt;pixels.push_back(
-            static_cast&lt;unsigned int&gt;(y * width_ + x));
-      }
-    }
-  }
-}
-
-void SppLabelImage::ProjectClusterToSppLabelImage() {
-  memset(labels_[0], 0, sizeof(uint16_t) * width_ * height_);
-  for (size_t n = 0; n &lt; clusters_.size(); ++n) {
-    auto&amp; cluster = clusters_[n];
-    for (auto&amp; pixel : cluster-&gt;pixels) {
-      labels_[0][pixel] = static_cast&lt;uint16_t&gt;(n + 1);
-    }
-  }
-}
-
-void SppLabelImage::FilterClusters(const float* confidence_map,
-                                   float threshold) {
-  for (auto&amp; cluster : clusters_) {
-    float sum = 0.f;
-    for (auto&amp; pixel : cluster-&gt;pixels) {
-      sum += confidence_map[pixel];
-    }
-    sum = cluster-&gt;pixels.size() &gt; 0
-              ? sum / static_cast&lt;float&gt;(cluster-&gt;pixels.size())
-              : sum;
-    cluster-&gt;confidence = sum;
-  }
-  size_t current = 0;
-  for (size_t n = 0; n &lt; clusters_.size(); ++n) {
-    if (clusters_[n]-&gt;confidence &gt;= threshold) {
-      if (current != n) {
-        clusters_[current] = clusters_[n];
-        for (auto&amp; pixel : clusters_[current]-&gt;pixels) {
-          labels_[0][pixel] = static_cast&lt;uint16_t&gt;(current + 1);
-        }
-      }
-      ++current;
-    } else {
-      for (auto&amp; pixel : clusters_[n]-&gt;pixels) {
-        labels_[0][pixel] = 0;
-      }
-    }
-  }
-  clusters_.resize(current);
-}
-
-void SppLabelImage::FilterClusters(const float* confidence_map,
-                                   const float* category_map,
-                                   float confidence_threshold,
-                                   float category_threshold) {
-  std::vector&lt;bool&gt; is_valid;
-  is_valid.reserve(clusters_.size());
-  for (auto&amp; cluster : clusters_) {
-    char mask = 1;
-    for (auto&amp; pixel : cluster-&gt;pixels) {
-      mask &amp;= range_mask_[0][pixel];
-    }
-    float sum_confidence = 0.f;
-    for (auto&amp; pixel : cluster-&gt;pixels) {
-      sum_confidence += confidence_map[pixel];
-    }
-    sum_confidence =
-        cluster-&gt;pixels.size() &gt; 0
-            ? sum_confidence / static_cast&lt;float&gt;(cluster-&gt;pixels.size())
-            : sum_confidence;
-    cluster-&gt;confidence = sum_confidence;
-    if (mask) {  // in range, use confidence estimation
-      is_valid.push_back(cluster-&gt;confidence &gt;= confidence_threshold);
-    } else {  // out of range, use category estimation
-      float sum_category = 0.f;
-      for (auto&amp; pixel : cluster-&gt;pixels) {
-        sum_category += category_map[pixel];
-      }
-      sum_category =
-          cluster-&gt;pixels.size() &gt; 0
-              ? sum_category / static_cast&lt;float&gt;(cluster-&gt;pixels.size())
-              : sum_category;
-      is_valid.push_back(sum_category &gt;= category_threshold);
-      // category is not stable, here we hack the confidence
-      cluster-&gt;confidence =
-          std::max(sum_confidence, confidence_threshold + 0.01f);
-    }
-  }
-  size_t current = 0;
-  for (size_t n = 0; n &lt; clusters_.size(); ++n) {
-    if (is_valid[n]) {
-      if (current != n) {
-        clusters_[current] = clusters_[n];
-        for (auto&amp; pixel : clusters_[current]-&gt;pixels) {
-          labels_[0][pixel] = static_cast&lt;uint16_t&gt;(current + 1);
-        }
-      }
-      ++current;
-    } else {
-      for (auto&amp; pixel : clusters_[n]-&gt;pixels) {
-        labels_[0][pixel] = 0;
-      }
-    }
-  }
-  clusters_.resize(current);
-}
-
-void SppLabelImage::CalculateClusterClass(const float* class_map,
-                                          size_t class_num) {
-  for (auto&amp; cluster : clusters_) {
-    cluster-&gt;class_prob.assign(class_num, 0.f);
-  }
-  size_t size = width_ * height_;
-  for (size_t c = 0; c &lt; class_num; ++c) {
-    const float* class_map_ptr = class_map + c * size;
-    for (auto&amp; cluster : clusters_) {
-      auto&amp; probs = cluster-&gt;class_prob;
-      for (auto&amp; pixel : cluster-&gt;pixels) {
-        probs[c] += class_map_ptr[pixel];
-      }
-    }
-  }
-  for (auto&amp; cluster : clusters_) {
-    auto&amp; probs = cluster-&gt;class_prob;
-    float sum = std::accumulate(probs.begin(), probs.end(), 0.f);
-    if (sum &gt; 1e-9) {
-      for (auto&amp; value : probs) {
-        value /= sum;
-      }
-    }
-    cluster-&gt;type = static_cast&lt;SppClassType&gt;(std::distance(
-        probs.begin(), std::max_element(probs.begin(), probs.end())));
-  }
-}
-
-void SppLabelImage::CalculateClusterHeading(const float* heading_map) {
-  const float* heading_map_x_ptr = heading_map;
-  const float* heading_map_y_ptr = heading_map + width_ * height_;
-
-  for (size_t n = 0; n &lt; clusters_.size(); ++n) {
-    float heading_x = 0.f, heading_y = 0.f;
-    for (auto pixel : clusters_[n]-&gt;pixels) {
-      heading_x += heading_map_x_ptr[pixel];
-      heading_y += heading_map_y_ptr[pixel];
-    }
-    clusters_[n]-&gt;yaw = std::atan2(heading_y, heading_x) * 0.5f;
-  }
-}
-
-void SppLabelImage::CalculateClusterTopZ(const float* top_z_map) {
-  for (auto&amp; cluster : clusters_) {
-    float sum = 0.f;
-    for (auto&amp; pixel : cluster-&gt;pixels) {
-      sum += top_z_map[pixel];
-    }
-    sum = cluster-&gt;pixels.size() &gt; 0
-              ? sum / static_cast&lt;float&gt;(cluster-&gt;pixels.size())
-              : sum;
-    cluster-&gt;top_z = sum;
-  }
-}
-
-void SppLabelImage::AddPixelSample(size_t id, uint32_t pixel) {
-  if (clusters_.size() &lt;= id) {
-    SppClusterPool::Instance(sensor_name_)
-        .BatchGet(id + 1 - clusters_.size(), &amp;clusters_);
-  }
-  clusters_[id]-&gt;pixels.push_back(pixel);
-}
-
-void SppLabelImage::ResizeClusters(size_t size) {
-  if (size &gt; clusters_.size()) {
-    SppClusterPool::Instance(sensor_name_)
-        .BatchGet(size - clusters_.size(), &amp;clusters_);
-  } else {
-    clusters_.resize(size);
-  }
-}
-
-void SppLabelImage::ResetClusters(size_t size) {
-  size_t reset_pos = std::min(clusters_.size(), size);
-  ResizeClusters(size);
-  for (size_t i = 0; i &lt; reset_pos; ++i) {
-    clusters_[i]-&gt;clear();
-  }
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_label_image.h" new_path="" added_lines="0" deleted_lines="153">
				<diff>@@ -1,153 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;memory&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#include "gtest/gtest_prod.h"
-
-#include "cyber/common/macros.h"
-#include "modules/perception/common/i_lib/core/i_alloc.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_cluster.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class SppLabelImage {
- public:
-  SppLabelImage() { clusters_.reserve(kDefaultReserveSize); }
-  ~SppLabelImage() {
-    if (labels_) {
-      common::IFree2(&amp;labels_);
-    }
-    if (range_mask_) {
-      common::IFree2(&amp;range_mask_);
-    }
-  }
-  // @brief: initialize label image
-  // @param [in]: image width
-  // @param [in]: image height
-  // @param [in]: sensor name
-  void Init(size_t width, size_t height,
-            const std::string&amp; sensor_name = "velodyne64");
-  // @brief: initialize range mask of label image
-  // @param [in]: range
-  // @param [in]: boundary distance for mask
-  void InitRangeMask(float range, float boundary_distance);
-  // @brief: transform clusters to label image
-  void CollectClusterFromSppLabelImage();
-  // @brief: transform label image to clusters
-  void ProjectClusterToSppLabelImage();
-  // @brief: filter clusters, given confidence map
-  // @param [in]: confidence_map of the same size
-  // @param [in]: confidence threshold
-  void FilterClusters(const float* confidence_map, float threshold);
-  // @brief: filter clusters, given confidence and category map
-  // @param [in]: confidence_map of the same size
-  // @param [in]: category_map of the same size
-  // @param [in]: confidence threshold
-  // @param [in]: category threshold
-  void FilterClusters(const float* confidence_map, const float* category_map,
-                      float confidence_threshold, float category_threshold);
-  // @brief: calculate class for each cluster, given class map
-  // @param [in]: class_map of the same size
-  // @param [in]: class number
-  void CalculateClusterClass(const float* class_map, size_t class_num);
-  // @brief: calculate heading (yaw) for each cluster, given heading map
-  // @param [in]: heading_map of the same size
-  void CalculateClusterHeading(const float* heading_map);
-  // @brief: calculate top_z for each cluster, given top_z map
-  // @param [in]: top_z_map of the same size
-  void CalculateClusterTopZ(const float* top_z_map);
-  // @brief: get label image
-  // @return: label image
-  uint16_t** GetSppLabelImage() { return labels_; }
-  // @brief: get label image, const version
-  // @return: const label image
-  const uint16_t* const* GetSppLabelImage() const { return labels_; }
-  // @brief: get clusters
-  // @return: clusters
-  inline std::vector&lt;SppClusterPtr&gt;&amp; GetClusters() { return clusters_; }
-  // @brief: get clusters, const version
-  // @return: const clusters
-  inline const std::vector&lt;SppClusterPtr&gt;&amp; GetClusters() const {
-    return clusters_;
-  }
-  // @brief: get label row pointer
-  // @param [in]: row id
-  // @return: row pointer
-  uint16_t* operator[](size_t id) { return labels_[id]; }
-  // @brief: get label row pointer, const version
-  // @param [in]: row id
-  // @return: row pointer
-  const uint16_t* operator[](size_t id) const { return labels_[id]; }
-  // @brief: get cluster number
-  // @return: cluster number
-  size_t GetClusterNum() const { return clusters_.size(); }
-  // @brief: get cluster given id
-  // @param [in]: cluster id
-  // @return: cluster pointer
-  SppClusterPtr GetCluster(size_t id) { return clusters_[id]; }
-  // @brief: get cluster given id, const version
-  // @param [in]: cluster id
-  // @return: cluster pointer
-  SppClusterConstPtr GetCluster(size_t id) const { return clusters_[id]; }
-  // @brief: add a pixel to labeled cluster
-  // @param [in]: label id
-  // @param [in]: pixel x
-  // @param [in]: pixel y
-  void AddPixelSample(size_t id, uint16_t x, uint16_t y) {
-    return AddPixelSample(id, y * static_cast&lt;uint32_t&gt;(width_) + x);
-  }
-  // @brief: add a pixel to labeled cluster
-  // @param [in]: label id
-  // @param [in]: pixel id
-  void AddPixelSample(size_t id, uint32_t pixel);
-  // @brief: clear clusters
-  inline void ClearClusters() { clusters_.clear(); }
-  // @brief: resize clusters
-  // @param [in]: target cluster size
-  void ResizeClusters(size_t size);
-  // @brief: reset clusters
-  // @param [in]: target cluster size
-  void ResetClusters(size_t size);
-
- private:
-  // note the correspondence between label and cluster id is
-  // label - 1 == cluster id, label zero is reserved for background
-  uint16_t** labels_ = nullptr;
-  size_t width_ = 0;
-  size_t height_ = 0;
-  char** range_mask_ = nullptr;
-  std::vector&lt;SppClusterPtr&gt; clusters_;
-  std::string sensor_name_;
-
- private:
-  static const size_t kDefaultReserveSize = 500;
-
-  FRIEND_TEST(SppClusterTest, spp_cluster_test);
-  DISALLOW_COPY_AND_ASSIGN(SppLabelImage);
-};
-
-typedef std::shared_ptr&lt;SppLabelImage&gt; SppLabelImagePtr;
-typedef std::shared_ptr&lt;const SppLabelImage&gt; SppLabelImageConstPtr;
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_pool_types.cc" new_path="" added_lines="0" deleted_lines="33">
				<diff>@@ -1,33 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_pool_types.h"
-#include "modules/perception/lidar/common/lidar_log.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-// @brief call pool instance once to initialize memory
-__attribute__((constructor)) void SppPoolInitialize() {
-  SppClusterPool::Instance("velodyne16");
-  SppClusterPool::Instance("velodyne64");
-  SppClusterPool::Instance("velodyne128");
-  AINFO &lt;&lt; "Initialize spp cluster pool.";
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_pool_types.h" new_path="" added_lines="0" deleted_lines="39">
				<diff>@@ -1,39 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include "modules/perception/base/light_object_pool.h"
-#include "modules/perception/base/object_pool_types.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_cluster.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-struct SppClusterInitializer {
-  void operator()(SppCluster* cluster) const { cluster-&gt;clear(); }
-};
-
-static const size_t kSppClusterPoolSize = 1000;
-
-typedef base::LightObjectPool&lt;SppCluster, kSppClusterPoolSize,
-                              SppClusterInitializer,
-                              base::SensorType::VELODYNE_64&gt;
-    SppClusterPool;
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_seg_cc_2d.cc" new_path="" added_lines="0" deleted_lines="238">
				<diff>@@ -1,238 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include &lt;algorithm&gt;
-
-#include "modules/perception/lidar/common/lidar_log.h"
-#include "modules/perception/lidar/common/lidar_timer.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_seg_cc_2d.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-void SppCCDetector::SetData(const float* const* prob_map,
-                            const float* offset_map, float scale,
-                            float objectness_threshold) {
-  prob_map_ = prob_map;
-  offset_map_ = offset_map;
-  scale_ = scale;
-  objectness_threshold_ = objectness_threshold;
-  worker_.Bind(std::bind(&amp;SppCCDetector::CleanNodes, this));
-  worker_.Start();
-}
-
-bool SppCCDetector::BuildNodes(int start_row_index, int end_row_index) {
-  const float* offset_row_ptr = offset_map_ + start_row_index * cols_;
-  const float* offset_col_ptr = offset_map_ + (rows_ + start_row_index) * cols_;
-  const float* prob_map_ptr = prob_map_[0] + start_row_index * cols_;
-  Node* node_ptr = nodes_[0] + start_row_index * cols_;
-  for (int row = start_row_index; row &lt; end_row_index; ++row) {
-    for (int col = 0; col &lt; cols_; ++col) {
-      node_ptr-&gt;set_is_object(*prob_map_ptr++ &gt;= objectness_threshold_);
-      int center_row = static_cast&lt;int&gt;(*offset_row_ptr++ * scale_ +
-                                        static_cast&lt;float&gt;(row) + 0.5f);
-      int center_col = static_cast&lt;int&gt;(*offset_col_ptr++ * scale_ +
-                                        static_cast&lt;float&gt;(col) + 0.5f);
-      center_row = std::max(0, std::min(rows_ - 1, center_row));
-      center_col = std::max(0, std::min(cols_ - 1, center_col));
-      (node_ptr++)-&gt;center_node = center_row * cols_ + center_col;
-    }
-  }
-  return true;
-}
-
-bool SppCCDetector::CleanNodes() {
-  memset(nodes_[0], 0, sizeof(Node) * rows_ * cols_);
-  uint32_t node_idx = 0;
-  for (int row = 0; row &lt; rows_; ++row) {
-    for (int col = 0; col &lt; cols_; ++col) {
-      nodes_[row][col].parent = node_idx++;
-    }
-  }
-  return true;
-}
-
-size_t SppCCDetector::Detect(SppLabelImage* labels) {
-  Timer timer;
-  if (!first_process_) {
-    worker_.Join();  // sync for cleaning nodes
-  }
-  first_process_ = false;
-  BuildNodes(0, rows_);
-  double init_time = timer.toc(true);
-
-  double sync_time = timer.toc(true);
-
-  TraverseNodes();
-  double traverse_time = timer.toc(true);
-
-  UnionNodes();
-  double union_time = timer.toc(true);
-
-  size_t num = ToLabelMap(labels);
-  worker_.WakeUp();  // for next use
-  double collect_time = timer.toc(true);
-
-  AINFO &lt;&lt; "SppSegCC2D: init: " &lt;&lt; init_time &lt;&lt; "\tsync: " &lt;&lt; sync_time
-        &lt;&lt; "\ttraverse: " &lt;&lt; traverse_time &lt;&lt; "\tunion: " &lt;&lt; union_time
-        &lt;&lt; "\tcollect: " &lt;&lt; collect_time &lt;&lt; "\t#obj: " &lt;&lt; num;
-
-  return num;
-}
-
-void SppCCDetector::TraverseNodes() {
-  for (int row = 0; row &lt; rows_; row++) {
-    for (int col = 0; col &lt; cols_; col++) {
-      Node&amp; node = nodes_[row][col];
-      if (node.is_object() &amp;&amp; node.get_traversed() == 0) {
-        Traverse(&amp;node);
-      }
-    }
-  }
-}
-
-void SppCCDetector::UnionNodes() {
-  for (int row = 0; row &lt; rows_; ++row) {
-    for (int col = 0; col &lt; cols_; ++col) {
-      Node* node = &amp;nodes_[row][col];
-      if (!node-&gt;is_center()) {
-        continue;
-      }
-      Node* node_neighbor = nullptr;
-      // right
-      if (col &lt; cols_ - 1) {
-        node_neighbor = &amp;nodes_[row][col + 1];
-        if (node_neighbor-&gt;is_center()) {
-          DisjointSetUnion(node, node_neighbor);
-        }
-      }
-      // down
-      if (row &lt; rows_ - 1) {
-        node_neighbor = &amp;nodes_[row + 1][col];
-        if (node_neighbor-&gt;is_center()) {
-          DisjointSetUnion(node, node_neighbor);
-        }
-      }
-      // right down
-      if (row &lt; rows_ - 1 &amp;&amp; col &lt; cols_ - 1) {
-        node_neighbor = &amp;nodes_[row + 1][col + 1];
-        if (node_neighbor-&gt;is_center()) {
-          DisjointSetUnion(node, node_neighbor);
-        }
-      }
-      // left down
-      if (row &lt; rows_ - 1 &amp;&amp; col &gt; 0) {
-        node_neighbor = &amp;nodes_[row + 1][col - 1];
-        if (node_neighbor-&gt;is_center()) {
-          DisjointSetUnion(node, node_neighbor);
-        }
-      }
-    }
-  }
-}
-
-size_t SppCCDetector::ToLabelMap(SppLabelImage* labels) {
-  uint16_t id = 0;
-  uint32_t pixel_id = 0;
-  labels-&gt;ResetClusters(kDefaultReserveSize);
-  for (int row = 0; row &lt; rows_; ++row) {
-    for (int col = 0; col &lt; cols_; ++col, ++pixel_id) {
-      Node* node = &amp;nodes_[row][col];
-      if (!node-&gt;is_object()) {
-        (*labels)[row][col] = 0;
-        continue;
-      }
-      Node* root = DisjointSetFind(node);
-      // note label in label image started from 1,
-      // zero is reserved from non-object
-      if (!root-&gt;id) {
-        root-&gt;id = ++id;
-      }
-      (*labels)[row][col] = root-&gt;id;
-      labels-&gt;AddPixelSample(root-&gt;id - 1, pixel_id);
-    }
-  }
-  labels-&gt;ResizeClusters(id);
-  return id;
-}
-
-void SppCCDetector::Traverse(SppCCDetector::Node* x) {
-  std::vector&lt;SppCCDetector::Node*&gt; p;
-  p.clear();
-  while (x-&gt;get_traversed() == 0) {
-    p.push_back(x);
-    x-&gt;set_traversed(2);
-    x = nodes_[0] + x-&gt;center_node;
-  }
-  if (x-&gt;get_traversed() == 2) {
-    for (int i = static_cast&lt;int&gt;(p.size()) - 1; i &gt;= 0 &amp;&amp; p[i] != x; i--) {
-      p[i]-&gt;set_is_center(true);
-    }
-    x-&gt;set_is_center(true);
-  }
-  for (size_t i = 0; i &lt; p.size(); i++) {
-    Node* y = p[i];
-    y-&gt;set_traversed(1);
-    y-&gt;parent = x-&gt;parent;
-  }
-}
-
-SppCCDetector::Node* SppCCDetector::DisjointSetFindLoop(Node* x) {
-  Node* root = x;
-  while (nodes_[0] + root-&gt;parent != root) {
-    root = nodes_[0] + root-&gt;parent;
-  }
-  Node* w = x;
-  while (nodes_[0] + w-&gt;parent != w) {
-    Node* temp = nodes_[0] + w-&gt;parent;
-    w-&gt;parent = root-&gt;parent;
-    w = temp;
-  }
-  return root;
-}
-
-SppCCDetector::Node* SppCCDetector::DisjointSetFind(Node* x) {
-  Node* y = nodes_[0] + x-&gt;parent;
-  if (y == x || nodes_[0] + y-&gt;parent == y) {
-    return y;
-  }
-  Node* root = DisjointSetFindLoop(nodes_[0] + y-&gt;parent);
-  x-&gt;parent = root-&gt;parent;
-  y-&gt;parent = root-&gt;parent;
-  return root;
-}
-
-void SppCCDetector::DisjointSetUnion(Node* x, Node* y) {
-  x = DisjointSetFind(x);
-  y = DisjointSetFind(y);
-  if (x == y) {
-    return;
-  }
-  uint16_t x_node_rank = x-&gt;get_node_rank();
-  uint16_t y_node_rank = y-&gt;get_node_rank();
-  if (x_node_rank &lt; y_node_rank) {
-    x-&gt;parent = y-&gt;parent;
-  } else if (y_node_rank &lt; x_node_rank) {
-    y-&gt;parent = x-&gt;parent;
-  } else {
-    y-&gt;parent = x-&gt;parent;
-    x-&gt;set_node_rank(static_cast&lt;uint16_t&gt;(x_node_rank + 1));
-  }
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_seg_cc_2d.h" new_path="" added_lines="0" deleted_lines="153">
				<diff>@@ -1,153 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;vector&gt;
-
-#include "modules/perception/common/i_lib/core/i_alloc.h"
-#include "modules/perception/lib/thread/thread_worker.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_label_image.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class SppCCDetector {
- public:
-  SppCCDetector() = default;
-
-  ~SppCCDetector() {
-    if (nodes_ != nullptr) {
-      common::IFree2(&amp;nodes_);
-    }
-  }
-  // @brief: initialize detector
-  // @param [in]: rows of feature map
-  // @param [in]: cols of feature map
-  void Init(int rows, int cols) {
-    if (rows_ * cols_ != rows * cols) {
-      if (nodes_ != nullptr) {
-        common::IFree2(&amp;nodes_);
-      }
-      nodes_ = common::IAlloc2&lt;Node&gt;(rows, cols);
-      rows_ = static_cast&lt;int&gt;(rows);
-      cols_ = static_cast&lt;int&gt;(cols);
-    }
-    CleanNodes();
-  }
-  // @brief: set data for clusterin
-  // @param [in]: probability map
-  // @param [in]: center offset map
-  // @param [in]: scale of offset map
-  // @param [in]: objectness threshold
-  void SetData(const float* const* prob_map, const float* offset_map,
-               float scale, float objectness_threshold);
-  // @brief: detect clusters
-  // @param [out]: label image
-  // @return: label number
-  size_t Detect(SppLabelImage* labels);
-
- private:
-  // @brief: build node matrix given start row index and end row index
-  // @param [in]: start row index, inclusive
-  // @param [in]: end row index, exclusive
-  // @param [out]: state of build nodes
-  bool BuildNodes(int start_row_index, int end_row_index);
-  // @brief: traverse node matrix
-  void TraverseNodes();
-  // @brief: union adjacent nodes
-  void UnionNodes();
-  // @brief: collect clusters to label map
-  size_t ToLabelMap(SppLabelImage* labels);
-  // @brief: clean node matrix
-  bool CleanNodes();
-
- private:
-  struct Node {
-    uint32_t center_node = 0;
-    uint32_t parent = 0;
-    uint16_t id = 0;
-    // Note, we compress node_rank, traversed, is_center and is_object
-    // in one 16bits variable, the arrangemant is as following
-    // |is_center(1bit)|is_object(1bit)|traversed(3bit)|node_rank(11bit)|
-    uint16_t status = 0;
-
-    inline uint16_t get_node_rank() { return status &amp; 2047; }
-    inline void set_node_rank(uint16_t node_rank) {
-      status &amp;= 63488;
-      status |= node_rank;
-    }
-    inline uint16_t get_traversed() {
-      uint16_t pattern = 14336;
-      return static_cast&lt;uint16_t&gt;((status &amp; pattern) &gt;&gt; 11);
-    }
-    inline void set_traversed(uint16_t traversed) {
-      status &amp;= 51199;
-      uint16_t pattern = 7;
-      status |= static_cast&lt;uint16_t&gt;((traversed &amp; pattern) &lt;&lt; 11);
-    }
-    inline bool is_center() { return static_cast&lt;bool&gt;(status &amp; 32768); }
-    inline void set_is_center(bool is_center) {
-      if (is_center) {
-        status |= 32768;
-      } else {
-        status &amp;= 32767;
-      }
-    }
-    inline bool is_object() { return static_cast&lt;bool&gt;(status &amp; 16384); }
-    inline void set_is_object(bool is_object) {
-      if (is_object) {
-        status |= 16384;  // 2^14
-      } else {
-        status &amp;= 49151;  // 65535 - 2^14
-      }
-    }
-  };
-  // @brief: tranverse a node
-  // @param [in]: input node
-  void Traverse(Node* x);
-  // @brief: find root of input node and compress path
-  // @param [in]: input node
-  // @return: root node
-  Node* DisjointSetFindLoop(Node* x);
-  // @brief: find root of input node
-  // @param [in]: input node
-  // @return: root node
-  Node* DisjointSetFind(Node* x);
-  // @brief: union of two sets
-  // @param [in]: input two nodes
-  void DisjointSetUnion(Node* x, Node* y);
-
- private:
-  int rows_ = 0;
-  int cols_ = 0;
-  Node** nodes_ = nullptr;
-
-  const float* const* prob_map_ = nullptr;
-  const float* offset_map_ = nullptr;
-  float scale_ = 0.f;
-  float objectness_threshold_ = 0.f;
-
-  lib::ThreadWorker worker_;
-  bool first_process_ = true;
-
- private:
-  static const size_t kDefaultReserveSize = 500;
-};  // class SppCCDetector
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_struct.cc" new_path="" added_lines="0" deleted_lines="57">
				<diff>@@ -1,57 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_struct.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-void SppData::MakeReference(size_t width, size_t height, float range) {
-  obs_prob_data = category_pt_blob-&gt;mutable_cpu_data();
-  offset_data = instance_pt_blob-&gt;mutable_cpu_data();
-  confidence_data = confidence_pt_blob-&gt;mutable_cpu_data();
-  if (height_pt_blob != nullptr) {
-    z_data = height_pt_blob-&gt;mutable_cpu_data();
-  }
-  if (classify_pt_blob != nullptr) {
-    class_prob_data = classify_pt_blob-&gt;mutable_cpu_data();
-  }
-  if (heading_pt_blob != nullptr) {
-    heading_data = heading_pt_blob-&gt;mutable_cpu_data();
-  }
-
-  if (obs_prob_data_ref == nullptr) {
-    obs_prob_data_ref = new float*[height];
-  }
-  for (size_t i = 0; i &lt; height; ++i) {
-    obs_prob_data_ref[i] = obs_prob_data + i * width;
-  }
-
-  data_width = width;
-  data_height = height;
-  data_range = range;
-  data_size = width * height;
-}
-
-SppData::~SppData() {
-  if (obs_prob_data_ref) {
-    delete[] obs_prob_data_ref;
-  }
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_struct.h" new_path="" added_lines="0" deleted_lines="65">
				<diff>@@ -1,65 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include "modules/perception/base/blob.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-struct SppData {
-  float* obs_prob_data = nullptr;
-  float* offset_data = nullptr;
-  float* confidence_data = nullptr;
-  float* z_data = nullptr;
-  float* class_prob_data = nullptr;
-  float* heading_data = nullptr;
-
-  base::Blob&lt;float&gt;* instance_pt_blob = nullptr;
-  base::Blob&lt;float&gt;* category_pt_blob = nullptr;
-  base::Blob&lt;float&gt;* confidence_pt_blob = nullptr;
-  base::Blob&lt;float&gt;* classify_pt_blob = nullptr;
-  base::Blob&lt;float&gt;* heading_pt_blob = nullptr;
-  base::Blob&lt;float&gt;* height_pt_blob = nullptr;
-
-  float** obs_prob_data_ref = nullptr;
-
-  int* grid_indices = nullptr;
-
-  float objectness_threshold = 0.f;
-  float confidence_threshold = 0.f;
-  float top_z_threshold = 0.f;
-
-  size_t class_num = 0;
-  size_t data_width = 0;
-  size_t data_height = 0;
-  size_t data_size = 0;
-  float data_range = 0.0f;
-
-  void MakeReference(size_t width, size_t height, float range);
-
-  ~SppData();
-};
-
-struct SppParams {
-  float height_gap = 0.5f;
-  float confidence_range = 58.f;
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\util.h" new_path="" added_lines="0" deleted_lines="59">
				<diff>@@ -1,59 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-enum class MetaType {
-  META_UNKNOWN = 0,
-  META_SMALLMOT = 1,
-  META_BIGMOT = 2,
-  META_NONMOT = 3,
-  META_PEDESTRIAN = 4,
-  MAX_META_TYPE
-};
-
-const double kPI = 3.1415926535897932384626433832795;
-
-inline int F2I(float val, float ori, float scale) {
-  return static_cast&lt;int&gt;(std::floor((ori - val) * scale));
-}
-
-// for axis rotated case
-inline void GroupPc2Pixel(float pc_x, float pc_y, float scale, float range,
-                          int* x, int* y) {
-  float fx = (range - (0.707107f * (pc_x + pc_y))) * scale;
-  float fy = (range - (0.707107f * (pc_x - pc_y))) * scale;
-  *x = fx &lt; 0 ? -1 : static_cast&lt;int&gt;(fx);
-  *y = fy &lt; 0 ? -1 : static_cast&lt;int&gt;(fy);
-}
-
-// for axis aligned case
-inline int Pc2Pixel(float in_pc, float in_range, float out_size) {
-  float inv_res = 0.5f * out_size / in_range;
-  return static_cast&lt;int&gt;(std::floor((in_range - in_pc) * inv_res));
-}
-
-inline float Pixel2Pc(int in_pixel, float in_size, float out_range) {
-  float res = 2.0f * out_range / in_size;
-  return out_range - (static_cast&lt;float&gt;(in_pixel) + 0.5f) * res;
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\flood_fill.cc" new_path="" added_lines="0" deleted_lines="157">
				<diff>@@ -1,157 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/ncut/common/flood_fill.h"
-#include "cyber/common/log.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-namespace {
-const int kNumDirections = 8;
-const int di[kNumDirections] = {+1, 0, -1, 0, +1, +1, -1, -1};
-const int dj[kNumDirections] = {0, +1, 0, -1, +1, -1, +1, -1};
-const int kEmptyGridLabel = -1;
-const int kNonEmptyGridLabel = -2;
-}  // namespace
-
-int FloodFill::Pos(float x, float y) const {
-  const int irow = static_cast&lt;int&gt;((y + _offset_y) / _cell_size);
-  if (!IsValidRowIndex(irow)) {
-    return -1;
-  }
-  const int jcol = static_cast&lt;int&gt;((x + _offset_x) / _cell_size);
-  if (!IsValidColIndex(jcol)) {
-    return -1;
-  }
-  return irow * _grid_num_cols + jcol;
-}
-
-bool FloodFill::Pos2d(float x, float y, int* irow, int* jcol) const {
-  *irow = static_cast&lt;int&gt;((y + _offset_y) / _cell_size);
-  if (!IsValidRowIndex(*irow)) {
-    return false;
-  }
-  *jcol = static_cast&lt;int&gt;((x + _offset_x) / _cell_size);
-  if (!IsValidColIndex(*jcol)) {
-    return false;
-  }
-  return true;
-}
-
-void FloodFill::BuildGrid(base::PointFCloudConstPtr cloud) {
-  CHECK_GT(_grid_radius, 0.0);
-  CHECK_GT(_cell_size, 0.0);
-  // .1 calculate grid size
-  //  max_grid_size = 2.f *_grid_radius /_cell_size;
-  _num_points = static_cast&lt;int&gt;(cloud-&gt;size());
-  const double min_grid_radius = _grid_radius / 10.0;
-  float min_x = static_cast&lt;float&gt;(-min_grid_radius);
-  float min_y = static_cast&lt;float&gt;(-min_grid_radius);
-  float max_x = static_cast&lt;float&gt;(min_grid_radius);
-  float max_y = static_cast&lt;float&gt;(min_grid_radius);
-
-  for (size_t i = 0; i &lt; cloud-&gt;size(); ++i) {
-    auto pt = (*cloud)[i];
-    max_x = std::max(max_x, pt.x);
-    min_x = std::min(min_x, pt.x);
-    max_y = std::max(max_y, pt.y);
-    min_y = std::min(min_y, pt.y);
-  }
-  CHECK_LE(min_x, max_x);
-  CHECK_LE(min_y, max_y);
-  // .2 move origin to the left bottom corner
-  const float lower_x = std::max(min_x, -_grid_radius);
-  const float lower_y = std::max(min_y, -_grid_radius);
-  const float upper_x = std::min(max_x, _grid_radius);
-  const float upper_y = std::min(max_y, _grid_radius);
-  _offset_x = -lower_x;
-  _offset_y = -lower_y;
-  _grid_num_rows = static_cast&lt;int&gt;(ceil((upper_y - lower_y) / _cell_size)) + 1;
-  _grid_num_cols = static_cast&lt;int&gt;(ceil((upper_x - lower_x) / _cell_size)) + 1;
-  CHECK_GT(_grid_num_rows, 0);
-  CHECK_GT(_grid_num_cols, 0);
-  _grid_size = _grid_num_rows * _grid_num_cols;
-  // .3 locate points into grid
-  _point_cloud_grid_idx.assign(_num_points, -1);
-  _label.assign(_grid_size, kEmptyGridLabel);
-  for (int i = 0; i &lt; _num_points; ++i) {
-    const int idx = Pos((*cloud)[i].x, (*cloud)[i].y);
-    if (idx &gt;= 0) {
-      _point_cloud_grid_idx[i] = idx;
-      _label[idx] = kNonEmptyGridLabel;
-    }
-  }
-}
-
-int FloodFill::GetConnectedComponents() {
-  int num_components = 0;
-  for (int idx = 0; idx &lt; _grid_size; ++idx) {
-    auto&amp; label = _label[idx];
-    if (label == kNonEmptyGridLabel) {
-      label = num_components;
-      DfsColoring(idx / _grid_num_cols, idx % _grid_num_cols, num_components);
-      ++num_components;
-    }
-  }
-  return num_components;
-}
-
-void FloodFill::DfsColoring(int i, int j, int curr_component) {
-  // recursively label the neighbors
-  for (int direction = 0; direction &lt; kNumDirections; ++direction) {
-    const int i2 = i + di[direction];
-    const int j2 = j + dj[direction];
-    if (IsValidRowIndex(i2) &amp;&amp; IsValidColIndex(j2)) {
-      auto&amp; label = _label[i2 * _grid_num_cols + j2];
-      if (label == kNonEmptyGridLabel) {
-        label = curr_component;
-        DfsColoring(i2, j2, curr_component);
-      }
-    }
-  }
-}
-
-void FloodFill::GetSegments(base::PointFCloudConstPtr cloud,
-                            std::vector&lt;std::vector&lt;int&gt;&gt;* segments_indices,
-                            std::vector&lt;int&gt;* num_cells_per_segment) {
-  CHECK_NOTNULL(segments_indices);
-  CHECK_NOTNULL(num_cells_per_segment);
-  // .1 build grid
-  BuildGrid(cloud);
-  // .2 get connected components
-  const int num_segments = GetConnectedComponents();
-  CHECK_GE(num_segments, 0);
-  // .3 write result
-  segments_indices-&gt;clear();
-  segments_indices-&gt;resize(num_segments);
-  num_cells_per_segment-&gt;clear();
-  num_cells_per_segment-&gt;resize(num_segments, 0);
-  for (int i = 0; i &lt; _grid_size; ++i) {
-    if (_label[i] != kEmptyGridLabel) {
-      (*num_cells_per_segment)[_label[i]]++;
-    }
-  }
-  for (int i = 0; i &lt; _num_points; ++i) {
-    const int idx = _point_cloud_grid_idx[i];
-    if (idx &gt;= 0) {
-      (*segments_indices)[_label[idx]].push_back(i);
-    }
-  }
-}
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\flood_fill.h" new_path="" added_lines="0" deleted_lines="67">
				<diff>@@ -1,67 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;algorithm&gt;
-#include &lt;cstdlib&gt;
-#include &lt;vector&gt;
-
-#include "modules/perception/base/point_cloud.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class FloodFill {
- public:
-  FloodFill() = default;
-  FloodFill(float grid_radius, float cell_size)
-      : _grid_radius(grid_radius), _cell_size(cell_size) {}
-  void GetSegments(base::PointFCloudConstPtr cloud,
-                   std::vector&lt;std::vector&lt;int&gt;&gt;* segments_indices,
-                   std::vector&lt;int&gt;* num_cells_per_segment);
-  // The grids at the boundary are valid.
-  int Pos(float x, float y) const;
-  bool Pos2d(float x, float y, int* irow, int* jcol) const;
-  void BuildGrid(base::PointFCloudConstPtr cloud);
-  void SetGridRadius(float grid_radius) { _grid_radius = grid_radius; }
-  void SetCellSize(float cell_size) { _cell_size = cell_size; }
-  int GetNumRows() const { return _grid_num_rows; }
-  int GetNumCols() const { return _grid_num_cols; }
-  int GetNumCells() const { return _grid_size; }
-  const std::vector&lt;int&gt;&amp; GetPointIdxInGrid() const {
-    return _point_cloud_grid_idx;
-  }
-
- private:
-  bool IsValidRowIndex(int i) const { return (i &gt;= 0 &amp;&amp; i &lt; _grid_num_rows); }
-  bool IsValidColIndex(int j) const { return (j &gt;= 0 &amp;&amp; j &lt; _grid_num_cols); }
-  int GetConnectedComponents();
-  void DfsColoring(int i, int j, int curr_component);
-  float _grid_radius = 0.0;
-  float _cell_size = 0.0;
-  float _offset_x = 0.0;
-  float _offset_y = 0.0;
-  int _grid_num_rows = 0;
-  int _grid_num_cols = 0;
-  int _grid_size = 0;
-  int _num_points = 0;
-  std::vector&lt;int&gt; _point_cloud_grid_idx;
-  std::vector&lt;int&gt; _label;
-};
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\graph_felzenszwalb\convolve.h" new_path="" added_lines="0" deleted_lines="76">
				<diff>@@ -1,76 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
-Copyright (C) 2006 Pedro Felzenszwalb
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-#pragma once
-#include &lt;algorithm&gt;
-#include &lt;cmath&gt;
-#include &lt;vector&gt;
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/image.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-// convolve src with mask.  dst is flipped!
-void convolve_even(Image&lt;float&gt; *src, Image&lt;float&gt; *dst,
-                   const std::vector&lt;float&gt; &amp;mask) {
-  int width = src-&gt;width();
-  int height = src-&gt;height();
-  int len = mask.size();
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      float sum = mask[0] * imRef(src, x, y);
-      for (int i = 1; i &lt; len; i++) {
-        sum += mask[i] * (imRef(src, std::max(x - i, 0), y) +
-                          imRef(src, std::min(x + i, width - 1), y));
-      }
-      imRef(dst, y, x) = sum;
-    }
-  }
-}
-// convolve src with mask.  dst is flipped!
-void convolve_odd(Image&lt;float&gt; *src, Image&lt;float&gt; *dst,
-                  const std::vector&lt;float&gt; &amp;mask) {
-  int width = src-&gt;width();
-  int height = src-&gt;height();
-  int len = mask.size();
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      float sum = mask[0] * imRef(src, x, y);
-      for (int i = 1; i &lt; len; i++) {
-        sum += mask[i] * (imRef(src, std::max(x - i, 0), y) -
-                          imRef(src, std::min(x + i, width - 1), y));
-      }
-      imRef(dst, y, x) = sum;
-    }
-  }
-}
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\graph_felzenszwalb\disjoint_set.h" new_path="" added_lines="0" deleted_lines="100">
				<diff>@@ -1,100 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
-Copyright (C) 2006 Pedro Felzenszwalb
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-
-#pragma once
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-// disjoint-set forests using union-by-rank and path compression (sort of).
-
-typedef struct {
-  int rank;
-  int p;
-  int size;
-} uni_elt;
-
-class Universe {
- public:
-  explicit Universe(int elements);
-  ~Universe();
-  int find(int x);
-  void join(int x, int y);
-  int size(int x) const { return _elts[x].size; }
-  int num_sets() const { return _num; }
-
- private:
-  uni_elt *_elts;
-  int _num;
-};
-
-Universe::Universe(int elements) {
-  _elts = new uni_elt[elements];
-  _num = elements;
-  for (int i = 0; i &lt; elements; i++) {
-    _elts[i].rank = 0;
-    _elts[i].size = 1;
-    _elts[i].p = i;
-  }
-}
-
-Universe::~Universe() { delete[] _elts; }
-
-int Universe::find(int x) {
-  int y = x;
-  while (y != _elts[y].p) {
-    y = _elts[y].p;
-  }
-  _elts[x].p = y;
-  return y;
-}
-
-void Universe::join(int x, int y) {
-  if (_elts[x].rank &gt; _elts[y].rank) {
-    _elts[y].p = x;
-    _elts[x].size += _elts[y].size;
-  } else {
-    _elts[x].p = y;
-    _elts[y].size += _elts[x].size;
-    if (_elts[x].rank == _elts[y].rank) {
-      _elts[y].rank++;
-    }
-  }
-  _num--;
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\graph_felzenszwalb\filter.h" new_path="" added_lines="0" deleted_lines="106">
				<diff>@@ -1,106 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
-Copyright (C) 2006 Pedro Felzenszwalb
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-/* simple filters */
-#pragma once
-#include &lt;algorithm&gt;
-#include &lt;cmath&gt;
-#include &lt;vector&gt;
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/convolve.h"
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/image.h"
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/imconv.h"
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/misc.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-const double WIDTH = 4.0;
-/* normalize mask so it integrates to one */
-void normalize(std::vector&lt;float&gt; *mask_input) {
-  std::vector&lt;float&gt; &amp;mask = *mask_input;
-  int len = mask.size();
-  float sum = 0;
-  for (int i = 1; i &lt; len; i++) {
-    sum += fabs(mask[i]);
-  }
-  sum = 2 * sum + fabs(mask[0]);
-  for (int i = 0; i &lt; len; i++) {
-    mask[i] /= sum;
-  }
-}
-/* make filters */
-#define MAKE_FILTER(name, fun)                           \
-  std::vector&lt;float&gt; make_##name(float sigma) {          \
-    sigma = std::max(sigma, 0.01F);                      \
-    int len = static_cast&lt;int&gt;(ceil(sigma * WIDTH)) + 1; \
-    std::vector&lt;float&gt; mask(len);                        \
-    for (int i = 0; i &lt; len; i++) {                      \
-      mask[i] = fun;                                     \
-    }                                                    \
-    return mask;                                         \
-  }
-MAKE_FILTER(fgauss, exp(-0.5 * square(i / sigma)));
-/* convolve image with gaussian filter */
-Image&lt;float&gt; *smooth(Image&lt;float&gt; *src, float sigma) {
-  std::vector&lt;float&gt; mask = make_fgauss(sigma);
-  normalize(mask);
-  Image&lt;float&gt; *tmp = new Image&lt;float&gt;(src-&gt;height(), src-&gt;width(), false);
-  Image&lt;float&gt; *dst = new Image&lt;float&gt;(src-&gt;width(), src-&gt;height(), false);
-  convolve_even(src, tmp, mask);
-  convolve_even(tmp, dst, mask);
-  delete tmp;
-  return dst;
-}
-/* convolve image with gaussian filter */
-Image&lt;float&gt; *smooth(Image&lt;uchar&gt; *src, float sigma) {
-  Image&lt;float&gt; *tmp = image_uchar2float(src);
-  Image&lt;float&gt; *dst = smooth(tmp, sigma);
-  delete tmp;
-  return dst;
-}
-/* compute laplacian */
-Image&lt;float&gt; *laplacian(Image&lt;float&gt; *src) {
-  int width = src-&gt;width();
-  int height = src-&gt;height();
-  Image&lt;float&gt; *dst = new Image&lt;float&gt;(width, height);
-  for (int y = 1; y &lt; height - 1; y++) {
-    for (int x = 1; x &lt; width - 1; x++) {
-      float d2x =
-          imRef(src, x - 1, y) + imRef(src, x + 1, y) - 2 * imRef(src, x, y);
-      float d2y =
-          imRef(src, x, y - 1) + imRef(src, x, y + 1) - 2 * imRef(src, x, y);
-      imRef(dst, x, y) = d2x + d2y;
-    }
-  }
-  return dst;
-}
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\graph_felzenszwalb\image.h" new_path="" added_lines="0" deleted_lines="108">
				<diff>@@ -1,108 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
-Copyright (C) 2006 Pedro Felzenszwalb
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-/* a simple image class */
-#pragma once
-#include &lt;cstring&gt;
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-template &lt;class T&gt;
-class Image {
- public:
-  /* create an image */
-  Image(const int width, const int height, const bool init = true);
-  /* delete an image */
-  ~Image();
-  /* init an image */
-  void init(const T &amp;val);
-  /* copy an image */
-  Image&lt;T&gt; *copy() const;
-
-  /* get the width of an image. */
-  int width() const { return _w; }
-
-  /* get the height of an image. */
-  int height() const { return _h; }
-
-  /* image data. */
-  T *_data;
-
-  /* row pointers. */
-  T **_access;
-
- private:
-  int _w;
-  int _h;
-};
-/* use imRef to access image data. */
-#define imRef(im, x, y) (im-&gt;_access[y][x])
-/* use imPtr to get pointer to image data. */
-#define imPtr(im, x, y) &amp;(im-&gt;_access[y][x])
-template &lt;class T&gt;
-Image&lt;T&gt;::Image(const int width, const int height, const bool init) {
-  _w = width;
-  _h = height;
-  _data = new T[_w * _h];  // allocate space for image data
-  _access = new T *[_h];   // allocate space for row pointers
-
-  // initialize row pointers
-  for (int i = 0; i &lt; _h; i++) {
-    _access[i] = _data + (i * _w);
-  }
-
-  if (init) {
-    memset(_data, 0, _w * _h * sizeof(T));
-  }
-}
-template &lt;class T&gt;
-Image&lt;T&gt;::~Image() {
-  delete[] _data;
-  delete[] _access;
-}
-template &lt;class T&gt;
-void Image&lt;T&gt;::init(const T &amp;val) {
-  T *ptr = imPtr(this, 0, 0);
-  T *end = imPtr(this, _w - 1, _h - 1);
-  while (ptr &lt;= end) {
-    *ptr++ = val;
-  }
-}
-template &lt;class T&gt;
-Image&lt;T&gt; *Image&lt;T&gt;::copy() const {
-  Image&lt;T&gt; *im = new Image&lt;T&gt;(_w, _h, false);
-  memcpy(im-&gt;_data, _data, _w * _h * sizeof(T));
-  return im;
-}
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\graph_felzenszwalb\imconv.h" new_path="" added_lines="0" deleted_lines="176">
				<diff>@@ -1,176 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
-Copyright (C) 2006 Pedro Felzenszwalb
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-/* image conversion */
-#pragma once
-
-#include &lt;limits&gt;
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/image.h"
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/imutil.h"
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/misc.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-const double RED_WEIGHT = 0.299;
-const double GREEN_WEIGHT = 0.587;
-const double BLUE_WEIGHT = 0.114;
-Image&lt;uchar&gt; *image_rgb2gray(Image&lt;rgb&gt; *input) {
-  int width = input-&gt;width();
-  int height = input-&gt;height();
-  Image&lt;uchar&gt; *output = new Image&lt;uchar&gt;(width, height, false);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      imRef(output, x, y) = (uchar)(imRef(input, x, y).r * RED_WEIGHT +
-                                    imRef(input, x, y).g * GREEN_WEIGHT +
-                                    imRef(input, x, y).b * BLUE_WEIGHT);
-    }
-  }
-  return output;
-}
-Image&lt;rgb&gt; *image_gray2rgb(Image&lt;uchar&gt; *input) {
-  int width = input-&gt;width();
-  int height = input-&gt;height();
-  Image&lt;rgb&gt; *output = new Image&lt;rgb&gt;(width, height, false);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      imRef(output, x, y).r = imRef(input, x, y);
-      imRef(output, x, y).g = imRef(input, x, y);
-      imRef(output, x, y).b = imRef(input, x, y);
-    }
-  }
-  return output;
-}
-Image&lt;float&gt; *image_uchar2float(Image&lt;uchar&gt; *input) {
-  int width = input-&gt;width();
-  int height = input-&gt;height();
-  Image&lt;float&gt; *output = new Image&lt;float&gt;(width, height, false);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      imRef(output, x, y) = imRef(input, x, y);
-    }
-  }
-  return output;
-}
-Image&lt;float&gt; *image_int2float(Image&lt;int&gt; *input) {
-  int width = input-&gt;width();
-  int height = input-&gt;height();
-  Image&lt;float&gt; *output = new Image&lt;float&gt;(width, height, false);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      imRef(output, x, y) = imRef(input, x, y);
-    }
-  }
-  return output;
-}
-Image&lt;uchar&gt; *image_float2uchar(Image&lt;float&gt; *input, float min, float max) {
-  int width = input-&gt;width();
-  int height = input-&gt;height();
-  Image&lt;uchar&gt; *output = new Image&lt;uchar&gt;(width, height, false);
-  if (max == min) {
-    return output;
-  }
-  float scale = std::numeric_limits&lt;unsigned char&gt;::max() / (max - min);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      uchar val = (uchar)((imRef(input, x, y) - min) * scale);
-      imRef(output, x, y) = bound(
-          val, (uchar)0, (uchar)std::numeric_limits&lt;unsigned char&gt;::max());
-    }
-  }
-  return output;
-}
-Image&lt;uchar&gt; *image_float2uchar(Image&lt;float&gt; *input) {
-  float min, max;
-  min_max(input, &amp;min, &amp;max);
-  return image_float2uchar(input, min, max);
-}
-Image&lt;uint32_t&gt; *image_uchar2long(Image&lt;uchar&gt; *input) {
-  int width = input-&gt;width();
-  int height = input-&gt;height();
-  Image&lt;uint32_t&gt; *output = new Image&lt;uint32_t&gt;(width, height, false);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      imRef(output, x, y) = imRef(input, x, y);
-    }
-  }
-  return output;
-}
-Image&lt;uchar&gt; *image_long2uchar(Image&lt;uint32_t&gt; *input, uint32_t min,
-                               uint32_t max) {
-  int width = input-&gt;width();
-  int height = input-&gt;height();
-  Image&lt;uchar&gt; *output = new Image&lt;uchar&gt;(width, height, false);
-  if (max == min) {
-    return output;
-  }
-  float scale =
-      std::numeric_limits&lt;unsigned char&gt;::max() / static_cast&lt;float&gt;(max - min);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      uchar val = (uchar)((imRef(input, x, y) - min) * scale);
-      imRef(output, x, y) = bound(
-          val, (uchar)0, (uchar)std::numeric_limits&lt;unsigned char&gt;::max());
-    }
-  }
-  return output;
-}
-Image&lt;uchar&gt; *image_long2uchar(Image&lt;uint32_t&gt; *input) {
-  uint32_t min, max;
-  min_max(input, &amp;min, &amp;max);
-  return image_long2uchar(input, min, max);
-}
-Image&lt;uchar&gt; *image_short2uchar(Image&lt;uint16_t&gt; *input, uint16_t min,
-                                uint16_t max) {
-  int width = input-&gt;width();
-  int height = input-&gt;height();
-  Image&lt;uchar&gt; *output = new Image&lt;uchar&gt;(width, height, false);
-  if (max == min) {
-    return output;
-  }
-  float scale =
-      std::numeric_limits&lt;unsigned char&gt;::max() / static_cast&lt;float&gt;(max - min);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      uchar val = (uchar)((imRef(input, x, y) - min) * scale);
-      imRef(output, x, y) = bound(
-          val, (uchar)0, (uchar)std::numeric_limits&lt;unsigned char&gt;::max());
-    }
-  }
-  return output;
-}
-Image&lt;uchar&gt; *image_short2uchar(Image&lt;uint16_t&gt; *input) {
-  uint16_t min, max;
-  min_max(input, &amp;min, &amp;max);
-  return image_short2uchar(input, min, max);
-}
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\graph_felzenszwalb\imutil.h" new_path="" added_lines="0" deleted_lines="76">
				<diff>@@ -1,76 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
-Copyright (C) 2006 Pedro Felzenszwalb
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-/* some image utilities */
-#pragma once
-
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/image.h"
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/misc.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-/* compute minimum and maximum value in an image */
-template &lt;class T&gt;
-void min_max(Image&lt;T&gt; *im, T *ret_min, T *ret_max) {
-  int width = im-&gt;width();
-  int height = im-&gt;height();
-  T min = imRef(im, 0, 0);
-  T max = imRef(im, 0, 0);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      T val = imRef(im, x, y);
-      if (min &gt; val) {
-        min = val;
-      }
-      if (max &lt; val) {
-        max = val;
-      }
-    }
-  }
-  *ret_min = min;
-  *ret_max = max;
-}
-/* threshold image */
-template &lt;class T&gt;
-Image&lt;uchar&gt; *threshold(Image&lt;T&gt; *src, int t) {
-  int width = src-&gt;width();
-  int height = src-&gt;height();
-  Image&lt;uchar&gt; *dst = new Image&lt;uchar&gt;(width, height);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      imRef(dst, x, y) = (imRef(src, x, y) &gt;= t);
-    }
-  }
-  return dst;
-}
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\graph_felzenszwalb\misc.h" new_path="" added_lines="0" deleted_lines="74">
				<diff>@@ -1,74 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
-Copyright (C) 2006 Pedro Felzenszwalb
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-
-#pragma once
-
-#include &lt;cmath&gt;
-namespace apollo {
-namespace perception {
-namespace lidar {
-typedef unsigned char uchar;
-typedef struct {
-  uchar r;
-  uchar g;
-  uchar b;
-} rgb;
-inline bool operator==(const rgb &amp;a, const rgb &amp;b) {
-  return ((a.r == b.r) &amp;&amp; (a.g == b.g) &amp;&amp; (a.b == b.b));
-}
-template &lt;class T&gt;
-inline T abs(const T &amp;x) {
-  return (x &gt; 0 ? x : -x);
-}
-template &lt;class T&gt;
-inline int sign(const T &amp;x) {
-  return (x &gt;= 0 ? 1 : -1);
-}
-template &lt;class T&gt;
-inline T square(const T &amp;x) {
-  return x * x;
-}
-template &lt;class T&gt;
-inline T bound(const T &amp;x, const T &amp;min, const T &amp;max) {
-  return (x &lt; min ? min : (x &gt; max ? max : x));
-}
-template &lt;class T&gt;
-inline bool check_bound(const T &amp;x, const T &amp;min, const T &amp;max) {
-  return ((x &lt; min) || (x &gt; max));
-}
-inline int vlib_round(float x) { return static_cast&lt;int&gt;(x + 0.5F); }
-inline int vlib_round(double x) { return static_cast&lt;int&gt;(x + 0.5); }
-inline double gaussian(double val, double sigma) {
-  return exp(-square(val / sigma) / 2) / (sqrt(2 * M_PI) * sigma);
-}
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\graph_felzenszwalb\segment_graph.h" new_path="" added_lines="0" deleted_lines="101">
				<diff>@@ -1,101 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-/*
-Copyright (C) 2006 Pedro Felzenszwalb
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-
-#pragma once
-#include &lt;algorithm&gt;
-#include &lt;cmath&gt;
-
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/disjoint_set.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-// threshold function
-#define THRESHOLD(size, c) (c / size)
-
-typedef struct {
-  float w;
-  int a;
-  int b;
-} edge;
-
-bool operator&lt;(const edge &amp;a, const edge &amp;b) { return a.w &lt; b.w; }
-
-/*
- * Segment a graph
- *
- * Returns a disjoint-set forest representing the segmentation.
- *
- * num_vertices: number of vertices in graph.
- * num_edges: number of edges in graph
- * edges: array of edges.
- * c: constant for threshold function.
- */
-Universe *segment_graph(int num_vertices, int num_edges, edge *edges, float c) {
-  // sort edges by weight
-  std::sort(edges, edges + num_edges);
-
-  // make a disjoint-set forest
-  Universe *u = new Universe(num_vertices);
-
-  // init thresholds
-  float *threshold = new float[num_vertices];
-  for (int i = 0; i &lt; num_vertices; i++) {
-    threshold[i] = THRESHOLD(1, c);
-  }
-
-  // for each edge, in non-decreasing weight order...
-  for (int i = 0; i &lt; num_edges; i++) {
-    edge *pedge = &amp;edges[i];
-
-    // components connected by this edge
-    int a = u-&gt;find(pedge-&gt;a);
-    int b = u-&gt;find(pedge-&gt;b);
-    if (a != b) {
-      if ((pedge-&gt;w &lt;= threshold[a]) &amp;&amp; (pedge-&gt;w &lt;= threshold[b])) {
-        u-&gt;join(a, b);
-        a = u-&gt;find(a);
-        threshold[a] = pedge-&gt;w + THRESHOLD(u-&gt;size(a), c);
-      }
-    }
-  }
-
-  // free up
-  delete threshold;
-  return u;
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\graph_felzenszwalb\segment_image.h" new_path="" added_lines="0" deleted_lines="119">
				<diff>@@ -1,119 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
-Copyright (C) 2006 Pedro Felzenszwalb
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-
-#pragma once
-
-#include &lt;cstdlib&gt;
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/filter.h"
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/image.h"
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/misc.h"
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/segment_graph.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-// dissimilarity measure between pixels
-inline float diff(Image&lt;float&gt; *I, int x1, int y1, int x2, int y2) {
-  return std::fabs(imRef(I, x1, y1) - imRef(I, x2, y2));
-}
-/*
- * Segment an image
- *
- * Returns a color image representing the segmentation.
- *
- * im: image to segment.
- * sigma: to smooth the image.
- * c: constant for threshold function.
- * min_size: minimum component size (enforced by post-processing stage).
- * num_ccs: number of connected components in the segmentation.
- */
-Image&lt;int&gt; *segment_image(Image&lt;float&gt; *im, float sigma, float c, int min_size,
-                          int *num_ccs) {
-  int width = im-&gt;width();
-  int height = im-&gt;height();
-  // smooth each color channel
-  Image&lt;float&gt; *smooth_r = smooth(im, sigma);
-  // build graph
-  edge *edges = new edge[width * height * 4];
-  int num = 0;
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      if (x &lt; width - 1) {
-        edges[num].a = y * width + x;
-        edges[num].b = y * width + (x + 1);
-        edges[num].w = diff(smooth_r, x, y, x + 1, y);
-        num++;
-      }
-      if (y &lt; height - 1) {
-        edges[num].a = y * width + x;
-        edges[num].b = (y + 1) * width + x;
-        edges[num].w = diff(smooth_r, x, y, x, y + 1);
-        num++;
-      }
-      if ((x &lt; width - 1) &amp;&amp; (y &lt; height - 1)) {
-        edges[num].a = y * width + x;
-        edges[num].b = (y + 1) * width + (x + 1);
-        edges[num].w = diff(smooth_r, x, y, x + 1, y + 1);
-        num++;
-      }
-      if ((x &lt; width - 1) &amp;&amp; (y &gt; 0)) {
-        edges[num].a = y * width + x;
-        edges[num].b = (y - 1) * width + (x + 1);
-        edges[num].w = diff(smooth_r, x, y, x + 1, y - 1);
-        num++;
-      }
-    }
-  }
-  delete smooth_r;
-  // segment
-  Universe *u = segment_graph(width * height, num, edges, c);
-  // post process small components
-  for (int i = 0; i &lt; num; i++) {
-    int a = u-&gt;find(edges[i].a);
-    int b = u-&gt;find(edges[i].b);
-    if ((a != b) &amp;&amp; ((u-&gt;size(a) &lt; min_size) || (u-&gt;size(b) &lt; min_size)))
-      u-&gt;join(a, b);
-  }
-  delete[] edges;
-  *num_ccs = u-&gt;num_sets();
-  Image&lt;int&gt; *output = new Image&lt;int&gt;(width, height);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      int comp = u-&gt;find(y * width + x);
-      imRef(output, x, y) = comp;
-    }
-  }
-  delete u;
-  return output;
-}
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\lr_classifier.h" new_path="" added_lines="0" deleted_lines="93">
				<diff>@@ -1,93 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;algorithm&gt;
-#include &lt;cmath&gt;
-#include &lt;cstdlib&gt;
-#include &lt;iostream&gt;
-#include &lt;limits&gt;
-#include &lt;map&gt;
-#include &lt;string&gt;
-#include &lt;tuple&gt;
-#include &lt;unordered_set&gt;
-#include &lt;vector&gt;
-
-#include "Eigen/Core"
-
-#include "modules/perception/base/point_cloud.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class LRClassifier {
- public:
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-
- public:
-  LRClassifier() = default;
-  ~LRClassifier() {}
-  bool init() {
-    _lr_parameters.resize(3, 4);
-    _lr_parameters.coeffRef(0, 0) = 0.0510903f;
-    _lr_parameters.coeffRef(0, 1) = -1.00989f;
-    _lr_parameters.coeffRef(0, 2) = -1.6537f;
-    _lr_parameters.coeffRef(0, 3) = 0.130055f;
-    _lr_parameters.coeffRef(1, 0) = 0.266469f;
-    _lr_parameters.coeffRef(1, 1) = -0.538964f;
-    _lr_parameters.coeffRef(1, 2) = -0.291611f;
-    _lr_parameters.coeffRef(1, 3) = -0.070701f;
-    _lr_parameters.coeffRef(2, 0) = 0.497949f;
-    _lr_parameters.coeffRef(2, 1) = -0.504843f;
-    _lr_parameters.coeffRef(2, 2) = -0.152141f;
-    _lr_parameters.coeffRef(2, 3) = -1.38024f;
-    return true;
-  }
-
-  std::string GetLabel(base::PointFCloudConstPtr cloud) {
-    // point cloud should be rotated
-    float x_max = -std::numeric_limits&lt;float&gt;::max();
-    float y_max = -std::numeric_limits&lt;float&gt;::max();
-    float z_max = -std::numeric_limits&lt;float&gt;::max();
-    float x_min = std::numeric_limits&lt;float&gt;::max();
-    float y_min = std::numeric_limits&lt;float&gt;::max();
-    float z_min = std::numeric_limits&lt;float&gt;::max();
-    for (size_t i = 0; i &lt; cloud-&gt;size(); ++i) {
-      auto pt = (*cloud)[i];
-      x_min = std::min(x_min, pt.x);
-      x_max = std::max(x_max, pt.x);
-      y_min = std::min(y_min, pt.y);
-      y_max = std::max(y_max, pt.y);
-      z_min = std::min(z_min, pt.z);
-      z_max = std::max(z_max, pt.z);
-    }
-    Eigen::Vector3f fea = {x_max - x_min, y_max - y_min, z_max - z_min};
-    Eigen::VectorXf response = fea.transpose() * _lr_parameters;
-    int type = 0;
-    // float max_score = response.maxCoeff(&amp;type);
-    return _labels[type];
-  }
-
- private:
-  Eigen::MatrixXf _lr_parameters;
-  std::vector&lt;std::string&gt; _labels = {"unknown", "nonMot", "pedestrian",
-                                      "smallMot"};
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\ncut.cc" new_path="" added_lines="0" deleted_lines="833">
				<diff>@@ -1,833 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-#include "modules/perception/lidar/lib/segmentation/ncut/ncut.h"
-
-#include &lt;algorithm&gt;
-#include &lt;ctime&gt;
-#include &lt;functional&gt;
-#include &lt;limits&gt;
-#include &lt;queue&gt;
-#include &lt;stack&gt;
-#include &lt;string&gt;
-#include &lt;unordered_map&gt;
-#include &lt;utility&gt;
-#include &lt;vector&gt;
-
-#include &lt;omp.h&gt;
-
-#include "cyber/common/file.h"
-#include "cyber/common/log.h"
-#include "modules/perception/base/point_cloud_util.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-namespace {
-const int OBSTACLE_MINIMUM_NUM_POINTS = 50;
-}
-
-using apollo::cyber::common::GetAbsolutePath;
-using apollo::cyber::common::GetProtoFromFile;
-using Eigen::MatrixXf;
-
-NCut::NCut() {}
-NCut::~NCut() { ADEBUG &lt;&lt; "NCut destructor done"; }
-
-bool NCut::Init(const NCutParam &amp;param) {
-  if (!Configure(param)) {
-    AERROR &lt;&lt; "failed to load ncut config.";
-    return false;
-  }
-
-  _classifier.reset(new LRClassifier);
-  if (!_classifier-&gt;init()) {
-    AERROR &lt;&lt; "failed to init FrameClassifierPipeline.";
-    return false;
-  }
-  return true;
-}
-
-bool NCut::Configure(const NCutParam &amp;ncut_param_) {
-  _grid_radius = ncut_param_.grid_radius();
-  _connect_radius = ncut_param_.connect_radius();
-  _super_pixel_cell_size = ncut_param_.super_pixel_cell_size();
-  _num_cuts = ncut_param_.num_cuts();
-  _ncuts_stop_threshold = ncut_param_.ncuts_stop_threshold();
-  _ncuts_enable_classifier_threshold =
-      ncut_param_.ncuts_enable_classifier_threshold();
-  _sigma_space = ncut_param_.sigma_space();
-  _sigma_feature = ncut_param_.sigma_feature();
-  _skeleton_cell_size = ncut_param_.skeleton_cell_size();
-  _patch_size = ncut_param_.patch_size();
-  _overlap_factor = ncut_param_.overlap_factor();
-  _felzenszwalb_sigma = ncut_param_.felzenszwalb_sigma();
-  _felzenszwalb_k = ncut_param_.felzenszwalb_k();
-  _felzenszwalb_min_size = ncut_param_.felzenszwalb_min_size();
-
-  AINFO &lt;&lt; "NCut Parameters" &lt;&lt; ncut_param_.DebugString();
-  return true;
-}
-
-void NCut::Segment(base::PointFCloudConstPtr cloud) {
-#ifdef DEBUG_NCUT
-  double start_t = omp_get_wtime();
-#endif
-  // .0 clear everything
-  _segment_pids.clear();
-  _segment_labels.clear();
-  _segment_bbox.clear();
-  _outlier_pids.clear();
-  _cluster_points.clear();
-  _cluster_bounding_box.clear();
-  _cluster_skeleton_points.clear();
-  _cluster_skeleton_features.clear();
-  std::vector&lt;int&gt; pids(cloud-&gt;size());
-  for (size_t i = 0; i &lt; cloud-&gt;size(); ++i) {
-    pids[i] = static_cast&lt;int&gt;(i);
-  }
-  _cloud_obstacles = base::PointFCloudPtr(new base::PointFCloud(*cloud, pids));
-  AINFO &lt;&lt; "cloud obstacle size in ncut segment is "
-        &lt;&lt; _cloud_obstacles-&gt;size();
-#ifdef DEBUG_NCUT
-  ADEBUG &lt;&lt; "segment enter ... input cloud size " &lt;&lt; cloud-&gt;size();
-// visualize_points(pids);
-#endif
-  // .1 super pixels
-  // super_pixels_felzenszwalb(cloud, _grid_radius, _super_pixel_cell_size,
-  // _cluster_points);
-  SuperPixelsFloodFill(cloud, _grid_radius, _super_pixel_cell_size,
-                       &amp;_cluster_points);
-#ifdef DEBUG_NCUT
-  // visualize_segments_from_points(_cluster_points);
-  ADEBUG &lt;&lt; "super pixels " &lt;&lt; _cluster_points.size();
-  AINFO &lt;&lt; "super pixels done " &lt;&lt; omp_get_wtime() - start_t;
-  start_t = omp_get_wtime();
-#endif
-
-  // .2 precompute skeleton and bbox
-  PrecomputeAllSkeletonAndBbox();
-#ifdef DEBUG_NCUT
-  AINFO &lt;&lt; "precompute skeleton and bbox done " &lt;&lt; omp_get_wtime() - start_t;
-  start_t = omp_get_wtime();
-#endif
-  // .3 grach cut
-  std::vector&lt;std::vector&lt;int&gt;&gt; segment_clusters;
-  std::vector&lt;std::string&gt; segment_labels;
-  NormalizedCut(_ncuts_stop_threshold, true, &amp;segment_clusters,
-                &amp;segment_labels);
-#ifdef DEBUG_NCUT
-  AINFO &lt;&lt; "normalized_cut done, #segments " &lt;&lt; segment_clusters.size()
-        &lt;&lt; ", time: " &lt;&lt; omp_get_wtime() - start_t;
-  start_t = omp_get_wtime();
-#endif
-  // .4 _segment_pids;
-  for (size_t i = 0; i &lt; segment_clusters.size(); ++i) {
-    std::vector&lt;int&gt; pids;
-    GetClustersPids(segment_clusters[i], &amp;pids);
-    if (pids.size() &gt; 0) {
-      _segment_pids.push_back(pids);
-      _segment_labels.push_back(segment_labels[i]);
-      NcutBoundingBox box;
-      GetComponentBoundingBox(segment_clusters[i], &amp;box);
-      _segment_bbox.push_back(box);
-    }
-  }
-}
-
-void NCut::SuperPixelsFloodFill(base::PointFCloudConstPtr cloud, float radius,
-                                float cell_size,
-                                std::vector&lt;std::vector&lt;int&gt;&gt; *super_pixels) {
-  FloodFill ff_grid(radius, cell_size);
-  std::vector&lt;int&gt; num_cells_per_components;
-  ff_grid.GetSegments(cloud, super_pixels, &amp;num_cells_per_components);
-}
-
-void NCut::PrecomputeAllSkeletonAndBbox() {
-  const int num_clusters = static_cast&lt;int&gt;(_cluster_points.size());
-  _cluster_skeleton_points.resize(num_clusters);
-  _cluster_skeleton_features.resize(num_clusters);
-  _cluster_bounding_box.resize(num_clusters);
-  _cluster_labels.resize(num_clusters, "unknown");
-  // skeleton
-  _ff_feature_grid.SetGridRadius(_grid_radius);
-  _ff_feature_grid.SetCellSize(_skeleton_cell_size);
-  _ff_feature_grid.BuildGrid(_cloud_obstacles);
-  std::vector&lt;gridIndex&gt; dummy_indices;
-  BuildAverageHeightMap(_cloud_obstacles, _ff_feature_grid, &amp;_cv_feature_map,
-                        &amp;dummy_indices);
-
-  // build_maximum_height_map(_cloud_obstacles, _ff_feature_grid,
-  // _cv_feature_map, dummy_indices);
-  for (int i = 0; i &lt; num_clusters; ++i) {
-    SampleByGrid(_cluster_points[i], &amp;_cluster_skeleton_points[i],
-                 &amp;_cluster_skeleton_features[i]);
-    _cluster_bounding_box[i] = ComputeClusterBoundingBox(_cluster_points[i]);
-  }
-  // cluster label
-  for (size_t i = 0; i &lt; _cluster_points.size(); ++i) {
-    base::PointFCloudPtr pc = base::PointFCloudPtr(
-        new base::PointFCloud(*_cloud_obstacles, _cluster_points[i]));
-    _cluster_labels[i] = GetPcLabel(pc);
-  }
-}
-
-void NCut::BuildAverageHeightMap(
-    base::PointFCloudConstPtr cloud, const FloodFill &amp;ff_map,
-    cv::Mat *cv_height_map_in, std::vector&lt;gridIndex&gt; *point_pixel_indices_in) {
-  cv::Mat &amp;cv_height_map = *cv_height_map_in;
-  std::vector&lt;gridIndex&gt; &amp;point_pixel_indices = *point_pixel_indices_in;
-  const int num_points = static_cast&lt;int&gt;(cloud-&gt;size());
-  cv::Mat cv_img =
-      cv::Mat::zeros(ff_map.GetNumRows(), ff_map.GetNumCols(), CV_32F);
-  std::vector&lt;std::vector&lt;int&gt;&gt; counts;
-  counts.resize(cv_img.rows);
-  for (size_t i = 0; i &lt; counts.size(); ++i) {
-    counts[i].resize(cv_img.cols, 0);
-  }
-  point_pixel_indices.resize(num_points);
-  for (int i = 0; i &lt; num_points; ++i) {
-    int irow = -1;
-    int jcol = -1;
-    base::PointF pt = (*cloud)[i];
-    if (ff_map.Pos2d(pt.x, pt.y, &amp;irow, &amp;jcol)) {
-      cv_img.at&lt;float&gt;(irow, jcol) += pt.z;
-      counts[irow][jcol] += 1;
-      point_pixel_indices[i].irow = irow;
-      point_pixel_indices[i].jcol = jcol;
-    } else {
-      point_pixel_indices[i].irow = -1;
-      point_pixel_indices[i].jcol = -1;
-    }
-  }
-  for (int i = 0; i &lt; cv_img.rows; ++i) {
-    for (int j = 0; j &lt; cv_img.cols; ++j) {
-      if (counts[i][j] &gt; 0) {
-        cv_img.at&lt;float&gt;(i, j) /= static_cast&lt;float&gt;(counts[i][j]);
-      }
-    }
-  }
-  cv::Mat cv_height_map_copy;
-  cv::GaussianBlur(cv_img, cv_height_map_copy, cv::Size(3, 3), 0, 0);
-  cv::normalize(cv_height_map_copy, cv_height_map, 0, 255, cv::NORM_MINMAX,
-                CV_8UC1);
-}
-
-void NCut::SampleByGrid(const std::vector&lt;int&gt; &amp;point_gids,
-                        MatrixXf *skeleton_coords_in,
-                        MatrixXf *skeleton_feature_in) {
-  MatrixXf &amp;skeleton_coords = *skeleton_coords_in;
-  MatrixXf &amp;skeleton_feature = *skeleton_feature_in;
-  FloodFill sampler(_grid_radius, _skeleton_cell_size);
-  base::PointFCloudPtr pc = base::PointFCloudPtr(
-      new base::PointFCloud(*_cloud_obstacles, point_gids));
-  sampler.BuildGrid(pc);
-  std::unordered_map&lt;int, std::pair&lt;base::PointF, float&gt;&gt; centroids;
-  const std::vector&lt;int&gt; &amp;point_idx = sampler.GetPointIdxInGrid();
-  std::unordered_map&lt;int, std::pair&lt;base::PointF, float&gt;&gt;::iterator it;
-  for (size_t i = 0; i &lt; point_idx.size(); ++i) {
-    it = centroids.find(point_idx[i]);
-    if (it != centroids.end()) {
-      it-&gt;second.first.x += (*pc)[i].x;
-      it-&gt;second.first.y += (*pc)[i].y;
-      it-&gt;second.first.z += (*pc)[i].z;
-      it-&gt;second.second += 1.f;
-    } else {
-      centroids[point_idx[i]] = std::make_pair((*pc)[i], 1.f);
-    }
-  }
-  int num_skeletons = static_cast&lt;int&gt;(centroids.size());
-  skeleton_coords.resize(num_skeletons, 3);
-  int p = 0;
-  for (it = centroids.begin(); it != centroids.end(); ++it) {
-    skeleton_coords.coeffRef(p, 0) = it-&gt;second.first.x / it-&gt;second.second;
-    skeleton_coords.coeffRef(p, 1) = it-&gt;second.first.y / it-&gt;second.second;
-    skeleton_coords.coeffRef(p, 2) = it-&gt;second.first.z / it-&gt;second.second;
-    p++;
-  }
-  GetPatchFeature(skeleton_coords, &amp;skeleton_feature);
-}
-
-void NCut::GetPatchFeature(const MatrixXf &amp;points, MatrixXf *features_in) {
-  MatrixXf &amp;features = *features_in;
-  const int num_points = static_cast&lt;int&gt;(points.rows());
-  const int dim = _patch_size * _patch_size;
-  features.resize(num_points, dim);
-  for (int i = 0; i &lt; num_points; ++i) {
-    // .1 patch
-    int irow = 0;
-    int jcol = 0;
-    _ff_feature_grid.Pos2d(points.coeffRef(i, 0), points.coeffRef(i, 1), &amp;irow,
-                           &amp;jcol);
-    cv::Mat patch;
-    cv::Point2f pt(static_cast&lt;float&gt;(irow), static_cast&lt;float&gt;(jcol));
-    cv::getRectSubPix(_cv_feature_map, cv::Size(_patch_size, _patch_size), pt,
-                      patch);
-    // .2 maybe later i will add other features based on patch
-    // .3 add to features
-    assert(dim == patch.rows * patch.cols);
-    int p = 0;
-    for (int r = 0; r &lt; patch.rows; ++r) {
-      for (int c = 0; c &lt; patch.cols; ++c) {
-        float val = patch.at&lt;float&gt;(r, c);
-        features.coeffRef(i, p++) = static_cast&lt;float&gt;(
-            (std::isnan(val) || std::isinf(val)) ? 1.e-50 : val);
-        // features.coeffRef(i, p++) = patch.at&lt;float&gt;(r, c);
-      }
-    }
-  }
-}
-
-NCut::NcutBoundingBox NCut::ComputeClusterBoundingBox(
-    const std::vector&lt;int&gt; &amp;point_gids) {
-  // ! Note: do not perform rotation, so just some intuitive guess
-  float x_max = -std::numeric_limits&lt;float&gt;::max();
-  float y_max = -std::numeric_limits&lt;float&gt;::max();
-  float z_max = -std::numeric_limits&lt;float&gt;::max();
-  float x_min = std::numeric_limits&lt;float&gt;::max();
-  float y_min = std::numeric_limits&lt;float&gt;::max();
-  float z_min = std::numeric_limits&lt;float&gt;::max();
-  for (size_t j = 0; j &lt; point_gids.size(); ++j) {
-    int pid = point_gids[j];
-    x_min = std::min(x_min, (*_cloud_obstacles)[pid].x);
-    x_max = std::max(x_max, (*_cloud_obstacles)[pid].x);
-    y_min = std::min(y_min, (*_cloud_obstacles)[pid].y);
-    y_max = std::max(y_max, (*_cloud_obstacles)[pid].y);
-    z_min = std::min(z_min, (*_cloud_obstacles)[pid].z);
-    z_max = std::max(z_max, (*_cloud_obstacles)[pid].z);
-  }
-  NcutBoundingBox box;
-  std::get&lt;0&gt;(box) = x_min;
-  std::get&lt;1&gt;(box) = x_max;
-  std::get&lt;2&gt;(box) = y_min;
-  std::get&lt;3&gt;(box) = y_max;
-  std::get&lt;4&gt;(box) = z_min;
-  std::get&lt;5&gt;(box) = z_max;
-  return box;
-}
-
-std::string NCut::GetPcLabel(const base::PointFCloudPtr &amp;cloud) {
-  if (cloud-&gt;size() &lt; OBSTACLE_MINIMUM_NUM_POINTS) {
-    return "unknown";
-  }
-  base::PointFCloudPtr rot_cloud(new base::PointFCloud);
-  base::OrientCloud(*cloud, rot_cloud.get(), true);
-  std::string label;
-  // Eigen::VectorXf response = _classifier-&gt;classify_and_get_label(rot_cloud,
-  // &amp;label);
-  label = _classifier-&gt;GetLabel(rot_cloud);
-  // ./obstacle_detection/classifier/frame_classifier_pipeline.cpp line 466
-  if (label == "background") {
-    label = "unknown";
-  }
-  return label;
-}
-
-void NCut::NormalizedCut(float ncuts_threshold, bool use_classifier,
-                         std::vector&lt;std::vector&lt;int&gt;&gt; *segment_clusters_in,
-                         std::vector&lt;std::string&gt; *segment_labels_in) {
-  std::vector&lt;std::vector&lt;int&gt;&gt; &amp;segment_clusters = *segment_clusters_in;
-  std::vector&lt;std::string&gt; &amp;segment_labels = *segment_labels_in;
-  const int num_clusters = static_cast&lt;int&gt;(_cluster_points.size());
-  if (num_clusters &lt; 1) {
-    return;
-  }
-  if (num_clusters == 1) {
-    std::vector&lt;int&gt; tmp(1, 0);
-    segment_clusters.push_back(tmp);
-    segment_labels.push_back(_cluster_labels[0]);
-    return;
-  }
-#ifdef DEBUG_NCUT
-  LOG_DEBUG &lt;&lt; "\n+++++++++++++++++++++++++++++ input " &lt;&lt; num_clusters
-            &lt;&lt; " clusters +++++++++++++++++++++++++++\n";
-// visualize_segments_from_cluster(_cluster_points);
-#endif
-  MatrixXf weights;
-  ComputeSkeletonWeights(&amp;weights);
-  std::vector&lt;int&gt; *curr = new std::vector&lt;int&gt;(num_clusters);
-  for (int i = 0; i &lt; num_clusters; ++i) {
-    (*curr)[i] = i;
-  }
-  std::stack&lt;std::vector&lt;int&gt; *&gt; job_stack;
-  job_stack.push(curr);
-  while (!job_stack.empty()) {
-    curr = job_stack.top();
-    job_stack.pop();
-#ifdef DEBUG_NCUT
-    AINFO &lt;&lt; "curr size " &lt;&lt; curr-&gt;size();
-// visualize_cluster(curr);
-#endif
-    std::string seg_label;
-    if (curr-&gt;size() == 1) {
-      segment_clusters.push_back(*curr);
-      segment_labels.push_back(_cluster_labels[(*curr)[0]]);
-    } else if (use_classifier &amp;&amp; IsMovableObstacle(*curr, &amp;seg_label)) {
-      segment_clusters.push_back(*curr);
-      segment_labels.push_back(seg_label);
-#ifdef DEBUG_NCUT
-      std::cout &lt;&lt; "cluster: ";
-      for (size_t i = 0; i &lt; curr-&gt;size(); ++i) {
-        std::cout &lt;&lt; (*curr)[i] &lt;&lt; " ";
-      }
-      std::cout &lt;&lt; " as a segment (" &lt;&lt; seg_label &lt;&lt; ")" &lt;&lt; std::endl;
-#endif
-    } else {
-      std::vector&lt;int&gt; *seg1 = new std::vector&lt;int&gt;();
-      std::vector&lt;int&gt; *seg2 = new std::vector&lt;int&gt;();
-      MatrixXf my_weights(curr-&gt;size(), curr-&gt;size());
-      for (size_t i = 0; i &lt; curr-&gt;size(); ++i) {
-        const int ci = curr-&gt;at(i);
-        for (size_t j = 0; j &lt; curr-&gt;size(); ++j) {
-          const int cj = curr-&gt;at(j);
-          my_weights.coeffRef(i, j) = weights.coeffRef(ci, cj);
-        }
-      }
-      double cost = GetMinNcuts(my_weights, curr, seg1, seg2);
-#ifdef DEBUG_NCUT
-      AINFO &lt;&lt; "N cut cost is " &lt;&lt; cost &lt;&lt; ", seg1 size " &lt;&lt; seg1-&gt;size()
-            &lt;&lt; ", seg2 size " &lt;&lt; seg2-&gt;size();
-      if (curr-&gt;size() &lt; 50) {
-        std::cout &lt;&lt; "seg1: ";
-        for (size_t i = 0; i &lt; seg1-&gt;size(); ++i) {
-          std::cout &lt;&lt; (*seg1)[i] &lt;&lt; " ";
-        }
-        std::cout &lt;&lt; std::endl;
-        std::cout &lt;&lt; "seg2: ";
-        for (size_t i = 0; i &lt; seg2-&gt;size(); ++i) {
-          std::cout &lt;&lt; (*seg2)[i] &lt;&lt; " ";
-        }
-        std::cout &lt;&lt; std::endl;
-      }
-// visualize_graph_cut(seg1, seg2);
-#endif
-      if (cost &gt; ncuts_threshold || 0 == seg1-&gt;size() || 0 == seg2-&gt;size()) {
-        std::vector&lt;int&gt; buffer;
-        for (size_t i = 0; i &lt; curr-&gt;size(); ++i) {
-          const int cid = (*curr)[i];
-          if (_cluster_labels[cid] != "unknown") {
-#ifdef DEBUG_NCUT
-            std::cout &lt;&lt; "cluster: " &lt;&lt; cid &lt;&lt; " as a segment (hit, "
-                      &lt;&lt; _cluster_labels[cid] &lt;&lt; ")" &lt;&lt; std::endl;
-#endif
-            std::vector&lt;int&gt; tmp(1, cid);
-            segment_clusters.push_back(tmp);
-            segment_labels.push_back(_cluster_labels[cid]);
-          } else {
-            buffer.push_back(cid);
-          }
-        }
-        if (buffer.size() &gt; 0) {
-          segment_clusters.push_back(buffer);
-          segment_labels.push_back("unknown");
-        }
-#ifdef DEBUG_NCUT
-        std::cout &lt;&lt; "cluster: ";
-        for (size_t i = 0; i &lt; buffer.size(); ++i) {
-          std::cout &lt;&lt; buffer[i] &lt;&lt; " ";
-        }
-        std::cout &lt;&lt; " as a segment (hit, unknown)" &lt;&lt; std::endl;
-#endif
-        delete seg1;
-        delete seg2;
-      } else {
-        job_stack.push(seg1);
-        job_stack.push(seg2);
-      }
-    }
-#ifdef DEBUG_NCUT
-    LOG_DEBUG &lt;&lt; "============================================================="
-                 "================";
-#endif
-    delete curr;
-  }  // end of while
-#ifdef DEBUG_NCUT
-  std::cout &lt;&lt; "graph cut return segments: " &lt;&lt; std::endl;
-  for (size_t i = 0; i &lt; segment_clusters.size(); ++i) {
-    std::cout &lt;&lt; "seg " &lt;&lt; i &lt;&lt; ": ";
-    for (size_t j = 0; j &lt; segment_clusters[i].size(); ++j) {
-      std::cout &lt;&lt; segment_clusters[i][j] &lt;&lt; " ";
-    }
-    std::cout &lt;&lt; ": " &lt;&lt; segment_labels[i] &lt;&lt; std::endl;
-  }
-  LOG_DEBUG &lt;&lt; "normalized_cut: " &lt;&lt; segment_clusters.size()
-            &lt;&lt; " segments from " &lt;&lt; _cluster_points.size() &lt;&lt; " clusters";
-// visualize_segments_from_cluster(segment_clusters);
-#endif
-}
-
-void NCut::ComputeSkeletonWeights(Eigen::MatrixXf *weights_in) {
-  Eigen::MatrixXf &amp;weights = *weights_in;
-  const int num_clusters = static_cast&lt;int&gt;(_cluster_points.size());
-  const double hs2 = _sigma_space * _sigma_space;
-  const double hf2 = _sigma_feature * _sigma_feature;
-  const double radius2 = _connect_radius * _connect_radius;
-  weights.resize(num_clusters, num_clusters);
-  for (int i = 0; i &lt; num_clusters; ++i) {
-    weights.coeffRef(i, i) = 1.f;
-    for (int j = i + 1; j &lt; num_clusters; ++j) {
-      float dist_point = std::numeric_limits&lt;float&gt;::max();
-      float dist_feature = std::numeric_limits&lt;float&gt;::max();
-      ComputeSquaredSkeletonDistance(
-          _cluster_skeleton_points[i], _cluster_skeleton_features[i],
-          _cluster_skeleton_points[j], _cluster_skeleton_features[j],
-          &amp;dist_point, &amp;dist_feature);
-      if (dist_point &gt; radius2) {
-        weights.coeffRef(i, j) = 0.f;
-        weights.coeffRef(j, i) = 0.f;
-      } else {
-        weights.coeffRef(i, j) = static_cast&lt;float&gt;(exp(-dist_point / hs2) *
-                                                    exp(-dist_feature / hf2));
-        weights.coeffRef(j, i) = weights.coeffRef(i, j);
-      }
-    }
-  }
-}
-
-float NCut::GetMinNcuts(const Eigen::MatrixXf &amp;in_weights,
-                        const std::vector&lt;int&gt; *in_clusters,
-                        std::vector&lt;int&gt; *seg1, std::vector&lt;int&gt; *seg2) {
-  // .0 initialization
-  const int num_clusters = static_cast&lt;int&gt;(in_weights.rows());
-  seg1-&gt;resize(num_clusters);
-  seg2-&gt;resize(num_clusters);
-  // .1 eigen decompostion
-  Eigen::MatrixXf eigenvectors;
-  LaplacianDecomposition(in_weights, &amp;eigenvectors);
-// std::cout &lt;&lt; "\nweights: " &lt;&lt; in_weights &lt;&lt; std::endl;
-// std::cout &lt;&lt; "\neigv: " &lt;&lt; eigenvectors &lt;&lt; std::endl;
-#ifdef DEBUG_NCUT
-// std::cout &lt;&lt; "weights:\n " &lt;&lt; in_weights &lt;&lt; std::endl &lt;&lt; std::endl;
-// std::cout &lt;&lt; "eigen vectors:\n " &lt;&lt; eigenvectors &lt;&lt; std::endl &lt;&lt; std::endl;
-#endif
-  // .2 search for best split
-  const float minval = eigenvectors.col(1).minCoeff();
-  const float maxval = eigenvectors.col(1).maxCoeff();
-  const float increment = static_cast&lt;float&gt;(
-      (maxval - minval) / (static_cast&lt;float&gt;(_num_cuts) + 1.0f));
-  int num_seg1 = 0;
-  int num_seg2 = 0;
-  float opt_split = 0.0;
-  float opt_cost = std::numeric_limits&lt;float&gt;::max();
-  for (int i = 0; i &lt; _num_cuts; ++i) {
-    num_seg1 = 0;
-    num_seg2 = 0;
-    // .2.1 split
-    float split =
-        static_cast&lt;float&gt;(minval + static_cast&lt;float&gt;(i + 1) * increment);
-    for (int j = 0; j &lt; num_clusters; ++j) {
-      if (eigenvectors.coeffRef(j, 1) &gt; split) {
-        (*seg1)[num_seg1++] = j;
-      } else {
-        (*seg2)[num_seg2++] = j;
-      }
-    }
-    // .2.2 compute best normalized_cuts cost
-    double assoc1 = 0.0;
-    double assoc2 = 0.0;
-    double cut = 0.0;
-    for (int j = 0; j &lt; num_seg1; ++j) {
-      assoc1 += in_weights.row(seg1-&gt;at(j)).sum();
-    }
-    for (int j = 0; j &lt; num_seg2; ++j) {
-      assoc2 += in_weights.row(seg2-&gt;at(j)).sum();
-    }
-    for (int j = 0; j &lt; num_seg1; ++j) {
-      for (int t = 0; t &lt; num_seg2; ++t) {
-        cut += in_weights.coeffRef(seg1-&gt;at(j), seg2-&gt;at(t));
-      }
-    }
-    float cost = static_cast&lt;float&gt;(cut / assoc1 + cut / assoc2);
-#ifdef DEBUG_NCUT
-    LOG_DEBUG &lt;&lt; "seg1: " &lt;&lt; num_seg1 &lt;&lt; ", seg2: " &lt;&lt; num_seg2 &lt;&lt; ", split "
-              &lt;&lt; split &lt;&lt; ", cut " &lt;&lt; cut &lt;&lt; ", assoc1 " &lt;&lt; assoc1
-              &lt;&lt; ", assoc2 " &lt;&lt; assoc2 &lt;&lt; ", cost " &lt;&lt; cost;
-#endif
-    // .2.3 find best cost
-    if (cost &lt; opt_cost) {
-      opt_cost = cost;
-      opt_split = split;
-    }
-  }
-  // .3 split data according to best split
-  num_seg1 = 0;
-  num_seg2 = 0;
-  for (int i = 0; i &lt; num_clusters; ++i) {
-    if (eigenvectors.coeffRef(i, 1) &gt; opt_split) {
-      (*seg1)[num_seg1++] = in_clusters-&gt;at(i);
-    } else {
-      (*seg2)[num_seg2++] = in_clusters-&gt;at(i);
-    }
-  }
-  seg1-&gt;resize(num_seg1);
-  seg2-&gt;resize(num_seg2);
-  return opt_cost;
-}
-
-void NCut::LaplacianDecomposition(const Eigen::MatrixXf &amp;weights,
-                                  Eigen::MatrixXf *eigenvectors_in) {
-#ifdef DEBUG_NCUT
-// std::cout &lt;&lt; "laplacian 0:\n " &lt;&lt; weights &lt;&lt; std::endl &lt;&lt; std::endl;
-#endif
-  Eigen::MatrixXf &amp;eigenvectors = *eigenvectors_in;
-  // .1 degree matrix: D = sum(W, 2)
-  Eigen::VectorXf diag(weights.rows());
-  for (int i = 0; i &lt; weights.rows(); ++i) {
-    diag.coeffRef(i) = weights.row(i).sum();
-  }
-  // .2 graph laplacian L = D - W
-  Eigen::MatrixXf laplacian(weights.rows(), weights.cols());
-  for (int i = 0; i &lt; laplacian.rows(); ++i) {
-    for (int j = 0; j &lt; laplacian.cols(); ++j) {
-      if (i == j) {
-        laplacian.coeffRef(i, j) = diag.coeffRef(i) - weights.coeffRef(i, j);
-      } else {
-        laplacian.coeffRef(i, j) = 0.f - weights.coeffRef(i, j);
-      }
-    }
-  }
-#ifdef DEBUG_NCUT
-// std::cout &lt;&lt; "laplacian 1:\n " &lt;&lt; laplacian &lt;&lt; std::endl &lt;&lt; std::endl;
-#endif
-  // .3 D^(-1/2)
-  Eigen::VectorXf diag_halfinv(weights.rows());
-  for (int i = 0; i &lt; weights.rows(); ++i) {
-    diag_halfinv.coeffRef(i) =
-        static_cast&lt;float&gt;(1.0 / std::sqrt(diag.coeffRef(i)));
-  }
-  // .4 normalized laplacian D^(-1/2) * L * D^(-1/2)
-  for (int i = 0; i &lt; laplacian.rows(); ++i) {
-    laplacian.row(i) *= diag_halfinv.coeffRef(i);
-  }
-  for (int j = 0; j &lt; laplacian.cols(); ++j) {
-    laplacian.col(j) *= diag_halfinv.coeffRef(j);
-  }
-  // .4.2 for numerical stability, add eps to the diagonal of laplacian
-  float eps = 1e-10f;
-  for (int i = 0; i &lt; laplacian.rows(); ++i) {
-    laplacian.coeffRef(i, i) += eps;
-  }
-#ifdef DEBUG_NCUT
-// std::cout &lt;&lt; "laplacian 2:\n " &lt;&lt; laplacian &lt;&lt; std::endl &lt;&lt; std::endl;
-#endif
-  // .5 solve eigen decompostion: TODO: lanczos
-  Eigen::EigenSolver&lt;MatrixXf&gt; eig_solver(laplacian);
-#ifdef DEBUG_NCUT
-// std::cout &lt;&lt; "eigvec 1:\n " &lt;&lt; eig_solver.eigenvectors() &lt;&lt; std::endl &lt;&lt;
-// std::endl;
-#endif
-  // .6 sort eigen values
-  std::vector&lt;std::pair&lt;float, int&gt;&gt; eigval(laplacian.rows());
-  for (size_t i = 0; i &lt; eigval.size(); ++i) {
-    eigval[i] = std::make_pair(eig_solver.eigenvalues()[i].real(), i);
-  }
-  std::sort(eigval.begin(), eigval.end(), std::less&lt;std::pair&lt;float, int&gt;&gt;());
-  // .7 get sorted eigen vectors
-  eigenvectors.resize(weights.rows(), weights.cols());
-  for (int i = 0; i &lt; eigenvectors.cols(); ++i) {
-    eigenvectors.col(i) =
-        eig_solver.eigenvectors().col(eigval[i].second).real();
-  }
-  for (int i = 0; i &lt; eigenvectors.rows(); ++i) {
-    eigenvectors.row(i) *= diag_halfinv.coeffRef(i);
-  }
-}
-
-bool NCut::ComputeSquaredSkeletonDistance(const Eigen::MatrixXf &amp;in1_points,
-                                          const Eigen::MatrixXf &amp;in1_features,
-                                          const Eigen::MatrixXf &amp;in2_points,
-                                          const Eigen::MatrixXf &amp;in2_features,
-                                          float *dist_point,
-                                          float *dist_feature) {
-  if (!((in1_points.rows() == in1_features.rows()) &amp;&amp;
-        (in2_points.rows() == in2_features.rows()))) {
-    return false;
-  }
-  const int num1 = static_cast&lt;int&gt;(in1_points.rows());
-  const int num2 = static_cast&lt;int&gt;(in2_points.rows());
-  const int dim = static_cast&lt;int&gt;(in1_features.cols());
-  int min_index1 = -1;
-  int min_index2 = -1;
-  float min_dist = std::numeric_limits&lt;float&gt;::max();
-  for (int i = 0; i &lt; num1; ++i) {
-    for (int j = 0; j &lt; num2; ++j) {
-      const float diff_x =
-          in1_points.coeffRef(i, 0) - in2_points.coeffRef(j, 0);
-      const float diff_y =
-          in1_points.coeffRef(i, 1) - in2_points.coeffRef(j, 1);
-      const float diff_z =
-          in1_points.coeffRef(i, 2) - in2_points.coeffRef(j, 2);
-      float dist = diff_x * diff_x + diff_y * diff_y + diff_z * diff_z;
-      if (dist &lt; min_dist) {
-        min_dist = dist;
-        min_index1 = i;
-        min_index2 = j;
-      }
-    }
-  }
-  *dist_point = min_dist;
-  *dist_feature = 0.f;
-  for (int i = 0; i &lt; dim; ++i) {
-    float diff = in1_features.coeffRef(min_index1, i) -
-                 in2_features.coeffRef(min_index2, i);
-    *dist_feature += diff * diff;
-  }
-  return true;
-}
-
-bool NCut::IsMovableObstacle(const std::vector&lt;int&gt; &amp;cluster_ids,
-                             std::string *label) {
-  NcutBoundingBox box;
-  GetComponentBoundingBox(cluster_ids, &amp;box);
-  float dummy_length = GetBboxLength(box);
-  float dummy_width = GetBboxWidth(box);
-  float length = std::max(dummy_length, dummy_width);
-  float width = std::min(dummy_length, dummy_width);
-  if (IsPotentialPedestrianSize(length, width) ||
-      IsPotentialBicyclistSize(length, width) ||
-      IsPotentialCarSize(length, width)) {
-    *label = GetClustersLabel(cluster_ids);
-    if (*label != "unknown" || *label != "background") {
-      return true;
-    }
-  }
-  return false;
-}
-
-std::string NCut::GetClustersLabel(const std::vector&lt;int&gt; &amp;cluster_ids) {
-  std::vector&lt;int&gt; point_ids;
-  GetClustersPids(cluster_ids, &amp;point_ids);
-  base::PointFCloudPtr cloud =
-      base::PointFCloudPtr(new base::PointFCloud(*_cloud_obstacles, point_ids));
-  return GetPcLabel(cloud);
-}
-
-void NCut::GetClustersPids(const std::vector&lt;int&gt; &amp;cids,
-                           std::vector&lt;int&gt; *pids_in) {
-  std::vector&lt;int&gt; &amp;pids = *pids_in;
-  int num_points = 0;
-  for (size_t i = 0; i &lt; cids.size(); ++i) {
-    num_points += static_cast&lt;int&gt;(_cluster_points[cids[i]].size());
-  }
-  pids.resize(num_points, -1);
-  int offset = 0;
-  for (size_t i = 0; i &lt; cids.size(); ++i) {
-    const std::vector&lt;int&gt; &amp;curr_pids = _cluster_points[cids[i]];
-    memcpy(pids.data() + offset, curr_pids.data(),
-           sizeof(int) * curr_pids.size());
-    offset += static_cast&lt;int&gt;(curr_pids.size());
-  }
-}
-
-int NCut::GetComponentBoundingBox(const std::vector&lt;int&gt; &amp;cluster_ids,
-                                  NcutBoundingBox *box_in) {
-  NcutBoundingBox &amp;box = *box_in;
-  if (cluster_ids.empty()) {
-    return 0;
-  }
-  int cid = cluster_ids[0];
-  float x_min = std::get&lt;0&gt;(_cluster_bounding_box[cid]);
-  float x_max = std::get&lt;1&gt;(_cluster_bounding_box[cid]);
-  float y_min = std::get&lt;2&gt;(_cluster_bounding_box[cid]);
-  float y_max = std::get&lt;3&gt;(_cluster_bounding_box[cid]);
-  float z_min = std::get&lt;4&gt;(_cluster_bounding_box[cid]);
-  float z_max = std::get&lt;5&gt;(_cluster_bounding_box[cid]);
-  int num_points = static_cast&lt;int&gt;(_cluster_points[cid].size());
-  for (size_t i = 1; i &lt; cluster_ids.size(); ++i) {
-    cid = cluster_ids[i];
-    x_min = std::min(x_min, std::get&lt;0&gt;(_cluster_bounding_box[cid]));
-    x_max = std::max(x_max, std::get&lt;1&gt;(_cluster_bounding_box[cid]));
-    y_min = std::min(y_min, std::get&lt;2&gt;(_cluster_bounding_box[cid]));
-    y_max = std::max(y_max, std::get&lt;3&gt;(_cluster_bounding_box[cid]));
-    z_min = std::min(y_min, std::get&lt;4&gt;(_cluster_bounding_box[cid]));
-    z_max = std::max(y_max, std::get&lt;5&gt;(_cluster_bounding_box[cid]));
-    num_points += static_cast&lt;int&gt;(_cluster_points[cid].size());
-  }
-  std::get&lt;0&gt;(box) = x_min;
-  std::get&lt;1&gt;(box) = x_max;
-  std::get&lt;2&gt;(box) = y_min;
-  std::get&lt;3&gt;(box) = y_max;
-  std::get&lt;4&gt;(box) = z_min;
-  std::get&lt;5&gt;(box) = z_max;
-  return num_points;
-}
-
-std::string NCut::GetPcRoughLabel(const base::PointFCloudPtr &amp;cloud,
-                                  bool only_check_pedestrian) {
-  if (cloud-&gt;size() &lt; OBSTACLE_MINIMUM_NUM_POINTS) {
-    return "unknown";
-  }
-  float x_max = -std::numeric_limits&lt;float&gt;::max();
-  float y_max = -std::numeric_limits&lt;float&gt;::max();
-  float x_min = std::numeric_limits&lt;float&gt;::max();
-  float y_min = std::numeric_limits&lt;float&gt;::max();
-  for (size_t i = 0; i &lt; cloud-&gt;size(); ++i) {
-    base::PointF pt = (*cloud)[i];
-    x_min = std::min(x_min, pt.x);
-    x_max = std::max(x_max, pt.x);
-    y_min = std::min(y_min, pt.y);
-    y_max = std::max(y_max, pt.y);
-  }
-  float dummy_length = x_max - x_min;
-  float dummy_width = y_max - y_min;
-  float length = std::max(dummy_length, dummy_width);
-  float width = std::min(dummy_length, dummy_width);
-  std::string label = "unknown";
-  bool is_candidate = false;
-  if (only_check_pedestrian) {
-    if (IsPotentialPedestrianSize(length, width) ||
-        IsPotentialBicyclistSize(length, width)) {
-      is_candidate = true;
-    }
-  } else {
-    if (IsPotentialPedestrianSize(length, width) ||
-        IsPotentialBicyclistSize(length, width) ||
-        IsPotentialCarSize(length, width)) {
-      is_candidate = true;
-    }
-  }
-  if (is_candidate) {
-    label = GetPcLabel(cloud);
-  }
-  return label;
-}
-
-void NCut::GetSegmentRoughSize(const base::PointFCloudPtr &amp;cloud, float *length,
-                               float *width, float *height) {
-  float x_max = -std::numeric_limits&lt;float&gt;::max();
-  float y_max = -std::numeric_limits&lt;float&gt;::max();
-  float z_max = -std::numeric_limits&lt;float&gt;::max();
-  float x_min = std::numeric_limits&lt;float&gt;::max();
-  float y_min = std::numeric_limits&lt;float&gt;::max();
-  float z_min = std::numeric_limits&lt;float&gt;::max();
-  for (size_t i = 0; i &lt; cloud-&gt;size(); ++i) {
-    base::PointF pt = (*cloud)[i];
-    x_min = std::min(x_min, pt.x);
-    x_max = std::max(x_max, pt.x);
-    y_min = std::min(y_min, pt.y);
-    y_max = std::max(y_max, pt.y);
-    z_min = std::min(z_min, pt.z);
-    z_max = std::max(z_max, pt.z);
-  }
-  *length = (x_max - x_min);
-  *width = (y_max - y_min);
-  *height = (z_max - z_min);
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\ncut.h" new_path="" added_lines="0" deleted_lines="198">
				<diff>@@ -1,198 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;cmath&gt;
-#include &lt;cstdlib&gt;
-#include &lt;iostream&gt;
-#include &lt;map&gt;
-#include &lt;memory&gt;
-#include &lt;string&gt;
-#include &lt;tuple&gt;
-#include &lt;vector&gt;
-
-#include &lt;opencv2/opencv.hpp&gt;
-#include "Eigen/Core"
-
-#include "modules/perception/lidar/lib/segmentation/ncut/common/flood_fill.h"
-#include "modules/perception/lidar/lib/segmentation/ncut/common/lr_classifier.h"
-#include "modules/perception/lidar/lib/segmentation/ncut/proto/ncut_config.pb.h"
-#include "modules/perception/lidar/lib/segmentation/ncut/proto/ncut_param.pb.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class NCut {
- public:
-  NCut();
-  ~NCut();
-  bool Init(const NCutParam&amp; param);
-
-  int NumSegments() const { return static_cast&lt;int&gt;(_segment_pids.size()); }
-  std::string GetSegmentLabel(int sid) const { return _segment_labels[sid]; }
-
-  void GetSegmentSize(int sid, float* length, float* width,
-                      float* height) const {
-    NcutBoundingBox box = _segment_bbox[sid];
-    *length = std::get&lt;1&gt;(box) - std::get&lt;0&gt;(box);
-    *width = std::get&lt;3&gt;(box) - std::get&lt;2&gt;(box);
-    *height = std::get&lt;5&gt;(box) - std::get&lt;4&gt;(box);
-  }
-
-  base::PointFCloudPtr GetSegmentPointCloud(int sid) const {
-    base::PointFCloudPtr pc = base::PointFCloudPtr(
-        new base::PointFCloud(*_cloud_obstacles, _segment_pids[sid]));
-    return pc;
-  }
-
-  void Segment(base::PointFCloudConstPtr cloud);
-
-  std::string GetPcRoughLabel(const base::PointFCloudPtr&amp; cloud,
-                              bool only_check_pedestrian);
-
-  void GetSegmentRoughSize(const base::PointFCloudPtr&amp; cloud, float* length,
-                           float* width, float* height);
-
- private:
-  struct gridIndex {
-    int irow;
-    int jcol;
-  };
-
-  // x_min, x_max, y_min, y_max, z_min, z_max;
-  typedef std::tuple&lt;float, float, float, float, float, float&gt; NcutBoundingBox;
-  base::PointFCloudPtr _cloud_obstacles;
-  // super pixels related
-  float _grid_radius;
-  float _super_pixel_cell_size;
-  std::unique_ptr&lt;LRClassifier&gt; _classifier;
-  // felzenszwalb
-  double _felzenszwalb_sigma;
-  double _felzenszwalb_k;
-  int _felzenszwalb_min_size;
-  // graph cut related
-  double _sigma_feature;
-  double _sigma_space;
-  double _connect_radius;
-  int _num_cuts;
-  float _ncuts_stop_threshold;
-  double _ncuts_enable_classifier_threshold;
-  // component (cluster) information
-  std::vector&lt;std::vector&lt;int&gt;&gt; _cluster_points;
-  // x_min, x_max, y_min, y_max, z_min, z_max;
-  std::vector&lt;NcutBoundingBox&gt; _cluster_bounding_box;
-  std::vector&lt;std::string&gt; _cluster_labels;
-  // skeleton related
-  float _skeleton_cell_size;  // skeleton sample size
-  int _patch_size;
-  cv::Mat _cv_feature_map;
-  FloodFill _ff_feature_grid;
-  std::vector&lt;Eigen::MatrixXf&gt; _cluster_skeleton_points;
-  std::vector&lt;Eigen::MatrixXf&gt; _cluster_skeleton_features;
-  // merge overlap
-  double _overlap_factor;
-  // final segments, each vector contains
-  std::vector&lt;std::vector&lt;int&gt;&gt; _segment_pids;
-  std::vector&lt;std::string&gt; _segment_labels;
-  std::vector&lt;NcutBoundingBox&gt; _segment_bbox;
-  std::vector&lt;std::vector&lt;int&gt;&gt; _outlier_pids;
-
-  void SampleByGrid(const std::vector&lt;int&gt;&amp; point_gids,
-                    Eigen::MatrixXf* skeleton_coords,
-                    Eigen::MatrixXf* skeleton_feature);
-
-  void PrecomputeAllSkeletonAndBbox();
-
-  bool Configure(const NCutParam&amp; ncut_param_);
-
-  void SuperPixelsFloodFill(base::PointFCloudConstPtr cloud, float radius,
-                            float cell_size,
-                            std::vector&lt;std::vector&lt;int&gt;&gt;* super_pixels);
-
-  // super pixels
-  void BuildAverageHeightMap(base::PointFCloudConstPtr cloud,
-                             const FloodFill&amp; ff_map, cv::Mat* cv_height_map,
-                             std::vector&lt;gridIndex&gt;* point_pixel_indices);
-
-  // skeleton
-  void GetPatchFeature(const Eigen::MatrixXf&amp; points,
-                       Eigen::MatrixXf* features);
-
-  // bounding box
-  NcutBoundingBox ComputeClusterBoundingBox(const std::vector&lt;int&gt;&amp; point_gids);
-
-  std::string GetPcLabel(const base::PointFCloudPtr&amp; cloud);
-
-  void NormalizedCut(float ncuts_threshold, bool use_classifier,
-                     std::vector&lt;std::vector&lt;int&gt;&gt;* segment_clusters,
-                     std::vector&lt;std::string&gt;* segment_labels);
-
-  void ComputeSkeletonWeights(Eigen::MatrixXf* weights);
-
-  float GetMinNcuts(const Eigen::MatrixXf&amp; in_weights,
-                    const std::vector&lt;int&gt;* in_clusters, std::vector&lt;int&gt;* seg1,
-                    std::vector&lt;int&gt;* seg2);
-
-  void LaplacianDecomposition(const Eigen::MatrixXf&amp; weights,
-                              Eigen::MatrixXf* eigenvectors);
-
-  bool ComputeSquaredSkeletonDistance(const Eigen::MatrixXf&amp; in1_points,
-                                      const Eigen::MatrixXf&amp; in1_features,
-                                      const Eigen::MatrixXf&amp; in2_points,
-                                      const Eigen::MatrixXf&amp; in2_features,
-                                      float* dist_point, float* dist_feature);
-
-  bool IsMovableObstacle(const std::vector&lt;int&gt;&amp; cluster_ids,
-                         std::string* label);
-
-  inline bool IsPotentialPedestrianSize(float length, float width) {
-    return ((length &gt; 0.5 &amp;&amp; length &lt; 1.5) &amp;&amp; (width &gt; 0.3 &amp;&amp; width &lt; 1));
-  }
-
-  inline bool IsPotentialBicyclistSize(float length, float width) {
-    return ((length &gt; 1 &amp;&amp; length &lt; 2.5) &amp;&amp; (width &gt; 0.3 &amp;&amp; width &lt; 1.5));
-  }
-
-  inline bool IsPotentialCarSize(float length, float width) {
-    // return ( (length &gt; 1.0 &amp;&amp; length &lt; 20.0) &amp;&amp; (width &gt; 1.0 &amp;&amp; width &lt; 3.5)
-    // );
-    return ((length &gt; 1.0 &amp;&amp; length &lt; 8.0) &amp;&amp; (width &gt; 1.0 &amp;&amp; width &lt; 3.5));
-  }
-
-  int GetComponentBoundingBox(const std::vector&lt;int&gt;&amp; cluster_ids,
-                              NcutBoundingBox* box);
-
-  inline float GetBboxLength(const NcutBoundingBox&amp; box) {
-    return (std::get&lt;1&gt;(box) - std::get&lt;0&gt;(box));
-  }
-
-  inline float GetBboxWidth(const NcutBoundingBox&amp; box) {
-    return (std::get&lt;3&gt;(box) - std::get&lt;2&gt;(box));
-  }
-
-  inline float GetBboxHeight(const NcutBoundingBox&amp; box) {
-    return (std::get&lt;5&gt;(box) - std::get&lt;4&gt;(box));
-  }
-
-  std::string GetClustersLabel(const std::vector&lt;int&gt;&amp; cluster_ids);
-
-  void GetClustersPids(const std::vector&lt;int&gt;&amp; cids, std::vector&lt;int&gt;* pids);
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\ncut_segmentation.cc" new_path="" added_lines="0" deleted_lines="638">
				<diff>@@ -1,638 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-#include "modules/perception/lidar/lib/segmentation/ncut/ncut_segmentation.h"
-
-#include &lt;algorithm&gt;
-#include &lt;limits&gt;
-#include &lt;map&gt;
-
-#include &lt;omp.h&gt;
-
-#include "cyber/common/file.h"
-#include "cyber/common/log.h"
-#include "modules/perception/lib/config_manager/config_manager.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-using apollo::cyber::common::GetAbsolutePath;
-using apollo::cyber::common::GetProtoFromFile;
-using Eigen::MatrixXf;
-
-bool NCutSegmentation::Init(const LidarDetectorInitOptions&amp; options) {
-  std::string param_file;
-  ACHECK(GetConfigs(&amp;param_file));
-  AINFO &lt;&lt; "--    param_file: " &lt;&lt; param_file;
-
-  if (!Configure(param_file)) {
-    AERROR &lt;&lt; "failed to load ncut config.";
-    return false;
-  }
-
-  // init ground detector
-  ground_detector_ =
-      BaseGroundDetectorRegisterer::GetInstanceByName(ground_detector_str_);
-  CHECK_NOTNULL(ground_detector_);
-  GroundDetectorInitOptions ground_detector_init_options;
-  ACHECK(ground_detector_-&gt;Init(ground_detector_init_options))
-      &lt;&lt; "Failed to init ground detection.";
-
-  // init roi filter
-  roi_filter_ = BaseROIFilterRegisterer::GetInstanceByName(roi_filter_str_);
-  CHECK_NOTNULL(roi_filter_);
-  ROIFilterInitOptions roi_filter_init_options;
-  ACHECK(roi_filter_-&gt;Init(roi_filter_init_options))
-      &lt;&lt; "Failed to init roi filter.";
-
-  _outliers.reset(new std::vector&lt;ObjectPtr&gt;);
-  if (!_outliers) {
-    AERROR &lt;&lt; "Failed to reset outliers.";
-    return false;
-  }
-  int num_threads = 1;
-#pragma omp parallel
-  { num_threads = omp_get_num_threads(); }
-
-  AINFO &lt;&lt; "number threads " &lt;&lt; num_threads;
-  _segmentors.resize(num_threads);
-  for (int i = 0; i &lt; num_threads; ++i) {
-    _segmentors[i].reset(new NCut);
-    if (!(_segmentors[i]-&gt;Init(ncut_param_))) {
-      AERROR &lt;&lt; "failed to init NormalizedCut " &lt;&lt; i &lt;&lt; ".";
-      return false;
-    }
-  }
-
-  roi_cloud_ = base::PointFCloudPool::Instance().Get();
-  roi_world_cloud_ = base::PointDCloudPool::Instance().Get();
-
-  // init thread worker
-  worker_.Bind([&amp;]() {
-    ROIFilterOptions roi_filter_options;
-    if (lidar_frame_ref_-&gt;hdmap_struct != nullptr &amp;&amp;
-        roi_filter_-&gt;Filter(roi_filter_options, lidar_frame_ref_)) {
-      roi_cloud_-&gt;CopyPointCloud(*lidar_frame_ref_-&gt;cloud,
-                                 lidar_frame_ref_-&gt;roi_indices);
-      roi_world_cloud_-&gt;CopyPointCloud(*lidar_frame_ref_-&gt;world_cloud,
-                                       lidar_frame_ref_-&gt;roi_indices);
-    } else {
-      AINFO &lt;&lt; "Fail to call roi filter, use origin cloud.";
-      lidar_frame_ref_-&gt;roi_indices.indices.resize(original_cloud_-&gt;size());
-      // we manually fill roi indices with all cloud point indices
-      std::iota(lidar_frame_ref_-&gt;roi_indices.indices.begin(),
-                lidar_frame_ref_-&gt;roi_indices.indices.end(), 0);
-      // note roi cloud's memory should be kept here
-      *roi_cloud_ = *original_cloud_;
-      *roi_world_cloud_ = *original_world_cloud_;
-    }
-    lidar_frame_ref_-&gt;cloud = roi_cloud_;
-    lidar_frame_ref_-&gt;world_cloud = roi_world_cloud_;
-    AINFO &lt;&lt; "lidar 2 world pose " &lt;&lt; lidar_frame_ref_-&gt;lidar2world_pose(0, 3)
-          &lt;&lt; " " &lt;&lt; lidar_frame_ref_-&gt;lidar2world_pose(1, 3) &lt;&lt; " "
-          &lt;&lt; lidar_frame_ref_-&gt;lidar2world_pose(2, 3);
-    GroundDetectorOptions ground_detector_options;
-    ground_detector_-&gt;Detect(ground_detector_options, lidar_frame_ref_);
-    return true;
-  });
-
-  worker_.Start();
-
-#ifdef DEBUG_NCUT
-  _viewer = pcl::visualization::PCLVisualizer::Ptr(
-      new pcl::visualization::PCLVisualizer("3D Viewer"));
-  _viewer-&gt;setBackgroundColor(0, 0, 0);
-  _viewer-&gt;addCoordinateSystem(1.0);
-  _viewer-&gt;initCameraParameters();
-  _viewer_count = 0;
-  _rgb_cloud = CPointCloudPtr(new CPointCloud);
-#endif
-
-  AINFO &lt;&lt; "NCutSegmentation init success, num_threads: " &lt;&lt; num_threads;
-  return true;
-}
-
-bool NCutSegmentation::Configure(std::string param_file) {
-  NCutSegmentationParam seg_param_;
-  // get cnnseg params
-  ACHECK(GetProtoFromFile(param_file, &amp;seg_param_))
-      &lt;&lt; "Failed to parse CNNSegParam config file." &lt;&lt; param_file;
-  grid_radius_ = seg_param_.grid_radius();
-  height_threshold_ = seg_param_.height_threshold();
-  partition_cell_size_ = seg_param_.partition_cell_size();
-  vehicle_filter_cell_size_ = seg_param_.vehicle_filter_cell_size();
-  pedestrian_filter_cell_size_ = seg_param_.pedestrian_filter_cell_size();
-  outlier_length_ = seg_param_.outlier_length();
-  outlier_width_ = seg_param_.outlier_width();
-  outlier_height_ = seg_param_.outlier_height();
-  outlier_min_num_points_ = seg_param_.outlier_min_num_points();
-  remove_ground_ = seg_param_.remove_ground_points();
-  remove_roi_ = seg_param_.remove_roi();
-  ground_detector_str_ = seg_param_.ground_detector();
-  roi_filter_str_ = seg_param_.roi_filter();
-  ncut_param_ = seg_param_.ncut_param();
-  do_classification_ = seg_param_.do_classification();
-  AINFO &lt;&lt; "NCut Segmentation " &lt;&lt; seg_param_.DebugString();
-  return true;
-}
-
-bool NCutSegmentation::GetConfigs(std::string* param_file) {
-  auto config_manager = lib::ConfigManager::Instance();
-  const lib::ModelConfig* model_config = nullptr;
-  ACHECK(config_manager-&gt;GetModelConfig("NCutSegmentation", &amp;model_config))
-      &lt;&lt; "Failed to get model config: CNNSegmentation";
-
-  const std::string&amp; work_root = config_manager-&gt;work_root();
-  std::string root_path;
-  ACHECK(model_config-&gt;get_value("root_path", &amp;root_path))
-      &lt;&lt; "Failed to get value of root_path.";
-  std::string config_file;
-  config_file = GetAbsolutePath(work_root, root_path);
-  config_file = GetAbsolutePath(config_file, "ncut.conf");
-
-  NCutConfig config;
-  ACHECK(apollo::cyber::common::GetProtoFromFile(config_file, &amp;config))
-      &lt;&lt; "Failed to parse CNNSeg config file";
-  *param_file = GetAbsolutePath(work_root, config.param_file());
-  return true;
-}
-
-bool NCutSegmentation::Detect(const LidarDetectorOptions&amp; options,
-                               LidarFrame* frame) {
-  // check input
-  if (frame == nullptr) {
-    AERROR &lt;&lt; "Input null frame ptr.";
-    return false;
-  }
-  if (frame-&gt;cloud == nullptr) {
-    AERROR &lt;&lt; "Input null frame cloud.";
-    return false;
-  }
-  if (frame-&gt;world_cloud == nullptr) {
-    AERROR &lt;&lt; "Input null frame world cloud.";
-    return false;
-  }
-  if (frame-&gt;cloud-&gt;size() == 0) {
-    AERROR &lt;&lt; "Input none points.";
-    return false;
-  }
-  if (frame-&gt;cloud-&gt;size() != frame-&gt;world_cloud-&gt;size()) {
-    AERROR &lt;&lt; "Cloud size and world cloud size not consistent.";
-    return false;
-  }
-
-  // record input cloud and lidar frame
-  original_cloud_ = frame-&gt;cloud;
-  original_world_cloud_ = frame-&gt;world_cloud;
-  lidar_frame_ref_ = frame;
-
-  std::vector&lt;base::ObjectPtr&gt;* segments = &amp;(frame-&gt;segmented_objects);
-  double start_t = omp_get_wtime();
-  int num_threads = 1;
-#pragma omp parallel
-  { num_threads = omp_get_num_threads(); }
-
-  AINFO &lt;&lt; "input point cloud: " &lt;&lt; original_cloud_-&gt;size() &lt;&lt; " points";
-#ifdef DEBUG_NCUT
-  VisualizePointCloud(original_cloud_);
-#endif
-
-  if (remove_roi_) {
-    AINFO &lt;&lt; "remove roi and remove ground for ncut segmentation";
-    worker_.WakeUp();
-    worker_.Join();
-  }
-
-  base::PointFCloudPtr cloud_above_ground(new base::PointFCloud);
-  if (remove_ground_) {
-    AINFO &lt;&lt; "remove ground";
-    cloud_above_ground-&gt;CopyPointCloud(*lidar_frame_ref_-&gt;cloud,
-                                       lidar_frame_ref_-&gt;non_ground_indices);
-  } else {
-    // if used as secondary segmentor, got from cloud directly
-    cloud_above_ground-&gt;CopyPointCloud(*lidar_frame_ref_-&gt;cloud,
-                                       lidar_frame_ref_-&gt;secondary_indices);
-  }
-
-#ifdef DEBUG_NCUT
-  // filter_by_ground(cloud, non_ground_indices, &amp;cloud_above_ground);
-  AINFO &lt;&lt; "filter ground, elapsed time: " &lt;&lt; omp_get_wtime() - start_t
-        &lt;&lt; cloud_above_ground-&gt;size() &lt;&lt; " points left";
-  start_t = omp_get_wtime();
-  VisualizePointCloud(cloud_above_ground);
-#endif
-
-  // .3 filter vehicle
-  base::PointFCloudPtr cloud_after_car_filter;
-  ObstacleFilter(cloud_above_ground, vehicle_filter_cell_size_, false,
-                 &amp;cloud_after_car_filter, segments);
-#ifdef DEBUG_NCUT
-  AINFO &lt;&lt; "filter vehicle, elapsed time: " &lt;&lt; omp_get_wtime() - start_t
-        &lt;&lt; "filter vehicle: " &lt;&lt; cloud_after_car_filter-&gt;size()
-        &lt;&lt; " points left";
-  start_t = omp_get_wtime();
-  VisualizePointCloud(cloud_after_car_filter);
-#endif
-
-  // .4 filter pedestrian
-  base::PointFCloudPtr cloud_after_people_filter;
-  ObstacleFilter(cloud_after_car_filter, pedestrian_filter_cell_size_, true,
-                 &amp;cloud_after_people_filter, segments);
-
-#ifdef DEBUG_NCUT
-  AINFO &lt;&lt; "filter pedestrian, elapsed time: " &lt;&lt; omp_get_wtime() - start_t;
-  start_t = omp_get_wtime();
-  AINFO &lt;&lt; "filter pedestrian: " &lt;&lt; cloud_after_people_filter-&gt;size()
-        &lt;&lt; " points left";
-  VisualizePointCloud(cloud_after_people_filter);
-  AINFO &lt;&lt; "after filter car/pedestrian #segments " &lt;&lt; segments-&gt;size();
-// VisualizeSegments(*segments);
-#endif
-
-  // .5 partition into small regions
-  std::vector&lt;base::PointFCloudPtr&gt; cloud_components;
-  PartitionConnectedComponents(cloud_after_people_filter, partition_cell_size_,
-                               &amp;cloud_components);
-
-#ifdef DEBUG_NCUT
-  AINFO &lt;&lt; "partition small regions, elapsed time: "
-        &lt;&lt; omp_get_wtime() - start_t;
-  start_t = omp_get_wtime();
-  AINFO &lt;&lt; "partition " &lt;&lt; cloud_components.size() &lt;&lt; " components";
-#endif
-
-  std::vector&lt;bool&gt; cloud_outlier_flag(cloud_components.size());
-
-#pragma omp parallel
-  {
-#pragma omp for
-    for (size_t i = 0; i &lt; cloud_components.size(); ++i) {
-      cloud_outlier_flag[i] = IsOutlier(cloud_components[i]);
-    }
-  }
-
-  std::vector&lt;int&gt; cloud_outlier;
-  std::vector&lt;int&gt; cloud_tbd;
-  for (int i = 0; i &lt; static_cast&lt;int&gt;(cloud_components.size()); ++i) {
-    if (cloud_outlier_flag[i]) {
-      cloud_outlier.push_back(i);
-    } else {
-      cloud_tbd.push_back(i);
-    }
-  }
-
-  // .5.1 outlier
-  for (size_t i = 0; i &lt; cloud_outlier.size(); ++i) {
-    base::PointFCloudPtr pc = cloud_components[cloud_outlier[i]];
-    base::ObjectPtr obj(new base::Object);
-    obj-&gt;lidar_supplement.cloud = *pc;
-    _outliers-&gt;push_back(obj);
-  }
-#ifdef DEBUG_NCUT
-  AINFO &lt;&lt; "filter outlier, elapsed time: " &lt;&lt; omp_get_wtime() - start_t;
-  start_t = omp_get_wtime();
-#endif
-  // .6 graph cut each
-  std::vector&lt;std::vector&lt;base::PointFCloudPtr&gt;&gt; threads_segment_pcs(
-      num_threads);
-  std::vector&lt;std::vector&lt;std::string&gt;&gt; threads_segment_labels(num_threads);
-  std::vector&lt;std::vector&lt;base::PointFCloudPtr&gt;&gt; threads_outlier_pcs(
-      num_threads);
-// .6.1 process each component in parallel
-#pragma omp parallel
-  {
-    int tid = omp_get_thread_num();
-    std::shared_ptr&lt;NCut&gt; my_ncut = _segmentors[tid];
-    std::vector&lt;base::PointFCloudPtr&gt;&amp; my_segment_pcs =
-        threads_segment_pcs[tid];
-    std::vector&lt;std::string&gt;&amp; my_segment_labels = threads_segment_labels[tid];
-    std::vector&lt;base::PointFCloudPtr&gt;&amp; my_outlier_pcs =
-        threads_outlier_pcs[tid];
-
-#pragma omp for schedule(guided)
-    for (size_t i = 0; i &lt; cloud_tbd.size(); ++i) {
-      my_ncut-&gt;Segment(cloud_components[cloud_tbd[i]]);
-      ADEBUG &lt;&lt; "after segment with num segments" &lt;&lt; my_ncut-&gt;NumSegments();
-      for (int j = 0; j &lt; my_ncut-&gt;NumSegments(); ++j) {
-        base::PointFCloudPtr pc = my_ncut-&gt;GetSegmentPointCloud(j);
-        std::string label = my_ncut-&gt;GetSegmentLabel(j);
-        if (IsOutlier(pc)) {
-          my_outlier_pcs.push_back(pc);
-        } else {
-          my_segment_pcs.push_back(pc);
-          my_segment_labels.push_back(label);
-        }
-      }
-    }
-  }
-#ifdef DEBUG_NCUT
-  ADEBUG &lt;&lt; "parallel normalized cut, elapsed time: "
-         &lt;&lt; omp_get_wtime() - start_t;
-  start_t = omp_get_wtime();
-#endif
-  // .6.2 aggregate results
-  std::vector&lt;int&gt; segment_offset(num_threads,
-                                  static_cast&lt;int&gt;(segments-&gt;size()));
-  for (int i = 1; i &lt; num_threads; ++i) {
-    segment_offset[i] = segment_offset[i - 1] +
-                        static_cast&lt;int&gt;(threads_segment_pcs[i - 1].size());
-  }
-  int new_num_segments =
-      static_cast&lt;int&gt;(threads_segment_pcs[num_threads - 1].size()) +
-      segment_offset[num_threads - 1];
-  segments-&gt;resize(new_num_segments);
-#pragma omp parallel for
-  for (int i = 0; i &lt; num_threads; ++i) {
-    int offset = segment_offset[i];
-    for (size_t j = 0; j &lt; threads_segment_pcs[i].size(); ++j) {
-      base::ObjectPtr&amp; obj_ptr = (*segments)[offset + j];
-      obj_ptr.reset(new base::Object());
-      obj_ptr-&gt;lidar_supplement.cloud = *threads_segment_pcs[i][j];
-
-      if (do_classification_) {
-        obj_ptr-&gt;type = Label2Type(threads_segment_labels[i][j]);
-      }
-    }
-  }
-  std::vector&lt;int&gt; outlier_offset(num_threads,
-                                  static_cast&lt;int&gt;(_outliers-&gt;size()));
-  for (int i = 1; i &lt; num_threads; ++i) {
-    outlier_offset[i] = outlier_offset[i - 1] +
-                        static_cast&lt;int&gt;(threads_outlier_pcs[i - 1].size());
-  }
-  int new_num_outliers =
-      static_cast&lt;int&gt;(threads_outlier_pcs[num_threads - 1].size()) +
-      outlier_offset[num_threads - 1];
-  _outliers-&gt;resize(new_num_outliers);
-#pragma omp parallel for
-  for (int i = 0; i &lt; num_threads; ++i) {
-    int offset = outlier_offset[i];
-    for (size_t j = 0; j &lt; threads_outlier_pcs[i].size(); ++j) {
-      base::ObjectPtr&amp; obj_ptr = (*_outliers)[offset + j];
-      obj_ptr.reset(new base::Object);
-      obj_ptr-&gt;lidar_supplement.cloud = *threads_outlier_pcs[i][j];
-    }
-  }
-  AINFO &lt;&lt; "aggregate results, elapsed time: " &lt;&lt; omp_get_wtime() - start_t;
-  AINFO &lt;&lt; "final #segments " &lt;&lt; segments-&gt;size();
-  AINFO &lt;&lt; "final #outliers " &lt;&lt; _outliers-&gt;size();
-
-#ifdef DEBUG_NCUT
-  VisualizeSegments(*segments);
-  VisualizeSegments(*_outliers);
-#endif
-
-  return true;
-}
-
-base::ObjectType NCutSegmentation::Label2Type(const std::string&amp; label) {
-  if (label == "unknown") {
-    return base::ObjectType::UNKNOWN;
-  }
-  if (label == "nonMot") {
-    return base::ObjectType::BICYCLE;
-  }
-  if (label == "pedestrian") {
-    return base::ObjectType::PEDESTRIAN;
-  }
-  if (label == "smallMot") {
-    return base::ObjectType::VEHICLE;
-  }
-  return base::ObjectType::UNKNOWN;
-}
-
-void NCutSegmentation::PartitionConnectedComponents(
-    const base::PointFCloudPtr&amp; in_cloud, float cell_size,
-    std::vector&lt;base::PointFCloudPtr&gt;* out_clouds) {
-  std::vector&lt;base::PointFCloudPtr&gt;&amp; temp_clouds = *out_clouds;
-  FloodFill FFfilter(grid_radius_, cell_size);
-  std::vector&lt;std::vector&lt;int&gt;&gt; component_points;
-  std::vector&lt;int&gt; num_cells_per_components;
-  FFfilter.GetSegments(in_cloud, &amp;component_points, &amp;num_cells_per_components);
-  temp_clouds.resize(component_points.size());
-  for (size_t i = 0; i &lt; component_points.size(); ++i) {
-    temp_clouds[i] = base::PointFCloudPtr(
-        new base::PointFCloud(*in_cloud, component_points[i]));
-  }
-}
-
-void NCutSegmentation::ObstacleFilter(const base::PointFCloudPtr&amp; in_cloud,
-                                      float cell_size,
-                                      bool filter_pedestrian_only,
-                                      base::PointFCloudPtr* out_cloud,
-                                      std::vector&lt;base::ObjectPtr&gt;* segments) {
-  FloodFill FFfilter(grid_radius_, cell_size);
-  std::vector&lt;std::vector&lt;int&gt;&gt; component_points;
-  std::vector&lt;int&gt; num_cells_per_components;
-  FFfilter.GetSegments(in_cloud, &amp;component_points, &amp;num_cells_per_components);
-
-#ifdef DEBUG_NCUT
-  AINFO &lt;&lt; "flood fill: " &lt;&lt; component_points.size() &lt;&lt; " components";
-// VisualizeComponents(in_cloud, component_points);
-#endif
-
-  const unsigned int min_num_points = 50;
-  const int num_components = static_cast&lt;int&gt;(component_points.size());
-  std::vector&lt;std::string&gt; component_labels(num_components, "unknown");
-  int tid = 0;
-  for (int i = 0; i &lt; num_components; ++i) {
-    if (component_points[i].size() &gt; min_num_points) {
-      base::PointFCloudPtr pc = base::PointFCloudPtr(
-          new base::PointFCloud(*in_cloud, component_points[i]));
-      std::string label =
-          _segmentors[tid]-&gt;GetPcRoughLabel(pc, filter_pedestrian_only);
-      AINFO &lt;&lt; "before: component id: " &lt;&lt; i &lt;&lt; ", label: " &lt;&lt; label;
-      if (filter_pedestrian_only) {
-        label =
-            (label == "pedestrian" || label == "nonMot") ? label : "unknown";
-      }
-      AINFO &lt;&lt; "after: component id: " &lt;&lt; i &lt;&lt; ", label: " &lt;&lt; label;
-      component_labels[i] = label;
-    }
-  }  // end of for
-
-  AINFO &lt;&lt; "classification done";
-  std::vector&lt;int&gt; remaining_pids;
-  std::vector&lt;int&gt; obstacle_components;
-  for (int i = 0; i &lt; num_components; ++i) {
-    if (component_labels[i] != "unknown") {
-      obstacle_components.push_back(i);
-    } else {
-      remaining_pids.insert(remaining_pids.begin(), component_points[i].begin(),
-                            component_points[i].end());
-    }
-  }
-  AINFO &lt;&lt; "obstacle_filter: filter unknown out, obstacle_components.size = "
-        &lt;&lt; obstacle_components.size()
-        &lt;&lt; ", remaining_pids.size = " &lt;&lt; remaining_pids.size();
-  int offset = static_cast&lt;int&gt;(segments-&gt;size());
-  segments-&gt;resize(offset + obstacle_components.size());
-  for (size_t i = 0; i &lt; obstacle_components.size(); ++i) {
-    int cid = obstacle_components[i];
-    ObjectPtr&amp; object_ptr = (*segments)[offset + i];
-    object_ptr.reset(new base::Object);
-    object_ptr-&gt;lidar_supplement.cloud.CopyPointCloud(*in_cloud,
-                                                      component_points[cid]);
-  }
-  *out_cloud =
-      base::PointFCloudPtr(new base::PointFCloud(*in_cloud, remaining_pids));
-}
-
-bool NCutSegmentation::IsOutlier(const base::PointFCloudPtr&amp; in_cloud) {
-  size_t min_num_points = std::max(outlier_min_num_points_, 1);
-  if (in_cloud-&gt;size() &lt; min_num_points) {
-    return true;
-  }
-  float x_max = -std::numeric_limits&lt;float&gt;::max();
-  float y_max = -std::numeric_limits&lt;float&gt;::max();
-  float z_max = -std::numeric_limits&lt;float&gt;::max();
-  float x_min = std::numeric_limits&lt;float&gt;::max();
-  float y_min = std::numeric_limits&lt;float&gt;::max();
-  float z_min = std::numeric_limits&lt;float&gt;::max();
-  base::PointF pt_max = (*in_cloud)[0];
-  for (size_t i = 0; i &lt; in_cloud-&gt;size(); ++i) {
-    const base::PointF&amp; pt = (*in_cloud)[i];
-    x_min = std::min(x_min, pt.x);
-    x_max = std::max(x_max, pt.x);
-    y_min = std::min(y_min, pt.y);
-    y_max = std::max(y_max, pt.y);
-    z_min = std::min(z_min, pt.z);
-    if (pt.z &gt; z_max) {
-      z_max = pt.z;
-      pt_max = pt;
-    }
-  }
-  float length = x_max - x_min;
-  float width = y_max - y_min;
-  float height = z_max - z_min;
-  if (length &lt; outlier_length_ &amp;&amp; width &lt; outlier_width_) {
-    return true;
-  }
-  if (height &lt; outlier_height_) {
-    return true;
-  }
-  // std::pair&lt;float, bool&gt; dist = _ground_detector.distance_to_ground(pt_max);
-  // if (dist.second &amp;&amp; dist.first &lt; _outlier_height) {
-  //    return true;
-  //}
-  return false;
-}
-
-#ifdef DEBUG_NCUT
-void NCutSegmentation::VisualizePointCloud(const base::PointFCloudPtr&amp; cloud) {
-  // _viewer-&gt;removePointCloud(_viewer_id, 0);
-  _viewer-&gt;removeAllPointClouds(0);
-  _viewer-&gt;removeAllShapes(0);
-  _rgb_cloud-&gt;clear();
-  for (size_t i = 0; i &lt; cloud-&gt;size(); ++i) {
-    CPoint pt;
-    pt.x = (*cloud)[i].x;
-    pt.y = (*cloud)[i].y;
-    pt.z = (*cloud)[i].z;
-    pt.r = 255;
-    pt.g = 255;
-    pt.b = 255;
-    _rgb_cloud-&gt;push_back(pt);
-  }
-  snprintf(_viewer_id, sizeof(_viewer_id), "vis%06d", _viewer_count++);
-  _viewer-&gt;addPointCloud(_rgb_cloud, _viewer_id, 0);
-  _viewer-&gt;spin();
-}
-
-void NCutSegmentation::VisualizeSegments(
-    const std::vector&lt;base::ObjectPtr&gt;&amp; segments) {
-  // _viewer-&gt;removePointCloud(_viewer_id, 0);
-  unsigned int seed;
-  _viewer-&gt;removeAllPointClouds(0);
-  _viewer-&gt;removeAllShapes(0);
-  _rgb_cloud-&gt;clear();
-  for (size_t i = 0; i &lt; segments.size(); ++i) {
-    int red = 50 + rand_r(&amp;seed) % 206;
-    int green = 50 + rand_r(&amp;seed) % 206;
-    int blue = 50 + rand_r(&amp;seed) % 206;
-    const base::PointFCloud&amp; pc = segments[i]-&gt;lidar_supplement.cloud;
-    for (size_t j = 0; j &lt; pc.size(); ++j) {
-      CPoint pt;
-      pt.x = pc[j].x;
-      pt.y = pc[j].y;
-      pt.z = pc[j].z;
-      pt.r = static_cast&lt;uint8_t&gt;(red);
-      pt.g = static_cast&lt;uint8_t&gt;(green);
-      pt.b = static_cast&lt;uint8_t&gt;(blue);
-      _rgb_cloud-&gt;push_back(pt);
-    }
-  }
-  snprintf(_viewer_id, sizeof(_viewer_id), "vis%06d", _viewer_count++);
-  _viewer-&gt;addPointCloud(_rgb_cloud, _viewer_id, 0);
-  _viewer-&gt;spin();
-}
-
-void NCutSegmentation::VisualizeComponents(
-    const base::PointFCloudPtr&amp; cloud,
-    const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; component_points) {
-  // _viewer-&gt;removePointCloud(_viewer_id, 0);
-  unsigned int seed;
-  _viewer-&gt;removeAllPointClouds(0);
-  _viewer-&gt;removeAllShapes(0);
-  _rgb_cloud-&gt;clear();
-  std::vector&lt;CPoint&gt; centers(component_points.size());
-  for (size_t i = 0; i &lt; component_points.size(); ++i) {
-    int red = 50 + rand_r(&amp;seed) % 206;
-    int green = 50 + rand_r(&amp;seed) % 206;
-    int blue = 50 + rand_r(&amp;seed) % 206;
-    const int num_points = static_cast&lt;int&gt;(component_points[i].size());
-    CPoint center;
-    center.x = 0.f;
-    center.y = 0.f;
-    center.z = 0.f;
-    for (size_t j = 0; j &lt; component_points[i].size(); ++j) {
-      CPoint pt;
-      int pid = component_points[i][j];
-      pt.x = (*cloud)[pid].x;
-      pt.y = (*cloud)[pid].y;
-      pt.z = (*cloud)[pid].z;
-      pt.r = static_cast&lt;uint8_t&gt;(red);
-      pt.g = static_cast&lt;uint8_t&gt;(green);
-      pt.b = static_cast&lt;uint8_t&gt;(blue);
-      _rgb_cloud-&gt;push_back(pt);
-      center.x += pt.x;
-      center.y += pt.y;
-      center.z += pt.z;
-    }
-    center.x /= static_cast&lt;float&gt;(num_points);
-    center.y /= static_cast&lt;float&gt;(num_points);
-    center.z /= static_cast&lt;float&gt;(num_points);
-    centers[i] = center;
-  }
-  snprintf(_viewer_id, sizeof(_viewer_id), "vis%06d", _viewer_count++);
-  _viewer-&gt;addPointCloud(_rgb_cloud, _viewer_id, 0);
-  for (size_t i = 0; i &lt; component_points.size(); ++i) {
-    char text[256];
-    char text_id[256];
-    snprintf(text, sizeof(text), "%zu", i);
-    snprintf(text_id, sizeof(text_id), "c%zu", i);
-    _viewer-&gt;addText3D(text, centers[i], 0.3, 1.0, 1.0, 1.0, text_id, 0);
-  }
-  _viewer-&gt;spin();
-}
-#endif
-
-PERCEPTION_REGISTER_LIDARDETECTOR(NCutSegmentation);
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\ncut_segmentation.h" new_path="" added_lines="0" deleted_lines="125">
				<diff>@@ -1,125 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;memory&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#ifdef DEBUG_NCUT
-#include "pcl/visualization/pcl_visualizer.h"
-#endif
-
-#include "modules/perception/base/object.h"
-#include "modules/perception/lib/thread/thread_worker.h"
-#include "modules/perception/lidar/common/pcl_util.h"
-#include "modules/perception/lidar/lib/interface/base_ground_detector.h"
-#include "modules/perception/lidar/lib/interface/base_roi_filter.h"
-#include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
-#include "modules/perception/lidar/lib/segmentation/ncut/ncut.h"
-#include "modules/perception/lidar/lib/segmentation/ncut/proto/ncut_param.pb.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-using base::ObjectPtr;
-
-class NCutSegmentation : public BaseLidarDetector {
- public:
-  NCutSegmentation() = default;
-  virtual ~NCutSegmentation() = default;
-
-  bool Init(const LidarDetectorInitOptions&amp; options =
-                LidarDetectorInitOptions()) override;
-
-  bool Detect(const LidarDetectorOptions&amp; options, LidarFrame* frame) override;
-
-  std::string Name() const override { return "NCutSegmentation"; }
-
-  void ByPassROIService() {
-    remove_roi_ = false;
-    remove_ground_ = false;
-  }
-
- private:
-  bool Configure(std::string model_name);
-
-  void PartitionConnectedComponents(
-      const base::PointFCloudPtr&amp; in_cloud, float cell_size,
-      std::vector&lt;base::PointFCloudPtr&gt;* out_clouds);
-
-  void ObstacleFilter(const base::PointFCloudPtr&amp; in_cloud, float cell_size,
-                      bool filter_pedestrian_only,
-                      base::PointFCloudPtr* out_cloud,
-                      std::vector&lt;base::ObjectPtr&gt;* segments);
-
-  bool IsOutlier(const base::PointFCloudPtr&amp; in_cloud);
-
-  bool GetConfigs(std::string* ncut_file);
-
-  base::ObjectType Label2Type(const std::string&amp; label);
-
-  // ground detector for background segmentation
-  BaseGroundDetector* ground_detector_;
-  // roi filter for background segmentation
-  BaseROIFilter* roi_filter_;
-
-  // reference pointer of lidar frame
-  LidarFrame* lidar_frame_ref_ = nullptr;
-  std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointF&gt;&gt; original_cloud_;
-  std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointD&gt;&gt;
-      original_world_cloud_;
-  std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointF&gt;&gt; roi_cloud_;
-  std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointD&gt;&gt; roi_world_cloud_;
-  // thread worker
-  lib::ThreadWorker worker_;
-
-  std::vector&lt;std::shared_ptr&lt;NCut&gt;&gt; _segmentors;
-  // for outliers, must be "unknown"
-  std::unique_ptr&lt;std::vector&lt;ObjectPtr&gt;&gt; _outliers;
-  float grid_radius_ = 100.0f;
-  float height_threshold_ = 2.5f;
-  float partition_cell_size_ = 1.0f;
-  float vehicle_filter_cell_size_ = 1.0f;
-  float pedestrian_filter_cell_size_ = 0.05f;
-  float outlier_length_ = 0.3f;
-  float outlier_width_ = 0.3f;
-  float outlier_height_ = 0.3f;
-  int outlier_min_num_points_ = 10;
-  bool remove_ground_ = true;
-  bool remove_roi_ = true;
-  bool do_classification_ = true;
-  std::string ground_detector_str_;
-  std::string roi_filter_str_;
-  NCutParam ncut_param_;
-
-#ifdef DEBUG_NCUT
-  pcl::visualization::PCLVisualizer::Ptr _viewer;
-  CPointCloudPtr _rgb_cloud;
-  char _viewer_id[128];
-  int _viewer_count;
-  void VisualizePointCloud(const base::PointFCloudPtr&amp; cloud);
-  void VisualizeSegments(const std::vector&lt;base::ObjectPtr&gt;&amp; segments);
-  void VisualizeComponents(
-      const base::PointFCloudPtr&amp; cloud,
-      const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; component_points);
-#endif
-};  // class NCutSegmentation
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne128\lidar_obstacle_detection.conf" new_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne128\lidar_obstacle_detection.conf" added_lines="1" deleted_lines="1">
				<diff>@@ -1,4 +1,4 @@
 preprocessor: "PointCloudPreprocessor"
-detector: "PointPillarsDetection"
+detector: "CNNSegmentation"
 use_map_manager: true
 use_object_filter_bank: true
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4066e68ffc34320999b711fa793c8432a01608f4" author="haina0421">
		<msg>Solve CI problems according to code standard</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\app\lidar_app_lidar_pipeline_test.cc" new_path="modules\perception\lidar\app\lidar_app_lidar_pipeline_test.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -17,7 +17,7 @@
 
 #include "modules/perception/common/io/io_util.h"
 #include "modules/perception/common/perception_gflags.h"
-#include "modules/perception/lidar/app/lidar_obstacle_segmentation.h"
+#include "modules/perception/lidar/app/lidar_obstacle_detection.h"
 #include "modules/perception/lidar/app/lidar_obstacle_tracking.h"
 #include "modules/perception/lidar/common/lidar_error_code.h"
 // #include "modules/perception/lidar/common/pcl_util.h"
@@ -42,7 +42,7 @@ class LidarAppPipelineTest : public testing::Test {
 
   void TearDown() {}
 
-  LidarObstacleSegmentation segmentation_;
+  LidarObstacleDetection segmentation_;
   LidarObstacleTracking tracking_;
 };  // class DecisionForestClassifierTest
 
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" new_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" added_lines="7" deleted_lines="4">
				<diff>@@ -62,12 +62,14 @@ bool LidarObstacleDetection::Init(
   }
 
   BasePointCloudPreprocessor* preprocessor =
-      BasePointCloudPreprocessorRegisterer::GetInstanceByName(config.preprocessor());
+      BasePointCloudPreprocessorRegisterer::
+      GetInstanceByName(config.preprocessor());
   CHECK_NOTNULL(preprocessor);
   cloud_preprocessor_.reset(preprocessor);
   PointCloudPreprocessorInitOptions preprocessor_init_options;
   preprocessor_init_options.sensor_name = sensor_name;
-  ACHECK(cloud_preprocessor_-&gt;Init(preprocessor_init_options)) &lt;&lt; "lidar preprocessor init error";
+  ACHECK(cloud_preprocessor_-&gt;Init(preprocessor_init_options)) &lt;&lt;
+                            "lidar preprocessor init error";
 
   BaseLidarDetector* detector =
       BaseLidarDetectorRegisterer::GetInstanceByName(config.detector());
@@ -75,9 +77,10 @@ bool LidarObstacleDetection::Init(
   detector_.reset(detector);
   LidarDetectorInitOptions detection_init_options;
   detection_init_options.sensor_name = sensor_name;
-  ACHECK(detector_-&gt;Init(detection_init_options)) &lt;&lt; "lidar detector init error";
+  ACHECK(detector_-&gt;Init(detection_init_options)) &lt;&lt;
+                            "lidar detector init error";
 
-  if(use_object_builder_) {
+  if (use_object_builder_) {
     ObjectBuilderInitOptions builder_init_options;
     ACHECK(builder_.Init(builder_init_options));
   }
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.h" new_path="modules\perception\lidar\app\lidar_obstacle_detection.h" added_lines="1" deleted_lines="0">
				<diff>@@ -15,6 +15,7 @@
  *****************************************************************************/
 #pragma once
 
+#include &lt;string&gt;
 #include &lt;memory&gt;
 
 #include "modules/perception/lidar/lib/interface/base_lidar_obstacle_detection.h"
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_tracking.cc" new_path="modules\perception\lidar\app\lidar_obstacle_tracking.cc" added_lines="6" deleted_lines="3">
				<diff>@@ -45,18 +45,21 @@ bool LidarObstacleTracking::Init(
   ACHECK(cyber::common::GetProtoFromFile(config_file, &amp;config));
 
   BaseMultiTargetTracker* multi_target_tracker =
-      BaseMultiTargetTrackerRegisterer::GetInstanceByName(config.multi_target_tracker());
+      BaseMultiTargetTrackerRegisterer::
+      GetInstanceByName(config.multi_target_tracker());
   CHECK_NOTNULL(multi_target_tracker);
   multi_target_tracker_.reset(multi_target_tracker);
   MultiTargetTrackerInitOptions tracker_init_options;
-  ACHECK(multi_target_tracker_-&gt;Init(tracker_init_options)) &lt;&lt; "lidar multi_target_tracker init error";
+  ACHECK(multi_target_tracker_-&gt;Init(tracker_init_options)) &lt;&lt;
+                              "lidar multi_target_tracker init error";
 
   BaseClassifier* fusion_classifier =
       BaseClassifierRegisterer::GetInstanceByName(config.fusion_classifier());
   CHECK_NOTNULL(fusion_classifier);
   fusion_classifier_.reset(fusion_classifier);
   ClassifierInitOptions fusion_classifier_init_options;
-  ACHECK(fusion_classifier_-&gt;Init(fusion_classifier_init_options)) &lt;&lt; "lidar classifier init error";
+  ACHECK(fusion_classifier_-&gt;Init(fusion_classifier_init_options)) &lt;&lt;
+                              "lidar classifier init error";
   return true;
 }
 
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detector\point_pillars_detection\point_pillars_detection.h" new_path="modules\perception\lidar\lib\detector\point_pillars_detection\point_pillars_detection.h" added_lines="2" deleted_lines="1">
				<diff>@@ -38,7 +38,8 @@ class PointPillarsDetection : public BaseLidarDetector {
   PointPillarsDetection();
   virtual ~PointPillarsDetection() = default;
 
-  bool Init(const LidarDetectorInitOptions&amp; options = LidarDetectorInitOptions()) override;
+  bool Init(const LidarDetectorInitOptions&amp; options =
+                LidarDetectorInitOptions()) override;
 
   bool Detect(const LidarDetectorOptions&amp; options, LidarFrame* frame) override;
 
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\interface\base_lidar_obstacle_detection.h" new_path="modules\perception\lidar\lib\interface\base_lidar_obstacle_detection.h" added_lines="6" deleted_lines="4">
				<diff>@@ -47,16 +47,18 @@ class BaseLidarObstacleDetection {
   BaseLidarObstacleDetection() = default;
   virtual ~BaseLidarObstacleDetection() = default;
 
-  virtual bool Init(const LidarObstacleDetectionInitOptions&amp; options =
-                LidarObstacleDetectionInitOptions()) = 0;
+  virtual bool Init(
+      const LidarObstacleDetectionInitOptions&amp; options =
+      LidarObstacleDetectionInitOptions()) = 0;
 
   virtual LidarProcessResult Process(
       const LidarObstacleDetectionOptions&amp; options,
       const std::shared_ptr&lt;apollo::drivers::PointCloud const&gt;&amp; message,
       LidarFrame* frame) = 0;
 
-  virtual LidarProcessResult Process(const LidarObstacleDetectionOptions&amp; options,
-                             LidarFrame* frame) = 0;
+  virtual LidarProcessResult Process(
+      const LidarObstacleDetectionOptions&amp; options,
+      LidarFrame* frame) = 0;
 
   virtual std::string Name() const = 0;
 
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\interface\base_lidar_obstacle_tracking.h" new_path="modules\perception\lidar\lib\interface\base_lidar_obstacle_tracking.h" added_lines="7" deleted_lines="5">
				<diff>@@ -40,16 +40,18 @@ class BaseLidarObstacleTracking {
   BaseLidarObstacleTracking() = default;
   virtual ~BaseLidarObstacleTracking() = default;
 
-  virtual bool Init(const LidarObstacleTrackingInitOptions&amp; options =
-                LidarObstacleTrackingInitOptions()) = 0;
+  virtual bool Init(
+            const LidarObstacleTrackingInitOptions&amp; options =
+            LidarObstacleTrackingInitOptions()) = 0;
 
-  virtual LidarProcessResult Process(const LidarObstacleTrackingOptions&amp; options,
-                             LidarFrame* frame) = 0;
+  virtual LidarProcessResult Process(
+            const LidarObstacleTrackingOptions&amp; options,
+            LidarFrame* frame) = 0;
 
   virtual std::string Name() const  = 0;
 
  private:
- DISALLOW_COPY_AND_ASSIGN(BaseLidarObstacleTracking);
+  DISALLOW_COPY_AND_ASSIGN(BaseLidarObstacleTracking);
 };  // class BaseLidarObstacleTracking
 
 PERCEPTION_REGISTER_REGISTERER(BaseLidarObstacleTracking);
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\interface\base_pointcloud_preprocessor.h" new_path="modules\perception\lidar\lib\interface\base_pointcloud_preprocessor.h" added_lines="1" deleted_lines="0">
				<diff>@@ -16,6 +16,7 @@
 #pragma once
 
 #include &lt;string&gt;
+#include &lt;memory&gt;
 
 #include "cyber/common/macros.h"
 #include "modules/perception/lib/registerer/registerer.h"
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\pointcloud_preprocessor\pointcloud_preprocessor.h" new_path="modules\perception\lidar\lib\pointcloud_preprocessor\pointcloud_preprocessor.h" added_lines="1" deleted_lines="0">
				<diff>@@ -15,6 +15,7 @@
  *****************************************************************************/
 #pragma once
 
+#include &lt;string&gt;
 #include &lt;memory&gt;
 
 #include "modules/perception/lidar/lib/interface/base_pointcloud_preprocessor.h"
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="363543440fda73a7a541e12adc83907018bc19d1" author="haina0421">
		<msg>add base_pointcloud_preprocessor and re-write inheritance methods</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" new_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" added_lines="7" deleted_lines="4">
				<diff>@@ -43,11 +43,14 @@ bool LidarObstacleDetection::Init(
 
   LidarObstacleDetectionConfig config;
   ACHECK(cyber::common::GetProtoFromFile(config_file, &amp;config));
-  detector_name_ = config.detector();
 
+  BasePointCloudPreprocessor* preprocessor =
+      BasePointCloudPreprocessorRegisterer::GetInstanceByName(config.preprocessor());
+  CHECK_NOTNULL(preprocessor);
+  cloud_preprocessor_.reset(preprocessor);
   PointCloudPreprocessorInitOptions preprocessor_init_options;
   preprocessor_init_options.sensor_name = sensor_name;
-  ACHECK(cloud_preprocessor_.Init(preprocessor_init_options));
+  ACHECK(cloud_preprocessor_-&gt;Init(preprocessor_init_options)) &lt;&lt; "lidar preprocessor init error";
 
   detector_.reset(new PointPillarsDetection);
   // detector_.reset(
@@ -65,7 +68,7 @@ LidarProcessResult LidarObstacleDetection::Process(
   PointCloudPreprocessorOptions preprocessor_options;
   preprocessor_options.sensor2novatel_extrinsics =
       options.sensor2novatel_extrinsics;
-  if (cloud_preprocessor_.Preprocess(preprocessor_options, frame)) {
+  if (cloud_preprocessor_-&gt;Preprocess(preprocessor_options, frame)) {
     return ProcessCommon(options, frame);
   }
   return LidarProcessResult(LidarErrorCode::PointCloudPreprocessorError,
@@ -85,7 +88,7 @@ LidarProcessResult LidarObstacleDetection::Process(
   preprocessor_options.sensor2novatel_extrinsics =
       options.sensor2novatel_extrinsics;
   PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "preprocess");
-  if (cloud_preprocessor_.Preprocess(preprocessor_options, message, frame)) {
+  if (cloud_preprocessor_-&gt;Preprocess(preprocessor_options, message, frame)) {
     return ProcessCommon(options, frame);
   }
   return LidarProcessResult(LidarErrorCode::PointCloudPreprocessorError,
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.h" new_path="modules\perception\lidar\app\lidar_obstacle_detection.h" added_lines="3" deleted_lines="5">
				<diff>@@ -22,7 +22,7 @@
 
 #include "modules/perception/lidar/common/lidar_error_code.h"
 #include "modules/perception/lidar/lib/detection/lidar_point_pillars/point_pillars_detection.h"
-#include "modules/perception/lidar/lib/pointcloud_preprocessor/pointcloud_preprocessor.h"
+#include "modules/perception/lidar/lib/interface/base_pointcloud_preprocessor.h"
 
 namespace apollo {
 namespace perception {
@@ -62,10 +62,8 @@ class LidarObstacleDetection {
                                    LidarFrame* frame);
 
  private:
-  PointCloudPreprocessor cloud_preprocessor_;
-  std::unique_ptr&lt;PointPillarsDetection&gt; detector_;
-  // params
-  std::string detector_name_;
+  std::shared_ptr&lt;BasePointCloudPreprocessor&gt; cloud_preprocessor_;
+  std::shared_ptr&lt;PointPillarsDetection&gt; detector_;
 };  // class LidarObstacleDetection
 
 }  // namespace lidar
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" new_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" added_lines="15" deleted_lines="10">
				<diff>@@ -44,7 +44,6 @@ bool LidarObstacleSegmentation::Init(
 
   LidarObstacleSegmentationConfig config;
   ACHECK(cyber::common::GetProtoFromFile(config_file, &amp;config));
-  segmentor_name_ = config.segmentor();
   use_map_manager_ = config.use_map_manager();
   use_object_filter_bank_ = config.use_object_filter_bank();
 
@@ -53,10 +52,6 @@ bool LidarObstacleSegmentation::Init(
   SceneManagerInitOptions scene_manager_init_options;
   ACHECK(SceneManager::Instance().Init(scene_manager_init_options));
 
-  PointCloudPreprocessorInitOptions preprocessor_init_options;
-  preprocessor_init_options.sensor_name = sensor_name;
-  ACHECK(cloud_preprocessor_.Init(preprocessor_init_options));
-
   if (use_map_manager_) {
     MapManagerInitOptions map_manager_init_options;
     if (!map_manager_.Init(map_manager_init_options)) {
@@ -65,11 +60,21 @@ bool LidarObstacleSegmentation::Init(
     }
   }
 
-  segmentor_ = BaseSegmentationRegisterer::GetInstanceByName(segmentor_name_);
-  CHECK_NOTNULL(segmentor_);
+  BasePointCloudPreprocessor* preprocessor =
+      BasePointCloudPreprocessorRegisterer::GetInstanceByName(config.preprocessor());
+  CHECK_NOTNULL(preprocessor);
+  cloud_preprocessor_.reset(preprocessor);
+  PointCloudPreprocessorInitOptions preprocessor_init_options;
+  preprocessor_init_options.sensor_name = sensor_name;
+  ACHECK(cloud_preprocessor_-&gt;Init(preprocessor_init_options)) &lt;&lt; "lidar preprocessor init error";
+
+  BaseSegmentation* segmentor =
+      BaseSegmentationRegisterer::GetInstanceByName(config.segmentor());
+  CHECK_NOTNULL(segmentor);
+  segmentor_.reset(segmentor);
   SegmentationInitOptions segmentation_init_options;
   segmentation_init_options.sensor_name = sensor_name;
-  ACHECK(segmentor_-&gt;Init(segmentation_init_options));
+  ACHECK(segmentor_-&gt;Init(segmentation_init_options)) &lt;&lt; "lidar segmentor init error";
 
   ObjectBuilderInitOptions builder_init_options;
   ACHECK(builder_.Init(builder_init_options));
@@ -88,7 +93,7 @@ LidarProcessResult LidarObstacleSegmentation::Process(
   PointCloudPreprocessorOptions preprocessor_options;
   preprocessor_options.sensor2novatel_extrinsics =
       options.sensor2novatel_extrinsics;
-  if (cloud_preprocessor_.Preprocess(preprocessor_options, frame)) {
+  if (cloud_preprocessor_-&gt;Preprocess(preprocessor_options, frame)) {
     return ProcessCommon(options, frame);
   }
   return LidarProcessResult(LidarErrorCode::PointCloudPreprocessorError,
@@ -108,7 +113,7 @@ LidarProcessResult LidarObstacleSegmentation::Process(
   preprocessor_options.sensor2novatel_extrinsics =
       options.sensor2novatel_extrinsics;
   PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "preprocess");
-  if (cloud_preprocessor_.Preprocess(preprocessor_options, message, frame)) {
+  if (cloud_preprocessor_-&gt;Preprocess(preprocessor_options, message, frame)) {
     return ProcessCommon(options, frame);
   }
   return LidarProcessResult(LidarErrorCode::PointCloudPreprocessorError,
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.h" new_path="modules\perception\lidar\app\lidar_obstacle_segmentation.h" added_lines="3" deleted_lines="4">
				<diff>@@ -26,7 +26,7 @@
 #include "modules/perception/lidar/lib/map_manager/map_manager.h"
 #include "modules/perception/lidar/lib/object_builder/object_builder.h"
 #include "modules/perception/lidar/lib/object_filter_bank/object_filter_bank.h"
-#include "modules/perception/lidar/lib/pointcloud_preprocessor/pointcloud_preprocessor.h"
+#include "modules/perception/lidar/lib/interface/base_pointcloud_preprocessor.h"
 
 namespace apollo {
 namespace perception {
@@ -67,13 +67,12 @@ class LidarObstacleSegmentation {
       const LidarObstacleSegmentationOptions&amp; options, LidarFrame* frame);
 
  private:
-  PointCloudPreprocessor cloud_preprocessor_;
+  std::shared_ptr&lt;BasePointCloudPreprocessor&gt; cloud_preprocessor_;
   MapManager map_manager_;
-  BaseSegmentation* segmentor_;
+  std::shared_ptr&lt;BaseSegmentation&gt; segmentor_;
   ObjectBuilder builder_;
   ObjectFilterBank filter_bank_;
   // params
-  std::string segmentor_name_;
   bool use_map_manager_ = true;
   bool use_object_filter_bank_ = true;
 };  // class LidarObstacleSegmentation
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\pointcloud_preprocessor\pointcloud_preprocessor.h" new_path="modules\perception\lidar\lib\pointcloud_preprocessor\pointcloud_preprocessor.h" added_lines="6" deleted_lines="26">
				<diff>@@ -16,51 +16,31 @@
 #pragma once
 
 #include &lt;memory&gt;
-#include &lt;string&gt;
 
-#include "modules/drivers/proto/pointcloud.pb.h"
-#include "modules/perception/lidar/common/lidar_frame.h"
+#include "modules/perception/lidar/lib/interface/base_pointcloud_preprocessor.h"
 
 namespace apollo {
 namespace perception {
 namespace lidar {
 
-struct PointCloudPreprocessorInitOptions {
-  std::string sensor_name = "velodyne64";
-};
-
-struct PointCloudPreprocessorOptions {
-  Eigen::Affine3d sensor2novatel_extrinsics;
-
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-} EIGEN_ALIGN16;
-
-class PointCloudPreprocessor {
+class PointCloudPreprocessor : public BasePointCloudPreprocessor {
  public:
   PointCloudPreprocessor() = default;
 
   ~PointCloudPreprocessor() = default;
 
   bool Init(const PointCloudPreprocessorInitOptions&amp; options =
-                PointCloudPreprocessorInitOptions());
+                PointCloudPreprocessorInitOptions()) override;
 
-  // @brief: preprocess point cloud
-  // @param [in]: options
-  // @param [in]: point cloud message
-  // @param [in/out]: frame
-  // cloud should be filled, required,
   bool Preprocess(
       const PointCloudPreprocessorOptions&amp; options,
       const std::shared_ptr&lt;apollo::drivers::PointCloud const&gt;&amp; message,
-      LidarFrame* frame) const;
+      LidarFrame* frame) const override;
 
-  // @brief: preprocess point cloud
-  // @param [in/out]: frame
-  // cloud should be filled, required,
   bool Preprocess(const PointCloudPreprocessorOptions&amp; options,
-                  LidarFrame* frame) const;
+                  LidarFrame* frame) const override;
 
-  std::string Name() const { return "PointCloudPreprocessor"; }
+  std::string Name() const override { return "PointCloudPreprocessor"; }
 
  private:
   bool TransformCloud(const base::PointFCloudPtr&amp; local_cloud,
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a671923672ad65242e8a30b87e579b57a32523fc" author="haina0421">
		<msg>add base_lidar_detector, remove base_segmentation and update inheritance</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" new_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" added_lines="8" deleted_lines="8">
				<diff>@@ -52,13 +52,13 @@ bool LidarObstacleDetection::Init(
   preprocessor_init_options.sensor_name = sensor_name;
   ACHECK(cloud_preprocessor_-&gt;Init(preprocessor_init_options)) &lt;&lt; "lidar preprocessor init error";
 
-  detector_.reset(new PointPillarsDetection);
-  // detector_.reset(
-  //    BaseSegmentationRegisterer::GetInstanceByName(segmentor_name_));
-  CHECK_NOTNULL(detector_.get());
-  DetectionInitOptions detection_init_options;
-  // segmentation_init_options.sensor_name = sensor_name;
-  ACHECK(detector_-&gt;Init(detection_init_options));
+  BaseLidarDetector* detector =
+      BaseLidarDetectorRegisterer::GetInstanceByName(config.detector());
+  CHECK_NOTNULL(detector);
+  detector_.reset(detector);
+  LidarDetectorInitOptions detection_init_options;
+  detection_init_options.sensor_name = sensor_name;
+  ACHECK(detector_-&gt;Init(detection_init_options)) &lt;&lt; "lidar detector init error";
 
   return true;
 }
@@ -100,7 +100,7 @@ LidarProcessResult LidarObstacleDetection::ProcessCommon(
   const auto&amp; sensor_name = options.sensor_name;
 
   PERF_BLOCK_START();
-  DetectionOptions detection_options;
+  LidarDetectorOptions detection_options;
   if (!detector_-&gt;Detect(detection_options, frame)) {
     return LidarProcessResult(LidarErrorCode::DetectionError,
                               "Failed to detect.");
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.h" new_path="modules\perception\lidar\app\lidar_obstacle_detection.h" added_lines="2" deleted_lines="2">
				<diff>@@ -21,8 +21,8 @@
 #include "Eigen/Dense"
 
 #include "modules/perception/lidar/common/lidar_error_code.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/point_pillars_detection.h"
 #include "modules/perception/lidar/lib/interface/base_pointcloud_preprocessor.h"
+#include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
 
 namespace apollo {
 namespace perception {
@@ -63,7 +63,7 @@ class LidarObstacleDetection {
 
  private:
   std::shared_ptr&lt;BasePointCloudPreprocessor&gt; cloud_preprocessor_;
-  std::shared_ptr&lt;PointPillarsDetection&gt; detector_;
+  std::shared_ptr&lt;BaseLidarDetector&gt; detector_;
 };  // class LidarObstacleDetection
 
 }  // namespace lidar
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" new_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" added_lines="5" deleted_lines="5">
				<diff>@@ -68,11 +68,11 @@ bool LidarObstacleSegmentation::Init(
   preprocessor_init_options.sensor_name = sensor_name;
   ACHECK(cloud_preprocessor_-&gt;Init(preprocessor_init_options)) &lt;&lt; "lidar preprocessor init error";
 
-  BaseSegmentation* segmentor =
-      BaseSegmentationRegisterer::GetInstanceByName(config.segmentor());
+  BaseLidarDetector* segmentor =
+      BaseLidarDetectorRegisterer::GetInstanceByName(config.segmentor());
   CHECK_NOTNULL(segmentor);
   segmentor_.reset(segmentor);
-  SegmentationInitOptions segmentation_init_options;
+  LidarDetectorInitOptions segmentation_init_options;
   segmentation_init_options.sensor_name = sensor_name;
   ACHECK(segmentor_-&gt;Init(segmentation_init_options)) &lt;&lt; "lidar segmentor init error";
 
@@ -134,8 +134,8 @@ LidarProcessResult LidarObstacleSegmentation::ProcessCommon(
   }
   PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "map_manager");
 
-  SegmentationOptions segmentation_options;
-  if (!segmentor_-&gt;Segment(segmentation_options, frame)) {
+  LidarDetectorOptions segmentation_options;
+  if (!segmentor_-&gt;Detect(segmentation_options, frame)) {
     return LidarProcessResult(LidarErrorCode::SegmentationError,
                               "Failed to segment.");
   }
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.h" new_path="modules\perception\lidar\app\lidar_obstacle_segmentation.h" added_lines="2" deleted_lines="2">
				<diff>@@ -22,7 +22,7 @@
 
 #include "modules/perception/lidar/common/lidar_error_code.h"
 #include "modules/perception/lidar/lib/interface/base_classifier.h"
-#include "modules/perception/lidar/lib/interface/base_segmentation.h"
+#include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
 #include "modules/perception/lidar/lib/map_manager/map_manager.h"
 #include "modules/perception/lidar/lib/object_builder/object_builder.h"
 #include "modules/perception/lidar/lib/object_filter_bank/object_filter_bank.h"
@@ -69,7 +69,7 @@ class LidarObstacleSegmentation {
  private:
   std::shared_ptr&lt;BasePointCloudPreprocessor&gt; cloud_preprocessor_;
   MapManager map_manager_;
-  std::shared_ptr&lt;BaseSegmentation&gt; segmentor_;
+  std::shared_ptr&lt;BaseLidarDetector&gt; segmentor_;
   ObjectBuilder builder_;
   ObjectFilterBank filter_bank_;
   // params
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.cc" new_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.cc" added_lines="4" deleted_lines="2">
				<diff>@@ -51,7 +51,7 @@ PointPillarsDetection::PointPillarsDetection()
 
 // TODO(chenjiahao):
 //  specify score threshold and nms over lap threshold for each class.
-bool PointPillarsDetection::Init(const DetectionInitOptions&amp; options) {
+bool PointPillarsDetection::Init(const LidarDetectorInitOptions&amp; options) {
   point_pillars_ptr_.reset(
       new PointPillars(FLAGS_reproduce_result_mode, FLAGS_score_threshold,
                        FLAGS_nms_overlap_threshold, FLAGS_pfe_torch_file,
@@ -60,7 +60,7 @@ bool PointPillarsDetection::Init(const DetectionInitOptions&amp; options) {
   return true;
 }
 
-bool PointPillarsDetection::Detect(const DetectionOptions&amp; options,
+bool PointPillarsDetection::Detect(const LidarDetectorOptions&amp; options,
                                    LidarFrame* frame) {
   // check input
   if (frame == nullptr) {
@@ -365,6 +365,8 @@ base::ObjectSubType PointPillarsDetection::GetObjectSubType(const int label) {
   }
 }
 
+PERCEPTION_REGISTER_LIDARDETECTOR(PointPillarsDetection);
+
 }  // namespace lidar
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.h" new_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.h" added_lines="5" deleted_lines="8">
				<diff>@@ -27,25 +27,22 @@
 #include "modules/perception/base/point_cloud.h"
 #include "modules/perception/lidar/common/lidar_frame.h"
 #include "modules/perception/lidar/lib/detection/lidar_point_pillars/point_pillars.h"
+#include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
 
 namespace apollo {
 namespace perception {
 namespace lidar {
 
-struct DetectionInitOptions {};
-
-struct DetectionOptions {};
-
-class PointPillarsDetection {
+class PointPillarsDetection : public BaseLidarDetector {
  public:
   PointPillarsDetection();
   ~PointPillarsDetection() = default;
 
-  bool Init(const DetectionInitOptions&amp; options = DetectionInitOptions());
+  bool Init(const LidarDetectorInitOptions&amp; options = LidarDetectorInitOptions()) override;
 
-  bool Detect(const DetectionOptions&amp; options, LidarFrame* frame);
+  bool Detect(const LidarDetectorOptions&amp; options, LidarFrame* frame) override;
 
-  std::string Name() const { return "PointPillarsDetection"; }
+  std::string Name() const override { return "PointPillarsDetection"; }
 
  private:
   void CloudToArray(const base::PointFCloudPtr&amp; pc_ptr, float* out_points_array,
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\interface\base_segmentation.h" new_path="modules\perception\lidar\lib\interface\base_lidar_detector.h" added_lines="14" deleted_lines="14">
				<diff>@@ -25,38 +25,38 @@ namespace apollo {
 namespace perception {
 namespace lidar {
 
-struct SegmentationInitOptions {
+struct LidarDetectorInitOptions {
   std::string sensor_name = "velodyne64";
 };
 
-struct SegmentationOptions {};
+struct LidarDetectorOptions {};
 
-class BaseSegmentation {
+class BaseLidarDetector {
  public:
-  BaseSegmentation() = default;
+  BaseLidarDetector() = default;
 
-  virtual ~BaseSegmentation() = default;
+  virtual ~BaseLidarDetector() = default;
 
   virtual bool Init(
-      const SegmentationInitOptions&amp; options = SegmentationInitOptions()) = 0;
+      const LidarDetectorInitOptions&amp; options = LidarDetectorInitOptions()) = 0;
 
-  // @brief: segment point cloud and get objects.
+  // @brief: process point cloud and get objects.
   // @param [in]: options
   // @param [in/out]: frame
-  // segmented_objects should be filled, required,
+  // objects should be filled, required,
   // label field of point cloud can be filled, optional,
-  virtual bool Segment(const SegmentationOptions&amp; options,
+  virtual bool Detect(const LidarDetectorOptions&amp; options,
                        LidarFrame* frame) = 0;
 
   virtual std::string Name() const = 0;
 
  private:
-  DISALLOW_COPY_AND_ASSIGN(BaseSegmentation);
-};  // class BaseSegmentation
+  DISALLOW_COPY_AND_ASSIGN(BaseLidarDetector);
+};  // class BaseLidarDetector
 
-PERCEPTION_REGISTER_REGISTERER(BaseSegmentation);
-#define PERCEPTION_REGISTER_SEGMENTATION(name) \
-  PERCEPTION_REGISTER_CLASS(BaseSegmentation, name)
+PERCEPTION_REGISTER_REGISTERER(BaseLidarDetector);
+#define PERCEPTION_REGISTER_LIDARDETECTOR(name) \
+  PERCEPTION_REGISTER_CLASS(BaseLidarDetector, name)
 
 }  // namespace lidar
 }  // namespace perception
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.cc" new_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -40,7 +40,7 @@ using base::AttributePointCloud;
 using base::Object;
 using base::PointF;
 
-bool CNNSegmentation::Init(const SegmentationInitOptions&amp; options) {
+bool CNNSegmentation::Init(const LidarDetectorInitOptions&amp; options) {
   // get configs
   std::string param_file;
   std::string proto_file;
@@ -263,7 +263,7 @@ void CNNSegmentation::MapPointToGrid(
   }
 }
 
-bool CNNSegmentation::Segment(const SegmentationOptions&amp; options,
+bool CNNSegmentation::Detect(const LidarDetectorOptions&amp; options,
                               LidarFrame* frame) {
   // check input
   if (frame == nullptr) {
@@ -494,7 +494,7 @@ bool CNNSegmentation::GetConfigs(std::string* param_file,
   return true;
 }
 
-PERCEPTION_REGISTER_SEGMENTATION(CNNSegmentation);
+PERCEPTION_REGISTER_LIDARDETECTOR(CNNSegmentation);
 
 }  // namespace lidar
 }  // namespace perception
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.h" new_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.h" added_lines="6" deleted_lines="6">
				<diff>@@ -30,7 +30,7 @@
 #include "modules/perception/lib/thread/thread_worker.h"
 #include "modules/perception/lidar/lib/interface/base_ground_detector.h"
 #include "modules/perception/lidar/lib/interface/base_roi_filter.h"
-#include "modules/perception/lidar/lib/interface/base_segmentation.h"
+#include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
 #include "modules/perception/lidar/lib/segmentation/cnnseg/feature_generator.h"
 #include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_engine.h"
 
@@ -38,15 +38,15 @@ namespace apollo {
 namespace perception {
 namespace lidar {
 
-class CNNSegmentation : public BaseSegmentation {
+class CNNSegmentation : public BaseLidarDetector {
  public:
   CNNSegmentation() = default;
   ~CNNSegmentation() = default;
 
-  bool Init(const SegmentationInitOptions&amp; options =
-                SegmentationInitOptions()) override;
+  bool Init(const LidarDetectorInitOptions&amp; options =
+                LidarDetectorInitOptions()) override;
 
-  bool Segment(const SegmentationOptions&amp; options, LidarFrame* frame) override;
+  bool Detect(const LidarDetectorOptions&amp; options, LidarFrame* frame) override;
 
   std::string Name() const override { return "CNNSegmentation"; }
 
@@ -122,7 +122,7 @@ class CNNSegmentation : public BaseSegmentation {
 
   // secondary segmentation to improve miss detection
   // not found by neural networks !
-  std::shared_ptr&lt;BaseSegmentation&gt; secondary_segmentor;
+  std::shared_ptr&lt;BaseLidarDetector&gt; secondary_segmentor;
 
  private:
   const int kDefaultPointCloudSize = 120000;
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation_test.cc" new_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation_test.cc" added_lines="10" deleted_lines="10">
				<diff>@@ -81,13 +81,13 @@ TEST(CNNSegmentationTest, cnn_segmentation_sequence_test) {
       "lidar/lib/segmentation/cnnseg/";
 
   auto segmentation = std::shared_ptr&lt;CNNSegmentation&gt;(new CNNSegmentation);
-  SegmentationOptions options;
-  EXPECT_FALSE(segmentation-&gt;Segment(options, nullptr));
+  LidarDetectorOptions options;
+  EXPECT_FALSE(segmentation-&gt;Detect(options, nullptr));
   LidarFrame frame_data;
-  EXPECT_FALSE(segmentation-&gt;Segment(options, &amp;frame_data));
+  EXPECT_FALSE(segmentation-&gt;Detect(options, &amp;frame_data));
   frame_data.cloud = base::PointFCloudPool::Instance().Get();
   frame_data.world_cloud = base::PointDCloudPool::Instance().Get();
-  EXPECT_FALSE(segmentation-&gt;Segment(options, &amp;frame_data));
+  EXPECT_FALSE(segmentation-&gt;Detect(options, &amp;frame_data));
 
   EXPECT_TRUE(segmentation-&gt;Init());
   EXPECT_TRUE(segmentation-&gt;InitClusterAndBackgroundSegmentation());
@@ -115,7 +115,7 @@ TEST(CNNSegmentationTest, cnn_segmentation_sequence_test) {
       continue;
     }
     frame-&gt;world_cloud-&gt;resize(frame-&gt;cloud-&gt;size());
-    EXPECT_TRUE(segmentation-&gt;Segment(options, frame.get()));
+    EXPECT_TRUE(segmentation-&gt;Detect(options, frame.get()));
   }
 }
 
@@ -149,13 +149,13 @@ TEST(CNNSegmentationTest, cnn_segmentation_test) {
 
   // test segment
   using base::ObjectType;
-  SegmentationOptions options;
+  LidarDetectorOptions options;
   LidarFrame frame_data;
   frame_data.cloud = pcl_ptr;
   frame_data.world_cloud = base::PointDCloudPool::Instance().Get();
   frame_data.world_cloud-&gt;resize(pcl_ptr-&gt;size());
   frame_data.non_ground_indices = non_ground_indices;
-  segmentation-&gt;Segment(options, &amp;frame_data);
+  segmentation-&gt;Detect(options, &amp;frame_data);
   std::vector&lt;base::ObjectPtr&gt;&amp; objects = frame_data.segmented_objects;
   //  EXPECT_LE(4, objects.size());
   EXPECT_GT(objects[0]-&gt;lidar_supplement.cloud.size(), 0);
@@ -171,7 +171,7 @@ TEST(CNNSegmentationTest, cnn_segmentation_test) {
 
   segmentation-&gt;cnnseg_param_.set_do_classification(false);
   segmentation-&gt;cnnseg_param_.set_do_heading(false);
-  segmentation-&gt;Segment(options, &amp;frame_data);
+  segmentation-&gt;Detect(options, &amp;frame_data);
   objects = frame_data.segmented_objects;
   //  EXPECT_LE(4, objects.size());
   EXPECT_GT(objects[0]-&gt;lidar_supplement.cloud.size(), 0);
@@ -184,7 +184,7 @@ TEST(CNNSegmentationTest, cnn_segmentation_test) {
   PrintObjects(objects);
 
   segmentation-&gt;InitClusterAndBackgroundSegmentation();
-  segmentation-&gt;Segment(options, &amp;frame_data);
+  segmentation-&gt;Detect(options, &amp;frame_data);
   objects = frame_data.segmented_objects;
   //  EXPECT_EQ(4, objects.size());
   EXPECT_GT(objects[0]-&gt;lidar_supplement.cloud.size(), 0);
@@ -192,7 +192,7 @@ TEST(CNNSegmentationTest, cnn_segmentation_test) {
   PrintObjects(objects);
 
   EXPECT_TRUE(segmentation-&gt;InitClusterAndBackgroundSegmentation());
-  EXPECT_TRUE(segmentation-&gt;Segment(options, &amp;frame_data));
+  EXPECT_TRUE(segmentation-&gt;Detect(options, &amp;frame_data));
   objects = frame_data.segmented_objects;
   //  EXPECT_LE(4, objects.size());
 }
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\ncut_segmentation.cc" new_path="modules\perception\lidar\lib\segmentation\ncut\ncut_segmentation.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -34,7 +34,7 @@ using apollo::cyber::common::GetAbsolutePath;
 using apollo::cyber::common::GetProtoFromFile;
 using Eigen::MatrixXf;
 
-bool NCutSegmentation::Init(const SegmentationInitOptions&amp; options) {
+bool NCutSegmentation::Init(const LidarDetectorInitOptions&amp; options) {
   std::string param_file;
   ACHECK(GetConfigs(&amp;param_file));
   AINFO &lt;&lt; "--    param_file: " &lt;&lt; param_file;
@@ -171,7 +171,7 @@ bool NCutSegmentation::GetConfigs(std::string* param_file) {
   return true;
 }
 
-bool NCutSegmentation::Segment(const SegmentationOptions&amp; options,
+bool NCutSegmentation::Detect(const LidarDetectorOptions&amp; options,
                                LidarFrame* frame) {
   // check input
   if (frame == nullptr) {
@@ -631,7 +631,7 @@ void NCutSegmentation::VisualizeComponents(
 }
 #endif
 
-PERCEPTION_REGISTER_SEGMENTATION(NCutSegmentation);
+PERCEPTION_REGISTER_LIDARDETECTOR(NCutSegmentation);
 
 }  // namespace lidar
 }  // namespace perception
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\ncut_segmentation.h" new_path="modules\perception\lidar\lib\segmentation\ncut\ncut_segmentation.h" added_lines="5" deleted_lines="5">
				<diff>@@ -28,7 +28,7 @@
 #include "modules/perception/lidar/common/pcl_util.h"
 #include "modules/perception/lidar/lib/interface/base_ground_detector.h"
 #include "modules/perception/lidar/lib/interface/base_roi_filter.h"
-#include "modules/perception/lidar/lib/interface/base_segmentation.h"
+#include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
 #include "modules/perception/lidar/lib/segmentation/ncut/ncut.h"
 #include "modules/perception/lidar/lib/segmentation/ncut/proto/ncut_param.pb.h"
 
@@ -38,15 +38,15 @@ namespace lidar {
 
 using base::ObjectPtr;
 
-class NCutSegmentation : public BaseSegmentation {
+class NCutSegmentation : public BaseLidarDetector {
  public:
   NCutSegmentation() = default;
   ~NCutSegmentation() = default;
 
-  bool Init(const SegmentationInitOptions&amp; options =
-                SegmentationInitOptions()) override;
+  bool Init(const LidarDetectorInitOptions&amp; options =
+                LidarDetectorInitOptions()) override;
 
-  bool Segment(const SegmentationOptions&amp; options, LidarFrame* frame) override;
+  bool Detect(const LidarDetectorOptions&amp; options, LidarFrame* frame) override;
 
   std::string Name() const override { return "NCutSegmentation"; }
 
</diff>
			</file>
			<file old_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne128\lidar_obstacle_detection.conf" new_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne128\lidar_obstacle_detection.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -1,3 +1,4 @@
+preprocessor: "PointCloudPreprocessor"
 detector: "PointPillarsDetection"
 use_map_manager: true
 use_object_filter_bank: true
</diff>
			</file>
			<file old_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne128\lidar_obstacle_segmentation.conf" new_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne128\lidar_obstacle_segmentation.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -1,3 +1,4 @@
+preprocessor: "PointCloudPreprocessor"
 segmentor: "CNNSegmentation"
 use_map_manager: true
 use_object_filter_bank: true
</diff>
			</file>
			<file old_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne16\lidar_obstacle_detection.conf" new_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne16\lidar_obstacle_detection.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -1,3 +1,4 @@
+preprocessor: "PointCloudPreprocessor"
 detector: "PointPillarsDetection"
 use_map_manager: true
 use_object_filter_bank: true
</diff>
			</file>
			<file old_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne16\lidar_obstacle_segmentation.conf" new_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne16\lidar_obstacle_segmentation.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -1,3 +1,4 @@
+preprocessor: "PointCloudPreprocessor"
 segmentor: "CNNSegmentation"
 use_map_manager: true
 use_object_filter_bank: true
</diff>
			</file>
			<file old_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne64\lidar_obstacle_detection.conf" new_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne64\lidar_obstacle_detection.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -1,3 +1,4 @@
+preprocessor: "PointCloudPreprocessor"
 detector: "PointPillarsDetection"
 use_map_manager: true
 use_object_filter_bank: true
</diff>
			</file>
			<file old_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne64\lidar_obstacle_segmentation.conf" new_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne64\lidar_obstacle_segmentation.conf" added_lines="1" deleted_lines="0">
				<diff>@@ -1,3 +1,4 @@
+preprocessor: "PointCloudPreprocessor"
 segmentor: "CNNSegmentation"
 use_map_manager: true
 use_object_filter_bank: true
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="bf58e35d4935b172c94bfe8978e91d8ad8dd2e47" author="haina0421">
		<msg>add base_lidar_obstacle_detection and update inherence of original detection and segmentation</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" new_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" added_lines="2" deleted_lines="0">
				<diff>@@ -110,6 +110,8 @@ LidarProcessResult LidarObstacleDetection::ProcessCommon(
   return LidarProcessResult(LidarErrorCode::Succeed);
 }
 
+PERCEPTION_REGISTER_LIDAROBSTACLEDETECTION(LidarObstacleDetection);
+
 }  // namespace lidar
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.h" new_path="modules\perception\lidar\app\lidar_obstacle_detection.h" added_lines="7" deleted_lines="21">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
+ * Copyright 2021 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,11 +16,8 @@
 #pragma once
 
 #include &lt;memory&gt;
-#include &lt;string&gt;
 
-#include "Eigen/Dense"
-
-#include "modules/perception/lidar/common/lidar_error_code.h"
+#include "modules/perception/lidar/lib/interface/base_lidar_obstacle_detection.h"
 #include "modules/perception/lidar/lib/interface/base_pointcloud_preprocessor.h"
 #include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
 
@@ -28,34 +25,23 @@ namespace apollo {
 namespace perception {
 namespace lidar {
 
-struct LidarObstacleDetectionInitOptions {
-  std::string sensor_name = "velodyne64";
-};
-
-struct LidarObstacleDetectionOptions {
-  std::string sensor_name;
-  Eigen::Affine3d sensor2novatel_extrinsics;
-
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-} EIGEN_ALIGN16;
-
-class LidarObstacleDetection {
+class LidarObstacleDetection : public BaseLidarObstacleDetection{
  public:
   LidarObstacleDetection() = default;
   ~LidarObstacleDetection() = default;
 
   bool Init(const LidarObstacleDetectionInitOptions&amp; options =
-                LidarObstacleDetectionInitOptions());
+                LidarObstacleDetectionInitOptions()) override;
 
   LidarProcessResult Process(
       const LidarObstacleDetectionOptions&amp; options,
       const std::shared_ptr&lt;apollo::drivers::PointCloud const&gt;&amp; message,
-      LidarFrame* frame);
+      LidarFrame* frame) override;
 
   LidarProcessResult Process(const LidarObstacleDetectionOptions&amp; options,
-                             LidarFrame* frame);
+                             LidarFrame* frame) override;
 
-  std::string Name() const { return "LidarObstacleDetection"; }
+  std::string Name() const override { return "LidarObstacleDetection"; }
 
  private:
   LidarProcessResult ProcessCommon(const LidarObstacleDetectionOptions&amp; options,
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" new_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" added_lines="6" deleted_lines="4">
				<diff>@@ -27,7 +27,7 @@ namespace perception {
 namespace lidar {
 
 bool LidarObstacleSegmentation::Init(
-    const LidarObstacleSegmentationInitOptions&amp; options) {
+    const LidarObstacleDetectionInitOptions&amp; options) {
   auto&amp; sensor_name = options.sensor_name;
   auto config_manager = lib::ConfigManager::Instance();
   const lib::ModelConfig* model_config = nullptr;
@@ -89,7 +89,7 @@ bool LidarObstacleSegmentation::Init(
 }
 
 LidarProcessResult LidarObstacleSegmentation::Process(
-    const LidarObstacleSegmentationOptions&amp; options, LidarFrame* frame) {
+    const LidarObstacleDetectionOptions&amp; options, LidarFrame* frame) {
   PointCloudPreprocessorOptions preprocessor_options;
   preprocessor_options.sensor2novatel_extrinsics =
       options.sensor2novatel_extrinsics;
@@ -101,7 +101,7 @@ LidarProcessResult LidarObstacleSegmentation::Process(
 }
 
 LidarProcessResult LidarObstacleSegmentation::Process(
-    const LidarObstacleSegmentationOptions&amp; options,
+    const LidarObstacleDetectionOptions&amp; options,
     const std::shared_ptr&lt;apollo::drivers::PointCloud const&gt;&amp; message,
     LidarFrame* frame) {
   const auto&amp; sensor_name = options.sensor_name;
@@ -121,7 +121,7 @@ LidarProcessResult LidarObstacleSegmentation::Process(
 }
 
 LidarProcessResult LidarObstacleSegmentation::ProcessCommon(
-    const LidarObstacleSegmentationOptions&amp; options, LidarFrame* frame) {
+    const LidarObstacleDetectionOptions&amp; options, LidarFrame* frame) {
   const auto&amp; sensor_name = options.sensor_name;
 
   PERF_BLOCK_START();
@@ -158,6 +158,8 @@ LidarProcessResult LidarObstacleSegmentation::ProcessCommon(
   return LidarProcessResult(LidarErrorCode::Succeed);
 }
 
+PERCEPTION_REGISTER_LIDAROBSTACLEDETECTION(LidarObstacleSegmentation);
+
 }  // namespace lidar
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.h" new_path="modules\perception\lidar\app\lidar_obstacle_segmentation.h" added_lines="11" deleted_lines="27">
				<diff>@@ -16,55 +16,39 @@
 #pragma once
 
 #include &lt;memory&gt;
-#include &lt;string&gt;
 
-#include "Eigen/Dense"
-
-#include "modules/perception/lidar/common/lidar_error_code.h"
-#include "modules/perception/lidar/lib/interface/base_classifier.h"
+#include "modules/perception/lidar/lib/interface/base_lidar_obstacle_detection.h"
+#include "modules/perception/lidar/lib/interface/base_pointcloud_preprocessor.h"
 #include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
 #include "modules/perception/lidar/lib/map_manager/map_manager.h"
 #include "modules/perception/lidar/lib/object_builder/object_builder.h"
 #include "modules/perception/lidar/lib/object_filter_bank/object_filter_bank.h"
-#include "modules/perception/lidar/lib/interface/base_pointcloud_preprocessor.h"
 
 namespace apollo {
 namespace perception {
 namespace lidar {
 
-struct LidarObstacleSegmentationInitOptions {
-  std::string sensor_name = "velodyne64";
-  bool enable_hdmap_input = true;
-};
-
-struct LidarObstacleSegmentationOptions {
-  std::string sensor_name;
-  Eigen::Affine3d sensor2novatel_extrinsics;
-
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-} EIGEN_ALIGN16;
-
-class LidarObstacleSegmentation {
+class LidarObstacleSegmentation : public BaseLidarObstacleDetection{
  public:
   LidarObstacleSegmentation() = default;
   ~LidarObstacleSegmentation() = default;
 
-  bool Init(const LidarObstacleSegmentationInitOptions&amp; options =
-                LidarObstacleSegmentationInitOptions());
+  bool Init(const LidarObstacleDetectionInitOptions&amp; options =
+                LidarObstacleDetectionInitOptions()) override;
 
   LidarProcessResult Process(
-      const LidarObstacleSegmentationOptions&amp; options,
+      const LidarObstacleDetectionOptions&amp; options,
       const std::shared_ptr&lt;apollo::drivers::PointCloud const&gt;&amp; message,
-      LidarFrame* frame);
+      LidarFrame* frame) override;
 
-  LidarProcessResult Process(const LidarObstacleSegmentationOptions&amp; options,
-                             LidarFrame* frame);
+  LidarProcessResult Process(const LidarObstacleDetectionOptions&amp; options,
+                             LidarFrame* frame) override;
 
-  std::string Name() const { return "LidarObstacleSegmentation"; }
+  std::string Name() const override { return "LidarObstacleSegmentation"; }
 
  private:
   LidarProcessResult ProcessCommon(
-      const LidarObstacleSegmentationOptions&amp; options, LidarFrame* frame);
+      const LidarObstacleDetectionOptions&amp; options, LidarFrame* frame);
 
  private:
   std::shared_ptr&lt;BasePointCloudPreprocessor&gt; cloud_preprocessor_;
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\pointcloud_preprocessor\pointcloud_preprocessor.cc" new_path="modules\perception\lidar\lib\pointcloud_preprocessor\pointcloud_preprocessor.cc" added_lines="2" deleted_lines="0">
				<diff>@@ -188,6 +188,8 @@ bool PointCloudPreprocessor::TransformCloud(
   return true;
 }
 
+PERCEPTION_REGISTER_POINTCLOUDPREPROCESSOR(PointCloudPreprocessor);
+
 }  // namespace lidar
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\segmentation_component.cc" new_path="modules\perception\onboard\component\segmentation_component.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -82,7 +82,7 @@ bool SegmentationComponent::InitAlgorithmPlugin() {
            &lt;&lt; "Failed to get segmentation instance";
     return false;
   }
-  lidar::LidarObstacleSegmentationInitOptions init_options;
+  lidar::LidarObstacleDetectionInitOptions init_options;
   init_options.sensor_name = sensor_name_;
   init_options.enable_hdmap_input =
       FLAGS_obs_enable_hdmap_input &amp;&amp; enable_hdmap_;
@@ -140,7 +140,7 @@ bool SegmentationComponent::InternalProc(
   frame-&gt;lidar2world_pose = pose;
   frame-&gt;novatel2world_pose = pose_novatel;
 
-  lidar::LidarObstacleSegmentationOptions segment_opts;
+  lidar::LidarObstacleDetectionOptions segment_opts;
   segment_opts.sensor_name = sensor_name_;
   lidar2world_trans_.GetExtrinsics(&amp;segment_opts.sensor2novatel_extrinsics);
   lidar::LidarProcessResult ret =
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="2ab61cd72212ba9987a10aa5f408ba30d3b60f31" author="haina0421">
		<msg>Debug preprocessor</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" new_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" added_lines="8" deleted_lines="0">
				<diff>@@ -22,6 +22,8 @@
 #include "modules/perception/lidar/common/lidar_log.h"
 #include "modules/perception/lidar/lib/scene_manager/scene_manager.h"
 
+#include &lt;vector&gt;
+
 namespace apollo {
 namespace perception {
 namespace lidar {
@@ -59,6 +61,12 @@ bool LidarObstacleSegmentation::Init(
       use_map_manager_ = false;
     }
   }
+  
+  // For Debug
+  std::vector&lt;BasePointCloudPreprocessor *&gt; vec = BasePointCloudPreprocessorRegisterer::GetAllInstances();
+  std::cout&lt;&lt;"Size of Preprocessor Map: "&lt;&lt;vec.size()&lt;&lt;std::endl;
+
+  // End Debug
 
   BasePointCloudPreprocessor* preprocessor =
       BasePointCloudPreprocessorRegisterer::GetInstanceByName(config.preprocessor());
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\dummy\dummy_segmentation.cc" new_path="modules\perception\lidar\lib\dummy\dummy_segmentation.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -20,16 +20,16 @@ namespace apollo {
 namespace perception {
 namespace lidar {
 
-bool DummySegmentation::Init(const SegmentationInitOptions&amp; options) {
+bool DummySegmentation::Init(const LidarDetectorInitOptions&amp; options) {
   return true;
 }
 
-bool DummySegmentation::Segment(const SegmentationOptions&amp; options,
+bool DummySegmentation::Detect(const LidarDetectorOptions&amp; options,
                                 LidarFrame* frame) {
   return true;
 }
 
-PERCEPTION_REGISTER_SEGMENTATION(DummySegmentation);
+PERCEPTION_REGISTER_LIDARDETECTOR(DummySegmentation);
 
 }  // namespace lidar
 }  // namespace perception
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\dummy\dummy_segmentation.h" new_path="modules\perception\lidar\lib\dummy\dummy_segmentation.h" added_lines="5" deleted_lines="5">
				<diff>@@ -18,27 +18,27 @@
 
 #include &lt;string&gt;
 
-#include "modules/perception/lidar/lib/interface/base_segmentation.h"
+#include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
 
 namespace apollo {
 namespace perception {
 namespace lidar {
 
-class DummySegmentation : public BaseSegmentation {
+class DummySegmentation : public BaseLidarDetector {
  public:
   DummySegmentation() = default;
 
   virtual ~DummySegmentation() = default;
 
-  bool Init(const SegmentationInitOptions&amp; options =
-                SegmentationInitOptions()) override;
+  bool Init(const LidarDetectorInitOptions&amp; options =
+                LidarDetectorInitOptions()) override;
 
   // @brief: segment point cloud and get objects.
   // @param [in]: options
   // @param [in/out]: frame
   // segmented_objects should be filled, required,
   // label field of point cloud can be filled, optional,
-  bool Segment(const SegmentationOptions&amp; options, LidarFrame* frame) override;
+  bool Detect(const LidarDetectorOptions&amp; options, LidarFrame* frame) override;
 
   std::string Name() const override { return "DummySegmentation"; }
 };  // class DummySegmentation
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4be2d2bb72dc208d35ea5ee0bd74313c7d9818ad" author="haina0421">
		<msg>Debug preprocessor 2</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" new_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" added_lines="1" deleted_lines="0">
				<diff>@@ -20,6 +20,7 @@
 #include "modules/perception/lib/config_manager/config_manager.h"
 #include "modules/perception/lidar/app/proto/lidar_obstacle_detection_config.pb.h"
 #include "modules/perception/lidar/common/lidar_log.h"
+#include "modules/perception/lib/registerer/registerer.h"
 
 namespace apollo {
 namespace perception {
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" new_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" added_lines="1" deleted_lines="0">
				<diff>@@ -21,6 +21,7 @@
 #include "modules/perception/lidar/app/proto/lidar_obstacle_segmentation_config.pb.h"
 #include "modules/perception/lidar/common/lidar_log.h"
 #include "modules/perception/lidar/lib/scene_manager/scene_manager.h"
+#include "modules/perception/lib/registerer/registerer.h"
 
 #include &lt;vector&gt;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7b5e8ba1d0e71c48bc1a7f240c135820d2730890" author="haina0421">
		<msg>Debug preprocessor 3</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" new_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" added_lines="0" deleted_lines="1">
				<diff>@@ -20,7 +20,6 @@
 #include "modules/perception/lib/config_manager/config_manager.h"
 #include "modules/perception/lidar/app/proto/lidar_obstacle_detection_config.pb.h"
 #include "modules/perception/lidar/common/lidar_log.h"
-#include "modules/perception/lib/registerer/registerer.h"
 
 namespace apollo {
 namespace perception {
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" new_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" added_lines="0" deleted_lines="1">
				<diff>@@ -21,7 +21,6 @@
 #include "modules/perception/lidar/app/proto/lidar_obstacle_segmentation_config.pb.h"
 #include "modules/perception/lidar/common/lidar_log.h"
 #include "modules/perception/lidar/lib/scene_manager/scene_manager.h"
-#include "modules/perception/lib/registerer/registerer.h"
 
 #include &lt;vector&gt;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3b5fa448725bb78b84ef1aa057df488aa828d17f" author="haina0421">
		<msg>Test Base_lidar_obstacle_tracking</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\lib\interface\base_lidar_obstacle_detection.h" new_path="modules\perception\lidar\lib\interface\base_lidar_obstacle_detection.h" added_lines="1" deleted_lines="1">
				<diff>@@ -45,7 +45,7 @@ struct LidarObstacleDetectionOptions {
 class BaseLidarObstacleDetection {
  public:
   BaseLidarObstacleDetection() = default;
-  ~BaseLidarObstacleDetection() = default;
+  virtual ~BaseLidarObstacleDetection() = default;
 
   virtual bool Init(const LidarObstacleDetectionInitOptions&amp; options =
                 LidarObstacleDetectionInitOptions()) = 0;
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\interface\base_pointcloud_preprocessor.h" new_path="modules\perception\lidar\lib\interface\base_pointcloud_preprocessor.h" added_lines="1" deleted_lines="1">
				<diff>@@ -40,7 +40,7 @@ class BasePointCloudPreprocessor {
  public:
   BasePointCloudPreprocessor() = default;
 
-  ~BasePointCloudPreprocessor() = default;
+  virtual ~BasePointCloudPreprocessor() = default;
 
   virtual bool Init(const PointCloudPreprocessorInitOptions&amp; options =
                 PointCloudPreprocessorInitOptions()) = 0;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8b54da5627a46f928374c636779ebded7ca14a6a" author="haina0421">
		<msg>Add base_lidar_obstacle_tracking and update inheritance</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.h" new_path="modules\perception\lidar\app\lidar_obstacle_detection.h" added_lines="1" deleted_lines="1">
				<diff>@@ -28,7 +28,7 @@ namespace lidar {
 class LidarObstacleDetection : public BaseLidarObstacleDetection{
  public:
   LidarObstacleDetection() = default;
-  ~LidarObstacleDetection() = default;
+  virtual ~LidarObstacleDetection() = default;
 
   bool Init(const LidarObstacleDetectionInitOptions&amp; options =
                 LidarObstacleDetectionInitOptions()) override;
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.h" new_path="modules\perception\lidar\app\lidar_obstacle_segmentation.h" added_lines="1" deleted_lines="1">
				<diff>@@ -31,7 +31,7 @@ namespace lidar {
 class LidarObstacleSegmentation : public BaseLidarObstacleDetection{
  public:
   LidarObstacleSegmentation() = default;
-  ~LidarObstacleSegmentation() = default;
+  virtual ~LidarObstacleSegmentation() = default;
 
   bool Init(const LidarObstacleDetectionInitOptions&amp; options =
                 LidarObstacleDetectionInitOptions()) override;
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_tracking.cc" new_path="modules\perception\lidar\app\lidar_obstacle_tracking.cc" added_lines="12" deleted_lines="10">
				<diff>@@ -43,20 +43,20 @@ bool LidarObstacleTracking::Init(
 
   LidarObstacleTrackingConfig config;
   ACHECK(cyber::common::GetProtoFromFile(config_file, &amp;config));
-  multi_target_tracker_name_ = config.multi_target_tracker();
-  fusion_classifier_name_ = config.fusion_classifier();
 
-  multi_target_tracker_ = BaseMultiTargetTrackerRegisterer::GetInstanceByName(
-      multi_target_tracker_name_);
-  CHECK_NOTNULL(multi_target_tracker_);
+  BaseMultiTargetTracker* multi_target_tracker =
+      BaseMultiTargetTrackerRegisterer::GetInstanceByName(config.multi_target_tracker());
+  CHECK_NOTNULL(multi_target_tracker);
+  multi_target_tracker_.reset(multi_target_tracker);
   MultiTargetTrackerInitOptions tracker_init_options;
-  ACHECK(multi_target_tracker_-&gt;Init(tracker_init_options));
+  ACHECK(multi_target_tracker_-&gt;Init(tracker_init_options)) &lt;&lt; "lidar multi_target_tracker init error";
 
-  fusion_classifier_ =
-      BaseClassifierRegisterer::GetInstanceByName(fusion_classifier_name_);
-  CHECK_NOTNULL(fusion_classifier_);
+  BaseClassifier* fusion_classifier =
+      BaseClassifierRegisterer::GetInstanceByName(config.fusion_classifier());
+  CHECK_NOTNULL(fusion_classifier);
+  fusion_classifier_.reset(fusion_classifier);
   ClassifierInitOptions fusion_classifier_init_options;
-  ACHECK(fusion_classifier_-&gt;Init(fusion_classifier_init_options));
+  ACHECK(fusion_classifier_-&gt;Init(fusion_classifier_init_options)) &lt;&lt; "lidar classifier init error";
   return true;
 }
 
@@ -84,6 +84,8 @@ LidarProcessResult LidarObstacleTracking::Process(
   return LidarProcessResult(LidarErrorCode::Succeed);
 }
 
+PERCEPTION_REGISTER_LIDAROBSTACLETRACKING(LidarObstacleTracking);
+
 }  // namespace lidar
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_tracking.h" new_path="modules\perception\lidar\app\lidar_obstacle_tracking.h" added_lines="8" deleted_lines="17">
				<diff>@@ -19,6 +19,7 @@
 #include &lt;string&gt;
 
 #include "modules/perception/lidar/common/lidar_error_code.h"
+#include "modules/perception/lidar/lib/interface/base_lidar_obstacle_tracking.h"
 #include "modules/perception/lidar/lib/interface/base_classifier.h"
 #include "modules/perception/lidar/lib/interface/base_multi_target_tracker.h"
 
@@ -26,32 +27,22 @@ namespace apollo {
 namespace perception {
 namespace lidar {
 
-struct LidarObstacleTrackingInitOptions {
-  std::string sensor_name = "velodyne64";
-};
-
-struct LidarObstacleTrackingOptions {
-  std::string sensor_name;
-};
-
-class LidarObstacleTracking {
+class LidarObstacleTracking : public BaseLidarObstacleTracking {
  public:
   LidarObstacleTracking() = default;
-  ~LidarObstacleTracking() = default;
+  virtual ~LidarObstacleTracking() = default;
 
   bool Init(const LidarObstacleTrackingInitOptions&amp; options =
-                LidarObstacleTrackingInitOptions());
+                LidarObstacleTrackingInitOptions()) override;
 
   LidarProcessResult Process(const LidarObstacleTrackingOptions&amp; options,
-                             LidarFrame* frame);
+                             LidarFrame* frame) override;
 
-  std::string Name() const { return "LidarObstacleTracking"; }
+  std::string Name() const override { return "LidarObstacleTracking"; }
 
  private:
-  BaseMultiTargetTracker* multi_target_tracker_;
-  BaseClassifier* fusion_classifier_;
-  std::string multi_target_tracker_name_;
-  std::string fusion_classifier_name_;
+  std::shared_ptr&lt;BaseMultiTargetTracker&gt; multi_target_tracker_;
+  std::shared_ptr&lt;BaseClassifier&gt; fusion_classifier_;
 };  // class LidarObstacleTracking
 
 }  // namespace lidar
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.h" new_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.h" added_lines="1" deleted_lines="1">
				<diff>@@ -36,7 +36,7 @@ namespace lidar {
 class PointPillarsDetection : public BaseLidarDetector {
  public:
   PointPillarsDetection();
-  ~PointPillarsDetection() = default;
+  virtual ~PointPillarsDetection() = default;
 
   bool Init(const LidarDetectorInitOptions&amp; options = LidarDetectorInitOptions()) override;
 
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\pointcloud_preprocessor\pointcloud_preprocessor.h" new_path="modules\perception\lidar\lib\pointcloud_preprocessor\pointcloud_preprocessor.h" added_lines="2" deleted_lines="2">
				<diff>@@ -25,9 +25,9 @@ namespace lidar {
 
 class PointCloudPreprocessor : public BasePointCloudPreprocessor {
  public:
-  PointCloudPreprocessor() = default;
+  PointCloudPreprocessor() : BasePointCloudPreprocessor() {}
 
-  ~PointCloudPreprocessor() = default;
+  virtual ~PointCloudPreprocessor() = default;
 
   bool Init(const PointCloudPreprocessorInitOptions&amp; options =
                 PointCloudPreprocessorInitOptions()) override;
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.h" new_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.h" added_lines="1" deleted_lines="1">
				<diff>@@ -41,7 +41,7 @@ namespace lidar {
 class CNNSegmentation : public BaseLidarDetector {
  public:
   CNNSegmentation() = default;
-  ~CNNSegmentation() = default;
+  virtual ~CNNSegmentation() = default;
 
   bool Init(const LidarDetectorInitOptions&amp; options =
                 LidarDetectorInitOptions()) override;
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\ncut_segmentation.h" new_path="modules\perception\lidar\lib\segmentation\ncut\ncut_segmentation.h" added_lines="1" deleted_lines="1">
				<diff>@@ -41,7 +41,7 @@ using base::ObjectPtr;
 class NCutSegmentation : public BaseLidarDetector {
  public:
   NCutSegmentation() = default;
-  ~NCutSegmentation() = default;
+  virtual ~NCutSegmentation() = default;
 
   bool Init(const LidarDetectorInitOptions&amp; options =
                 LidarDetectorInitOptions()) override;
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\tracker\multi_lidar_fusion\mlf_engine.h" new_path="modules\perception\lidar\lib\tracker\multi_lidar_fusion\mlf_engine.h" added_lines="1" deleted_lines="1">
				<diff>@@ -38,7 +38,7 @@ class MlfEngine : public BaseMultiTargetTracker {
 
  public:
   MlfEngine() = default;
-  ~MlfEngine() = default;
+  virtual ~MlfEngine() = default;
 
   bool Init(const MultiTargetTrackerInitOptions&amp; options =
                 MultiTargetTrackerInitOptions()) override;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="bde30a97cff62ee11275c9958039126100ef9828" author="haina0421">
		<msg>Integrate Detection and Segmentation</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" new_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" added_lines="55" deleted_lines="0">
				<diff>@@ -20,6 +20,7 @@
 #include "modules/perception/lib/config_manager/config_manager.h"
 #include "modules/perception/lidar/app/proto/lidar_obstacle_detection_config.pb.h"
 #include "modules/perception/lidar/common/lidar_log.h"
+#include "modules/perception/lidar/lib/scene_manager/scene_manager.h"
 
 namespace apollo {
 namespace perception {
@@ -43,6 +44,22 @@ bool LidarObstacleDetection::Init(
 
   LidarObstacleDetectionConfig config;
   ACHECK(cyber::common::GetProtoFromFile(config_file, &amp;config));
+  use_map_manager_ = config.use_map_manager();
+  use_object_filter_bank_ = config.use_object_filter_bank();
+  use_object_builder_ = ("PointPillarsDetection" != config.detector());
+
+  use_map_manager_ = use_map_manager_ &amp;&amp; options.enable_hdmap_input;
+
+  SceneManagerInitOptions scene_manager_init_options;
+  ACHECK(SceneManager::Instance().Init(scene_manager_init_options));
+
+  if (use_map_manager_) {
+    MapManagerInitOptions map_manager_init_options;
+    if (!map_manager_.Init(map_manager_init_options)) {
+      AINFO &lt;&lt; "Failed to init map manager.";
+      use_map_manager_ = false;
+    }
+  }
 
   BasePointCloudPreprocessor* preprocessor =
       BasePointCloudPreprocessorRegisterer::GetInstanceByName(config.preprocessor());
@@ -60,6 +77,17 @@ bool LidarObstacleDetection::Init(
   detection_init_options.sensor_name = sensor_name;
   ACHECK(detector_-&gt;Init(detection_init_options)) &lt;&lt; "lidar detector init error";
 
+  if(use_object_builder_) {
+    ObjectBuilderInitOptions builder_init_options;
+    ACHECK(builder_.Init(builder_init_options));
+  }
+
+  if (use_object_filter_bank_) {
+    ObjectFilterInitOptions filter_bank_init_options;
+    filter_bank_init_options.sensor_name = sensor_name;
+    ACHECK(filter_bank_.Init(filter_bank_init_options));
+  }
+
   return true;
 }
 
@@ -100,6 +128,15 @@ LidarProcessResult LidarObstacleDetection::ProcessCommon(
   const auto&amp; sensor_name = options.sensor_name;
 
   PERF_BLOCK_START();
+  if (use_map_manager_) {
+    MapManagerOptions map_manager_options;
+    if (!map_manager_.Update(map_manager_options, frame)) {
+      return LidarProcessResult(LidarErrorCode::MapManagerError,
+                                "Failed to update map structure.");
+    }
+  }
+  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "map_manager");
+
   LidarDetectorOptions detection_options;
   if (!detector_-&gt;Detect(detection_options, frame)) {
     return LidarProcessResult(LidarErrorCode::DetectionError,
@@ -107,6 +144,24 @@ LidarProcessResult LidarObstacleDetection::ProcessCommon(
   }
   PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "detection");
 
+  if (use_object_builder_) {
+    ObjectBuilderOptions builder_options;
+    if (!builder_.Build(builder_options, frame)) {
+      return LidarProcessResult(LidarErrorCode::ObjectBuilderError,
+                                "Failed to build objects.");
+    }
+  }
+  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "object_builder");
+
+  if (use_object_filter_bank_) {
+    ObjectFilterOptions filter_options;
+    if (!filter_bank_.Filter(filter_options, frame)) {
+      return LidarProcessResult(LidarErrorCode::ObjectFilterError,
+                                "Failed to filter objects.");
+    }
+  }
+  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "filter_bank");
+
   return LidarProcessResult(LidarErrorCode::Succeed);
 }
 
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.h" new_path="modules\perception\lidar\app\lidar_obstacle_detection.h" added_lines="10" deleted_lines="0">
				<diff>@@ -20,6 +20,9 @@
 #include "modules/perception/lidar/lib/interface/base_lidar_obstacle_detection.h"
 #include "modules/perception/lidar/lib/interface/base_pointcloud_preprocessor.h"
 #include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
+#include "modules/perception/lidar/lib/map_manager/map_manager.h"
+#include "modules/perception/lidar/lib/object_builder/object_builder.h"
+#include "modules/perception/lidar/lib/object_filter_bank/object_filter_bank.h"
 
 namespace apollo {
 namespace perception {
@@ -50,6 +53,13 @@ class LidarObstacleDetection : public BaseLidarObstacleDetection{
  private:
   std::shared_ptr&lt;BasePointCloudPreprocessor&gt; cloud_preprocessor_;
   std::shared_ptr&lt;BaseLidarDetector&gt; detector_;
+  MapManager map_manager_;
+  ObjectBuilder builder_;
+  ObjectFilterBank filter_bank_;
+  // params
+  bool use_map_manager_ = true;
+  bool use_object_filter_bank_ = true;
+  bool use_object_builder_ = true;
 };  // class LidarObstacleDetection
 
 }  // namespace lidar
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.cc" new_path="" added_lines="0" deleted_lines="173">
				<diff>@@ -1,173 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/app/lidar_obstacle_segmentation.h"
-
-#include "cyber/common/file.h"
-#include "modules/common/util/perf_util.h"
-#include "modules/perception/lib/config_manager/config_manager.h"
-#include "modules/perception/lidar/app/proto/lidar_obstacle_segmentation_config.pb.h"
-#include "modules/perception/lidar/common/lidar_log.h"
-#include "modules/perception/lidar/lib/scene_manager/scene_manager.h"
-
-#include &lt;vector&gt;
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-bool LidarObstacleSegmentation::Init(
-    const LidarObstacleDetectionInitOptions&amp; options) {
-  auto&amp; sensor_name = options.sensor_name;
-  auto config_manager = lib::ConfigManager::Instance();
-  const lib::ModelConfig* model_config = nullptr;
-  ACHECK(config_manager-&gt;GetModelConfig(Name(), &amp;model_config));
-
-  const std::string work_root = config_manager-&gt;work_root();
-  std::string config_file;
-  std::string root_path;
-  ACHECK(model_config-&gt;get_value("root_path", &amp;root_path));
-  config_file = cyber::common::GetAbsolutePath(work_root, root_path);
-  config_file = cyber::common::GetAbsolutePath(config_file, sensor_name);
-  config_file = cyber::common::GetAbsolutePath(
-      config_file, "lidar_obstacle_segmentation.conf");
-
-  LidarObstacleSegmentationConfig config;
-  ACHECK(cyber::common::GetProtoFromFile(config_file, &amp;config));
-  use_map_manager_ = config.use_map_manager();
-  use_object_filter_bank_ = config.use_object_filter_bank();
-
-  use_map_manager_ = use_map_manager_ &amp;&amp; options.enable_hdmap_input;
-
-  SceneManagerInitOptions scene_manager_init_options;
-  ACHECK(SceneManager::Instance().Init(scene_manager_init_options));
-
-  if (use_map_manager_) {
-    MapManagerInitOptions map_manager_init_options;
-    if (!map_manager_.Init(map_manager_init_options)) {
-      AINFO &lt;&lt; "Failed to init map manager.";
-      use_map_manager_ = false;
-    }
-  }
-  
-  // For Debug
-  std::vector&lt;BasePointCloudPreprocessor *&gt; vec = BasePointCloudPreprocessorRegisterer::GetAllInstances();
-  std::cout&lt;&lt;"Size of Preprocessor Map: "&lt;&lt;vec.size()&lt;&lt;std::endl;
-
-  // End Debug
-
-  BasePointCloudPreprocessor* preprocessor =
-      BasePointCloudPreprocessorRegisterer::GetInstanceByName(config.preprocessor());
-  CHECK_NOTNULL(preprocessor);
-  cloud_preprocessor_.reset(preprocessor);
-  PointCloudPreprocessorInitOptions preprocessor_init_options;
-  preprocessor_init_options.sensor_name = sensor_name;
-  ACHECK(cloud_preprocessor_-&gt;Init(preprocessor_init_options)) &lt;&lt; "lidar preprocessor init error";
-
-  BaseLidarDetector* segmentor =
-      BaseLidarDetectorRegisterer::GetInstanceByName(config.segmentor());
-  CHECK_NOTNULL(segmentor);
-  segmentor_.reset(segmentor);
-  LidarDetectorInitOptions segmentation_init_options;
-  segmentation_init_options.sensor_name = sensor_name;
-  ACHECK(segmentor_-&gt;Init(segmentation_init_options)) &lt;&lt; "lidar segmentor init error";
-
-  ObjectBuilderInitOptions builder_init_options;
-  ACHECK(builder_.Init(builder_init_options));
-
-  if (use_object_filter_bank_) {
-    ObjectFilterInitOptions filter_bank_init_options;
-    filter_bank_init_options.sensor_name = sensor_name;
-    ACHECK(filter_bank_.Init(filter_bank_init_options));
-  }
-
-  return true;
-}
-
-LidarProcessResult LidarObstacleSegmentation::Process(
-    const LidarObstacleDetectionOptions&amp; options, LidarFrame* frame) {
-  PointCloudPreprocessorOptions preprocessor_options;
-  preprocessor_options.sensor2novatel_extrinsics =
-      options.sensor2novatel_extrinsics;
-  if (cloud_preprocessor_-&gt;Preprocess(preprocessor_options, frame)) {
-    return ProcessCommon(options, frame);
-  }
-  return LidarProcessResult(LidarErrorCode::PointCloudPreprocessorError,
-                            "Failed to preprocess point cloud.");
-}
-
-LidarProcessResult LidarObstacleSegmentation::Process(
-    const LidarObstacleDetectionOptions&amp; options,
-    const std::shared_ptr&lt;apollo::drivers::PointCloud const&gt;&amp; message,
-    LidarFrame* frame) {
-  const auto&amp; sensor_name = options.sensor_name;
-
-  PERF_FUNCTION_WITH_INDICATOR(options.sensor_name);
-
-  PERF_BLOCK_START();
-  PointCloudPreprocessorOptions preprocessor_options;
-  preprocessor_options.sensor2novatel_extrinsics =
-      options.sensor2novatel_extrinsics;
-  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "preprocess");
-  if (cloud_preprocessor_-&gt;Preprocess(preprocessor_options, message, frame)) {
-    return ProcessCommon(options, frame);
-  }
-  return LidarProcessResult(LidarErrorCode::PointCloudPreprocessorError,
-                            "Failed to preprocess point cloud.");
-}
-
-LidarProcessResult LidarObstacleSegmentation::ProcessCommon(
-    const LidarObstacleDetectionOptions&amp; options, LidarFrame* frame) {
-  const auto&amp; sensor_name = options.sensor_name;
-
-  PERF_BLOCK_START();
-  if (use_map_manager_) {
-    MapManagerOptions map_manager_options;
-    if (!map_manager_.Update(map_manager_options, frame)) {
-      return LidarProcessResult(LidarErrorCode::MapManagerError,
-                                "Failed to update map structure.");
-    }
-  }
-  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "map_manager");
-
-  LidarDetectorOptions segmentation_options;
-  if (!segmentor_-&gt;Detect(segmentation_options, frame)) {
-    return LidarProcessResult(LidarErrorCode::SegmentationError,
-                              "Failed to segment.");
-  }
-  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "segmentation");
-
-  ObjectBuilderOptions builder_options;
-  if (!builder_.Build(builder_options, frame)) {
-    return LidarProcessResult(LidarErrorCode::ObjectBuilderError,
-                              "Failed to build objects.");
-  }
-  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "object_builder");
-
-  ObjectFilterOptions filter_options;
-  if (!filter_bank_.Filter(filter_options, frame)) {
-    return LidarProcessResult(LidarErrorCode::ObjectFilterError,
-                              "Failed to filter objects.");
-  }
-  PERF_BLOCK_END_WITH_INDICATOR(sensor_name, "filter_bank");
-
-  return LidarProcessResult(LidarErrorCode::Succeed);
-}
-
-PERCEPTION_REGISTER_LIDAROBSTACLEDETECTION(LidarObstacleSegmentation);
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_segmentation.h" new_path="" added_lines="0" deleted_lines="66">
				<diff>@@ -1,66 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;memory&gt;
-
-#include "modules/perception/lidar/lib/interface/base_lidar_obstacle_detection.h"
-#include "modules/perception/lidar/lib/interface/base_pointcloud_preprocessor.h"
-#include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
-#include "modules/perception/lidar/lib/map_manager/map_manager.h"
-#include "modules/perception/lidar/lib/object_builder/object_builder.h"
-#include "modules/perception/lidar/lib/object_filter_bank/object_filter_bank.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class LidarObstacleSegmentation : public BaseLidarObstacleDetection{
- public:
-  LidarObstacleSegmentation() = default;
-  virtual ~LidarObstacleSegmentation() = default;
-
-  bool Init(const LidarObstacleDetectionInitOptions&amp; options =
-                LidarObstacleDetectionInitOptions()) override;
-
-  LidarProcessResult Process(
-      const LidarObstacleDetectionOptions&amp; options,
-      const std::shared_ptr&lt;apollo::drivers::PointCloud const&gt;&amp; message,
-      LidarFrame* frame) override;
-
-  LidarProcessResult Process(const LidarObstacleDetectionOptions&amp; options,
-                             LidarFrame* frame) override;
-
-  std::string Name() const override { return "LidarObstacleSegmentation"; }
-
- private:
-  LidarProcessResult ProcessCommon(
-      const LidarObstacleDetectionOptions&amp; options, LidarFrame* frame);
-
- private:
-  std::shared_ptr&lt;BasePointCloudPreprocessor&gt; cloud_preprocessor_;
-  MapManager map_manager_;
-  std::shared_ptr&lt;BaseLidarDetector&gt; segmentor_;
-  ObjectBuilder builder_;
-  ObjectFilterBank filter_bank_;
-  // params
-  bool use_map_manager_ = true;
-  bool use_object_filter_bank_ = true;
-};  // class LidarObstacleSegmentation
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\common\lidar_error_code.h" new_path="modules\perception\lidar\common\lidar_error_code.h" added_lines="1" deleted_lines="2">
				<diff>@@ -26,12 +26,11 @@ enum class LidarErrorCode {
   InitError = 1,
   PointCloudPreprocessorError = 2,
   MapManagerError = 3,
-  SegmentationError = 4,
+  DetectionError = 4,
   ObjectBuilderError = 5,
   ObjectFilterError = 6,
   ClassifierError = 7,
   TrackerError = 8,
-  DetectionError = 9,
 };
 
 struct LidarProcessResult {
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\detection_component.cc" new_path="modules\perception\onboard\component\detection_component.cc" added_lines="8" deleted_lines="7">
				<diff>@@ -43,7 +43,7 @@ bool DetectionComponent::Init() {
       comp_config.lidar2novatel_tf2_child_frame_id();
   lidar_query_tf_offset_ =
       static_cast&lt;float&gt;(comp_config.lidar_query_tf_offset());
-  //  enable_hdmap_ = comp_config.enable_hdmap();
+  enable_hdmap_ = comp_config.enable_hdmap();
   writer_ = node_-&gt;CreateWriter&lt;LidarFrameMessage&gt;(output_channel_name_);
 
   if (!InitAlgorithmPlugin()) {
@@ -82,8 +82,8 @@ bool DetectionComponent::InitAlgorithmPlugin() {
   }
   lidar::LidarObstacleDetectionInitOptions init_options;
   init_options.sensor_name = sensor_name_;
-  //  init_options.enable_hdmap_input =
-  //      FLAGS_obs_enable_hdmap_input &amp;&amp; enable_hdmap_;
+  init_options.enable_hdmap_input =
+      FLAGS_obs_enable_hdmap_input &amp;&amp; enable_hdmap_;
   if (!detector_-&gt;Init(init_options)) {
     AINFO &lt;&lt; "sensor_name_ "
           &lt;&lt; "Failed to init detection.";
@@ -118,17 +118,18 @@ bool DetectionComponent::InternalProc(
   frame-&gt;sensor_info = sensor_info_;
 
   Eigen::Affine3d pose = Eigen::Affine3d::Identity();
+  Eigen::Affine3d pose_novatel = Eigen::Affine3d::Identity();
   const double lidar_query_tf_timestamp =
       timestamp - lidar_query_tf_offset_ * 0.001;
-  if (!lidar2world_trans_.GetSensor2worldTrans(lidar_query_tf_timestamp,
-                                               &amp;pose)) {
+  if (!lidar2world_trans_.GetSensor2worldTrans(lidar_query_tf_timestamp, &amp;pose,
+                                               &amp;pose_novatel)) {
     out_message-&gt;error_code_ = apollo::common::ErrorCode::PERCEPTION_ERROR_TF;
-    AERROR &lt;&lt; "Failed to get pose at time: "
-           &lt;&lt; FORMAT_TIMESTAMP(lidar_query_tf_timestamp);
+    AERROR &lt;&lt; "Failed to get pose at time: " &lt;&lt; lidar_query_tf_timestamp;
     return false;
   }
 
   frame-&gt;lidar2world_pose = pose;
+  frame-&gt;novatel2world_pose = pose_novatel;
 
   lidar::LidarObstacleDetectionOptions detect_opts;
   detect_opts.sensor_name = sensor_name_;
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\detection_component.h" new_path="modules\perception\onboard\component\detection_component.h" added_lines="2" deleted_lines="2">
				<diff>@@ -48,13 +48,13 @@ class DetectionComponent : public cyber::Component&lt;drivers::PointCloud&gt; {
  private:
   static std::atomic&lt;uint32_t&gt; seq_num_;
   std::string sensor_name_;
-  // bool enable_hdmap_ = true;
+  bool enable_hdmap_ = true;
   float lidar_query_tf_offset_ = 20.0f;
   std::string lidar2novatel_tf2_child_frame_id_;
   std::string output_channel_name_;
   base::SensorInfo sensor_info_;
   TransformWrapper lidar2world_trans_;
-  std::unique_ptr&lt;lidar::LidarObstacleDetection&gt; detector_;
+  std::unique_ptr&lt;lidar::BaseLidarObstacleDetection&gt; detector_;
   std::shared_ptr&lt;apollo::cyber::Writer&lt;LidarFrameMessage&gt;&gt; writer_;
 };
 
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\segmentation_component.cc" new_path="" added_lines="0" deleted_lines="162">
				<diff>@@ -1,162 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/onboard/component/segmentation_component.h"
-
-#include "cyber/time/clock.h"
-#include "modules/common/util/perf_util.h"
-#include "modules/perception/common/sensor_manager/sensor_manager.h"
-#include "modules/perception/lidar/common/lidar_error_code.h"
-#include "modules/perception/lidar/common/lidar_frame_pool.h"
-#include "modules/perception/lidar/common/lidar_log.h"
-#include "modules/perception/onboard/common_flags/common_flags.h"
-
-using ::apollo::cyber::Clock;
-
-namespace apollo {
-namespace perception {
-namespace onboard {
-
-uint32_t SegmentationComponent::s_seq_num_ = 0;
-std::mutex SegmentationComponent::s_mutex_;
-
-bool SegmentationComponent::Init() {
-  LidarSegmentationComponentConfig comp_config;
-  if (!GetProtoConfig(&amp;comp_config)) {
-    return false;
-  }
-  ADEBUG &lt;&lt; "Lidar Component Configs: " &lt;&lt; comp_config.DebugString();
-  output_channel_name_ = comp_config.output_channel_name();
-  sensor_name_ = comp_config.sensor_name();
-  lidar2novatel_tf2_child_frame_id_ =
-      comp_config.lidar2novatel_tf2_child_frame_id();
-  lidar_query_tf_offset_ =
-      static_cast&lt;float&gt;(comp_config.lidar_query_tf_offset());
-  enable_hdmap_ = comp_config.enable_hdmap();
-  writer_ = node_-&gt;CreateWriter&lt;LidarFrameMessage&gt;(output_channel_name_);
-
-  if (!InitAlgorithmPlugin()) {
-    AERROR &lt;&lt; "Failed to init segmentation component algorithm plugin.";
-    return false;
-  }
-  return true;
-}
-
-bool SegmentationComponent::Proc(
-    const std::shared_ptr&lt;drivers::PointCloud&gt;&amp; message) {
-  AINFO &lt;&lt; std::setprecision(16)
-        &lt;&lt; "Enter segmentation component, message timestamp: "
-        &lt;&lt; message-&gt;measurement_time() &lt;&lt; " current timestamp: "
-        &lt;&lt; Clock::NowInSeconds();
-
-  std::shared_ptr&lt;LidarFrameMessage&gt; out_message(new (std::nothrow)
-                                                     LidarFrameMessage);
-
-  bool status = InternalProc(message, out_message);
-  if (status) {
-    writer_-&gt;Write(out_message);
-    AINFO &lt;&lt; "Send lidar segment output message.";
-  }
-  return status;
-}
-
-bool SegmentationComponent::InitAlgorithmPlugin() {
-  ACHECK(common::SensorManager::Instance()-&gt;GetSensorInfo(sensor_name_,
-                                                          &amp;sensor_info_));
-
-  segmentor_.reset(new lidar::LidarObstacleSegmentation);
-  if (segmentor_ == nullptr) {
-    AERROR &lt;&lt; "sensor_name_ "
-           &lt;&lt; "Failed to get segmentation instance";
-    return false;
-  }
-  lidar::LidarObstacleDetectionInitOptions init_options;
-  init_options.sensor_name = sensor_name_;
-  init_options.enable_hdmap_input =
-      FLAGS_obs_enable_hdmap_input &amp;&amp; enable_hdmap_;
-  if (!segmentor_-&gt;Init(init_options)) {
-    AINFO &lt;&lt; "sensor_name_ "
-          &lt;&lt; "Failed to init segmentation.";
-    return false;
-  }
-
-  lidar2world_trans_.Init(lidar2novatel_tf2_child_frame_id_);
-  return true;
-}
-
-bool SegmentationComponent::InternalProc(
-    const std::shared_ptr&lt;const drivers::PointCloud&gt;&amp; in_message,
-    const std::shared_ptr&lt;LidarFrameMessage&gt;&amp; out_message) {
-  PERF_FUNCTION_WITH_INDICATOR(sensor_name_);
-  {
-    std::unique_lock&lt;std::mutex&gt; lock(s_mutex_);
-    s_seq_num_++;
-  }
-  const double timestamp = in_message-&gt;measurement_time();
-  const double cur_time = Clock::NowInSeconds();
-  const double start_latency = (cur_time - timestamp) * 1e3;
-  AINFO &lt;&lt; std::setprecision(16) &lt;&lt; "FRAME_STATISTICS:Lidar:Start:msg_time["
-        &lt;&lt; timestamp &lt;&lt; "]:sensor[" &lt;&lt; sensor_name_ &lt;&lt; "]:cur_time[" &lt;&lt; cur_time
-        &lt;&lt; "]:cur_latency[" &lt;&lt; start_latency &lt;&lt; "]";
-
-  out_message-&gt;timestamp_ = timestamp;
-  out_message-&gt;lidar_timestamp_ = in_message-&gt;header().lidar_timestamp();
-  out_message-&gt;seq_num_ = s_seq_num_;
-  out_message-&gt;process_stage_ = ProcessStage::LIDAR_SEGMENTATION;
-  out_message-&gt;error_code_ = apollo::common::ErrorCode::OK;
-
-  auto&amp; frame = out_message-&gt;lidar_frame_;
-  frame = lidar::LidarFramePool::Instance().Get();
-  frame-&gt;cloud = base::PointFCloudPool::Instance().Get();
-  frame-&gt;timestamp = timestamp;
-  frame-&gt;sensor_info = sensor_info_;
-
-  PERF_BLOCK_START();
-  Eigen::Affine3d pose = Eigen::Affine3d::Identity();
-  Eigen::Affine3d pose_novatel = Eigen::Affine3d::Identity();
-  const double lidar_query_tf_timestamp =
-      timestamp - lidar_query_tf_offset_ * 0.001;
-  if (!lidar2world_trans_.GetSensor2worldTrans(lidar_query_tf_timestamp, &amp;pose,
-                                               &amp;pose_novatel)) {
-    out_message-&gt;error_code_ = apollo::common::ErrorCode::PERCEPTION_ERROR_TF;
-    AERROR &lt;&lt; "Failed to get pose at time: " &lt;&lt; lidar_query_tf_timestamp;
-    return false;
-  }
-  PERF_BLOCK_END_WITH_INDICATOR(sensor_name_,
-                                "segmentation_1::get_lidar_to_world_pose");
-
-  frame-&gt;lidar2world_pose = pose;
-  frame-&gt;novatel2world_pose = pose_novatel;
-
-  lidar::LidarObstacleDetectionOptions segment_opts;
-  segment_opts.sensor_name = sensor_name_;
-  lidar2world_trans_.GetExtrinsics(&amp;segment_opts.sensor2novatel_extrinsics);
-  lidar::LidarProcessResult ret =
-      segmentor_-&gt;Process(segment_opts, in_message, frame.get());
-  if (ret.error_code != lidar::LidarErrorCode::Succeed) {
-    out_message-&gt;error_code_ =
-        apollo::common::ErrorCode::PERCEPTION_ERROR_PROCESS;
-    AERROR &lt;&lt; "Lidar segmentation process error, " &lt;&lt; ret.log;
-    return false;
-  }
-  PERF_BLOCK_END_WITH_INDICATOR(sensor_name_,
-                                "segmentation_2::segment_obstacle");
-
-  return true;
-}
-
-}  // namespace onboard
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\segmentation_component.h" new_path="" added_lines="0" deleted_lines="66">
				<diff>@@ -1,66 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;memory&gt;
-#include &lt;string&gt;
-
-#include "cyber/cyber.h"
-#include "modules/drivers/proto/pointcloud.pb.h"
-#include "modules/perception/lidar/app/lidar_obstacle_segmentation.h"
-#include "modules/perception/lidar/common/lidar_frame.h"
-#include "modules/perception/onboard/component/lidar_inner_component_messages.h"
-#include "modules/perception/onboard/proto/lidar_component_config.pb.h"
-#include "modules/perception/onboard/transform_wrapper/transform_wrapper.h"
-
-namespace apollo {
-namespace perception {
-namespace onboard {
-
-class SegmentationComponent : public cyber::Component&lt;drivers::PointCloud&gt; {
- public:
-  SegmentationComponent() : segmentor_(nullptr) {}
-
-  ~SegmentationComponent() = default;
-
-  bool Init() override;
-  bool Proc(const std::shared_ptr&lt;drivers::PointCloud&gt;&amp; message) override;
-
- private:
-  bool InitAlgorithmPlugin();
-  bool InternalProc(
-      const std::shared_ptr&lt;const drivers::PointCloud&gt;&amp; in_message,
-      const std::shared_ptr&lt;LidarFrameMessage&gt;&amp; out_message);
-
- private:
-  static std::mutex s_mutex_;
-  static uint32_t s_seq_num_;
-  std::string sensor_name_;
-  bool enable_hdmap_ = true;
-  float lidar_query_tf_offset_ = 20.0f;
-  std::string lidar2novatel_tf2_child_frame_id_;
-  std::string output_channel_name_;
-  base::SensorInfo sensor_info_;
-  TransformWrapper lidar2world_trans_;
-  std::unique_ptr&lt;lidar::LidarObstacleSegmentation&gt; segmentor_;
-  std::shared_ptr&lt;apollo::cyber::Writer&lt;LidarFrameMessage&gt;&gt; writer_;
-};
-
-CYBER_REGISTER_COMPONENT(SegmentationComponent);
-
-}  // namespace onboard
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\production\conf\perception\lidar\modules\lidar_obstacle_pipeline.config" new_path="modules\perception\production\conf\perception\lidar\modules\lidar_obstacle_pipeline.config" added_lines="0" deleted_lines="9">
				<diff>@@ -1,12 +1,3 @@
-model_configs {
-    name: "LidarObstacleSegmentation"
-    version: "1.0.0"
-    string_params {
-        name: "root_path"
-        value: "./data/perception/lidar/models/lidar_obstacle_pipeline"
-    }
-}
-
 model_configs {
     name: "LidarObstacleDetection"
     version: "1.0.0"
</diff>
			</file>
			<file old_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne128\lidar_obstacle_segmentation.conf" new_path="" added_lines="0" deleted_lines="4">
				<diff>@@ -1,4 +0,0 @@
-preprocessor: "PointCloudPreprocessor"
-segmentor: "CNNSegmentation"
-use_map_manager: true
-use_object_filter_bank: true
</diff>
			</file>
			<file old_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne16\lidar_obstacle_segmentation.conf" new_path="" added_lines="0" deleted_lines="4">
				<diff>@@ -1,4 +0,0 @@
-preprocessor: "PointCloudPreprocessor"
-segmentor: "CNNSegmentation"
-use_map_manager: true
-use_object_filter_bank: true
</diff>
			</file>
			<file old_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne64\lidar_obstacle_segmentation.conf" new_path="" added_lines="0" deleted_lines="4">
				<diff>@@ -1,4 +0,0 @@
-preprocessor: "PointCloudPreprocessor"
-segmentor: "CNNSegmentation"
-use_map_manager: true
-use_object_filter_bank: true
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d48b6fb45079f7d4922b9c3f23ccfbdf72d908f0" author="haina0421">
		<msg>Adjust cyber schedule conf</msg>
		<modified_files>
			<file old_path="cyber\conf\compute_sched_choreography.conf" new_path="cyber\conf\compute_sched_choreography.conf" added_lines="2" deleted_lines="2">
				<diff>@@ -44,12 +44,12 @@ scheduler_conf {
         prio: 10
       },
       {
-        name: "Velodyne128Segmentation"
+        name: "Velodyne128Detection"
         processor: 3
         prio: 13
       },
       {
-        name: "Velodyne16Segmentation"
+        name: "Velodyne16Detection"
         processor: 3
         prio: 10
       },
</diff>
			</file>
			<file old_path="cyber\conf\compute_sched_classic.conf" new_path="cyber\conf\compute_sched_classic.conf" added_lines="2" deleted_lines="2">
				<diff>@@ -31,7 +31,7 @@ scheduler_conf {
             prio: 11
           },
           {
-            name: "Velodyne16Segmentation"
+            name: "Velodyne16Detection"
             prio: 11
           },
           {
@@ -43,7 +43,7 @@ scheduler_conf {
             prio: 12
           },
           {
-            name: "Velodyne128Segmentation"
+            name: "Velodyne128Detection"
             prio: 13
           },
           {
</diff>
			</file>
			<file old_path="modules\perception\onboard\inner_component_messages\inner_component_messages.h" new_path="modules\perception\onboard\inner_component_messages\inner_component_messages.h" added_lines="2" deleted_lines="3">
				<diff>@@ -29,7 +29,7 @@ namespace onboard {
 
 enum class ProcessStage {
   LIDAR_PREPROCESS = 0,
-  LIDAR_SEGMENTATION = 1,
+  LIDAR_DETECTION = 1,
   LIDAR_RECOGNITION = 2,
   STEREO_CAMERA_DETECTION = 3,
   MONOCULAR_CAMERA_DETECTION = 4,
@@ -38,8 +38,7 @@ enum class ProcessStage {
   ULTRASONIC_DETECTION = 7,
   SENSOR_FUSION = 8,
   UNKNOWN_STAGE = 9,
-  PROCESSSTAGE_COUNT = 10,
-  LIDAR_DETECTION = 11
+  PROCESSSTAGE_COUNT = 10
 };
 
 class Descriptor {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4ceea156f9ee7ff2a4a024fd85c279a05cc33f0e" author="haina0421">
		<msg>delete segmentation and detection folder</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\anchor_mask_cuda.cu" new_path="" added_lines="0" deleted_lines="216">
				<diff>@@ -1,216 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include &lt;algorithm&gt;
-
-// headers in local files
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/anchor_mask_cuda.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/common.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-// modified prefix sum code from
-// https://www.mimuw.edu.pl/~ps209291/kgkp/slides/scan.pdf
-__global__ void scan_x(int* g_odata, int* g_idata, int n) {
-  extern __shared__ int temp[];  // allocated on invocation
-  int thid = threadIdx.x;
-  int bid = blockIdx.x;
-  int bdim = blockDim.x;
-  int offset = 1;
-  temp[2 * thid] =
-      g_idata[bid * bdim * 2 + 2 * thid];  // load input into shared memory
-  temp[2 * thid + 1] = g_idata[bid * bdim * 2 + 2 * thid + 1];
-  for (int d = n &gt;&gt; 1; d &gt; 0; d &gt;&gt;= 1) {  // build sum in place up the tree
-    __syncthreads();
-    if (thid &lt; d) {
-      int ai = offset * (2 * thid + 1) - 1;
-      int bi = offset * (2 * thid + 2) - 1;
-      temp[bi] += temp[ai];
-    }
-    offset *= 2;
-  }
-  if (thid == 0) {
-    temp[n - 1] = 0;
-  }                                 // clear the last element
-  for (int d = 1; d &lt; n; d *= 2) {  // traverse down tree &amp; build scan
-    offset &gt;&gt;= 1;
-    __syncthreads();
-    if (thid &lt; d) {
-      int ai = offset * (2 * thid + 1) - 1;
-      int bi = offset * (2 * thid + 2) - 1;
-      int t = temp[ai];
-      temp[ai] = temp[bi];
-      temp[bi] += t;
-    }
-  }
-  __syncthreads();
-  g_odata[bid * bdim * 2 + 2 * thid] =
-      temp[2 * thid + 1];  // write results to device memory
-  int second_ind = 2 * thid + 2;
-  if (second_ind == bdim * 2) {
-    g_odata[bid * bdim * 2 + 2 * thid + 1] =
-        temp[2 * thid + 1] + g_idata[bid * bdim * 2 + 2 * thid + 1];
-  } else {
-    g_odata[bid * bdim * 2 + 2 * thid + 1] = temp[2 * thid + 2];
-  }
-}
-
-// modified prefix sum code from
-// https://www.mimuw.edu.pl/~ps209291/kgkp/slides/scan.pdf
-__global__ void scan_y(int* g_odata, int* g_idata, int n) {
-  extern __shared__ int temp[];  // allocated on invocation
-  int thid = threadIdx.x;
-  int bid = blockIdx.x;
-  int bdim = blockDim.x;
-  int gdim = gridDim.x;
-  int offset = 1;
-  temp[2 * thid] =
-      g_idata[bid + 2 * thid * gdim];  // load input into shared memory
-  temp[2 * thid + 1] = g_idata[bid + 2 * thid * gdim + gdim];
-  for (int d = n &gt;&gt; 1; d &gt; 0; d &gt;&gt;= 1) {  // build sum in place up the tree
-    __syncthreads();
-    if (thid &lt; d) {
-      int ai = offset * (2 * thid + 1) - 1;
-      int bi = offset * (2 * thid + 2) - 1;
-      temp[bi] += temp[ai];
-    }
-    offset *= 2;
-  }
-  if (thid == 0) {
-    temp[n - 1] = 0;
-  }                                 // clear the last element
-  for (int d = 1; d &lt; n; d *= 2) {  // traverse down tree &amp; build scan
-    offset &gt;&gt;= 1;
-    __syncthreads();
-    if (thid &lt; d) {
-      int ai = offset * (2 * thid + 1) - 1;
-      int bi = offset * (2 * thid + 2) - 1;
-      int t = temp[ai];
-      temp[ai] = temp[bi];
-      temp[bi] += t;
-    }
-  }
-  __syncthreads();
-  g_odata[bid + 2 * thid * gdim] =
-      temp[2 * thid + 1];  // write results to device memory
-  int second_ind = 2 * thid + 2;
-  if (second_ind == bdim * 2) {
-    g_odata[bid + 2 * thid * gdim + gdim] =
-        temp[2 * thid + 1] + g_idata[bid + 2 * thid * gdim + gdim];
-  } else {
-    g_odata[bid + 2 * thid * gdim + gdim] = temp[2 * thid + 2];
-  }
-}
-
-__global__ void make_anchor_mask_kernel(
-    const float* dev_box_anchors_min_x, const float* dev_box_anchors_min_y,
-    const float* dev_box_anchors_max_x, const float* dev_box_anchors_max_y,
-    int* dev_sparse_pillar_map, int* dev_anchor_mask, const float min_x_range,
-    const float min_y_range, const float pillar_x_size,
-    const float pillar_y_size, const int grid_x_size, const int grid_y_size,
-    const int num_inds_for_scan) {
-  int tid = threadIdx.x + blockIdx.x * blockDim.x;
-  int anchor_coor[NUM_2D_BOX_CORNERS_MACRO] = {0};
-  const int grid_x_size_1 = grid_x_size - 1;  // grid_x_size - 1
-  const int grid_y_size_1 = grid_y_size - 1;  // grid_y_size - 1
-
-  anchor_coor[0] =
-      floor((dev_box_anchors_min_x[tid] - min_x_range) / pillar_x_size);
-  anchor_coor[1] =
-      floor((dev_box_anchors_min_y[tid] - min_y_range) / pillar_y_size);
-  anchor_coor[2] =
-      floor((dev_box_anchors_max_x[tid] - min_x_range) / pillar_x_size);
-  anchor_coor[3] =
-      floor((dev_box_anchors_max_y[tid] - min_y_range) / pillar_y_size);
-  anchor_coor[0] = max(anchor_coor[0], 0);
-  anchor_coor[1] = max(anchor_coor[1], 0);
-  anchor_coor[2] = min(anchor_coor[2], grid_x_size_1);
-  anchor_coor[3] = min(anchor_coor[3], grid_y_size_1);
-
-  int right_top = dev_sparse_pillar_map[anchor_coor[3] * num_inds_for_scan +
-                                        anchor_coor[2]];
-  int left_bottom = dev_sparse_pillar_map[anchor_coor[1] * num_inds_for_scan +
-                                          anchor_coor[0]];
-  int left_top = dev_sparse_pillar_map[anchor_coor[3] * num_inds_for_scan +
-                                       anchor_coor[0]];
-  int right_bottom = dev_sparse_pillar_map[anchor_coor[1] * num_inds_for_scan +
-                                           anchor_coor[2]];
-
-  int area = right_top - left_top - right_bottom + left_bottom;
-  if (area &gt; 1) {
-    dev_anchor_mask[tid] = 1;
-  } else {
-    dev_anchor_mask[tid] = 0;
-  }
-}
-
-AnchorMaskCuda::AnchorMaskCuda(
-    const int num_threads, const int num_inds_for_scan, const int num_anchor,
-    const float min_x_range, const float min_y_range, const float pillar_x_size,
-    const float pillar_y_size, const int grid_x_size, const int grid_y_size)
-    : num_threads_(num_threads),
-      num_inds_for_scan_(num_inds_for_scan),
-      num_anchor_(num_anchor),
-      min_x_range_(min_x_range),
-      min_y_range_(min_y_range),
-      pillar_x_size_(pillar_x_size),
-      pillar_y_size_(pillar_y_size),
-      grid_x_size_(grid_x_size),
-      grid_y_size_(grid_y_size) {}
-
-void AnchorMaskCuda::DoAnchorMaskCuda(
-    int* dev_sparse_pillar_map, int* dev_cumsum_along_x,
-    int* dev_cumsum_along_y, const float* dev_box_anchors_min_x,
-    const float* dev_box_anchors_min_y, const float* dev_box_anchors_max_x,
-    const float* dev_box_anchors_max_y, int* dev_anchor_mask) {
-  scan_x&lt;&lt;&lt;num_inds_for_scan_, num_inds_for_scan_ / 2,
-           num_inds_for_scan_ * sizeof(int)&gt;&gt;&gt;(
-      dev_cumsum_along_x, dev_sparse_pillar_map, num_inds_for_scan_);
-  scan_y&lt;&lt;&lt;num_inds_for_scan_, num_inds_for_scan_ / 2,
-           num_inds_for_scan_ * sizeof(int)&gt;&gt;&gt;(
-      dev_cumsum_along_y, dev_cumsum_along_x, num_inds_for_scan_);
-  GPU_CHECK(cudaMemcpy(dev_sparse_pillar_map, dev_cumsum_along_y,
-                       num_inds_for_scan_ * num_inds_for_scan_ * sizeof(int),
-                       cudaMemcpyDeviceToDevice));
-
-  int num_blocks = DIVUP(num_anchor_, num_threads_);
-  make_anchor_mask_kernel&lt;&lt;&lt;num_blocks, num_threads_&gt;&gt;&gt;(
-      dev_box_anchors_min_x, dev_box_anchors_min_y, dev_box_anchors_max_x,
-      dev_box_anchors_max_y, dev_sparse_pillar_map, dev_anchor_mask,
-      min_x_range_, min_y_range_, pillar_x_size_, pillar_y_size_, grid_x_size_,
-      grid_y_size_, num_inds_for_scan_);
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\anchor_mask_cuda.h" new_path="" added_lines="0" deleted_lines="111">
				<diff>@@ -1,111 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file anchor_mask_cuda.h
- * @brief Make anchor mask for filtering output
- * @author Kosuke Murakami
- * @date 2019/02/26
- */
-
-#pragma once
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class AnchorMaskCuda {
- private:
-  const int num_threads_;
-  const int num_inds_for_scan_;
-  const int num_anchor_;
-  const float min_x_range_;
-  const float min_y_range_;
-  const float pillar_x_size_;
-  const float pillar_y_size_;
-  const int grid_x_size_;
-  const int grid_y_size_;
-
- public:
-  /**
-   * @brief Constructor
-   * @param[in] num_threads Number of threads per block
-   * @param[in] num_inds_for_scan Number of indexes for scan(cumsum)
-   * @param[in] num_anchor Number of anchors in total
-   * @param[in] min_x_range Minimum x value for point cloud
-   * @param[in] min_y_range Minimum y value for point cloud
-   * @param[in] pillar_x_size Size of x-dimension for a pillar
-   * @param[in] pillar_y_size Size of y-dimension for a pillar
-   * @param[in] grid_x_size Number of pillars in x-coordinate
-   * @param[in] grid_y_size Number of pillars in y-coordinate
-   * @details Captital variables never change after the compile
-   */
-  AnchorMaskCuda(const int num_threads, const int num_inds_for_scan,
-                 const int num_anchor, const float min_x_range,
-                 const float min_y_range, const float pillar_x_size,
-                 const float pillar_y_size, const int grid_x_size,
-                 const int grid_y_size);
-
-  /**
-   * @brief call cuda code for making anchor mask
-   * @param[in] dev_sparse_pillar_map
-   *   Grid map representation for pillar occupancy
-   * @param[in] dev_cumsum_along_x
-   *   Array for storing cumsum-ed dev_sparse_pillar_map values
-   * @param[in] dev_cumsum_along_y
-   *   Array for storing cumsum-ed dev_cumsum_along_y values
-   * @param[in] dev_box_anchors_min_x
-   *   Array for storing min x value for each anchor
-   * @param[in] dev_box_anchors_min_y
-   *   Array for storing min y value for each anchor
-   * @param[in] dev_box_anchors_max_x
-   *   Array for storing max x value for each anchor
-   * @param[in] dev_box_anchors_max_y
-   *   Array for storing max y value for each anchor
-   * @param[in] dev_box_anchors_max_y
-   *   Array for storing max y value for each anchor
-   * @param[out] dev_anchor_mask Anchor mask for filtering the network output
-   * @details dev_* means device memory. Make a mask for filtering pillar
-   * occupancy area
-   */
-  void DoAnchorMaskCuda(int* dev_sparse_pillar_map, int* dev_cumsum_along_x,
-                        int* dev_cumsum_along_y,
-                        const float* dev_box_anchors_min_x,
-                        const float* dev_box_anchors_min_y,
-                        const float* dev_box_anchors_max_x,
-                        const float* dev_box_anchors_max_y,
-                        int* dev_anchor_mask);
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\common.h" new_path="" added_lines="0" deleted_lines="72">
				<diff>@@ -1,72 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file common.h
- * @brief MACRO for CUDA codes
- * @author Kosuke Murakami
- * @date 2019/02/26
- */
-
-#pragma once
-
-// headers in STL
-#include &lt;stdio.h&gt;
-
-// headers in CUDA
-#include &lt;cuda_runtime_api.h&gt;
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-// using MACRO to allocate memory inside CUDA kernel
-#define NUM_3D_BOX_CORNERS_MACRO 8
-#define NUM_2D_BOX_CORNERS_MACRO 4
-#define NUM_THREADS_MACRO 64  // need to be changed when num_threads_ is changed
-
-#define DIVUP(m, n) ((m) / (n) + ((m) % (n) &gt; 0))
-
-#define GPU_CHECK(ans) \
-  { GPUAssert((ans), __FILE__, __LINE__); }
-inline void GPUAssert(cudaError_t code, const char* file, int line,
-                      bool abort = true) {
-  if (code != cudaSuccess) {
-    fprintf(stderr, "GPUassert: %s %s %d\n", cudaGetErrorString(code), file,
-            line);
-    if (abort) exit(code);
-  }
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\nms_cuda.cu" new_path="" added_lines="0" deleted_lines="141">
				<diff>@@ -1,141 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-// ------------------------------------------------------------------
-// Copyright (c) 2015 Microsoft
-// Licensed under The MIT License
-// Modified from MATLAB Faster R-CNN
-// (https://github.com/shaoqingren/faster_rcnn)
-// ------------------------------------------------------------------
-
-#include &lt;algorithm&gt;
-
-// headers in local files
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/nms_cuda.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-__device__ inline float devIoU(float const *const a, float const *const b) {
-  float left = max(a[0], b[0]), right = min(a[2], b[2]);
-  float top = max(a[1], b[1]), bottom = min(a[3], b[3]);
-  float width = max(right - left + 1, 0.f), height = max(bottom - top + 1, 0.f);
-  float interS = width * height;
-  float Sa = (a[2] - a[0] + 1) * (a[3] - a[1] + 1);
-  float Sb = (b[2] - b[0] + 1) * (b[3] - b[1] + 1);
-  return interS / (Sa + Sb - interS);
-}
-
-__global__ void nms_kernel(const int n_boxes, const float nms_overlap_thresh,
-                           const float *dev_boxes, uint64_t *dev_mask,
-                           const int num_box_corners) {
-  const int row_start = blockIdx.y;
-  const int col_start = blockIdx.x;
-
-  const int block_threads = blockDim.x;
-
-  const int row_size = min(n_boxes - row_start * block_threads, block_threads);
-  const int col_size = min(n_boxes - col_start * block_threads, block_threads);
-
-  __shared__ float block_boxes[NUM_THREADS_MACRO * NUM_2D_BOX_CORNERS_MACRO];
-  if (threadIdx.x &lt; col_size) {
-    block_boxes[threadIdx.x * num_box_corners + 0] =
-        dev_boxes[(block_threads * col_start + threadIdx.x) * num_box_corners +
-                  0];
-    block_boxes[threadIdx.x * num_box_corners + 1] =
-        dev_boxes[(block_threads * col_start + threadIdx.x) * num_box_corners +
-                  1];
-    block_boxes[threadIdx.x * num_box_corners + 2] =
-        dev_boxes[(block_threads * col_start + threadIdx.x) * num_box_corners +
-                  2];
-    block_boxes[threadIdx.x * num_box_corners + 3] =
-        dev_boxes[(block_threads * col_start + threadIdx.x) * num_box_corners +
-                  3];
-  }
-  __syncthreads();
-
-  if (threadIdx.x &lt; row_size) {
-    const int cur_box_idx = block_threads * row_start + threadIdx.x;
-    const float cur_box[NUM_2D_BOX_CORNERS_MACRO] = {
-        dev_boxes[cur_box_idx * num_box_corners + 0],
-        dev_boxes[cur_box_idx * num_box_corners + 1],
-        dev_boxes[cur_box_idx * num_box_corners + 2],
-        dev_boxes[cur_box_idx * num_box_corners + 3]};
-    uint64_t t = 0;
-    int start = 0;
-    if (row_start == col_start) {
-      start = threadIdx.x + 1;
-    }
-    for (int i = start; i &lt; col_size; ++i) {
-      if (devIoU(cur_box, block_boxes + i * num_box_corners) &gt;
-          nms_overlap_thresh) {
-        t |= 1ULL &lt;&lt; i;
-      }
-    }
-    const int col_blocks = DIVUP(n_boxes, block_threads);
-    dev_mask[cur_box_idx * col_blocks + col_start] = t;
-  }
-}
-
-NmsCuda::NmsCuda(const int num_threads, const int num_box_corners,
-                 const float nms_overlap_threshold)
-    : num_threads_(num_threads),
-      num_box_corners_(num_box_corners),
-      nms_overlap_threshold_(nms_overlap_threshold) {}
-
-void NmsCuda::DoNmsCuda(const int host_filter_count,
-                        float *dev_sorted_box_for_nms, int *out_keep_inds,
-                        int *out_num_to_keep) {
-  const int col_blocks = DIVUP(host_filter_count, num_threads_);
-  dim3 blocks(DIVUP(host_filter_count, num_threads_),
-              DIVUP(host_filter_count, num_threads_));
-  dim3 threads(num_threads_);
-
-  uint64_t *dev_mask = NULL;
-  GPU_CHECK(
-      cudaMalloc(&amp;dev_mask, host_filter_count * col_blocks * sizeof(uint64_t)));
-
-  nms_kernel&lt;&lt;&lt;blocks, threads&gt;&gt;&gt;(host_filter_count, nms_overlap_threshold_,
-                                  dev_sorted_box_for_nms, dev_mask,
-                                  num_box_corners_);
-
-  // postprocess for nms output
-  std::vector&lt;uint64_t&gt; host_mask(host_filter_count * col_blocks);
-  GPU_CHECK(cudaMemcpy(&amp;host_mask[0], dev_mask,
-                       sizeof(uint64_t) * host_filter_count * col_blocks,
-                       cudaMemcpyDeviceToHost));
-  std::vector&lt;uint64_t&gt; remv(col_blocks);
-  memset(&amp;remv[0], 0, sizeof(uint64_t) * col_blocks);
-
-  for (int i = 0; i &lt; host_filter_count; ++i) {
-    int nblock = i / num_threads_;
-    int inblock = i % num_threads_;
-
-    if (!(remv[nblock] &amp; (1ULL &lt;&lt; inblock))) {
-      out_keep_inds[(*out_num_to_keep)++] = i;
-      uint64_t *p = &amp;host_mask[0] + i * col_blocks;
-      for (int j = nblock; j &lt; col_blocks; ++j) {
-        remv[j] |= p[j];
-      }
-    }
-  }
-  GPU_CHECK(cudaFree(dev_mask));
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\nms_cuda.h" new_path="" added_lines="0" deleted_lines="85">
				<diff>@@ -1,85 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file nms_cuda.h
- * @brief Non-maximum suppresion for network output
- * @author Modified by Kosuke Murakami
- * @date 2019/02/26
- */
-
-#pragma once
-
-// heders in STL
-#include &lt;iostream&gt;
-#include &lt;vector&gt;
-
-// headers in local files
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/common.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class NmsCuda {
- private:
-  const int num_threads_;
-  const int num_box_corners_;
-  const float nms_overlap_threshold_;
-
- public:
-  /**
-   * @brief Constructor
-   * @param[in] num_threads Number of threads when launching cuda kernel
-   * @param[in] num_box_corners Number of corners for 2D box
-   * @param[in] nms_overlap_threshold IOU threshold for NMS
-   * @details Captital variables never change after the compile, Non-captital
-   * variables could be chaned through rosparam
-   */
-  NmsCuda(const int num_threads, const int num_box_corners,
-          const float nms_overlap_threshold);
-
-  /**
-   * @brief GPU Non-Maximum Suppresion for network output
-   * @param[in] host_filter_count Number of filtered output
-   * @param[in] dev_sorted_box_for_nms Bounding box output sorted by score
-   * @param[out] out_keep_inds Indexes of selected bounding box
-   * @param[out] out_num_to_keep Number of kept bounding boxes
-   * @details NMS in GPU and postprocessing for selecting box in CPU
-   */
-  void DoNmsCuda(const int host_filter_count, float* dev_sorted_box_for_nms,
-                 int* out_keep_inds, int* out_num_to_keep);
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\params.h" new_path="" added_lines="0" deleted_lines="87">
				<diff>@@ -1,87 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-#pragma once
-
-#include &lt;vector&gt;
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class Params {
- public:
-  static constexpr float kPillarXSize = 0.32f;
-  static constexpr float kPillarYSize = 0.32f;
-  static constexpr float kPillarZSize = 6.0f;
-  static constexpr float kMinXRange = -74.88f;
-  static constexpr float kMinYRange = -74.88f;
-  static constexpr float kMinZRange = -2.0f;
-  static constexpr float kMaxXRange = 74.88f;
-  static constexpr float kMaxYRange = 74.88f;
-  static constexpr float kMaxZRange = 4.0f;
-  static constexpr int kNumClass = 3;
-  static constexpr int kMaxNumPillars = 32000;
-  static constexpr int kMaxNumPointsPerPillar = 20;
-  static constexpr int kNumPointFeature = 5;  // x, y, z, i, delta of time
-  static constexpr int kNumAnchor = 468 * 468 * 6;
-  static constexpr int kNumOutputBoxFeature = 7;
-  static constexpr int kBatchSize = 1;
-  static constexpr int kNumIndsForScan = 1024;
-  static constexpr int kNumThreads = 64;
-  static constexpr int kNumBoxCorners = 4;
-
-  static std::vector&lt;int&gt; AnchorStrides() { return std::vector&lt;int&gt;{1}; }
-
-  static std::vector&lt;int&gt; NumAnchorSets() { return std::vector&lt;int&gt;{6}; }
-
-  static std::vector&lt;std::vector&lt;float&gt;&gt; AnchorDxSizes() {
-    return std::vector&lt;std::vector&lt;float&gt;&gt;{
-        std::vector&lt;float&gt;{2.08, 0.84, 0.84}};
-  }
-
-  static std::vector&lt;std::vector&lt;float&gt;&gt; AnchorDySizes() {
-    return std::vector&lt;std::vector&lt;float&gt;&gt;{
-        std::vector&lt;float&gt;{4.73, 1.81, 0.91}};
-  }
-
-  static std::vector&lt;std::vector&lt;float&gt;&gt; AnchorDzSizes() {
-    return std::vector&lt;std::vector&lt;float&gt;&gt;{
-        std::vector&lt;float&gt;{1.77, 1.77, 1.74}};
-  }
-
-  static std::vector&lt;std::vector&lt;float&gt;&gt; AnchorZCoors() {
-    return std::vector&lt;std::vector&lt;float&gt;&gt;{
-        std::vector&lt;float&gt;{-0.0345, -0.1188, 0}};
-  }
-
-  static std::vector&lt;std::vector&lt;int&gt;&gt; NumAnchorRo() {
-    return std::vector&lt;std::vector&lt;int&gt;&gt;{std::vector&lt;int&gt;{2, 2, 2}};
-  }
-
-  static std::vector&lt;std::vector&lt;float&gt;&gt; AnchorRo() {
-    return std::vector&lt;std::vector&lt;float&gt;&gt;{
-        std::vector&lt;float&gt;{0, M_PI / 2, 0, M_PI / 2, 0, M_PI / 2}};
-  }
-
- private:
-  Params() = default;
-  ~Params() = default;
-};  // class Params
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\pfe_cuda.cu" new_path="" added_lines="0" deleted_lines="99">
				<diff>@@ -1,99 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/pfe_cuda.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-__global__ void gather_point_feature_kernel(
-    float* dev_pillar_point_feature, float* dev_num_points_per_pillar,
-    float* dev_pillar_coors, float* dev_pfe_gather_feature,
-    int max_num_points_per_pillar, int num_point_feature,
-    int num_gather_point_feature, float pillar_x_size, float pillar_y_size,
-    float min_x_range, float min_y_range) {
-  int tid = threadIdx.x + blockIdx.x * blockDim.x;
-  float point_mean[3];
-  for (int point_id = 0; point_id &lt; dev_num_points_per_pillar[tid];
-       ++point_id) {
-    for (int i = 0; i &lt; 3; ++i) {
-      int feature_id = i + point_id * num_point_feature +
-                       tid * max_num_points_per_pillar * num_point_feature;
-      point_mean[i] += dev_pillar_point_feature[feature_id];
-    }
-  }
-  for (int i = 0; i &lt; 3; ++i) {
-    point_mean[i] = point_mean[i] / dev_num_points_per_pillar[tid];
-  }
-
-  float x_offset = pillar_x_size / 2 + min_x_range;
-  float y_offset = pillar_y_size / 2 + min_y_range;
-  for (int point_id = 0; point_id &lt; dev_num_points_per_pillar[tid];
-       ++point_id) {
-    int point_head_id = point_id * num_point_feature +
-                        tid * max_num_points_per_pillar * num_point_feature;
-    int pfe_gather_head_id = point_id * num_gather_point_feature +
-        tid * max_num_points_per_pillar * num_gather_point_feature;
-    float point_x = dev_pillar_point_feature[point_head_id];
-    float point_y = dev_pillar_point_feature[point_head_id + 1];
-    dev_pfe_gather_feature[pfe_gather_head_id] =
-        sqrt(point_x * point_x + point_y * point_y);
-    for (int i = 2; i &lt; num_point_feature; ++i) {
-      dev_pfe_gather_feature[pfe_gather_head_id + i - 1] =
-          dev_pillar_point_feature[point_head_id + i];
-    }
-    for (int i = 4; i &lt; 7; ++i) {
-      dev_pfe_gather_feature[pfe_gather_head_id + i] =
-          dev_pillar_point_feature[point_head_id + i - 4] - point_mean[i - 4];
-    }
-    dev_pfe_gather_feature[pfe_gather_head_id + 7] =
-        dev_pillar_point_feature[point_head_id] -
-        (dev_pillar_coors[tid * 4 + 3] * pillar_x_size + x_offset);
-    dev_pfe_gather_feature[pfe_gather_head_id + 8] =
-        dev_pillar_point_feature[point_head_id + 1] -
-        (dev_pillar_coors[tid * 4 + 2] * pillar_y_size + y_offset);
-  }
-}
-
-PfeCuda::PfeCuda(int max_num_pillars, int max_num_points_per_pillar,
-                 int num_point_feature, int num_gather_point_feature,
-                 float pillar_x_size, float pillar_y_size, float min_x_range,
-                 float min_y_range, int num_threads)
-    : max_num_pillars_(max_num_pillars),
-      max_num_points_per_pillar_(max_num_points_per_pillar),
-      num_point_feature_(num_point_feature),
-      num_gather_point_feature_(num_gather_point_feature),
-      pillar_x_size_(pillar_x_size),
-      pillar_y_size_(pillar_y_size),
-      min_x_range_(min_x_range),
-      min_y_range_(min_y_range),
-      num_threads_(num_threads) {}
-
-void PfeCuda::GatherPointFeature(float* dev_pillar_point_feature,
-                                 float* dev_num_points_per_pillar,
-                                 float* dev_pillar_coors,
-                                 float* dev_pfe_gather_feature) {
-  const int num_blocks = DIVUP(max_num_pillars_, num_threads_);
-  gather_point_feature_kernel&lt;&lt;&lt;num_blocks, num_threads_&gt;&gt;&gt;(
-      dev_pillar_point_feature, dev_num_points_per_pillar, dev_pillar_coors,
-      dev_pfe_gather_feature, max_num_points_per_pillar_, num_point_feature_,
-      num_gather_point_feature_, pillar_x_size_, pillar_y_size_, min_x_range_,
-      min_y_range_);
-}
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\pfe_cuda.h" new_path="" added_lines="0" deleted_lines="51">
				<diff>@@ -1,51 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-#pragma once
-
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/common.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class PfeCuda {
- public:
-  PfeCuda(int max_num_pillars, int max_num_points_per_pillar,
-          int num_point_feature, int num_gather_point_feature,
-          float pillar_x_size, float pillar_y_size, float min_x_range,
-          float min_y_range, int num_threads);
-  ~PfeCuda() = default;
-
-  void GatherPointFeature(float* dev_pillar_point_feature,
-                          float* dev_num_points_per_pillar,
-                          float* dev_pillar_coors,
-                          float* dev_pfe_gather_feature);
-
- private:
-  int max_num_pillars_;
-  int max_num_points_per_pillar_;
-  int num_point_feature_;
-  int num_gather_point_feature_;
-  float pillar_x_size_;
-  float pillar_y_size_;
-  float min_x_range_;
-  float min_y_range_;
-  int num_threads_;
-};
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars.cc" new_path="" added_lines="0" deleted_lines="691">
				<diff>@@ -1,691 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/point_pillars.h"
-
-#include &lt;chrono&gt;
-#include &lt;iostream&gt;
-
-#include "cyber/common/log.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-const float PointPillars::kPillarXSize = Params::kPillarXSize;
-const float PointPillars::kPillarYSize = Params::kPillarYSize;
-const float PointPillars::kPillarZSize = Params::kPillarZSize;
-const float PointPillars::kMinXRange = Params::kMinXRange;
-const float PointPillars::kMinYRange = Params::kMinYRange;
-const float PointPillars::kMinZRange = Params::kMinZRange;
-const float PointPillars::kMaxXRange = Params::kMaxXRange;
-const float PointPillars::kMaxYRange = Params::kMaxYRange;
-const float PointPillars::kMaxZRange = Params::kMaxZRange;
-const int PointPillars::kNumClass = Params::kNumClass;
-const int PointPillars::kMaxNumPillars = Params::kMaxNumPillars;
-const int PointPillars::kMaxNumPointsPerPillar = Params::kMaxNumPointsPerPillar;
-const int PointPillars::kNumPointFeature = Params::kNumPointFeature;
-const int PointPillars::kGridXSize =
-    static_cast&lt;int&gt;((kMaxXRange - kMinXRange) / kPillarXSize);
-const int PointPillars::kGridYSize =
-    static_cast&lt;int&gt;((kMaxYRange - kMinYRange) / kPillarYSize);
-const int PointPillars::kGridZSize =
-    static_cast&lt;int&gt;((kMaxZRange - kMinZRange) / kPillarZSize);
-const int PointPillars::kRpnInputSize = 64 * kGridXSize * kGridYSize;
-const int PointPillars::kNumAnchor = Params::kNumAnchor;
-const int PointPillars::kNumOutputBoxFeature = Params::kNumOutputBoxFeature;
-const int PointPillars::kRpnBoxOutputSize = kNumAnchor * kNumOutputBoxFeature;
-const int PointPillars::kRpnClsOutputSize = kNumAnchor * kNumClass;
-const int PointPillars::kRpnDirOutputSize = kNumAnchor * 2;
-const int PointPillars::kBatchSize = Params::kBatchSize;
-const int PointPillars::kNumIndsForScan = Params::kNumIndsForScan;
-const int PointPillars::kNumThreads = Params::kNumThreads;
-// if you change kNumThreads, need to modify NUM_THREADS_MACRO in
-// common.h
-const int PointPillars::kNumBoxCorners = Params::kNumBoxCorners;
-const std::vector&lt;int&gt; PointPillars::kAnchorStrides = Params::AnchorStrides();
-const std::vector&lt;int&gt; PointPillars::kAnchorRanges{
-    0,
-    kGridXSize,
-    0,
-    kGridYSize,
-    static_cast&lt;int&gt;(kGridXSize * 0.25),
-    static_cast&lt;int&gt;(kGridXSize * 0.75),
-    static_cast&lt;int&gt;(kGridYSize * 0.25),
-    static_cast&lt;int&gt;(kGridYSize * 0.75)};
-const std::vector&lt;int&gt; PointPillars::kNumAnchorSets = Params::NumAnchorSets();
-const std::vector&lt;std::vector&lt;float&gt;&gt; PointPillars::kAnchorDxSizes =
-    Params::AnchorDxSizes();
-const std::vector&lt;std::vector&lt;float&gt;&gt; PointPillars::kAnchorDySizes =
-    Params::AnchorDySizes();
-const std::vector&lt;std::vector&lt;float&gt;&gt; PointPillars::kAnchorDzSizes =
-    Params::AnchorDzSizes();
-const std::vector&lt;std::vector&lt;float&gt;&gt; PointPillars::kAnchorZCoors =
-    Params::AnchorZCoors();
-const std::vector&lt;std::vector&lt;int&gt;&gt; PointPillars::kNumAnchorRo =
-    Params::NumAnchorRo();
-const std::vector&lt;std::vector&lt;float&gt;&gt; PointPillars::kAnchorRo =
-    Params::AnchorRo();
-
-PointPillars::PointPillars(const bool reproduce_result_mode,
-                           const float score_threshold,
-                           const float nms_overlap_threshold,
-                           const std::string&amp; pfe_torch_file,
-                           const std::string&amp; scattered_torch_file,
-                           const std::string&amp; backbone_torch_file,
-                           const std::string&amp; fpn_torch_file,
-                           const std::string&amp; bbox_head_torch_file)
-    : reproduce_result_mode_(reproduce_result_mode),
-      score_threshold_(score_threshold),
-      nms_overlap_threshold_(nms_overlap_threshold),
-      pfe_torch_file_(pfe_torch_file),
-      scattered_torch_file_(scattered_torch_file),
-      backbone_torch_file_(backbone_torch_file),
-      fpn_torch_file_(fpn_torch_file),
-      bbox_head_torch_file_(bbox_head_torch_file) {
-  if (reproduce_result_mode_) {
-    preprocess_points_ptr_.reset(new PreprocessPoints(
-        kMaxNumPillars, kMaxNumPointsPerPillar, kNumPointFeature, kGridXSize,
-        kGridYSize, kGridZSize, kPillarXSize, kPillarYSize, kPillarZSize,
-        kMinXRange, kMinYRange, kMinZRange, kNumIndsForScan));
-  } else {
-    preprocess_points_cuda_ptr_.reset(new PreprocessPointsCuda(
-        kNumThreads, kMaxNumPillars, kMaxNumPointsPerPillar, kNumPointFeature,
-        kNumIndsForScan, kGridXSize, kGridYSize, kGridZSize, kPillarXSize,
-        kPillarYSize, kPillarZSize, kMinXRange, kMinYRange, kMinZRange));
-  }
-
-  anchor_mask_cuda_ptr_.reset(new AnchorMaskCuda(
-      kNumThreads, kNumIndsForScan, kNumAnchor, kMinXRange, kMinYRange,
-      kPillarXSize, kPillarYSize, kGridXSize, kGridYSize));
-
-  const float float_min = std::numeric_limits&lt;float&gt;::lowest();
-  const float float_max = std::numeric_limits&lt;float&gt;::max();
-  postprocess_cuda_ptr_.reset(
-      new PostprocessCuda(float_min, float_max, kNumAnchor, kNumClass,
-                          score_threshold_, kNumThreads, nms_overlap_threshold_,
-                          kNumBoxCorners, kNumOutputBoxFeature));
-
-  DeviceMemoryMalloc();
-  InitTorch();
-  InitAnchors();
-}
-
-PointPillars::~PointPillars() {
-  delete[] anchors_px_;
-  delete[] anchors_py_;
-  delete[] anchors_pz_;
-  delete[] anchors_dx_;
-  delete[] anchors_dy_;
-  delete[] anchors_dz_;
-  delete[] anchors_ro_;
-  delete[] box_anchors_min_x_;
-  delete[] box_anchors_min_y_;
-  delete[] box_anchors_max_x_;
-  delete[] box_anchors_max_y_;
-
-  GPU_CHECK(cudaFree(dev_x_coors_));
-  GPU_CHECK(cudaFree(dev_y_coors_));
-  GPU_CHECK(cudaFree(dev_num_points_per_pillar_));
-  GPU_CHECK(cudaFree(dev_sparse_pillar_map_));
-  GPU_CHECK(cudaFree(dev_pillar_point_feature_));
-  GPU_CHECK(cudaFree(dev_pillar_coors_));
-
-  GPU_CHECK(cudaFree(dev_cumsum_along_x_));
-  GPU_CHECK(cudaFree(dev_cumsum_along_y_));
-
-  GPU_CHECK(cudaFree(dev_box_anchors_min_x_));
-  GPU_CHECK(cudaFree(dev_box_anchors_min_y_));
-  GPU_CHECK(cudaFree(dev_box_anchors_max_x_));
-  GPU_CHECK(cudaFree(dev_box_anchors_max_y_));
-  GPU_CHECK(cudaFree(dev_anchor_mask_));
-
-  GPU_CHECK(cudaFree(pfe_buffers_[0]));
-  GPU_CHECK(cudaFree(pfe_buffers_[1]));
-  GPU_CHECK(cudaFree(pfe_buffers_[2]));
-
-  GPU_CHECK(cudaFree(rpn_buffers_[0]));
-  GPU_CHECK(cudaFree(rpn_buffers_[1]));
-  GPU_CHECK(cudaFree(rpn_buffers_[2]));
-  GPU_CHECK(cudaFree(rpn_buffers_[3]));
-
-  GPU_CHECK(cudaFree(dev_scattered_feature_));
-
-  GPU_CHECK(cudaFree(dev_anchors_px_));
-  GPU_CHECK(cudaFree(dev_anchors_py_));
-  GPU_CHECK(cudaFree(dev_anchors_pz_));
-  GPU_CHECK(cudaFree(dev_anchors_dx_));
-  GPU_CHECK(cudaFree(dev_anchors_dy_));
-  GPU_CHECK(cudaFree(dev_anchors_dz_));
-  GPU_CHECK(cudaFree(dev_anchors_ro_));
-  GPU_CHECK(cudaFree(dev_filtered_box_));
-  GPU_CHECK(cudaFree(dev_filtered_score_));
-  GPU_CHECK(cudaFree(dev_filtered_label_));
-  GPU_CHECK(cudaFree(dev_filtered_dir_));
-  GPU_CHECK(cudaFree(dev_box_for_nms_));
-  GPU_CHECK(cudaFree(dev_filter_count_));
-}
-
-void PointPillars::DeviceMemoryMalloc() {
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_x_coors_),
-                       kMaxNumPillars * sizeof(int)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_y_coors_),
-                       kMaxNumPillars * sizeof(int)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_num_points_per_pillar_),
-                       kMaxNumPillars * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_sparse_pillar_map_),
-                       kNumIndsForScan * kNumIndsForScan * sizeof(int)));
-
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_pillar_point_feature_),
-                       kMaxNumPillars * kMaxNumPointsPerPillar *
-                           kNumPointFeature * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_pillar_coors_),
-                       kMaxNumPillars * 4 * sizeof(float)));
-
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_cumsum_along_x_),
-                       kNumIndsForScan * kNumIndsForScan * sizeof(int)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_cumsum_along_y_),
-                       kNumIndsForScan * kNumIndsForScan * sizeof(int)));
-
-  // for make anchor mask kernel
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_box_anchors_min_x_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_box_anchors_min_y_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_box_anchors_max_x_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_box_anchors_max_y_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_anchor_mask_),
-                       kNumAnchor * sizeof(int)));
-
-  // for trt inference
-  // create GPU buffers and a stream
-  GPU_CHECK(
-      cudaMalloc(&amp;pfe_buffers_[0], kMaxNumPillars * kMaxNumPointsPerPillar *
-                                       kNumPointFeature * sizeof(float)));
-  GPU_CHECK(cudaMalloc(&amp;pfe_buffers_[1], kMaxNumPillars * sizeof(float)));
-  GPU_CHECK(cudaMalloc(&amp;pfe_buffers_[2], kMaxNumPillars * 4 * sizeof(float)));
-
-  GPU_CHECK(cudaMalloc(&amp;rpn_buffers_[0], kRpnInputSize * sizeof(float)));
-  GPU_CHECK(cudaMalloc(&amp;rpn_buffers_[1], kRpnBoxOutputSize * sizeof(float)));
-  GPU_CHECK(cudaMalloc(&amp;rpn_buffers_[2], kRpnClsOutputSize * sizeof(float)));
-  GPU_CHECK(cudaMalloc(&amp;rpn_buffers_[3], kRpnDirOutputSize * sizeof(float)));
-
-  // for scatter kernel
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_scattered_feature_),
-                       kNumThreads * kGridYSize * kGridXSize * sizeof(float)));
-
-  // for filter
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_anchors_px_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_anchors_py_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_anchors_pz_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_anchors_dx_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_anchors_dy_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_anchors_dz_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_anchors_ro_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_filtered_box_),
-                       kNumAnchor * kNumOutputBoxFeature * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_filtered_score_),
-                       kNumAnchor * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_filtered_label_),
-                       kNumAnchor * sizeof(int)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_filtered_dir_),
-                       kNumAnchor * sizeof(int)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_box_for_nms_),
-                       kNumAnchor * kNumBoxCorners * sizeof(float)));
-  GPU_CHECK(
-      cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_filter_count_), sizeof(int)));
-}
-
-void PointPillars::InitAnchors() {
-  // allocate memory for anchors
-  anchors_px_ = new float[kNumAnchor]();
-  anchors_py_ = new float[kNumAnchor]();
-  anchors_pz_ = new float[kNumAnchor]();
-  anchors_dx_ = new float[kNumAnchor]();
-  anchors_dy_ = new float[kNumAnchor]();
-  anchors_dz_ = new float[kNumAnchor]();
-  anchors_ro_ = new float[kNumAnchor]();
-  box_anchors_min_x_ = new float[kNumAnchor]();
-  box_anchors_min_y_ = new float[kNumAnchor]();
-  box_anchors_max_x_ = new float[kNumAnchor]();
-  box_anchors_max_y_ = new float[kNumAnchor]();
-  // deallocate these memories in destructor
-
-  GenerateAnchors(anchors_px_, anchors_py_, anchors_pz_, anchors_dx_,
-                  anchors_dy_, anchors_dz_, anchors_ro_);
-
-  ConvertAnchors2BoxAnchors(anchors_px_, anchors_py_, box_anchors_min_x_,
-                            box_anchors_min_y_, box_anchors_max_x_,
-                            box_anchors_max_y_);
-
-  PutAnchorsInDeviceMemory();
-}
-
-void PointPillars::GenerateAnchors(float* anchors_px_, float* anchors_py_,
-                                   float* anchors_pz_, float* anchors_dx_,
-                                   float* anchors_dy_, float* anchors_dz_,
-                                   float* anchors_ro_) {
-  for (int i = 0; i &lt; kNumAnchor; ++i) {
-    anchors_px_[i] = 0;
-    anchors_py_[i] = 0;
-    anchors_pz_[i] = 0;
-    anchors_dx_[i] = 0;
-    anchors_dy_[i] = 0;
-    anchors_dz_[i] = 0;
-    anchors_ro_[i] = 0;
-    box_anchors_min_x_[i] = 0;
-    box_anchors_min_y_[i] = 0;
-    box_anchors_max_x_[i] = 0;
-    box_anchors_max_y_[i] = 0;
-  }
-
-  int ind = 0;
-  for (size_t head = 0; head &lt; kNumAnchorSets.size(); ++head) {
-    float x_stride = kPillarXSize * kAnchorStrides[head];
-    float y_stride = kPillarYSize * kAnchorStrides[head];
-    int x_ind_start = kAnchorRanges[head * 4 + 0] / kAnchorStrides[head];
-    int x_ind_end = kAnchorRanges[head * 4 + 1] / kAnchorStrides[head];
-    int y_ind_start = kAnchorRanges[head * 4 + 2] / kAnchorStrides[head];
-    int y_ind_end = kAnchorRanges[head * 4 + 3] / kAnchorStrides[head];
-    // coors of first anchor's center
-    float x_offset = kMinXRange + x_stride / 2.0;
-    float y_offset = kMinYRange + y_stride / 2.0;
-
-    std::vector&lt;float&gt; anchor_x_count, anchor_y_count;
-    for (int i = x_ind_start; i &lt; x_ind_end; ++i) {
-      float anchor_coor_x = static_cast&lt;float&gt;(i) * x_stride + x_offset;
-      anchor_x_count.push_back(anchor_coor_x);
-    }
-    for (int i = y_ind_start; i &lt; y_ind_end; ++i) {
-      float anchor_coor_y = static_cast&lt;float&gt;(i) * y_stride + y_offset;
-      anchor_y_count.push_back(anchor_coor_y);
-    }
-
-    for (int y = 0; y &lt; y_ind_end - y_ind_start; ++y) {
-      for (int x = 0; x &lt; x_ind_end - x_ind_start; ++x) {
-        int ro_count = 0;
-        for (size_t c = 0; c &lt; kNumAnchorRo[head].size(); ++c) {
-          for (int i = 0; i &lt; kNumAnchorRo[head][c]; ++i) {
-            anchors_px_[ind] = anchor_x_count[x];
-            anchors_py_[ind] = anchor_y_count[y];
-            anchors_ro_[ind] = kAnchorRo[head][ro_count];
-            anchors_pz_[ind] = kAnchorZCoors[head][c];
-            anchors_dx_[ind] = kAnchorDxSizes[head][c];
-            anchors_dy_[ind] = kAnchorDySizes[head][c];
-            anchors_dz_[ind] = kAnchorDzSizes[head][c];
-            ro_count++;
-            ind++;
-          }
-        }
-      }
-    }
-  }
-}
-
-void PointPillars::PutAnchorsInDeviceMemory() {
-  GPU_CHECK(cudaMemcpy(dev_box_anchors_min_x_, box_anchors_min_x_,
-                       kNumAnchor * sizeof(float), cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_box_anchors_min_y_, box_anchors_min_y_,
-                       kNumAnchor * sizeof(float), cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_box_anchors_max_x_, box_anchors_max_x_,
-                       kNumAnchor * sizeof(float), cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_box_anchors_max_y_, box_anchors_max_y_,
-                       kNumAnchor * sizeof(float), cudaMemcpyHostToDevice));
-
-  GPU_CHECK(cudaMemcpy(dev_anchors_px_, anchors_px_, kNumAnchor * sizeof(float),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_anchors_py_, anchors_py_, kNumAnchor * sizeof(float),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_anchors_pz_, anchors_pz_, kNumAnchor * sizeof(float),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_anchors_dx_, anchors_dx_, kNumAnchor * sizeof(float),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_anchors_dy_, anchors_dy_, kNumAnchor * sizeof(float),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_anchors_dz_, anchors_dz_, kNumAnchor * sizeof(float),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_anchors_ro_, anchors_ro_, kNumAnchor * sizeof(float),
-                       cudaMemcpyHostToDevice));
-}
-
-void PointPillars::ConvertAnchors2BoxAnchors(float* anchors_px,
-                                             float* anchors_py,
-                                             float* box_anchors_min_x_,
-                                             float* box_anchors_min_y_,
-                                             float* box_anchors_max_x_,
-                                             float* box_anchors_max_y_) {
-  // flipping box's dimension
-  float* flipped_anchors_dx = new float[kNumAnchor]();
-  float* flipped_anchors_dy = new float[kNumAnchor]();
-
-  int ind = 0;
-  for (size_t head = 0; head &lt; kNumAnchorSets.size(); ++head) {
-    int num_x_inds =
-        (kAnchorRanges[head * 4 + 1] - kAnchorRanges[head * 4 + 0]) /
-        kAnchorStrides[head];
-    int num_y_inds =
-        (kAnchorRanges[head * 4 + 3] - kAnchorRanges[head * 4 + 2]) /
-        kAnchorStrides[head];
-    int base_ind = ind;
-    int ro_count = 0;
-    for (int x = 0; x &lt; num_x_inds; ++x) {
-      for (int y = 0; y &lt; num_y_inds; ++y) {
-        ro_count = 0;
-        for (size_t c = 0; c &lt; kNumAnchorRo[head].size(); ++c) {
-          for (int i = 0; i &lt; kNumAnchorRo[head][c]; ++i) {
-            if (kAnchorRo[head][ro_count] &lt;= 0.78) {
-              flipped_anchors_dx[base_ind] = kAnchorDxSizes[head][c];
-              flipped_anchors_dy[base_ind] = kAnchorDySizes[head][c];
-            } else {
-              flipped_anchors_dx[base_ind] = kAnchorDySizes[head][c];
-              flipped_anchors_dy[base_ind] = kAnchorDxSizes[head][c];
-            }
-            ro_count++;
-            base_ind++;
-          }
-        }
-      }
-    }
-
-    for (int x = 0; x &lt; num_x_inds; ++x) {
-      for (int y = 0; y &lt; num_y_inds; ++y) {
-        for (size_t i = 0; i &lt; kAnchorRo[head].size(); ++i) {
-          box_anchors_min_x_[ind] =
-              anchors_px[ind] - flipped_anchors_dx[ind] / 2.0f;
-          box_anchors_min_y_[ind] =
-              anchors_py[ind] - flipped_anchors_dy[ind] / 2.0f;
-          box_anchors_max_x_[ind] =
-              anchors_px[ind] + flipped_anchors_dx[ind] / 2.0f;
-          box_anchors_max_y_[ind] =
-              anchors_py[ind] + flipped_anchors_dy[ind] / 2.0f;
-          ind++;
-        }
-      }
-    }
-  }
-
-  delete[] flipped_anchors_dx;
-  delete[] flipped_anchors_dy;
-}
-
-void PointPillars::InitTorch() {
-  if (gpu_id_ &gt;= 0) {
-    device_type_ = torch::kCUDA;
-    device_id_ = gpu_id_;
-  } else {
-    device_type_ = torch::kCPU;
-  }
-
-  // Init torch net
-  torch::Device device(device_type_, device_id_);
-
-  pfe_net_ = torch::jit::load(pfe_torch_file_, device);
-  scattered_net_ = torch::jit::load(scattered_torch_file_, device);
-  backbone_net_ = torch::jit::load(backbone_torch_file_, device);
-  fpn_net_ = torch::jit::load(fpn_torch_file_, device);
-  bbox_head_net_ = torch::jit::load(bbox_head_torch_file_, device);
-}
-
-void PointPillars::InitTRT() {
-  // create a TensorRT model from the onnx model and load it into an engine
-  OnnxToTRTModel(pfe_onnx_file_, &amp;pfe_engine_);
-  OnnxToTRTModel(rpn_onnx_file_, &amp;rpn_engine_);
-  if (pfe_engine_ == nullptr || rpn_engine_ == nullptr) {
-    AERROR &lt;&lt; "Failed to load ONNX file.";
-  }
-
-  // create execution context from the engine
-  pfe_context_ = pfe_engine_-&gt;createExecutionContext();
-  rpn_context_ = rpn_engine_-&gt;createExecutionContext();
-  if (pfe_context_ == nullptr || rpn_context_ == nullptr) {
-    AERROR &lt;&lt; "Failed to create TensorRT Execution Context.";
-  }
-}
-
-void PointPillars::OnnxToTRTModel(
-    const std::string&amp; model_file,  // name of the onnx model
-    nvinfer1::ICudaEngine** engine_ptr) {
-  int verbosity = static_cast&lt;int&gt;(nvinfer1::ILogger::Severity::kWARNING);
-
-  // create the builder
-  const auto explicit_batch =
-      static_cast&lt;uint32_t&gt;(kBatchSize) &lt;&lt; static_cast&lt;uint32_t&gt;(
-          nvinfer1::NetworkDefinitionCreationFlag::kEXPLICIT_BATCH);
-  nvinfer1::IBuilder* builder = nvinfer1::createInferBuilder(g_logger_);
-  nvinfer1::INetworkDefinition* network =
-      builder-&gt;createNetworkV2(explicit_batch);
-
-  // parse onnx model
-  auto parser = nvonnxparser::createParser(*network, g_logger_);
-  if (!parser-&gt;parseFromFile(model_file.c_str(), verbosity)) {
-    std::string msg("failed to parse onnx file");
-    g_logger_.log(nvinfer1::ILogger::Severity::kERROR, msg.c_str());
-    exit(EXIT_FAILURE);
-  }
-
-  // Build the engine
-  builder-&gt;setMaxBatchSize(kBatchSize);
-  nvinfer1::IBuilderConfig* config = builder-&gt;createBuilderConfig();
-  config-&gt;setMaxWorkspaceSize(1 &lt;&lt; 20);
-  nvinfer1::ICudaEngine* engine =
-      builder-&gt;buildEngineWithConfig(*network, *config);
-
-  *engine_ptr = engine;
-  parser-&gt;destroy();
-  network-&gt;destroy();
-  config-&gt;destroy();
-  builder-&gt;destroy();
-}
-
-void PointPillars::PreprocessCPU(const float* in_points_array,
-                                 const int in_num_points) {
-  int x_coors[kMaxNumPillars] = {};
-  int y_coors[kMaxNumPillars] = {};
-  float num_points_per_pillar[kMaxNumPillars] = {};
-
-  float* pillar_point_feature =
-      new float[kMaxNumPillars * kMaxNumPointsPerPillar * kNumPointFeature];
-  float* pillar_coors = new float[kMaxNumPillars * 4];
-  float* sparse_pillar_map = new float[kNumIndsForScan * kNumIndsForScan];
-
-  preprocess_points_ptr_-&gt;Preprocess(in_points_array, in_num_points, x_coors,
-                                     y_coors, num_points_per_pillar,
-                                     pillar_point_feature, pillar_coors,
-                                     sparse_pillar_map, host_pillar_count_);
-
-  GPU_CHECK(cudaMemset(dev_x_coors_, 0, kMaxNumPillars * sizeof(int)));
-  GPU_CHECK(cudaMemset(dev_y_coors_, 0, kMaxNumPillars * sizeof(int)));
-  GPU_CHECK(cudaMemset(dev_pillar_point_feature_, 0,
-                       kMaxNumPillars * kMaxNumPointsPerPillar *
-                           kNumPointFeature * sizeof(float)));
-  GPU_CHECK(
-      cudaMemset(dev_pillar_coors_, 0, kMaxNumPillars * 4 * sizeof(float)));
-  GPU_CHECK(cudaMemset(dev_num_points_per_pillar_, 0,
-                       kMaxNumPillars * sizeof(float)));
-  GPU_CHECK(cudaMemset(dev_sparse_pillar_map_, 0,
-                       kNumIndsForScan * kNumIndsForScan * sizeof(int)));
-
-  GPU_CHECK(cudaMemcpy(dev_x_coors_, x_coors, kMaxNumPillars * sizeof(int),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_y_coors_, y_coors, kMaxNumPillars * sizeof(int),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_pillar_point_feature_, pillar_point_feature,
-                       kMaxNumPillars * kMaxNumPointsPerPillar *
-                           kNumPointFeature * sizeof(float),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_pillar_coors_, pillar_coors,
-                       kMaxNumPillars * 4 * sizeof(float),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_num_points_per_pillar_, num_points_per_pillar,
-                       kMaxNumPillars * sizeof(float), cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemcpy(dev_sparse_pillar_map_, sparse_pillar_map,
-                       kNumIndsForScan * kNumIndsForScan * sizeof(float),
-                       cudaMemcpyHostToDevice));
-
-  delete[] pillar_point_feature;
-  delete[] pillar_coors;
-  delete[] sparse_pillar_map;
-}
-
-void PointPillars::PreprocessGPU(const float* in_points_array,
-                                 const int in_num_points) {
-  float* dev_points;
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_points),
-                       in_num_points * kNumPointFeature * sizeof(float)));
-  GPU_CHECK(cudaMemcpy(dev_points, in_points_array,
-                       in_num_points * kNumPointFeature * sizeof(float),
-                       cudaMemcpyHostToDevice));
-
-  GPU_CHECK(cudaMemset(dev_x_coors_, 0, kMaxNumPillars * sizeof(int)));
-  GPU_CHECK(cudaMemset(dev_y_coors_, 0, kMaxNumPillars * sizeof(int)));
-  GPU_CHECK(cudaMemset(dev_num_points_per_pillar_, 0,
-                       kMaxNumPillars * sizeof(float)));
-  GPU_CHECK(cudaMemset(dev_pillar_point_feature_, 0,
-                       kMaxNumPillars * kMaxNumPointsPerPillar *
-                           kNumPointFeature * sizeof(float)));
-  GPU_CHECK(
-      cudaMemset(dev_pillar_coors_, 0, kMaxNumPillars * 4 * sizeof(float)));
-  GPU_CHECK(cudaMemset(dev_sparse_pillar_map_, 0,
-                       kNumIndsForScan * kNumIndsForScan * sizeof(int)));
-  host_pillar_count_[0] = 0;
-
-  GPU_CHECK(cudaMemset(dev_anchor_mask_, 0, kNumAnchor * sizeof(int)));
-
-  preprocess_points_cuda_ptr_-&gt;DoPreprocessPointsCuda(
-      dev_points, in_num_points, dev_x_coors_, dev_y_coors_,
-      dev_num_points_per_pillar_, dev_pillar_point_feature_, dev_pillar_coors_,
-      dev_sparse_pillar_map_, host_pillar_count_);
-
-  GPU_CHECK(cudaFree(dev_points));
-}
-
-void PointPillars::Preprocess(const float* in_points_array,
-                              const int in_num_points) {
-  if (reproduce_result_mode_) {
-    PreprocessCPU(in_points_array, in_num_points);
-  } else {
-    PreprocessGPU(in_points_array, in_num_points);
-  }
-}
-
-void PointPillars::DoInference(const float* in_points_array,
-                               const int in_num_points,
-                               std::vector&lt;float&gt;* out_detections,
-                               std::vector&lt;int&gt;* out_labels) {
-  if (device_id_ &lt; 0) {
-    AERROR &lt;&lt; "Torch is not using GPU!";
-    return;
-  }
-
-  Preprocess(in_points_array, in_num_points);
-
-  anchor_mask_cuda_ptr_-&gt;DoAnchorMaskCuda(
-      dev_sparse_pillar_map_, dev_cumsum_along_x_, dev_cumsum_along_y_,
-      dev_box_anchors_min_x_, dev_box_anchors_min_y_, dev_box_anchors_max_x_,
-      dev_box_anchors_max_y_, dev_anchor_mask_);
-
-  cudaStream_t stream;
-  GPU_CHECK(cudaStreamCreate(&amp;stream));
-  GPU_CHECK(cudaMemcpyAsync(pfe_buffers_[0], dev_pillar_point_feature_,
-                            kMaxNumPillars * kMaxNumPointsPerPillar *
-                                kNumPointFeature * sizeof(float),
-                            cudaMemcpyDeviceToDevice, stream));
-  GPU_CHECK(cudaMemcpyAsync(pfe_buffers_[1], dev_num_points_per_pillar_,
-                            kMaxNumPillars * sizeof(float),
-                            cudaMemcpyDeviceToDevice, stream));
-  GPU_CHECK(cudaMemcpyAsync(pfe_buffers_[2], dev_pillar_coors_,
-                            kMaxNumPillars * 4 * sizeof(float),
-                            cudaMemcpyDeviceToDevice, stream));
-
-  torch::Tensor tensor_pillar_point_feature = torch::from_blob(
-      pfe_buffers_[0],
-      {kMaxNumPillars, kMaxNumPointsPerPillar, kNumPointFeature}, torch::kCUDA);
-  torch::Tensor tensor_num_points_per_pillar =
-      torch::from_blob(pfe_buffers_[1], {kMaxNumPillars}, torch::kCUDA);
-  torch::Tensor tensor_pillar_coors =
-      torch::from_blob(pfe_buffers_[2], {kMaxNumPillars, 4}, torch::kCUDA);
-
-  torch::Device device(device_type_, device_id_);
-  tensor_pillar_point_feature.to(device);
-  tensor_num_points_per_pillar.to(device);
-  tensor_pillar_coors.to(device);
-
-  torch::Tensor scattered_batch_size = torch::ones(1);
-  scattered_batch_size.to(device);
-
-  auto pfe_output =
-      pfe_net_
-          .forward({tensor_pillar_point_feature, tensor_num_points_per_pillar,
-                    tensor_pillar_coors})
-          .toTensor();
-
-  auto scattered_feature =
-      scattered_net_
-          .forward({pfe_output, tensor_pillar_coors, scattered_batch_size})
-          .toTensor();
-
-  auto backbone_feature = backbone_net_.forward({scattered_feature});
-
-  auto fpn_feature = fpn_net_.forward({backbone_feature});
-
-  auto bbox_head_output = bbox_head_net_.forward({fpn_feature}).toTuple();
-
-  auto cls_score = bbox_head_output-&gt;elements()[0].toTensor();
-  auto bbox_pred = bbox_head_output-&gt;elements()[1].toTensor();
-  auto dir_cls_preds = bbox_head_output-&gt;elements()[2].toTensor();
-
-  GPU_CHECK(cudaMemset(dev_filter_count_, 0, sizeof(int)));
-  postprocess_cuda_ptr_-&gt;DoPostprocessCuda(
-      bbox_pred.data_ptr&lt;float&gt;(),
-      cls_score.data_ptr&lt;float&gt;(),
-      dir_cls_preds.data_ptr&lt;float&gt;(),
-      dev_anchor_mask_, dev_anchors_px_, dev_anchors_py_, dev_anchors_pz_,
-      dev_anchors_dx_, dev_anchors_dy_, dev_anchors_dz_, dev_anchors_ro_,
-      dev_filtered_box_, dev_filtered_score_, dev_filtered_label_,
-      dev_filtered_dir_, dev_box_for_nms_, dev_filter_count_, out_detections,
-      out_labels);
-
-  // release the stream and the buffers
-  cudaStreamDestroy(stream);
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars.h" new_path="" added_lines="0" deleted_lines="375">
				<diff>@@ -1,375 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file point_pillars.h
- * @brief Algorithm for PointPillars
- * @author Kosuke Murakami
- * @date 2019/02/26
- */
-
-#pragma once
-
-// headers in STL
-#include &lt;algorithm&gt;
-#include &lt;cmath&gt;
-#include &lt;iomanip&gt;
-#include &lt;limits&gt;
-#include &lt;map&gt;
-#include &lt;memory&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-// headers in TensorRT
-#include "NvInfer.h"
-#include "NvOnnxParser.h"
-#include "torch/script.h"
-#include "torch/torch.h"
-
-// headers in local files
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/anchor_mask_cuda.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/common.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/params.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/postprocess_cuda.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/preprocess_points.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/preprocess_points_cuda.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/scatter_cuda.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-// Logger for TensorRT info/warning/errors
-class Logger : public nvinfer1::ILogger {
- public:
-  explicit Logger(Severity severity = Severity::kWARNING)
-      : reportable_severity(severity) {}
-
-  void log(Severity severity, const char* msg) override {
-    // suppress messages with severity enum value greater than the reportable
-    if (severity &gt; reportable_severity) return;
-
-    switch (severity) {
-      case Severity::kINTERNAL_ERROR:
-        std::cerr &lt;&lt; "INTERNAL_ERROR: ";
-        break;
-      case Severity::kERROR:
-        std::cerr &lt;&lt; "ERROR: ";
-        break;
-      case Severity::kWARNING:
-        std::cerr &lt;&lt; "WARNING: ";
-        break;
-      case Severity::kINFO:
-        std::cerr &lt;&lt; "INFO: ";
-        break;
-      default:
-        std::cerr &lt;&lt; "UNKNOWN: ";
-        break;
-    }
-    std::cerr &lt;&lt; msg &lt;&lt; std::endl;
-  }
-
-  Severity reportable_severity;
-};
-
-class PointPillars {
- private:
-  friend class TestClass;
-  static const float kPillarXSize;
-  static const float kPillarYSize;
-  static const float kPillarZSize;
-  static const float kMinXRange;
-  static const float kMinYRange;
-  static const float kMinZRange;
-  static const float kMaxXRange;
-  static const float kMaxYRange;
-  static const float kMaxZRange;
-  static const int kNumClass;
-  static const int kMaxNumPillars;
-  static const int kMaxNumPointsPerPillar;
-  static const int kNumPointFeature;
-  static const int kGridXSize;
-  static const int kGridYSize;
-  static const int kGridZSize;
-  static const int kRpnInputSize;
-  static const int kNumAnchor;
-  static const int kNumOutputBoxFeature;
-  static const int kRpnBoxOutputSize;
-  static const int kRpnClsOutputSize;
-  static const int kRpnDirOutputSize;
-  static const int kBatchSize;
-  static const int kNumIndsForScan;
-  static const int kNumThreads;
-  // if you change kNumThreads, need to modify NUM_THREADS_MACRO in
-  // common.h
-  static const int kNumBoxCorners;
-  static const std::vector&lt;int&gt; kAnchorStrides;
-  static const std::vector&lt;int&gt; kAnchorRanges;
-  static const std::vector&lt;int&gt; kNumAnchorSets;
-  static const std::vector&lt;std::vector&lt;float&gt;&gt; kAnchorDxSizes;
-  static const std::vector&lt;std::vector&lt;float&gt;&gt; kAnchorDySizes;
-  static const std::vector&lt;std::vector&lt;float&gt;&gt; kAnchorDzSizes;
-  static const std::vector&lt;std::vector&lt;float&gt;&gt; kAnchorZCoors;
-  static const std::vector&lt;std::vector&lt;int&gt;&gt; kNumAnchorRo;
-  static const std::vector&lt;std::vector&lt;float&gt;&gt; kAnchorRo;
-
-  // initialize in initializer list
-  const bool reproduce_result_mode_;
-  const float score_threshold_;
-  const float nms_overlap_threshold_;
-  const std::string pfe_onnx_file_;
-  const std::string rpn_onnx_file_;
-  const std::string pfe_torch_file_;
-  const std::string scattered_torch_file_;
-  const std::string backbone_torch_file_;
-  const std::string fpn_torch_file_;
-  const std::string bbox_head_torch_file_;
-  // end initializer list
-
-  int host_pillar_count_[1];
-
-  float* anchors_px_;
-  float* anchors_py_;
-  float* anchors_pz_;
-  float* anchors_dx_;
-  float* anchors_dy_;
-  float* anchors_dz_;
-  float* anchors_ro_;
-
-  float* box_anchors_min_x_;
-  float* box_anchors_min_y_;
-  float* box_anchors_max_x_;
-  float* box_anchors_max_y_;
-
-  int* dev_x_coors_;
-  int* dev_y_coors_;
-  float* dev_num_points_per_pillar_;
-  int* dev_sparse_pillar_map_;
-  int* dev_cumsum_along_x_;
-  int* dev_cumsum_along_y_;
-
-  float* dev_pillar_point_feature_;
-  float* dev_pillar_coors_;
-
-  float* dev_box_anchors_min_x_;
-  float* dev_box_anchors_min_y_;
-  float* dev_box_anchors_max_x_;
-  float* dev_box_anchors_max_y_;
-  int* dev_anchor_mask_;
-
-  void* pfe_buffers_[3];
-  void* rpn_buffers_[4];
-
-  float* dev_scattered_feature_;
-
-  float* dev_anchors_px_;
-  float* dev_anchors_py_;
-  float* dev_anchors_pz_;
-  float* dev_anchors_dx_;
-  float* dev_anchors_dy_;
-  float* dev_anchors_dz_;
-  float* dev_anchors_ro_;
-  float* dev_filtered_box_;
-  float* dev_filtered_score_;
-  int* dev_filtered_label_;
-  int* dev_filtered_dir_;
-  float* dev_box_for_nms_;
-  int* dev_filter_count_;
-
-  std::unique_ptr&lt;PreprocessPoints&gt; preprocess_points_ptr_;
-  std::unique_ptr&lt;PreprocessPointsCuda&gt; preprocess_points_cuda_ptr_;
-  std::unique_ptr&lt;AnchorMaskCuda&gt; anchor_mask_cuda_ptr_;
-  std::unique_ptr&lt;PostprocessCuda&gt; postprocess_cuda_ptr_;
-
-  Logger g_logger_;
-  nvinfer1::ICudaEngine* pfe_engine_;
-  nvinfer1::ICudaEngine* rpn_engine_;
-  nvinfer1::IExecutionContext* pfe_context_;
-  nvinfer1::IExecutionContext* rpn_context_;
-
-  int device_id_ = -1;
-  int gpu_id_ = 0;
-  torch::DeviceType device_type_;
-  torch::jit::script::Module pfe_net_;
-  torch::jit::script::Module scattered_net_;
-  torch::jit::script::Module backbone_net_;
-  torch::jit::script::Module fpn_net_;
-  torch::jit::script::Module bbox_head_net_;
-
-  /**
-   * @brief Memory allocation for device memory
-   * @details Called in the constructor
-   */
-  void DeviceMemoryMalloc();
-
-  /**
-   * @brief Initializing anchor
-   * @details Called in the constructor
-   */
-  void InitAnchors();
-
-  /**
-   * @brief Initializing LibTorch net
-   * @details Called in the constructor
-   */
-  void InitTorch();
-
-  /**
-   * @brief Initializing TensorRT instances
-   * @details Called in the constructor
-   */
-  void InitTRT();
-
-  /**
-   * @brief Generate anchors
-   * @param[in] anchors_px_ Represents x-coordinate values for a corresponding
-   * anchor
-   * @param[in] anchors_py_ Represents y-coordinate values for a corresponding
-   * anchor
-   * @param[in] anchors_pz_ Represents z-coordinate values for a corresponding
-   * anchor
-   * @param[in] anchors_dx_ Represents x-dimension values for a corresponding
-   * anchor
-   * @param[in] anchors_dy_ Represents y-dimension values for a corresponding
-   * anchor
-   * @param[in] anchors_dz_ Represents z-dimension values for a corresponding
-   * anchor
-   * @param[in] anchors_ro_ Represents rotation values for a corresponding
-   * anchor
-   * @details Generate anchors for each grid
-   */
-  void GenerateAnchors(float* anchors_px_, float* anchors_py_,
-                       float* anchors_pz_, float* anchors_dx_,
-                       float* anchors_dy_, float* anchors_dz_,
-                       float* anchors_ro_);
-
-  /**
-   * @brief Convert ONNX to TensorRT model
-   * @param[in] model_file ONNX model file path
-   * @param[out] engine_ptr TensorRT model engine made out of ONNX model
-   * @details Load ONNX model, and convert it to TensorRT model
-   */
-  void OnnxToTRTModel(const std::string&amp; model_file,
-                      nvinfer1::ICudaEngine** engine_ptr);
-
-  /**
-   * @brief Preproces points
-   * @param[in] in_points_array Point cloud array
-   * @param[in] in_num_points Number of points
-   * @details Call CPU or GPU preprocess
-   */
-  void Preprocess(const float* in_points_array, const int in_num_points);
-
-  /**
-   * @brief Preproces by CPU
-   * @param[in] in_points_array Point cloud array
-   * @param[in] in_num_points Number of points
-   * @details The output from preprocessCPU is reproducible, while preprocessGPU
-   * is not
-   */
-  void PreprocessCPU(const float* in_points_array, const int in_num_points);
-
-  /**
-   * @brief Preproces by GPU
-   * @param[in] in_points_array Point cloud array
-   * @param[in] in_num_points Number of points
-   * @details Faster preprocess compared with CPU preprocess
-   */
-  void PreprocessGPU(const float* in_points_array, const int in_num_points);
-
-  /**
-   * @brief Convert anchors to box form like min_x, min_y, max_x, max_y anchors
-   * @param[in] anchors_px_
-   *   Represents x-coordinate value for a corresponding anchor
-   * @param[in] anchors_py_
-   *   Represents y-coordinate value for a corresponding anchor
-   * @param[in] box_anchors_min_x_
-   *   Represents minimum x value for a corresponding anchor
-   * @param[in] box_anchors_min_y_
-   *   Represents minimum y value for a corresponding anchor
-   * @param[in] box_anchors_max_x_
-   *   Represents maximum x value for a corresponding anchor
-   * @param[in] box_anchors_max_y_
-   *   Represents maximum y value for a corresponding anchor
-   * @details Make box anchors for nms
-   */
-  void ConvertAnchors2BoxAnchors(float* anchors_px_, float* anchors_py_,
-                                 float* box_anchors_min_x_,
-                                 float* box_anchors_min_y_,
-                                 float* box_anchors_max_x_,
-                                 float* box_anchors_max_y_);
-
-  /**
-   * @brief Memory allocation for anchors
-   * @details Memory allocation for anchors
-   */
-  void PutAnchorsInDeviceMemory();
-
- public:
-  /**
-   * @brief Constructor
-   * @param[in] reproduce_result_mode Boolean, if true, the output is
-   * reproducible for the same input
-   * @param[in] score_threshold Score threshold for filtering output
-   * @param[in] nms_overlap_threshold IOU threshold for NMS
-   * @param[in] pfe_torch_file Pillar Feature Extractor Torch file path
-   * @param[in] scattered_torch_file Pillar Feature scatter Torch file path
-   * @param[in] backbone_torch_file Pillar Backbone Torch file path
-   * @param[in] fpn_torch_file Pillar Fpn Torch file path
-   * @param[in] bbox_head_torch_file Pillar Bbox Head Torch file path
-   * @details Variables could be changed through point_pillars_detection
-   */
-  PointPillars(const bool reproduce_result_mode, const float score_threshold,
-               const float nms_overlap_threshold,
-               const std::string&amp; pfe_torch_file,
-               const std::string&amp; scattered_torch_file,
-               const std::string&amp; backbone_torch_file,
-               const std::string&amp; fpn_torch_file,
-               const std::string&amp; bbox_head_torch_file);
-  ~PointPillars();
-
-  /**
-   * @brief Call PointPillars for the inference
-   * @param[in] in_points_array Point cloud array
-   * @param[in] in_num_points Number of points
-   * @param[out] out_detections Network output bounding box
-   * @param[out] out_labels Network output object's label
-   * @details This is an interface for the algorithm
-   */
-  void DoInference(const float* in_points_array, const int in_num_points,
-                   std::vector&lt;float&gt;* out_detections,
-                   std::vector&lt;int&gt;* out_labels);
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.cc" new_path="" added_lines="0" deleted_lines="372">
				<diff>@@ -1,372 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/point_pillars_detection.h"
-
-#include &lt;algorithm&gt;
-#include &lt;numeric&gt;
-#include &lt;random&gt;
-
-#include &lt;cuda_runtime_api.h&gt;
-
-#include "cyber/common/log.h"
-#include "modules/perception/base/object_pool_types.h"
-#include "modules/perception/base/point_cloud_util.h"
-#include "modules/perception/common/perception_gflags.h"
-#include "modules/perception/lidar/common/lidar_timer.h"
-#include "modules/perception/lidar/common/pcl_util.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/params.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-using base::Object;
-using base::PointD;
-using base::PointF;
-
-PointPillarsDetection::PointPillarsDetection()
-    : x_min_(Params::kMinXRange),
-      x_max_(Params::kMaxXRange),
-      y_min_(Params::kMinYRange),
-      y_max_(Params::kMaxYRange),
-      z_min_(Params::kMinZRange),
-      z_max_(Params::kMaxZRange) {
-  if (FLAGS_enable_ground_removal) {
-    z_min_ = std::max(z_min_, static_cast&lt;float&gt;(FLAGS_ground_removal_height));
-  }
-}
-
-// TODO(chenjiahao):
-//  specify score threshold and nms over lap threshold for each class.
-bool PointPillarsDetection::Init(const LidarDetectorInitOptions&amp; options) {
-  point_pillars_ptr_.reset(
-      new PointPillars(FLAGS_reproduce_result_mode, FLAGS_score_threshold,
-                       FLAGS_nms_overlap_threshold, FLAGS_pfe_torch_file,
-                       FLAGS_scattered_torch_file, FLAGS_backbone_torch_file,
-                       FLAGS_fpn_torch_file, FLAGS_bbox_head_torch_file));
-  return true;
-}
-
-bool PointPillarsDetection::Detect(const LidarDetectorOptions&amp; options,
-                                   LidarFrame* frame) {
-  // check input
-  if (frame == nullptr) {
-    AERROR &lt;&lt; "Input null frame ptr.";
-    return false;
-  }
-  if (frame-&gt;cloud == nullptr) {
-    AERROR &lt;&lt; "Input null frame cloud.";
-    return false;
-  }
-  if (frame-&gt;cloud-&gt;size() == 0) {
-    AERROR &lt;&lt; "Input none points.";
-    return false;
-  }
-
-  // record input cloud and lidar frame
-  original_cloud_ = frame-&gt;cloud;
-  original_world_cloud_ = frame-&gt;world_cloud;
-  lidar_frame_ref_ = frame;
-
-  // check output
-  frame-&gt;segmented_objects.clear();
-
-  if (cudaSetDevice(FLAGS_gpu_id) != cudaSuccess) {
-    AERROR &lt;&lt; "Failed to set device to gpu " &lt;&lt; FLAGS_gpu_id;
-    return false;
-  }
-
-  Timer timer;
-
-  int num_points;
-  cur_cloud_ptr_ = std::shared_ptr&lt;base::PointFCloud&gt;(
-      new base::PointFCloud(*original_cloud_));
-
-  // down sample the point cloud through filtering beams
-  if (FLAGS_enable_downsample_beams) {
-    base::PointFCloudPtr downsample_beams_cloud_ptr(new base::PointFCloud());
-    if (DownSamplePointCloudBeams(original_cloud_, downsample_beams_cloud_ptr,
-                                  FLAGS_downsample_beams_factor)) {
-      cur_cloud_ptr_ = downsample_beams_cloud_ptr;
-    } else {
-      AWARN &lt;&lt; "Down-sample beams factor must be &gt;= 1. Cancel down-sampling."
-               " Current factor: "
-            &lt;&lt; FLAGS_downsample_beams_factor;
-    }
-  }
-
-  // down sample the point cloud through filtering voxel grid
-  if (FLAGS_enable_downsample_pointcloud) {
-    pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr pcl_cloud_ptr(
-        new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
-    pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_cloud_ptr(
-        new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
-    TransformToPCLXYZI(*cur_cloud_ptr_, pcl_cloud_ptr);
-    DownSampleCloudByVoxelGrid(
-        pcl_cloud_ptr, filtered_cloud_ptr, FLAGS_downsample_voxel_size_x,
-        FLAGS_downsample_voxel_size_y, FLAGS_downsample_voxel_size_z);
-
-    // transform pcl point cloud to apollo point cloud
-    base::PointFCloudPtr downsample_voxel_cloud_ptr(new base::PointFCloud());
-    TransformFromPCLXYZI(filtered_cloud_ptr, downsample_voxel_cloud_ptr);
-    cur_cloud_ptr_ = downsample_voxel_cloud_ptr;
-  }
-  downsample_time_ = timer.toc(true);
-
-  num_points = cur_cloud_ptr_-&gt;size();
-  AINFO &lt;&lt; "num points before fusing: " &lt;&lt; num_points;
-
-  // fuse clouds of preceding frames with current cloud
-  cur_cloud_ptr_-&gt;mutable_points_timestamp()-&gt;assign(cur_cloud_ptr_-&gt;size(),
-                                                     0.0);
-  if (FLAGS_enable_fuse_frames &amp;&amp; FLAGS_num_fuse_frames &gt; 1) {
-    // before fusing
-    while (!prev_world_clouds_.empty() &amp;&amp;
-           frame-&gt;timestamp - prev_world_clouds_.front()-&gt;get_timestamp() &gt;
-               FLAGS_fuse_time_interval) {
-      prev_world_clouds_.pop_front();
-    }
-    // transform current cloud to world coordinate and save to a new ptr
-    base::PointDCloudPtr cur_world_cloud_ptr =
-        std::make_shared&lt;base::PointDCloud&gt;();
-    for (size_t i = 0; i &lt; cur_cloud_ptr_-&gt;size(); ++i) {
-      auto&amp; pt = cur_cloud_ptr_-&gt;at(i);
-      Eigen::Vector3d trans_point(pt.x, pt.y, pt.z);
-      trans_point = lidar_frame_ref_-&gt;lidar2world_pose * trans_point;
-      PointD world_point;
-      world_point.x = trans_point(0);
-      world_point.y = trans_point(1);
-      world_point.z = trans_point(2);
-      world_point.intensity = pt.intensity;
-      cur_world_cloud_ptr-&gt;push_back(world_point);
-    }
-    cur_world_cloud_ptr-&gt;set_timestamp(frame-&gt;timestamp);
-
-    // fusing clouds
-    for (auto&amp; prev_world_cloud_ptr : prev_world_clouds_) {
-      num_points += prev_world_cloud_ptr-&gt;size();
-    }
-    FuseCloud(cur_cloud_ptr_, prev_world_clouds_);
-
-    // after fusing
-    while (static_cast&lt;int&gt;(prev_world_clouds_.size()) &gt;=
-           FLAGS_num_fuse_frames - 1) {
-      prev_world_clouds_.pop_front();
-    }
-    prev_world_clouds_.emplace_back(cur_world_cloud_ptr);
-  }
-  AINFO &lt;&lt; "num points after fusing: " &lt;&lt; num_points;
-  fuse_time_ = timer.toc(true);
-
-  // shuffle points and cut off
-  if (FLAGS_enable_shuffle_points) {
-    num_points = std::min(num_points, FLAGS_max_num_points);
-    std::vector&lt;int&gt; point_indices = GenerateIndices(0, num_points, true);
-    base::PointFCloudPtr shuffle_cloud_ptr(
-        new base::PointFCloud(*cur_cloud_ptr_, point_indices));
-    cur_cloud_ptr_ = shuffle_cloud_ptr;
-  }
-  shuffle_time_ = timer.toc(true);
-
-  // point cloud to array
-  float* points_array = new float[num_points * FLAGS_num_point_feature]();
-  CloudToArray(cur_cloud_ptr_, points_array, FLAGS_normalizing_factor);
-  cloud_to_array_time_ = timer.toc(true);
-
-  // inference
-  std::vector&lt;float&gt; out_detections;
-  std::vector&lt;int&gt; out_labels;
-  point_pillars_ptr_-&gt;DoInference(points_array, num_points, &amp;out_detections,
-                                  &amp;out_labels);
-  inference_time_ = timer.toc(true);
-
-  // transfer output bounding boxes to objects
-  GetObjects(&amp;frame-&gt;segmented_objects, frame-&gt;lidar2world_pose,
-             &amp;out_detections, &amp;out_labels);
-  collect_time_ = timer.toc(true);
-
-  AINFO &lt;&lt; "PointPillars: "
-        &lt;&lt; "\n"
-        &lt;&lt; "down sample: " &lt;&lt; downsample_time_ &lt;&lt; "\t"
-        &lt;&lt; "fuse: " &lt;&lt; fuse_time_ &lt;&lt; "\t"
-        &lt;&lt; "shuffle: " &lt;&lt; shuffle_time_ &lt;&lt; "\t"
-        &lt;&lt; "cloud_to_array: " &lt;&lt; cloud_to_array_time_ &lt;&lt; "\t"
-        &lt;&lt; "inference: " &lt;&lt; inference_time_ &lt;&lt; "\t"
-        &lt;&lt; "collect: " &lt;&lt; collect_time_;
-
-  delete[] points_array;
-  return true;
-}
-
-void PointPillarsDetection::CloudToArray(const base::PointFCloudPtr&amp; pc_ptr,
-                                         float* out_points_array,
-                                         const float normalizing_factor) {
-  for (size_t i = 0; i &lt; pc_ptr-&gt;size(); ++i) {
-    const auto&amp; point = pc_ptr-&gt;at(i);
-    float x = point.x;
-    float y = point.y;
-    float z = point.z;
-    float intensity = point.intensity;
-    if (z &lt; z_min_ || z &gt; z_max_ || y &lt; y_min_ || y &gt; y_max_ || x &lt; x_min_ ||
-        x &gt; x_max_) {
-      continue;
-    }
-    out_points_array[i * FLAGS_num_point_feature + 0] = x;
-    out_points_array[i * FLAGS_num_point_feature + 1] = y;
-    out_points_array[i * FLAGS_num_point_feature + 2] = z;
-    out_points_array[i * FLAGS_num_point_feature + 3] =
-        intensity / normalizing_factor;
-    // delta of timestamp between prev and cur frames
-    out_points_array[i * FLAGS_num_point_feature + 4] =
-        static_cast&lt;float&gt;(pc_ptr-&gt;points_timestamp(i));
-  }
-}
-
-void PointPillarsDetection::FuseCloud(
-    const base::PointFCloudPtr&amp; out_cloud_ptr,
-    const std::deque&lt;base::PointDCloudPtr&gt;&amp; fuse_clouds) {
-  for (auto iter = fuse_clouds.rbegin(); iter != fuse_clouds.rend(); ++iter) {
-    double delta_t = lidar_frame_ref_-&gt;timestamp - (*iter)-&gt;get_timestamp();
-    // transform prev world point cloud to current sensor's coordinates
-    for (size_t i = 0; i &lt; (*iter)-&gt;size(); ++i) {
-      auto&amp; point = (*iter)-&gt;at(i);
-      Eigen::Vector3d trans_point(point.x, point.y, point.z);
-      trans_point = lidar_frame_ref_-&gt;lidar2world_pose.inverse() * trans_point;
-      base::PointF pt;
-      pt.x = static_cast&lt;float&gt;(trans_point(0));
-      pt.y = static_cast&lt;float&gt;(trans_point(1));
-      pt.z = static_cast&lt;float&gt;(trans_point(2));
-      pt.intensity = static_cast&lt;float&gt;(point.intensity);
-      // delta of time between current and prev frame
-      out_cloud_ptr-&gt;push_back(pt, delta_t);
-    }
-  }
-}
-
-std::vector&lt;int&gt; PointPillarsDetection::GenerateIndices(int start_index,
-                                                        int size,
-                                                        bool shuffle) {
-  // create a range number array
-  std::vector&lt;int&gt; indices(size);
-  std::iota(indices.begin(), indices.end(), start_index);
-
-  // shuffle the index array
-  if (shuffle) {
-    unsigned seed = 0;
-    std::shuffle(indices.begin(), indices.end(),
-                 std::default_random_engine(seed));
-  }
-  return indices;
-}
-
-void PointPillarsDetection::GetObjects(
-    std::vector&lt;std::shared_ptr&lt;Object&gt;&gt;* objects, const Eigen::Affine3d&amp; pose,
-    std::vector&lt;float&gt;* detections, std::vector&lt;int&gt;* labels) {
-  int num_objects = detections-&gt;size() / FLAGS_num_output_box_feature;
-
-  objects-&gt;clear();
-  base::ObjectPool::Instance().BatchGet(num_objects, objects);
-
-  for (int i = 0; i &lt; num_objects; ++i) {
-    auto&amp; object = objects-&gt;at(i);
-    object-&gt;id = i;
-
-    // read params of bounding box
-    float x = detections-&gt;at(i * FLAGS_num_output_box_feature + 0);
-    float y = detections-&gt;at(i * FLAGS_num_output_box_feature + 1);
-    float z = detections-&gt;at(i * FLAGS_num_output_box_feature + 2);
-    float dx = detections-&gt;at(i * FLAGS_num_output_box_feature + 4);
-    float dy = detections-&gt;at(i * FLAGS_num_output_box_feature + 3);
-    float dz = detections-&gt;at(i * FLAGS_num_output_box_feature + 5);
-    float yaw = detections-&gt;at(i * FLAGS_num_output_box_feature + 6);
-    yaw += M_PI / 2;
-    yaw = std::atan2(sinf(yaw), cosf(yaw));
-    yaw = -yaw;
-
-    // directions
-    object-&gt;theta = yaw;
-    object-&gt;direction[0] = cosf(yaw);
-    object-&gt;direction[1] = sinf(yaw);
-    object-&gt;direction[2] = 0;
-    object-&gt;lidar_supplement.is_orientation_ready = true;
-
-    // compute vertexes of bounding box and transform to world coordinate
-    object-&gt;lidar_supplement.num_points_in_roi = 8;
-    object-&gt;lidar_supplement.on_use = true;
-    object-&gt;lidar_supplement.is_background = false;
-    float roll = 0, pitch = 0;
-    Eigen::Quaternionf quater =
-        Eigen::AngleAxisf(roll, Eigen::Vector3f::UnitX()) *
-        Eigen::AngleAxisf(pitch, Eigen::Vector3f::UnitY()) *
-        Eigen::AngleAxisf(yaw, Eigen::Vector3f::UnitZ());
-    Eigen::Translation3f translation(x, y, z);
-    Eigen::Affine3f affine3f = translation * quater.toRotationMatrix();
-    for (float vx : std::vector&lt;float&gt;{dx / 2, -dx / 2}) {
-      for (float vy : std::vector&lt;float&gt;{dy / 2, -dy / 2}) {
-        for (float vz : std::vector&lt;float&gt;{0, dz}) {
-          Eigen::Vector3f v3f(vx, vy, vz);
-          v3f = affine3f * v3f;
-          PointF point;
-          point.x = v3f.x();
-          point.y = v3f.y();
-          point.z = v3f.z();
-          object-&gt;lidar_supplement.cloud.push_back(point);
-
-          Eigen::Vector3d trans_point(point.x, point.y, point.z);
-          trans_point = pose * trans_point;
-          PointD world_point;
-          world_point.x = trans_point(0);
-          world_point.y = trans_point(1);
-          world_point.z = trans_point(2);
-          object-&gt;lidar_supplement.cloud_world.push_back(world_point);
-        }
-      }
-    }
-
-    // classification
-    object-&gt;lidar_supplement.raw_probs.push_back(std::vector&lt;float&gt;(
-        static_cast&lt;int&gt;(base::ObjectType::MAX_OBJECT_TYPE), 0.f));
-    object-&gt;lidar_supplement.raw_classification_methods.push_back(Name());
-    object-&gt;sub_type = GetObjectSubType(labels-&gt;at(i));
-    object-&gt;type = base::kSubType2TypeMap.at(object-&gt;sub_type);
-    object-&gt;lidar_supplement.raw_probs.back()[static_cast&lt;int&gt;(object-&gt;type)] =
-        1.0f;
-    // copy to type
-    object-&gt;type_probs.assign(object-&gt;lidar_supplement.raw_probs.back().begin(),
-                              object-&gt;lidar_supplement.raw_probs.back().end());
-  }
-}
-
-// TODO(all): update the base ObjectSubType with more fine-grained types
-// TODO(chenjiahao): move types into an array in the same order as offline
-base::ObjectSubType PointPillarsDetection::GetObjectSubType(const int label) {
-  switch (label) {
-    case 0:
-      return base::ObjectSubType::CAR;
-    case 1:
-      return base::ObjectSubType::PEDESTRIAN;
-    case 2:  // construction vehicle
-      return base::ObjectSubType::CYCLIST;
-    default:
-      return base::ObjectSubType::UNKNOWN;
-  }
-}
-
-PERCEPTION_REGISTER_LIDARDETECTOR(PointPillarsDetection);
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_detection.h" new_path="" added_lines="0" deleted_lines="92">
				<diff>@@ -1,92 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;deque&gt;
-#include &lt;memory&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#include "pcl/point_cloud.h"
-#include "pcl/point_types.h"
-
-#include "modules/perception/base/object.h"
-#include "modules/perception/base/point_cloud.h"
-#include "modules/perception/lidar/common/lidar_frame.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/point_pillars.h"
-#include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class PointPillarsDetection : public BaseLidarDetector {
- public:
-  PointPillarsDetection();
-  virtual ~PointPillarsDetection() = default;
-
-  bool Init(const LidarDetectorInitOptions&amp; options = LidarDetectorInitOptions()) override;
-
-  bool Detect(const LidarDetectorOptions&amp; options, LidarFrame* frame) override;
-
-  std::string Name() const override { return "PointPillarsDetection"; }
-
- private:
-  void CloudToArray(const base::PointFCloudPtr&amp; pc_ptr, float* out_points_array,
-                    float normalizing_factor);
-
-  void FuseCloud(const base::PointFCloudPtr&amp; out_cloud_ptr,
-                 const std::deque&lt;base::PointDCloudPtr&gt;&amp; fuse_clouds);
-
-  std::vector&lt;int&gt; GenerateIndices(int start_index, int size, bool shuffle);
-
-  void GetObjects(std::vector&lt;std::shared_ptr&lt;base::Object&gt;&gt;* objects,
-                  const Eigen::Affine3d&amp; pose, std::vector&lt;float&gt;* detections,
-                  std::vector&lt;int&gt;* labels);
-
-  base::ObjectSubType GetObjectSubType(int label);
-
-  // reference pointer of lidar frame
-  LidarFrame* lidar_frame_ref_ = nullptr;
-  std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointF&gt;&gt; original_cloud_;
-  std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointD&gt;&gt;
-      original_world_cloud_;
-
-  // PointPillars
-  std::unique_ptr&lt;PointPillars&gt; point_pillars_ptr_;
-  std::deque&lt;base::PointDCloudPtr&gt; prev_world_clouds_;
-  base::PointFCloudPtr cur_cloud_ptr_;
-
-  // point cloud range
-  float x_min_;
-  float x_max_;
-  float y_min_;
-  float y_max_;
-  float z_min_;
-  float z_max_;
-
-  // time statistics
-  double downsample_time_ = 0.0;
-  double fuse_time_ = 0.0;
-  double shuffle_time_ = 0.0;
-  double cloud_to_array_time_ = 0.0;
-  double inference_time_ = 0.0;
-  double collect_time_ = 0.0;
-};  // class PointPillarsDetection
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\point_pillars_test.cc" new_path="" added_lines="0" deleted_lines="687">
				<diff>@@ -1,687 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file test_point_pillars.cpp
- * @brief unit test file
- * @author Kosuke Murakami
- * @date 2019/02/26
- */
-
-
-
-#include &lt;vector&gt;
-
-#include "gtest/gtest.h"
-
-#include "pcl/io/pcd_io.h"
-#include "pcl/point_types.h"
-
-#include "modules/perception/common/perception_gflags.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/point_pillars.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/preprocess_points.h"
-#include "modules/perception/tool/benchmark/lidar/util/io_util.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class TestSuite : public ::testing::Test {
- public:
-  TestSuite() {}
-  ~TestSuite() {}
-};
-
-class TestClass {
- public:
-  TestClass();
-  TestClass(const int num_class, const int max_num_pillars,
-            const int max_num_points_per_pillar, const int num_point_feature,
-            const int grid_x_size, const int grid_y_size, const int grid_z_size,
-            const float pillar_x_size, const float pillar_y_size,
-            const float pillar_z_size, const float min_x_range,
-            const float min_y_range, const float min_z_range,
-            const int num_inds_for_scan, const int num_threads);
-  const int num_class;
-  const int max_num_pillars;
-  const int max_num_points_per_pillar;
-  const int num_point_feature;
-  const int grid_x_size;
-  const int grid_y_size;
-  const int grid_z_size;
-  const float pillar_x_size;
-  const float pillar_y_size;
-  const float pillar_z_size;
-  const float min_x_range;
-  const float min_y_range;
-  const float min_z_range;
-  const int num_inds_for_scan;
-  const int num_threads;
-
-  // Make pointcloud for test
-  void MakePointsForTest(pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_pcl_pc_ptr);
-  void PclToArray(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr&amp; in_pcl_pc_ptr,
-                  float* out_points_array,
-                  const float normalizing_factor = 1.0);
-  void PclXYZITToArray(
-      const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr&amp; in_pcl_pc_ptr,
-      float* out_points_array, const float normalizing_factor = 1.0);
-  void Preprocess(const float* in_points_array, int in_num_points, int* x_coors,
-                  int* y_coors, float* num_points_per_pillar,
-                  float* pillar_point_feature, float* pillar_coors,
-                  float* sparse_pillar_map, int* host_pillar_count);
-  void PreprocessGPU(const float* in_points_array, int in_num_points,
-                     int* x_coors, int* y_coors, float* num_points_per_pillar,
-                     float* pillar_point_feature, float* pillar_coors,
-                     int* sparse_pillar_map, int* host_pillar_count);
-  void GenerateAnchors(float* anchors_px, float* anchors_py, float* anchors_pz,
-                       float* anchors_dx, float* anchors_dy, float* anchors_dz,
-                       float* anchors_ro);
-  void ConvertAnchors2BoxAnchors(float* anchors_px, float* anchors_py,
-                                 float* box_anchors_min_x,
-                                 float* box_anchors_min_y,
-                                 float* box_anchors_max_x,
-                                 float* box_anchors_max_y);
-  void DoInference(const float* in_points_array, const int in_num_points,
-                   std::vector&lt;float&gt;* out_detections,
-                   std::vector&lt;int&gt;* out_labels);
-
- private:
-  std::unique_ptr&lt;PreprocessPoints&gt; preprocess_points_ptr_;
-  std::unique_ptr&lt;PreprocessPointsCuda&gt; preprocess_points_cuda_ptr_;
-  std::unique_ptr&lt;PointPillars&gt; point_pillars_ptr_;
-};
-
-TestClass::TestClass()
-    : num_class(3),
-      max_num_pillars(12000),
-      max_num_points_per_pillar(100),
-      num_point_feature(4),
-      grid_x_size(280),
-      grid_y_size(320),
-      grid_z_size(1),
-      pillar_x_size(0.25),
-      pillar_y_size(0.25),
-      pillar_z_size(4.0),
-      min_x_range(0),
-      min_y_range(-40.0),
-      min_z_range(-3.0),
-      num_inds_for_scan(512),
-      num_threads(64) {
-  preprocess_points_ptr_.reset(new PreprocessPoints(
-      max_num_pillars, max_num_points_per_pillar, num_point_feature,
-      grid_x_size, grid_y_size, grid_z_size, pillar_x_size, pillar_y_size,
-      pillar_z_size, min_x_range, min_y_range, min_z_range, num_inds_for_scan));
-  preprocess_points_cuda_ptr_.reset(new PreprocessPointsCuda(
-      num_threads, max_num_pillars, max_num_points_per_pillar,
-      num_point_feature, num_inds_for_scan, grid_x_size, grid_y_size,
-      grid_z_size, pillar_x_size, pillar_y_size, pillar_z_size, min_x_range,
-      min_y_range, min_z_range));
-
-  bool reproduce_result_mode = false;
-  float score_threshold = 0.5;
-  float nms_overlap_threshold = 0.5;
-
-  point_pillars_ptr_.reset(
-      new PointPillars(reproduce_result_mode, score_threshold,
-                       nms_overlap_threshold, FLAGS_pfe_torch_file,
-                       FLAGS_scattered_torch_file, FLAGS_backbone_torch_file,
-                       FLAGS_fpn_torch_file, FLAGS_bbox_head_torch_file));
-}
-
-TestClass::TestClass(const int num_class, const int max_num_pillars,
-                     const int max_num_points_per_pillar,
-                     const int num_point_feature, const int grid_x_size,
-                     const int grid_y_size, const int grid_z_size,
-                     const float pillar_x_size, const float pillar_y_size,
-                     const float pillar_z_size, const float min_x_range,
-                     const float min_y_range, const float min_z_range,
-                     const int num_inds_for_scan, const int num_threads)
-    : num_class(num_class),
-      max_num_pillars(max_num_pillars),
-      max_num_points_per_pillar(max_num_points_per_pillar),
-      num_point_feature(num_point_feature),
-      grid_x_size(grid_x_size),
-      grid_y_size(grid_y_size),
-      grid_z_size(grid_z_size),
-      pillar_x_size(pillar_x_size),
-      pillar_y_size(pillar_y_size),
-      pillar_z_size(pillar_z_size),
-      min_x_range(min_x_range),
-      min_y_range(min_y_range),
-      min_z_range(min_z_range),
-      num_inds_for_scan(num_inds_for_scan),
-      num_threads(num_threads) {
-  preprocess_points_ptr_.reset(new PreprocessPoints(
-      max_num_pillars, max_num_points_per_pillar, num_point_feature,
-      grid_x_size, grid_y_size, grid_z_size, pillar_x_size, pillar_y_size,
-      pillar_z_size, min_x_range, min_y_range, min_z_range, num_inds_for_scan));
-  preprocess_points_cuda_ptr_.reset(new PreprocessPointsCuda(
-      num_threads, max_num_pillars, max_num_points_per_pillar,
-      num_point_feature, num_inds_for_scan, grid_x_size, grid_y_size,
-      grid_z_size, pillar_x_size, pillar_y_size, pillar_z_size, min_x_range,
-      min_y_range, min_z_range));
-
-  bool reproduce_result_mode = false;
-  float score_threshold = 0.5;
-  float nms_overlap_threshold = 0.5;
-
-  point_pillars_ptr_.reset(
-      new PointPillars(reproduce_result_mode, score_threshold,
-                       nms_overlap_threshold, FLAGS_pfe_torch_file,
-                       FLAGS_scattered_torch_file, FLAGS_backbone_torch_file,
-                       FLAGS_fpn_torch_file, FLAGS_bbox_head_torch_file));
-}
-
-void TestClass::Preprocess(const float* in_points_array, int in_num_points,
-                           int* x_coors, int* y_coors,
-                           float* num_points_per_pillar,
-                           float* pillar_point_feature, float* pillar_coors,
-                           float* sparse_pillar_map, int* host_pillar_count) {
-  preprocess_points_ptr_-&gt;Preprocess(
-      in_points_array, in_num_points, x_coors, y_coors, num_points_per_pillar,
-      pillar_point_feature, pillar_coors, sparse_pillar_map, host_pillar_count);
-}
-
-void TestClass::PreprocessGPU(const float* in_points_array, int in_num_points,
-                              int* x_coors, int* y_coors,
-                              float* num_points_per_pillar,
-                              float* pillar_point_feature, float* pillar_coors,
-                              int* sparse_pillar_map, int* host_pillar_count) {
-  preprocess_points_cuda_ptr_-&gt;DoPreprocessPointsCuda(
-      in_points_array, in_num_points, x_coors, y_coors, num_points_per_pillar,
-      pillar_point_feature, pillar_coors, sparse_pillar_map, host_pillar_count);
-}
-
-void TestClass::PclToArray(
-    const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr&amp; in_pcl_pc_ptr,
-    float* out_points_array, const float normalizing_factor) {
-  for (size_t i = 0; i &lt; in_pcl_pc_ptr-&gt;size(); ++i) {
-    pcl::PointXYZI point = in_pcl_pc_ptr-&gt;at(i);
-    out_points_array[i * 4 + 0] = point.x;
-    out_points_array[i * 4 + 1] = point.y;
-    out_points_array[i * 4 + 2] = point.z;
-    out_points_array[i * 4 + 3] =
-        static_cast&lt;float&gt;(point.intensity / normalizing_factor);
-  }
-}
-
-void TestClass::PclXYZITToArray(
-    const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr&amp; in_pcl_pc_ptr,
-    float* out_points_array, const float normalizing_factor) {
-  for (size_t i = 0; i &lt; in_pcl_pc_ptr-&gt;size(); ++i) {
-    pcl::PointXYZI point = in_pcl_pc_ptr-&gt;at(i);
-    out_points_array[i * 5 + 0] = point.x;
-    out_points_array[i * 5 + 1] = point.y;
-    out_points_array[i * 5 + 2] = point.z;
-    out_points_array[i * 5 + 3] =
-        static_cast&lt;float&gt;(point.intensity / normalizing_factor);
-    out_points_array[i * 5 + 4] = 0;
-  }
-}
-
-void TestClass::MakePointsForTest(
-    pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_pcl_pc_ptr) {
-  pcl::PointXYZI point;
-  point.x = 12.9892;
-  point.y = -9.98058;
-  point.z = 0;
-  point.intensity = 4;
-  in_pcl_pc_ptr-&gt;push_back(point);
-  point.x = 11.8697;
-  point.y = -11.123;
-  point.z = -0.189377;
-  point.intensity = 35;
-  in_pcl_pc_ptr-&gt;push_back(point);
-  point.x = 12.489;
-  point.y = -9.59703;
-  point.z = -2.15565;
-  point.intensity = 11;
-  in_pcl_pc_ptr-&gt;push_back(point);
-  point.x = 12.9084;
-  point.y = -10.9626;
-  point.z = -2.15565;
-  point.intensity = 11;
-  in_pcl_pc_ptr-&gt;push_back(point);
-  point.x = 13.8676;
-  point.y = -9.61668;
-  point.z = 0.0980819;
-  point.intensity = 14;
-  in_pcl_pc_ptr-&gt;push_back(point);
-  point.x = 13.5673;
-  point.y = -12.9834;
-  point.z = 0.21862;
-  point.intensity = 1;
-  in_pcl_pc_ptr-&gt;push_back(point);
-  point.x = 13.8213;
-  point.y = -10.8529;
-  point.z = -1.22883;
-  point.intensity = 19;
-  in_pcl_pc_ptr-&gt;push_back(point);
-  point.x = 11.8957;
-  point.y = -10.3189;
-  point.z = -1.28556;
-  point.intensity = 13;
-  in_pcl_pc_ptr-&gt;push_back(point);
-}
-
-void TestClass::GenerateAnchors(float* anchors_px, float* anchors_py,
-                                float* anchors_pz, float* anchors_dx,
-                                float* anchors_dy, float* anchors_dz,
-                                float* anchors_ro) {
-  return point_pillars_ptr_-&gt;GenerateAnchors(anchors_px, anchors_py, anchors_pz,
-                                             anchors_dx, anchors_dy, anchors_dz,
-                                             anchors_ro);
-}
-
-void TestClass::ConvertAnchors2BoxAnchors(float* anchors_px, float* anchors_py,
-                                          float* box_anchors_min_x,
-                                          float* box_anchors_min_y,
-                                          float* box_anchors_max_x,
-                                          float* box_anchors_max_y) {
-  return point_pillars_ptr_-&gt;ConvertAnchors2BoxAnchors(
-      anchors_px, anchors_py, box_anchors_min_x, box_anchors_min_y,
-      box_anchors_max_x, box_anchors_max_y);
-}
-
-void TestClass::DoInference(const float* in_points_array,
-                            const int in_num_points,
-                            std::vector&lt;float&gt;* out_detections,
-                            std::vector&lt;int&gt;* out_labels) {
-  return point_pillars_ptr_-&gt;DoInference(in_points_array, in_num_points,
-                                         out_detections, out_labels);
-}
-/*
-TEST(TestSuite, CheckPreprocessPointsCPU) {
-  const int kNumClass = 1;
-  const int kMaxNumPillars = 12000;
-  const int kMaxNumPointsPerPillar = 100;
-  const int kNumPointFeature = 4;
-  const int kGridXSize = 432;
-  const int kGridYSize = 496;
-  const int kGridZSize = 1;
-  const float kPillarXSize = 0.16;
-  const float kPillarYSize = 0.16;
-  const float kPillarZSize = 4.0;
-  const float kMinXRange = 0;
-  const float kMinYRange = -39.68;
-  const float kMinZRange = -3.0;
-  const int kNumIndsForScan = 512;
-  const int kNumThreads = 64;
-  TestClass test_obj(kNumClass, kMaxNumPillars, kMaxNumPointsPerPillar,
-                     kNumPointFeature, kGridXSize, kGridYSize, kGridZSize,
-                     kPillarXSize, kPillarYSize, kPillarZSize, kMinXRange,
-                     kMinYRange, kMinZRange, kNumIndsForScan, kNumThreads);
-
-  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr pcl_pc_ptr(
-      new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
-  test_obj.MakePointsForTest(pcl_pc_ptr);
-
-  float* points_array = new float[pcl_pc_ptr-&gt;size() * 4];
-  test_obj.PclToArray(pcl_pc_ptr, points_array);
-
-  int x_coors[kMaxNumPillars] = {};
-  int y_coors[kMaxNumPillars] = {};
-  float num_points_per_pillar[kMaxNumPillars] = {};
-
-  float* pillar_point_feature =
-      new float[test_obj.max_num_pillars * test_obj.max_num_points_per_pillar *
-                test_obj.num_point_feature];
-  float* pillar_coors = new float[test_obj.max_num_pillars * 4];
-  float* sparse_pillar_map = new float[kNumIndsForScan * kNumIndsForScan];
-
-  int host_pillar_count[1] = {0};
-  test_obj.Preprocess(points_array, pcl_pc_ptr-&gt;size(), x_coors, y_coors,
-                      num_points_per_pillar, pillar_point_feature, pillar_coors,
-                      sparse_pillar_map, host_pillar_count);
-  EXPECT_EQ(1, num_points_per_pillar[0]);
-  EXPECT_FLOAT_EQ(12.9892, pillar_point_feature[0]);
-  EXPECT_EQ(74, x_coors[1]);
-  EXPECT_EQ(178, y_coors[1]);
-  EXPECT_EQ(1, sparse_pillar_map[178 * 512 + 74]);
-  EXPECT_EQ(8, host_pillar_count[0]);
-
-  delete[] points_array;
-  delete[] pillar_point_feature;
-  delete[] pillar_coors;
-  delete[] sparse_pillar_map;
-}
-
-TEST(TestSuite, CheckPreprocessGPU) {
-  const int kNumClass = 1;
-  const int kMaxNumPillars = 12000;
-  const int kMaxNumPointsPerPillar = 100;
-  const int kNumPointFeature = 4;
-  const int kGridXSize = 432;
-  const int kGridYSize = 496;
-  const int kGridZSize = 1;
-  const float kPillarXSize = 0.16;
-  const float kPillarYSize = 0.16;
-  const float kPillarZSize = 4.0;
-  const float kMinXRange = 0;
-  const float kMinYRange = -39.68;
-  const float kMinZRange = -3.0;
-  const int kNumIndsForScan = 512;
-  const int kNumThreads = 64;
-  const float kNormalizingFactor = 255.0;
-  TestClass test_obj(kNumClass, kMaxNumPillars, kMaxNumPointsPerPillar,
-                     kNumPointFeature, kGridXSize, kGridYSize, kGridZSize,
-                     kPillarXSize, kPillarYSize, kPillarZSize, kMinXRange,
-                     kMinYRange, kMinZRange, kNumIndsForScan, kNumThreads);
-
-  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr pcl_pc_ptr(
-      new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
-  apollo::perception::benchmark::PointCloudPtr org_cloud_ptr(
-      new pcl::PointCloud&lt;apollo::perception::benchmark::PointXYZIL&gt;);
-  std::string file_name =
-      "/apollo/modules/perception/testdata/lidar/app/data/0001_00.pcd";
-
-  bool ret = apollo::perception::benchmark::load_pcl_pcds_xyzit(file_name,
-                                                                org_cloud_ptr);
-  ASSERT_TRUE(ret) &lt;&lt; "Failed to load pcd file: " &lt;&lt; file_name;
-
-  for (size_t i = 0; i &lt; org_cloud_ptr-&gt;size(); ++i) {
-    pcl::PointXYZI point;
-    point.x = org_cloud_ptr-&gt;at(i).x;
-    point.y = org_cloud_ptr-&gt;at(i).y;
-    point.z = org_cloud_ptr-&gt;at(i).z;
-    point.intensity = org_cloud_ptr-&gt;at(i).intensity;
-    pcl_pc_ptr-&gt;push_back(point);
-  }
-  int in_num_points = pcl_pc_ptr-&gt;size();
-  float* points_array = new float[pcl_pc_ptr-&gt;size() * 4];
-  test_obj.PclToArray(pcl_pc_ptr, points_array, kNormalizingFactor);
-
-  float* dev_points;
-  int* dev_x_coors;
-  int* dev_y_coors;
-  float* dev_num_points_per_pillar;
-  int* dev_sparse_pillar_map;
-  float* dev_pillar_point_feature;
-  float* dev_pillar_coors;
-  int host_pillar_count[1] = {};
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_points),
-                       in_num_points * kNumPointFeature * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_x_coors),
-                       kMaxNumPillars * sizeof(int)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_y_coors),
-                       kMaxNumPillars * sizeof(int)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_num_points_per_pillar),
-                       kMaxNumPillars * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_sparse_pillar_map),
-                       kNumIndsForScan * kNumIndsForScan * sizeof(int)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_pillar_point_feature),
-                       kMaxNumPillars * kMaxNumPointsPerPillar *
-                           kNumPointFeature * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_pillar_coors),
-                       kMaxNumPillars * 4 * sizeof(float)));
-
-  GPU_CHECK(cudaMemcpy(dev_points, points_array,
-                       in_num_points * kNumPointFeature * sizeof(float),
-                       cudaMemcpyHostToDevice));
-  GPU_CHECK(cudaMemset(dev_x_coors, 0, kMaxNumPillars * sizeof(int)));
-  GPU_CHECK(cudaMemset(dev_y_coors, 0, kMaxNumPillars * sizeof(int)));
-  GPU_CHECK(
-      cudaMemset(dev_num_points_per_pillar, 0, kMaxNumPillars * sizeof(float)));
-  GPU_CHECK(cudaMemset(dev_pillar_point_feature, 0,
-                       kMaxNumPillars * kMaxNumPointsPerPillar *
-                           kNumPointFeature * sizeof(float)));
-  GPU_CHECK(
-      cudaMemset(dev_pillar_coors, 0, kMaxNumPillars * 4 * sizeof(float)));
-  GPU_CHECK(cudaMemset(dev_sparse_pillar_map, 0,
-                       kNumIndsForScan * kNumIndsForScan * sizeof(int)));
-
-  test_obj.PreprocessGPU(dev_points, in_num_points, dev_x_coors, dev_y_coors,
-                         dev_num_points_per_pillar, dev_pillar_point_feature,
-                         dev_pillar_coors, dev_sparse_pillar_map,
-                         host_pillar_count);
-
-  int* x_coors = new int[kMaxNumPillars];
-  int* y_coors = new int[kMaxNumPillars];
-  float* num_points_per_pillar = new float[kMaxNumPillars];
-  int* sparse_pillar_map = new int[kNumIndsForScan * kNumIndsForScan];
-  float* pillar_point_feature =
-      new float[kMaxNumPillars * kMaxNumPointsPerPillar * kNumPointFeature];
-  float* pillar_coors = new float[kMaxNumPillars * 4];
-  GPU_CHECK(cudaMemcpy(x_coors, dev_x_coors, kMaxNumPillars * sizeof(int),
-                       cudaMemcpyDeviceToHost));
-  GPU_CHECK(cudaMemcpy(y_coors, dev_y_coors, kMaxNumPillars * sizeof(int),
-                       cudaMemcpyDeviceToHost));
-  GPU_CHECK(cudaMemcpy(num_points_per_pillar, dev_num_points_per_pillar,
-                       kMaxNumPillars * sizeof(float), cudaMemcpyDeviceToHost));
-  GPU_CHECK(cudaMemcpy(sparse_pillar_map, dev_sparse_pillar_map,
-                       kNumIndsForScan * kNumIndsForScan * sizeof(int),
-                       cudaMemcpyDeviceToHost));
-  GPU_CHECK(cudaMemcpy(pillar_point_feature, dev_pillar_point_feature,
-                       kMaxNumPillars * kMaxNumPointsPerPillar *
-                           kNumPointFeature * sizeof(float),
-                       cudaMemcpyDeviceToHost));
-  GPU_CHECK(cudaMemcpy(pillar_coors, dev_pillar_coors,
-                       kMaxNumPillars * 4 * sizeof(float),
-                       cudaMemcpyDeviceToHost));
-
-  EXPECT_EQ(x_coors[320], static_cast&lt;int&gt;(pillar_coors[1283]));
-  EXPECT_EQ(y_coors[44], static_cast&lt;int&gt;(pillar_coors[178]));
-  EXPECT_GT(pillar_coors[10930 * 4 + 2], 0.9);
-  EXPECT_GT(pillar_coors[10930 * 4 + 3], 0.9);
-  EXPECT_EQ(pillar_coors[10931 * 4 + 2], 0);
-  EXPECT_EQ(pillar_coors[10931 * 4 + 3], 0);
-  EXPECT_GT(num_points_per_pillar[10930], 0.9);
-  EXPECT_EQ(num_points_per_pillar[10931], 0);
-  EXPECT_EQ(host_pillar_count[0], 10931);
-
-  GPU_CHECK(cudaFree(dev_points));
-  GPU_CHECK(cudaFree(dev_x_coors));
-  GPU_CHECK(cudaFree(dev_y_coors));
-  GPU_CHECK(cudaFree(dev_num_points_per_pillar));
-  GPU_CHECK(cudaFree(dev_sparse_pillar_map));
-  GPU_CHECK(cudaFree(dev_pillar_point_feature));
-  GPU_CHECK(cudaFree(dev_pillar_coors));
-
-  delete[] points_array;
-  delete[] x_coors;
-  delete[] y_coors;
-  delete[] num_points_per_pillar;
-  delete[] sparse_pillar_map;
-  delete[] pillar_point_feature;
-  delete[] pillar_coors;
-}
-*/
-/*
-// TODO(chenjiahao): should be changed to multi-anchor for multi-class
-TEST(TestSuite, CheckGenerateAnchors) {
-  const int kNumClass = 1;
-  const int kMaxNumPillars = 12000;
-  const int kMaxNumPointsPerPillar = 100;
-  const int kNumPointFeature = 4;
-  const int kGridXSize = 432;
-  const int kGridYSize = 496;
-  const int kGridZSize = 1;
-  const float kPillarXSize = 0.16;
-  const float kPillarYSize = 0.16;
-  const float kPillarZSize = 4.0;
-  const float kMinXRange = 0;
-  const float kMinYRange = -39.68;
-  const float kMinZRange = -3.0;
-  const int kNumIndsForScan = 512;
-  const int kNumThreads = 64;
-  TestClass test_obj(kNumClass, kMaxNumPillars, kMaxNumPointsPerPillar,
-                     kNumPointFeature, kGridXSize, kGridYSize, kGridZSize,
-                     kPillarXSize, kPillarYSize, kPillarZSize, kMinXRange,
-                     kMinYRange, kMinZRange, kNumIndsForScan, kNumThreads);
-
-  const int kNumAnchor = 432 * 0.5 * 496 * 0.5 * 2;
-  float* anchors_px = new float[kNumAnchor];
-  float* anchors_py = new float[kNumAnchor];
-  float* anchors_pz = new float[kNumAnchor];
-  float* anchors_dx = new float[kNumAnchor];
-  float* anchors_dy = new float[kNumAnchor];
-  float* anchors_dz = new float[kNumAnchor];
-  float* anchors_ro = new float[kNumAnchor];
-  test_obj.GenerateAnchors(anchors_px, anchors_py, anchors_pz, anchors_dx,
-                           anchors_dy, anchors_dz, anchors_ro);
-
-  EXPECT_NEAR(0.48, anchors_px[3], 0.001);
-  EXPECT_NEAR(-39.52, anchors_py[109], 0.001);
-  EXPECT_NEAR(-1.73, anchors_pz[76], 0.001);
-  EXPECT_NEAR(1.6, anchors_dx[338], 0.001);
-  EXPECT_NEAR(3.9, anchors_dy[22], 0.001);
-  EXPECT_NEAR(1.56, anchors_dz[993], 0.001);
-  EXPECT_NEAR(1.5708, anchors_ro[1765], 0.001);
-
-  delete[] anchors_px;
-  delete[] anchors_py;
-  delete[] anchors_pz;
-  delete[] anchors_dx;
-  delete[] anchors_dy;
-  delete[] anchors_dz;
-  delete[] anchors_ro;
-}
-
-TEST(TestSuite, CheckGenerateBoxAnchors) {
-  const int kNumClass = 1;
-  const int kMaxNumPillars = 12000;
-  const int kMaxNumPointsPerPillar = 100;
-  const int kNumPointFeature = 4;
-  const int kGridXSize = 432;
-  const int kGridYSize = 496;
-  const int kGridZSize = 1;
-  const float kPillarXSize = 0.16;
-  const float kPillarYSize = 0.16;
-  const float kPillarZSize = 4.0;
-  const float kMinXRange = 0;
-  const float kMinYRange = -39.68;
-  const float kMinZRange = -3.0;
-  const int kNumIndsForScan = 512;
-  const int kNumThreads = 64;
-  TestClass test_obj(kNumClass, kMaxNumPillars, kMaxNumPointsPerPillar,
-                     kNumPointFeature, kGridXSize, kGridYSize, kGridZSize,
-                     kPillarXSize, kPillarYSize, kPillarZSize, kMinXRange,
-                     kMinYRange, kMinZRange, kNumIndsForScan, kNumThreads);
-
-  const int kNumAnchor = 432 * 0.5 * 496 * 0.5 * 2;
-
-  float* anchors_px = new float[kNumAnchor];
-  float* anchors_py = new float[kNumAnchor];
-  float* anchors_pz = new float[kNumAnchor];
-  float* anchors_dx = new float[kNumAnchor];
-  float* anchors_dy = new float[kNumAnchor];
-  float* anchors_dz = new float[kNumAnchor];
-  float* anchors_ro = new float[kNumAnchor];
-  float* box_anchors_min_x = new float[kNumAnchor];
-  float* box_anchors_min_y = new float[kNumAnchor];
-  float* box_anchors_max_x = new float[kNumAnchor];
-  float* box_anchors_max_y = new float[kNumAnchor];
-  test_obj.GenerateAnchors(anchors_px, anchors_py, anchors_pz, anchors_dx,
-                           anchors_dy, anchors_dz, anchors_ro);
-  test_obj.ConvertAnchors2BoxAnchors(anchors_px, anchors_py, box_anchors_min_x,
-                                     box_anchors_min_y, box_anchors_max_x,
-                                     box_anchors_max_y);
-
-  EXPECT_NEAR(53.25, box_anchors_min_x[345], 0.001);
-  EXPECT_NEAR(-41.47, box_anchors_min_y[22], 0.001);
-  EXPECT_NEAR(38.4, box_anchors_max_x[1098], 0.001);
-  EXPECT_NEAR(-38.4, box_anchors_max_y[675], 0.001);
-
-  delete[] anchors_px;
-  delete[] anchors_py;
-  delete[] anchors_pz;
-  delete[] anchors_dx;
-  delete[] anchors_dy;
-  delete[] anchors_dz;
-  delete[] anchors_ro;
-  delete[] box_anchors_min_x;
-  delete[] box_anchors_min_y;
-  delete[] box_anchors_max_x;
-  delete[] box_anchors_max_y;
-}*/
-
-TEST(TestSuite, CheckDoInference) {
-  const int kNumPointFeature = 5;
-  const int kOutputNumBoxFeature = 7;
-  const float kNormalizingFactor = 255.0;
-  TestClass test_obj;
-
-  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr pcl_pc_ptr(
-      new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
-  apollo::perception::benchmark::PointCloudPtr org_cloud_ptr(
-      new pcl::PointCloud&lt;apollo::perception::benchmark::PointXYZIL&gt;);
-  std::string file_name =
-      "/apollo/modules/perception/testdata/lidar/app/data/0001_00.pcd";
-
-  bool ret = apollo::perception::benchmark::load_pcl_pcds_xyzit(file_name,
-                                                                org_cloud_ptr);
-  ASSERT_TRUE(ret) &lt;&lt; "Failed to load pcd file: " &lt;&lt; file_name;
-
-  for (size_t i = 0; i &lt; org_cloud_ptr-&gt;size(); ++i) {
-    pcl::PointXYZI point;
-    point.x = org_cloud_ptr-&gt;at(i).x;
-    point.y = org_cloud_ptr-&gt;at(i).y;
-    point.z = org_cloud_ptr-&gt;at(i).z;
-    point.intensity = org_cloud_ptr-&gt;at(i).intensity;
-    pcl_pc_ptr-&gt;push_back(point);
-  }
-  float* points_array = new float[pcl_pc_ptr-&gt;size() * kNumPointFeature];
-  test_obj.PclXYZITToArray(pcl_pc_ptr, points_array, kNormalizingFactor);
-
-  std::vector&lt;float&gt; out_detections;
-  std::vector&lt;int&gt; out_labels;
-  test_obj.DoInference(points_array, pcl_pc_ptr-&gt;size(), &amp;out_detections,
-                       &amp;out_labels);
-
-  int num_objects = out_detections.size() / kOutputNumBoxFeature;
-  EXPECT_GE(num_objects, 10);
-  EXPECT_EQ(num_objects, out_labels.size());
-
-  for (int j = 0; j &lt; num_objects; ++j) {
-    float x = out_detections.at(j * kOutputNumBoxFeature + 0);
-    float y = out_detections.at(j * kOutputNumBoxFeature + 1);
-    float z = out_detections.at(j * kOutputNumBoxFeature + 2);
-    float dx = out_detections.at(j * kOutputNumBoxFeature + 4);
-    float dy = out_detections.at(j * kOutputNumBoxFeature + 3);
-    float dz = out_detections.at(j * kOutputNumBoxFeature + 5);
-    float yaw = out_detections.at(j * kOutputNumBoxFeature + 6);
-    yaw += M_PI / 2;
-    yaw = std::atan2(std::sin(yaw), std::cos(yaw));
-    yaw = -yaw;
-
-    int label = out_labels.at(j);
-    std::cout &lt;&lt; "object id: " &lt;&lt; j &lt;&lt; ", x: " &lt;&lt; x &lt;&lt; ", y: " &lt;&lt; y
-              &lt;&lt; ", z: " &lt;&lt; z &lt;&lt; ", dx: " &lt;&lt; dx &lt;&lt; ", dy: " &lt;&lt; dy
-              &lt;&lt; ", dz: " &lt;&lt; dz &lt;&lt; ", yaw: " &lt;&lt; yaw &lt;&lt; ", label: " &lt;&lt; label
-              &lt;&lt; std::endl;
-  }
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\postprocess_cuda.cu" new_path="" added_lines="0" deleted_lines="330">
				<diff>@@ -1,330 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// headers in CUDA
-#include &lt;thrust/device_ptr.h&gt;
-#include &lt;thrust/host_vector.h&gt;
-#include &lt;thrust/sort.h&gt;
-
-// headers in local files
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/postprocess_cuda.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-__global__ void filter_kernel(
-    const float* box_preds, const float* cls_preds, const float* dir_preds,
-    const int* anchor_mask, const float* dev_anchors_px,
-    const float* dev_anchors_py, const float* dev_anchors_pz,
-    const float* dev_anchors_dx, const float* dev_anchors_dy,
-    const float* dev_anchors_dz, const float* dev_anchors_ro,
-    float* filtered_box, float* filtered_score, int* filtered_label,
-    int* filtered_dir, float* box_for_nms, int* filter_count,
-    const float float_min, const float float_max, const float score_threshold,
-    const int num_box_corners, const int num_output_box_feature,
-    const int num_class) {
-  // boxes ([N, 7] Tensor): normal boxes: x, y, z, w, l, h, r
-  int tid = threadIdx.x + blockIdx.x * blockDim.x;
-  // sigmoid function
-  float top_score = 0;
-  int top_label = 0;
-  for (int i = 0; i &lt; num_class; ++i) {
-    float score = 1 / (1 + expf(-cls_preds[tid * num_class + i]));
-    if (score &gt; top_score) {
-      top_score = score;
-      top_label = i;
-    }
-  }
-  if (anchor_mask[tid] == 1 &amp;&amp; top_score &gt; score_threshold) {
-    int counter = atomicAdd(filter_count, 1);
-    float za = dev_anchors_pz[tid] + dev_anchors_dz[tid] / 2;
-
-    // decode network output
-    float diagonal = sqrtf(dev_anchors_dx[tid] * dev_anchors_dx[tid] +
-                           dev_anchors_dy[tid] * dev_anchors_dy[tid]);
-    float box_px = box_preds[tid * num_output_box_feature + 0] * diagonal +
-                   dev_anchors_px[tid];
-    float box_py = box_preds[tid * num_output_box_feature + 1] * diagonal +
-                   dev_anchors_py[tid];
-    float box_pz =
-        box_preds[tid * num_output_box_feature + 2] * dev_anchors_dz[tid] + za;
-    float box_dx =
-        expf(box_preds[tid * num_output_box_feature + 3]) * dev_anchors_dx[tid];
-    float box_dy =
-        expf(box_preds[tid * num_output_box_feature + 4]) * dev_anchors_dy[tid];
-    float box_dz =
-        expf(box_preds[tid * num_output_box_feature + 5]) * dev_anchors_dz[tid];
-    float box_ro =
-        box_preds[tid * num_output_box_feature + 6] + dev_anchors_ro[tid];
-
-    box_pz = box_pz - box_dz / 2;
-
-    filtered_box[counter * num_output_box_feature + 0] = box_px;
-    filtered_box[counter * num_output_box_feature + 1] = box_py;
-    filtered_box[counter * num_output_box_feature + 2] = box_pz;
-    filtered_box[counter * num_output_box_feature + 3] = box_dx;
-    filtered_box[counter * num_output_box_feature + 4] = box_dy;
-    filtered_box[counter * num_output_box_feature + 5] = box_dz;
-    filtered_box[counter * num_output_box_feature + 6] = box_ro;
-    filtered_score[counter] = top_score;
-    filtered_label[counter] = top_label;
-
-    int direction_label;
-    if (dir_preds[tid * 2 + 0] &lt; dir_preds[tid * 2 + 1]) {
-      direction_label = 1;
-    } else {
-      direction_label = 0;
-    }
-    filtered_dir[counter] = direction_label;
-
-    // convrt normal box(normal boxes: x, y, z, w, l, h, r) to box(xmin, ymin,
-    // xmax, ymax) for nms calculation First: dx, dy -&gt; box(x0y0, x0y1, x1y0,
-    // x1y1)
-    float corners[NUM_3D_BOX_CORNERS_MACRO] = {
-        static_cast&lt;float&gt;(-0.5 * box_dx), static_cast&lt;float&gt;(-0.5 * box_dy),
-        static_cast&lt;float&gt;(-0.5 * box_dx), static_cast&lt;float&gt;(0.5 * box_dy),
-        static_cast&lt;float&gt;(0.5 * box_dx),  static_cast&lt;float&gt;(0.5 * box_dy),
-        static_cast&lt;float&gt;(0.5 * box_dx),  static_cast&lt;float&gt;(-0.5 * box_dy)};
-
-    // Second: Rotate, Offset and convert to point(xmin. ymin, xmax, ymax)
-    float rotated_corners[NUM_3D_BOX_CORNERS_MACRO];
-    float offset_corners[NUM_3D_BOX_CORNERS_MACRO];
-    float sin_yaw = sinf(box_ro);
-    float cos_yaw = cosf(box_ro);
-    float xmin = float_max;
-    float ymin = float_max;
-    float xmax = float_min;
-    float ymax = float_min;
-    for (size_t i = 0; i &lt; num_box_corners; ++i) {
-      rotated_corners[i * 2 + 0] =
-          cos_yaw * corners[i * 2 + 0] - sin_yaw * corners[i * 2 + 1];
-      rotated_corners[i * 2 + 1] =
-          sin_yaw * corners[i * 2 + 0] + cos_yaw * corners[i * 2 + 1];
-
-      offset_corners[i * 2 + 0] = rotated_corners[i * 2 + 0] + box_px;
-      offset_corners[i * 2 + 1] = rotated_corners[i * 2 + 1] + box_py;
-
-      xmin = fminf(xmin, offset_corners[i * 2 + 0]);
-      ymin = fminf(ymin, offset_corners[i * 2 + 1]);
-      xmax = fmaxf(xmax, offset_corners[i * 2 + 0]);
-      ymax = fmaxf(ymax, offset_corners[i * 2 + 1]);
-    }
-    // box_for_nms(num_box, 4)
-    box_for_nms[counter * num_box_corners + 0] = xmin;
-    box_for_nms[counter * num_box_corners + 1] = ymin;
-    box_for_nms[counter * num_box_corners + 2] = xmax;
-    box_for_nms[counter * num_box_corners + 3] = ymax;
-  }
-}
-
-__global__ void sort_boxes_by_indexes_kernel(
-    float* filtered_box, int* filtered_label, int* filtered_dir,
-    float* box_for_nms, int* indexes, int filter_count,
-    float* sorted_filtered_boxes, int* sorted_filtered_label,
-    int* sorted_filtered_dir, float* sorted_box_for_nms,
-    const int num_box_corners, const int num_output_box_feature) {
-  int tid = threadIdx.x + blockIdx.x * blockDim.x;
-  if (tid &lt; filter_count) {
-    int sort_index = indexes[tid];
-    sorted_filtered_boxes[tid * num_output_box_feature + 0] =
-        filtered_box[sort_index * num_output_box_feature + 0];
-    sorted_filtered_boxes[tid * num_output_box_feature + 1] =
-        filtered_box[sort_index * num_output_box_feature + 1];
-    sorted_filtered_boxes[tid * num_output_box_feature + 2] =
-        filtered_box[sort_index * num_output_box_feature + 2];
-    sorted_filtered_boxes[tid * num_output_box_feature + 3] =
-        filtered_box[sort_index * num_output_box_feature + 3];
-    sorted_filtered_boxes[tid * num_output_box_feature + 4] =
-        filtered_box[sort_index * num_output_box_feature + 4];
-    sorted_filtered_boxes[tid * num_output_box_feature + 5] =
-        filtered_box[sort_index * num_output_box_feature + 5];
-    sorted_filtered_boxes[tid * num_output_box_feature + 6] =
-        filtered_box[sort_index * num_output_box_feature + 6];
-
-    sorted_filtered_label[tid] = filtered_label[sort_index];
-
-    sorted_filtered_dir[tid] = filtered_dir[sort_index];
-
-    sorted_box_for_nms[tid * num_box_corners + 0] =
-        box_for_nms[sort_index * num_box_corners + 0];
-    sorted_box_for_nms[tid * num_box_corners + 1] =
-        box_for_nms[sort_index * num_box_corners + 1];
-    sorted_box_for_nms[tid * num_box_corners + 2] =
-        box_for_nms[sort_index * num_box_corners + 2];
-    sorted_box_for_nms[tid * num_box_corners + 3] =
-        box_for_nms[sort_index * num_box_corners + 3];
-  }
-}
-
-PostprocessCuda::PostprocessCuda(const float float_min, const float float_max,
-                                 const int num_anchor, const int num_class,
-                                 const float score_threshold,
-                                 const int num_threads,
-                                 const float nms_overlap_threshold,
-                                 const int num_box_corners,
-                                 const int num_output_box_feature)
-    : float_min_(float_min),
-      float_max_(float_max),
-      num_anchor_(num_anchor),
-      num_class_(num_class),
-      score_threshold_(score_threshold),
-      num_threads_(num_threads),
-      nms_overlap_threshold_(nms_overlap_threshold),
-      num_box_corners_(num_box_corners),
-      num_output_box_feature_(num_output_box_feature) {
-  nms_cuda_ptr_.reset(
-      new NmsCuda(num_threads, num_box_corners, nms_overlap_threshold));
-}
-
-void PostprocessCuda::DoPostprocessCuda(
-    const float* rpn_box_output, const float* rpn_cls_output,
-    const float* rpn_dir_output, int* dev_anchor_mask,
-    const float* dev_anchors_px, const float* dev_anchors_py,
-    const float* dev_anchors_pz, const float* dev_anchors_dx,
-    const float* dev_anchors_dy, const float* dev_anchors_dz,
-    const float* dev_anchors_ro, float* dev_filtered_box,
-    float* dev_filtered_score, int* dev_filtered_label, int* dev_filtered_dir,
-    float* dev_box_for_nms, int* dev_filter_count,
-    std::vector&lt;float&gt;* out_detection, std::vector&lt;int&gt;* out_label) {
-  const int num_blocks_filter_kernel = DIVUP(num_anchor_, num_threads_);
-  filter_kernel&lt;&lt;&lt;num_blocks_filter_kernel, num_threads_&gt;&gt;&gt;(
-      rpn_box_output, rpn_cls_output, rpn_dir_output, dev_anchor_mask,
-      dev_anchors_px, dev_anchors_py, dev_anchors_pz, dev_anchors_dx,
-      dev_anchors_dy, dev_anchors_dz, dev_anchors_ro, dev_filtered_box,
-      dev_filtered_score, dev_filtered_label, dev_filtered_dir, dev_box_for_nms,
-      dev_filter_count, float_min_, float_max_, score_threshold_,
-      num_box_corners_, num_output_box_feature_, num_class_);
-
-  int host_filter_count[1] = {0};
-  GPU_CHECK(cudaMemcpy(host_filter_count, dev_filter_count, sizeof(int),
-                       cudaMemcpyDeviceToHost));
-  if (host_filter_count[0] == 0) {
-    return;
-  }
-
-  int* dev_indexes;
-  float *dev_sorted_filtered_box, *dev_sorted_box_for_nms;
-  int *dev_sorted_filtered_label, *dev_sorted_filtered_dir;
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_indexes),
-                       host_filter_count[0] * sizeof(int)));
-  GPU_CHECK(cudaMalloc(
-      reinterpret_cast&lt;void**&gt;(&amp;dev_sorted_filtered_box),
-      num_output_box_feature_ * host_filter_count[0] * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_sorted_filtered_label),
-                       host_filter_count[0] * sizeof(int)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_sorted_filtered_dir),
-                       host_filter_count[0] * sizeof(int)));
-  GPU_CHECK(
-      cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_sorted_box_for_nms),
-                 num_box_corners_ * host_filter_count[0] * sizeof(float)));
-
-  thrust::device_ptr&lt;float&gt; dev_ptr_filtered_score(dev_filtered_score);
-  thrust::host_vector&lt;float&gt; host_filtered_score(host_filter_count[0]);
-  thrust::copy(dev_ptr_filtered_score,
-               dev_ptr_filtered_score + size_t(host_filter_count[0]),
-               host_filtered_score.begin());
-
-  thrust::host_vector&lt;int&gt; host_indexes(host_filter_count[0]);
-  thrust::sequence(host_indexes.begin(), host_indexes.end());
-
-  // TODO(chenjiahao): using GPU may cause crash, so use CPU here to sort,
-  //  temporarily. Will change to GPU after upgrading CUDA in the future.
-  thrust::sort_by_key(host_filtered_score.begin(),
-                      host_filtered_score.end(),
-                      host_indexes.begin(), thrust::greater&lt;float&gt;());
-  GPU_CHECK(cudaMemcpy(dev_indexes,
-                       thrust::raw_pointer_cast(host_indexes.data()),
-                       host_filter_count[0] * sizeof(int),
-                       cudaMemcpyHostToDevice));
-
-  const int num_blocks = DIVUP(host_filter_count[0], num_threads_);
-  sort_boxes_by_indexes_kernel&lt;&lt;&lt;num_blocks, num_threads_&gt;&gt;&gt;(
-      dev_filtered_box, dev_filtered_label, dev_filtered_dir, dev_box_for_nms,
-      dev_indexes, host_filter_count[0], dev_sorted_filtered_box,
-      dev_sorted_filtered_label, dev_sorted_filtered_dir,
-      dev_sorted_box_for_nms, num_box_corners_, num_output_box_feature_);
-
-  int keep_inds[host_filter_count[0]];
-  memset(keep_inds, 0, host_filter_count[0] * sizeof(int));
-  int out_num_objects = 0;
-  nms_cuda_ptr_-&gt;DoNmsCuda(host_filter_count[0], dev_sorted_box_for_nms,
-                           keep_inds, &amp;out_num_objects);
-
-  float host_filtered_box[host_filter_count[0] * num_output_box_feature_];
-  int host_filtered_label[host_filter_count[0]];
-  int host_filtered_dir[host_filter_count[0]];
-  GPU_CHECK(
-      cudaMemcpy(host_filtered_box, dev_sorted_filtered_box,
-                 num_output_box_feature_ * host_filter_count[0] * sizeof(float),
-                 cudaMemcpyDeviceToHost));
-  GPU_CHECK(cudaMemcpy(host_filtered_label, dev_sorted_filtered_label,
-                       host_filter_count[0] * sizeof(int),
-                       cudaMemcpyDeviceToHost));
-  GPU_CHECK(cudaMemcpy(host_filtered_dir, dev_sorted_filtered_dir,
-                       host_filter_count[0] * sizeof(int),
-                       cudaMemcpyDeviceToHost));
-  for (size_t i = 0; i &lt; out_num_objects; ++i) {
-    out_detection-&gt;push_back(
-        host_filtered_box[keep_inds[i] * num_output_box_feature_ + 0]);
-    out_detection-&gt;push_back(
-        host_filtered_box[keep_inds[i] * num_output_box_feature_ + 1]);
-    out_detection-&gt;push_back(
-        host_filtered_box[keep_inds[i] * num_output_box_feature_ + 2]);
-    out_detection-&gt;push_back(
-        host_filtered_box[keep_inds[i] * num_output_box_feature_ + 3]);
-    out_detection-&gt;push_back(
-        host_filtered_box[keep_inds[i] * num_output_box_feature_ + 4]);
-    out_detection-&gt;push_back(
-        host_filtered_box[keep_inds[i] * num_output_box_feature_ + 5]);
-
-    if (host_filtered_dir[keep_inds[i]] == 0) {
-      out_detection-&gt;push_back(
-          host_filtered_box[keep_inds[i] * num_output_box_feature_ + 6] + M_PI);
-    } else {
-      out_detection-&gt;push_back(
-          host_filtered_box[keep_inds[i] * num_output_box_feature_ + 6]);
-    }
-
-    out_label-&gt;push_back(host_filtered_label[keep_inds[i]]);
-  }
-
-  GPU_CHECK(cudaFree(dev_indexes));
-  GPU_CHECK(cudaFree(dev_sorted_filtered_box));
-  GPU_CHECK(cudaFree(dev_sorted_filtered_label));
-  GPU_CHECK(cudaFree(dev_sorted_filtered_dir));
-  GPU_CHECK(cudaFree(dev_sorted_box_for_nms));
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\postprocess_cuda.h" new_path="" added_lines="0" deleted_lines="127">
				<diff>@@ -1,127 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file postprocess_cuda.h
- * @brief Postprocess for network output
- * @author Kosuke Murakami
- * @date 2019/02/26
- */
-
-#pragma once
-
-// headers in STL
-#include &lt;iostream&gt;
-#include &lt;memory&gt;
-#include &lt;vector&gt;
-
-// headers in local files
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/nms_cuda.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class PostprocessCuda {
- private:
-  const float float_min_;
-  const float float_max_;
-  const int num_anchor_;
-  const int num_class_;
-  const float score_threshold_;
-  const int num_threads_;
-  const float nms_overlap_threshold_;
-  const int num_box_corners_;
-  const int num_output_box_feature_;
-
-  std::unique_ptr&lt;NmsCuda&gt; nms_cuda_ptr_;
-
- public:
-  /**
-   * @brief Constructor
-   * @param[in] float_min The lowest float value
-   * @param[in] float_max The maximum float value
-   * @param[in] num_anchor Number of anchors in total
-   * @param[in] num_class Number of object's classes
-   * @param[in] score_threshold Score threshold for filtering output
-   * @param[in] num_threads Number of threads when launching cuda kernel
-   * @param[in] nms_overlap_threshold IOU threshold for NMS
-   * @param[in] num_box_corners Number of box's corner
-   * @param[in] num_output_box_feature Number of output box's feature
-   * @details Captital variables never change after the compile, non-capital
-   * variables could be changed through rosparam
-   */
-  PostprocessCuda(const float float_min, const float float_max,
-                  const int num_anchor, const int num_class,
-                  const float score_threshold, const int num_threads,
-                  const float nms_overlap_threshold, const int num_box_corners,
-                  const int num_output_box_feature);
-
-  /**
-   * @brief Postprocessing for the network output
-   * @param[in] rpn_box_output Box predictions from the network output
-   * @param[in] rpn_cls_output Class predictions from the network output
-   * @param[in] rpn_dir_output Direction predictions from the network output
-   * @param[in] dev_anchor_mask Anchor mask for filtering the network output
-   * @param[in] dev_anchors_px X-coordinate values for corresponding anchors
-   * @param[in] dev_anchors_py Y-coordinate values for corresponding anchors
-   * @param[in] dev_anchors_pz Z-coordinate values for corresponding anchors
-   * @param[in] dev_anchors_dx X-dimension values for corresponding anchors
-   * @param[in] dev_anchors_dy Y-dimension values for corresponding anchors
-   * @param[in] dev_anchors_dz Z-dimension values for corresponding anchors
-   * @param[in] dev_anchors_ro Rotation values for corresponding anchors
-   * @param[in] dev_filtered_box Filtered box predictions
-   * @param[in] dev_filtered_score Filtered score predictions
-   * @param[in] dev_filtered_label Filtered label predictions
-   * @param[in] dev_filtered_dir Filtered direction predictions
-   * @param[in] dev_box_for_nms Decoded boxes in min_x min_y max_x max_y
-   * represenation from pose and dimension
-   * @param[in] dev_filter_count The number of filtered output
-   * @param[out] out_detection Output bounding boxes
-   * @param[out] out_label Output labels of objects
-   * @details dev_* represents device memory allocated variables
-   */
-  void DoPostprocessCuda(
-      const float* rpn_box_output, const float* rpn_cls_output,
-      const float* rpn_dir_output, int* dev_anchor_mask,
-      const float* dev_anchors_px, const float* dev_anchors_py,
-      const float* dev_anchors_pz, const float* dev_anchors_dx,
-      const float* dev_anchors_dy, const float* dev_anchors_dz,
-      const float* dev_anchors_ro, float* dev_filtered_box,
-      float* dev_filtered_score, int* dev_filtered_label, int* dev_filtered_dir,
-      float* dev_box_for_nms, int* dev_filter_count,
-      std::vector&lt;float&gt;* out_detection, std::vector&lt;int&gt;* out_label);
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\preprocess_points.cc" new_path="" added_lines="0" deleted_lines="162">
				<diff>@@ -1,162 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// headers in STL
-#include &lt;cmath&gt;
-#include &lt;iostream&gt;
-
-// headers in local files
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/preprocess_points.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-PreprocessPoints::PreprocessPoints(
-    const int max_num_pillars, const int max_points_per_pillar,
-    const int num_point_feature, const int grid_x_size, const int grid_y_size,
-    const int grid_z_size, const float pillar_x_size, const float pillar_y_size,
-    const float pillar_z_size, const float min_x_range, const float min_y_range,
-    const float min_z_range, const int num_inds_for_scan)
-    : max_num_pillars_(max_num_pillars),
-      max_num_points_per_pillar_(max_points_per_pillar),
-      num_point_feature_(num_point_feature),
-      grid_x_size_(grid_x_size),
-      grid_y_size_(grid_y_size),
-      grid_z_size_(grid_z_size),
-      pillar_x_size_(pillar_x_size),
-      pillar_y_size_(pillar_y_size),
-      pillar_z_size_(pillar_z_size),
-      min_x_range_(min_x_range),
-      min_y_range_(min_y_range),
-      min_z_range_(min_z_range),
-      num_inds_for_scan_(num_inds_for_scan) {}
-
-void PreprocessPoints::InitializeVariables(int* coor_to_pillaridx,
-                                           float* sparse_pillar_map,
-                                           float* pillar_point_feature,
-                                           float* pillar_coors) {
-  for (int i = 0; i &lt; grid_y_size_; ++i) {
-    for (int j = 0; j &lt; grid_x_size_; ++j) {
-      coor_to_pillaridx[i * grid_x_size_ + j] = -1;
-    }
-  }
-
-  for (int i = 0; i &lt; num_inds_for_scan_; ++i) {
-    for (int j = 0; j &lt; num_inds_for_scan_; ++j) {
-      sparse_pillar_map[i * num_inds_for_scan_ + j] = 0;
-    }
-  }
-
-  for (int i = 0;
-       i &lt; max_num_pillars_ * max_num_points_per_pillar_ * num_point_feature_;
-       ++i) {
-    pillar_point_feature[i] = 0;
-  }
-
-  for (int i = 0; i &lt; max_num_pillars_ * 4; ++i) {
-    pillar_coors[i] = 0;
-  }
-}
-
-void PreprocessPoints::Preprocess(const float* in_points_array,
-                                  int in_num_points, int* x_coors, int* y_coors,
-                                  float* num_points_per_pillar,
-                                  float* pillar_point_feature,
-                                  float* pillar_coors, float* sparse_pillar_map,
-                                  int* host_pillar_count) {
-  int pillar_count = 0;
-  // init variables
-  int* coor_to_pillaridx = new int[grid_y_size_ * grid_x_size_];
-  InitializeVariables(coor_to_pillaridx, sparse_pillar_map,
-                      pillar_point_feature, pillar_coors);
-  for (int i = 0; i &lt; in_num_points; ++i) {
-    int x_coor = std::floor(
-        (in_points_array[i * num_point_feature_ + 0] - min_x_range_) /
-        pillar_x_size_);
-    int y_coor = std::floor(
-        (in_points_array[i * num_point_feature_ + 1] - min_y_range_) /
-        pillar_y_size_);
-    int z_coor = std::floor(
-        (in_points_array[i * num_point_feature_ + 2] - min_z_range_) /
-        pillar_z_size_);
-    if (x_coor &lt; 0 || x_coor &gt;= grid_x_size_ || y_coor &lt; 0 ||
-        y_coor &gt;= grid_y_size_ || z_coor &lt; 0 || z_coor &gt;= grid_z_size_) {
-      continue;
-    }
-    // reverse index
-    int pillar_index = coor_to_pillaridx[y_coor * grid_x_size_ + x_coor];
-    if (pillar_index == -1) {
-      pillar_index = pillar_count;
-      if (pillar_count &gt;= max_num_pillars_) {
-        break;
-      }
-      pillar_count += 1;
-      coor_to_pillaridx[y_coor * grid_x_size_ + x_coor] = pillar_index;
-
-      y_coors[pillar_index] = std::floor(y_coor);
-      x_coors[pillar_index] = std::floor(x_coor);
-
-      sparse_pillar_map[y_coor * num_inds_for_scan_ + x_coor] = 1;
-    }
-    int num = num_points_per_pillar[pillar_index];
-    if (num &lt; max_num_points_per_pillar_) {
-      for (int j = 0; j &lt; num_point_feature_; ++j) {
-        pillar_point_feature[pillar_index * max_num_points_per_pillar_ *
-                                 num_point_feature_ +
-                             num * num_point_feature_ + j] =
-            in_points_array[i * num_point_feature_ + j];
-      }
-      num_points_per_pillar[pillar_index] += 1;
-    }
-  }
-
-  for (int i = 0; i &lt; max_num_pillars_; ++i) {
-    float x = 0;
-    float y = 0;
-    if (i &lt; pillar_count) {
-      x = static_cast&lt;float&gt;(x_coors[i]);
-      y = static_cast&lt;float&gt;(y_coors[i]);
-    }
-    pillar_coors[i * 4 + 0] = 0;  // batch idx, but currently it is useless
-    pillar_coors[i * 4 + 1] = 0;  // z
-    pillar_coors[i * 4 + 2] = y;
-    pillar_coors[i * 4 + 3] = x;
-  }
-  host_pillar_count[0] = pillar_count;
-
-  delete[] coor_to_pillaridx;
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\preprocess_points.h" new_path="" added_lines="0" deleted_lines="125">
				<diff>@@ -1,125 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file preprocess_points.h
- * @brief CPU version of preprocess points
- * @author Kosuke Murakami
- * @date 2019/02/26
- */
-
-#pragma once
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class PreprocessPoints {
- private:
-  friend class TestClass;
-  const int max_num_pillars_;
-  const int max_num_points_per_pillar_;
-  const int num_point_feature_;
-  const int grid_x_size_;
-  const int grid_y_size_;
-  const int grid_z_size_;
-  const float pillar_x_size_;
-  const float pillar_y_size_;
-  const float pillar_z_size_;
-  const float min_x_range_;
-  const float min_y_range_;
-  const float min_z_range_;
-  const int num_inds_for_scan_;
-
- public:
-  /**
-   * @brief Constructor
-   * @param[in] max_num_pillars Maximum number of pillars
-   * @param[in] max_points_per_pillar Maximum number of points per pillar
-   * @param[in] num_point_feature Number of features in a point
-   * @param[in] grid_x_size Number of pillars in x-coordinate
-   * @param[in] grid_y_size Number of pillars in y-coordinate
-   * @param[in] grid_z_size Number of pillars in z-coordinate
-   * @param[in] pillar_x_size Size of x-dimension for a pillar
-   * @param[in] pillar_y_size Size of y-dimension for a pillar
-   * @param[in] pillar_z_size Size of z-dimension for a pillar
-   * @param[in] min_x_range Minimum x value for pointcloud
-   * @param[in] min_y_range Minimum y value for pointcloud
-   * @param[in] min_z_range Minimum z value for pointcloud
-   * @param[in] num_inds_for_scan Number of indexes for scan(cumsum)
-   * @details Captital variables never change after the compile
-   */
-  PreprocessPoints(const int max_num_pillars, const int max_points_per_pillar,
-                   const int num_point_feature, const int grid_x_size,
-                   const int grid_y_size, const int grid_z_size,
-                   const float pillar_x_size, const float pillar_y_size,
-                   const float pillar_z_size, const float min_x_range,
-                   const float min_y_range, const float min_z_range,
-                   const int num_inds_for_scan);
-
-  /**
-   * @brief CPU preprocessing for input pointcloud
-   * @param[in] in_points_array Pointcloud array
-   * @param[in] in_num_points The number of points
-   * @param[in] x_coors X-coordinate indexes for corresponding pillars
-   * @param[in] y_coors Y-coordinate indexes for corresponding pillars
-   * @param[in] num_points_per_pillar Number of points in corresponding pillars
-   * @param[in] pillar_point_feature Values for features of points in each
-   * pillar
-   * @param[in] pillar_coors Array for coors of pillars
-   * @param[in] sparse_pillar_map Grid map representation for pillar-occupancy
-   * @param[in] host_pillar_count The numnber of valid pillars for the input
-   * pointcloud
-   * @details Convert pointcloud to pillar representation
-   */
-  void Preprocess(const float* in_points_array, int in_num_points, int* x_coors,
-                  int* y_coors, float* num_points_per_pillar,
-                  float* pillar_point_feature, float* pillar_coors,
-                  float* sparse_pillar_map, int* host_pillar_count);
-
-  /**
-   * @brief Initializing variables for preprocessing
-   * @param[in] coor_to_pillaridx Map for converting one set of coordinate to a
-   * pillar
-   * @param[in] sparse_pillar_map Grid map representation for pillar-occupancy
-   * @param[in] pillar_point_feature Values for features of points in each
-   * pillar
-   * @param[in] pillar_coors Array for coors of pillars
-   * @details Initializeing input arguments with certain values
-   */
-  void InitializeVariables(int* coor_to_pillaridx, float* sparse_pillar_map,
-                           float* pillar_point_feature, float* pillar_coors);
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\preprocess_points_cuda.cu" new_path="" added_lines="0" deleted_lines="213">
				<diff>@@ -1,213 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// headers in STL
-#include &lt;iostream&gt;
-
-// headers in local files
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/common.h"
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/preprocess_points_cuda.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-__global__ void make_pillar_histo_kernel(
-    const float* dev_points, float* dev_pillar_point_feature_in_coors,
-    int* pillar_count_histo, const int num_points,
-    const int max_points_per_pillar, const int grid_x_size,
-    const int grid_y_size, const int grid_z_size, const float min_x_range,
-    const float min_y_range, const float min_z_range, const float pillar_x_size,
-    const float pillar_y_size, const float pillar_z_size,
-    const int num_point_feature) {
-  int th_i = threadIdx.x + blockIdx.x * blockDim.x;
-  if (th_i &gt;= num_points) {
-    return;
-  }
-  int y_coor = floor((dev_points[th_i * num_point_feature + 1] - min_y_range) /
-                     pillar_y_size);
-  int x_coor = floor((dev_points[th_i * num_point_feature + 0] - min_x_range) /
-                     pillar_x_size);
-  int z_coor = floor((dev_points[th_i * num_point_feature + 2] - min_z_range) /
-                     pillar_z_size);
-
-  if (x_coor &gt;= 0 &amp;&amp; x_coor &lt; grid_x_size &amp;&amp; y_coor &gt;= 0 &amp;&amp;
-      y_coor &lt; grid_y_size &amp;&amp; z_coor &gt;= 0 &amp;&amp; z_coor &lt; grid_z_size) {
-    int count =
-        atomicAdd(&amp;pillar_count_histo[y_coor * grid_x_size + x_coor], 1);
-    if (count &lt; max_points_per_pillar) {
-      int ind =
-          y_coor * grid_x_size * max_points_per_pillar * num_point_feature +
-          x_coor * max_points_per_pillar * num_point_feature +
-          count * num_point_feature;
-      for (int i = 0; i &lt; num_point_feature; ++i) {
-        dev_pillar_point_feature_in_coors[ind + i] =
-            dev_points[th_i * num_point_feature + i];
-      }
-    }
-  }
-}
-
-__global__ void make_pillar_index_kernel(
-    int* dev_pillar_count_histo, int* dev_counter, int* dev_pillar_count,
-    int* dev_x_coors, int* dev_y_coors, float* dev_num_points_per_pillar,
-    int* dev_sparse_pillar_map, const int max_pillars,
-    const int max_points_per_pillar, const int grid_x_size,
-    const int num_inds_for_scan) {
-  int x = blockIdx.x;
-  int y = threadIdx.x;
-  int num_points_at_this_pillar = dev_pillar_count_histo[y * grid_x_size + x];
-  if (num_points_at_this_pillar == 0) {
-    return;
-  }
-
-  int count = atomicAdd(dev_counter, 1);
-  if (count &lt; max_pillars) {
-    atomicAdd(dev_pillar_count, 1);
-    if (num_points_at_this_pillar &gt;= max_points_per_pillar) {
-      dev_num_points_per_pillar[count] = max_points_per_pillar;
-    } else {
-      dev_num_points_per_pillar[count] = num_points_at_this_pillar;
-    }
-    dev_x_coors[count] = x;
-    dev_y_coors[count] = y;
-    dev_sparse_pillar_map[y * num_inds_for_scan + x] = 1;
-  }
-}
-
-__global__ void make_pillar_feature_kernel(
-    float* dev_pillar_point_feature_in_coors, float* dev_pillar_point_feature,
-    float* dev_pillar_coors, int* dev_x_coors, int* dev_y_coors,
-    float* dev_num_points_per_pillar, const int max_points,
-    const int num_point_feature, const int grid_x_size) {
-  int ith_pillar = blockIdx.x;
-  int num_points_at_this_pillar = dev_num_points_per_pillar[ith_pillar];
-  int ith_point = threadIdx.x;
-  if (ith_point &gt;= num_points_at_this_pillar) {
-    return;
-  }
-  int x_ind = dev_x_coors[ith_pillar];
-  int y_ind = dev_y_coors[ith_pillar];
-  int pillar_ind = ith_pillar * max_points * num_point_feature +
-                   ith_point * num_point_feature;
-  int coors_ind = y_ind * grid_x_size * max_points * num_point_feature +
-                  x_ind * max_points * num_point_feature +
-                  ith_point * num_point_feature;
-  for (int i = 0; i &lt; num_point_feature; ++i) {
-    dev_pillar_point_feature[pillar_ind + i] =
-        dev_pillar_point_feature_in_coors[coors_ind + i];
-  }
-
-  float coor_x = static_cast&lt;float&gt;(x_ind);
-  float coor_y = static_cast&lt;float&gt;(y_ind);
-  dev_pillar_coors[ith_pillar * 4 + 0] = 0;  // batch idx
-  dev_pillar_coors[ith_pillar * 4 + 1] = 0;  // z
-  dev_pillar_coors[ith_pillar * 4 + 2] = coor_y;
-  dev_pillar_coors[ith_pillar * 4 + 3] = coor_x;
-}
-
-PreprocessPointsCuda::PreprocessPointsCuda(
-    const int num_threads, const int max_num_pillars,
-    const int max_points_per_pillar, const int num_point_feature,
-    const int num_inds_for_scan, const int grid_x_size, const int grid_y_size,
-    const int grid_z_size, const float pillar_x_size, const float pillar_y_size,
-    const float pillar_z_size, const float min_x_range, const float min_y_range,
-    const float min_z_range)
-    : num_threads_(num_threads),
-      max_num_pillars_(max_num_pillars),
-      max_num_points_per_pillar_(max_points_per_pillar),
-      num_point_feature_(num_point_feature),
-      num_inds_for_scan_(num_inds_for_scan),
-      grid_x_size_(grid_x_size),
-      grid_y_size_(grid_y_size),
-      grid_z_size_(grid_z_size),
-      pillar_x_size_(pillar_x_size),
-      pillar_y_size_(pillar_y_size),
-      pillar_z_size_(pillar_z_size),
-      min_x_range_(min_x_range),
-      min_y_range_(min_y_range),
-      min_z_range_(min_z_range) {
-  GPU_CHECK(
-      cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_pillar_point_feature_in_coors_),
-                 grid_y_size_ * grid_x_size_ * max_num_points_per_pillar_ *
-                     num_point_feature_ * sizeof(float)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_pillar_count_histo_),
-                       grid_y_size_ * grid_x_size_ * sizeof(int)));
-  GPU_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_counter_), sizeof(int)));
-  GPU_CHECK(
-      cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;dev_pillar_count_), sizeof(int)));
-}
-
-PreprocessPointsCuda::~PreprocessPointsCuda() {
-  GPU_CHECK(cudaFree(dev_pillar_point_feature_in_coors_));
-
-  GPU_CHECK(cudaFree(dev_pillar_count_histo_));
-
-  GPU_CHECK(cudaFree(dev_counter_));
-  GPU_CHECK(cudaFree(dev_pillar_count_));
-}
-
-void PreprocessPointsCuda::DoPreprocessPointsCuda(
-    const float* dev_points, const int in_num_points, int* dev_x_coors,
-    int* dev_y_coors, float* dev_num_points_per_pillar,
-    float* dev_pillar_point_feature, float* dev_pillar_coors,
-    int* dev_sparse_pillar_map, int* host_pillar_count) {
-  GPU_CHECK(cudaMemset(dev_pillar_count_histo_, 0,
-                       grid_y_size_ * grid_x_size_ * sizeof(int)));
-  GPU_CHECK(cudaMemset(dev_counter_, 0, sizeof(int)));
-  GPU_CHECK(cudaMemset(dev_pillar_count_, 0, sizeof(int)));
-
-  int num_block = DIVUP(in_num_points, num_threads_);
-  make_pillar_histo_kernel&lt;&lt;&lt;num_block, num_threads_&gt;&gt;&gt;(
-      dev_points, dev_pillar_point_feature_in_coors_, dev_pillar_count_histo_,
-      in_num_points, max_num_points_per_pillar_, grid_x_size_, grid_y_size_,
-      grid_z_size_, min_x_range_, min_y_range_, min_z_range_, pillar_x_size_,
-      pillar_y_size_, pillar_z_size_, num_point_feature_);
-
-  make_pillar_index_kernel&lt;&lt;&lt;grid_x_size_, grid_y_size_&gt;&gt;&gt;(
-      dev_pillar_count_histo_, dev_counter_, dev_pillar_count_, dev_x_coors,
-      dev_y_coors, dev_num_points_per_pillar, dev_sparse_pillar_map,
-      max_num_pillars_, max_num_points_per_pillar_, grid_x_size_,
-      num_inds_for_scan_);
-
-  GPU_CHECK(cudaMemcpy(host_pillar_count, dev_pillar_count_, sizeof(int),
-                       cudaMemcpyDeviceToHost));
-  make_pillar_feature_kernel&lt;&lt;&lt;host_pillar_count[0],
-                               max_num_points_per_pillar_&gt;&gt;&gt;(
-      dev_pillar_point_feature_in_coors_, dev_pillar_point_feature,
-      dev_pillar_coors, dev_x_coors, dev_y_coors, dev_num_points_per_pillar,
-      max_num_points_per_pillar_, num_point_feature_, grid_x_size_);
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\preprocess_points_cuda.h" new_path="" added_lines="0" deleted_lines="128">
				<diff>@@ -1,128 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file preprocess_points_cuda.h
- * @brief GPU version of preprocess points
- * @author Kosuke Murakami
- * @date 2019/02/26
- */
-
-#pragma once
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class PreprocessPointsCuda {
- private:
-  // initializer list
-  const int num_threads_;
-  const int max_num_pillars_;
-  const int max_num_points_per_pillar_;
-  const int num_point_feature_;
-  const int num_inds_for_scan_;
-  const int grid_x_size_;
-  const int grid_y_size_;
-  const int grid_z_size_;
-  const float pillar_x_size_;
-  const float pillar_y_size_;
-  const float pillar_z_size_;
-  const float min_x_range_;
-  const float min_y_range_;
-  const float min_z_range_;
-  // end initializer list
-
-  float* dev_pillar_point_feature_in_coors_;
-  int* dev_pillar_count_histo_;
-
-  int* dev_counter_;
-  int* dev_pillar_count_;
-
- public:
-  /**
-   * @brief Constructor
-   * @param[in] num_threads Number of threads when launching cuda kernel
-   * @param[in] max_num_pillars Maximum number of pillars
-   * @param[in] max_points_per_pillar Maximum number of points per pillar
-   * @param[in] num_point_feature Number of features in a point
-   * @param[in] num_inds_for_scan Number of indexes for scan(cumsum)
-   * @param[in] grid_x_size Number of pillars in x-coordinate
-   * @param[in] grid_y_size Number of pillars in y-coordinate
-   * @param[in] grid_z_size Number of pillars in z-coordinate
-   * @param[in] pillar_x_size Size of x-dimension for a pillar
-   * @param[in] pillar_y_size Size of y-dimension for a pillar
-   * @param[in] pillar_z_size Size of z-dimension for a pillar
-   * @param[in] min_x_range Minimum x value for point cloud
-   * @param[in] min_y_range Minimum y value for point cloud
-   * @param[in] min_z_range Minimum z value for point cloud
-   * @details Captital variables never change after the compile
-   */
-  PreprocessPointsCuda(const int num_threads, const int max_num_pillars,
-                       const int max_points_per_pillar,
-                       const int num_point_feature, const int num_inds_for_scan,
-                       const int grid_x_size, const int grid_y_size,
-                       const int grid_z_size, const float pillar_x_size,
-                       const float pillar_y_size, const float pillar_z_size,
-                       const float min_x_range, const float min_y_range,
-                       const float min_z_range);
-  ~PreprocessPointsCuda();
-
-  /**
-   * @brief CUDA preprocessing for input point cloud
-   * @param[in] dev_points Point cloud array
-   * @param[in] in_num_points The number of points
-   * @param[in] dev_x_coors X-coordinate indexes for corresponding pillars
-   * @param[in] dev_y_coors Y-coordinate indexes for corresponding pillars
-   * @param[in] dev_num_points_per_pillar
-   *   Number of points in corresponding pillars
-   * @param[in] pillar_point_feature
-   *   Values of point feature in each pillar
-   * @param[in] pillar_coors Array for coors of pillars
-   * @param[in] dev_sparse_pillar_map
-   *   Grid map representation for pillar-occupancy
-   * @param[in] host_pillar_count
-   *   The number of valid pillars for an input point cloud
-   * @details Convert point cloud to pillar representation
-   */
-  void DoPreprocessPointsCuda(const float* dev_points, const int in_num_points,
-                              int* dev_x_coors, int* dev_y_coors,
-                              float* dev_num_points_per_pillar,
-                              float* dev_pillar_point_feature,
-                              float* dev_pillar_coors,
-                              int* dev_sparse_pillar_map,
-                              int* host_pillar_count);
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\scatter_cuda.cu" new_path="" added_lines="0" deleted_lines="68">
				<diff>@@ -1,68 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// headers in local files
-#include "modules/perception/lidar/lib/detection/lidar_point_pillars/scatter_cuda.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-__global__ void scatter_kernel(int *x_coors, int *y_coors, float *pfe_output,
-                               float *scattered_feature, const int grid_x_size,
-                               const int grid_y_size) {
-  int i_pillar = blockIdx.x;
-  int i_feature = threadIdx.x;
-  int x_ind = x_coors[i_pillar];
-  int y_ind = y_coors[i_pillar];
-  float feature = pfe_output[i_pillar * 64 + i_feature];
-  scattered_feature[i_feature * grid_y_size * grid_x_size +
-                    y_ind * grid_x_size + x_ind] = feature;
-}
-
-ScatterCuda::ScatterCuda(const int num_threads, const int grid_x_size,
-                         const int grid_y_size)
-    : num_threads_(num_threads),
-      grid_x_size_(grid_x_size),
-      grid_y_size_(grid_y_size) {}
-
-void ScatterCuda::DoScatterCuda(const int pillar_count, int *x_coors,
-                                int *y_coors, float *pfe_output,
-                                float *scattered_feature) {
-  scatter_kernel&lt;&lt;&lt;pillar_count, num_threads_&gt;&gt;&gt;(x_coors, y_coors, pfe_output,
-                                                 scattered_feature,
-                                                 grid_x_size_, grid_y_size_);
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detection\lidar_point_pillars\scatter_cuda.h" new_path="" added_lines="0" deleted_lines="79">
				<diff>@@ -1,79 +0,0 @@
-/******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file scatter_cuda.h
- * @brief CUDA code for scatter operation
- * @author Kosuke Murakami
- * @date 2019/02/26
- */
-
-#pragma once
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class ScatterCuda {
- private:
-  const int num_threads_;
-  const int grid_x_size_;
-  const int grid_y_size_;
-
- public:
-  /**
-   * @brief Constructor
-   * @param[in] num_threads The number of threads to launch cuda kernel
-   * @param[in] grid_x_size Number of pillars in x-coordinate
-   * @param[in] grid_y_size Number of pillars in y-coordinate
-   * @details Captital variables never change after the compile
-   */
-  ScatterCuda(const int num_threads, const int grid_x_size,
-              const int grid_y_size);
-
-  /**
-   * @brief Call scatter cuda kernel
-   * @param[in] pillar_count The valid number of pillars
-   * @param[in] x_coors X-coordinate indexes for corresponding pillars
-   * @param[in] y_coors Y-coordinate indexes for corresponding pillars
-   * @param[in] pfe_output Output from Pillar Feature Extractor
-   * @param[out] scattered_feature Gridmap representation for pillars' feature
-   * @details Allocate pillars in gridmap based on index(coordinates)
-   * information
-   */
-  void DoScatterCuda(const int pillar_count, int* x_coors, int* y_coors,
-                     float* pfe_output, float* scattered_feature);
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\interface\base_lidar_detector.h" new_path="modules\perception\lidar\lib\interface\base_lidar_detector.h" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
+ * Copyright 2021 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\interface\base_pointcloud_preprocessor.h" new_path="modules\perception\lidar\lib\interface\base_pointcloud_preprocessor.h" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
+ * Copyright 2021 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.cc" new_path="" added_lines="0" deleted_lines="501">
				<diff>@@ -1,501 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/cnnseg/cnn_segmentation.h"
-
-#include &lt;map&gt;
-
-#include "modules/perception/lidar/lib/segmentation/cnnseg/proto/cnnseg_config.pb.h"
-
-#include "cyber/common/file.h"
-#include "cyber/common/log.h"
-#include "modules/common/adapters/adapter_gflags.h"
-#include "modules/perception/base/object_pool_types.h"
-#include "modules/perception/inference/inference_factory.h"
-#include "modules/perception/lib/config_manager/config_manager.h"
-#include "modules/perception/lidar/common/lidar_point_label.h"
-#include "modules/perception/lidar/common/lidar_timer.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/util.h"
-#include "modules/perception/lidar/lib/segmentation/ncut/ncut_segmentation.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-using apollo::cyber::common::GetAbsolutePath;
-using apollo::cyber::common::GetProtoFromFile;
-using base::AttributePointCloud;
-using base::Object;
-using base::PointF;
-
-bool CNNSegmentation::Init(const LidarDetectorInitOptions&amp; options) {
-  // get configs
-  std::string param_file;
-  std::string proto_file;
-  std::string weight_file;
-  std::string engine_file;
-
-  if (!FLAGS_lidar_model_version.empty()) {
-    sensor_name_ = FLAGS_lidar_model_version;
-  } else {
-    sensor_name_ = options.sensor_name;
-  }
-
-  CHECK(GetConfigs(&amp;param_file, &amp;proto_file, &amp;weight_file, &amp;engine_file));
-  AINFO &lt;&lt; "--    param_file: " &lt;&lt; param_file;
-  AINFO &lt;&lt; "--    proto_file: " &lt;&lt; proto_file;
-  AINFO &lt;&lt; "--    weight_file: " &lt;&lt; weight_file;
-  AINFO &lt;&lt; "--    engine_file: " &lt;&lt; engine_file;
-
-  // get cnnseg params
-  ACHECK(GetProtoFromFile(param_file, &amp;cnnseg_param_))
-      &lt;&lt; "Failed to parse CNNSegParam config file." &lt;&lt; param_file;
-  ACHECK(GetProtoFromFile(engine_file, &amp;spp_engine_config_))
-      &lt;&lt; "Failed to parse SppEngine config file." &lt;&lt; engine_file;
-
-  // init feature parameters
-  const FeatureParam&amp; feature_param = cnnseg_param_.feature_param();
-  range_ = feature_param.point_cloud_range();
-  width_ = feature_param.width();
-  height_ = feature_param.height();
-  min_height_ = feature_param.min_height();
-  max_height_ = feature_param.max_height();
-
-  // init inference model
-  const NetworkParam&amp; network_param = cnnseg_param_.network_param();
-  std::vector&lt;std::string&gt; output_names;
-  output_names.push_back(network_param.instance_pt_blob());
-  output_names.push_back(network_param.category_pt_blob());
-  output_names.push_back(network_param.confidence_pt_blob());
-  output_names.push_back(network_param.height_pt_blob());
-  output_names.push_back(network_param.heading_pt_blob());
-  output_names.push_back(network_param.class_pt_blob());
-  std::vector&lt;std::string&gt; input_names;
-  input_names.push_back(network_param.feature_blob());
-  inference_.reset(inference::CreateInferenceByName(cnnseg_param_.model_type(),
-                                                    proto_file, weight_file,
-                                                    output_names, input_names));
-  CHECK_NOTNULL(inference_.get());
-
-  gpu_id_ = cnnseg_param_.has_gpu_id() ? cnnseg_param_.gpu_id() : -1;
-  BASE_CUDA_CHECK(cudaSetDevice(gpu_id_));
-  inference_-&gt;set_gpu_id(gpu_id_);  // inference sets CPU mode when -1
-
-  std::map&lt;std::string, std::vector&lt;int&gt;&gt; input_shapes;
-  auto&amp; input_shape = input_shapes[network_param.feature_blob()];
-  input_shape = {1, 8, height_, width_};
-  if (!feature_param.use_intensity_feature()) {
-    input_shape[1] -= 2;
-  }
-  if (!feature_param.use_constant_feature()) {
-    input_shape[1] -= 2;
-  }
-  ACHECK(inference_-&gt;Init(input_shapes)) &lt;&lt; "Failed to init inference.";
-
-  // init blobs
-  instance_pt_blob_ = inference_-&gt;get_blob(network_param.instance_pt_blob());
-  CHECK_NOTNULL(instance_pt_blob_.get());
-  category_pt_blob_ = inference_-&gt;get_blob(network_param.category_pt_blob());
-  CHECK_NOTNULL(category_pt_blob_.get());
-  confidence_pt_blob_ =
-      inference_-&gt;get_blob(network_param.confidence_pt_blob());
-  CHECK_NOTNULL(confidence_pt_blob_.get());
-  height_pt_blob_ = inference_-&gt;get_blob(network_param.height_pt_blob());
-  CHECK_NOTNULL(height_pt_blob_.get());
-  feature_blob_ = inference_-&gt;get_blob(network_param.feature_blob());
-  CHECK_NOTNULL(feature_blob_.get());
-  if (cnnseg_param_.do_classification()) {
-    classify_pt_blob_ = inference_-&gt;get_blob(network_param.class_pt_blob());
-    CHECK_NOTNULL(classify_pt_blob_.get());
-  }
-  if (cnnseg_param_.do_heading()) {
-    heading_pt_blob_ = inference_-&gt;get_blob(network_param.heading_pt_blob());
-    CHECK_NOTNULL(heading_pt_blob_.get());
-  }
-
-  // init feature generator
-  feature_generator_.reset(new FeatureGenerator);
-  ACHECK(feature_generator_-&gt;Init(feature_param, feature_blob_.get()))
-      &lt;&lt; "Failed to init feature generator.";
-
-  point2grid_.reserve(kDefaultPointCloudSize);
-
-  // init cluster and background segmentation methods
-  ACHECK(InitClusterAndBackgroundSegmentation());
-
-  // secondary segmentor
-  /*if (cnnseg_param_.fill_recall_with_ncut()) {
-     secondary_segmentor.reset(new NCutSegmentation());
-     if(!secondary_segmentor-&gt;Init(SegmentationInitOptions())) {
-         AERROR&lt;&lt;"initialized secondary segmentor fails";
-         return false;
-     }
-  }*/
-  return true;
-}
-
-bool CNNSegmentation::InitClusterAndBackgroundSegmentation() {
-  // init ground detector
-  ground_detector_ = BaseGroundDetectorRegisterer::GetInstanceByName(
-      cnnseg_param_.ground_detector());
-  CHECK_NOTNULL(ground_detector_);
-  GroundDetectorInitOptions ground_detector_init_options;
-  ACHECK(ground_detector_-&gt;Init(ground_detector_init_options))
-      &lt;&lt; "Failed to init ground detection.";
-
-  // init roi filter
-  roi_filter_ =
-      BaseROIFilterRegisterer::GetInstanceByName(cnnseg_param_.roi_filter());
-  CHECK_NOTNULL(roi_filter_);
-  ROIFilterInitOptions roi_filter_init_options;
-  ACHECK(roi_filter_-&gt;Init(roi_filter_init_options))
-      &lt;&lt; "Failed to init roi filter.";
-
-  // init spp engine
-  SppParams params;
-  params.height_gap = spp_engine_config_.height_gap();
-  params.confidence_range = cnnseg_param_.confidence_range();
-
-  // init spp data
-  auto&amp; spp_data = spp_engine_.GetSppData();
-  spp_data.instance_pt_blob = instance_pt_blob_.get();
-  spp_data.category_pt_blob = category_pt_blob_.get();
-  spp_data.confidence_pt_blob = confidence_pt_blob_.get();
-
-  spp_data.objectness_threshold = cnnseg_param_.objectness_thresh();
-  spp_data.confidence_threshold = cnnseg_param_.confidence_thresh();
-  spp_data.top_z_threshold = cnnseg_param_.height_thresh();
-  spp_data.class_num = static_cast&lt;size_t&gt;(MetaType::MAX_META_TYPE);
-  if (height_pt_blob_ != nullptr) {
-    spp_data.height_pt_blob = height_pt_blob_.get();
-  }
-  if (cnnseg_param_.do_classification()) {
-    spp_data.classify_pt_blob = classify_pt_blob_.get();
-  }
-  if (cnnseg_param_.do_heading()) {
-    spp_data.heading_pt_blob = heading_pt_blob_.get();
-  }
-  spp_data.MakeReference(width_, height_, range_);
-
-  // init spp engine
-  spp_engine_.Init(width_, height_, range_, params, sensor_name_);
-
-  roi_cloud_ = base::PointFCloudPool::Instance().Get();
-  roi_world_cloud_ = base::PointDCloudPool::Instance().Get();
-
-  // init thread worker
-  worker_.Bind([&amp;]() {
-    Timer timer;
-    ROIFilterOptions roi_filter_options;
-    AINFO &lt;&lt; "before roi filter";
-    if (lidar_frame_ref_-&gt;hdmap_struct != nullptr &amp;&amp;
-        roi_filter_-&gt;Filter(roi_filter_options, lidar_frame_ref_)) {
-      roi_cloud_-&gt;CopyPointCloud(*lidar_frame_ref_-&gt;cloud,
-                                 lidar_frame_ref_-&gt;roi_indices);
-      roi_world_cloud_-&gt;CopyPointCloud(*lidar_frame_ref_-&gt;world_cloud,
-                                       lidar_frame_ref_-&gt;roi_indices);
-    } else {
-      AINFO &lt;&lt; "Fail to call roi filter, use origin cloud.";
-      lidar_frame_ref_-&gt;roi_indices.indices.resize(original_cloud_-&gt;size());
-      // we manually fill roi indices with all cloud point indices
-      std::iota(lidar_frame_ref_-&gt;roi_indices.indices.begin(),
-                lidar_frame_ref_-&gt;roi_indices.indices.end(), 0);
-      // note roi cloud's memory should be kept here
-      *roi_cloud_ = *original_cloud_;
-      *roi_world_cloud_ = *original_world_cloud_;
-    }
-    lidar_frame_ref_-&gt;cloud = roi_cloud_;
-    lidar_frame_ref_-&gt;world_cloud = roi_world_cloud_;
-
-    roi_filter_time_ = timer.toc(true);
-    AINFO &lt;&lt; "after roi filter";
-    GroundDetectorOptions ground_detector_options;
-    ground_detector_-&gt;Detect(ground_detector_options, lidar_frame_ref_);
-    if (lidar_frame_ref_-&gt;cloud != original_cloud_) {
-      lidar_frame_ref_-&gt;cloud = original_cloud_;
-    }
-    if (lidar_frame_ref_-&gt;world_cloud != original_world_cloud_) {
-      lidar_frame_ref_-&gt;world_cloud = original_world_cloud_;
-    }
-    ground_detector_time_ = timer.toc(true);
-    AINFO &lt;&lt; "Roi-filter time: " &lt;&lt; roi_filter_time_
-          &lt;&lt; "\tGround-detector time: " &lt;&lt; ground_detector_time_;
-    return true;
-  });
-  worker_.Start();
-  return true;
-}
-
-void CNNSegmentation::MapPointToGrid(
-    const std::shared_ptr&lt;AttributePointCloud&lt;PointF&gt;&gt;&amp; pc_ptr) {
-  float inv_res_x = 0.5f * static_cast&lt;float&gt;(width_) / range_;
-  // float inv_res_y = 0.5 * static_cast&lt;float&gt;(height_) / range_;
-  point2grid_.assign(pc_ptr-&gt;size(), -1);
-  int pos_x = -1;
-  int pos_y = -1;
-  for (size_t i = 0; i &lt; pc_ptr-&gt;size(); ++i) {
-    const auto&amp; pt = pc_ptr-&gt;at(i);
-    if (pt.z &lt;= min_height_ || pt.z &gt;= max_height_) {
-      continue;
-    }
-    // the coordinates of x and y are exchanged here
-    // (row &lt;-&gt; x, column &lt;-&gt; y)
-    // int pos_x = F2I(pt.y, range_, inv_res_x);  // col
-    // int pos_y = F2I(pt.x, range_, inv_res_y);  // row
-    // 2018.6.21, switch to axis rotated projection
-    GroupPc2Pixel(pt.x, pt.y, inv_res_x, range_, &amp;pos_x, &amp;pos_y);
-    if (pos_y &lt; 0 || pos_y &gt;= height_ || pos_x &lt; 0 || pos_x &gt;= width_) {
-      continue;
-    }
-    point2grid_[i] = pos_y * width_ + pos_x;
-  }
-}
-
-bool CNNSegmentation::Detect(const LidarDetectorOptions&amp; options,
-                              LidarFrame* frame) {
-  // check input
-  if (frame == nullptr) {
-    AERROR &lt;&lt; "Input null frame ptr.";
-    return false;
-  }
-  if (frame-&gt;cloud == nullptr) {
-    AERROR &lt;&lt; "Input null frame cloud.";
-    return false;
-  }
-  if (frame-&gt;world_cloud == nullptr) {
-    AERROR &lt;&lt; "Input null frame world cloud.";
-    return false;
-  }
-  if (frame-&gt;cloud-&gt;size() == 0) {
-    AERROR &lt;&lt; "Input none points.";
-    return false;
-  }
-  if (frame-&gt;cloud-&gt;size() != frame-&gt;world_cloud-&gt;size()) {
-    AERROR &lt;&lt; "Cloud size and world cloud size not consistent.";
-    return false;
-  }
-  // record input cloud and lidar frame
-  original_cloud_ = frame-&gt;cloud;
-  original_world_cloud_ = frame-&gt;world_cloud;
-  lidar_frame_ref_ = frame;
-
-  // check output
-  frame-&gt;segmented_objects.clear();
-  worker_.WakeUp();
-
-  // note we should use origninal cloud here, frame-&gt;cloud may be exchanged
-  Timer timer;
-  // map 3d points to 2d image grids
-  MapPointToGrid(original_cloud_);
-  mapping_time_ = timer.toc(true);
-
-  if (cudaSetDevice(gpu_id_) != cudaSuccess) {
-    AERROR &lt;&lt; "Failed to set device to " &lt;&lt; gpu_id_;
-    return false;
-  }
-
-  // generate features
-  feature_generator_-&gt;Generate(original_cloud_, point2grid_);
-  feature_time_ = timer.toc(true);
-
-  // model inference
-  inference_-&gt;Infer();
-  infer_time_ = timer.toc(true);
-
-  // processing clustering
-  GetObjectsFromSppEngine(&amp;frame-&gt;segmented_objects);
-
-  AINFO &lt;&lt; "CNNSEG: mapping: " &lt;&lt; mapping_time_ &lt;&lt; "\t"
-        &lt;&lt; " feature: " &lt;&lt; feature_time_ &lt;&lt; "\t"
-        &lt;&lt; " infer: " &lt;&lt; infer_time_ &lt;&lt; "\t"
-        &lt;&lt; " fg-seg: " &lt;&lt; fg_seg_time_ &lt;&lt; "\t"
-        &lt;&lt; " join: " &lt;&lt; join_time_ &lt;&lt; "\t"
-        &lt;&lt; " collect: " &lt;&lt; collect_time_;
-  return true;
-}
-
-void CNNSegmentation::GetObjectsFromSppEngine(
-    std::vector&lt;std::shared_ptr&lt;Object&gt;&gt;* objects) {
-  Timer timer;
-  spp_engine_.GetSppData().grid_indices = point2grid_.data();
-  size_t num_foreground =
-      spp_engine_.ProcessForegroundSegmentation(original_cloud_);
-  fg_seg_time_ = timer.toc(true);
-  // should sync with worker before do background segmentation
-  worker_.Join();
-  join_time_ = timer.toc(true);
-  // copy height from roi cloud to origin cloud,
-  // note ground points include other noise points
-  // filtered by ground detection post process
-  AINFO &lt;&lt; "Use origin cloud and copy height";
-  for (std::size_t i = 0; i &lt; lidar_frame_ref_-&gt;roi_indices.indices.size();
-       ++i) {
-    const int roi_id = lidar_frame_ref_-&gt;roi_indices.indices[i];
-    original_cloud_-&gt;mutable_points_height()-&gt;at(roi_id) =
-        roi_cloud_-&gt;points_height(i);
-    if (roi_cloud_-&gt;mutable_points_label()-&gt;at(i) ==
-        static_cast&lt;uint8_t&gt;(LidarPointLabel::GROUND)) {
-      original_cloud_-&gt;mutable_points_label()-&gt;at(roi_id) =
-          roi_cloud_-&gt;points_label().at(i);
-    }
-  }
-  memcpy(&amp;original_world_cloud_-&gt;mutable_points_height()-&gt;at(0),
-         &amp;original_cloud_-&gt;points_height().at(0),
-         sizeof(float) * original_cloud_-&gt;size());
-  memcpy(&amp;original_world_cloud_-&gt;mutable_points_label()-&gt;at(0),
-         &amp;original_cloud_-&gt;points_label().at(0),
-         sizeof(uint8_t) * original_cloud_-&gt;size());
-  if (cnnseg_param_.remove_ground_points()) {
-    num_foreground = spp_engine_.RemoveGroundPointsInForegroundCluster(
-        original_cloud_, lidar_frame_ref_-&gt;roi_indices,
-        lidar_frame_ref_-&gt;non_ground_indices);
-    if (num_foreground == 0) {
-      ADEBUG &lt;&lt; "No foreground segmentation output";
-    }
-  }
-
-  const auto&amp; clusters = spp_engine_.clusters();
-  objects-&gt;clear();
-  base::ObjectPool::Instance().BatchGet(clusters.size(), objects);
-  size_t valid = 0;
-
-  // prepare for valid point cloud for seconary segmentor
-  // after removing pts from primary segmentor, ground and non roi pts
-  /*CloudMask mask;
-  if (cnnseg_param_.fill_recall_with_ncut()) {
-     mask.Set(original_cloud_.size(), 0);
-     mask.AddIndicesOfIndices(lidar_frame_ref-&gt;roi_indices,
-  lidar_frame_ref-&gt;non_ground_indices, 1);
-  }*/
-
-  for (int i = 0; i &lt; static_cast&lt;int&gt;(clusters.size()); ++i) {
-    if (clusters[i]-&gt;points.size() &lt;= cnnseg_param_.min_pts_num() &amp;&amp;
-        clusters[i]-&gt;pixels.size() &lt; cnnseg_param_.min_pts_num()) {
-      continue;
-    }
-    auto&amp; cluster = clusters[i];
-    auto&amp; object = objects-&gt;at(valid);
-    object-&gt;lidar_supplement.num_points_in_roi = cluster-&gt;points_in_roi;
-    object-&gt;lidar_supplement.on_use = true;
-    object-&gt;lidar_supplement.is_background = false;
-    // ACHECK(cluster-&gt;points.size() == cluster-&gt;point_ids.size())
-    //  &lt;&lt; "cluster points size: " &lt;&lt; cluster-&gt;points.size()
-    //  &lt;&lt; "cluster point ids size: " &lt;&lt; cluster-&gt;point_ids.size();
-    object-&gt;lidar_supplement.cloud.CopyPointCloud(*original_cloud_,
-                                                  cluster-&gt;point_ids);
-    object-&gt;lidar_supplement.cloud_world.CopyPointCloud(*original_world_cloud_,
-                                                        cluster-&gt;point_ids);
-
-    // for miss detection, try to fill recall with ncut
-    /*if (cnnseg_param_.fill_recall_with_ncut()) {
-         base::PointIndices ind;
-         ind.indices = cluster-&gt;point_ids; // ? valid
-         mask.RemoveIndices(ind);
-    }*/
-
-    // for (auto&amp; id : cluster-&gt;point_ids) {
-    //  original_cloud_-&gt;points_label(id)
-    //    = static_cast&lt;uint8_t&gt;(LidarPointLabel::OBJECT);
-    //}
-    object-&gt;confidence = cluster-&gt;confidence;
-    object-&gt;id = static_cast&lt;int&gt;(valid);
-    if (cnnseg_param_.do_classification()) {
-      object-&gt;lidar_supplement.raw_probs.push_back(std::vector&lt;float&gt;(
-          static_cast&lt;int&gt;(base::ObjectType::MAX_OBJECT_TYPE), 0.f));
-      object-&gt;lidar_supplement.raw_classification_methods.push_back(Name());
-      object-&gt;lidar_supplement.raw_probs
-          .back()[static_cast&lt;int&gt;(base::ObjectType::UNKNOWN)] =
-          cluster-&gt;class_prob[static_cast&lt;int&gt;(MetaType::META_UNKNOWN)];
-      object-&gt;lidar_supplement.raw_probs
-          .back()[static_cast&lt;int&gt;(base::ObjectType::PEDESTRIAN)] =
-          cluster-&gt;class_prob[static_cast&lt;int&gt;(MetaType::META_PEDESTRIAN)];
-      object-&gt;lidar_supplement.raw_probs
-          .back()[static_cast&lt;int&gt;(base::ObjectType::BICYCLE)] =
-          cluster-&gt;class_prob[static_cast&lt;int&gt;(MetaType::META_NONMOT)];
-      object-&gt;lidar_supplement.raw_probs
-          .back()[static_cast&lt;int&gt;(base::ObjectType::VEHICLE)] =
-          cluster-&gt;class_prob[static_cast&lt;int&gt;(MetaType::META_SMALLMOT)] +
-          cluster-&gt;class_prob[static_cast&lt;int&gt;(MetaType::META_BIGMOT)];
-      // copy to type
-      object-&gt;type_probs.assign(
-          object-&gt;lidar_supplement.raw_probs.back().begin(),
-          object-&gt;lidar_supplement.raw_probs.back().end());
-      object-&gt;type = static_cast&lt;base::ObjectType&gt;(
-          std::distance(object-&gt;type_probs.begin(),
-                        std::max_element(object-&gt;type_probs.begin(),
-                                         object-&gt;type_probs.end())));
-    }
-
-    if (cnnseg_param_.do_heading()) {
-      // object-&gt;theta = cluster-&gt;yaw;
-      // object-&gt;direction[0] = cos(cluster-&gt;yaw);
-      // object-&gt;direction[1] = sin(cluster-&gt;yaw);
-      // 2018.6.21, switch to axis rotated projection
-      // should be reverted after retrain model.
-      static const float quater_pi = static_cast&lt;float&gt;(M_PI) * 0.25f;
-      object-&gt;theta = cluster-&gt;yaw - quater_pi;
-      object-&gt;direction[0] = cosf(cluster-&gt;yaw - quater_pi);
-      object-&gt;direction[1] = sinf(cluster-&gt;yaw - quater_pi);
-      object-&gt;direction[2] = 0;
-      object-&gt;lidar_supplement.is_orientation_ready = true;
-    }
-    ++valid;
-  }
-  objects-&gt;resize(valid);
-
-  // add additional object seg logic with ncut if cnnseg miss detects
-  /*if (cnnseg_param_.fill_recall_with_ncut() &amp;&amp; secondary_segmentor) {
-      mask.GetValidIndices(lidar_frame_ref_-&gt;secondary_indices);
-      secondary_segmentor-&gt;Segment(SegmentationOptions(), lidar_frame_ref_);
-  //segment based on lidar frame ref
-  }*/
-
-  collect_time_ = timer.toc(true);
-}
-
-bool CNNSegmentation::GetConfigs(std::string* param_file,
-                                 std::string* proto_file,
-                                 std::string* weight_file,
-                                 std::string* engine_file) {
-  auto config_manager = lib::ConfigManager::Instance();
-  const lib::ModelConfig* model_config = nullptr;
-  ACHECK(config_manager-&gt;GetModelConfig("CNNSegmentation", &amp;model_config))
-      &lt;&lt; "Failed to get model config: CNNSegmentation";
-
-  const std::string&amp; work_root = config_manager-&gt;work_root();
-  std::string root_path;
-  ACHECK(model_config-&gt;get_value("root_path", &amp;root_path))
-      &lt;&lt; "Failed to get value of root_path.";
-  std::string config_file;
-  config_file = GetAbsolutePath(work_root, root_path);
-  config_file = GetAbsolutePath(config_file, sensor_name_);
-  config_file = GetAbsolutePath(config_file, "cnnseg.conf");
-
-  CNNSegConfig config;
-  ACHECK(apollo::cyber::common::GetProtoFromFile(config_file, &amp;config))
-      &lt;&lt; "Failed to parse CNNSeg config file";
-  *proto_file = GetAbsolutePath(work_root, config.proto_file());
-  *weight_file = GetAbsolutePath(work_root, config.weight_file());
-  *param_file = GetAbsolutePath(work_root, config.param_file());
-  *engine_file = GetAbsolutePath(work_root, config.engine_file());
-
-  return true;
-}
-
-PERCEPTION_REGISTER_LIDARDETECTOR(CNNSegmentation);
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.h" new_path="" added_lines="0" deleted_lines="136">
				<diff>@@ -1,136 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;memory&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#include "gtest/gtest_prod.h"
-
-#include "modules/perception/lidar/lib/segmentation/cnnseg/proto/cnnseg_param.pb.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/proto/spp_engine_config.pb.h"
-
-#include "modules/perception/base/blob.h"
-#include "modules/perception/inference/inference.h"
-#include "modules/perception/inference/inference_factory.h"
-#include "modules/perception/lib/thread/thread_worker.h"
-#include "modules/perception/lidar/lib/interface/base_ground_detector.h"
-#include "modules/perception/lidar/lib/interface/base_roi_filter.h"
-#include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/feature_generator.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_engine.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class CNNSegmentation : public BaseLidarDetector {
- public:
-  CNNSegmentation() = default;
-  virtual ~CNNSegmentation() = default;
-
-  bool Init(const LidarDetectorInitOptions&amp; options =
-                LidarDetectorInitOptions()) override;
-
-  bool Detect(const LidarDetectorOptions&amp; options, LidarFrame* frame) override;
-
-  std::string Name() const override { return "CNNSegmentation"; }
-
- private:
-  bool GetConfigs(std::string* param_file, std::string* proto_file,
-                  std::string* weight_file, std::string* engine_file);
-
-  bool InitClusterAndBackgroundSegmentation();
-
-  void GetObjectsFromSppEngine(
-      std::vector&lt;std::shared_ptr&lt;base::Object&gt;&gt;* objects);
-
-  void MapPointToGrid(
-      const std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointF&gt;&gt;&amp; pc_ptr);
-
-  CNNSegParam cnnseg_param_;
-  std::shared_ptr&lt;inference::Inference&gt; inference_;
-  std::shared_ptr&lt;FeatureGenerator&gt; feature_generator_;
-
-  // output blobs
-  std::shared_ptr&lt;base::Blob&lt;float&gt;&gt; instance_pt_blob_;
-  std::shared_ptr&lt;base::Blob&lt;float&gt;&gt; category_pt_blob_;
-  std::shared_ptr&lt;base::Blob&lt;float&gt;&gt; confidence_pt_blob_;
-  std::shared_ptr&lt;base::Blob&lt;float&gt;&gt; classify_pt_blob_;
-  std::shared_ptr&lt;base::Blob&lt;float&gt;&gt; heading_pt_blob_;
-  std::shared_ptr&lt;base::Blob&lt;float&gt;&gt; height_pt_blob_;
-  // input blobs
-  std::shared_ptr&lt;base::Blob&lt;float&gt;&gt; feature_blob_;
-
-  // feature parameters
-  float range_ = 0.f;
-  int width_ = 0;
-  int height_ = 0;
-  float min_height_ = 0.f;
-  float max_height_ = 0.f;
-
-  // 1-d index in feature map of each point
-  std::vector&lt;int&gt; point2grid_;
-
-  // ground detector for background segmentation
-  BaseGroundDetector* ground_detector_;
-  // roi filter for background segmentation
-  BaseROIFilter* roi_filter_;
-
-  // thread worker
-  lib::ThreadWorker worker_;
-
-  // spp engine
-  SppEngine spp_engine_;
-  SppEngineConfig spp_engine_config_;
-
-  // reference pointer of lidar frame
-  LidarFrame* lidar_frame_ref_ = nullptr;
-  std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointF&gt;&gt; original_cloud_;
-  std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointD&gt;&gt;
-      original_world_cloud_;
-  std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointF&gt;&gt; roi_cloud_;
-  std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointD&gt;&gt; roi_world_cloud_;
-  int gpu_id_ = -1;
-
-  // time statistics
-  double mapping_time_ = 0.0;
-  double feature_time_ = 0.0;
-  double infer_time_ = 0.0;
-  double join_time_ = 0.0;
-  double fg_seg_time_ = 0.0;
-  double collect_time_ = 0.0;
-  double roi_filter_time_ = 0.0;
-  double ground_detector_time_ = 0.0;
-
-  // sensor_name
-  std::string sensor_name_;
-
-  // secondary segmentation to improve miss detection
-  // not found by neural networks !
-  std::shared_ptr&lt;BaseLidarDetector&gt; secondary_segmentor;
-
- private:
-  const int kDefaultPointCloudSize = 120000;
-
-  FRIEND_TEST(CNNSegmentationTest, cnn_segmentation_sequence_test);
-  FRIEND_TEST(CNNSegmentationTest, cnn_segmentation_test);
-};  // class CNNSegmentation
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation_test.cc" new_path="" added_lines="0" deleted_lines="202">
				<diff>@@ -1,202 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/cnnseg/cnn_segmentation.h"
-
-#include &lt;algorithm&gt;
-#include &lt;limits&gt;
-
-#include "gtest/gtest.h"
-#include "pcl/io/pcd_io.h"
-
-#include "modules/perception/common/io/io_util.h"
-#include "modules/perception/common/perception_gflags.h"
-
-namespace {
-constexpr float kFloatEpsilon = std::numeric_limits&lt;float&gt;::epsilon();
-}  // namespace
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-bool LoadPCDFile(const std::string&amp; file_path, base::PointFCloudPtr cloud_out) {
-  int ret = 0;
-  pcl::PointCloud&lt;pcl::PointXYZI&gt; org_cloud;
-  if ((ret = pcl::io::loadPCDFile(file_path, org_cloud)) &lt; 0) {
-    AERROR &lt;&lt; "Failed to load pcd file: " &lt;&lt; file_path &lt;&lt; " " &lt;&lt; ret;
-    return false;
-  }
-
-  cloud_out-&gt;resize(org_cloud.size());
-  int pid = 0;
-  for (size_t i = 0; i &lt; org_cloud.size(); ++i) {
-    if (std::isnan(org_cloud.at(i).x) || std::isnan(org_cloud.at(i).y) ||
-        std::isnan(org_cloud.at(i).z)) {
-      continue;
-    }
-    base::PointF&amp; pt = cloud_out-&gt;at(pid++);
-    pt.x = org_cloud.at(i).x;
-    pt.y = org_cloud.at(i).y;
-    pt.z = org_cloud.at(i).z;
-    pt.intensity = org_cloud.at(i).intensity;
-  }
-  cloud_out-&gt;resize(pid);
-
-  return true;
-}
-
-void PrintObjects(const std::vector&lt;base::ObjectPtr&gt;&amp; objects) {
-  AINFO &lt;&lt; "Total objects num: " &lt;&lt; objects.size();
-  int obj_id = 0;
-  for (auto object : objects) {
-    unsigned cloud_size =
-        static_cast&lt;unsigned&gt;(object-&gt;lidar_supplement.cloud.size());
-    AINFO &lt;&lt; "Point num of Segment: " &lt;&lt; cloud_size;
-    std::cout &lt;&lt; "-- Object " &lt;&lt; obj_id++ &lt;&lt; " : ";
-    std::cout &lt;&lt; object-&gt;ToString() &lt;&lt; ", type_probs: " &lt;&lt; object-&gt;type_probs[0]
-              &lt;&lt; ", " &lt;&lt; object-&gt;type_probs[1] &lt;&lt; ", " &lt;&lt; object-&gt;type_probs[2]
-              &lt;&lt; ", " &lt;&lt; object-&gt;type_probs[3] &lt;&lt; ", " &lt;&lt; object-&gt;type_probs[4]
-              &lt;&lt; ", " &lt;&lt; object-&gt;type_probs[5] &lt;&lt; std::endl;
-  }
-}
-
-TEST(CNNSegmentationTest, cnn_segmentation_sequence_test) {
-  unsetenv("CYBER_PATH");
-  unsetenv("MODULE_PATH");
-  FLAGS_work_root =
-      "/apollo/modules/perception/testdata/"
-      "lidar/lib/segmentation/cnnseg/";
-
-  auto segmentation = std::shared_ptr&lt;CNNSegmentation&gt;(new CNNSegmentation);
-  LidarDetectorOptions options;
-  EXPECT_FALSE(segmentation-&gt;Detect(options, nullptr));
-  LidarFrame frame_data;
-  EXPECT_FALSE(segmentation-&gt;Detect(options, &amp;frame_data));
-  frame_data.cloud = base::PointFCloudPool::Instance().Get();
-  frame_data.world_cloud = base::PointDCloudPool::Instance().Get();
-  EXPECT_FALSE(segmentation-&gt;Detect(options, &amp;frame_data));
-
-  EXPECT_TRUE(segmentation-&gt;Init());
-  EXPECT_TRUE(segmentation-&gt;InitClusterAndBackgroundSegmentation());
-
-  std::string pcd_path =
-      "/apollo/modules/perception/testdata/lidar/app/data/";
-  std::vector&lt;std::string&gt; pcd_file_names;
-  common::GetFileList(pcd_path, ".pcd", &amp;pcd_file_names);
-  std::string file_name;
-  std::sort(pcd_file_names.begin(), pcd_file_names.end(),
-            [](const std::string&amp; lhs, const std::string&amp; rhs) {
-              if (lhs.length() &lt; rhs.length()) {
-                return true;
-              } else if (lhs.length() == rhs.length()) {
-                return lhs &lt;= rhs;
-              } else {
-                return false;
-              }
-            });
-  for (size_t i = 0; i &lt; pcd_file_names.size(); ++i) {
-    std::shared_ptr&lt;LidarFrame&gt; frame(new LidarFrame);
-    frame-&gt;cloud = base::PointFCloudPool::Instance().Get();
-    frame-&gt;world_cloud = base::PointDCloudPool::Instance().Get();
-    if (!LoadPCDFile(pcd_file_names[i], frame-&gt;cloud)) {
-      continue;
-    }
-    frame-&gt;world_cloud-&gt;resize(frame-&gt;cloud-&gt;size());
-    EXPECT_TRUE(segmentation-&gt;Detect(options, frame.get()));
-  }
-}
-
-TEST(CNNSegmentationTest, cnn_segmentation_test) {
-  unsetenv("CYBER_PATH");
-  unsetenv("MODULE_PATH");
-  FLAGS_work_root =
-      "/apollo/modules/perception/testdata/"
-      "lidar/lib/segmentation/cnnseg/";
-
-  // load pcd data
-  auto pcl_ptr = std::shared_ptr&lt;base::PointFCloud&gt;(new base::PointFCloud);
-  std::string filename =
-      "/apollo/modules/perception/testdata/lidar/app/data/0002_00.pcd";
-  bool ret = LoadPCDFile(filename, pcl_ptr);
-  ACHECK(ret) &lt;&lt; "Failed to load " &lt;&lt; filename;
-  // load non ground indices
-  base::PointIndices non_ground_indices;
-  //  auto&amp; indices = non_ground_indices.indices;
-  //  std::ifstream in_file(
-  //      "/apollo/modules/perception/testdata/lidar/app/data/perception/lidar/files/0002_00.txt");
-  //  ASSERT_TRUE(in_file.good());
-  //  std::string line;
-  //  while (getline(in_file, line)) {
-  //    indices.push_back(std::stoi(line));
-  //  }
-
-  // test init
-  auto segmentation = std::shared_ptr&lt;CNNSegmentation&gt;(new CNNSegmentation);
-  EXPECT_TRUE(segmentation-&gt;Init());
-
-  // test segment
-  using base::ObjectType;
-  LidarDetectorOptions options;
-  LidarFrame frame_data;
-  frame_data.cloud = pcl_ptr;
-  frame_data.world_cloud = base::PointDCloudPool::Instance().Get();
-  frame_data.world_cloud-&gt;resize(pcl_ptr-&gt;size());
-  frame_data.non_ground_indices = non_ground_indices;
-  segmentation-&gt;Detect(options, &amp;frame_data);
-  std::vector&lt;base::ObjectPtr&gt;&amp; objects = frame_data.segmented_objects;
-  //  EXPECT_LE(4, objects.size());
-  EXPECT_GT(objects[0]-&gt;lidar_supplement.cloud.size(), 0);
-  EXPECT_GT(fabs(objects[3]-&gt;confidence), kFloatEpsilon);
-  // test heading
-  EXPECT_GT(fabs(objects[3]-&gt;theta), kFloatEpsilon);
-  // test classification
-  EXPECT_EQ(1, objects[1]-&gt;lidar_supplement.raw_classification_methods.size());
-  EXPECT_EQ(1, objects[1]-&gt;lidar_supplement.raw_probs.size());
-  EXPECT_EQ(static_cast&lt;int&gt;(ObjectType::MAX_OBJECT_TYPE),
-            objects[2]-&gt;lidar_supplement.raw_probs[0].size());
-  PrintObjects(objects);
-
-  segmentation-&gt;cnnseg_param_.set_do_classification(false);
-  segmentation-&gt;cnnseg_param_.set_do_heading(false);
-  segmentation-&gt;Detect(options, &amp;frame_data);
-  objects = frame_data.segmented_objects;
-  //  EXPECT_LE(4, objects.size());
-  EXPECT_GT(objects[0]-&gt;lidar_supplement.cloud.size(), 0);
-  EXPECT_GT(fabs(objects[3]-&gt;confidence), kFloatEpsilon);
-  // test no heading
-  EXPECT_LE(fabs(objects[3]-&gt;theta), kFloatEpsilon);
-  // test no classification
-  EXPECT_EQ(0, objects[1]-&gt;lidar_supplement.raw_probs.size());
-  EXPECT_EQ(0, objects[1]-&gt;lidar_supplement.raw_classification_methods.size());
-  PrintObjects(objects);
-
-  segmentation-&gt;InitClusterAndBackgroundSegmentation();
-  segmentation-&gt;Detect(options, &amp;frame_data);
-  objects = frame_data.segmented_objects;
-  //  EXPECT_EQ(4, objects.size());
-  EXPECT_GT(objects[0]-&gt;lidar_supplement.cloud.size(), 0);
-  EXPECT_GT(fabs(objects[3]-&gt;confidence), kFloatEpsilon);
-  PrintObjects(objects);
-
-  EXPECT_TRUE(segmentation-&gt;InitClusterAndBackgroundSegmentation());
-  EXPECT_TRUE(segmentation-&gt;Detect(options, &amp;frame_data));
-  objects = frame_data.segmented_objects;
-  //  EXPECT_LE(4, objects.size());
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\disjoint_set.h" new_path="" added_lines="0" deleted_lines="91">
				<diff>@@ -1,91 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-template &lt;class T&gt;
-void DisjointSetMakeSet(T* x) {
-  x-&gt;parent = x;
-  x-&gt;node_rank = 0;
-}
-
-template &lt;class T&gt;
-T* DisjointSetFindRecursive(T* x) {
-  if (x-&gt;parent != x) {
-    x-&gt;parent = DisjointSetFindRecursive(x-&gt;parent);
-  }
-  return x-&gt;parent;
-}
-
-template &lt;class T&gt;
-T* DisjointSetFindLoop(T* x) {
-  T* y = x;
-  while (y-&gt;parent != y) {
-    y = y-&gt;parent;
-  }
-
-  T* w = x;
-  T* temp = x;
-  while (w-&gt;parent != w) {
-    temp = w-&gt;parent;
-    w-&gt;parent = y;
-    w = temp;
-  }
-
-  return y;
-}
-
-template &lt;class T&gt;
-T* DisjointSetFind(T* x) {
-  T* y = x-&gt;parent;
-  if (y == x || y-&gt;parent == y) {
-    return y;
-  }
-  T* root = DisjointSetFindLoop(y-&gt;parent);
-  x-&gt;parent = root;
-  y-&gt;parent = root;
-  return root;
-}
-
-template &lt;class T&gt;
-void DisjointSetMerge(T* x, const T* y) {}
-
-template &lt;class T&gt;
-void DisjointSetUnion(T* x, T* y) {
-  x = DisjointSetFind(x);
-  y = DisjointSetFind(y);
-  if (x == y) {
-    return;
-  }
-  if (x-&gt;node_rank &lt; y-&gt;node_rank) {
-    x-&gt;parent = y;
-    // DisjointSetMerge(y, x);
-  } else if (y-&gt;node_rank &lt; x-&gt;node_rank) {
-    y-&gt;parent = x;
-    // DisjointSetMerge(x, y);
-  } else {
-    y-&gt;parent = x;
-    x-&gt;node_rank++;
-    // DisjointSetMerge(x, y);
-  }
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\feature_generator.cc" new_path="" added_lines="0" deleted_lines="173">
				<diff>@@ -1,173 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/cnnseg/feature_generator.h"
-
-#include &lt;limits&gt;
-
-#include "modules/perception/base/common.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/util.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-bool FeatureGenerator::Init(const FeatureParam&amp; feature_param,
-                            base::Blob&lt;float&gt;* out_blob) {
-  // set output feature blob
-  out_blob_ = out_blob;
-
-  // set feature parameters
-  range_ = feature_param.point_cloud_range();
-  width_ = feature_param.width();
-  height_ = feature_param.height();
-  min_height_ = feature_param.min_height();
-  max_height_ = feature_param.max_height();
-  CHECK_EQ(width_, height_)
-      &lt;&lt; "Current implementation version requires input_width == input_height.";
-  use_intensity_feature_ = feature_param.use_intensity_feature();
-  use_constant_feature_ = feature_param.use_constant_feature();
-
-  // set log lookup table
-  log_table_.resize(kMaxLogNum);
-  for (size_t i = 0; i &lt; log_table_.size(); ++i) {
-    log_table_[i] = std::log(static_cast&lt;float&gt;(1 + i));
-  }
-
-  // set output feature blob data
-  float* out_blob_data = nullptr;
-#if USE_GPU == 1
-  log_blob_.reset(
-      new base::Blob&lt;float&gt;(1, 1, 1, static_cast&lt;int&gt;(log_table_.size())));
-  float* log_table = log_blob_-&gt;mutable_gpu_data();
-  cudaMemcpy(log_table, log_table_.data(), log_table_.size() * sizeof(float),
-             cudaMemcpyHostToDevice);
-  out_blob_data = out_blob_-&gt;mutable_gpu_data();
-#else
-  out_blob_data = out_blob_-&gt;mutable_cpu_data();
-#endif
-
-  // set raw feature data
-  int channel_index = 0;
-  max_height_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
-  mean_height_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
-  count_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
-  if (use_constant_feature_) {
-    direction_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
-  }
-  if (use_intensity_feature_) {
-    top_intensity_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
-    mean_intensity_data_ =
-        out_blob_data + out_blob_-&gt;offset(0, channel_index++);
-  }
-  if (use_constant_feature_) {
-    distance_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
-  }
-  nonempty_data_ = out_blob_data + out_blob_-&gt;offset(0, channel_index++);
-  CHECK_EQ(out_blob_-&gt;offset(0, channel_index), out_blob_-&gt;count());
-
-  // compute direction and distance features
-  if (use_constant_feature_) {
-    int map_size = height_ * width_;
-    std::vector&lt;float&gt; direction_data(map_size);
-    std::vector&lt;float&gt; distance_data(map_size);
-    for (int row = 0; row &lt; height_; ++row) {
-      for (int col = 0; col &lt; width_; ++col) {
-        int idx = row * width_ + col;
-        // * row &lt;-&gt; x, column &lt;-&gt; y
-        float center_x = Pixel2Pc(row, static_cast&lt;float&gt;(height_), range_);
-        float center_y = Pixel2Pc(col, static_cast&lt;float&gt;(width_), range_);
-        direction_data[idx] =
-            static_cast&lt;float&gt;(std::atan2(center_y, center_x) / (2.0 * kPI));
-        distance_data[idx] =
-            static_cast&lt;float&gt;(std::hypot(center_x, center_y) / 60.0 - 0.5);
-      }
-    }
-
-// memory copy direction and distance features
-#if USE_GPU == 1
-    cudaMemcpy(direction_data_, direction_data.data(),
-               direction_data.size() * sizeof(float), cudaMemcpyHostToDevice);
-    cudaMemcpy(distance_data_, distance_data.data(),
-               distance_data.size() * sizeof(float), cudaMemcpyHostToDevice);
-#else
-    memcpy(direction_data_, direction_data.data(),
-           direction_data.size() * sizeof(float));
-    memcpy(distance_data_, distance_data.data(),
-           distance_data.size() * sizeof(float));
-#endif
-  }
-  return true;
-}
-
-void FeatureGenerator::GenerateCPU(const base::PointFCloudPtr&amp; pc_ptr,
-                                   const std::vector&lt;int&gt;&amp; point2grid) {
-  // DO NOT remove this line!!!
-  // Otherwise, the gpu_data will not be updated for the later frames.
-  // It marks the head at cpu for blob.
-  out_blob_-&gt;mutable_cpu_data();
-
-  // fill initial value for feature blob
-  const int map_size = height_ * width_;
-  for (int i = 0; i &lt; map_size; ++i) {
-    max_height_data_[i] = -5.f;
-  }
-  memset(mean_height_data_, 0, map_size * sizeof(float));
-  memset(count_data_, 0, map_size * sizeof(float));
-  memset(nonempty_data_, 0, map_size * sizeof(float));
-  if (use_intensity_feature_) {
-    memset(top_intensity_data_, 0, map_size * sizeof(float));
-    memset(mean_intensity_data_, 0, map_size * sizeof(float));
-  }
-
-  // compute features
-  for (size_t i = 0; i &lt; pc_ptr-&gt;size(); ++i) {
-    int idx = point2grid[i];
-    if (idx == -1) {
-      continue;
-    }
-    const auto&amp; pt = pc_ptr-&gt;at(i);
-    float pz = pt.z;
-    float pi = pt.intensity / 255.0f;
-    if (max_height_data_[idx] &lt; pz) {
-      max_height_data_[idx] = pz;
-      if (use_intensity_feature_) {
-        top_intensity_data_[idx] = pi;
-      }
-    }
-    mean_height_data_[idx] += static_cast&lt;float&gt;(pz);
-    if (use_intensity_feature_) {
-      mean_intensity_data_[idx] += static_cast&lt;float&gt;(pi);
-    }
-    count_data_[idx] += 1.f;
-  }
-
-  for (int i = 0; i &lt; map_size; ++i) {
-    if (count_data_[i] &lt;= std::numeric_limits&lt;float&gt;::epsilon()) {
-      max_height_data_[i] = 0.f;
-    } else {
-      mean_height_data_[i] /= count_data_[i];
-      if (use_intensity_feature_) {
-        mean_intensity_data_[i] /= count_data_[i];
-      }
-      nonempty_data_[i] = 1.f;
-    }
-    count_data_[i] = LogCount(static_cast&lt;int&gt;(count_data_[i]));
-  }
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\feature_generator.cu" new_path="" added_lines="0" deleted_lines="225">
				<diff>@@ -1,225 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/cnnseg/feature_generator.h"
-
-#include "modules/perception/base/common.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-#define CUDA_KERNEL_LOOP(i, n)                                 \
-  for (int i = blockIdx.x * blockDim.x + threadIdx.x; i &lt; (n); \
-       i += blockDim.x * gridDim.x)
-
-#if __CUDA_ARCH__ &lt; 600
-__device__ double atomicAdd(double* address, double val) {
-  unsigned long long int* address_as_ull = (unsigned long long int*)address;
-  unsigned long long int old = *address_as_ull, assumed;
-  do {
-    assumed = old;
-    old = atomicCAS(address_as_ull, assumed,
-                    __double_as_longlong(val + __longlong_as_double(assumed)));
-    // Note: uses integer comparison to avoid hang in case of NaN
-    // (since NaN != NaN)
-  } while (assumed != old);
-  return __longlong_as_double(old);
-}
-#endif
-
-__device__ float atomicAdd(float* address, float val) {
-  int* address_as_ull = reinterpret_cast&lt;int*&gt;(address);
-  int old = *address_as_ull, assumed;
-  do {
-    assumed = old;
-    old = atomicCAS(address_as_ull, assumed,
-                    __float_as_int(val + __int_as_float(assumed)));
-    // Note: uses integer comparison to avoid hang in case of NaN
-    // (since NaN != NaN)
-  } while (assumed != old);
-  return __int_as_float(old);
-}
-
-__device__ double atomic_exch(double* addr, double val) {
-  unsigned long long int* m_addr = (unsigned long long int*)addr;
-  unsigned long long int old_val = 0;
-  old_val = atomicExch(m_addr, __double_as_longlong(val));
-  return __longlong_as_double(old_val);
-}
-
-__device__ float atomic_exch(float* addr, float val) {
-  return atomicExch(addr, (val));
-}
-
-// __device__ void atomicMax(double* max_height_addr, double pz) {
-//   double old_pz = *max_height_addr;
-//   do {
-//     old_pz = atomic_exch(max_height_addr, (pz));
-//     if (pz &lt; old_pz) {
-//       pz = old_pz;
-//     }
-//   } while (pz &gt; (*max_height_addr));
-// }
-
-__device__ void atomicMax(float* max_height_addr, float pz) {
-  float old_pz = *max_height_addr;
-  do {
-    old_pz = atomic_exch(max_height_addr, (pz));
-    if (pz &lt; old_pz) {
-      pz = old_pz;
-    }
-  } while (pz &gt; (*max_height_addr));
-}
-
-template &lt;typename Dtype&gt;
-__global__ void MapKernel(const int n, const base::PointF* pc,
-                          Dtype* max_height_data, Dtype* mean_height_data,
-                          Dtype* mean_intensity_data, Dtype* count_data,
-                          int* point2grid) {
-  CUDA_KERNEL_LOOP(i, n) {
-    int idx = point2grid[i];
-    if (idx == -1) {
-      continue;
-    }
-    Dtype pz = pc[i].z;
-    Dtype pi = pc[i].intensity / 255.0;
-    atomicMax(&amp;max_height_data[idx], pz);
-    atomicAdd(&amp;mean_height_data[idx], pz);
-    if (mean_intensity_data != nullptr) {
-      atomicAdd(&amp;mean_intensity_data[idx], pi);
-    }
-    atomicAdd(&amp;count_data[idx], (Dtype)1);
-  }
-}
-
-template &lt;typename Dtype&gt;
-__global__ void AverageKernel(const int n, Dtype* count_data,
-                              Dtype* max_height_data, Dtype* mean_height_data,
-                              Dtype* mean_intensity_data, Dtype* nonempty_data,
-                              Dtype* log_table, const int max_log_num) {
-  CUDA_KERNEL_LOOP(i, n) {
-    if (count_data[i] &lt; 1e-6) {
-      max_height_data[i] = 0;
-    } else {
-      mean_height_data[i] /= count_data[i];
-      if (mean_intensity_data != nullptr) {
-        mean_intensity_data[i] /= count_data[i];
-      }
-      nonempty_data[i] = Dtype(1.0);
-    }
-    int count = static_cast&lt;int&gt;(count_data[i]);
-    if (count &lt; max_log_num) {
-      count_data[i] = log_table[count];
-    } else {
-      count_data[i] = log(1.0 + count);
-    }
-  }
-}
-
-template &lt;typename Dtype&gt;
-__global__ void TopIntensityKernel(const int n, Dtype* top_intensity,
-                                   base::PointF* pc, Dtype* max_height_data,
-                                   int* point2grid) {
-  if (top_intensity == nullptr) {
-    return;
-  }
-  CUDA_KERNEL_LOOP(i, n) {
-    int idx = point2grid[i];
-    if (idx == -1) {
-      continue;
-    }
-    Dtype pz = pc[i].z;
-    Dtype pi = pc[i].intensity / 255.0;
-    if (pz == max_height_data[idx]) {
-      top_intensity[idx] = pi;
-    }
-  }
-}
-
-template &lt;typename Dtype&gt;
-__global__ void SetKernel(const int n, const Dtype alpha, Dtype* y) {
-  CUDA_KERNEL_LOOP(i, n) { y[i] = alpha; }
-}
-
-void FeatureGenerator::GenerateGPU(const base::PointFCloudPtr&amp; pc_ptr,
-                                   const std::vector&lt;int&gt;&amp; point2grid) {
-  // fill initial value for feature blob
-  int map_size = width_ * height_;
-  int block_size = (map_size + kGPUThreadSize - 1) / kGPUThreadSize;
-  SetKernel&lt;float&gt;
-      &lt;&lt;&lt;block_size, kGPUThreadSize&gt;&gt;&gt;(map_size, -5.f, max_height_data_);
-  BASE_CUDA_CHECK(cudaMemset(mean_height_data_, 0.f, sizeof(float) * map_size));
-  BASE_CUDA_CHECK(cudaMemset(count_data_, 0.f, sizeof(float) * map_size));
-  BASE_CUDA_CHECK(cudaMemset(nonempty_data_, 0.f, sizeof(float) * map_size));
-  if (use_intensity_feature_) {
-    BASE_CUDA_CHECK(
-        cudaMemset(top_intensity_data_, 0.f, sizeof(float) * map_size));
-    BASE_CUDA_CHECK(
-        cudaMemset(mean_intensity_data_, 0.f, sizeof(float) * map_size));
-  }
-
-  // copy cloud data and point2grid from CPU to GPU memory
-  size_t cloud_size = pc_ptr-&gt;size();
-  if (cloud_size &gt; pc_gpu_size_) {
-    // cloud data
-    BASE_CUDA_CHECK(cudaFree(pc_gpu_));
-    BASE_CUDA_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;pc_gpu_),
-                               cloud_size * sizeof(base::PointF)));
-    pc_gpu_size_ = cloud_size;
-    // point2grid
-    BASE_CUDA_CHECK(cudaFree(point2grid_gpu_));
-    BASE_CUDA_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;point2grid_gpu_),
-                               cloud_size * sizeof(int)));
-  }
-  BASE_CUDA_CHECK(cudaMemcpy(pc_gpu_, &amp;(pc_ptr-&gt;front()),
-                             sizeof(base::PointF) * cloud_size,
-                             cudaMemcpyHostToDevice));
-  BASE_CUDA_CHECK(cudaMemcpy(point2grid_gpu_, point2grid.data(),
-                             sizeof(int) * cloud_size, cudaMemcpyHostToDevice));
-
-  // compute features
-  // float inv_res_x = 0.5 * width_ / range_;
-  // float inv_res_y = 0.5 * height_ / range_;
-  {
-    int block_size = (cloud_size + kGPUThreadSize - 1) / kGPUThreadSize;
-    MapKernel&lt;float&gt;&lt;&lt;&lt;block_size, kGPUThreadSize&gt;&gt;&gt;(
-        cloud_size, pc_gpu_, max_height_data_, mean_height_data_,
-        mean_intensity_data_, count_data_, point2grid_gpu_);
-    TopIntensityKernel&lt;float&gt;&lt;&lt;&lt;block_size, kGPUThreadSize&gt;&gt;&gt;(
-        cloud_size, top_intensity_data_, pc_gpu_, max_height_data_,
-        point2grid_gpu_);
-  }
-  {
-    int block_size = (map_size + kGPUThreadSize - 1) / kGPUThreadSize;
-    float* log_table = log_blob_-&gt;mutable_gpu_data() + log_blob_-&gt;offset(0, 0);
-    AverageKernel&lt;float&gt;&lt;&lt;&lt;block_size, kGPUThreadSize&gt;&gt;&gt;(
-        map_size, count_data_, max_height_data_, mean_height_data_,
-        mean_intensity_data_, nonempty_data_, log_table, kMaxLogNum);
-  }
-}
-
-void FeatureGenerator::ReleaseGPUMemory() {
-  if (pc_gpu_ != nullptr) {
-    BASE_CUDA_CHECK(cudaFree(pc_gpu_));
-  }
-  if (point2grid_gpu_ != nullptr) {
-    BASE_CUDA_CHECK(cudaFree(point2grid_gpu_));
-  }
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\feature_generator.h" new_path="" added_lines="0" deleted_lines="125">
				<diff>@@ -1,125 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;memory&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#include "gtest/gtest_prod.h"
-
-#include "modules/perception/lidar/lib/segmentation/cnnseg/proto/cnnseg_param.pb.h"
-
-#include "modules/perception/base/blob.h"
-#include "modules/perception/base/point_cloud.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class FeatureGenerator {
- public:
-  FeatureGenerator() {
-#if USE_GPU == 1
-    pc_gpu_size_ = kMaxPointCloudGPUSize;
-    BASE_CUDA_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;pc_gpu_),
-                               pc_gpu_size_ * sizeof(base::PointF)));
-    BASE_CUDA_CHECK(cudaMalloc(reinterpret_cast&lt;void**&gt;(&amp;point2grid_gpu_),
-                               pc_gpu_size_ * sizeof(int)));
-#endif
-  }
-
-  virtual ~FeatureGenerator() {
-#if USE_GPU == 1
-    ReleaseGPUMemory();
-#endif
-  }
-
-  bool Init(const FeatureParam&amp; feature_param, base::Blob&lt;float&gt;* out_blob);
-
-  void Generate(const base::PointFCloudPtr&amp; pc_ptr,
-                const std::vector&lt;int&gt;&amp; point2grid) {
-#if USE_GPU == 1
-    GenerateGPU(pc_ptr, point2grid);
-#else
-    GenerateCPU(pc_ptr, point2grid);
-#endif
-  }
-
-  inline std::string Name() const { return "FeatureGenerator"; }
-
- private:
-#if USE_GPU == 1
-  void GenerateGPU(const base::PointFCloudPtr&amp; pc_ptr,
-                   const std::vector&lt;int&gt;&amp; point2grid);
-  void ReleaseGPUMemory();
-#endif
-  void GenerateCPU(const base::PointFCloudPtr&amp; pc_ptr,
-                   const std::vector&lt;int&gt;&amp; point2grid);
-
-  float LogCount(int count) {
-    if (count &lt; static_cast&lt;int&gt;(log_table_.size())) {
-      return log_table_[count];
-    }
-    return logf(static_cast&lt;float&gt;(1 + count));
-  }
-
-  // log table for CPU, with std::vector type
-  std::vector&lt;float&gt; log_table_;
-  // log table for GPU, with base::Blob type
-  std::shared_ptr&lt;base::Blob&lt;float&gt;&gt; log_blob_;
-  const int kMaxLogNum = 256;
-
-  // feature param
-  int width_ = 0;
-  int height_ = 0;
-  float range_ = 0.0f;
-  float min_height_ = 0.0f;
-  float max_height_ = 0.0f;
-  bool use_intensity_feature_ = false;
-  bool use_constant_feature_ = false;
-
-  // raw feature data
-  float* max_height_data_ = nullptr;
-  float* mean_height_data_ = nullptr;
-  float* count_data_ = nullptr;
-  float* direction_data_ = nullptr;
-  float* top_intensity_data_ = nullptr;
-  float* mean_intensity_data_ = nullptr;
-  float* distance_data_ = nullptr;
-  float* nonempty_data_ = nullptr;
-
-  // 1-d index in feature map of each point
-  std::vector&lt;int&gt; map_idx_;
-
-  // output feature blob
-  base::Blob&lt;float&gt;* out_blob_ = nullptr;
-
-  // param for managing gpu memory, only for cuda code
-  base::PointF* pc_gpu_ = nullptr;
-  int* point2grid_gpu_ = nullptr;
-  int pc_gpu_size_ = 0;
-  const int kMaxPointCloudGPUSize = 120000;
-  const int kGPUThreadSize = 512;
-
-  // for TEST only
-  FRIEND_TEST(FeatureGeneratorTest, basic_test);
-  friend class FeatureGeneratorTest;
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\feature_generator_test.cc" new_path="" added_lines="0" deleted_lines="222">
				<diff>@@ -1,222 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/cnnseg/feature_generator.h"
-
-#include "opencv2/opencv.hpp"
-
-#include "modules/perception/common/perception_gflags.h"
-#include "modules/perception/lidar/common/pcl_util.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/util.h"
-
-namespace apollo {
-namespace perception {
-namespace lib {
-DECLARE_string(work_root);
-}
-
-namespace lidar {
-
-class FeatureGeneratorTest : public ::testing::Test {
- public:
-  virtual void SetUp() {}
-
-  void MapPointToGrid(const base::PointFCloudPtr&amp; pc_ptr,
-                      std::vector&lt;int&gt;* point2grid, float range, size_t width,
-                      size_t height, float min_height, float max_height) {
-    float inv_res_x = 0.5 * static_cast&lt;float&gt;(width) / range;
-    float inv_res_y = 0.5 * static_cast&lt;float&gt;(height) / range;
-    point2grid-&gt;assign(pc_ptr-&gt;size(), -1);
-    for (size_t i = 0; i &lt; pc_ptr-&gt;size(); ++i) {
-      const auto&amp; pt = pc_ptr-&gt;at(i);
-      if (pt.z &lt;= min_height || pt.z &gt;= max_height) {
-        continue;
-      }
-      // the coordinates of x and y are exchanged here
-      // (row &lt;-&gt; x, column &lt;-&gt; y)
-      int pos_x = F2I(pt.y, range, inv_res_x);  // col
-      int pos_y = F2I(pt.x, range, inv_res_y);  // row
-      if (pos_y &lt; 0 || pos_y &gt;= static_cast&lt;int&gt;(height) || pos_x &lt; 0 ||
-          pos_x &gt;= static_cast&lt;int&gt;(width)) {
-        continue;
-      }
-      point2grid-&gt;at(i) = pos_y * width + pos_x;
-    }
-  }
-
-  void InitCPUBlobs(bool use_intensity_feature) {
-    base::Blob&lt;float&gt;* out_blob = generator_-&gt;out_blob_;
-    float* out_blob_data = nullptr;
-    out_blob_data = out_blob-&gt;mutable_cpu_data();
-
-    // set raw feature data
-    int channel_index = 0;
-    generator_-&gt;max_height_data_ =
-        out_blob_data + out_blob-&gt;offset(0, channel_index++);
-    generator_-&gt;mean_height_data_ =
-        out_blob_data + out_blob-&gt;offset(0, channel_index++);
-    generator_-&gt;count_data_ =
-        out_blob_data + out_blob-&gt;offset(0, channel_index++);
-    generator_-&gt;direction_data_ =
-        out_blob_data + out_blob-&gt;offset(0, channel_index++);
-    if (use_intensity_feature) {
-      generator_-&gt;top_intensity_data_ =
-          out_blob_data + out_blob-&gt;offset(0, channel_index++);
-      generator_-&gt;mean_intensity_data_ =
-          out_blob_data + out_blob-&gt;offset(0, channel_index++);
-    }
-    generator_-&gt;distance_data_ =
-        out_blob_data + out_blob-&gt;offset(0, channel_index++);
-    generator_-&gt;nonempty_data_ =
-        out_blob_data + out_blob-&gt;offset(0, channel_index++);
-    CHECK_EQ(out_blob-&gt;offset(0, channel_index), out_blob-&gt;count());
-
-    // compute direction and distance features
-    int map_size = generator_-&gt;height_ * generator_-&gt;width_;
-    std::vector&lt;float&gt; direction_data(map_size);
-    std::vector&lt;float&gt; distance_data(map_size);
-    for (int row = 0; row &lt; generator_-&gt;height_; ++row) {
-      for (int col = 0; col &lt; generator_-&gt;width_; ++col) {
-        int idx = row * generator_-&gt;width_ + col;
-        // * row &lt;-&gt; x, column &lt;-&gt; y
-        float center_x = Pixel2Pc(row, generator_-&gt;height_, generator_-&gt;range_);
-        float center_y = Pixel2Pc(col, generator_-&gt;width_, generator_-&gt;range_);
-        direction_data[idx] =
-            static_cast&lt;float&gt;(std::atan2(center_y, center_x) / (2.0 * kPI));
-        distance_data[idx] =
-            static_cast&lt;float&gt;(std::hypot(center_x, center_y) / 60.0 - 0.5);
-      }
-    }
-
-    // memory copy direction and distance features
-    memcpy(generator_-&gt;direction_data_, direction_data.data(),
-           direction_data.size() * sizeof(float));
-    memcpy(generator_-&gt;distance_data_, distance_data.data(),
-           distance_data.size() * sizeof(float));
-  }
-
- protected:
-  std::unique_ptr&lt;FeatureGenerator&gt; generator_;
-};
-
-TEST_F(FeatureGeneratorTest, basic_test) {
-  char cyber_path[100] = "CYBER_PATH=";
-  putenv(cyber_path);
-  char module_path[100] = "MODULE_PATH=";
-  putenv(module_path);
-  FLAGS_work_root =
-      "/apollo/modules/perception/testdata/"
-      "lidar/lib/segmentation/cnnseg/";
-
-  // load pcd data
-  base::PointFCloudPtr pc_ptr;
-  pc_ptr.reset(new base::PointFCloud);
-  std::string filename =
-      "/apollo/modules/perception/testdata/lidar/lib/segmentation/cnnseg/"
-      "pcd_data/3_car_1_person.pcd";
-  bool ret = LoadPCLPCD(filename, pc_ptr.get());
-  ACHECK(ret) &lt;&lt; "Failed to load " &lt;&lt; filename;
-
-  std::vector&lt;int&gt; point2grid;
-  float range = 60.f;
-  size_t width = 640;
-  size_t height = 640;
-  float min_height = -5.f;
-  float max_height = 5.f;
-  MapPointToGrid(pc_ptr, &amp;point2grid, range, width, height, min_height,
-                 max_height);
-
-  FeatureParam param;
-  param.set_point_cloud_range(range);
-  param.set_width(width);
-  param.set_height(height);
-  param.set_min_height(min_height);
-  param.set_max_height(max_height);
-  param.set_use_intensity_feature(true);
-
-  // cpu generator test
-  {
-    generator_.reset(new FeatureGenerator);
-    base::Blob&lt;float&gt; feature_blob;
-    feature_blob.Reshape(1, 8, param.height(), param.width());
-    EXPECT_TRUE(generator_-&gt;Init(param, &amp;feature_blob));
-    InitCPUBlobs(true);
-    generator_-&gt;GenerateCPU(pc_ptr, point2grid);
-    EXPECT_NE(generator_-&gt;mean_intensity_data_, nullptr);
-    EXPECT_NE(generator_-&gt;top_intensity_data_, nullptr);
-    // save feature map
-    std::ofstream ofs("cpu_top_intensity_map.txt");
-    ACHECK(ofs.is_open());
-    for (size_t i = 0; i &lt; param.height() * param.width(); ++i) {
-      ofs &lt;&lt; generator_-&gt;top_intensity_data_[i] &lt;&lt; std::endl;
-    }
-    ofs.close();
-    cv::Mat image(param.height(), param.width(), CV_32FC1,
-                  generator_-&gt;top_intensity_data_);
-    image.convertTo(image, CV_32FC3, 255.0);
-    cv::imwrite("cpu_top_intensity_map.jpg", image);
-  }
-  {
-    generator_.reset(new FeatureGenerator);
-    base::Blob&lt;float&gt; feature_blob;
-    param.set_use_intensity_feature(false);
-    feature_blob.Reshape(1, 6, param.height(), param.width());
-    EXPECT_TRUE(generator_-&gt;Init(param, &amp;feature_blob));
-    InitCPUBlobs(false);
-    generator_-&gt;GenerateCPU(pc_ptr, point2grid);
-    EXPECT_EQ(generator_-&gt;mean_intensity_data_, nullptr);
-    EXPECT_EQ(generator_-&gt;top_intensity_data_, nullptr);
-  }
-  // gpu generator test
-  {
-    generator_.reset(new FeatureGenerator);
-    base::Blob&lt;float&gt; feature_blob;
-    param.set_use_intensity_feature(true);
-    feature_blob.Reshape(1, 8, param.height(), param.width());
-    EXPECT_TRUE(generator_-&gt;Init(param, &amp;feature_blob));
-    generator_-&gt;GenerateGPU(pc_ptr, point2grid);
-    EXPECT_NE(generator_-&gt;mean_intensity_data_, nullptr);
-    EXPECT_NE(generator_-&gt;top_intensity_data_, nullptr);
-    // save feature map
-    size_t map_size = param.height() * param.width();
-    std::vector&lt;float&gt; top_intensity_data(map_size);
-    cudaMemcpy(top_intensity_data.data(), generator_-&gt;top_intensity_data_,
-               map_size * sizeof(float), cudaMemcpyDeviceToHost);
-    std::ofstream ofs("gpu_top_intensity_map.txt");
-    ACHECK(ofs.is_open());
-    for (size_t i = 0; i &lt; param.height() * param.width(); ++i) {
-      ofs &lt;&lt; top_intensity_data[i] &lt;&lt; std::endl;
-    }
-    ofs.close();
-    cv::Mat image(param.height(), param.width(), CV_32FC1,
-                  top_intensity_data.data());
-    image.convertTo(image, CV_32FC3, 255.0);
-    cv::imwrite("gpu_top_intensity_map.jpg", image);
-  }
-  {
-    generator_.reset(new FeatureGenerator);
-    base::Blob&lt;float&gt; feature_blob;
-    param.set_use_intensity_feature(false);
-    feature_blob.Reshape(1, 6, param.height(), param.width());
-    EXPECT_TRUE(generator_-&gt;Init(param, &amp;feature_blob));
-    generator_-&gt;GenerateGPU(pc_ptr, point2grid);
-    EXPECT_EQ(generator_-&gt;mean_intensity_data_, nullptr);
-    EXPECT_EQ(generator_-&gt;top_intensity_data_, nullptr);
-  }
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_cluster.h" new_path="" added_lines="0" deleted_lines="136">
				<diff>@@ -1,136 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;algorithm&gt;
-#include &lt;memory&gt;
-#include &lt;numeric&gt;
-#include &lt;vector&gt;
-
-#include "modules/perception/base/point_cloud.h"
-#include "modules/perception/lidar/common/cloud_mask.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-enum class SppClassType {
-  OTHERS = 0,
-  SMALLMOT = 1,
-  BIGMOT = 2,
-  CYCLIST = 3,
-  PEDESTRIAN = 4,
-  CONE = 5,
-  MAX_TYPE = 6,
-};
-
-struct SppPoint {
-  float x = 0.f;
-  float y = 0.f;
-  float z = 0.f;
-  float h = 0.f;
-
-  SppPoint() = default;
-
-  SppPoint(const base::PointF&amp; point, float height) {
-    x = point.x;
-    y = point.y;
-    z = point.z;
-    h = height;
-  }
-};
-
-struct SppCluster {
-  // 3d points and ids
-  std::vector&lt;SppPoint&gt; points;
-  std::vector&lt;uint32_t&gt; point_ids;
-  // 2d pixels
-  std::vector&lt;uint32_t&gt; pixels;
-  // class probabilities and type
-  std::vector&lt;float&gt; class_prob;
-  SppClassType type = SppClassType::OTHERS;
-  float yaw = 0.f;
-  float confidence = 1.f;
-  float top_z = kDefaultTopZ;
-  size_t points_in_roi = 0;
-
-  SppCluster() {
-    points.reserve(kDefaultReserveSize);
-    point_ids.reserve(kDefaultReserveSize);
-    pixels.reserve(kDefaultReserveSize);
-    class_prob.reserve(static_cast&lt;size_t&gt;(SppClassType::MAX_TYPE));
-  }
-
-  inline void AddPointSample(const base::PointF&amp; point, float height,
-                             uint32_t point_id) {
-    points.push_back(SppPoint(point, height));
-    point_ids.push_back(point_id);
-  }
-
-  void SortPoint() {
-    std::vector&lt;int&gt; indices(points.size(), 0);
-    std::iota(indices.begin(), indices.end(), 0);
-    std::sort(indices.begin(), indices.end(),
-              [&amp;](const int lhs, const int rhs) {
-                return points[lhs].z &lt; points[rhs].z;
-              });
-    std::vector&lt;SppPoint&gt; points_target(points.size());
-    std::vector&lt;uint32_t&gt; point_ids_target(points.size());
-    for (size_t i = 0; i &lt; points.size(); ++i) {
-      points_target[i] = points[indices[i]];
-      point_ids_target[i] = point_ids[indices[i]];
-    }
-    points.swap(points_target);
-    point_ids.swap(point_ids_target);
-  }
-
-  inline void clear() {
-    points.clear();
-    point_ids.clear();
-    pixels.clear();
-    class_prob.clear();
-    type = SppClassType::OTHERS;
-    yaw = 0.f;
-    confidence = 1.f;
-    top_z = kDefaultTopZ;
-    points_in_roi = 0;
-  }
-
-  inline void RemovePoints(const CloudMask&amp; mask) {
-    size_t valid = 0;
-    for (size_t i = 0; i &lt; point_ids.size(); ++i) {
-      if (mask[point_ids[i]]) {
-        if (valid != i) {
-          point_ids[valid] = point_ids[i];
-          points[valid] = points[i];
-        }
-        ++valid;
-      }
-    }
-    points.resize(valid);
-    point_ids.resize(valid);
-  }
-
-  static const size_t kDefaultReserveSize = 1000;
-  static constexpr float kDefaultTopZ = 50.f;
-};
-
-typedef std::shared_ptr&lt;SppCluster&gt; SppClusterPtr;
-typedef std::shared_ptr&lt;const SppCluster&gt; SppClusterConstPtr;
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_cluster_list.cc" new_path="" added_lines="0" deleted_lines="136">
				<diff>@@ -1,136 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_cluster_list.h"
-
-#include "modules/perception/lidar/common/lidar_log.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_pool_types.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-void SppClusterList::Init(size_t size, const std::string&amp; sensor_name) {
-  sensor_name_ = sensor_name;
-  clusters_.clear();
-  SppClusterPool::Instance(sensor_name_).BatchGet(size, &amp;clusters_);
-}
-
-void SppClusterList::resize(size_t size) {
-  if (clusters_.size() &lt; size) {
-    SppClusterPool::Instance(sensor_name_)
-        .BatchGet(size - clusters_.size(), &amp;clusters_);
-  } else {
-    clusters_.resize(size);
-  }
-}
-
-void SppClusterList::AddPointSample(size_t cluster_id,
-                                    const base::PointF&amp; point, float height,
-                                    uint32_t point_id) {
-  if (clusters_.size() &lt;= cluster_id) {
-    resize(cluster_id + 1);
-  }
-  clusters_[cluster_id]-&gt;AddPointSample(point, height, point_id);
-}
-
-void SppClusterList::Merge(SppClusterList* rhs) {
-  clusters_.reserve(clusters_.size() + rhs-&gt;clusters_.size());
-  for (size_t i = 0; i &lt; rhs-&gt;size(); ++i) {
-    clusters_.push_back((*rhs)[static_cast&lt;int&gt;(i)]);
-  }
-}
-
-size_t SppClusterList::HeightCut(float max_gap, size_t start_id) {
-  size_t size = clusters_.size();
-  size_t count = 0;
-  for (size_t i = start_id; i &lt; size; ++i) {
-    if (clusters_[i]-&gt;points.size() &gt; 0) {
-      if (ComputeHeightAndSplitCluster(i, max_gap)) {
-        ++count;
-      }
-    }
-  }
-  AINFO &lt;&lt; "Split " &lt;&lt; count &lt;&lt; " clusters in 3d";
-  return count;
-}
-
-bool SppClusterList::ComputeHeightAndSplitCluster(size_t id, float max_gap) {
-  if (id &gt;= clusters_.size()) {
-    return false;
-  }
-
-  clusters_[id]-&gt;SortPoint();
-  std::vector&lt;SppPoint&gt;&amp; points = clusters_[id]-&gt;points;
-  std::vector&lt;uint32_t&gt;&amp; indices = clusters_[id]-&gt;point_ids;
-
-  float gap = 0.f;
-  std::vector&lt;size_t&gt; split_indices(1, 0);
-  for (size_t i = 1; i &lt; points.size(); ++i) {
-    if (points[i].h &lt; 0) {
-      continue;
-    }
-    gap = points[i].z - points[i - 1].z;
-    if (gap &gt; max_gap) {
-      split_indices.push_back(i);
-    }
-  }
-  size_t split_num = split_indices.size();
-  if (split_num &gt; 0) {
-    size_t max_index = split_indices.size() - 1;
-    size_t length = points.size() - split_indices.back();
-    size_t max_length = length;
-    for (size_t i = 1; i &lt; split_indices.size(); ++i) {
-      length = split_indices[i] - split_indices[i - 1];
-      if (length &gt; max_length) {
-        max_length = length;
-        max_index = i - 1;
-      }
-    }
-    // the highest split is not stable
-    if (max_index != split_indices.size() - 1) {
-      size_t split_index = split_indices[max_index + 1];
-      points.resize(split_index);
-      indices.resize(split_index);
-      return true;
-    }
-  }
-  return false;
-}
-
-void SppClusterList::RemoveEmptyClusters() {
-  size_t current = 0;
-  for (size_t i = 0; i &lt; clusters_.size(); ++i) {
-    if (clusters_[i]-&gt;points.size() &gt; 0) {
-      if (current != i) {
-        clusters_[current] = clusters_[i];
-      }
-      ++current;
-    }
-  }
-  clusters_.resize(current);
-}
-
-void SppClusterList::EraseCluster(size_t id) {
-  if (clusters_.size() &lt;= id) {
-    return;
-  }
-  clusters_[id] = clusters_.back();
-  clusters_.resize(clusters_.size() - 1);
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_cluster_list.h" new_path="" added_lines="0" deleted_lines="99">
				<diff>@@ -1,99 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#include "cyber/common/macros.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_cluster.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_label_image.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class SppClusterList {
- public:
-  SppClusterList() { clusters_.reserve(kDefaultReserveSize); }
-  // @brief: initialize cluster list
-  // @param [in]: size
-  // @param [in]: sensor_name
-  void Init(size_t size, const std::string&amp; sensor_name = "velodyne64");
-  // @brief: reset cluster list
-  inline void Reset() { clusters_.clear(); }
-  // @brief: resize cluster list
-  // @param [in]: size
-  void resize(size_t size);
-  // @brief: add an 3d point sample
-  // @param [in]: cluster id
-  // @param [in]: 3d point
-  // @param [in]: point height above ground
-  // @param [in]: point id
-  void AddPointSample(size_t cluster_id, const base::PointF&amp; point,
-                      float height, uint32_t point_id);
-  // @brief: get clusters data
-  // @return: clusters
-  inline std::vector&lt;SppClusterPtr&gt;&amp; clusters() { return clusters_; }
-  // @brief: get clusters data, const version
-  // @return: clusters
-  inline const std::vector&lt;SppClusterPtr&gt;&amp; clusters() const {
-    return clusters_;
-  }
-  // @brief: get clusters size
-  // @return: cluster size
-  inline size_t size() const { return clusters_.size(); }
-  // @brief: get cluster pointer
-  // @return: cluster pointer
-  inline SppClusterPtr&amp; operator[](int id) { return clusters_[id]; }
-  // @brief: get cluster pointer, const version
-  // @return: cluster pointer
-  inline const SppClusterPtr&amp; operator[](int id) const { return clusters_[id]; }
-  // @brief: merge elements from another cluster list and clear it
-  // @param [in]: another cluster list
-  void Merge(SppClusterList* rhs);
-  // @brief: cut along height axis to split cluster
-  // @param [in]: max gap value in two connected component
-  // @param [in]: start cluster id
-  // @return: cut number in all clusters
-  size_t HeightCut(float max_gap, size_t start_id = 0);
-  // @brief: compute height and split clusters
-  // @param [in]: cluster id
-  // @param [in]: max gap value in two connected component
-  // @return: true if successfully split
-  bool ComputeHeightAndSplitCluster(size_t id, float max_gap);
-  // @brief: remove empty cluster from clusters
-  void RemoveEmptyClusters();
-  // @brief: remove cluster given id
-  void EraseCluster(size_t id);
-  // @brief: assign clusters from label image
-  SppClusterList&amp; operator=(const SppLabelImage&amp; rhs) {
-    clusters_ = rhs.GetClusters();
-    return *this;
-  }
-
- private:
-  static const size_t kDefaultReserveSize = 500;
-
- private:
-  std::vector&lt;SppClusterPtr&gt; clusters_;
-  std::string sensor_name_;
-  DISALLOW_COPY_AND_ASSIGN(SppClusterList);
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_cluster_list_test.cc" new_path="" added_lines="0" deleted_lines="182">
				<diff>@@ -1,182 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_cluster_list.h"
-
-#include "gtest/gtest.h"
-
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_label_image.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-TEST(SppClusterTest, spp_cluster_test) {
-  SppLabelImage image;
-  SppLabelImage&amp; const_image = image;
-  image.Init(5, 5);
-  EXPECT_EQ(image.width_, 5);
-  EXPECT_EQ(image.height_, 5);
-  /* test labels
-   * 0 0 0 0 3
-   * 0 1 0 3 3
-   * 0 1 0 0 0
-   * 0 1 0 2 0
-   * 0 0 0 2 0
-   * */
-  image.AddPixelSample(0, 1, 1);
-  image.AddPixelSample(0, 1, 2);
-  image.AddPixelSample(0, 1, 3);
-
-  image.AddPixelSample(1, 3, 3);
-  image.AddPixelSample(1, 3, 4);
-
-  image.AddPixelSample(2, 4, 0);
-  image.AddPixelSample(2, 4, 1);
-  image.AddPixelSample(2, 3, 1);
-
-  image.ProjectClusterToSppLabelImage();
-  EXPECT_EQ(image.GetClusterNum(), 3);
-  EXPECT_EQ(image.GetClusters().size(), 3);
-  EXPECT_EQ(const_image.GetClusters().size(), 3);
-  EXPECT_EQ(image.GetCluster(0)-&gt;pixels.size(), 3);
-  EXPECT_EQ(image.GetCluster(1)-&gt;pixels.size(), 2);
-  EXPECT_EQ(image.GetCluster(2)-&gt;pixels.size(), 3);
-  EXPECT_EQ(const_image.GetCluster(2)-&gt;pixels.size(), 3);
-  image.CollectClusterFromSppLabelImage();
-  EXPECT_EQ(image[1][1], 1);
-  EXPECT_EQ(const_image[1][1], 1);
-  EXPECT_NE(image.GetSppLabelImage(), nullptr);
-  EXPECT_NE(const_image.GetSppLabelImage(), nullptr);
-
-  float confidence_map[] = {0.1f, 0.1f, 0.1f, 0.1f, 0.3f, 0.1f, 0.6f,
-                            0.1f, 0.3f, 0.3f, 0.1f, 0.6f, 0.1f, 0.1f,
-                            0.1f, 0.1f, 0.6f, 0.1f, 0.2f, 0.1f, 0.1f,
-                            0.1f, 0.1f, 0.2f, 0.1f};
-
-  image.FilterClusters(confidence_map, 0.5f);
-  EXPECT_EQ(image.GetClusterNum(), 1);
-
-  float class_map[] = {
-      0.1f, 0.1f, 0.1f, 0.1f, 0.3f, 0.1f, 0.2f, 0.1f, 0.3f, 0.3f,
-      0.1f, 0.3f, 0.1f, 0.1f, 0.1f, 0.1f, 0.4f, 0.1f, 0.2f, 0.1f,
-      0.1f, 0.1f, 0.1f, 0.2f, 0.1f, 0.1f, 0.1f, 0.1f, 0.1f, 0.3f,
-      0.1f, 0.8f, 0.1f, 0.3f, 0.3f, 0.1f, 0.7f, 0.1f, 0.1f, 0.1f,
-      0.1f, 0.6f, 0.1f, 0.2f, 0.1f, 0.1f, 0.1f, 0.1f, 0.2f, 0.1f,
-  };
-  image.CalculateClusterClass(class_map, 2);
-  EXPECT_EQ(static_cast&lt;size_t&gt;(image.GetCluster(0)-&gt;type), 1);
-
-  float heading_map[] = {
-      0.1f, 0.1f, 0.1f, 0.1f, 0.3f, 0.1f, 1.0f, 0.1f, 0.3f, 0.3f,
-      0.1f, 1.0f, 0.1f, 0.1f, 0.1f, 0.1f, 1.0f, 0.1f, 0.2f, 0.1f,
-      0.1f, 0.1f, 0.1f, 0.2f, 0.1f, 0.1f, 0.1f, 0.1f, 0.1f, 0.3f,
-      0.1f, 0.0f, 0.1f, 0.3f, 0.3f, 0.1f, 0.0f, 0.1f, 0.1f, 0.1f,
-      0.1f, 0.0f, 0.1f, 0.2f, 0.1f, 0.1f, 0.1f, 0.1f, 0.2f, 0.1f,
-  };
-  image.CalculateClusterHeading(heading_map);
-  EXPECT_NEAR(image.GetCluster(0)-&gt;yaw, 0.f, 1e-9);
-
-  float top_z_map[] = {0.1f, 0.1f, 0.1f, 0.1f, 0.3f, 0.1f, 0.5f, 0.1f, 0.3f,
-                       0.3f, 0.1f, 0.6f, 0.1f, 0.1f, 0.1f, 0.1f, 0.7f, 0.1f,
-                       0.2f, 0.1f, 0.1f, 0.1f, 0.1f, 0.2f, 0.1f};
-
-  image.CalculateClusterTopZ(top_z_map);
-  EXPECT_NEAR(image.GetCluster(0)-&gt;top_z, 0.6f, 1e-4);
-
-  SppClusterList list;
-  const SppClusterList&amp; const_list = list;
-  list.Init(10);
-  EXPECT_EQ(list.size(), 10);
-  EXPECT_EQ(const_list.size(), 10);
-  EXPECT_EQ(list.clusters().size(), 10);
-  EXPECT_EQ(const_list.clusters().size(), 10);
-  list.resize(5);
-  EXPECT_EQ(list.size(), 5);
-  list.Reset();
-  EXPECT_EQ(list.size(), 0);
-  base::PointF point;
-  list.AddPointSample(0, point, 0.5f, 0);
-  list.AddPointSample(1, point, 0.5f, 1);
-  list.AddPointSample(2, point, 0.5f, 2);
-  list.AddPointSample(0, point, 0.5f, 3);
-  EXPECT_EQ(list.size(), 3);
-  EXPECT_EQ(list[0]-&gt;points.size(), 2);
-  EXPECT_EQ(list[1]-&gt;points.size(), 1);
-  EXPECT_EQ(list[2]-&gt;points.size(), 1);
-  EXPECT_EQ(const_list[0]-&gt;points.size(), 2);
-  SppClusterList list2;
-  list2.Init(2);
-  list.Merge(&amp;list2);
-  EXPECT_EQ(list.size(), 5);
-  list.RemoveEmptyClusters();
-  EXPECT_EQ(list.size(), 3);
-  list.EraseCluster(10);
-  EXPECT_EQ(list.size(), 3);
-  list.EraseCluster(0);
-  EXPECT_EQ(list[0]-&gt;points.size(), 1);
-
-  list.Reset();
-  list.resize(1);
-  point.x = 0.f;
-  point.y = 0.f;
-  point.z = -0.1f;
-  list.AddPointSample(0, point, point.z, 0);
-  point.z = 0.1f;
-  list.AddPointSample(0, point, point.z, 1);
-  point.z = 0.2f;
-  list.AddPointSample(0, point, point.z, 2);
-  point.z = 0.3f;
-  list.AddPointSample(0, point, point.z, 3);
-  point.z = 0.4f;
-  list.AddPointSample(0, point, point.z, 4);
-  point.z = 1.0f;
-  list.AddPointSample(0, point, point.z, 5);
-  point.z = 1.1f;
-  list.AddPointSample(0, point, point.z, 6);
-
-  EXPECT_EQ(list.HeightCut(0.5, 0), 1);
-  EXPECT_EQ(list[0]-&gt;points.size(), 5);
-
-  list.Reset();
-  list.resize(1);
-  point.x = 0.f;
-  point.y = 0.f;
-  point.z = 0.1f;
-  list.AddPointSample(0, point, point.z, 0);
-  point.z = 0.1f;
-  list.AddPointSample(0, point, point.z, 1);
-  point.z = 0.9f;
-  list.AddPointSample(0, point, point.z, 2);
-  point.z = 0.9f;
-  list.AddPointSample(0, point, point.z, 3);
-  point.z = 1.8f;
-  list.AddPointSample(0, point, point.z, 4);
-  point.z = 1.8f;
-  list.AddPointSample(0, point, point.z, 5);
-  point.z = 1.9f;
-  list.AddPointSample(0, point, point.z, 6);
-
-  EXPECT_EQ(list.HeightCut(0.5, 0), 0);
-  EXPECT_EQ(list[0]-&gt;points.size(), 7);
-  EXPECT_EQ(list[0]-&gt;points.size(), list[0]-&gt;point_ids.size());
-
-  list = image;
-  EXPECT_EQ(list.size(), 1);
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_engine.cc" new_path="" added_lines="0" deleted_lines="150">
				<diff>@@ -1,150 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_engine.h"
-#include "modules/perception/base/object_pool_types.h"
-#include "modules/perception/lidar/common/lidar_log.h"
-#include "modules/perception/lidar/common/lidar_timer.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-void SppEngine::Init(size_t width, size_t height, float range,
-                     const SppParams&amp; param, const std::string&amp; sensor_name) {
-  // initialize connect component detector
-  detector_2d_cc_.Init(static_cast&lt;int&gt;(height), static_cast&lt;int&gt;(width));
-  detector_2d_cc_.SetData(data_.obs_prob_data_ref, data_.offset_data,
-                          static_cast&lt;float&gt;(height) / (2.f * range),
-                          data_.objectness_threshold);
-  // initialize label image
-  labels_2d_.Init(width, height, sensor_name);
-  labels_2d_.InitRangeMask(range, param.confidence_range);
-  // set parameters of dynamic map
-  params_ = param;
-
-  // initialize feature size
-  width_ = width;
-  height_ = height;
-  range_ = range;
-  // bind worker
-  worker_.Bind([&amp;]() {
-    data_.confidence_pt_blob-&gt;cpu_data();
-    data_.classify_pt_blob-&gt;cpu_data();
-    data_.heading_pt_blob-&gt;cpu_data();
-    data_.height_pt_blob-&gt;cpu_data();
-    return true;
-  });
-  worker_.Start();
-}
-
-size_t SppEngine::ProcessConnectedComponentCluster(
-    const base::PointFCloudConstPtr point_cloud, const CloudMask&amp; mask) {
-  Timer timer;
-  data_.category_pt_blob-&gt;cpu_data();
-  data_.instance_pt_blob-&gt;cpu_data();
-  double sync_time1 = timer.toc(true);
-  worker_.WakeUp();
-  size_t num = detector_2d_cc_.Detect(&amp;labels_2d_);
-  if (num == 0) {
-    ADEBUG &lt;&lt; "No object detected";
-    // Later will decide if return this function here
-  }
-  double detect_time = timer.toc(true);
-  worker_.Join();
-  double sync_time2 = timer.toc(true);
-  // labels_2d_.FilterClusters(data.confidence_data,
-  //    data.confidence_threshold);
-  // 2018.6.21 filter use category data to reserve long range objects
-  // should be reverted after retrain model
-  labels_2d_.FilterClusters(data_.confidence_data, data_.obs_prob_data_ref[0],
-                            data_.confidence_threshold,
-                            data_.objectness_threshold);
-  double filter_time = timer.toc(true);
-  if (data_.class_prob_data != nullptr) {
-    labels_2d_.CalculateClusterClass(data_.class_prob_data, data_.class_num);
-  }
-  if (data_.heading_data != nullptr) {
-    labels_2d_.CalculateClusterHeading(data_.heading_data);
-  }
-  if (data_.z_data != nullptr) {
-    labels_2d_.CalculateClusterTopZ(data_.z_data);
-  }
-  double chz_time = timer.toc(true);
-  // 2. process 2d to 3d
-  // first sync between cluster list and label image,
-  // and they shared the same cluster pointer
-  clusters_ = labels_2d_;
-  for (size_t i = 0; i &lt; point_cloud-&gt;size(); ++i) {
-    if (mask.size() &amp;&amp; mask[static_cast&lt;int&gt;(i)] == 0) {
-      continue;
-    }
-    // out of range
-    const int id = data_.grid_indices[i];
-    if (id &lt; 0) {
-      continue;
-    }
-    const auto&amp; point = point_cloud-&gt;at(i);
-    const uint16_t&amp; label = labels_2d_[0][id];
-    if (!label) {
-      continue;
-    }
-    if (point.z &lt;=
-        labels_2d_.GetCluster(label - 1)-&gt;top_z + data_.top_z_threshold) {
-      clusters_.AddPointSample(label - 1, point, point_cloud-&gt;points_height(i),
-                               static_cast&lt;uint32_t&gt;(i));
-    }
-  }
-  double mapping_time = timer.toc(true);
-  // 5. remove empty clusters
-  clusters_.RemoveEmptyClusters();
-  double remove_time = timer.toc(true);
-
-  AINFO &lt;&lt; "SegForeground: sync1 " &lt;&lt; sync_time1 &lt;&lt; "\tdetect: " &lt;&lt; detect_time
-        &lt;&lt; "\tsync2: " &lt;&lt; sync_time2 &lt;&lt; "\tfilter: " &lt;&lt; filter_time
-        &lt;&lt; "\tchz: " &lt;&lt; chz_time &lt;&lt; "\tmapping: " &lt;&lt; mapping_time
-        &lt;&lt; "\tremove: " &lt;&lt; remove_time;
-
-  return clusters_.size();
-}
-
-size_t SppEngine::ProcessForegroundSegmentation(
-    const base::PointFCloudConstPtr point_cloud) {
-  mask_.clear();
-  ProcessConnectedComponentCluster(point_cloud, mask_);
-  AINFO &lt;&lt; "Foreground: " &lt;&lt; clusters_.size() &lt;&lt; " clusters";
-  return clusters_.size();
-}
-
-size_t SppEngine::RemoveGroundPointsInForegroundCluster(
-    const base::PointFCloudConstPtr full_point_cloud,
-    const base::PointIndices&amp; roi_indices,
-    const base::PointIndices&amp; roi_non_ground_indices) {
-  mask_.Set(full_point_cloud-&gt;size(), 0);
-  mask_.AddIndices(roi_indices);
-  mask_.RemoveIndicesOfIndices(roi_indices, roi_non_ground_indices);
-  mask_.Flip();
-  // at this time, all ground points has mask value 0
-  for (size_t i = 0; i &lt; clusters_.size(); ++i) {
-    clusters_[static_cast&lt;int&gt;(i)]-&gt;RemovePoints(mask_);
-  }
-  clusters_.RemoveEmptyClusters();
-  return clusters_.size();
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_engine.h" new_path="" added_lines="0" deleted_lines="100">
				<diff>@@ -1,100 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;string&gt;
-
-#include "Eigen/Dense"
-
-#include "modules/perception/lib/thread/thread_worker.h"
-#include "modules/perception/lidar/common/cloud_mask.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_cluster.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_cluster_list.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_seg_cc_2d.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_struct.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class SppEngine {
- public:
-  SppEngine() = default;
-  ~SppEngine() = default;
-  // @brief: initialize spp engine
-  // @param [in]: feature map width
-  // @param [in]: feature map height
-  // @param [in]: feature map range
-  // @param [in]: sensor name
-  void Init(size_t width, size_t height, float range,
-            const SppParams&amp; param = SppParams(),
-            const std::string&amp; sensor_name = "velodyne64");
-  // @brief: process foreground segmentation
-  // @param [in]: point cloud
-  // @return: size of foreground clusters
-  size_t ProcessForegroundSegmentation(
-      const base::PointFCloudConstPtr point_cloud);
-  // @brief: remove ground points in foreground cluster
-  // @param [in]: point cloud
-  // @param [in]: roi indices of point cloud
-  // @param [in]: non ground indices in roi of point cloud
-  size_t RemoveGroundPointsInForegroundCluster(
-      const base::PointFCloudConstPtr full_point_cloud,
-      const base::PointIndices&amp; roi_indices,
-      const base::PointIndices&amp; roi_non_ground_indices);
-  // @brief: get cluster list, const version
-  // @return: cluster list
-  inline const SppClusterList&amp; clusters() const { return clusters_; }
-  // @brief: get cluster list, const version
-  // @return: cluster list
-  inline SppClusterList&amp; clusters() { return clusters_; }
-  // @brief: get feature data, need to filled first
-  inline SppData&amp; GetSppData() { return data_; }
-  // @brief: get feature data, need to filled first, const version
-  inline const SppData&amp; GetSppData() const { return data_; }
-
- private:
-  // @brief: process clustering on input feature map
-  // @param [in]: point cloud
-  // @param [in]: point cloud mask
-  size_t ProcessConnectedComponentCluster(
-      const base::PointFCloudConstPtr point_cloud, const CloudMask&amp; mask);
-
- private:
-  // feature size
-  size_t width_ = 0;
-  size_t height_ = 0;
-  float range_ = 0.f;
-  // label image
-  SppLabelImage labels_2d_;
-  // clusters
-  SppClusterList clusters_;
-  // cloud mask
-  CloudMask mask_;
-  CloudMask roi_mask_;
-  // clustering method
-  SppCCDetector detector_2d_cc_;
-  // global parameters
-  SppParams params_;
-  // const spp data pointer
-  SppData data_;
-  // thread worker for sync data
-  lib::ThreadWorker worker_;
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_label_image.cc" new_path="" added_lines="0" deleted_lines="264">
				<diff>@@ -1,264 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_label_image.h"
-
-#include &lt;algorithm&gt;
-#include &lt;utility&gt;
-
-#include "modules/perception/lidar/common/lidar_log.h"
-#include "modules/perception/lidar/common/lidar_timer.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_pool_types.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-void SppLabelImage::Init(size_t width, size_t height,
-                         const std::string&amp; sensor_name) {
-  // simply release the last memory and allocate new one
-  if (labels_) {
-    common::IFree2(&amp;labels_);
-  }
-  width_ = width;
-  height_ = height;
-  sensor_name_ = sensor_name;
-  labels_ = common::IAlloc2&lt;uint16_t&gt;(static_cast&lt;int&gt;(height_),
-                                      static_cast&lt;int&gt;(width_));
-  memset(labels_[0], 0, sizeof(uint16_t) * width_ * height_);
-  clusters_.clear();
-}
-
-void SppLabelImage::InitRangeMask(float range, float boundary_distance) {
-  if (range_mask_) {
-    common::IFree2(&amp;range_mask_);
-  }
-  range_mask_ = common::IAlloc2&lt;char&gt;(static_cast&lt;int&gt;(height_),
-                                      static_cast&lt;int&gt;(width_));
-  memset(range_mask_[0], 0, sizeof(char) * width_ * height_);
-  float meter_per_pixel = range * 2.0f / static_cast&lt;float&gt;(width_);
-  size_t half_width = width_ / 2;
-  size_t half_height = height_ / 2;
-  for (size_t r = 0; r &lt; height_; ++r) {
-    for (size_t c = 0; c &lt; width_; ++c) {
-      float distance = sqrtf(
-          powf((static_cast&lt;float&gt;(r) - static_cast&lt;float&gt;(half_height)), 2.f) +
-          powf((static_cast&lt;float&gt;(c) - static_cast&lt;float&gt;(half_width)), 2.f));
-      distance *= meter_per_pixel;
-      if (distance &lt;= boundary_distance) {
-        range_mask_[r][c] = 1;
-      }
-    }
-  }
-}
-
-void SppLabelImage::CollectClusterFromSppLabelImage() {
-  size_t size = width_ * height_;
-  // find max label
-  uint16_t max_label = *(std::max_element(labels_[0], labels_[0] + size));
-  clusters_.clear();
-  SppClusterPool::Instance(sensor_name_).BatchGet(max_label, &amp;clusters_);
-  for (size_t y = 0; y &lt; height_; ++y) {
-    for (size_t x = 0; x &lt; width_; ++x) {
-      uint16_t&amp; label = labels_[y][x];
-      // label 0 is invalid, will be ignored
-      if (label) {
-        clusters_[label - 1]-&gt;pixels.push_back(
-            static_cast&lt;unsigned int&gt;(y * width_ + x));
-      }
-    }
-  }
-}
-
-void SppLabelImage::ProjectClusterToSppLabelImage() {
-  memset(labels_[0], 0, sizeof(uint16_t) * width_ * height_);
-  for (size_t n = 0; n &lt; clusters_.size(); ++n) {
-    auto&amp; cluster = clusters_[n];
-    for (auto&amp; pixel : cluster-&gt;pixels) {
-      labels_[0][pixel] = static_cast&lt;uint16_t&gt;(n + 1);
-    }
-  }
-}
-
-void SppLabelImage::FilterClusters(const float* confidence_map,
-                                   float threshold) {
-  for (auto&amp; cluster : clusters_) {
-    float sum = 0.f;
-    for (auto&amp; pixel : cluster-&gt;pixels) {
-      sum += confidence_map[pixel];
-    }
-    sum = cluster-&gt;pixels.size() &gt; 0
-              ? sum / static_cast&lt;float&gt;(cluster-&gt;pixels.size())
-              : sum;
-    cluster-&gt;confidence = sum;
-  }
-  size_t current = 0;
-  for (size_t n = 0; n &lt; clusters_.size(); ++n) {
-    if (clusters_[n]-&gt;confidence &gt;= threshold) {
-      if (current != n) {
-        clusters_[current] = clusters_[n];
-        for (auto&amp; pixel : clusters_[current]-&gt;pixels) {
-          labels_[0][pixel] = static_cast&lt;uint16_t&gt;(current + 1);
-        }
-      }
-      ++current;
-    } else {
-      for (auto&amp; pixel : clusters_[n]-&gt;pixels) {
-        labels_[0][pixel] = 0;
-      }
-    }
-  }
-  clusters_.resize(current);
-}
-
-void SppLabelImage::FilterClusters(const float* confidence_map,
-                                   const float* category_map,
-                                   float confidence_threshold,
-                                   float category_threshold) {
-  std::vector&lt;bool&gt; is_valid;
-  is_valid.reserve(clusters_.size());
-  for (auto&amp; cluster : clusters_) {
-    char mask = 1;
-    for (auto&amp; pixel : cluster-&gt;pixels) {
-      mask &amp;= range_mask_[0][pixel];
-    }
-    float sum_confidence = 0.f;
-    for (auto&amp; pixel : cluster-&gt;pixels) {
-      sum_confidence += confidence_map[pixel];
-    }
-    sum_confidence =
-        cluster-&gt;pixels.size() &gt; 0
-            ? sum_confidence / static_cast&lt;float&gt;(cluster-&gt;pixels.size())
-            : sum_confidence;
-    cluster-&gt;confidence = sum_confidence;
-    if (mask) {  // in range, use confidence estimation
-      is_valid.push_back(cluster-&gt;confidence &gt;= confidence_threshold);
-    } else {  // out of range, use category estimation
-      float sum_category = 0.f;
-      for (auto&amp; pixel : cluster-&gt;pixels) {
-        sum_category += category_map[pixel];
-      }
-      sum_category =
-          cluster-&gt;pixels.size() &gt; 0
-              ? sum_category / static_cast&lt;float&gt;(cluster-&gt;pixels.size())
-              : sum_category;
-      is_valid.push_back(sum_category &gt;= category_threshold);
-      // category is not stable, here we hack the confidence
-      cluster-&gt;confidence =
-          std::max(sum_confidence, confidence_threshold + 0.01f);
-    }
-  }
-  size_t current = 0;
-  for (size_t n = 0; n &lt; clusters_.size(); ++n) {
-    if (is_valid[n]) {
-      if (current != n) {
-        clusters_[current] = clusters_[n];
-        for (auto&amp; pixel : clusters_[current]-&gt;pixels) {
-          labels_[0][pixel] = static_cast&lt;uint16_t&gt;(current + 1);
-        }
-      }
-      ++current;
-    } else {
-      for (auto&amp; pixel : clusters_[n]-&gt;pixels) {
-        labels_[0][pixel] = 0;
-      }
-    }
-  }
-  clusters_.resize(current);
-}
-
-void SppLabelImage::CalculateClusterClass(const float* class_map,
-                                          size_t class_num) {
-  for (auto&amp; cluster : clusters_) {
-    cluster-&gt;class_prob.assign(class_num, 0.f);
-  }
-  size_t size = width_ * height_;
-  for (size_t c = 0; c &lt; class_num; ++c) {
-    const float* class_map_ptr = class_map + c * size;
-    for (auto&amp; cluster : clusters_) {
-      auto&amp; probs = cluster-&gt;class_prob;
-      for (auto&amp; pixel : cluster-&gt;pixels) {
-        probs[c] += class_map_ptr[pixel];
-      }
-    }
-  }
-  for (auto&amp; cluster : clusters_) {
-    auto&amp; probs = cluster-&gt;class_prob;
-    float sum = std::accumulate(probs.begin(), probs.end(), 0.f);
-    if (sum &gt; 1e-9) {
-      for (auto&amp; value : probs) {
-        value /= sum;
-      }
-    }
-    cluster-&gt;type = static_cast&lt;SppClassType&gt;(std::distance(
-        probs.begin(), std::max_element(probs.begin(), probs.end())));
-  }
-}
-
-void SppLabelImage::CalculateClusterHeading(const float* heading_map) {
-  const float* heading_map_x_ptr = heading_map;
-  const float* heading_map_y_ptr = heading_map + width_ * height_;
-
-  for (size_t n = 0; n &lt; clusters_.size(); ++n) {
-    float heading_x = 0.f, heading_y = 0.f;
-    for (auto pixel : clusters_[n]-&gt;pixels) {
-      heading_x += heading_map_x_ptr[pixel];
-      heading_y += heading_map_y_ptr[pixel];
-    }
-    clusters_[n]-&gt;yaw = std::atan2(heading_y, heading_x) * 0.5f;
-  }
-}
-
-void SppLabelImage::CalculateClusterTopZ(const float* top_z_map) {
-  for (auto&amp; cluster : clusters_) {
-    float sum = 0.f;
-    for (auto&amp; pixel : cluster-&gt;pixels) {
-      sum += top_z_map[pixel];
-    }
-    sum = cluster-&gt;pixels.size() &gt; 0
-              ? sum / static_cast&lt;float&gt;(cluster-&gt;pixels.size())
-              : sum;
-    cluster-&gt;top_z = sum;
-  }
-}
-
-void SppLabelImage::AddPixelSample(size_t id, uint32_t pixel) {
-  if (clusters_.size() &lt;= id) {
-    SppClusterPool::Instance(sensor_name_)
-        .BatchGet(id + 1 - clusters_.size(), &amp;clusters_);
-  }
-  clusters_[id]-&gt;pixels.push_back(pixel);
-}
-
-void SppLabelImage::ResizeClusters(size_t size) {
-  if (size &gt; clusters_.size()) {
-    SppClusterPool::Instance(sensor_name_)
-        .BatchGet(size - clusters_.size(), &amp;clusters_);
-  } else {
-    clusters_.resize(size);
-  }
-}
-
-void SppLabelImage::ResetClusters(size_t size) {
-  size_t reset_pos = std::min(clusters_.size(), size);
-  ResizeClusters(size);
-  for (size_t i = 0; i &lt; reset_pos; ++i) {
-    clusters_[i]-&gt;clear();
-  }
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_label_image.h" new_path="" added_lines="0" deleted_lines="153">
				<diff>@@ -1,153 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;memory&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#include "gtest/gtest_prod.h"
-
-#include "cyber/common/macros.h"
-#include "modules/perception/common/i_lib/core/i_alloc.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_cluster.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class SppLabelImage {
- public:
-  SppLabelImage() { clusters_.reserve(kDefaultReserveSize); }
-  ~SppLabelImage() {
-    if (labels_) {
-      common::IFree2(&amp;labels_);
-    }
-    if (range_mask_) {
-      common::IFree2(&amp;range_mask_);
-    }
-  }
-  // @brief: initialize label image
-  // @param [in]: image width
-  // @param [in]: image height
-  // @param [in]: sensor name
-  void Init(size_t width, size_t height,
-            const std::string&amp; sensor_name = "velodyne64");
-  // @brief: initialize range mask of label image
-  // @param [in]: range
-  // @param [in]: boundary distance for mask
-  void InitRangeMask(float range, float boundary_distance);
-  // @brief: transform clusters to label image
-  void CollectClusterFromSppLabelImage();
-  // @brief: transform label image to clusters
-  void ProjectClusterToSppLabelImage();
-  // @brief: filter clusters, given confidence map
-  // @param [in]: confidence_map of the same size
-  // @param [in]: confidence threshold
-  void FilterClusters(const float* confidence_map, float threshold);
-  // @brief: filter clusters, given confidence and category map
-  // @param [in]: confidence_map of the same size
-  // @param [in]: category_map of the same size
-  // @param [in]: confidence threshold
-  // @param [in]: category threshold
-  void FilterClusters(const float* confidence_map, const float* category_map,
-                      float confidence_threshold, float category_threshold);
-  // @brief: calculate class for each cluster, given class map
-  // @param [in]: class_map of the same size
-  // @param [in]: class number
-  void CalculateClusterClass(const float* class_map, size_t class_num);
-  // @brief: calculate heading (yaw) for each cluster, given heading map
-  // @param [in]: heading_map of the same size
-  void CalculateClusterHeading(const float* heading_map);
-  // @brief: calculate top_z for each cluster, given top_z map
-  // @param [in]: top_z_map of the same size
-  void CalculateClusterTopZ(const float* top_z_map);
-  // @brief: get label image
-  // @return: label image
-  uint16_t** GetSppLabelImage() { return labels_; }
-  // @brief: get label image, const version
-  // @return: const label image
-  const uint16_t* const* GetSppLabelImage() const { return labels_; }
-  // @brief: get clusters
-  // @return: clusters
-  inline std::vector&lt;SppClusterPtr&gt;&amp; GetClusters() { return clusters_; }
-  // @brief: get clusters, const version
-  // @return: const clusters
-  inline const std::vector&lt;SppClusterPtr&gt;&amp; GetClusters() const {
-    return clusters_;
-  }
-  // @brief: get label row pointer
-  // @param [in]: row id
-  // @return: row pointer
-  uint16_t* operator[](size_t id) { return labels_[id]; }
-  // @brief: get label row pointer, const version
-  // @param [in]: row id
-  // @return: row pointer
-  const uint16_t* operator[](size_t id) const { return labels_[id]; }
-  // @brief: get cluster number
-  // @return: cluster number
-  size_t GetClusterNum() const { return clusters_.size(); }
-  // @brief: get cluster given id
-  // @param [in]: cluster id
-  // @return: cluster pointer
-  SppClusterPtr GetCluster(size_t id) { return clusters_[id]; }
-  // @brief: get cluster given id, const version
-  // @param [in]: cluster id
-  // @return: cluster pointer
-  SppClusterConstPtr GetCluster(size_t id) const { return clusters_[id]; }
-  // @brief: add a pixel to labeled cluster
-  // @param [in]: label id
-  // @param [in]: pixel x
-  // @param [in]: pixel y
-  void AddPixelSample(size_t id, uint16_t x, uint16_t y) {
-    return AddPixelSample(id, y * static_cast&lt;uint32_t&gt;(width_) + x);
-  }
-  // @brief: add a pixel to labeled cluster
-  // @param [in]: label id
-  // @param [in]: pixel id
-  void AddPixelSample(size_t id, uint32_t pixel);
-  // @brief: clear clusters
-  inline void ClearClusters() { clusters_.clear(); }
-  // @brief: resize clusters
-  // @param [in]: target cluster size
-  void ResizeClusters(size_t size);
-  // @brief: reset clusters
-  // @param [in]: target cluster size
-  void ResetClusters(size_t size);
-
- private:
-  // note the correspondence between label and cluster id is
-  // label - 1 == cluster id, label zero is reserved for background
-  uint16_t** labels_ = nullptr;
-  size_t width_ = 0;
-  size_t height_ = 0;
-  char** range_mask_ = nullptr;
-  std::vector&lt;SppClusterPtr&gt; clusters_;
-  std::string sensor_name_;
-
- private:
-  static const size_t kDefaultReserveSize = 500;
-
-  FRIEND_TEST(SppClusterTest, spp_cluster_test);
-  DISALLOW_COPY_AND_ASSIGN(SppLabelImage);
-};
-
-typedef std::shared_ptr&lt;SppLabelImage&gt; SppLabelImagePtr;
-typedef std::shared_ptr&lt;const SppLabelImage&gt; SppLabelImageConstPtr;
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_pool_types.cc" new_path="" added_lines="0" deleted_lines="33">
				<diff>@@ -1,33 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_pool_types.h"
-#include "modules/perception/lidar/common/lidar_log.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-// @brief call pool instance once to initialize memory
-__attribute__((constructor)) void SppPoolInitialize() {
-  SppClusterPool::Instance("velodyne16");
-  SppClusterPool::Instance("velodyne64");
-  SppClusterPool::Instance("velodyne128");
-  AINFO &lt;&lt; "Initialize spp cluster pool.";
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_pool_types.h" new_path="" added_lines="0" deleted_lines="39">
				<diff>@@ -1,39 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include "modules/perception/base/light_object_pool.h"
-#include "modules/perception/base/object_pool_types.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_cluster.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-struct SppClusterInitializer {
-  void operator()(SppCluster* cluster) const { cluster-&gt;clear(); }
-};
-
-static const size_t kSppClusterPoolSize = 1000;
-
-typedef base::LightObjectPool&lt;SppCluster, kSppClusterPoolSize,
-                              SppClusterInitializer,
-                              base::SensorType::VELODYNE_64&gt;
-    SppClusterPool;
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_seg_cc_2d.cc" new_path="" added_lines="0" deleted_lines="238">
				<diff>@@ -1,238 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include &lt;algorithm&gt;
-
-#include "modules/perception/lidar/common/lidar_log.h"
-#include "modules/perception/lidar/common/lidar_timer.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_seg_cc_2d.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-void SppCCDetector::SetData(const float* const* prob_map,
-                            const float* offset_map, float scale,
-                            float objectness_threshold) {
-  prob_map_ = prob_map;
-  offset_map_ = offset_map;
-  scale_ = scale;
-  objectness_threshold_ = objectness_threshold;
-  worker_.Bind(std::bind(&amp;SppCCDetector::CleanNodes, this));
-  worker_.Start();
-}
-
-bool SppCCDetector::BuildNodes(int start_row_index, int end_row_index) {
-  const float* offset_row_ptr = offset_map_ + start_row_index * cols_;
-  const float* offset_col_ptr = offset_map_ + (rows_ + start_row_index) * cols_;
-  const float* prob_map_ptr = prob_map_[0] + start_row_index * cols_;
-  Node* node_ptr = nodes_[0] + start_row_index * cols_;
-  for (int row = start_row_index; row &lt; end_row_index; ++row) {
-    for (int col = 0; col &lt; cols_; ++col) {
-      node_ptr-&gt;set_is_object(*prob_map_ptr++ &gt;= objectness_threshold_);
-      int center_row = static_cast&lt;int&gt;(*offset_row_ptr++ * scale_ +
-                                        static_cast&lt;float&gt;(row) + 0.5f);
-      int center_col = static_cast&lt;int&gt;(*offset_col_ptr++ * scale_ +
-                                        static_cast&lt;float&gt;(col) + 0.5f);
-      center_row = std::max(0, std::min(rows_ - 1, center_row));
-      center_col = std::max(0, std::min(cols_ - 1, center_col));
-      (node_ptr++)-&gt;center_node = center_row * cols_ + center_col;
-    }
-  }
-  return true;
-}
-
-bool SppCCDetector::CleanNodes() {
-  memset(nodes_[0], 0, sizeof(Node) * rows_ * cols_);
-  uint32_t node_idx = 0;
-  for (int row = 0; row &lt; rows_; ++row) {
-    for (int col = 0; col &lt; cols_; ++col) {
-      nodes_[row][col].parent = node_idx++;
-    }
-  }
-  return true;
-}
-
-size_t SppCCDetector::Detect(SppLabelImage* labels) {
-  Timer timer;
-  if (!first_process_) {
-    worker_.Join();  // sync for cleaning nodes
-  }
-  first_process_ = false;
-  BuildNodes(0, rows_);
-  double init_time = timer.toc(true);
-
-  double sync_time = timer.toc(true);
-
-  TraverseNodes();
-  double traverse_time = timer.toc(true);
-
-  UnionNodes();
-  double union_time = timer.toc(true);
-
-  size_t num = ToLabelMap(labels);
-  worker_.WakeUp();  // for next use
-  double collect_time = timer.toc(true);
-
-  AINFO &lt;&lt; "SppSegCC2D: init: " &lt;&lt; init_time &lt;&lt; "\tsync: " &lt;&lt; sync_time
-        &lt;&lt; "\ttraverse: " &lt;&lt; traverse_time &lt;&lt; "\tunion: " &lt;&lt; union_time
-        &lt;&lt; "\tcollect: " &lt;&lt; collect_time &lt;&lt; "\t#obj: " &lt;&lt; num;
-
-  return num;
-}
-
-void SppCCDetector::TraverseNodes() {
-  for (int row = 0; row &lt; rows_; row++) {
-    for (int col = 0; col &lt; cols_; col++) {
-      Node&amp; node = nodes_[row][col];
-      if (node.is_object() &amp;&amp; node.get_traversed() == 0) {
-        Traverse(&amp;node);
-      }
-    }
-  }
-}
-
-void SppCCDetector::UnionNodes() {
-  for (int row = 0; row &lt; rows_; ++row) {
-    for (int col = 0; col &lt; cols_; ++col) {
-      Node* node = &amp;nodes_[row][col];
-      if (!node-&gt;is_center()) {
-        continue;
-      }
-      Node* node_neighbor = nullptr;
-      // right
-      if (col &lt; cols_ - 1) {
-        node_neighbor = &amp;nodes_[row][col + 1];
-        if (node_neighbor-&gt;is_center()) {
-          DisjointSetUnion(node, node_neighbor);
-        }
-      }
-      // down
-      if (row &lt; rows_ - 1) {
-        node_neighbor = &amp;nodes_[row + 1][col];
-        if (node_neighbor-&gt;is_center()) {
-          DisjointSetUnion(node, node_neighbor);
-        }
-      }
-      // right down
-      if (row &lt; rows_ - 1 &amp;&amp; col &lt; cols_ - 1) {
-        node_neighbor = &amp;nodes_[row + 1][col + 1];
-        if (node_neighbor-&gt;is_center()) {
-          DisjointSetUnion(node, node_neighbor);
-        }
-      }
-      // left down
-      if (row &lt; rows_ - 1 &amp;&amp; col &gt; 0) {
-        node_neighbor = &amp;nodes_[row + 1][col - 1];
-        if (node_neighbor-&gt;is_center()) {
-          DisjointSetUnion(node, node_neighbor);
-        }
-      }
-    }
-  }
-}
-
-size_t SppCCDetector::ToLabelMap(SppLabelImage* labels) {
-  uint16_t id = 0;
-  uint32_t pixel_id = 0;
-  labels-&gt;ResetClusters(kDefaultReserveSize);
-  for (int row = 0; row &lt; rows_; ++row) {
-    for (int col = 0; col &lt; cols_; ++col, ++pixel_id) {
-      Node* node = &amp;nodes_[row][col];
-      if (!node-&gt;is_object()) {
-        (*labels)[row][col] = 0;
-        continue;
-      }
-      Node* root = DisjointSetFind(node);
-      // note label in label image started from 1,
-      // zero is reserved from non-object
-      if (!root-&gt;id) {
-        root-&gt;id = ++id;
-      }
-      (*labels)[row][col] = root-&gt;id;
-      labels-&gt;AddPixelSample(root-&gt;id - 1, pixel_id);
-    }
-  }
-  labels-&gt;ResizeClusters(id);
-  return id;
-}
-
-void SppCCDetector::Traverse(SppCCDetector::Node* x) {
-  std::vector&lt;SppCCDetector::Node*&gt; p;
-  p.clear();
-  while (x-&gt;get_traversed() == 0) {
-    p.push_back(x);
-    x-&gt;set_traversed(2);
-    x = nodes_[0] + x-&gt;center_node;
-  }
-  if (x-&gt;get_traversed() == 2) {
-    for (int i = static_cast&lt;int&gt;(p.size()) - 1; i &gt;= 0 &amp;&amp; p[i] != x; i--) {
-      p[i]-&gt;set_is_center(true);
-    }
-    x-&gt;set_is_center(true);
-  }
-  for (size_t i = 0; i &lt; p.size(); i++) {
-    Node* y = p[i];
-    y-&gt;set_traversed(1);
-    y-&gt;parent = x-&gt;parent;
-  }
-}
-
-SppCCDetector::Node* SppCCDetector::DisjointSetFindLoop(Node* x) {
-  Node* root = x;
-  while (nodes_[0] + root-&gt;parent != root) {
-    root = nodes_[0] + root-&gt;parent;
-  }
-  Node* w = x;
-  while (nodes_[0] + w-&gt;parent != w) {
-    Node* temp = nodes_[0] + w-&gt;parent;
-    w-&gt;parent = root-&gt;parent;
-    w = temp;
-  }
-  return root;
-}
-
-SppCCDetector::Node* SppCCDetector::DisjointSetFind(Node* x) {
-  Node* y = nodes_[0] + x-&gt;parent;
-  if (y == x || nodes_[0] + y-&gt;parent == y) {
-    return y;
-  }
-  Node* root = DisjointSetFindLoop(nodes_[0] + y-&gt;parent);
-  x-&gt;parent = root-&gt;parent;
-  y-&gt;parent = root-&gt;parent;
-  return root;
-}
-
-void SppCCDetector::DisjointSetUnion(Node* x, Node* y) {
-  x = DisjointSetFind(x);
-  y = DisjointSetFind(y);
-  if (x == y) {
-    return;
-  }
-  uint16_t x_node_rank = x-&gt;get_node_rank();
-  uint16_t y_node_rank = y-&gt;get_node_rank();
-  if (x_node_rank &lt; y_node_rank) {
-    x-&gt;parent = y-&gt;parent;
-  } else if (y_node_rank &lt; x_node_rank) {
-    y-&gt;parent = x-&gt;parent;
-  } else {
-    y-&gt;parent = x-&gt;parent;
-    x-&gt;set_node_rank(static_cast&lt;uint16_t&gt;(x_node_rank + 1));
-  }
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_seg_cc_2d.h" new_path="" added_lines="0" deleted_lines="153">
				<diff>@@ -1,153 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;vector&gt;
-
-#include "modules/perception/common/i_lib/core/i_alloc.h"
-#include "modules/perception/lib/thread/thread_worker.h"
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_label_image.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class SppCCDetector {
- public:
-  SppCCDetector() = default;
-
-  ~SppCCDetector() {
-    if (nodes_ != nullptr) {
-      common::IFree2(&amp;nodes_);
-    }
-  }
-  // @brief: initialize detector
-  // @param [in]: rows of feature map
-  // @param [in]: cols of feature map
-  void Init(int rows, int cols) {
-    if (rows_ * cols_ != rows * cols) {
-      if (nodes_ != nullptr) {
-        common::IFree2(&amp;nodes_);
-      }
-      nodes_ = common::IAlloc2&lt;Node&gt;(rows, cols);
-      rows_ = static_cast&lt;int&gt;(rows);
-      cols_ = static_cast&lt;int&gt;(cols);
-    }
-    CleanNodes();
-  }
-  // @brief: set data for clusterin
-  // @param [in]: probability map
-  // @param [in]: center offset map
-  // @param [in]: scale of offset map
-  // @param [in]: objectness threshold
-  void SetData(const float* const* prob_map, const float* offset_map,
-               float scale, float objectness_threshold);
-  // @brief: detect clusters
-  // @param [out]: label image
-  // @return: label number
-  size_t Detect(SppLabelImage* labels);
-
- private:
-  // @brief: build node matrix given start row index and end row index
-  // @param [in]: start row index, inclusive
-  // @param [in]: end row index, exclusive
-  // @param [out]: state of build nodes
-  bool BuildNodes(int start_row_index, int end_row_index);
-  // @brief: traverse node matrix
-  void TraverseNodes();
-  // @brief: union adjacent nodes
-  void UnionNodes();
-  // @brief: collect clusters to label map
-  size_t ToLabelMap(SppLabelImage* labels);
-  // @brief: clean node matrix
-  bool CleanNodes();
-
- private:
-  struct Node {
-    uint32_t center_node = 0;
-    uint32_t parent = 0;
-    uint16_t id = 0;
-    // Note, we compress node_rank, traversed, is_center and is_object
-    // in one 16bits variable, the arrangemant is as following
-    // |is_center(1bit)|is_object(1bit)|traversed(3bit)|node_rank(11bit)|
-    uint16_t status = 0;
-
-    inline uint16_t get_node_rank() { return status &amp; 2047; }
-    inline void set_node_rank(uint16_t node_rank) {
-      status &amp;= 63488;
-      status |= node_rank;
-    }
-    inline uint16_t get_traversed() {
-      uint16_t pattern = 14336;
-      return static_cast&lt;uint16_t&gt;((status &amp; pattern) &gt;&gt; 11);
-    }
-    inline void set_traversed(uint16_t traversed) {
-      status &amp;= 51199;
-      uint16_t pattern = 7;
-      status |= static_cast&lt;uint16_t&gt;((traversed &amp; pattern) &lt;&lt; 11);
-    }
-    inline bool is_center() { return static_cast&lt;bool&gt;(status &amp; 32768); }
-    inline void set_is_center(bool is_center) {
-      if (is_center) {
-        status |= 32768;
-      } else {
-        status &amp;= 32767;
-      }
-    }
-    inline bool is_object() { return static_cast&lt;bool&gt;(status &amp; 16384); }
-    inline void set_is_object(bool is_object) {
-      if (is_object) {
-        status |= 16384;  // 2^14
-      } else {
-        status &amp;= 49151;  // 65535 - 2^14
-      }
-    }
-  };
-  // @brief: tranverse a node
-  // @param [in]: input node
-  void Traverse(Node* x);
-  // @brief: find root of input node and compress path
-  // @param [in]: input node
-  // @return: root node
-  Node* DisjointSetFindLoop(Node* x);
-  // @brief: find root of input node
-  // @param [in]: input node
-  // @return: root node
-  Node* DisjointSetFind(Node* x);
-  // @brief: union of two sets
-  // @param [in]: input two nodes
-  void DisjointSetUnion(Node* x, Node* y);
-
- private:
-  int rows_ = 0;
-  int cols_ = 0;
-  Node** nodes_ = nullptr;
-
-  const float* const* prob_map_ = nullptr;
-  const float* offset_map_ = nullptr;
-  float scale_ = 0.f;
-  float objectness_threshold_ = 0.f;
-
-  lib::ThreadWorker worker_;
-  bool first_process_ = true;
-
- private:
-  static const size_t kDefaultReserveSize = 500;
-};  // class SppCCDetector
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_struct.cc" new_path="" added_lines="0" deleted_lines="57">
				<diff>@@ -1,57 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/cnnseg/spp_engine/spp_struct.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-void SppData::MakeReference(size_t width, size_t height, float range) {
-  obs_prob_data = category_pt_blob-&gt;mutable_cpu_data();
-  offset_data = instance_pt_blob-&gt;mutable_cpu_data();
-  confidence_data = confidence_pt_blob-&gt;mutable_cpu_data();
-  if (height_pt_blob != nullptr) {
-    z_data = height_pt_blob-&gt;mutable_cpu_data();
-  }
-  if (classify_pt_blob != nullptr) {
-    class_prob_data = classify_pt_blob-&gt;mutable_cpu_data();
-  }
-  if (heading_pt_blob != nullptr) {
-    heading_data = heading_pt_blob-&gt;mutable_cpu_data();
-  }
-
-  if (obs_prob_data_ref == nullptr) {
-    obs_prob_data_ref = new float*[height];
-  }
-  for (size_t i = 0; i &lt; height; ++i) {
-    obs_prob_data_ref[i] = obs_prob_data + i * width;
-  }
-
-  data_width = width;
-  data_height = height;
-  data_range = range;
-  data_size = width * height;
-}
-
-SppData::~SppData() {
-  if (obs_prob_data_ref) {
-    delete[] obs_prob_data_ref;
-  }
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\spp_engine\spp_struct.h" new_path="" added_lines="0" deleted_lines="65">
				<diff>@@ -1,65 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include "modules/perception/base/blob.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-struct SppData {
-  float* obs_prob_data = nullptr;
-  float* offset_data = nullptr;
-  float* confidence_data = nullptr;
-  float* z_data = nullptr;
-  float* class_prob_data = nullptr;
-  float* heading_data = nullptr;
-
-  base::Blob&lt;float&gt;* instance_pt_blob = nullptr;
-  base::Blob&lt;float&gt;* category_pt_blob = nullptr;
-  base::Blob&lt;float&gt;* confidence_pt_blob = nullptr;
-  base::Blob&lt;float&gt;* classify_pt_blob = nullptr;
-  base::Blob&lt;float&gt;* heading_pt_blob = nullptr;
-  base::Blob&lt;float&gt;* height_pt_blob = nullptr;
-
-  float** obs_prob_data_ref = nullptr;
-
-  int* grid_indices = nullptr;
-
-  float objectness_threshold = 0.f;
-  float confidence_threshold = 0.f;
-  float top_z_threshold = 0.f;
-
-  size_t class_num = 0;
-  size_t data_width = 0;
-  size_t data_height = 0;
-  size_t data_size = 0;
-  float data_range = 0.0f;
-
-  void MakeReference(size_t width, size_t height, float range);
-
-  ~SppData();
-};
-
-struct SppParams {
-  float height_gap = 0.5f;
-  float confidence_range = 58.f;
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\cnnseg\util.h" new_path="" added_lines="0" deleted_lines="59">
				<diff>@@ -1,59 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-enum class MetaType {
-  META_UNKNOWN = 0,
-  META_SMALLMOT = 1,
-  META_BIGMOT = 2,
-  META_NONMOT = 3,
-  META_PEDESTRIAN = 4,
-  MAX_META_TYPE
-};
-
-const double kPI = 3.1415926535897932384626433832795;
-
-inline int F2I(float val, float ori, float scale) {
-  return static_cast&lt;int&gt;(std::floor((ori - val) * scale));
-}
-
-// for axis rotated case
-inline void GroupPc2Pixel(float pc_x, float pc_y, float scale, float range,
-                          int* x, int* y) {
-  float fx = (range - (0.707107f * (pc_x + pc_y))) * scale;
-  float fy = (range - (0.707107f * (pc_x - pc_y))) * scale;
-  *x = fx &lt; 0 ? -1 : static_cast&lt;int&gt;(fx);
-  *y = fy &lt; 0 ? -1 : static_cast&lt;int&gt;(fy);
-}
-
-// for axis aligned case
-inline int Pc2Pixel(float in_pc, float in_range, float out_size) {
-  float inv_res = 0.5f * out_size / in_range;
-  return static_cast&lt;int&gt;(std::floor((in_range - in_pc) * inv_res));
-}
-
-inline float Pixel2Pc(int in_pixel, float in_size, float out_range) {
-  float res = 2.0f * out_range / in_size;
-  return out_range - (static_cast&lt;float&gt;(in_pixel) + 0.5f) * res;
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\flood_fill.cc" new_path="" added_lines="0" deleted_lines="157">
				<diff>@@ -1,157 +0,0 @@
-/******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#include "modules/perception/lidar/lib/segmentation/ncut/common/flood_fill.h"
-#include "cyber/common/log.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-namespace {
-const int kNumDirections = 8;
-const int di[kNumDirections] = {+1, 0, -1, 0, +1, +1, -1, -1};
-const int dj[kNumDirections] = {0, +1, 0, -1, +1, -1, +1, -1};
-const int kEmptyGridLabel = -1;
-const int kNonEmptyGridLabel = -2;
-}  // namespace
-
-int FloodFill::Pos(float x, float y) const {
-  const int irow = static_cast&lt;int&gt;((y + _offset_y) / _cell_size);
-  if (!IsValidRowIndex(irow)) {
-    return -1;
-  }
-  const int jcol = static_cast&lt;int&gt;((x + _offset_x) / _cell_size);
-  if (!IsValidColIndex(jcol)) {
-    return -1;
-  }
-  return irow * _grid_num_cols + jcol;
-}
-
-bool FloodFill::Pos2d(float x, float y, int* irow, int* jcol) const {
-  *irow = static_cast&lt;int&gt;((y + _offset_y) / _cell_size);
-  if (!IsValidRowIndex(*irow)) {
-    return false;
-  }
-  *jcol = static_cast&lt;int&gt;((x + _offset_x) / _cell_size);
-  if (!IsValidColIndex(*jcol)) {
-    return false;
-  }
-  return true;
-}
-
-void FloodFill::BuildGrid(base::PointFCloudConstPtr cloud) {
-  CHECK_GT(_grid_radius, 0.0);
-  CHECK_GT(_cell_size, 0.0);
-  // .1 calculate grid size
-  //  max_grid_size = 2.f *_grid_radius /_cell_size;
-  _num_points = static_cast&lt;int&gt;(cloud-&gt;size());
-  const double min_grid_radius = _grid_radius / 10.0;
-  float min_x = static_cast&lt;float&gt;(-min_grid_radius);
-  float min_y = static_cast&lt;float&gt;(-min_grid_radius);
-  float max_x = static_cast&lt;float&gt;(min_grid_radius);
-  float max_y = static_cast&lt;float&gt;(min_grid_radius);
-
-  for (size_t i = 0; i &lt; cloud-&gt;size(); ++i) {
-    auto pt = (*cloud)[i];
-    max_x = std::max(max_x, pt.x);
-    min_x = std::min(min_x, pt.x);
-    max_y = std::max(max_y, pt.y);
-    min_y = std::min(min_y, pt.y);
-  }
-  CHECK_LE(min_x, max_x);
-  CHECK_LE(min_y, max_y);
-  // .2 move origin to the left bottom corner
-  const float lower_x = std::max(min_x, -_grid_radius);
-  const float lower_y = std::max(min_y, -_grid_radius);
-  const float upper_x = std::min(max_x, _grid_radius);
-  const float upper_y = std::min(max_y, _grid_radius);
-  _offset_x = -lower_x;
-  _offset_y = -lower_y;
-  _grid_num_rows = static_cast&lt;int&gt;(ceil((upper_y - lower_y) / _cell_size)) + 1;
-  _grid_num_cols = static_cast&lt;int&gt;(ceil((upper_x - lower_x) / _cell_size)) + 1;
-  CHECK_GT(_grid_num_rows, 0);
-  CHECK_GT(_grid_num_cols, 0);
-  _grid_size = _grid_num_rows * _grid_num_cols;
-  // .3 locate points into grid
-  _point_cloud_grid_idx.assign(_num_points, -1);
-  _label.assign(_grid_size, kEmptyGridLabel);
-  for (int i = 0; i &lt; _num_points; ++i) {
-    const int idx = Pos((*cloud)[i].x, (*cloud)[i].y);
-    if (idx &gt;= 0) {
-      _point_cloud_grid_idx[i] = idx;
-      _label[idx] = kNonEmptyGridLabel;
-    }
-  }
-}
-
-int FloodFill::GetConnectedComponents() {
-  int num_components = 0;
-  for (int idx = 0; idx &lt; _grid_size; ++idx) {
-    auto&amp; label = _label[idx];
-    if (label == kNonEmptyGridLabel) {
-      label = num_components;
-      DfsColoring(idx / _grid_num_cols, idx % _grid_num_cols, num_components);
-      ++num_components;
-    }
-  }
-  return num_components;
-}
-
-void FloodFill::DfsColoring(int i, int j, int curr_component) {
-  // recursively label the neighbors
-  for (int direction = 0; direction &lt; kNumDirections; ++direction) {
-    const int i2 = i + di[direction];
-    const int j2 = j + dj[direction];
-    if (IsValidRowIndex(i2) &amp;&amp; IsValidColIndex(j2)) {
-      auto&amp; label = _label[i2 * _grid_num_cols + j2];
-      if (label == kNonEmptyGridLabel) {
-        label = curr_component;
-        DfsColoring(i2, j2, curr_component);
-      }
-    }
-  }
-}
-
-void FloodFill::GetSegments(base::PointFCloudConstPtr cloud,
-                            std::vector&lt;std::vector&lt;int&gt;&gt;* segments_indices,
-                            std::vector&lt;int&gt;* num_cells_per_segment) {
-  CHECK_NOTNULL(segments_indices);
-  CHECK_NOTNULL(num_cells_per_segment);
-  // .1 build grid
-  BuildGrid(cloud);
-  // .2 get connected components
-  const int num_segments = GetConnectedComponents();
-  CHECK_GE(num_segments, 0);
-  // .3 write result
-  segments_indices-&gt;clear();
-  segments_indices-&gt;resize(num_segments);
-  num_cells_per_segment-&gt;clear();
-  num_cells_per_segment-&gt;resize(num_segments, 0);
-  for (int i = 0; i &lt; _grid_size; ++i) {
-    if (_label[i] != kEmptyGridLabel) {
-      (*num_cells_per_segment)[_label[i]]++;
-    }
-  }
-  for (int i = 0; i &lt; _num_points; ++i) {
-    const int idx = _point_cloud_grid_idx[i];
-    if (idx &gt;= 0) {
-      (*segments_indices)[_label[idx]].push_back(i);
-    }
-  }
-}
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\flood_fill.h" new_path="" added_lines="0" deleted_lines="67">
				<diff>@@ -1,67 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;algorithm&gt;
-#include &lt;cstdlib&gt;
-#include &lt;vector&gt;
-
-#include "modules/perception/base/point_cloud.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class FloodFill {
- public:
-  FloodFill() = default;
-  FloodFill(float grid_radius, float cell_size)
-      : _grid_radius(grid_radius), _cell_size(cell_size) {}
-  void GetSegments(base::PointFCloudConstPtr cloud,
-                   std::vector&lt;std::vector&lt;int&gt;&gt;* segments_indices,
-                   std::vector&lt;int&gt;* num_cells_per_segment);
-  // The grids at the boundary are valid.
-  int Pos(float x, float y) const;
-  bool Pos2d(float x, float y, int* irow, int* jcol) const;
-  void BuildGrid(base::PointFCloudConstPtr cloud);
-  void SetGridRadius(float grid_radius) { _grid_radius = grid_radius; }
-  void SetCellSize(float cell_size) { _cell_size = cell_size; }
-  int GetNumRows() const { return _grid_num_rows; }
-  int GetNumCols() const { return _grid_num_cols; }
-  int GetNumCells() const { return _grid_size; }
-  const std::vector&lt;int&gt;&amp; GetPointIdxInGrid() const {
-    return _point_cloud_grid_idx;
-  }
-
- private:
-  bool IsValidRowIndex(int i) const { return (i &gt;= 0 &amp;&amp; i &lt; _grid_num_rows); }
-  bool IsValidColIndex(int j) const { return (j &gt;= 0 &amp;&amp; j &lt; _grid_num_cols); }
-  int GetConnectedComponents();
-  void DfsColoring(int i, int j, int curr_component);
-  float _grid_radius = 0.0;
-  float _cell_size = 0.0;
-  float _offset_x = 0.0;
-  float _offset_y = 0.0;
-  int _grid_num_rows = 0;
-  int _grid_num_cols = 0;
-  int _grid_size = 0;
-  int _num_points = 0;
-  std::vector&lt;int&gt; _point_cloud_grid_idx;
-  std::vector&lt;int&gt; _label;
-};
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\graph_felzenszwalb\convolve.h" new_path="" added_lines="0" deleted_lines="76">
				<diff>@@ -1,76 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
-Copyright (C) 2006 Pedro Felzenszwalb
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-#pragma once
-#include &lt;algorithm&gt;
-#include &lt;cmath&gt;
-#include &lt;vector&gt;
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/image.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-// convolve src with mask.  dst is flipped!
-void convolve_even(Image&lt;float&gt; *src, Image&lt;float&gt; *dst,
-                   const std::vector&lt;float&gt; &amp;mask) {
-  int width = src-&gt;width();
-  int height = src-&gt;height();
-  int len = mask.size();
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      float sum = mask[0] * imRef(src, x, y);
-      for (int i = 1; i &lt; len; i++) {
-        sum += mask[i] * (imRef(src, std::max(x - i, 0), y) +
-                          imRef(src, std::min(x + i, width - 1), y));
-      }
-      imRef(dst, y, x) = sum;
-    }
-  }
-}
-// convolve src with mask.  dst is flipped!
-void convolve_odd(Image&lt;float&gt; *src, Image&lt;float&gt; *dst,
-                  const std::vector&lt;float&gt; &amp;mask) {
-  int width = src-&gt;width();
-  int height = src-&gt;height();
-  int len = mask.size();
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      float sum = mask[0] * imRef(src, x, y);
-      for (int i = 1; i &lt; len; i++) {
-        sum += mask[i] * (imRef(src, std::max(x - i, 0), y) -
-                          imRef(src, std::min(x + i, width - 1), y));
-      }
-      imRef(dst, y, x) = sum;
-    }
-  }
-}
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\graph_felzenszwalb\disjoint_set.h" new_path="" added_lines="0" deleted_lines="100">
				<diff>@@ -1,100 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
-Copyright (C) 2006 Pedro Felzenszwalb
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-
-#pragma once
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-// disjoint-set forests using union-by-rank and path compression (sort of).
-
-typedef struct {
-  int rank;
-  int p;
-  int size;
-} uni_elt;
-
-class Universe {
- public:
-  explicit Universe(int elements);
-  ~Universe();
-  int find(int x);
-  void join(int x, int y);
-  int size(int x) const { return _elts[x].size; }
-  int num_sets() const { return _num; }
-
- private:
-  uni_elt *_elts;
-  int _num;
-};
-
-Universe::Universe(int elements) {
-  _elts = new uni_elt[elements];
-  _num = elements;
-  for (int i = 0; i &lt; elements; i++) {
-    _elts[i].rank = 0;
-    _elts[i].size = 1;
-    _elts[i].p = i;
-  }
-}
-
-Universe::~Universe() { delete[] _elts; }
-
-int Universe::find(int x) {
-  int y = x;
-  while (y != _elts[y].p) {
-    y = _elts[y].p;
-  }
-  _elts[x].p = y;
-  return y;
-}
-
-void Universe::join(int x, int y) {
-  if (_elts[x].rank &gt; _elts[y].rank) {
-    _elts[y].p = x;
-    _elts[x].size += _elts[y].size;
-  } else {
-    _elts[x].p = y;
-    _elts[y].size += _elts[x].size;
-    if (_elts[x].rank == _elts[y].rank) {
-      _elts[y].rank++;
-    }
-  }
-  _num--;
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\graph_felzenszwalb\filter.h" new_path="" added_lines="0" deleted_lines="106">
				<diff>@@ -1,106 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
-Copyright (C) 2006 Pedro Felzenszwalb
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-/* simple filters */
-#pragma once
-#include &lt;algorithm&gt;
-#include &lt;cmath&gt;
-#include &lt;vector&gt;
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/convolve.h"
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/image.h"
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/imconv.h"
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/misc.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-const double WIDTH = 4.0;
-/* normalize mask so it integrates to one */
-void normalize(std::vector&lt;float&gt; *mask_input) {
-  std::vector&lt;float&gt; &amp;mask = *mask_input;
-  int len = mask.size();
-  float sum = 0;
-  for (int i = 1; i &lt; len; i++) {
-    sum += fabs(mask[i]);
-  }
-  sum = 2 * sum + fabs(mask[0]);
-  for (int i = 0; i &lt; len; i++) {
-    mask[i] /= sum;
-  }
-}
-/* make filters */
-#define MAKE_FILTER(name, fun)                           \
-  std::vector&lt;float&gt; make_##name(float sigma) {          \
-    sigma = std::max(sigma, 0.01F);                      \
-    int len = static_cast&lt;int&gt;(ceil(sigma * WIDTH)) + 1; \
-    std::vector&lt;float&gt; mask(len);                        \
-    for (int i = 0; i &lt; len; i++) {                      \
-      mask[i] = fun;                                     \
-    }                                                    \
-    return mask;                                         \
-  }
-MAKE_FILTER(fgauss, exp(-0.5 * square(i / sigma)));
-/* convolve image with gaussian filter */
-Image&lt;float&gt; *smooth(Image&lt;float&gt; *src, float sigma) {
-  std::vector&lt;float&gt; mask = make_fgauss(sigma);
-  normalize(mask);
-  Image&lt;float&gt; *tmp = new Image&lt;float&gt;(src-&gt;height(), src-&gt;width(), false);
-  Image&lt;float&gt; *dst = new Image&lt;float&gt;(src-&gt;width(), src-&gt;height(), false);
-  convolve_even(src, tmp, mask);
-  convolve_even(tmp, dst, mask);
-  delete tmp;
-  return dst;
-}
-/* convolve image with gaussian filter */
-Image&lt;float&gt; *smooth(Image&lt;uchar&gt; *src, float sigma) {
-  Image&lt;float&gt; *tmp = image_uchar2float(src);
-  Image&lt;float&gt; *dst = smooth(tmp, sigma);
-  delete tmp;
-  return dst;
-}
-/* compute laplacian */
-Image&lt;float&gt; *laplacian(Image&lt;float&gt; *src) {
-  int width = src-&gt;width();
-  int height = src-&gt;height();
-  Image&lt;float&gt; *dst = new Image&lt;float&gt;(width, height);
-  for (int y = 1; y &lt; height - 1; y++) {
-    for (int x = 1; x &lt; width - 1; x++) {
-      float d2x =
-          imRef(src, x - 1, y) + imRef(src, x + 1, y) - 2 * imRef(src, x, y);
-      float d2y =
-          imRef(src, x, y - 1) + imRef(src, x, y + 1) - 2 * imRef(src, x, y);
-      imRef(dst, x, y) = d2x + d2y;
-    }
-  }
-  return dst;
-}
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\graph_felzenszwalb\image.h" new_path="" added_lines="0" deleted_lines="108">
				<diff>@@ -1,108 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
-Copyright (C) 2006 Pedro Felzenszwalb
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-/* a simple image class */
-#pragma once
-#include &lt;cstring&gt;
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-template &lt;class T&gt;
-class Image {
- public:
-  /* create an image */
-  Image(const int width, const int height, const bool init = true);
-  /* delete an image */
-  ~Image();
-  /* init an image */
-  void init(const T &amp;val);
-  /* copy an image */
-  Image&lt;T&gt; *copy() const;
-
-  /* get the width of an image. */
-  int width() const { return _w; }
-
-  /* get the height of an image. */
-  int height() const { return _h; }
-
-  /* image data. */
-  T *_data;
-
-  /* row pointers. */
-  T **_access;
-
- private:
-  int _w;
-  int _h;
-};
-/* use imRef to access image data. */
-#define imRef(im, x, y) (im-&gt;_access[y][x])
-/* use imPtr to get pointer to image data. */
-#define imPtr(im, x, y) &amp;(im-&gt;_access[y][x])
-template &lt;class T&gt;
-Image&lt;T&gt;::Image(const int width, const int height, const bool init) {
-  _w = width;
-  _h = height;
-  _data = new T[_w * _h];  // allocate space for image data
-  _access = new T *[_h];   // allocate space for row pointers
-
-  // initialize row pointers
-  for (int i = 0; i &lt; _h; i++) {
-    _access[i] = _data + (i * _w);
-  }
-
-  if (init) {
-    memset(_data, 0, _w * _h * sizeof(T));
-  }
-}
-template &lt;class T&gt;
-Image&lt;T&gt;::~Image() {
-  delete[] _data;
-  delete[] _access;
-}
-template &lt;class T&gt;
-void Image&lt;T&gt;::init(const T &amp;val) {
-  T *ptr = imPtr(this, 0, 0);
-  T *end = imPtr(this, _w - 1, _h - 1);
-  while (ptr &lt;= end) {
-    *ptr++ = val;
-  }
-}
-template &lt;class T&gt;
-Image&lt;T&gt; *Image&lt;T&gt;::copy() const {
-  Image&lt;T&gt; *im = new Image&lt;T&gt;(_w, _h, false);
-  memcpy(im-&gt;_data, _data, _w * _h * sizeof(T));
-  return im;
-}
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\graph_felzenszwalb\imconv.h" new_path="" added_lines="0" deleted_lines="176">
				<diff>@@ -1,176 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
-Copyright (C) 2006 Pedro Felzenszwalb
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-/* image conversion */
-#pragma once
-
-#include &lt;limits&gt;
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/image.h"
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/imutil.h"
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/misc.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-const double RED_WEIGHT = 0.299;
-const double GREEN_WEIGHT = 0.587;
-const double BLUE_WEIGHT = 0.114;
-Image&lt;uchar&gt; *image_rgb2gray(Image&lt;rgb&gt; *input) {
-  int width = input-&gt;width();
-  int height = input-&gt;height();
-  Image&lt;uchar&gt; *output = new Image&lt;uchar&gt;(width, height, false);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      imRef(output, x, y) = (uchar)(imRef(input, x, y).r * RED_WEIGHT +
-                                    imRef(input, x, y).g * GREEN_WEIGHT +
-                                    imRef(input, x, y).b * BLUE_WEIGHT);
-    }
-  }
-  return output;
-}
-Image&lt;rgb&gt; *image_gray2rgb(Image&lt;uchar&gt; *input) {
-  int width = input-&gt;width();
-  int height = input-&gt;height();
-  Image&lt;rgb&gt; *output = new Image&lt;rgb&gt;(width, height, false);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      imRef(output, x, y).r = imRef(input, x, y);
-      imRef(output, x, y).g = imRef(input, x, y);
-      imRef(output, x, y).b = imRef(input, x, y);
-    }
-  }
-  return output;
-}
-Image&lt;float&gt; *image_uchar2float(Image&lt;uchar&gt; *input) {
-  int width = input-&gt;width();
-  int height = input-&gt;height();
-  Image&lt;float&gt; *output = new Image&lt;float&gt;(width, height, false);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      imRef(output, x, y) = imRef(input, x, y);
-    }
-  }
-  return output;
-}
-Image&lt;float&gt; *image_int2float(Image&lt;int&gt; *input) {
-  int width = input-&gt;width();
-  int height = input-&gt;height();
-  Image&lt;float&gt; *output = new Image&lt;float&gt;(width, height, false);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      imRef(output, x, y) = imRef(input, x, y);
-    }
-  }
-  return output;
-}
-Image&lt;uchar&gt; *image_float2uchar(Image&lt;float&gt; *input, float min, float max) {
-  int width = input-&gt;width();
-  int height = input-&gt;height();
-  Image&lt;uchar&gt; *output = new Image&lt;uchar&gt;(width, height, false);
-  if (max == min) {
-    return output;
-  }
-  float scale = std::numeric_limits&lt;unsigned char&gt;::max() / (max - min);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      uchar val = (uchar)((imRef(input, x, y) - min) * scale);
-      imRef(output, x, y) = bound(
-          val, (uchar)0, (uchar)std::numeric_limits&lt;unsigned char&gt;::max());
-    }
-  }
-  return output;
-}
-Image&lt;uchar&gt; *image_float2uchar(Image&lt;float&gt; *input) {
-  float min, max;
-  min_max(input, &amp;min, &amp;max);
-  return image_float2uchar(input, min, max);
-}
-Image&lt;uint32_t&gt; *image_uchar2long(Image&lt;uchar&gt; *input) {
-  int width = input-&gt;width();
-  int height = input-&gt;height();
-  Image&lt;uint32_t&gt; *output = new Image&lt;uint32_t&gt;(width, height, false);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      imRef(output, x, y) = imRef(input, x, y);
-    }
-  }
-  return output;
-}
-Image&lt;uchar&gt; *image_long2uchar(Image&lt;uint32_t&gt; *input, uint32_t min,
-                               uint32_t max) {
-  int width = input-&gt;width();
-  int height = input-&gt;height();
-  Image&lt;uchar&gt; *output = new Image&lt;uchar&gt;(width, height, false);
-  if (max == min) {
-    return output;
-  }
-  float scale =
-      std::numeric_limits&lt;unsigned char&gt;::max() / static_cast&lt;float&gt;(max - min);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      uchar val = (uchar)((imRef(input, x, y) - min) * scale);
-      imRef(output, x, y) = bound(
-          val, (uchar)0, (uchar)std::numeric_limits&lt;unsigned char&gt;::max());
-    }
-  }
-  return output;
-}
-Image&lt;uchar&gt; *image_long2uchar(Image&lt;uint32_t&gt; *input) {
-  uint32_t min, max;
-  min_max(input, &amp;min, &amp;max);
-  return image_long2uchar(input, min, max);
-}
-Image&lt;uchar&gt; *image_short2uchar(Image&lt;uint16_t&gt; *input, uint16_t min,
-                                uint16_t max) {
-  int width = input-&gt;width();
-  int height = input-&gt;height();
-  Image&lt;uchar&gt; *output = new Image&lt;uchar&gt;(width, height, false);
-  if (max == min) {
-    return output;
-  }
-  float scale =
-      std::numeric_limits&lt;unsigned char&gt;::max() / static_cast&lt;float&gt;(max - min);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      uchar val = (uchar)((imRef(input, x, y) - min) * scale);
-      imRef(output, x, y) = bound(
-          val, (uchar)0, (uchar)std::numeric_limits&lt;unsigned char&gt;::max());
-    }
-  }
-  return output;
-}
-Image&lt;uchar&gt; *image_short2uchar(Image&lt;uint16_t&gt; *input) {
-  uint16_t min, max;
-  min_max(input, &amp;min, &amp;max);
-  return image_short2uchar(input, min, max);
-}
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\graph_felzenszwalb\imutil.h" new_path="" added_lines="0" deleted_lines="76">
				<diff>@@ -1,76 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
-Copyright (C) 2006 Pedro Felzenszwalb
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-/* some image utilities */
-#pragma once
-
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/image.h"
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/misc.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-/* compute minimum and maximum value in an image */
-template &lt;class T&gt;
-void min_max(Image&lt;T&gt; *im, T *ret_min, T *ret_max) {
-  int width = im-&gt;width();
-  int height = im-&gt;height();
-  T min = imRef(im, 0, 0);
-  T max = imRef(im, 0, 0);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      T val = imRef(im, x, y);
-      if (min &gt; val) {
-        min = val;
-      }
-      if (max &lt; val) {
-        max = val;
-      }
-    }
-  }
-  *ret_min = min;
-  *ret_max = max;
-}
-/* threshold image */
-template &lt;class T&gt;
-Image&lt;uchar&gt; *threshold(Image&lt;T&gt; *src, int t) {
-  int width = src-&gt;width();
-  int height = src-&gt;height();
-  Image&lt;uchar&gt; *dst = new Image&lt;uchar&gt;(width, height);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      imRef(dst, x, y) = (imRef(src, x, y) &gt;= t);
-    }
-  }
-  return dst;
-}
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\graph_felzenszwalb\misc.h" new_path="" added_lines="0" deleted_lines="74">
				<diff>@@ -1,74 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
-Copyright (C) 2006 Pedro Felzenszwalb
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-
-#pragma once
-
-#include &lt;cmath&gt;
-namespace apollo {
-namespace perception {
-namespace lidar {
-typedef unsigned char uchar;
-typedef struct {
-  uchar r;
-  uchar g;
-  uchar b;
-} rgb;
-inline bool operator==(const rgb &amp;a, const rgb &amp;b) {
-  return ((a.r == b.r) &amp;&amp; (a.g == b.g) &amp;&amp; (a.b == b.b));
-}
-template &lt;class T&gt;
-inline T abs(const T &amp;x) {
-  return (x &gt; 0 ? x : -x);
-}
-template &lt;class T&gt;
-inline int sign(const T &amp;x) {
-  return (x &gt;= 0 ? 1 : -1);
-}
-template &lt;class T&gt;
-inline T square(const T &amp;x) {
-  return x * x;
-}
-template &lt;class T&gt;
-inline T bound(const T &amp;x, const T &amp;min, const T &amp;max) {
-  return (x &lt; min ? min : (x &gt; max ? max : x));
-}
-template &lt;class T&gt;
-inline bool check_bound(const T &amp;x, const T &amp;min, const T &amp;max) {
-  return ((x &lt; min) || (x &gt; max));
-}
-inline int vlib_round(float x) { return static_cast&lt;int&gt;(x + 0.5F); }
-inline int vlib_round(double x) { return static_cast&lt;int&gt;(x + 0.5); }
-inline double gaussian(double val, double sigma) {
-  return exp(-square(val / sigma) / 2) / (sqrt(2 * M_PI) * sigma);
-}
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\graph_felzenszwalb\segment_graph.h" new_path="" added_lines="0" deleted_lines="101">
				<diff>@@ -1,101 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-/*
-Copyright (C) 2006 Pedro Felzenszwalb
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-
-#pragma once
-#include &lt;algorithm&gt;
-#include &lt;cmath&gt;
-
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/disjoint_set.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-// threshold function
-#define THRESHOLD(size, c) (c / size)
-
-typedef struct {
-  float w;
-  int a;
-  int b;
-} edge;
-
-bool operator&lt;(const edge &amp;a, const edge &amp;b) { return a.w &lt; b.w; }
-
-/*
- * Segment a graph
- *
- * Returns a disjoint-set forest representing the segmentation.
- *
- * num_vertices: number of vertices in graph.
- * num_edges: number of edges in graph
- * edges: array of edges.
- * c: constant for threshold function.
- */
-Universe *segment_graph(int num_vertices, int num_edges, edge *edges, float c) {
-  // sort edges by weight
-  std::sort(edges, edges + num_edges);
-
-  // make a disjoint-set forest
-  Universe *u = new Universe(num_vertices);
-
-  // init thresholds
-  float *threshold = new float[num_vertices];
-  for (int i = 0; i &lt; num_vertices; i++) {
-    threshold[i] = THRESHOLD(1, c);
-  }
-
-  // for each edge, in non-decreasing weight order...
-  for (int i = 0; i &lt; num_edges; i++) {
-    edge *pedge = &amp;edges[i];
-
-    // components connected by this edge
-    int a = u-&gt;find(pedge-&gt;a);
-    int b = u-&gt;find(pedge-&gt;b);
-    if (a != b) {
-      if ((pedge-&gt;w &lt;= threshold[a]) &amp;&amp; (pedge-&gt;w &lt;= threshold[b])) {
-        u-&gt;join(a, b);
-        a = u-&gt;find(a);
-        threshold[a] = pedge-&gt;w + THRESHOLD(u-&gt;size(a), c);
-      }
-    }
-  }
-
-  // free up
-  delete threshold;
-  return u;
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\graph_felzenszwalb\segment_image.h" new_path="" added_lines="0" deleted_lines="119">
				<diff>@@ -1,119 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-/*
-Copyright (C) 2006 Pedro Felzenszwalb
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-*/
-
-#pragma once
-
-#include &lt;cstdlib&gt;
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/filter.h"
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/image.h"
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/misc.h"
-#include "modules/perception/lidar/segmentation/ncut/common/graph_felzenszwalb/segment_graph.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-// dissimilarity measure between pixels
-inline float diff(Image&lt;float&gt; *I, int x1, int y1, int x2, int y2) {
-  return std::fabs(imRef(I, x1, y1) - imRef(I, x2, y2));
-}
-/*
- * Segment an image
- *
- * Returns a color image representing the segmentation.
- *
- * im: image to segment.
- * sigma: to smooth the image.
- * c: constant for threshold function.
- * min_size: minimum component size (enforced by post-processing stage).
- * num_ccs: number of connected components in the segmentation.
- */
-Image&lt;int&gt; *segment_image(Image&lt;float&gt; *im, float sigma, float c, int min_size,
-                          int *num_ccs) {
-  int width = im-&gt;width();
-  int height = im-&gt;height();
-  // smooth each color channel
-  Image&lt;float&gt; *smooth_r = smooth(im, sigma);
-  // build graph
-  edge *edges = new edge[width * height * 4];
-  int num = 0;
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      if (x &lt; width - 1) {
-        edges[num].a = y * width + x;
-        edges[num].b = y * width + (x + 1);
-        edges[num].w = diff(smooth_r, x, y, x + 1, y);
-        num++;
-      }
-      if (y &lt; height - 1) {
-        edges[num].a = y * width + x;
-        edges[num].b = (y + 1) * width + x;
-        edges[num].w = diff(smooth_r, x, y, x, y + 1);
-        num++;
-      }
-      if ((x &lt; width - 1) &amp;&amp; (y &lt; height - 1)) {
-        edges[num].a = y * width + x;
-        edges[num].b = (y + 1) * width + (x + 1);
-        edges[num].w = diff(smooth_r, x, y, x + 1, y + 1);
-        num++;
-      }
-      if ((x &lt; width - 1) &amp;&amp; (y &gt; 0)) {
-        edges[num].a = y * width + x;
-        edges[num].b = (y - 1) * width + (x + 1);
-        edges[num].w = diff(smooth_r, x, y, x + 1, y - 1);
-        num++;
-      }
-    }
-  }
-  delete smooth_r;
-  // segment
-  Universe *u = segment_graph(width * height, num, edges, c);
-  // post process small components
-  for (int i = 0; i &lt; num; i++) {
-    int a = u-&gt;find(edges[i].a);
-    int b = u-&gt;find(edges[i].b);
-    if ((a != b) &amp;&amp; ((u-&gt;size(a) &lt; min_size) || (u-&gt;size(b) &lt; min_size)))
-      u-&gt;join(a, b);
-  }
-  delete[] edges;
-  *num_ccs = u-&gt;num_sets();
-  Image&lt;int&gt; *output = new Image&lt;int&gt;(width, height);
-  for (int y = 0; y &lt; height; y++) {
-    for (int x = 0; x &lt; width; x++) {
-      int comp = u-&gt;find(y * width + x);
-      imRef(output, x, y) = comp;
-    }
-  }
-  delete u;
-  return output;
-}
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\common\lr_classifier.h" new_path="" added_lines="0" deleted_lines="93">
				<diff>@@ -1,93 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;algorithm&gt;
-#include &lt;cmath&gt;
-#include &lt;cstdlib&gt;
-#include &lt;iostream&gt;
-#include &lt;limits&gt;
-#include &lt;map&gt;
-#include &lt;string&gt;
-#include &lt;tuple&gt;
-#include &lt;unordered_set&gt;
-#include &lt;vector&gt;
-
-#include "Eigen/Core"
-
-#include "modules/perception/base/point_cloud.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class LRClassifier {
- public:
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-
- public:
-  LRClassifier() = default;
-  ~LRClassifier() {}
-  bool init() {
-    _lr_parameters.resize(3, 4);
-    _lr_parameters.coeffRef(0, 0) = 0.0510903f;
-    _lr_parameters.coeffRef(0, 1) = -1.00989f;
-    _lr_parameters.coeffRef(0, 2) = -1.6537f;
-    _lr_parameters.coeffRef(0, 3) = 0.130055f;
-    _lr_parameters.coeffRef(1, 0) = 0.266469f;
-    _lr_parameters.coeffRef(1, 1) = -0.538964f;
-    _lr_parameters.coeffRef(1, 2) = -0.291611f;
-    _lr_parameters.coeffRef(1, 3) = -0.070701f;
-    _lr_parameters.coeffRef(2, 0) = 0.497949f;
-    _lr_parameters.coeffRef(2, 1) = -0.504843f;
-    _lr_parameters.coeffRef(2, 2) = -0.152141f;
-    _lr_parameters.coeffRef(2, 3) = -1.38024f;
-    return true;
-  }
-
-  std::string GetLabel(base::PointFCloudConstPtr cloud) {
-    // point cloud should be rotated
-    float x_max = -std::numeric_limits&lt;float&gt;::max();
-    float y_max = -std::numeric_limits&lt;float&gt;::max();
-    float z_max = -std::numeric_limits&lt;float&gt;::max();
-    float x_min = std::numeric_limits&lt;float&gt;::max();
-    float y_min = std::numeric_limits&lt;float&gt;::max();
-    float z_min = std::numeric_limits&lt;float&gt;::max();
-    for (size_t i = 0; i &lt; cloud-&gt;size(); ++i) {
-      auto pt = (*cloud)[i];
-      x_min = std::min(x_min, pt.x);
-      x_max = std::max(x_max, pt.x);
-      y_min = std::min(y_min, pt.y);
-      y_max = std::max(y_max, pt.y);
-      z_min = std::min(z_min, pt.z);
-      z_max = std::max(z_max, pt.z);
-    }
-    Eigen::Vector3f fea = {x_max - x_min, y_max - y_min, z_max - z_min};
-    Eigen::VectorXf response = fea.transpose() * _lr_parameters;
-    int type = 0;
-    // float max_score = response.maxCoeff(&amp;type);
-    return _labels[type];
-  }
-
- private:
-  Eigen::MatrixXf _lr_parameters;
-  std::vector&lt;std::string&gt; _labels = {"unknown", "nonMot", "pedestrian",
-                                      "smallMot"};
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\ncut.cc" new_path="" added_lines="0" deleted_lines="833">
				<diff>@@ -1,833 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-#include "modules/perception/lidar/lib/segmentation/ncut/ncut.h"
-
-#include &lt;algorithm&gt;
-#include &lt;ctime&gt;
-#include &lt;functional&gt;
-#include &lt;limits&gt;
-#include &lt;queue&gt;
-#include &lt;stack&gt;
-#include &lt;string&gt;
-#include &lt;unordered_map&gt;
-#include &lt;utility&gt;
-#include &lt;vector&gt;
-
-#include &lt;omp.h&gt;
-
-#include "cyber/common/file.h"
-#include "cyber/common/log.h"
-#include "modules/perception/base/point_cloud_util.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-namespace {
-const int OBSTACLE_MINIMUM_NUM_POINTS = 50;
-}
-
-using apollo::cyber::common::GetAbsolutePath;
-using apollo::cyber::common::GetProtoFromFile;
-using Eigen::MatrixXf;
-
-NCut::NCut() {}
-NCut::~NCut() { ADEBUG &lt;&lt; "NCut destructor done"; }
-
-bool NCut::Init(const NCutParam &amp;param) {
-  if (!Configure(param)) {
-    AERROR &lt;&lt; "failed to load ncut config.";
-    return false;
-  }
-
-  _classifier.reset(new LRClassifier);
-  if (!_classifier-&gt;init()) {
-    AERROR &lt;&lt; "failed to init FrameClassifierPipeline.";
-    return false;
-  }
-  return true;
-}
-
-bool NCut::Configure(const NCutParam &amp;ncut_param_) {
-  _grid_radius = ncut_param_.grid_radius();
-  _connect_radius = ncut_param_.connect_radius();
-  _super_pixel_cell_size = ncut_param_.super_pixel_cell_size();
-  _num_cuts = ncut_param_.num_cuts();
-  _ncuts_stop_threshold = ncut_param_.ncuts_stop_threshold();
-  _ncuts_enable_classifier_threshold =
-      ncut_param_.ncuts_enable_classifier_threshold();
-  _sigma_space = ncut_param_.sigma_space();
-  _sigma_feature = ncut_param_.sigma_feature();
-  _skeleton_cell_size = ncut_param_.skeleton_cell_size();
-  _patch_size = ncut_param_.patch_size();
-  _overlap_factor = ncut_param_.overlap_factor();
-  _felzenszwalb_sigma = ncut_param_.felzenszwalb_sigma();
-  _felzenszwalb_k = ncut_param_.felzenszwalb_k();
-  _felzenszwalb_min_size = ncut_param_.felzenszwalb_min_size();
-
-  AINFO &lt;&lt; "NCut Parameters" &lt;&lt; ncut_param_.DebugString();
-  return true;
-}
-
-void NCut::Segment(base::PointFCloudConstPtr cloud) {
-#ifdef DEBUG_NCUT
-  double start_t = omp_get_wtime();
-#endif
-  // .0 clear everything
-  _segment_pids.clear();
-  _segment_labels.clear();
-  _segment_bbox.clear();
-  _outlier_pids.clear();
-  _cluster_points.clear();
-  _cluster_bounding_box.clear();
-  _cluster_skeleton_points.clear();
-  _cluster_skeleton_features.clear();
-  std::vector&lt;int&gt; pids(cloud-&gt;size());
-  for (size_t i = 0; i &lt; cloud-&gt;size(); ++i) {
-    pids[i] = static_cast&lt;int&gt;(i);
-  }
-  _cloud_obstacles = base::PointFCloudPtr(new base::PointFCloud(*cloud, pids));
-  AINFO &lt;&lt; "cloud obstacle size in ncut segment is "
-        &lt;&lt; _cloud_obstacles-&gt;size();
-#ifdef DEBUG_NCUT
-  ADEBUG &lt;&lt; "segment enter ... input cloud size " &lt;&lt; cloud-&gt;size();
-// visualize_points(pids);
-#endif
-  // .1 super pixels
-  // super_pixels_felzenszwalb(cloud, _grid_radius, _super_pixel_cell_size,
-  // _cluster_points);
-  SuperPixelsFloodFill(cloud, _grid_radius, _super_pixel_cell_size,
-                       &amp;_cluster_points);
-#ifdef DEBUG_NCUT
-  // visualize_segments_from_points(_cluster_points);
-  ADEBUG &lt;&lt; "super pixels " &lt;&lt; _cluster_points.size();
-  AINFO &lt;&lt; "super pixels done " &lt;&lt; omp_get_wtime() - start_t;
-  start_t = omp_get_wtime();
-#endif
-
-  // .2 precompute skeleton and bbox
-  PrecomputeAllSkeletonAndBbox();
-#ifdef DEBUG_NCUT
-  AINFO &lt;&lt; "precompute skeleton and bbox done " &lt;&lt; omp_get_wtime() - start_t;
-  start_t = omp_get_wtime();
-#endif
-  // .3 grach cut
-  std::vector&lt;std::vector&lt;int&gt;&gt; segment_clusters;
-  std::vector&lt;std::string&gt; segment_labels;
-  NormalizedCut(_ncuts_stop_threshold, true, &amp;segment_clusters,
-                &amp;segment_labels);
-#ifdef DEBUG_NCUT
-  AINFO &lt;&lt; "normalized_cut done, #segments " &lt;&lt; segment_clusters.size()
-        &lt;&lt; ", time: " &lt;&lt; omp_get_wtime() - start_t;
-  start_t = omp_get_wtime();
-#endif
-  // .4 _segment_pids;
-  for (size_t i = 0; i &lt; segment_clusters.size(); ++i) {
-    std::vector&lt;int&gt; pids;
-    GetClustersPids(segment_clusters[i], &amp;pids);
-    if (pids.size() &gt; 0) {
-      _segment_pids.push_back(pids);
-      _segment_labels.push_back(segment_labels[i]);
-      NcutBoundingBox box;
-      GetComponentBoundingBox(segment_clusters[i], &amp;box);
-      _segment_bbox.push_back(box);
-    }
-  }
-}
-
-void NCut::SuperPixelsFloodFill(base::PointFCloudConstPtr cloud, float radius,
-                                float cell_size,
-                                std::vector&lt;std::vector&lt;int&gt;&gt; *super_pixels) {
-  FloodFill ff_grid(radius, cell_size);
-  std::vector&lt;int&gt; num_cells_per_components;
-  ff_grid.GetSegments(cloud, super_pixels, &amp;num_cells_per_components);
-}
-
-void NCut::PrecomputeAllSkeletonAndBbox() {
-  const int num_clusters = static_cast&lt;int&gt;(_cluster_points.size());
-  _cluster_skeleton_points.resize(num_clusters);
-  _cluster_skeleton_features.resize(num_clusters);
-  _cluster_bounding_box.resize(num_clusters);
-  _cluster_labels.resize(num_clusters, "unknown");
-  // skeleton
-  _ff_feature_grid.SetGridRadius(_grid_radius);
-  _ff_feature_grid.SetCellSize(_skeleton_cell_size);
-  _ff_feature_grid.BuildGrid(_cloud_obstacles);
-  std::vector&lt;gridIndex&gt; dummy_indices;
-  BuildAverageHeightMap(_cloud_obstacles, _ff_feature_grid, &amp;_cv_feature_map,
-                        &amp;dummy_indices);
-
-  // build_maximum_height_map(_cloud_obstacles, _ff_feature_grid,
-  // _cv_feature_map, dummy_indices);
-  for (int i = 0; i &lt; num_clusters; ++i) {
-    SampleByGrid(_cluster_points[i], &amp;_cluster_skeleton_points[i],
-                 &amp;_cluster_skeleton_features[i]);
-    _cluster_bounding_box[i] = ComputeClusterBoundingBox(_cluster_points[i]);
-  }
-  // cluster label
-  for (size_t i = 0; i &lt; _cluster_points.size(); ++i) {
-    base::PointFCloudPtr pc = base::PointFCloudPtr(
-        new base::PointFCloud(*_cloud_obstacles, _cluster_points[i]));
-    _cluster_labels[i] = GetPcLabel(pc);
-  }
-}
-
-void NCut::BuildAverageHeightMap(
-    base::PointFCloudConstPtr cloud, const FloodFill &amp;ff_map,
-    cv::Mat *cv_height_map_in, std::vector&lt;gridIndex&gt; *point_pixel_indices_in) {
-  cv::Mat &amp;cv_height_map = *cv_height_map_in;
-  std::vector&lt;gridIndex&gt; &amp;point_pixel_indices = *point_pixel_indices_in;
-  const int num_points = static_cast&lt;int&gt;(cloud-&gt;size());
-  cv::Mat cv_img =
-      cv::Mat::zeros(ff_map.GetNumRows(), ff_map.GetNumCols(), CV_32F);
-  std::vector&lt;std::vector&lt;int&gt;&gt; counts;
-  counts.resize(cv_img.rows);
-  for (size_t i = 0; i &lt; counts.size(); ++i) {
-    counts[i].resize(cv_img.cols, 0);
-  }
-  point_pixel_indices.resize(num_points);
-  for (int i = 0; i &lt; num_points; ++i) {
-    int irow = -1;
-    int jcol = -1;
-    base::PointF pt = (*cloud)[i];
-    if (ff_map.Pos2d(pt.x, pt.y, &amp;irow, &amp;jcol)) {
-      cv_img.at&lt;float&gt;(irow, jcol) += pt.z;
-      counts[irow][jcol] += 1;
-      point_pixel_indices[i].irow = irow;
-      point_pixel_indices[i].jcol = jcol;
-    } else {
-      point_pixel_indices[i].irow = -1;
-      point_pixel_indices[i].jcol = -1;
-    }
-  }
-  for (int i = 0; i &lt; cv_img.rows; ++i) {
-    for (int j = 0; j &lt; cv_img.cols; ++j) {
-      if (counts[i][j] &gt; 0) {
-        cv_img.at&lt;float&gt;(i, j) /= static_cast&lt;float&gt;(counts[i][j]);
-      }
-    }
-  }
-  cv::Mat cv_height_map_copy;
-  cv::GaussianBlur(cv_img, cv_height_map_copy, cv::Size(3, 3), 0, 0);
-  cv::normalize(cv_height_map_copy, cv_height_map, 0, 255, cv::NORM_MINMAX,
-                CV_8UC1);
-}
-
-void NCut::SampleByGrid(const std::vector&lt;int&gt; &amp;point_gids,
-                        MatrixXf *skeleton_coords_in,
-                        MatrixXf *skeleton_feature_in) {
-  MatrixXf &amp;skeleton_coords = *skeleton_coords_in;
-  MatrixXf &amp;skeleton_feature = *skeleton_feature_in;
-  FloodFill sampler(_grid_radius, _skeleton_cell_size);
-  base::PointFCloudPtr pc = base::PointFCloudPtr(
-      new base::PointFCloud(*_cloud_obstacles, point_gids));
-  sampler.BuildGrid(pc);
-  std::unordered_map&lt;int, std::pair&lt;base::PointF, float&gt;&gt; centroids;
-  const std::vector&lt;int&gt; &amp;point_idx = sampler.GetPointIdxInGrid();
-  std::unordered_map&lt;int, std::pair&lt;base::PointF, float&gt;&gt;::iterator it;
-  for (size_t i = 0; i &lt; point_idx.size(); ++i) {
-    it = centroids.find(point_idx[i]);
-    if (it != centroids.end()) {
-      it-&gt;second.first.x += (*pc)[i].x;
-      it-&gt;second.first.y += (*pc)[i].y;
-      it-&gt;second.first.z += (*pc)[i].z;
-      it-&gt;second.second += 1.f;
-    } else {
-      centroids[point_idx[i]] = std::make_pair((*pc)[i], 1.f);
-    }
-  }
-  int num_skeletons = static_cast&lt;int&gt;(centroids.size());
-  skeleton_coords.resize(num_skeletons, 3);
-  int p = 0;
-  for (it = centroids.begin(); it != centroids.end(); ++it) {
-    skeleton_coords.coeffRef(p, 0) = it-&gt;second.first.x / it-&gt;second.second;
-    skeleton_coords.coeffRef(p, 1) = it-&gt;second.first.y / it-&gt;second.second;
-    skeleton_coords.coeffRef(p, 2) = it-&gt;second.first.z / it-&gt;second.second;
-    p++;
-  }
-  GetPatchFeature(skeleton_coords, &amp;skeleton_feature);
-}
-
-void NCut::GetPatchFeature(const MatrixXf &amp;points, MatrixXf *features_in) {
-  MatrixXf &amp;features = *features_in;
-  const int num_points = static_cast&lt;int&gt;(points.rows());
-  const int dim = _patch_size * _patch_size;
-  features.resize(num_points, dim);
-  for (int i = 0; i &lt; num_points; ++i) {
-    // .1 patch
-    int irow = 0;
-    int jcol = 0;
-    _ff_feature_grid.Pos2d(points.coeffRef(i, 0), points.coeffRef(i, 1), &amp;irow,
-                           &amp;jcol);
-    cv::Mat patch;
-    cv::Point2f pt(static_cast&lt;float&gt;(irow), static_cast&lt;float&gt;(jcol));
-    cv::getRectSubPix(_cv_feature_map, cv::Size(_patch_size, _patch_size), pt,
-                      patch);
-    // .2 maybe later i will add other features based on patch
-    // .3 add to features
-    assert(dim == patch.rows * patch.cols);
-    int p = 0;
-    for (int r = 0; r &lt; patch.rows; ++r) {
-      for (int c = 0; c &lt; patch.cols; ++c) {
-        float val = patch.at&lt;float&gt;(r, c);
-        features.coeffRef(i, p++) = static_cast&lt;float&gt;(
-            (std::isnan(val) || std::isinf(val)) ? 1.e-50 : val);
-        // features.coeffRef(i, p++) = patch.at&lt;float&gt;(r, c);
-      }
-    }
-  }
-}
-
-NCut::NcutBoundingBox NCut::ComputeClusterBoundingBox(
-    const std::vector&lt;int&gt; &amp;point_gids) {
-  // ! Note: do not perform rotation, so just some intuitive guess
-  float x_max = -std::numeric_limits&lt;float&gt;::max();
-  float y_max = -std::numeric_limits&lt;float&gt;::max();
-  float z_max = -std::numeric_limits&lt;float&gt;::max();
-  float x_min = std::numeric_limits&lt;float&gt;::max();
-  float y_min = std::numeric_limits&lt;float&gt;::max();
-  float z_min = std::numeric_limits&lt;float&gt;::max();
-  for (size_t j = 0; j &lt; point_gids.size(); ++j) {
-    int pid = point_gids[j];
-    x_min = std::min(x_min, (*_cloud_obstacles)[pid].x);
-    x_max = std::max(x_max, (*_cloud_obstacles)[pid].x);
-    y_min = std::min(y_min, (*_cloud_obstacles)[pid].y);
-    y_max = std::max(y_max, (*_cloud_obstacles)[pid].y);
-    z_min = std::min(z_min, (*_cloud_obstacles)[pid].z);
-    z_max = std::max(z_max, (*_cloud_obstacles)[pid].z);
-  }
-  NcutBoundingBox box;
-  std::get&lt;0&gt;(box) = x_min;
-  std::get&lt;1&gt;(box) = x_max;
-  std::get&lt;2&gt;(box) = y_min;
-  std::get&lt;3&gt;(box) = y_max;
-  std::get&lt;4&gt;(box) = z_min;
-  std::get&lt;5&gt;(box) = z_max;
-  return box;
-}
-
-std::string NCut::GetPcLabel(const base::PointFCloudPtr &amp;cloud) {
-  if (cloud-&gt;size() &lt; OBSTACLE_MINIMUM_NUM_POINTS) {
-    return "unknown";
-  }
-  base::PointFCloudPtr rot_cloud(new base::PointFCloud);
-  base::OrientCloud(*cloud, rot_cloud.get(), true);
-  std::string label;
-  // Eigen::VectorXf response = _classifier-&gt;classify_and_get_label(rot_cloud,
-  // &amp;label);
-  label = _classifier-&gt;GetLabel(rot_cloud);
-  // ./obstacle_detection/classifier/frame_classifier_pipeline.cpp line 466
-  if (label == "background") {
-    label = "unknown";
-  }
-  return label;
-}
-
-void NCut::NormalizedCut(float ncuts_threshold, bool use_classifier,
-                         std::vector&lt;std::vector&lt;int&gt;&gt; *segment_clusters_in,
-                         std::vector&lt;std::string&gt; *segment_labels_in) {
-  std::vector&lt;std::vector&lt;int&gt;&gt; &amp;segment_clusters = *segment_clusters_in;
-  std::vector&lt;std::string&gt; &amp;segment_labels = *segment_labels_in;
-  const int num_clusters = static_cast&lt;int&gt;(_cluster_points.size());
-  if (num_clusters &lt; 1) {
-    return;
-  }
-  if (num_clusters == 1) {
-    std::vector&lt;int&gt; tmp(1, 0);
-    segment_clusters.push_back(tmp);
-    segment_labels.push_back(_cluster_labels[0]);
-    return;
-  }
-#ifdef DEBUG_NCUT
-  LOG_DEBUG &lt;&lt; "\n+++++++++++++++++++++++++++++ input " &lt;&lt; num_clusters
-            &lt;&lt; " clusters +++++++++++++++++++++++++++\n";
-// visualize_segments_from_cluster(_cluster_points);
-#endif
-  MatrixXf weights;
-  ComputeSkeletonWeights(&amp;weights);
-  std::vector&lt;int&gt; *curr = new std::vector&lt;int&gt;(num_clusters);
-  for (int i = 0; i &lt; num_clusters; ++i) {
-    (*curr)[i] = i;
-  }
-  std::stack&lt;std::vector&lt;int&gt; *&gt; job_stack;
-  job_stack.push(curr);
-  while (!job_stack.empty()) {
-    curr = job_stack.top();
-    job_stack.pop();
-#ifdef DEBUG_NCUT
-    AINFO &lt;&lt; "curr size " &lt;&lt; curr-&gt;size();
-// visualize_cluster(curr);
-#endif
-    std::string seg_label;
-    if (curr-&gt;size() == 1) {
-      segment_clusters.push_back(*curr);
-      segment_labels.push_back(_cluster_labels[(*curr)[0]]);
-    } else if (use_classifier &amp;&amp; IsMovableObstacle(*curr, &amp;seg_label)) {
-      segment_clusters.push_back(*curr);
-      segment_labels.push_back(seg_label);
-#ifdef DEBUG_NCUT
-      std::cout &lt;&lt; "cluster: ";
-      for (size_t i = 0; i &lt; curr-&gt;size(); ++i) {
-        std::cout &lt;&lt; (*curr)[i] &lt;&lt; " ";
-      }
-      std::cout &lt;&lt; " as a segment (" &lt;&lt; seg_label &lt;&lt; ")" &lt;&lt; std::endl;
-#endif
-    } else {
-      std::vector&lt;int&gt; *seg1 = new std::vector&lt;int&gt;();
-      std::vector&lt;int&gt; *seg2 = new std::vector&lt;int&gt;();
-      MatrixXf my_weights(curr-&gt;size(), curr-&gt;size());
-      for (size_t i = 0; i &lt; curr-&gt;size(); ++i) {
-        const int ci = curr-&gt;at(i);
-        for (size_t j = 0; j &lt; curr-&gt;size(); ++j) {
-          const int cj = curr-&gt;at(j);
-          my_weights.coeffRef(i, j) = weights.coeffRef(ci, cj);
-        }
-      }
-      double cost = GetMinNcuts(my_weights, curr, seg1, seg2);
-#ifdef DEBUG_NCUT
-      AINFO &lt;&lt; "N cut cost is " &lt;&lt; cost &lt;&lt; ", seg1 size " &lt;&lt; seg1-&gt;size()
-            &lt;&lt; ", seg2 size " &lt;&lt; seg2-&gt;size();
-      if (curr-&gt;size() &lt; 50) {
-        std::cout &lt;&lt; "seg1: ";
-        for (size_t i = 0; i &lt; seg1-&gt;size(); ++i) {
-          std::cout &lt;&lt; (*seg1)[i] &lt;&lt; " ";
-        }
-        std::cout &lt;&lt; std::endl;
-        std::cout &lt;&lt; "seg2: ";
-        for (size_t i = 0; i &lt; seg2-&gt;size(); ++i) {
-          std::cout &lt;&lt; (*seg2)[i] &lt;&lt; " ";
-        }
-        std::cout &lt;&lt; std::endl;
-      }
-// visualize_graph_cut(seg1, seg2);
-#endif
-      if (cost &gt; ncuts_threshold || 0 == seg1-&gt;size() || 0 == seg2-&gt;size()) {
-        std::vector&lt;int&gt; buffer;
-        for (size_t i = 0; i &lt; curr-&gt;size(); ++i) {
-          const int cid = (*curr)[i];
-          if (_cluster_labels[cid] != "unknown") {
-#ifdef DEBUG_NCUT
-            std::cout &lt;&lt; "cluster: " &lt;&lt; cid &lt;&lt; " as a segment (hit, "
-                      &lt;&lt; _cluster_labels[cid] &lt;&lt; ")" &lt;&lt; std::endl;
-#endif
-            std::vector&lt;int&gt; tmp(1, cid);
-            segment_clusters.push_back(tmp);
-            segment_labels.push_back(_cluster_labels[cid]);
-          } else {
-            buffer.push_back(cid);
-          }
-        }
-        if (buffer.size() &gt; 0) {
-          segment_clusters.push_back(buffer);
-          segment_labels.push_back("unknown");
-        }
-#ifdef DEBUG_NCUT
-        std::cout &lt;&lt; "cluster: ";
-        for (size_t i = 0; i &lt; buffer.size(); ++i) {
-          std::cout &lt;&lt; buffer[i] &lt;&lt; " ";
-        }
-        std::cout &lt;&lt; " as a segment (hit, unknown)" &lt;&lt; std::endl;
-#endif
-        delete seg1;
-        delete seg2;
-      } else {
-        job_stack.push(seg1);
-        job_stack.push(seg2);
-      }
-    }
-#ifdef DEBUG_NCUT
-    LOG_DEBUG &lt;&lt; "============================================================="
-                 "================";
-#endif
-    delete curr;
-  }  // end of while
-#ifdef DEBUG_NCUT
-  std::cout &lt;&lt; "graph cut return segments: " &lt;&lt; std::endl;
-  for (size_t i = 0; i &lt; segment_clusters.size(); ++i) {
-    std::cout &lt;&lt; "seg " &lt;&lt; i &lt;&lt; ": ";
-    for (size_t j = 0; j &lt; segment_clusters[i].size(); ++j) {
-      std::cout &lt;&lt; segment_clusters[i][j] &lt;&lt; " ";
-    }
-    std::cout &lt;&lt; ": " &lt;&lt; segment_labels[i] &lt;&lt; std::endl;
-  }
-  LOG_DEBUG &lt;&lt; "normalized_cut: " &lt;&lt; segment_clusters.size()
-            &lt;&lt; " segments from " &lt;&lt; _cluster_points.size() &lt;&lt; " clusters";
-// visualize_segments_from_cluster(segment_clusters);
-#endif
-}
-
-void NCut::ComputeSkeletonWeights(Eigen::MatrixXf *weights_in) {
-  Eigen::MatrixXf &amp;weights = *weights_in;
-  const int num_clusters = static_cast&lt;int&gt;(_cluster_points.size());
-  const double hs2 = _sigma_space * _sigma_space;
-  const double hf2 = _sigma_feature * _sigma_feature;
-  const double radius2 = _connect_radius * _connect_radius;
-  weights.resize(num_clusters, num_clusters);
-  for (int i = 0; i &lt; num_clusters; ++i) {
-    weights.coeffRef(i, i) = 1.f;
-    for (int j = i + 1; j &lt; num_clusters; ++j) {
-      float dist_point = std::numeric_limits&lt;float&gt;::max();
-      float dist_feature = std::numeric_limits&lt;float&gt;::max();
-      ComputeSquaredSkeletonDistance(
-          _cluster_skeleton_points[i], _cluster_skeleton_features[i],
-          _cluster_skeleton_points[j], _cluster_skeleton_features[j],
-          &amp;dist_point, &amp;dist_feature);
-      if (dist_point &gt; radius2) {
-        weights.coeffRef(i, j) = 0.f;
-        weights.coeffRef(j, i) = 0.f;
-      } else {
-        weights.coeffRef(i, j) = static_cast&lt;float&gt;(exp(-dist_point / hs2) *
-                                                    exp(-dist_feature / hf2));
-        weights.coeffRef(j, i) = weights.coeffRef(i, j);
-      }
-    }
-  }
-}
-
-float NCut::GetMinNcuts(const Eigen::MatrixXf &amp;in_weights,
-                        const std::vector&lt;int&gt; *in_clusters,
-                        std::vector&lt;int&gt; *seg1, std::vector&lt;int&gt; *seg2) {
-  // .0 initialization
-  const int num_clusters = static_cast&lt;int&gt;(in_weights.rows());
-  seg1-&gt;resize(num_clusters);
-  seg2-&gt;resize(num_clusters);
-  // .1 eigen decompostion
-  Eigen::MatrixXf eigenvectors;
-  LaplacianDecomposition(in_weights, &amp;eigenvectors);
-// std::cout &lt;&lt; "\nweights: " &lt;&lt; in_weights &lt;&lt; std::endl;
-// std::cout &lt;&lt; "\neigv: " &lt;&lt; eigenvectors &lt;&lt; std::endl;
-#ifdef DEBUG_NCUT
-// std::cout &lt;&lt; "weights:\n " &lt;&lt; in_weights &lt;&lt; std::endl &lt;&lt; std::endl;
-// std::cout &lt;&lt; "eigen vectors:\n " &lt;&lt; eigenvectors &lt;&lt; std::endl &lt;&lt; std::endl;
-#endif
-  // .2 search for best split
-  const float minval = eigenvectors.col(1).minCoeff();
-  const float maxval = eigenvectors.col(1).maxCoeff();
-  const float increment = static_cast&lt;float&gt;(
-      (maxval - minval) / (static_cast&lt;float&gt;(_num_cuts) + 1.0f));
-  int num_seg1 = 0;
-  int num_seg2 = 0;
-  float opt_split = 0.0;
-  float opt_cost = std::numeric_limits&lt;float&gt;::max();
-  for (int i = 0; i &lt; _num_cuts; ++i) {
-    num_seg1 = 0;
-    num_seg2 = 0;
-    // .2.1 split
-    float split =
-        static_cast&lt;float&gt;(minval + static_cast&lt;float&gt;(i + 1) * increment);
-    for (int j = 0; j &lt; num_clusters; ++j) {
-      if (eigenvectors.coeffRef(j, 1) &gt; split) {
-        (*seg1)[num_seg1++] = j;
-      } else {
-        (*seg2)[num_seg2++] = j;
-      }
-    }
-    // .2.2 compute best normalized_cuts cost
-    double assoc1 = 0.0;
-    double assoc2 = 0.0;
-    double cut = 0.0;
-    for (int j = 0; j &lt; num_seg1; ++j) {
-      assoc1 += in_weights.row(seg1-&gt;at(j)).sum();
-    }
-    for (int j = 0; j &lt; num_seg2; ++j) {
-      assoc2 += in_weights.row(seg2-&gt;at(j)).sum();
-    }
-    for (int j = 0; j &lt; num_seg1; ++j) {
-      for (int t = 0; t &lt; num_seg2; ++t) {
-        cut += in_weights.coeffRef(seg1-&gt;at(j), seg2-&gt;at(t));
-      }
-    }
-    float cost = static_cast&lt;float&gt;(cut / assoc1 + cut / assoc2);
-#ifdef DEBUG_NCUT
-    LOG_DEBUG &lt;&lt; "seg1: " &lt;&lt; num_seg1 &lt;&lt; ", seg2: " &lt;&lt; num_seg2 &lt;&lt; ", split "
-              &lt;&lt; split &lt;&lt; ", cut " &lt;&lt; cut &lt;&lt; ", assoc1 " &lt;&lt; assoc1
-              &lt;&lt; ", assoc2 " &lt;&lt; assoc2 &lt;&lt; ", cost " &lt;&lt; cost;
-#endif
-    // .2.3 find best cost
-    if (cost &lt; opt_cost) {
-      opt_cost = cost;
-      opt_split = split;
-    }
-  }
-  // .3 split data according to best split
-  num_seg1 = 0;
-  num_seg2 = 0;
-  for (int i = 0; i &lt; num_clusters; ++i) {
-    if (eigenvectors.coeffRef(i, 1) &gt; opt_split) {
-      (*seg1)[num_seg1++] = in_clusters-&gt;at(i);
-    } else {
-      (*seg2)[num_seg2++] = in_clusters-&gt;at(i);
-    }
-  }
-  seg1-&gt;resize(num_seg1);
-  seg2-&gt;resize(num_seg2);
-  return opt_cost;
-}
-
-void NCut::LaplacianDecomposition(const Eigen::MatrixXf &amp;weights,
-                                  Eigen::MatrixXf *eigenvectors_in) {
-#ifdef DEBUG_NCUT
-// std::cout &lt;&lt; "laplacian 0:\n " &lt;&lt; weights &lt;&lt; std::endl &lt;&lt; std::endl;
-#endif
-  Eigen::MatrixXf &amp;eigenvectors = *eigenvectors_in;
-  // .1 degree matrix: D = sum(W, 2)
-  Eigen::VectorXf diag(weights.rows());
-  for (int i = 0; i &lt; weights.rows(); ++i) {
-    diag.coeffRef(i) = weights.row(i).sum();
-  }
-  // .2 graph laplacian L = D - W
-  Eigen::MatrixXf laplacian(weights.rows(), weights.cols());
-  for (int i = 0; i &lt; laplacian.rows(); ++i) {
-    for (int j = 0; j &lt; laplacian.cols(); ++j) {
-      if (i == j) {
-        laplacian.coeffRef(i, j) = diag.coeffRef(i) - weights.coeffRef(i, j);
-      } else {
-        laplacian.coeffRef(i, j) = 0.f - weights.coeffRef(i, j);
-      }
-    }
-  }
-#ifdef DEBUG_NCUT
-// std::cout &lt;&lt; "laplacian 1:\n " &lt;&lt; laplacian &lt;&lt; std::endl &lt;&lt; std::endl;
-#endif
-  // .3 D^(-1/2)
-  Eigen::VectorXf diag_halfinv(weights.rows());
-  for (int i = 0; i &lt; weights.rows(); ++i) {
-    diag_halfinv.coeffRef(i) =
-        static_cast&lt;float&gt;(1.0 / std::sqrt(diag.coeffRef(i)));
-  }
-  // .4 normalized laplacian D^(-1/2) * L * D^(-1/2)
-  for (int i = 0; i &lt; laplacian.rows(); ++i) {
-    laplacian.row(i) *= diag_halfinv.coeffRef(i);
-  }
-  for (int j = 0; j &lt; laplacian.cols(); ++j) {
-    laplacian.col(j) *= diag_halfinv.coeffRef(j);
-  }
-  // .4.2 for numerical stability, add eps to the diagonal of laplacian
-  float eps = 1e-10f;
-  for (int i = 0; i &lt; laplacian.rows(); ++i) {
-    laplacian.coeffRef(i, i) += eps;
-  }
-#ifdef DEBUG_NCUT
-// std::cout &lt;&lt; "laplacian 2:\n " &lt;&lt; laplacian &lt;&lt; std::endl &lt;&lt; std::endl;
-#endif
-  // .5 solve eigen decompostion: TODO: lanczos
-  Eigen::EigenSolver&lt;MatrixXf&gt; eig_solver(laplacian);
-#ifdef DEBUG_NCUT
-// std::cout &lt;&lt; "eigvec 1:\n " &lt;&lt; eig_solver.eigenvectors() &lt;&lt; std::endl &lt;&lt;
-// std::endl;
-#endif
-  // .6 sort eigen values
-  std::vector&lt;std::pair&lt;float, int&gt;&gt; eigval(laplacian.rows());
-  for (size_t i = 0; i &lt; eigval.size(); ++i) {
-    eigval[i] = std::make_pair(eig_solver.eigenvalues()[i].real(), i);
-  }
-  std::sort(eigval.begin(), eigval.end(), std::less&lt;std::pair&lt;float, int&gt;&gt;());
-  // .7 get sorted eigen vectors
-  eigenvectors.resize(weights.rows(), weights.cols());
-  for (int i = 0; i &lt; eigenvectors.cols(); ++i) {
-    eigenvectors.col(i) =
-        eig_solver.eigenvectors().col(eigval[i].second).real();
-  }
-  for (int i = 0; i &lt; eigenvectors.rows(); ++i) {
-    eigenvectors.row(i) *= diag_halfinv.coeffRef(i);
-  }
-}
-
-bool NCut::ComputeSquaredSkeletonDistance(const Eigen::MatrixXf &amp;in1_points,
-                                          const Eigen::MatrixXf &amp;in1_features,
-                                          const Eigen::MatrixXf &amp;in2_points,
-                                          const Eigen::MatrixXf &amp;in2_features,
-                                          float *dist_point,
-                                          float *dist_feature) {
-  if (!((in1_points.rows() == in1_features.rows()) &amp;&amp;
-        (in2_points.rows() == in2_features.rows()))) {
-    return false;
-  }
-  const int num1 = static_cast&lt;int&gt;(in1_points.rows());
-  const int num2 = static_cast&lt;int&gt;(in2_points.rows());
-  const int dim = static_cast&lt;int&gt;(in1_features.cols());
-  int min_index1 = -1;
-  int min_index2 = -1;
-  float min_dist = std::numeric_limits&lt;float&gt;::max();
-  for (int i = 0; i &lt; num1; ++i) {
-    for (int j = 0; j &lt; num2; ++j) {
-      const float diff_x =
-          in1_points.coeffRef(i, 0) - in2_points.coeffRef(j, 0);
-      const float diff_y =
-          in1_points.coeffRef(i, 1) - in2_points.coeffRef(j, 1);
-      const float diff_z =
-          in1_points.coeffRef(i, 2) - in2_points.coeffRef(j, 2);
-      float dist = diff_x * diff_x + diff_y * diff_y + diff_z * diff_z;
-      if (dist &lt; min_dist) {
-        min_dist = dist;
-        min_index1 = i;
-        min_index2 = j;
-      }
-    }
-  }
-  *dist_point = min_dist;
-  *dist_feature = 0.f;
-  for (int i = 0; i &lt; dim; ++i) {
-    float diff = in1_features.coeffRef(min_index1, i) -
-                 in2_features.coeffRef(min_index2, i);
-    *dist_feature += diff * diff;
-  }
-  return true;
-}
-
-bool NCut::IsMovableObstacle(const std::vector&lt;int&gt; &amp;cluster_ids,
-                             std::string *label) {
-  NcutBoundingBox box;
-  GetComponentBoundingBox(cluster_ids, &amp;box);
-  float dummy_length = GetBboxLength(box);
-  float dummy_width = GetBboxWidth(box);
-  float length = std::max(dummy_length, dummy_width);
-  float width = std::min(dummy_length, dummy_width);
-  if (IsPotentialPedestrianSize(length, width) ||
-      IsPotentialBicyclistSize(length, width) ||
-      IsPotentialCarSize(length, width)) {
-    *label = GetClustersLabel(cluster_ids);
-    if (*label != "unknown" || *label != "background") {
-      return true;
-    }
-  }
-  return false;
-}
-
-std::string NCut::GetClustersLabel(const std::vector&lt;int&gt; &amp;cluster_ids) {
-  std::vector&lt;int&gt; point_ids;
-  GetClustersPids(cluster_ids, &amp;point_ids);
-  base::PointFCloudPtr cloud =
-      base::PointFCloudPtr(new base::PointFCloud(*_cloud_obstacles, point_ids));
-  return GetPcLabel(cloud);
-}
-
-void NCut::GetClustersPids(const std::vector&lt;int&gt; &amp;cids,
-                           std::vector&lt;int&gt; *pids_in) {
-  std::vector&lt;int&gt; &amp;pids = *pids_in;
-  int num_points = 0;
-  for (size_t i = 0; i &lt; cids.size(); ++i) {
-    num_points += static_cast&lt;int&gt;(_cluster_points[cids[i]].size());
-  }
-  pids.resize(num_points, -1);
-  int offset = 0;
-  for (size_t i = 0; i &lt; cids.size(); ++i) {
-    const std::vector&lt;int&gt; &amp;curr_pids = _cluster_points[cids[i]];
-    memcpy(pids.data() + offset, curr_pids.data(),
-           sizeof(int) * curr_pids.size());
-    offset += static_cast&lt;int&gt;(curr_pids.size());
-  }
-}
-
-int NCut::GetComponentBoundingBox(const std::vector&lt;int&gt; &amp;cluster_ids,
-                                  NcutBoundingBox *box_in) {
-  NcutBoundingBox &amp;box = *box_in;
-  if (cluster_ids.empty()) {
-    return 0;
-  }
-  int cid = cluster_ids[0];
-  float x_min = std::get&lt;0&gt;(_cluster_bounding_box[cid]);
-  float x_max = std::get&lt;1&gt;(_cluster_bounding_box[cid]);
-  float y_min = std::get&lt;2&gt;(_cluster_bounding_box[cid]);
-  float y_max = std::get&lt;3&gt;(_cluster_bounding_box[cid]);
-  float z_min = std::get&lt;4&gt;(_cluster_bounding_box[cid]);
-  float z_max = std::get&lt;5&gt;(_cluster_bounding_box[cid]);
-  int num_points = static_cast&lt;int&gt;(_cluster_points[cid].size());
-  for (size_t i = 1; i &lt; cluster_ids.size(); ++i) {
-    cid = cluster_ids[i];
-    x_min = std::min(x_min, std::get&lt;0&gt;(_cluster_bounding_box[cid]));
-    x_max = std::max(x_max, std::get&lt;1&gt;(_cluster_bounding_box[cid]));
-    y_min = std::min(y_min, std::get&lt;2&gt;(_cluster_bounding_box[cid]));
-    y_max = std::max(y_max, std::get&lt;3&gt;(_cluster_bounding_box[cid]));
-    z_min = std::min(y_min, std::get&lt;4&gt;(_cluster_bounding_box[cid]));
-    z_max = std::max(y_max, std::get&lt;5&gt;(_cluster_bounding_box[cid]));
-    num_points += static_cast&lt;int&gt;(_cluster_points[cid].size());
-  }
-  std::get&lt;0&gt;(box) = x_min;
-  std::get&lt;1&gt;(box) = x_max;
-  std::get&lt;2&gt;(box) = y_min;
-  std::get&lt;3&gt;(box) = y_max;
-  std::get&lt;4&gt;(box) = z_min;
-  std::get&lt;5&gt;(box) = z_max;
-  return num_points;
-}
-
-std::string NCut::GetPcRoughLabel(const base::PointFCloudPtr &amp;cloud,
-                                  bool only_check_pedestrian) {
-  if (cloud-&gt;size() &lt; OBSTACLE_MINIMUM_NUM_POINTS) {
-    return "unknown";
-  }
-  float x_max = -std::numeric_limits&lt;float&gt;::max();
-  float y_max = -std::numeric_limits&lt;float&gt;::max();
-  float x_min = std::numeric_limits&lt;float&gt;::max();
-  float y_min = std::numeric_limits&lt;float&gt;::max();
-  for (size_t i = 0; i &lt; cloud-&gt;size(); ++i) {
-    base::PointF pt = (*cloud)[i];
-    x_min = std::min(x_min, pt.x);
-    x_max = std::max(x_max, pt.x);
-    y_min = std::min(y_min, pt.y);
-    y_max = std::max(y_max, pt.y);
-  }
-  float dummy_length = x_max - x_min;
-  float dummy_width = y_max - y_min;
-  float length = std::max(dummy_length, dummy_width);
-  float width = std::min(dummy_length, dummy_width);
-  std::string label = "unknown";
-  bool is_candidate = false;
-  if (only_check_pedestrian) {
-    if (IsPotentialPedestrianSize(length, width) ||
-        IsPotentialBicyclistSize(length, width)) {
-      is_candidate = true;
-    }
-  } else {
-    if (IsPotentialPedestrianSize(length, width) ||
-        IsPotentialBicyclistSize(length, width) ||
-        IsPotentialCarSize(length, width)) {
-      is_candidate = true;
-    }
-  }
-  if (is_candidate) {
-    label = GetPcLabel(cloud);
-  }
-  return label;
-}
-
-void NCut::GetSegmentRoughSize(const base::PointFCloudPtr &amp;cloud, float *length,
-                               float *width, float *height) {
-  float x_max = -std::numeric_limits&lt;float&gt;::max();
-  float y_max = -std::numeric_limits&lt;float&gt;::max();
-  float z_max = -std::numeric_limits&lt;float&gt;::max();
-  float x_min = std::numeric_limits&lt;float&gt;::max();
-  float y_min = std::numeric_limits&lt;float&gt;::max();
-  float z_min = std::numeric_limits&lt;float&gt;::max();
-  for (size_t i = 0; i &lt; cloud-&gt;size(); ++i) {
-    base::PointF pt = (*cloud)[i];
-    x_min = std::min(x_min, pt.x);
-    x_max = std::max(x_max, pt.x);
-    y_min = std::min(y_min, pt.y);
-    y_max = std::max(y_max, pt.y);
-    z_min = std::min(z_min, pt.z);
-    z_max = std::max(z_max, pt.z);
-  }
-  *length = (x_max - x_min);
-  *width = (y_max - y_min);
-  *height = (z_max - z_min);
-}
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\ncut.h" new_path="" added_lines="0" deleted_lines="198">
				<diff>@@ -1,198 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;cmath&gt;
-#include &lt;cstdlib&gt;
-#include &lt;iostream&gt;
-#include &lt;map&gt;
-#include &lt;memory&gt;
-#include &lt;string&gt;
-#include &lt;tuple&gt;
-#include &lt;vector&gt;
-
-#include &lt;opencv2/opencv.hpp&gt;
-#include "Eigen/Core"
-
-#include "modules/perception/lidar/lib/segmentation/ncut/common/flood_fill.h"
-#include "modules/perception/lidar/lib/segmentation/ncut/common/lr_classifier.h"
-#include "modules/perception/lidar/lib/segmentation/ncut/proto/ncut_config.pb.h"
-#include "modules/perception/lidar/lib/segmentation/ncut/proto/ncut_param.pb.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-class NCut {
- public:
-  NCut();
-  ~NCut();
-  bool Init(const NCutParam&amp; param);
-
-  int NumSegments() const { return static_cast&lt;int&gt;(_segment_pids.size()); }
-  std::string GetSegmentLabel(int sid) const { return _segment_labels[sid]; }
-
-  void GetSegmentSize(int sid, float* length, float* width,
-                      float* height) const {
-    NcutBoundingBox box = _segment_bbox[sid];
-    *length = std::get&lt;1&gt;(box) - std::get&lt;0&gt;(box);
-    *width = std::get&lt;3&gt;(box) - std::get&lt;2&gt;(box);
-    *height = std::get&lt;5&gt;(box) - std::get&lt;4&gt;(box);
-  }
-
-  base::PointFCloudPtr GetSegmentPointCloud(int sid) const {
-    base::PointFCloudPtr pc = base::PointFCloudPtr(
-        new base::PointFCloud(*_cloud_obstacles, _segment_pids[sid]));
-    return pc;
-  }
-
-  void Segment(base::PointFCloudConstPtr cloud);
-
-  std::string GetPcRoughLabel(const base::PointFCloudPtr&amp; cloud,
-                              bool only_check_pedestrian);
-
-  void GetSegmentRoughSize(const base::PointFCloudPtr&amp; cloud, float* length,
-                           float* width, float* height);
-
- private:
-  struct gridIndex {
-    int irow;
-    int jcol;
-  };
-
-  // x_min, x_max, y_min, y_max, z_min, z_max;
-  typedef std::tuple&lt;float, float, float, float, float, float&gt; NcutBoundingBox;
-  base::PointFCloudPtr _cloud_obstacles;
-  // super pixels related
-  float _grid_radius;
-  float _super_pixel_cell_size;
-  std::unique_ptr&lt;LRClassifier&gt; _classifier;
-  // felzenszwalb
-  double _felzenszwalb_sigma;
-  double _felzenszwalb_k;
-  int _felzenszwalb_min_size;
-  // graph cut related
-  double _sigma_feature;
-  double _sigma_space;
-  double _connect_radius;
-  int _num_cuts;
-  float _ncuts_stop_threshold;
-  double _ncuts_enable_classifier_threshold;
-  // component (cluster) information
-  std::vector&lt;std::vector&lt;int&gt;&gt; _cluster_points;
-  // x_min, x_max, y_min, y_max, z_min, z_max;
-  std::vector&lt;NcutBoundingBox&gt; _cluster_bounding_box;
-  std::vector&lt;std::string&gt; _cluster_labels;
-  // skeleton related
-  float _skeleton_cell_size;  // skeleton sample size
-  int _patch_size;
-  cv::Mat _cv_feature_map;
-  FloodFill _ff_feature_grid;
-  std::vector&lt;Eigen::MatrixXf&gt; _cluster_skeleton_points;
-  std::vector&lt;Eigen::MatrixXf&gt; _cluster_skeleton_features;
-  // merge overlap
-  double _overlap_factor;
-  // final segments, each vector contains
-  std::vector&lt;std::vector&lt;int&gt;&gt; _segment_pids;
-  std::vector&lt;std::string&gt; _segment_labels;
-  std::vector&lt;NcutBoundingBox&gt; _segment_bbox;
-  std::vector&lt;std::vector&lt;int&gt;&gt; _outlier_pids;
-
-  void SampleByGrid(const std::vector&lt;int&gt;&amp; point_gids,
-                    Eigen::MatrixXf* skeleton_coords,
-                    Eigen::MatrixXf* skeleton_feature);
-
-  void PrecomputeAllSkeletonAndBbox();
-
-  bool Configure(const NCutParam&amp; ncut_param_);
-
-  void SuperPixelsFloodFill(base::PointFCloudConstPtr cloud, float radius,
-                            float cell_size,
-                            std::vector&lt;std::vector&lt;int&gt;&gt;* super_pixels);
-
-  // super pixels
-  void BuildAverageHeightMap(base::PointFCloudConstPtr cloud,
-                             const FloodFill&amp; ff_map, cv::Mat* cv_height_map,
-                             std::vector&lt;gridIndex&gt;* point_pixel_indices);
-
-  // skeleton
-  void GetPatchFeature(const Eigen::MatrixXf&amp; points,
-                       Eigen::MatrixXf* features);
-
-  // bounding box
-  NcutBoundingBox ComputeClusterBoundingBox(const std::vector&lt;int&gt;&amp; point_gids);
-
-  std::string GetPcLabel(const base::PointFCloudPtr&amp; cloud);
-
-  void NormalizedCut(float ncuts_threshold, bool use_classifier,
-                     std::vector&lt;std::vector&lt;int&gt;&gt;* segment_clusters,
-                     std::vector&lt;std::string&gt;* segment_labels);
-
-  void ComputeSkeletonWeights(Eigen::MatrixXf* weights);
-
-  float GetMinNcuts(const Eigen::MatrixXf&amp; in_weights,
-                    const std::vector&lt;int&gt;* in_clusters, std::vector&lt;int&gt;* seg1,
-                    std::vector&lt;int&gt;* seg2);
-
-  void LaplacianDecomposition(const Eigen::MatrixXf&amp; weights,
-                              Eigen::MatrixXf* eigenvectors);
-
-  bool ComputeSquaredSkeletonDistance(const Eigen::MatrixXf&amp; in1_points,
-                                      const Eigen::MatrixXf&amp; in1_features,
-                                      const Eigen::MatrixXf&amp; in2_points,
-                                      const Eigen::MatrixXf&amp; in2_features,
-                                      float* dist_point, float* dist_feature);
-
-  bool IsMovableObstacle(const std::vector&lt;int&gt;&amp; cluster_ids,
-                         std::string* label);
-
-  inline bool IsPotentialPedestrianSize(float length, float width) {
-    return ((length &gt; 0.5 &amp;&amp; length &lt; 1.5) &amp;&amp; (width &gt; 0.3 &amp;&amp; width &lt; 1));
-  }
-
-  inline bool IsPotentialBicyclistSize(float length, float width) {
-    return ((length &gt; 1 &amp;&amp; length &lt; 2.5) &amp;&amp; (width &gt; 0.3 &amp;&amp; width &lt; 1.5));
-  }
-
-  inline bool IsPotentialCarSize(float length, float width) {
-    // return ( (length &gt; 1.0 &amp;&amp; length &lt; 20.0) &amp;&amp; (width &gt; 1.0 &amp;&amp; width &lt; 3.5)
-    // );
-    return ((length &gt; 1.0 &amp;&amp; length &lt; 8.0) &amp;&amp; (width &gt; 1.0 &amp;&amp; width &lt; 3.5));
-  }
-
-  int GetComponentBoundingBox(const std::vector&lt;int&gt;&amp; cluster_ids,
-                              NcutBoundingBox* box);
-
-  inline float GetBboxLength(const NcutBoundingBox&amp; box) {
-    return (std::get&lt;1&gt;(box) - std::get&lt;0&gt;(box));
-  }
-
-  inline float GetBboxWidth(const NcutBoundingBox&amp; box) {
-    return (std::get&lt;3&gt;(box) - std::get&lt;2&gt;(box));
-  }
-
-  inline float GetBboxHeight(const NcutBoundingBox&amp; box) {
-    return (std::get&lt;5&gt;(box) - std::get&lt;4&gt;(box));
-  }
-
-  std::string GetClustersLabel(const std::vector&lt;int&gt;&amp; cluster_ids);
-
-  void GetClustersPids(const std::vector&lt;int&gt;&amp; cids, std::vector&lt;int&gt;* pids);
-};
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\ncut_segmentation.cc" new_path="" added_lines="0" deleted_lines="638">
				<diff>@@ -1,638 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-
-#include "modules/perception/lidar/lib/segmentation/ncut/ncut_segmentation.h"
-
-#include &lt;algorithm&gt;
-#include &lt;limits&gt;
-#include &lt;map&gt;
-
-#include &lt;omp.h&gt;
-
-#include "cyber/common/file.h"
-#include "cyber/common/log.h"
-#include "modules/perception/lib/config_manager/config_manager.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-using apollo::cyber::common::GetAbsolutePath;
-using apollo::cyber::common::GetProtoFromFile;
-using Eigen::MatrixXf;
-
-bool NCutSegmentation::Init(const LidarDetectorInitOptions&amp; options) {
-  std::string param_file;
-  ACHECK(GetConfigs(&amp;param_file));
-  AINFO &lt;&lt; "--    param_file: " &lt;&lt; param_file;
-
-  if (!Configure(param_file)) {
-    AERROR &lt;&lt; "failed to load ncut config.";
-    return false;
-  }
-
-  // init ground detector
-  ground_detector_ =
-      BaseGroundDetectorRegisterer::GetInstanceByName(ground_detector_str_);
-  CHECK_NOTNULL(ground_detector_);
-  GroundDetectorInitOptions ground_detector_init_options;
-  ACHECK(ground_detector_-&gt;Init(ground_detector_init_options))
-      &lt;&lt; "Failed to init ground detection.";
-
-  // init roi filter
-  roi_filter_ = BaseROIFilterRegisterer::GetInstanceByName(roi_filter_str_);
-  CHECK_NOTNULL(roi_filter_);
-  ROIFilterInitOptions roi_filter_init_options;
-  ACHECK(roi_filter_-&gt;Init(roi_filter_init_options))
-      &lt;&lt; "Failed to init roi filter.";
-
-  _outliers.reset(new std::vector&lt;ObjectPtr&gt;);
-  if (!_outliers) {
-    AERROR &lt;&lt; "Failed to reset outliers.";
-    return false;
-  }
-  int num_threads = 1;
-#pragma omp parallel
-  { num_threads = omp_get_num_threads(); }
-
-  AINFO &lt;&lt; "number threads " &lt;&lt; num_threads;
-  _segmentors.resize(num_threads);
-  for (int i = 0; i &lt; num_threads; ++i) {
-    _segmentors[i].reset(new NCut);
-    if (!(_segmentors[i]-&gt;Init(ncut_param_))) {
-      AERROR &lt;&lt; "failed to init NormalizedCut " &lt;&lt; i &lt;&lt; ".";
-      return false;
-    }
-  }
-
-  roi_cloud_ = base::PointFCloudPool::Instance().Get();
-  roi_world_cloud_ = base::PointDCloudPool::Instance().Get();
-
-  // init thread worker
-  worker_.Bind([&amp;]() {
-    ROIFilterOptions roi_filter_options;
-    if (lidar_frame_ref_-&gt;hdmap_struct != nullptr &amp;&amp;
-        roi_filter_-&gt;Filter(roi_filter_options, lidar_frame_ref_)) {
-      roi_cloud_-&gt;CopyPointCloud(*lidar_frame_ref_-&gt;cloud,
-                                 lidar_frame_ref_-&gt;roi_indices);
-      roi_world_cloud_-&gt;CopyPointCloud(*lidar_frame_ref_-&gt;world_cloud,
-                                       lidar_frame_ref_-&gt;roi_indices);
-    } else {
-      AINFO &lt;&lt; "Fail to call roi filter, use origin cloud.";
-      lidar_frame_ref_-&gt;roi_indices.indices.resize(original_cloud_-&gt;size());
-      // we manually fill roi indices with all cloud point indices
-      std::iota(lidar_frame_ref_-&gt;roi_indices.indices.begin(),
-                lidar_frame_ref_-&gt;roi_indices.indices.end(), 0);
-      // note roi cloud's memory should be kept here
-      *roi_cloud_ = *original_cloud_;
-      *roi_world_cloud_ = *original_world_cloud_;
-    }
-    lidar_frame_ref_-&gt;cloud = roi_cloud_;
-    lidar_frame_ref_-&gt;world_cloud = roi_world_cloud_;
-    AINFO &lt;&lt; "lidar 2 world pose " &lt;&lt; lidar_frame_ref_-&gt;lidar2world_pose(0, 3)
-          &lt;&lt; " " &lt;&lt; lidar_frame_ref_-&gt;lidar2world_pose(1, 3) &lt;&lt; " "
-          &lt;&lt; lidar_frame_ref_-&gt;lidar2world_pose(2, 3);
-    GroundDetectorOptions ground_detector_options;
-    ground_detector_-&gt;Detect(ground_detector_options, lidar_frame_ref_);
-    return true;
-  });
-
-  worker_.Start();
-
-#ifdef DEBUG_NCUT
-  _viewer = pcl::visualization::PCLVisualizer::Ptr(
-      new pcl::visualization::PCLVisualizer("3D Viewer"));
-  _viewer-&gt;setBackgroundColor(0, 0, 0);
-  _viewer-&gt;addCoordinateSystem(1.0);
-  _viewer-&gt;initCameraParameters();
-  _viewer_count = 0;
-  _rgb_cloud = CPointCloudPtr(new CPointCloud);
-#endif
-
-  AINFO &lt;&lt; "NCutSegmentation init success, num_threads: " &lt;&lt; num_threads;
-  return true;
-}
-
-bool NCutSegmentation::Configure(std::string param_file) {
-  NCutSegmentationParam seg_param_;
-  // get cnnseg params
-  ACHECK(GetProtoFromFile(param_file, &amp;seg_param_))
-      &lt;&lt; "Failed to parse CNNSegParam config file." &lt;&lt; param_file;
-  grid_radius_ = seg_param_.grid_radius();
-  height_threshold_ = seg_param_.height_threshold();
-  partition_cell_size_ = seg_param_.partition_cell_size();
-  vehicle_filter_cell_size_ = seg_param_.vehicle_filter_cell_size();
-  pedestrian_filter_cell_size_ = seg_param_.pedestrian_filter_cell_size();
-  outlier_length_ = seg_param_.outlier_length();
-  outlier_width_ = seg_param_.outlier_width();
-  outlier_height_ = seg_param_.outlier_height();
-  outlier_min_num_points_ = seg_param_.outlier_min_num_points();
-  remove_ground_ = seg_param_.remove_ground_points();
-  remove_roi_ = seg_param_.remove_roi();
-  ground_detector_str_ = seg_param_.ground_detector();
-  roi_filter_str_ = seg_param_.roi_filter();
-  ncut_param_ = seg_param_.ncut_param();
-  do_classification_ = seg_param_.do_classification();
-  AINFO &lt;&lt; "NCut Segmentation " &lt;&lt; seg_param_.DebugString();
-  return true;
-}
-
-bool NCutSegmentation::GetConfigs(std::string* param_file) {
-  auto config_manager = lib::ConfigManager::Instance();
-  const lib::ModelConfig* model_config = nullptr;
-  ACHECK(config_manager-&gt;GetModelConfig("NCutSegmentation", &amp;model_config))
-      &lt;&lt; "Failed to get model config: CNNSegmentation";
-
-  const std::string&amp; work_root = config_manager-&gt;work_root();
-  std::string root_path;
-  ACHECK(model_config-&gt;get_value("root_path", &amp;root_path))
-      &lt;&lt; "Failed to get value of root_path.";
-  std::string config_file;
-  config_file = GetAbsolutePath(work_root, root_path);
-  config_file = GetAbsolutePath(config_file, "ncut.conf");
-
-  NCutConfig config;
-  ACHECK(apollo::cyber::common::GetProtoFromFile(config_file, &amp;config))
-      &lt;&lt; "Failed to parse CNNSeg config file";
-  *param_file = GetAbsolutePath(work_root, config.param_file());
-  return true;
-}
-
-bool NCutSegmentation::Detect(const LidarDetectorOptions&amp; options,
-                               LidarFrame* frame) {
-  // check input
-  if (frame == nullptr) {
-    AERROR &lt;&lt; "Input null frame ptr.";
-    return false;
-  }
-  if (frame-&gt;cloud == nullptr) {
-    AERROR &lt;&lt; "Input null frame cloud.";
-    return false;
-  }
-  if (frame-&gt;world_cloud == nullptr) {
-    AERROR &lt;&lt; "Input null frame world cloud.";
-    return false;
-  }
-  if (frame-&gt;cloud-&gt;size() == 0) {
-    AERROR &lt;&lt; "Input none points.";
-    return false;
-  }
-  if (frame-&gt;cloud-&gt;size() != frame-&gt;world_cloud-&gt;size()) {
-    AERROR &lt;&lt; "Cloud size and world cloud size not consistent.";
-    return false;
-  }
-
-  // record input cloud and lidar frame
-  original_cloud_ = frame-&gt;cloud;
-  original_world_cloud_ = frame-&gt;world_cloud;
-  lidar_frame_ref_ = frame;
-
-  std::vector&lt;base::ObjectPtr&gt;* segments = &amp;(frame-&gt;segmented_objects);
-  double start_t = omp_get_wtime();
-  int num_threads = 1;
-#pragma omp parallel
-  { num_threads = omp_get_num_threads(); }
-
-  AINFO &lt;&lt; "input point cloud: " &lt;&lt; original_cloud_-&gt;size() &lt;&lt; " points";
-#ifdef DEBUG_NCUT
-  VisualizePointCloud(original_cloud_);
-#endif
-
-  if (remove_roi_) {
-    AINFO &lt;&lt; "remove roi and remove ground for ncut segmentation";
-    worker_.WakeUp();
-    worker_.Join();
-  }
-
-  base::PointFCloudPtr cloud_above_ground(new base::PointFCloud);
-  if (remove_ground_) {
-    AINFO &lt;&lt; "remove ground";
-    cloud_above_ground-&gt;CopyPointCloud(*lidar_frame_ref_-&gt;cloud,
-                                       lidar_frame_ref_-&gt;non_ground_indices);
-  } else {
-    // if used as secondary segmentor, got from cloud directly
-    cloud_above_ground-&gt;CopyPointCloud(*lidar_frame_ref_-&gt;cloud,
-                                       lidar_frame_ref_-&gt;secondary_indices);
-  }
-
-#ifdef DEBUG_NCUT
-  // filter_by_ground(cloud, non_ground_indices, &amp;cloud_above_ground);
-  AINFO &lt;&lt; "filter ground, elapsed time: " &lt;&lt; omp_get_wtime() - start_t
-        &lt;&lt; cloud_above_ground-&gt;size() &lt;&lt; " points left";
-  start_t = omp_get_wtime();
-  VisualizePointCloud(cloud_above_ground);
-#endif
-
-  // .3 filter vehicle
-  base::PointFCloudPtr cloud_after_car_filter;
-  ObstacleFilter(cloud_above_ground, vehicle_filter_cell_size_, false,
-                 &amp;cloud_after_car_filter, segments);
-#ifdef DEBUG_NCUT
-  AINFO &lt;&lt; "filter vehicle, elapsed time: " &lt;&lt; omp_get_wtime() - start_t
-        &lt;&lt; "filter vehicle: " &lt;&lt; cloud_after_car_filter-&gt;size()
-        &lt;&lt; " points left";
-  start_t = omp_get_wtime();
-  VisualizePointCloud(cloud_after_car_filter);
-#endif
-
-  // .4 filter pedestrian
-  base::PointFCloudPtr cloud_after_people_filter;
-  ObstacleFilter(cloud_after_car_filter, pedestrian_filter_cell_size_, true,
-                 &amp;cloud_after_people_filter, segments);
-
-#ifdef DEBUG_NCUT
-  AINFO &lt;&lt; "filter pedestrian, elapsed time: " &lt;&lt; omp_get_wtime() - start_t;
-  start_t = omp_get_wtime();
-  AINFO &lt;&lt; "filter pedestrian: " &lt;&lt; cloud_after_people_filter-&gt;size()
-        &lt;&lt; " points left";
-  VisualizePointCloud(cloud_after_people_filter);
-  AINFO &lt;&lt; "after filter car/pedestrian #segments " &lt;&lt; segments-&gt;size();
-// VisualizeSegments(*segments);
-#endif
-
-  // .5 partition into small regions
-  std::vector&lt;base::PointFCloudPtr&gt; cloud_components;
-  PartitionConnectedComponents(cloud_after_people_filter, partition_cell_size_,
-                               &amp;cloud_components);
-
-#ifdef DEBUG_NCUT
-  AINFO &lt;&lt; "partition small regions, elapsed time: "
-        &lt;&lt; omp_get_wtime() - start_t;
-  start_t = omp_get_wtime();
-  AINFO &lt;&lt; "partition " &lt;&lt; cloud_components.size() &lt;&lt; " components";
-#endif
-
-  std::vector&lt;bool&gt; cloud_outlier_flag(cloud_components.size());
-
-#pragma omp parallel
-  {
-#pragma omp for
-    for (size_t i = 0; i &lt; cloud_components.size(); ++i) {
-      cloud_outlier_flag[i] = IsOutlier(cloud_components[i]);
-    }
-  }
-
-  std::vector&lt;int&gt; cloud_outlier;
-  std::vector&lt;int&gt; cloud_tbd;
-  for (int i = 0; i &lt; static_cast&lt;int&gt;(cloud_components.size()); ++i) {
-    if (cloud_outlier_flag[i]) {
-      cloud_outlier.push_back(i);
-    } else {
-      cloud_tbd.push_back(i);
-    }
-  }
-
-  // .5.1 outlier
-  for (size_t i = 0; i &lt; cloud_outlier.size(); ++i) {
-    base::PointFCloudPtr pc = cloud_components[cloud_outlier[i]];
-    base::ObjectPtr obj(new base::Object);
-    obj-&gt;lidar_supplement.cloud = *pc;
-    _outliers-&gt;push_back(obj);
-  }
-#ifdef DEBUG_NCUT
-  AINFO &lt;&lt; "filter outlier, elapsed time: " &lt;&lt; omp_get_wtime() - start_t;
-  start_t = omp_get_wtime();
-#endif
-  // .6 graph cut each
-  std::vector&lt;std::vector&lt;base::PointFCloudPtr&gt;&gt; threads_segment_pcs(
-      num_threads);
-  std::vector&lt;std::vector&lt;std::string&gt;&gt; threads_segment_labels(num_threads);
-  std::vector&lt;std::vector&lt;base::PointFCloudPtr&gt;&gt; threads_outlier_pcs(
-      num_threads);
-// .6.1 process each component in parallel
-#pragma omp parallel
-  {
-    int tid = omp_get_thread_num();
-    std::shared_ptr&lt;NCut&gt; my_ncut = _segmentors[tid];
-    std::vector&lt;base::PointFCloudPtr&gt;&amp; my_segment_pcs =
-        threads_segment_pcs[tid];
-    std::vector&lt;std::string&gt;&amp; my_segment_labels = threads_segment_labels[tid];
-    std::vector&lt;base::PointFCloudPtr&gt;&amp; my_outlier_pcs =
-        threads_outlier_pcs[tid];
-
-#pragma omp for schedule(guided)
-    for (size_t i = 0; i &lt; cloud_tbd.size(); ++i) {
-      my_ncut-&gt;Segment(cloud_components[cloud_tbd[i]]);
-      ADEBUG &lt;&lt; "after segment with num segments" &lt;&lt; my_ncut-&gt;NumSegments();
-      for (int j = 0; j &lt; my_ncut-&gt;NumSegments(); ++j) {
-        base::PointFCloudPtr pc = my_ncut-&gt;GetSegmentPointCloud(j);
-        std::string label = my_ncut-&gt;GetSegmentLabel(j);
-        if (IsOutlier(pc)) {
-          my_outlier_pcs.push_back(pc);
-        } else {
-          my_segment_pcs.push_back(pc);
-          my_segment_labels.push_back(label);
-        }
-      }
-    }
-  }
-#ifdef DEBUG_NCUT
-  ADEBUG &lt;&lt; "parallel normalized cut, elapsed time: "
-         &lt;&lt; omp_get_wtime() - start_t;
-  start_t = omp_get_wtime();
-#endif
-  // .6.2 aggregate results
-  std::vector&lt;int&gt; segment_offset(num_threads,
-                                  static_cast&lt;int&gt;(segments-&gt;size()));
-  for (int i = 1; i &lt; num_threads; ++i) {
-    segment_offset[i] = segment_offset[i - 1] +
-                        static_cast&lt;int&gt;(threads_segment_pcs[i - 1].size());
-  }
-  int new_num_segments =
-      static_cast&lt;int&gt;(threads_segment_pcs[num_threads - 1].size()) +
-      segment_offset[num_threads - 1];
-  segments-&gt;resize(new_num_segments);
-#pragma omp parallel for
-  for (int i = 0; i &lt; num_threads; ++i) {
-    int offset = segment_offset[i];
-    for (size_t j = 0; j &lt; threads_segment_pcs[i].size(); ++j) {
-      base::ObjectPtr&amp; obj_ptr = (*segments)[offset + j];
-      obj_ptr.reset(new base::Object());
-      obj_ptr-&gt;lidar_supplement.cloud = *threads_segment_pcs[i][j];
-
-      if (do_classification_) {
-        obj_ptr-&gt;type = Label2Type(threads_segment_labels[i][j]);
-      }
-    }
-  }
-  std::vector&lt;int&gt; outlier_offset(num_threads,
-                                  static_cast&lt;int&gt;(_outliers-&gt;size()));
-  for (int i = 1; i &lt; num_threads; ++i) {
-    outlier_offset[i] = outlier_offset[i - 1] +
-                        static_cast&lt;int&gt;(threads_outlier_pcs[i - 1].size());
-  }
-  int new_num_outliers =
-      static_cast&lt;int&gt;(threads_outlier_pcs[num_threads - 1].size()) +
-      outlier_offset[num_threads - 1];
-  _outliers-&gt;resize(new_num_outliers);
-#pragma omp parallel for
-  for (int i = 0; i &lt; num_threads; ++i) {
-    int offset = outlier_offset[i];
-    for (size_t j = 0; j &lt; threads_outlier_pcs[i].size(); ++j) {
-      base::ObjectPtr&amp; obj_ptr = (*_outliers)[offset + j];
-      obj_ptr.reset(new base::Object);
-      obj_ptr-&gt;lidar_supplement.cloud = *threads_outlier_pcs[i][j];
-    }
-  }
-  AINFO &lt;&lt; "aggregate results, elapsed time: " &lt;&lt; omp_get_wtime() - start_t;
-  AINFO &lt;&lt; "final #segments " &lt;&lt; segments-&gt;size();
-  AINFO &lt;&lt; "final #outliers " &lt;&lt; _outliers-&gt;size();
-
-#ifdef DEBUG_NCUT
-  VisualizeSegments(*segments);
-  VisualizeSegments(*_outliers);
-#endif
-
-  return true;
-}
-
-base::ObjectType NCutSegmentation::Label2Type(const std::string&amp; label) {
-  if (label == "unknown") {
-    return base::ObjectType::UNKNOWN;
-  }
-  if (label == "nonMot") {
-    return base::ObjectType::BICYCLE;
-  }
-  if (label == "pedestrian") {
-    return base::ObjectType::PEDESTRIAN;
-  }
-  if (label == "smallMot") {
-    return base::ObjectType::VEHICLE;
-  }
-  return base::ObjectType::UNKNOWN;
-}
-
-void NCutSegmentation::PartitionConnectedComponents(
-    const base::PointFCloudPtr&amp; in_cloud, float cell_size,
-    std::vector&lt;base::PointFCloudPtr&gt;* out_clouds) {
-  std::vector&lt;base::PointFCloudPtr&gt;&amp; temp_clouds = *out_clouds;
-  FloodFill FFfilter(grid_radius_, cell_size);
-  std::vector&lt;std::vector&lt;int&gt;&gt; component_points;
-  std::vector&lt;int&gt; num_cells_per_components;
-  FFfilter.GetSegments(in_cloud, &amp;component_points, &amp;num_cells_per_components);
-  temp_clouds.resize(component_points.size());
-  for (size_t i = 0; i &lt; component_points.size(); ++i) {
-    temp_clouds[i] = base::PointFCloudPtr(
-        new base::PointFCloud(*in_cloud, component_points[i]));
-  }
-}
-
-void NCutSegmentation::ObstacleFilter(const base::PointFCloudPtr&amp; in_cloud,
-                                      float cell_size,
-                                      bool filter_pedestrian_only,
-                                      base::PointFCloudPtr* out_cloud,
-                                      std::vector&lt;base::ObjectPtr&gt;* segments) {
-  FloodFill FFfilter(grid_radius_, cell_size);
-  std::vector&lt;std::vector&lt;int&gt;&gt; component_points;
-  std::vector&lt;int&gt; num_cells_per_components;
-  FFfilter.GetSegments(in_cloud, &amp;component_points, &amp;num_cells_per_components);
-
-#ifdef DEBUG_NCUT
-  AINFO &lt;&lt; "flood fill: " &lt;&lt; component_points.size() &lt;&lt; " components";
-// VisualizeComponents(in_cloud, component_points);
-#endif
-
-  const unsigned int min_num_points = 50;
-  const int num_components = static_cast&lt;int&gt;(component_points.size());
-  std::vector&lt;std::string&gt; component_labels(num_components, "unknown");
-  int tid = 0;
-  for (int i = 0; i &lt; num_components; ++i) {
-    if (component_points[i].size() &gt; min_num_points) {
-      base::PointFCloudPtr pc = base::PointFCloudPtr(
-          new base::PointFCloud(*in_cloud, component_points[i]));
-      std::string label =
-          _segmentors[tid]-&gt;GetPcRoughLabel(pc, filter_pedestrian_only);
-      AINFO &lt;&lt; "before: component id: " &lt;&lt; i &lt;&lt; ", label: " &lt;&lt; label;
-      if (filter_pedestrian_only) {
-        label =
-            (label == "pedestrian" || label == "nonMot") ? label : "unknown";
-      }
-      AINFO &lt;&lt; "after: component id: " &lt;&lt; i &lt;&lt; ", label: " &lt;&lt; label;
-      component_labels[i] = label;
-    }
-  }  // end of for
-
-  AINFO &lt;&lt; "classification done";
-  std::vector&lt;int&gt; remaining_pids;
-  std::vector&lt;int&gt; obstacle_components;
-  for (int i = 0; i &lt; num_components; ++i) {
-    if (component_labels[i] != "unknown") {
-      obstacle_components.push_back(i);
-    } else {
-      remaining_pids.insert(remaining_pids.begin(), component_points[i].begin(),
-                            component_points[i].end());
-    }
-  }
-  AINFO &lt;&lt; "obstacle_filter: filter unknown out, obstacle_components.size = "
-        &lt;&lt; obstacle_components.size()
-        &lt;&lt; ", remaining_pids.size = " &lt;&lt; remaining_pids.size();
-  int offset = static_cast&lt;int&gt;(segments-&gt;size());
-  segments-&gt;resize(offset + obstacle_components.size());
-  for (size_t i = 0; i &lt; obstacle_components.size(); ++i) {
-    int cid = obstacle_components[i];
-    ObjectPtr&amp; object_ptr = (*segments)[offset + i];
-    object_ptr.reset(new base::Object);
-    object_ptr-&gt;lidar_supplement.cloud.CopyPointCloud(*in_cloud,
-                                                      component_points[cid]);
-  }
-  *out_cloud =
-      base::PointFCloudPtr(new base::PointFCloud(*in_cloud, remaining_pids));
-}
-
-bool NCutSegmentation::IsOutlier(const base::PointFCloudPtr&amp; in_cloud) {
-  size_t min_num_points = std::max(outlier_min_num_points_, 1);
-  if (in_cloud-&gt;size() &lt; min_num_points) {
-    return true;
-  }
-  float x_max = -std::numeric_limits&lt;float&gt;::max();
-  float y_max = -std::numeric_limits&lt;float&gt;::max();
-  float z_max = -std::numeric_limits&lt;float&gt;::max();
-  float x_min = std::numeric_limits&lt;float&gt;::max();
-  float y_min = std::numeric_limits&lt;float&gt;::max();
-  float z_min = std::numeric_limits&lt;float&gt;::max();
-  base::PointF pt_max = (*in_cloud)[0];
-  for (size_t i = 0; i &lt; in_cloud-&gt;size(); ++i) {
-    const base::PointF&amp; pt = (*in_cloud)[i];
-    x_min = std::min(x_min, pt.x);
-    x_max = std::max(x_max, pt.x);
-    y_min = std::min(y_min, pt.y);
-    y_max = std::max(y_max, pt.y);
-    z_min = std::min(z_min, pt.z);
-    if (pt.z &gt; z_max) {
-      z_max = pt.z;
-      pt_max = pt;
-    }
-  }
-  float length = x_max - x_min;
-  float width = y_max - y_min;
-  float height = z_max - z_min;
-  if (length &lt; outlier_length_ &amp;&amp; width &lt; outlier_width_) {
-    return true;
-  }
-  if (height &lt; outlier_height_) {
-    return true;
-  }
-  // std::pair&lt;float, bool&gt; dist = _ground_detector.distance_to_ground(pt_max);
-  // if (dist.second &amp;&amp; dist.first &lt; _outlier_height) {
-  //    return true;
-  //}
-  return false;
-}
-
-#ifdef DEBUG_NCUT
-void NCutSegmentation::VisualizePointCloud(const base::PointFCloudPtr&amp; cloud) {
-  // _viewer-&gt;removePointCloud(_viewer_id, 0);
-  _viewer-&gt;removeAllPointClouds(0);
-  _viewer-&gt;removeAllShapes(0);
-  _rgb_cloud-&gt;clear();
-  for (size_t i = 0; i &lt; cloud-&gt;size(); ++i) {
-    CPoint pt;
-    pt.x = (*cloud)[i].x;
-    pt.y = (*cloud)[i].y;
-    pt.z = (*cloud)[i].z;
-    pt.r = 255;
-    pt.g = 255;
-    pt.b = 255;
-    _rgb_cloud-&gt;push_back(pt);
-  }
-  snprintf(_viewer_id, sizeof(_viewer_id), "vis%06d", _viewer_count++);
-  _viewer-&gt;addPointCloud(_rgb_cloud, _viewer_id, 0);
-  _viewer-&gt;spin();
-}
-
-void NCutSegmentation::VisualizeSegments(
-    const std::vector&lt;base::ObjectPtr&gt;&amp; segments) {
-  // _viewer-&gt;removePointCloud(_viewer_id, 0);
-  unsigned int seed;
-  _viewer-&gt;removeAllPointClouds(0);
-  _viewer-&gt;removeAllShapes(0);
-  _rgb_cloud-&gt;clear();
-  for (size_t i = 0; i &lt; segments.size(); ++i) {
-    int red = 50 + rand_r(&amp;seed) % 206;
-    int green = 50 + rand_r(&amp;seed) % 206;
-    int blue = 50 + rand_r(&amp;seed) % 206;
-    const base::PointFCloud&amp; pc = segments[i]-&gt;lidar_supplement.cloud;
-    for (size_t j = 0; j &lt; pc.size(); ++j) {
-      CPoint pt;
-      pt.x = pc[j].x;
-      pt.y = pc[j].y;
-      pt.z = pc[j].z;
-      pt.r = static_cast&lt;uint8_t&gt;(red);
-      pt.g = static_cast&lt;uint8_t&gt;(green);
-      pt.b = static_cast&lt;uint8_t&gt;(blue);
-      _rgb_cloud-&gt;push_back(pt);
-    }
-  }
-  snprintf(_viewer_id, sizeof(_viewer_id), "vis%06d", _viewer_count++);
-  _viewer-&gt;addPointCloud(_rgb_cloud, _viewer_id, 0);
-  _viewer-&gt;spin();
-}
-
-void NCutSegmentation::VisualizeComponents(
-    const base::PointFCloudPtr&amp; cloud,
-    const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; component_points) {
-  // _viewer-&gt;removePointCloud(_viewer_id, 0);
-  unsigned int seed;
-  _viewer-&gt;removeAllPointClouds(0);
-  _viewer-&gt;removeAllShapes(0);
-  _rgb_cloud-&gt;clear();
-  std::vector&lt;CPoint&gt; centers(component_points.size());
-  for (size_t i = 0; i &lt; component_points.size(); ++i) {
-    int red = 50 + rand_r(&amp;seed) % 206;
-    int green = 50 + rand_r(&amp;seed) % 206;
-    int blue = 50 + rand_r(&amp;seed) % 206;
-    const int num_points = static_cast&lt;int&gt;(component_points[i].size());
-    CPoint center;
-    center.x = 0.f;
-    center.y = 0.f;
-    center.z = 0.f;
-    for (size_t j = 0; j &lt; component_points[i].size(); ++j) {
-      CPoint pt;
-      int pid = component_points[i][j];
-      pt.x = (*cloud)[pid].x;
-      pt.y = (*cloud)[pid].y;
-      pt.z = (*cloud)[pid].z;
-      pt.r = static_cast&lt;uint8_t&gt;(red);
-      pt.g = static_cast&lt;uint8_t&gt;(green);
-      pt.b = static_cast&lt;uint8_t&gt;(blue);
-      _rgb_cloud-&gt;push_back(pt);
-      center.x += pt.x;
-      center.y += pt.y;
-      center.z += pt.z;
-    }
-    center.x /= static_cast&lt;float&gt;(num_points);
-    center.y /= static_cast&lt;float&gt;(num_points);
-    center.z /= static_cast&lt;float&gt;(num_points);
-    centers[i] = center;
-  }
-  snprintf(_viewer_id, sizeof(_viewer_id), "vis%06d", _viewer_count++);
-  _viewer-&gt;addPointCloud(_rgb_cloud, _viewer_id, 0);
-  for (size_t i = 0; i &lt; component_points.size(); ++i) {
-    char text[256];
-    char text_id[256];
-    snprintf(text, sizeof(text), "%zu", i);
-    snprintf(text_id, sizeof(text_id), "c%zu", i);
-    _viewer-&gt;addText3D(text, centers[i], 0.3, 1.0, 1.0, 1.0, text_id, 0);
-  }
-  _viewer-&gt;spin();
-}
-#endif
-
-PERCEPTION_REGISTER_LIDARDETECTOR(NCutSegmentation);
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\segmentation\ncut\ncut_segmentation.h" new_path="" added_lines="0" deleted_lines="125">
				<diff>@@ -1,125 +0,0 @@
-/******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *****************************************************************************/
-#pragma once
-
-#include &lt;memory&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#ifdef DEBUG_NCUT
-#include "pcl/visualization/pcl_visualizer.h"
-#endif
-
-#include "modules/perception/base/object.h"
-#include "modules/perception/lib/thread/thread_worker.h"
-#include "modules/perception/lidar/common/pcl_util.h"
-#include "modules/perception/lidar/lib/interface/base_ground_detector.h"
-#include "modules/perception/lidar/lib/interface/base_roi_filter.h"
-#include "modules/perception/lidar/lib/interface/base_lidar_detector.h"
-#include "modules/perception/lidar/lib/segmentation/ncut/ncut.h"
-#include "modules/perception/lidar/lib/segmentation/ncut/proto/ncut_param.pb.h"
-
-namespace apollo {
-namespace perception {
-namespace lidar {
-
-using base::ObjectPtr;
-
-class NCutSegmentation : public BaseLidarDetector {
- public:
-  NCutSegmentation() = default;
-  virtual ~NCutSegmentation() = default;
-
-  bool Init(const LidarDetectorInitOptions&amp; options =
-                LidarDetectorInitOptions()) override;
-
-  bool Detect(const LidarDetectorOptions&amp; options, LidarFrame* frame) override;
-
-  std::string Name() const override { return "NCutSegmentation"; }
-
-  void ByPassROIService() {
-    remove_roi_ = false;
-    remove_ground_ = false;
-  }
-
- private:
-  bool Configure(std::string model_name);
-
-  void PartitionConnectedComponents(
-      const base::PointFCloudPtr&amp; in_cloud, float cell_size,
-      std::vector&lt;base::PointFCloudPtr&gt;* out_clouds);
-
-  void ObstacleFilter(const base::PointFCloudPtr&amp; in_cloud, float cell_size,
-                      bool filter_pedestrian_only,
-                      base::PointFCloudPtr* out_cloud,
-                      std::vector&lt;base::ObjectPtr&gt;* segments);
-
-  bool IsOutlier(const base::PointFCloudPtr&amp; in_cloud);
-
-  bool GetConfigs(std::string* ncut_file);
-
-  base::ObjectType Label2Type(const std::string&amp; label);
-
-  // ground detector for background segmentation
-  BaseGroundDetector* ground_detector_;
-  // roi filter for background segmentation
-  BaseROIFilter* roi_filter_;
-
-  // reference pointer of lidar frame
-  LidarFrame* lidar_frame_ref_ = nullptr;
-  std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointF&gt;&gt; original_cloud_;
-  std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointD&gt;&gt;
-      original_world_cloud_;
-  std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointF&gt;&gt; roi_cloud_;
-  std::shared_ptr&lt;base::AttributePointCloud&lt;base::PointD&gt;&gt; roi_world_cloud_;
-  // thread worker
-  lib::ThreadWorker worker_;
-
-  std::vector&lt;std::shared_ptr&lt;NCut&gt;&gt; _segmentors;
-  // for outliers, must be "unknown"
-  std::unique_ptr&lt;std::vector&lt;ObjectPtr&gt;&gt; _outliers;
-  float grid_radius_ = 100.0f;
-  float height_threshold_ = 2.5f;
-  float partition_cell_size_ = 1.0f;
-  float vehicle_filter_cell_size_ = 1.0f;
-  float pedestrian_filter_cell_size_ = 0.05f;
-  float outlier_length_ = 0.3f;
-  float outlier_width_ = 0.3f;
-  float outlier_height_ = 0.3f;
-  int outlier_min_num_points_ = 10;
-  bool remove_ground_ = true;
-  bool remove_roi_ = true;
-  bool do_classification_ = true;
-  std::string ground_detector_str_;
-  std::string roi_filter_str_;
-  NCutParam ncut_param_;
-
-#ifdef DEBUG_NCUT
-  pcl::visualization::PCLVisualizer::Ptr _viewer;
-  CPointCloudPtr _rgb_cloud;
-  char _viewer_id[128];
-  int _viewer_count;
-  void VisualizePointCloud(const base::PointFCloudPtr&amp; cloud);
-  void VisualizeSegments(const std::vector&lt;base::ObjectPtr&gt;&amp; segments);
-  void VisualizeComponents(
-      const base::PointFCloudPtr&amp; cloud,
-      const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; component_points);
-#endif
-};  // class NCutSegmentation
-
-}  // namespace lidar
-}  // namespace perception
-}  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne128\lidar_obstacle_detection.conf" new_path="modules\perception\production\data\perception\lidar\models\lidar_obstacle_pipeline\velodyne128\lidar_obstacle_detection.conf" added_lines="1" deleted_lines="1">
				<diff>@@ -1,4 +1,4 @@
 preprocessor: "PointCloudPreprocessor"
-detector: "PointPillarsDetection"
+detector: "CNNSegmentation"
 use_map_manager: true
 use_object_filter_bank: true
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="84e5b617c2da310cd6d53b29f3b4f36c78cae3ef" author="haina0421">
		<msg>Solve CI problems according to code standard</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\app\lidar_app_lidar_pipeline_test.cc" new_path="modules\perception\lidar\app\lidar_app_lidar_pipeline_test.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -17,7 +17,7 @@
 
 #include "modules/perception/common/io/io_util.h"
 #include "modules/perception/common/perception_gflags.h"
-#include "modules/perception/lidar/app/lidar_obstacle_segmentation.h"
+#include "modules/perception/lidar/app/lidar_obstacle_detection.h"
 #include "modules/perception/lidar/app/lidar_obstacle_tracking.h"
 #include "modules/perception/lidar/common/lidar_error_code.h"
 // #include "modules/perception/lidar/common/pcl_util.h"
@@ -42,7 +42,7 @@ class LidarAppPipelineTest : public testing::Test {
 
   void TearDown() {}
 
-  LidarObstacleSegmentation segmentation_;
+  LidarObstacleDetection segmentation_;
   LidarObstacleTracking tracking_;
 };  // class DecisionForestClassifierTest
 
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" new_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" added_lines="7" deleted_lines="4">
				<diff>@@ -62,12 +62,14 @@ bool LidarObstacleDetection::Init(
   }
 
   BasePointCloudPreprocessor* preprocessor =
-      BasePointCloudPreprocessorRegisterer::GetInstanceByName(config.preprocessor());
+      BasePointCloudPreprocessorRegisterer::
+      GetInstanceByName(config.preprocessor());
   CHECK_NOTNULL(preprocessor);
   cloud_preprocessor_.reset(preprocessor);
   PointCloudPreprocessorInitOptions preprocessor_init_options;
   preprocessor_init_options.sensor_name = sensor_name;
-  ACHECK(cloud_preprocessor_-&gt;Init(preprocessor_init_options)) &lt;&lt; "lidar preprocessor init error";
+  ACHECK(cloud_preprocessor_-&gt;Init(preprocessor_init_options)) &lt;&lt;
+                            "lidar preprocessor init error";
 
   BaseLidarDetector* detector =
       BaseLidarDetectorRegisterer::GetInstanceByName(config.detector());
@@ -75,9 +77,10 @@ bool LidarObstacleDetection::Init(
   detector_.reset(detector);
   LidarDetectorInitOptions detection_init_options;
   detection_init_options.sensor_name = sensor_name;
-  ACHECK(detector_-&gt;Init(detection_init_options)) &lt;&lt; "lidar detector init error";
+  ACHECK(detector_-&gt;Init(detection_init_options)) &lt;&lt;
+                            "lidar detector init error";
 
-  if(use_object_builder_) {
+  if (use_object_builder_) {
     ObjectBuilderInitOptions builder_init_options;
     ACHECK(builder_.Init(builder_init_options));
   }
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.h" new_path="modules\perception\lidar\app\lidar_obstacle_detection.h" added_lines="1" deleted_lines="0">
				<diff>@@ -15,6 +15,7 @@
  *****************************************************************************/
 #pragma once
 
+#include &lt;string&gt;
 #include &lt;memory&gt;
 
 #include "modules/perception/lidar/lib/interface/base_lidar_obstacle_detection.h"
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_tracking.cc" new_path="modules\perception\lidar\app\lidar_obstacle_tracking.cc" added_lines="6" deleted_lines="3">
				<diff>@@ -45,18 +45,21 @@ bool LidarObstacleTracking::Init(
   ACHECK(cyber::common::GetProtoFromFile(config_file, &amp;config));
 
   BaseMultiTargetTracker* multi_target_tracker =
-      BaseMultiTargetTrackerRegisterer::GetInstanceByName(config.multi_target_tracker());
+      BaseMultiTargetTrackerRegisterer::
+      GetInstanceByName(config.multi_target_tracker());
   CHECK_NOTNULL(multi_target_tracker);
   multi_target_tracker_.reset(multi_target_tracker);
   MultiTargetTrackerInitOptions tracker_init_options;
-  ACHECK(multi_target_tracker_-&gt;Init(tracker_init_options)) &lt;&lt; "lidar multi_target_tracker init error";
+  ACHECK(multi_target_tracker_-&gt;Init(tracker_init_options)) &lt;&lt;
+                              "lidar multi_target_tracker init error";
 
   BaseClassifier* fusion_classifier =
       BaseClassifierRegisterer::GetInstanceByName(config.fusion_classifier());
   CHECK_NOTNULL(fusion_classifier);
   fusion_classifier_.reset(fusion_classifier);
   ClassifierInitOptions fusion_classifier_init_options;
-  ACHECK(fusion_classifier_-&gt;Init(fusion_classifier_init_options)) &lt;&lt; "lidar classifier init error";
+  ACHECK(fusion_classifier_-&gt;Init(fusion_classifier_init_options)) &lt;&lt;
+                              "lidar classifier init error";
   return true;
 }
 
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detector\point_pillars_detection\point_pillars_detection.h" new_path="modules\perception\lidar\lib\detector\point_pillars_detection\point_pillars_detection.h" added_lines="2" deleted_lines="1">
				<diff>@@ -38,7 +38,8 @@ class PointPillarsDetection : public BaseLidarDetector {
   PointPillarsDetection();
   virtual ~PointPillarsDetection() = default;
 
-  bool Init(const LidarDetectorInitOptions&amp; options = LidarDetectorInitOptions()) override;
+  bool Init(const LidarDetectorInitOptions&amp; options =
+                LidarDetectorInitOptions()) override;
 
   bool Detect(const LidarDetectorOptions&amp; options, LidarFrame* frame) override;
 
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\interface\base_lidar_obstacle_detection.h" new_path="modules\perception\lidar\lib\interface\base_lidar_obstacle_detection.h" added_lines="6" deleted_lines="4">
				<diff>@@ -47,16 +47,18 @@ class BaseLidarObstacleDetection {
   BaseLidarObstacleDetection() = default;
   virtual ~BaseLidarObstacleDetection() = default;
 
-  virtual bool Init(const LidarObstacleDetectionInitOptions&amp; options =
-                LidarObstacleDetectionInitOptions()) = 0;
+  virtual bool Init(
+      const LidarObstacleDetectionInitOptions&amp; options =
+      LidarObstacleDetectionInitOptions()) = 0;
 
   virtual LidarProcessResult Process(
       const LidarObstacleDetectionOptions&amp; options,
       const std::shared_ptr&lt;apollo::drivers::PointCloud const&gt;&amp; message,
       LidarFrame* frame) = 0;
 
-  virtual LidarProcessResult Process(const LidarObstacleDetectionOptions&amp; options,
-                             LidarFrame* frame) = 0;
+  virtual LidarProcessResult Process(
+      const LidarObstacleDetectionOptions&amp; options,
+      LidarFrame* frame) = 0;
 
   virtual std::string Name() const = 0;
 
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\interface\base_lidar_obstacle_tracking.h" new_path="modules\perception\lidar\lib\interface\base_lidar_obstacle_tracking.h" added_lines="7" deleted_lines="5">
				<diff>@@ -40,16 +40,18 @@ class BaseLidarObstacleTracking {
   BaseLidarObstacleTracking() = default;
   virtual ~BaseLidarObstacleTracking() = default;
 
-  virtual bool Init(const LidarObstacleTrackingInitOptions&amp; options =
-                LidarObstacleTrackingInitOptions()) = 0;
+  virtual bool Init(
+            const LidarObstacleTrackingInitOptions&amp; options =
+            LidarObstacleTrackingInitOptions()) = 0;
 
-  virtual LidarProcessResult Process(const LidarObstacleTrackingOptions&amp; options,
-                             LidarFrame* frame) = 0;
+  virtual LidarProcessResult Process(
+            const LidarObstacleTrackingOptions&amp; options,
+            LidarFrame* frame) = 0;
 
   virtual std::string Name() const  = 0;
 
  private:
- DISALLOW_COPY_AND_ASSIGN(BaseLidarObstacleTracking);
+  DISALLOW_COPY_AND_ASSIGN(BaseLidarObstacleTracking);
 };  // class BaseLidarObstacleTracking
 
 PERCEPTION_REGISTER_REGISTERER(BaseLidarObstacleTracking);
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\interface\base_pointcloud_preprocessor.h" new_path="modules\perception\lidar\lib\interface\base_pointcloud_preprocessor.h" added_lines="1" deleted_lines="0">
				<diff>@@ -16,6 +16,7 @@
 #pragma once
 
 #include &lt;string&gt;
+#include &lt;memory&gt;
 
 #include "cyber/common/macros.h"
 #include "modules/perception/lib/registerer/registerer.h"
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\pointcloud_preprocessor\pointcloud_preprocessor.h" new_path="modules\perception\lidar\lib\pointcloud_preprocessor\pointcloud_preprocessor.h" added_lines="1" deleted_lines="0">
				<diff>@@ -15,6 +15,7 @@
  *****************************************************************************/
 #pragma once
 
+#include &lt;string&gt;
 #include &lt;memory&gt;
 
 #include "modules/perception/lidar/lib/interface/base_pointcloud_preprocessor.h"
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7909a06309289995b8605be670d7d5ddbc9d9bf2" author="foreverhza">
		<msg>Drivers:fix  a potential null pointer problem</msg>
		<modified_files>
			<file old_path="modules\drivers\lidar\lidar_driver_component.cc" new_path="modules\drivers\lidar\lidar_driver_component.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -31,7 +31,7 @@ bool LidarDriverComponent::Init() {
   AINFO &lt;&lt; "conf:" &lt;&lt; conf_.DebugString();
   LidarDriverFactory::Instance()-&gt;RegisterLidarClients();
   driver_ = LidarDriverFactory::Instance()-&gt;CreateLidarDriver(node_, conf_);
-  if (!driver_-&gt;Init()) {
+  if (driver_ == nullptr || !driver_-&gt;Init()) {
     AERROR &lt;&lt; "driver init error";
     return false;
   }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="91ef5399753822afb2c859ddcba6724d1b74b7d4" author="SeasoulChris">
		<msg>Velodyne: fix a bug: base_time couldn't update on the hour (#13920) (#13924)</msg>
		<modified_files>
			<file old_path="modules\drivers\lidar\velodyne\driver\driver.cc" new_path="modules\drivers\lidar\velodyne\driver\driver.cc" added_lines="1" deleted_lines="2">
				<diff>@@ -216,8 +216,7 @@ void VelodyneDriver::UpdateGpsTopHour(uint32_t current_time) {
     return;
   }
   if (last_gps_time_ &gt; current_time) {
-    int32_t time_diff = static_cast&lt;int32_t&gt;(last_gps_time_ - current_time);
-    if (time_diff &gt; 3599000000) {
+    if ((last_gps_time_ - current_time) &gt; 3599000000) {
       basetime_ += static_cast&lt;uint64_t&gt;(3600 * 1e6);
       AINFO &lt;&lt; "Base time plus 3600s. Model: " &lt;&lt; config_.model() &lt;&lt; std::fixed
             &lt;&lt; ". current:" &lt;&lt; current_time &lt;&lt; ", last time:" &lt;&lt; last_gps_time_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="36a590dd9ff97c16e9bada2a9c367931c8badb84" author="zhangxiao23">
		<msg>Perception: add camera_obstacle_detection_component

Change-Id: I1b9abf91844accdaea748c70b094277b87c97830</msg>
		<modified_files>
			<file old_path="modules\perception\camera\lib\obstacle\tracker\omt\obstacle_reference.cc" new_path="modules\perception\camera\lib\obstacle\tracker\omt\obstacle_reference.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -133,7 +133,8 @@ void ObstacleReference::UpdateReference(const CameraFrame *frame,
   }
 
   int count_samples = static_cast&lt;int&gt;(vd_samples.size() / 2);
-  if (count_samples &gt; ground_estimator.get_min_nr_samples()) {
+    if (count_samples &gt; ground_estimator.get_min_nr_samples() &amp;&amp;
+      frame-&gt;calibration_service != nullptr) {
     ground_estimator.DetetGround(
         frame-&gt;calibration_service-&gt;QueryPitchAngle(),
         frame-&gt;calibration_service-&gt;QueryCameraToGroundHeight(),
</diff>
			</file>
			<file old_path="modules\perception\inference\onnx\libtorch_obstacle_detector.cc" new_path="modules\perception\inference\onnx\libtorch_obstacle_detector.cc" added_lines="22" deleted_lines="17">
				<diff>@@ -42,6 +42,22 @@ bool ObstacleDetector::Init(const std::map&lt;std::string,
     device_type_ = torch::kCPU;
   }
 
+  for (const auto&amp; name : output_names_) {
+    auto iter = shapes.find(name);
+    if (iter != shapes.end()) {
+      auto blob = std::make_shared&lt;Blob&lt;float&gt;&gt;(iter-&gt;second);
+      blobs_.emplace(name, blob);
+    }
+  }
+
+  for (const auto&amp; name : input_names_) {
+    auto iter = shapes.find(name);
+    if (iter != shapes.end()) {
+      auto blob = std::make_shared&lt;Blob&lt;float&gt;&gt;(iter-&gt;second);
+      blobs_.emplace(name, blob);
+    }
+  }
+
   // Load model without grad, equal to torch.no_grad()
   // torch::NoGradGuard no_grad;
   // Init net
@@ -50,7 +66,9 @@ bool ObstacleDetector::Init(const std::map&lt;std::string,
   net_.eval();
 
   // run a fake inference at init time as first inference is relative slow
-  torch::Tensor input_feature_tensor = torch::zeros({1, 3, 640, 960});
+  int height_ = blobs_[input_names_[0]]-&gt;shape(1);
+  int width_ = blobs_[input_names_[0]]-&gt;shape(2);
+  torch::Tensor input_feature_tensor = torch::zeros({1, 3, height_, width_});
   std::array&lt;float, 2&gt; down_ratio{8.0f, 8.0f};
   torch::Tensor tensor_downratio = torch::from_blob(down_ratio.data(), {1, 2});
   std::array&lt;float, 9&gt; K{1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f};
@@ -63,23 +81,11 @@ bool ObstacleDetector::Init(const std::map&lt;std::string,
   torch_inputs.push_back(std::make_tuple(tensor_K.to(device),
                                          tensor_downratio.to(device)));
   auto torch_output_tensor =
-      net_.forward(torch_inputs);
-
-  for (const auto&amp; name : output_names_) {
-    auto iter = shapes.find(name);
-    if (iter != shapes.end()) {
-      auto blob = std::make_shared&lt;Blob&lt;float&gt;&gt;(iter-&gt;second);
-      blobs_.emplace(name, blob);
-    }
+      net_.forward(torch_inputs).toTuple()-&gt;elements();
+  if (torch_output_tensor[0].toTensor().requires_grad()) {
+    AWARN &lt;&lt; "Require grad";
   }
 
-  for (const auto&amp; name : input_names_) {
-    auto iter = shapes.find(name);
-    if (iter != shapes.end()) {
-      auto blob = std::make_shared&lt;Blob&lt;float&gt;&gt;(iter-&gt;second);
-      blobs_.emplace(name, blob);
-    }
-  }
   c10::cuda::CUDACachingAllocator::emptyCache();
   return true;
 }
@@ -143,7 +149,6 @@ void ObstacleDetector::Infer() {
     blobs_[output_names_[i]]-&gt;Reshape(output_size);
     blobs_[output_names_[i]]-&gt;set_gpu_data(output_tensor.data_ptr&lt;float&gt;());
   }
-  c10::cuda::CUDACachingAllocator::emptyCache();
 }
 
 }  // namespace inference
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_camera_detection_component.cc" new_path="modules\perception\onboard\component\fusion_camera_detection_component.cc" added_lines="11" deleted_lines="11">
				<diff>@@ -65,11 +65,11 @@ static int GetGpuId(const camera::CameraPerceptionInitOptions &amp;options) {
   return perception_param.gpu_id();
 }
 
-bool SetCameraHeight(const std::string &amp;sensor_name,
-                     const std::string &amp;params_dir,
-                     const std::string &amp;lidar_sensor_name,
-                     float default_camera_height,
-                     float *camera_height) {
+static bool SetCameraHeight(const std::string &amp;sensor_name,
+                            const std::string &amp;params_dir,
+                            const std::string &amp;lidar_sensor_name,
+                            float default_camera_height,
+                            float *camera_height) {
   float base_h = default_camera_height;
   float camera_offset = 0.0f;
   try {
@@ -99,8 +99,8 @@ bool SetCameraHeight(const std::string &amp;sensor_name,
 }
 
 // @description: load camera extrinsics from yaml file
-bool LoadExtrinsics(const std::string &amp;yaml_file,
-                    Eigen::Matrix4d *camera_extrinsic) {
+static bool LoadExtrinsics(const std::string &amp;yaml_file,
+                           Eigen::Matrix4d *camera_extrinsic) {
   if (!apollo::cyber::common::PathExists(yaml_file)) {
     AINFO &lt;&lt; yaml_file &lt;&lt; " does not exist!";
     return false;
@@ -153,10 +153,10 @@ bool LoadExtrinsics(const std::string &amp;yaml_file,
 }
 
 // @description: get project matrix
-bool GetProjectMatrix(
-    const std::vector&lt;std::string&gt; &amp;camera_names,
-    const EigenMap&lt;std::string, Eigen::Matrix4d&gt; &amp;extrinsic_map,
-    const EigenMap&lt;std::string, Eigen::Matrix3f&gt; &amp;intrinsic_map,
+static bool GetProjectMatrix(
+      const std::vector&lt;std::string&gt; &amp;camera_names,
+      const EigenMap&lt;std::string, Eigen::Matrix4d&gt; &amp;extrinsic_map,
+      const EigenMap&lt;std::string, Eigen::Matrix3f&gt; &amp;intrinsic_map,
     Eigen::Matrix3d *project_matrix, double *pitch_diff = nullptr) {
   // TODO(techoe): This condition should be removed.
   if (camera_names.size() != 2) {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="26df886d44d8738c6adf883199fa509113333170" author="lilu15">
		<msg>task_manager: add send out routing and refine routing logic

Change-Id: I6711a32e82967ff32e9d39773b4f52508e97a13e</msg>
		<modified_files>
			<file old_path="modules\task_manager\common\task_manager_gflags.cc" new_path="modules\task_manager\common\task_manager_gflags.cc" added_lines="6" deleted_lines="0">
				<diff>@@ -25,3 +25,9 @@ DEFINE_double(threshold_for_destination_check, 1.0,
 DEFINE_double(plot_size_buffer, 0.2, "the size buffer of parking plot");
 
 DEFINE_double(road_width_buffer, 0.0, "the size buffer of road width");
+
+DEFINE_double(dead_end_destination_threshold, 0.01,
+              "the threshold is used to check to get the destination");
+
+DEFINE_double(search_junction_threshold, 1.0,
+              "the threshold is used to search junction a certain range");
</diff>
			</file>
			<file old_path="modules\task_manager\common\task_manager_gflags.h" new_path="modules\task_manager\common\task_manager_gflags.h" added_lines="4" deleted_lines="0">
				<diff>@@ -25,3 +25,7 @@ DECLARE_double(threshold_for_destination_check);
 DECLARE_double(plot_size_buffer);
 
 DECLARE_double(road_width_buffer);
+
+DECLARE_double(dead_end_destination_threshold);
+
+DECLARE_double(search_junction_threshold);
</diff>
			</file>
			<file old_path="modules\task_manager\dead_end_routing_manager.cc" new_path="modules\task_manager\dead_end_routing_manager.cc" added_lines="77" deleted_lines="0">
				<diff>@@ -18,6 +18,12 @@
 
 namespace apollo {
 namespace task_manager {
+using apollo::common::VehicleState;
+using apollo::common::PointENU;
+using apollo::routing::RoutingRequest;
+using apollo::hdmap::JunctionInfoConstPtr;
+using apollo::common::math::Polygon2d;
+using apollo::common::math::Vec2d;
 
 DeadEndRoutingManager::DeadEndRoutingManager()
     : monitor_logger_buffer_(
@@ -25,7 +31,78 @@ DeadEndRoutingManager::DeadEndRoutingManager()
 
 common::Status DeadEndRoutingManager::Init(
     const DeadEndRoutingTask&amp; dead_end_routing_task) {
+  cycle_ = 2;
+  routing_request_in_ = dead_end_routing_task.routing_request_in();
+  routing_request_out_ = dead_end_routing_task.routing_request_out();
   return common::Status::OK();
 }
+
+bool DeadEndRoutingManager::JudgeCarInDeadEndJunction(
+    const Vec2d&amp; car_position,
+    const common::PointENU&amp; target_point) {
+  size_t waypoint_num = routing_request_in_.waypoint().size();
+  PointENU dead_end_point = routing_request_in_
+                            .waypoint().at(waypoint_num - 1).pose();
+  const hdmap::HDMap* base_map_ptr = hdmap::HDMapUtil::BaseMapPtr();
+  std::vector&lt;JunctionInfoConstPtr&gt; junctions;
+  JunctionInfoConstPtr junction;
+  if (base_map_ptr-&gt;GetJunctions(
+      dead_end_point, FLAGS_search_junction_threshold, &amp;junctions) != 0) {
+    AERROR &lt;&lt; "Fail to get junctions from base_map.";
+    return false;
+  }
+  if (junctions.size() &lt;= 0) {
+    AERROR &lt;&lt; "No junction from map";
+    return false;
+  }
+  size_t junction_num = junctions.size();
+  for (size_t i = 0; i &lt; junction_num; ++i) {
+    if (junctions.at(i)-&gt;junction().type() == DEAD_END) {
+      double distance_to_vehicle =
+        (car_position.x() - target_point.x()) *
+        (car_position.x() - target_point.x()) +
+        (car_position.y() - target_point.y()) *
+        (car_position.y() - target_point.y());
+      if (distance_to_vehicle &lt; FLAGS_dead_end_destination_threshold) {
+        return true;
+      }
+    } else {
+      return false;
+    }
+  }
+  return false;
+}
+
+bool DeadEndRoutingManager::GetNewRouting(
+  const localization::Pose&amp; pose,
+  routing::RoutingRequest* routing_request) {
+  Vec2d car_position;
+  car_position.set_x(pose.position().x());
+  car_position.set_y(pose.position().y());
+  const common::PointENU&amp; target_point =
+    routing_request_out_.waypoint().at(0).pose();
+  if (JudgeCarInDeadEndJunction(car_position, target_point)) {
+    if (routing_out_flag_) {
+      *routing_request = routing_request_out_;
+      routing_request-&gt;mutable_dead_end_info()-&gt;
+        set_dead_end_routing_type(routing::ROUTING_OUT);
+      --cycle_;
+      routing_out_flag_ = false;
+      return true;
+    }
+  } else {
+    if (routing_in_flag_) {
+      *routing_request = routing_request_in_;
+      routing_request-&gt;mutable_dead_end_info()-&gt;
+        set_dead_end_routing_type(routing::ROUTING_IN);
+      routing_request-&gt;mutable_dead_end_info()-&gt;
+        mutable_target_point()-&gt;CopyFrom(target_point);
+      routing_in_flag_ = false;
+      return true;
+    }
+  }
+  return false;
+}
+
 }  // namespace task_manager
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\task_manager\dead_end_routing_manager.h" new_path="modules\task_manager\dead_end_routing_manager.h" added_lines="17" deleted_lines="0">
				<diff>@@ -22,8 +22,12 @@
 
 #include "modules/common/monitor_log/monitor_log_buffer.h"
 #include "modules/common/status/status.h"
+#include "modules/common/vehicle_state/vehicle_state_provider.h"
+#include "modules/map/hdmap/hdmap_util.h"
+#include "modules/localization/proto/localization.pb.h"
 #include "modules/task_manager/proto/task_manager.pb.h"
 #include "modules/task_manager/proto/task_manager_config.pb.h"
+#include "modules/task_manager/common/task_manager_gflags.h"
 
 namespace apollo {
 namespace task_manager {
@@ -42,8 +46,21 @@ class DeadEndRoutingManager {
    */
   virtual ~DeadEndRoutingManager() = default;
 
+  int GetNumber() const { return cycle_; }
+
+  bool GetNewRouting(const localization::Pose&amp; pose,
+                     routing::RoutingRequest* routing_request);
+
+  bool JudgeCarInDeadEndJunction(const common::math::Vec2d&amp; car_position,
+                                 const common::PointENU&amp; target_point);
+
  private:
+  int cycle_ = 0;
+  bool routing_in_flag_ = true;
+  bool routing_out_flag_ = true;
   apollo::common::monitor::MonitorLogBuffer monitor_logger_buffer_;
+  routing::RoutingRequest routing_request_in_;
+  routing::RoutingRequest routing_request_out_;
 };
 
 }  // namespace task_manager
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.cc" new_path="modules\task_manager\task_manager_component.cc" added_lines="12" deleted_lines="6">
				<diff>@@ -16,7 +16,6 @@
 #include "modules/task_manager/task_manager_component.h"
 
 #include "modules/task_manager/proto/task_manager_config.pb.h"
-
 #include "cyber/time/rate.h"
 
 namespace apollo {
@@ -27,6 +26,7 @@ using apollo::cyber::Rate;
 using apollo::localization::LocalizationEstimate;
 using apollo::routing::RoutingRequest;
 using apollo::routing::RoutingResponse;
+using apollo::planning::ADCTrajectory;
 
 bool TaskManagerComponent::Init() {
   TaskManagerConfig task_manager_conf;
@@ -67,7 +67,6 @@ bool TaskManagerComponent::Init() {
 }
 
 bool TaskManagerComponent::Proc(const std::shared_ptr&lt;Task&gt;&amp; task) {
-  task_name_ = task-&gt;task_name();
   if (task-&gt;task_type() != CYCLE_ROUTING &amp;&amp;
       task-&gt;task_type() != PARKING_ROUTING &amp;&amp;
       task-&gt;task_type() != DEAD_END_ROUTING) {
@@ -137,12 +136,19 @@ bool TaskManagerComponent::Proc(const std::shared_ptr&lt;Task&gt;&amp; task) {
       return false;
     }
   } else if (task-&gt;task_type() == DEAD_END_ROUTING) {
-    AERROR &lt;&lt; "enter the turn around task";
     dead_end_routing_manager_ = std::make_shared&lt;DeadEndRoutingManager&gt;();
     dead_end_routing_manager_-&gt;Init(task-&gt;dead_end_routing_task());
-    routing_request_in_ = task-&gt;dead_end_routing_task().routing_request_in();
-    common::util::FillHeader(node_-&gt;Name(), &amp;routing_request_in_);
-    request_writer_-&gt;Write(routing_request_in_);
+    routing_request_ = task-&gt;dead_end_routing_task().routing_request_in();
+    Rate rate(1.0);
+    while (dead_end_routing_manager_-&gt;GetNumber() &gt; 0) {
+      if (dead_end_routing_manager_-&gt;GetNewRouting(localization_.pose(),
+                                                   &amp;routing_request_)) {
+        common::util::FillHeader(node_-&gt;Name(), &amp;routing_request_);
+        request_writer_-&gt;Write(routing_request_);
+        rate.Sleep();
+      }
+    rate.Sleep();
+    }
   }
   return true;
 }
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.h" new_path="modules\task_manager\task_manager_component.h" added_lines="3" deleted_lines="2">
				<diff>@@ -21,6 +21,7 @@
 
 #include "cyber/class_loader/class_loader.h"
 #include "cyber/component/component.h"
+#include "modules/planning/proto/planning.pb.h"
 #include "modules/task_manager/cycle_routing_manager.h"
 #include "modules/task_manager/parking_routing_manager.h"
 #include "modules/task_manager/dead_end_routing_manager.h"
@@ -41,15 +42,15 @@ class TaskManagerComponent final : public cyber::Component&lt;task_manager::Task&gt; {
  private:
   std::shared_ptr&lt;cyber::Reader&lt;LocalizationEstimate&gt;&gt; localization_reader_;
   std::shared_ptr&lt;cyber::Reader&lt;routing::RoutingResponse&gt;&gt; response_reader_;
+  std::shared_ptr&lt;cyber::Reader&lt;planning::ADCTrajectory&gt;&gt; trajectory_reader_;
   std::shared_ptr&lt;cyber::Writer&lt;routing::RoutingRequest&gt;&gt; request_writer_;
   std::shared_ptr&lt;CycleRoutingManager&gt; cycle_routing_manager_;
   std::shared_ptr&lt;ParkingRoutingManager&gt; parking_routing_manager_;
   std::shared_ptr&lt;DeadEndRoutingManager&gt; dead_end_routing_manager_;
   routing::RoutingRequest routing_request_;
-  routing::RoutingRequest routing_request_in_;
-  routing::RoutingRequest routing_request_out_;
   routing::RoutingResponse routing_response_;
   LocalizationEstimate localization_;
+  apollo::planning::ADCTrajectory planning_;
   std::mutex mutex_;
   std::string task_name_;
 };
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c19a93f8f287471225c364343604864bfbc88f8c" author="zhangxiao23">
		<msg>Perception: add mask-pillars detection

Change-Id: If36d9183259d615880bca59197b0a8cb9c939c5b</msg>
		<modified_files>
			<file old_path="modules\perception\common\perception_gflags.cc" new_path="modules\perception\common\perception_gflags.cc" added_lines="22" deleted_lines="0">
				<diff>@@ -93,6 +93,28 @@ DEFINE_double(score_threshold, 0.5, "Classification score threshold.");
 DEFINE_double(nms_overlap_threshold, 0.5, "Nms overlap threshold.");
 DEFINE_int32(num_output_box_feature, 7, "Length of output box feature.");
 
+// lidar_mask_pillars
+DEFINE_string(mask_pfe_torch_file,
+              "/apollo/modules/perception/production/data/perception/lidar/"
+              "models/detection/mask_pillars/pts_voxel_encoder.zip",
+              "The path of pillars feature extractor torch file.");
+DEFINE_string(mask_scattered_torch_file,
+              "/apollo/modules/perception/production/data/perception/lidar/"
+              "models/detection/mask_pillars/pts_middle_encoder.zip",
+              "The path of pillars feature scatter torch file.");
+DEFINE_string(mask_backbone_torch_file,
+              "/apollo/modules/perception/production/data/perception/lidar/"
+              "models/detection/mask_pillars/pts_backbone.zip",
+              "The path of pillars backbone torch file.");
+DEFINE_string(mask_fpn_torch_file,
+              "/apollo/modules/perception/production/data/perception/lidar/"
+              "models/detection/mask_pillars/pts_neck.zip",
+              "The path of pillars fpn torch file.");
+DEFINE_string(mask_bbox_head_torch_file,
+              "/apollo/modules/perception/production/data/perception/lidar/"
+              "models/detection/mask_pillars/pts_bbox_head.zip",
+              "The path of pillars bbox head torch file.");
+
 // emergency detection onnx
 DEFINE_string(onnx_obstacle_detector_model,
               "/apollo/modules/perception/camera"
</diff>
			</file>
			<file old_path="modules\perception\common\perception_gflags.h" new_path="modules\perception\common\perception_gflags.h" added_lines="7" deleted_lines="0">
				<diff>@@ -58,6 +58,13 @@ DECLARE_double(score_threshold);
 DECLARE_double(nms_overlap_threshold);
 DECLARE_int32(num_output_box_feature);
 
+// lidar_mask_pillars
+DECLARE_string(mask_pfe_torch_file);
+DECLARE_string(mask_scattered_torch_file);
+DECLARE_string(mask_backbone_torch_file);
+DECLARE_string(mask_fpn_torch_file);
+DECLARE_string(mask_bbox_head_torch_file);
+
 // emergency detection onnx
 DECLARE_string(onnx_obstacle_detector_model);
 DECLARE_string(onnx_test_input_path);
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" new_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -46,7 +46,8 @@ bool LidarObstacleDetection::Init(
   ACHECK(cyber::common::GetProtoFromFile(config_file, &amp;config));
   use_map_manager_ = config.use_map_manager();
   use_object_filter_bank_ = config.use_object_filter_bank();
-  use_object_builder_ = ("PointPillarsDetection" != config.detector());
+  use_object_builder_ = ("PointPillarsDetection" != config.detector() || 
+                         "MaskPillarsDetection" != config.detector());
 
   use_map_manager_ = use_map_manager_ &amp;&amp; options.enable_hdmap_input;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="83dc73a4e9182a17fe1643beefa8c17eae9861a1" author="zhangxiao23">
		<msg>Perception: lint

Change-Id: I00ff744bb41388b31761699827695cae7ba2551c</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" new_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -46,7 +46,7 @@ bool LidarObstacleDetection::Init(
   ACHECK(cyber::common::GetProtoFromFile(config_file, &amp;config));
   use_map_manager_ = config.use_map_manager();
   use_object_filter_bank_ = config.use_object_filter_bank();
-  use_object_builder_ = ("PointPillarsDetection" != config.detector() || 
+  use_object_builder_ = ("PointPillarsDetection" != config.detector() ||
                          "MaskPillarsDetection" != config.detector());
 
   use_map_manager_ = use_map_manager_ &amp;&amp; options.enable_hdmap_input;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="23ddd20c2a98fdfb6d85daf66ee70405cb2b93aa" author="zhangxiao23">
		<msg>Perception: reset dag_streaming_perception

Change-Id: I26b2476d5b455a309e406843e5b024c79668ac83</msg>
		<modified_files>
			<file old_path="modules\perception\lidar\lib\detector\mask_pillars_detection\mask_pillars_detection.cc" new_path="modules\perception\lidar\lib\detector\mask_pillars_detection\mask_pillars_detection.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
+ * Copyright 2021 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
</diff>
			</file>
			<file old_path="modules\perception\lidar\lib\detector\mask_pillars_detection\mask_pillars_detection.h" new_path="modules\perception\lidar\lib\detector\mask_pillars_detection\mask_pillars_detection.h" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2020 The Apollo Authors. All Rights Reserved.
+ * Copyright 2021 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="da92e2aa43c9ef52a7502912505492529ab9b0e6" author="xiaoMrzhang">
		<msg>Add new perception modules (#13964)</msg>
		<modified_files>
			<file old_path="modules\perception\camera\lib\obstacle\tracker\omt\obstacle_reference.cc" new_path="modules\perception\camera\lib\obstacle\tracker\omt\obstacle_reference.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -133,7 +133,8 @@ void ObstacleReference::UpdateReference(const CameraFrame *frame,
   }
 
   int count_samples = static_cast&lt;int&gt;(vd_samples.size() / 2);
-  if (count_samples &gt; ground_estimator.get_min_nr_samples()) {
+    if (count_samples &gt; ground_estimator.get_min_nr_samples() &amp;&amp;
+      frame-&gt;calibration_service != nullptr) {
     ground_estimator.DetetGround(
         frame-&gt;calibration_service-&gt;QueryPitchAngle(),
         frame-&gt;calibration_service-&gt;QueryCameraToGroundHeight(),
</diff>
			</file>
			<file old_path="modules\perception\common\perception_gflags.cc" new_path="modules\perception\common\perception_gflags.cc" added_lines="22" deleted_lines="0">
				<diff>@@ -93,6 +93,28 @@ DEFINE_double(score_threshold, 0.5, "Classification score threshold.");
 DEFINE_double(nms_overlap_threshold, 0.5, "Nms overlap threshold.");
 DEFINE_int32(num_output_box_feature, 7, "Length of output box feature.");
 
+// lidar_mask_pillars
+DEFINE_string(mask_pfe_torch_file,
+              "/apollo/modules/perception/production/data/perception/lidar/"
+              "models/detection/mask_pillars/pts_voxel_encoder.zip",
+              "The path of pillars feature extractor torch file.");
+DEFINE_string(mask_scattered_torch_file,
+              "/apollo/modules/perception/production/data/perception/lidar/"
+              "models/detection/mask_pillars/pts_middle_encoder.zip",
+              "The path of pillars feature scatter torch file.");
+DEFINE_string(mask_backbone_torch_file,
+              "/apollo/modules/perception/production/data/perception/lidar/"
+              "models/detection/mask_pillars/pts_backbone.zip",
+              "The path of pillars backbone torch file.");
+DEFINE_string(mask_fpn_torch_file,
+              "/apollo/modules/perception/production/data/perception/lidar/"
+              "models/detection/mask_pillars/pts_neck.zip",
+              "The path of pillars fpn torch file.");
+DEFINE_string(mask_bbox_head_torch_file,
+              "/apollo/modules/perception/production/data/perception/lidar/"
+              "models/detection/mask_pillars/pts_bbox_head.zip",
+              "The path of pillars bbox head torch file.");
+
 // emergency detection onnx
 DEFINE_string(onnx_obstacle_detector_model,
               "/apollo/modules/perception/camera"
</diff>
			</file>
			<file old_path="modules\perception\common\perception_gflags.h" new_path="modules\perception\common\perception_gflags.h" added_lines="7" deleted_lines="0">
				<diff>@@ -58,6 +58,13 @@ DECLARE_double(score_threshold);
 DECLARE_double(nms_overlap_threshold);
 DECLARE_int32(num_output_box_feature);
 
+// lidar_mask_pillars
+DECLARE_string(mask_pfe_torch_file);
+DECLARE_string(mask_scattered_torch_file);
+DECLARE_string(mask_backbone_torch_file);
+DECLARE_string(mask_fpn_torch_file);
+DECLARE_string(mask_bbox_head_torch_file);
+
 // emergency detection onnx
 DECLARE_string(onnx_obstacle_detector_model);
 DECLARE_string(onnx_test_input_path);
</diff>
			</file>
			<file old_path="modules\perception\inference\onnx\libtorch_obstacle_detector.cc" new_path="modules\perception\inference\onnx\libtorch_obstacle_detector.cc" added_lines="22" deleted_lines="17">
				<diff>@@ -42,6 +42,22 @@ bool ObstacleDetector::Init(const std::map&lt;std::string,
     device_type_ = torch::kCPU;
   }
 
+  for (const auto&amp; name : output_names_) {
+    auto iter = shapes.find(name);
+    if (iter != shapes.end()) {
+      auto blob = std::make_shared&lt;Blob&lt;float&gt;&gt;(iter-&gt;second);
+      blobs_.emplace(name, blob);
+    }
+  }
+
+  for (const auto&amp; name : input_names_) {
+    auto iter = shapes.find(name);
+    if (iter != shapes.end()) {
+      auto blob = std::make_shared&lt;Blob&lt;float&gt;&gt;(iter-&gt;second);
+      blobs_.emplace(name, blob);
+    }
+  }
+
   // Load model without grad, equal to torch.no_grad()
   // torch::NoGradGuard no_grad;
   // Init net
@@ -50,7 +66,9 @@ bool ObstacleDetector::Init(const std::map&lt;std::string,
   net_.eval();
 
   // run a fake inference at init time as first inference is relative slow
-  torch::Tensor input_feature_tensor = torch::zeros({1, 3, 640, 960});
+  int height_ = blobs_[input_names_[0]]-&gt;shape(1);
+  int width_ = blobs_[input_names_[0]]-&gt;shape(2);
+  torch::Tensor input_feature_tensor = torch::zeros({1, 3, height_, width_});
   std::array&lt;float, 2&gt; down_ratio{8.0f, 8.0f};
   torch::Tensor tensor_downratio = torch::from_blob(down_ratio.data(), {1, 2});
   std::array&lt;float, 9&gt; K{1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f};
@@ -63,23 +81,11 @@ bool ObstacleDetector::Init(const std::map&lt;std::string,
   torch_inputs.push_back(std::make_tuple(tensor_K.to(device),
                                          tensor_downratio.to(device)));
   auto torch_output_tensor =
-      net_.forward(torch_inputs);
-
-  for (const auto&amp; name : output_names_) {
-    auto iter = shapes.find(name);
-    if (iter != shapes.end()) {
-      auto blob = std::make_shared&lt;Blob&lt;float&gt;&gt;(iter-&gt;second);
-      blobs_.emplace(name, blob);
-    }
+      net_.forward(torch_inputs).toTuple()-&gt;elements();
+  if (torch_output_tensor[0].toTensor().requires_grad()) {
+    AWARN &lt;&lt; "Require grad";
   }
 
-  for (const auto&amp; name : input_names_) {
-    auto iter = shapes.find(name);
-    if (iter != shapes.end()) {
-      auto blob = std::make_shared&lt;Blob&lt;float&gt;&gt;(iter-&gt;second);
-      blobs_.emplace(name, blob);
-    }
-  }
   c10::cuda::CUDACachingAllocator::emptyCache();
   return true;
 }
@@ -143,7 +149,6 @@ void ObstacleDetector::Infer() {
     blobs_[output_names_[i]]-&gt;Reshape(output_size);
     blobs_[output_names_[i]]-&gt;set_gpu_data(output_tensor.data_ptr&lt;float&gt;());
   }
-  c10::cuda::CUDACachingAllocator::emptyCache();
 }
 
 }  // namespace inference
</diff>
			</file>
			<file old_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" new_path="modules\perception\lidar\app\lidar_obstacle_detection.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -46,7 +46,8 @@ bool LidarObstacleDetection::Init(
   ACHECK(cyber::common::GetProtoFromFile(config_file, &amp;config));
   use_map_manager_ = config.use_map_manager();
   use_object_filter_bank_ = config.use_object_filter_bank();
-  use_object_builder_ = ("PointPillarsDetection" != config.detector());
+  use_object_builder_ = ("PointPillarsDetection" != config.detector() ||
+                         "MaskPillarsDetection" != config.detector());
 
   use_map_manager_ = use_map_manager_ &amp;&amp; options.enable_hdmap_input;
 
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_camera_detection_component.cc" new_path="modules\perception\onboard\component\fusion_camera_detection_component.cc" added_lines="11" deleted_lines="11">
				<diff>@@ -65,11 +65,11 @@ static int GetGpuId(const camera::CameraPerceptionInitOptions &amp;options) {
   return perception_param.gpu_id();
 }
 
-bool SetCameraHeight(const std::string &amp;sensor_name,
-                     const std::string &amp;params_dir,
-                     const std::string &amp;lidar_sensor_name,
-                     float default_camera_height,
-                     float *camera_height) {
+static bool SetCameraHeight(const std::string &amp;sensor_name,
+                            const std::string &amp;params_dir,
+                            const std::string &amp;lidar_sensor_name,
+                            float default_camera_height,
+                            float *camera_height) {
   float base_h = default_camera_height;
   float camera_offset = 0.0f;
   try {
@@ -99,8 +99,8 @@ bool SetCameraHeight(const std::string &amp;sensor_name,
 }
 
 // @description: load camera extrinsics from yaml file
-bool LoadExtrinsics(const std::string &amp;yaml_file,
-                    Eigen::Matrix4d *camera_extrinsic) {
+static bool LoadExtrinsics(const std::string &amp;yaml_file,
+                           Eigen::Matrix4d *camera_extrinsic) {
   if (!apollo::cyber::common::PathExists(yaml_file)) {
     AINFO &lt;&lt; yaml_file &lt;&lt; " does not exist!";
     return false;
@@ -153,10 +153,10 @@ bool LoadExtrinsics(const std::string &amp;yaml_file,
 }
 
 // @description: get project matrix
-bool GetProjectMatrix(
-    const std::vector&lt;std::string&gt; &amp;camera_names,
-    const EigenMap&lt;std::string, Eigen::Matrix4d&gt; &amp;extrinsic_map,
-    const EigenMap&lt;std::string, Eigen::Matrix3f&gt; &amp;intrinsic_map,
+static bool GetProjectMatrix(
+      const std::vector&lt;std::string&gt; &amp;camera_names,
+      const EigenMap&lt;std::string, Eigen::Matrix4d&gt; &amp;extrinsic_map,
+      const EigenMap&lt;std::string, Eigen::Matrix3f&gt; &amp;intrinsic_map,
     Eigen::Matrix3d *project_matrix, double *pitch_diff = nullptr) {
   // TODO(techoe): This condition should be removed.
   if (camera_names.size() != 2) {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5a54b1ff0e8439929207419de447bcdbf89d2932" author="jiangjianan">
		<msg>Prediction: add vector net model inference

Change-Id: Icde87ab8433cec4daa064129056451a217d5b9d7</msg>
		<modified_files>
			<file old_path="modules\prediction\common\prediction_gflags.cc" new_path="modules\prediction\common\prediction_gflags.cc" added_lines="7" deleted_lines="1">
				<diff>@@ -173,6 +173,12 @@ DEFINE_string(torch_vehicle_cruise_cutin_file,
 DEFINE_string(torch_vehicle_lane_scanning_file,
               "/apollo/modules/prediction/data/lane_scanning_vehicle_model.pt",
               "Vehicle lane scanning model file");
+DEFINE_string(torch_vehicle_vectornet_file,
+              "/apollo/modules/prediction/data/vectornet_vehicle_model.pt",
+              "Vehicle vectornet model file");
+DEFINE_string(torch_vehicle_vectornet_cpu_file,
+              "/apollo/modules/prediction/data/vectornet_vehicle_cpu_model.pt",
+              "Vehicle vectornet cpu model file");
 DEFINE_string(torch_pedestrian_interaction_position_embedding_file,
               "/apollo/modules/prediction/data/"
               "pedestrian_interaction_position_embedding.pt",
@@ -260,7 +266,7 @@ DEFINE_double(default_s_if_no_obstacle_in_lane_sequence, 1000.0,
               "The default s value if no obstacle in the lane sequence.");
 DEFINE_double(default_l_if_no_obstacle_in_lane_sequence, 10.0,
               "The default l value if no obstacle in the lane sequence.");
-DEFINE_bool(enable_semantic_map, true, "If enable semantic map on prediction");
+DEFINE_bool(enable_semantic_map, false, "If enable semantic map on prediction");
 
 // Obstacle trajectory
 DEFINE_bool(enable_cruise_regression, false,
</diff>
			</file>
			<file old_path="modules\prediction\common\prediction_gflags.h" new_path="modules\prediction\common\prediction_gflags.h" added_lines="2" deleted_lines="0">
				<diff>@@ -104,6 +104,8 @@ DECLARE_string(torch_vehicle_semantic_lstm_cpu_file);
 DECLARE_string(torch_vehicle_cruise_go_file);
 DECLARE_string(torch_vehicle_cruise_cutin_file);
 DECLARE_string(torch_vehicle_lane_scanning_file);
+DECLARE_string(torch_vehicle_vectornet_file);
+DECLARE_string(torch_vehicle_vectornet_cpu_file);
 DECLARE_string(torch_pedestrian_interaction_position_embedding_file);
 DECLARE_string(torch_pedestrian_interaction_social_embedding_file);
 DECLARE_string(torch_pedestrian_interaction_single_lstm_file);
</diff>
			</file>
			<file old_path="modules\prediction\common\prediction_system_gflags.cc" new_path="modules\prediction\common\prediction_system_gflags.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -60,7 +60,7 @@ DEFINE_int32(max_caution_thread_num, 2,
              "Maximal number of threads for caution obstacles.");
 DEFINE_bool(enable_async_draw_base_image, true,
             "If enable async to draw base image");
-DEFINE_bool(use_cuda, true, "If use cuda for torch.");
+DEFINE_bool(use_cuda, false, "If use cuda for torch.");
 
 // Bag replay timestamp gap
 DEFINE_double(replay_timestamp_gap, 10.0,
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\evaluator_manager.cc" new_path="modules\prediction\evaluator\evaluator_manager.cc" added_lines="6" deleted_lines="0">
				<diff>@@ -35,6 +35,7 @@
 #include "modules/prediction/evaluator/vehicle/lane_scanning_evaluator.h"
 #include "modules/prediction/evaluator/vehicle/mlp_evaluator.h"
 #include "modules/prediction/evaluator/vehicle/semantic_lstm_evaluator.h"
+#include "modules/prediction/evaluator/vehicle/vectornet_evaluator.h"
 
 namespace apollo {
 namespace prediction {
@@ -104,6 +105,7 @@ void EvaluatorManager::RegisterEvaluators() {
   RegisterEvaluator(ObstacleConf::LANE_AGGREGATING_EVALUATOR);
   RegisterEvaluator(ObstacleConf::JUNCTION_MAP_EVALUATOR);
   RegisterEvaluator(ObstacleConf::SEMANTIC_LSTM_EVALUATOR);
+  RegisterEvaluator(ObstacleConf::VECTORNET_EVALUATOR);
 }
 
 void EvaluatorManager::Init(const PredictionConf&amp; config) {
@@ -408,6 +410,10 @@ std::unique_ptr&lt;Evaluator&gt; EvaluatorManager::CreateEvaluator(
       evaluator_ptr.reset(new SemanticLSTMEvaluator(semantic_map_.get()));
       break;
     }
+    case ObstacleConf::VECTORNET_EVALUATOR: {
+      evaluator_ptr.reset(new VectornetEvaluator());
+      break;
+    }
     default: {
       break;
     }
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\evaluator_manager.h" new_path="modules\prediction\evaluator\evaluator_manager.h" added_lines="4" deleted_lines="0">
				<diff>@@ -31,6 +31,7 @@
 #include "modules/prediction/common/semantic_map.h"
 #include "modules/prediction/evaluator/evaluator.h"
 #include "modules/prediction/proto/prediction_conf.pb.h"
+#include "modules/prediction/pipeline/vector_net.h"
 
 /**
  * @namespace apollo::prediction
@@ -124,6 +125,9 @@ class EvaluatorManager {
   ObstacleConf::EvaluatorType pedestrian_evaluator_ =
       ObstacleConf::SEMANTIC_LSTM_EVALUATOR;
 
+  ObstacleConf::EvaluatorType vectornet_evaluator_ =
+      ObstacleConf::VECTORNET_EVALUATOR;
+
   ObstacleConf::EvaluatorType default_on_lane_evaluator_ =
       ObstacleConf::MLP_EVALUATOR;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f047e75ed7d3890d7cf09b0ff1f9d23af5364646" author="jinyunzhou">
		<msg>Planning: add more latency log and remove an unused variable

Change-Id: Ia8ccbd2afa2d445e96365a7397a241887fcfe185</msg>
		<modified_files>
			<file old_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" added_lines="76" deleted_lines="64">
				<diff>@@ -16,8 +16,8 @@
 
 #include "modules/prediction/evaluator/vehicle/vectornet_evaluator.h"
 
-#include &lt;limits&gt;
 #include &lt;omp.h&gt;
+#include &lt;limits&gt;
 
 #include "Eigen/Dense"
 #include "cyber/common/file.h"
@@ -33,8 +33,7 @@ using apollo::common::TrajectoryPoint;
 using apollo::common::math::Vec2d;
 using apollo::prediction::VectorNet;
 
-VectornetEvaluator::VectornetEvaluator()
-    : device_(torch::kCPU) {
+VectornetEvaluator::VectornetEvaluator() : device_(torch::kCPU) {
   evaluator_type_ = ObstacleConf::VECTORNET_EVALUATOR;
   LoadModel();
 }
@@ -42,7 +41,7 @@ VectornetEvaluator::VectornetEvaluator()
 void VectornetEvaluator::Clear() {}
 
 bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
-                                     ObstaclesContainer* obstacles_container) {
+                                  ObstaclesContainer* obstacles_container) {
   omp_set_num_threads(1);
 
   obstacle_ptr-&gt;SetEvaluatorType(evaluator_type_);
@@ -62,12 +61,9 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   std::vector&lt;std::pair&lt;double, double&gt;&gt; target_pos_history(20, {0.0, 0.0});
   std::vector&lt;std::pair&lt;double, double&gt;&gt; all_obs_length;
   std::vector&lt;std::vector&lt;std::pair&lt;double, double&gt;&gt;&gt; all_obs_pos_history;
-  if (!ExtractObstaclesHistory(
-        obstacle_ptr,
-        obstacles_container,
-        &amp;target_pos_history,
-        &amp;all_obs_length,
-        &amp;all_obs_pos_history)) {
+  if (!ExtractObstaclesHistory(obstacle_ptr, obstacles_container,
+                               &amp;target_pos_history, &amp;all_obs_length,
+                               &amp;all_obs_pos_history)) {
     ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id &lt;&lt; "] failed to extract obstacle history";
     return false;
   }
@@ -88,8 +84,8 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   }
 
   // Process all obs pos_history
-  int obs_num = obstacles_container
-      -&gt;curr_frame_considered_obstacle_ids().size();
+  int obs_num =
+      obstacles_container-&gt;curr_frame_considered_obstacle_ids().size();
   torch::Tensor all_obstacle_pos = torch::zeros({obs_num, 20, 2});
   for (int i = 0; i &lt; obs_num; ++i) {
     for (int j = 0; j &lt; 20; ++j) {
@@ -107,11 +103,20 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   center_point.set_x(pos_x);
   center_point.set_y(pos_y);
   double heading = latest_feature_ptr-&gt;velocity_heading();
+
+  auto start_time_query = std::chrono::system_clock::now();
+
   VectorNet vector_net = VectorNet();
   if (!vector_net.query(center_point, heading, &amp;map_feature, &amp;map_p_id)) {
     return false;
   }
 
+  auto end_time_query = std::chrono::system_clock::now();
+  std::chrono::duration&lt;double&gt; diff_query = end_time_query - start_time_query;
+  ADEBUG &lt;&lt; "vectors query used time: " &lt;&lt; diff.count() * 1000 &lt;&lt; " ms.";
+
+  auto start_time_data_prep = std::chrono::system_clock::now();
+
   // Process mask &amp; p_id
   // process v_mask for obs
   int obs_his_size = obstacle_ptr-&gt;history_size();
@@ -119,14 +124,15 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   // torch::Tensor obs_p_id = torch::zeros({obs_num, 2});
   for (int i = 0; i &lt; obs_num; ++i) {
     if (obs_his_size &gt; 1 &amp;&amp; obs_his_size &lt;= 20) {
-      vector_mask.index_put_({i, torch::indexing::Slice(
-          torch::indexing::None, -(obs_his_size - 1))}, 1);
+      vector_mask.index_put_({i, torch::indexing::Slice(torch::indexing::None,
+                                                        -(obs_his_size - 1))},
+                             1);
     } else if (obs_his_size &gt; 20) {
-      vector_mask.index_put_({i, torch::indexing::Slice(
-          torch::indexing::None, -19)}, 1);
+      vector_mask.index_put_(
+          {i, torch::indexing::Slice(torch::indexing::None, -19)}, 1);
     } else {
-      vector_mask.index_put_({i, torch::indexing::Slice(
-          torch::indexing::None, -1)}, 1);
+      vector_mask.index_put_(
+          {i, torch::indexing::Slice(torch::indexing::None, -1)}, 1);
     }
   }
 
@@ -135,8 +141,9 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   for (int i = obs_num; i &lt;= map_polyline_num; ++i) {
     int one_polyline_vector_num = map_feature[i].size();
     if (one_polyline_vector_num &lt; 50) {
-      vector_mask.index_put_({i, torch::indexing::Slice(
-          one_polyline_vector_num, torch::indexing::None)}, 1);
+      vector_mask.index_put_({i, torch::indexing::Slice(one_polyline_vector_num,
+                                                        torch::indexing::None)},
+                             1);
     }
   }
 
@@ -154,17 +161,16 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   torch::Tensor polyline_mask = torch::zeros({450});
   int data_length = obs_num + map_polyline_num;
   if (data_length &lt; 450) {
-    polyline_mask.index_put_({torch::indexing::Slice(
-        data_length, torch::indexing::None)}, 1);
+    polyline_mask.index_put_(
+        {torch::indexing::Slice(data_length, torch::indexing::None)}, 1);
   }
 
-
   // process p_id for obs and map p_id
   torch::Tensor all_obs_p_id = torch::zeros({obs_num, 2});
   torch::Tensor all_map_p_id = torch::zeros({map_polyline_num, 2});
   for (int i = 0; i &lt; obs_num; ++i) {
     std::vector&lt;double&gt; obs_p_id{std::numeric_limits&lt;float&gt;::max(),
-                                     std::numeric_limits&lt;float&gt;::max()};
+                                 std::numeric_limits&lt;float&gt;::max()};
     for (int j = 0; j &lt; obs_his_size &amp;&amp; j &lt; 20; ++j) {
       if (obs_p_id[0] &gt; obstacle_ptr-&gt;latest_feature().position().x()) {
         obs_p_id[0] = obstacle_ptr-&gt;latest_feature().position().x();
@@ -183,28 +189,27 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   }
 
   // Extend obs data to specific dimension
-  torch::Tensor obs_pos_data = torch::cat({
-      all_obstacle_pos.index({torch::indexing::Slice(),
-          torch::indexing::Slice(torch::indexing::None, -1),
-          torch::indexing::Slice()}),
-      all_obstacle_pos.index({torch::indexing::Slice(),
-          torch::indexing::Slice(1, torch::indexing::None),
-          torch::indexing::Slice()})}, 2);
+  torch::Tensor obs_pos_data = torch::cat(
+      {all_obstacle_pos.index(
+           {torch::indexing::Slice(),
+            torch::indexing::Slice(torch::indexing::None, -1),
+            torch::indexing::Slice()}),
+       all_obstacle_pos.index({torch::indexing::Slice(),
+                               torch::indexing::Slice(1, torch::indexing::None),
+                               torch::indexing::Slice()})},
+      2);
   // Add obs length
   torch::Tensor obs_length_tmp = torch::zeros({obs_num, 2});
   for (int i = 0; i &lt; obs_num; ++i) {
     obs_length_tmp[i][0] = all_obs_length[i].first;
     obs_length_tmp[i][1] = all_obs_length[i].second;
   }
-  torch::Tensor obs_length = obs_length_tmp.unsqueeze(1).repeat(
-      {1, 19, 1});
+  torch::Tensor obs_length = obs_length_tmp.unsqueeze(1).repeat({1, 19, 1});
   // Add obs attribute
   torch::Tensor obs_attr_agent =
-      torch::tensor({11.0, 4.0}).unsqueeze(0).unsqueeze(0).repeat(
-      {1, 19, 1});
+      torch::tensor({11.0, 4.0}).unsqueeze(0).unsqueeze(0).repeat({1, 19, 1});
   torch::Tensor obs_attr_other =
-      torch::tensor({10.0, 4.0}).unsqueeze(0).unsqueeze(0).repeat(
-      {1, 19, 1});
+      torch::tensor({10.0, 4.0}).unsqueeze(0).unsqueeze(0).repeat({1, 19, 1});
   torch::Tensor obs_attr = torch::cat({obs_attr_agent, obs_attr_other}, 0);
   // ADD obs id
   torch::Tensor obs_id =
@@ -214,9 +219,8 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   torch::Tensor obs_data_with_attr =
       torch::cat({obs_data_with_len, obs_attr}, 2);
   torch::Tensor obs_data_with_id = torch::cat({obs_data_with_attr, obs_id}, 2);
-  torch::Tensor obs_data_final = torch::cat({
-      torch::zeros({obs_num, (50 - 19), 9}),
-      obs_data_with_id}, 1);
+  torch::Tensor obs_data_final =
+      torch::cat({torch::zeros({obs_num, (50 - 19), 9}), obs_data_with_id}, 1);
 
   // Extend data &amp; pid to specific demension
   torch::Tensor data_tmp = torch::cat({obs_data_final, map_data}, 0);
@@ -247,21 +251,28 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
        std::move(rand_mask.unsqueeze(0).to(device_)),
        std::move(polyline_id.unsqueeze(0).to(device_))}));
 
-  // Compute pred_traj
-  std::vector&lt;double&gt; pred_traj;
+  auto end_time_data_prep = std::chrono::system_clock::now();
+  std::chrono::duration&lt;double&gt; diff_data_prep =
+      end_time_data_prep - start_time_data_prep;
+  ADEBUG &lt;&lt; "vectornet input tensor prepration used time: "
+         &lt;&lt; diff_data_prep.count() * 1000 &lt;&lt; " ms.";
+
+  auto start_time_inference = std::chrono::system_clock::now();
 
-  auto start_time = std::chrono::system_clock::now();
   at::Tensor torch_output_tensor = torch_default_output_tensor_;
   torch_output_tensor =
       torch_vehicle_model_.forward(torch_inputs).toTensor().to(torch::kCPU);
 
-  auto end_time = std::chrono::system_clock::now();
-  std::chrono::duration&lt;double&gt; diff = end_time - start_time;
-  ADEBUG &lt;&lt; "vectornet_evaluator used time: " &lt;&lt; diff.count() * 1000
+  auto end_time_inference = std::chrono::system_clock::now();
+  std::chrono::duration&lt;double&gt; diff_inference =
+      end_time_inference - start_time_inference;
+  ADEBUG &lt;&lt; "vectornet inference used time: " &lt;&lt; diff_inference.count() * 1000
          &lt;&lt; " ms.";
-  auto torch_output = torch_output_tensor.accessor&lt;float, 3&gt;();
 
   // Get the trajectory
+  auto start_time_output_process = std::chrono::system_clock::now();
+
+  auto torch_output = torch_output_tensor.accessor&lt;float, 3&gt;();
   Trajectory* trajectory = latest_feature_ptr-&gt;add_predicted_trajectory();
   trajectory-&gt;set_probability(1.0);
 
@@ -306,12 +317,17 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
                    FLAGS_prediction_trajectory_time_resolution);
     }
   }
+
+  auto end_time_output_process = std::chrono::system_clock::now();
+  std::chrono::duration&lt;double&gt; diff_output_process =
+      end_time_output_process - start_time_output_process;
+  ADEBUG &lt;&lt; "vectornet output process used time: "
+         &lt;&lt; diff_output_process.count() * 1000 &lt;&lt; " ms.";
   return true;
 }
 
 bool VectornetEvaluator::ExtractObstaclesHistory(
-    Obstacle* obstacle_ptr,
-    ObstaclesContainer* obstacles_container,
+    Obstacle* obstacle_ptr, ObstaclesContainer* obstacles_container,
     std::vector&lt;std::pair&lt;double, double&gt;&gt;* target_pos_history,
     std::vector&lt;std::pair&lt;double, double&gt;&gt;* all_obs_length,
     std::vector&lt;std::vector&lt;std::pair&lt;double, double&gt;&gt;&gt;* all_obs_pos_history) {
@@ -326,14 +342,13 @@ bool VectornetEvaluator::ExtractObstaclesHistory(
     if (!target_feature.IsInitialized()) {
       break;
     }
-    tar_pos_his[i] = WorldCoordToObjCoord(
-        std::make_pair(target_feature.position().x(),
-                       target_feature.position().y()),
-        obs_curr_pos, obs_curr_heading);
+    tar_pos_his[i] =
+        WorldCoordToObjCoord(std::make_pair(target_feature.position().x(),
+                                            target_feature.position().y()),
+                             obs_curr_pos, obs_curr_heading);
   }
   all_obs_length-&gt;emplace_back(
-      std::make_pair(obs_curr_feature.length(),
-      obs_curr_feature.width()));
+      std::make_pair(obs_curr_feature.length(), obs_curr_feature.width()));
   all_obs_pos_history-&gt;emplace_back(tar_pos_his);
   target_pos_history = &amp;tar_pos_his;
 
@@ -346,9 +361,8 @@ bool VectornetEvaluator::ExtractObstaclesHistory(
       continue;
     }
     const Feature&amp; other_obs_curr_feature = obstacle-&gt;latest_feature();
-    all_obs_length-&gt;emplace_back(
-        std::make_pair(other_obs_curr_feature.length(),
-        other_obs_curr_feature.width()));
+    all_obs_length-&gt;emplace_back(std::make_pair(
+        other_obs_curr_feature.length(), other_obs_curr_feature.width()));
 
     for (std::size_t i = 0; i &lt; obstacle-&gt;history_size() &amp;&amp; i &lt; 20; ++i) {
       const Feature&amp; feature = obstacle-&gt;feature(i);
@@ -376,7 +390,7 @@ void VectornetEvaluator::LoadModel() {
   }
   torch::set_num_threads(1);
 
-// Fake intput for the first frame
+  // Fake intput for the first frame
   torch::Tensor target_obstacle_pos = torch::zeros({1, 20, 2});
   torch::Tensor target_obstacle_pos_step = torch::zeros({1, 20, 2});
   torch::Tensor vector_data = torch::zeros({1, 450, 50, 9});
@@ -388,12 +402,10 @@ void VectornetEvaluator::LoadModel() {
   torch_inputs.push_back(c10::ivalue::Tuple::create(
       {std::move(target_obstacle_pos.to(device_)),
        std::move(target_obstacle_pos_step.to(device_)),
-       std::move(vector_data.to(device_)),
-       std::move(vector_mask.to(device_)),
-       std::move(polyline_mask.to(device_)),
-       std::move(rand_mask.to(device_)),
+       std::move(vector_data.to(device_)), std::move(vector_mask.to(device_)),
+       std::move(polyline_mask.to(device_)), std::move(rand_mask.to(device_)),
        std::move(polyline_id.to(device_))}));
-// Run one inference to avoid very slow first inference later
+  // Run one inference to avoid very slow first inference later
   torch_default_output_tensor_ =
       torch_vehicle_model_.forward(torch_inputs).toTensor().to(torch::kCPU);
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="326ea16d34a10086c4ba660fb1038f5b6dec3a05" author="jinyunzhou">
		<msg>Prediction: move reload map in vectornet to contruction time and related file lint

Change-Id: I2f35a0624a2a047cfe9817e87d569d242a98224e</msg>
		<modified_files>
			<file old_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" added_lines="2" deleted_lines="3">
				<diff>@@ -106,14 +106,13 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
 
   auto start_time_query = std::chrono::system_clock::now();
 
-  VectorNet vector_net = VectorNet();
-  if (!vector_net.query(center_point, heading, &amp;map_feature, &amp;map_p_id)) {
+  if (!vector_net_.query(center_point, heading, &amp;map_feature, &amp;map_p_id)) {
     return false;
   }
 
   auto end_time_query = std::chrono::system_clock::now();
   std::chrono::duration&lt;double&gt; diff_query = end_time_query - start_time_query;
-  ADEBUG &lt;&lt; "vectors query used time: " &lt;&lt; diff.count() * 1000 &lt;&lt; " ms.";
+  ADEBUG &lt;&lt; "vectors query used time: " &lt;&lt; diff_query.count() * 1000 &lt;&lt; " ms.";
 
   auto start_time_data_prep = std::chrono::system_clock::now();
 
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.h" new_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.h" added_lines="4" deleted_lines="4">
				<diff>@@ -20,10 +20,10 @@
 #include &lt;utility&gt;
 #include &lt;vector&gt;
 
-#include "modules/prediction/evaluator/evaluator.h"
-#include "modules/prediction/pipeline/vector_net.h"
 #include "torch/extension.h"
 #include "torch/script.h"
+#include "modules/prediction/evaluator/evaluator.h"
+#include "modules/prediction/pipeline/vector_net.h"
 
 namespace apollo {
 namespace prediction {
@@ -59,8 +59,7 @@ class VectornetEvaluator : public Evaluator {
    *        Feature container in a vector for receiving the obstacle history
    */
   bool ExtractObstaclesHistory(
-      Obstacle* obstacle_ptr,
-      ObstaclesContainer* obstacles_container,
+      Obstacle* obstacle_ptr, ObstaclesContainer* obstacles_container,
       std::vector&lt;std::pair&lt;double, double&gt;&gt;* curr_pos_history,
       std::vector&lt;std::pair&lt;double, double&gt;&gt;* all_obs_length,
       std::vector&lt;std::vector&lt;std::pair&lt;double, double&gt;&gt;&gt;* all_obs_pos_history);
@@ -80,6 +79,7 @@ class VectornetEvaluator : public Evaluator {
   torch::jit::script::Module torch_vehicle_model_;
   at::Tensor torch_default_output_tensor_;
   torch::Device device_;
+  VectorNet vector_net_;
 };
 
 }  // namespace prediction
</diff>
			</file>
			<file old_path="modules\prediction\pipeline\vector_net.cc" new_path="modules\prediction\pipeline\vector_net.cc" added_lines="22" deleted_lines="25">
				<diff>@@ -24,21 +24,20 @@
 
 namespace apollo {
 namespace prediction {
-
 template &lt;typename Points&gt;
 void VectorNet::GetOnePolyline(
-                          const Points&amp; points, double *start_length,
-                          const common::PointENU&amp; center_point,
-                          const double obstacle_phi, ATTRIBUTE_TYPE attr_type,
-                          BOUNDARY_TYPE bound_type, const int count,
-                          std::vector&lt;std::vector&lt;double&gt;&gt;* const one_polyline,
-                          std::vector&lt;double&gt;* const one_p_id) {
+    const Points&amp; points, double* start_length,
+    const common::PointENU&amp; center_point, const double obstacle_phi,
+    ATTRIBUTE_TYPE attr_type, BOUNDARY_TYPE bound_type, const int count,
+    std::vector&lt;std::vector&lt;double&gt;&gt;* const one_polyline,
+    std::vector&lt;double&gt;* const one_p_id) {
   size_t size = points.size();
   std::vector&lt;double&gt; s(size, 0);
 
   for (size_t i = 1; i &lt; size; ++i) {
     s[i] = std::hypot(points.at(i).x() - points.at(i - 1).x(),
-                      points.at(i).y() - points.at(i - 1).y()) + s[i - 1];
+                      points.at(i).y() - points.at(i - 1).y()) +
+           s[i - 1];
   }
 
   std::vector&lt;double&gt; x;
@@ -53,12 +52,10 @@ void VectorNet::GetOnePolyline(
     } else {
       const auto distance = std::distance(s.begin(), it_lower);
       x.push_back(common::math::lerp(points.at(distance - 1).x(),
-                                     s[distance - 1],
-                                     points.at(distance).x(),
+                                     s[distance - 1], points.at(distance).x(),
                                      s[distance], cur_length));
       y.push_back(common::math::lerp(points.at(distance - 1).y(),
-                                     s[distance - 1],
-                                     points.at(distance).y(),
+                                     s[distance - 1], points.at(distance).y(),
                                      s[distance], cur_length));
     }
     cur_length += FLAGS_point_distance;
@@ -71,8 +68,8 @@ void VectorNet::GetOnePolyline(
   const double attr = attribute_map.at(attr_type);
   const double bound = boundary_map.at(bound_type);
   auto last_point_after_rotate = common::math::RotateVector2d(
-    {x[0] - center_point.x(), y[0] - center_point.y()},
-    M_PI_2 - obstacle_phi);
+      {x[0] - center_point.x(), y[0] - center_point.y()},
+      M_PI_2 - obstacle_phi);
 
   for (size_t i = 1; i &lt; point_size; ++i) {
     if (one_p_id-&gt;at(0) &gt; last_point_after_rotate.x()) {
@@ -89,8 +86,8 @@ void VectorNet::GetOnePolyline(
     one_vector.push_back(last_point_after_rotate.y());
 
     Eigen::Vector2d point_after_rotate = common::math::RotateVector2d(
-      {x[i] - center_point.x(), y[i] - center_point.y()},
-      M_PI_2 - obstacle_phi);
+        {x[i] - center_point.x(), y[i] - center_point.y()},
+        M_PI_2 - obstacle_phi);
 
     one_vector.push_back(point_after_rotate.x());
     one_vector.push_back(point_after_rotate.y());
@@ -110,7 +107,6 @@ bool VectorNet::query(const common::PointENU&amp; center_point,
                       PidVector* const p_id_ptr) {
   CHECK_NOTNULL(feature_ptr);
   count_ = 0;
-  apollo::hdmap::HDMapUtil::ReloadMaps();
   GetRoads(center_point, obstacle_phi, feature_ptr, p_id_ptr);
   GetLanes(center_point, obstacle_phi, feature_ptr, p_id_ptr);
   GetJunctions(center_point, obstacle_phi, feature_ptr, p_id_ptr);
@@ -178,8 +174,8 @@ void VectorNet::GetRoads(const common::PointENU&amp; center_point,
 
         for (const auto&amp; segment : edge.curve().segment()) {
           GetOnePolyline(segment.line_segment().point(), &amp;start_length,
-                         center_point, obstacle_phi, ROAD, bound_type,
-                         count_, &amp;one_polyline, &amp;one_p_id);
+                         center_point, obstacle_phi, ROAD, bound_type, count_,
+                         &amp;one_polyline, &amp;one_p_id);
         }
         if (one_polyline.size() == 0) continue;
 
@@ -191,8 +187,9 @@ void VectorNet::GetRoads(const common::PointENU&amp; center_point,
   }
 }
 
-void VectorNet::GetLaneQueue(const std::vector&lt;hdmap::LaneInfoConstPtr&gt;&amp; lanes,
-  std::vector&lt;std::deque&lt;hdmap::LaneInfoConstPtr&gt;&gt;* const lane_deque_ptr) {
+void VectorNet::GetLaneQueue(
+    const std::vector&lt;hdmap::LaneInfoConstPtr&gt;&amp; lanes,
+    std::vector&lt;std::deque&lt;hdmap::LaneInfoConstPtr&gt;&gt;* const lane_deque_ptr) {
   std::unordered_set&lt;hdmap::LaneInfoConstPtr&gt; lane_set(lanes.begin(),
                                                        lanes.end());
 
@@ -249,9 +246,9 @@ void VectorNet::GetLanes(const common::PointENU&amp; center_point,
       std::cout &lt;&lt; lane-&gt;lane().id().id() &lt;&lt; " ";
       // if (lane-&gt;lane().left_boundary().virtual_()) continue;
       for (const auto&amp; segment :
-             lane-&gt;lane().left_boundary().curve().segment()) {
+           lane-&gt;lane().left_boundary().curve().segment()) {
         auto bound_type =
-          lane-&gt;lane().left_boundary().boundary_type(0).types(0);
+            lane-&gt;lane().left_boundary().boundary_type(0).types(0);
         GetOnePolyline(segment.line_segment().point(), &amp;start_length,
                        center_point, obstacle_phi, lane_attr_map.at(bound_type),
                        LEFT_BOUNDARY, count_, &amp;left_polyline, &amp;left_p_id);
@@ -271,9 +268,9 @@ void VectorNet::GetLanes(const common::PointENU&amp; center_point,
     for (const auto&amp; lane : lane_deque) {
       // if (lane-&gt;lane().right_boundary().virtual_()) continue;
       for (const auto&amp; segment :
-             lane-&gt;lane().right_boundary().curve().segment()) {
+           lane-&gt;lane().right_boundary().curve().segment()) {
         auto bound_type =
-          lane-&gt;lane().left_boundary().boundary_type(0).types(0);
+            lane-&gt;lane().left_boundary().boundary_type(0).types(0);
         GetOnePolyline(segment.line_segment().point(), &amp;start_length,
                        center_point, obstacle_phi, lane_attr_map.at(bound_type),
                        RIGHT_BOUNDARY, count_, &amp;right_polyline, &amp;right_p_id);
</diff>
			</file>
			<file old_path="modules\prediction\pipeline\vector_net.h" new_path="modules\prediction\pipeline\vector_net.h" added_lines="37" deleted_lines="43">
				<diff>@@ -20,11 +20,11 @@
 #include &lt;map&gt;
 #include &lt;vector&gt;
 
+#include "modules/prediction/proto/vector_net.pb.h"
 #include "modules/common/math/linear_interpolation.h"
 #include "modules/common/util/point_factory.h"
 #include "modules/map/hdmap/hdmap_util.h"
 #include "modules/prediction/common/prediction_system_gflags.h"
-#include "modules/prediction/proto/vector_net.pb.h"
 
 namespace apollo {
 namespace prediction {
@@ -54,7 +54,7 @@ enum BOUNDARY_TYPE {
 
 class VectorNet {
  public:
-  VectorNet() = default;
+  VectorNet() { apollo::hdmap::HDMapUtil::ReloadMaps(); };
 
   ~VectorNet() = default;
 
@@ -67,62 +67,56 @@ class VectorNet {
  private:
   // TODO(Yiqun): 1.Left/Right boundary 2.Ordinal Encoding
   const std::map&lt;ATTRIBUTE_TYPE, double&gt; attribute_map{
-    {ROAD, 0.0},
-    {LANE_UNKOWN, 1.0},
-    {LANE_DOTTED_YELLOW, 2.0},
-    {LANE_DOTTED_WHITE, 3.0},
-    {LANE_SOLID_YELLOW, 4.0},
-    {LANE_SOLID_WHITE, 5.0},
-    {LANE_DOUBLE_YELLOW, 6.0},
-    {LANE_CURB, 7.0},
-    {JUNCTION, 8.0},
-    {CROSSWALK, 9.0},
+      {ROAD, 0.0},
+      {LANE_UNKOWN, 1.0},
+      {LANE_DOTTED_YELLOW, 2.0},
+      {LANE_DOTTED_WHITE, 3.0},
+      {LANE_SOLID_YELLOW, 4.0},
+      {LANE_SOLID_WHITE, 5.0},
+      {LANE_DOUBLE_YELLOW, 6.0},
+      {LANE_CURB, 7.0},
+      {JUNCTION, 8.0},
+      {CROSSWALK, 9.0},
   };
 
   const std::map&lt;BOUNDARY_TYPE, double&gt; boundary_map{
-    {UNKNOW, 0.0},
-    {NORMAL, 1.0},
-    {LEFT_BOUNDARY, 2.0},
-    {RIGHT_BOUNDARY, 3.0},
+      {UNKNOW, 0.0}, {NORMAL, 1.0}, {LEFT_BOUNDARY, 2.0}, {RIGHT_BOUNDARY, 3.0},
   };
 
   const std::map&lt;hdmap::LaneBoundaryType::Type, ATTRIBUTE_TYPE&gt; lane_attr_map{
-    {hdmap::LaneBoundaryType::UNKNOWN, LANE_UNKOWN},
-    {hdmap::LaneBoundaryType::DOTTED_YELLOW, LANE_DOTTED_YELLOW},
-    {hdmap::LaneBoundaryType::DOTTED_WHITE, LANE_DOTTED_WHITE},
-    {hdmap::LaneBoundaryType::SOLID_YELLOW, LANE_SOLID_YELLOW},
-    {hdmap::LaneBoundaryType::SOLID_WHITE, LANE_SOLID_WHITE},
-    {hdmap::LaneBoundaryType::DOUBLE_YELLOW, LANE_DOUBLE_YELLOW},
-    {hdmap::LaneBoundaryType::CURB, LANE_CURB},
+      {hdmap::LaneBoundaryType::UNKNOWN, LANE_UNKOWN},
+      {hdmap::LaneBoundaryType::DOTTED_YELLOW, LANE_DOTTED_YELLOW},
+      {hdmap::LaneBoundaryType::DOTTED_WHITE, LANE_DOTTED_WHITE},
+      {hdmap::LaneBoundaryType::SOLID_YELLOW, LANE_SOLID_YELLOW},
+      {hdmap::LaneBoundaryType::SOLID_WHITE, LANE_SOLID_WHITE},
+      {hdmap::LaneBoundaryType::DOUBLE_YELLOW, LANE_DOUBLE_YELLOW},
+      {hdmap::LaneBoundaryType::CURB, LANE_CURB},
   };
 
   template &lt;typename Points&gt;
-  void GetOnePolyline(const Points&amp; points, double *start_length,
-                     const common::PointENU&amp; center_point,
-                     const double obstacle_phi, ATTRIBUTE_TYPE attr_type,
-                     BOUNDARY_TYPE bound_type, const int count,
-                     std::vector&lt;std::vector&lt;double&gt;&gt;* const one_polyline,
-                     std::vector&lt;double&gt;* const one_p_id);
-
-  void GetRoads(const common::PointENU&amp; center_point,
-                const double obstacle_phi,
+  void GetOnePolyline(const Points&amp; points, double* start_length,
+                      const common::PointENU&amp; center_point,
+                      const double obstacle_phi, ATTRIBUTE_TYPE attr_type,
+                      BOUNDARY_TYPE bound_type, const int count,
+                      std::vector&lt;std::vector&lt;double&gt;&gt;* const one_polyline,
+                      std::vector&lt;double&gt;* const one_p_id);
+
+  void GetRoads(const common::PointENU&amp; center_point, const double obstacle_phi,
                 FeatureVector* const feature_ptr, PidVector* const p_id_ptr);
 
-  void GetLaneQueue(const std::vector&lt;hdmap::LaneInfoConstPtr&gt;&amp; lanes,
-    std::vector&lt;std::deque&lt;hdmap::LaneInfoConstPtr&gt;&gt;* const lane_deque_ptr);
+  void GetLaneQueue(
+      const std::vector&lt;hdmap::LaneInfoConstPtr&gt;&amp; lanes,
+      std::vector&lt;std::deque&lt;hdmap::LaneInfoConstPtr&gt;&gt;* const lane_deque_ptr);
 
-  void GetLanes(const common::PointENU&amp; center_point,
-                           const double obstacle_phi,
-                           FeatureVector* const feature_ptr,
-                           PidVector* const p_id_ptr);
+  void GetLanes(const common::PointENU&amp; center_point, const double obstacle_phi,
+                FeatureVector* const feature_ptr, PidVector* const p_id_ptr);
   void GetJunctions(const common::PointENU&amp; center_point,
-                    const double obstacle_phi,
-                    FeatureVector* const feature_ptr,
+                    const double obstacle_phi, FeatureVector* const feature_ptr,
                     PidVector* const p_id_ptr);
   void GetCrosswalks(const common::PointENU&amp; center_point,
-                    const double obstacle_phi,
-                    FeatureVector* const feature_ptr,
-                    PidVector* const p_id_ptr);
+                     const double obstacle_phi,
+                     FeatureVector* const feature_ptr,
+                     PidVector* const p_id_ptr);
   int count_ = 0;
 };
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8fcc479ae02fef350a4a03922309d5193a16d401" author="lilu15">
		<msg>planning: add dead end scenario and configure

Change-Id: Id99de952c28b1efdf804cfa26af7ff72c492af06</msg>
		<modified_files>
			<file old_path="modules\planning\common\planning_gflags.cc" new_path="modules\planning\common\planning_gflags.cc" added_lines="4" deleted_lines="0">
				<diff>@@ -83,6 +83,10 @@ DEFINE_string(scenario_valet_parking_config_file,
               "/apollo/modules/planning/conf/"
               "scenario/valet_parking_config.pb.txt",
               "valet_parking scenario config file");
+DEFINE_string(scenario_deadend_turnaround_config_file,
+              "/apollo/modules/planning/conf/"
+              "scenario/deadend_turnaround_config.pb.txt",
+              "deadend_turnaround scenario config file");
 DEFINE_string(scenario_yield_sign_config_file,
               "/apollo/modules/planning/conf/"
               "scenario/yield_sign_config.pb.txt",
</diff>
			</file>
			<file old_path="modules\planning\common\planning_gflags.h" new_path="modules\planning\common\planning_gflags.h" added_lines="1" deleted_lines="0">
				<diff>@@ -38,6 +38,7 @@ DECLARE_string(scenario_traffic_light_protected_config_file);
 DECLARE_string(scenario_traffic_light_unprotected_left_turn_config_file);
 DECLARE_string(scenario_traffic_light_unprotected_right_turn_config_file);
 DECLARE_string(scenario_valet_parking_config_file);
+DECLARE_string(scenario_deadend_turnaround_config_file);
 DECLARE_string(scenario_yield_sign_config_file);
 
 DECLARE_bool(enable_scenario_bare_intersection);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="fe4e50da27a1e4211cf080242733b28299a24a52" author="jinyunzhou">
		<msg>Prediction: decrease vectornet model torch tensor loading by blob in last dimension

Change-Id: I58f4820c4b31aeabab72659757921ebc4ad867ad</msg>
		<modified_files>
			<file old_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" added_lines="2" deleted_lines="4">
				<diff>@@ -120,7 +120,6 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   // process v_mask for obs
   int obs_his_size = obstacle_ptr-&gt;history_size();
   torch::Tensor vector_mask = torch::zeros({450, 50});
-  // torch::Tensor obs_p_id = torch::zeros({obs_num, 2});
   for (int i = 0; i &lt; obs_num; ++i) {
     if (obs_his_size &gt; 1 &amp;&amp; obs_his_size &lt;= 20) {
       vector_mask.index_put_({i, torch::indexing::Slice(torch::indexing::None,
@@ -150,9 +149,8 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   for (int i = 0; i &lt; map_polyline_num &amp;&amp; i &lt; 450; ++i) {
     int one_polyline_vector_num = map_feature[i].size();
     for (int j = 0; j &lt; one_polyline_vector_num &amp;&amp; j &lt; 50; ++j) {
-      for (int k = 0; k &lt; 9; ++k) {
-        map_data[i][j][k] = map_feature[i][j][k];
-      }
+      map_data.index_put_({i, j},
+                          torch::from_blob(map_feature[i][j].data(), {9}));
     }
   }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a332df93f502ba009473b0bb35eb8d2ebdc831a9" author="jinyunzhou">
		<msg>Prediction: fix lint

Change-Id: I5834c8d73a084862f18c548a4d6cd357052384ea</msg>
		<modified_files>
			<file old_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -16,10 +16,11 @@
 
 #include "modules/prediction/evaluator/vehicle/vectornet_evaluator.h"
 
-#include &lt;omp.h&gt;
 #include &lt;limits&gt;
+#include &lt;omp.h&gt;
 
 #include "Eigen/Dense"
+
 #include "cyber/common/file.h"
 #include "modules/prediction/common/prediction_gflags.h"
 #include "modules/prediction/common/prediction_map.h"
</diff>
			</file>
			<file old_path="modules\prediction\pipeline\vector_net.h" new_path="modules\prediction\pipeline\vector_net.h" added_lines="1" deleted_lines="1">
				<diff>@@ -54,7 +54,7 @@ enum BOUNDARY_TYPE {
 
 class VectorNet {
  public:
-  VectorNet() { apollo::hdmap::HDMapUtil::ReloadMaps(); };
+  VectorNet() { apollo::hdmap::HDMapUtil::ReloadMaps(); }
 
   ~VectorNet() = default;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="41165d4400025037802cc3858d0865f29bfe1683" author="jiangjianan">
		<msg>Prediction: fix bug when load vectornet gpu model

Change-Id: I557308473667e9bb51e4609512e282c3885d8c0c</msg>
		<modified_files>
			<file old_path="modules\prediction\common\prediction_system_gflags.cc" new_path="modules\prediction\common\prediction_system_gflags.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -60,7 +60,7 @@ DEFINE_int32(max_caution_thread_num, 2,
              "Maximal number of threads for caution obstacles.");
 DEFINE_bool(enable_async_draw_base_image, true,
             "If enable async to draw base image");
-DEFINE_bool(use_cuda, false, "If use cuda for torch.");
+DEFINE_bool(use_cuda, true, "If use cuda for torch.");
 
 // Bag replay timestamp gap
 DEFINE_double(replay_timestamp_gap, 10.0,
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" added_lines="9" deleted_lines="6">
				<diff>@@ -207,7 +207,8 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   torch::Tensor obs_attr_agent =
       torch::tensor({11.0, 4.0}).unsqueeze(0).unsqueeze(0).repeat({1, 19, 1});
   torch::Tensor obs_attr_other =
-      torch::tensor({10.0, 4.0}).unsqueeze(0).unsqueeze(0).repeat({1, 19, 1});
+      torch::tensor({10.0, 4.0}).unsqueeze(0).unsqueeze(0).repeat(
+        {(obs_num - 1), 19, 1});
   torch::Tensor obs_attr = torch::cat({obs_attr_agent, obs_attr_other}, 0);
   // ADD obs id
   torch::Tensor obs_id =
@@ -237,15 +238,17 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
 
   // Empty rand mask as placeholder
   torch::Tensor rand_mask = torch::zeros({0});
-
+  // Change mask type to bool
+  auto bool_vector_mask = vector_mask.toType(at::kBool);
+  auto bool_polyline_mask = polyline_mask.toType(at::kBool);
   // Build input features for torch
   std::vector&lt;torch::jit::IValue&gt; torch_inputs;
   torch_inputs.push_back(c10::ivalue::Tuple::create(
       {std::move(target_obstacle_pos.unsqueeze(0).to(device_)),
        std::move(target_obstacle_pos_step.unsqueeze(0).to(device_)),
        std::move(vector_data.unsqueeze(0).to(device_)),
-       std::move(vector_mask.unsqueeze(0).to(device_)),
-       std::move(polyline_mask.unsqueeze(0).to(device_)),
+       std::move(bool_vector_mask.unsqueeze(0).to(device_)),
+       std::move(bool_polyline_mask.unsqueeze(0).to(device_)),
        std::move(rand_mask.unsqueeze(0).to(device_)),
        std::move(polyline_id.unsqueeze(0).to(device_))}));
 
@@ -392,8 +395,8 @@ void VectornetEvaluator::LoadModel() {
   torch::Tensor target_obstacle_pos = torch::zeros({1, 20, 2});
   torch::Tensor target_obstacle_pos_step = torch::zeros({1, 20, 2});
   torch::Tensor vector_data = torch::zeros({1, 450, 50, 9});
-  torch::Tensor vector_mask = torch::zeros({1, 450, 50});
-  torch::Tensor polyline_mask = torch::zeros({1, 450});
+  torch::Tensor vector_mask = torch::randn({1, 450, 50}) &gt; 0.9;
+  torch::Tensor polyline_mask = torch::randn({1, 450}) &gt; 0.9;
   torch::Tensor rand_mask = torch::zeros({0});
   torch::Tensor polyline_id = torch::zeros({1, 450, 2});
   std::vector&lt;torch::jit::IValue&gt; torch_inputs;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3887d22c95212cd307461c59faed1373d4f9271f" author="lilu15">
		<msg>planning: add reference line handle and construct roi boundary

Change-Id: I363b66b2a873e352652f80649d41ecb7f5caeac7</msg>
		<modified_files>
			<file old_path="modules\map\pnc_map\path.h" new_path="modules\map\pnc_map\path.h" added_lines="4" deleted_lines="0">
				<diff>@@ -315,6 +315,9 @@ class Path {
   const std::vector&lt;PathOverlap&gt;&amp; parking_space_overlaps() const {
     return parking_space_overlaps_;
   }
+  const std::vector&lt;PathOverlap&gt;&amp; dead_end_overlaps() const {
+    return dead_end_overlaps_;
+  }
 
   double GetLaneLeftWidth(const double s) const;
   double GetLaneRightWidth(const double s) const;
@@ -374,6 +377,7 @@ class Path {
   std::vector&lt;PathOverlap&gt; stop_sign_overlaps_;
   std::vector&lt;PathOverlap&gt; crosswalk_overlaps_;
   std::vector&lt;PathOverlap&gt; parking_space_overlaps_;
+  std::vector&lt;PathOverlap&gt; dead_end_overlaps_;
   std::vector&lt;PathOverlap&gt; junction_overlaps_;
   std::vector&lt;PathOverlap&gt; pnc_junction_overlaps_;
   std::vector&lt;PathOverlap&gt; clear_area_overlaps_;
</diff>
			</file>
			<file old_path="modules\planning\common\planning_gflags.cc" new_path="modules\planning\common\planning_gflags.cc" added_lines="7" deleted_lines="0">
				<diff>@@ -183,6 +183,13 @@ DEFINE_double(planning_upper_speed_limit, 31.3,
 
 DEFINE_double(trajectory_time_length, 8.0, "Trajectory time length");
 
+DEFINE_double(threshold_distance_for_destination, 0.01,
+              "threshold distance for destination");
+
+DEFINE_double(buffer_in_routing, 0.0, "buffer for select in lane for boundary");
+
+DEFINE_double(buffer_out_routing, 2.0,
+              "buffer for select out lane for boundary");
 // planning trajectory output time density control
 DEFINE_double(
     trajectory_time_min_interval, 0.02,
</diff>
			</file>
			<file old_path="modules\planning\common\planning_gflags.h" new_path="modules\planning\common\planning_gflags.h" added_lines="6" deleted_lines="0">
				<diff>@@ -268,6 +268,12 @@ DECLARE_bool(use_front_axe_center_in_path_planning);
 
 DECLARE_bool(use_road_boundary_from_map);
 
+DECLARE_double(threshold_distance_for_destination);
+
+DECLARE_double(buffer_in_routing);
+
+DECLARE_double(buffer_out_routing);
+
 // learning related
 DECLARE_bool(planning_offline_learning);
 DECLARE_string(planning_data_dir);
</diff>
			</file>
			<file old_path="modules\planning\on_lane_planning.cc" new_path="modules\planning\on_lane_planning.cc" added_lines="76" deleted_lines="6">
				<diff>@@ -60,6 +60,10 @@ using apollo::hdmap::HDMapUtil;
 using apollo::planning_internal::SLFrameDebug;
 using apollo::planning_internal::SpeedPlan;
 using apollo::planning_internal::STGraphDebug;
+using apollo::routing::RoutingRequest;
+using apollo::hdmap::JunctionInfoConstPtr;
+using apollo::common::math::Polygon2d;
+using apollo::common::PointENU;
 
 OnLanePlanning::~OnLanePlanning() {
   if (reference_line_provider_) {
@@ -105,7 +109,6 @@ Status OnLanePlanning::Init(const PlanningConfig&amp; config) {
   reference_line_provider_ = std::make_unique&lt;ReferenceLineProvider&gt;(
       injector_-&gt;vehicle_state(), hdmap_);
   reference_line_provider_-&gt;Start();
-
   // dispatch planner
   planner_ = planner_dispatcher_-&gt;DispatchPlanner(config_, injector_);
   if (!planner_) {
@@ -202,6 +205,56 @@ void OnLanePlanning::GenerateStopTrajectory(ADCTrajectory* ptr_trajectory_pb) {
   }
 }
 
+bool OnLanePlanning::JudgeCarInDeadEndJunction(
+    std::vector&lt;JunctionInfoConstPtr&gt;* junctions,
+    const Vec2d&amp; car_position,
+    JunctionInfoConstPtr* target_junction) {
+  // warning: the car only be the one junction
+  size_t junction_num = junctions-&gt;size();
+  if (junction_num &lt;= 0) {
+    return false;
+  }
+  for (size_t i = 0; i &lt; junction_num; ++i) {
+    if (junctions-&gt;at(i)-&gt;junction().type() == DEAD_END) {
+      Polygon2d polygon = junctions-&gt;at(i)-&gt;polygon();
+      // judge dead end point in the select junction
+      if (polygon.IsPointIn(car_position)) {
+        *target_junction = junctions-&gt;at(i);
+        return true;
+      } else {
+        return false;
+      }
+    } else {
+      return false;
+    }
+  }
+  return true;
+}
+
+bool OnLanePlanning::DeadEndHandle(
+  const PointENU&amp; dead_end_point,
+  const VehicleState&amp; vehicle_state) {
+  const hdmap::HDMap* base_map_ptr = hdmap::HDMapUtil::BaseMapPtr();
+  std::vector&lt;JunctionInfoConstPtr&gt; junctions;
+  JunctionInfoConstPtr junction;
+  if (base_map_ptr-&gt;GetJunctions(dead_end_point, 1.0, &amp;junctions) != 0) {
+    ADEBUG &lt;&lt; "Fail to get junctions from base_map.";
+    return false;
+  }
+  if (junctions.size() &lt;= 0) {
+    ADEBUG &lt;&lt; "No junction from map";
+    return false;
+  }
+  Vec2d car_position;
+  car_position.set_x(vehicle_state.x());
+  car_position.set_y(vehicle_state.y());
+  if (!JudgeCarInDeadEndJunction(&amp;junctions, car_position, &amp;junction)) {
+    ADEBUG &lt;&lt; "Target Dead End not found";
+    return false;
+  }
+  return true;
+}
+
 void OnLanePlanning::RunOnce(const LocalView&amp; local_view,
                              ADCTrajectory* const ptr_trajectory_pb) {
   // when rerouting, reference line might not be updated. In this case, planning
@@ -213,7 +266,6 @@ void OnLanePlanning::RunOnce(const LocalView&amp; local_view,
       std::chrono::duration&lt;double&gt;(
           std::chrono::system_clock::now().time_since_epoch())
           .count();
-
   // localization
   ADEBUG &lt;&lt; "Get localization:"
          &lt;&lt; local_view_.localization_estimate-&gt;DebugString();
@@ -225,6 +277,21 @@ void OnLanePlanning::RunOnce(const LocalView&amp; local_view,
       *local_view_.localization_estimate, *local_view_.chassis);
 
   VehicleState vehicle_state = injector_-&gt;vehicle_state()-&gt;vehicle_state();
+  size_t waypoint_num =
+    local_view_.routing-&gt;routing_request().waypoint().size();
+  if (local_view_.routing-&gt;routing_request().dead_end_info().
+    dead_end_routing_type() == routing::ROUTING_IN) {
+    dead_end_point_ = local_view_.routing-&gt;routing_request()
+                    .waypoint().at(waypoint_num - 1).pose();
+  } else if (local_view_.routing-&gt;routing_request().dead_end_info().
+    dead_end_routing_type() == routing::ROUTING_OUT) {
+    dead_end_point_ = local_view_.routing-&gt;routing_request()
+                    .waypoint().at(0).pose();
+  }
+  if (DeadEndHandle(dead_end_point_, vehicle_state) &amp;&amp; !wait_flag_) {
+    // do not use reference line
+    reference_line_provider_-&gt;Wait();
+  }
   const double vehicle_state_timestamp = vehicle_state.timestamp();
   DCHECK_GE(start_timestamp, vehicle_state_timestamp)
       &lt;&lt; "start_timestamp is behind vehicle_state_timestamp by "
@@ -263,7 +330,6 @@ void OnLanePlanning::RunOnce(const LocalView&amp; local_view,
 
   failed_to_update_reference_line =
       (!reference_line_provider_-&gt;UpdatedReferenceLine());
-
   // early return when reference line fails to update after rerouting
   if (failed_to_update_reference_line) {
     const std::string msg = "Failed to update reference line after rerouting.";
@@ -278,7 +344,6 @@ void OnLanePlanning::RunOnce(const LocalView&amp; local_view,
     GenerateStopTrajectory(ptr_trajectory_pb);
     return;
   }
-
   // Update reference line provider and reset pull over if necessary
   reference_line_provider_-&gt;UpdateVehicleState(vehicle_state);
 
@@ -349,9 +414,7 @@ void OnLanePlanning::RunOnce(const LocalView&amp; local_view,
             &lt;&lt; " traffic decider failed";
     }
   }
-
   status = Plan(start_timestamp, stitching_trajectory, ptr_trajectory_pb);
-
   for (const auto&amp; p : ptr_trajectory_pb-&gt;trajectory_point()) {
     ADEBUG &lt;&lt; p.DebugString();
   }
@@ -408,6 +471,13 @@ void OnLanePlanning::RunOnce(const LocalView&amp; local_view,
     }
   }
 
+  // reference line recovery only one frame
+  bool complete_dead_end =
+    frame_.get()-&gt;open_space_info().destination_reached();
+  if (complete_dead_end) {
+    reference_line_provider_-&gt;Start();
+    wait_flag_ = true;
+  }
   const uint32_t n = frame_-&gt;SequenceNum();
   injector_-&gt;frame_history()-&gt;Add(n, std::move(frame_));
 }
</diff>
			</file>
			<file old_path="modules\planning\on_lane_planning.h" new_path="modules\planning\on_lane_planning.h" added_lines="11" deleted_lines="0">
				<diff>@@ -102,10 +102,21 @@ class OnLanePlanning : public PlanningBase {
   void AddFallbackTrajectory(const planning_internal::Debug&amp; debug_info,
                              planning_internal::Debug* debug_chart);
 
+  bool DeadEndHandle(const common::PointENU&amp; dead_end_point,
+                     const common::VehicleState&amp; vehicle_state);
+
+  bool JudgeCarInDeadEndJunction(
+    std::vector&lt;hdmap::JunctionInfoConstPtr&gt;* junctions,
+    const common::math::Vec2d&amp; dead_end_point,
+    hdmap::JunctionInfoConstPtr* target_junction);
+
  private:
   routing::RoutingResponse last_routing_;
   std::unique_ptr&lt;ReferenceLineProvider&gt; reference_line_provider_;
   Smoother planning_smoother_;
+  bool wait_flag_ = false;
+  bool routing_in_flag_ = true;
+  common::PointENU dead_end_point_;
 };
 
 }  // namespace planning
</diff>
			</file>
			<file old_path="modules\planning\reference_line\reference_line_provider.cc" new_path="modules\planning\reference_line\reference_line_provider.cc" added_lines="9" deleted_lines="0">
				<diff>@@ -114,6 +114,7 @@ void ReferenceLineProvider::UpdateVehicleState(
 }
 
 bool ReferenceLineProvider::Start() {
+  is_stop_ = false;
   if (FLAGS_use_navigation_mode) {
     return true;
   }
@@ -128,6 +129,13 @@ bool ReferenceLineProvider::Start() {
   return true;
 }
 
+void ReferenceLineProvider::Wait() {
+  is_stop_ = true;
+  if (FLAGS_enable_reference_line_provider_thread) {
+    task_future_.wait();
+  }
+}
+
 void ReferenceLineProvider::Stop() {
   is_stop_ = true;
   if (FLAGS_enable_reference_line_provider_thread) {
@@ -189,6 +197,7 @@ void ReferenceLineProvider::UpdateReferenceLine(
 
 void ReferenceLineProvider::GenerateThread() {
   while (!is_stop_) {
+    is_reference_line_updated_ = true;
     static constexpr int32_t kSleepTime = 50;  // milliseconds
     cyber::SleepFor(std::chrono::milliseconds(kSleepTime));
     const double start_time = Clock::NowInSeconds();
</diff>
			</file>
			<file old_path="modules\planning\reference_line\reference_line_provider.h" new_path="modules\planning\reference_line\reference_line_provider.h" added_lines="2" deleted_lines="0">
				<diff>@@ -77,6 +77,8 @@ class ReferenceLineProvider {
 
   void Stop();
 
+  void Wait();
+
   bool GetReferenceLines(std::list&lt;ReferenceLine&gt;* reference_lines,
                          std::list&lt;hdmap::RouteSegments&gt;* segments);
 
</diff>
			</file>
			<file old_path="modules\planning\scenarios\scenario_manager.cc" new_path="modules\planning\scenarios\scenario_manager.cc" added_lines="67" deleted_lines="7">
				<diff>@@ -34,6 +34,7 @@
 #include "modules/planning/scenarios/learning_model/learning_model_sample_scenario.h"
 #include "modules/planning/scenarios/park/pull_over/pull_over_scenario.h"
 #include "modules/planning/scenarios/park/valet_parking/valet_parking_scenario.h"
+#include "modules/planning/scenarios/dead_end/deadend_turnaround/deadend_turnaround_scenario.h"
 #include "modules/planning/scenarios/park_and_go/park_and_go_scenario.h"
 #include "modules/planning/scenarios/stop_sign/unprotected/stop_sign_unprotected_scenario.h"
 #include "modules/planning/scenarios/traffic_light/protected/traffic_light_protected_scenario.h"
@@ -121,6 +122,10 @@ std::unique_ptr&lt;Scenario&gt; ScenarioManager::CreateScenario(
       ptr.reset(new scenario::yield_sign::YieldSignScenario(
           config_map_[scenario_type], &amp;scenario_context_, injector_));
       break;
+    case ScenarioConfig::DEADEND_TURNAROUND:
+      ptr.reset(new scenario::deadend_turnaround::DeadEndTurnAroundScenario(
+          config_map_[scenario_type], &amp;scenario_context_, injector_));
+      break;
     default:
       return nullptr;
   }
@@ -193,6 +198,10 @@ void ScenarioManager::RegisterScenarios() {
   // yield_sign
   ACHECK(Scenario::LoadConfig(FLAGS_scenario_yield_sign_config_file,
                               &amp;config_map_[ScenarioConfig::YIELD_SIGN]));
+  // turn around
+  ACHECK(Scenario::LoadConfig(
+      FLAGS_scenario_deadend_turnaround_config_file,
+      &amp;config_map_[ScenarioConfig::DEADEND_TURNAROUND]));
 }
 
 ScenarioConfig::ScenarioType ScenarioManager::SelectPullOverScenario(
@@ -312,6 +321,7 @@ ScenarioConfig::ScenarioType ScenarioManager::SelectPullOverScenario(
     case ScenarioConfig::TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN:
     case ScenarioConfig::TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN:
     case ScenarioConfig::VALET_PARKING:
+    case ScenarioConfig::DEADEND_TURNAROUND:
     case ScenarioConfig::YIELD_SIGN:
       if (current_scenario_-&gt;GetStatus() !=
           Scenario::ScenarioStatus::STATUS_DONE) {
@@ -328,7 +338,6 @@ ScenarioConfig::ScenarioType ScenarioManager::SelectPullOverScenario(
 ScenarioConfig::ScenarioType ScenarioManager::SelectPadMsgScenario(
     const Frame&amp; frame) {
   const auto&amp; pad_msg_driving_action = frame.GetPadMsgDrivingAction();
-
   switch (pad_msg_driving_action) {
     case DrivingAction::PULL_OVER:
       if (FLAGS_enable_scenario_emergency_pull_over) {
@@ -351,7 +360,6 @@ ScenarioConfig::ScenarioType ScenarioManager::SelectPadMsgScenario(
     default:
       break;
   }
-
   return default_scenario_type_;
 }
 
@@ -730,6 +738,33 @@ ScenarioConfig::ScenarioType ScenarioManager::SelectValetParkingScenario(
   return default_scenario_type_;
 }
 
+ScenarioConfig::ScenarioType ScenarioManager::SelectDeadEndScenario(
+    const Frame&amp; frame) {
+  size_t waypoint_num =
+    frame.local_view().routing-&gt;routing_request().waypoint().size();
+  const auto&amp; routing_type =
+    frame.local_view().routing-&gt;routing_request().dead_end_info().
+    dead_end_routing_type();
+  if (routing_type == routing::ROUTING_IN) {
+    dead_end_point_ = frame.local_view().routing-&gt;routing_request().
+                    waypoint().at(waypoint_num - 1).pose();
+  } else if (routing_type == routing::ROUTING_OUT) {
+    dead_end_point_ = frame.local_view().routing-&gt;routing_request().
+                    waypoint().at(0).pose();
+  }
+  const auto&amp; scenario_config =
+    config_map_[ScenarioConfig::DEADEND_TURNAROUND].deadend_turnaround_config();
+  double dead_end_start_range =
+      scenario_config.dead_end_start_range();
+  if (scenario::deadend_turnaround::DeadEndTurnAroundScenario::IsTransferable(
+          frame, dead_end_point_, dead_end_start_range) &amp;&amp;
+          routing_type == routing::ROUTING_IN) {
+    return ScenarioConfig::DEADEND_TURNAROUND;
+  }
+
+  return default_scenario_type_;
+}
+
 ScenarioConfig::ScenarioType ScenarioManager::SelectParkAndGoScenario(
     const Frame&amp; frame) {
   bool park_and_go = false;
@@ -760,7 +795,6 @@ ScenarioConfig::ScenarioType ScenarioManager::SelectParkAndGoScenario(
   const double adc_front_edge_s = reference_line_info.AdcSlBoundary().end_s();
 
   const double adc_distance_to_dest = dest_sl.s() - adc_front_edge_s;
-  ADEBUG &lt;&lt; "adc_distance_to_dest:" &lt;&lt; adc_distance_to_dest;
   // if vehicle is static, far enough to destination and (off-lane or not on
   // city_driving lane)
   if (std::fabs(adc_speed) &lt; max_abs_speed_when_stopped &amp;&amp;
@@ -804,6 +838,7 @@ void ScenarioManager::Update(const common::TrajectoryPoint&amp; ego_point,
   ScenarioDispatch(frame);
 }
 
+
 void ScenarioManager::ScenarioDispatch(const Frame&amp; frame) {
   ACHECK(!frame.reference_line_info().empty());
   ScenarioConfig::ScenarioType scenario_type;
@@ -842,16 +877,31 @@ ScenarioConfig::ScenarioType ScenarioManager::ScenarioDispatchLearning() {
   return scenario_type;
 }
 
+bool ScenarioManager::JudgeReachTargetPoint(
+  const common::VehicleState&amp; car_position,
+  const common::PointENU&amp; target_point) {
+  double distance_to_vehicle =
+    (car_position.x() - target_point.x()) *
+    (car_position.x() - target_point.x()) +
+    (car_position.y() - target_point.y()) *
+    (car_position.y() - target_point.y());
+  return distance_to_vehicle &lt; FLAGS_threshold_distance_for_destination;
+}
+
 ScenarioConfig::ScenarioType ScenarioManager::ScenarioDispatchNonLearning(
     const Frame&amp; frame) {
   ////////////////////////////////////////
   // default: LANE_FOLLOW
   ScenarioConfig::ScenarioType scenario_type = default_scenario_type_;
-
   ////////////////////////////////////////
   // Pad Msg scenario
   scenario_type = SelectPadMsgScenario(frame);
 
+  const auto vehicle_state_provider = injector_-&gt;vehicle_state();
+  common::VehicleState vehicle_state = vehicle_state_provider-&gt;vehicle_state();
+  const common::PointENU&amp; target_point =
+  frame.local_view().routing-&gt;routing_request().dead_end_info().target_point();
+  const common::VehicleState&amp; car_position = frame.vehicle_state();
   if (scenario_type == default_scenario_type_) {
     // check current_scenario (not switchable)
     switch (current_scenario_-&gt;scenario_type()) {
@@ -867,6 +917,12 @@ ScenarioConfig::ScenarioType ScenarioManager::ScenarioDispatchNonLearning(
       case ScenarioConfig::TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN:
       case ScenarioConfig::TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN:
       case ScenarioConfig::VALET_PARKING:
+      case ScenarioConfig::DEADEND_TURNAROUND:
+        // transfer dead_end to lane follow, should enhance transfer logic
+        if (JudgeReachTargetPoint(car_position, target_point)) {
+          scenario_type = ScenarioConfig::LANE_FOLLOW;
+          reach_target_pose_ = true;
+        }
       case ScenarioConfig::YIELD_SIGN:
         // must continue until finish
         if (current_scenario_-&gt;GetStatus() !=
@@ -878,11 +934,10 @@ ScenarioConfig::ScenarioType ScenarioManager::ScenarioDispatchNonLearning(
         break;
     }
   }
-
   ////////////////////////////////////////
   // ParkAndGo / starting scenario
   if (scenario_type == default_scenario_type_) {
-    if (FLAGS_enable_scenario_park_and_go) {
+    if (FLAGS_enable_scenario_park_and_go &amp;&amp; !reach_target_pose_) {
       scenario_type = SelectParkAndGoScenario(frame);
     }
   }
@@ -906,7 +961,12 @@ ScenarioConfig::ScenarioType ScenarioManager::ScenarioDispatchNonLearning(
   if (scenario_type == default_scenario_type_) {
     scenario_type = SelectValetParkingScenario(frame);
   }
-
+  ////////////////////////////////////////
+  // dead end
+  if (scenario_type == default_scenario_type_) {
+    scenario_type = SelectDeadEndScenario(frame);
+  }
+  ////////////////////////////////////////
   return scenario_type;
 }
 
</diff>
			</file>
			<file old_path="modules\planning\scenarios\scenario_manager.h" new_path="modules\planning\scenarios\scenario_manager.h" added_lines="8" deleted_lines="0">
				<diff>@@ -67,6 +67,8 @@ class ScenarioManager final {
 
   ScenarioConfig::ScenarioType SelectValetParkingScenario(const Frame&amp; frame);
 
+  ScenarioConfig::ScenarioType SelectDeadEndScenario(const Frame&amp; frame);
+
   ScenarioConfig::ScenarioType SelectYieldSignScenario(
       const Frame&amp; frame, const hdmap::PathOverlap&amp; yield_sign_overlap);
 
@@ -104,6 +106,9 @@ class ScenarioManager final {
   void UpdatePlanningContextYieldSignScenario(
       const Frame&amp; frame, const ScenarioConfig::ScenarioType&amp; scenario_type);
 
+  bool JudgeReachTargetPoint(const common::VehicleState&amp; car_position,
+                             const common::PointENU&amp; target_point);
+
  private:
   std::shared_ptr&lt;DependencyInjector&gt; injector_;
   PlanningConfig planning_config_;
@@ -116,6 +121,9 @@ class ScenarioManager final {
   std::unordered_map&lt;ReferenceLineInfo::OverlapType, hdmap::PathOverlap,
                      std::hash&lt;int&gt;&gt;
       first_encountered_overlap_map_;
+  bool routing_in_flag_ = true;
+  common::PointENU dead_end_point_;
+  bool reach_target_pose_ = false;
 };
 
 }  // namespace scenario
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_pre_stop_decider.cc" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_pre_stop_decider.cc" added_lines="113" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
+ * Copyright 2021 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -31,12 +31,16 @@
 
 namespace apollo {
 namespace planning {
-
+using apollo::common::PointENU;
 using apollo::common::ErrorCode;
 using apollo::common::Status;
 using apollo::common::VehicleState;
 using apollo::common::math::Vec2d;
+using apollo::common::math::Polygon2d;
+using apollo::hdmap::HDMapUtil;
+using apollo::hdmap::JunctionInfoConstPtr;
 using apollo::hdmap::ParkingSpaceInfoConstPtr;
+using apollo::routing::RoutingRequest;
 
 OpenSpacePreStopDecider::OpenSpacePreStopDecider(
     const TaskConfig&amp; config,
@@ -70,6 +74,14 @@ Status OpenSpacePreStopDecider::Process(
       }
       SetPullOverStopFence(target_s, frame, reference_line_info);
       break;
+    case OpenSpacePreStopDeciderConfig::DEAD_END_PRE_STOP:
+      if (!CheckDeadEndPreStop(frame, reference_line_info, &amp;target_s)) {
+        const std::string msg = "Checking dead end pre stop fails";
+        AERROR &lt;&lt; msg;
+        return Status(ErrorCode::PLANNING_ERROR, msg);
+      }
+      SetDeadEndStopFence(target_s, frame, reference_line_info);
+      break;
     default:
       const std::string msg = "This stop type not implemented";
       AERROR &lt;&lt; msg;
@@ -151,6 +163,105 @@ bool OpenSpacePreStopDecider::CheckParkingSpotPreStop(
   return true;
 }
 
+bool OpenSpacePreStopDecider::SelectTargetDeadEndJunction(
+    std::vector&lt;JunctionInfoConstPtr&gt;* junctions,
+    const apollo::common::PointENU&amp; dead_end_point,
+    JunctionInfoConstPtr* target_junction) {
+  // warning: the car only be the one junction
+  size_t junction_num = junctions-&gt;size();
+  if (junction_num &lt;= 0) {
+    ADEBUG &lt;&lt; "No junctions frim map";
+    return false;
+  }
+  Vec2d target_point = {dead_end_point.x(), dead_end_point.y()};
+  for (size_t i = 0; i &lt; junction_num; ++i) {
+    if (junctions-&gt;at(i)-&gt;junction().type() == 5) {
+      Polygon2d polygon = junctions-&gt;at(i)-&gt;polygon();
+      if (polygon.IsPointIn(target_point)) {
+        *target_junction = junctions-&gt;at(i);
+        ADEBUG &lt;&lt; "car in the junction";
+        return true;
+      } else {
+        return false;
+      }
+    } else {
+      ADEBUG &lt;&lt; "No dead end junction";
+      return false;
+    }
+  }
+  return true;
+}
+
+bool OpenSpacePreStopDecider::CheckDeadEndPreStop(
+  Frame* const frame,
+  ReferenceLineInfo* const reference_line_info,
+  double* target_s) {
+  const auto&amp; routing_type = frame-&gt;local_view().
+    routing-&gt;routing_request().dead_end_info().dead_end_routing_type();
+  size_t waypoint_num =
+    frame-&gt;local_view().routing-&gt;routing_request().waypoint().size();
+  if (routing_type == routing::ROUTING_IN) {
+    dead_end_point_ = frame-&gt;local_view().routing-&gt;routing_request().
+                    waypoint().at(waypoint_num - 1).pose();
+  } else if (routing_type == routing::ROUTING_OUT) {
+    dead_end_point_ = frame-&gt;local_view().routing-&gt;routing_request().
+                    waypoint().at(0).pose();
+  }
+  const hdmap::HDMap* base_map_ptr = HDMapUtil::BaseMapPtr();
+  std::vector&lt;JunctionInfoConstPtr&gt; junctions;
+  JunctionInfoConstPtr junction;
+  if (base_map_ptr-&gt;GetJunctions(dead_end_point_, 1.0, &amp;junctions) != 0) {
+    ADEBUG &lt;&lt; "Fail to get junctions from sim_map.";
+    return false;
+  }
+  if (junctions.size() &lt;= 0) {
+    ADEBUG &lt;&lt; "No junctions from map";
+    return false;
+  }
+  if (!SelectTargetDeadEndJunction(&amp;junctions, dead_end_point_, &amp;junction)) {
+    ADEBUG &lt;&lt; "Target Dead End not found";
+    return false;
+  }
+  // compute the x value of dead end
+  auto points = junction-&gt;polygon().points();
+  const auto&amp; nearby_path =
+      reference_line_info-&gt;reference_line().map_path();
+  Vec2d first_point = points.front();
+  // the last point's s value may be unsuitable
+  Vec2d last_point = points.back();
+  double first_point_s = 0.0;
+  double first_point_l = 0.0;
+  double last_point_s = 0.0;
+  double last_point_l = 0.0;
+  nearby_path.GetNearestPoint(first_point, &amp;first_point_s,
+                              &amp;first_point_l);
+  nearby_path.GetNearestPoint(last_point, &amp;last_point_s,
+                              &amp;last_point_l);
+  double center_s = (first_point_s + last_point_s) / 2.0;
+  *target_s = center_s;
+  return true;
+}
+
+void OpenSpacePreStopDecider::SetDeadEndStopFence(
+    const double target_s, Frame* const frame,
+    ReferenceLineInfo* const reference_line_info) {
+  double stop_line_s = 0.0;
+  double stop_distance_to_target =
+      open_space_pre_stop_decider_config_.stop_distance_to_target();
+  CHECK_GE(stop_distance_to_target, 1.0e-8);
+  // get the stop point s
+  stop_line_s = target_s - stop_distance_to_target;
+  // set stop fence
+  const std::string stop_wall_id = OPEN_SPACE_STOP_ID;
+  std::vector&lt;std::string&gt; wait_for_obstacles;
+  frame-&gt;mutable_open_space_info()-&gt;set_open_space_pre_stop_fence_s(
+      stop_line_s);
+  util::BuildStopDecision(stop_wall_id, stop_line_s, 0.0,
+                          StopReasonCode::STOP_REASON_PRE_OPEN_SPACE_STOP,
+                          wait_for_obstacles, "OpenSpacePreStopDecider", frame,
+                          reference_line_info);
+}
+
 void OpenSpacePreStopDecider::SetParkingSpotStopFence(
     const double target_s, Frame* const frame,
     ReferenceLineInfo* const reference_line_info) {
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_pre_stop_decider.h" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_pre_stop_decider.h" added_lines="15" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
+ * Copyright 2021 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,7 +21,7 @@
 #pragma once
 
 #include &lt;memory&gt;
-
+#include &lt;vector&gt;
 #include "cyber/common/macros.h"
 #include "modules/planning/common/frame.h"
 #include "modules/planning/common/reference_line_info.h"
@@ -46,16 +46,29 @@ class OpenSpacePreStopDecider : public Decider {
   bool CheckPullOverPreStop(Frame* const frame,
                             ReferenceLineInfo* const reference_line_info,
                             double* target_s);
+  bool CheckDeadEndPreStop(Frame* const frame,
+                           ReferenceLineInfo* const reference_line_info,
+                           double* target_x);
 
+  void SetDeadEndStopFence(const double target_x,
+                           Frame* const frame,
+                           ReferenceLineInfo* const reference_line_info);
   void SetParkingSpotStopFence(const double target_s, Frame* const frame,
                                ReferenceLineInfo* const reference_line_info);
 
   void SetPullOverStopFence(const double target_s, Frame* const frame,
                             ReferenceLineInfo* const reference_line_info);
 
+  static bool SelectTargetDeadEndJunction(
+        std::vector&lt;hdmap::JunctionInfoConstPtr&gt;* junctions,
+        const apollo::common::PointENU&amp; dead_end_point,
+        hdmap::JunctionInfoConstPtr* target_junction);
+
  private:
   static constexpr const char* OPEN_SPACE_STOP_ID = "OPEN_SPACE_PRE_STOP";
   OpenSpacePreStopDeciderConfig open_space_pre_stop_decider_config_;
+  bool routing_in_flag_ = true;
+  common::PointENU dead_end_point_;
 };
 
 }  // namespace planning
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" added_lines="382" deleted_lines="3">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
+ * Copyright 2021 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -33,12 +33,17 @@ using apollo::common::ErrorCode;
 using apollo::common::Status;
 using apollo::common::math::Box2d;
 using apollo::common::math::Vec2d;
+using apollo::common::math::Polygon2d;
+using apollo::common::PointENU;
 using apollo::hdmap::HDMapUtil;
 using apollo::hdmap::LaneInfoConstPtr;
 using apollo::hdmap::LaneSegment;
 using apollo::hdmap::ParkingSpaceInfoConstPtr;
 using apollo::hdmap::Path;
+using apollo::hdmap::JunctionInfoConstPtr;
 using apollo::routing::ParkingSpaceType;
+using apollo::routing::RoutingRequest;
+using apollo::routing::LaneWaypoint;
 
 OpenSpaceRoiDecider::OpenSpaceRoiDecider(
     const TaskConfig &amp;config,
@@ -48,6 +53,9 @@ OpenSpaceRoiDecider::OpenSpaceRoiDecider(
   CHECK_NOTNULL(hdmap_);
   vehicle_params_ =
       apollo::common::VehicleConfigHelper::GetConfig().vehicle_param();
+  injector-&gt;vehicle_state();
+  temp_state_.set_x(injector-&gt;vehicle_state()-&gt;x());
+  temp_state_.set_y(injector-&gt;vehicle_state()-&gt;y());
 }
 
 Status OpenSpaceRoiDecider::Process(Frame *frame) {
@@ -62,6 +70,7 @@ Status OpenSpaceRoiDecider::Process(Frame *frame) {
   obstacles_by_frame_ = frame-&gt;GetObstacleList();
 
   std::array&lt;Vec2d, 4&gt; spot_vertices;
+  std::vector&lt;Vec2d&gt; dead_end_vertices;
   Path nearby_path;
   // @brief vector of different obstacle consisting of vertice points.The
   // obstacle and the vertices order are in counter-clockwise order
@@ -97,6 +106,50 @@ Status OpenSpaceRoiDecider::Process(Frame *frame) {
       AERROR &lt;&lt; msg;
       return Status(ErrorCode::PLANNING_ERROR, msg);
     }
+  } else if (roi_type == OpenSpaceRoiDeciderConfig::DEAD_END) {
+    const auto&amp; routing_type =
+      frame-&gt;local_view().routing-&gt;routing_request().dead_end_info().
+      dead_end_routing_type();
+    size_t waypoint_num =
+      frame-&gt;local_view().routing-&gt;routing_request().waypoint().size();
+    if (routing_type == routing::ROUTING_IN) {
+      dead_end_point_ = frame-&gt;local_view().routing-&gt;routing_request().
+                      waypoint().at(waypoint_num - 1).pose();
+    } else if (routing_type == routing::ROUTING_OUT) {
+      dead_end_point_ = frame-&gt;local_view().routing-&gt;routing_request().
+                      waypoint().at(0).pose();
+    }
+    const hdmap::HDMap* base_map_ptr = HDMapUtil::BaseMapPtr();
+    std::vector&lt;JunctionInfoConstPtr&gt; junctions;
+    JunctionInfoConstPtr junction;
+    if (base_map_ptr-&gt;GetJunctions(dead_end_point_, 1.0, &amp;junctions) != 0) {
+      const std::string msg = "Fail to get junctions from sim_map.";
+      AERROR &lt;&lt; msg;
+      Status(ErrorCode::PLANNING_ERROR, msg);
+    }
+    if (junctions.size() &lt;= 0) {
+      const std::string msg = "No junctions from map";
+      AERROR &lt;&lt; msg;
+      Status(ErrorCode::PLANNING_ERROR, msg);
+    }
+    if (!SelectTargetDeadEndJunction(&amp;junctions, dead_end_point_, &amp;junction)) {
+      const std::string msg = "Target Dead End not found";
+      AERROR &lt;&lt; msg;
+      Status(ErrorCode::PLANNING_ERROR, msg);
+    }
+    if (!GetDeadEndSpot(frame, &amp;junction, &amp;dead_end_vertices)) {
+      const std::string msg = "Fail to get dead end vertices from map";
+      AERROR &lt;&lt; msg;
+      return Status(ErrorCode::PLANNING_ERROR, msg);
+    }
+    SetDeadEndOrigin(frame, dead_end_vertices);
+    SetDeadEndPose(frame, dead_end_vertices);
+    if (!GetDeadEndBoundary(frame, dead_end_vertices,
+                            nearby_path, &amp;roi_boundary)) {
+      const std::string msg = "Fail to get dead end boundary";
+      AERROR &lt;&lt; msg;
+      return Status(ErrorCode::PLANNING_ERROR, msg);
+    }
   } else if (roi_type == OpenSpaceRoiDeciderConfig::PULL_OVER) {
     if (!GetPullOverSpot(frame, &amp;spot_vertices, &amp;nearby_path)) {
       const std::string msg = "Fail to get parking boundary from map";
@@ -144,16 +197,43 @@ Status OpenSpaceRoiDecider::Process(Frame *frame) {
     AERROR &lt;&lt; msg;
     return Status(ErrorCode::PLANNING_ERROR, msg);
   }
-
   if (!FormulateBoundaryConstraints(roi_boundary, frame)) {
     const std::string msg = "Fail to formulate boundary constraints";
     AERROR &lt;&lt; msg;
     return Status(ErrorCode::PLANNING_ERROR, msg);
   }
-
   return Status::OK();
 }
 
+bool OpenSpaceRoiDecider::SelectTargetDeadEndJunction(
+    std::vector&lt;JunctionInfoConstPtr&gt;* junctions,
+    const apollo::common::PointENU&amp; dead_end_point,
+    JunctionInfoConstPtr* target_junction) {
+  // warning: the car only be the one junction
+  size_t junction_num = junctions-&gt;size();
+  if (junction_num &lt;= 0) {
+    ADEBUG &lt;&lt; "No junctions frim map";
+    return false;
+  }
+  Vec2d target_point = {dead_end_point.x(), dead_end_point.y()};
+  for (size_t i = 0; i &lt; junction_num; ++i) {
+    if (junctions-&gt;at(i)-&gt;junction().type() == 5) {
+      Polygon2d polygon = junctions-&gt;at(i)-&gt;polygon();
+      if (polygon.IsPointIn(target_point)) {
+        *target_junction = junctions-&gt;at(i);
+        ADEBUG &lt;&lt; "car in the junction";
+        return true;
+      } else {
+        return false;
+      }
+    } else {
+      ADEBUG &lt;&lt; "No dead end junction";
+      return false;
+    }
+  }
+  return true;
+}
+
 // get origin from ADC
 void OpenSpaceRoiDecider::SetOriginFromADC(Frame *const frame,
                                            const hdmap::Path &amp;nearby_path) {
@@ -199,6 +279,20 @@ void OpenSpaceRoiDecider::SetOriginFromADC(Frame *const frame,
   frame-&gt;mutable_open_space_info()-&gt;mutable_origin_point()-&gt;set_y(left_top.y());
 }
 
+void OpenSpaceRoiDecider::SetDeadEndOrigin(
+  Frame* const frame,
+  const std::vector&lt;Vec2d&gt; &amp;dead_end_vertices) {
+  auto last_point = dead_end_vertices.back();
+  auto first_point = dead_end_vertices.front();
+  Vec2d heading_vec = last_point - first_point;
+  // set origin point
+  frame-&gt;mutable_open_space_info()-&gt;set_origin_heading(heading_vec.Angle());
+  frame-&gt;mutable_open_space_info()-&gt;
+    mutable_origin_point()-&gt;set_x(first_point.x());
+  frame-&gt;mutable_open_space_info()-&gt;
+    mutable_origin_point()-&gt;set_y(first_point.y());
+}
+
 void OpenSpaceRoiDecider::SetOrigin(
     Frame *const frame, const std::array&lt;common::math::Vec2d, 4&gt; &amp;vertices) {
   auto left_top = vertices[0];
@@ -211,6 +305,36 @@ void OpenSpaceRoiDecider::SetOrigin(
   frame-&gt;mutable_open_space_info()-&gt;mutable_origin_point()-&gt;set_y(left_top.y());
 }
 
+void OpenSpaceRoiDecider::SetDeadEndPose(
+  Frame* const frame,
+  const std::vector&lt;Vec2d&gt; &amp;dead_end_vertices) {
+  // the target point should be in the adjacent lanes based the map,
+  // curret map is rectangle, vertice is  anti-clockwise
+  auto *end_pose =
+      frame-&gt;mutable_open_space_info()-&gt;mutable_open_space_end_pose();
+  const auto&amp; target_point =
+      frame-&gt;local_view().routing-&gt;routing_request().
+      dead_end_info().target_point();
+  Vec2d end_point = {target_point.x(), target_point.y()};
+  // coordinate transfer
+  const auto &amp;origin_point = frame-&gt;open_space_info().origin_point();
+  const auto &amp;origin_heading = frame-&gt;open_space_info().origin_heading();
+  auto first_point = dead_end_vertices[0];
+  auto second_point = dead_end_vertices[1];
+  end_point -= origin_point;
+  end_point.SelfRotate(-origin_heading);
+  first_point -= origin_point;
+  first_point.SelfRotate(-origin_heading);
+  second_point -= origin_point;
+  second_point.SelfRotate(-origin_heading);
+  double parking_spot_heading = (first_point - second_point).Angle();
+  // set end point
+  end_pose-&gt;push_back(end_point.x());
+  end_pose-&gt;push_back(end_point.y());
+  end_pose-&gt;push_back(parking_spot_heading);
+  end_pose-&gt;push_back(0.0);
+}
+
 void OpenSpaceRoiDecider::SetParkingSpotEndPose(
     Frame *const frame, const std::array&lt;common::math::Vec2d, 4&gt; &amp;vertices) {
   const auto &amp;routing_request =
@@ -688,6 +812,242 @@ void OpenSpaceRoiDecider::AddBoundaryKeyPoint(
   }
 }
 
+// only one lane one lane has one segment
+void OpenSpaceRoiDecider::GetInLaneEndPoint(LaneInfoConstPtr lane_info,
+                                           PointENU* left_boundary_point,
+                                           PointENU* right_boundary_point) {
+  const auto&amp; left_boundary_segment =
+    lane_info-&gt;lane().left_boundary().curve().segment();
+  const auto&amp; right_boundary_segment =
+    lane_info-&gt;lane().right_boundary().curve().segment();
+  size_t lane_points_num = left_boundary_segment[0].line_segment().point_size();
+  *left_boundary_point =
+    left_boundary_segment[0].line_segment().point(lane_points_num - 1);
+  *right_boundary_point =
+    right_boundary_segment[0].line_segment().point(lane_points_num - 1);
+}
+
+void OpenSpaceRoiDecider::GetOutLaneStartPoint(
+  LaneInfoConstPtr lane_info,
+  PointENU* left_boundary_point,
+  PointENU* right_boundary_point) {
+  const auto&amp; left_boundary_segment =
+    lane_info-&gt;lane().left_boundary().curve().segment();
+  const auto&amp; right_boundary_segment =
+    lane_info-&gt;lane().right_boundary().curve().segment();
+  *left_boundary_point =
+    left_boundary_segment[0].line_segment().point(0);
+  *right_boundary_point =
+    right_boundary_segment[0].line_segment().point(0);
+}
+
+void OpenSpaceRoiDecider::GetInLaneBoundaryPoints(LaneInfoConstPtr lane_info,
+                        const hdmap::Path &amp;nearby_path,
+                        std::vector&lt;PointENU&gt;* In_left_boundary_points,
+                        std::vector&lt;PointENU&gt;* In_right_boundary_points) {
+  const auto&amp; left_boundary_segment =
+    lane_info-&gt;lane().left_boundary().curve().segment();
+  const auto&amp; right_boundary_segment =
+    lane_info-&gt;lane().right_boundary().curve().segment();
+  size_t lane_points_num = left_boundary_segment[0].line_segment().point_size();
+  int temp_record_left = 0;
+  int temp_record_right = 0;
+  std::vector&lt;PointENU&gt; left_points, right_points;
+  for (size_t i = 0; i &lt; lane_points_num; ++i) {
+    left_points.push_back(left_boundary_segment[0].
+                          line_segment().point().at(i));
+    right_points.push_back(right_boundary_segment[0].
+                           line_segment().point().at(i));
+  }
+  // (to do): by s
+  for (size_t i = 0; i &lt; lane_points_num; ++i) {
+    if (left_points[i].x() &lt; temp_state_.x()) {
+      In_left_boundary_points-&gt;push_back(left_points[i]);
+      temp_record_left = i;
+    }
+    if (right_points[i].x() &lt; temp_state_.x()) {
+      In_right_boundary_points-&gt;push_back(right_points[i]);
+      temp_record_right = i;
+    }
+  }
+  // add one point, bigger than vehicle x
+  if (left_points[temp_record_left - 1].x() &gt; temp_state_.x()) {
+    In_left_boundary_points-&gt;push_back(left_points[temp_record_left - 1]);
+  }
+  if (right_points[temp_record_right - 1].x() &gt; temp_state_.x()) {
+    In_right_boundary_points-&gt;push_back(right_points[temp_record_right - 1]);
+  }
+  std::reverse(In_right_boundary_points-&gt;begin(),
+               In_right_boundary_points-&gt;end());
+}
+
+void OpenSpaceRoiDecider::GetOutLaneBoundaryPoints(
+  LaneInfoConstPtr lane_info,
+  const hdmap::Path &amp;nearby_path,
+  std::vector&lt;PointENU&gt;* Out_left_boundary_points,
+  std::vector&lt;PointENU&gt;* Out_right_boundary_points) {
+  const auto&amp; left_boundary_segment =
+    lane_info-&gt;lane().left_boundary().curve().segment();
+  const auto&amp; right_boundary_segment =
+    lane_info-&gt;lane().right_boundary().curve().segment();
+  size_t lane_points_num =
+    left_boundary_segment[0].line_segment().point_size();
+  int temp_record_left = 0;
+  int temp_record_right = 0;
+  std::vector&lt;PointENU&gt; left_points, right_points;
+  for (size_t i = 0; i &lt; lane_points_num; ++i) {
+    left_points.push_back(left_boundary_segment[0].
+                          line_segment().point().at(i));
+    right_points.push_back(right_boundary_segment[0].
+                          line_segment().point().at(i));
+  }
+  // (to do): by s
+  for (size_t i = 0; i &lt; lane_points_num; ++i) {
+    if (left_points[i].x() &lt; routing_target_point_.x()) {
+      Out_left_boundary_points-&gt;push_back(left_points[i]);
+      temp_record_left = i;
+    }
+    if (right_points[i].x() &lt; routing_target_point_.x()) {
+      Out_right_boundary_points-&gt;push_back(right_points[i]);
+      temp_record_right = i;
+    }
+  }
+  // add one point, bigger than vehicle x
+  if (left_points[temp_record_left + 1].x() &gt; routing_target_point_.x()) {
+    Out_left_boundary_points-&gt;push_back(left_points[temp_record_left + 1]);
+  }
+  if (right_points[temp_record_right + 1].x() &gt; routing_target_point_.x()) {
+    Out_right_boundary_points-&gt;push_back(right_points[temp_record_right + 1]);
+  }
+  std::reverse(Out_left_boundary_points-&gt;begin(),
+               Out_left_boundary_points-&gt;end());
+}
+
+bool OpenSpaceRoiDecider::GetDeadEndBoundary(
+  Frame* const frame, const std::vector&lt;Vec2d&gt; &amp;dead_end_vertices,
+  const hdmap::Path &amp;nearby_path,
+  std::vector&lt;std::vector&lt;common::math::Vec2d&gt;&gt; *const roi_deadend_boundary) {
+  size_t waypoint_num =
+    frame-&gt;local_view().routing-&gt;routing_request().waypoint().size();
+  routing_target_point_ = frame-&gt;local_view().routing-&gt;
+    routing_request().dead_end_info().target_point();
+  if (routing_in_flag_) {
+    routing_end_point_ = frame-&gt;local_view().routing-&gt;routing_request().
+                         waypoint().at(waypoint_num - 1).pose();
+    routing_in_flag_ = false;
+  }
+  double nearest_s = 0.0;
+  double nearest_l = 0.0;
+  LaneInfoConstPtr start_nearest_lane;
+  PointENU left_end_point, right_end_point;
+  hdmap_-&gt;GetNearestLane(routing_end_point_,
+    &amp;start_nearest_lane, &amp;nearest_s, &amp;nearest_l);
+  GetInLaneEndPoint(start_nearest_lane, &amp;left_end_point, &amp;right_end_point);
+
+  LaneInfoConstPtr end_nearest_lane;
+  PointENU left_start_point, right_start_point;
+  hdmap_-&gt;GetNearestLane(routing_target_point_,
+    &amp;end_nearest_lane, &amp;nearest_s, &amp;nearest_l);
+  GetOutLaneStartPoint(end_nearest_lane,
+                       &amp;left_start_point,
+                       &amp;right_start_point);
+
+  LaneInfoConstPtr car_lane;
+  PointENU car_pose;
+  car_pose.set_x(temp_state_.x());
+  car_pose.set_y(temp_state_.y());
+  hdmap_-&gt;GetNearestLane(car_pose, &amp;car_lane, &amp;nearest_s, &amp;nearest_l);
+  std::vector&lt;PointENU&gt; In_left_boundary_points;
+  std::vector&lt;PointENU&gt; In_right_boundary_points;
+  GetInLaneBoundaryPoints(car_lane, nearby_path,
+                          &amp;In_left_boundary_points,
+                          &amp;In_right_boundary_points);
+
+  LaneInfoConstPtr target_lane;
+  double out_routing_x = routing_target_point_.x() + FLAGS_buffer_out_routing;
+  routing_target_point_.set_x(out_routing_x);
+  hdmap_-&gt;GetNearestLane(routing_target_point_,
+                         &amp;target_lane,
+                         &amp;nearest_s,
+                         &amp;nearest_l);
+  std::vector&lt;PointENU&gt; Out_left_boundary_points;
+  std::vector&lt;PointENU&gt; Out_right_boundary_points;
+  GetOutLaneBoundaryPoints(target_lane,
+                           nearby_path,
+                           &amp;Out_left_boundary_points,
+                           &amp;Out_right_boundary_points);
+
+  std::vector&lt;Vec2d&gt; point_boundary;
+  for (size_t i = 0; i &lt; In_right_boundary_points.size(); ++i) {
+    point_boundary.push_back({In_right_boundary_points[i].x(),
+                              In_right_boundary_points[i].y()});
+  }
+  point_boundary.push_back({right_end_point.x(), right_end_point.y()});
+  for (size_t i = 0; i &lt; dead_end_vertices.size(); ++i) {
+    point_boundary.push_back(dead_end_vertices[i]);
+  }
+  point_boundary.push_back({right_start_point.x(), right_start_point.y()});
+  for (size_t i = 0; i &lt; Out_right_boundary_points.size(); ++i) {
+    point_boundary.push_back({Out_right_boundary_points[i].x(),
+                              Out_right_boundary_points[i].y()});
+  }
+  for (size_t i = 0; i &lt; Out_left_boundary_points.size(); ++i) {
+    point_boundary.push_back({Out_left_boundary_points[i].x(),
+                              Out_left_boundary_points[i].y()});
+  }
+  point_boundary.push_back({left_start_point.x(), left_start_point.y()});
+  point_boundary.push_back({left_end_point.x(), left_end_point.y()});
+  for (size_t i = 0; i &lt; In_left_boundary_points.size(); ++i) {
+    point_boundary.push_back({In_left_boundary_points[i].x(),
+                              In_left_boundary_points[i].y()});
+  }
+  point_boundary.push_back({In_right_boundary_points[0].x(),
+                            In_right_boundary_points[0].y()});
+  const auto &amp;origin_point = frame-&gt;open_space_info().origin_point();
+  const auto &amp;origin_heading = frame-&gt;open_space_info().origin_heading();
+
+  for (size_t i = 0; i &lt; point_boundary.size(); ++i) {
+    point_boundary[i] -= origin_point;
+    point_boundary[i].SelfRotate(-origin_heading);
+  }
+  // construct LineSegment
+  for (size_t i = 0; i &lt; point_boundary.size(); ++i) {
+    std::vector&lt;Vec2d&gt; segment{point_boundary[i],
+                               point_boundary[i + 1]};
+    roi_deadend_boundary-&gt;push_back(segment);
+  }
+  // Fuse line segments into convex contraints
+  if (!FuseLineSegments(roi_deadend_boundary)) {
+    AERROR &lt;&lt; "FuseLineSegments failed in parking ROI";
+    return false;
+  }
+  // Get xy boundary
+  auto xminmax = std::minmax_element(
+      point_boundary.begin(), point_boundary.end(),
+      [](const Vec2d &amp;a, const Vec2d &amp;b) { return a.x() &lt; b.x(); });
+  auto yminmax = std::minmax_element(
+      point_boundary.begin(), point_boundary.end(),
+      [](const Vec2d &amp;a, const Vec2d &amp;b) { return a.y() &lt; b.y(); });
+  std::vector&lt;double&gt; ROI_xy_boundary{xminmax.first-&gt;x(), xminmax.second-&gt;x(),
+                                      yminmax.first-&gt;y(), yminmax.second-&gt;y()};
+  auto *xy_boundary =
+      frame-&gt;mutable_open_space_info()-&gt;mutable_ROI_xy_boundary();
+  xy_boundary-&gt;assign(ROI_xy_boundary.begin(), ROI_xy_boundary.end());
+
+  Vec2d vehicle_xy = Vec2d(vehicle_state_.x(), vehicle_state_.y());
+  vehicle_xy -= origin_point;
+  vehicle_xy.SelfRotate(-origin_heading);
+
+  if (vehicle_xy.x() &lt; ROI_xy_boundary[0] ||
+      vehicle_xy.x() &gt; ROI_xy_boundary[1] ||
+      vehicle_xy.y() &lt; ROI_xy_boundary[2] ||
+      vehicle_xy.y() &gt; ROI_xy_boundary[3]) {
+    ADEBUG &lt;&lt; "vehicle outside of xy boundary of parking ROI";
+    return false;
+  }
+  return true;
+}
+
 bool OpenSpaceRoiDecider::GetParkingBoundary(
     Frame *const frame, const std::array&lt;Vec2d, 4&gt; &amp;vertices,
     const hdmap::Path &amp;nearby_path,
@@ -754,6 +1114,7 @@ bool OpenSpaceRoiDecider::GetParkingBoundary(
 
   // If smaller than zero, the parking spot is on the right of the lane
   // Left, right, down or opposite of the boundary is decided when viewing the
+
   // parking spot upward
   const double average_l = (left_top_l + right_top_l) / 2.0;
   std::vector&lt;Vec2d&gt; boundary_points;
@@ -765,6 +1126,7 @@ bool OpenSpaceRoiDecider::GetParkingBoundary(
     // lane boundary and assume that the lane half width is average_l
     ADEBUG &lt;&lt; "average_l is less than 0 in OpenSpaceROI";
     size_t point_size = right_lane_boundary.size();
+
     for (size_t i = 0; i &lt; point_size; i++) {
       right_lane_boundary[i].SelfRotate(origin_heading);
       right_lane_boundary[i] += origin_point;
@@ -778,12 +1140,14 @@ bool OpenSpaceRoiDecider::GetParkingBoundary(
 
     auto point_left_to_left_top_connor_s = std::lower_bound(
         center_lane_s_right.begin(), center_lane_s_right.end(), left_top_s);
+
     size_t point_left_to_left_top_connor_index = std::distance(
         center_lane_s_right.begin(), point_left_to_left_top_connor_s);
     point_left_to_left_top_connor_index =
         point_left_to_left_top_connor_index == 0
             ? point_left_to_left_top_connor_index
             : point_left_to_left_top_connor_index - 1;
+
     auto point_left_to_left_top_connor_itr =
         right_lane_boundary.begin() + point_left_to_left_top_connor_index;
     auto point_right_to_right_top_connor_s = std::upper_bound(
@@ -1197,6 +1561,21 @@ bool OpenSpaceRoiDecider::GetParkAndGoBoundary(
   return true;
 }
 
+bool OpenSpaceRoiDecider::GetDeadEndSpot(
+  Frame *const frame,
+  JunctionInfoConstPtr* junction,
+  std::vector&lt;Vec2d&gt;* dead_end_vertices) {
+  if (frame == nullptr) {
+    ADEBUG &lt;&lt; "Invalid frame, fail to GetDeadEndSpotFromMap from frame. ";
+    return false;
+  }
+  auto &amp;junction_point = (*junction)-&gt;polygon().points();
+  for (size_t i = 0; i &lt; junction_point.size(); ++i) {
+    (*dead_end_vertices).push_back(junction_point.at(i));
+  }
+  return true;
+}
+
 bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
                                          std::array&lt;Vec2d, 4&gt; *vertices,
                                          Path *nearby_path) {
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.h" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.h" added_lines="44" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
+ * Copyright 2021 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -32,6 +32,7 @@
 #include "modules/common/math/vec2d.h"
 #include "modules/common/vehicle_state/proto/vehicle_state.pb.h"
 #include "modules/common/vehicle_state/vehicle_state_provider.h"
+#include "modules/dreamview/backend/map/map_service.h"
 #include "modules/map/hdmap/hdmap_util.h"
 #include "modules/map/pnc_map/path.h"
 #include "modules/map/pnc_map/pnc_map.h"
@@ -53,6 +54,40 @@ class OpenSpaceRoiDecider : public Decider {
   apollo::common::Status Process(Frame *frame) override;
 
  private:
+  static bool SelectTargetDeadEndJunction(
+        std::vector&lt;hdmap::JunctionInfoConstPtr&gt;* junctions,
+        const apollo::common::PointENU&amp; dead_end_point,
+        hdmap::JunctionInfoConstPtr* target_junction);
+  bool GetDeadEndSpot(Frame *const frame,
+                      hdmap::JunctionInfoConstPtr* junction,
+                      std::vector&lt;common::math::Vec2d&gt;* dead_end_vertices);
+  void SetDeadEndOrigin(
+      Frame* const frame,
+      const std::vector&lt;common::math::Vec2d&gt; &amp;dead_end_vertices);
+  void SetDeadEndPose(
+      Frame* const frame,
+      const std::vector&lt;common::math::Vec2d&gt; &amp;dead_end_vertices);
+  bool GetDeadEndBoundary(
+    Frame* const frame,
+    const std::vector&lt;common::math::Vec2d&gt; &amp;dead_end_vertices,
+    const hdmap::Path &amp;nearby_path,
+    std::vector&lt;std::vector&lt;common::math::Vec2d&gt;&gt; *const roi_deadend_boundary);
+  void GetInLaneEndPoint(hdmap::LaneInfoConstPtr laneinfo,
+                         common::PointENU* left_end_point,
+                         common::PointENU* right_end_point);
+  void GetOutLaneStartPoint(hdmap::LaneInfoConstPtr laneinfo,
+                            common::PointENU* left_start_point,
+                            common::PointENU* right_start_point);
+  void GetInLaneBoundaryPoints(
+    hdmap::LaneInfoConstPtr lane_info,
+    const hdmap::Path &amp;nearby_path,
+    std::vector&lt;common::PointENU&gt;* In_left_boundary_points,
+    std::vector&lt;common::PointENU&gt;* In_right_boundary_points);
+  void GetOutLaneBoundaryPoints(
+    hdmap::LaneInfoConstPtr lane_info,
+    const hdmap::Path &amp;nearby_path,
+    std::vector&lt;common::PointENU&gt;* Out_left_boundary_points,
+    std::vector&lt;common::PointENU&gt;* Out_right_boundary_points);
   // @brief generate the path by vehicle location and return the target parking
   // spot on that path
   bool GetParkingSpot(Frame *const frame,
@@ -208,6 +243,14 @@ class OpenSpaceRoiDecider : public Decider {
   ThreadSafeIndexedObstacles *obstacles_by_frame_;
 
   common::VehicleState vehicle_state_;
+
+  common::VehicleParam vehicle_param_ =
+      common::VehicleConfigHelper::GetConfig().vehicle_param();
+  bool routing_in_flag_ = true;
+  common::PointENU dead_end_point_;
+  common::PointENU routing_end_point_;
+  common::VehicleState temp_state_;
+  common::PointENU routing_target_point_;
 };
 
 }  // namespace planning
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="2ee3611ee957a4de60ce4788d99f4e3d5aee0adf" author="haina0421">
		<msg>Add base_cipv interface and re-write inheritance</msg>
		<modified_files>
			<file old_path="modules\perception\camera\app\cipv_camera.cc" new_path="modules\perception\camera\app\cipv_camera.cc" added_lines="34" deleted_lines="20">
				<diff>@@ -25,37 +25,31 @@
 
 namespace apollo {
 namespace perception {
-
-Cipv::Cipv() {}
-
-Cipv::~Cipv() {}
+namespace camera{
 
 bool Cipv::Init(const Eigen::Matrix3d &amp;homography_im2car,
-                const float min_laneline_length_for_cipv,
-                const float average_lane_width_in_meter,
-                const float max_vehicle_width_in_meter,
-                const float average_frame_rate, const bool image_based_cipv,
-                const int debug_devel) {
-  b_image_based_cipv_ = image_based_cipv;
+                const CipvInitOptions &amp;options) {
+  b_image_based_cipv_ = options.image_based_cipv;
   debug_level_ =
-      debug_devel;  // 0: no debug message
+      options.debug_level;  
+                    // 0: no debug message
                     // 1: minimal output
                     // 2: some important output
                     // 3: verbose message
                     // 4: visualization
                     // 5: all
                     // -x: specific debugging, where x is the specific number
-  time_unit_ = average_frame_rate;
+  time_unit_ = options.average_frame_rate;
   homography_im2car_ = homography_im2car;
   homography_car2im_ = homography_im2car.inverse();
 
-  min_laneline_length_for_cipv_ = min_laneline_length_for_cipv;
-  average_lane_width_in_meter_ = average_lane_width_in_meter;
-  max_vehicle_width_in_meter_ = max_vehicle_width_in_meter;
+  min_laneline_length_for_cipv_ = options.min_laneline_length_for_cipv;
+  average_lane_width_in_meter_ = options.average_lane_width_in_meter;
+  max_vehicle_width_in_meter_ = options.max_vehicle_width_in_meter;
   margin_vehicle_to_lane_ =
-      (average_lane_width_in_meter - max_vehicle_width_in_meter) * 0.5f;
-  single_virtual_egolane_width_in_meter_ = max_vehicle_width_in_meter;
-  half_vehicle_width_in_meter_ = max_vehicle_width_in_meter * 0.5f;
+      (average_lane_width_in_meter_ - max_vehicle_width_in_meter_) * 0.5f;
+  single_virtual_egolane_width_in_meter_ = max_vehicle_width_in_meter_;
+  half_vehicle_width_in_meter_ = max_vehicle_width_in_meter_ * 0.5f;
   half_virtual_egolane_width_in_meter_ =
       single_virtual_egolane_width_in_meter_ * 0.5f;
   old_cipv_track_id_ = -2;
@@ -63,13 +57,30 @@ bool Cipv::Init(const Eigen::Matrix3d &amp;homography_im2car,
   return true;
 }
 
+bool Cipv::Process(CameraFrame *frame,
+               const CipvOptions &amp;options,
+               const Eigen::Affine3d &amp;world2camera,
+               const base::MotionBufferPtr &amp;motion_buffer){
+
+  DetermineCipv(frame-&gt;lane_objects, options, world2camera,
+                          &amp;frame-&gt;tracked_objects);
+
+  // Get Drop points
+  if (motion_buffer-&gt;size() &gt; 0) {
+  CollectDrops(motion_buffer, world2camera, &amp;frame-&gt;tracked_objects);
+  } else {
+    AWARN &lt;&lt; "motion_buffer is empty";
+  }
+  return true;
+}
+
 // Distance from a point to a line segment
 bool Cipv::DistanceFromPointToLineSegment(const Point2Df &amp;point,
                                           const Point2Df &amp;line_seg_start_point,
                                           const Point2Df &amp;line_seg_end_point,
                                           float *distance) {
-  common::math::Vec2d p = {point(0), point(1)};
-  common::math::LineSegment2d line_seg(
+  apollo::common::math::Vec2d p = {point(0), point(1)};
+  apollo::common::math::LineSegment2d line_seg(
       {line_seg_start_point(0), line_seg_start_point(1)},
       {line_seg_end_point(0), line_seg_end_point(1)});
   if (line_seg.length_sqr() &lt;= kFloatEpsilon) {
@@ -1108,5 +1119,8 @@ std::string Cipv::Name() const { return "Cipv"; }
 // Register plugin.
 // REGISTER_CIPV(Cipv);
 
+PERCEPTION_REGISTER_CIPV(Cipv);
+
+}  // namespace camera
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\camera\app\cipv_camera.h" new_path="modules\perception\camera\app\cipv_camera.h" added_lines="15" deleted_lines="21">
				<diff>@@ -31,15 +31,11 @@
 #include "modules/perception/base/lane_struct.h"
 #include "modules/perception/base/object.h"
 #include "modules/perception/camera/common/lane_object.h"
+#include "modules/perception/camera/lib/interface/base_cipv.h"
 
 namespace apollo {
 namespace perception {
-
-struct CipvOptions {
-  float velocity = 5.0f;
-  float yaw_rate = 0.0f;
-  float yaw_angle = 0.0f;
-};
+namespace camera{
 
 constexpr float kMinVelocity = 10.0f;  // in m/s
 constexpr float kMaxDistObjectToLaneInMeter = 70.0f;
@@ -53,23 +49,20 @@ static constexpr uint32_t kMaxNumVirtualLanePoint = 25;
 // TODO(All) average image frame rate should come from other header file.
 static constexpr float kAverageFrameRate = 0.05f;
 
-class Cipv {
+class Cipv : public BaseCipv {
  public:
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+  Cipv() = default;
+  ~Cipv() = default;
 
-  // Member functions
- public:
-  Cipv(void);
-  virtual ~Cipv(void);
-
-  virtual bool Init(
-      const Eigen::Matrix3d &amp;homography_im2car,
-      const float min_laneline_length_for_cipv = kMinLaneLineLengthForCIPV,
-      const float average_lane_width_in_meter = kAverageLaneWidthInMeter,
-      const float max_vehicle_width_in_meter = kMaxVehicleWidthInMeter,
-      const float average_frame_rate = kAverageFrameRate,
-      const bool image_based_cipv = false, const int debug_level = 0);
-  virtual std::string Name() const;
+  bool Init(const Eigen::Matrix3d &amp;homography_im2car,
+            const CipvInitOptions &amp;options =CipvInitOptions()) override;
+
+  bool Process(CameraFrame *frame,
+               const CipvOptions &amp;options,
+               const Eigen::Affine3d &amp;world2camera,
+               const base::MotionBufferPtr &amp;motion_buffer) override;
+
+  std::string Name() const override;
 
   // Determine CIPV among multiple objects
   bool DetermineCipv(const std::vector&lt;base::LaneLine&gt; &amp;lane_objects,
@@ -214,5 +207,6 @@ class Cipv {
   int32_t old_cipv_track_id_ = -2;
 };
 
+}  // namespace camera
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\detection_component.cc" new_path="modules\perception\onboard\component\detection_component.cc" added_lines="8" deleted_lines="11">
				<diff>@@ -39,6 +39,7 @@ bool DetectionComponent::Init() {
   ADEBUG &lt;&lt; "Lidar Component Configs: " &lt;&lt; comp_config.DebugString();
   output_channel_name_ = comp_config.output_channel_name();
   sensor_name_ = comp_config.sensor_name();
+  detector_name_ = comp_config.detector_name();
   lidar2novatel_tf2_child_frame_id_ =
       comp_config.lidar2novatel_tf2_child_frame_id();
   lidar_query_tf_offset_ =
@@ -74,21 +75,17 @@ bool DetectionComponent::InitAlgorithmPlugin() {
   ACHECK(common::SensorManager::Instance()-&gt;GetSensorInfo(sensor_name_,
                                                           &amp;sensor_info_));
 
-  detector_.reset(new lidar::LidarObstacleDetection);
-  if (detector_ == nullptr) {
-    AERROR &lt;&lt; "sensor_name_ "
-           &lt;&lt; "Failed to get detection instance";
-    return false;
-  }
+  lidar::BaseLidarObstacleDetection* detector =
+      lidar::BaseLidarObstacleDetectionRegisterer::
+      GetInstanceByName(detector_name_);
+  CHECK_NOTNULL(detector);
+  detector_.reset(detector);
   lidar::LidarObstacleDetectionInitOptions init_options;
   init_options.sensor_name = sensor_name_;
   init_options.enable_hdmap_input =
       FLAGS_obs_enable_hdmap_input &amp;&amp; enable_hdmap_;
-  if (!detector_-&gt;Init(init_options)) {
-    AINFO &lt;&lt; "sensor_name_ "
-          &lt;&lt; "Failed to init detection.";
-    return false;
-  }
+  ACHECK(detector_-&gt;Init(init_options)) &lt;&lt;
+                            "lidar obstacle detection init error";
 
   lidar2world_trans_.Init(lidar2novatel_tf2_child_frame_id_);
   return true;
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\detection_component.h" new_path="modules\perception\onboard\component\detection_component.h" added_lines="1" deleted_lines="0">
				<diff>@@ -48,6 +48,7 @@ class DetectionComponent : public cyber::Component&lt;drivers::PointCloud&gt; {
  private:
   static std::atomic&lt;uint32_t&gt; seq_num_;
   std::string sensor_name_;
+  std::string detector_name_;
   bool enable_hdmap_ = true;
   float lidar_query_tf_offset_ = 20.0f;
   std::string lidar2novatel_tf2_child_frame_id_;
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_camera_detection_component.cc" new_path="modules\perception\onboard\component\fusion_camera_detection_component.cc" added_lines="17" deleted_lines="19">
				<diff>@@ -248,9 +248,12 @@ bool FusionCameraDetectionComponent::Init() {
   camera_obstacle_pipeline_-&gt;SetIm2CarHomography(homography_im2car_);
 
   if (enable_cipv_) {
-    cipv_.Init(homography_im2car_, min_laneline_length_for_cipv_,
-               average_lane_width_in_meter_, max_vehicle_width_in_meter_,
-               average_frame_rate_, image_based_cipv_, debug_level_);
+    camera::BaseCipv* cipv = camera::BaseCipvRegisterer::
+        GetInstanceByName(cipv_name_);
+    CHECK_NOTNULL(cipv);
+    cipv_.reset(cipv);
+    ACHECK(cipv_-&gt;Init(homography_im2car_, cipv_init_options_))
+               &lt;&lt; "camera cipv init error";
   }
 
   if (enable_visualization_) {
@@ -393,21 +396,23 @@ int FusionCameraDetectionComponent::InitConfig() {
   ts_diff_ = fusion_camera_detection_param.ts_diff();
   write_visual_img_ = fusion_camera_detection_param.write_visual_img();
 
-  min_laneline_length_for_cipv_ = static_cast&lt;float&gt;(
+  cipv_init_options_.min_laneline_length_for_cipv = static_cast&lt;float&gt;(
       fusion_camera_detection_param.min_laneline_length_for_cipv());
-  average_lane_width_in_meter_ = static_cast&lt;float&gt;(
+  cipv_init_options_.average_lane_width_in_meter = static_cast&lt;float&gt;(
       fusion_camera_detection_param.average_lane_width_in_meter());
-  max_vehicle_width_in_meter_ = static_cast&lt;float&gt;(
+  cipv_init_options_.max_vehicle_width_in_meter = static_cast&lt;float&gt;(
       fusion_camera_detection_param.max_vehicle_width_in_meter());
-  average_frame_rate_ =
+  cipv_init_options_.average_frame_rate =
       static_cast&lt;float&gt;(fusion_camera_detection_param.average_frame_rate());
 
-  image_based_cipv_ =
+  cipv_init_options_.image_based_cipv =
       static_cast&lt;float&gt;(fusion_camera_detection_param.image_based_cipv());
 
-  debug_level_ = static_cast&lt;int&gt;(fusion_camera_detection_param.debug_level());
+  cipv_init_options_.debug_level = static_cast&lt;int&gt;(fusion_camera_detection_param.debug_level());
   enable_cipv_ = fusion_camera_detection_param.enable_cipv();
 
+  cipv_name_ = fusion_camera_detection_param.cipv();
+
   std::string format_str = R"(
       FusionCameraDetectionComponent InitConfig success
       camera_names:    %s, %s
@@ -496,6 +501,7 @@ int FusionCameraDetectionComponent::InitAlgorithmPlugin() {
   }
   AINFO &lt;&lt; "camera_obstacle_pipeline_-&gt;Init() succeed";
   return cyber::SUCC;
+
 }
 
 int FusionCameraDetectionComponent::InitCameraFrames() {
@@ -767,7 +773,7 @@ int FusionCameraDetectionComponent::InternalProc(
 
   //  Determine CIPV
   if (enable_cipv_) {
-    CipvOptions cipv_options;
+    camera::CipvOptions cipv_options;
     if (motion_buffer_ != nullptr) {
       if (motion_buffer_-&gt;size() == 0) {
         AWARN &lt;&lt; "motion_buffer_ is empty";
@@ -779,16 +785,8 @@ int FusionCameraDetectionComponent::InternalProc(
       }
       ADEBUG &lt;&lt; "[CIPV] velocity " &lt;&lt; cipv_options.velocity
              &lt;&lt; ", yaw rate: " &lt;&lt; cipv_options.yaw_rate;
-      cipv_.DetermineCipv(camera_frame.lane_objects, cipv_options, world2camera,
-                          &amp;camera_frame.tracked_objects);
 
-      // Get Drop points
-      if (motion_buffer_-&gt;size() &gt; 0) {
-        cipv_.CollectDrops(motion_buffer_, world2camera,
-                           &amp;camera_frame.tracked_objects);
-      } else {
-        AWARN &lt;&lt; "motion_buffer is empty";
-      }
+      cipv_-&gt;Process(&amp;camera_frame, cipv_options, world2camera, motion_buffer_);
     }
   }
 
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_camera_detection_component.h" new_path="modules\perception\onboard\component\fusion_camera_detection_component.h" added_lines="4" deleted_lines="7">
				<diff>@@ -202,13 +202,10 @@ class FusionCameraDetectionComponent : public apollo::cyber::Component&lt;&gt; {
 
   // // variables for CIPV
   bool enable_cipv_ = false;
-  Cipv cipv_;
-  float min_laneline_length_for_cipv_ = kMinLaneLineLengthForCIPV;
-  float average_lane_width_in_meter_ = kAverageLaneWidthInMeter;
-  float max_vehicle_width_in_meter_ = kMaxVehicleWidthInMeter;
-  float average_frame_rate_ = kAverageFrameRate;
-  bool image_based_cipv_ = false;
-  int debug_level_ = 0;
+  std::unique_ptr&lt;camera::BaseCipv&gt; cipv_;
+  camera::CipvInitOptions cipv_init_options_;
+  std::string cipv_name_;
+
   // variables for visualization
   camera::Visualizer visualize_;
   bool write_visual_img_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e120d91dffedc5ce7ccaa923acdcff5633b22942" author="haina0421">
		<msg>Add base TL Preprocessor and update inheritance</msg>
		<modified_files>
			<file old_path="modules\perception\camera\lib\traffic_light\preprocessor\tl_preprocessor.cc" new_path="modules\perception\camera\lib\traffic_light\preprocessor\tl_preprocessor.cc" added_lines="2" deleted_lines="0">
				<diff>@@ -352,6 +352,8 @@ std::string TLPreprocessor::GetMaxFocalLenWorkingCameraName() const {
   return "";
 }
 
+PERCEPTION_REGISTER_TLPREPROCESSOR(TLPreprocessor);
+
 }  // namespace camera
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\traffic_light\preprocessor\tl_preprocessor.h" new_path="modules\perception\camera\lib\traffic_light\preprocessor\tl_preprocessor.h" added_lines="9" deleted_lines="18">
				<diff>@@ -29,45 +29,36 @@
 
 #include "modules/perception/camera/common/camera_frame.h"
 #include "modules/perception/camera/lib/interface/base_init_options.h"
+#include "modules/perception/camera/lib/interface/base_tl_preprocessor.h"
 
 namespace apollo {
 namespace perception {
 namespace camera {
 
-struct TrafficLightPreprocessorInitOptions : public BaseInitOptions {
-  int gpu_id = 0;
-  float sync_interval_seconds;
-  std::vector&lt;std::string&gt; camera_names;
-};
-
-struct TLPreprocessorOption {
-  std::map&lt;std::string, int&gt;* image_borders_size = nullptr;
-};
-
-class TLPreprocessor {
+class TLPreprocessor : public BaseTLPreprocessor {
  public:
   TLPreprocessor() = default;
   ~TLPreprocessor() = default;
 
-  bool Init(const TrafficLightPreprocessorInitOptions&amp; options);
+  bool Init(const TrafficLightPreprocessorInitOptions&amp; options) override;
 
-  std::string Name() const;
+  std::string Name() const override;
 
   bool UpdateCameraSelection(const CarPose&amp; pose,
                              const TLPreprocessorOption&amp; option,
-                             std::vector&lt;base::TrafficLightPtr&gt;* lights);
+                             std::vector&lt;base::TrafficLightPtr&gt;* lights) override;
 
   bool SyncInformation(const double ts, const std::string&amp; camera_name);
   bool UpdateLightsProjection(const CarPose&amp; pose,
                               const TLPreprocessorOption&amp; option,
                               const std::string&amp; camera_name,
-                              std::vector&lt;base::TrafficLightPtr&gt;* lights);
+                              std::vector&lt;base::TrafficLightPtr&gt;* lights) override;
 
-  bool SetCameraWorkingFlag(const std::string&amp; camera_name, bool is_working);
+  bool SetCameraWorkingFlag(const std::string&amp; camera_name, bool is_working) override;
   bool GetCameraWorkingFlag(const std::string&amp; camera_name,
-                            bool* is_working) const;
+                            bool* is_working) const override;
 
-  const std::vector&lt;std::string&gt;&amp; GetCameraNamesByDescendingFocalLen() const {
+  const std::vector&lt;std::string&gt;&amp; GetCameraNamesByDescendingFocalLen() const override {
     return projection_.getCameraNamesByDescendingFocalLen();
   }
   bool GetAlllightsOutsideFlag() const;
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\trafficlights_perception_component.cc" new_path="modules\perception\onboard\component\trafficlights_perception_component.cc" added_lines="6" deleted_lines="5">
				<diff>@@ -163,6 +163,8 @@ int TrafficLightsPerceptionComponent::InitConfig() {
       traffic_light_param.image_sys_ts_diff_threshold();
   preprocessor_init_options_.sync_interval_seconds =
       static_cast&lt;float&gt;(traffic_light_param.sync_interval_seconds());
+  tl_preprocessor_name_ = traffic_light_param.tl_preprocessor_name();
+  
   camera_perception_init_options_.root_dir =
       traffic_light_param.camera_traffic_light_perception_conf_dir();
   camera_perception_init_options_.conf_file =
@@ -184,11 +186,10 @@ int TrafficLightsPerceptionComponent::InitConfig() {
 
 int TrafficLightsPerceptionComponent::InitAlgorithmPlugin() {
   // init preprocessor
-  preprocessor_.reset(new camera::TLPreprocessor);
-  if (!preprocessor_) {
-    AERROR &lt;&lt; "TrafficLightsPerceptionComponent new preprocessor failed";
-    return cyber::FAIL;
-  }
+  camera::BaseTLPreprocessor* preprocessor = camera::BaseTLPreprocessorRegisterer::
+        GetInstanceByName(tl_preprocessor_name_);
+  CHECK_NOTNULL(preprocessor);
+  preprocessor_.reset(preprocessor);
 
   preprocessor_init_options_.camera_names = camera_names_;
   if (!preprocessor_-&gt;Init(preprocessor_init_options_)) {
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\trafficlights_perception_component.h" new_path="modules\perception\onboard\component\trafficlights_perception_component.h" added_lines="2" deleted_lines="1">
				<diff>@@ -111,10 +111,11 @@ class TrafficLightsPerceptionComponent : public apollo::cyber::Component&lt;&gt; {
  private:
   std::mutex mutex_;
 
-  std::shared_ptr&lt;camera::TLPreprocessor&gt; preprocessor_;
+  std::shared_ptr&lt;camera::BaseTLPreprocessor&gt; preprocessor_;
   apollo::perception::map::HDMapInput* hd_map_ = nullptr;
 
   camera::TrafficLightPreprocessorInitOptions preprocessor_init_options_;
+  std::string tl_preprocessor_name_;
 
   std::string tf2_frame_id_;
   std::string tf2_child_frame_id_;
</diff>
			</file>
			<file old_path="modules\perception\production\conf\perception\camera\trafficlights_perception_component.config" new_path="modules\perception\production\conf\perception\camera\trafficlights_perception_component.config" added_lines="1" deleted_lines="0">
				<diff>@@ -19,3 +19,4 @@ simulation_channel_name : "/perception/traffic_light_simulation"
 v2x_trafficlights_input_channel_name : "/apollo/v2x/traffic_light"
 v2x_sync_interval_seconds : 0.1
 max_v2x_msg_buff_size : 50
+tl_preprocessor_name : "TLPreprocessor"
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d30bdce4a546a4390058f518559a8b562cc1c15a" author="haina0421">
		<msg>DreamLand Debug</msg>
		<modified_files>
			<file old_path="modules\perception\camera\lib\traffic_light\preprocessor\tl_preprocessor.h" new_path="modules\perception\camera\lib\traffic_light\preprocessor\tl_preprocessor.h" added_lines="1" deleted_lines="0">
				<diff>@@ -30,6 +30,7 @@
 #include "modules/perception/camera/common/camera_frame.h"
 #include "modules/perception/camera/lib/interface/base_init_options.h"
 #include "modules/perception/camera/lib/interface/base_tl_preprocessor.h"
+#include "modules/perception/lib/registerer/registerer.h"
 
 namespace apollo {
 namespace perception {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6d3bf014de845ee3607f97ff38e721c689fb5322" author="haina0421">
		<msg>Add base_multisensor_fusion and update inheritance</msg>
		<modified_files>
			<file old_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.cc" new_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.cc" added_lines="5" deleted_lines="1">
				<diff>@@ -25,7 +25,9 @@ bool ObstacleMultiSensorFusion::Init(
     AINFO &lt;&lt; "Already inited";
     return true;
   }
-  fusion_ = BaseFusionSystemRegisterer::GetInstanceByName(param.fusion_method);
+  BaseFusionSystem* fusion = 
+          BaseFusionSystemRegisterer::GetInstanceByName(param.fusion_method);
+  fusion_.reset(fusion);
 
   FusionInitOptions init_options;
   init_options.main_sensors = param.main_sensors;
@@ -42,6 +44,8 @@ bool ObstacleMultiSensorFusion::Process(const base::FrameConstPtr&amp; frame,
   return fusion_-&gt;Fuse(options, frame, objects);
 }
 
+PERCEPTION_REGISTER_MULTISENSORFUSION(ObstacleMultiSensorFusion);
+
 }  // namespace fusion
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.h" new_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.h" added_lines="8" deleted_lines="13">
				<diff>@@ -18,32 +18,27 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
+#include "modules/perception/fusion/lib/interface/base_multisensor_fusion.h"
 #include "modules/perception/fusion/lib/interface/base_fusion_system.h"
 
 namespace apollo {
 namespace perception {
 namespace fusion {
 
-struct ObstacleMultiSensorFusionParam {
-  std::vector&lt;std::string&gt; main_sensors;
-  std::string fusion_method;
-};
-
-class ObstacleMultiSensorFusion {
+class ObstacleMultiSensorFusion : public BaseMultiSensorFusion {
  public:
   ObstacleMultiSensorFusion() = default;
   ~ObstacleMultiSensorFusion() = default;
-  ObstacleMultiSensorFusion(const ObstacleMultiSensorFusion&amp;) = delete;
-  ObstacleMultiSensorFusion&amp; operator=(const ObstacleMultiSensorFusion&amp;) =
-      delete;
-  bool Init(const ObstacleMultiSensorFusionParam&amp; param);
+
+  bool Init(const ObstacleMultiSensorFusionParam&amp; param) override;
+
   bool Process(const base::FrameConstPtr&amp; frame,
-               std::vector&lt;base::ObjectPtr&gt;* objects);
+               std::vector&lt;base::ObjectPtr&gt;* objects) override;
 
-  std::string Name() const { return "ObstacleMultiSensorFusion"; }
+  std::string Name() const override { return "ObstacleMultiSensorFusion"; }
 
  protected:
-  BaseFusionSystem* fusion_ = nullptr;
+  std::unique_ptr&lt;BaseFusionSystem&gt; fusion_;
 };
 
 }  // namespace fusion
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_component.cc" new_path="modules\perception\onboard\component\fusion_component.cc" added_lines="5" deleted_lines="1">
				<diff>@@ -36,6 +36,7 @@ bool FusionComponent::Init() {
   AINFO &lt;&lt; "Fusion Component Configs: " &lt;&lt; comp_config.DebugString();
 
   // to load component configs
+  fusion_name_ = comp_config.fusion_name();
   fusion_method_ = comp_config.fusion_method();
   for (int i = 0; i &lt; comp_config.fusion_main_sensors_size(); ++i) {
     fusion_main_sensors_.push_back(comp_config.fusion_main_sensors(i));
@@ -83,7 +84,10 @@ bool FusionComponent::Proc(const std::shared_ptr&lt;SensorFrameMessage&gt;&amp; message) {
 }
 
 bool FusionComponent::InitAlgorithmPlugin() {
-  fusion_.reset(new fusion::ObstacleMultiSensorFusion());
+  fusion::BaseMultiSensorFusion* fusion =
+    fusion::BaseMultiSensorFusionRegisterer::GetInstanceByName(fusion_name_);
+  CHECK_NOTNULL(fusion);
+  fusion_.reset(fusion);
   fusion::ObstacleMultiSensorFusionParam param;
   param.main_sensors = fusion_main_sensors_;
   param.fusion_method = fusion_method_;
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_component.h" new_path="modules\perception\onboard\component\fusion_component.h" added_lines="2" deleted_lines="1">
				<diff>@@ -48,12 +48,13 @@ class FusionComponent : public cyber::Component&lt;SensorFrameMessage&gt; {
   static std::mutex s_mutex_;
   static uint32_t s_seq_num_;
 
+  std::string fusion_name_;
   std::string fusion_method_;
   std::vector&lt;std::string&gt; fusion_main_sensors_;
   bool object_in_roi_check_ = false;
   double radius_for_roi_object_check_ = 0;
 
-  std::unique_ptr&lt;fusion::ObstacleMultiSensorFusion&gt; fusion_;
+  std::unique_ptr&lt;fusion::BaseMultiSensorFusion&gt; fusion_;
   map::HDMapInput* hdmap_input_ = nullptr;
   std::shared_ptr&lt;apollo::cyber::Writer&lt;PerceptionObstacles&gt;&gt; writer_;
   std::shared_ptr&lt;apollo::cyber::Writer&lt;SensorFrameMessage&gt;&gt; inner_writer_;
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\trafficlights_perception_component.cc" new_path="modules\perception\onboard\component\trafficlights_perception_component.cc" added_lines="0" deleted_lines="3">
				<diff>@@ -188,9 +188,6 @@ int TrafficLightsPerceptionComponent::InitAlgorithmPlugin() {
   // init preprocessor
   camera::BaseTLPreprocessor* preprocessor = camera::BaseTLPreprocessorRegisterer::
         GetInstanceByName(tl_preprocessor_name_);
-  std::vector&lt;camera::BaseTLPreprocessor*&gt; vec = camera::BaseTLPreprocessorRegisterer::
-        GetAllInstances();
-  std::cout &lt;&lt; "Size of TLPreprocessor Map: " &lt;&lt; vec.size() &lt;&lt; std::endl;
   CHECK_NOTNULL(preprocessor);
   preprocessor_.reset(preprocessor);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a7c2fd0d00c69251a6775393c224d542a3ea01bc" author="haina0421">
		<msg>BugFixed Fusion undefined symbol</msg>
		<modified_files>
			<file old_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.h" new_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.h" added_lines="2" deleted_lines="1">
				<diff>@@ -15,6 +15,7 @@
  *****************************************************************************/
 #pragma once
 
+#include &lt;memory&gt;
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
@@ -28,7 +29,7 @@ namespace fusion {
 class ObstacleMultiSensorFusion : public BaseMultiSensorFusion {
  public:
   ObstacleMultiSensorFusion() = default;
-  ~ObstacleMultiSensorFusion() = default;
+  virtual ~ObstacleMultiSensorFusion() = default;
 
   bool Init(const ObstacleMultiSensorFusionParam&amp; param) override;
 
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\interface\base_multisensor_fusion.h" new_path="modules\perception\fusion\lib\interface\base_multisensor_fusion.h" added_lines="2" deleted_lines="2">
				<diff>@@ -38,10 +38,10 @@ class BaseMultiSensorFusion {
   BaseMultiSensorFusion() = default;
   virtual ~BaseMultiSensorFusion() = default;
 
-  virtual bool Init(const ObstacleMultiSensorFusionParam&amp; param);
+  virtual bool Init(const ObstacleMultiSensorFusionParam&amp; param) = 0;
 
   virtual bool Process(const base::FrameConstPtr&amp; frame,
-               std::vector&lt;base::ObjectPtr&gt;* objects);
+               std::vector&lt;base::ObjectPtr&gt;* objects) = 0;
 
   virtual std::string Name() const = 0;
 
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_component.h" new_path="modules\perception\onboard\component\fusion_component.h" added_lines="1" deleted_lines="1">
				<diff>@@ -21,7 +21,7 @@
 
 #include "cyber/component/component.h"
 #include "modules/perception/base/object.h"
-#include "modules/perception/fusion/app/obstacle_multi_sensor_fusion.h"
+#include "modules/perception/fusion/lib/interface/base_multisensor_fusion.h"
 #include "modules/perception/fusion/lib/interface/base_fusion_system.h"
 #include "modules/perception/map/hdmap/hdmap_input.h"
 #include "modules/perception/onboard/inner_component_messages/inner_component_messages.h"
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ce565859475c6614e9d3de4f9779642a44f2a7cc" author="haina0421">
		<msg>Solve CI issues</msg>
		<modified_files>
			<file old_path="modules\perception\camera\app\cipv_camera.cc" new_path="modules\perception\camera\app\cipv_camera.cc" added_lines="3" deleted_lines="4">
				<diff>@@ -25,13 +25,13 @@
 
 namespace apollo {
 namespace perception {
-namespace camera{
+namespace camera {
 
 bool Cipv::Init(const Eigen::Matrix3d &amp;homography_im2car,
                 const CipvInitOptions &amp;options) {
   b_image_based_cipv_ = options.image_based_cipv;
   debug_level_ =
-      options.debug_level;  
+      options.debug_level;
                     // 0: no debug message
                     // 1: minimal output
                     // 2: some important output
@@ -60,8 +60,7 @@ bool Cipv::Init(const Eigen::Matrix3d &amp;homography_im2car,
 bool Cipv::Process(CameraFrame *frame,
                const CipvOptions &amp;options,
                const Eigen::Affine3d &amp;world2camera,
-               const base::MotionBufferPtr &amp;motion_buffer){
-
+               const base::MotionBufferPtr &amp;motion_buffer) {
   DetermineCipv(frame-&gt;lane_objects, options, world2camera,
                           &amp;frame-&gt;tracked_objects);
 
</diff>
			</file>
			<file old_path="modules\perception\camera\app\cipv_camera.h" new_path="modules\perception\camera\app\cipv_camera.h" added_lines="2" deleted_lines="2">
				<diff>@@ -35,7 +35,7 @@
 
 namespace apollo {
 namespace perception {
-namespace camera{
+namespace camera {
 
 constexpr float kMinVelocity = 10.0f;  // in m/s
 constexpr float kMaxDistObjectToLaneInMeter = 70.0f;
@@ -55,7 +55,7 @@ class Cipv : public BaseCipv {
   ~Cipv() = default;
 
   bool Init(const Eigen::Matrix3d &amp;homography_im2car,
-            const CipvInitOptions &amp;options =CipvInitOptions()) override;
+            const CipvInitOptions &amp;options = CipvInitOptions()) override;
 
   bool Process(CameraFrame *frame,
                const CipvOptions &amp;options,
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\interface\base_cipv.h" new_path="modules\perception\camera\lib\interface\base_cipv.h" added_lines="2" deleted_lines="2">
				<diff>@@ -30,7 +30,7 @@
 
 namespace apollo {
 namespace perception {
-namespace camera{
+namespace camera {
 
 struct CipvInitOptions : public BaseInitOptions {
   float min_laneline_length_for_cipv = 2.0f;
@@ -57,7 +57,7 @@ class BaseCipv {
   virtual ~BaseCipv() = default;
 
   virtual bool Init(const Eigen::Matrix3d &amp;homography_im2car,
-      const CipvInitOptions &amp;options =CipvInitOptions()) = 0;
+      const CipvInitOptions &amp;options = CipvInitOptions()) = 0;
 
   virtual bool Process(CameraFrame *frame,
                     const CipvOptions &amp;options,
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\interface\base_tl_preprocessor.h" new_path="modules\perception\camera\lib\interface\base_tl_preprocessor.h" added_lines="3" deleted_lines="2">
				<diff>@@ -66,9 +66,10 @@ class BaseTLPreprocessor {
   virtual bool GetCameraWorkingFlag(const std::string&amp; camera_name,
                             bool* is_working) const = 0;
 
-  virtual const std::vector&lt;std::string&gt;&amp; GetCameraNamesByDescendingFocalLen() const = 0;
+  virtual const std::vector&lt;std::string&gt;&amp;
+                GetCameraNamesByDescendingFocalLen() const = 0;
 
-  private:
+ private:
   DISALLOW_COPY_AND_ASSIGN(BaseTLPreprocessor);
 };
 
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\traffic_light\preprocessor\tl_preprocessor.h" new_path="modules\perception\camera\lib\traffic_light\preprocessor\tl_preprocessor.h" added_lines="9" deleted_lines="7">
				<diff>@@ -46,20 +46,22 @@ class TLPreprocessor : public BaseTLPreprocessor {
   std::string Name() const override;
 
   bool UpdateCameraSelection(const CarPose&amp; pose,
-                             const TLPreprocessorOption&amp; option,
-                             std::vector&lt;base::TrafficLightPtr&gt;* lights) override;
+                    const TLPreprocessorOption&amp; option,
+                    std::vector&lt;base::TrafficLightPtr&gt;* lights) override;
 
   bool SyncInformation(const double ts, const std::string&amp; camera_name);
   bool UpdateLightsProjection(const CarPose&amp; pose,
-                              const TLPreprocessorOption&amp; option,
-                              const std::string&amp; camera_name,
-                              std::vector&lt;base::TrafficLightPtr&gt;* lights) override;
+                    const TLPreprocessorOption&amp; option,
+                    const std::string&amp; camera_name,
+                    std::vector&lt;base::TrafficLightPtr&gt;* lights) override;
 
-  bool SetCameraWorkingFlag(const std::string&amp; camera_name, bool is_working) override;
+  bool SetCameraWorkingFlag(const std::string&amp; camera_name,
+                    bool is_working) override;
   bool GetCameraWorkingFlag(const std::string&amp; camera_name,
                             bool* is_working) const override;
 
-  const std::vector&lt;std::string&gt;&amp; GetCameraNamesByDescendingFocalLen() const override {
+  const std::vector&lt;std::string&gt;&amp;
+    GetCameraNamesByDescendingFocalLen() const override {
     return projection_.getCameraNamesByDescendingFocalLen();
   }
   bool GetAlllightsOutsideFlag() const;
</diff>
			</file>
			<file old_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.cc" new_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -25,7 +25,7 @@ bool ObstacleMultiSensorFusion::Init(
     AINFO &lt;&lt; "Already inited";
     return true;
   }
-  BaseFusionSystem* fusion = 
+  BaseFusionSystem* fusion =
           BaseFusionSystemRegisterer::GetInstanceByName(param.fusion_method);
   fusion_.reset(fusion);
 
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\interface\base_multisensor_fusion.h" new_path="modules\perception\fusion\lib\interface\base_multisensor_fusion.h" added_lines="1" deleted_lines="1">
				<diff>@@ -47,7 +47,7 @@ class BaseMultiSensorFusion {
 
  private:
   DISALLOW_COPY_AND_ASSIGN(BaseMultiSensorFusion);
-}; // Class BaseMultiSensorFusion
+};  // Class BaseMultiSensorFusion
 
 PERCEPTION_REGISTER_REGISTERER(BaseMultiSensorFusion);
 #define PERCEPTION_REGISTER_MULTISENSORFUSION(name) \
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_camera_detection_component.cc" new_path="modules\perception\onboard\component\fusion_camera_detection_component.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -408,7 +408,8 @@ int FusionCameraDetectionComponent::InitConfig() {
   cipv_init_options_.image_based_cipv =
       static_cast&lt;float&gt;(fusion_camera_detection_param.image_based_cipv());
 
-  cipv_init_options_.debug_level = static_cast&lt;int&gt;(fusion_camera_detection_param.debug_level());
+  cipv_init_options_.debug_level =
+      static_cast&lt;int&gt;(fusion_camera_detection_param.debug_level());
   enable_cipv_ = fusion_camera_detection_param.enable_cipv();
 
   cipv_name_ = fusion_camera_detection_param.cipv();
@@ -501,7 +502,6 @@ int FusionCameraDetectionComponent::InitAlgorithmPlugin() {
   }
   AINFO &lt;&lt; "camera_obstacle_pipeline_-&gt;Init() succeed";
   return cyber::SUCC;
-
 }
 
 int FusionCameraDetectionComponent::InitCameraFrames() {
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\trafficlights_perception_component.cc" new_path="modules\perception\onboard\component\trafficlights_perception_component.cc" added_lines="4" deleted_lines="3">
				<diff>@@ -164,7 +164,7 @@ int TrafficLightsPerceptionComponent::InitConfig() {
   preprocessor_init_options_.sync_interval_seconds =
       static_cast&lt;float&gt;(traffic_light_param.sync_interval_seconds());
   tl_preprocessor_name_ = traffic_light_param.tl_preprocessor_name();
-  
+
   camera_perception_init_options_.root_dir =
       traffic_light_param.camera_traffic_light_perception_conf_dir();
   camera_perception_init_options_.conf_file =
@@ -186,8 +186,9 @@ int TrafficLightsPerceptionComponent::InitConfig() {
 
 int TrafficLightsPerceptionComponent::InitAlgorithmPlugin() {
   // init preprocessor
-  camera::BaseTLPreprocessor* preprocessor = camera::BaseTLPreprocessorRegisterer::
-        GetInstanceByName(tl_preprocessor_name_);
+  camera::BaseTLPreprocessor* preprocessor =
+            camera::BaseTLPreprocessorRegisterer::
+            GetInstanceByName(tl_preprocessor_name_);
   CHECK_NOTNULL(preprocessor);
   preprocessor_.reset(preprocessor);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1b2d76e193616f55c1ed4abfbceca6da0d6ca6e6" author="haina0421">
		<msg>Update camera_obstacle_detection_component</msg>
		<modified_files>
			<file old_path="modules\perception\onboard\component\camera_obstacle_detection_component.cc" new_path="modules\perception\onboard\component\camera_obstacle_detection_component.cc" added_lines="17" deleted_lines="19">
				<diff>@@ -248,9 +248,12 @@ bool CameraObstacleDetectionComponent::Init() {
   camera_obstacle_pipeline_-&gt;SetIm2CarHomography(homography_im2car_);
 
   if (enable_cipv_) {
-    cipv_.Init(homography_im2car_, min_laneline_length_for_cipv_,
-               average_lane_width_in_meter_, max_vehicle_width_in_meter_,
-               average_frame_rate_, image_based_cipv_, debug_level_);
+    camera::BaseCipv* cipv = camera::BaseCipvRegisterer::
+        GetInstanceByName(cipv_name_);
+    CHECK_NOTNULL(cipv);
+    cipv_.reset(cipv);
+    ACHECK(cipv_-&gt;Init(homography_im2car_, cipv_init_options_))
+               &lt;&lt; "camera cipv init error";
   }
 
   if (enable_visualization_) {
@@ -393,21 +396,24 @@ int CameraObstacleDetectionComponent::InitConfig() {
   ts_diff_ = fusion_camera_detection_param.ts_diff();
   write_visual_img_ = fusion_camera_detection_param.write_visual_img();
 
-  min_laneline_length_for_cipv_ = static_cast&lt;float&gt;(
+  cipv_init_options_.min_laneline_length_for_cipv = static_cast&lt;float&gt;(
       fusion_camera_detection_param.min_laneline_length_for_cipv());
-  average_lane_width_in_meter_ = static_cast&lt;float&gt;(
+  cipv_init_options_.average_lane_width_in_meter = static_cast&lt;float&gt;(
       fusion_camera_detection_param.average_lane_width_in_meter());
-  max_vehicle_width_in_meter_ = static_cast&lt;float&gt;(
+  cipv_init_options_.max_vehicle_width_in_meter = static_cast&lt;float&gt;(
       fusion_camera_detection_param.max_vehicle_width_in_meter());
-  average_frame_rate_ =
+  cipv_init_options_.average_frame_rate =
       static_cast&lt;float&gt;(fusion_camera_detection_param.average_frame_rate());
 
-  image_based_cipv_ =
+  cipv_init_options_.image_based_cipv =
       static_cast&lt;float&gt;(fusion_camera_detection_param.image_based_cipv());
 
-  debug_level_ = static_cast&lt;int&gt;(fusion_camera_detection_param.debug_level());
+  cipv_init_options_.debug_level =
+      static_cast&lt;int&gt;(fusion_camera_detection_param.debug_level());
   enable_cipv_ = fusion_camera_detection_param.enable_cipv();
 
+  cipv_name_ = fusion_camera_detection_param.cipv();
+
   std::string format_str = R"(
       CameraObstacleDetectionComponent InitConfig success
       camera_names:    %s, %s
@@ -762,7 +768,7 @@ int CameraObstacleDetectionComponent::InternalProc(
 
   //  Determine CIPV
   if (enable_cipv_) {
-    CipvOptions cipv_options;
+    camera::CipvOptions cipv_options;
     if (motion_buffer_ != nullptr) {
       if (motion_buffer_-&gt;size() == 0) {
         AWARN &lt;&lt; "motion_buffer_ is empty";
@@ -774,16 +780,8 @@ int CameraObstacleDetectionComponent::InternalProc(
       }
       ADEBUG &lt;&lt; "[CIPV] velocity " &lt;&lt; cipv_options.velocity
              &lt;&lt; ", yaw rate: " &lt;&lt; cipv_options.yaw_rate;
-      cipv_.DetermineCipv(camera_frame.lane_objects, cipv_options, world2camera,
-                          &amp;camera_frame.tracked_objects);
 
-      // Get Drop points
-      if (motion_buffer_-&gt;size() &gt; 0) {
-        cipv_.CollectDrops(motion_buffer_, world2camera,
-                           &amp;camera_frame.tracked_objects);
-      } else {
-        AWARN &lt;&lt; "motion_buffer is empty";
-      }
+      cipv_-&gt;Process(&amp;camera_frame, cipv_options, world2camera, motion_buffer_);
     }
   }
 
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\camera_obstacle_detection_component.h" new_path="modules\perception\onboard\component\camera_obstacle_detection_component.h" added_lines="4" deleted_lines="7">
				<diff>@@ -203,13 +203,10 @@ class CameraObstacleDetectionComponent : public apollo::cyber::Component&lt;&gt; {
 
   // // variables for CIPV
   bool enable_cipv_ = false;
-  Cipv cipv_;
-  float min_laneline_length_for_cipv_ = kMinLaneLineLengthForCIPV;
-  float average_lane_width_in_meter_ = kAverageLaneWidthInMeter;
-  float max_vehicle_width_in_meter_ = kMaxVehicleWidthInMeter;
-  float average_frame_rate_ = kAverageFrameRate;
-  bool image_based_cipv_ = false;
-  int debug_level_ = 0;
+  std::unique_ptr&lt;camera::BaseCipv&gt; cipv_;
+  camera::CipvInitOptions cipv_init_options_;
+  std::string cipv_name_;
+
   // variables for visualization
   camera::Visualizer visualize_;
   bool write_visual_img_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="cf4f346fc3e10136d179372addd7516fbd9c5f58" author="foreverhza">
		<msg>Drivers:fix  a potential null pointer problem</msg>
		<modified_files>
			<file old_path="modules\drivers\lidar\lidar_driver_component.cc" new_path="modules\drivers\lidar\lidar_driver_component.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -31,7 +31,7 @@ bool LidarDriverComponent::Init() {
   AINFO &lt;&lt; "conf:" &lt;&lt; conf_.DebugString();
   LidarDriverFactory::Instance()-&gt;RegisterLidarClients();
   driver_ = LidarDriverFactory::Instance()-&gt;CreateLidarDriver(node_, conf_);
-  if (!driver_-&gt;Init()) {
+  if (driver_ == nullptr || !driver_-&gt;Init()) {
     AERROR &lt;&lt; "driver init error";
     return false;
   }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="69c53e76e180c4546dab871dab61cca4ad0e6b8c" author="SeasoulChris">
		<msg>Velodyne: fix a bug: base_time couldn't update on the hour (#13920) (#13924)</msg>
		<modified_files>
			<file old_path="modules\drivers\lidar\velodyne\driver\driver.cc" new_path="modules\drivers\lidar\velodyne\driver\driver.cc" added_lines="1" deleted_lines="2">
				<diff>@@ -216,8 +216,7 @@ void VelodyneDriver::UpdateGpsTopHour(uint32_t current_time) {
     return;
   }
   if (last_gps_time_ &gt; current_time) {
-    int32_t time_diff = static_cast&lt;int32_t&gt;(last_gps_time_ - current_time);
-    if (time_diff &gt; 3599000000) {
+    if ((last_gps_time_ - current_time) &gt; 3599000000) {
       basetime_ += static_cast&lt;uint64_t&gt;(3600 * 1e6);
       AINFO &lt;&lt; "Base time plus 3600s. Model: " &lt;&lt; config_.model() &lt;&lt; std::fixed
             &lt;&lt; ". current:" &lt;&lt; current_time &lt;&lt; ", last time:" &lt;&lt; last_gps_time_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6c09ac670d4c798da31bc1f1e127823fba1d45bb" author="haina0421">
		<msg>Add base_cipv interface and re-write inheritance</msg>
		<modified_files>
			<file old_path="modules\perception\camera\app\cipv_camera.cc" new_path="modules\perception\camera\app\cipv_camera.cc" added_lines="34" deleted_lines="20">
				<diff>@@ -25,37 +25,31 @@
 
 namespace apollo {
 namespace perception {
-
-Cipv::Cipv() {}
-
-Cipv::~Cipv() {}
+namespace camera{
 
 bool Cipv::Init(const Eigen::Matrix3d &amp;homography_im2car,
-                const float min_laneline_length_for_cipv,
-                const float average_lane_width_in_meter,
-                const float max_vehicle_width_in_meter,
-                const float average_frame_rate, const bool image_based_cipv,
-                const int debug_devel) {
-  b_image_based_cipv_ = image_based_cipv;
+                const CipvInitOptions &amp;options) {
+  b_image_based_cipv_ = options.image_based_cipv;
   debug_level_ =
-      debug_devel;  // 0: no debug message
+      options.debug_level;  
+                    // 0: no debug message
                     // 1: minimal output
                     // 2: some important output
                     // 3: verbose message
                     // 4: visualization
                     // 5: all
                     // -x: specific debugging, where x is the specific number
-  time_unit_ = average_frame_rate;
+  time_unit_ = options.average_frame_rate;
   homography_im2car_ = homography_im2car;
   homography_car2im_ = homography_im2car.inverse();
 
-  min_laneline_length_for_cipv_ = min_laneline_length_for_cipv;
-  average_lane_width_in_meter_ = average_lane_width_in_meter;
-  max_vehicle_width_in_meter_ = max_vehicle_width_in_meter;
+  min_laneline_length_for_cipv_ = options.min_laneline_length_for_cipv;
+  average_lane_width_in_meter_ = options.average_lane_width_in_meter;
+  max_vehicle_width_in_meter_ = options.max_vehicle_width_in_meter;
   margin_vehicle_to_lane_ =
-      (average_lane_width_in_meter - max_vehicle_width_in_meter) * 0.5f;
-  single_virtual_egolane_width_in_meter_ = max_vehicle_width_in_meter;
-  half_vehicle_width_in_meter_ = max_vehicle_width_in_meter * 0.5f;
+      (average_lane_width_in_meter_ - max_vehicle_width_in_meter_) * 0.5f;
+  single_virtual_egolane_width_in_meter_ = max_vehicle_width_in_meter_;
+  half_vehicle_width_in_meter_ = max_vehicle_width_in_meter_ * 0.5f;
   half_virtual_egolane_width_in_meter_ =
       single_virtual_egolane_width_in_meter_ * 0.5f;
   old_cipv_track_id_ = -2;
@@ -63,13 +57,30 @@ bool Cipv::Init(const Eigen::Matrix3d &amp;homography_im2car,
   return true;
 }
 
+bool Cipv::Process(CameraFrame *frame,
+               const CipvOptions &amp;options,
+               const Eigen::Affine3d &amp;world2camera,
+               const base::MotionBufferPtr &amp;motion_buffer){
+
+  DetermineCipv(frame-&gt;lane_objects, options, world2camera,
+                          &amp;frame-&gt;tracked_objects);
+
+  // Get Drop points
+  if (motion_buffer-&gt;size() &gt; 0) {
+  CollectDrops(motion_buffer, world2camera, &amp;frame-&gt;tracked_objects);
+  } else {
+    AWARN &lt;&lt; "motion_buffer is empty";
+  }
+  return true;
+}
+
 // Distance from a point to a line segment
 bool Cipv::DistanceFromPointToLineSegment(const Point2Df &amp;point,
                                           const Point2Df &amp;line_seg_start_point,
                                           const Point2Df &amp;line_seg_end_point,
                                           float *distance) {
-  common::math::Vec2d p = {point(0), point(1)};
-  common::math::LineSegment2d line_seg(
+  apollo::common::math::Vec2d p = {point(0), point(1)};
+  apollo::common::math::LineSegment2d line_seg(
       {line_seg_start_point(0), line_seg_start_point(1)},
       {line_seg_end_point(0), line_seg_end_point(1)});
   if (line_seg.length_sqr() &lt;= kFloatEpsilon) {
@@ -1108,5 +1119,8 @@ std::string Cipv::Name() const { return "Cipv"; }
 // Register plugin.
 // REGISTER_CIPV(Cipv);
 
+PERCEPTION_REGISTER_CIPV(Cipv);
+
+}  // namespace camera
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\camera\app\cipv_camera.h" new_path="modules\perception\camera\app\cipv_camera.h" added_lines="15" deleted_lines="21">
				<diff>@@ -31,15 +31,11 @@
 #include "modules/perception/base/lane_struct.h"
 #include "modules/perception/base/object.h"
 #include "modules/perception/camera/common/lane_object.h"
+#include "modules/perception/camera/lib/interface/base_cipv.h"
 
 namespace apollo {
 namespace perception {
-
-struct CipvOptions {
-  float velocity = 5.0f;
-  float yaw_rate = 0.0f;
-  float yaw_angle = 0.0f;
-};
+namespace camera{
 
 constexpr float kMinVelocity = 10.0f;  // in m/s
 constexpr float kMaxDistObjectToLaneInMeter = 70.0f;
@@ -53,23 +49,20 @@ static constexpr uint32_t kMaxNumVirtualLanePoint = 25;
 // TODO(All) average image frame rate should come from other header file.
 static constexpr float kAverageFrameRate = 0.05f;
 
-class Cipv {
+class Cipv : public BaseCipv {
  public:
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+  Cipv() = default;
+  ~Cipv() = default;
 
-  // Member functions
- public:
-  Cipv(void);
-  virtual ~Cipv(void);
-
-  virtual bool Init(
-      const Eigen::Matrix3d &amp;homography_im2car,
-      const float min_laneline_length_for_cipv = kMinLaneLineLengthForCIPV,
-      const float average_lane_width_in_meter = kAverageLaneWidthInMeter,
-      const float max_vehicle_width_in_meter = kMaxVehicleWidthInMeter,
-      const float average_frame_rate = kAverageFrameRate,
-      const bool image_based_cipv = false, const int debug_level = 0);
-  virtual std::string Name() const;
+  bool Init(const Eigen::Matrix3d &amp;homography_im2car,
+            const CipvInitOptions &amp;options =CipvInitOptions()) override;
+
+  bool Process(CameraFrame *frame,
+               const CipvOptions &amp;options,
+               const Eigen::Affine3d &amp;world2camera,
+               const base::MotionBufferPtr &amp;motion_buffer) override;
+
+  std::string Name() const override;
 
   // Determine CIPV among multiple objects
   bool DetermineCipv(const std::vector&lt;base::LaneLine&gt; &amp;lane_objects,
@@ -214,5 +207,6 @@ class Cipv {
   int32_t old_cipv_track_id_ = -2;
 };
 
+}  // namespace camera
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\detection_component.cc" new_path="modules\perception\onboard\component\detection_component.cc" added_lines="8" deleted_lines="11">
				<diff>@@ -39,6 +39,7 @@ bool DetectionComponent::Init() {
   ADEBUG &lt;&lt; "Lidar Component Configs: " &lt;&lt; comp_config.DebugString();
   output_channel_name_ = comp_config.output_channel_name();
   sensor_name_ = comp_config.sensor_name();
+  detector_name_ = comp_config.detector_name();
   lidar2novatel_tf2_child_frame_id_ =
       comp_config.lidar2novatel_tf2_child_frame_id();
   lidar_query_tf_offset_ =
@@ -74,21 +75,17 @@ bool DetectionComponent::InitAlgorithmPlugin() {
   ACHECK(common::SensorManager::Instance()-&gt;GetSensorInfo(sensor_name_,
                                                           &amp;sensor_info_));
 
-  detector_.reset(new lidar::LidarObstacleDetection);
-  if (detector_ == nullptr) {
-    AERROR &lt;&lt; "sensor_name_ "
-           &lt;&lt; "Failed to get detection instance";
-    return false;
-  }
+  lidar::BaseLidarObstacleDetection* detector =
+      lidar::BaseLidarObstacleDetectionRegisterer::
+      GetInstanceByName(detector_name_);
+  CHECK_NOTNULL(detector);
+  detector_.reset(detector);
   lidar::LidarObstacleDetectionInitOptions init_options;
   init_options.sensor_name = sensor_name_;
   init_options.enable_hdmap_input =
       FLAGS_obs_enable_hdmap_input &amp;&amp; enable_hdmap_;
-  if (!detector_-&gt;Init(init_options)) {
-    AINFO &lt;&lt; "sensor_name_ "
-          &lt;&lt; "Failed to init detection.";
-    return false;
-  }
+  ACHECK(detector_-&gt;Init(init_options)) &lt;&lt;
+                            "lidar obstacle detection init error";
 
   lidar2world_trans_.Init(lidar2novatel_tf2_child_frame_id_);
   return true;
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\detection_component.h" new_path="modules\perception\onboard\component\detection_component.h" added_lines="1" deleted_lines="0">
				<diff>@@ -48,6 +48,7 @@ class DetectionComponent : public cyber::Component&lt;drivers::PointCloud&gt; {
  private:
   static std::atomic&lt;uint32_t&gt; seq_num_;
   std::string sensor_name_;
+  std::string detector_name_;
   bool enable_hdmap_ = true;
   float lidar_query_tf_offset_ = 20.0f;
   std::string lidar2novatel_tf2_child_frame_id_;
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_camera_detection_component.cc" new_path="modules\perception\onboard\component\fusion_camera_detection_component.cc" added_lines="17" deleted_lines="19">
				<diff>@@ -248,9 +248,12 @@ bool FusionCameraDetectionComponent::Init() {
   camera_obstacle_pipeline_-&gt;SetIm2CarHomography(homography_im2car_);
 
   if (enable_cipv_) {
-    cipv_.Init(homography_im2car_, min_laneline_length_for_cipv_,
-               average_lane_width_in_meter_, max_vehicle_width_in_meter_,
-               average_frame_rate_, image_based_cipv_, debug_level_);
+    camera::BaseCipv* cipv = camera::BaseCipvRegisterer::
+        GetInstanceByName(cipv_name_);
+    CHECK_NOTNULL(cipv);
+    cipv_.reset(cipv);
+    ACHECK(cipv_-&gt;Init(homography_im2car_, cipv_init_options_))
+               &lt;&lt; "camera cipv init error";
   }
 
   if (enable_visualization_) {
@@ -393,21 +396,23 @@ int FusionCameraDetectionComponent::InitConfig() {
   ts_diff_ = fusion_camera_detection_param.ts_diff();
   write_visual_img_ = fusion_camera_detection_param.write_visual_img();
 
-  min_laneline_length_for_cipv_ = static_cast&lt;float&gt;(
+  cipv_init_options_.min_laneline_length_for_cipv = static_cast&lt;float&gt;(
       fusion_camera_detection_param.min_laneline_length_for_cipv());
-  average_lane_width_in_meter_ = static_cast&lt;float&gt;(
+  cipv_init_options_.average_lane_width_in_meter = static_cast&lt;float&gt;(
       fusion_camera_detection_param.average_lane_width_in_meter());
-  max_vehicle_width_in_meter_ = static_cast&lt;float&gt;(
+  cipv_init_options_.max_vehicle_width_in_meter = static_cast&lt;float&gt;(
       fusion_camera_detection_param.max_vehicle_width_in_meter());
-  average_frame_rate_ =
+  cipv_init_options_.average_frame_rate =
       static_cast&lt;float&gt;(fusion_camera_detection_param.average_frame_rate());
 
-  image_based_cipv_ =
+  cipv_init_options_.image_based_cipv =
       static_cast&lt;float&gt;(fusion_camera_detection_param.image_based_cipv());
 
-  debug_level_ = static_cast&lt;int&gt;(fusion_camera_detection_param.debug_level());
+  cipv_init_options_.debug_level = static_cast&lt;int&gt;(fusion_camera_detection_param.debug_level());
   enable_cipv_ = fusion_camera_detection_param.enable_cipv();
 
+  cipv_name_ = fusion_camera_detection_param.cipv();
+
   std::string format_str = R"(
       FusionCameraDetectionComponent InitConfig success
       camera_names:    %s, %s
@@ -496,6 +501,7 @@ int FusionCameraDetectionComponent::InitAlgorithmPlugin() {
   }
   AINFO &lt;&lt; "camera_obstacle_pipeline_-&gt;Init() succeed";
   return cyber::SUCC;
+
 }
 
 int FusionCameraDetectionComponent::InitCameraFrames() {
@@ -767,7 +773,7 @@ int FusionCameraDetectionComponent::InternalProc(
 
   //  Determine CIPV
   if (enable_cipv_) {
-    CipvOptions cipv_options;
+    camera::CipvOptions cipv_options;
     if (motion_buffer_ != nullptr) {
       if (motion_buffer_-&gt;size() == 0) {
         AWARN &lt;&lt; "motion_buffer_ is empty";
@@ -779,16 +785,8 @@ int FusionCameraDetectionComponent::InternalProc(
       }
       ADEBUG &lt;&lt; "[CIPV] velocity " &lt;&lt; cipv_options.velocity
              &lt;&lt; ", yaw rate: " &lt;&lt; cipv_options.yaw_rate;
-      cipv_.DetermineCipv(camera_frame.lane_objects, cipv_options, world2camera,
-                          &amp;camera_frame.tracked_objects);
 
-      // Get Drop points
-      if (motion_buffer_-&gt;size() &gt; 0) {
-        cipv_.CollectDrops(motion_buffer_, world2camera,
-                           &amp;camera_frame.tracked_objects);
-      } else {
-        AWARN &lt;&lt; "motion_buffer is empty";
-      }
+      cipv_-&gt;Process(&amp;camera_frame, cipv_options, world2camera, motion_buffer_);
     }
   }
 
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_camera_detection_component.h" new_path="modules\perception\onboard\component\fusion_camera_detection_component.h" added_lines="4" deleted_lines="7">
				<diff>@@ -202,13 +202,10 @@ class FusionCameraDetectionComponent : public apollo::cyber::Component&lt;&gt; {
 
   // // variables for CIPV
   bool enable_cipv_ = false;
-  Cipv cipv_;
-  float min_laneline_length_for_cipv_ = kMinLaneLineLengthForCIPV;
-  float average_lane_width_in_meter_ = kAverageLaneWidthInMeter;
-  float max_vehicle_width_in_meter_ = kMaxVehicleWidthInMeter;
-  float average_frame_rate_ = kAverageFrameRate;
-  bool image_based_cipv_ = false;
-  int debug_level_ = 0;
+  std::unique_ptr&lt;camera::BaseCipv&gt; cipv_;
+  camera::CipvInitOptions cipv_init_options_;
+  std::string cipv_name_;
+
   // variables for visualization
   camera::Visualizer visualize_;
   bool write_visual_img_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="897be08002c35a68e96c375a48a8179bc85a9507" author="haina0421">
		<msg>Add base TL Preprocessor and update inheritance</msg>
		<modified_files>
			<file old_path="modules\perception\camera\lib\traffic_light\preprocessor\tl_preprocessor.cc" new_path="modules\perception\camera\lib\traffic_light\preprocessor\tl_preprocessor.cc" added_lines="2" deleted_lines="0">
				<diff>@@ -352,6 +352,8 @@ std::string TLPreprocessor::GetMaxFocalLenWorkingCameraName() const {
   return "";
 }
 
+PERCEPTION_REGISTER_TLPREPROCESSOR(TLPreprocessor);
+
 }  // namespace camera
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\traffic_light\preprocessor\tl_preprocessor.h" new_path="modules\perception\camera\lib\traffic_light\preprocessor\tl_preprocessor.h" added_lines="9" deleted_lines="18">
				<diff>@@ -29,45 +29,36 @@
 
 #include "modules/perception/camera/common/camera_frame.h"
 #include "modules/perception/camera/lib/interface/base_init_options.h"
+#include "modules/perception/camera/lib/interface/base_tl_preprocessor.h"
 
 namespace apollo {
 namespace perception {
 namespace camera {
 
-struct TrafficLightPreprocessorInitOptions : public BaseInitOptions {
-  int gpu_id = 0;
-  float sync_interval_seconds;
-  std::vector&lt;std::string&gt; camera_names;
-};
-
-struct TLPreprocessorOption {
-  std::map&lt;std::string, int&gt;* image_borders_size = nullptr;
-};
-
-class TLPreprocessor {
+class TLPreprocessor : public BaseTLPreprocessor {
  public:
   TLPreprocessor() = default;
   ~TLPreprocessor() = default;
 
-  bool Init(const TrafficLightPreprocessorInitOptions&amp; options);
+  bool Init(const TrafficLightPreprocessorInitOptions&amp; options) override;
 
-  std::string Name() const;
+  std::string Name() const override;
 
   bool UpdateCameraSelection(const CarPose&amp; pose,
                              const TLPreprocessorOption&amp; option,
-                             std::vector&lt;base::TrafficLightPtr&gt;* lights);
+                             std::vector&lt;base::TrafficLightPtr&gt;* lights) override;
 
   bool SyncInformation(const double ts, const std::string&amp; camera_name);
   bool UpdateLightsProjection(const CarPose&amp; pose,
                               const TLPreprocessorOption&amp; option,
                               const std::string&amp; camera_name,
-                              std::vector&lt;base::TrafficLightPtr&gt;* lights);
+                              std::vector&lt;base::TrafficLightPtr&gt;* lights) override;
 
-  bool SetCameraWorkingFlag(const std::string&amp; camera_name, bool is_working);
+  bool SetCameraWorkingFlag(const std::string&amp; camera_name, bool is_working) override;
   bool GetCameraWorkingFlag(const std::string&amp; camera_name,
-                            bool* is_working) const;
+                            bool* is_working) const override;
 
-  const std::vector&lt;std::string&gt;&amp; GetCameraNamesByDescendingFocalLen() const {
+  const std::vector&lt;std::string&gt;&amp; GetCameraNamesByDescendingFocalLen() const override {
     return projection_.getCameraNamesByDescendingFocalLen();
   }
   bool GetAlllightsOutsideFlag() const;
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\trafficlights_perception_component.cc" new_path="modules\perception\onboard\component\trafficlights_perception_component.cc" added_lines="6" deleted_lines="5">
				<diff>@@ -163,6 +163,8 @@ int TrafficLightsPerceptionComponent::InitConfig() {
       traffic_light_param.image_sys_ts_diff_threshold();
   preprocessor_init_options_.sync_interval_seconds =
       static_cast&lt;float&gt;(traffic_light_param.sync_interval_seconds());
+  tl_preprocessor_name_ = traffic_light_param.tl_preprocessor_name();
+  
   camera_perception_init_options_.root_dir =
       traffic_light_param.camera_traffic_light_perception_conf_dir();
   camera_perception_init_options_.conf_file =
@@ -184,11 +186,10 @@ int TrafficLightsPerceptionComponent::InitConfig() {
 
 int TrafficLightsPerceptionComponent::InitAlgorithmPlugin() {
   // init preprocessor
-  preprocessor_.reset(new camera::TLPreprocessor);
-  if (!preprocessor_) {
-    AERROR &lt;&lt; "TrafficLightsPerceptionComponent new preprocessor failed";
-    return cyber::FAIL;
-  }
+  camera::BaseTLPreprocessor* preprocessor = camera::BaseTLPreprocessorRegisterer::
+        GetInstanceByName(tl_preprocessor_name_);
+  CHECK_NOTNULL(preprocessor);
+  preprocessor_.reset(preprocessor);
 
   preprocessor_init_options_.camera_names = camera_names_;
   if (!preprocessor_-&gt;Init(preprocessor_init_options_)) {
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\trafficlights_perception_component.h" new_path="modules\perception\onboard\component\trafficlights_perception_component.h" added_lines="2" deleted_lines="1">
				<diff>@@ -111,10 +111,11 @@ class TrafficLightsPerceptionComponent : public apollo::cyber::Component&lt;&gt; {
  private:
   std::mutex mutex_;
 
-  std::shared_ptr&lt;camera::TLPreprocessor&gt; preprocessor_;
+  std::shared_ptr&lt;camera::BaseTLPreprocessor&gt; preprocessor_;
   apollo::perception::map::HDMapInput* hd_map_ = nullptr;
 
   camera::TrafficLightPreprocessorInitOptions preprocessor_init_options_;
+  std::string tl_preprocessor_name_;
 
   std::string tf2_frame_id_;
   std::string tf2_child_frame_id_;
</diff>
			</file>
			<file old_path="modules\perception\production\conf\perception\camera\trafficlights_perception_component.config" new_path="modules\perception\production\conf\perception\camera\trafficlights_perception_component.config" added_lines="1" deleted_lines="0">
				<diff>@@ -19,3 +19,4 @@ simulation_channel_name : "/perception/traffic_light_simulation"
 v2x_trafficlights_input_channel_name : "/apollo/v2x/traffic_light"
 v2x_sync_interval_seconds : 0.1
 max_v2x_msg_buff_size : 50
+tl_preprocessor_name : "TLPreprocessor"
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="330616af6e7ad52b7e3f2e4ed186e4cc690d4536" author="haina0421">
		<msg>DreamLand Debug</msg>
		<modified_files>
			<file old_path="modules\perception\camera\lib\traffic_light\preprocessor\tl_preprocessor.h" new_path="modules\perception\camera\lib\traffic_light\preprocessor\tl_preprocessor.h" added_lines="1" deleted_lines="0">
				<diff>@@ -30,6 +30,7 @@
 #include "modules/perception/camera/common/camera_frame.h"
 #include "modules/perception/camera/lib/interface/base_init_options.h"
 #include "modules/perception/camera/lib/interface/base_tl_preprocessor.h"
+#include "modules/perception/lib/registerer/registerer.h"
 
 namespace apollo {
 namespace perception {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3ba26c7434a14ad880fa04b9ab4e3b31d9f283ad" author="haina0421">
		<msg>Add base_multisensor_fusion and update inheritance</msg>
		<modified_files>
			<file old_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.cc" new_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.cc" added_lines="5" deleted_lines="1">
				<diff>@@ -25,7 +25,9 @@ bool ObstacleMultiSensorFusion::Init(
     AINFO &lt;&lt; "Already inited";
     return true;
   }
-  fusion_ = BaseFusionSystemRegisterer::GetInstanceByName(param.fusion_method);
+  BaseFusionSystem* fusion = 
+          BaseFusionSystemRegisterer::GetInstanceByName(param.fusion_method);
+  fusion_.reset(fusion);
 
   FusionInitOptions init_options;
   init_options.main_sensors = param.main_sensors;
@@ -42,6 +44,8 @@ bool ObstacleMultiSensorFusion::Process(const base::FrameConstPtr&amp; frame,
   return fusion_-&gt;Fuse(options, frame, objects);
 }
 
+PERCEPTION_REGISTER_MULTISENSORFUSION(ObstacleMultiSensorFusion);
+
 }  // namespace fusion
 }  // namespace perception
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.h" new_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.h" added_lines="8" deleted_lines="13">
				<diff>@@ -18,32 +18,27 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
+#include "modules/perception/fusion/lib/interface/base_multisensor_fusion.h"
 #include "modules/perception/fusion/lib/interface/base_fusion_system.h"
 
 namespace apollo {
 namespace perception {
 namespace fusion {
 
-struct ObstacleMultiSensorFusionParam {
-  std::vector&lt;std::string&gt; main_sensors;
-  std::string fusion_method;
-};
-
-class ObstacleMultiSensorFusion {
+class ObstacleMultiSensorFusion : public BaseMultiSensorFusion {
  public:
   ObstacleMultiSensorFusion() = default;
   ~ObstacleMultiSensorFusion() = default;
-  ObstacleMultiSensorFusion(const ObstacleMultiSensorFusion&amp;) = delete;
-  ObstacleMultiSensorFusion&amp; operator=(const ObstacleMultiSensorFusion&amp;) =
-      delete;
-  bool Init(const ObstacleMultiSensorFusionParam&amp; param);
+
+  bool Init(const ObstacleMultiSensorFusionParam&amp; param) override;
+
   bool Process(const base::FrameConstPtr&amp; frame,
-               std::vector&lt;base::ObjectPtr&gt;* objects);
+               std::vector&lt;base::ObjectPtr&gt;* objects) override;
 
-  std::string Name() const { return "ObstacleMultiSensorFusion"; }
+  std::string Name() const override { return "ObstacleMultiSensorFusion"; }
 
  protected:
-  BaseFusionSystem* fusion_ = nullptr;
+  std::unique_ptr&lt;BaseFusionSystem&gt; fusion_;
 };
 
 }  // namespace fusion
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_component.cc" new_path="modules\perception\onboard\component\fusion_component.cc" added_lines="5" deleted_lines="1">
				<diff>@@ -36,6 +36,7 @@ bool FusionComponent::Init() {
   AINFO &lt;&lt; "Fusion Component Configs: " &lt;&lt; comp_config.DebugString();
 
   // to load component configs
+  fusion_name_ = comp_config.fusion_name();
   fusion_method_ = comp_config.fusion_method();
   for (int i = 0; i &lt; comp_config.fusion_main_sensors_size(); ++i) {
     fusion_main_sensors_.push_back(comp_config.fusion_main_sensors(i));
@@ -83,7 +84,10 @@ bool FusionComponent::Proc(const std::shared_ptr&lt;SensorFrameMessage&gt;&amp; message) {
 }
 
 bool FusionComponent::InitAlgorithmPlugin() {
-  fusion_.reset(new fusion::ObstacleMultiSensorFusion());
+  fusion::BaseMultiSensorFusion* fusion =
+    fusion::BaseMultiSensorFusionRegisterer::GetInstanceByName(fusion_name_);
+  CHECK_NOTNULL(fusion);
+  fusion_.reset(fusion);
   fusion::ObstacleMultiSensorFusionParam param;
   param.main_sensors = fusion_main_sensors_;
   param.fusion_method = fusion_method_;
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_component.h" new_path="modules\perception\onboard\component\fusion_component.h" added_lines="2" deleted_lines="1">
				<diff>@@ -48,12 +48,13 @@ class FusionComponent : public cyber::Component&lt;SensorFrameMessage&gt; {
   static std::mutex s_mutex_;
   static uint32_t s_seq_num_;
 
+  std::string fusion_name_;
   std::string fusion_method_;
   std::vector&lt;std::string&gt; fusion_main_sensors_;
   bool object_in_roi_check_ = false;
   double radius_for_roi_object_check_ = 0;
 
-  std::unique_ptr&lt;fusion::ObstacleMultiSensorFusion&gt; fusion_;
+  std::unique_ptr&lt;fusion::BaseMultiSensorFusion&gt; fusion_;
   map::HDMapInput* hdmap_input_ = nullptr;
   std::shared_ptr&lt;apollo::cyber::Writer&lt;PerceptionObstacles&gt;&gt; writer_;
   std::shared_ptr&lt;apollo::cyber::Writer&lt;SensorFrameMessage&gt;&gt; inner_writer_;
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\trafficlights_perception_component.cc" new_path="modules\perception\onboard\component\trafficlights_perception_component.cc" added_lines="0" deleted_lines="3">
				<diff>@@ -188,9 +188,6 @@ int TrafficLightsPerceptionComponent::InitAlgorithmPlugin() {
   // init preprocessor
   camera::BaseTLPreprocessor* preprocessor = camera::BaseTLPreprocessorRegisterer::
         GetInstanceByName(tl_preprocessor_name_);
-  std::vector&lt;camera::BaseTLPreprocessor*&gt; vec = camera::BaseTLPreprocessorRegisterer::
-        GetAllInstances();
-  std::cout &lt;&lt; "Size of TLPreprocessor Map: " &lt;&lt; vec.size() &lt;&lt; std::endl;
   CHECK_NOTNULL(preprocessor);
   preprocessor_.reset(preprocessor);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3bd2bce81748f761e3cc5fc4eaf603b08e20c027" author="haina0421">
		<msg>BugFixed Fusion undefined symbol</msg>
		<modified_files>
			<file old_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.h" new_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.h" added_lines="2" deleted_lines="1">
				<diff>@@ -15,6 +15,7 @@
  *****************************************************************************/
 #pragma once
 
+#include &lt;memory&gt;
 #include &lt;string&gt;
 #include &lt;vector&gt;
 
@@ -28,7 +29,7 @@ namespace fusion {
 class ObstacleMultiSensorFusion : public BaseMultiSensorFusion {
  public:
   ObstacleMultiSensorFusion() = default;
-  ~ObstacleMultiSensorFusion() = default;
+  virtual ~ObstacleMultiSensorFusion() = default;
 
   bool Init(const ObstacleMultiSensorFusionParam&amp; param) override;
 
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\interface\base_multisensor_fusion.h" new_path="modules\perception\fusion\lib\interface\base_multisensor_fusion.h" added_lines="2" deleted_lines="2">
				<diff>@@ -38,10 +38,10 @@ class BaseMultiSensorFusion {
   BaseMultiSensorFusion() = default;
   virtual ~BaseMultiSensorFusion() = default;
 
-  virtual bool Init(const ObstacleMultiSensorFusionParam&amp; param);
+  virtual bool Init(const ObstacleMultiSensorFusionParam&amp; param) = 0;
 
   virtual bool Process(const base::FrameConstPtr&amp; frame,
-               std::vector&lt;base::ObjectPtr&gt;* objects);
+               std::vector&lt;base::ObjectPtr&gt;* objects) = 0;
 
   virtual std::string Name() const = 0;
 
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_component.h" new_path="modules\perception\onboard\component\fusion_component.h" added_lines="1" deleted_lines="1">
				<diff>@@ -21,7 +21,7 @@
 
 #include "cyber/component/component.h"
 #include "modules/perception/base/object.h"
-#include "modules/perception/fusion/app/obstacle_multi_sensor_fusion.h"
+#include "modules/perception/fusion/lib/interface/base_multisensor_fusion.h"
 #include "modules/perception/fusion/lib/interface/base_fusion_system.h"
 #include "modules/perception/map/hdmap/hdmap_input.h"
 #include "modules/perception/onboard/inner_component_messages/inner_component_messages.h"
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b5ed489d5c2327a58d707a5ed34513a5ddb8d9ca" author="haina0421">
		<msg>Solve CI issues</msg>
		<modified_files>
			<file old_path="modules\perception\camera\app\cipv_camera.cc" new_path="modules\perception\camera\app\cipv_camera.cc" added_lines="3" deleted_lines="4">
				<diff>@@ -25,13 +25,13 @@
 
 namespace apollo {
 namespace perception {
-namespace camera{
+namespace camera {
 
 bool Cipv::Init(const Eigen::Matrix3d &amp;homography_im2car,
                 const CipvInitOptions &amp;options) {
   b_image_based_cipv_ = options.image_based_cipv;
   debug_level_ =
-      options.debug_level;  
+      options.debug_level;
                     // 0: no debug message
                     // 1: minimal output
                     // 2: some important output
@@ -60,8 +60,7 @@ bool Cipv::Init(const Eigen::Matrix3d &amp;homography_im2car,
 bool Cipv::Process(CameraFrame *frame,
                const CipvOptions &amp;options,
                const Eigen::Affine3d &amp;world2camera,
-               const base::MotionBufferPtr &amp;motion_buffer){
-
+               const base::MotionBufferPtr &amp;motion_buffer) {
   DetermineCipv(frame-&gt;lane_objects, options, world2camera,
                           &amp;frame-&gt;tracked_objects);
 
</diff>
			</file>
			<file old_path="modules\perception\camera\app\cipv_camera.h" new_path="modules\perception\camera\app\cipv_camera.h" added_lines="2" deleted_lines="2">
				<diff>@@ -35,7 +35,7 @@
 
 namespace apollo {
 namespace perception {
-namespace camera{
+namespace camera {
 
 constexpr float kMinVelocity = 10.0f;  // in m/s
 constexpr float kMaxDistObjectToLaneInMeter = 70.0f;
@@ -55,7 +55,7 @@ class Cipv : public BaseCipv {
   ~Cipv() = default;
 
   bool Init(const Eigen::Matrix3d &amp;homography_im2car,
-            const CipvInitOptions &amp;options =CipvInitOptions()) override;
+            const CipvInitOptions &amp;options = CipvInitOptions()) override;
 
   bool Process(CameraFrame *frame,
                const CipvOptions &amp;options,
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\interface\base_cipv.h" new_path="modules\perception\camera\lib\interface\base_cipv.h" added_lines="2" deleted_lines="2">
				<diff>@@ -30,7 +30,7 @@
 
 namespace apollo {
 namespace perception {
-namespace camera{
+namespace camera {
 
 struct CipvInitOptions : public BaseInitOptions {
   float min_laneline_length_for_cipv = 2.0f;
@@ -57,7 +57,7 @@ class BaseCipv {
   virtual ~BaseCipv() = default;
 
   virtual bool Init(const Eigen::Matrix3d &amp;homography_im2car,
-      const CipvInitOptions &amp;options =CipvInitOptions()) = 0;
+      const CipvInitOptions &amp;options = CipvInitOptions()) = 0;
 
   virtual bool Process(CameraFrame *frame,
                     const CipvOptions &amp;options,
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\interface\base_tl_preprocessor.h" new_path="modules\perception\camera\lib\interface\base_tl_preprocessor.h" added_lines="3" deleted_lines="2">
				<diff>@@ -66,9 +66,10 @@ class BaseTLPreprocessor {
   virtual bool GetCameraWorkingFlag(const std::string&amp; camera_name,
                             bool* is_working) const = 0;
 
-  virtual const std::vector&lt;std::string&gt;&amp; GetCameraNamesByDescendingFocalLen() const = 0;
+  virtual const std::vector&lt;std::string&gt;&amp;
+                GetCameraNamesByDescendingFocalLen() const = 0;
 
-  private:
+ private:
   DISALLOW_COPY_AND_ASSIGN(BaseTLPreprocessor);
 };
 
</diff>
			</file>
			<file old_path="modules\perception\camera\lib\traffic_light\preprocessor\tl_preprocessor.h" new_path="modules\perception\camera\lib\traffic_light\preprocessor\tl_preprocessor.h" added_lines="9" deleted_lines="7">
				<diff>@@ -46,20 +46,22 @@ class TLPreprocessor : public BaseTLPreprocessor {
   std::string Name() const override;
 
   bool UpdateCameraSelection(const CarPose&amp; pose,
-                             const TLPreprocessorOption&amp; option,
-                             std::vector&lt;base::TrafficLightPtr&gt;* lights) override;
+                    const TLPreprocessorOption&amp; option,
+                    std::vector&lt;base::TrafficLightPtr&gt;* lights) override;
 
   bool SyncInformation(const double ts, const std::string&amp; camera_name);
   bool UpdateLightsProjection(const CarPose&amp; pose,
-                              const TLPreprocessorOption&amp; option,
-                              const std::string&amp; camera_name,
-                              std::vector&lt;base::TrafficLightPtr&gt;* lights) override;
+                    const TLPreprocessorOption&amp; option,
+                    const std::string&amp; camera_name,
+                    std::vector&lt;base::TrafficLightPtr&gt;* lights) override;
 
-  bool SetCameraWorkingFlag(const std::string&amp; camera_name, bool is_working) override;
+  bool SetCameraWorkingFlag(const std::string&amp; camera_name,
+                    bool is_working) override;
   bool GetCameraWorkingFlag(const std::string&amp; camera_name,
                             bool* is_working) const override;
 
-  const std::vector&lt;std::string&gt;&amp; GetCameraNamesByDescendingFocalLen() const override {
+  const std::vector&lt;std::string&gt;&amp;
+    GetCameraNamesByDescendingFocalLen() const override {
     return projection_.getCameraNamesByDescendingFocalLen();
   }
   bool GetAlllightsOutsideFlag() const;
</diff>
			</file>
			<file old_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.cc" new_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -25,7 +25,7 @@ bool ObstacleMultiSensorFusion::Init(
     AINFO &lt;&lt; "Already inited";
     return true;
   }
-  BaseFusionSystem* fusion = 
+  BaseFusionSystem* fusion =
           BaseFusionSystemRegisterer::GetInstanceByName(param.fusion_method);
   fusion_.reset(fusion);
 
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\interface\base_multisensor_fusion.h" new_path="modules\perception\fusion\lib\interface\base_multisensor_fusion.h" added_lines="1" deleted_lines="1">
				<diff>@@ -47,7 +47,7 @@ class BaseMultiSensorFusion {
 
  private:
   DISALLOW_COPY_AND_ASSIGN(BaseMultiSensorFusion);
-}; // Class BaseMultiSensorFusion
+};  // Class BaseMultiSensorFusion
 
 PERCEPTION_REGISTER_REGISTERER(BaseMultiSensorFusion);
 #define PERCEPTION_REGISTER_MULTISENSORFUSION(name) \
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_camera_detection_component.cc" new_path="modules\perception\onboard\component\fusion_camera_detection_component.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -408,7 +408,8 @@ int FusionCameraDetectionComponent::InitConfig() {
   cipv_init_options_.image_based_cipv =
       static_cast&lt;float&gt;(fusion_camera_detection_param.image_based_cipv());
 
-  cipv_init_options_.debug_level = static_cast&lt;int&gt;(fusion_camera_detection_param.debug_level());
+  cipv_init_options_.debug_level =
+      static_cast&lt;int&gt;(fusion_camera_detection_param.debug_level());
   enable_cipv_ = fusion_camera_detection_param.enable_cipv();
 
   cipv_name_ = fusion_camera_detection_param.cipv();
@@ -501,7 +502,6 @@ int FusionCameraDetectionComponent::InitAlgorithmPlugin() {
   }
   AINFO &lt;&lt; "camera_obstacle_pipeline_-&gt;Init() succeed";
   return cyber::SUCC;
-
 }
 
 int FusionCameraDetectionComponent::InitCameraFrames() {
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\trafficlights_perception_component.cc" new_path="modules\perception\onboard\component\trafficlights_perception_component.cc" added_lines="4" deleted_lines="3">
				<diff>@@ -164,7 +164,7 @@ int TrafficLightsPerceptionComponent::InitConfig() {
   preprocessor_init_options_.sync_interval_seconds =
       static_cast&lt;float&gt;(traffic_light_param.sync_interval_seconds());
   tl_preprocessor_name_ = traffic_light_param.tl_preprocessor_name();
-  
+
   camera_perception_init_options_.root_dir =
       traffic_light_param.camera_traffic_light_perception_conf_dir();
   camera_perception_init_options_.conf_file =
@@ -186,8 +186,9 @@ int TrafficLightsPerceptionComponent::InitConfig() {
 
 int TrafficLightsPerceptionComponent::InitAlgorithmPlugin() {
   // init preprocessor
-  camera::BaseTLPreprocessor* preprocessor = camera::BaseTLPreprocessorRegisterer::
-        GetInstanceByName(tl_preprocessor_name_);
+  camera::BaseTLPreprocessor* preprocessor =
+            camera::BaseTLPreprocessorRegisterer::
+            GetInstanceByName(tl_preprocessor_name_);
   CHECK_NOTNULL(preprocessor);
   preprocessor_.reset(preprocessor);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c032c48102a4d8eb67e5cb7268d1d4332eefe47a" author="haina0421">
		<msg>Update camera_obstacle_detection_component</msg>
		<modified_files>
			<file old_path="modules\perception\onboard\component\camera_obstacle_detection_component.cc" new_path="modules\perception\onboard\component\camera_obstacle_detection_component.cc" added_lines="17" deleted_lines="19">
				<diff>@@ -248,9 +248,12 @@ bool CameraObstacleDetectionComponent::Init() {
   camera_obstacle_pipeline_-&gt;SetIm2CarHomography(homography_im2car_);
 
   if (enable_cipv_) {
-    cipv_.Init(homography_im2car_, min_laneline_length_for_cipv_,
-               average_lane_width_in_meter_, max_vehicle_width_in_meter_,
-               average_frame_rate_, image_based_cipv_, debug_level_);
+    camera::BaseCipv* cipv = camera::BaseCipvRegisterer::
+        GetInstanceByName(cipv_name_);
+    CHECK_NOTNULL(cipv);
+    cipv_.reset(cipv);
+    ACHECK(cipv_-&gt;Init(homography_im2car_, cipv_init_options_))
+               &lt;&lt; "camera cipv init error";
   }
 
   if (enable_visualization_) {
@@ -393,21 +396,24 @@ int CameraObstacleDetectionComponent::InitConfig() {
   ts_diff_ = fusion_camera_detection_param.ts_diff();
   write_visual_img_ = fusion_camera_detection_param.write_visual_img();
 
-  min_laneline_length_for_cipv_ = static_cast&lt;float&gt;(
+  cipv_init_options_.min_laneline_length_for_cipv = static_cast&lt;float&gt;(
       fusion_camera_detection_param.min_laneline_length_for_cipv());
-  average_lane_width_in_meter_ = static_cast&lt;float&gt;(
+  cipv_init_options_.average_lane_width_in_meter = static_cast&lt;float&gt;(
       fusion_camera_detection_param.average_lane_width_in_meter());
-  max_vehicle_width_in_meter_ = static_cast&lt;float&gt;(
+  cipv_init_options_.max_vehicle_width_in_meter = static_cast&lt;float&gt;(
       fusion_camera_detection_param.max_vehicle_width_in_meter());
-  average_frame_rate_ =
+  cipv_init_options_.average_frame_rate =
       static_cast&lt;float&gt;(fusion_camera_detection_param.average_frame_rate());
 
-  image_based_cipv_ =
+  cipv_init_options_.image_based_cipv =
       static_cast&lt;float&gt;(fusion_camera_detection_param.image_based_cipv());
 
-  debug_level_ = static_cast&lt;int&gt;(fusion_camera_detection_param.debug_level());
+  cipv_init_options_.debug_level =
+      static_cast&lt;int&gt;(fusion_camera_detection_param.debug_level());
   enable_cipv_ = fusion_camera_detection_param.enable_cipv();
 
+  cipv_name_ = fusion_camera_detection_param.cipv();
+
   std::string format_str = R"(
       CameraObstacleDetectionComponent InitConfig success
       camera_names:    %s, %s
@@ -762,7 +768,7 @@ int CameraObstacleDetectionComponent::InternalProc(
 
   //  Determine CIPV
   if (enable_cipv_) {
-    CipvOptions cipv_options;
+    camera::CipvOptions cipv_options;
     if (motion_buffer_ != nullptr) {
       if (motion_buffer_-&gt;size() == 0) {
         AWARN &lt;&lt; "motion_buffer_ is empty";
@@ -774,16 +780,8 @@ int CameraObstacleDetectionComponent::InternalProc(
       }
       ADEBUG &lt;&lt; "[CIPV] velocity " &lt;&lt; cipv_options.velocity
              &lt;&lt; ", yaw rate: " &lt;&lt; cipv_options.yaw_rate;
-      cipv_.DetermineCipv(camera_frame.lane_objects, cipv_options, world2camera,
-                          &amp;camera_frame.tracked_objects);
 
-      // Get Drop points
-      if (motion_buffer_-&gt;size() &gt; 0) {
-        cipv_.CollectDrops(motion_buffer_, world2camera,
-                           &amp;camera_frame.tracked_objects);
-      } else {
-        AWARN &lt;&lt; "motion_buffer is empty";
-      }
+      cipv_-&gt;Process(&amp;camera_frame, cipv_options, world2camera, motion_buffer_);
     }
   }
 
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\camera_obstacle_detection_component.h" new_path="modules\perception\onboard\component\camera_obstacle_detection_component.h" added_lines="4" deleted_lines="7">
				<diff>@@ -203,13 +203,10 @@ class CameraObstacleDetectionComponent : public apollo::cyber::Component&lt;&gt; {
 
   // // variables for CIPV
   bool enable_cipv_ = false;
-  Cipv cipv_;
-  float min_laneline_length_for_cipv_ = kMinLaneLineLengthForCIPV;
-  float average_lane_width_in_meter_ = kAverageLaneWidthInMeter;
-  float max_vehicle_width_in_meter_ = kMaxVehicleWidthInMeter;
-  float average_frame_rate_ = kAverageFrameRate;
-  bool image_based_cipv_ = false;
-  int debug_level_ = 0;
+  std::unique_ptr&lt;camera::BaseCipv&gt; cipv_;
+  camera::CipvInitOptions cipv_init_options_;
+  std::string cipv_name_;
+
   // variables for visualization
   camera::Visualizer visualize_;
   bool write_visual_img_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ac8cb200899af38e1f510c518dc038421fc4c6a6" author="jiangjianan">
		<msg>Prediction: merge vectornet and interaction model into master</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_service.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_service.cc" added_lines="6" deleted_lines="0">
				<diff>@@ -70,6 +70,7 @@ using apollo::planning::ADCTrajectory;
 using apollo::planning::DecisionResult;
 using apollo::planning::StopReasonCode;
 using apollo::planning_internal::PlanningData;
+using apollo::prediction::ObstacleInteractiveTag;
 using apollo::prediction::ObstaclePriority;
 using apollo::prediction::PredictionObstacle;
 using apollo::prediction::PredictionObstacles;
@@ -1144,6 +1145,11 @@ void SimulationWorldService::UpdateSimulationWorld(
       world_obj.mutable_obstacle_priority()-&gt;CopyFrom(obstacle.priority());
     }
 
+    // Add prediction interactive tag
+    if (obstacle.has_interactive_tag()) {
+      world_obj.mutable_interactive_tag()-&gt;CopyFrom(obstacle.interactive_tag());
+    }
+
     world_obj.set_timestamp_sec(
         std::max(obstacle.timestamp(), world_obj.timestamp_sec()));
   }
</diff>
			</file>
			<file old_path="modules\prediction\common\message_process.cc" new_path="modules\prediction\common\message_process.cc" added_lines="15" deleted_lines="3">
				<diff>@@ -32,6 +32,7 @@
 #include "modules/prediction/evaluator/evaluator_manager.h"
 #include "modules/prediction/predictor/predictor_manager.h"
 #include "modules/prediction/proto/offline_features.pb.h"
+#include "modules/prediction/scenario/interaction_filter/interaction_filter.h"
 #include "modules/prediction/scenario/prioritization/obstacles_prioritizer.h"
 #include "modules/prediction/scenario/right_of_way/right_of_way.h"
 #include "modules/prediction/util/data_extraction.h"
@@ -150,9 +151,15 @@ void MessageProcess::ContainerProcess(
   ptr_obstacles_container-&gt;Insert(perception_obstacles);
 
   ObstaclesPrioritizer obstacles_prioritizer(container_manager);
+
+  InteractionFilter interaction_filter(container_manager);
+
   // Ignore some obstacles
   obstacles_prioritizer.AssignIgnoreLevel();
 
+  // Add interactive tag
+  interaction_filter.AssignInteractiveTag();
+
   // Scenario analysis
   scenario_manager-&gt;Run(container_manager.get());
 
@@ -207,10 +214,14 @@ void MessageProcess::OnPerception(
       }
       // TODO(all): the adc trajectory should be part of features for learning
       //            algorithms rather than part of the feature.proto
-      /*
       *obstacle_ptr-&gt;mutable_latest_feature()-&gt;mutable_adc_trajectory_point() =
           ptr_ego_trajectory_container-&gt;adc_trajectory().trajectory_point();
-      */
+
+      // adc trajectory timestamp
+      obstacle_ptr-&gt;mutable_latest_feature()-&gt;set_adc_timestamp(
+          ptr_ego_trajectory_container-&gt;adc_trajectory()
+          .header().timestamp_sec());
+
       FeatureOutput::InsertFeatureProto(obstacle_ptr-&gt;latest_feature());
       ADEBUG &lt;&lt; "Insert feature into feature output";
     }
@@ -219,7 +230,8 @@ void MessageProcess::OnPerception(
   }
 
   // Make evaluations
-  evaluator_manager-&gt;Run(ptr_obstacles_container);
+  evaluator_manager-&gt;Run(ptr_ego_trajectory_container,
+                         ptr_obstacles_container);
   if (FLAGS_prediction_offline_mode ==
           PredictionConstants::kDumpDataForLearning ||
       FLAGS_prediction_offline_mode == PredictionConstants::kDumpFrameEnv) {
</diff>
			</file>
			<file old_path="modules\prediction\common\prediction_gflags.cc" new_path="modules\prediction\common\prediction_gflags.cc" added_lines="34" deleted_lines="0">
				<diff>@@ -58,6 +58,8 @@ DEFINE_double(surrounding_lane_search_radius, 3.0,
 
 // Semantic Map
 DEFINE_double(base_image_half_range, 100.0, "The half range of base image.");
+DEFINE_bool(enable_draw_adc_trajectory, false,
+            "If draw adc trajectory in semantic map");
 DEFINE_bool(img_show_semantic_map, false, "If show the image of semantic map.");
 
 // Scenario
@@ -70,6 +72,8 @@ DEFINE_bool(enable_all_pedestrian_caution_in_front, false,
             "If true, then all pedestrian in front of ADC are marked caution.");
 DEFINE_bool(enable_rank_caution_obstacles, true,
             "Rank the caution-level obstacles.");
+DEFINE_bool(enable_rank_interactive_obstacles, true,
+            "Rank the interactive obstacles.");
 DEFINE_int32(caution_obs_max_nums, 6,
              "The max number of caution-level obstacles");
 DEFINE_double(caution_distance_threshold, 60.0,
@@ -86,6 +90,20 @@ DEFINE_double(caution_search_distance_backward_for_overlap, 30.0,
               "in the case of overlap");
 DEFINE_double(caution_pedestrian_approach_time, 3.0,
               "The time for a pedestrian to approach adc trajectory");
+DEFINE_int32(interactive_obs_max_nums, 6,
+             "The max number of interactive obstacles");
+DEFINE_double(interaction_distance_threshold, 60.0,
+              "Distance threshold for interactive obstacles");
+DEFINE_double(interaction_search_distance_ahead, 50.0,
+              "The distance ahead to search interactive obstacles");
+DEFINE_double(interaction_search_distance_backward, 50.0,
+              "The distance backward to search interactive obstacles");
+DEFINE_double(interaction_search_distance_backward_for_merge, 60.0,
+              "The distance backward to search interactive obstacles "
+              "in the case of merging");
+DEFINE_double(interaction_search_distance_backward_for_overlap, 30.0,
+              "The distance backward to search interactive obstacles "
+              "in the case of overlap");
 
 // Obstacle features
 DEFINE_int32(ego_vehicle_id, -1, "The obstacle ID of the ego vehicle.");
@@ -151,6 +169,16 @@ DEFINE_string(evaluator_vehicle_mlp_file,
 DEFINE_string(evaluator_vehicle_rnn_file,
               "/apollo/modules/prediction/data/rnn_vehicle_model.bin",
               "rnn model file for vehicle evaluator");
+DEFINE_string(
+    torch_vehicle_jointly_model_file,
+    "/apollo/modules/prediction/data/"
+    "jointly_prediction_planning_vehicle_model.pt",
+    "Vehicle jointly prediction and planning model file");
+DEFINE_string(
+    torch_vehicle_jointly_model_cpu_file,
+    "/apollo/modules/prediction/data/"
+    "jointly_prediction_planning_vehicle_cpu_model.pt",
+    "Vehicle jointly prediction and planning cpu model file");
 DEFINE_string(torch_vehicle_junction_mlp_file,
               "/apollo/modules/prediction/data/junction_mlp_vehicle_model.pt",
               "Vehicle junction MLP model file");
@@ -173,6 +201,12 @@ DEFINE_string(torch_vehicle_cruise_cutin_file,
 DEFINE_string(torch_vehicle_lane_scanning_file,
               "/apollo/modules/prediction/data/lane_scanning_vehicle_model.pt",
               "Vehicle lane scanning model file");
+DEFINE_string(torch_vehicle_vectornet_file,
+              "/apollo/modules/prediction/data/vectornet_vehicle_model.pt",
+              "Vehicle vectornet model file");
+DEFINE_string(torch_vehicle_vectornet_cpu_file,
+              "/apollo/modules/prediction/data/vectornet_vehicle_cpu_model.pt",
+              "Vehicle vectornet cpu model file");
 DEFINE_string(torch_pedestrian_interaction_position_embedding_file,
               "/apollo/modules/prediction/data/"
               "pedestrian_interaction_position_embedding.pt",
</diff>
			</file>
			<file old_path="modules\prediction\common\prediction_gflags.h" new_path="modules\prediction\common\prediction_gflags.h" added_lines="12" deleted_lines="0">
				<diff>@@ -45,6 +45,7 @@ DECLARE_double(surrounding_lane_search_radius);
 
 // Semantic Map
 DECLARE_double(base_image_half_range);
+DECLARE_bool(enable_draw_adc_trajectory);
 DECLARE_bool(img_show_semantic_map);
 
 // Scenario
@@ -52,6 +53,7 @@ DECLARE_double(junction_distance_threshold);
 DECLARE_bool(enable_all_junction);
 DECLARE_bool(enable_all_pedestrian_caution_in_front);
 DECLARE_bool(enable_rank_caution_obstacles);
+DECLARE_bool(enable_rank_interactive_obstacles);
 DECLARE_int32(caution_obs_max_nums);
 DECLARE_double(caution_distance_threshold);
 DECLARE_double(caution_search_distance_ahead);
@@ -59,6 +61,12 @@ DECLARE_double(caution_search_distance_backward);
 DECLARE_double(caution_search_distance_backward_for_merge);
 DECLARE_double(caution_search_distance_backward_for_overlap);
 DECLARE_double(caution_pedestrian_approach_time);
+DECLARE_int32(interactive_obs_max_nums);
+DECLARE_double(interaction_distance_threshold);
+DECLARE_double(interaction_search_distance_ahead);
+DECLARE_double(interaction_search_distance_backward);
+DECLARE_double(interaction_search_distance_backward_for_merge);
+DECLARE_double(interaction_search_distance_backward_for_overlap);
 
 // Obstacle features
 DECLARE_int32(ego_vehicle_id);
@@ -97,6 +105,8 @@ DECLARE_double(pedestrian_max_speed);
 DECLARE_double(pedestrian_max_acc);
 DECLARE_double(still_speed);
 DECLARE_string(evaluator_vehicle_mlp_file);
+DECLARE_string(torch_vehicle_jointly_model_file);
+DECLARE_string(torch_vehicle_jointly_model_cpu_file);
 DECLARE_string(torch_vehicle_junction_mlp_file);
 DECLARE_string(torch_vehicle_junction_map_file);
 DECLARE_string(torch_vehicle_semantic_lstm_file);
@@ -104,6 +114,8 @@ DECLARE_string(torch_vehicle_semantic_lstm_cpu_file);
 DECLARE_string(torch_vehicle_cruise_go_file);
 DECLARE_string(torch_vehicle_cruise_cutin_file);
 DECLARE_string(torch_vehicle_lane_scanning_file);
+DECLARE_string(torch_vehicle_vectornet_file);
+DECLARE_string(torch_vehicle_vectornet_cpu_file);
 DECLARE_string(torch_pedestrian_interaction_position_embedding_file);
 DECLARE_string(torch_pedestrian_interaction_social_embedding_file);
 DECLARE_string(torch_pedestrian_interaction_single_lstm_file);
</diff>
			</file>
			<file old_path="modules\prediction\common\prediction_system_gflags.cc" new_path="modules\prediction\common\prediction_system_gflags.cc" added_lines="11" deleted_lines="0">
				<diff>@@ -84,3 +84,14 @@ DEFINE_string(evaluator_submodule_name, "evaluator_submodule",
 DEFINE_string(perception_obstacles_topic_name,
               "/apollo/prediction/perception_obstacles",
               "Internal topic of perception obstacles");
+
+// VectorNet
+DEFINE_string(prediction_target_file, "/apollo/data/train/test.pb.txt",
+              "VectorNet target pb file name");
+DEFINE_double(obstacle_x, 0.0, "obstacle position x");
+DEFINE_double(obstacle_y, 0.0, "obstacle position y");
+DEFINE_double(obstacle_phi, 0.0, "obstacle heading phi");
+DEFINE_double(road_distance, 141.4,
+              "road distance within which the points are got");
+DEFINE_double(point_distance, 5.0,
+              "sampling distance of two points");
</diff>
			</file>
			<file old_path="modules\prediction\common\prediction_system_gflags.h" new_path="modules\prediction\common\prediction_system_gflags.h" added_lines="8" deleted_lines="0">
				<diff>@@ -51,3 +51,11 @@ DECLARE_string(evaluator_topic_name);
 DECLARE_string(container_submodule_name);
 DECLARE_string(evaluator_submodule_name);
 DECLARE_string(perception_obstacles_topic_name);
+
+// VectorNet
+DECLARE_string(prediction_target_file);
+DECLARE_double(obstacle_x);
+DECLARE_double(obstacle_y);
+DECLARE_double(obstacle_phi);
+DECLARE_double(road_distance);
+DECLARE_double(point_distance);
</diff>
			</file>
			<file old_path="modules\prediction\common\semantic_map.cc" new_path="modules\prediction\common\semantic_map.cc" added_lines="19" deleted_lines="0">
				<diff>@@ -88,6 +88,12 @@ void SemanticMap::RunCurrFrame(
     }
   }
 
+  // Draw ADC trajectory
+  if (FLAGS_enable_draw_adc_trajectory) {
+    DrawADCTrajectory(cv::Scalar(0, 255, 255),
+                curr_base_x_, curr_base_y_, &amp;curr_img_);
+  }
+
   // Draw all obstacles_history
   for (const auto obstacle_id_history_pair : obstacle_id_history_map) {
     DrawHistory(obstacle_id_history_pair.second, cv::Scalar(0, 255, 255),
@@ -342,6 +348,19 @@ void SemanticMap::DrawHistory(const ObstacleHistory&amp; history,
   }
 }
 
+void SemanticMap::DrawADCTrajectory(const cv::Scalar&amp; color,
+                              const double base_x,
+                              const double base_y,
+                              cv::Mat* img) {
+  size_t traj_num = ego_feature_.adc_trajectory_point().size();
+  for (size_t i = 0; i &lt; traj_num; ++i) {
+    double time_decay = ego_feature_.adc_trajectory_point(i).relative_time() -
+                        ego_feature_.adc_trajectory_point(0).relative_time();
+    cv::Scalar decay_color = color * time_decay;
+    DrawPoly(ego_feature_, decay_color, base_x, base_y, img);
+  }
+}
+
 cv::Mat SemanticMap::CropArea(const cv::Mat&amp; input_img,
                               const cv::Point2i&amp; center_point,
                               const double heading) {
</diff>
			</file>
			<file old_path="modules\prediction\common\semantic_map.h" new_path="modules\prediction\common\semantic_map.h" added_lines="4" deleted_lines="0">
				<diff>@@ -79,6 +79,10 @@ class SemanticMap {
   void DrawHistory(const ObstacleHistory&amp; history, const cv::Scalar&amp; color,
                    const double base_x, const double base_y, cv::Mat* img);
 
+  // Draw adc trajectory in semantic map
+  void DrawADCTrajectory(const cv::Scalar&amp; color, const double base_x,
+                         const double base_y, cv::Mat* img);
+
   cv::Mat CropArea(const cv::Mat&amp; input_img, const cv::Point2i&amp; center_point,
                    const double heading);
 
</diff>
			</file>
			<file old_path="modules\prediction\container\obstacles\obstacle.cc" new_path="modules\prediction\container\obstacles\obstacle.cc" added_lines="23" deleted_lines="0">
				<diff>@@ -1456,6 +1456,29 @@ bool Obstacle::IsCaution() const {
   return feature.priority().priority() == ObstaclePriority::CAUTION;
 }
 
+void Obstacle::SetInteractiveTag() {
+  CHECK_GT(feature_history_.size(), 0U);
+  Feature* feature = mutable_latest_feature();
+  feature-&gt;mutable_interactive_tag()
+      -&gt;set_interactive_tag(ObstacleInteractiveTag::INTERACTION);
+}
+
+void Obstacle::SetNonInteractiveTag() {
+  CHECK_GT(feature_history_.size(), 0U);
+  Feature* feature = mutable_latest_feature();
+  feature-&gt;mutable_interactive_tag()
+      -&gt;set_interactive_tag(ObstacleInteractiveTag::NONINTERACTION);
+}
+
+bool Obstacle::IsInteractiveObstacle() const {
+  if (feature_history_.empty()) {
+    return false;
+  }
+  const Feature&amp; feature = latest_feature();
+  return feature.interactive_tag().interactive_tag() ==
+                 ObstacleInteractiveTag::INTERACTION;
+}
+
 void Obstacle::SetEvaluatorType(
     const ObstacleConf::EvaluatorType&amp; evaluator_type) {
   obstacle_conf_.set_evaluator_type(evaluator_type);
</diff>
			</file>
			<file old_path="modules\prediction\container\obstacles\obstacle.h" new_path="modules\prediction\container\obstacles\obstacle.h" added_lines="11" deleted_lines="0">
				<diff>@@ -228,6 +228,17 @@ class Obstacle {
 
   bool IsCaution() const;
 
+  /**
+   * @brief Set the obstacle as interactive obstacle.
+   */
+  void SetInteractiveTag();
+  /**
+   * @brief Set the obstacle as noninteractive obstacle.
+   */
+  void SetNonInteractiveTag();
+
+  bool IsInteractiveObstacle() const;
+
   void SetEvaluatorType(const ObstacleConf::EvaluatorType&amp; evaluator_type);
 
   void SetPredictorType(const ObstacleConf::PredictorType&amp; predictor_type);
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\evaluator.h" new_path="modules\prediction\evaluator\evaluator.h" added_lines="12" deleted_lines="0">
				<diff>@@ -28,6 +28,7 @@
 #include "modules/prediction/container/obstacles/obstacle.h"
 
 #include "modules/prediction/container/obstacles/obstacles_container.h"
+#include "modules/prediction/container/adc_trajectory/adc_trajectory_container.h"
 
 /**
  * @namespace apollo::prediction
@@ -71,6 +72,17 @@ class Evaluator {
     return Evaluate(obstacle, obstacles_container);
   }
 
+  /**
+   * @brief Evaluate an obstacle
+   * @param ADC trajectory container
+   * @param Obstacle pointer
+   * @param Obstacles container
+   */
+  virtual bool Evaluate(const ADCTrajectoryContainer* adc_trajectory_container,
+                        Obstacle* obstacle,
+                        ObstaclesContainer* obstacles_container) {
+    return Evaluate(obstacle, obstacles_container);
+  }
   /**
    * @brief Get the name of evaluator
    */
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\evaluator_manager.cc" new_path="modules\prediction\evaluator\evaluator_manager.cc" added_lines="49" deleted_lines="12">
				<diff>@@ -35,6 +35,8 @@
 #include "modules/prediction/evaluator/vehicle/lane_scanning_evaluator.h"
 #include "modules/prediction/evaluator/vehicle/mlp_evaluator.h"
 #include "modules/prediction/evaluator/vehicle/semantic_lstm_evaluator.h"
+#include "modules/prediction/evaluator/vehicle/jointly_prediction_planning_evaluator.h"
+#include "modules/prediction/evaluator/vehicle/vectornet_evaluator.h"
 
 namespace apollo {
 namespace prediction {
@@ -104,6 +106,8 @@ void EvaluatorManager::RegisterEvaluators() {
   RegisterEvaluator(ObstacleConf::LANE_AGGREGATING_EVALUATOR);
   RegisterEvaluator(ObstacleConf::JUNCTION_MAP_EVALUATOR);
   RegisterEvaluator(ObstacleConf::SEMANTIC_LSTM_EVALUATOR);
+  RegisterEvaluator(ObstacleConf::JOINTLY_PREDICTION_PLANNING_EVALUATOR);
+  RegisterEvaluator(ObstacleConf::VECTORNET_EVALUATOR);
 }
 
 void EvaluatorManager::Init(const PredictionConf&amp; config) {
@@ -173,6 +177,8 @@ void EvaluatorManager::Init(const PredictionConf&amp; config) {
           break;
         }
       }
+    } else if (obstacle_conf.has_interactive_tag()) {
+      interaction_evaluator_ = obstacle_conf.evaluator_type();
     }
   }
 
@@ -190,7 +196,9 @@ Evaluator* EvaluatorManager::GetEvaluator(
   return it != evaluators_.end() ? it-&gt;second.get() : nullptr;
 }
 
-void EvaluatorManager::Run(ObstaclesContainer* obstacles_container) {
+void EvaluatorManager::Run(
+    const ADCTrajectoryContainer* adc_trajectory_container,
+    ObstaclesContainer* obstacles_container) {
   if (FLAGS_enable_semantic_map ||
       FLAGS_prediction_offline_mode == PredictionConstants::kDumpFrameEnv) {
     size_t max_num_frame = 10;
@@ -214,7 +222,8 @@ void EvaluatorManager::Run(ObstaclesContainer* obstacles_container) {
         id_obstacle_map.begin(), id_obstacle_map.end(),
         [&amp;](IdObstacleListMap::iterator::value_type&amp; obstacles_iter) {
           for (auto obstacle_ptr : obstacles_iter.second) {
-            EvaluateObstacle(obstacle_ptr, obstacles_container, dynamic_env);
+            EvaluateObstacle(adc_trajectory_container, obstacle_ptr,
+                             obstacles_container, dynamic_env);
           }
         });
   } else {
@@ -229,20 +238,25 @@ void EvaluatorManager::Run(ObstaclesContainer* obstacles_container) {
         continue;
       }
 
-      EvaluateObstacle(obstacle, obstacles_container, dynamic_env);
+      EvaluateObstacle(adc_trajectory_container, obstacle,
+                       obstacles_container, dynamic_env);
     }
   }
 }
 
-void EvaluatorManager::EvaluateObstacle(Obstacle* obstacle,
-                                        ObstaclesContainer* obstacles_container,
-                                        std::vector&lt;Obstacle*&gt; dynamic_env) {
+void EvaluatorManager::EvaluateObstacle(
+    const ADCTrajectoryContainer* adc_trajectory_container,
+    Obstacle* obstacle,
+    ObstaclesContainer* obstacles_container,
+    std::vector&lt;Obstacle*&gt; dynamic_env) {
   Evaluator* evaluator = nullptr;
   // Select different evaluators depending on the obstacle's type.
   switch (obstacle-&gt;type()) {
     case PerceptionObstacle::VEHICLE: {
       if (obstacle-&gt;IsCaution() &amp;&amp; !obstacle-&gt;IsSlow()) {
-        if (obstacle-&gt;IsNearJunction()) {
+        if (obstacle-&gt;IsInteractiveObstacle()) {
+          evaluator = GetEvaluator(interaction_evaluator_);
+        } else if (obstacle-&gt;IsNearJunction()) {
           evaluator = GetEvaluator(vehicle_in_junction_caution_evaluator_);
         } else if (obstacle-&gt;IsOnLane()) {
           evaluator = GetEvaluator(vehicle_on_lane_caution_evaluator_);
@@ -251,13 +265,25 @@ void EvaluatorManager::EvaluateObstacle(Obstacle* obstacle,
         }
         CHECK_NOTNULL(evaluator);
         // Evaluate and break if success
-        if (evaluator-&gt;Evaluate(obstacle, obstacles_container)) {
-          break;
+        if (evaluator-&gt;GetName() == "JOINTLY_PREDICTION_PLANNING_EVALUATOR") {
+          if (evaluator-&gt;Evaluate(adc_trajectory_container,
+                                  obstacle, obstacles_container)) {
+            break;
+          } else {
+            AERROR &lt;&lt; "Obstacle: " &lt;&lt; obstacle-&gt;id()
+                  &lt;&lt; " interaction evaluator failed,"
+                  &lt;&lt; " downgrade to normal level!";
+          }
         } else {
-          AERROR &lt;&lt; "Obstacle: " &lt;&lt; obstacle-&gt;id()
-                 &lt;&lt; " caution evaluator failed, downgrade to normal level!";
+          if (evaluator-&gt;Evaluate(obstacle, obstacles_container)) {
+            break;
+          } else {
+            AERROR &lt;&lt; "Obstacle: " &lt;&lt; obstacle-&gt;id()
+                  &lt;&lt; " caution evaluator failed, downgrade to normal level!";
+          }
         }
       }
+
       // if obstacle is not caution or caution_evaluator run failed
       if (obstacle-&gt;HasJunctionFeatureWithExits() &amp;&amp;
           !obstacle-&gt;IsCloseToJunctionExit()) {
@@ -310,7 +336,9 @@ void EvaluatorManager::EvaluateObstacle(Obstacle* obstacle,
 void EvaluatorManager::EvaluateObstacle(
     Obstacle* obstacle, ObstaclesContainer* obstacles_container) {
   std::vector&lt;Obstacle*&gt; dummy_dynamic_env;
-  EvaluateObstacle(obstacle, obstacles_container, dummy_dynamic_env);
+  ADCTrajectoryContainer* adc_trajectory_container = nullptr;
+  EvaluateObstacle(adc_trajectory_container, obstacle,
+                   obstacles_container, dummy_dynamic_env);
 }
 
 void EvaluatorManager::BuildObstacleIdHistoryMap(
@@ -408,6 +436,15 @@ std::unique_ptr&lt;Evaluator&gt; EvaluatorManager::CreateEvaluator(
       evaluator_ptr.reset(new SemanticLSTMEvaluator(semantic_map_.get()));
       break;
     }
+    case ObstacleConf::JOINTLY_PREDICTION_PLANNING_EVALUATOR: {
+      evaluator_ptr.reset(new JointlyPredictionPlanningEvaluator(
+          semantic_map_.get()));
+      break;
+    }
+    case ObstacleConf::VECTORNET_EVALUATOR: {
+      evaluator_ptr.reset(new VectornetEvaluator());
+      break;
+    }
     default: {
       break;
     }
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\evaluator_manager.h" new_path="modules\prediction\evaluator\evaluator_manager.h" added_lines="11" deleted_lines="2">
				<diff>@@ -31,6 +31,7 @@
 #include "modules/prediction/common/semantic_map.h"
 #include "modules/prediction/evaluator/evaluator.h"
 #include "modules/prediction/proto/prediction_conf.pb.h"
+#include "modules/prediction/pipeline/vector_net.h"
 
 /**
  * @namespace apollo::prediction
@@ -66,9 +67,11 @@ class EvaluatorManager {
   /**
    * @brief Run evaluators
    */
-  void Run(ObstaclesContainer* obstacles_container);
+  void Run(const ADCTrajectoryContainer* adc_trajectory_container,
+           ObstaclesContainer* obstacles_container);
 
-  void EvaluateObstacle(Obstacle* obstacle,
+  void EvaluateObstacle(const ADCTrajectoryContainer* adc_trajectory_container,
+                        Obstacle* obstacle,
                         ObstaclesContainer* obstacles_container,
                         std::vector&lt;Obstacle*&gt; dynamic_env);
 
@@ -124,9 +127,15 @@ class EvaluatorManager {
   ObstacleConf::EvaluatorType pedestrian_evaluator_ =
       ObstacleConf::SEMANTIC_LSTM_EVALUATOR;
 
+  ObstacleConf::EvaluatorType vectornet_evaluator_ =
+      ObstacleConf::VECTORNET_EVALUATOR;
+
   ObstacleConf::EvaluatorType default_on_lane_evaluator_ =
       ObstacleConf::MLP_EVALUATOR;
 
+  ObstacleConf::EvaluatorType interaction_evaluator_ =
+      ObstacleConf::JOINTLY_PREDICTION_PLANNING_EVALUATOR;
+
   std::unordered_map&lt;int, ObstacleHistory&gt; obstacle_id_history_map_;
 
   std::unique_ptr&lt;SemanticMap&gt; semantic_map_;
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\evaluator_manager_test.cc" new_path="modules\prediction\evaluator\evaluator_manager_test.cc" added_lines="5" deleted_lines="1">
				<diff>@@ -49,6 +49,9 @@ TEST_F(EvaluatorManagerTest, General) {
 
   ContainerManager container_manager;
   container_manager.Init(adapter_conf_);
+  auto adc_trajectory_container =
+      container_manager.GetContainer&lt;ADCTrajectoryContainer&gt;(
+          AdapterConfig::PLANNING_TRAJECTORY);
   auto obstacles_container =
       container_manager.GetContainer&lt;ObstaclesContainer&gt;(
           AdapterConfig::PERCEPTION_OBSTACLES);
@@ -58,7 +61,8 @@ TEST_F(EvaluatorManagerTest, General) {
   EvaluatorManager evaluator_manager;
 
   evaluator_manager.Init(prediction_conf_);
-  evaluator_manager.Run(obstacles_container);
+  evaluator_manager.Run(adc_trajectory_container,
+      obstacles_container);
 
   Obstacle* obstacle_ptr = obstacles_container-&gt;GetObstacle(1);
   EXPECT_NE(obstacle_ptr, nullptr);
</diff>
			</file>
			<file old_path="modules\prediction\predictor\predictor_manager.cc" new_path="modules\prediction\predictor\predictor_manager.cc" added_lines="15" deleted_lines="0">
				<diff>@@ -276,6 +276,8 @@ void PredictorManager::PredictObstacle(
   prediction_obstacle-&gt;set_timestamp(obstacle-&gt;timestamp());
   prediction_obstacle-&gt;mutable_priority()-&gt;CopyFrom(
       obstacle-&gt;latest_feature().priority());
+  prediction_obstacle-&gt;mutable_interactive_tag()-&gt;CopyFrom(
+      obstacle-&gt;latest_feature().interactive_tag());
   prediction_obstacle-&gt;set_is_static(obstacle-&gt;IsStill());
   if (FLAGS_prediction_offline_mode ==
       PredictionConstants::kDumpPredictionResult) {
@@ -337,6 +339,9 @@ const PredictionObstacles&amp; PredictorManager::prediction_obstacles() {
 }
 
 void PredictorManager::InitVehiclePredictors(const ObstacleConf&amp; conf) {
+  if (!conf.has_obstacle_status() &amp;&amp; conf.has_interactive_tag()) {
+    vehicle_interactive_predictor_ = conf.predictor_type();
+  }
   switch (conf.obstacle_status()) {
     case ObstacleConf::ON_LANE: {
       if (conf.priority_type() == ObstaclePriority::CAUTION) {
@@ -394,6 +399,16 @@ void PredictorManager::RunVehiclePredictor(
     const ADCTrajectoryContainer* adc_trajectory_container, Obstacle* obstacle,
     ObstaclesContainer* obstacles_container) {
   Predictor* predictor = nullptr;
+  if (obstacle-&gt;IsInteractiveObstacle()) {
+    predictor = GetPredictor(vehicle_interactive_predictor_);
+    if (predictor-&gt;Predict(adc_trajectory_container, obstacle,
+                           obstacles_container)) {
+      return;
+    } else {
+      AERROR &lt;&lt; "Obstacle: " &lt;&lt; obstacle-&gt;id()
+             &lt;&lt; " interactive predictor failed!";
+    }
+  }
   if (obstacle-&gt;IsCaution()) {
     if (obstacle-&gt;IsNearJunction()) {
       predictor = GetPredictor(vehicle_in_junction_caution_predictor_);
</diff>
			</file>
			<file old_path="modules\prediction\predictor\predictor_manager.h" new_path="modules\prediction\predictor\predictor_manager.h" added_lines="3" deleted_lines="0">
				<diff>@@ -178,6 +178,9 @@ class PredictorManager {
   ObstacleConf::PredictorType vehicle_default_caution_predictor_ =
       ObstacleConf::EXTRAPOLATION_PREDICTOR;
 
+  ObstacleConf::PredictorType vehicle_interactive_predictor_ =
+      ObstacleConf::EMPTY_PREDICTOR;
+
   PredictionObstacles prediction_obstacles_;
 };
 
</diff>
			</file>
			<file old_path="modules\prediction\predictor\predictor_manager_test.cc" new_path="modules\prediction\predictor\predictor_manager_test.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -71,7 +71,7 @@ TEST_F(PredictorManagerTest, General) {
       container_manager_-&gt;GetContainer&lt;ADCTrajectoryContainer&gt;(
           AdapterConfig::PLANNING_TRAJECTORY);
 
-  evaluator_manager_-&gt;Run(obstacles_container);
+  evaluator_manager_-&gt;Run(adc_trajectory_container, obstacles_container);
   predictor_manager_-&gt;Run(perception_obstacles_, adc_trajectory_container,
                           obstacles_container);
 
</diff>
			</file>
			<file old_path="modules\prediction\submodules\evaluator_submodule.cc" new_path="modules\prediction\submodules\evaluator_submodule.cc" added_lines="3" deleted_lines="1">
				<diff>@@ -52,11 +52,13 @@ bool EvaluatorSubmodule::Init() {
 }
 
 bool EvaluatorSubmodule::Proc(
+    const std::shared_ptr&lt;ADCTrajectoryContainer&gt;&amp; adc_trajectory_container,
     const std::shared_ptr&lt;SubmoduleOutput&gt;&amp; container_output) {
   constexpr static size_t kHistorySize = 1;
   const auto frame_start_time = container_output-&gt;frame_start_time();
   ObstaclesContainer obstacles_container(*container_output);
-  evaluator_manager_-&gt;Run(&amp;obstacles_container);
+  evaluator_manager_-&gt;Run(adc_trajectory_container.get(),
+      &amp;obstacles_container);
   SubmoduleOutput submodule_output =
       obstacles_container.GetSubmoduleOutput(kHistorySize, frame_start_time);
   evaluator_writer_-&gt;Write(submodule_output);
</diff>
			</file>
			<file old_path="modules\prediction\submodules\evaluator_submodule.h" new_path="modules\prediction\submodules\evaluator_submodule.h" added_lines="6" deleted_lines="2">
				<diff>@@ -33,7 +33,9 @@
 namespace apollo {
 namespace prediction {
 
-class EvaluatorSubmodule : public cyber::Component&lt;SubmoduleOutput&gt; {
+class EvaluatorSubmodule
+    : public cyber::Component&lt;ADCTrajectoryContainer,
+                            SubmoduleOutput&gt; {
  public:
   /**
    * @brief Destructor
@@ -56,7 +58,9 @@ class EvaluatorSubmodule : public cyber::Component&lt;SubmoduleOutput&gt; {
    * @brief Data callback upon receiving a prediction container output.
    * @param Prediction container output.
    */
-  bool Proc(const std::shared_ptr&lt;SubmoduleOutput&gt;&amp;) override;
+  bool Proc(
+      const std::shared_ptr&lt;ADCTrajectoryContainer&gt;&amp; adc_trajectory_container,
+      const std::shared_ptr&lt;SubmoduleOutput&gt;&amp;) override;
 
  private:
   std::shared_ptr&lt;cyber::Writer&lt;SubmoduleOutput&gt;&gt; evaluator_writer_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6db2a1bc66ca3d564c18545c8ff8ebd0762249e7" author="spicyog">
		<msg>Merge v6.1_turn_around to master (#13970)</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\common\dreamview_gflags.cc" new_path="modules\dreamview\backend\common\dreamview_gflags.cc" added_lines="5" deleted_lines="1">
				<diff>@@ -93,7 +93,7 @@ DEFINE_string(default_data_collection_config_path,
               "/apollo/modules/dreamview/conf/data_collection_table.pb.txt",
               "Data collection table config path.");
 
-DEFINE_double(loop_routing_end_to_start_distance_threshold, 10.0,
+DEFINE_int32(loop_routing_end_to_start_distance_threshold, 10,
              "Loop routing distance threshold: start to end");
 
 DEFINE_string(default_preprocess_config_path,
@@ -108,3 +108,7 @@ DEFINE_string(lidar_calibration_mode, "Lidar-IMU Sensor Calibration",
 
 DEFINE_string(camera_calibration_mode, "Camera-Lidar Sensor Calibration",
               "Name of camera_to_lidar calibration mode.");
+
+DEFINE_double(parking_routing_distance_threshold, 20.0,
+              "For open space planner parking situation: get the routing"
+              "end point based on this threshold.");
</diff>
			</file>
			<file old_path="modules\dreamview\backend\common\dreamview_gflags.h" new_path="modules\dreamview\backend\common\dreamview_gflags.h" added_lines="3" deleted_lines="1">
				<diff>@@ -60,7 +60,7 @@ DECLARE_int32(monitor_msg_pending_queue_size);
 
 DECLARE_string(default_data_collection_config_path);
 
-DECLARE_double(loop_routing_end_to_start_distance_threshold);
+DECLARE_int32(loop_routing_end_to_start_distance_threshold);
 
 DECLARE_string(default_preprocess_config_path);
 
@@ -69,3 +69,5 @@ DECLARE_string(vehicle_calibration_mode);
 DECLARE_string(lidar_calibration_mode);
 
 DECLARE_string(camera_calibration_mode);
+
+DECLARE_double(parking_routing_distance_threshold);
</diff>
			</file>
			<file old_path="modules\dreamview\backend\hmi\hmi_worker.cc" new_path="modules\dreamview\backend\hmi\hmi_worker.cc" added_lines="1" deleted_lines="2">
				<diff>@@ -462,8 +462,7 @@ void HMIWorker::SubmitDriveEvent(const uint64_t event_time_ms,
 
 void HMIWorker::SensorCalibrationPreprocess(const std::string&amp; task_type) {
   std::string start_command = absl::StrCat(
-      "nohup bash /apollo/modules/tools/sensor_calibration/extract_data.sh -t ",
-      task_type, " &amp;");
+      "nohup bash /apollo/scripts/extract_data.sh -t ", task_type, " &amp;");
   System(start_command);
 }
 
</diff>
			</file>
			<file old_path="modules\dreamview\backend\map\map_service.cc" new_path="modules\dreamview\backend\map\map_service.cc" added_lines="47" deleted_lines="0">
				<diff>@@ -429,6 +429,36 @@ bool MapService::ConstructLaneWayPointWithHeading(
   return true;
 }
 
+bool MapService::ConstructLaneWayPointWithLaneId(
+    const double x, const double y, const std::string id,
+    routing::LaneWaypoint *laneWayPoint) const {
+  LaneInfoConstPtr lane = HDMap()-&gt;GetLaneById(hdmap::MakeMapId(id));
+  if (!lane) {
+    return false;
+  }
+
+  if (!CheckRoutingPointLaneType(lane)) {
+    return false;
+  }
+
+  double s, l;
+  PointENU point;
+  point.set_x(x);
+  point.set_y(y);
+
+  if (!lane-&gt;GetProjection({point.x(), point.y()}, &amp;s, &amp;l)) {
+    return false;
+  }
+
+  laneWayPoint-&gt;set_id(id);
+  laneWayPoint-&gt;set_s(s);
+  auto *pose = laneWayPoint-&gt;mutable_pose();
+  pose-&gt;set_x(x);
+  pose-&gt;set_y(y);
+
+  return true;
+}
+
 bool MapService::CheckRoutingPoint(const double x, const double y) const {
   double s, l;
   LaneInfoConstPtr lane;
@@ -441,6 +471,23 @@ bool MapService::CheckRoutingPoint(const double x, const double y) const {
   return true;
 }
 
+bool MapService::CheckRoutingPointLaneId(
+    const double x, const double y, std::vector&lt;std::string&gt; idsArr) const {
+  if (idsArr.empty()) {
+    return false;
+  }
+  double s, l;
+  LaneInfoConstPtr lane;
+  if (!GetNearestLane(x, y, &amp;lane, &amp;s, &amp;l)) {
+    return false;
+  }
+  if (!CheckRoutingPointLaneType(lane)) {
+    return false;
+  }
+  return std::find(idsArr.begin(), idsArr.end(), lane-&gt;id().id()) !=
+         idsArr.end();
+}
+
 bool MapService::CheckRoutingPointLaneType(LaneInfoConstPtr lane) const {
   if (lane-&gt;lane().type() != Lane::CITY_DRIVING) {
     AERROR
</diff>
			</file>
			<file old_path="modules\dreamview\backend\map\map_service.h" new_path="modules\dreamview\backend\map\map_service.h" added_lines="10" deleted_lines="1">
				<diff>@@ -26,9 +26,11 @@
 #include &lt;boost/thread/locks.hpp&gt;
 #include &lt;boost/thread/shared_mutex.hpp&gt;
 
+#include "nlohmann/json.hpp"
+
 #include "modules/dreamview/proto/simulation_world.pb.h"
+
 #include "modules/map/pnc_map/pnc_map.h"
-#include "nlohmann/json.hpp"
 
 /**
  * @namespace apollo::dreamview
@@ -76,8 +78,15 @@ class MapService {
       const double x, const double y, const double heading,
       routing::LaneWaypoint *laneWayPoint) const;
 
+  bool ConstructLaneWayPointWithLaneId(
+      const double x, const double y, const std::string id,
+      routing::LaneWaypoint *laneWayPoint) const;
+
   bool CheckRoutingPoint(const double x, const double y) const;
 
+  bool CheckRoutingPointLaneId(const double x, const double y,
+                               const std::vector&lt;std::string&gt; idsArr) const;
+
   bool CheckRoutingPointLaneType(apollo::hdmap::LaneInfoConstPtr lane) const;
 
   // Reload map from current FLAGS_map_dir.
</diff>
			</file>
			<file old_path="modules\dreamview\backend\sim_control\sim_control.cc" new_path="modules\dreamview\backend\sim_control\sim_control.cc" added_lines="4" deleted_lines="3">
				<diff>@@ -107,9 +107,9 @@ void SimControl::InitTimerAndIO() {
       false));
 }
 
-void SimControl::Init(double start_velocity,
+void SimControl::Init(bool set_start_point, double start_velocity,
                       double start_acceleration) {
-  if (!FLAGS_use_navigation_mode) {
+  if (set_start_point &amp;&amp; !FLAGS_use_navigation_mode) {
     InitStartPoint(start_velocity, start_acceleration);
   }
 }
@@ -252,7 +252,8 @@ void SimControl::Start() {
     // When localization is already available, we do not need to
     // reset/override the start point.
     localization_reader_-&gt;Observe();
-    Init(next_point_.has_v() ? next_point_.v() : 0.0,
+    Init(localization_reader_-&gt;Empty(),
+         next_point_.has_v() ? next_point_.v() : 0.0,
          next_point_.has_a() ? next_point_.a() : 0.0);
 
     InternalReset();
</diff>
			</file>
			<file old_path="modules\dreamview\backend\sim_control\sim_control.h" new_path="modules\dreamview\backend\sim_control\sim_control.h" added_lines="1" deleted_lines="1">
				<diff>@@ -62,7 +62,7 @@ class SimControl : SimControlInterface {
    * @brief setup callbacks and timer
    * @param set_start_point initialize localization.
    */
-  void Init(double start_velocity = 0.0,
+  void Init(bool set_start_point, double start_velocity = 0.0,
             double start_acceleration = 0.0) override;
 
   /**
</diff>
			</file>
			<file old_path="modules\dreamview\backend\sim_control\sim_control_interface.h" new_path="modules\dreamview\backend\sim_control\sim_control_interface.h" added_lines="1" deleted_lines="1">
				<diff>@@ -38,7 +38,7 @@ class SimControlInterface {
   /**
    * @brief Initialization.
    */
-  virtual void Init(double start_velocity = 0.0,
+  virtual void Init(bool set_start_point, double start_velocity = 0.0,
                     double start_acceleration = 0.0) = 0;
 
   /**
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_service.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_service.cc" added_lines="1" deleted_lines="2">
				<diff>@@ -546,8 +546,7 @@ void SimulationWorldService::UpdateSimulationWorld(const Chassis &amp;chassis) {
 
   auto_driving_car-&gt;set_disengage_type(DeduceDisengageType(chassis));
 
-  auto_driving_car-&gt;set_battery_percentage(
-    chassis.battery_soc_percentage());
+  auto_driving_car-&gt;set_battery_percentage(chassis.battery_soc_percentage());
   auto_driving_car-&gt;set_gear_location(chassis.gear_location());
 }
 
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_service_test.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_service_test.cc" added_lines="0" deleted_lines="1">
				<diff>@@ -23,7 +23,6 @@
 #include "modules/common/adapters/adapter_gflags.h"
 #include "modules/common/configs/vehicle_config_helper.h"
 #include "modules/common/math/quaternion.h"
-
 #include "modules/dreamview/backend/common/dreamview_gflags.h"
 
 using apollo::canbus::Chassis;
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" added_lines="201" deleted_lines="5">
				<diff>@@ -38,6 +38,8 @@ using apollo::hdmap::EndWayPointFile;
 using apollo::relative_map::NavigationInfo;
 using apollo::routing::RoutingRequest;
 using apollo::task_manager::CycleRoutingTask;
+using apollo::task_manager::DeadEndRoutingTask;
+using apollo::task_manager::ParkingRoutingTask;
 using apollo::task_manager::Task;
 
 using Json = nlohmann::json;
@@ -164,6 +166,37 @@ void SimulationWorldUpdater::RegisterMessageHandlers() {
         }
       });
 
+  websocket_-&gt;RegisterMessageHandler(
+      "SendDeadEndJunctionRoutingRequest",
+      [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
+        Json result = CheckDeadEndJunctionPoints(json);
+        if (result.contains("error")) {
+          AINFO &lt;&lt; result["error"];
+          sim_world_service_.PublishMonitorMessage(MonitorMessageItem::ERROR,
+                                                   result["error"]);
+        } else {
+          auto task = std::make_shared&lt;Task&gt;();
+          auto *dead_junction_routing_task =
+              task-&gt;mutable_dead_end_routing_task();
+          bool succeed = ConstructDeadJunctionRoutingTask(
+              result, dead_junction_routing_task);
+          if (succeed) {
+            task-&gt;set_task_name("dead_end_junction_routing_task");
+            task-&gt;set_task_type(
+                apollo::task_manager::TaskType::DEAD_END_ROUTING);
+            sim_world_service_.PublishTask(task);
+            AINFO &lt;&lt; task-&gt;DebugString();
+            sim_world_service_.PublishMonitorMessage(
+                MonitorMessageItem::INFO, "dead junction routing task sent.");
+          } else {
+            sim_world_service_.PublishMonitorMessage(
+                MonitorMessageItem::ERROR,
+                "Failed to send a dead junction routing task to task manager "
+                "module.");
+          }
+        }
+      });
+
   websocket_-&gt;RegisterMessageHandler(
       "SendDefaultCycleRoutingRequest",
       [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
@@ -193,6 +226,37 @@ void SimulationWorldUpdater::RegisterMessageHandlers() {
         }
       });
 
+  websocket_-&gt;RegisterMessageHandler(
+      "SendParkingRoutingRequest",
+      [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
+        auto task = std::make_shared&lt;Task&gt;();
+        auto *parking_routing_task = task-&gt;mutable_parking_routing_task();
+        bool succeed = ConstructParkingRoutingTask(json, parking_routing_task);
+        // For test routing
+        auto routing_request = std::make_shared&lt;RoutingRequest&gt;();
+        bool suc = ConstructRoutingRequest(json, routing_request.get());
+        if (suc) {
+          sim_world_service_.PublishRoutingRequest(routing_request);
+          sim_world_service_.PublishMonitorMessage(MonitorMessageItem::INFO,
+                                                   "Routing request sent.");
+        } else {
+          sim_world_service_.PublishMonitorMessage(
+              MonitorMessageItem::ERROR, "Failed to send a routing request.");
+        }
+        if (succeed) {
+          task-&gt;set_task_name("parking_routing_task");
+          task-&gt;set_task_type(apollo::task_manager::TaskType::PARKING_ROUTING);
+          sim_world_service_.PublishTask(task);
+          AINFO &lt;&lt; task-&gt;DebugString();
+          sim_world_service_.PublishMonitorMessage(
+              MonitorMessageItem::INFO, "parking routing task sent.");
+        } else {
+          sim_world_service_.PublishMonitorMessage(
+              MonitorMessageItem::ERROR,
+              "Failed to send a parking routing task to task manager module.");
+        }
+      });
+
   websocket_-&gt;RegisterMessageHandler(
       "RequestSimulationWorld",
       [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
@@ -345,6 +409,15 @@ void SimulationWorldUpdater::RegisterMessageHandlers() {
         }
       });
 
+  websocket_-&gt;RegisterMessageHandler(
+      "GetParkingRoutingDistance",
+      [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
+        Json response;
+        response["type"] = "ParkingRoutingDistance";
+        response["threshold"] = FLAGS_parking_routing_distance_threshold;
+        websocket_-&gt;SendData(conn, response.dump());
+      });
+
   websocket_-&gt;RegisterMessageHandler(
       "RequestPreprocessProgress",
       [this](const Json &amp;json, WebSocketHandler::Connection *conn) {
@@ -412,6 +485,56 @@ Json SimulationWorldUpdater::CheckRoutingPoint(const Json &amp;json) {
   return result;
 }
 
+Json SimulationWorldUpdater::CheckDeadEndJunctionPoints(const Json &amp;json) {
+  Json result;
+  if (!ContainsKey(json, "start1")) {
+    result["error"] = "Failed to check start point for dead end junction.";
+    AERROR &lt;&lt; result["error"];
+    return result;
+  }
+  if (!ContainsKey(json, "end2")) {
+    result["error"] = "Failed to check end point for dead end junction.";
+    AERROR &lt;&lt; result["error"];
+    return result;
+  }
+  auto iter = json.find("inLaneIds");
+  if (iter == json.end() || !iter-&gt;is_array()) {
+    result["error"] = "Failed to check start point for dead end junction.";
+    return result;
+  }
+  std::vector&lt;std::string&gt; laneIds;
+  auto point = json["start1"];
+  for (size_t i = 0; i &lt; iter-&gt;size(); ++i) {
+    auto &amp;id = (*iter)[i];
+    laneIds.push_back(id);
+  }
+  if (!map_service_-&gt;CheckRoutingPointLaneId(point["x"], point["y"], laneIds)) {
+    result["error"] = "Error start point for dead end junction.";
+  }
+  laneIds.clear();
+  point = json["end2"];
+  iter = json.find("outLaneIds");
+  if (iter == json.end() || !iter-&gt;is_array()) {
+    result["error"] = "Failed to check end point for dead end junction.";
+    return result;
+  }
+  for (size_t i = 0; i &lt; iter-&gt;size(); ++i) {
+    auto &amp;id = (*iter)[i];
+    laneIds.push_back(id);
+  }
+  if (!map_service_-&gt;CheckRoutingPointLaneId(point["x"], point["y"], laneIds)) {
+    result["error"] = "Error end point for dead end junction.";
+    return result;
+  }
+
+  result["routing1"]["start"] = json["start1"];
+  result["routing1"]["end"] = json["end1"];
+  result["routing2"]["start"] = json["start2"];
+  result["routing2"]["end"] = json["end2"];
+  result["routing2"]["waypoint"] = json["routingPoint"];
+  return result;
+}
+
 bool SimulationWorldUpdater::ConstructRoutingRequest(
     const Json &amp;json, RoutingRequest *routing_request) {
   routing_request-&gt;clear_waypoint();
@@ -434,6 +557,14 @@ bool SimulationWorldUpdater::ConstructRoutingRequest(
              &lt;&lt; start["heading"] &lt;&lt; " cannot locate start point on map.";
       return false;
     }
+  } else if (ContainsKey(start, "id")) {
+    if (!map_service_-&gt;ConstructLaneWayPointWithLaneId(
+            start["x"], start["y"], start["id"],
+            routing_request-&gt;add_waypoint())) {
+      AERROR &lt;&lt; "Failed to prepare a routing request with lane id: "
+             &lt;&lt; start["id"] &lt;&lt; " cannot locate end point on map.";
+      return false;
+    }
   } else {
     if (!map_service_-&gt;ConstructLaneWayPoint(start["x"], start["y"],
                                              routing_request-&gt;add_waypoint())) {
@@ -473,11 +604,20 @@ bool SimulationWorldUpdater::ConstructRoutingRequest(
     AERROR &lt;&lt; "Failed to prepare a routing request: invalid end point.";
     return false;
   }
-  if (!map_service_-&gt;ConstructLaneWayPoint(end["x"], end["y"],
-                                           routing_request-&gt;add_waypoint())) {
-    AERROR &lt;&lt; "Failed to prepare a routing request:"
-           &lt;&lt; " cannot locate end point on map.";
-    return false;
+  if (ContainsKey(end, "id")) {
+    if (!map_service_-&gt;ConstructLaneWayPointWithLaneId(
+            end["x"], end["y"], end["id"], routing_request-&gt;add_waypoint())) {
+      AERROR &lt;&lt; "Failed to prepare a routing request with lane id: "
+             &lt;&lt; end["id"] &lt;&lt; " cannot locate end point on map.";
+      return false;
+    }
+  } else {
+    if (!map_service_-&gt;ConstructLaneWayPoint(end["x"], end["y"],
+                                             routing_request-&gt;add_waypoint())) {
+      AERROR &lt;&lt; "Failed to prepare a routing request:"
+             &lt;&lt; " cannot locate end point on map.";
+      return false;
+    }
   }
 
   // set parking info
@@ -489,6 +629,23 @@ bool SimulationWorldUpdater::ConstructRoutingRequest(
              &lt;&lt; json["parkingInfo"].dump();
       return false;
     }
+    if (ContainsKey(json, "cornerPoints")) {
+      auto point_iter = json.find("cornerPoints");
+      auto *points =
+          requested_parking_info-&gt;mutable_corner_point()-&gt;mutable_point();
+      if (point_iter != json.end() &amp;&amp; point_iter-&gt;is_array()) {
+        for (size_t i = 0; i &lt; point_iter-&gt;size(); ++i) {
+          auto &amp;point = (*point_iter)[i];
+          auto *p = points-&gt;Add();
+          if (!ValidateCoordinate(point)) {
+            AERROR &lt;&lt; "Failed to add a corner point: invalid corner point.";
+            return false;
+          }
+          p-&gt;set_x(static_cast&lt;double&gt;(point["x"]));
+          p-&gt;set_y(static_cast&lt;double&gt;(point["y"]));
+        }
+      }
+    }
   }
 
   AINFO &lt;&lt; "Constructed RoutingRequest to be sent:\n"
@@ -497,6 +654,45 @@ bool SimulationWorldUpdater::ConstructRoutingRequest(
   return true;
 }
 
+bool SimulationWorldUpdater::ConstructParkingRoutingTask(
+    const Json &amp;json, ParkingRoutingTask *parking_routing_task) {
+  auto *routing_request = parking_routing_task-&gt;mutable_routing_request();
+  // set parking Space
+  if (!ContainsKey(json, "laneWidth")) {
+    AERROR &lt;&lt; "Failed to prepare a parking routing task: "
+           &lt;&lt; "lane width not found.";
+    return false;
+  }
+  bool succeed = ConstructRoutingRequest(json, routing_request);
+  if (succeed) {
+    parking_routing_task-&gt;set_lane_width(
+        static_cast&lt;double&gt;(json["laneWidth"]));
+    return true;
+  }
+  return false;
+}
+
+bool SimulationWorldUpdater::ConstructDeadJunctionRoutingTask(
+    const Json &amp;json, DeadEndRoutingTask *dead_junction_routing_task) {
+  auto *routing_request_in =
+      dead_junction_routing_task-&gt;mutable_routing_request_in();
+  bool succeed = ConstructRoutingRequest(json["routing1"], routing_request_in);
+  if (!succeed) {
+    AERROR &lt;&lt; "Failed to construct the first routing request for dead end "
+              "junction routing task";
+    return false;
+  }
+  auto *routing_request_out =
+      dead_junction_routing_task-&gt;mutable_routing_request_out();
+  succeed = ConstructRoutingRequest(json["routing2"], routing_request_out);
+  if (!succeed) {
+    AERROR &lt;&lt; "Failed to construct the second routing request for dead end "
+              "junction routing task";
+    return false;
+  }
+  return true;
+}
+
 bool SimulationWorldUpdater::ValidateCoordinate(const nlohmann::json &amp;json) {
   if (!ContainsKey(json, "x") || !ContainsKey(json, "y")) {
     AERROR &lt;&lt; "Failed to find x or y coordinate.";
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_updater.h" new_path="modules\dreamview\backend\simulation_world\simulation_world_updater.h" added_lines="32" deleted_lines="0">
				<diff>@@ -22,6 +22,7 @@
 
 #include &lt;memory&gt;
 #include &lt;string&gt;
+#include &lt;vector&gt;
 
 #include &lt;boost/thread/locks.hpp&gt;
 #include &lt;boost/thread/shared_mutex.hpp&gt;
@@ -98,6 +99,30 @@ class SimulationWorldUpdater {
       const nlohmann::json &amp;json,
       apollo::routing::RoutingRequest *routing_request);
 
+  /**
+   * @brief The function to construct a parking routing task from the given
+   * json,
+   * @param json that contains start, end, waypoint, parking info, lane width,
+   * @param parking_routing_task
+   * @return True if parking routing task is constructed successfully
+   */
+  bool ConstructParkingRoutingTask(
+      const nlohmann::json &amp;json,
+      apollo::task_manager::ParkingRoutingTask *parking_routing_task);
+
+  /**
+   * @brief The function to construct a dead end junction routing task from the
+   * given json,
+   * @param json that contains start1, end1, start2, end2, inLaneIds,
+   * outLaneIds, junctionInfo
+   * @param dead_junction_routing_task
+   * @return True if dead junction routing task is constructed successfully
+   */
+  bool ConstructDeadJunctionRoutingTask(
+      const nlohmann::json &amp;json,
+      apollo::task_manager::DeadEndRoutingTask
+          *dead_end_routing_task);
+
   bool ValidateCoordinate(const nlohmann::json &amp;json);
 
   /**
@@ -107,6 +132,13 @@ class SimulationWorldUpdater {
    */
   nlohmann::json CheckRoutingPoint(const nlohmann::json &amp;json);
 
+  /**
+   * @brief Check if routing point is located on a lane that included by arr
+   * @param json that contains point and ids array
+   * @return json contains error means check failed else means check succeed
+   */
+  nlohmann::json CheckDeadEndJunctionPoints(const nlohmann::json &amp;json);
+
   /**
    * @brief Tries to load the points of interest from the file if it has
    * not been.
</diff>
			</file>
			<file old_path="modules\map\pnc_map\path.h" new_path="modules\map\pnc_map\path.h" added_lines="4" deleted_lines="0">
				<diff>@@ -315,6 +315,9 @@ class Path {
   const std::vector&lt;PathOverlap&gt;&amp; parking_space_overlaps() const {
     return parking_space_overlaps_;
   }
+  const std::vector&lt;PathOverlap&gt;&amp; dead_end_overlaps() const {
+    return dead_end_overlaps_;
+  }
 
   double GetLaneLeftWidth(const double s) const;
   double GetLaneRightWidth(const double s) const;
@@ -374,6 +377,7 @@ class Path {
   std::vector&lt;PathOverlap&gt; stop_sign_overlaps_;
   std::vector&lt;PathOverlap&gt; crosswalk_overlaps_;
   std::vector&lt;PathOverlap&gt; parking_space_overlaps_;
+  std::vector&lt;PathOverlap&gt; dead_end_overlaps_;
   std::vector&lt;PathOverlap&gt; junction_overlaps_;
   std::vector&lt;PathOverlap&gt; pnc_junction_overlaps_;
   std::vector&lt;PathOverlap&gt; clear_area_overlaps_;
</diff>
			</file>
			<file old_path="modules\planning\common\planning_gflags.cc" new_path="modules\planning\common\planning_gflags.cc" added_lines="11" deleted_lines="0">
				<diff>@@ -83,6 +83,10 @@ DEFINE_string(scenario_valet_parking_config_file,
               "/apollo/modules/planning/conf/"
               "scenario/valet_parking_config.pb.txt",
               "valet_parking scenario config file");
+DEFINE_string(scenario_deadend_turnaround_config_file,
+              "/apollo/modules/planning/conf/"
+              "scenario/deadend_turnaround_config.pb.txt",
+              "deadend_turnaround scenario config file");
 DEFINE_string(scenario_yield_sign_config_file,
               "/apollo/modules/planning/conf/"
               "scenario/yield_sign_config.pb.txt",
@@ -179,6 +183,13 @@ DEFINE_double(planning_upper_speed_limit, 31.3,
 
 DEFINE_double(trajectory_time_length, 8.0, "Trajectory time length");
 
+DEFINE_double(threshold_distance_for_destination, 0.01,
+              "threshold distance for destination");
+
+DEFINE_double(buffer_in_routing, 0.0, "buffer for select in lane for boundary");
+
+DEFINE_double(buffer_out_routing, 2.0,
+              "buffer for select out lane for boundary");
 // planning trajectory output time density control
 DEFINE_double(
     trajectory_time_min_interval, 0.02,
</diff>
			</file>
			<file old_path="modules\planning\common\planning_gflags.h" new_path="modules\planning\common\planning_gflags.h" added_lines="7" deleted_lines="0">
				<diff>@@ -38,6 +38,7 @@ DECLARE_string(scenario_traffic_light_protected_config_file);
 DECLARE_string(scenario_traffic_light_unprotected_left_turn_config_file);
 DECLARE_string(scenario_traffic_light_unprotected_right_turn_config_file);
 DECLARE_string(scenario_valet_parking_config_file);
+DECLARE_string(scenario_deadend_turnaround_config_file);
 DECLARE_string(scenario_yield_sign_config_file);
 
 DECLARE_bool(enable_scenario_bare_intersection);
@@ -267,6 +268,12 @@ DECLARE_bool(use_front_axe_center_in_path_planning);
 
 DECLARE_bool(use_road_boundary_from_map);
 
+DECLARE_double(threshold_distance_for_destination);
+
+DECLARE_double(buffer_in_routing);
+
+DECLARE_double(buffer_out_routing);
+
 // learning related
 DECLARE_bool(planning_offline_learning);
 DECLARE_string(planning_data_dir);
</diff>
			</file>
			<file old_path="modules\planning\conf\planning.conf" new_path="modules\planning\conf\planning.conf" added_lines="1" deleted_lines="1">
				<diff>@@ -20,7 +20,7 @@
 # --use_dual_variable_warm_start=true
 # --enable_open_space_planner_thread=true
 # --enable_record_debug=true
-# --use_gear_shift_trajectory=true
+--use_gear_shift_trajectory=true
 # --enable_parallel_hybrid_a=true
 --export_chart=true
 
</diff>
			</file>
			<file old_path="modules\planning\navi_planning.cc" new_path="modules\planning\navi_planning.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -199,7 +199,6 @@ void NaviPlanning::RunOnce(const LocalView&amp; local_view,
       FLAGS_trajectory_stitching_preserved_length, true,
       last_publishable_trajectory_.get(), &amp;replan_reason);
 
-  injector_-&gt;ego_info()-&gt;Update(stitching_trajectory.back(), vehicle_state);
   const uint32_t frame_num = static_cast&lt;uint32_t&gt;(seq_num_++);
   status = InitFrame(frame_num, stitching_trajectory.back(), vehicle_state);
 
@@ -214,6 +213,8 @@ void NaviPlanning::RunOnce(const LocalView&amp; local_view,
     return;
   }
 
+  injector_-&gt;ego_info()-&gt;Update(stitching_trajectory.back(), vehicle_state);
+
   if (FLAGS_enable_record_debug) {
     frame_-&gt;RecordInputDebug(trajectory_pb-&gt;mutable_debug());
   }
</diff>
			</file>
			<file old_path="modules\planning\on_lane_planning.cc" new_path="modules\planning\on_lane_planning.cc" added_lines="76" deleted_lines="6">
				<diff>@@ -60,6 +60,10 @@ using apollo::hdmap::HDMapUtil;
 using apollo::planning_internal::SLFrameDebug;
 using apollo::planning_internal::SpeedPlan;
 using apollo::planning_internal::STGraphDebug;
+using apollo::routing::RoutingRequest;
+using apollo::hdmap::JunctionInfoConstPtr;
+using apollo::common::math::Polygon2d;
+using apollo::common::PointENU;
 
 OnLanePlanning::~OnLanePlanning() {
   if (reference_line_provider_) {
@@ -105,7 +109,6 @@ Status OnLanePlanning::Init(const PlanningConfig&amp; config) {
   reference_line_provider_ = std::make_unique&lt;ReferenceLineProvider&gt;(
       injector_-&gt;vehicle_state(), hdmap_);
   reference_line_provider_-&gt;Start();
-
   // dispatch planner
   planner_ = planner_dispatcher_-&gt;DispatchPlanner(config_, injector_);
   if (!planner_) {
@@ -202,6 +205,56 @@ void OnLanePlanning::GenerateStopTrajectory(ADCTrajectory* ptr_trajectory_pb) {
   }
 }
 
+bool OnLanePlanning::JudgeCarInDeadEndJunction(
+    std::vector&lt;JunctionInfoConstPtr&gt;* junctions,
+    const Vec2d&amp; car_position,
+    JunctionInfoConstPtr* target_junction) {
+  // warning: the car only be the one junction
+  size_t junction_num = junctions-&gt;size();
+  if (junction_num &lt;= 0) {
+    return false;
+  }
+  for (size_t i = 0; i &lt; junction_num; ++i) {
+    if (junctions-&gt;at(i)-&gt;junction().type() == DEAD_END) {
+      Polygon2d polygon = junctions-&gt;at(i)-&gt;polygon();
+      // judge dead end point in the select junction
+      if (polygon.IsPointIn(car_position)) {
+        *target_junction = junctions-&gt;at(i);
+        return true;
+      } else {
+        return false;
+      }
+    } else {
+      return false;
+    }
+  }
+  return true;
+}
+
+bool OnLanePlanning::DeadEndHandle(
+  const PointENU&amp; dead_end_point,
+  const VehicleState&amp; vehicle_state) {
+  const hdmap::HDMap* base_map_ptr = hdmap::HDMapUtil::BaseMapPtr();
+  std::vector&lt;JunctionInfoConstPtr&gt; junctions;
+  JunctionInfoConstPtr junction;
+  if (base_map_ptr-&gt;GetJunctions(dead_end_point, 1.0, &amp;junctions) != 0) {
+    ADEBUG &lt;&lt; "Fail to get junctions from base_map.";
+    return false;
+  }
+  if (junctions.size() &lt;= 0) {
+    ADEBUG &lt;&lt; "No junction from map";
+    return false;
+  }
+  Vec2d car_position;
+  car_position.set_x(vehicle_state.x());
+  car_position.set_y(vehicle_state.y());
+  if (!JudgeCarInDeadEndJunction(&amp;junctions, car_position, &amp;junction)) {
+    ADEBUG &lt;&lt; "Target Dead End not found";
+    return false;
+  }
+  return true;
+}
+
 void OnLanePlanning::RunOnce(const LocalView&amp; local_view,
                              ADCTrajectory* const ptr_trajectory_pb) {
   // when rerouting, reference line might not be updated. In this case, planning
@@ -213,7 +266,6 @@ void OnLanePlanning::RunOnce(const LocalView&amp; local_view,
       std::chrono::duration&lt;double&gt;(
           std::chrono::system_clock::now().time_since_epoch())
           .count();
-
   // localization
   ADEBUG &lt;&lt; "Get localization:"
          &lt;&lt; local_view_.localization_estimate-&gt;DebugString();
@@ -225,6 +277,21 @@ void OnLanePlanning::RunOnce(const LocalView&amp; local_view,
       *local_view_.localization_estimate, *local_view_.chassis);
 
   VehicleState vehicle_state = injector_-&gt;vehicle_state()-&gt;vehicle_state();
+  size_t waypoint_num =
+    local_view_.routing-&gt;routing_request().waypoint().size();
+  if (local_view_.routing-&gt;routing_request().dead_end_info().
+    dead_end_routing_type() == routing::ROUTING_IN) {
+    dead_end_point_ = local_view_.routing-&gt;routing_request()
+                    .waypoint().at(waypoint_num - 1).pose();
+  } else if (local_view_.routing-&gt;routing_request().dead_end_info().
+    dead_end_routing_type() == routing::ROUTING_OUT) {
+    dead_end_point_ = local_view_.routing-&gt;routing_request()
+                    .waypoint().at(0).pose();
+  }
+  if (DeadEndHandle(dead_end_point_, vehicle_state) &amp;&amp; !wait_flag_) {
+    // do not use reference line
+    reference_line_provider_-&gt;Wait();
+  }
   const double vehicle_state_timestamp = vehicle_state.timestamp();
   DCHECK_GE(start_timestamp, vehicle_state_timestamp)
       &lt;&lt; "start_timestamp is behind vehicle_state_timestamp by "
@@ -263,7 +330,6 @@ void OnLanePlanning::RunOnce(const LocalView&amp; local_view,
 
   failed_to_update_reference_line =
       (!reference_line_provider_-&gt;UpdatedReferenceLine());
-
   // early return when reference line fails to update after rerouting
   if (failed_to_update_reference_line) {
     const std::string msg = "Failed to update reference line after rerouting.";
@@ -278,7 +344,6 @@ void OnLanePlanning::RunOnce(const LocalView&amp; local_view,
     GenerateStopTrajectory(ptr_trajectory_pb);
     return;
   }
-
   // Update reference line provider and reset pull over if necessary
   reference_line_provider_-&gt;UpdateVehicleState(vehicle_state);
 
@@ -349,9 +414,7 @@ void OnLanePlanning::RunOnce(const LocalView&amp; local_view,
             &lt;&lt; " traffic decider failed";
     }
   }
-
   status = Plan(start_timestamp, stitching_trajectory, ptr_trajectory_pb);
-
   for (const auto&amp; p : ptr_trajectory_pb-&gt;trajectory_point()) {
     ADEBUG &lt;&lt; p.DebugString();
   }
@@ -408,6 +471,13 @@ void OnLanePlanning::RunOnce(const LocalView&amp; local_view,
     }
   }
 
+  // reference line recovery only one frame
+  bool complete_dead_end =
+    frame_.get()-&gt;open_space_info().destination_reached();
+  if (complete_dead_end) {
+    reference_line_provider_-&gt;Start();
+    wait_flag_ = true;
+  }
   const uint32_t n = frame_-&gt;SequenceNum();
   injector_-&gt;frame_history()-&gt;Add(n, std::move(frame_));
 }
</diff>
			</file>
			<file old_path="modules\planning\on_lane_planning.h" new_path="modules\planning\on_lane_planning.h" added_lines="11" deleted_lines="0">
				<diff>@@ -102,10 +102,21 @@ class OnLanePlanning : public PlanningBase {
   void AddFallbackTrajectory(const planning_internal::Debug&amp; debug_info,
                              planning_internal::Debug* debug_chart);
 
+  bool DeadEndHandle(const common::PointENU&amp; dead_end_point,
+                     const common::VehicleState&amp; vehicle_state);
+
+  bool JudgeCarInDeadEndJunction(
+    std::vector&lt;hdmap::JunctionInfoConstPtr&gt;* junctions,
+    const common::math::Vec2d&amp; dead_end_point,
+    hdmap::JunctionInfoConstPtr* target_junction);
+
  private:
   routing::RoutingResponse last_routing_;
   std::unique_ptr&lt;ReferenceLineProvider&gt; reference_line_provider_;
   Smoother planning_smoother_;
+  bool wait_flag_ = false;
+  bool routing_in_flag_ = true;
+  common::PointENU dead_end_point_;
 };
 
 }  // namespace planning
</diff>
			</file>
			<file old_path="modules\planning\open_space\coarse_trajectory_generator\hybrid_a_star.cc" new_path="modules\planning\open_space\coarse_trajectory_generator\hybrid_a_star.cc" added_lines="3" deleted_lines="12">
				<diff>@@ -20,8 +20,6 @@
 
 #include "modules/planning/open_space/coarse_trajectory_generator/hybrid_a_star.h"
 
-#include &lt;limits&gt;
-
 #include "modules/planning/math/piecewise_jerk/piecewise_jerk_speed_problem.h"
 
 namespace apollo {
@@ -405,11 +403,7 @@ bool HybridAStar::GenerateSCurveSpeedAcceleration(HybridAStartResult* result) {
                                               path_length * max_reverse_acc) /
                                              (max_reverse_acc * max_reverse_v),
                                   10.0);
-  if (total_t + delta_t &gt;= delta_t * std::numeric_limits&lt;size_t&gt;::max()) {
-    AERROR &lt;&lt; "Number of knots overflow. total_t: " &lt;&lt; total_t
-           &lt;&lt; ", delta_t: " &lt;&lt; delta_t;
-    return false;
-  }
+
   const size_t num_of_knots = static_cast&lt;size_t&gt;(total_t / delta_t) + 1;
 
   PiecewiseJerkSpeedProblem piecewise_jerk_problem(
@@ -648,7 +642,6 @@ bool HybridAStar::Plan(
   close_set_.clear();
   open_pq_ = decltype(open_pq_)();
   final_node_ = nullptr;
-
   std::vector&lt;std::vector&lt;common::math::LineSegment2d&gt;&gt;
       obstacles_linesegments_vec;
   for (const auto&amp; obstacle_vertices : obstacles_vertices_vec) {
@@ -662,7 +655,6 @@ bool HybridAStar::Plan(
     obstacles_linesegments_vec.emplace_back(obstacle_linesegments);
   }
   obstacles_linesegments_vec_ = std::move(obstacles_linesegments_vec);
-
   // load XYbounds
   XYbounds_ = XYbounds;
   // load nodes and obstacles
@@ -671,11 +663,11 @@ bool HybridAStar::Plan(
   end_node_.reset(
       new Node3d({ex}, {ey}, {ephi}, XYbounds_, planner_open_space_config_));
   if (!ValidityCheck(start_node_)) {
-    ADEBUG &lt;&lt; "start_node in collision with obstacles";
+    AERROR &lt;&lt; "start_node in collision with obstacles";
     return false;
   }
   if (!ValidityCheck(end_node_)) {
-    ADEBUG &lt;&lt; "end_node in collision with obstacles";
+    AERROR &lt;&lt; "end_node in collision with obstacles";
     return false;
   }
   double map_time = Clock::NowInSeconds();
@@ -685,7 +677,6 @@ bool HybridAStar::Plan(
   // load open set, pq
   open_set_.emplace(start_node_-&gt;GetIndex(), start_node_);
   open_pq_.emplace(start_node_-&gt;GetIndex(), start_node_-&gt;GetCost());
-
   // Hybrid A* begins
   size_t explored_node_num = 0;
   double astar_start_time = Clock::NowInSeconds();
</diff>
			</file>
			<file old_path="modules\planning\open_space\trajectory_smoother\iterative_anchoring_smoother.cc" new_path="modules\planning\open_space\trajectory_smoother\iterative_anchoring_smoother.cc" added_lines="1" deleted_lines="7">
				<diff>@@ -626,13 +626,7 @@ bool IterativeAnchoringSmoother::SmoothSpeed(const double init_a,
           .delta_t();
 
   const double total_t = 2 * path_length / max_reverse_acc * 10;
-
-  if (total_t + delta_t &gt;= delta_t * std::numeric_limits&lt;size_t&gt;::max()) {
-    AERROR &lt;&lt; "Number of knots overflow. total_t: " &lt;&lt; total_t
-           &lt;&lt; ", delta_t: " &lt;&lt; delta_t;
-    return false;
-  }
-
+  ADEBUG &lt;&lt; "total_t is : " &lt;&lt; total_t;
   const size_t num_of_knots = static_cast&lt;size_t&gt;(total_t / delta_t) + 1;
 
   PiecewiseJerkSpeedProblem piecewise_jerk_problem(
</diff>
			</file>
			<file old_path="modules\planning\reference_line\reference_line_provider.cc" new_path="modules\planning\reference_line\reference_line_provider.cc" added_lines="9" deleted_lines="0">
				<diff>@@ -114,6 +114,7 @@ void ReferenceLineProvider::UpdateVehicleState(
 }
 
 bool ReferenceLineProvider::Start() {
+  is_stop_ = false;
   if (FLAGS_use_navigation_mode) {
     return true;
   }
@@ -128,6 +129,13 @@ bool ReferenceLineProvider::Start() {
   return true;
 }
 
+void ReferenceLineProvider::Wait() {
+  is_stop_ = true;
+  if (FLAGS_enable_reference_line_provider_thread) {
+    task_future_.wait();
+  }
+}
+
 void ReferenceLineProvider::Stop() {
   is_stop_ = true;
   if (FLAGS_enable_reference_line_provider_thread) {
@@ -189,6 +197,7 @@ void ReferenceLineProvider::UpdateReferenceLine(
 
 void ReferenceLineProvider::GenerateThread() {
   while (!is_stop_) {
+    is_reference_line_updated_ = true;
     static constexpr int32_t kSleepTime = 50;  // milliseconds
     cyber::SleepFor(std::chrono::milliseconds(kSleepTime));
     const double start_time = Clock::NowInSeconds();
</diff>
			</file>
			<file old_path="modules\planning\reference_line\reference_line_provider.h" new_path="modules\planning\reference_line\reference_line_provider.h" added_lines="2" deleted_lines="0">
				<diff>@@ -77,6 +77,8 @@ class ReferenceLineProvider {
 
   void Stop();
 
+  void Wait();
+
   bool GetReferenceLines(std::list&lt;ReferenceLine&gt;* reference_lines,
                          std::list&lt;hdmap::RouteSegments&gt;* segments);
 
</diff>
			</file>
			<file old_path="modules\planning\scenarios\park\valet_parking\valet_parking_scenario.cc" new_path="modules\planning\scenarios\park\valet_parking\valet_parking_scenario.cc" added_lines="10" deleted_lines="1">
				<diff>@@ -132,7 +132,7 @@ bool ValetParkingScenario::IsTransferable(const Frame&amp; frame,
     return false;
   }
 
-  if (!CheckDistanceToParkingSpot(vehicle_state, nearby_path,
+  if (!CheckDistanceToParkingSpot(frame, vehicle_state, nearby_path,
                                   parking_start_range, parking_space_overlap)) {
     ADEBUG &lt;&lt; "target parking spot found, but too far, distance larger than "
               "pre-defined distance"
@@ -157,6 +157,7 @@ bool ValetParkingScenario::SearchTargetParkingSpotOnPath(
 }
 
 bool ValetParkingScenario::CheckDistanceToParkingSpot(
+    const Frame&amp; frame,
     const VehicleState&amp; vehicle_state, const Path&amp; nearby_path,
     const double parking_start_range,
     const PathOverlap&amp; parking_space_overlap) {
@@ -170,6 +171,14 @@ bool ValetParkingScenario::CheckDistanceToParkingSpot(
       hdmap-&gt;GetParkingSpaceById(id);
   Vec2d left_bottom_point = target_parking_spot_ptr-&gt;polygon().points().at(0);
   Vec2d right_bottom_point = target_parking_spot_ptr-&gt;polygon().points().at(1);
+  const auto &amp;routing_request =
+      frame.local_view().routing-&gt;routing_request();
+  auto corner_point =
+      routing_request.parking_info().corner_point();
+  left_bottom_point.set_x(corner_point.point().at(0).x());
+  left_bottom_point.set_y(corner_point.point().at(0).y());
+  right_bottom_point.set_x(corner_point.point().at(1).x());
+  right_bottom_point.set_y(corner_point.point().at(1).y());
   double left_bottom_point_s = 0.0;
   double left_bottom_point_l = 0.0;
   double right_bottom_point_s = 0.0;
</diff>
			</file>
			<file old_path="modules\planning\scenarios\park\valet_parking\valet_parking_scenario.h" new_path="modules\planning\scenarios\park\valet_parking\valet_parking_scenario.h" added_lines="1" deleted_lines="0">
				<diff>@@ -66,6 +66,7 @@ class ValetParkingScenario : public Scenario {
       const hdmap::Path&amp; nearby_path, const std::string&amp; target_parking_id,
       hdmap::PathOverlap* parking_space_overlap);
   static bool CheckDistanceToParkingSpot(
+      const Frame&amp; frame,
       const common::VehicleState&amp; vehicle_state, const hdmap::Path&amp; nearby_path,
       const double parking_start_range,
       const hdmap::PathOverlap&amp; parking_space_overlap);
</diff>
			</file>
			<file old_path="modules\planning\scenarios\scenario_manager.cc" new_path="modules\planning\scenarios\scenario_manager.cc" added_lines="69" deleted_lines="9">
				<diff>@@ -34,6 +34,7 @@
 #include "modules/planning/scenarios/learning_model/learning_model_sample_scenario.h"
 #include "modules/planning/scenarios/park/pull_over/pull_over_scenario.h"
 #include "modules/planning/scenarios/park/valet_parking/valet_parking_scenario.h"
+#include "modules/planning/scenarios/dead_end/deadend_turnaround/deadend_turnaround_scenario.h"
 #include "modules/planning/scenarios/park_and_go/park_and_go_scenario.h"
 #include "modules/planning/scenarios/stop_sign/unprotected/stop_sign_unprotected_scenario.h"
 #include "modules/planning/scenarios/traffic_light/protected/traffic_light_protected_scenario.h"
@@ -121,6 +122,10 @@ std::unique_ptr&lt;Scenario&gt; ScenarioManager::CreateScenario(
       ptr.reset(new scenario::yield_sign::YieldSignScenario(
           config_map_[scenario_type], &amp;scenario_context_, injector_));
       break;
+    case ScenarioConfig::DEADEND_TURNAROUND:
+      ptr.reset(new scenario::deadend_turnaround::DeadEndTurnAroundScenario(
+          config_map_[scenario_type], &amp;scenario_context_, injector_));
+      break;
     default:
       return nullptr;
   }
@@ -193,6 +198,10 @@ void ScenarioManager::RegisterScenarios() {
   // yield_sign
   ACHECK(Scenario::LoadConfig(FLAGS_scenario_yield_sign_config_file,
                               &amp;config_map_[ScenarioConfig::YIELD_SIGN]));
+  // turn around
+  ACHECK(Scenario::LoadConfig(
+      FLAGS_scenario_deadend_turnaround_config_file,
+      &amp;config_map_[ScenarioConfig::DEADEND_TURNAROUND]));
 }
 
 ScenarioConfig::ScenarioType ScenarioManager::SelectPullOverScenario(
@@ -312,6 +321,7 @@ ScenarioConfig::ScenarioType ScenarioManager::SelectPullOverScenario(
     case ScenarioConfig::TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN:
     case ScenarioConfig::TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN:
     case ScenarioConfig::VALET_PARKING:
+    case ScenarioConfig::DEADEND_TURNAROUND:
     case ScenarioConfig::YIELD_SIGN:
       if (current_scenario_-&gt;GetStatus() !=
           Scenario::ScenarioStatus::STATUS_DONE) {
@@ -328,7 +338,6 @@ ScenarioConfig::ScenarioType ScenarioManager::SelectPullOverScenario(
 ScenarioConfig::ScenarioType ScenarioManager::SelectPadMsgScenario(
     const Frame&amp; frame) {
   const auto&amp; pad_msg_driving_action = frame.GetPadMsgDrivingAction();
-
   switch (pad_msg_driving_action) {
     case DrivingAction::PULL_OVER:
       if (FLAGS_enable_scenario_emergency_pull_over) {
@@ -351,11 +360,10 @@ ScenarioConfig::ScenarioType ScenarioManager::SelectPadMsgScenario(
     default:
       break;
   }
-
   return default_scenario_type_;
 }
 
-ScenarioConfig::ScenarioType ScenarioManager::SelectIntersectionScenario(
+ScenarioConfig::ScenarioType ScenarioManager::SelectInterceptionScenario(
     const Frame&amp; frame) {
   ScenarioConfig::ScenarioType scenario_type = default_scenario_type_;
 
@@ -730,6 +738,33 @@ ScenarioConfig::ScenarioType ScenarioManager::SelectValetParkingScenario(
   return default_scenario_type_;
 }
 
+ScenarioConfig::ScenarioType ScenarioManager::SelectDeadEndScenario(
+    const Frame&amp; frame) {
+  size_t waypoint_num =
+    frame.local_view().routing-&gt;routing_request().waypoint().size();
+  const auto&amp; routing_type =
+    frame.local_view().routing-&gt;routing_request().dead_end_info().
+    dead_end_routing_type();
+  if (routing_type == routing::ROUTING_IN) {
+    dead_end_point_ = frame.local_view().routing-&gt;routing_request().
+                    waypoint().at(waypoint_num - 1).pose();
+  } else if (routing_type == routing::ROUTING_OUT) {
+    dead_end_point_ = frame.local_view().routing-&gt;routing_request().
+                    waypoint().at(0).pose();
+  }
+  const auto&amp; scenario_config =
+    config_map_[ScenarioConfig::DEADEND_TURNAROUND].deadend_turnaround_config();
+  double dead_end_start_range =
+      scenario_config.dead_end_start_range();
+  if (scenario::deadend_turnaround::DeadEndTurnAroundScenario::IsTransferable(
+          frame, dead_end_point_, dead_end_start_range) &amp;&amp;
+          routing_type == routing::ROUTING_IN) {
+    return ScenarioConfig::DEADEND_TURNAROUND;
+  }
+
+  return default_scenario_type_;
+}
+
 ScenarioConfig::ScenarioType ScenarioManager::SelectParkAndGoScenario(
     const Frame&amp; frame) {
   bool park_and_go = false;
@@ -760,7 +795,6 @@ ScenarioConfig::ScenarioType ScenarioManager::SelectParkAndGoScenario(
   const double adc_front_edge_s = reference_line_info.AdcSlBoundary().end_s();
 
   const double adc_distance_to_dest = dest_sl.s() - adc_front_edge_s;
-  ADEBUG &lt;&lt; "adc_distance_to_dest:" &lt;&lt; adc_distance_to_dest;
   // if vehicle is static, far enough to destination and (off-lane or not on
   // city_driving lane)
   if (std::fabs(adc_speed) &lt; max_abs_speed_when_stopped &amp;&amp;
@@ -804,6 +838,7 @@ void ScenarioManager::Update(const common::TrajectoryPoint&amp; ego_point,
   ScenarioDispatch(frame);
 }
 
+
 void ScenarioManager::ScenarioDispatch(const Frame&amp; frame) {
   ACHECK(!frame.reference_line_info().empty());
   ScenarioConfig::ScenarioType scenario_type;
@@ -842,16 +877,31 @@ ScenarioConfig::ScenarioType ScenarioManager::ScenarioDispatchLearning() {
   return scenario_type;
 }
 
+bool ScenarioManager::JudgeReachTargetPoint(
+  const common::VehicleState&amp; car_position,
+  const common::PointENU&amp; target_point) {
+  double distance_to_vehicle =
+    (car_position.x() - target_point.x()) *
+    (car_position.x() - target_point.x()) +
+    (car_position.y() - target_point.y()) *
+    (car_position.y() - target_point.y());
+  return distance_to_vehicle &lt; FLAGS_threshold_distance_for_destination;
+}
+
 ScenarioConfig::ScenarioType ScenarioManager::ScenarioDispatchNonLearning(
     const Frame&amp; frame) {
   ////////////////////////////////////////
   // default: LANE_FOLLOW
   ScenarioConfig::ScenarioType scenario_type = default_scenario_type_;
-
   ////////////////////////////////////////
   // Pad Msg scenario
   scenario_type = SelectPadMsgScenario(frame);
 
+  const auto vehicle_state_provider = injector_-&gt;vehicle_state();
+  common::VehicleState vehicle_state = vehicle_state_provider-&gt;vehicle_state();
+  const common::PointENU&amp; target_point =
+  frame.local_view().routing-&gt;routing_request().dead_end_info().target_point();
+  const common::VehicleState&amp; car_position = frame.vehicle_state();
   if (scenario_type == default_scenario_type_) {
     // check current_scenario (not switchable)
     switch (current_scenario_-&gt;scenario_type()) {
@@ -867,6 +917,12 @@ ScenarioConfig::ScenarioType ScenarioManager::ScenarioDispatchNonLearning(
       case ScenarioConfig::TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN:
       case ScenarioConfig::TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN:
       case ScenarioConfig::VALET_PARKING:
+      case ScenarioConfig::DEADEND_TURNAROUND:
+        // transfer dead_end to lane follow, should enhance transfer logic
+        if (JudgeReachTargetPoint(car_position, target_point)) {
+          scenario_type = ScenarioConfig::LANE_FOLLOW;
+          reach_target_pose_ = true;
+        }
       case ScenarioConfig::YIELD_SIGN:
         // must continue until finish
         if (current_scenario_-&gt;GetStatus() !=
@@ -878,11 +934,10 @@ ScenarioConfig::ScenarioType ScenarioManager::ScenarioDispatchNonLearning(
         break;
     }
   }
-
   ////////////////////////////////////////
   // ParkAndGo / starting scenario
   if (scenario_type == default_scenario_type_) {
-    if (FLAGS_enable_scenario_park_and_go) {
+    if (FLAGS_enable_scenario_park_and_go &amp;&amp; !reach_target_pose_) {
       scenario_type = SelectParkAndGoScenario(frame);
     }
   }
@@ -890,7 +945,7 @@ ScenarioConfig::ScenarioType ScenarioManager::ScenarioDispatchNonLearning(
   ////////////////////////////////////////
   // intersection scenarios
   if (scenario_type == default_scenario_type_) {
-    scenario_type = SelectIntersectionScenario(frame);
+    scenario_type = SelectInterceptionScenario(frame);
   }
 
   ////////////////////////////////////////
@@ -906,7 +961,12 @@ ScenarioConfig::ScenarioType ScenarioManager::ScenarioDispatchNonLearning(
   if (scenario_type == default_scenario_type_) {
     scenario_type = SelectValetParkingScenario(frame);
   }
-
+  ////////////////////////////////////////
+  // dead end
+  if (scenario_type == default_scenario_type_) {
+    scenario_type = SelectDeadEndScenario(frame);
+  }
+  ////////////////////////////////////////
   return scenario_type;
 }
 
</diff>
			</file>
			<file old_path="modules\planning\scenarios\scenario_manager.h" new_path="modules\planning\scenarios\scenario_manager.h" added_lines="9" deleted_lines="1">
				<diff>@@ -57,7 +57,7 @@ class ScenarioManager final {
 
   ScenarioConfig::ScenarioType SelectPadMsgScenario(const Frame&amp; frame);
 
-  ScenarioConfig::ScenarioType SelectIntersectionScenario(const Frame&amp; frame);
+  ScenarioConfig::ScenarioType SelectInterceptionScenario(const Frame&amp; frame);
 
   ScenarioConfig::ScenarioType SelectStopSignScenario(
       const Frame&amp; frame, const hdmap::PathOverlap&amp; stop_sign_overlap);
@@ -67,6 +67,8 @@ class ScenarioManager final {
 
   ScenarioConfig::ScenarioType SelectValetParkingScenario(const Frame&amp; frame);
 
+  ScenarioConfig::ScenarioType SelectDeadEndScenario(const Frame&amp; frame);
+
   ScenarioConfig::ScenarioType SelectYieldSignScenario(
       const Frame&amp; frame, const hdmap::PathOverlap&amp; yield_sign_overlap);
 
@@ -104,6 +106,9 @@ class ScenarioManager final {
   void UpdatePlanningContextYieldSignScenario(
       const Frame&amp; frame, const ScenarioConfig::ScenarioType&amp; scenario_type);
 
+  bool JudgeReachTargetPoint(const common::VehicleState&amp; car_position,
+                             const common::PointENU&amp; target_point);
+
  private:
   std::shared_ptr&lt;DependencyInjector&gt; injector_;
   PlanningConfig planning_config_;
@@ -116,6 +121,9 @@ class ScenarioManager final {
   std::unordered_map&lt;ReferenceLineInfo::OverlapType, hdmap::PathOverlap,
                      std::hash&lt;int&gt;&gt;
       first_encountered_overlap_map_;
+  bool routing_in_flag_ = true;
+  common::PointENU dead_end_point_;
+  bool reach_target_pose_ = false;
 };
 
 }  // namespace scenario
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_pre_stop_decider.cc" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_pre_stop_decider.cc" added_lines="121" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
+ * Copyright 2021 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -31,12 +31,16 @@
 
 namespace apollo {
 namespace planning {
-
+using apollo::common::PointENU;
 using apollo::common::ErrorCode;
 using apollo::common::Status;
 using apollo::common::VehicleState;
 using apollo::common::math::Vec2d;
+using apollo::common::math::Polygon2d;
+using apollo::hdmap::HDMapUtil;
+using apollo::hdmap::JunctionInfoConstPtr;
 using apollo::hdmap::ParkingSpaceInfoConstPtr;
+using apollo::routing::RoutingRequest;
 
 OpenSpacePreStopDecider::OpenSpacePreStopDecider(
     const TaskConfig&amp; config,
@@ -70,6 +74,14 @@ Status OpenSpacePreStopDecider::Process(
       }
       SetPullOverStopFence(target_s, frame, reference_line_info);
       break;
+    case OpenSpacePreStopDeciderConfig::DEAD_END_PRE_STOP:
+      if (!CheckDeadEndPreStop(frame, reference_line_info, &amp;target_s)) {
+        const std::string msg = "Checking dead end pre stop fails";
+        AERROR &lt;&lt; msg;
+        return Status(ErrorCode::PLANNING_ERROR, msg);
+      }
+      SetDeadEndStopFence(target_s, frame, reference_line_info);
+      break;
     default:
       const std::string msg = "This stop type not implemented";
       AERROR &lt;&lt; msg;
@@ -97,6 +109,10 @@ bool OpenSpacePreStopDecider::CheckPullOverPreStop(
 bool OpenSpacePreStopDecider::CheckParkingSpotPreStop(
     Frame* const frame, ReferenceLineInfo* const reference_line_info,
     double* target_s) {
+  const auto &amp;routing_request =
+      frame-&gt;local_view().routing-&gt;routing_request();
+  auto corner_point =
+      routing_request.parking_info().corner_point();
   const auto&amp; target_parking_spot_id =
       frame-&gt;open_space_info().target_parking_spot_id();
   const auto&amp; nearby_path = reference_line_info-&gt;reference_line().map_path();
@@ -122,6 +138,10 @@ bool OpenSpacePreStopDecider::CheckParkingSpotPreStop(
           target_parking_spot_ptr-&gt;polygon().points().at(0);
       Vec2d right_bottom_point =
           target_parking_spot_ptr-&gt;polygon().points().at(1);
+      left_bottom_point.set_x(corner_point.point().at(0).x());
+      left_bottom_point.set_y(corner_point.point().at(0).y());
+      right_bottom_point.set_x(corner_point.point().at(1).x());
+      right_bottom_point.set_y(corner_point.point().at(1).y());
       double left_bottom_point_s = 0.0;
       double left_bottom_point_l = 0.0;
       double right_bottom_point_s = 0.0;
@@ -143,6 +163,105 @@ bool OpenSpacePreStopDecider::CheckParkingSpotPreStop(
   return true;
 }
 
+bool OpenSpacePreStopDecider::SelectTargetDeadEndJunction(
+    std::vector&lt;JunctionInfoConstPtr&gt;* junctions,
+    const apollo::common::PointENU&amp; dead_end_point,
+    JunctionInfoConstPtr* target_junction) {
+  // warning: the car only be the one junction
+  size_t junction_num = junctions-&gt;size();
+  if (junction_num &lt;= 0) {
+    ADEBUG &lt;&lt; "No junctions frim map";
+    return false;
+  }
+  Vec2d target_point = {dead_end_point.x(), dead_end_point.y()};
+  for (size_t i = 0; i &lt; junction_num; ++i) {
+    if (junctions-&gt;at(i)-&gt;junction().type() == 5) {
+      Polygon2d polygon = junctions-&gt;at(i)-&gt;polygon();
+      if (polygon.IsPointIn(target_point)) {
+        *target_junction = junctions-&gt;at(i);
+        ADEBUG &lt;&lt; "car in the junction";
+        return true;
+      } else {
+        return false;
+      }
+    } else {
+      ADEBUG &lt;&lt; "No dead end junction";
+      return false;
+    }
+  }
+  return true;
+}
+
+bool OpenSpacePreStopDecider::CheckDeadEndPreStop(
+  Frame* const frame,
+  ReferenceLineInfo* const reference_line_info,
+  double* target_s) {
+  const auto&amp; routing_type = frame-&gt;local_view().
+    routing-&gt;routing_request().dead_end_info().dead_end_routing_type();
+  size_t waypoint_num =
+    frame-&gt;local_view().routing-&gt;routing_request().waypoint().size();
+  if (routing_type == routing::ROUTING_IN) {
+    dead_end_point_ = frame-&gt;local_view().routing-&gt;routing_request().
+                    waypoint().at(waypoint_num - 1).pose();
+  } else if (routing_type == routing::ROUTING_OUT) {
+    dead_end_point_ = frame-&gt;local_view().routing-&gt;routing_request().
+                    waypoint().at(0).pose();
+  }
+  const hdmap::HDMap* base_map_ptr = HDMapUtil::BaseMapPtr();
+  std::vector&lt;JunctionInfoConstPtr&gt; junctions;
+  JunctionInfoConstPtr junction;
+  if (base_map_ptr-&gt;GetJunctions(dead_end_point_, 1.0, &amp;junctions) != 0) {
+    ADEBUG &lt;&lt; "Fail to get junctions from sim_map.";
+    return false;
+  }
+  if (junctions.size() &lt;= 0) {
+    ADEBUG &lt;&lt; "No junctions from map";
+    return false;
+  }
+  if (!SelectTargetDeadEndJunction(&amp;junctions, dead_end_point_, &amp;junction)) {
+    ADEBUG &lt;&lt; "Target Dead End not found";
+    return false;
+  }
+  // compute the x value of dead end
+  auto points = junction-&gt;polygon().points();
+  const auto&amp; nearby_path =
+      reference_line_info-&gt;reference_line().map_path();
+  Vec2d first_point = points.front();
+  // the last point's s value may be unsuitable
+  Vec2d last_point = points.back();
+  double first_point_s = 0.0;
+  double first_point_l = 0.0;
+  double last_point_s = 0.0;
+  double last_point_l = 0.0;
+  nearby_path.GetNearestPoint(first_point, &amp;first_point_s,
+                              &amp;first_point_l);
+  nearby_path.GetNearestPoint(last_point, &amp;last_point_s,
+                              &amp;last_point_l);
+  double center_s = (first_point_s + last_point_s) / 2.0;
+  *target_s = center_s;
+  return true;
+}
+
+void OpenSpacePreStopDecider::SetDeadEndStopFence(
+    const double target_s, Frame* const frame,
+    ReferenceLineInfo* const reference_line_info) {
+  double stop_line_s = 0.0;
+  double stop_distance_to_target =
+      open_space_pre_stop_decider_config_.stop_distance_to_target();
+  CHECK_GE(stop_distance_to_target, 1.0e-8);
+  // get the stop point s
+  stop_line_s = target_s - stop_distance_to_target;
+  // set stop fence
+  const std::string stop_wall_id = OPEN_SPACE_STOP_ID;
+  std::vector&lt;std::string&gt; wait_for_obstacles;
+  frame-&gt;mutable_open_space_info()-&gt;set_open_space_pre_stop_fence_s(
+      stop_line_s);
+  util::BuildStopDecision(stop_wall_id, stop_line_s, 0.0,
+                          StopReasonCode::STOP_REASON_PRE_OPEN_SPACE_STOP,
+                          wait_for_obstacles, "OpenSpacePreStopDecider", frame,
+                          reference_line_info);
+}
+
 void OpenSpacePreStopDecider::SetParkingSpotStopFence(
     const double target_s, Frame* const frame,
     ReferenceLineInfo* const reference_line_info) {
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_pre_stop_decider.h" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_pre_stop_decider.h" added_lines="15" deleted_lines="2">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2018 The Apollo Authors. All Rights Reserved.
+ * Copyright 2021 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,7 +21,7 @@
 #pragma once
 
 #include &lt;memory&gt;
-
+#include &lt;vector&gt;
 #include "cyber/common/macros.h"
 #include "modules/planning/common/frame.h"
 #include "modules/planning/common/reference_line_info.h"
@@ -46,16 +46,29 @@ class OpenSpacePreStopDecider : public Decider {
   bool CheckPullOverPreStop(Frame* const frame,
                             ReferenceLineInfo* const reference_line_info,
                             double* target_s);
+  bool CheckDeadEndPreStop(Frame* const frame,
+                           ReferenceLineInfo* const reference_line_info,
+                           double* target_x);
 
+  void SetDeadEndStopFence(const double target_x,
+                           Frame* const frame,
+                           ReferenceLineInfo* const reference_line_info);
   void SetParkingSpotStopFence(const double target_s, Frame* const frame,
                                ReferenceLineInfo* const reference_line_info);
 
   void SetPullOverStopFence(const double target_s, Frame* const frame,
                             ReferenceLineInfo* const reference_line_info);
 
+  static bool SelectTargetDeadEndJunction(
+        std::vector&lt;hdmap::JunctionInfoConstPtr&gt;* junctions,
+        const apollo::common::PointENU&amp; dead_end_point,
+        hdmap::JunctionInfoConstPtr* target_junction);
+
  private:
   static constexpr const char* OPEN_SPACE_STOP_ID = "OPEN_SPACE_PRE_STOP";
   OpenSpacePreStopDeciderConfig open_space_pre_stop_decider_config_;
+  bool routing_in_flag_ = true;
+  common::PointENU dead_end_point_;
 };
 
 }  // namespace planning
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" added_lines="440" deleted_lines="6">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
+ * Copyright 2021 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -33,11 +33,17 @@ using apollo::common::ErrorCode;
 using apollo::common::Status;
 using apollo::common::math::Box2d;
 using apollo::common::math::Vec2d;
+using apollo::common::math::Polygon2d;
+using apollo::common::PointENU;
 using apollo::hdmap::HDMapUtil;
 using apollo::hdmap::LaneInfoConstPtr;
 using apollo::hdmap::LaneSegment;
 using apollo::hdmap::ParkingSpaceInfoConstPtr;
 using apollo::hdmap::Path;
+using apollo::hdmap::JunctionInfoConstPtr;
+using apollo::routing::ParkingSpaceType;
+using apollo::routing::RoutingRequest;
+using apollo::routing::LaneWaypoint;
 
 OpenSpaceRoiDecider::OpenSpaceRoiDecider(
     const TaskConfig &amp;config,
@@ -47,6 +53,9 @@ OpenSpaceRoiDecider::OpenSpaceRoiDecider(
   CHECK_NOTNULL(hdmap_);
   vehicle_params_ =
       apollo::common::VehicleConfigHelper::GetConfig().vehicle_param();
+  injector-&gt;vehicle_state();
+  temp_state_.set_x(injector-&gt;vehicle_state()-&gt;x());
+  temp_state_.set_y(injector-&gt;vehicle_state()-&gt;y());
 }
 
 Status OpenSpaceRoiDecider::Process(Frame *frame) {
@@ -61,6 +70,7 @@ Status OpenSpaceRoiDecider::Process(Frame *frame) {
   obstacles_by_frame_ = frame-&gt;GetObstacleList();
 
   std::array&lt;Vec2d, 4&gt; spot_vertices;
+  std::vector&lt;Vec2d&gt; dead_end_vertices;
   Path nearby_path;
   // @brief vector of different obstacle consisting of vertice points.The
   // obstacle and the vertices order are in counter-clockwise order
@@ -96,6 +106,50 @@ Status OpenSpaceRoiDecider::Process(Frame *frame) {
       AERROR &lt;&lt; msg;
       return Status(ErrorCode::PLANNING_ERROR, msg);
     }
+  } else if (roi_type == OpenSpaceRoiDeciderConfig::DEAD_END) {
+    const auto&amp; routing_type =
+      frame-&gt;local_view().routing-&gt;routing_request().dead_end_info().
+      dead_end_routing_type();
+    size_t waypoint_num =
+      frame-&gt;local_view().routing-&gt;routing_request().waypoint().size();
+    if (routing_type == routing::ROUTING_IN) {
+      dead_end_point_ = frame-&gt;local_view().routing-&gt;routing_request().
+                      waypoint().at(waypoint_num - 1).pose();
+    } else if (routing_type == routing::ROUTING_OUT) {
+      dead_end_point_ = frame-&gt;local_view().routing-&gt;routing_request().
+                      waypoint().at(0).pose();
+    }
+    const hdmap::HDMap* base_map_ptr = HDMapUtil::BaseMapPtr();
+    std::vector&lt;JunctionInfoConstPtr&gt; junctions;
+    JunctionInfoConstPtr junction;
+    if (base_map_ptr-&gt;GetJunctions(dead_end_point_, 1.0, &amp;junctions) != 0) {
+      const std::string msg = "Fail to get junctions from sim_map.";
+      AERROR &lt;&lt; msg;
+      Status(ErrorCode::PLANNING_ERROR, msg);
+    }
+    if (junctions.size() &lt;= 0) {
+      const std::string msg = "No junctions from map";
+      AERROR &lt;&lt; msg;
+      Status(ErrorCode::PLANNING_ERROR, msg);
+    }
+    if (!SelectTargetDeadEndJunction(&amp;junctions, dead_end_point_, &amp;junction)) {
+      const std::string msg = "Target Dead End not found";
+      AERROR &lt;&lt; msg;
+      Status(ErrorCode::PLANNING_ERROR, msg);
+    }
+    if (!GetDeadEndSpot(frame, &amp;junction, &amp;dead_end_vertices)) {
+      const std::string msg = "Fail to get dead end vertices from map";
+      AERROR &lt;&lt; msg;
+      return Status(ErrorCode::PLANNING_ERROR, msg);
+    }
+    SetDeadEndOrigin(frame, dead_end_vertices);
+    SetDeadEndPose(frame, dead_end_vertices);
+    if (!GetDeadEndBoundary(frame, dead_end_vertices,
+                            nearby_path, &amp;roi_boundary)) {
+      const std::string msg = "Fail to get dead end boundary";
+      AERROR &lt;&lt; msg;
+      return Status(ErrorCode::PLANNING_ERROR, msg);
+    }
   } else if (roi_type == OpenSpaceRoiDeciderConfig::PULL_OVER) {
     if (!GetPullOverSpot(frame, &amp;spot_vertices, &amp;nearby_path)) {
       const std::string msg = "Fail to get parking boundary from map";
@@ -143,16 +197,43 @@ Status OpenSpaceRoiDecider::Process(Frame *frame) {
     AERROR &lt;&lt; msg;
     return Status(ErrorCode::PLANNING_ERROR, msg);
   }
-
   if (!FormulateBoundaryConstraints(roi_boundary, frame)) {
     const std::string msg = "Fail to formulate boundary constraints";
     AERROR &lt;&lt; msg;
     return Status(ErrorCode::PLANNING_ERROR, msg);
   }
-
   return Status::OK();
 }
 
+bool OpenSpaceRoiDecider::SelectTargetDeadEndJunction(
+    std::vector&lt;JunctionInfoConstPtr&gt;* junctions,
+    const apollo::common::PointENU&amp; dead_end_point,
+    JunctionInfoConstPtr* target_junction) {
+  // warning: the car only be the one junction
+  size_t junction_num = junctions-&gt;size();
+  if (junction_num &lt;= 0) {
+    ADEBUG &lt;&lt; "No junctions frim map";
+    return false;
+  }
+  Vec2d target_point = {dead_end_point.x(), dead_end_point.y()};
+  for (size_t i = 0; i &lt; junction_num; ++i) {
+    if (junctions-&gt;at(i)-&gt;junction().type() == 5) {
+      Polygon2d polygon = junctions-&gt;at(i)-&gt;polygon();
+      if (polygon.IsPointIn(target_point)) {
+        *target_junction = junctions-&gt;at(i);
+        ADEBUG &lt;&lt; "car in the junction";
+        return true;
+      } else {
+        return false;
+      }
+    } else {
+      ADEBUG &lt;&lt; "No dead end junction";
+      return false;
+    }
+  }
+  return true;
+}
+
 // get origin from ADC
 void OpenSpaceRoiDecider::SetOriginFromADC(Frame *const frame,
                                            const hdmap::Path &amp;nearby_path) {
@@ -198,6 +279,20 @@ void OpenSpaceRoiDecider::SetOriginFromADC(Frame *const frame,
   frame-&gt;mutable_open_space_info()-&gt;mutable_origin_point()-&gt;set_y(left_top.y());
 }
 
+void OpenSpaceRoiDecider::SetDeadEndOrigin(
+  Frame* const frame,
+  const std::vector&lt;Vec2d&gt; &amp;dead_end_vertices) {
+  auto last_point = dead_end_vertices.back();
+  auto first_point = dead_end_vertices.front();
+  Vec2d heading_vec = last_point - first_point;
+  // set origin point
+  frame-&gt;mutable_open_space_info()-&gt;set_origin_heading(heading_vec.Angle());
+  frame-&gt;mutable_open_space_info()-&gt;
+    mutable_origin_point()-&gt;set_x(first_point.x());
+  frame-&gt;mutable_open_space_info()-&gt;
+    mutable_origin_point()-&gt;set_y(first_point.y());
+}
+
 void OpenSpaceRoiDecider::SetOrigin(
     Frame *const frame, const std::array&lt;common::math::Vec2d, 4&gt; &amp;vertices) {
   auto left_top = vertices[0];
@@ -210,8 +305,41 @@ void OpenSpaceRoiDecider::SetOrigin(
   frame-&gt;mutable_open_space_info()-&gt;mutable_origin_point()-&gt;set_y(left_top.y());
 }
 
+void OpenSpaceRoiDecider::SetDeadEndPose(
+  Frame* const frame,
+  const std::vector&lt;Vec2d&gt; &amp;dead_end_vertices) {
+  // the target point should be in the adjacent lanes based the map,
+  // curret map is rectangle, vertice is  anti-clockwise
+  auto *end_pose =
+      frame-&gt;mutable_open_space_info()-&gt;mutable_open_space_end_pose();
+  const auto&amp; target_point =
+      frame-&gt;local_view().routing-&gt;routing_request().
+      dead_end_info().target_point();
+  Vec2d end_point = {target_point.x(), target_point.y()};
+  // coordinate transfer
+  const auto &amp;origin_point = frame-&gt;open_space_info().origin_point();
+  const auto &amp;origin_heading = frame-&gt;open_space_info().origin_heading();
+  auto first_point = dead_end_vertices[0];
+  auto second_point = dead_end_vertices[1];
+  end_point -= origin_point;
+  end_point.SelfRotate(-origin_heading);
+  first_point -= origin_point;
+  first_point.SelfRotate(-origin_heading);
+  second_point -= origin_point;
+  second_point.SelfRotate(-origin_heading);
+  double parking_spot_heading = (first_point - second_point).Angle();
+  // set end point
+  end_pose-&gt;push_back(end_point.x());
+  end_pose-&gt;push_back(end_point.y());
+  end_pose-&gt;push_back(parking_spot_heading);
+  end_pose-&gt;push_back(0.0);
+}
+
 void OpenSpaceRoiDecider::SetParkingSpotEndPose(
     Frame *const frame, const std::array&lt;common::math::Vec2d, 4&gt; &amp;vertices) {
+  const auto &amp;routing_request =
+        frame-&gt;local_view().routing-&gt;routing_request();
+  auto plot_type = routing_request.parking_info().parking_space_type();
   auto left_top = vertices[0];
   auto left_down = vertices[1];
   auto right_down = vertices[2];
@@ -264,7 +392,14 @@ void OpenSpaceRoiDecider::SetParkingSpotEndPose(
                                parking_depth_buffer);
     }
   }
-
+  if (plot_type == ParkingSpaceType::PARALLEL_PARKING) {
+    double parllel_park_end_x_buffer =
+        config_.open_space_roi_decider_config().parallel_park_end_x_buffer();
+    parking_spot_heading = (left_down - right_down).Angle();
+    end_y = (left_top.y() + left_down.y()) / 2.0;
+    end_x = left_top.x() + vehicle_params_.back_edge_to_center() +
+      parllel_park_end_x_buffer;
+  }
   auto *end_pose =
       frame-&gt;mutable_open_space_info()-&gt;mutable_open_space_end_pose();
   end_pose-&gt;push_back(end_x);
@@ -677,6 +812,242 @@ void OpenSpaceRoiDecider::AddBoundaryKeyPoint(
   }
 }
 
+// only one lane one lane has one segment
+void OpenSpaceRoiDecider::GetInLaneEndPoint(LaneInfoConstPtr lane_info,
+                                           PointENU* left_boundary_point,
+                                           PointENU* right_boundary_point) {
+  const auto&amp; left_boundary_segment =
+    lane_info-&gt;lane().left_boundary().curve().segment();
+  const auto&amp; right_boundary_segment =
+    lane_info-&gt;lane().right_boundary().curve().segment();
+  size_t lane_points_num = left_boundary_segment[0].line_segment().point_size();
+  *left_boundary_point =
+    left_boundary_segment[0].line_segment().point(lane_points_num - 1);
+  *right_boundary_point =
+    right_boundary_segment[0].line_segment().point(lane_points_num - 1);
+}
+
+void OpenSpaceRoiDecider::GetOutLaneStartPoint(
+  LaneInfoConstPtr lane_info,
+  PointENU* left_boundary_point,
+  PointENU* right_boundary_point) {
+  const auto&amp; left_boundary_segment =
+    lane_info-&gt;lane().left_boundary().curve().segment();
+  const auto&amp; right_boundary_segment =
+    lane_info-&gt;lane().right_boundary().curve().segment();
+  *left_boundary_point =
+    left_boundary_segment[0].line_segment().point(0);
+  *right_boundary_point =
+    right_boundary_segment[0].line_segment().point(0);
+}
+
+void OpenSpaceRoiDecider::GetInLaneBoundaryPoints(LaneInfoConstPtr lane_info,
+                        const hdmap::Path &amp;nearby_path,
+                        std::vector&lt;PointENU&gt;* In_left_boundary_points,
+                        std::vector&lt;PointENU&gt;* In_right_boundary_points) {
+  const auto&amp; left_boundary_segment =
+    lane_info-&gt;lane().left_boundary().curve().segment();
+  const auto&amp; right_boundary_segment =
+    lane_info-&gt;lane().right_boundary().curve().segment();
+  size_t lane_points_num = left_boundary_segment[0].line_segment().point_size();
+  int temp_record_left = 0;
+  int temp_record_right = 0;
+  std::vector&lt;PointENU&gt; left_points, right_points;
+  for (size_t i = 0; i &lt; lane_points_num; ++i) {
+    left_points.push_back(left_boundary_segment[0].
+                          line_segment().point().at(i));
+    right_points.push_back(right_boundary_segment[0].
+                           line_segment().point().at(i));
+  }
+  // (to do): by s
+  for (size_t i = 0; i &lt; lane_points_num; ++i) {
+    if (left_points[i].x() &lt; temp_state_.x()) {
+      In_left_boundary_points-&gt;push_back(left_points[i]);
+      temp_record_left = i;
+    }
+    if (right_points[i].x() &lt; temp_state_.x()) {
+      In_right_boundary_points-&gt;push_back(right_points[i]);
+      temp_record_right = i;
+    }
+  }
+  // add one point, bigger than vehicle x
+  if (left_points[temp_record_left - 1].x() &gt; temp_state_.x()) {
+    In_left_boundary_points-&gt;push_back(left_points[temp_record_left - 1]);
+  }
+  if (right_points[temp_record_right - 1].x() &gt; temp_state_.x()) {
+    In_right_boundary_points-&gt;push_back(right_points[temp_record_right - 1]);
+  }
+  std::reverse(In_right_boundary_points-&gt;begin(),
+               In_right_boundary_points-&gt;end());
+}
+
+void OpenSpaceRoiDecider::GetOutLaneBoundaryPoints(
+  LaneInfoConstPtr lane_info,
+  const hdmap::Path &amp;nearby_path,
+  std::vector&lt;PointENU&gt;* Out_left_boundary_points,
+  std::vector&lt;PointENU&gt;* Out_right_boundary_points) {
+  const auto&amp; left_boundary_segment =
+    lane_info-&gt;lane().left_boundary().curve().segment();
+  const auto&amp; right_boundary_segment =
+    lane_info-&gt;lane().right_boundary().curve().segment();
+  size_t lane_points_num =
+    left_boundary_segment[0].line_segment().point_size();
+  int temp_record_left = 0;
+  int temp_record_right = 0;
+  std::vector&lt;PointENU&gt; left_points, right_points;
+  for (size_t i = 0; i &lt; lane_points_num; ++i) {
+    left_points.push_back(left_boundary_segment[0].
+                          line_segment().point().at(i));
+    right_points.push_back(right_boundary_segment[0].
+                          line_segment().point().at(i));
+  }
+  // (to do): by s
+  for (size_t i = 0; i &lt; lane_points_num; ++i) {
+    if (left_points[i].x() &lt; routing_target_point_.x()) {
+      Out_left_boundary_points-&gt;push_back(left_points[i]);
+      temp_record_left = i;
+    }
+    if (right_points[i].x() &lt; routing_target_point_.x()) {
+      Out_right_boundary_points-&gt;push_back(right_points[i]);
+      temp_record_right = i;
+    }
+  }
+  // add one point, bigger than vehicle x
+  if (left_points[temp_record_left + 1].x() &gt; routing_target_point_.x()) {
+    Out_left_boundary_points-&gt;push_back(left_points[temp_record_left + 1]);
+  }
+  if (right_points[temp_record_right + 1].x() &gt; routing_target_point_.x()) {
+    Out_right_boundary_points-&gt;push_back(right_points[temp_record_right + 1]);
+  }
+  std::reverse(Out_left_boundary_points-&gt;begin(),
+               Out_left_boundary_points-&gt;end());
+}
+
+bool OpenSpaceRoiDecider::GetDeadEndBoundary(
+  Frame* const frame, const std::vector&lt;Vec2d&gt; &amp;dead_end_vertices,
+  const hdmap::Path &amp;nearby_path,
+  std::vector&lt;std::vector&lt;common::math::Vec2d&gt;&gt; *const roi_deadend_boundary) {
+  size_t waypoint_num =
+    frame-&gt;local_view().routing-&gt;routing_request().waypoint().size();
+  routing_target_point_ = frame-&gt;local_view().routing-&gt;
+    routing_request().dead_end_info().target_point();
+  if (routing_in_flag_) {
+    routing_end_point_ = frame-&gt;local_view().routing-&gt;routing_request().
+                         waypoint().at(waypoint_num - 1).pose();
+    routing_in_flag_ = false;
+  }
+  double nearest_s = 0.0;
+  double nearest_l = 0.0;
+  LaneInfoConstPtr start_nearest_lane;
+  PointENU left_end_point, right_end_point;
+  hdmap_-&gt;GetNearestLane(routing_end_point_,
+    &amp;start_nearest_lane, &amp;nearest_s, &amp;nearest_l);
+  GetInLaneEndPoint(start_nearest_lane, &amp;left_end_point, &amp;right_end_point);
+
+  LaneInfoConstPtr end_nearest_lane;
+  PointENU left_start_point, right_start_point;
+  hdmap_-&gt;GetNearestLane(routing_target_point_,
+    &amp;end_nearest_lane, &amp;nearest_s, &amp;nearest_l);
+  GetOutLaneStartPoint(end_nearest_lane,
+                       &amp;left_start_point,
+                       &amp;right_start_point);
+
+  LaneInfoConstPtr car_lane;
+  PointENU car_pose;
+  car_pose.set_x(temp_state_.x());
+  car_pose.set_y(temp_state_.y());
+  hdmap_-&gt;GetNearestLane(car_pose, &amp;car_lane, &amp;nearest_s, &amp;nearest_l);
+  std::vector&lt;PointENU&gt; In_left_boundary_points;
+  std::vector&lt;PointENU&gt; In_right_boundary_points;
+  GetInLaneBoundaryPoints(car_lane, nearby_path,
+                          &amp;In_left_boundary_points,
+                          &amp;In_right_boundary_points);
+
+  LaneInfoConstPtr target_lane;
+  double out_routing_x = routing_target_point_.x() + FLAGS_buffer_out_routing;
+  routing_target_point_.set_x(out_routing_x);
+  hdmap_-&gt;GetNearestLane(routing_target_point_,
+                         &amp;target_lane,
+                         &amp;nearest_s,
+                         &amp;nearest_l);
+  std::vector&lt;PointENU&gt; Out_left_boundary_points;
+  std::vector&lt;PointENU&gt; Out_right_boundary_points;
+  GetOutLaneBoundaryPoints(target_lane,
+                           nearby_path,
+                           &amp;Out_left_boundary_points,
+                           &amp;Out_right_boundary_points);
+
+  std::vector&lt;Vec2d&gt; point_boundary;
+  for (size_t i = 0; i &lt; In_right_boundary_points.size(); ++i) {
+    point_boundary.push_back({In_right_boundary_points[i].x(),
+                              In_right_boundary_points[i].y()});
+  }
+  point_boundary.push_back({right_end_point.x(), right_end_point.y()});
+  for (size_t i = 0; i &lt; dead_end_vertices.size(); ++i) {
+    point_boundary.push_back(dead_end_vertices[i]);
+  }
+  point_boundary.push_back({right_start_point.x(), right_start_point.y()});
+  for (size_t i = 0; i &lt; Out_right_boundary_points.size(); ++i) {
+    point_boundary.push_back({Out_right_boundary_points[i].x(),
+                              Out_right_boundary_points[i].y()});
+  }
+  for (size_t i = 0; i &lt; Out_left_boundary_points.size(); ++i) {
+    point_boundary.push_back({Out_left_boundary_points[i].x(),
+                              Out_left_boundary_points[i].y()});
+  }
+  point_boundary.push_back({left_start_point.x(), left_start_point.y()});
+  point_boundary.push_back({left_end_point.x(), left_end_point.y()});
+  for (size_t i = 0; i &lt; In_left_boundary_points.size(); ++i) {
+    point_boundary.push_back({In_left_boundary_points[i].x(),
+                              In_left_boundary_points[i].y()});
+  }
+  point_boundary.push_back({In_right_boundary_points[0].x(),
+                            In_right_boundary_points[0].y()});
+  const auto &amp;origin_point = frame-&gt;open_space_info().origin_point();
+  const auto &amp;origin_heading = frame-&gt;open_space_info().origin_heading();
+
+  for (size_t i = 0; i &lt; point_boundary.size(); ++i) {
+    point_boundary[i] -= origin_point;
+    point_boundary[i].SelfRotate(-origin_heading);
+  }
+  // construct LineSegment
+  for (size_t i = 0; i &lt; point_boundary.size(); ++i) {
+    std::vector&lt;Vec2d&gt; segment{point_boundary[i],
+                               point_boundary[i + 1]};
+    roi_deadend_boundary-&gt;push_back(segment);
+  }
+  // Fuse line segments into convex contraints
+  if (!FuseLineSegments(roi_deadend_boundary)) {
+    AERROR &lt;&lt; "FuseLineSegments failed in parking ROI";
+    return false;
+  }
+  // Get xy boundary
+  auto xminmax = std::minmax_element(
+      point_boundary.begin(), point_boundary.end(),
+      [](const Vec2d &amp;a, const Vec2d &amp;b) { return a.x() &lt; b.x(); });
+  auto yminmax = std::minmax_element(
+      point_boundary.begin(), point_boundary.end(),
+      [](const Vec2d &amp;a, const Vec2d &amp;b) { return a.y() &lt; b.y(); });
+  std::vector&lt;double&gt; ROI_xy_boundary{xminmax.first-&gt;x(), xminmax.second-&gt;x(),
+                                      yminmax.first-&gt;y(), yminmax.second-&gt;y()};
+  auto *xy_boundary =
+      frame-&gt;mutable_open_space_info()-&gt;mutable_ROI_xy_boundary();
+  xy_boundary-&gt;assign(ROI_xy_boundary.begin(), ROI_xy_boundary.end());
+
+  Vec2d vehicle_xy = Vec2d(vehicle_state_.x(), vehicle_state_.y());
+  vehicle_xy -= origin_point;
+  vehicle_xy.SelfRotate(-origin_heading);
+
+  if (vehicle_xy.x() &lt; ROI_xy_boundary[0] ||
+      vehicle_xy.x() &gt; ROI_xy_boundary[1] ||
+      vehicle_xy.y() &lt; ROI_xy_boundary[2] ||
+      vehicle_xy.y() &gt; ROI_xy_boundary[3]) {
+    ADEBUG &lt;&lt; "vehicle outside of xy boundary of parking ROI";
+    return false;
+  }
+  return true;
+}
+
 bool OpenSpaceRoiDecider::GetParkingBoundary(
     Frame *const frame, const std::array&lt;Vec2d, 4&gt; &amp;vertices,
     const hdmap::Path &amp;nearby_path,
@@ -743,6 +1114,7 @@ bool OpenSpaceRoiDecider::GetParkingBoundary(
 
   // If smaller than zero, the parking spot is on the right of the lane
   // Left, right, down or opposite of the boundary is decided when viewing the
+
   // parking spot upward
   const double average_l = (left_top_l + right_top_l) / 2.0;
   std::vector&lt;Vec2d&gt; boundary_points;
@@ -754,6 +1126,7 @@ bool OpenSpaceRoiDecider::GetParkingBoundary(
     // lane boundary and assume that the lane half width is average_l
     ADEBUG &lt;&lt; "average_l is less than 0 in OpenSpaceROI";
     size_t point_size = right_lane_boundary.size();
+
     for (size_t i = 0; i &lt; point_size; i++) {
       right_lane_boundary[i].SelfRotate(origin_heading);
       right_lane_boundary[i] += origin_point;
@@ -767,12 +1140,14 @@ bool OpenSpaceRoiDecider::GetParkingBoundary(
 
     auto point_left_to_left_top_connor_s = std::lower_bound(
         center_lane_s_right.begin(), center_lane_s_right.end(), left_top_s);
+
     size_t point_left_to_left_top_connor_index = std::distance(
         center_lane_s_right.begin(), point_left_to_left_top_connor_s);
     point_left_to_left_top_connor_index =
         point_left_to_left_top_connor_index == 0
             ? point_left_to_left_top_connor_index
             : point_left_to_left_top_connor_index - 1;
+
     auto point_left_to_left_top_connor_itr =
         right_lane_boundary.begin() + point_left_to_left_top_connor_index;
     auto point_right_to_right_top_connor_s = std::upper_bound(
@@ -1186,9 +1561,27 @@ bool OpenSpaceRoiDecider::GetParkAndGoBoundary(
   return true;
 }
 
+bool OpenSpaceRoiDecider::GetDeadEndSpot(
+  Frame *const frame,
+  JunctionInfoConstPtr* junction,
+  std::vector&lt;Vec2d&gt;* dead_end_vertices) {
+  if (frame == nullptr) {
+    ADEBUG &lt;&lt; "Invalid frame, fail to GetDeadEndSpotFromMap from frame. ";
+    return false;
+  }
+  auto &amp;junction_point = (*junction)-&gt;polygon().points();
+  for (size_t i = 0; i &lt; junction_point.size(); ++i) {
+    (*dead_end_vertices).push_back(junction_point.at(i));
+  }
+  return true;
+}
+
 bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
                                          std::array&lt;Vec2d, 4&gt; *vertices,
                                          Path *nearby_path) {
+  const auto &amp;routing_request =
+        frame-&gt;local_view().routing-&gt;routing_request();
+  auto plot_type = routing_request.parking_info().parking_space_type();
   if (frame == nullptr) {
     AERROR &lt;&lt; "Invalid frame, fail to GetParkingSpotFromMap from frame. ";
     return false;
@@ -1240,6 +1633,17 @@ bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
           LaneSegment(next_lane, next_lane-&gt;accumulate_s().front(),
                       next_lane-&gt;accumulate_s().back());
       segments_vector.push_back(next_lanesegment);
+      size_t succeed_lanes_num = next_lane-&gt;lane().successor_id_size();
+      if (succeed_lanes_num != 0) {
+        for (size_t j = 0; j &lt; succeed_lanes_num; j++) {
+          auto succeed_lane_id = next_lane-&gt;lane().successor_id(j);
+          auto succeed_lane = hdmap_-&gt;GetLaneById(succeed_lane_id);
+          LaneSegment succeed_lanesegment =
+            LaneSegment(succeed_lane, succeed_lane-&gt;accumulate_s().front(),
+                        succeed_lane-&gt;accumulate_s().back());
+            segments_vector.push_back(succeed_lanesegment);
+        }
+      }
       *nearby_path = Path(segments_vector);
       SearchTargetParkingSpotOnPath(*nearby_path, &amp;target_parking_spot);
       if (target_parking_spot != nullptr) {
@@ -1258,7 +1662,7 @@ bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
     return false;
   }
 
-  if (!CheckDistanceToParkingSpot(*nearby_path, target_parking_spot)) {
+  if (!CheckDistanceToParkingSpot(frame, *nearby_path, target_parking_spot)) {
     AERROR &lt;&lt; "target parking spot found, but too far, distance larger than "
               "pre-defined distance";
     return false;
@@ -1270,7 +1674,28 @@ bool OpenSpaceRoiDecider::GetParkingSpot(Frame *const frame,
   Vec2d left_down = target_parking_spot-&gt;polygon().points().at(0);
   Vec2d right_down = target_parking_spot-&gt;polygon().points().at(1);
   Vec2d right_top = target_parking_spot-&gt;polygon().points().at(2);
-
+  if (plot_type == ParkingSpaceType::PARALLEL_PARKING) {
+    const auto &amp;routing_request =
+      frame-&gt;local_view().routing-&gt;routing_request();
+    auto corner_point =
+        routing_request.parking_info().corner_point();
+    left_top.set_x(corner_point.point().at(3).x());
+    left_top.set_y(corner_point.point().at(3).y());
+    left_down.set_x(corner_point.point().at(0).x());
+    left_down.set_y(corner_point.point().at(0).y());
+    right_down.set_x(corner_point.point().at(1).x());
+    right_down.set_y(corner_point.point().at(1).y());
+    right_top.set_x(corner_point.point().at(2).x());
+    right_top.set_y(corner_point.point().at(2).y());
+    double extend_right_x_buffer =
+      config_.open_space_roi_decider_config().extend_right_x_buffer();
+    double extend_left_x_buffer =
+      config_.open_space_roi_decider_config().extend_left_x_buffer();
+    right_top.set_x(right_top.x() + extend_right_x_buffer);
+    left_top.set_x(left_top.x() - extend_left_x_buffer);
+    left_down.set_x(left_down.x() - extend_left_x_buffer);
+    right_down.set_x(right_down.x() + extend_right_x_buffer);
+  }
   std::array&lt;Vec2d, 4&gt; parking_vertices{left_top, left_down, right_down,
                                         right_top};
 
@@ -1354,10 +1779,19 @@ void OpenSpaceRoiDecider::SearchTargetParkingSpotOnPath(
 }
 
 bool OpenSpaceRoiDecider::CheckDistanceToParkingSpot(
+    Frame *const frame,
     const hdmap::Path &amp;nearby_path,
     const hdmap::ParkingSpaceInfoConstPtr &amp;target_parking_spot) {
+  const auto &amp;routing_request =
+      frame-&gt;local_view().routing-&gt;routing_request();
+  auto corner_point =
+      routing_request.parking_info().corner_point();
   Vec2d left_bottom_point = target_parking_spot-&gt;polygon().points().at(0);
   Vec2d right_bottom_point = target_parking_spot-&gt;polygon().points().at(1);
+  left_bottom_point.set_x(corner_point.point().at(0).x());
+  left_bottom_point.set_y(corner_point.point().at(0).y());
+  right_bottom_point.set_x(corner_point.point().at(1).x());
+  right_bottom_point.set_y(corner_point.point().at(1).y());
   double left_bottom_point_s = 0.0;
   double left_bottom_point_l = 0.0;
   double right_bottom_point_s = 0.0;
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.h" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.h" added_lines="45" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /******************************************************************************
- * Copyright 2019 The Apollo Authors. All Rights Reserved.
+ * Copyright 2021 The Apollo Authors. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -32,6 +32,7 @@
 #include "modules/common/math/vec2d.h"
 #include "modules/common/vehicle_state/proto/vehicle_state.pb.h"
 #include "modules/common/vehicle_state/vehicle_state_provider.h"
+#include "modules/dreamview/backend/map/map_service.h"
 #include "modules/map/hdmap/hdmap_util.h"
 #include "modules/map/pnc_map/path.h"
 #include "modules/map/pnc_map/pnc_map.h"
@@ -53,6 +54,40 @@ class OpenSpaceRoiDecider : public Decider {
   apollo::common::Status Process(Frame *frame) override;
 
  private:
+  static bool SelectTargetDeadEndJunction(
+        std::vector&lt;hdmap::JunctionInfoConstPtr&gt;* junctions,
+        const apollo::common::PointENU&amp; dead_end_point,
+        hdmap::JunctionInfoConstPtr* target_junction);
+  bool GetDeadEndSpot(Frame *const frame,
+                      hdmap::JunctionInfoConstPtr* junction,
+                      std::vector&lt;common::math::Vec2d&gt;* dead_end_vertices);
+  void SetDeadEndOrigin(
+      Frame* const frame,
+      const std::vector&lt;common::math::Vec2d&gt; &amp;dead_end_vertices);
+  void SetDeadEndPose(
+      Frame* const frame,
+      const std::vector&lt;common::math::Vec2d&gt; &amp;dead_end_vertices);
+  bool GetDeadEndBoundary(
+    Frame* const frame,
+    const std::vector&lt;common::math::Vec2d&gt; &amp;dead_end_vertices,
+    const hdmap::Path &amp;nearby_path,
+    std::vector&lt;std::vector&lt;common::math::Vec2d&gt;&gt; *const roi_deadend_boundary);
+  void GetInLaneEndPoint(hdmap::LaneInfoConstPtr laneinfo,
+                         common::PointENU* left_end_point,
+                         common::PointENU* right_end_point);
+  void GetOutLaneStartPoint(hdmap::LaneInfoConstPtr laneinfo,
+                            common::PointENU* left_start_point,
+                            common::PointENU* right_start_point);
+  void GetInLaneBoundaryPoints(
+    hdmap::LaneInfoConstPtr lane_info,
+    const hdmap::Path &amp;nearby_path,
+    std::vector&lt;common::PointENU&gt;* In_left_boundary_points,
+    std::vector&lt;common::PointENU&gt;* In_right_boundary_points);
+  void GetOutLaneBoundaryPoints(
+    hdmap::LaneInfoConstPtr lane_info,
+    const hdmap::Path &amp;nearby_path,
+    std::vector&lt;common::PointENU&gt;* Out_left_boundary_points,
+    std::vector&lt;common::PointENU&gt;* Out_right_boundary_points);
   // @brief generate the path by vehicle location and return the target parking
   // spot on that path
   bool GetParkingSpot(Frame *const frame,
@@ -147,6 +182,7 @@ class OpenSpaceRoiDecider : public Decider {
 
   // @brief if not close enough to parking spot, return false
   bool CheckDistanceToParkingSpot(
+      Frame *const frame,
       const hdmap::Path &amp;nearby_path,
       const hdmap::ParkingSpaceInfoConstPtr &amp;target_parking_spot);
 
@@ -207,6 +243,14 @@ class OpenSpaceRoiDecider : public Decider {
   ThreadSafeIndexedObstacles *obstacles_by_frame_;
 
   common::VehicleState vehicle_state_;
+
+  common::VehicleParam vehicle_param_ =
+      common::VehicleConfigHelper::GetConfig().vehicle_param();
+  bool routing_in_flag_ = true;
+  common::PointENU dead_end_point_;
+  common::PointENU routing_end_point_;
+  common::VehicleState temp_state_;
+  common::PointENU routing_target_point_;
 };
 
 }  // namespace planning
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\path_lane_borrow_decider\path_lane_borrow_decider.cc" new_path="modules\planning\tasks\deciders\path_lane_borrow_decider\path_lane_borrow_decider.cc" added_lines="0" deleted_lines="1">
				<diff>@@ -291,7 +291,6 @@ void PathLaneBorrowDecider::CheckLaneBorrow(
     if (*left_neighbor_lane_borrowable) {
       lane_boundary_type = hdmap::LeftBoundaryType(waypoint);
       if (lane_boundary_type == hdmap::LaneBoundaryType::SOLID_YELLOW ||
-          lane_boundary_type == hdmap::LaneBoundaryType::DOUBLE_YELLOW ||
           lane_boundary_type == hdmap::LaneBoundaryType::SOLID_WHITE) {
         *left_neighbor_lane_borrowable = false;
       }
</diff>
			</file>
			<file old_path="modules\task_manager\common\task_manager_gflags.cc" new_path="modules\task_manager\common\task_manager_gflags.cc" added_lines="10" deleted_lines="0">
				<diff>@@ -21,3 +21,13 @@ DEFINE_string(task_manager_node_name, "task_manager", "the name for this node");
 DEFINE_double(threshold_for_destination_check, 1.0,
               "meters, which is 100 feet.  This threshold is used to check if"
               "the vehicle reaches the destination");
+
+DEFINE_double(plot_size_buffer, 0.2, "the size buffer of parking plot");
+
+DEFINE_double(road_width_buffer, 0.0, "the size buffer of road width");
+
+DEFINE_double(dead_end_destination_threshold, 0.01,
+              "the threshold is used to check to get the destination");
+
+DEFINE_double(search_junction_threshold, 1.0,
+              "the threshold is used to search junction a certain range");
</diff>
			</file>
			<file old_path="modules\task_manager\common\task_manager_gflags.h" new_path="modules\task_manager\common\task_manager_gflags.h" added_lines="8" deleted_lines="0">
				<diff>@@ -21,3 +21,11 @@
 DECLARE_string(task_manager_node_name);
 
 DECLARE_double(threshold_for_destination_check);
+
+DECLARE_double(plot_size_buffer);
+
+DECLARE_double(road_width_buffer);
+
+DECLARE_double(dead_end_destination_threshold);
+
+DECLARE_double(search_junction_threshold);
</diff>
			</file>
			<file old_path="modules\task_manager\conf\task_manager.conf" new_path="modules\task_manager\conf\task_manager.conf" added_lines="3" deleted_lines="0">
				<diff>@@ -1,2 +1,4 @@
 --flagfile=/apollo/modules/common/data/global_flagfile.txt
---threshold_for_destination_check=10.0
\ No newline at end of file
+--threshold_for_destination_check=10.0
+--plot_size_buffer=0.2
+--road_width_buffer=0.0
</diff>
			</file>
			<file old_path="modules\task_manager\cycle_routing_manager.cc" new_path="modules\task_manager\cycle_routing_manager.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -58,7 +58,7 @@ bool CycleRoutingManager::GetNewRouting(
   if (is_allowed_to_route_) {
     if (CheckPointDistanceInThreshold(begin_point_.pose(), pose.position(),
                                       FLAGS_threshold_for_destination_check)) {
-      AINFO &lt;&lt; "GetNewRouting: reach begin point"
+      AINFO &lt;&lt; "GetNewRouting: reach begin point."
             &lt;&lt; "Remaining cycles: " &lt;&lt; cycle_;
       new_routing_request-&gt;CopyFrom(original_routing_request_);
       auto cur_point = new_routing_request-&gt;mutable_waypoint(0);
@@ -74,7 +74,7 @@ bool CycleRoutingManager::GetNewRouting(
   } else {
     if (CheckPointDistanceInThreshold(end_point_.pose(), pose.position(),
                                       FLAGS_threshold_for_destination_check)) {
-      AINFO &lt;&lt; "GetNewRouting: reach end point"
+      AINFO &lt;&lt; "GetNewRouting: reach end point. "
             &lt;&lt; "Remaining cycles: " &lt;&lt; cycle_;
       new_routing_request-&gt;clear_waypoint();
       auto cur_point = new_routing_request-&gt;add_waypoint();
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.cc" new_path="modules\task_manager\task_manager_component.cc" added_lines="84" deleted_lines="13">
				<diff>@@ -16,7 +16,6 @@
 #include "modules/task_manager/task_manager_component.h"
 
 #include "modules/task_manager/proto/task_manager_config.pb.h"
-
 #include "cyber/time/rate.h"
 
 namespace apollo {
@@ -26,6 +25,8 @@ using apollo::cyber::ComponentBase;
 using apollo::cyber::Rate;
 using apollo::localization::LocalizationEstimate;
 using apollo::routing::RoutingRequest;
+using apollo::routing::RoutingResponse;
+using apollo::planning::ADCTrajectory;
 
 bool TaskManagerComponent::Init() {
   TaskManagerConfig task_manager_conf;
@@ -44,6 +45,14 @@ bool TaskManagerComponent::Init() {
         localization_.CopyFrom(*localization);
       });
 
+  response_reader_ = node_-&gt;CreateReader&lt;RoutingResponse&gt;(
+      task_manager_conf.topic_config().routing_response_topic(),
+      [this](const std::shared_ptr&lt;RoutingResponse&gt;&amp; response) {
+        ADEBUG &lt;&lt; "Received routing_response data: run response callback.";
+        std::lock_guard&lt;std::mutex&gt; lock(mutex_);
+        routing_response_.CopyFrom(*response);
+      });
+
   cyber::proto::RoleAttributes attr;
   attr.set_channel_name(
       task_manager_conf.topic_config().routing_request_topic());
@@ -58,26 +67,88 @@ bool TaskManagerComponent::Init() {
 }
 
 bool TaskManagerComponent::Proc(const std::shared_ptr&lt;Task&gt;&amp; task) {
-  task_name_ = task-&gt;task_name();
-  if (task-&gt;task_type() != CYCLE_ROUTING) {
-    AINFO &lt;&lt; "Task type is not cycle_routing.";
+  if (task-&gt;task_type() != CYCLE_ROUTING &amp;&amp;
+      task-&gt;task_type() != PARKING_ROUTING &amp;&amp;
+      task-&gt;task_type() != DEAD_END_ROUTING) {
+    AERROR &lt;&lt; "Task type is not cycle_routing or parking_routing.";
     return false;
   }
 
-  cycle_routing_manager_ = std::make_shared&lt;CycleRoutingManager&gt;();
-  cycle_routing_manager_-&gt;Init(task-&gt;cycle_routing_task());
-  routing_request_ = task-&gt;cycle_routing_task().routing_request();
-  Rate rate(1.0);
+  if (task-&gt;task_type() == CYCLE_ROUTING) {
+    cycle_routing_manager_ = std::make_shared&lt;CycleRoutingManager&gt;();
+    cycle_routing_manager_-&gt;Init(task-&gt;cycle_routing_task());
+    routing_request_ = task-&gt;cycle_routing_task().routing_request();
+    Rate rate(1.0);
 
-  while (cycle_routing_manager_-&gt;GetCycle() &gt; 0) {
-    if (cycle_routing_manager_-&gt;GetNewRouting(localization_.pose(),
-                                              &amp;routing_request_)) {
+    while (cycle_routing_manager_-&gt;GetCycle() &gt; 0) {
+      if (cycle_routing_manager_-&gt;GetNewRouting(localization_.pose(),
+                                                &amp;routing_request_)) {
+        auto last_routing_response_ = routing_response_;
+        common::util::FillHeader(node_-&gt;Name(), &amp;routing_request_);
+        request_writer_-&gt;Write(routing_request_);
+        AINFO &lt;&lt; "[TaskManagerComponent]Reach begin/end point: "
+              &lt;&lt; "routing manager send a routing request. ";
+        rate.Sleep();
+
+        if (!routing_response_.has_header()) {
+          AINFO &lt;&lt; "[TaskManagerComponent]routing failed";
+          return false;
+        }
+        if (last_routing_response_.has_header()) {
+          if (last_routing_response_.header().sequence_num() ==
+              routing_response_.header().sequence_num()) {
+            AINFO &lt;&lt; "[TaskManagerComponent]No routing response: "
+                  &lt;&lt; "new routing failed";
+            return false;
+          }
+        }
+      }
+      rate.Sleep();
+    }
+  } else if (task-&gt;task_type() == PARKING_ROUTING) {
+    AERROR &lt;&lt; "enter the parking routing task";
+    parking_routing_manager_ = std::make_shared&lt;ParkingRoutingManager&gt;();
+    parking_routing_manager_-&gt;Init(task-&gt;parking_routing_task());
+    routing_request_ = task-&gt;parking_routing_task().routing_request();
+    if (parking_routing_manager_-&gt;SizeVerification(
+            task-&gt;parking_routing_task()) &amp;&amp;
+        parking_routing_manager_-&gt;RoadWidthVerification(
+            task-&gt;parking_routing_task())) {
+      AERROR &lt;&lt; "compelet the Verification";
       common::util::FillHeader(node_-&gt;Name(), &amp;routing_request_);
       request_writer_-&gt;Write(routing_request_);
-      AINFO &lt;&lt; "[TaskManagerComponent]Reach begin/end point: "
-            &lt;&lt; "routing manager send a routing request. ";
+      AINFO &lt;&lt; "send a auto parking task";
+    } else {
+      auto last_routing_response_ = routing_response_;
+      if (!routing_response_.has_header()) {
+           AINFO &lt;&lt; "[TaskManagerComponent]parking routing failed";
+           return false;
+         }
+         if (last_routing_response_.has_header()) {
+           if (last_routing_response_.header().sequence_num() ==
+               routing_response_.header().sequence_num()) {
+             AINFO &lt;&lt; "[TaskManagerComponent]No parking routing response: "
+                   &lt;&lt; "new parking routing failed";
+             return false;
+           }
+         }
+      AERROR &lt;&lt; "plot verification failed, please select suitable plot!";
+      return false;
     }
+  } else if (task-&gt;task_type() == DEAD_END_ROUTING) {
+    dead_end_routing_manager_ = std::make_shared&lt;DeadEndRoutingManager&gt;();
+    dead_end_routing_manager_-&gt;Init(task-&gt;dead_end_routing_task());
+    routing_request_ = task-&gt;dead_end_routing_task().routing_request_in();
+    Rate rate(1.0);
+    while (dead_end_routing_manager_-&gt;GetNumber() &gt; 0) {
+      if (dead_end_routing_manager_-&gt;GetNewRouting(localization_.pose(),
+                                                   &amp;routing_request_)) {
+        common::util::FillHeader(node_-&gt;Name(), &amp;routing_request_);
+        request_writer_-&gt;Write(routing_request_);
+        rate.Sleep();
+      }
     rate.Sleep();
+    }
   }
   return true;
 }
</diff>
			</file>
			<file old_path="modules\task_manager\task_manager_component.h" new_path="modules\task_manager\task_manager_component.h" added_lines="9" deleted_lines="1">
				<diff>@@ -21,8 +21,10 @@
 
 #include "cyber/class_loader/class_loader.h"
 #include "cyber/component/component.h"
+#include "modules/planning/proto/planning.pb.h"
 #include "modules/task_manager/cycle_routing_manager.h"
-
+#include "modules/task_manager/parking_routing_manager.h"
+#include "modules/task_manager/dead_end_routing_manager.h"
 namespace apollo {
 namespace task_manager {
 
@@ -39,10 +41,16 @@ class TaskManagerComponent final : public cyber::Component&lt;task_manager::Task&gt; {
 
  private:
   std::shared_ptr&lt;cyber::Reader&lt;LocalizationEstimate&gt;&gt; localization_reader_;
+  std::shared_ptr&lt;cyber::Reader&lt;routing::RoutingResponse&gt;&gt; response_reader_;
+  std::shared_ptr&lt;cyber::Reader&lt;planning::ADCTrajectory&gt;&gt; trajectory_reader_;
   std::shared_ptr&lt;cyber::Writer&lt;routing::RoutingRequest&gt;&gt; request_writer_;
   std::shared_ptr&lt;CycleRoutingManager&gt; cycle_routing_manager_;
+  std::shared_ptr&lt;ParkingRoutingManager&gt; parking_routing_manager_;
+  std::shared_ptr&lt;DeadEndRoutingManager&gt; dead_end_routing_manager_;
   routing::RoutingRequest routing_request_;
+  routing::RoutingResponse routing_response_;
   LocalizationEstimate localization_;
+  apollo::planning::ADCTrajectory planning_;
   std::mutex mutex_;
   std::string task_name_;
 };
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="65042093236edeb51c7ec517192adf0278549f7b" author="haina0421">
		<msg>add howto docs for camera detector</msg>
		<modified_files>
			<file old_path="modules\perception\production\conf\perception\camera\smoke_detection_component.config" new_path="modules\perception\production\conf\perception\camera\smoke_detection_component.config" added_lines="1" deleted_lines="0">
				<diff>@@ -25,3 +25,4 @@ visual_camera : "front_6mm"
 write_visual_img : false
 enable_cipv : false
 debug_level : 0
+cipv : "Cipv"
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1858202c9f696e3da7dd94bc97b0bace9f513666" author="jiangjianan">
		<msg>prediction: enable jointly model</msg>
		<modified_files>
			<file old_path="modules\prediction\common\message_process.cc" new_path="modules\prediction\common\message_process.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -157,9 +157,6 @@ void MessageProcess::ContainerProcess(
   // Ignore some obstacles
   obstacles_prioritizer.AssignIgnoreLevel();
 
-  // Add interactive tag
-  interaction_filter.AssignInteractiveTag();
-
   // Scenario analysis
   scenario_manager-&gt;Run(container_manager.get());
 
@@ -177,6 +174,9 @@ void MessageProcess::ContainerProcess(
   // Assign CautionLevel for obstacles
   obstacles_prioritizer.AssignCautionLevel();
 
+  // Add interactive tag
+  interaction_filter.AssignInteractiveTag();  
+
   // Analyze RightOfWay for the caution obstacles
   RightOfWay::Analyze(container_manager.get());
 }
</diff>
			</file>
			<file old_path="modules\prediction\common\prediction_gflags.cc" new_path="modules\prediction\common\prediction_gflags.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -58,7 +58,7 @@ DEFINE_double(surrounding_lane_search_radius, 3.0,
 
 // Semantic Map
 DEFINE_double(base_image_half_range, 100.0, "The half range of base image.");
-DEFINE_bool(enable_draw_adc_trajectory, false,
+DEFINE_bool(enable_draw_adc_trajectory, true,
             "If draw adc trajectory in semantic map");
 DEFINE_bool(img_show_semantic_map, false, "If show the image of semantic map.");
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ff2a835edb088d301004d3b4fd09367b3b4f70b4" author="jiangjianan">
		<msg>prediction: modified vectornet evaluator and add interaction model docs</msg>
		<modified_files>
			<file old_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" added_lines="68" deleted_lines="70">
				<diff>@@ -69,32 +69,6 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
     return false;
   }
 
-  // Process target obs pos_history
-  torch::Tensor target_obstacle_pos = torch::zeros({20, 2});
-  torch::Tensor target_obstacle_pos_step = torch::zeros({20, 2});
-  for (int i = 0; i &lt; 20; ++i) {
-    target_obstacle_pos[19 - i][0] = target_pos_history[i].first;
-    target_obstacle_pos[19 - i][1] = target_pos_history[i].second;
-    if (i == 19 || (i &gt; 0 &amp;&amp; target_pos_history[i].first == 0.0)) {
-      break;
-    }
-    target_obstacle_pos_step[19 - i][0] =
-        target_pos_history[i].first - target_pos_history[i + 1].first;
-    target_obstacle_pos_step[19 - i][1] =
-        target_pos_history[i].second - target_pos_history[i + 1].second;
-  }
-
-  // Process all obs pos_history
-  int obs_num =
-      obstacles_container-&gt;curr_frame_considered_obstacle_ids().size();
-  torch::Tensor all_obstacle_pos = torch::zeros({obs_num, 20, 2});
-  for (int i = 0; i &lt; obs_num; ++i) {
-    for (int j = 0; j &lt; 20; ++j) {
-      all_obstacle_pos[i][19 - j][0] = all_obs_pos_history[i][j].first;
-      all_obstacle_pos[i][19 - j][1] = all_obs_pos_history[i][j].second;
-    }
-  }
-
   // Query the map data vector
   FeatureVector map_feature;
   PidVector map_p_id;
@@ -114,41 +88,87 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   auto end_time_query = std::chrono::system_clock::now();
   std::chrono::duration&lt;double&gt; diff_query = end_time_query - start_time_query;
   ADEBUG &lt;&lt; "vectors query used time: " &lt;&lt; diff_query.count() * 1000 &lt;&lt; " ms.";
+  
+  // Process all obs pos_history &amp; obs pid
+  auto start_time_data_prep = std::chrono::system_clock::now(); 
+  int obs_num =
+      obstacles_container-&gt;curr_frame_considered_obstacle_ids().size();
+  torch::Tensor target_obstacle_pos = torch::zeros({20, 2});
+  torch::Tensor target_obstacle_pos_step = torch::zeros({20, 2});      
+  torch::Tensor all_obstacle_pos = torch::zeros({obs_num, 20, 2});
+  torch::Tensor all_obs_p_id = torch::zeros({obs_num, 2});
+  for (int i = 0; i &lt; obs_num; ++i) {
+    std::vector&lt;double&gt; obs_p_id{std::numeric_limits&lt;float&gt;::max(),
+                              std::numeric_limits&lt;float&gt;::max()};
+    for (int j = 0; j &lt; 20; ++j) {  
+      // Process obs pid
+      if (obs_p_id[0] &gt; std::abs(all_obs_pos_history[i][j].first)) {
+        obs_p_id[0] = std::abs(all_obs_pos_history[i][j].first);
+        all_obs_p_id[i][0] = obs_p_id[0];
+      }
+      if (obs_p_id[1] &gt; std::abs(all_obs_pos_history[i][j].second)) {
+        obs_p_id[1] = std::abs(all_obs_pos_history[i][j].second);
+        all_obs_p_id[i][1] = obs_p_id[1];
+      }
+      // Process obs pos history
+      target_obstacle_pos[19 - j][0] = target_pos_history[j].first;
+      target_obstacle_pos[19 - j][1] = target_pos_history[j].second;
+      all_obstacle_pos[i][19 - j][0] = all_obs_pos_history[i][j].first;
+      all_obstacle_pos[i][19 - j][1] = all_obs_pos_history[i][j].second;
+      if (j == 19 || (j &gt; 0 &amp;&amp; target_pos_history[j].first == 0.0)) {
+        break;
+      }
+      target_obstacle_pos_step[19 - j][0] =
+          target_pos_history[j].first - target_pos_history[j + 1].first;
+      target_obstacle_pos_step[19 - j][1] =
+          target_pos_history[j].second - target_pos_history[j + 1].second;     
+    }
+  }
 
-  auto start_time_data_prep = std::chrono::system_clock::now();
-
-  // Process mask &amp; p_id
+  // Process mask
   // process v_mask for obs
-  int obs_his_size = obstacle_ptr-&gt;history_size();
   torch::Tensor vector_mask = torch::zeros({450, 50});
-  for (int i = 0; i &lt; obs_num; ++i) {
-    if (obs_his_size &gt; 1 &amp;&amp; obs_his_size &lt;= 20) {
-      vector_mask.index_put_({i, torch::indexing::Slice(torch::indexing::None,
-                                                        -(obs_his_size - 1))},
-                             1);
-    } else if (obs_his_size &gt; 20) {
-      vector_mask.index_put_(
-          {i, torch::indexing::Slice(torch::indexing::None, -19)}, 1);
+  int obs_count = 0;
+  for (int id : obstacles_container-&gt;curr_frame_considered_obstacle_ids()) {
+    Obstacle* obstacle = obstacles_container-&gt;GetObstacle(id);
+    int obs_his_size =
+        (obstacle-&gt;history_size() &lt;= 20) ? obstacle-&gt;history_size() : 20;
+    if (obs_his_size &gt; 0) {
+      vector_mask.index_put_({obs_count, torch::indexing::Slice(torch::indexing::None,
+                                                        -(obs_his_size))}, 1);
     } else {
-      vector_mask.index_put_(
-          {i, torch::indexing::Slice(torch::indexing::None, -1)}, 1);
+      vector_mask.index_put_({obs_count, torch::indexing::Slice()}, 1);
     }
+    ++obs_count;
   }
 
-  // process map data &amp; v_mask for map polyline
+  // process map data &amp; map p id &amp; v_mask for map polyline
   int map_polyline_num = map_feature.size();
-  for (int i = obs_num; i &lt;= map_polyline_num; ++i) {
-    int one_polyline_vector_num = map_feature[i].size();
+  int data_length = 
+      ((obs_num + map_polyline_num) &lt; 450) ? (obs_num + map_polyline_num) : 450;
+  for (int i = obs_num; i &lt; data_length; ++i) {
+    int one_polyline_vector_size = map_feature[i].size();
+    int one_polyline_vector_num = std::abs(one_polyline_vector_size);
+    if (one_polyline_vector_size &lt; 0) {
+      vector_mask.index_put_({i, torch::indexing::Slice()}, 1);
+      continue;
+    }
     if (one_polyline_vector_num &lt; 50) {
       vector_mask.index_put_({i, torch::indexing::Slice(one_polyline_vector_num,
                                                         torch::indexing::None)},
                              1);
     }
   }
-
   torch::Tensor map_data = torch::zeros({map_polyline_num, 50, 9});
+  torch::Tensor all_map_p_id = torch::zeros({map_polyline_num, 2});
   for (int i = 0; i &lt; map_polyline_num &amp;&amp; i &lt; 450; ++i) {
-    int one_polyline_vector_num = map_feature[i].size();
+    all_map_p_id[i][0] = map_p_id[i][0];
+    all_map_p_id[i][1] = map_p_id[i][1];
+    int one_polyline_vector_size = map_feature[i].size();
+    if (one_polyline_vector_size &lt; 0) {
+      continue;
+    }
+    int one_polyline_vector_num = std::abs(one_polyline_vector_size);
     for (int j = 0; j &lt; one_polyline_vector_num &amp;&amp; j &lt; 50; ++j) {
       map_data.index_put_({i, j},
                           torch::from_blob(map_feature[i][j].data(), {9}));
@@ -157,35 +177,11 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
 
   // process p mask
   torch::Tensor polyline_mask = torch::zeros({450});
-  int data_length = obs_num + map_polyline_num;
   if (data_length &lt; 450) {
     polyline_mask.index_put_(
         {torch::indexing::Slice(data_length, torch::indexing::None)}, 1);
   }
 
-  // process p_id for obs and map p_id
-  torch::Tensor all_obs_p_id = torch::zeros({obs_num, 2});
-  torch::Tensor all_map_p_id = torch::zeros({map_polyline_num, 2});
-  for (int i = 0; i &lt; obs_num; ++i) {
-    std::vector&lt;double&gt; obs_p_id{std::numeric_limits&lt;float&gt;::max(),
-                                 std::numeric_limits&lt;float&gt;::max()};
-    for (int j = 0; j &lt; obs_his_size &amp;&amp; j &lt; 20; ++j) {
-      if (obs_p_id[0] &gt; obstacle_ptr-&gt;latest_feature().position().x()) {
-        obs_p_id[0] = obstacle_ptr-&gt;latest_feature().position().x();
-        all_obs_p_id[i][0] = obs_p_id[0];
-      }
-      if (obs_p_id[1] &gt; obstacle_ptr-&gt;latest_feature().position().y()) {
-        obs_p_id[1] = obstacle_ptr-&gt;latest_feature().position().y();
-        all_obs_p_id[i][1] = obs_p_id[1];
-      }
-    }
-  }
-
-  for (int i = 0; i &lt; map_polyline_num; ++i) {
-    all_map_p_id[i][0] = map_p_id[i][0];
-    all_map_p_id[i][1] = map_p_id[i][1];
-  }
-
   // Extend obs data to specific dimension
   torch::Tensor obs_pos_data = torch::cat(
       {all_obstacle_pos.index(
@@ -406,9 +402,11 @@ void VectornetEvaluator::LoadModel() {
        std::move(vector_data.to(device_)), std::move(vector_mask.to(device_)),
        std::move(polyline_mask.to(device_)), std::move(rand_mask.to(device_)),
        std::move(polyline_id.to(device_))}));
-  // Run one inference to avoid very slow first inference later
+  // Run inference twice to avoid very slow first inference later
   torch_default_output_tensor_ =
       torch_vehicle_model_.forward(torch_inputs).toTensor().to(torch::kCPU);
+  torch_default_output_tensor_ =
+      torch_vehicle_model_.forward(torch_inputs).toTensor().to(torch::kCPU);      
 }
 
 }  // namespace prediction
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ba6ce2f430aa675c740174c73dc8998abe6e4983" author="jiangjianan">
		<msg>prediction: modified vectornet model inference</msg>
		<modified_files>
			<file old_path="modules\prediction\common\message_process.cc" new_path="modules\prediction\common\message_process.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -175,7 +175,7 @@ void MessageProcess::ContainerProcess(
   obstacles_prioritizer.AssignCautionLevel();
 
   // Add interactive tag
-  interaction_filter.AssignInteractiveTag();  
+  interaction_filter.AssignInteractiveTag();
 
   // Analyze RightOfWay for the caution obstacles
   RightOfWay::Analyze(container_manager.get());
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" added_lines="10" deleted_lines="9">
				<diff>@@ -88,19 +88,19 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   auto end_time_query = std::chrono::system_clock::now();
   std::chrono::duration&lt;double&gt; diff_query = end_time_query - start_time_query;
   ADEBUG &lt;&lt; "vectors query used time: " &lt;&lt; diff_query.count() * 1000 &lt;&lt; " ms.";
-  
+
   // Process all obs pos_history &amp; obs pid
-  auto start_time_data_prep = std::chrono::system_clock::now(); 
+  auto start_time_data_prep = std::chrono::system_clock::now();
   int obs_num =
       obstacles_container-&gt;curr_frame_considered_obstacle_ids().size();
   torch::Tensor target_obstacle_pos = torch::zeros({20, 2});
-  torch::Tensor target_obstacle_pos_step = torch::zeros({20, 2});      
+  torch::Tensor target_obstacle_pos_step = torch::zeros({20, 2});
   torch::Tensor all_obstacle_pos = torch::zeros({obs_num, 20, 2});
   torch::Tensor all_obs_p_id = torch::zeros({obs_num, 2});
   for (int i = 0; i &lt; obs_num; ++i) {
     std::vector&lt;double&gt; obs_p_id{std::numeric_limits&lt;float&gt;::max(),
                               std::numeric_limits&lt;float&gt;::max()};
-    for (int j = 0; j &lt; 20; ++j) {  
+    for (int j = 0; j &lt; 20; ++j) {
       // Process obs pid
       if (obs_p_id[0] &gt; std::abs(all_obs_pos_history[i][j].first)) {
         obs_p_id[0] = std::abs(all_obs_pos_history[i][j].first);
@@ -121,7 +121,7 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
       target_obstacle_pos_step[19 - j][0] =
           target_pos_history[j].first - target_pos_history[j + 1].first;
       target_obstacle_pos_step[19 - j][1] =
-          target_pos_history[j].second - target_pos_history[j + 1].second;     
+          target_pos_history[j].second - target_pos_history[j + 1].second;
     }
   }
 
@@ -134,8 +134,9 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
     int obs_his_size =
         (obstacle-&gt;history_size() &lt;= 20) ? obstacle-&gt;history_size() : 20;
     if (obs_his_size &gt; 0) {
-      vector_mask.index_put_({obs_count, torch::indexing::Slice(torch::indexing::None,
-                                                        -(obs_his_size))}, 1);
+      vector_mask.index_put_({obs_count,
+          torch::indexing::Slice(torch::indexing::None,
+                                -(obs_his_size))}, 1);
     } else {
       vector_mask.index_put_({obs_count, torch::indexing::Slice()}, 1);
     }
@@ -144,7 +145,7 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
 
   // process map data &amp; map p id &amp; v_mask for map polyline
   int map_polyline_num = map_feature.size();
-  int data_length = 
+  int data_length =
       ((obs_num + map_polyline_num) &lt; 450) ? (obs_num + map_polyline_num) : 450;
   for (int i = obs_num; i &lt; data_length; ++i) {
     int one_polyline_vector_size = map_feature[i].size();
@@ -406,7 +407,7 @@ void VectornetEvaluator::LoadModel() {
   torch_default_output_tensor_ =
       torch_vehicle_model_.forward(torch_inputs).toTensor().to(torch::kCPU);
   torch_default_output_tensor_ =
-      torch_vehicle_model_.forward(torch_inputs).toTensor().to(torch::kCPU);      
+      torch_vehicle_model_.forward(torch_inputs).toTensor().to(torch::kCPU);
 }
 
 }  // namespace prediction
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d33e1e410526b6f009f5fc7fdb82ebac71a3ddff" author="jiangjianan">
		<msg>Prediction: modified interaction model to integrate with vectornet &amp; link tech docs to prediction readme</msg>
		<modified_files>
			<file old_path="modules\prediction\evaluator\evaluator_manager.cc" new_path="modules\prediction\evaluator\evaluator_manager.cc" added_lines="1" deleted_lines="2">
				<diff>@@ -437,8 +437,7 @@ std::unique_ptr&lt;Evaluator&gt; EvaluatorManager::CreateEvaluator(
       break;
     }
     case ObstacleConf::JOINTLY_PREDICTION_PLANNING_EVALUATOR: {
-      evaluator_ptr.reset(new JointlyPredictionPlanningEvaluator(
-          semantic_map_.get()));
+      evaluator_ptr.reset(new JointlyPredictionPlanningEvaluator());
       break;
     }
     case ObstacleConf::VECTORNET_EVALUATOR: {
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.cc" added_lines="254" deleted_lines="61">
				<diff>@@ -16,6 +16,7 @@
 
 #include "modules/prediction/evaluator/vehicle/jointly_prediction_planning_evaluator.h"
 
+#include &lt;limits&gt;
 #include &lt;omp.h&gt;
 
 #include "Eigen/Dense"
@@ -33,10 +34,10 @@ namespace prediction {
 using apollo::common::TrajectoryPoint;
 using apollo::common::math::Vec2d;
 using apollo::common::math::InterpolateUsingLinearApproximation;
+using apollo::prediction::VectorNet;
 
-JointlyPredictionPlanningEvaluator::JointlyPredictionPlanningEvaluator(
-    SemanticMap* semantic_map)
-    : device_(torch::kCPU), semantic_map_(semantic_map) {
+JointlyPredictionPlanningEvaluator::JointlyPredictionPlanningEvaluator()
+    : device_(torch::kCPU) {
   evaluator_type_ = ObstacleConf::JOINTLY_PREDICTION_PLANNING_EVALUATOR;
   LoadModel();
 }
@@ -68,49 +69,193 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
   Feature* latest_feature_ptr = obstacle_ptr-&gt;mutable_latest_feature();
   CHECK_NOTNULL(latest_feature_ptr);
 
-  if (!FLAGS_enable_semantic_map) {
-    ADEBUG &lt;&lt; "Not enable semantic map, exit semantic_lstm_evaluator.";
-    return false;
-  }
-  cv::Mat feature_map;
-  if (!semantic_map_-&gt;GetMapById(id, &amp;feature_map)) {
-    return false;
-  }
   if (adc_trajectory_container == nullptr) {
     AERROR &lt;&lt; "Null adc trajectory container";
     return false;
   }
-  // Process the feature_map
-  cv::cvtColor(feature_map, feature_map, cv::COLOR_BGR2RGB);
-  cv::Mat img_float;
-  feature_map.convertTo(img_float, CV_32F, 1.0 / 255);
-  torch::Tensor img_tensor = torch::from_blob(img_float.data, {1, 224, 224, 3});
-  img_tensor = img_tensor.permute({0, 3, 1, 2});
-  img_tensor[0][0] = img_tensor[0][0].sub(0.485).div(0.229);
-  img_tensor[0][1] = img_tensor[0][1].sub(0.456).div(0.224);
-  img_tensor[0][2] = img_tensor[0][2].sub(0.406).div(0.225);
 
+  // obs data vector
   // Extract features of pos_history
-  std::vector&lt;std::pair&lt;double, double&gt;&gt; pos_history(20, {0.0, 0.0});
-  if (!ExtractObstacleHistory(obstacle_ptr, &amp;pos_history)) {
+  std::vector&lt;std::pair&lt;double, double&gt;&gt; target_pos_history(20, {0.0, 0.0});
+  std::vector&lt;std::pair&lt;double, double&gt;&gt; all_obs_length;
+  std::vector&lt;std::vector&lt;std::pair&lt;double, double&gt;&gt;&gt; all_obs_pos_history;
+  if (!ExtractObstaclesHistory(obstacle_ptr, obstacles_container,
+                               &amp;target_pos_history, &amp;all_obs_length,
+                               &amp;all_obs_pos_history)) {
     ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id &lt;&lt; "] failed to extract obstacle history";
     return false;
   }
-  // Process obstacle_history
-  torch::Tensor obstacle_pos = torch::zeros({1, 20, 2});
-  torch::Tensor obstacle_pos_step = torch::zeros({1, 20, 2});
-  for (int i = 0; i &lt; 20; ++i) {
-    obstacle_pos[0][19 - i][0] = pos_history[i].first;
-    obstacle_pos[0][19 - i][1] = pos_history[i].second;
-    if (i == 19 || (i &gt; 0 &amp;&amp; pos_history[i].first &lt; 1.0e-10)) {
-      break;
+
+  // Query the map data vector
+  FeatureVector map_feature;
+  PidVector map_p_id;
+  double pos_x = latest_feature_ptr-&gt;position().x();
+  double pos_y = latest_feature_ptr-&gt;position().y();
+  common::PointENU center_point;
+  center_point.set_x(pos_x);
+  center_point.set_y(pos_y);
+  double heading = latest_feature_ptr-&gt;velocity_heading();
+
+  auto start_time_query = std::chrono::system_clock::now();
+
+  if (!vector_net_.query(center_point, heading, &amp;map_feature, &amp;map_p_id)) {
+    return false;
+  }
+
+  auto end_time_query = std::chrono::system_clock::now();
+  std::chrono::duration&lt;double&gt; diff_query = end_time_query - start_time_query;
+  ADEBUG &lt;&lt; "vectors query used time: " &lt;&lt; diff_query.count() * 1000 &lt;&lt; " ms.";
+
+  // Process all obs pos_history &amp; obs pid
+  auto start_time_data_prep = std::chrono::system_clock::now();
+  int obs_num =
+      obstacles_container-&gt;curr_frame_considered_obstacle_ids().size();
+  torch::Tensor target_obstacle_pos = torch::zeros({20, 2});
+  torch::Tensor target_obstacle_pos_step = torch::zeros({20, 2});
+  torch::Tensor all_obstacle_pos = torch::zeros({obs_num, 20, 2});
+  torch::Tensor all_obs_p_id = torch::zeros({obs_num, 2});
+  for (int i = 0; i &lt; obs_num; ++i) {
+    std::vector&lt;double&gt; obs_p_id{std::numeric_limits&lt;float&gt;::max(),
+                              std::numeric_limits&lt;float&gt;::max()};
+    for (int j = 0; j &lt; 20; ++j) {
+      // Process obs pid
+      if (obs_p_id[0] &gt; std::abs(all_obs_pos_history[i][j].first)) {
+        obs_p_id[0] = std::abs(all_obs_pos_history[i][j].first);
+        all_obs_p_id[i][0] = obs_p_id[0];
+      }
+      if (obs_p_id[1] &gt; std::abs(all_obs_pos_history[i][j].second)) {
+        obs_p_id[1] = std::abs(all_obs_pos_history[i][j].second);
+        all_obs_p_id[i][1] = obs_p_id[1];
+      }
+      // Process obs pos history
+      target_obstacle_pos[19 - j][0] = target_pos_history[j].first;
+      target_obstacle_pos[19 - j][1] = target_pos_history[j].second;
+      all_obstacle_pos[i][19 - j][0] = all_obs_pos_history[i][j].first;
+      all_obstacle_pos[i][19 - j][1] = all_obs_pos_history[i][j].second;
+      if (j == 19 || (j &gt; 0 &amp;&amp; target_pos_history[j].first == 0.0)) {
+        break;
+      }
+      target_obstacle_pos_step[19 - j][0] =
+          target_pos_history[j].first - target_pos_history[j + 1].first;
+      target_obstacle_pos_step[19 - j][1] =
+          target_pos_history[j].second - target_pos_history[j + 1].second;
+    }
+  }
+
+  // Process mask
+  // process v_mask for obs
+  torch::Tensor vector_mask = torch::zeros({450, 50});
+  int obs_count = 0;
+  for (int id : obstacles_container-&gt;curr_frame_considered_obstacle_ids()) {
+    Obstacle* obstacle = obstacles_container-&gt;GetObstacle(id);
+    int obs_his_size =
+        (obstacle-&gt;history_size() &lt;= 20) ? obstacle-&gt;history_size() : 20;
+    if (obs_his_size &gt; 0) {
+      vector_mask.index_put_({obs_count,
+          torch::indexing::Slice(torch::indexing::None,
+                                -(obs_his_size))}, 1);
+    } else {
+      vector_mask.index_put_({obs_count, torch::indexing::Slice()}, 1);
+    }
+    ++obs_count;
+  }
+
+  // process map data &amp; map p id &amp; v_mask for map polyline
+  int map_polyline_num = map_feature.size();
+  int data_length =
+      ((obs_num + map_polyline_num) &lt; 450) ? (obs_num + map_polyline_num) : 450;
+  for (int i = obs_num; i &lt; data_length; ++i) {
+    int one_polyline_vector_size = map_feature[i].size();
+    int one_polyline_vector_num = std::abs(one_polyline_vector_size);
+    if (one_polyline_vector_size &lt; 0) {
+      vector_mask.index_put_({i, torch::indexing::Slice()}, 1);
+      continue;
+    }
+    if (one_polyline_vector_num &lt; 50) {
+      vector_mask.index_put_({i, torch::indexing::Slice(one_polyline_vector_num,
+                                                        torch::indexing::None)},
+                             1);
+    }
+  }
+  torch::Tensor map_data = torch::zeros({map_polyline_num, 50, 9});
+  torch::Tensor all_map_p_id = torch::zeros({map_polyline_num, 2});
+  for (int i = 0; i &lt; map_polyline_num &amp;&amp; i &lt; 450; ++i) {
+    all_map_p_id[i][0] = map_p_id[i][0];
+    all_map_p_id[i][1] = map_p_id[i][1];
+    int one_polyline_vector_size = map_feature[i].size();
+    if (one_polyline_vector_size &lt; 0) {
+      continue;
+    }
+    int one_polyline_vector_num = std::abs(one_polyline_vector_size);
+    for (int j = 0; j &lt; one_polyline_vector_num &amp;&amp; j &lt; 50; ++j) {
+      map_data.index_put_({i, j},
+                          torch::from_blob(map_feature[i][j].data(), {9}));
     }
-    obstacle_pos_step[0][19 - i][0] =
-        pos_history[i].first - pos_history[i + 1].first;
-    obstacle_pos_step[0][19 - i][1] =
-        pos_history[i].second - pos_history[i + 1].second;
   }
 
+  // process p mask
+  torch::Tensor polyline_mask = torch::zeros({450});
+  if (data_length &lt; 450) {
+    polyline_mask.index_put_(
+        {torch::indexing::Slice(data_length, torch::indexing::None)}, 1);
+  }
+
+  // Extend obs data to specific dimension
+  torch::Tensor obs_pos_data = torch::cat(
+      {all_obstacle_pos.index(
+           {torch::indexing::Slice(),
+            torch::indexing::Slice(torch::indexing::None, -1),
+            torch::indexing::Slice()}),
+       all_obstacle_pos.index({torch::indexing::Slice(),
+                               torch::indexing::Slice(1, torch::indexing::None),
+                               torch::indexing::Slice()})},
+      2);
+  // Add obs length
+  torch::Tensor obs_length_tmp = torch::zeros({obs_num, 2});
+  for (int i = 0; i &lt; obs_num; ++i) {
+    obs_length_tmp[i][0] = all_obs_length[i].first;
+    obs_length_tmp[i][1] = all_obs_length[i].second;
+  }
+  torch::Tensor obs_length = obs_length_tmp.unsqueeze(1).repeat({1, 19, 1});
+  // Add obs attribute
+  torch::Tensor obs_attr_agent =
+      torch::tensor({11.0, 4.0}).unsqueeze(0).unsqueeze(0).repeat({1, 19, 1});
+  torch::Tensor obs_attr_other =
+      torch::tensor({10.0, 4.0}).unsqueeze(0).unsqueeze(0).repeat(
+        {(obs_num - 1), 19, 1});
+  torch::Tensor obs_attr = torch::cat({obs_attr_agent, obs_attr_other}, 0);
+  // ADD obs id
+  torch::Tensor obs_id =
+      torch::arange(0, obs_num).unsqueeze(1).repeat({1, 19}).unsqueeze(2);
+  // Process obs data
+  torch::Tensor obs_data_with_len = torch::cat({obs_pos_data, obs_length}, 2);
+  torch::Tensor obs_data_with_attr =
+      torch::cat({obs_data_with_len, obs_attr}, 2);
+  torch::Tensor obs_data_with_id = torch::cat({obs_data_with_attr, obs_id}, 2);
+  torch::Tensor obs_data_final =
+      torch::cat({torch::zeros({obs_num, (50 - 19), 9}), obs_data_with_id}, 1);
+
+  // Extend data &amp; pid to specific demension
+  torch::Tensor data_tmp = torch::cat({obs_data_final, map_data}, 0);
+  torch::Tensor p_id_tmp = torch::cat({all_obs_p_id, all_map_p_id}, 0);
+  torch::Tensor vector_data;
+  torch::Tensor polyline_id;
+  if (data_length &lt; 450) {
+    torch::Tensor data_zeros = torch::zeros({(450 - data_length), 50, 9});
+    torch::Tensor p_id_zeros = torch::zeros({(450 - data_length), 2});
+    vector_data = torch::cat({data_tmp, data_zeros}, 0);
+    polyline_id = torch::cat({p_id_tmp, p_id_zeros}, 0);
+  } else {
+    vector_data = data_tmp;
+    polyline_id = p_id_tmp;
+  }
+
+  // Empty rand mask as placeholder
+  torch::Tensor rand_mask = torch::zeros({0});
+  // Change mask type to bool
+  auto bool_vector_mask = vector_mask.toType(at::kBool);
+  auto bool_polyline_mask = polyline_mask.toType(at::kBool);
+
   // Process ADC trajectory &amp; Extract features of ADC trajectory
   std::vector&lt;std::pair&lt;double, double&gt;&gt; adc_traj_curr_pos(30, {0.0, 0.0});
   torch::Tensor adc_trajectory = torch::zeros({1, 30, 6});
@@ -167,30 +312,37 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
 
   // Build input features for torch
   std::vector&lt;torch::jit::IValue&gt; torch_inputs;
-
   auto X_value = c10::ivalue::Tuple::create(
-      {std::move(img_tensor.to(device_)), std::move(obstacle_pos.to(device_)),
-       std::move(obstacle_pos_step.to(device_))});
+      {std::move(target_obstacle_pos.unsqueeze(0).to(device_)),
+       std::move(target_obstacle_pos_step.unsqueeze(0).to(device_)),
+       std::move(vector_data.unsqueeze(0).to(device_)),
+       std::move(bool_vector_mask.unsqueeze(0).to(device_)),
+       std::move(bool_polyline_mask.unsqueeze(0).to(device_)),
+       std::move(rand_mask.unsqueeze(0).to(device_)),
+       std::move(polyline_id.unsqueeze(0).to(device_))});
   torch_inputs.push_back(c10::ivalue::Tuple::create(
       {X_value, std::move(adc_trajectory.to(device_))}));
 
-  // Compute pred_traj
-  std::vector&lt;double&gt; pred_traj;
+  auto end_time_data_prep = std::chrono::system_clock::now();
+  std::chrono::duration&lt;double&gt; diff_data_prep =
+      end_time_data_prep - start_time_data_prep;
+  ADEBUG &lt;&lt; "vectornet input tensor prepration used time: "
+         &lt;&lt; diff_data_prep.count() * 1000 &lt;&lt; " ms.";
 
-  auto start_time = std::chrono::system_clock::now();
+  // Compute pred_traj
+  auto start_time_inference = std::chrono::system_clock::now();
   at::Tensor torch_output_tensor = torch_default_output_tensor_;
   torch_output_tensor =
       torch_vehicle_model_.forward(torch_inputs).toTensor().to(torch::kCPU);
 
-  auto end_time = std::chrono::system_clock::now();
-  std::chrono::duration&lt;double&gt; diff = end_time - start_time;
-  ADEBUG &lt;&lt; "Semantic_LSTM_evaluator used time: " &lt;&lt; diff.count() * 1000
+  auto end_time_inference = std::chrono::system_clock::now();
+  std::chrono::duration&lt;double&gt; diff_inference =
+      end_time_inference - start_time_inference;
+  ADEBUG &lt;&lt; "vectornet inference used time: " &lt;&lt; diff_inference.count() * 1000
          &lt;&lt; " ms.";
-  auto torch_output = torch_output_tensor.accessor&lt;float, 3&gt;();
 
   // Get the trajectory
-  double pos_x = latest_feature_ptr-&gt;position().x();
-  double pos_y = latest_feature_ptr-&gt;position().y();
+  auto torch_output = torch_output_tensor.accessor&lt;float, 3&gt;();
   Trajectory* trajectory = latest_feature_ptr-&gt;add_predicted_trajectory();
   trajectory-&gt;set_probability(1.0);
 
@@ -239,22 +391,54 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
   return true;
 }
 
-bool JointlyPredictionPlanningEvaluator::ExtractObstacleHistory(
-    Obstacle* obstacle_ptr,
-    std::vector&lt;std::pair&lt;double, double&gt;&gt;* pos_history) {
-  pos_history-&gt;resize(20, {0.0, 0.0});
+bool JointlyPredictionPlanningEvaluator::ExtractObstaclesHistory(
+    Obstacle* obstacle_ptr, ObstaclesContainer* obstacles_container,
+    std::vector&lt;std::pair&lt;double, double&gt;&gt;* target_pos_history,
+    std::vector&lt;std::pair&lt;double, double&gt;&gt;* all_obs_length,
+    std::vector&lt;std::vector&lt;std::pair&lt;double, double&gt;&gt;&gt;* all_obs_pos_history) {
   const Feature&amp; obs_curr_feature = obstacle_ptr-&gt;latest_feature();
   double obs_curr_heading = obs_curr_feature.velocity_heading();
   std::pair&lt;double, double&gt; obs_curr_pos = std::make_pair(
       obs_curr_feature.position().x(), obs_curr_feature.position().y());
+  // Extract target obstacle history
+  std::vector&lt;std::pair&lt;double, double&gt;&gt; tar_pos_his(20, {0.0, 0.0});
   for (std::size_t i = 0; i &lt; obstacle_ptr-&gt;history_size() &amp;&amp; i &lt; 20; ++i) {
-    const Feature&amp; feature = obstacle_ptr-&gt;feature(i);
-    if (!feature.IsInitialized()) {
+    const Feature&amp; target_feature = obstacle_ptr-&gt;feature(i);
+    if (!target_feature.IsInitialized()) {
       break;
     }
-    pos_history-&gt;at(i) = WorldCoordToObjCoord(
-        std::make_pair(feature.position().x(), feature.position().y()),
-        obs_curr_pos, obs_curr_heading);
+    tar_pos_his[i] =
+        WorldCoordToObjCoord(std::make_pair(target_feature.position().x(),
+                                            target_feature.position().y()),
+                             obs_curr_pos, obs_curr_heading);
+  }
+  all_obs_length-&gt;emplace_back(
+      std::make_pair(obs_curr_feature.length(), obs_curr_feature.width()));
+  all_obs_pos_history-&gt;emplace_back(tar_pos_his);
+  target_pos_history = &amp;tar_pos_his;
+
+  // Extract other obstacles &amp; convert pos to traget obstacle relative coord
+  std::vector&lt;std::pair&lt;double, double&gt;&gt; pos_history(20, {0.0, 0.0});
+  for (int id : obstacles_container-&gt;curr_frame_considered_obstacle_ids()) {
+    Obstacle* obstacle = obstacles_container-&gt;GetObstacle(id);
+    int target_id = obstacle_ptr-&gt;id();
+    if (id == target_id) {
+      continue;
+    }
+    const Feature&amp; other_obs_curr_feature = obstacle-&gt;latest_feature();
+    all_obs_length-&gt;emplace_back(std::make_pair(
+        other_obs_curr_feature.length(), other_obs_curr_feature.width()));
+
+    for (std::size_t i = 0; i &lt; obstacle-&gt;history_size() &amp;&amp; i &lt; 20; ++i) {
+      const Feature&amp; feature = obstacle-&gt;feature(i);
+      if (!feature.IsInitialized()) {
+        break;
+      }
+      pos_history[i] = WorldCoordToObjCoord(
+          std::make_pair(feature.position().x(), feature.position().y()),
+          obs_curr_pos, obs_curr_heading);
+    }
+    all_obs_pos_history-&gt;emplace_back(pos_history);
   }
   return true;
 }
@@ -296,18 +480,27 @@ void JointlyPredictionPlanningEvaluator::LoadModel() {
   torch::set_num_threads(1);
 
   // Fake intput for the first frame
-  torch::Tensor img_tensor = torch::zeros({1, 3, 224, 224});
-  torch::Tensor obstacle_pos = torch::zeros({1, 20, 2});
-  torch::Tensor obstacle_pos_step = torch::zeros({1, 20, 2});
+  torch::Tensor target_obstacle_pos = torch::zeros({1, 20, 2});
+  torch::Tensor target_obstacle_pos_step = torch::zeros({1, 20, 2});
+  torch::Tensor vector_data = torch::zeros({1, 450, 50, 9});
+  torch::Tensor vector_mask = torch::randn({1, 450, 50}) &gt; 0.9;
+  torch::Tensor polyline_mask = torch::randn({1, 450}) &gt; 0.9;
+  torch::Tensor rand_mask = torch::zeros({0});
+  torch::Tensor polyline_id = torch::zeros({1, 450, 2});
   torch::Tensor adc_trajectory = torch::zeros({1, 30, 6});
   std::vector&lt;torch::jit::IValue&gt; torch_inputs;
 
   auto X_value = c10::ivalue::Tuple::create(
-      {std::move(img_tensor.to(device_)), std::move(obstacle_pos.to(device_)),
-       std::move(obstacle_pos_step.to(device_))});
+      {std::move(target_obstacle_pos.to(device_)),
+       std::move(target_obstacle_pos_step.to(device_)),
+       std::move(vector_data.to(device_)), std::move(vector_mask.to(device_)),
+       std::move(polyline_mask.to(device_)), std::move(rand_mask.to(device_)),
+       std::move(polyline_id.to(device_))});
   torch_inputs.push_back(c10::ivalue::Tuple::create(
       {X_value, std::move(adc_trajectory.to(device_))}));
-  // Run one inference to avoid very slow first inference later
+  // Run inference twice to avoid very slow first inference later
+  torch_default_output_tensor_ =
+      torch_vehicle_model_.forward(torch_inputs).toTensor().to(torch::kCPU);
   torch_default_output_tensor_ =
       torch_vehicle_model_.forward(torch_inputs).toTensor().to(torch::kCPU);
 }
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.h" new_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.h" added_lines="10" deleted_lines="9">
				<diff>@@ -20,11 +20,11 @@
 #include &lt;utility&gt;
 #include &lt;vector&gt;
 
-#include "modules/prediction/common/semantic_map.h"
 #include "modules/prediction/evaluator/evaluator.h"
 #include "torch/extension.h"
 #include "torch/script.h"
 #include "modules/prediction/container/container_manager.h"
+#include "modules/prediction/pipeline/vector_net.h"
 
 namespace apollo {
 namespace prediction {
@@ -36,8 +36,7 @@ class JointlyPredictionPlanningEvaluator : public Evaluator {
   /**
    * @brief Constructor
    */
-  JointlyPredictionPlanningEvaluator() = delete;
-  explicit JointlyPredictionPlanningEvaluator(SemanticMap* semantic_map);
+  JointlyPredictionPlanningEvaluator();
 
   /**
    * @brief Destructor
@@ -69,13 +68,15 @@ class JointlyPredictionPlanningEvaluator : public Evaluator {
                 ObstaclesContainer* obstacles_container) override;
 
   /**
-   * @brief Extract obstacle history
-   * @param Obstacle pointer
+   * @brief Extract all obstacles history
+   * @param Obstacles container
    *        Feature container in a vector for receiving the obstacle history
    */
-  bool ExtractObstacleHistory(
-      Obstacle* obstacle_ptr,
-      std::vector&lt;std::pair&lt;double, double&gt;&gt;* pos_history);
+  bool ExtractObstaclesHistory(
+      Obstacle* obstacle_ptr, ObstaclesContainer* obstacles_container,
+      std::vector&lt;std::pair&lt;double, double&gt;&gt;* curr_pos_history,
+      std::vector&lt;std::pair&lt;double, double&gt;&gt;* all_obs_length,
+      std::vector&lt;std::vector&lt;std::pair&lt;double, double&gt;&gt;&gt;* all_obs_pos_history);
 
   /**
    * @brief Extract adc trajectory and convert world coord to obstacle coord
@@ -104,7 +105,7 @@ class JointlyPredictionPlanningEvaluator : public Evaluator {
   torch::jit::script::Module torch_vehicle_model_;
   at::Tensor torch_default_output_tensor_;
   torch::Device device_;
-  SemanticMap* semantic_map_;
+  VectorNet vector_net_;
 };
 
 }  // namespace prediction
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="116bb4f758e23cb0eb8cf046bf6e78a18a8366a1" author="jiangjianan">
		<msg>Prediction: merge jointly model from github to icode

Change-Id: I6a5e270275a0939d8399a98c86d247be105ef3eb</msg>
		<modified_files>
			<file old_path="modules\prediction\common\message_process.cc" new_path="modules\prediction\common\message_process.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -157,9 +157,6 @@ void MessageProcess::ContainerProcess(
   // Ignore some obstacles
   obstacles_prioritizer.AssignIgnoreLevel();
 
-  // Add interactive tag
-  interaction_filter.AssignInteractiveTag();
-
   // Scenario analysis
   scenario_manager-&gt;Run(container_manager.get());
 
@@ -177,6 +174,9 @@ void MessageProcess::ContainerProcess(
   // Assign CautionLevel for obstacles
   obstacles_prioritizer.AssignCautionLevel();
 
+  // Add interactive tag
+  interaction_filter.AssignInteractiveTag();
+
   // Analyze RightOfWay for the caution obstacles
   RightOfWay::Analyze(container_manager.get());
 }
</diff>
			</file>
			<file old_path="modules\prediction\common\prediction_gflags.cc" new_path="modules\prediction\common\prediction_gflags.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -58,7 +58,7 @@ DEFINE_double(surrounding_lane_search_radius, 3.0,
 
 // Semantic Map
 DEFINE_double(base_image_half_range, 100.0, "The half range of base image.");
-DEFINE_bool(enable_draw_adc_trajectory, false,
+DEFINE_bool(enable_draw_adc_trajectory, true,
             "If draw adc trajectory in semantic map");
 DEFINE_bool(img_show_semantic_map, false, "If show the image of semantic map.");
 
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\evaluator_manager.cc" new_path="modules\prediction\evaluator\evaluator_manager.cc" added_lines="1" deleted_lines="2">
				<diff>@@ -437,8 +437,7 @@ std::unique_ptr&lt;Evaluator&gt; EvaluatorManager::CreateEvaluator(
       break;
     }
     case ObstacleConf::JOINTLY_PREDICTION_PLANNING_EVALUATOR: {
-      evaluator_ptr.reset(new JointlyPredictionPlanningEvaluator(
-          semantic_map_.get()));
+      evaluator_ptr.reset(new JointlyPredictionPlanningEvaluator());
       break;
     }
     case ObstacleConf::VECTORNET_EVALUATOR: {
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.cc" added_lines="255" deleted_lines="61">
				<diff>@@ -16,6 +16,7 @@
 
 #include "modules/prediction/evaluator/vehicle/jointly_prediction_planning_evaluator.h"
 
+#include &lt;limits&gt;
 #include &lt;omp.h&gt;
 
 #include "Eigen/Dense"
@@ -33,10 +34,10 @@ namespace prediction {
 using apollo::common::TrajectoryPoint;
 using apollo::common::math::Vec2d;
 using apollo::common::math::InterpolateUsingLinearApproximation;
+using apollo::prediction::VectorNet;
 
-JointlyPredictionPlanningEvaluator::JointlyPredictionPlanningEvaluator(
-    SemanticMap* semantic_map)
-    : device_(torch::kCPU), semantic_map_(semantic_map) {
+JointlyPredictionPlanningEvaluator::JointlyPredictionPlanningEvaluator()
+    : device_(torch::kCPU) {
   evaluator_type_ = ObstacleConf::JOINTLY_PREDICTION_PLANNING_EVALUATOR;
   LoadModel();
 }
@@ -68,49 +69,182 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
   Feature* latest_feature_ptr = obstacle_ptr-&gt;mutable_latest_feature();
   CHECK_NOTNULL(latest_feature_ptr);
 
-  if (!FLAGS_enable_semantic_map) {
-    ADEBUG &lt;&lt; "Not enable semantic map, exit semantic_lstm_evaluator.";
-    return false;
-  }
-  cv::Mat feature_map;
-  if (!semantic_map_-&gt;GetMapById(id, &amp;feature_map)) {
-    return false;
-  }
   if (adc_trajectory_container == nullptr) {
     AERROR &lt;&lt; "Null adc trajectory container";
     return false;
   }
-  // Process the feature_map
-  cv::cvtColor(feature_map, feature_map, cv::COLOR_BGR2RGB);
-  cv::Mat img_float;
-  feature_map.convertTo(img_float, CV_32F, 1.0 / 255);
-  torch::Tensor img_tensor = torch::from_blob(img_float.data, {1, 224, 224, 3});
-  img_tensor = img_tensor.permute({0, 3, 1, 2});
-  img_tensor[0][0] = img_tensor[0][0].sub(0.485).div(0.229);
-  img_tensor[0][1] = img_tensor[0][1].sub(0.456).div(0.224);
-  img_tensor[0][2] = img_tensor[0][2].sub(0.406).div(0.225);
 
+  // obs data vector
   // Extract features of pos_history
-  std::vector&lt;std::pair&lt;double, double&gt;&gt; pos_history(20, {0.0, 0.0});
-  if (!ExtractObstacleHistory(obstacle_ptr, &amp;pos_history)) {
+  std::vector&lt;std::pair&lt;double, double&gt;&gt; target_pos_history(20, {0.0, 0.0});
+  std::vector&lt;std::pair&lt;double, double&gt;&gt; all_obs_length;
+  std::vector&lt;std::vector&lt;std::pair&lt;double, double&gt;&gt;&gt; all_obs_pos_history;
+  // Process mask
+  // process v_mask for obs
+  torch::Tensor vector_mask = torch::zeros({450, 50});
+
+  if (!ExtractObstaclesHistory(obstacle_ptr, obstacles_container,
+                               &amp;target_pos_history, &amp;all_obs_length,
+                               &amp;all_obs_pos_history, &amp;vector_mask)) {
     ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id &lt;&lt; "] failed to extract obstacle history";
     return false;
   }
-  // Process obstacle_history
-  torch::Tensor obstacle_pos = torch::zeros({1, 20, 2});
-  torch::Tensor obstacle_pos_step = torch::zeros({1, 20, 2});
-  for (int i = 0; i &lt; 20; ++i) {
-    obstacle_pos[0][19 - i][0] = pos_history[i].first;
-    obstacle_pos[0][19 - i][1] = pos_history[i].second;
-    if (i == 19 || (i &gt; 0 &amp;&amp; pos_history[i].first &lt; 1.0e-10)) {
+
+  // Query the map data vector
+  FeatureVector map_feature;
+  PidVector map_p_id;
+  double pos_x = latest_feature_ptr-&gt;position().x();
+  double pos_y = latest_feature_ptr-&gt;position().y();
+  common::PointENU center_point;
+  center_point.set_x(pos_x);
+  center_point.set_y(pos_y);
+  double heading = latest_feature_ptr-&gt;velocity_heading();
+
+  auto start_time_query = std::chrono::system_clock::now();
+
+  if (!vector_net_.query(center_point, heading, &amp;map_feature, &amp;map_p_id)) {
+    return false;
+  }
+
+  auto end_time_query = std::chrono::system_clock::now();
+  std::chrono::duration&lt;double&gt; diff_query = end_time_query - start_time_query;
+  ADEBUG &lt;&lt; "vectors query used time: " &lt;&lt; diff_query.count() * 1000 &lt;&lt; " ms.";
+
+  // Process all obs pos_history &amp; obs pid
+  auto start_time_data_prep = std::chrono::system_clock::now();
+  int obs_num =
+      obstacles_container-&gt;curr_frame_considered_obstacle_ids().size();
+  torch::Tensor target_obstacle_pos = torch::zeros({20, 2});
+  torch::Tensor target_obstacle_pos_step = torch::zeros({20, 2});
+  for (int j = 0; j &lt; 20; ++j) {
+    target_obstacle_pos[19 - j][0] = target_pos_history[j].first;
+    target_obstacle_pos[19 - j][1] = target_pos_history[j].second;
+    if (j == 19 || (j &gt; 0 &amp;&amp; target_pos_history[j + 1].first == 0.0)) {
       break;
     }
-    obstacle_pos_step[0][19 - i][0] =
-        pos_history[i].first - pos_history[i + 1].first;
-    obstacle_pos_step[0][19 - i][1] =
-        pos_history[i].second - pos_history[i + 1].second;
+    target_obstacle_pos_step[19 - j][0] =
+        target_pos_history[j].first - target_pos_history[j + 1].first;
+    target_obstacle_pos_step[19 - j][1] =
+        target_pos_history[j].second - target_pos_history[j + 1].second;
+  }
+
+  torch::Tensor all_obstacle_pos = torch::zeros({obs_num, 20, 2});
+  torch::Tensor all_obs_p_id = torch::zeros({obs_num, 2});
+  for (int i = 0; i &lt; obs_num; ++i) {
+    std::vector&lt;double&gt; obs_p_id{std::numeric_limits&lt;float&gt;::max(),
+                              std::numeric_limits&lt;float&gt;::max()};
+    for (int j = 0; j &lt; 20; ++j) {
+      // Process obs pid
+      if (obs_p_id[0] &gt; all_obs_pos_history[i][j].first) {
+        obs_p_id[0] = all_obs_pos_history[i][j].first;
+      }
+      if (obs_p_id[1] &gt; all_obs_pos_history[i][j].second) {
+        obs_p_id[1] = all_obs_pos_history[i][j].second;
+      }
+      // Process obs pos history
+      all_obstacle_pos[i][19 - j][0] = all_obs_pos_history[i][j].first;
+      all_obstacle_pos[i][19 - j][1] = all_obs_pos_history[i][j].second;
+    }
+    all_obs_p_id[i][0] = obs_p_id[0];
+    all_obs_p_id[i][1] = obs_p_id[1];
+  }
+
+  // process map data &amp; map p id &amp; v_mask for map polyline
+  int map_polyline_num = map_feature.size();
+  int data_length =
+      ((obs_num + map_polyline_num) &lt; 450) ? (obs_num + map_polyline_num) : 450;
+  for (int i = 0; i &lt; map_polyline_num &amp;&amp; obs_num + i &lt; 450; ++i) {
+    size_t one_polyline_vector_size = map_feature[i].size();
+    if (one_polyline_vector_size &lt; 50) {
+      vector_mask.index_put_({obs_num + i,
+                             torch::indexing::Slice(one_polyline_vector_size,
+                                                    torch::indexing::None)},
+                             1);
+    }
+  }
+
+  torch::Tensor map_data = torch::zeros({map_polyline_num, 50, 9});
+  torch::Tensor all_map_p_id = torch::zeros({map_polyline_num, 2});
+  auto opts = torch::TensorOptions().dtype(torch::kDouble);
+
+  for (int i = 0; i &lt; map_polyline_num &amp;&amp; i + obs_num &lt; 450; ++i) {
+    all_map_p_id[i][0] = map_p_id[i][0];
+    all_map_p_id[i][1] = map_p_id[i][1];
+
+    int one_polyline_vector_size = map_feature[i].size();
+    for (int j = 0; j &lt; one_polyline_vector_size &amp;&amp; j &lt; 50; ++j) {
+      map_data.index_put_({i, j},
+                          torch::from_blob(map_feature[i][j].data(),
+                          {9}, opts));
+    }
+  }
+  map_data = map_data.toType(at::kFloat);
+
+  // process p mask
+  torch::Tensor polyline_mask = torch::zeros({450});
+  if (data_length &lt; 450) {
+    polyline_mask.index_put_(
+        {torch::indexing::Slice(data_length, torch::indexing::None)}, 1);
   }
 
+  // Extend obs data to specific dimension
+  torch::Tensor obs_pos_data = torch::cat(
+      {all_obstacle_pos.index(
+           {torch::indexing::Slice(),
+            torch::indexing::Slice(torch::indexing::None, -1),
+            torch::indexing::Slice()}),
+       all_obstacle_pos.index({torch::indexing::Slice(),
+                               torch::indexing::Slice(1, torch::indexing::None),
+                               torch::indexing::Slice()})},
+      2);
+  // Add obs length
+  torch::Tensor obs_length_tmp = torch::zeros({obs_num, 2});
+  for (int i = 0; i &lt; obs_num; ++i) {
+    obs_length_tmp[i][0] = all_obs_length[i].first;
+    obs_length_tmp[i][1] = all_obs_length[i].second;
+  }
+  torch::Tensor obs_length = obs_length_tmp.unsqueeze(1).repeat({1, 19, 1});
+  // Add obs attribute
+  torch::Tensor obs_attr_agent =
+      torch::tensor({11.0, 4.0}).unsqueeze(0).unsqueeze(0).repeat({1, 19, 1});
+  torch::Tensor obs_attr_other =
+      torch::tensor({10.0, 4.0}).unsqueeze(0).unsqueeze(0).repeat(
+        {(obs_num - 1), 19, 1});
+  torch::Tensor obs_attr = torch::cat({obs_attr_agent, obs_attr_other}, 0);
+  // ADD obs id
+  // add 500 to avoid same id as in map_info
+  torch::Tensor obs_id =
+      torch::arange(500, obs_num + 500).unsqueeze(1).repeat(
+        {1, 19}).unsqueeze(2);
+  // Process obs data
+  torch::Tensor obs_data_with_len = torch::cat({obs_pos_data, obs_length}, 2);
+  torch::Tensor obs_data_with_attr =
+      torch::cat({obs_data_with_len, obs_attr}, 2);
+  torch::Tensor obs_data_with_id = torch::cat({obs_data_with_attr, obs_id}, 2);
+  torch::Tensor obs_data_final =
+      torch::cat({torch::zeros({obs_num, (50 - 19), 9}), obs_data_with_id}, 1);
+
+  // Extend data &amp; pid to specific demension
+  torch::Tensor data_tmp = torch::cat({obs_data_final, map_data}, 0);
+  torch::Tensor p_id_tmp = torch::cat({all_obs_p_id, all_map_p_id}, 0);
+  torch::Tensor vector_data;
+  torch::Tensor polyline_id;
+  if (data_length &lt; 450) {
+    torch::Tensor data_zeros = torch::zeros({(450 - data_length), 50, 9});
+    torch::Tensor p_id_zeros = torch::zeros({(450 - data_length), 2});
+    vector_data = torch::cat({data_tmp, data_zeros}, 0);
+    polyline_id = torch::cat({p_id_tmp, p_id_zeros}, 0);
+  } else {
+    vector_data = data_tmp;
+    polyline_id = p_id_tmp;
+  }
+
+  // Empty rand mask as placeholder
+  auto rand_mask = torch::zeros({450}).toType(at::kBool);
+  // Change mask type to bool
+  auto bool_vector_mask = vector_mask.toType(at::kBool);
+  auto bool_polyline_mask = polyline_mask.toType(at::kBool);
+
   // Process ADC trajectory &amp; Extract features of ADC trajectory
   std::vector&lt;std::pair&lt;double, double&gt;&gt; adc_traj_curr_pos(30, {0.0, 0.0});
   torch::Tensor adc_trajectory = torch::zeros({1, 30, 6});
@@ -167,30 +301,38 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
 
   // Build input features for torch
   std::vector&lt;torch::jit::IValue&gt; torch_inputs;
-
   auto X_value = c10::ivalue::Tuple::create(
-      {std::move(img_tensor.to(device_)), std::move(obstacle_pos.to(device_)),
-       std::move(obstacle_pos_step.to(device_))});
+      {std::move(target_obstacle_pos.unsqueeze(0).to(device_)),
+       std::move(target_obstacle_pos_step.unsqueeze(0).to(device_)),
+       std::move(vector_data.unsqueeze(0).to(device_)),
+       std::move(bool_vector_mask.unsqueeze(0).to(device_)),
+       std::move(bool_polyline_mask.unsqueeze(0).to(device_)),
+       std::move(rand_mask.unsqueeze(0).to(device_)),
+       std::move(polyline_id.unsqueeze(0).to(device_))});
   torch_inputs.push_back(c10::ivalue::Tuple::create(
       {X_value, std::move(adc_trajectory.to(device_))}));
 
-  // Compute pred_traj
-  std::vector&lt;double&gt; pred_traj;
+  auto end_time_data_prep = std::chrono::system_clock::now();
+  std::chrono::duration&lt;double&gt; diff_data_prep =
+      end_time_data_prep - start_time_data_prep;
+  ADEBUG &lt;&lt; "vectornet input tensor prepration used time: "
+         &lt;&lt; diff_data_prep.count() * 1000 &lt;&lt; " ms.";
 
-  auto start_time = std::chrono::system_clock::now();
+  // Compute pred_traj
+  auto start_time_inference = std::chrono::system_clock::now();
   at::Tensor torch_output_tensor = torch_default_output_tensor_;
   torch_output_tensor =
       torch_vehicle_model_.forward(torch_inputs).toTensor().to(torch::kCPU);
 
-  auto end_time = std::chrono::system_clock::now();
-  std::chrono::duration&lt;double&gt; diff = end_time - start_time;
-  ADEBUG &lt;&lt; "Semantic_LSTM_evaluator used time: " &lt;&lt; diff.count() * 1000
+  auto end_time_inference = std::chrono::system_clock::now();
+  std::chrono::duration&lt;double&gt; diff_inference =
+      end_time_inference - start_time_inference;
+  ADEBUG &lt;&lt; "vectornet-interaction inference used time: "
+         &lt;&lt; diff_inference.count() * 1000
          &lt;&lt; " ms.";
-  auto torch_output = torch_output_tensor.accessor&lt;float, 3&gt;();
 
   // Get the trajectory
-  double pos_x = latest_feature_ptr-&gt;position().x();
-  double pos_y = latest_feature_ptr-&gt;position().y();
+  auto torch_output = torch_output_tensor.accessor&lt;float, 3&gt;();
   Trajectory* trajectory = latest_feature_ptr-&gt;add_predicted_trajectory();
   trajectory-&gt;set_probability(1.0);
 
@@ -239,22 +381,66 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
   return true;
 }
 
-bool JointlyPredictionPlanningEvaluator::ExtractObstacleHistory(
-    Obstacle* obstacle_ptr,
-    std::vector&lt;std::pair&lt;double, double&gt;&gt;* pos_history) {
-  pos_history-&gt;resize(20, {0.0, 0.0});
+bool JointlyPredictionPlanningEvaluator::ExtractObstaclesHistory(
+    Obstacle* obstacle_ptr, ObstaclesContainer* obstacles_container,
+    std::vector&lt;std::pair&lt;double, double&gt;&gt;* target_pos_history,
+    std::vector&lt;std::pair&lt;double, double&gt;&gt;* all_obs_length,
+    std::vector&lt;std::vector&lt;std::pair&lt;double, double&gt;&gt;&gt;* all_obs_pos_history,
+    torch::Tensor* vector_mask) {
   const Feature&amp; obs_curr_feature = obstacle_ptr-&gt;latest_feature();
   double obs_curr_heading = obs_curr_feature.velocity_heading();
   std::pair&lt;double, double&gt; obs_curr_pos = std::make_pair(
       obs_curr_feature.position().x(), obs_curr_feature.position().y());
+  // Extract target obstacle history
   for (std::size_t i = 0; i &lt; obstacle_ptr-&gt;history_size() &amp;&amp; i &lt; 20; ++i) {
-    const Feature&amp; feature = obstacle_ptr-&gt;feature(i);
-    if (!feature.IsInitialized()) {
+    const Feature&amp; target_feature = obstacle_ptr-&gt;feature(i);
+    if (!target_feature.IsInitialized()) {
       break;
     }
-    pos_history-&gt;at(i) = WorldCoordToObjCoord(
-        std::make_pair(feature.position().x(), feature.position().y()),
-        obs_curr_pos, obs_curr_heading);
+    target_pos_history-&gt;at(i) =
+        WorldCoordToObjCoord(std::make_pair(target_feature.position().x(),
+                                            target_feature.position().y()),
+                             obs_curr_pos, obs_curr_heading);
+  }
+  all_obs_length-&gt;emplace_back(
+      std::make_pair(obs_curr_feature.length(), obs_curr_feature.width()));
+  all_obs_pos_history-&gt;emplace_back(*target_pos_history);
+
+  // Extract other obstacles &amp; convert pos to traget obstacle relative coord
+  std::vector&lt;std::pair&lt;double, double&gt;&gt; pos_history(20, {0.0, 0.0});
+  for (int id : obstacles_container-&gt;curr_frame_considered_obstacle_ids()) {
+    Obstacle* obstacle = obstacles_container-&gt;GetObstacle(id);
+    int target_id = obstacle_ptr-&gt;id();
+    if (id == target_id) {
+      continue;
+    }
+    const Feature&amp; other_obs_curr_feature = obstacle-&gt;latest_feature();
+    all_obs_length-&gt;emplace_back(std::make_pair(
+        other_obs_curr_feature.length(), other_obs_curr_feature.width()));
+
+    size_t obs_his_size = obstacle-&gt;history_size();
+    obs_his_size = obs_his_size &lt;= 20 ? obs_his_size : 20;
+    int cur_idx = all_obs_pos_history-&gt;size();
+    if (obs_his_size &gt; 1) {
+      vector_mask-&gt;index_put_({cur_idx,
+                              torch::indexing::Slice(torch::indexing::None,
+                                                     -(obs_his_size - 1))}, 1);
+    } else {
+      vector_mask-&gt;index_put_({cur_idx,
+                              torch::indexing::Slice(torch::indexing::None,
+                              -1)}, 1);
+    }
+
+    for (size_t i = 0; i &lt; obs_his_size; ++i) {
+      const Feature&amp; feature = obstacle-&gt;feature(i);
+      if (!feature.IsInitialized()) {
+        break;
+      }
+      pos_history[i] = WorldCoordToObjCoord(
+          std::make_pair(feature.position().x(), feature.position().y()),
+          obs_curr_pos, obs_curr_heading);
+    }
+    all_obs_pos_history-&gt;emplace_back(pos_history);
   }
   return true;
 }
@@ -296,18 +482,26 @@ void JointlyPredictionPlanningEvaluator::LoadModel() {
   torch::set_num_threads(1);
 
   // Fake intput for the first frame
-  torch::Tensor img_tensor = torch::zeros({1, 3, 224, 224});
-  torch::Tensor obstacle_pos = torch::zeros({1, 20, 2});
-  torch::Tensor obstacle_pos_step = torch::zeros({1, 20, 2});
+  torch::Tensor target_obstacle_pos = torch::randn({1, 20, 2});
+  torch::Tensor target_obstacle_pos_step = torch::randn({1, 20, 2});
+  torch::Tensor vector_data = torch::randn({1, 450, 50, 9});
+  torch::Tensor vector_mask = torch::randn({1, 450, 50}) &gt; 0.9;
+  torch::Tensor polyline_mask = torch::randn({1, 450}) &gt; 0.9;
+  torch::Tensor rand_mask = torch::zeros({1, 450});
+  torch::Tensor polyline_id = torch::randn({1, 450, 2});
   torch::Tensor adc_trajectory = torch::zeros({1, 30, 6});
   std::vector&lt;torch::jit::IValue&gt; torch_inputs;
-
   auto X_value = c10::ivalue::Tuple::create(
-      {std::move(img_tensor.to(device_)), std::move(obstacle_pos.to(device_)),
-       std::move(obstacle_pos_step.to(device_))});
+      {std::move(target_obstacle_pos.to(device_)),
+       std::move(target_obstacle_pos_step.to(device_)),
+       std::move(vector_data.to(device_)), std::move(vector_mask.to(device_)),
+       std::move(polyline_mask.to(device_)), std::move(rand_mask.to(device_)),
+       std::move(polyline_id.to(device_))});
   torch_inputs.push_back(c10::ivalue::Tuple::create(
       {X_value, std::move(adc_trajectory.to(device_))}));
-  // Run one inference to avoid very slow first inference later
+  // Run inference twice to avoid very slow first inference later
+  torch_default_output_tensor_ =
+      torch_vehicle_model_.forward(torch_inputs).toTensor().to(torch::kCPU);
   torch_default_output_tensor_ =
       torch_vehicle_model_.forward(torch_inputs).toTensor().to(torch::kCPU);
 }
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.h" new_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.h" added_lines="11" deleted_lines="9">
				<diff>@@ -20,11 +20,11 @@
 #include &lt;utility&gt;
 #include &lt;vector&gt;
 
-#include "modules/prediction/common/semantic_map.h"
 #include "modules/prediction/evaluator/evaluator.h"
 #include "torch/extension.h"
 #include "torch/script.h"
 #include "modules/prediction/container/container_manager.h"
+#include "modules/prediction/pipeline/vector_net.h"
 
 namespace apollo {
 namespace prediction {
@@ -36,8 +36,7 @@ class JointlyPredictionPlanningEvaluator : public Evaluator {
   /**
    * @brief Constructor
    */
-  JointlyPredictionPlanningEvaluator() = delete;
-  explicit JointlyPredictionPlanningEvaluator(SemanticMap* semantic_map);
+  JointlyPredictionPlanningEvaluator();
 
   /**
    * @brief Destructor
@@ -69,13 +68,16 @@ class JointlyPredictionPlanningEvaluator : public Evaluator {
                 ObstaclesContainer* obstacles_container) override;
 
   /**
-   * @brief Extract obstacle history
-   * @param Obstacle pointer
+   * @brief Extract all obstacles history
+   * @param Obstacles container
    *        Feature container in a vector for receiving the obstacle history
    */
-  bool ExtractObstacleHistory(
-      Obstacle* obstacle_ptr,
-      std::vector&lt;std::pair&lt;double, double&gt;&gt;* pos_history);
+    bool ExtractObstaclesHistory(
+      Obstacle* obstacle_ptr, ObstaclesContainer* obstacles_container,
+      std::vector&lt;std::pair&lt;double, double&gt;&gt;* curr_pos_history,
+      std::vector&lt;std::pair&lt;double, double&gt;&gt;* all_obs_length,
+      std::vector&lt;std::vector&lt;std::pair&lt;double, double&gt;&gt;&gt;* all_obs_pos_history,
+      torch::Tensor* vector_mask);
 
   /**
    * @brief Extract adc trajectory and convert world coord to obstacle coord
@@ -104,7 +106,7 @@ class JointlyPredictionPlanningEvaluator : public Evaluator {
   torch::jit::script::Module torch_vehicle_model_;
   at::Tensor torch_default_output_tensor_;
   torch::Device device_;
-  SemanticMap* semantic_map_;
+  VectorNet vector_net_;
 };
 
 }  // namespace prediction
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3d90987ed53e4adb002be50b8e2a16ebaecc620b" author="liuxu21">
		<msg>Prediction: add ego car localization to feature.proto

Change-Id: I4c008946f0919d56d7cbf692aa75653fd8f8f392</msg>
		<modified_files>
			<file old_path="modules\prediction\common\message_process.cc" new_path="modules\prediction\common\message_process.cc" added_lines="9" deleted_lines="0">
				<diff>@@ -222,6 +222,15 @@ void MessageProcess::OnPerception(
           ptr_ego_trajectory_container-&gt;adc_trajectory()
           .header().timestamp_sec());
 
+      // ego pose_container
+      auto ptr_ego_pose = container_manager-&gt;GetContainer&lt;PoseContainer&gt;(
+          AdapterConfig::LOCALIZATION);
+      CHECK_NOTNULL(ptr_ego_pose);
+
+      // adc localization
+      obstacle_ptr-&gt;mutable_latest_feature()-&gt;mutable_adc_localization()-&gt;
+        CopyFrom(*ptr_ego_pose-&gt;ToPerceptionObstacle());
+
       FeatureOutput::InsertFeatureProto(obstacle_ptr-&gt;latest_feature());
       ADEBUG &lt;&lt; "Insert feature into feature output";
     }
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\evaluator_manager.cc" new_path="modules\prediction\evaluator\evaluator_manager.cc" added_lines="3" deleted_lines="0">
				<diff>@@ -361,6 +361,9 @@ void EvaluatorManager::BuildObstacleIdHistoryMap(
       feature.set_type(obstacle_feature.type());
       feature.mutable_position()-&gt;CopyFrom(obstacle_feature.position());
       feature.set_theta(obstacle_feature.velocity_heading());
+      feature.mutable_interactive_tag()-&gt;CopyFrom(
+          obstacle_feature.interactive_tag());
+
       if (obstacle_feature.id() != FLAGS_ego_vehicle_id) {
         feature.mutable_polygon_point()-&gt;CopyFrom(
             obstacle_feature.polygon_point());
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3d7b58c0ecc13edda7b97b605606ac945efe2d7a" author="liuxu21">
		<msg>Prediction: add offline data batch processing function for vector-net

Change-Id: I4b40b4ef66d7b57080be25c8484f742d8d6f053b</msg>
		<modified_files>
			<file old_path="modules\prediction\common\prediction_system_gflags.cc" new_path="modules\prediction\common\prediction_system_gflags.cc" added_lines="4" deleted_lines="0">
				<diff>@@ -88,6 +88,10 @@ DEFINE_string(perception_obstacles_topic_name,
 // VectorNet
 DEFINE_string(prediction_target_file, "/apollo/data/train/test.pb.txt",
               "VectorNet target pb file name");
+DEFINE_string(world_coordinate_file, "/apollo/data/world_coord.bin",
+              "VectorNet world coordinate file name");
+DEFINE_string(prediction_target_dir, "/apollo/data/train/",
+              "VectorNet target dir");
 DEFINE_double(obstacle_x, 0.0, "obstacle position x");
 DEFINE_double(obstacle_y, 0.0, "obstacle position y");
 DEFINE_double(obstacle_phi, 0.0, "obstacle heading phi");
</diff>
			</file>
			<file old_path="modules\prediction\common\prediction_system_gflags.h" new_path="modules\prediction\common\prediction_system_gflags.h" added_lines="2" deleted_lines="0">
				<diff>@@ -54,6 +54,8 @@ DECLARE_string(perception_obstacles_topic_name);
 
 // VectorNet
 DECLARE_string(prediction_target_file);
+DECLARE_string(world_coordinate_file);
+DECLARE_string(prediction_target_dir);
 DECLARE_double(obstacle_x);
 DECLARE_double(obstacle_y);
 DECLARE_double(obstacle_phi);
</diff>
			</file>
			<file old_path="modules\prediction\pipeline\vector_net.cc" new_path="modules\prediction\pipeline\vector_net.cc" added_lines="11" deleted_lines="1">
				<diff>@@ -116,6 +116,16 @@ bool VectorNet::query(const common::PointENU&amp; center_point,
 
 bool VectorNet::offline_query(const double obstacle_x, const double obstacle_y,
                               const double obstacle_phi) {
+  return offline_query(obstacle_x,
+                       obstacle_y,
+                       obstacle_phi,
+                       FLAGS_prediction_target_file);
+}
+
+bool VectorNet::offline_query(const double obstacle_x,
+                              const double obstacle_y,
+                              const double obstacle_phi,
+                              const std::string file_name) {
   FeatureVector offline_feature;
   PidVector p_id;
   common::PointENU center_point =
@@ -141,7 +151,7 @@ bool VectorNet::offline_query(const double obstacle_x, const double obstacle_y,
     }
   }
   cyber::common::SetProtoToASCIIFile(vector_net_pb_,
-                                     FLAGS_prediction_target_file);
+                                     file_name);
 
   return true;
 }
</diff>
			</file>
			<file old_path="modules\prediction\pipeline\vector_net.h" new_path="modules\prediction\pipeline\vector_net.h" added_lines="4" deleted_lines="0">
				<diff>@@ -19,6 +19,7 @@
 #include &lt;deque&gt;
 #include &lt;map&gt;
 #include &lt;vector&gt;
+#include &lt;string&gt;
 
 #include "modules/prediction/proto/vector_net.pb.h"
 #include "modules/common/math/linear_interpolation.h"
@@ -64,6 +65,9 @@ class VectorNet {
   bool offline_query(const double obstacle_x, const double obstacle_y,
                      const double obstacle_phi);
 
+  bool offline_query(const double obstacle_x, const double obstacle_y,
+                     const double obstacle_phi, const std::string file_name);
+
  private:
   // TODO(Yiqun): 1.Left/Right boundary 2.Ordinal Encoding
   const std::map&lt;ATTRIBUTE_TYPE, double&gt; attribute_map{
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="161bd35b0000c7f96cec6e47270cf432b12b9904" author="weixiao">
		<msg>merge github

Change-Id: I1f80afacb6c87e5f849bbec7c1608943853c7531</msg>
		<modified_files>
			<file old_path="modules\perception\production\conf\perception\camera\smoke_detection_component.config" new_path="modules\perception\production\conf\perception\camera\smoke_detection_component.config" added_lines="1" deleted_lines="0">
				<diff>@@ -25,3 +25,4 @@ visual_camera : "front_6mm"
 write_visual_img : false
 enable_cipv : false
 debug_level : 0
+cipv : "Cipv"
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7a1c9558496fdf06b45b20c139660d89707ef66a" author="lilu15">
		<msg>refine the logic on the new map

Change-Id: Ie38276651d416743d531b100c076678ffdfe7774</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\map\map_service.cc" new_path="modules\dreamview\backend\map\map_service.cc" added_lines="5" deleted_lines="0">
				<diff>@@ -450,6 +450,11 @@ bool MapService::ConstructLaneWayPointWithLaneId(
     return false;
   }
 
+  if (s &gt; lane-&gt;lane().length()) {
+    s = lane-&gt;lane().length();
+  }
+
+
   laneWayPoint-&gt;set_id(id);
   laneWayPoint-&gt;set_s(s);
   auto *pose = laneWayPoint-&gt;mutable_pose();
</diff>
			</file>
			<file old_path="modules\planning\scenarios\dead_end\deadend_turnaround\deadend_turnaround_scenario.cc" new_path="modules\planning\scenarios\dead_end\deadend_turnaround\deadend_turnaround_scenario.cc" added_lines="8" deleted_lines="0">
				<diff>@@ -102,6 +102,14 @@ bool DeadEndTurnAroundScenario::IsTransferable(
   const PointENU&amp; dead_end_point,
   const double dead_end_start_range) {
   std::string target_dead_end_id;
+  const auto&amp; routing_type =
+      frame.local_view().routing-&gt;routing_request().dead_end_info().
+      dead_end_routing_type();
+  if (routing_type != routing::ROUTING_IN &amp;&amp;
+      routing_type != routing::ROUTING_OUT) {
+    ADEBUG &lt;&lt; "falied to get dead end routing task";
+    return false;
+  }
   // vaild check
   const hdmap::HDMap* base_map_ptr = hdmap::HDMapUtil::BaseMapPtr();
   std::vector&lt;JunctionInfoConstPtr&gt; junctions;
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" new_path="modules\planning\tasks\deciders\open_space_decider\open_space_roi_decider.cc" added_lines="71" deleted_lines="30">
				<diff>@@ -849,32 +849,53 @@ void OpenSpaceRoiDecider::GetInLaneBoundaryPoints(LaneInfoConstPtr lane_info,
     lane_info-&gt;lane().left_boundary().curve().segment();
   const auto&amp; right_boundary_segment =
     lane_info-&gt;lane().right_boundary().curve().segment();
-  size_t lane_points_num = left_boundary_segment[0].line_segment().point_size();
+  size_t lane_points_num =
+    left_boundary_segment[0].line_segment().point_size();
   int temp_record_left = 0;
   int temp_record_right = 0;
+  double left_point_s = 0.0;
+  double left_point_l = 0.0;
+  double right_point_s = 0.0;
+  double right_point_l = 0.0;
+  std::vector&lt;double&gt; left_s, right_s, left_l, right_l;
   std::vector&lt;PointENU&gt; left_points, right_points;
+  double car_s, car_l;
+  Vec2d car_position = {temp_state_.x(), temp_state_.y()};
+  lane_info-&gt;GetProjection(car_position, &amp;car_s, &amp;car_l);
   for (size_t i = 0; i &lt; lane_points_num; ++i) {
-    left_points.push_back(left_boundary_segment[0].
-                          line_segment().point().at(i));
-    right_points.push_back(right_boundary_segment[0].
-                           line_segment().point().at(i));
-  }
-  // (to do): by s
-  for (size_t i = 0; i &lt; lane_points_num; ++i) {
-    if (left_points[i].x() &lt; temp_state_.x()) {
-      In_left_boundary_points-&gt;push_back(left_points[i]);
+    PointENU left_point = left_boundary_segment[0].
+                          line_segment().point().at(i);
+    PointENU right_point = right_boundary_segment[0].
+                           line_segment().point().at(i);
+    left_points.push_back(left_point);
+    right_points.push_back(right_point);
+    Vec2d left_point_v = {left_boundary_segment[0].
+                        line_segment().point().at(i).x(),
+                        left_boundary_segment[0].
+                        line_segment().point().at(i).y()};
+    Vec2d right_point_v = {right_boundary_segment[0].
+                         line_segment().point().at(i).x(),
+                         right_boundary_segment[0].
+                         line_segment().point().at(i).y()};
+    lane_info-&gt;GetProjection(left_point_v, &amp;left_point_s, &amp;left_point_l);
+    lane_info-&gt;GetProjection(right_point_v, &amp;right_point_s, &amp;right_point_l);
+    if (left_point_s &gt; car_s) {
+      In_left_boundary_points-&gt;push_back(left_point);
       temp_record_left = i;
     }
-    if (right_points[i].x() &lt; temp_state_.x()) {
-      In_right_boundary_points-&gt;push_back(right_points[i]);
+    if (right_point_s &gt; car_s) {
+      In_right_boundary_points-&gt;push_back(right_point);
       temp_record_right = i;
     }
+    left_s.push_back(left_point_s);
+    left_l.push_back(left_point_l);
+    right_s.push_back(right_point_s);
+    right_l.push_back(right_point_l);
   }
-  // add one point, bigger than vehicle x
-  if (left_points[temp_record_left - 1].x() &gt; temp_state_.x()) {
+  if (left_s[temp_record_left - 1] &lt; car_s) {
     In_left_boundary_points-&gt;push_back(left_points[temp_record_left - 1]);
   }
-  if (right_points[temp_record_right - 1].x() &gt; temp_state_.x()) {
+  if (right_s[temp_record_right - 1] &lt; car_s) {
     In_right_boundary_points-&gt;push_back(right_points[temp_record_right - 1]);
   }
   std::reverse(In_right_boundary_points-&gt;begin(),
@@ -894,29 +915,50 @@ void OpenSpaceRoiDecider::GetOutLaneBoundaryPoints(
     left_boundary_segment[0].line_segment().point_size();
   int temp_record_left = 0;
   int temp_record_right = 0;
+  double left_point_s = 0.0;
+  double left_point_l = 0.0;
+  double right_point_s = 0.0;
+  double right_point_l = 0.0;
+  std::vector&lt;double&gt; left_s, right_s, left_l, right_l;
   std::vector&lt;PointENU&gt; left_points, right_points;
+  double target_point_s, target_point_l;
+  Vec2d target_position = {routing_target_point_.x(),
+                           routing_target_point_.y()};
+  lane_info-&gt;GetProjection(target_position, &amp;target_point_s, &amp;target_point_l);
   for (size_t i = 0; i &lt; lane_points_num; ++i) {
-    left_points.push_back(left_boundary_segment[0].
-                          line_segment().point().at(i));
-    right_points.push_back(right_boundary_segment[0].
-                          line_segment().point().at(i));
-  }
-  // (to do): by s
-  for (size_t i = 0; i &lt; lane_points_num; ++i) {
-    if (left_points[i].x() &lt; routing_target_point_.x()) {
-      Out_left_boundary_points-&gt;push_back(left_points[i]);
+    PointENU left_point = left_boundary_segment[0].
+                          line_segment().point().at(i);
+    PointENU right_point = right_boundary_segment[0].
+                           line_segment().point().at(i);
+    left_points.push_back(left_point);
+    right_points.push_back(right_point);
+    Vec2d left_point_v = {left_boundary_segment[0].
+                          line_segment().point().at(i).x(),
+                          left_boundary_segment[0].
+                          line_segment().point().at(i).y()};
+    Vec2d right_point_v = {right_boundary_segment[0].
+                           line_segment().point().at(i).x(),
+                           right_boundary_segment[0].
+                           line_segment().point().at(i).y()};
+    lane_info-&gt;GetProjection(left_point_v, &amp;left_point_s, &amp;left_point_l);
+    lane_info-&gt;GetProjection(right_point_v, &amp;right_point_s, &amp;right_point_l);
+    if (left_point_s &lt; target_point_s) {
+      Out_left_boundary_points-&gt;push_back(left_point);
       temp_record_left = i;
     }
-    if (right_points[i].x() &lt; routing_target_point_.x()) {
-      Out_right_boundary_points-&gt;push_back(right_points[i]);
+    if (right_point_s &lt; target_point_s) {
+      Out_right_boundary_points-&gt;push_back(right_point);
       temp_record_right = i;
     }
+    left_s.push_back(left_point_s);
+    left_l.push_back(left_point_l);
+    right_s.push_back(right_point_s);
+    right_l.push_back(right_point_l);
   }
-  // add one point, bigger than vehicle x
-  if (left_points[temp_record_left + 1].x() &gt; routing_target_point_.x()) {
+  if (left_s[temp_record_left + 1] &gt; target_point_s) {
     Out_left_boundary_points-&gt;push_back(left_points[temp_record_left + 1]);
   }
-  if (right_points[temp_record_right + 1].x() &gt; routing_target_point_.x()) {
+  if (right_s[temp_record_right + 1] &gt; target_point_s) {
     Out_right_boundary_points-&gt;push_back(right_points[temp_record_right + 1]);
   }
   std::reverse(Out_left_boundary_points-&gt;begin(),
@@ -1005,7 +1047,6 @@ bool OpenSpaceRoiDecider::GetDeadEndBoundary(
                             In_right_boundary_points[0].y()});
   const auto &amp;origin_point = frame-&gt;open_space_info().origin_point();
   const auto &amp;origin_heading = frame-&gt;open_space_info().origin_heading();
-
   for (size_t i = 0; i &lt; point_boundary.size(); ++i) {
     point_boundary[i] -= origin_point;
     point_boundary[i].SelfRotate(-origin_heading);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1ef2259ce28747559a088d8f4c49ba010dc0ce8a" author="fuyiqun">
		<msg>prediction: fix nan for vectornet inference

Change-Id: I6c8cba2a966647aa5c05d9fcfea048d5d146a380</msg>
		<modified_files>
			<file old_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" added_lines="159" deleted_lines="112">
				<diff>@@ -41,69 +41,130 @@ VectornetEvaluator::VectornetEvaluator() : device_(torch::kCPU) {
 
 void VectornetEvaluator::Clear() {}
 
-bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
-                                  ObstaclesContainer* obstacles_container) {
-  omp_set_num_threads(1);
-
-  obstacle_ptr-&gt;SetEvaluatorType(evaluator_type_);
-
-  Clear();
-  CHECK_NOTNULL(obstacle_ptr);
-  int id = obstacle_ptr-&gt;id();
-  if (!obstacle_ptr-&gt;latest_feature().IsInitialized()) {
-    AERROR &lt;&lt; "Obstacle [" &lt;&lt; id &lt;&lt; "] has no latest feature.";
-    return false;
-  }
-  Feature* latest_feature_ptr = obstacle_ptr-&gt;mutable_latest_feature();
-  CHECK_NOTNULL(latest_feature_ptr);
-
+bool VectornetEvaluator::VectornetProcessObstaclePosition(
+                             Obstacle* obstacle_ptr,
+                             ObstaclesContainer* obstacles_container,
+                             torch::Tensor* ptr_target_obs_pos,
+                             torch::Tensor* ptr_target_obs_pos_step,
+                             torch::Tensor* ptr_vector_mask,
+                             torch::Tensor* ptr_all_obstacle_pos,
+                             torch::Tensor* ptr_all_obs_p_id,
+                             torch::Tensor* ptr_obs_length) {
   // obs data vector
   // Extract features of pos_history
   std::vector&lt;std::pair&lt;double, double&gt;&gt; target_pos_history(20, {0.0, 0.0});
   std::vector&lt;std::pair&lt;double, double&gt;&gt; all_obs_length;
   std::vector&lt;std::vector&lt;std::pair&lt;double, double&gt;&gt;&gt; all_obs_pos_history;
+
   if (!ExtractObstaclesHistory(obstacle_ptr, obstacles_container,
                                &amp;target_pos_history, &amp;all_obs_length,
-                               &amp;all_obs_pos_history)) {
-    ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id &lt;&lt; "] failed to extract obstacle history";
+                               &amp;all_obs_pos_history, ptr_vector_mask)) {
+    ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; obstacle_ptr-&gt;id()
+           &lt;&lt; "] failed to extract obstacle history";
     return false;
   }
 
-  // Process target obs pos_history
-  torch::Tensor target_obstacle_pos = torch::zeros({20, 2});
-  torch::Tensor target_obstacle_pos_step = torch::zeros({20, 2});
-  for (int i = 0; i &lt; 20; ++i) {
-    target_obstacle_pos[19 - i][0] = target_pos_history[i].first;
-    target_obstacle_pos[19 - i][1] = target_pos_history[i].second;
-    if (i == 19 || (i &gt; 0 &amp;&amp; target_pos_history[i].first == 0.0)) {
+  for (int j = 0; j &lt; 20; ++j) {
+    ptr_target_obs_pos-&gt;index_put_({19 - j, 0}, target_pos_history[j].first);
+    ptr_target_obs_pos-&gt;index_put_({19 - j, 1}, target_pos_history[j].second);
+    if (j == 19 || (j &gt; 0 &amp;&amp; target_pos_history[j + 1].first == 0.0)) {
       break;
     }
-    target_obstacle_pos_step[19 - i][0] =
-        target_pos_history[i].first - target_pos_history[i + 1].first;
-    target_obstacle_pos_step[19 - i][1] =
-        target_pos_history[i].second - target_pos_history[i + 1].second;
+    ptr_target_obs_pos_step-&gt;index_put_(
+        {19 - j, 0},
+        target_pos_history[j].first - target_pos_history[j + 1].first);
+    ptr_target_obs_pos_step-&gt;index_put_(
+        {19 - j, 1},
+        target_pos_history[j].second - target_pos_history[j + 1].second);
   }
 
-  // Process all obs pos_history
   int obs_num =
       obstacles_container-&gt;curr_frame_considered_obstacle_ids().size();
-  torch::Tensor all_obstacle_pos = torch::zeros({obs_num, 20, 2});
   for (int i = 0; i &lt; obs_num; ++i) {
+    std::vector&lt;double&gt; obs_p_id{std::numeric_limits&lt;float&gt;::max(),
+                              std::numeric_limits&lt;float&gt;::max()};
     for (int j = 0; j &lt; 20; ++j) {
-      all_obstacle_pos[i][19 - j][0] = all_obs_pos_history[i][j].first;
-      all_obstacle_pos[i][19 - j][1] = all_obs_pos_history[i][j].second;
+      // Process obs pid
+      if (obs_p_id[0] &gt; all_obs_pos_history[i][j].first) {
+        obs_p_id[0] = all_obs_pos_history[i][j].first;
+      }
+      if (obs_p_id[1] &gt; all_obs_pos_history[i][j].second) {
+        obs_p_id[1] = all_obs_pos_history[i][j].second;
+      }
+      // Process obs pos history
+      ptr_all_obstacle_pos-&gt;index_put_(
+          {i, 19 - j, 0},
+          all_obs_pos_history[i][j].first);
+      ptr_all_obstacle_pos-&gt;index_put_(
+          {i, 19 - j, 1},
+          all_obs_pos_history[i][j].second);
     }
+
+    ptr_all_obs_p_id-&gt;index_put_({i, 0}, obs_p_id[0]);
+    ptr_all_obs_p_id-&gt;index_put_({i, 1}, obs_p_id[1]);
   }
 
-  // Query the map data vector
+  for (int i = 0; i &lt; obs_num; ++i) {
+    ptr_obs_length-&gt;index_put_({i, 0}, all_obs_length[i].first);
+    ptr_obs_length-&gt;index_put_({i, 1}, all_obs_length[i].second);
+  }
+
+  return true;
+}
+
+bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
+                                  ObstaclesContainer* obstacles_container) {
+  omp_set_num_threads(1);
+
+  obstacle_ptr-&gt;SetEvaluatorType(evaluator_type_);
+
+  Clear();
+  CHECK_NOTNULL(obstacle_ptr);
+  int id = obstacle_ptr-&gt;id();
+  if (!obstacle_ptr-&gt;latest_feature().IsInitialized()) {
+    AERROR &lt;&lt; "Obstacle [" &lt;&lt; id &lt;&lt; "] has no latest feature.";
+    return false;
+  }
+
+  int obs_num =
+      obstacles_container-&gt;curr_frame_considered_obstacle_ids().size();
+
+  auto start_time_obs = std::chrono::system_clock::now();
+
+  torch::Tensor target_obstacle_pos = torch::zeros({20, 2});
+  torch::Tensor target_obstacle_pos_step = torch::zeros({20, 2});
+  torch::Tensor vector_mask = torch::zeros({450, 50});
+  torch::Tensor all_obstacle_pos = torch::zeros({obs_num, 20, 2});
+  torch::Tensor all_obs_p_id = torch::zeros({obs_num, 2});
+  torch::Tensor obs_length_tmp = torch::zeros({obs_num, 2});
+
+  if (VectornetProcessObstaclePosition(obstacle_ptr,
+                                       obstacles_container,
+                                       &amp;target_obstacle_pos,
+                                       &amp;target_obstacle_pos_step,
+                                       &amp;vector_mask,
+                                       &amp;all_obstacle_pos,
+                                       &amp;all_obs_p_id,
+                                       &amp;obs_length_tmp)) {
+    AERROR &lt;&lt; "Obstacle [" &lt;&lt; id &lt;&lt; "] processing obstacle position fails.";
+    return false;
+  }
+
+  auto end_time_obs = std::chrono::system_clock::now();
+  std::chrono::duration&lt;double&gt; diff_obs = end_time_obs - start_time_obs;
+  ADEBUG &lt;&lt; "obstacle vectors used time: " &lt;&lt; diff_obs.count() * 1000 &lt;&lt; " ms.";
+
+  Feature* latest_feature_ptr = obstacle_ptr-&gt;mutable_latest_feature();
+  CHECK_NOTNULL(latest_feature_ptr);
+
+  // Query the map data
   FeatureVector map_feature;
   PidVector map_p_id;
-  double pos_x = latest_feature_ptr-&gt;position().x();
-  double pos_y = latest_feature_ptr-&gt;position().y();
-  common::PointENU center_point;
-  center_point.set_x(pos_x);
-  center_point.set_y(pos_y);
-  double heading = latest_feature_ptr-&gt;velocity_heading();
+  const double pos_x = latest_feature_ptr-&gt;position().x();
+  const double pos_y = latest_feature_ptr-&gt;position().y();
+  common::PointENU center_point
+      = common::util::PointFactory::ToPointENU(pos_x, pos_y);;
+  const double heading = latest_feature_ptr-&gt;velocity_heading();
 
   auto start_time_query = std::chrono::system_clock::now();
 
@@ -115,77 +176,48 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   std::chrono::duration&lt;double&gt; diff_query = end_time_query - start_time_query;
   ADEBUG &lt;&lt; "vectors query used time: " &lt;&lt; diff_query.count() * 1000 &lt;&lt; " ms.";
 
+  // Process all obs pos_history &amp; obs pid
   auto start_time_data_prep = std::chrono::system_clock::now();
 
-  // Process mask &amp; p_id
-  // process v_mask for obs
-  int obs_his_size = obstacle_ptr-&gt;history_size();
-  torch::Tensor vector_mask = torch::zeros({450, 50});
-  for (int i = 0; i &lt; obs_num; ++i) {
-    if (obs_his_size &gt; 1 &amp;&amp; obs_his_size &lt;= 20) {
-      vector_mask.index_put_({i, torch::indexing::Slice(torch::indexing::None,
-                                                        -(obs_his_size - 1))},
-                             1);
-    } else if (obs_his_size &gt; 20) {
-      vector_mask.index_put_(
-          {i, torch::indexing::Slice(torch::indexing::None, -19)}, 1);
-    } else {
-      vector_mask.index_put_(
-          {i, torch::indexing::Slice(torch::indexing::None, -1)}, 1);
-    }
-  }
-
-  // process map data &amp; v_mask for map polyline
+  // process map data &amp; map p id &amp; v_mask for map polyline
   int map_polyline_num = map_feature.size();
-  for (int i = obs_num; i &lt;= map_polyline_num; ++i) {
-    int one_polyline_vector_num = map_feature[i].size();
-    if (one_polyline_vector_num &lt; 50) {
-      vector_mask.index_put_({i, torch::indexing::Slice(one_polyline_vector_num,
-                                                        torch::indexing::None)},
+  int data_length =
+      ((obs_num + map_polyline_num) &lt; 450) ? (obs_num + map_polyline_num) : 450;
+  for (int i = 0; i &lt; map_polyline_num &amp;&amp; obs_num + i &lt; 450; ++i) {
+    size_t one_polyline_vector_size = map_feature[i].size();
+    if (one_polyline_vector_size &lt; 50) {
+      vector_mask.index_put_({obs_num + i,
+                              torch::indexing::Slice(one_polyline_vector_size,
+                                                     torch::indexing::None)},
                              1);
     }
   }
 
   torch::Tensor map_data = torch::zeros({map_polyline_num, 50, 9});
-  for (int i = 0; i &lt; map_polyline_num &amp;&amp; i &lt; 450; ++i) {
-    int one_polyline_vector_num = map_feature[i].size();
-    for (int j = 0; j &lt; one_polyline_vector_num &amp;&amp; j &lt; 50; ++j) {
+  torch::Tensor all_map_p_id = torch::zeros({map_polyline_num, 2});
+  auto opts = torch::TensorOptions().dtype(torch::kDouble);
+
+  for (int i = 0; i &lt; map_polyline_num &amp;&amp; i + obs_num &lt; 450; ++i) {
+    all_map_p_id[i][0] = map_p_id[i][0];
+    all_map_p_id[i][1] = map_p_id[i][1];
+
+    int one_polyline_vector_size = map_feature[i].size();
+    for (int j = 0; j &lt; one_polyline_vector_size &amp;&amp; j &lt; 50; ++j) {
       map_data.index_put_({i, j},
-                          torch::from_blob(map_feature[i][j].data(), {9}));
+                          torch::from_blob(map_feature[i][j].data(),
+                                           {9},
+                                           opts));
     }
   }
+  map_data = map_data.toType(at::kFloat);
 
   // process p mask
   torch::Tensor polyline_mask = torch::zeros({450});
-  int data_length = obs_num + map_polyline_num;
   if (data_length &lt; 450) {
     polyline_mask.index_put_(
         {torch::indexing::Slice(data_length, torch::indexing::None)}, 1);
   }
 
-  // process p_id for obs and map p_id
-  torch::Tensor all_obs_p_id = torch::zeros({obs_num, 2});
-  torch::Tensor all_map_p_id = torch::zeros({map_polyline_num, 2});
-  for (int i = 0; i &lt; obs_num; ++i) {
-    std::vector&lt;double&gt; obs_p_id{std::numeric_limits&lt;float&gt;::max(),
-                                 std::numeric_limits&lt;float&gt;::max()};
-    for (int j = 0; j &lt; obs_his_size &amp;&amp; j &lt; 20; ++j) {
-      if (obs_p_id[0] &gt; obstacle_ptr-&gt;latest_feature().position().x()) {
-        obs_p_id[0] = obstacle_ptr-&gt;latest_feature().position().x();
-        all_obs_p_id[i][0] = obs_p_id[0];
-      }
-      if (obs_p_id[1] &gt; obstacle_ptr-&gt;latest_feature().position().y()) {
-        obs_p_id[1] = obstacle_ptr-&gt;latest_feature().position().y();
-        all_obs_p_id[i][1] = obs_p_id[1];
-      }
-    }
-  }
-
-  for (int i = 0; i &lt; map_polyline_num; ++i) {
-    all_map_p_id[i][0] = map_p_id[i][0];
-    all_map_p_id[i][1] = map_p_id[i][1];
-  }
-
   // Extend obs data to specific dimension
   torch::Tensor obs_pos_data = torch::cat(
       {all_obstacle_pos.index(
@@ -196,12 +228,7 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
                                torch::indexing::Slice(1, torch::indexing::None),
                                torch::indexing::Slice()})},
       2);
-  // Add obs length
-  torch::Tensor obs_length_tmp = torch::zeros({obs_num, 2});
-  for (int i = 0; i &lt; obs_num; ++i) {
-    obs_length_tmp[i][0] = all_obs_length[i].first;
-    obs_length_tmp[i][1] = all_obs_length[i].second;
-  }
+
   torch::Tensor obs_length = obs_length_tmp.unsqueeze(1).repeat({1, 19, 1});
   // Add obs attribute
   torch::Tensor obs_attr_agent =
@@ -211,8 +238,10 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
         {(obs_num - 1), 19, 1});
   torch::Tensor obs_attr = torch::cat({obs_attr_agent, obs_attr_other}, 0);
   // ADD obs id
+  // add 500 to avoid same id as in map_info
   torch::Tensor obs_id =
-      torch::arange(0, obs_num).unsqueeze(1).repeat({1, 19}).unsqueeze(2);
+      torch::arange(500,
+                    obs_num + 500).unsqueeze(1).repeat({1, 19}).unsqueeze(2);
   // Process obs data
   torch::Tensor obs_data_with_len = torch::cat({obs_pos_data, obs_length}, 2);
   torch::Tensor obs_data_with_attr =
@@ -237,12 +266,13 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   }
 
   // Empty rand mask as placeholder
-  torch::Tensor rand_mask = torch::zeros({0});
+  auto rand_mask = torch::zeros({450}).toType(at::kBool);
   // Change mask type to bool
   auto bool_vector_mask = vector_mask.toType(at::kBool);
   auto bool_polyline_mask = polyline_mask.toType(at::kBool);
   // Build input features for torch
   std::vector&lt;torch::jit::IValue&gt; torch_inputs;
+
   torch_inputs.push_back(c10::ivalue::Tuple::create(
       {std::move(target_obstacle_pos.unsqueeze(0).to(device_)),
        std::move(target_obstacle_pos_step.unsqueeze(0).to(device_)),
@@ -331,27 +361,26 @@ bool VectornetEvaluator::ExtractObstaclesHistory(
     Obstacle* obstacle_ptr, ObstaclesContainer* obstacles_container,
     std::vector&lt;std::pair&lt;double, double&gt;&gt;* target_pos_history,
     std::vector&lt;std::pair&lt;double, double&gt;&gt;* all_obs_length,
-    std::vector&lt;std::vector&lt;std::pair&lt;double, double&gt;&gt;&gt;* all_obs_pos_history) {
+    std::vector&lt;std::vector&lt;std::pair&lt;double, double&gt;&gt;&gt;* all_obs_pos_history,
+    torch::Tensor* vector_mask) {
   const Feature&amp; obs_curr_feature = obstacle_ptr-&gt;latest_feature();
   double obs_curr_heading = obs_curr_feature.velocity_heading();
   std::pair&lt;double, double&gt; obs_curr_pos = std::make_pair(
       obs_curr_feature.position().x(), obs_curr_feature.position().y());
   // Extract target obstacle history
-  std::vector&lt;std::pair&lt;double, double&gt;&gt; tar_pos_his(20, {0.0, 0.0});
   for (std::size_t i = 0; i &lt; obstacle_ptr-&gt;history_size() &amp;&amp; i &lt; 20; ++i) {
     const Feature&amp; target_feature = obstacle_ptr-&gt;feature(i);
     if (!target_feature.IsInitialized()) {
       break;
     }
-    tar_pos_his[i] =
+    target_pos_history-&gt;at(i) =
         WorldCoordToObjCoord(std::make_pair(target_feature.position().x(),
                                             target_feature.position().y()),
                              obs_curr_pos, obs_curr_heading);
   }
   all_obs_length-&gt;emplace_back(
       std::make_pair(obs_curr_feature.length(), obs_curr_feature.width()));
-  all_obs_pos_history-&gt;emplace_back(tar_pos_his);
-  target_pos_history = &amp;tar_pos_his;
+  all_obs_pos_history-&gt;emplace_back(*target_pos_history);
 
   // Extract other obstacles &amp; convert pos to traget obstacle relative coord
   std::vector&lt;std::pair&lt;double, double&gt;&gt; pos_history(20, {0.0, 0.0});
@@ -365,7 +394,22 @@ bool VectornetEvaluator::ExtractObstaclesHistory(
     all_obs_length-&gt;emplace_back(std::make_pair(
         other_obs_curr_feature.length(), other_obs_curr_feature.width()));
 
-    for (std::size_t i = 0; i &lt; obstacle-&gt;history_size() &amp;&amp; i &lt; 20; ++i) {
+    size_t obs_his_size = obstacle-&gt;history_size();
+    obs_his_size = obs_his_size &lt;= 20 ? obs_his_size : 20;
+    int cur_idx = all_obs_pos_history-&gt;size();
+    if (obs_his_size &gt; 1) {
+      vector_mask-&gt;index_put_({cur_idx,
+                               torch::indexing::Slice(torch::indexing::None,
+                                                      -(obs_his_size - 1))},
+                              1);
+    } else {
+      vector_mask-&gt;index_put_({cur_idx,
+                               torch::indexing::Slice(torch::indexing::None,
+                                                      -1)},
+                              1);
+    }
+
+    for (size_t i = 0; i &lt; obs_his_size; ++i) {
       const Feature&amp; feature = obstacle-&gt;feature(i);
       if (!feature.IsInitialized()) {
         break;
@@ -381,7 +425,7 @@ bool VectornetEvaluator::ExtractObstaclesHistory(
 
 void VectornetEvaluator::LoadModel() {
   if (FLAGS_use_cuda &amp;&amp; torch::cuda::is_available()) {
-    ADEBUG &lt;&lt; "CUDA is available";
+    AINFO &lt;&lt; "CUDA is available";
     device_ = torch::Device(torch::kCUDA);
     torch_vehicle_model_ =
         torch::jit::load(FLAGS_torch_vehicle_vectornet_file, device_);
@@ -390,15 +434,16 @@ void VectornetEvaluator::LoadModel() {
         torch::jit::load(FLAGS_torch_vehicle_vectornet_cpu_file, device_);
   }
   torch::set_num_threads(1);
+  AINFO &lt;&lt; "CUDA is 11111";
 
   // Fake intput for the first frame
-  torch::Tensor target_obstacle_pos = torch::zeros({1, 20, 2});
-  torch::Tensor target_obstacle_pos_step = torch::zeros({1, 20, 2});
-  torch::Tensor vector_data = torch::zeros({1, 450, 50, 9});
+  torch::Tensor target_obstacle_pos = torch::randn({1, 20, 2});
+  torch::Tensor target_obstacle_pos_step = torch::randn({1, 20, 2});
+  torch::Tensor vector_data = torch::randn({1, 450, 50, 9});
   torch::Tensor vector_mask = torch::randn({1, 450, 50}) &gt; 0.9;
   torch::Tensor polyline_mask = torch::randn({1, 450}) &gt; 0.9;
-  torch::Tensor rand_mask = torch::zeros({0});
-  torch::Tensor polyline_id = torch::zeros({1, 450, 2});
+  torch::Tensor rand_mask = torch::zeros({1, 450});
+  torch::Tensor polyline_id = torch::randn({1, 450, 2});
   std::vector&lt;torch::jit::IValue&gt; torch_inputs;
   torch_inputs.push_back(c10::ivalue::Tuple::create(
       {std::move(target_obstacle_pos.to(device_)),
@@ -409,6 +454,8 @@ void VectornetEvaluator::LoadModel() {
   // Run one inference to avoid very slow first inference later
   torch_default_output_tensor_ =
       torch_vehicle_model_.forward(torch_inputs).toTensor().to(torch::kCPU);
+  torch_default_output_tensor_ =
+      torch_vehicle_model_.forward(torch_inputs).toTensor().to(torch::kCPU);
 }
 
 }  // namespace prediction
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.h" new_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.h" added_lines="22" deleted_lines="1">
				<diff>@@ -45,6 +45,26 @@ class VectornetEvaluator : public Evaluator {
    */
   void Clear();
 
+  /**
+   * @brief Process obstacle position to vector
+   * @param Obstacles pointer
+   * @param Obstacles container
+   * @param Tensor: target obstacle position
+   * @param Tensor: target obstacle position step
+   * @param Tensor: vector mask
+   * @param Tensor: all obstacle position
+   * @param Tensor: all obstacle p_id
+   * @param Tensor: all obstacle length
+   */
+  bool VectornetProcessObstaclePosition(Obstacle* obstacle_ptr,
+                                    ObstaclesContainer* obstacles_container,
+                                    torch::Tensor* ptr_target_obs_pos,
+                                    torch::Tensor* ptr_target_obs_pos_step,
+                                    torch::Tensor* ptr_vector_mask,
+                                    torch::Tensor* ptr_all_obstacle_pos,
+                                    torch::Tensor* ptr_all_obs_p_id,
+                                    torch::Tensor* ptr_obs_length);
+
   /**
    * @brief Override Evaluate
    * @param Obstacle pointer
@@ -62,7 +82,8 @@ class VectornetEvaluator : public Evaluator {
       Obstacle* obstacle_ptr, ObstaclesContainer* obstacles_container,
       std::vector&lt;std::pair&lt;double, double&gt;&gt;* curr_pos_history,
       std::vector&lt;std::pair&lt;double, double&gt;&gt;* all_obs_length,
-      std::vector&lt;std::vector&lt;std::pair&lt;double, double&gt;&gt;&gt;* all_obs_pos_history);
+      std::vector&lt;std::vector&lt;std::pair&lt;double, double&gt;&gt;&gt;* all_obs_pos_history,
+      torch::Tensor* vector_mask);
 
   /**
    * @brief Get the name of evaluator.
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d8d79496528d988faac0129d6fca75c901e0c374" author="fuyiqun">
		<msg>prediction: decouple map_info process

Change-Id: I764444342cd04bdedfea2bc729c84052093959be</msg>
		<modified_files>
			<file old_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" added_lines="58" deleted_lines="33">
				<diff>@@ -112,6 +112,47 @@ bool VectornetEvaluator::VectornetProcessObstaclePosition(
   return true;
 }
 
+bool VectornetEvaluator::VectornetProcessMapData(
+                             FeatureVector* map_feature,
+                             PidVector* map_p_id,
+                             const int obs_num,
+                             torch::Tensor* ptr_map_data,
+                             torch::Tensor* ptr_all_map_p_id,
+                             torch::Tensor* ptr_vector_mask) {
+  int map_polyline_num = map_feature-&gt;size();
+
+  for (int i = 0; i &lt; map_polyline_num &amp;&amp; obs_num + i &lt; 450; ++i) {
+    size_t one_polyline_vector_size = map_feature-&gt;at(i).size();
+    if (one_polyline_vector_size &lt; 50) {
+      ptr_vector_mask-&gt;index_put_({obs_num + i,
+                                   torch::indexing::Slice(
+                                       one_polyline_vector_size,
+                                       torch::indexing::None)},
+                                  1);
+    }
+  }
+
+  auto opts = torch::TensorOptions().dtype(torch::kDouble);
+
+  for (int i = 0; i &lt; map_polyline_num &amp;&amp; i + obs_num &lt; 450; ++i) {
+    ptr_all_map_p_id-&gt;index_put_({i}, torch::from_blob(map_p_id-&gt;at(i).data(),
+                                                       {2},
+                                                       opts));
+
+    int one_polyline_vector_size = map_feature-&gt;at(i).size();
+    for (int j = 0; j &lt; one_polyline_vector_size &amp;&amp; j &lt; 50; ++j) {
+      ptr_map_data-&gt;index_put_({i, j},
+                               torch::from_blob(map_feature-&gt;at(i)[j].data(),
+                                                {9},
+                                                opts));
+    }
+  }
+  *ptr_map_data = ptr_map_data-&gt;toType(at::kFloat);
+  *ptr_all_map_p_id = ptr_all_map_p_id-&gt;toType(at::kFloat);
+
+  return true;
+}
+
 bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
                                   ObstaclesContainer* obstacles_container) {
   omp_set_num_threads(1);
@@ -138,7 +179,7 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   torch::Tensor all_obs_p_id = torch::zeros({obs_num, 2});
   torch::Tensor obs_length_tmp = torch::zeros({obs_num, 2});
 
-  if (VectornetProcessObstaclePosition(obstacle_ptr,
+  if (!VectornetProcessObstaclePosition(obstacle_ptr,
                                        obstacles_container,
                                        &amp;target_obstacle_pos,
                                        &amp;target_obstacle_pos_step,
@@ -152,7 +193,7 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
 
   auto end_time_obs = std::chrono::system_clock::now();
   std::chrono::duration&lt;double&gt; diff_obs = end_time_obs - start_time_obs;
-  ADEBUG &lt;&lt; "obstacle vectors used time: " &lt;&lt; diff_obs.count() * 1000 &lt;&lt; " ms.";
+  AINFO &lt;&lt; "obstacle vectors used time: " &lt;&lt; diff_obs.count() * 1000 &lt;&lt; " ms.";
 
   Feature* latest_feature_ptr = obstacle_ptr-&gt;mutable_latest_feature();
   CHECK_NOTNULL(latest_feature_ptr);
@@ -163,7 +204,7 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   const double pos_x = latest_feature_ptr-&gt;position().x();
   const double pos_y = latest_feature_ptr-&gt;position().y();
   common::PointENU center_point
-      = common::util::PointFactory::ToPointENU(pos_x, pos_y);;
+     = common::util::PointFactory::ToPointENU(pos_x, pos_y);;
   const double heading = latest_feature_ptr-&gt;velocity_heading();
 
   auto start_time_query = std::chrono::system_clock::now();
@@ -174,42 +215,27 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
 
   auto end_time_query = std::chrono::system_clock::now();
   std::chrono::duration&lt;double&gt; diff_query = end_time_query - start_time_query;
-  ADEBUG &lt;&lt; "vectors query used time: " &lt;&lt; diff_query.count() * 1000 &lt;&lt; " ms.";
-
-  // Process all obs pos_history &amp; obs pid
-  auto start_time_data_prep = std::chrono::system_clock::now();
+  AINFO &lt;&lt; "vectors query used time: " &lt;&lt; diff_query.count() * 1000 &lt;&lt; " ms.";
 
   // process map data &amp; map p id &amp; v_mask for map polyline
   int map_polyline_num = map_feature.size();
   int data_length =
       ((obs_num + map_polyline_num) &lt; 450) ? (obs_num + map_polyline_num) : 450;
-  for (int i = 0; i &lt; map_polyline_num &amp;&amp; obs_num + i &lt; 450; ++i) {
-    size_t one_polyline_vector_size = map_feature[i].size();
-    if (one_polyline_vector_size &lt; 50) {
-      vector_mask.index_put_({obs_num + i,
-                              torch::indexing::Slice(one_polyline_vector_size,
-                                                     torch::indexing::None)},
-                             1);
-    }
-  }
 
+  // Process input tensor
+  auto start_time_data_prep = std::chrono::system_clock::now();
   torch::Tensor map_data = torch::zeros({map_polyline_num, 50, 9});
   torch::Tensor all_map_p_id = torch::zeros({map_polyline_num, 2});
-  auto opts = torch::TensorOptions().dtype(torch::kDouble);
-
-  for (int i = 0; i &lt; map_polyline_num &amp;&amp; i + obs_num &lt; 450; ++i) {
-    all_map_p_id[i][0] = map_p_id[i][0];
-    all_map_p_id[i][1] = map_p_id[i][1];
 
-    int one_polyline_vector_size = map_feature[i].size();
-    for (int j = 0; j &lt; one_polyline_vector_size &amp;&amp; j &lt; 50; ++j) {
-      map_data.index_put_({i, j},
-                          torch::from_blob(map_feature[i][j].data(),
-                                           {9},
-                                           opts));
-    }
+  if (!VectornetProcessMapData(&amp;map_feature,
+                               &amp;map_p_id,
+                               obs_num,
+                               &amp;map_data,
+                               &amp;all_map_p_id,
+                               &amp;vector_mask)) {
+    AERROR &lt;&lt; "Obstacle [" &lt;&lt; id &lt;&lt; "] processing map data fails.";
+    return false;
   }
-  map_data = map_data.toType(at::kFloat);
 
   // process p mask
   torch::Tensor polyline_mask = torch::zeros({450});
@@ -285,7 +311,7 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   auto end_time_data_prep = std::chrono::system_clock::now();
   std::chrono::duration&lt;double&gt; diff_data_prep =
       end_time_data_prep - start_time_data_prep;
-  ADEBUG &lt;&lt; "vectornet input tensor prepration used time: "
+  AINFO &lt;&lt; "vectornet input tensor preparation used time: "
          &lt;&lt; diff_data_prep.count() * 1000 &lt;&lt; " ms.";
 
   auto start_time_inference = std::chrono::system_clock::now();
@@ -297,7 +323,7 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   auto end_time_inference = std::chrono::system_clock::now();
   std::chrono::duration&lt;double&gt; diff_inference =
       end_time_inference - start_time_inference;
-  ADEBUG &lt;&lt; "vectornet inference used time: " &lt;&lt; diff_inference.count() * 1000
+  AINFO &lt;&lt; "vectornet inference used time: " &lt;&lt; diff_inference.count() * 1000
          &lt;&lt; " ms.";
 
   // Get the trajectory
@@ -352,7 +378,7 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   auto end_time_output_process = std::chrono::system_clock::now();
   std::chrono::duration&lt;double&gt; diff_output_process =
       end_time_output_process - start_time_output_process;
-  ADEBUG &lt;&lt; "vectornet output process used time: "
+  AINFO &lt;&lt; "vectornet output process used time: "
          &lt;&lt; diff_output_process.count() * 1000 &lt;&lt; " ms.";
   return true;
 }
@@ -434,7 +460,6 @@ void VectornetEvaluator::LoadModel() {
         torch::jit::load(FLAGS_torch_vehicle_vectornet_cpu_file, device_);
   }
   torch::set_num_threads(1);
-  AINFO &lt;&lt; "CUDA is 11111";
 
   // Fake intput for the first frame
   torch::Tensor target_obstacle_pos = torch::randn({1, 20, 2});
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.h" new_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.h" added_lines="15" deleted_lines="0">
				<diff>@@ -65,6 +65,21 @@ class VectornetEvaluator : public Evaluator {
                                     torch::Tensor* ptr_all_obs_p_id,
                                     torch::Tensor* ptr_obs_length);
 
+  /**
+  * @brief Process map data to vector
+  * @param FeatureVector: map feature vector
+  * @param int: obstacle number
+  * @param PidVector: map p_id vector
+  * @param Tensor: map data
+  * @param Tensor: map data p_id
+  */
+  bool VectornetProcessMapData(FeatureVector *map_feature,
+                               PidVector *map_p_id,
+                               const int obs_num,
+                               torch::Tensor* ptr_map_data,
+                               torch::Tensor* ptr_all_map_p_id,
+                               torch::Tensor* ptr_vector_mask);
+
   /**
    * @brief Override Evaluate
    * @param Obstacle pointer
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="04bfd8323a5d4fbcfc8c4bcc74a898523efc50bf" author="jiangjianan">
		<msg>Prediction: modified jointly evaluator to prevent core dump when adc traj point num is less than 1

Change-Id: Ib27016f580b92d035e9628b65b66ab83f584d367</msg>
		<modified_files>
			<file old_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.cc" added_lines="152" deleted_lines="77">
				<diff>@@ -44,6 +44,118 @@ JointlyPredictionPlanningEvaluator::JointlyPredictionPlanningEvaluator()
 
 void JointlyPredictionPlanningEvaluator::Clear() {}
 
+bool JointlyPredictionPlanningEvaluator::VectornetProcessObstaclePosition(
+      Obstacle* obstacle_ptr,
+      ObstaclesContainer* obstacles_container,
+      torch::Tensor* ptr_target_obs_pos,
+      torch::Tensor* ptr_target_obs_pos_step,
+      torch::Tensor* ptr_vector_mask,
+      torch::Tensor* ptr_all_obstacle_pos,
+      torch::Tensor* ptr_all_obs_p_id,
+      torch::Tensor* ptr_obs_length) {
+  // obs data vector
+  // Extract features of pos_history
+  std::vector&lt;std::pair&lt;double, double&gt;&gt; target_pos_history(20, {0.0, 0.0});
+  std::vector&lt;std::pair&lt;double, double&gt;&gt; all_obs_length;
+  std::vector&lt;std::vector&lt;std::pair&lt;double, double&gt;&gt;&gt; all_obs_pos_history;
+
+  if (!ExtractObstaclesHistory(obstacle_ptr, obstacles_container,
+                               &amp;target_pos_history, &amp;all_obs_length,
+                               &amp;all_obs_pos_history, ptr_vector_mask)) {
+    AERROR &lt;&lt; "Obstacle [" &lt;&lt; obstacle_ptr-&gt;id()
+           &lt;&lt; "] failed to extract obstacle history";
+    return false;
+  }
+
+  for (int j = 0; j &lt; 20; ++j) {
+    ptr_target_obs_pos-&gt;index_put_({19 - j, 0}, target_pos_history[j].first);
+    ptr_target_obs_pos-&gt;index_put_({19 - j, 1}, target_pos_history[j].second);
+    if (j == 19 || (j &gt; 0 &amp;&amp; target_pos_history[j + 1].first == 0.0)) {
+      break;
+    }
+    ptr_target_obs_pos_step-&gt;index_put_(
+        {19 - j, 0},
+        target_pos_history[j].first - target_pos_history[j + 1].first);
+    ptr_target_obs_pos_step-&gt;index_put_(
+        {19 - j, 1},
+        target_pos_history[j].second - target_pos_history[j + 1].second);
+  }
+
+  int obs_num =
+      obstacles_container-&gt;curr_frame_considered_obstacle_ids().size();
+  for (int i = 0; i &lt; obs_num; ++i) {
+    std::vector&lt;double&gt; obs_p_id{std::numeric_limits&lt;float&gt;::max(),
+                              std::numeric_limits&lt;float&gt;::max()};
+    for (int j = 0; j &lt; 20; ++j) {
+      // Process obs pid
+      if (obs_p_id[0] &gt; all_obs_pos_history[i][j].first) {
+        obs_p_id[0] = all_obs_pos_history[i][j].first;
+      }
+      if (obs_p_id[1] &gt; all_obs_pos_history[i][j].second) {
+        obs_p_id[1] = all_obs_pos_history[i][j].second;
+      }
+      // Process obs pos history
+      ptr_all_obstacle_pos-&gt;index_put_(
+          {i, 19 - j, 0},
+          all_obs_pos_history[i][j].first);
+      ptr_all_obstacle_pos-&gt;index_put_(
+          {i, 19 - j, 1},
+          all_obs_pos_history[i][j].second);
+    }
+
+    ptr_all_obs_p_id-&gt;index_put_({i, 0}, obs_p_id[0]);
+    ptr_all_obs_p_id-&gt;index_put_({i, 1}, obs_p_id[1]);
+  }
+
+  for (int i = 0; i &lt; obs_num; ++i) {
+    ptr_obs_length-&gt;index_put_({i, 0}, all_obs_length[i].first);
+    ptr_obs_length-&gt;index_put_({i, 1}, all_obs_length[i].second);
+  }
+
+  return true;
+}
+
+bool JointlyPredictionPlanningEvaluator::VectornetProcessMapData(
+      FeatureVector* map_feature,
+      PidVector* map_p_id,
+      const int obs_num,
+      torch::Tensor* ptr_map_data,
+      torch::Tensor* ptr_all_map_p_id,
+      torch::Tensor* ptr_vector_mask) {
+  int map_polyline_num = map_feature-&gt;size();
+
+  for (int i = 0; i &lt; map_polyline_num &amp;&amp; obs_num + i &lt; 450; ++i) {
+    size_t one_polyline_vector_size = map_feature-&gt;at(i).size();
+    if (one_polyline_vector_size &lt; 50) {
+      ptr_vector_mask-&gt;index_put_({obs_num + i,
+                                   torch::indexing::Slice(
+                                       one_polyline_vector_size,
+                                       torch::indexing::None)},
+                                  1);
+    }
+  }
+
+  auto opts = torch::TensorOptions().dtype(torch::kDouble);
+
+  for (int i = 0; i &lt; map_polyline_num &amp;&amp; i + obs_num &lt; 450; ++i) {
+    ptr_all_map_p_id-&gt;index_put_({i}, torch::from_blob(map_p_id-&gt;at(i).data(),
+                                                       {2},
+                                                       opts));
+
+    int one_polyline_vector_size = map_feature-&gt;at(i).size();
+    for (int j = 0; j &lt; one_polyline_vector_size &amp;&amp; j &lt; 50; ++j) {
+      ptr_map_data-&gt;index_put_({i, j},
+                               torch::from_blob(map_feature-&gt;at(i)[j].data(),
+                                                {9},
+                                                opts));
+    }
+  }
+  *ptr_map_data = ptr_map_data-&gt;toType(at::kFloat);
+  *ptr_all_map_p_id = ptr_all_map_p_id-&gt;toType(at::kFloat);
+
+  return true;
+}
+
 bool JointlyPredictionPlanningEvaluator::Evaluate(Obstacle* obstacle_ptr,
                                      ObstaclesContainer* obstacles_container) {
   const ADCTrajectoryContainer* adc_trajectory_container;
@@ -74,22 +186,35 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
     return false;
   }
 
-  // obs data vector
-  // Extract features of pos_history
-  std::vector&lt;std::pair&lt;double, double&gt;&gt; target_pos_history(20, {0.0, 0.0});
-  std::vector&lt;std::pair&lt;double, double&gt;&gt; all_obs_length;
-  std::vector&lt;std::vector&lt;std::pair&lt;double, double&gt;&gt;&gt; all_obs_pos_history;
-  // Process mask
-  // process v_mask for obs
+  int obs_num =
+      obstacles_container-&gt;curr_frame_considered_obstacle_ids().size();
+
+  auto start_time_obs = std::chrono::system_clock::now();
+
+  torch::Tensor target_obstacle_pos = torch::zeros({20, 2});
+  torch::Tensor target_obstacle_pos_step = torch::zeros({20, 2});
   torch::Tensor vector_mask = torch::zeros({450, 50});
+  torch::Tensor all_obstacle_pos = torch::zeros({obs_num, 20, 2});
+  torch::Tensor all_obs_p_id = torch::zeros({obs_num, 2});
+  torch::Tensor obs_length_tmp = torch::zeros({obs_num, 2});
 
-  if (!ExtractObstaclesHistory(obstacle_ptr, obstacles_container,
-                               &amp;target_pos_history, &amp;all_obs_length,
-                               &amp;all_obs_pos_history, &amp;vector_mask)) {
-    ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id &lt;&lt; "] failed to extract obstacle history";
+  if (!VectornetProcessObstaclePosition(obstacle_ptr,
+                                       obstacles_container,
+                                       &amp;target_obstacle_pos,
+                                       &amp;target_obstacle_pos_step,
+                                       &amp;vector_mask,
+                                       &amp;all_obstacle_pos,
+                                       &amp;all_obs_p_id,
+                                       &amp;obs_length_tmp)) {
+    AERROR &lt;&lt; "Obstacle [" &lt;&lt; id &lt;&lt; "] processing obstacle position fails.";
     return false;
   }
 
+  auto end_time_obs = std::chrono::system_clock::now();
+  std::chrono::duration&lt;double&gt; diff_obs = end_time_obs - start_time_obs;
+  ADEBUG &lt;&lt; "obstacle vectors used time: " &lt;&lt; diff_obs.count() * 1000 &lt;&lt; " ms.";
+
+
   // Query the map data vector
   FeatureVector map_feature;
   PidVector map_p_id;
@@ -110,75 +235,25 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
   std::chrono::duration&lt;double&gt; diff_query = end_time_query - start_time_query;
   ADEBUG &lt;&lt; "vectors query used time: " &lt;&lt; diff_query.count() * 1000 &lt;&lt; " ms.";
 
-  // Process all obs pos_history &amp; obs pid
-  auto start_time_data_prep = std::chrono::system_clock::now();
-  int obs_num =
-      obstacles_container-&gt;curr_frame_considered_obstacle_ids().size();
-  torch::Tensor target_obstacle_pos = torch::zeros({20, 2});
-  torch::Tensor target_obstacle_pos_step = torch::zeros({20, 2});
-  for (int j = 0; j &lt; 20; ++j) {
-    target_obstacle_pos[19 - j][0] = target_pos_history[j].first;
-    target_obstacle_pos[19 - j][1] = target_pos_history[j].second;
-    if (j == 19 || (j &gt; 0 &amp;&amp; target_pos_history[j + 1].first == 0.0)) {
-      break;
-    }
-    target_obstacle_pos_step[19 - j][0] =
-        target_pos_history[j].first - target_pos_history[j + 1].first;
-    target_obstacle_pos_step[19 - j][1] =
-        target_pos_history[j].second - target_pos_history[j + 1].second;
-  }
-
-  torch::Tensor all_obstacle_pos = torch::zeros({obs_num, 20, 2});
-  torch::Tensor all_obs_p_id = torch::zeros({obs_num, 2});
-  for (int i = 0; i &lt; obs_num; ++i) {
-    std::vector&lt;double&gt; obs_p_id{std::numeric_limits&lt;float&gt;::max(),
-                              std::numeric_limits&lt;float&gt;::max()};
-    for (int j = 0; j &lt; 20; ++j) {
-      // Process obs pid
-      if (obs_p_id[0] &gt; all_obs_pos_history[i][j].first) {
-        obs_p_id[0] = all_obs_pos_history[i][j].first;
-      }
-      if (obs_p_id[1] &gt; all_obs_pos_history[i][j].second) {
-        obs_p_id[1] = all_obs_pos_history[i][j].second;
-      }
-      // Process obs pos history
-      all_obstacle_pos[i][19 - j][0] = all_obs_pos_history[i][j].first;
-      all_obstacle_pos[i][19 - j][1] = all_obs_pos_history[i][j].second;
-    }
-    all_obs_p_id[i][0] = obs_p_id[0];
-    all_obs_p_id[i][1] = obs_p_id[1];
-  }
-
   // process map data &amp; map p id &amp; v_mask for map polyline
   int map_polyline_num = map_feature.size();
   int data_length =
       ((obs_num + map_polyline_num) &lt; 450) ? (obs_num + map_polyline_num) : 450;
-  for (int i = 0; i &lt; map_polyline_num &amp;&amp; obs_num + i &lt; 450; ++i) {
-    size_t one_polyline_vector_size = map_feature[i].size();
-    if (one_polyline_vector_size &lt; 50) {
-      vector_mask.index_put_({obs_num + i,
-                             torch::indexing::Slice(one_polyline_vector_size,
-                                                    torch::indexing::None)},
-                             1);
-    }
-  }
 
+  // Process input tensor
+  auto start_time_data_prep = std::chrono::system_clock::now();
   torch::Tensor map_data = torch::zeros({map_polyline_num, 50, 9});
   torch::Tensor all_map_p_id = torch::zeros({map_polyline_num, 2});
-  auto opts = torch::TensorOptions().dtype(torch::kDouble);
-
-  for (int i = 0; i &lt; map_polyline_num &amp;&amp; i + obs_num &lt; 450; ++i) {
-    all_map_p_id[i][0] = map_p_id[i][0];
-    all_map_p_id[i][1] = map_p_id[i][1];
 
-    int one_polyline_vector_size = map_feature[i].size();
-    for (int j = 0; j &lt; one_polyline_vector_size &amp;&amp; j &lt; 50; ++j) {
-      map_data.index_put_({i, j},
-                          torch::from_blob(map_feature[i][j].data(),
-                          {9}, opts));
-    }
+  if (!VectornetProcessMapData(&amp;map_feature,
+                               &amp;map_p_id,
+                               obs_num,
+                               &amp;map_data,
+                               &amp;all_map_p_id,
+                               &amp;vector_mask)) {
+    AERROR &lt;&lt; "Obstacle [" &lt;&lt; id &lt;&lt; "] processing map data fails.";
+    return false;
   }
-  map_data = map_data.toType(at::kFloat);
 
   // process p mask
   torch::Tensor polyline_mask = torch::zeros({450});
@@ -198,11 +273,6 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
                                torch::indexing::Slice()})},
       2);
   // Add obs length
-  torch::Tensor obs_length_tmp = torch::zeros({obs_num, 2});
-  for (int i = 0; i &lt; obs_num; ++i) {
-    obs_length_tmp[i][0] = all_obs_length[i].first;
-    obs_length_tmp[i][1] = all_obs_length[i].second;
-  }
   torch::Tensor obs_length = obs_length_tmp.unsqueeze(1).repeat({1, 19, 1});
   // Add obs attribute
   torch::Tensor obs_attr_agent =
@@ -250,6 +320,11 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
   torch::Tensor adc_trajectory = torch::zeros({1, 30, 6});
   const auto&amp; adc_traj = adc_trajectory_container-&gt;adc_trajectory();
   size_t adc_traj_points_num = adc_traj.trajectory_point().size();
+  if (adc_traj_points_num &lt; 1) {
+    AERROR &lt;&lt; "adc_traj points num is " &lt;&lt; adc_traj_points_num
+           &lt;&lt; " adc traj points are not enough";
+    return false;
+  }
   std::vector&lt;TrajectoryPoint&gt; adc_traj_points;
   // ADC trajectory info as model input needs to match with
   // the predicted obstalce's timestamp.
@@ -265,7 +340,7 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
   }
   if (!ExtractADCTrajectory(&amp;adc_traj_points,
       obstacle_ptr, &amp;adc_traj_curr_pos)) {
-    ADEBUG &lt;&lt; "Failed to extract adc trajectory";
+    AERROR &lt;&lt; "Failed to extract adc trajectory";
     return false;
   }
   size_t traj_points_num = adc_traj_points.size();
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.h" new_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.h" added_lines="35" deleted_lines="0">
				<diff>@@ -48,6 +48,41 @@ class JointlyPredictionPlanningEvaluator : public Evaluator {
    */
   void Clear();
 
+  /**
+   * @brief Process obstacle position to vector
+   * @param Obstacles pointer
+   * @param Obstacles container
+   * @param Tensor: target obstacle position
+   * @param Tensor: target obstacle position step
+   * @param Tensor: vector mask
+   * @param Tensor: all obstacle position
+   * @param Tensor: all obstacle p_id
+   * @param Tensor: all obstacle length
+   */
+  bool VectornetProcessObstaclePosition(Obstacle* obstacle_ptr,
+                                    ObstaclesContainer* obstacles_container,
+                                    torch::Tensor* ptr_target_obs_pos,
+                                    torch::Tensor* ptr_target_obs_pos_step,
+                                    torch::Tensor* ptr_vector_mask,
+                                    torch::Tensor* ptr_all_obstacle_pos,
+                                    torch::Tensor* ptr_all_obs_p_id,
+                                    torch::Tensor* ptr_obs_length);
+
+  /**
+  * @brief Process map data to vector
+  * @param FeatureVector: map feature vector
+  * @param int: obstacle number
+  * @param PidVector: map p_id vector
+  * @param Tensor: map data
+  * @param Tensor: map data p_id
+  */
+  bool VectornetProcessMapData(FeatureVector *map_feature,
+                               PidVector *map_p_id,
+                               const int obs_num,
+                               torch::Tensor* ptr_map_data,
+                               torch::Tensor* ptr_all_map_p_id,
+                               torch::Tensor* ptr_vector_mask);
+
   /**
    * @brief Override Evaluate
    * @param Obstacle pointer
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="883afd3cb2a2b2683610666863d43ad28d77f592" author="jiangjianan">
		<msg>Prediction: modified jointly evaluator to prevent core dump when adc traj point num is less than 1

Change-Id: Ib27016f580b92d035e9628b65b66ab83f584d367</msg>
		<modified_files>
			<file old_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.cc" added_lines="152" deleted_lines="77">
				<diff>@@ -44,6 +44,118 @@ JointlyPredictionPlanningEvaluator::JointlyPredictionPlanningEvaluator()
 
 void JointlyPredictionPlanningEvaluator::Clear() {}
 
+bool JointlyPredictionPlanningEvaluator::VectornetProcessObstaclePosition(
+      Obstacle* obstacle_ptr,
+      ObstaclesContainer* obstacles_container,
+      torch::Tensor* ptr_target_obs_pos,
+      torch::Tensor* ptr_target_obs_pos_step,
+      torch::Tensor* ptr_vector_mask,
+      torch::Tensor* ptr_all_obstacle_pos,
+      torch::Tensor* ptr_all_obs_p_id,
+      torch::Tensor* ptr_obs_length) {
+  // obs data vector
+  // Extract features of pos_history
+  std::vector&lt;std::pair&lt;double, double&gt;&gt; target_pos_history(20, {0.0, 0.0});
+  std::vector&lt;std::pair&lt;double, double&gt;&gt; all_obs_length;
+  std::vector&lt;std::vector&lt;std::pair&lt;double, double&gt;&gt;&gt; all_obs_pos_history;
+
+  if (!ExtractObstaclesHistory(obstacle_ptr, obstacles_container,
+                               &amp;target_pos_history, &amp;all_obs_length,
+                               &amp;all_obs_pos_history, ptr_vector_mask)) {
+    AERROR &lt;&lt; "Obstacle [" &lt;&lt; obstacle_ptr-&gt;id()
+           &lt;&lt; "] failed to extract obstacle history";
+    return false;
+  }
+
+  for (int j = 0; j &lt; 20; ++j) {
+    ptr_target_obs_pos-&gt;index_put_({19 - j, 0}, target_pos_history[j].first);
+    ptr_target_obs_pos-&gt;index_put_({19 - j, 1}, target_pos_history[j].second);
+    if (j == 19 || (j &gt; 0 &amp;&amp; target_pos_history[j + 1].first == 0.0)) {
+      break;
+    }
+    ptr_target_obs_pos_step-&gt;index_put_(
+        {19 - j, 0},
+        target_pos_history[j].first - target_pos_history[j + 1].first);
+    ptr_target_obs_pos_step-&gt;index_put_(
+        {19 - j, 1},
+        target_pos_history[j].second - target_pos_history[j + 1].second);
+  }
+
+  int obs_num =
+      obstacles_container-&gt;curr_frame_considered_obstacle_ids().size();
+  for (int i = 0; i &lt; obs_num; ++i) {
+    std::vector&lt;double&gt; obs_p_id{std::numeric_limits&lt;float&gt;::max(),
+                              std::numeric_limits&lt;float&gt;::max()};
+    for (int j = 0; j &lt; 20; ++j) {
+      // Process obs pid
+      if (obs_p_id[0] &gt; all_obs_pos_history[i][j].first) {
+        obs_p_id[0] = all_obs_pos_history[i][j].first;
+      }
+      if (obs_p_id[1] &gt; all_obs_pos_history[i][j].second) {
+        obs_p_id[1] = all_obs_pos_history[i][j].second;
+      }
+      // Process obs pos history
+      ptr_all_obstacle_pos-&gt;index_put_(
+          {i, 19 - j, 0},
+          all_obs_pos_history[i][j].first);
+      ptr_all_obstacle_pos-&gt;index_put_(
+          {i, 19 - j, 1},
+          all_obs_pos_history[i][j].second);
+    }
+
+    ptr_all_obs_p_id-&gt;index_put_({i, 0}, obs_p_id[0]);
+    ptr_all_obs_p_id-&gt;index_put_({i, 1}, obs_p_id[1]);
+  }
+
+  for (int i = 0; i &lt; obs_num; ++i) {
+    ptr_obs_length-&gt;index_put_({i, 0}, all_obs_length[i].first);
+    ptr_obs_length-&gt;index_put_({i, 1}, all_obs_length[i].second);
+  }
+
+  return true;
+}
+
+bool JointlyPredictionPlanningEvaluator::VectornetProcessMapData(
+      FeatureVector* map_feature,
+      PidVector* map_p_id,
+      const int obs_num,
+      torch::Tensor* ptr_map_data,
+      torch::Tensor* ptr_all_map_p_id,
+      torch::Tensor* ptr_vector_mask) {
+  int map_polyline_num = map_feature-&gt;size();
+
+  for (int i = 0; i &lt; map_polyline_num &amp;&amp; obs_num + i &lt; 450; ++i) {
+    size_t one_polyline_vector_size = map_feature-&gt;at(i).size();
+    if (one_polyline_vector_size &lt; 50) {
+      ptr_vector_mask-&gt;index_put_({obs_num + i,
+                                   torch::indexing::Slice(
+                                       one_polyline_vector_size,
+                                       torch::indexing::None)},
+                                  1);
+    }
+  }
+
+  auto opts = torch::TensorOptions().dtype(torch::kDouble);
+
+  for (int i = 0; i &lt; map_polyline_num &amp;&amp; i + obs_num &lt; 450; ++i) {
+    ptr_all_map_p_id-&gt;index_put_({i}, torch::from_blob(map_p_id-&gt;at(i).data(),
+                                                       {2},
+                                                       opts));
+
+    int one_polyline_vector_size = map_feature-&gt;at(i).size();
+    for (int j = 0; j &lt; one_polyline_vector_size &amp;&amp; j &lt; 50; ++j) {
+      ptr_map_data-&gt;index_put_({i, j},
+                               torch::from_blob(map_feature-&gt;at(i)[j].data(),
+                                                {9},
+                                                opts));
+    }
+  }
+  *ptr_map_data = ptr_map_data-&gt;toType(at::kFloat);
+  *ptr_all_map_p_id = ptr_all_map_p_id-&gt;toType(at::kFloat);
+
+  return true;
+}
+
 bool JointlyPredictionPlanningEvaluator::Evaluate(Obstacle* obstacle_ptr,
                                      ObstaclesContainer* obstacles_container) {
   const ADCTrajectoryContainer* adc_trajectory_container;
@@ -74,22 +186,35 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
     return false;
   }
 
-  // obs data vector
-  // Extract features of pos_history
-  std::vector&lt;std::pair&lt;double, double&gt;&gt; target_pos_history(20, {0.0, 0.0});
-  std::vector&lt;std::pair&lt;double, double&gt;&gt; all_obs_length;
-  std::vector&lt;std::vector&lt;std::pair&lt;double, double&gt;&gt;&gt; all_obs_pos_history;
-  // Process mask
-  // process v_mask for obs
+  int obs_num =
+      obstacles_container-&gt;curr_frame_considered_obstacle_ids().size();
+
+  auto start_time_obs = std::chrono::system_clock::now();
+
+  torch::Tensor target_obstacle_pos = torch::zeros({20, 2});
+  torch::Tensor target_obstacle_pos_step = torch::zeros({20, 2});
   torch::Tensor vector_mask = torch::zeros({450, 50});
+  torch::Tensor all_obstacle_pos = torch::zeros({obs_num, 20, 2});
+  torch::Tensor all_obs_p_id = torch::zeros({obs_num, 2});
+  torch::Tensor obs_length_tmp = torch::zeros({obs_num, 2});
 
-  if (!ExtractObstaclesHistory(obstacle_ptr, obstacles_container,
-                               &amp;target_pos_history, &amp;all_obs_length,
-                               &amp;all_obs_pos_history, &amp;vector_mask)) {
-    ADEBUG &lt;&lt; "Obstacle [" &lt;&lt; id &lt;&lt; "] failed to extract obstacle history";
+  if (!VectornetProcessObstaclePosition(obstacle_ptr,
+                                       obstacles_container,
+                                       &amp;target_obstacle_pos,
+                                       &amp;target_obstacle_pos_step,
+                                       &amp;vector_mask,
+                                       &amp;all_obstacle_pos,
+                                       &amp;all_obs_p_id,
+                                       &amp;obs_length_tmp)) {
+    AERROR &lt;&lt; "Obstacle [" &lt;&lt; id &lt;&lt; "] processing obstacle position fails.";
     return false;
   }
 
+  auto end_time_obs = std::chrono::system_clock::now();
+  std::chrono::duration&lt;double&gt; diff_obs = end_time_obs - start_time_obs;
+  ADEBUG &lt;&lt; "obstacle vectors used time: " &lt;&lt; diff_obs.count() * 1000 &lt;&lt; " ms.";
+
+
   // Query the map data vector
   FeatureVector map_feature;
   PidVector map_p_id;
@@ -110,75 +235,25 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
   std::chrono::duration&lt;double&gt; diff_query = end_time_query - start_time_query;
   ADEBUG &lt;&lt; "vectors query used time: " &lt;&lt; diff_query.count() * 1000 &lt;&lt; " ms.";
 
-  // Process all obs pos_history &amp; obs pid
-  auto start_time_data_prep = std::chrono::system_clock::now();
-  int obs_num =
-      obstacles_container-&gt;curr_frame_considered_obstacle_ids().size();
-  torch::Tensor target_obstacle_pos = torch::zeros({20, 2});
-  torch::Tensor target_obstacle_pos_step = torch::zeros({20, 2});
-  for (int j = 0; j &lt; 20; ++j) {
-    target_obstacle_pos[19 - j][0] = target_pos_history[j].first;
-    target_obstacle_pos[19 - j][1] = target_pos_history[j].second;
-    if (j == 19 || (j &gt; 0 &amp;&amp; target_pos_history[j + 1].first == 0.0)) {
-      break;
-    }
-    target_obstacle_pos_step[19 - j][0] =
-        target_pos_history[j].first - target_pos_history[j + 1].first;
-    target_obstacle_pos_step[19 - j][1] =
-        target_pos_history[j].second - target_pos_history[j + 1].second;
-  }
-
-  torch::Tensor all_obstacle_pos = torch::zeros({obs_num, 20, 2});
-  torch::Tensor all_obs_p_id = torch::zeros({obs_num, 2});
-  for (int i = 0; i &lt; obs_num; ++i) {
-    std::vector&lt;double&gt; obs_p_id{std::numeric_limits&lt;float&gt;::max(),
-                              std::numeric_limits&lt;float&gt;::max()};
-    for (int j = 0; j &lt; 20; ++j) {
-      // Process obs pid
-      if (obs_p_id[0] &gt; all_obs_pos_history[i][j].first) {
-        obs_p_id[0] = all_obs_pos_history[i][j].first;
-      }
-      if (obs_p_id[1] &gt; all_obs_pos_history[i][j].second) {
-        obs_p_id[1] = all_obs_pos_history[i][j].second;
-      }
-      // Process obs pos history
-      all_obstacle_pos[i][19 - j][0] = all_obs_pos_history[i][j].first;
-      all_obstacle_pos[i][19 - j][1] = all_obs_pos_history[i][j].second;
-    }
-    all_obs_p_id[i][0] = obs_p_id[0];
-    all_obs_p_id[i][1] = obs_p_id[1];
-  }
-
   // process map data &amp; map p id &amp; v_mask for map polyline
   int map_polyline_num = map_feature.size();
   int data_length =
       ((obs_num + map_polyline_num) &lt; 450) ? (obs_num + map_polyline_num) : 450;
-  for (int i = 0; i &lt; map_polyline_num &amp;&amp; obs_num + i &lt; 450; ++i) {
-    size_t one_polyline_vector_size = map_feature[i].size();
-    if (one_polyline_vector_size &lt; 50) {
-      vector_mask.index_put_({obs_num + i,
-                             torch::indexing::Slice(one_polyline_vector_size,
-                                                    torch::indexing::None)},
-                             1);
-    }
-  }
 
+  // Process input tensor
+  auto start_time_data_prep = std::chrono::system_clock::now();
   torch::Tensor map_data = torch::zeros({map_polyline_num, 50, 9});
   torch::Tensor all_map_p_id = torch::zeros({map_polyline_num, 2});
-  auto opts = torch::TensorOptions().dtype(torch::kDouble);
-
-  for (int i = 0; i &lt; map_polyline_num &amp;&amp; i + obs_num &lt; 450; ++i) {
-    all_map_p_id[i][0] = map_p_id[i][0];
-    all_map_p_id[i][1] = map_p_id[i][1];
 
-    int one_polyline_vector_size = map_feature[i].size();
-    for (int j = 0; j &lt; one_polyline_vector_size &amp;&amp; j &lt; 50; ++j) {
-      map_data.index_put_({i, j},
-                          torch::from_blob(map_feature[i][j].data(),
-                          {9}, opts));
-    }
+  if (!VectornetProcessMapData(&amp;map_feature,
+                               &amp;map_p_id,
+                               obs_num,
+                               &amp;map_data,
+                               &amp;all_map_p_id,
+                               &amp;vector_mask)) {
+    AERROR &lt;&lt; "Obstacle [" &lt;&lt; id &lt;&lt; "] processing map data fails.";
+    return false;
   }
-  map_data = map_data.toType(at::kFloat);
 
   // process p mask
   torch::Tensor polyline_mask = torch::zeros({450});
@@ -198,11 +273,6 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
                                torch::indexing::Slice()})},
       2);
   // Add obs length
-  torch::Tensor obs_length_tmp = torch::zeros({obs_num, 2});
-  for (int i = 0; i &lt; obs_num; ++i) {
-    obs_length_tmp[i][0] = all_obs_length[i].first;
-    obs_length_tmp[i][1] = all_obs_length[i].second;
-  }
   torch::Tensor obs_length = obs_length_tmp.unsqueeze(1).repeat({1, 19, 1});
   // Add obs attribute
   torch::Tensor obs_attr_agent =
@@ -250,6 +320,11 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
   torch::Tensor adc_trajectory = torch::zeros({1, 30, 6});
   const auto&amp; adc_traj = adc_trajectory_container-&gt;adc_trajectory();
   size_t adc_traj_points_num = adc_traj.trajectory_point().size();
+  if (adc_traj_points_num &lt; 1) {
+    AERROR &lt;&lt; "adc_traj points num is " &lt;&lt; adc_traj_points_num
+           &lt;&lt; " adc traj points are not enough";
+    return false;
+  }
   std::vector&lt;TrajectoryPoint&gt; adc_traj_points;
   // ADC trajectory info as model input needs to match with
   // the predicted obstalce's timestamp.
@@ -265,7 +340,7 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
   }
   if (!ExtractADCTrajectory(&amp;adc_traj_points,
       obstacle_ptr, &amp;adc_traj_curr_pos)) {
-    ADEBUG &lt;&lt; "Failed to extract adc trajectory";
+    AERROR &lt;&lt; "Failed to extract adc trajectory";
     return false;
   }
   size_t traj_points_num = adc_traj_points.size();
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.h" new_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.h" added_lines="35" deleted_lines="0">
				<diff>@@ -48,6 +48,41 @@ class JointlyPredictionPlanningEvaluator : public Evaluator {
    */
   void Clear();
 
+  /**
+   * @brief Process obstacle position to vector
+   * @param Obstacles pointer
+   * @param Obstacles container
+   * @param Tensor: target obstacle position
+   * @param Tensor: target obstacle position step
+   * @param Tensor: vector mask
+   * @param Tensor: all obstacle position
+   * @param Tensor: all obstacle p_id
+   * @param Tensor: all obstacle length
+   */
+  bool VectornetProcessObstaclePosition(Obstacle* obstacle_ptr,
+                                    ObstaclesContainer* obstacles_container,
+                                    torch::Tensor* ptr_target_obs_pos,
+                                    torch::Tensor* ptr_target_obs_pos_step,
+                                    torch::Tensor* ptr_vector_mask,
+                                    torch::Tensor* ptr_all_obstacle_pos,
+                                    torch::Tensor* ptr_all_obs_p_id,
+                                    torch::Tensor* ptr_obs_length);
+
+  /**
+  * @brief Process map data to vector
+  * @param FeatureVector: map feature vector
+  * @param int: obstacle number
+  * @param PidVector: map p_id vector
+  * @param Tensor: map data
+  * @param Tensor: map data p_id
+  */
+  bool VectornetProcessMapData(FeatureVector *map_feature,
+                               PidVector *map_p_id,
+                               const int obs_num,
+                               torch::Tensor* ptr_map_data,
+                               torch::Tensor* ptr_all_map_p_id,
+                               torch::Tensor* ptr_vector_mask);
+
   /**
    * @brief Override Evaluate
    * @param Obstacle pointer
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a7a1d9cef6700ff92c43d6beed43499115c72d4a" author="fuyiqun">
		<msg>prediction: decouple obstacle data process

Change-Id: I6b9f793af7109ba92821b9b6a3a3e88c9febc17f</msg>
		<modified_files>
			<file old_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" added_lines="52" deleted_lines="50">
				<diff>@@ -47,10 +47,8 @@ bool VectornetEvaluator::VectornetProcessObstaclePosition(
                              torch::Tensor* ptr_target_obs_pos,
                              torch::Tensor* ptr_target_obs_pos_step,
                              torch::Tensor* ptr_vector_mask,
-                             torch::Tensor* ptr_all_obstacle_pos,
-                             torch::Tensor* ptr_all_obs_p_id,
-                             torch::Tensor* ptr_obs_length) {
-  // obs data vector
+                             torch::Tensor* ptr_obstacle_data,
+                             torch::Tensor* ptr_all_obs_p_id) {
   // Extract features of pos_history
   std::vector&lt;std::pair&lt;double, double&gt;&gt; target_pos_history(20, {0.0, 0.0});
   std::vector&lt;std::pair&lt;double, double&gt;&gt; all_obs_length;
@@ -80,9 +78,13 @@ bool VectornetEvaluator::VectornetProcessObstaclePosition(
 
   int obs_num =
       obstacles_container-&gt;curr_frame_considered_obstacle_ids().size();
+  torch::Tensor all_obstacle_pos = torch::zeros({obs_num, 20, 2});
+  torch::Tensor obs_length_data = torch::zeros({obs_num, 2});
+  auto opts = torch::TensorOptions().dtype(torch::kDouble);
+
   for (int i = 0; i &lt; obs_num; ++i) {
     std::vector&lt;double&gt; obs_p_id{std::numeric_limits&lt;float&gt;::max(),
-                              std::numeric_limits&lt;float&gt;::max()};
+                                 std::numeric_limits&lt;float&gt;::max()};
     for (int j = 0; j &lt; 20; ++j) {
       // Process obs pid
       if (obs_p_id[0] &gt; all_obs_pos_history[i][j].first) {
@@ -92,22 +94,54 @@ bool VectornetEvaluator::VectornetProcessObstaclePosition(
         obs_p_id[1] = all_obs_pos_history[i][j].second;
       }
       // Process obs pos history
-      ptr_all_obstacle_pos-&gt;index_put_(
+      all_obstacle_pos.index_put_(
           {i, 19 - j, 0},
           all_obs_pos_history[i][j].first);
-      ptr_all_obstacle_pos-&gt;index_put_(
+      all_obstacle_pos.index_put_(
           {i, 19 - j, 1},
           all_obs_pos_history[i][j].second);
     }
 
-    ptr_all_obs_p_id-&gt;index_put_({i, 0}, obs_p_id[0]);
-    ptr_all_obs_p_id-&gt;index_put_({i, 1}, obs_p_id[1]);
+    ptr_all_obs_p_id-&gt;index_put_({i},
+                                 torch::from_blob(obs_p_id.data(), {2}, opts));
+    obs_length_data.index_put_({i, 0}, all_obs_length[i].first);
+    obs_length_data.index_put_({i, 1}, all_obs_length[i].second);
   }
 
-  for (int i = 0; i &lt; obs_num; ++i) {
-    ptr_obs_length-&gt;index_put_({i, 0}, all_obs_length[i].first);
-    ptr_obs_length-&gt;index_put_({i, 1}, all_obs_length[i].second);
-  }
+  // Extend obs data to specific dimension
+  torch::Tensor obs_pos_data = torch::cat(
+      {all_obstacle_pos.index(
+           {torch::indexing::Slice(),
+            torch::indexing::Slice(torch::indexing::None, -1),
+            torch::indexing::Slice()}),
+       all_obstacle_pos.index({torch::indexing::Slice(),
+                               torch::indexing::Slice(1, torch::indexing::None),
+                               torch::indexing::Slice()})},
+      2);
+
+  // Add obs attribute
+  torch::Tensor obs_attr_agent =
+      torch::tensor({11.0, 4.0}).unsqueeze(0).unsqueeze(0).repeat({1, 19, 1});
+  torch::Tensor obs_attr_other =
+      torch::tensor({10.0, 4.0}).unsqueeze(0).unsqueeze(0).repeat(
+        {(obs_num - 1), 19, 1});
+  torch::Tensor obs_attr = torch::cat({obs_attr_agent, obs_attr_other}, 0);
+  // ADD obs id
+  // add 500 to avoid same id as in map_info
+  torch::Tensor obs_id =
+      torch::arange(500,
+                    obs_num + 500).unsqueeze(1).repeat({1, 19}).unsqueeze(2);
+  // Process obs data
+  obs_length_data = obs_length_data.unsqueeze(1).repeat({1, 19, 1});
+  torch::Tensor obs_data_with_len =
+      torch::cat({obs_pos_data, obs_length_data}, 2);
+
+  torch::Tensor obs_data_with_attr =
+      torch::cat({obs_data_with_len, obs_attr}, 2);
+
+  torch::Tensor obs_data_with_id = torch::cat({obs_data_with_attr, obs_id}, 2);
+  *ptr_obstacle_data =
+      torch::cat({torch::zeros({obs_num, (50 - 19), 9}), obs_data_with_id}, 1);
 
   return true;
 }
@@ -175,18 +209,17 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   torch::Tensor target_obstacle_pos = torch::zeros({20, 2});
   torch::Tensor target_obstacle_pos_step = torch::zeros({20, 2});
   torch::Tensor vector_mask = torch::zeros({450, 50});
-  torch::Tensor all_obstacle_pos = torch::zeros({obs_num, 20, 2});
+  torch::Tensor obstacle_data = torch::zeros({obs_num, 20, 2});
   torch::Tensor all_obs_p_id = torch::zeros({obs_num, 2});
-  torch::Tensor obs_length_tmp = torch::zeros({obs_num, 2});
+  // torch::Tensor obs_length_tmp = torch::zeros({obs_num, 2});
 
   if (!VectornetProcessObstaclePosition(obstacle_ptr,
                                        obstacles_container,
                                        &amp;target_obstacle_pos,
                                        &amp;target_obstacle_pos_step,
                                        &amp;vector_mask,
-                                       &amp;all_obstacle_pos,
-                                       &amp;all_obs_p_id,
-                                       &amp;obs_length_tmp)) {
+                                       &amp;obstacle_data,
+                                       &amp;all_obs_p_id)) {
     AERROR &lt;&lt; "Obstacle [" &lt;&lt; id &lt;&lt; "] processing obstacle position fails.";
     return false;
   }
@@ -244,40 +277,9 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
         {torch::indexing::Slice(data_length, torch::indexing::None)}, 1);
   }
 
-  // Extend obs data to specific dimension
-  torch::Tensor obs_pos_data = torch::cat(
-      {all_obstacle_pos.index(
-           {torch::indexing::Slice(),
-            torch::indexing::Slice(torch::indexing::None, -1),
-            torch::indexing::Slice()}),
-       all_obstacle_pos.index({torch::indexing::Slice(),
-                               torch::indexing::Slice(1, torch::indexing::None),
-                               torch::indexing::Slice()})},
-      2);
-
-  torch::Tensor obs_length = obs_length_tmp.unsqueeze(1).repeat({1, 19, 1});
-  // Add obs attribute
-  torch::Tensor obs_attr_agent =
-      torch::tensor({11.0, 4.0}).unsqueeze(0).unsqueeze(0).repeat({1, 19, 1});
-  torch::Tensor obs_attr_other =
-      torch::tensor({10.0, 4.0}).unsqueeze(0).unsqueeze(0).repeat(
-        {(obs_num - 1), 19, 1});
-  torch::Tensor obs_attr = torch::cat({obs_attr_agent, obs_attr_other}, 0);
-  // ADD obs id
-  // add 500 to avoid same id as in map_info
-  torch::Tensor obs_id =
-      torch::arange(500,
-                    obs_num + 500).unsqueeze(1).repeat({1, 19}).unsqueeze(2);
-  // Process obs data
-  torch::Tensor obs_data_with_len = torch::cat({obs_pos_data, obs_length}, 2);
-  torch::Tensor obs_data_with_attr =
-      torch::cat({obs_data_with_len, obs_attr}, 2);
-  torch::Tensor obs_data_with_id = torch::cat({obs_data_with_attr, obs_id}, 2);
-  torch::Tensor obs_data_final =
-      torch::cat({torch::zeros({obs_num, (50 - 19), 9}), obs_data_with_id}, 1);
 
   // Extend data &amp; pid to specific demension
-  torch::Tensor data_tmp = torch::cat({obs_data_final, map_data}, 0);
+  torch::Tensor data_tmp = torch::cat({obstacle_data, map_data}, 0);
   torch::Tensor p_id_tmp = torch::cat({all_obs_p_id, all_map_p_id}, 0);
   torch::Tensor vector_data;
   torch::Tensor polyline_id;
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.h" new_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.h" added_lines="2" deleted_lines="3">
				<diff>@@ -61,9 +61,8 @@ class VectornetEvaluator : public Evaluator {
                                     torch::Tensor* ptr_target_obs_pos,
                                     torch::Tensor* ptr_target_obs_pos_step,
                                     torch::Tensor* ptr_vector_mask,
-                                    torch::Tensor* ptr_all_obstacle_pos,
-                                    torch::Tensor* ptr_all_obs_p_id,
-                                    torch::Tensor* ptr_obs_length);
+                                    torch::Tensor* ptr_obstacle_data,
+                                    torch::Tensor* ptr_all_obs_p_id);
 
   /**
   * @brief Process map data to vector
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="82eece36ed15c0383c0b2e35faccdc0b87323796" author="jiangjianan">
		<msg>Prediction: modified rotate angle &amp; vector data in jointly evaluator

Change-Id: I580e3196bf3e62a0112260637fa482fdc9549845</msg>
		<modified_files>
			<file old_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.cc" added_lines="6" deleted_lines="2">
				<diff>@@ -242,8 +242,12 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
 
   // Process input tensor
   auto start_time_data_prep = std::chrono::system_clock::now();
-  torch::Tensor map_data = torch::zeros({map_polyline_num, 50, 9});
-  torch::Tensor all_map_p_id = torch::zeros({map_polyline_num, 2});
+  int map_polyline_num_valid =
+      ((obs_num + map_polyline_num) &lt; 450) ? map_polyline_num : (450 - obs_num);
+  map_polyline_num_valid =
+      map_polyline_num_valid &gt; 0 ? map_polyline_num_valid : 0;
+  torch::Tensor map_data = torch::zeros({map_polyline_num_valid, 50, 9});
+  torch::Tensor all_map_p_id = torch::zeros({map_polyline_num_valid, 2});
 
   if (!VectornetProcessMapData(&amp;map_feature,
                                &amp;map_p_id,
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b99f37a8a038097bf9c004aac3b35d8d4ba42e7d" author="weixiao">
		<msg>merge github

Change-Id: I0f5d117a5cab9864cac2a6a991f7d8a5cb38855d</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\common\dreamview_gflags.cc" new_path="modules\dreamview\backend\common\dreamview_gflags.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -93,7 +93,7 @@ DEFINE_string(default_data_collection_config_path,
               "/apollo/modules/dreamview/conf/data_collection_table.pb.txt",
               "Data collection table config path.");
 
-DEFINE_double(loop_routing_end_to_start_distance_threshold, 10.0,
+DEFINE_int32(loop_routing_end_to_start_distance_threshold, 10,
              "Loop routing distance threshold: start to end");
 
 DEFINE_string(default_preprocess_config_path,
</diff>
			</file>
			<file old_path="modules\dreamview\backend\common\dreamview_gflags.h" new_path="modules\dreamview\backend\common\dreamview_gflags.h" added_lines="1" deleted_lines="1">
				<diff>@@ -60,7 +60,7 @@ DECLARE_int32(monitor_msg_pending_queue_size);
 
 DECLARE_string(default_data_collection_config_path);
 
-DECLARE_double(loop_routing_end_to_start_distance_threshold);
+DECLARE_int32(loop_routing_end_to_start_distance_threshold);
 
 DECLARE_string(default_preprocess_config_path);
 
</diff>
			</file>
			<file old_path="modules\planning\navi_planning.cc" new_path="modules\planning\navi_planning.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -199,7 +199,6 @@ void NaviPlanning::RunOnce(const LocalView&amp; local_view,
       FLAGS_trajectory_stitching_preserved_length, true,
       last_publishable_trajectory_.get(), &amp;replan_reason);
 
-  injector_-&gt;ego_info()-&gt;Update(stitching_trajectory.back(), vehicle_state);
   const uint32_t frame_num = static_cast&lt;uint32_t&gt;(seq_num_++);
   status = InitFrame(frame_num, stitching_trajectory.back(), vehicle_state);
 
@@ -214,6 +213,8 @@ void NaviPlanning::RunOnce(const LocalView&amp; local_view,
     return;
   }
 
+  injector_-&gt;ego_info()-&gt;Update(stitching_trajectory.back(), vehicle_state);
+
   if (FLAGS_enable_record_debug) {
     frame_-&gt;RecordInputDebug(trajectory_pb-&gt;mutable_debug());
   }
</diff>
			</file>
			<file old_path="modules\planning\open_space\coarse_trajectory_generator\hybrid_a_star.cc" new_path="modules\planning\open_space\coarse_trajectory_generator\hybrid_a_star.cc" added_lines="1" deleted_lines="7">
				<diff>@@ -20,8 +20,6 @@
 
 #include "modules/planning/open_space/coarse_trajectory_generator/hybrid_a_star.h"
 
-#include &lt;limits&gt;
-
 #include "modules/planning/math/piecewise_jerk/piecewise_jerk_speed_problem.h"
 
 namespace apollo {
@@ -405,11 +403,7 @@ bool HybridAStar::GenerateSCurveSpeedAcceleration(HybridAStartResult* result) {
                                               path_length * max_reverse_acc) /
                                              (max_reverse_acc * max_reverse_v),
                                   10.0);
-  if (total_t + delta_t &gt;= delta_t * std::numeric_limits&lt;size_t&gt;::max()) {
-    AERROR &lt;&lt; "Number of knots overflow. total_t: " &lt;&lt; total_t
-           &lt;&lt; ", delta_t: " &lt;&lt; delta_t;
-    return false;
-  }
+
   const size_t num_of_knots = static_cast&lt;size_t&gt;(total_t / delta_t) + 1;
 
   PiecewiseJerkSpeedProblem piecewise_jerk_problem(
</diff>
			</file>
			<file old_path="modules\planning\open_space\trajectory_smoother\iterative_anchoring_smoother.cc" new_path="modules\planning\open_space\trajectory_smoother\iterative_anchoring_smoother.cc" added_lines="1" deleted_lines="7">
				<diff>@@ -626,13 +626,7 @@ bool IterativeAnchoringSmoother::SmoothSpeed(const double init_a,
           .delta_t();
 
   const double total_t = 2 * path_length / max_reverse_acc * 10;
-
-  if (total_t + delta_t &gt;= delta_t * std::numeric_limits&lt;size_t&gt;::max()) {
-    AERROR &lt;&lt; "Number of knots overflow. total_t: " &lt;&lt; total_t
-           &lt;&lt; ", delta_t: " &lt;&lt; delta_t;
-    return false;
-  }
-
+  ADEBUG &lt;&lt; "total_t is : " &lt;&lt; total_t;
   const size_t num_of_knots = static_cast&lt;size_t&gt;(total_t / delta_t) + 1;
 
   PiecewiseJerkSpeedProblem piecewise_jerk_problem(
</diff>
			</file>
			<file old_path="modules\planning\scenarios\scenario_manager.cc" new_path="modules\planning\scenarios\scenario_manager.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -363,7 +363,7 @@ ScenarioConfig::ScenarioType ScenarioManager::SelectPadMsgScenario(
   return default_scenario_type_;
 }
 
-ScenarioConfig::ScenarioType ScenarioManager::SelectIntersectionScenario(
+ScenarioConfig::ScenarioType ScenarioManager::SelectInterceptionScenario(
     const Frame&amp; frame) {
   ScenarioConfig::ScenarioType scenario_type = default_scenario_type_;
 
@@ -945,7 +945,7 @@ ScenarioConfig::ScenarioType ScenarioManager::ScenarioDispatchNonLearning(
   ////////////////////////////////////////
   // intersection scenarios
   if (scenario_type == default_scenario_type_) {
-    scenario_type = SelectIntersectionScenario(frame);
+    scenario_type = SelectInterceptionScenario(frame);
   }
 
   ////////////////////////////////////////
</diff>
			</file>
			<file old_path="modules\planning\scenarios\scenario_manager.h" new_path="modules\planning\scenarios\scenario_manager.h" added_lines="1" deleted_lines="1">
				<diff>@@ -57,7 +57,7 @@ class ScenarioManager final {
 
   ScenarioConfig::ScenarioType SelectPadMsgScenario(const Frame&amp; frame);
 
-  ScenarioConfig::ScenarioType SelectIntersectionScenario(const Frame&amp; frame);
+  ScenarioConfig::ScenarioType SelectInterceptionScenario(const Frame&amp; frame);
 
   ScenarioConfig::ScenarioType SelectStopSignScenario(
       const Frame&amp; frame, const hdmap::PathOverlap&amp; stop_sign_overlap);
</diff>
			</file>
			<file old_path="modules\planning\tasks\deciders\path_lane_borrow_decider\path_lane_borrow_decider.cc" new_path="modules\planning\tasks\deciders\path_lane_borrow_decider\path_lane_borrow_decider.cc" added_lines="0" deleted_lines="1">
				<diff>@@ -291,7 +291,6 @@ void PathLaneBorrowDecider::CheckLaneBorrow(
     if (*left_neighbor_lane_borrowable) {
       lane_boundary_type = hdmap::LeftBoundaryType(waypoint);
       if (lane_boundary_type == hdmap::LaneBoundaryType::SOLID_YELLOW ||
-          lane_boundary_type == hdmap::LaneBoundaryType::DOUBLE_YELLOW ||
           lane_boundary_type == hdmap::LaneBoundaryType::SOLID_WHITE) {
         *left_neighbor_lane_borrowable = false;
       }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="55c87bf7450424277358c05255ef322ff587e367" author="fuyiqun">
		<msg>prediction: decouple obstacle data process

Change-Id: I6b9f793af7109ba92821b9b6a3a3e88c9febc17f</msg>
		<modified_files>
			<file old_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" added_lines="52" deleted_lines="50">
				<diff>@@ -47,10 +47,8 @@ bool VectornetEvaluator::VectornetProcessObstaclePosition(
                              torch::Tensor* ptr_target_obs_pos,
                              torch::Tensor* ptr_target_obs_pos_step,
                              torch::Tensor* ptr_vector_mask,
-                             torch::Tensor* ptr_all_obstacle_pos,
-                             torch::Tensor* ptr_all_obs_p_id,
-                             torch::Tensor* ptr_obs_length) {
-  // obs data vector
+                             torch::Tensor* ptr_obstacle_data,
+                             torch::Tensor* ptr_all_obs_p_id) {
   // Extract features of pos_history
   std::vector&lt;std::pair&lt;double, double&gt;&gt; target_pos_history(20, {0.0, 0.0});
   std::vector&lt;std::pair&lt;double, double&gt;&gt; all_obs_length;
@@ -80,9 +78,13 @@ bool VectornetEvaluator::VectornetProcessObstaclePosition(
 
   int obs_num =
       obstacles_container-&gt;curr_frame_considered_obstacle_ids().size();
+  torch::Tensor all_obstacle_pos = torch::zeros({obs_num, 20, 2});
+  torch::Tensor obs_length_data = torch::zeros({obs_num, 2});
+  auto opts = torch::TensorOptions().dtype(torch::kDouble);
+
   for (int i = 0; i &lt; obs_num; ++i) {
     std::vector&lt;double&gt; obs_p_id{std::numeric_limits&lt;float&gt;::max(),
-                              std::numeric_limits&lt;float&gt;::max()};
+                                 std::numeric_limits&lt;float&gt;::max()};
     for (int j = 0; j &lt; 20; ++j) {
       // Process obs pid
       if (obs_p_id[0] &gt; all_obs_pos_history[i][j].first) {
@@ -92,22 +94,54 @@ bool VectornetEvaluator::VectornetProcessObstaclePosition(
         obs_p_id[1] = all_obs_pos_history[i][j].second;
       }
       // Process obs pos history
-      ptr_all_obstacle_pos-&gt;index_put_(
+      all_obstacle_pos.index_put_(
           {i, 19 - j, 0},
           all_obs_pos_history[i][j].first);
-      ptr_all_obstacle_pos-&gt;index_put_(
+      all_obstacle_pos.index_put_(
           {i, 19 - j, 1},
           all_obs_pos_history[i][j].second);
     }
 
-    ptr_all_obs_p_id-&gt;index_put_({i, 0}, obs_p_id[0]);
-    ptr_all_obs_p_id-&gt;index_put_({i, 1}, obs_p_id[1]);
+    ptr_all_obs_p_id-&gt;index_put_({i},
+                                 torch::from_blob(obs_p_id.data(), {2}, opts));
+    obs_length_data.index_put_({i, 0}, all_obs_length[i].first);
+    obs_length_data.index_put_({i, 1}, all_obs_length[i].second);
   }
 
-  for (int i = 0; i &lt; obs_num; ++i) {
-    ptr_obs_length-&gt;index_put_({i, 0}, all_obs_length[i].first);
-    ptr_obs_length-&gt;index_put_({i, 1}, all_obs_length[i].second);
-  }
+  // Extend obs data to specific dimension
+  torch::Tensor obs_pos_data = torch::cat(
+      {all_obstacle_pos.index(
+           {torch::indexing::Slice(),
+            torch::indexing::Slice(torch::indexing::None, -1),
+            torch::indexing::Slice()}),
+       all_obstacle_pos.index({torch::indexing::Slice(),
+                               torch::indexing::Slice(1, torch::indexing::None),
+                               torch::indexing::Slice()})},
+      2);
+
+  // Add obs attribute
+  torch::Tensor obs_attr_agent =
+      torch::tensor({11.0, 4.0}).unsqueeze(0).unsqueeze(0).repeat({1, 19, 1});
+  torch::Tensor obs_attr_other =
+      torch::tensor({10.0, 4.0}).unsqueeze(0).unsqueeze(0).repeat(
+        {(obs_num - 1), 19, 1});
+  torch::Tensor obs_attr = torch::cat({obs_attr_agent, obs_attr_other}, 0);
+  // ADD obs id
+  // add 500 to avoid same id as in map_info
+  torch::Tensor obs_id =
+      torch::arange(500,
+                    obs_num + 500).unsqueeze(1).repeat({1, 19}).unsqueeze(2);
+  // Process obs data
+  obs_length_data = obs_length_data.unsqueeze(1).repeat({1, 19, 1});
+  torch::Tensor obs_data_with_len =
+      torch::cat({obs_pos_data, obs_length_data}, 2);
+
+  torch::Tensor obs_data_with_attr =
+      torch::cat({obs_data_with_len, obs_attr}, 2);
+
+  torch::Tensor obs_data_with_id = torch::cat({obs_data_with_attr, obs_id}, 2);
+  *ptr_obstacle_data =
+      torch::cat({torch::zeros({obs_num, (50 - 19), 9}), obs_data_with_id}, 1);
 
   return true;
 }
@@ -175,18 +209,17 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
   torch::Tensor target_obstacle_pos = torch::zeros({20, 2});
   torch::Tensor target_obstacle_pos_step = torch::zeros({20, 2});
   torch::Tensor vector_mask = torch::zeros({450, 50});
-  torch::Tensor all_obstacle_pos = torch::zeros({obs_num, 20, 2});
+  torch::Tensor obstacle_data = torch::zeros({obs_num, 20, 2});
   torch::Tensor all_obs_p_id = torch::zeros({obs_num, 2});
-  torch::Tensor obs_length_tmp = torch::zeros({obs_num, 2});
+  // torch::Tensor obs_length_tmp = torch::zeros({obs_num, 2});
 
   if (!VectornetProcessObstaclePosition(obstacle_ptr,
                                        obstacles_container,
                                        &amp;target_obstacle_pos,
                                        &amp;target_obstacle_pos_step,
                                        &amp;vector_mask,
-                                       &amp;all_obstacle_pos,
-                                       &amp;all_obs_p_id,
-                                       &amp;obs_length_tmp)) {
+                                       &amp;obstacle_data,
+                                       &amp;all_obs_p_id)) {
     AERROR &lt;&lt; "Obstacle [" &lt;&lt; id &lt;&lt; "] processing obstacle position fails.";
     return false;
   }
@@ -244,40 +277,9 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
         {torch::indexing::Slice(data_length, torch::indexing::None)}, 1);
   }
 
-  // Extend obs data to specific dimension
-  torch::Tensor obs_pos_data = torch::cat(
-      {all_obstacle_pos.index(
-           {torch::indexing::Slice(),
-            torch::indexing::Slice(torch::indexing::None, -1),
-            torch::indexing::Slice()}),
-       all_obstacle_pos.index({torch::indexing::Slice(),
-                               torch::indexing::Slice(1, torch::indexing::None),
-                               torch::indexing::Slice()})},
-      2);
-
-  torch::Tensor obs_length = obs_length_tmp.unsqueeze(1).repeat({1, 19, 1});
-  // Add obs attribute
-  torch::Tensor obs_attr_agent =
-      torch::tensor({11.0, 4.0}).unsqueeze(0).unsqueeze(0).repeat({1, 19, 1});
-  torch::Tensor obs_attr_other =
-      torch::tensor({10.0, 4.0}).unsqueeze(0).unsqueeze(0).repeat(
-        {(obs_num - 1), 19, 1});
-  torch::Tensor obs_attr = torch::cat({obs_attr_agent, obs_attr_other}, 0);
-  // ADD obs id
-  // add 500 to avoid same id as in map_info
-  torch::Tensor obs_id =
-      torch::arange(500,
-                    obs_num + 500).unsqueeze(1).repeat({1, 19}).unsqueeze(2);
-  // Process obs data
-  torch::Tensor obs_data_with_len = torch::cat({obs_pos_data, obs_length}, 2);
-  torch::Tensor obs_data_with_attr =
-      torch::cat({obs_data_with_len, obs_attr}, 2);
-  torch::Tensor obs_data_with_id = torch::cat({obs_data_with_attr, obs_id}, 2);
-  torch::Tensor obs_data_final =
-      torch::cat({torch::zeros({obs_num, (50 - 19), 9}), obs_data_with_id}, 1);
 
   // Extend data &amp; pid to specific demension
-  torch::Tensor data_tmp = torch::cat({obs_data_final, map_data}, 0);
+  torch::Tensor data_tmp = torch::cat({obstacle_data, map_data}, 0);
   torch::Tensor p_id_tmp = torch::cat({all_obs_p_id, all_map_p_id}, 0);
   torch::Tensor vector_data;
   torch::Tensor polyline_id;
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.h" new_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.h" added_lines="2" deleted_lines="3">
				<diff>@@ -61,9 +61,8 @@ class VectornetEvaluator : public Evaluator {
                                     torch::Tensor* ptr_target_obs_pos,
                                     torch::Tensor* ptr_target_obs_pos_step,
                                     torch::Tensor* ptr_vector_mask,
-                                    torch::Tensor* ptr_all_obstacle_pos,
-                                    torch::Tensor* ptr_all_obs_p_id,
-                                    torch::Tensor* ptr_obs_length);
+                                    torch::Tensor* ptr_obstacle_data,
+                                    torch::Tensor* ptr_all_obs_p_id);
 
   /**
   * @brief Process map data to vector
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="05877cee1dfca0d6f30fb35acf9b1f9a57fbb065" author="jiangjianan">
		<msg>Prediction: modified rotate angle &amp; vector data in jointly evaluator

Change-Id: I580e3196bf3e62a0112260637fa482fdc9549845</msg>
		<modified_files>
			<file old_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.cc" added_lines="6" deleted_lines="2">
				<diff>@@ -242,8 +242,12 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
 
   // Process input tensor
   auto start_time_data_prep = std::chrono::system_clock::now();
-  torch::Tensor map_data = torch::zeros({map_polyline_num, 50, 9});
-  torch::Tensor all_map_p_id = torch::zeros({map_polyline_num, 2});
+  int map_polyline_num_valid =
+      ((obs_num + map_polyline_num) &lt; 450) ? map_polyline_num : (450 - obs_num);
+  map_polyline_num_valid =
+      map_polyline_num_valid &gt; 0 ? map_polyline_num_valid : 0;
+  torch::Tensor map_data = torch::zeros({map_polyline_num_valid, 50, 9});
+  torch::Tensor all_map_p_id = torch::zeros({map_polyline_num_valid, 2});
 
   if (!VectornetProcessMapData(&amp;map_feature,
                                &amp;map_p_id,
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1de50cf3ba341b11b3af132c67cc352e6abdf5df" author="">
		<msg>Dreamview: fix bug and change default routing proto (#14029)

* Dreamview: fix bug and change default routing proto

* Dv:remove unused param

Co-authored-by: lijin18 &lt;lijin18@baidu.com&gt;</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" new_path="modules\dreamview\backend\simulation_world\simulation_world_updater.cc" added_lines="27" deleted_lines="18">
				<diff>@@ -36,6 +36,7 @@ using apollo::cyber::common::SetProtoToASCIIFile;
 using apollo::hdmap::DefaultRoutingFile;
 using apollo::hdmap::EndWayPointFile;
 using apollo::relative_map::NavigationInfo;
+using apollo::routing::LaneWaypoint;
 using apollo::routing::RoutingRequest;
 using apollo::task_manager::CycleRoutingTask;
 using apollo::task_manager::DeadEndRoutingTask;
@@ -314,10 +315,7 @@ void SimulationWorldUpdater::RegisterMessageHandlers() {
 
             Json waypoint_list;
             for (const auto &amp;waypoint : landmark.waypoint()) {
-              Json point;
-              point["x"] = waypoint.pose().x();
-              point["y"] = waypoint.pose().y();
-              waypoint_list.push_back(point);
+              waypoint_list.push_back(GetPointJsonFromLaneWaypoint(waypoint));
             }
             place["waypoint"] = waypoint_list;
 
@@ -344,16 +342,12 @@ void SimulationWorldUpdater::RegisterMessageHandlers() {
 
         Json default_routing_list = Json::array();
         if (LoadDefaultRoutings()) {
-          for (const auto &amp;defaultrouting :
-               default_routings_.defaultrouting()) {
+          for (const auto &amp;landmark : default_routings_.landmark()) {
             Json drouting;
-            drouting["name"] = defaultrouting.name();
+            drouting["name"] = landmark.name();
             Json point_list;
-            for (const auto &amp;point : defaultrouting.point()) {
-              Json point_json;
-              point_json["x"] = point.x();
-              point_json["y"] = point.y();
-              point_list.push_back(point_json);
+            for (const auto &amp;point : landmark.waypoint()) {
+              point_list.push_back(GetPointJsonFromLaneWaypoint(point));
             }
             drouting["point"] = point_list;
             default_routing_list.push_back(drouting);
@@ -485,6 +479,17 @@ Json SimulationWorldUpdater::CheckRoutingPoint(const Json &amp;json) {
   return result;
 }
 
+Json SimulationWorldUpdater::GetPointJsonFromLaneWaypoint(
+    const apollo::routing::LaneWaypoint &amp;waypoint) {
+  Json point;
+  point["x"] = waypoint.pose().x();
+  point["y"] = waypoint.pose().y();
+  if (waypoint.has_heading()) {
+    point["heading"] = waypoint.heading();
+  }
+  return point;
+}
+
 Json SimulationWorldUpdater::CheckDeadEndJunctionPoints(const Json &amp;json) {
   Json result;
   if (!ContainsKey(json, "start1")) {
@@ -759,21 +764,25 @@ bool SimulationWorldUpdater::AddDefaultRouting(const Json &amp;json) {
 
   std::string name = json["name"];
   auto iter = json.find("point");
-  default_routing_ = default_routings_.add_defaultrouting();
+  default_routing_ = default_routings_.add_landmark();
   default_routing_-&gt;clear_name();
-  default_routing_-&gt;clear_point();
+  default_routing_-&gt;clear_waypoint();
   default_routing_-&gt;set_name(name);
-  auto *waypoint = default_routing_-&gt;mutable_point();
+  auto *waypoint = default_routing_-&gt;mutable_waypoint();
   if (iter != json.end() &amp;&amp; iter-&gt;is_array()) {
     for (size_t i = 0; i &lt; iter-&gt;size(); ++i) {
       auto &amp;point = (*iter)[i];
-      auto *p = waypoint-&gt;Add();
       if (!ValidateCoordinate(point)) {
         AERROR &lt;&lt; "Failed to save a default routing: invalid waypoint.";
         return false;
       }
-      p-&gt;set_x(static_cast&lt;double&gt;(point["x"]));
-      p-&gt;set_y(static_cast&lt;double&gt;(point["y"]));
+      auto *p = waypoint-&gt;Add();
+      auto *pose = p-&gt;mutable_pose();
+      pose-&gt;set_x(static_cast&lt;double&gt;(point["x"]));
+      pose-&gt;set_y(static_cast&lt;double&gt;(point["y"]));
+      if (ContainsKey(point, "heading")) {
+        p-&gt;set_heading(point["heading"]);
+      }
     }
   }
   AINFO &lt;&lt; "Default Routing Points to be saved:\n";
</diff>
			</file>
			<file old_path="modules\dreamview\backend\simulation_world\simulation_world_updater.h" new_path="modules\dreamview\backend\simulation_world\simulation_world_updater.h" added_lines="10" deleted_lines="3">
				<diff>@@ -29,7 +29,6 @@
 
 #include "absl/strings/str_cat.h"
 
-#include "modules/routing/proto/default_routing.pb.h"
 #include "modules/routing/proto/poi.pb.h"
 #include "modules/task_manager/proto/task_manager.pb.h"
 
@@ -147,6 +146,14 @@ class SimulationWorldUpdater {
    */
   bool LoadPOI();
 
+    /**
+   * @brief get point from lanewaypoint in poi or default routings
+   * @param lanewaypoint
+   * @return json that contains point's coordinate x and y
+   */
+  nlohmann::json GetPointJsonFromLaneWaypoint(
+      const apollo::routing::LaneWaypoint &amp;waypoint);
+
   /**
    * @brief Tries to load the user-defined default routings from the txt file
    * @return False if failed to load from file,file doesn't exist
@@ -176,8 +183,8 @@ class SimulationWorldUpdater {
   apollo::routing::POI poi_;
 
   // default routings
-  apollo::routing::DefaultRoutings default_routings_;
-  apollo::routing::DefaultRouting *default_routing_;
+  apollo::routing::POI default_routings_;
+  apollo::routing::Landmark *default_routing_;
 
   // The simulation_world in wire format to be pushed to frontend, which is
   // updated by timer.
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3c852d8ae1e27882f0546d94a5f4508373456bee" author="fuyiqun">
		<msg>prediction: fix an error when polyline_num &gt; 450

Change-Id: I4eabf176b04071b34c40e887f150dd514e9acf0b</msg>
		<modified_files>
			<file old_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" added_lines="3" deleted_lines="2">
				<diff>@@ -289,8 +289,8 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
     vector_data = torch::cat({data_tmp, data_zeros}, 0);
     polyline_id = torch::cat({p_id_tmp, p_id_zeros}, 0);
   } else {
-    vector_data = data_tmp;
-    polyline_id = p_id_tmp;
+    vector_data = data_tmp.index({torch::indexing::Slice(0, 450)});
+    polyline_id = p_id_tmp.index({torch::indexing::Slice(0, 450)});
   }
 
   // Empty rand mask as placeholder
@@ -425,6 +425,7 @@ bool VectornetEvaluator::ExtractObstaclesHistory(
     size_t obs_his_size = obstacle-&gt;history_size();
     obs_his_size = obs_his_size &lt;= 20 ? obs_his_size : 20;
     int cur_idx = all_obs_pos_history-&gt;size();
+    // if cur_dix &gt;= 450, index_put_ discards it automatically.
     if (obs_his_size &gt; 1) {
       vector_mask-&gt;index_put_({cur_idx,
                                torch::indexing::Slice(torch::indexing::None,
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="20d532cc4dd759267b2a4577a08f1a1107ef047a" author="jiangjianan">
		<msg>Prediction: change obs coord to parallel &amp; update model files

Change-Id: I26b2154440c2236e9836343d94db3b54f1bf794f</msg>
		<modified_files>
			<file old_path="modules\prediction\common\message_process.cc" new_path="modules\prediction\common\message_process.cc" added_lines="3" deleted_lines="1">
				<diff>@@ -175,7 +175,9 @@ void MessageProcess::ContainerProcess(
   obstacles_prioritizer.AssignCautionLevel();
 
   // Add interactive tag
-  interaction_filter.AssignInteractiveTag();
+  if (FLAGS_enable_interactive_tag) {
+    interaction_filter.AssignInteractiveTag();
+  }
 
   // Analyze RightOfWay for the caution obstacles
   RightOfWay::Analyze(container_manager.get());
</diff>
			</file>
			<file old_path="modules\prediction\common\prediction_gflags.cc" new_path="modules\prediction\common\prediction_gflags.cc" added_lines="2" deleted_lines="0">
				<diff>@@ -351,6 +351,8 @@ DEFINE_bool(use_bell_curve_for_cost_function, false,
             "Whether to use bell curve for the cost function or not.");
 
 // interaction predictor
+DEFINE_bool(enable_interactive_tag, true,
+            "Whether to set interactive tag for obstacles.");
 DEFINE_double(collision_cost_time_resolution, 1.0,
               "The time resolution used to compute the collision cost");
 DEFINE_double(longitudinal_acceleration_cost_weight, 0.2,
</diff>
			</file>
			<file old_path="modules\prediction\common\prediction_gflags.h" new_path="modules\prediction\common\prediction_gflags.h" added_lines="1" deleted_lines="0">
				<diff>@@ -184,6 +184,7 @@ DECLARE_double(cost_function_sigma);
 DECLARE_bool(use_bell_curve_for_cost_function);
 
 // interaction predictor
+DECLARE_bool(enable_interactive_tag);
 DECLARE_double(collision_cost_time_resolution);
 DECLARE_double(longitudinal_acceleration_cost_weight);
 DECLARE_double(centripedal_acceleration_cost_weight);
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\evaluator.h" new_path="modules\prediction\evaluator\evaluator.h" added_lines="11" deleted_lines="0">
				<diff>@@ -102,6 +102,17 @@ class Evaluator {
     return std::make_pair(std::cos(theta) * rho, std::sin(theta) * rho);
   }
 
+  std::pair&lt;double, double&gt; WorldCoordToObjCoordNorth(
+      std::pair&lt;double, double&gt; input_world_coord,
+      std::pair&lt;double, double&gt; obj_world_coord, double obj_world_angle) {
+    double x_diff = input_world_coord.first - obj_world_coord.first;
+    double y_diff = input_world_coord.second - obj_world_coord.second;
+    double theta = M_PI / 2 - obj_world_angle;
+    double x = std::cos(theta) * x_diff - std::sin(theta) * y_diff;
+    double y = std::sin(theta) * x_diff + std::cos(theta) * y_diff;
+    return std::make_pair(x, y);
+  }
+
   double WorldAngleToObjAngle(double input_world_angle,
                               double obj_world_angle) {
     return common::math::NormalizeAngle(input_world_angle - obj_world_angle);
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.cc" added_lines="4" deleted_lines="4">
				<diff>@@ -429,7 +429,7 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
 
     double heading = latest_feature_ptr-&gt;velocity_heading();
     Vec2d offset(dx, dy);
-    Vec2d rotated_offset = offset.rotate(heading);
+    Vec2d rotated_offset = offset.rotate(heading - (M_PI / 2));
     double point_x = pos_x + rotated_offset.x();
     double point_y = pos_y + rotated_offset.y();
     point-&gt;mutable_path_point()-&gt;set_x(point_x);
@@ -477,7 +477,7 @@ bool JointlyPredictionPlanningEvaluator::ExtractObstaclesHistory(
       break;
     }
     target_pos_history-&gt;at(i) =
-        WorldCoordToObjCoord(std::make_pair(target_feature.position().x(),
+        WorldCoordToObjCoordNorth(std::make_pair(target_feature.position().x(),
                                             target_feature.position().y()),
                              obs_curr_pos, obs_curr_heading);
   }
@@ -515,7 +515,7 @@ bool JointlyPredictionPlanningEvaluator::ExtractObstaclesHistory(
       if (!feature.IsInitialized()) {
         break;
       }
-      pos_history[i] = WorldCoordToObjCoord(
+      pos_history[i] = WorldCoordToObjCoordNorth(
           std::make_pair(feature.position().x(), feature.position().y()),
           obs_curr_pos, obs_curr_heading);
     }
@@ -539,7 +539,7 @@ bool JointlyPredictionPlanningEvaluator::ExtractADCTrajectory(
       adc_traj_curr_pos-&gt;at(i) =
           adc_traj_curr_pos-&gt;at(adc_traj_points_num - 1);
     } else {
-      adc_traj_curr_pos-&gt;at(i) = WorldCoordToObjCoord(
+      adc_traj_curr_pos-&gt;at(i) = WorldCoordToObjCoordNorth(
           std::make_pair(trajectory_points-&gt;at(i).path_point().x(),
           trajectory_points-&gt;at(i).path_point().y()),
           obs_curr_pos, obs_curr_heading);
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" added_lines="6" deleted_lines="5">
				<diff>@@ -349,7 +349,7 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
 
     double heading = latest_feature_ptr-&gt;velocity_heading();
     Vec2d offset(dx, dy);
-    Vec2d rotated_offset = offset.rotate(heading);
+    Vec2d rotated_offset = offset.rotate(heading - (M_PI / 2));
     double point_x = pos_x + rotated_offset.x();
     double point_y = pos_y + rotated_offset.y();
     point-&gt;mutable_path_point()-&gt;set_x(point_x);
@@ -402,9 +402,10 @@ bool VectornetEvaluator::ExtractObstaclesHistory(
       break;
     }
     target_pos_history-&gt;at(i) =
-        WorldCoordToObjCoord(std::make_pair(target_feature.position().x(),
-                                            target_feature.position().y()),
-                             obs_curr_pos, obs_curr_heading);
+        WorldCoordToObjCoordNorth(
+            std::make_pair(target_feature.position().x(),
+                           target_feature.position().y()),
+                           obs_curr_pos, obs_curr_heading);
   }
   all_obs_length-&gt;emplace_back(
       std::make_pair(obs_curr_feature.length(), obs_curr_feature.width()));
@@ -443,7 +444,7 @@ bool VectornetEvaluator::ExtractObstaclesHistory(
       if (!feature.IsInitialized()) {
         break;
       }
-      pos_history[i] = WorldCoordToObjCoord(
+      pos_history[i] = WorldCoordToObjCoordNorth(
           std::make_pair(feature.position().x(), feature.position().y()),
           obs_curr_pos, obs_curr_heading);
     }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5f33440ad550a41d3812eec9bf474ee38ec6c3f4" author="jiangjianan">
		<msg>Prediction: change obs coord to parallel &amp; update model files

Change-Id: I26b2154440c2236e9836343d94db3b54f1bf794f</msg>
		<modified_files>
			<file old_path="modules\prediction\common\message_process.cc" new_path="modules\prediction\common\message_process.cc" added_lines="3" deleted_lines="1">
				<diff>@@ -175,7 +175,9 @@ void MessageProcess::ContainerProcess(
   obstacles_prioritizer.AssignCautionLevel();
 
   // Add interactive tag
-  interaction_filter.AssignInteractiveTag();
+  if (FLAGS_enable_interactive_tag) {
+    interaction_filter.AssignInteractiveTag();
+  }
 
   // Analyze RightOfWay for the caution obstacles
   RightOfWay::Analyze(container_manager.get());
</diff>
			</file>
			<file old_path="modules\prediction\common\prediction_gflags.cc" new_path="modules\prediction\common\prediction_gflags.cc" added_lines="2" deleted_lines="0">
				<diff>@@ -351,6 +351,8 @@ DEFINE_bool(use_bell_curve_for_cost_function, false,
             "Whether to use bell curve for the cost function or not.");
 
 // interaction predictor
+DEFINE_bool(enable_interactive_tag, true,
+            "Whether to set interactive tag for obstacles.");
 DEFINE_double(collision_cost_time_resolution, 1.0,
               "The time resolution used to compute the collision cost");
 DEFINE_double(longitudinal_acceleration_cost_weight, 0.2,
</diff>
			</file>
			<file old_path="modules\prediction\common\prediction_gflags.h" new_path="modules\prediction\common\prediction_gflags.h" added_lines="1" deleted_lines="0">
				<diff>@@ -184,6 +184,7 @@ DECLARE_double(cost_function_sigma);
 DECLARE_bool(use_bell_curve_for_cost_function);
 
 // interaction predictor
+DECLARE_bool(enable_interactive_tag);
 DECLARE_double(collision_cost_time_resolution);
 DECLARE_double(longitudinal_acceleration_cost_weight);
 DECLARE_double(centripedal_acceleration_cost_weight);
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\evaluator.h" new_path="modules\prediction\evaluator\evaluator.h" added_lines="11" deleted_lines="0">
				<diff>@@ -102,6 +102,17 @@ class Evaluator {
     return std::make_pair(std::cos(theta) * rho, std::sin(theta) * rho);
   }
 
+  std::pair&lt;double, double&gt; WorldCoordToObjCoordNorth(
+      std::pair&lt;double, double&gt; input_world_coord,
+      std::pair&lt;double, double&gt; obj_world_coord, double obj_world_angle) {
+    double x_diff = input_world_coord.first - obj_world_coord.first;
+    double y_diff = input_world_coord.second - obj_world_coord.second;
+    double theta = M_PI / 2 - obj_world_angle;
+    double x = std::cos(theta) * x_diff - std::sin(theta) * y_diff;
+    double y = std::sin(theta) * x_diff + std::cos(theta) * y_diff;
+    return std::make_pair(x, y);
+  }
+
   double WorldAngleToObjAngle(double input_world_angle,
                               double obj_world_angle) {
     return common::math::NormalizeAngle(input_world_angle - obj_world_angle);
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\jointly_prediction_planning_evaluator.cc" added_lines="4" deleted_lines="4">
				<diff>@@ -429,7 +429,7 @@ bool JointlyPredictionPlanningEvaluator::Evaluate(
 
     double heading = latest_feature_ptr-&gt;velocity_heading();
     Vec2d offset(dx, dy);
-    Vec2d rotated_offset = offset.rotate(heading);
+    Vec2d rotated_offset = offset.rotate(heading - (M_PI / 2));
     double point_x = pos_x + rotated_offset.x();
     double point_y = pos_y + rotated_offset.y();
     point-&gt;mutable_path_point()-&gt;set_x(point_x);
@@ -477,7 +477,7 @@ bool JointlyPredictionPlanningEvaluator::ExtractObstaclesHistory(
       break;
     }
     target_pos_history-&gt;at(i) =
-        WorldCoordToObjCoord(std::make_pair(target_feature.position().x(),
+        WorldCoordToObjCoordNorth(std::make_pair(target_feature.position().x(),
                                             target_feature.position().y()),
                              obs_curr_pos, obs_curr_heading);
   }
@@ -515,7 +515,7 @@ bool JointlyPredictionPlanningEvaluator::ExtractObstaclesHistory(
       if (!feature.IsInitialized()) {
         break;
       }
-      pos_history[i] = WorldCoordToObjCoord(
+      pos_history[i] = WorldCoordToObjCoordNorth(
           std::make_pair(feature.position().x(), feature.position().y()),
           obs_curr_pos, obs_curr_heading);
     }
@@ -539,7 +539,7 @@ bool JointlyPredictionPlanningEvaluator::ExtractADCTrajectory(
       adc_traj_curr_pos-&gt;at(i) =
           adc_traj_curr_pos-&gt;at(adc_traj_points_num - 1);
     } else {
-      adc_traj_curr_pos-&gt;at(i) = WorldCoordToObjCoord(
+      adc_traj_curr_pos-&gt;at(i) = WorldCoordToObjCoordNorth(
           std::make_pair(trajectory_points-&gt;at(i).path_point().x(),
           trajectory_points-&gt;at(i).path_point().y()),
           obs_curr_pos, obs_curr_heading);
</diff>
			</file>
			<file old_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" new_path="modules\prediction\evaluator\vehicle\vectornet_evaluator.cc" added_lines="6" deleted_lines="5">
				<diff>@@ -349,7 +349,7 @@ bool VectornetEvaluator::Evaluate(Obstacle* obstacle_ptr,
 
     double heading = latest_feature_ptr-&gt;velocity_heading();
     Vec2d offset(dx, dy);
-    Vec2d rotated_offset = offset.rotate(heading);
+    Vec2d rotated_offset = offset.rotate(heading - (M_PI / 2));
     double point_x = pos_x + rotated_offset.x();
     double point_y = pos_y + rotated_offset.y();
     point-&gt;mutable_path_point()-&gt;set_x(point_x);
@@ -402,9 +402,10 @@ bool VectornetEvaluator::ExtractObstaclesHistory(
       break;
     }
     target_pos_history-&gt;at(i) =
-        WorldCoordToObjCoord(std::make_pair(target_feature.position().x(),
-                                            target_feature.position().y()),
-                             obs_curr_pos, obs_curr_heading);
+        WorldCoordToObjCoordNorth(
+            std::make_pair(target_feature.position().x(),
+                           target_feature.position().y()),
+                           obs_curr_pos, obs_curr_heading);
   }
   all_obs_length-&gt;emplace_back(
       std::make_pair(obs_curr_feature.length(), obs_curr_feature.width()));
@@ -442,7 +443,7 @@ bool VectornetEvaluator::ExtractObstaclesHistory(
       if (!feature.IsInitialized()) {
         break;
       }
-      pos_history[i] = WorldCoordToObjCoord(
+      pos_history[i] = WorldCoordToObjCoordNorth(
           std::make_pair(feature.position().x(), feature.position().y()),
           obs_curr_pos, obs_curr_heading);
     }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f9ec6bb33218c17314ca10b3c58d681edaf98c89" author="machao20">
		<msg>Canbus: fix the lincoln mkz wheel speed and wheel direction protocols bug</msg>
		<modified_files>
			<file old_path="modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" new_path="modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" added_lines="28" deleted_lines="0">
				<diff>@@ -36,18 +36,26 @@ void Wheelspeed6a::Parse(const std::uint8_t *bytes, int32_t length,
   chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_fl(
       front_left_wheel_speed(bytes, length));
   chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_fl_valid(true);
+  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_direction_fl(
+      wheel_direction_convert(front_left_wheel_speed(bytes, length)));
   // front right
   chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_fr(
       front_right_wheel_speed(bytes, length));
   chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_fr_valid(true);
+  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_direction_fr(
+      wheel_direction_convert(front_right_wheel_speed(bytes, length)));
   // rear left
   chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_rl(
       rear_left_wheel_speed(bytes, length));
   chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_rl_valid(true);
+  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_direction_rl(
+      wheel_direction_convert(rear_left_wheel_speed(bytes, length)));
   // rear right
   chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_rr(
       rear_right_wheel_speed(bytes, length));
   chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_rr_valid(true);
+  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_direction_rr(
+      wheel_direction_convert(rear_right_wheel_speed(bytes, length)));
   /*
   -?(rr(bytes, length));
   -?(rl(bytes, length));
@@ -95,9 +103,29 @@ double Wheelspeed6a::parse_two_frames(const std::uint8_t low_byte,
   Byte low_frame(&amp;low_byte);
   int32_t low = low_frame.get_byte(0, 8);
   int32_t value = (high &lt;&lt; 8) | low;
+  if (value &gt; 0x7FFF) {
+    value -= 0x10000;
+  }
   return value * 0.010000;
 }
 
+WheelSpeed::WheelSpeedType Wheelspeed6a::wheel_direction_convert(
+    double wheel_speed) const {
+  int8_t wheel_direction = 0;
+  if (wheel_speed &gt; 0) {
+    wheel_direction = 0;
+  } else if ((wheel_speed &gt; -0.01) &amp;&amp; (wheel_speed &lt; 0.01)) {
+    wheel_direction = 2;
+  } else if (wheel_speed &lt; 0) {
+    wheel_direction = 1;
+  } else {
+    wheel_direction = 3;
+  }
+  WheelSpeed::WheelSpeedType ret =
+      static_cast&lt;WheelSpeed::WheelSpeedType&gt;(wheel_direction);
+  return ret;
+}
+
 }  // namespace lincoln
 }  // namespace canbus
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.h" new_path="modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.h" added_lines="4" deleted_lines="0">
				<diff>@@ -23,7 +23,9 @@
 
 #include &lt;sys/time.h&gt;
 
+#include "modules/canbus/proto/chassis.pb.h"
 #include "modules/canbus/proto/chassis_detail.pb.h"
+
 #include "modules/drivers/canbus/can_comm/protocol_data.h"
 
 /**
@@ -114,6 +116,8 @@ class Wheelspeed6a : public ::apollo::drivers::canbus::ProtocolData&lt;
 
   double parse_two_frames(const std::uint8_t low_byte,
                           const std::uint8_t high_byte) const;
+
+  WheelSpeed::WheelSpeedType wheel_direction_convert(double wheel_speed) const;
 };
 
 }  // namespace lincoln
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1f5d15a056ed82f447c4fbe15f2e46a7fe89f9d6" author="machao20">
		<msg>Canbus: fix the suggestion</msg>
		<modified_files>
			<file old_path="modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" new_path="modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" added_lines="6" deleted_lines="8">
				<diff>@@ -111,19 +111,17 @@ double Wheelspeed6a::parse_two_frames(const std::uint8_t low_byte,
 
 WheelSpeed::WheelSpeedType Wheelspeed6a::wheel_direction_convert(
     double wheel_speed) const {
-  int8_t wheel_direction = 0;
+  WheelSpeed::WheelSpeedType wheel_direction = WheelSpeed::INVALID;
   if (wheel_speed &gt; 0) {
-    wheel_direction = 0;
+    wheel_direction = WheelSpeed::FORWARD;
   } else if ((wheel_speed &gt; -0.01) &amp;&amp; (wheel_speed &lt; 0.01)) {
-    wheel_direction = 2;
+    wheel_direction = WheelSpeed::STANDSTILL;
   } else if (wheel_speed &lt; 0) {
-    wheel_direction = 1;
+    wheel_direction = WheelSpeed::BACKWARD;
   } else {
-    wheel_direction = 3;
+    wheel_direction = WheelSpeed::INVALID;
   }
-  WheelSpeed::WheelSpeedType ret =
-      static_cast&lt;WheelSpeed::WheelSpeedType&gt;(wheel_direction);
-  return ret;
+  return wheel_direction;
 }
 
 }  // namespace lincoln
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b106c7e552b6cca68838a4f275edb953f88fbfce" author="macDure">
		<msg>Canbus: fix the lincoln mkz wheel speed and wheel direction protocols bug</msg>
		<modified_files>
			<file old_path="modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" new_path="modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.cc" added_lines="26" deleted_lines="0">
				<diff>@@ -36,18 +36,26 @@ void Wheelspeed6a::Parse(const std::uint8_t *bytes, int32_t length,
   chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_fl(
       front_left_wheel_speed(bytes, length));
   chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_fl_valid(true);
+  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_direction_fl(
+      wheel_direction_convert(front_left_wheel_speed(bytes, length)));
   // front right
   chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_fr(
       front_right_wheel_speed(bytes, length));
   chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_fr_valid(true);
+  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_direction_fr(
+      wheel_direction_convert(front_right_wheel_speed(bytes, length)));
   // rear left
   chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_rl(
       rear_left_wheel_speed(bytes, length));
   chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_rl_valid(true);
+  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_direction_rl(
+      wheel_direction_convert(rear_left_wheel_speed(bytes, length)));
   // rear right
   chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_spd_rr(
       rear_right_wheel_speed(bytes, length));
   chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_is_wheel_spd_rr_valid(true);
+  chassis_detail-&gt;mutable_vehicle_spd()-&gt;set_wheel_direction_rr(
+      wheel_direction_convert(rear_right_wheel_speed(bytes, length)));
   /*
   -?(rr(bytes, length));
   -?(rl(bytes, length));
@@ -95,9 +103,27 @@ double Wheelspeed6a::parse_two_frames(const std::uint8_t low_byte,
   Byte low_frame(&amp;low_byte);
   int32_t low = low_frame.get_byte(0, 8);
   int32_t value = (high &lt;&lt; 8) | low;
+  if (value &gt; 0x7FFF) {
+    value -= 0x10000;
+  }
   return value * 0.010000;
 }
 
+WheelSpeed::WheelSpeedType Wheelspeed6a::wheel_direction_convert(
+    double wheel_speed) const {
+  WheelSpeed::WheelSpeedType wheel_direction = WheelSpeed::INVALID;
+  if (wheel_speed &gt; 0) {
+    wheel_direction = WheelSpeed::FORWARD;
+  } else if ((wheel_speed &gt; -0.01) &amp;&amp; (wheel_speed &lt; 0.01)) {
+    wheel_direction = WheelSpeed::STANDSTILL;
+  } else if (wheel_speed &lt; 0) {
+    wheel_direction = WheelSpeed::BACKWARD;
+  } else {
+    wheel_direction = WheelSpeed::INVALID;
+  }
+  return wheel_direction;
+}
+
 }  // namespace lincoln
 }  // namespace canbus
 }  // namespace apollo
</diff>
			</file>
			<file old_path="modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.h" new_path="modules\canbus\vehicle\lincoln\protocol\wheelspeed_6a.h" added_lines="4" deleted_lines="0">
				<diff>@@ -23,7 +23,9 @@
 
 #include &lt;sys/time.h&gt;
 
+#include "modules/canbus/proto/chassis.pb.h"
 #include "modules/canbus/proto/chassis_detail.pb.h"
+
 #include "modules/drivers/canbus/can_comm/protocol_data.h"
 
 /**
@@ -114,6 +116,8 @@ class Wheelspeed6a : public ::apollo::drivers::canbus::ProtocolData&lt;
 
   double parse_two_frames(const std::uint8_t low_byte,
                           const std::uint8_t high_byte) const;
+
+  WheelSpeed::WheelSpeedType wheel_direction_convert(double wheel_speed) const;
 };
 
 }  // namespace lincoln
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="539839c71452aedeecc30ff3df0d02aec4ec55fa" author="lilu15">
		<msg>Planning: refine the logic of construct out routing and fix the Reverse bug when car idle</msg>
		<modified_files>
			<file old_path="modules\planning\common\planning_gflags.cc" new_path="modules\planning\common\planning_gflags.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -188,7 +188,7 @@ DEFINE_double(threshold_distance_for_destination, 0.01,
 
 DEFINE_double(buffer_in_routing, 0.0, "buffer for select in lane for boundary");
 
-DEFINE_double(buffer_out_routing, 2.0,
+DEFINE_double(buffer_out_routing, -7.0,
               "buffer for select out lane for boundary");
 // planning trajectory output time density control
 DEFINE_double(
</diff>
			</file>
			<file old_path="modules\planning\tasks\optimizers\open_space_trajectory_partition\open_space_trajectory_partition.cc" new_path="modules\planning\tasks\optimizers\open_space_trajectory_partition\open_space_trajectory_partition.cc" added_lines="5" deleted_lines="0">
				<diff>@@ -666,6 +666,11 @@ bool OpenSpaceTrajectoryPartition::InsertGearShiftTrajectory(
       current_gear_status-&gt;gear_shift_period_finished = true;
       current_gear_status-&gt;gear_shift_period_started = true;
     } else {
+      // send N gear to protect idle
+      if (!last_frame-&gt;open_space_info().open_space_provider_success()) {
+        current_gear_status-&gt;gear_shift_position = canbus::Chassis::GEAR_NEUTRAL;
+      }
+      
       GenerateGearShiftTrajectory(current_gear_status-&gt;gear_shift_position,
                                   gear_switch_idle_time_trajectory);
       current_gear_status-&gt;gear_shift_period_time =
</diff>
			</file>
			<file old_path="modules\task_manager\dead_end_routing_manager.cc" new_path="modules\task_manager\dead_end_routing_manager.cc" added_lines="8" deleted_lines="0">
				<diff>@@ -34,6 +34,14 @@ common::Status DeadEndRoutingManager::Init(
   cycle_ = 2;
   routing_request_in_ = dead_end_routing_task.routing_request_in();
   routing_request_out_ = dead_end_routing_task.routing_request_out();
+
+  routing::RoutingRequest temp_out_routing_request = routing_request_out_;
+  routing_request_out_.clear_waypoint();
+  apollo::routing::LaneWaypoint *waypoint_first = routing_request_out_.add_waypoint();
+  waypoint_first-&gt;CopyFrom(temp_out_routing_request.waypoint().at(0));
+  apollo::routing::LaneWaypoint *waypoint_second = routing_request_out_.add_waypoint();
+  waypoint_second-&gt;CopyFrom(temp_out_routing_request.waypoint().at(2));
+
   return common::Status::OK();
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5ea5e966998d1731ced3d01bcf09c79139828a76" author="qwetqwe">
		<msg>Perception:fix fusion bug
fusion uses only one main sensor so that perception will output with main sensor frame

Change-Id: I42258042c0bacb00a36059d140f47252ad3d0735</msg>
		<modified_files>
			<file old_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.cc" new_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -30,7 +30,7 @@ bool ObstacleMultiSensorFusion::Init(
   fusion_.reset(fusion);
 
   FusionInitOptions init_options;
-  init_options.main_sensors = param.main_sensors;
+  init_options.main_sensor = param.main_sensor;
   if (fusion_ == nullptr || !fusion_-&gt;Init(init_options)) {
     AINFO &lt;&lt; "Failed to Get Instance or Initialize " &lt;&lt; param.fusion_method;
     return false;
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\dummy\dummy_algorithms.cc" new_path="modules\perception\fusion\lib\dummy\dummy_algorithms.cc" added_lines="2" deleted_lines="3">
				<diff>@@ -21,7 +21,7 @@ namespace fusion {
 
 // class DummyFusionSystem implementation
 bool DummyFusionSystem::Init(const FusionInitOptions&amp; options) {
-  main_sensors_ = options.main_sensors;
+  main_sensor_ = options.main_sensor;
   return true;
 }
 
@@ -33,8 +33,7 @@ bool DummyFusionSystem::Fuse(const FusionOptions&amp; options,
   }
 
   fused_objects-&gt;clear();
-  if (std::find(main_sensors_.begin(), main_sensors_.end(),
-                sensor_frame-&gt;sensor_info.name) == main_sensors_.end()) {
+  if (sensor_frame-&gt;sensor_info.name != main_sensor_) {
     return true;
   }
 
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\dummy\dummy_algorithms_test.cc" new_path="modules\perception\fusion\lib\dummy\dummy_algorithms_test.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -29,7 +29,7 @@ namespace fusion {
 
 TEST(DummyFusionSystemTest, test) {
   FusionInitOptions init_options;
-  init_options.main_sensors = std::vector&lt;std::string&gt;{"velodyne64"};
+  init_options.main_sensor = "velodyne64";
   DummyFusionSystem system;
   EXPECT_TRUE(system.Init(init_options));
 
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\fusion_system\probabilistic_fusion\probabilistic_fusion.cc" new_path="modules\perception\fusion\lib\fusion_system\probabilistic_fusion\probabilistic_fusion.cc" added_lines="6" deleted_lines="17">
				<diff>@@ -43,7 +43,7 @@ ProbabilisticFusion::ProbabilisticFusion() {}
 ProbabilisticFusion::~ProbabilisticFusion() {}
 
 bool ProbabilisticFusion::Init(const FusionInitOptions&amp; init_options) {
-  main_sensors_ = init_options.main_sensors;
+  main_sensor_ = init_options.main_sensor;
 
   BaseInitOptions options;
   if (!GetFusionInitOptions("ProbabilisticFusion", &amp;options)) {
@@ -128,16 +128,11 @@ bool ProbabilisticFusion::Fuse(const FusionOptions&amp; options,
     }
 
     bool is_publish_sensor = this-&gt;IsPublishSensor(sensor_frame);
-    if (is_publish_sensor) {
-      started_ = true;
-    }
 
-    if (started_) {
-      AINFO &lt;&lt; "add sensor measurement: " &lt;&lt; sensor_frame-&gt;sensor_info.name
-            &lt;&lt; ", obj_cnt : " &lt;&lt; sensor_frame-&gt;objects.size() &lt;&lt; ", "
-            &lt;&lt; FORMAT_TIMESTAMP(sensor_frame-&gt;timestamp);
-      sensor_data_manager-&gt;AddSensorMeasurements(sensor_frame);
-    }
+    AINFO &lt;&lt; "add sensor measurement: " &lt;&lt; sensor_frame-&gt;sensor_info.name
+          &lt;&lt; ", obj_cnt : " &lt;&lt; sensor_frame-&gt;objects.size() &lt;&lt; ", "
+          &lt;&lt; FORMAT_TIMESTAMP(sensor_frame-&gt;timestamp);
+    sensor_data_manager-&gt;AddSensorMeasurements(sensor_frame);
 
     if (!is_publish_sensor) {
       return true;
@@ -166,13 +161,7 @@ std::string ProbabilisticFusion::Name() const { return "ProbabilisticFusion"; }
 bool ProbabilisticFusion::IsPublishSensor(
     const base::FrameConstPtr&amp; sensor_frame) const {
   std::string sensor_id = sensor_frame-&gt;sensor_info.name;
-  const auto&amp; itr = std::find(
-      main_sensors_.begin(), main_sensors_.end(), sensor_id);
-  if (itr != main_sensors_.end()) {
-    return true;
-  } else {
-    return false;
-  }
+  return main_sensor_ == sensor_id;
 }
 
 void ProbabilisticFusion::FuseFrame(const SensorFramePtr&amp; frame) {
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\fusion_system\probabilistic_fusion\probabilistic_fusion_test.cc" new_path="modules\perception\fusion\lib\fusion_system\probabilistic_fusion\probabilistic_fusion_test.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -37,7 +37,7 @@ TEST(ProbabliticFusionTest, test_init) {
   sensor_manager-&gt;Reset();
   sensor_manager-&gt;Init();
   FusionInitOptions init_options;
-  init_options.main_sensors = std::vector&lt;std::string&gt;{"velodyne64"};
+  init_options.main_sensor = "velodyne64";
   ProbabilisticFusion pf;
   EXPECT_TRUE(pf.Init(init_options));
   EXPECT_EQ(pf.Name(), "ProbabilisticFusion");
@@ -106,7 +106,7 @@ TEST(ProbabliticFusionTest, test_update) {
   sensor_manager-&gt;Reset();
   sensor_manager-&gt;Init();
   FusionInitOptions init_options;
-  init_options.main_sensors = std::vector&lt;std::string&gt;{"velodyne64"};
+  init_options.main_sensor = "velodyne64";
   ProbabilisticFusion pf;
   EXPECT_TRUE(pf.Init(init_options));
   EXPECT_EQ(pf.Name(), "ProbabilisticFusion");
@@ -257,7 +257,7 @@ TEST(ProbabilisticFusionTest, test_collect_sensor_measurement) {
   sensor_manager-&gt;Reset();
   sensor_manager-&gt;Init();
   FusionInitOptions init_options;
-  init_options.main_sensors = std::vector&lt;std::string&gt;{"velodyne64"};
+  init_options.main_sensor = "velodyne64";
   ProbabilisticFusion pf;
   EXPECT_TRUE(pf.Init(init_options));
   EXPECT_EQ(pf.Name(), "ProbabilisticFusion");
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\interface\base_fusion_system.h" new_path="modules\perception\fusion\lib\interface\base_fusion_system.h" added_lines="2" deleted_lines="2">
				<diff>@@ -29,7 +29,7 @@ namespace perception {
 namespace fusion {
 
 struct FusionInitOptions {
-  std::vector&lt;std::string&gt; main_sensors;
+  std::string main_sensor;
 };
 
 struct FusionOptions {};
@@ -54,7 +54,7 @@ class BaseFusionSystem {
   virtual std::string Name() const = 0;
 
  protected:
-  std::vector&lt;std::string&gt; main_sensors_;
+  std::string main_sensor_;
 };
 
 PERCEPTION_REGISTER_REGISTERER(BaseFusionSystem);
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\interface\base_multisensor_fusion.h" new_path="modules\perception\fusion\lib\interface\base_multisensor_fusion.h" added_lines="1" deleted_lines="1">
				<diff>@@ -29,7 +29,7 @@ namespace perception {
 namespace fusion {
 
 struct ObstacleMultiSensorFusionParam {
-  std::vector&lt;std::string&gt; main_sensors;
+  std::string main_sensor;
   std::string fusion_method;
 };
 
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\detection_component.cc" new_path="modules\perception\onboard\component\detection_component.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -34,9 +34,10 @@ std::atomic&lt;uint32_t&gt; DetectionComponent::seq_num_{0};
 bool DetectionComponent::Init() {
   LidarDetectionComponentConfig comp_config;
   if (!GetProtoConfig(&amp;comp_config)) {
+    AERROR &lt;&lt; "Get config failed";
     return false;
   }
-  ADEBUG &lt;&lt; "Lidar Component Configs: " &lt;&lt; comp_config.DebugString();
+  AINFO &lt;&lt; "Lidar Component Configs: " &lt;&lt; comp_config.DebugString();
   output_channel_name_ = comp_config.output_channel_name();
   sensor_name_ = comp_config.sensor_name();
   detector_name_ = comp_config.detector_name();
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_component.cc" new_path="modules\perception\onboard\component\fusion_component.cc" added_lines="19" deleted_lines="19">
				<diff>@@ -38,9 +38,7 @@ bool FusionComponent::Init() {
   // to load component configs
   fusion_name_ = comp_config.fusion_name();
   fusion_method_ = comp_config.fusion_method();
-  for (int i = 0; i &lt; comp_config.fusion_main_sensors_size(); ++i) {
-    fusion_main_sensors_.push_back(comp_config.fusion_main_sensors(i));
-  }
+  fusion_main_sensor_ = comp_config.fusion_main_sensor();
   object_in_roi_check_ = comp_config.object_in_roi_check();
   radius_for_roi_object_check_ = comp_config.radius_for_roi_object_check();
 
@@ -61,23 +59,21 @@ bool FusionComponent::Proc(const std::shared_ptr&lt;SensorFrameMessage&gt;&amp; message) {
                                                        PerceptionObstacles);
   std::shared_ptr&lt;SensorFrameMessage&gt; viz_message(new (std::nothrow)
                                                       SensorFrameMessage);
-
-  // TODO(convert sensor id)
-  const auto&amp; itr = std::find(fusion_main_sensors_.begin(),
-                              fusion_main_sensors_.end(), message-&gt;sensor_id_);
-  if (itr == fusion_main_sensors_.end()) {
-    AINFO &lt;&lt; "Fusion receives message from " &lt;&lt; message-&gt;sensor_id_
-          &lt;&lt; " which is not in main sensors. Skip sending.";
-    return true;
-  }
-
   bool status = InternalProc(message, out_message, viz_message);
   if (status) {
-    writer_-&gt;Write(out_message);
-    AINFO &lt;&lt; "Send fusion processing output message.";
-    // send msg for visualization
-    if (FLAGS_obs_enable_visualization) {
-      inner_writer_-&gt;Write(viz_message);
+    // TODO(conver sensor id)
+    if (message-&gt;sensor_id_ != fusion_main_sensor_) {
+      AINFO &lt;&lt; "Fusion receive from " &lt;&lt; message-&gt;sensor_id_ &lt;&lt; "not from "
+            &lt;&lt; fusion_main_sensor_ &lt;&lt; ". Skip send.";
+    } else {
+      // Send("/apollo/perception/obstacles", out_message);
+      writer_-&gt;Write(out_message);
+      AINFO &lt;&lt; "Send fusion processing output message.";
+      // send msg for visualization
+      if (FLAGS_obs_enable_visualization) {
+        // Send("/apollo/perception/inner/PrefusedObjects", viz_message);
+        inner_writer_-&gt;Write(viz_message);
+      }
     }
   }
   return status;
@@ -89,7 +85,7 @@ bool FusionComponent::InitAlgorithmPlugin() {
   CHECK_NOTNULL(fusion);
   fusion_.reset(fusion);
   fusion::ObstacleMultiSensorFusionParam param;
-  param.main_sensors = fusion_main_sensors_;
+  param.main_sensor = fusion_main_sensor_;
   param.fusion_method = fusion_method_;
   ACHECK(fusion_-&gt;Init(param)) &lt;&lt; "Failed to init ObstacleMultiSensorFusion";
 
@@ -138,6 +134,10 @@ bool FusionComponent::InternalProc(
   }
   PERF_BLOCK_END_WITH_INDICATOR("fusion_process", in_message-&gt;sensor_id_);
 
+  if (in_message-&gt;sensor_id_ != fusion_main_sensor_) {
+    return true;
+  }
+
   Eigen::Matrix4d sensor2world_pose =
       in_message-&gt;frame_-&gt;sensor2world_pose.matrix();
   if (object_in_roi_check_ &amp;&amp; FLAGS_obs_enable_hdmap_input) {
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_component.h" new_path="modules\perception\onboard\component\fusion_component.h" added_lines="1" deleted_lines="1">
				<diff>@@ -50,7 +50,7 @@ class FusionComponent : public cyber::Component&lt;SensorFrameMessage&gt; {
 
   std::string fusion_name_;
   std::string fusion_method_;
-  std::vector&lt;std::string&gt; fusion_main_sensors_;
+  std::string fusion_main_sensor_;
   bool object_in_roi_check_ = false;
   double radius_for_roi_object_check_ = 0;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1cdf1909ba98caa39b3544399d0662fcd6b65635" author="qwetqwe">
		<msg>Perception:fix fusion bug
fusion uses only one main sensor so that perception will output with main sensor frame

Change-Id: I42258042c0bacb00a36059d140f47252ad3d0735</msg>
		<modified_files>
			<file old_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.cc" new_path="modules\perception\fusion\app\obstacle_multi_sensor_fusion.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -30,7 +30,7 @@ bool ObstacleMultiSensorFusion::Init(
   fusion_.reset(fusion);
 
   FusionInitOptions init_options;
-  init_options.main_sensors = param.main_sensors;
+  init_options.main_sensor = param.main_sensor;
   if (fusion_ == nullptr || !fusion_-&gt;Init(init_options)) {
     AINFO &lt;&lt; "Failed to Get Instance or Initialize " &lt;&lt; param.fusion_method;
     return false;
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\dummy\dummy_algorithms.cc" new_path="modules\perception\fusion\lib\dummy\dummy_algorithms.cc" added_lines="2" deleted_lines="3">
				<diff>@@ -21,7 +21,7 @@ namespace fusion {
 
 // class DummyFusionSystem implementation
 bool DummyFusionSystem::Init(const FusionInitOptions&amp; options) {
-  main_sensors_ = options.main_sensors;
+  main_sensor_ = options.main_sensor;
   return true;
 }
 
@@ -33,8 +33,7 @@ bool DummyFusionSystem::Fuse(const FusionOptions&amp; options,
   }
 
   fused_objects-&gt;clear();
-  if (std::find(main_sensors_.begin(), main_sensors_.end(),
-                sensor_frame-&gt;sensor_info.name) == main_sensors_.end()) {
+  if (sensor_frame-&gt;sensor_info.name != main_sensor_) {
     return true;
   }
 
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\dummy\dummy_algorithms_test.cc" new_path="modules\perception\fusion\lib\dummy\dummy_algorithms_test.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -29,7 +29,7 @@ namespace fusion {
 
 TEST(DummyFusionSystemTest, test) {
   FusionInitOptions init_options;
-  init_options.main_sensors = std::vector&lt;std::string&gt;{"velodyne64"};
+  init_options.main_sensor = "velodyne64";
   DummyFusionSystem system;
   EXPECT_TRUE(system.Init(init_options));
 
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\fusion_system\probabilistic_fusion\probabilistic_fusion.cc" new_path="modules\perception\fusion\lib\fusion_system\probabilistic_fusion\probabilistic_fusion.cc" added_lines="6" deleted_lines="17">
				<diff>@@ -43,7 +43,7 @@ ProbabilisticFusion::ProbabilisticFusion() {}
 ProbabilisticFusion::~ProbabilisticFusion() {}
 
 bool ProbabilisticFusion::Init(const FusionInitOptions&amp; init_options) {
-  main_sensors_ = init_options.main_sensors;
+  main_sensor_ = init_options.main_sensor;
 
   BaseInitOptions options;
   if (!GetFusionInitOptions("ProbabilisticFusion", &amp;options)) {
@@ -128,16 +128,11 @@ bool ProbabilisticFusion::Fuse(const FusionOptions&amp; options,
     }
 
     bool is_publish_sensor = this-&gt;IsPublishSensor(sensor_frame);
-    if (is_publish_sensor) {
-      started_ = true;
-    }
 
-    if (started_) {
-      AINFO &lt;&lt; "add sensor measurement: " &lt;&lt; sensor_frame-&gt;sensor_info.name
-            &lt;&lt; ", obj_cnt : " &lt;&lt; sensor_frame-&gt;objects.size() &lt;&lt; ", "
-            &lt;&lt; FORMAT_TIMESTAMP(sensor_frame-&gt;timestamp);
-      sensor_data_manager-&gt;AddSensorMeasurements(sensor_frame);
-    }
+    AINFO &lt;&lt; "add sensor measurement: " &lt;&lt; sensor_frame-&gt;sensor_info.name
+          &lt;&lt; ", obj_cnt : " &lt;&lt; sensor_frame-&gt;objects.size() &lt;&lt; ", "
+          &lt;&lt; FORMAT_TIMESTAMP(sensor_frame-&gt;timestamp);
+    sensor_data_manager-&gt;AddSensorMeasurements(sensor_frame);
 
     if (!is_publish_sensor) {
       return true;
@@ -166,13 +161,7 @@ std::string ProbabilisticFusion::Name() const { return "ProbabilisticFusion"; }
 bool ProbabilisticFusion::IsPublishSensor(
     const base::FrameConstPtr&amp; sensor_frame) const {
   std::string sensor_id = sensor_frame-&gt;sensor_info.name;
-  const auto&amp; itr = std::find(
-      main_sensors_.begin(), main_sensors_.end(), sensor_id);
-  if (itr != main_sensors_.end()) {
-    return true;
-  } else {
-    return false;
-  }
+  return main_sensor_ == sensor_id;
 }
 
 void ProbabilisticFusion::FuseFrame(const SensorFramePtr&amp; frame) {
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\fusion_system\probabilistic_fusion\probabilistic_fusion_test.cc" new_path="modules\perception\fusion\lib\fusion_system\probabilistic_fusion\probabilistic_fusion_test.cc" added_lines="3" deleted_lines="3">
				<diff>@@ -37,7 +37,7 @@ TEST(ProbabliticFusionTest, test_init) {
   sensor_manager-&gt;Reset();
   sensor_manager-&gt;Init();
   FusionInitOptions init_options;
-  init_options.main_sensors = std::vector&lt;std::string&gt;{"velodyne64"};
+  init_options.main_sensor = "velodyne64";
   ProbabilisticFusion pf;
   EXPECT_TRUE(pf.Init(init_options));
   EXPECT_EQ(pf.Name(), "ProbabilisticFusion");
@@ -106,7 +106,7 @@ TEST(ProbabliticFusionTest, test_update) {
   sensor_manager-&gt;Reset();
   sensor_manager-&gt;Init();
   FusionInitOptions init_options;
-  init_options.main_sensors = std::vector&lt;std::string&gt;{"velodyne64"};
+  init_options.main_sensor = "velodyne64";
   ProbabilisticFusion pf;
   EXPECT_TRUE(pf.Init(init_options));
   EXPECT_EQ(pf.Name(), "ProbabilisticFusion");
@@ -257,7 +257,7 @@ TEST(ProbabilisticFusionTest, test_collect_sensor_measurement) {
   sensor_manager-&gt;Reset();
   sensor_manager-&gt;Init();
   FusionInitOptions init_options;
-  init_options.main_sensors = std::vector&lt;std::string&gt;{"velodyne64"};
+  init_options.main_sensor = "velodyne64";
   ProbabilisticFusion pf;
   EXPECT_TRUE(pf.Init(init_options));
   EXPECT_EQ(pf.Name(), "ProbabilisticFusion");
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\interface\base_fusion_system.h" new_path="modules\perception\fusion\lib\interface\base_fusion_system.h" added_lines="2" deleted_lines="2">
				<diff>@@ -29,7 +29,7 @@ namespace perception {
 namespace fusion {
 
 struct FusionInitOptions {
-  std::vector&lt;std::string&gt; main_sensors;
+  std::string main_sensor;
 };
 
 struct FusionOptions {};
@@ -54,7 +54,7 @@ class BaseFusionSystem {
   virtual std::string Name() const = 0;
 
  protected:
-  std::vector&lt;std::string&gt; main_sensors_;
+  std::string main_sensor_;
 };
 
 PERCEPTION_REGISTER_REGISTERER(BaseFusionSystem);
</diff>
			</file>
			<file old_path="modules\perception\fusion\lib\interface\base_multisensor_fusion.h" new_path="modules\perception\fusion\lib\interface\base_multisensor_fusion.h" added_lines="1" deleted_lines="1">
				<diff>@@ -29,7 +29,7 @@ namespace perception {
 namespace fusion {
 
 struct ObstacleMultiSensorFusionParam {
-  std::vector&lt;std::string&gt; main_sensors;
+  std::string main_sensor;
   std::string fusion_method;
 };
 
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\detection_component.cc" new_path="modules\perception\onboard\component\detection_component.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -34,9 +34,10 @@ std::atomic&lt;uint32_t&gt; DetectionComponent::seq_num_{0};
 bool DetectionComponent::Init() {
   LidarDetectionComponentConfig comp_config;
   if (!GetProtoConfig(&amp;comp_config)) {
+    AERROR &lt;&lt; "Get config failed";
     return false;
   }
-  ADEBUG &lt;&lt; "Lidar Component Configs: " &lt;&lt; comp_config.DebugString();
+  AINFO &lt;&lt; "Lidar Component Configs: " &lt;&lt; comp_config.DebugString();
   output_channel_name_ = comp_config.output_channel_name();
   sensor_name_ = comp_config.sensor_name();
   detector_name_ = comp_config.detector_name();
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_component.cc" new_path="modules\perception\onboard\component\fusion_component.cc" added_lines="19" deleted_lines="19">
				<diff>@@ -38,9 +38,7 @@ bool FusionComponent::Init() {
   // to load component configs
   fusion_name_ = comp_config.fusion_name();
   fusion_method_ = comp_config.fusion_method();
-  for (int i = 0; i &lt; comp_config.fusion_main_sensors_size(); ++i) {
-    fusion_main_sensors_.push_back(comp_config.fusion_main_sensors(i));
-  }
+  fusion_main_sensor_ = comp_config.fusion_main_sensor();
   object_in_roi_check_ = comp_config.object_in_roi_check();
   radius_for_roi_object_check_ = comp_config.radius_for_roi_object_check();
 
@@ -61,23 +59,21 @@ bool FusionComponent::Proc(const std::shared_ptr&lt;SensorFrameMessage&gt;&amp; message) {
                                                        PerceptionObstacles);
   std::shared_ptr&lt;SensorFrameMessage&gt; viz_message(new (std::nothrow)
                                                       SensorFrameMessage);
-
-  // TODO(convert sensor id)
-  const auto&amp; itr = std::find(fusion_main_sensors_.begin(),
-                              fusion_main_sensors_.end(), message-&gt;sensor_id_);
-  if (itr == fusion_main_sensors_.end()) {
-    AINFO &lt;&lt; "Fusion receives message from " &lt;&lt; message-&gt;sensor_id_
-          &lt;&lt; " which is not in main sensors. Skip sending.";
-    return true;
-  }
-
   bool status = InternalProc(message, out_message, viz_message);
   if (status) {
-    writer_-&gt;Write(out_message);
-    AINFO &lt;&lt; "Send fusion processing output message.";
-    // send msg for visualization
-    if (FLAGS_obs_enable_visualization) {
-      inner_writer_-&gt;Write(viz_message);
+    // TODO(conver sensor id)
+    if (message-&gt;sensor_id_ != fusion_main_sensor_) {
+      AINFO &lt;&lt; "Fusion receive from " &lt;&lt; message-&gt;sensor_id_ &lt;&lt; "not from "
+            &lt;&lt; fusion_main_sensor_ &lt;&lt; ". Skip send.";
+    } else {
+      // Send("/apollo/perception/obstacles", out_message);
+      writer_-&gt;Write(out_message);
+      AINFO &lt;&lt; "Send fusion processing output message.";
+      // send msg for visualization
+      if (FLAGS_obs_enable_visualization) {
+        // Send("/apollo/perception/inner/PrefusedObjects", viz_message);
+        inner_writer_-&gt;Write(viz_message);
+      }
     }
   }
   return status;
@@ -89,7 +85,7 @@ bool FusionComponent::InitAlgorithmPlugin() {
   CHECK_NOTNULL(fusion);
   fusion_.reset(fusion);
   fusion::ObstacleMultiSensorFusionParam param;
-  param.main_sensors = fusion_main_sensors_;
+  param.main_sensor = fusion_main_sensor_;
   param.fusion_method = fusion_method_;
   ACHECK(fusion_-&gt;Init(param)) &lt;&lt; "Failed to init ObstacleMultiSensorFusion";
 
@@ -138,6 +134,10 @@ bool FusionComponent::InternalProc(
   }
   PERF_BLOCK_END_WITH_INDICATOR("fusion_process", in_message-&gt;sensor_id_);
 
+  if (in_message-&gt;sensor_id_ != fusion_main_sensor_) {
+    return true;
+  }
+
   Eigen::Matrix4d sensor2world_pose =
       in_message-&gt;frame_-&gt;sensor2world_pose.matrix();
   if (object_in_roi_check_ &amp;&amp; FLAGS_obs_enable_hdmap_input) {
</diff>
			</file>
			<file old_path="modules\perception\onboard\component\fusion_component.h" new_path="modules\perception\onboard\component\fusion_component.h" added_lines="1" deleted_lines="1">
				<diff>@@ -50,7 +50,7 @@ class FusionComponent : public cyber::Component&lt;SensorFrameMessage&gt; {
 
   std::string fusion_name_;
   std::string fusion_method_;
-  std::vector&lt;std::string&gt; fusion_main_sensors_;
+  std::string fusion_main_sensor_;
   bool object_in_roi_check_ = false;
   double radius_for_roi_object_check_ = 0;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e343fc5cbdbfadf9a251107ab78c8e0ea67a8a1a" author="lilu15">
		<msg>planning: refine the logic of completing the dead end</msg>
		<modified_files>
			<file old_path="modules\planning\on_lane_planning.cc" new_path="modules\planning\on_lane_planning.cc" added_lines="5" deleted_lines="3">
				<diff>@@ -472,12 +472,14 @@ void OnLanePlanning::RunOnce(const LocalView&amp; local_view,
   }
 
   // reference line recovery only one frame
-  bool complete_dead_end =
-    frame_.get()-&gt;open_space_info().destination_reached();
+  // bool complete_dead_end =
+  //   frame_.get()-&gt;open_space_info().destination_reached();
+  // AERROR &lt;&lt; "complete_dead_end is: " &lt;&lt; complete_dead_end;
+  /*
   if (complete_dead_end) {
     reference_line_provider_-&gt;Start();
     wait_flag_ = true;
-  }
+  }*/
   const uint32_t n = frame_-&gt;SequenceNum();
   injector_-&gt;frame_history()-&gt;Add(n, std::move(frame_));
 }
</diff>
			</file>
			<file old_path="modules\planning\on_lane_planning.h" new_path="modules\planning\on_lane_planning.h" added_lines="1" deleted_lines="1">
				<diff>@@ -114,7 +114,7 @@ class OnLanePlanning : public PlanningBase {
   routing::RoutingResponse last_routing_;
   std::unique_ptr&lt;ReferenceLineProvider&gt; reference_line_provider_;
   Smoother planning_smoother_;
-  bool wait_flag_ = false;
+  bool wait_flag_ = true;
   bool routing_in_flag_ = true;
   common::PointENU dead_end_point_;
 };
</diff>
			</file>
			<file old_path="modules\planning\scenarios\dead_end\deadend_turnaround\deadend_turnaround_scenario.cc" new_path="modules\planning\scenarios\dead_end\deadend_turnaround\deadend_turnaround_scenario.cc" added_lines="2" deleted_lines="0">
				<diff>@@ -180,6 +180,8 @@ bool DeadEndTurnAroundScenario::CheckDistanceToDeadEnd(
     JunctionInfoConstPtr* junction) {
   const Vec2d&amp; car_position = {vehicle_state.x(), vehicle_state.y()};
   auto junction_polygon = (*junction)-&gt;polygon();
+  AERROR &lt;&lt; "dead_end_start_range is: " &lt;&lt; dead_end_start_range;
+  AERROR &lt;&lt; "car dis is: " &lt;&lt; std::abs(junction_polygon.DistanceTo(car_position));
   return std::abs(junction_polygon.DistanceTo(car_position)) &lt;
          dead_end_start_range;
 }
</diff>
			</file>
			<file old_path="modules\planning\tasks\optimizers\open_space_trajectory_generation\open_space_trajectory_provider.cc" new_path="modules\planning\tasks\optimizers\open_space_trajectory_generation\open_space_trajectory_provider.cc" added_lines="23" deleted_lines="9">
				<diff>@@ -295,39 +295,53 @@ bool OpenSpaceTrajectoryProvider::IsVehicleNearDestination(
 
   end_pose_to_world_frame.SelfRotate(rotate_angle);
   end_pose_to_world_frame += translate_origin;
-
+  double distance_to_vehicle2 =
+      std::sqrt((vehicle_state.x() - end_pose_to_world_frame.x()) *
+                      (vehicle_state.x() - end_pose_to_world_frame.x()) +
+                  (vehicle_state.y() - end_pose_to_world_frame.y()) *
+                      (vehicle_state.y() - end_pose_to_world_frame.y()));
   double end_theta_to_world_frame = end_pose[2];
   end_theta_to_world_frame += rotate_angle;
-
+  double distance_to_vehicle1 =
+      std::sqrt((vehicle_state.x() - end_pose[0]) *
+                    (vehicle_state.x() - end_pose[0]) +
+                (vehicle_state.y() - end_pose[1]) *
+                    (vehicle_state.y() - end_pose[1]));
   double distance_to_vehicle =
       std::sqrt((vehicle_state.x() - end_pose_to_world_frame.x()) *
                     (vehicle_state.x() - end_pose_to_world_frame.x()) +
                 (vehicle_state.y() - end_pose_to_world_frame.y()) *
                     (vehicle_state.y() - end_pose_to_world_frame.y()));
-
   double theta_to_vehicle = std::abs(common::math::AngleDiff(
       vehicle_state.heading(), end_theta_to_world_frame));
-  ADEBUG &lt;&lt; "theta_to_vehicle" &lt;&lt; theta_to_vehicle &lt;&lt; "end_theta_to_world_frame"
+  AERROR &lt;&lt; "distance_to_vehicle1 is: " &lt;&lt; distance_to_vehicle1;
+  AERROR &lt;&lt; "distance_to_vehicle2 is: " &lt;&lt; distance_to_vehicle2;
+  AERROR &lt;&lt; "theta_to_vehicle" &lt;&lt; theta_to_vehicle &lt;&lt; "end_theta_to_world_frame"
          &lt;&lt; end_theta_to_world_frame &lt;&lt; "rotate_angle" &lt;&lt; rotate_angle;
-  ADEBUG &lt;&lt; "is_near_destination_threshold"
+  AERROR &lt;&lt; "is_near_destination_threshold"
          &lt;&lt; config_.open_space_trajectory_provider_config()
                 .open_space_trajectory_optimizer_config()
                 .planner_open_space_config()
                 .is_near_destination_threshold();  // which config file
-  ADEBUG &lt;&lt; "is_near_destination_theta_threshold"
+  AERROR &lt;&lt; "is_near_destination_theta_threshold"
          &lt;&lt; config_.open_space_trajectory_provider_config()
                 .open_space_trajectory_optimizer_config()
                 .planner_open_space_config()
                 .is_near_destination_theta_threshold();
-  if (distance_to_vehicle &lt; config_.open_space_trajectory_provider_config()
+  distance_to_vehicle = std::min(
+                        std::min(distance_to_vehicle, distance_to_vehicle1),
+                        distance_to_vehicle2);
+  theta_to_vehicle = std::min(theta_to_vehicle,
+                     std::abs(vehicle_state.heading()));
+ if (distance_to_vehicle &lt; config_.open_space_trajectory_provider_config()
                                 .open_space_trajectory_optimizer_config()
                                 .planner_open_space_config()
                                 .is_near_destination_threshold() &amp;&amp;
-      theta_to_vehicle &lt; config_.open_space_trajectory_provider_config()
+     theta_to_vehicle &lt; config_.open_space_trajectory_provider_config()
                              .open_space_trajectory_optimizer_config()
                              .planner_open_space_config()
                              .is_near_destination_theta_threshold()) {
-    ADEBUG &lt;&lt; "vehicle reach end_pose";
+    AERROR &lt;&lt; "vehicle reach end_pose";
     frame_-&gt;mutable_open_space_info()-&gt;set_destination_reached(true);
     return true;
   }
</diff>
			</file>
			<file old_path="modules\task_manager\dead_end_routing_manager.h" new_path="modules\task_manager\dead_end_routing_manager.h" added_lines="1" deleted_lines="1">
				<diff>@@ -57,7 +57,7 @@ class DeadEndRoutingManager {
  private:
   int cycle_ = 0;
   bool routing_in_flag_ = true;
-  bool routing_out_flag_ = true;
+  bool routing_out_flag_ = false;
   apollo::common::monitor::MonitorLogBuffer monitor_logger_buffer_;
   routing::RoutingRequest routing_request_in_;
   routing::RoutingRequest routing_request_out_;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="37e3365fd0ad383e1be1991d8eee90f88b628d60" author="litianjiao">
		<msg>Prediction: fix bug bike use free move on lane

Change-Id: Ib7abf5ebadbda224970d0189358aef28146cd082</msg>
		<modified_files>
			<file old_path="modules\prediction\container\obstacles\obstacle.cc" new_path="modules\prediction\container\obstacles\obstacle.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -110,7 +110,8 @@ bool Obstacle::IsOnLane() const {
     return false;
   }
   for (const auto&amp; curr_lane : latest_feature().lane().current_lane_feature()) {
-    if (curr_lane.lane_type() != hdmap::Lane::CITY_DRIVING) {
+    if (curr_lane.lane_type() != hdmap::Lane::CITY_DRIVING &amp;&amp;
+        curr_lane.lane_type() != hdmap::Lane::BIKING) {
       return false;
     }
   }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ae651cbb0d39e374dcc09e879dc7adf40105dca9" author="liuxu20">
		<msg>Lint: fix some lint bug

Change-Id: If3ef3f2011fcf47b4ef26c847e65f24df8e3b114</msg>
		<modified_files>
			<file old_path="modules\planning\scenarios\dead_end\deadend_turnaround\deadend_turnaround_scenario.cc" new_path="modules\planning\scenarios\dead_end\deadend_turnaround\deadend_turnaround_scenario.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -181,7 +181,8 @@ bool DeadEndTurnAroundScenario::CheckDistanceToDeadEnd(
   const Vec2d&amp; car_position = {vehicle_state.x(), vehicle_state.y()};
   auto junction_polygon = (*junction)-&gt;polygon();
   AERROR &lt;&lt; "dead_end_start_range is: " &lt;&lt; dead_end_start_range;
-  AERROR &lt;&lt; "car dis is: " &lt;&lt; std::abs(junction_polygon.DistanceTo(car_position));
+  AERROR &lt;&lt; "car dis is: " &lt;&lt;
+  std::abs(junction_polygon.DistanceTo(car_position));
   return std::abs(junction_polygon.DistanceTo(car_position)) &lt;
          dead_end_start_range;
 }
</diff>
			</file>
			<file old_path="modules\planning\tasks\optimizers\open_space_trajectory_generation\open_space_trajectory_provider.cc" new_path="modules\planning\tasks\optimizers\open_space_trajectory_generation\open_space_trajectory_provider.cc" added_lines="2" deleted_lines="1">
				<diff>@@ -20,6 +20,7 @@
 
 #include "modules/planning/tasks/optimizers/open_space_trajectory_generation/open_space_trajectory_provider.h"
 
+#include &lt;algorithm&gt;
 #include &lt;memory&gt;
 #include &lt;string&gt;
 
@@ -333,7 +334,7 @@ bool OpenSpaceTrajectoryProvider::IsVehicleNearDestination(
                         distance_to_vehicle2);
   theta_to_vehicle = std::min(theta_to_vehicle,
                      std::abs(vehicle_state.heading()));
- if (distance_to_vehicle &lt; config_.open_space_trajectory_provider_config()
+  if (distance_to_vehicle &lt; config_.open_space_trajectory_provider_config()
                                 .open_space_trajectory_optimizer_config()
                                 .planner_open_space_config()
                                 .is_near_destination_threshold() &amp;&amp;
</diff>
			</file>
			<file old_path="modules\planning\tasks\optimizers\open_space_trajectory_partition\open_space_trajectory_partition.cc" new_path="modules\planning\tasks\optimizers\open_space_trajectory_partition\open_space_trajectory_partition.cc" added_lines="2" deleted_lines="2">
				<diff>@@ -668,9 +668,9 @@ bool OpenSpaceTrajectoryPartition::InsertGearShiftTrajectory(
     } else {
       // send N gear to protect idle
       if (!last_frame-&gt;open_space_info().open_space_provider_success()) {
-        current_gear_status-&gt;gear_shift_position = canbus::Chassis::GEAR_NEUTRAL;
+        current_gear_status-&gt;gear_shift_position =
+        canbus::Chassis::GEAR_NEUTRAL;
       }
-      
       GenerateGearShiftTrajectory(current_gear_status-&gt;gear_shift_position,
                                   gear_switch_idle_time_trajectory);
       current_gear_status-&gt;gear_shift_period_time =
</diff>
			</file>
			<file old_path="modules\task_manager\dead_end_routing_manager.cc" new_path="modules\task_manager\dead_end_routing_manager.cc" added_lines="4" deleted_lines="2">
				<diff>@@ -37,9 +37,11 @@ common::Status DeadEndRoutingManager::Init(
 
   routing::RoutingRequest temp_out_routing_request = routing_request_out_;
   routing_request_out_.clear_waypoint();
-  apollo::routing::LaneWaypoint *waypoint_first = routing_request_out_.add_waypoint();
+  apollo::routing::LaneWaypoint *waypoint_first =
+  routing_request_out_.add_waypoint();
   waypoint_first-&gt;CopyFrom(temp_out_routing_request.waypoint().at(0));
-  apollo::routing::LaneWaypoint *waypoint_second = routing_request_out_.add_waypoint();
+  apollo::routing::LaneWaypoint *waypoint_second =
+  routing_request_out_.add_waypoint();
   waypoint_second-&gt;CopyFrom(temp_out_routing_request.waypoint().at(2));
 
   return common::Status::OK();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="183fbc22bde7750bdd83d6801d1885bf72d50eca" author="qwetqwe">
		<msg>Planning: fix left turn with multi stop line

Change-Id: If37b2f000889393553800507bf604c381cb846f3</msg>
		<modified_files>
			<file old_path="modules\planning\scenarios\common\stage_intersection_cruise_impl.cc" new_path="modules\planning\scenarios\common\stage_intersection_cruise_impl.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -85,7 +85,7 @@ bool StageIntersectionCruiseImpl::CheckDone(
       return true;
     }
 
-    static constexpr double kIntersectionPassDist = 20.0;  // unit: m
+    static constexpr double kIntersectionPassDist = 40.0;  // unit: m
     const double adc_back_edge_s =
         reference_line_info.AdcSlBoundary().start_s();
     const double distance_adc_pass_traffic_sign =
</diff>
			</file>
			<file old_path="modules\planning\scenarios\traffic_light\unprotected_left_turn\stage_approach.cc" new_path="modules\planning\scenarios\traffic_light\unprotected_left_turn\stage_approach.cc" added_lines="2" deleted_lines="0">
				<diff>@@ -96,6 +96,8 @@ Stage::StageStatus TrafficLightUnprotectedLeftTurnStageApproach::Process(
            &lt;&lt; "] distance_adc_to_stop_line[" &lt;&lt; distance_adc_to_stop_line
            &lt;&lt; "] color[" &lt;&lt; signal_color &lt;&lt; "]";
 
+    if (distance_adc_to_stop_line &lt; 0)
+        return FinishStage(frame);
     // check on traffic light color and distance to stop line
     if (signal_color != TrafficLight::GREEN ||
         distance_adc_to_stop_line &gt;=
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6fb71b1624e9bed1f44a8607f77d9fa82884d874" author="qwetqwe">
		<msg>Dreamview: fix map service bug
fix routing start point failed at roadside

Change-Id: I19a88f0d505e1470b1ddcbc397638dccde849016</msg>
		<modified_files>
			<file old_path="modules\dreamview\backend\map\map_service.cc" new_path="modules\dreamview\backend\map\map_service.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -354,7 +354,7 @@ bool MapService::GetNearestLaneWithHeading(const double x, const double y,
   PointENU point;
   point.set_x(x);
   point.set_y(y);
-  static constexpr double kSearchRadius = 1.0;
+  static constexpr double kSearchRadius = 3.0;
   static constexpr double kMaxHeadingDiff = 1.0;
   if (!MapReady() || HDMap()-&gt;GetNearestLaneWithHeading(
                          point, kSearchRadius, heading, kMaxHeadingDiff,
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e6f4fbcbcc1ca5de2eab2d7566d2bb1e479e5e19" author="liuxu21">
		<msg>prediction: add obstacle priority to obstacle history map.

Change-Id: I248e31805fabfdee29b44eccde3b5c47619f2910</msg>
		<modified_files>
			<file old_path="modules\prediction\evaluator\evaluator_manager.cc" new_path="modules\prediction\evaluator\evaluator_manager.cc" added_lines="1" deleted_lines="0">
				<diff>@@ -363,6 +363,7 @@ void EvaluatorManager::BuildObstacleIdHistoryMap(
       feature.set_theta(obstacle_feature.velocity_heading());
       feature.mutable_interactive_tag()-&gt;CopyFrom(
           obstacle_feature.interactive_tag());
+      feature.mutable_priority()-&gt;CopyFrom(obstacle_feature.priority());
 
       if (obstacle_feature.id() != FLAGS_ego_vehicle_id) {
         feature.mutable_polygon_point()-&gt;CopyFrom(
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7ded2a69737aa03144055605ddeab39ba5769858" author="Feng">
		<msg>Planning: fix bug in reeds shepp

invited by Jinyun</msg>
		<modified_files>
			<file old_path="modules\planning\open_space\coarse_trajectory_generator\reeds_shepp_path.cc" new_path="modules\planning\open_space\coarse_trajectory_generator\reeds_shepp_path.cc" added_lines="16" deleted_lines="16">
				<diff>@@ -459,7 +459,7 @@ bool ReedShepp::CCCC(const double x, const double y, const double phi,
 bool ReedShepp::CCSC(const double x, const double y, const double phi,
                      std::vector&lt;ReedSheppPath&gt;* all_possible_paths) {
   RSPParam LRSL1_param;
-  LRLRn(x, y, phi, &amp;LRSL1_param);
+  LRSL(x, y, phi, &amp;LRSL1_param);
   double LRSL1_lengths[4] = {LRSL1_param.t, -0.5 * M_PI, -LRSL1_param.u,
                              LRSL1_param.v};
   char LRSL1_types[] = "LRSL";
@@ -470,7 +470,7 @@ bool ReedShepp::CCSC(const double x, const double y, const double phi,
   }
 
   RSPParam LRSL2_param;
-  LRLRn(-x, y, -phi, &amp;LRSL2_param);
+  LRSL(-x, y, -phi, &amp;LRSL2_param);
   double LRSL2_lengths[4] = {-LRSL2_param.t, 0.5 * M_PI, -LRSL2_param.u,
                              -LRSL2_param.v};
   char LRSL2_types[] = "LRSL";
@@ -481,7 +481,7 @@ bool ReedShepp::CCSC(const double x, const double y, const double phi,
   }
 
   RSPParam LRSL3_param;
-  LRLRn(x, -y, -phi, &amp;LRSL3_param);
+  LRSL(x, -y, -phi, &amp;LRSL3_param);
   double LRSL3_lengths[4] = {LRSL3_param.t, -0.5 * M_PI, LRSL3_param.u,
                              LRSL3_param.v};
   char LRSL3_types[] = "RLSR";
@@ -492,7 +492,7 @@ bool ReedShepp::CCSC(const double x, const double y, const double phi,
   }
 
   RSPParam LRSL4_param;
-  LRLRn(-x, -y, phi, &amp;LRSL4_param);
+  LRSL(-x, -y, phi, &amp;LRSL4_param);
   double LRSL4_lengths[4] = {-LRSL4_param.t, -0.5 * M_PI, -LRSL4_param.u,
                              -LRSL4_param.v};
   char LRSL4_types[] = "RLSR";
@@ -503,7 +503,7 @@ bool ReedShepp::CCSC(const double x, const double y, const double phi,
   }
 
   RSPParam LRSR1_param;
-  LRLRp(x, y, phi, &amp;LRSR1_param);
+  LRSR(x, y, phi, &amp;LRSR1_param);
   double LRSR1_lengths[4] = {LRSR1_param.t, -0.5 * M_PI, LRSR1_param.u,
                              LRSR1_param.v};
   char LRSR1_types[] = "LRSR";
@@ -514,7 +514,7 @@ bool ReedShepp::CCSC(const double x, const double y, const double phi,
   }
 
   RSPParam LRSR2_param;
-  LRLRp(-x, y, -phi, &amp;LRSR2_param);
+  LRSR(-x, y, -phi, &amp;LRSR2_param);
   double LRSR2_lengths[4] = {-LRSR2_param.t, 0.5 * M_PI, -LRSR2_param.u,
                              -LRSR2_param.v};
   char LRSR2_types[] = "LRSR";
@@ -525,7 +525,7 @@ bool ReedShepp::CCSC(const double x, const double y, const double phi,
   }
 
   RSPParam LRSR3_param;
-  LRLRp(x, -y, -phi, &amp;LRSR3_param);
+  LRSR(x, -y, -phi, &amp;LRSR3_param);
   double LRSR3_lengths[4] = {LRSR3_param.t, -0.5 * M_PI, LRSR3_param.u,
                              LRSR3_param.v};
   char LRSR3_types[] = "RLSL";
@@ -536,7 +536,7 @@ bool ReedShepp::CCSC(const double x, const double y, const double phi,
   }
 
   RSPParam LRSR4_param;
-  LRLRp(-x, -y, phi, &amp;LRSR4_param);
+  LRSR(-x, -y, phi, &amp;LRSR4_param);
   double LRSR4_lengths[4] = {-LRSR4_param.t, 0.5 * M_PI, -LRSR4_param.u,
                              -LRSR4_param.v};
   char LRSR4_types[] = "RLSL";
@@ -551,7 +551,7 @@ bool ReedShepp::CCSC(const double x, const double y, const double phi,
   double yb = x * std::sin(phi) - y * std::cos(phi);
 
   RSPParam LRSL5_param;
-  LRLRn(xb, yb, phi, &amp;LRSL5_param);
+  LRSL(xb, yb, phi, &amp;LRSL5_param);
   double LRSL5_lengths[4] = {LRSL5_param.v, LRSL5_param.u, -0.5 * M_PI,
                              LRSL5_param.t};
   char LRSL5_types[] = "LSRL";
@@ -562,7 +562,7 @@ bool ReedShepp::CCSC(const double x, const double y, const double phi,
   }
 
   RSPParam LRSL6_param;
-  LRLRn(-xb, yb, -phi, &amp;LRSL6_param);
+  LRSL(-xb, yb, -phi, &amp;LRSL6_param);
   double LRSL6_lengths[4] = {-LRSL6_param.v, -LRSL6_param.u, 0.5 * M_PI,
                              -LRSL6_param.t};
   char LRSL6_types[] = "LSRL";
@@ -573,7 +573,7 @@ bool ReedShepp::CCSC(const double x, const double y, const double phi,
   }
 
   RSPParam LRSL7_param;
-  LRLRn(xb, -yb, -phi, &amp;LRSL7_param);
+  LRSL(xb, -yb, -phi, &amp;LRSL7_param);
   double LRSL7_lengths[4] = {LRSL7_param.v, LRSL7_param.u, -0.5 * M_PI,
                              LRSL7_param.t};
   char LRSL7_types[] = "RSLR";
@@ -584,7 +584,7 @@ bool ReedShepp::CCSC(const double x, const double y, const double phi,
   }
 
   RSPParam LRSL8_param;
-  LRLRn(-xb, -yb, phi, &amp;LRSL8_param);
+  LRSL(-xb, -yb, phi, &amp;LRSL8_param);
   double LRSL8_lengths[4] = {-LRSL8_param.v, -LRSL8_param.u, 0.5 * M_PI,
                              -LRSL8_param.t};
   char LRSL8_types[] = "RSLR";
@@ -595,7 +595,7 @@ bool ReedShepp::CCSC(const double x, const double y, const double phi,
   }
 
   RSPParam LRSR5_param;
-  LRLRp(xb, yb, phi, &amp;LRSR5_param);
+  LRSR(xb, yb, phi, &amp;LRSR5_param);
   double LRSR5_lengths[4] = {LRSR5_param.v, LRSR5_param.u, -0.5 * M_PI,
                              LRSR5_param.t};
   char LRSR5_types[] = "RSRL";
@@ -606,7 +606,7 @@ bool ReedShepp::CCSC(const double x, const double y, const double phi,
   }
 
   RSPParam LRSR6_param;
-  LRLRp(-xb, yb, -phi, &amp;LRSR6_param);
+  LRSR(-xb, yb, -phi, &amp;LRSR6_param);
   double LRSR6_lengths[4] = {-LRSR6_param.v, -LRSR6_param.u, 0.5 * M_PI,
                              -LRSR6_param.t};
   char LRSR6_types[] = "RSRL";
@@ -617,7 +617,7 @@ bool ReedShepp::CCSC(const double x, const double y, const double phi,
   }
 
   RSPParam LRSR7_param;
-  LRLRp(xb, -yb, -phi, &amp;LRSR7_param);
+  LRSR(xb, -yb, -phi, &amp;LRSR7_param);
   double LRSR7_lengths[4] = {LRSR7_param.v, LRSR7_param.u, -0.5 * M_PI,
                              LRSR7_param.t};
   char LRSR7_types[] = "LSLR";
@@ -628,7 +628,7 @@ bool ReedShepp::CCSC(const double x, const double y, const double phi,
   }
 
   RSPParam LRSR8_param;
-  LRLRp(-xb, -yb, phi, &amp;LRSR8_param);
+  LRSR(-xb, -yb, phi, &amp;LRSR8_param);
   double LRSR8_lengths[4] = {-LRSR8_param.v, -LRSR8_param.u, 0.5 * M_PI,
                              -LRSR8_param.t};
   char LRSR8_types[] = "LSLR";
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a0c7920f1bd18c109ac204d7043c627dd5229aaa" author="daohu527">
		<msg>bridge: fix class load error</msg>
		<modified_files>
			<file old_path="modules\bridge\udp_bridge_multi_receiver_component.h" new_path="modules\bridge\udp_bridge_multi_receiver_component.h" added_lines="3" deleted_lines="1">
				<diff>@@ -43,7 +43,7 @@ namespace bridge {
 class UDPBridgeMultiReceiverComponent final : public cyber::Component&lt;&gt; {
  public:
   UDPBridgeMultiReceiverComponent();
-  ~UDPBridgeMultiReceiverComponent();
+  ~UDPBridgeMultiReceiverComponent() = default;
 
   bool Init() override;
   std::string Name() const { return FLAGS_bridge_module_name; }
@@ -68,5 +68,7 @@ class UDPBridgeMultiReceiverComponent final : public cyber::Component&lt;&gt; {
   std::vector&lt;std::shared_ptr&lt;ProtoDiserializedBufBase&gt;&gt; proto_list_;
 };
 
+CYBER_REGISTER_COMPONENT(UDPBridgeMultiReceiverComponent)
+
 }  // namespace bridge
 }  // namespace apollo
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6a94703b3ff8c5ae7499c2321c67bc15f66b92fb" author="fuyiqun">
		<msg>prediction: change map_info range to 100.0 meters

Change-Id: If5372026475f3847c69abb515b7146b83340b513</msg>
		<modified_files>
			<file old_path="modules\prediction\common\prediction_system_gflags.cc" new_path="modules\prediction\common\prediction_system_gflags.cc" added_lines="1" deleted_lines="1">
				<diff>@@ -95,7 +95,7 @@ DEFINE_string(prediction_target_dir, "/apollo/data/train/",
 DEFINE_double(obstacle_x, 0.0, "obstacle position x");
 DEFINE_double(obstacle_y, 0.0, "obstacle position y");
 DEFINE_double(obstacle_phi, 0.0, "obstacle heading phi");
-DEFINE_double(road_distance, 141.4,
+DEFINE_double(road_distance, 100.0,
               "road distance within which the points are got");
 DEFINE_double(point_distance, 5.0,
               "sampling distance of two points");
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="15f82f87f2c875c804be1ed8d78cf612412c5934" author="wangbowen04">
		<msg>bug fix

Change-Id: I698620a25552dc41704d39d81e896fc8f5b9f307</msg>
		<modified_files>
			<file old_path="cyber\message\message_traits.h" new_path="cyber\message\message_traits.h" added_lines="3" deleted_lines="0">
				<diff>@@ -219,6 +219,9 @@ SerializeToHC(const T&amp; message, void* data, int size) {
   MessageHeader header;
   header.set_msg_type(type_name.data(), type_name.size());
   header.set_content_size(msg_size);
+  if (sizeof(header) &gt; static_cast&lt;size_t&gt;(size)) {
+    return false;
+  }
   char* ptr = reinterpret_cast&lt;char*&gt;(data);
   memcpy(ptr, static_cast&lt;const void*&gt;(&amp;header), sizeof(header));
   ptr += sizeof(header);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8fbed2e68e6a28a73bfb5437cb88a59b5ae71d5b" author="qwetqwe">
		<msg>Planning:fix traffic light scenarion selection bug
Planning always use traffic light unprotected scenario in turn left lane

Change-Id: I009535e584df4b76d4038594201b112d7e93d103</msg>
		<modified_files>
			<file old_path="modules\planning\scenarios\scenario_manager.cc" new_path="modules\planning\scenarios\scenario_manager.cc" added_lines="12" deleted_lines="3">
				<diff>@@ -515,7 +515,8 @@ ScenarioConfig::ScenarioType ScenarioManager::SelectTrafficLightScenario(
 
   bool traffic_light_scenario = false;
   bool red_light = false;
-
+  bool left_turn_signal = false;
+  const auto hdmap_ptr = HDMapUtil::BaseMapPtr();
   // note: need iterate all lights to check no RED/YELLOW/UNKNOWN
   for (const auto&amp; traffic_light_overlap : next_traffic_lights) {
     const double adc_distance_to_traffic_light =
@@ -538,7 +539,15 @@ ScenarioConfig::ScenarioType ScenarioManager::SelectTrafficLightScenario(
     ADEBUG &lt;&lt; "traffic_light_id[" &lt;&lt; traffic_light_overlap.object_id
            &lt;&lt; "] start_s[" &lt;&lt; traffic_light_overlap.start_s &lt;&lt; "] color["
            &lt;&lt; signal_color &lt;&lt; "]";
-
+    apollo::hdmap::Id signal_id;
+    signal_id.set_id(traffic_light_overlap.object_id);
+    auto signal = hdmap_ptr-&gt;GetSignalById(signal_id)-&gt;signal();
+    for (auto subsignal : signal.subsignal()) {
+      if (subsignal.type() == apollo::hdmap::Subsignal::ARROW_LEFT) {
+        left_turn_signal = true;
+        break;
+      }
+    }
     if (signal_color != perception::TrafficLight::GREEN) {
       red_light = true;
       break;
@@ -565,7 +574,7 @@ ScenarioConfig::ScenarioType ScenarioManager::SelectTrafficLightScenario(
           scenario_config.start_traffic_light_scenario_distance()) {
         traffic_light_unprotected_right_turn_scenario = true;
       }
-    } else if (left_turn) {
+    } else if (left_turn &amp;&amp; !left_turn_signal) {
       // check TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN
       const auto&amp; scenario_config =
           config_map_[ScenarioConfig::TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN]
</diff>
			</file>
		</modified_files>
	</commit>
</Root>
