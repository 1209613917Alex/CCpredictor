<?xml version="1.0" encoding="utf-8"?>
<Root>
	<commit hash="63aa0acadfef1f494e2a023775c22669c61b7ced" author="Yuki Kitsukawa">
		<msg>add approximate_ndt_mapping (#811)</msg>
		<modified_files>
			<file old_path="ros\src\.config\rviz\ndt_mapping.rviz" new_path="ros\src\.config\rviz\ndt_mapping.rviz" added_lines="9" deleted_lines="9">
				<diff>@@ -6,7 +6,7 @@ Panels:
       Expanded:
         - /Global Options1
       Splitter Ratio: 0.5
-    Tree Height: 895
+    Tree Height: 870
   - Class: rviz/Selection
     Name: Selection
   - Class: rviz/Tool Properties
@@ -25,7 +25,7 @@ Panels:
     Experimental: false
     Name: Time
     SyncMode: 0
-    SyncSource: NDT Map
+    SyncSource: ""
 Visualization Manager:
   Class: ""
   Displays:
@@ -58,6 +58,8 @@ Visualization Manager:
           Value: true
         velodyne:
           Value: true
+        world:
+          Value: true
       Marker Scale: 1
       Name: TF
       Show Arrows: true
@@ -65,7 +67,9 @@ Visualization Manager:
       Show Names: true
       Tree:
         map:
-          {}
+          base_link:
+            velodyne:
+              {}
       Update Interval: 0
       Value: true
     - Alpha: 1
@@ -88,7 +92,7 @@ Visualization Manager:
       Min Intensity: 0
       Name: NDT Map
       Position Transformer: XYZ
-      Queue Size: 10
+      Queue Size: 1
       Selectable: true
       Size (Pixels): 1
       Size (m): 0.01
@@ -162,10 +166,9 @@ Window Geometry:
     collapsed: false
   Displays:
     collapsed: false
-  Height: 1176
   Hide Left Dock: false
   Hide Right Dock: false
-  QMainWindow State: 000000ff00000000fd00000004000000000000016a0000040efc020000000afb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006400fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb000000100044006900730070006c00610079007301000000280000040e000000dd00fffffffb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb0000000a0049006d00610067006501000003a90000008d0000000000000000fb0000000c00430061006d0065007200610000000420000000160000001600000016000000010000010f0000040efc0200000003fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fc000000280000040e000000b000fffffffa000000010100000002fb0000000a0049006d0061006700650000000000ffffffff0000000000000000fb0000000a0056006900650077007301000003a10000010f0000010f00fffffffb0000001200530065006c0065006300740069006f006e010000025a000000b200000000000000000000000200000490000000a9fc0100000001fb0000000a00560069006500770073030000004e00000080000002e100000197000000030000073f0000003efc0100000002fb0000000800540069006d006501000000000000073f000002f600fffffffb0000000800540069006d00650100000000000004500000000000000000000004ba0000040e00000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
+  QMainWindow State: 000000ff00000000fd00000004000000000000016a000003f5fc020000000afb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006400fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afb000000100044006900730070006c0061007900730100000041000003f5000000dd00fffffffb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb0000000a0049006d00610067006501000003a90000008d0000000000000000fb0000000c00430061006d0065007200610000000420000000160000001600000016000000010000010f000003f5fc0200000003fb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fc00000041000003f5000000b000fffffffa000000010100000002fb0000000a0049006d0061006700650000000000ffffffff0000000000000000fb0000000a0056006900650077007301000003a10000010f0000010f00fffffffb0000001200530065006c0065006300740069006f006e010000025a000000b200000000000000000000000200000490000000a9fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000007510000003efc0100000002fb0000000800540069006d0065010000000000000751000002f600fffffffb0000000800540069006d00650100000000000004500000000000000000000004cc000003f500000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
   Selection:
     collapsed: false
   Time:
@@ -174,6 +177,3 @@ Window Geometry:
     collapsed: false
   Views:
     collapsed: false
-  Width: 1855
-  X: 65
-  Y: 207
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="083ff4863b3d173a2ed6ead8b81dd99fd9b7c4df" author="Yusuke FUJII">
		<msg>Release/1.5.1 (#816)

* fix a build error by gcc version

* fix build error for older indigo version

* update changelog for v1.5.1

* 1.5.1</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" added_lines="4" deleted_lines="0">
				<diff>@@ -1068,7 +1068,11 @@ void PlannerX::PlannerMainLoop()
 				enableLattice.data = 1;
 			}else{
 				visualization_msgs::Marker delMarker;
+#ifndef ROS_KINETIC
+				delMarker.action = visualization_msgs::Marker::DELETE;
+#else
 				delMarker.action = visualization_msgs::Marker::DELETEALL;
+#endif
 				delMarker.ns = "global_lane_array_marker_dynamic";
 				all_rollOuts_dynamic.markers.push_back(delMarker);
 				pub_LocalTrajectoriesRviz_dynamic.publish(all_rollOuts_dynamic);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ee29bf64c31a51d6751fac47de8521be62c469de" author="yukikitsukawa">
		<msg>bug fix on output filename.</msg>
		<modified_files>
			<file old_path="ros\src\util\packages\map_tools\nodes\map_extender\map_extender.cpp" new_path="ros\src\util\packages\map_tools\nodes\map_extender\map_extender.cpp" added_lines="14" deleted_lines="12">
				<diff>@@ -92,7 +92,7 @@ static ros::Publisher ndt_map_pub;
 static bool _get_height = false;
 static bool hasMapSet = false;
 
-static std::string input_pcd;
+static std::string input_pcd, output_pcd, output_pcd_rgb;
 
 static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr&amp; input)
 {
@@ -157,15 +157,9 @@ static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped:
   msg_ptr-&gt;header.frame_id = "/map";
   ndt_map_pub.publish(*msg_ptr);
 
-  // Writing Point Cloud data to PCD file
-  int tmp = input_pcd.find_last_of("/");
-  std::string prefix = "extended_";
-  std::string prefix_rgb = "extended_rgb_";
-  std::string output = input_pcd.insert(tmp+1, prefix);
-  std::string output_rgb = input_pcd.insert(tmp+1, prefix_rgb);
 
-  pcl::io::savePCDFileBinary(output, *transformed_additional_map_ptr);
-  std::cout &lt;&lt; "Saved " &lt;&lt; output &lt;&lt; ": " &lt;&lt; transformed_additional_map_ptr-&gt;points.size() &lt;&lt; " points." &lt;&lt; std::endl;
+  pcl::io::savePCDFileBinary(output_pcd, *transformed_additional_map_ptr);
+  std::cout &lt;&lt; "Saved " &lt;&lt; output_pcd &lt;&lt; ": " &lt;&lt; transformed_additional_map_ptr-&gt;points.size() &lt;&lt; " points." &lt;&lt; std::endl;
 
   pcl::PointCloud&lt;pcl::PointXYZRGB&gt; cloud_rgb;
   cloud_rgb.width = transformed_additional_map_ptr-&gt;width;
@@ -179,8 +173,8 @@ static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped:
     cloud_rgb.points[i].rgb = 255 &lt;&lt; 16 | 255 &lt;&lt; 8 | 255;
   }
 
-  pcl::io::savePCDFileBinary(output_rgb, cloud_rgb);
-  std::cout &lt;&lt; "Saved " &lt;&lt; output_rgb &lt;&lt; ": " &lt;&lt;  cloud_rgb.points.size() &lt;&lt; " points." &lt;&lt; std::endl;
+  pcl::io::savePCDFileBinary(output_pcd_rgb, cloud_rgb);
+  std::cout &lt;&lt; "Saved " &lt;&lt; output_pcd_rgb &lt;&lt; ": " &lt;&lt;  cloud_rgb.points.size() &lt;&lt; " points." &lt;&lt; std::endl;
 
   std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
   std::cout &lt;&lt; "Sequence number: " &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
@@ -219,7 +213,15 @@ int main(int argc, char **argv)
     ros::init(argc, argv, "map_extender");
     ros::NodeHandle n;
 
-    input_pcd = argv[1];
+    input_pcd = output_pcd = output_pcd_rgb = argv[1];
+    int tmp = input_pcd.find_last_of("/");
+    std::string prefix = "extended_";
+    std::string prefix_rgb = "extended_rgb_";
+    output_pcd.insert(tmp+1, prefix);
+    output_pcd_rgb.insert(tmp+1, prefix_rgb);
+    std::cout &lt;&lt; input_pcd &lt;&lt; std::endl;
+    std::cout &lt;&lt; output_pcd &lt;&lt; std::endl;
+    std::cout &lt;&lt; output_pcd_rgb &lt;&lt; std::endl;
 
     if(pcl::io::loadPCDFile&lt;pcl::PointXYZI&gt; (input_pcd, *additional_map_ptr) == -1){
       std::cout &lt;&lt; "Couldn't read " &lt;&lt; input_pcd &lt;&lt; "." &lt;&lt; std::endl;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="fa806eaa72892a2f077bc8edc89b750f7b5f1b5f" author="AMC">
		<msg>Ray Ground Filter Initial Commit</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" added_lines="5" deleted_lines="1">
				<diff>@@ -1068,7 +1068,11 @@ void PlannerX::PlannerMainLoop()
 				enableLattice.data = 1;
 			}else{
 				visualization_msgs::Marker delMarker;
-				delMarker.action = visualization_msgs::Marker::DELETEALL;
+#ifndef ROS_KINETIC
+					delMarker.action = visualization_msgs::Marker::DELETE;
+#else
+					delMarker.action = visualization_msgs::Marker::DELETEALL;
+#endif
 				delMarker.ns = "global_lane_array_marker_dynamic";
 				all_rollOuts_dynamic.markers.push_back(delMarker);
 				pub_LocalTrajectoriesRviz_dynamic.publish(all_rollOuts_dynamic);
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ground_filter\ground_filter.cpp" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ring_ground_filter\ring_ground_filter.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -395,7 +395,7 @@ void GroundFilter::VelodyneCallback(const pcl::PointCloud&lt;velodyne_pointcloud::P
 int main(int argc, char **argv)
 {
 
-	ros::init(argc, argv, "ground_filter");
+	ros::init(argc, argv, "ring_ground_filter");
 	GroundFilter node;
 	ros::spin();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c8da6ef868845f5af8b6609cf9fd46a8b77254df" author="AMC">
		<msg>Added Compilation fix for Kinect</msg>
		<modified_files>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\ray_ground_filter.cpp" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\ray_ground_filter.cpp" added_lines="2" deleted_lines="0">
				<diff>@@ -42,6 +42,8 @@
 #include &lt;pcl/filters/extract_indices.h&gt;
 #include &lt;velodyne_pointcloud/point_types.h&gt;
 #include "autoware_msgs/ConfigRayGroundFilter.h"
+
+#include &lt;opencv2/core/version.hpp&gt;
 #if (CV_MAJOR_VERSION == 3)
 	#include "gencolors.cpp"
 #else
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7dc35384b7fde7b356ea3766008169be1a0ec28f" author="Akihito Ohsato">
		<msg>Add ground_filter config for runtime_manager (#828)</msg>
		<modified_files>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ground_filter\ground_filter.cpp" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ground_filter\ground_filter.cpp" added_lines="45" deleted_lines="24">
				<diff>@@ -12,6 +12,7 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;velodyne_pointcloud/point_types.h&gt;
 #include &lt;opencv/cv.h&gt;
+#include "autoware_msgs/ConfigGroundFilter.h"
 
 enum Label
 {
@@ -23,12 +24,13 @@ enum Label
 class GroundFilter
 {
 public:
-	
+
 	GroundFilter();
 
 private:
 
 	ros::NodeHandle node_handle_;
+	ros::Subscriber config_node_sub_;
 	ros::Subscriber points_node_sub_;
 	ros::Publisher groundless_points_pub_;
 	ros::Publisher ground_points_pub_;
@@ -55,13 +57,14 @@ private:
 
 	const int 	DEFAULT_HOR_RES = 2000;
 
+	void SetHorizontalRes(const int sensor_model, int &amp;horizontal_res);
 	void InitLabelArray(int in_model);
 	void InitDepthMap(int in_width);
 	void PublishPointCloud(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
-				int in_indices[], int &amp;in_out_index_size, 
+				int in_indices[], int &amp;in_out_index_size,
 				pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;in_cloud);
 
-
+	void ConfigCallback(const autoware_msgs::ConfigGroundFilterConstPtr &amp;config);
 	void VelodyneCallback(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg);
 	void FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
 				pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;out_groundless_points,
@@ -98,23 +101,10 @@ GroundFilter::GroundFilter() : node_handle_("~")
 	ROS_INFO("Only Ground Output Point Cloud: %s", ground_topic.c_str());
 
 	int default_horizontal_res;
-	switch(sensor_model_)
-	{
-		case 64:
-			default_horizontal_res = 2083;
-			break;
-		case 32:
-			default_horizontal_res = 2250;
-			break;
-		case 16:
-			default_horizontal_res = 1800;
-			break;
-		default:
-			default_horizontal_res = DEFAULT_HOR_RES;
-			break;
-	}
+	SetHorizontalRes(sensor_model_, default_horizontal_res);
 	node_handle_.param("horizontal_res", horizontal_res_, default_horizontal_res);
 
+	config_node_sub_ = node_handle_.subscribe("/config/ground_filter", 10, &amp;GroundFilter::ConfigCallback, this);
 	points_node_sub_ = node_handle_.subscribe(point_topic_, 2, &amp;GroundFilter::VelodyneCallback, this);
 	groundless_points_pub_ = node_handle_.advertise&lt;sensor_msgs::PointCloud2&gt;(no_ground_topic, 2);
 	ground_points_pub_ = node_handle_.advertise&lt;sensor_msgs::PointCloud2&gt;(ground_topic, 2);
@@ -125,6 +115,25 @@ GroundFilter::GroundFilter() : node_handle_("~")
 
 }
 
+void GroundFilter::SetHorizontalRes(const int sensor_model, int &amp;horizontal_res)
+{
+	switch(sensor_model)
+	{
+		case 64:
+			horizontal_res = 2083;
+			break;
+		case 32:
+			horizontal_res = 2250;
+			break;
+		case 16:
+			horizontal_res = 1800;
+			break;
+		default:
+			horizontal_res = DEFAULT_HOR_RES;
+			break;
+	}
+}
+
 void GroundFilter::InitLabelArray(int in_model)
 {
 	for(int a = 0; a &lt; vertical_res_; a++)
@@ -140,7 +149,7 @@ void GroundFilter::InitDepthMap(int in_width)
 }
 
 void GroundFilter::PublishPointCloud(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
-				int in_indices[], int &amp;in_out_index_size, 
+				int in_indices[], int &amp;in_out_index_size,
 				pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;in_cloud)
 {
 	velodyne_pointcloud::PointXYZIR point;
@@ -153,7 +162,7 @@ void GroundFilter::PublishPointCloud(const pcl::PointCloud&lt;velodyne_pointcloud::
 		point.ring = in_cloud_msg-&gt;points[in_indices[i]].ring;
 		in_cloud.push_back(point);
 	}
-	in_out_index_size = 0;	
+	in_out_index_size = 0;
 }
 
 void GroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
@@ -175,7 +184,7 @@ void GroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::Point
 		int row = vertical_res_ - 1 - in_cloud_msg-&gt;points[i].ring;
 		index_map_.at&lt;int&gt;(row, column) = i;
 	}
-	
+
 	for (int i = 0; i &lt; horizontal_res_; i++)
 	{
 		Label point_class[vertical_res_];
@@ -185,7 +194,7 @@ void GroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::Point
 		int point_index_size = 0;
 		double z_ref = 0;
 		double r_ref = 0;
-		std::copy(class_label_, class_label_ + vertical_res_, point_class); 
+		std::copy(class_label_, class_label_ + vertical_res_, point_class);
 
 		for (int j = vertical_res_ - 1; j &gt;= 0; j--)
 		{
@@ -370,6 +379,18 @@ void GroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::Point
 
 }
 
+void GroundFilter::ConfigCallback(const autoware_msgs::ConfigGroundFilterConstPtr &amp;config)
+{
+  sensor_model_ = std::stoi(config-&gt;sensor_model);
+  sensor_height_ = config-&gt;sensor_height;
+	max_slope_ = config-&gt;max_slope;
+	point_distance_ = config-&gt;point_distance;
+	min_point_ = config-&gt;min_point;
+	clipping_thres_ = config-&gt;clipping_thres;
+	gap_thres_ = config-&gt;gap_thres;
+	SetHorizontalRes(sensor_model_, horizontal_res_);
+}
+
 void GroundFilter::VelodyneCallback(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg)
 {
 
@@ -385,8 +406,8 @@ void GroundFilter::VelodyneCallback(const pcl::PointCloud&lt;velodyne_pointcloud::P
 	if (!floor_removal_)
 	{
 		vertical_points = *in_cloud_msg;
-	} 
-	
+	}
+
 	groundless_points_pub_.publish(vertical_points);
 	ground_points_pub_.publish(ground_points);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="627e16d1f8d78399c68a6a6909a99f94ba11fab3" author="AMC">
		<msg>Solved conflicts by ring filter config message naming change</msg>
		<modified_files>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ring_ground_filter\ring_ground_filter.cpp" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ring_ground_filter\ring_ground_filter.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -12,7 +12,7 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;velodyne_pointcloud/point_types.h&gt;
 #include &lt;opencv/cv.h&gt;
-#include "autoware_msgs/ConfigGroundFilter.h"
+#include "autoware_msgs/ConfigRingGroundFilter.h"
 
 enum Label
 {
@@ -64,7 +64,7 @@ private:
 				int in_indices[], int &amp;in_out_index_size,
 				pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;in_cloud);
 
-	void ConfigCallback(const autoware_msgs::ConfigGroundFilterConstPtr &amp;config);
+	void ConfigCallback(const autoware_msgs::ConfigRingGroundFilterConstPtr &amp;config);
 	void VelodyneCallback(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg);
 	void FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
 				pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;out_groundless_points,
@@ -379,7 +379,7 @@ void RingGroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::P
 
 }
 
-void RingGroundFilter::ConfigCallback(const autoware_msgs::ConfigGroundFilterConstPtr &amp;config)
+void RingGroundFilter::ConfigCallback(const autoware_msgs::ConfigRingGroundFilterConstPtr &amp;config)
 {
   sensor_model_ = std::stoi(config-&gt;sensor_model);
   sensor_height_ = config-&gt;sensor_height;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="32c60d5ddf7d8a0090aa915831f1f1bbdfa43cc7" author="Yuki Iida">
		<msg>fix path of runtime manager for web</msg>
		<modified_files>
			<file old_path="ui\web\app\views\index.html" new_path="ui\web\runtime_manager\app\views\index.html" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d067f668cc26820420c508923ec99a2226093a23" author="yukikitsukawa">
		<msg>fix calculation of ndt_pose from localizer_pose</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="2" deleted_lines="8">
				<diff>@@ -190,7 +190,7 @@ static autoware_msgs::ndt_stat ndt_stat_msg;
 static double predict_pose_error = 0.0;
 
 static double _tf_x, _tf_y, _tf_z, _tf_roll, _tf_pitch, _tf_yaw;
-static Eigen::Matrix4f tf_btol, tf_ltob;
+static Eigen::Matrix4f tf_btol;
 
 static std::string _localizer = "velodyne";
 static std::string _offset = "linear";  // linear, zero, quadratic
@@ -805,7 +805,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
 
     t = ndt.getFinalTransformation();  // localizer
-    t2 = t * tf_ltob;                  // base_link
+    t2 = t * tf_btol.inverse();                  // base_link
 
     iteration = ndt.getFinalNumIteration();
 #ifdef USE_FAST_PCL
@@ -1336,12 +1336,6 @@ int main(int argc, char** argv)
   Eigen::AngleAxisf rot_z_btol(_tf_yaw, Eigen::Vector3f::UnitZ());
   tf_btol = (tl_btol * rot_z_btol * rot_y_btol * rot_x_btol).matrix();
 
-  Eigen::Translation3f tl_ltob((-1.0) * _tf_x, (-1.0) * _tf_y, (-1.0) * _tf_z);  // tl: translation
-  Eigen::AngleAxisf rot_x_ltob((-1.0) * _tf_roll, Eigen::Vector3f::UnitX());     // rot: rotation
-  Eigen::AngleAxisf rot_y_ltob((-1.0) * _tf_pitch, Eigen::Vector3f::UnitY());
-  Eigen::AngleAxisf rot_z_ltob((-1.0) * _tf_yaw, Eigen::Vector3f::UnitZ());
-  tf_ltob = (tl_ltob * rot_z_ltob * rot_y_ltob * rot_x_ltob).matrix();
-
   // Updated in initialpose_callback or gnss_callback
   initial_pose.x = 0.0;
   initial_pose.y = 0.0;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="cace949a5fd17fc68760384b48cb98b1b8ffd0e9" author="Yamato ANDO">
		<msg>remove inline functions</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\Matrix.h" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\Matrix.h" added_lines="194" deleted_lines="144">
				<diff>@@ -10,196 +10,246 @@ namespace gpu {
 
 class Matrix {
 public:
-	CUDAH Matrix() {
-		buffer_ = NULL;
-		rows_ = cols_ = offset_ = 0;
-	}
+	CUDAH Matrix();
 
-	CUDAH Matrix(int rows, int cols, int offset, double *buffer) {
-		rows_ = rows;
-		cols_ = cols;
-		offset_ = offset;
-		buffer_ = buffer;
-	}
+	CUDAH Matrix(int rows, int cols, int offset, double *buffer);
 
-	CUDAH int rows() const {
-		return rows_;
-	}
+	CUDAH int rows() const;
 
-	CUDAH int cols() const {
-		return cols_;
-	}
+	CUDAH int cols() const;
 
-	CUDAH int offset() const {
-		return offset_;
-	}
+	CUDAH int offset() const;
 
-	CUDAH double *buffer() const {
-		return buffer_;
-	}
+	CUDAH double *buffer() const;
 
-	CUDAH void setRows(int rows) { rows_ = rows; }
-	CUDAH void setCols(int cols) { cols_ = cols; }
-	CUDAH void setOffset(int offset) { offset_ = offset; }
-	CUDAH void setBuffer(double *buffer) { buffer_ = buffer; }
-	CUDAH void setCellVal(int row, int col, double val) {
-		buffer_[(row * cols_ + col) * offset_] = val;
-	}
+	CUDAH void setRows(int rows);
+	CUDAH void setCols(int cols);
+	CUDAH void setOffset(int offset);
+	CUDAH void setBuffer(double *buffer);
+	CUDAH void setCellVal(int row, int col, double val);
 
-	CUDAH void copy(Matrix &amp;output) {
-		for (int i = 0; i &lt; rows_; i++) {
-			for (int j = 0; j &lt; cols_; j++) {
-				output(i, j) = buffer_[(i * cols_ + j) * offset_];
-			}
-		}
-	}
+	CUDAH void copy(Matrix &amp;output);
 
 	//Need to fix. Only reducing rows is OK now.
-	CUDAH void resize(int rows, int cols) {
-		rows_ = rows;
-		cols_ = cols;
-	}
+	CUDAH void resize(int rows, int cols);
 
-	CUDAH double *cellAddr(int row, int col) {
-		if (row &gt;= rows_ || col &gt;= cols_ || row &lt; 0 || col &lt; 0)
-			return NULL;
+	CUDAH double *cellAddr(int row, int col);
 
-		return buffer_ + (row * cols_ + col) * offset_;
-	}
+	CUDAH double *cellAddr(int index);
+
+	//Assignment operator
+	CUDAH void operator=(const Matrix input);
+
+	CUDAH double&amp; operator()(int row, int col);
+
+	CUDAH void set(int row, int col, double val);
+
+	CUDAH double&amp; operator()(int index);
+
+	CUDAH double at(int row, int col) const;
+
+	CUDAH bool operator*=(double val);
+
+	CUDAH bool operator/=(double val);
+
+	CUDAH bool transpose(Matrix &amp;output);
+
+	//Only applicable for 3x3 matrix or below
+	CUDAH bool inverse(Matrix &amp;output);
+
+	CUDAH Matrix col(int index);
+
+	CUDAH Matrix row(int index);
 
-	CUDAH double *cellAddr(int index) {
-		if (rows_ == 1 &amp;&amp; index &gt;= 0 &amp;&amp; index &lt; cols_) {
-				return buffer_ + index * offset_;
-		} 
-		else if (cols_ == 1 &amp;&amp; index &gt;= 0 &amp;&amp; index &lt; rows_) {
-				return buffer_ + index * offset_;
+protected:
+	double *buffer_;
+	int rows_, cols_, offset_;
+};
+
+
+CUDAH Matrix::Matrix() {
+	buffer_ = NULL;
+	rows_ = cols_ = offset_ = 0;
+}
+
+CUDAH Matrix::Matrix(int rows, int cols, int offset, double *buffer) {
+	rows_ = rows;
+	cols_ = cols;
+	offset_ = offset;
+	buffer_ = buffer;
+}
+
+CUDAH int Matrix::rows() const {
+	return rows_;
+}
+
+CUDAH int Matrix::cols() const {
+	return cols_;
+}
+
+CUDAH int Matrix::offset() const {
+	return offset_;
+}
+
+CUDAH double *Matrix::buffer() const {
+	return buffer_;
+}
+
+CUDAH void Matrix::setRows(int rows) { rows_ = rows; }
+CUDAH void Matrix::setCols(int cols) { cols_ = cols; }
+CUDAH void Matrix::setOffset(int offset) { offset_ = offset; }
+CUDAH void Matrix::setBuffer(double *buffer) { buffer_ = buffer; }
+CUDAH void Matrix::setCellVal(int row, int col, double val) {
+	buffer_[(row * cols_ + col) * offset_] = val;
+}
+
+CUDAH void Matrix::copy(Matrix &amp;output) {
+	for (int i = 0; i &lt; rows_; i++) {
+		for (int j = 0; j &lt; cols_; j++) {
+			output(i, j) = buffer_[(i * cols_ + j) * offset_];
 		}
+	}
+}
+
+//Need to fix. Only reducing rows is OK now.
+CUDAH void Matrix::resize(int rows, int cols) {
+	rows_ = rows;
+	cols_ = cols;
+}
 
+CUDAH double *Matrix::cellAddr(int row, int col) {
+	if (row &gt;= rows_ || col &gt;= cols_ || row &lt; 0 || col &lt; 0)
 		return NULL;
-	}
 
-	//Assignment operator
-	CUDAH void operator=(const Matrix input) {
-		rows_ = input.rows_;
-		cols_ = input.cols_;
-		offset_ = input.offset_;
-		buffer_ = input.buffer_;
-	}
+	return buffer_ + (row * cols_ + col) * offset_;
+}
 
-	CUDAH double&amp; operator()(int row, int col) {
-		return buffer_[(row * cols_ + col) * offset_];
+CUDAH double *Matrix::cellAddr(int index) {
+	if (rows_ == 1 &amp;&amp; index &gt;= 0 &amp;&amp; index &lt; cols_) {
+			return buffer_ + index * offset_;
 	}
-
-	CUDAH void set(int row, int col, double val) {
-		buffer_[(row * cols_ + col) * offset_] = val;
+	else if (cols_ == 1 &amp;&amp; index &gt;= 0 &amp;&amp; index &lt; rows_) {
+			return buffer_ + index * offset_;
 	}
 
-	CUDAH double&amp; operator()(int index) {
-		return buffer_[index * offset_];
-	}
+	return NULL;
+}
 
-	CUDAH double at(int row, int col) const {
-		return buffer_[(row * cols_ + col) * offset_];
-	}
+//Assignment operator
+CUDAH void Matrix::operator=(const Matrix input) {
+	rows_ = input.rows_;
+	cols_ = input.cols_;
+	offset_ = input.offset_;
+	buffer_ = input.buffer_;
+}
 
-	CUDAH bool operator*=(double val) {
-		for (int i = 0; i &lt; rows_; i++) {
-			for (int j = 0; j &lt; cols_; j++) {
-				buffer_[(i * cols_ + j) * offset_] *= val;
-			}
-		}
+CUDAH double&amp; Matrix::operator()(int row, int col) {
+	return buffer_[(row * cols_ + col) * offset_];
+}
 
-		return true;
-	}
+CUDAH void Matrix::set(int row, int col, double val) {
+	buffer_[(row * cols_ + col) * offset_] = val;
+}
 
-	CUDAH bool operator/=(double val) {
-		if (val == 0)
-			return false;
+CUDAH double&amp; Matrix::operator()(int index) {
+	return buffer_[index * offset_];
+}
 
-		for (int i = 0; i &lt; rows_ * cols_; i++) {
-				buffer_[i * offset_] /= val;
-		}
+CUDAH double Matrix::at(int row, int col) const {
+	return buffer_[(row * cols_ + col) * offset_];
+}
 
-		return true;
+CUDAH bool Matrix::operator*=(double val) {
+	for (int i = 0; i &lt; rows_; i++) {
+		for (int j = 0; j &lt; cols_; j++) {
+			buffer_[(i * cols_ + j) * offset_] *= val;
+		}
 	}
 
-	CUDAH bool transpose(Matrix &amp;output) {
-		if (rows_ != output.cols_ || cols_ != output.rows_)
-			return false;
+	return true;
+}
 
-		for (int i = 0; i &lt; rows_; i++) {
-			for (int j = 0; j &lt; cols_; j++) {
-				output(j, i) = buffer_[(i * cols_ + j) * offset_];
-			}
-		}
+CUDAH bool Matrix::operator/=(double val) {
+	if (val == 0)
+		return false;
 
-		return true;
+	for (int i = 0; i &lt; rows_ * cols_; i++) {
+			buffer_[i * offset_] /= val;
 	}
 
-	//Only applicable for 3x3 matrix or below
-	CUDAH bool inverse(Matrix &amp;output) {
-		if (rows_ != cols_ || rows_ == 0 || cols_ == 0)
-			return false;
+	return true;
+}
+
+CUDAH bool Matrix::transpose(Matrix &amp;output) {
+	if (rows_ != output.cols_ || cols_ != output.rows_)
+		return false;
 
-		if (rows_ == 1) {
-			if (buffer_[0] != 0)
-				output(0, 0) = 1 / buffer_[0];
-			else
-				return false;
+	for (int i = 0; i &lt; rows_; i++) {
+		for (int j = 0; j &lt; cols_; j++) {
+			output(j, i) = buffer_[(i * cols_ + j) * offset_];
 		}
+	}
 
-		if (rows_ == 2) {
-			double det = at(0, 0) * at(1, 1) - at(0, 1) * at(1, 0);
+	return true;
+}
 
-			if (det != 0) {
-				output(0, 0) = at(1, 1) / det;
-				output(0, 1) = - at(0, 1) / det;
+//Only applicable for 3x3 matrix or below
+CUDAH bool Matrix::inverse(Matrix &amp;output) {
+	if (rows_ != cols_ || rows_ == 0 || cols_ == 0)
+		return false;
 
-				output(1, 0) = - at(1, 0) / det;
-				output(1, 1) = at(0, 0) / det;
-			} else
-				return false;
-		}
+	if (rows_ == 1) {
+		if (buffer_[0] != 0)
+			output(0, 0) = 1 / buffer_[0];
+		else
+			return false;
+	}
 
-		if (rows_ == 3) {
-			double det = at(0, 0) * at(1, 1) * at(2, 2) + at(0, 1) * at(1, 2) * at(2, 0) + at(1, 0) * at (2, 1) * at(0, 2)
-							- at(0, 2) * at(1, 1) * at(2, 0) - at(0, 1) * at(1, 0) * at(2, 2) - at(0, 0) * at(1, 2) * at(2, 1);
-			double idet = 1.0 / det;
-
-			if (det != 0) {
-				output(0, 0) = (at(1, 1) * at(2, 2) - at(1, 2) * at(2, 1)) * idet;
-				output(0, 1) = - (at(0, 1) * at(2, 2) - at(0, 2) * at(2, 1)) * idet;
-				output(0, 2) = (at(0, 1) * at(1, 2) - at(0, 2) * at(1, 1)) * idet;
-
-				output(1, 0) = - (at(1, 0) * at(2, 2) - at(1, 2) * at(2, 0)) * idet;
-				output(1, 1) = (at(0, 0) * at(2, 2) - at(0, 2) * at(2, 0)) * idet;
-				output(1, 2) = - (at(0, 0) * at(1, 2) - at(0, 2) * at(1, 0)) * idet;
-
-				output(2, 0) = (at(1, 0) * at(2, 1) - at(1, 1) * at(2, 0)) * idet;
-				output(2, 1) = - (at(0, 0) * at(2, 1) - at(0, 1) * at(2, 0)) * idet;
-				output(2, 2) = (at(0, 0) * at(1, 1) - at(0, 1) * at(1, 0)) * idet;
-			} else
-				return false;
-		}
+	if (rows_ == 2) {
+		double det = at(0, 0) * at(1, 1) - at(0, 1) * at(1, 0);
 
-		return true;
-	}
+		if (det != 0) {
+			output(0, 0) = at(1, 1) / det;
+			output(0, 1) = - at(0, 1) / det;
 
-	CUDAH Matrix col(int index) {
-		return Matrix(rows_, 1, offset_ * cols_, buffer_ + index * offset_);
+			output(1, 0) = - at(1, 0) / det;
+			output(1, 1) = at(0, 0) / det;
+		} else
+			return false;
 	}
 
-	CUDAH Matrix row(int index) {
-		return Matrix(1, cols_, offset_, buffer_ + index * cols_ * offset_);
+	if (rows_ == 3) {
+		double det = at(0, 0) * at(1, 1) * at(2, 2) + at(0, 1) * at(1, 2) * at(2, 0) + at(1, 0) * at (2, 1) * at(0, 2)
+						- at(0, 2) * at(1, 1) * at(2, 0) - at(0, 1) * at(1, 0) * at(2, 2) - at(0, 0) * at(1, 2) * at(2, 1);
+		double idet = 1.0 / det;
+
+		if (det != 0) {
+			output(0, 0) = (at(1, 1) * at(2, 2) - at(1, 2) * at(2, 1)) * idet;
+			output(0, 1) = - (at(0, 1) * at(2, 2) - at(0, 2) * at(2, 1)) * idet;
+			output(0, 2) = (at(0, 1) * at(1, 2) - at(0, 2) * at(1, 1)) * idet;
+
+			output(1, 0) = - (at(1, 0) * at(2, 2) - at(1, 2) * at(2, 0)) * idet;
+			output(1, 1) = (at(0, 0) * at(2, 2) - at(0, 2) * at(2, 0)) * idet;
+			output(1, 2) = - (at(0, 0) * at(1, 2) - at(0, 2) * at(1, 0)) * idet;
+
+			output(2, 0) = (at(1, 0) * at(2, 1) - at(1, 1) * at(2, 0)) * idet;
+			output(2, 1) = - (at(0, 0) * at(2, 1) - at(0, 1) * at(2, 0)) * idet;
+			output(2, 2) = (at(0, 0) * at(1, 1) - at(0, 1) * at(1, 0)) * idet;
+		} else
+			return false;
 	}
 
-protected:
-	double *buffer_;
-	int rows_, cols_, offset_;
-};
+	return true;
+}
 
+CUDAH Matrix Matrix::col(int index) {
+	return Matrix(rows_, 1, offset_ * cols_, buffer_ + index * offset_);
 }
 
-#endif
+CUDAH Matrix Matrix::row(int index) {
+	return Matrix(1, cols_, offset_, buffer_ + index * cols_ * offset_);
+}
 
+}
 
+#endif
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\MatrixDevice.h" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\MatrixDevice.h" added_lines="46" deleted_lines="26">
				<diff>@@ -6,38 +6,19 @@
 namespace gpu {
 class MatrixDevice : public Matrix {
 public:
-	CUDAH MatrixDevice() {
-		rows_ = cols_ = offset_ = 0;
-		buffer_ = NULL;
-		fr_ = true;
-	}
+	CUDAH MatrixDevice();
 
 	MatrixDevice(int rows, int cols);
 
-	CUDAH MatrixDevice(int rows, int cols, int offset, double *buffer) {
-		rows_ = rows;
-		cols_ = cols;
-		offset_ = offset;
-		buffer_ = buffer;
-		fr_ = false;
-	}
+	CUDAH MatrixDevice(int rows, int cols, int offset, double *buffer);
 
-	CUDAH bool isEmpty() {
-		return (rows_ == 0 &amp;&amp; cols_ == 0);
-	}
+	CUDAH bool isEmpty();
 
-	CUDAH MatrixDevice col(int index) {
-		return MatrixDevice(rows_, 1, offset_ * cols_, buffer_ + index * offset_);
-	}
+	CUDAH MatrixDevice col(int index);
 
-	CUDAH MatrixDevice row(int index) {
-		return MatrixDevice(1, cols_, offset_, buffer_ + index * cols_ * offset_);
-	}
-
-	CUDAH void setBuffer(double *buffer) {
-		buffer_ = buffer;
-	}
+	CUDAH MatrixDevice row(int index);
 
+	CUDAH void setBuffer(double *buffer);
 
 	void memFree();
 
@@ -45,10 +26,49 @@ private:
 	bool fr_;
 };
 
+CUDAH MatrixDevice::MatrixDevice()
+{
+	rows_ = cols_ = offset_ = 0;
+	buffer_ = NULL;
+	fr_ = true;
+}
+
+CUDAH MatrixDevice::MatrixDevice(int rows, int cols, int offset, double *buffer)
+{
+	rows_ = rows;
+	cols_ = cols;
+	offset_ = offset;
+	buffer_ = buffer;
+	fr_ = false;
+}
+
+CUDAH bool MatrixDevice::isEmpty()
+{
+	return (rows_ == 0 &amp;&amp; cols_ == 0);
+}
+
+CUDAH MatrixDevice MatrixDevice::col(int index)
+{
+	return MatrixDevice(rows_, 1, offset_ * cols_, buffer_ + index * offset_);
+}
+
+CUDAH MatrixDevice MatrixDevice::row(int index)
+{
+	return MatrixDevice(1, cols_, offset_, buffer_ + index * cols_ * offset_);
+}
+
+CUDAH void MatrixDevice::setBuffer(double *buffer)
+{
+	buffer_ = buffer;
+}
+
+
+
 class SquareMatrixDevice : public MatrixDevice {
 public:
-	SquareMatrixDevice(int size) : MatrixDevice(size, size) {};
+	SquareMatrixDevice(int size);
 };
+
 }
 
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\MatrixHost.h" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\MatrixHost.h" added_lines="3" deleted_lines="11">
				<diff>@@ -7,19 +7,11 @@
 namespace gpu {
 class MatrixHost : public Matrix {
 public:
-	MatrixHost() : Matrix() { fr_ = false; }
+	MatrixHost();
 	MatrixHost(int rows, int cols);
+	MatrixHost(int rows, int cols, int offset, double *buffer);
 	MatrixHost(const MatrixHost&amp; other);
 
-
-	MatrixHost(int rows, int cols, int offset, double *buffer) {
-		rows_ = rows;
-		cols_ = cols;
-		offset_ = offset;
-		buffer_ = buffer;
-		fr_ = false;
-	}
-
 	bool moveToGpu(MatrixDevice output);
 	bool moveToHost(MatrixDevice input);
 
@@ -34,7 +26,7 @@ private:
 
 class SquareMatrixHost: public MatrixHost {
 public:
-	SquareMatrixHost(int size) : MatrixHost(size, size) {};
+	SquareMatrixHost(int size);
 };
 
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\NormalDistributionsTransform.h" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\NormalDistributionsTransform.h" added_lines="21" deleted_lines="107">
				<diff>@@ -13,102 +13,23 @@ class GNormalDistributionsTransform: public GRegistration {
 public:
 	GNormalDistributionsTransform();
 
-	GNormalDistributionsTransform(const GNormalDistributionsTransform &amp;other)
-	{
-		gauss_d1_ = other.gauss_d1_;
-		gauss_d2_ = other.gauss_d2_;
-
-		outlier_ratio_ = other.outlier_ratio_;
-
-		j_ang_a_ = other.j_ang_a_;
-		j_ang_b_ = other.j_ang_b_;
-		j_ang_c_ = other.j_ang_c_;
-		j_ang_d_ = other.j_ang_d_;
-		j_ang_e_ = other.j_ang_e_;
-		j_ang_f_ = other.j_ang_f_;
-		j_ang_g_ = other.j_ang_g_;
-		j_ang_h_ = other.j_ang_h_;
-
-		h_ang_a2_ = other.h_ang_a2_;
-		h_ang_a3_ = other.h_ang_a3_;
-		h_ang_b2_ = other.h_ang_b2_;
-		h_ang_b3_ = other.h_ang_b3_;
-		h_ang_c2_ = other.h_ang_c2_;
-		h_ang_c3_ = other.h_ang_c3_;
-		h_ang_d1_ = other.h_ang_d2_;
-		h_ang_d2_ = other.h_ang_d2_;
-		h_ang_d3_ = other.h_ang_d3_;
-		h_ang_e1_ = other.h_ang_e1_;
-		h_ang_e2_ = other.h_ang_e2_;
-		h_ang_f1_ = other.h_ang_f1_;
-		h_ang_f2_ = other.h_ang_f2_;
-		h_ang_f3_ = other.h_ang_f3_;
-
-		dj_ang_a_ = other.dj_ang_a_;
-		dj_ang_b_ = other.dj_ang_b_;
-		dj_ang_c_ = other.dj_ang_c_;
-		dj_ang_e_ = other.dj_ang_e_;
-		dj_ang_f_ = other.dj_ang_f_;
-		dj_ang_g_ = other.dj_ang_g_;
-		dj_ang_h_ = other.dj_ang_h_;
-
-		dh_ang_a2_ = other.dh_ang_a2_;
-		dh_ang_a3_ = other.dh_ang_a3_;
-		dh_ang_b2_ = other.dh_ang_b2_;
-		dh_ang_b3_ = other.dh_ang_b3_;
-		dh_ang_c2_ = other.dh_ang_c2_;
-		dh_ang_c3_ = other.dh_ang_c3_;
-		dh_ang_d1_ = other.dh_ang_d2_;
-		dh_ang_d2_ = other.dh_ang_d2_;
-		dh_ang_d3_ = other.dh_ang_d3_;
-		dh_ang_e1_ = other.dh_ang_e1_;
-		dh_ang_e2_ = other.dh_ang_e2_;
-		dh_ang_f1_ = other.dh_ang_f1_;
-		dh_ang_f2_ = other.dh_ang_f2_;
-		dh_ang_f3_ = other.dh_ang_f3_;
-
-		step_size_ = other.step_size_;
-		resolution_ = other.resolution_;
-		trans_probability_ = other.trans_probability_;
-		real_iterations_ = other.real_iterations_;
-
-		voxel_grid_ = other.voxel_grid_;
-	}
-
-	inline void setStepSize(double step_size)
-	{
-		step_size_ = step_size;
-	}
-
-	inline void setResolution(float resolution)
-	{
-		resolution_ = resolution;
-	}
-
-	inline void setOutlierRatio(double olr)
-	{
-		outlier_ratio_ = olr;
-	}
-
-	inline double getStepSize()
-	{
-		return step_size_;
-	}
-
-	inline float getResolution()
-	{
-		return resolution_;
-	}
-
-	inline double getOutlierRatio()
-	{
-		return outlier_ratio_;
-	}
-
-	inline double getTransformationProbability()
-	{
-		return trans_probability_;
-	}
+	GNormalDistributionsTransform(const GNormalDistributionsTransform &amp;other);
+
+	void setStepSize(double step_size);
+
+	void setResolution(float resolution);
+
+	void setOutlierRatio(double olr);
+
+	double getStepSize() const;
+
+	float getResolution() const;
+
+	double getOutlierRatio() const;
+
+	double getTransformationProbability() const;
+
+	int getRealIterations();
 
 	/* Set the input map points */
 	void setInputTarget(pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr input);
@@ -117,27 +38,20 @@ public:
 	/* Compute and get fitness score */
 	double getFitnessScore(double max_range = DBL_MAX);
 
-	inline int getRealIterations() { return real_iterations_; }
-
 	~GNormalDistributionsTransform();
+
 protected:
-	void computeTransformation(Eigen::Matrix&lt;float, 4, 4&gt; &amp;guess);
+	void computeTransformation(const Eigen::Matrix&lt;float, 4, 4&gt; &amp;guess);
 	double computeDerivatives(Eigen::Matrix&lt;double, 6, 1&gt; &amp;score_gradient, Eigen::Matrix&lt;double, 6, 6&gt; &amp;hessian,
 								float *trans_x, float *trans_y, float *trans_z,
 								int points_num, Eigen::Matrix&lt;double, 6, 1&gt; pose, bool compute_hessian = true);
 
 private:
 	//Copied from ndt.h
-    inline double auxilaryFunction_PsiMT (double a, double f_a, double f_0, double g_0, double mu = 1.e-4)
-    {
-      return (f_a - f_0 - mu * g_0 * a);
-    }
+    double auxilaryFunction_PsiMT (double a, double f_a, double f_0, double g_0, double mu = 1.e-4);
 
     //Copied from ndt.h
-    inline double auxilaryFunction_dPsiMT (double g_a, double g_0, double mu = 1.e-4)
-    {
-      return (g_a - mu * g_0);
-    }
+    double auxilaryFunction_dPsiMT (double g_a, double g_0, double mu = 1.e-4);
 
     double updateIntervalMT (double &amp;a_l, double &amp;f_l, double &amp;g_l,
 								double &amp;a_u, double &amp;f_u, double &amp;g_u,
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\Registration.h" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\Registration.h" added_lines="11" deleted_lines="18">
				<diff>@@ -19,22 +19,17 @@ public:
 	GRegistration();
 	GRegistration(const GRegistration &amp;other);
 
-	void align(Eigen::Matrix&lt;float, 4, 4&gt; &amp;guess);
+	void align(const Eigen::Matrix&lt;float, 4, 4&gt; &amp;guess);
 
-	inline void setTransformationEpsilon(double trans_eps)
-	{
-		transformation_epsilon_ = trans_eps;
-	}
+	void setTransformationEpsilon(double trans_eps);
 
-	inline void setMaximumIterations(int max_itr)
-	{
-		max_iterations_ = max_itr;
-	}
+	double getTransformationEpsilon() const;
 
-	inline Eigen::Matrix&lt;float, 4, 4&gt; getFinalTransformation()
-	{
-		return final_transformation_;
-	}
+	void setMaximumIterations(int max_itr);
+
+	int getMaximumIterations() const;
+
+	Eigen::Matrix&lt;float, 4, 4&gt; getFinalTransformation() const;
 
 	/* Set input Scanned point cloud.
 	 * Copy input points from the main memory to the GPU memory */
@@ -46,16 +41,14 @@ public:
 	void setInputTarget(pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr input);
 	void setInputTarget(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr input);
 
-	inline int getFinalNumIteration() { return nr_iterations_; }
+	int getFinalNumIteration() const;
 
-	inline bool hasConverged() { return converged_; }
+	bool hasConverged() const;
 
 	virtual ~GRegistration();
 protected:
 
-	virtual void computeTransformation(Eigen::Matrix&lt;float, 4, 4&gt; &amp;guess) {
-		printf("Unsupported by Registration\n");
-	}
+	virtual void computeTransformation(const Eigen::Matrix&lt;float, 4, 4&gt; &amp;guess);
 
 	double transformation_epsilon_;
 	int max_iterations_;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\SymmetricEigenSolver.h" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\SymmetricEigenSolver.h" added_lines="34" deleted_lines="33">
				<diff>@@ -10,46 +10,19 @@ namespace gpu {
 
 class SymmetricEigensolver3x3 {
 public:
-	CUDAH SymmetricEigensolver3x3() {
-		buffer_ = NULL;
-		eigenvectors_ = NULL;
-		eigenvalues_ = NULL;
-		input_matrices_ = NULL;
-		maxAbsElement_ = NULL;
-		norm_ = NULL;
-		i02_ = NULL;
-		offset_ = 0;
-		is_copied_ = false;
-	}
+	CUDAH SymmetricEigensolver3x3();
 
 	SymmetricEigensolver3x3(int offset);
 
-	CUDAH SymmetricEigensolver3x3(const SymmetricEigensolver3x3&amp; other) {
-		buffer_ = other.buffer_;
-		offset_ = other.offset_;
-		eigenvectors_ = other.eigenvectors_;
-		eigenvalues_ = other.eigenvalues_;
-		input_matrices_ = other.input_matrices_;
-
-		maxAbsElement_ = other.maxAbsElement_;
-		norm_ = other.norm_;
-		i02_ = other.i02_;
-		is_copied_ = true;
-	}
+	CUDAH SymmetricEigensolver3x3(const SymmetricEigensolver3x3&amp; other);
 
-	void setInputMatrices(double *input_matrices) {
-		input_matrices_ = input_matrices;
-	}
+	void setInputMatrices(double *input_matrices);
 
-	void setEigenvectors(double *eigenvectors) {
-		eigenvectors_ = eigenvectors;
-	}
+	void setEigenvectors(double *eigenvectors);
 
-	void setEigenvalues(double *eigenvalues) {
-		eigenvalues_ = eigenvalues;
-	}
+	void setEigenvalues(double *eigenvalues);
 
-	double *getBuffer() { return buffer_; }
+	double *getBuffer() const;
 
 	/* Normalize input matrices by dividing each matrix
 	 * to the element that has the largest absolute value
@@ -114,6 +87,34 @@ private:
 	bool is_copied_;
 };
 
+
+CUDAH SymmetricEigensolver3x3::SymmetricEigensolver3x3()
+{
+		buffer_ = NULL;
+		eigenvectors_ = NULL;
+		eigenvalues_ = NULL;
+		input_matrices_ = NULL;
+		maxAbsElement_ = NULL;
+		norm_ = NULL;
+		i02_ = NULL;
+		offset_ = 0;
+		is_copied_ = false;
+}
+
+CUDAH SymmetricEigensolver3x3::SymmetricEigensolver3x3(const SymmetricEigensolver3x3&amp; other)
+{
+	buffer_ = other.buffer_;
+	offset_ = other.offset_;
+	eigenvectors_ = other.eigenvectors_;
+	eigenvalues_ = other.eigenvalues_;
+	input_matrices_ = other.input_matrices_;
+
+	maxAbsElement_ = other.maxAbsElement_;
+	norm_ = other.norm_;
+	i02_ = other.i02_;
+	is_copied_ = true;
+}
+
 CUDAH void SymmetricEigensolver3x3::normalizeInput(int tid)
 {
 	MatrixDevice input(3, 3, offset_, input_matrices_ + tid);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\VoxelGrid.h" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\VoxelGrid.h" added_lines="25" deleted_lines="60">
				<diff>@@ -13,38 +13,7 @@
 namespace gpu {
 class GVoxelGrid {
 public:
-	GVoxelGrid():
-		x_(NULL),
-		y_(NULL),
-		z_(NULL),
-		points_num_(0),
-		centroid_(NULL),
-		covariance_(NULL),
-		inverse_covariance_(NULL),
-		points_per_voxel_(NULL),
-		voxel_num_(0),
-		max_x_(FLT_MAX),
-		max_y_(FLT_MAX),
-		max_z_(FLT_MAX),
-		min_x_(FLT_MIN),
-		min_y_(FLT_MIN),
-		min_z_(FLT_MIN),
-		voxel_x_(0),
-		voxel_y_(0),
-		voxel_z_(0),
-		max_b_x_(0),
-		max_b_y_(0),
-		max_b_z_(0),
-		min_b_x_(0),
-		min_b_y_(0),
-		min_b_z_(0),
-		vgrid_x_(0),
-		vgrid_y_(0),
-		vgrid_z_(0),
-		min_points_per_voxel_(6),
-		starting_point_ids_(NULL),
-		point_ids_(NULL),
-		is_copied_(false) {};
+	GVoxelGrid();
 
 	GVoxelGrid(const GVoxelGrid &amp;other);
 
@@ -66,48 +35,44 @@ public:
 											int **valid_points, int **starting_voxel_id, int **voxel_id,
 											int *valid_voxel_num, int *valid_points_num);
 
-	int getVoxelNum() { return voxel_num_; }
+	int getVoxelNum() const;
 
-	float getMaxX() { return max_x_; }
-	float getMaxY() { return max_y_; }
-	float getMaxZ() { return max_z_; }
+	float getMaxX() const;
+	float getMaxY() const;
+	float getMaxZ() const;
 
-	float getMinX() { return min_x_; }
-	float getMinY() { return min_y_; }
-	float getMinZ() { return min_z_; }
+	float getMinX() const;
+	float getMinY() const;
+	float getMinZ() const;
 
-	float getVoxelX() { return voxel_x_; }
-	float getVoxelY() { return voxel_y_; }
-	float getVoxelZ() { return voxel_z_; }
+	float getVoxelX() const;
+	float getVoxelY() const;
+	float getVoxelZ() const;
 
-	int getMaxBX() { return max_b_x_; }
-	int getMaxBY() { return max_b_y_; }
-	int getMaxBZ() { return max_b_z_; }
+	int getMaxBX() const;
+	int getMaxBY() const;
+	int getMaxBZ() const;
 
-	int getMinBX() { return min_b_x_; }
-	int getMinBY() { return min_b_y_; }
-	int getMinBZ() { return min_b_z_; }
+	int getMinBX() const;
+	int getMinBY() const;
+	int getMinBZ() const;
 
-	int getVgridX() { return vgrid_x_; }
-	int getVgridY() { return vgrid_y_; }
-	int getVgridZ() { return vgrid_z_; }
+	int getVgridX() const;
+	int getVgridY() const;
+	int getVgridZ() const;
 
-	void setLeafSize(float voxel_x, float voxel_y, float voxel_z) {
-		voxel_x_ = voxel_x;
-		voxel_y_ = voxel_y;
-		voxel_z_ = voxel_z;
-	}
+	void setLeafSize(float voxel_x, float voxel_y, float voxel_z);
 
 	/* Get the centroid list. */
-	double *getCentroidList() { return centroid_; }
+	double *getCentroidList() const;
 
 	/* Get the covariance list. */
-	double *getCovarianceList() { return covariance_; }
+	double *getCovarianceList() const;
 
 	/* Get the pointer to the inverse covariances list. */
-	double *getInverseCovarianceList() { return inverse_covariance_; }
+	double *getInverseCovarianceList() const;
 
-	int *getPointsPerVoxelList() { return points_per_voxel_; }
+	int *getPointsPerVoxelList() const;
 
 	/* Searching for the nearest point of each input query point.
 	 * Coordinates of query points are input by trans_x, trans_y, and trans_z.
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\MatrixDevice.cu" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\MatrixDevice.cu" added_lines="6" deleted_lines="0">
				<diff>@@ -23,4 +23,10 @@ void MatrixDevice::memFree()
 }
 
 
+SquareMatrixDevice::SquareMatrixDevice(int size) :
+	MatrixDevice(size, size)
+{
+
+}
+
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\MatrixHost.cu" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\MatrixHost.cu" added_lines="22" deleted_lines="0">
				<diff>@@ -5,6 +5,12 @@
 #include &lt;stdlib.h&gt;
 
 namespace gpu {
+
+MatrixHost::MatrixHost()
+{
+	fr_ = false;
+}
+
 MatrixHost::MatrixHost(int rows, int cols) {
 	rows_ = rows;
 	cols_ = cols;
@@ -15,6 +21,15 @@ MatrixHost::MatrixHost(int rows, int cols) {
 	fr_ = true;
 }
 
+MatrixHost::MatrixHost(int rows, int cols, int offset, double *buffer)
+{
+	rows_ = rows;
+	cols_ = cols;
+	offset_ = offset;
+	buffer_ = buffer;
+	fr_ = false;
+}
+
 MatrixHost::MatrixHost(const MatrixHost&amp; other) {
 	rows_ = other.rows_;
 	cols_ = other.cols_;
@@ -131,4 +146,11 @@ MatrixHost::~MatrixHost()
 		free(buffer_);
 }
 
+
+SquareMatrixHost::SquareMatrixHost(int size) :
+	 MatrixHost(size, size)
+{
+
+}
+
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\NormalDistributionsTransform.cu" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\NormalDistributionsTransform.cu" added_lines="120" deleted_lines="5">
				<diff>@@ -10,7 +10,7 @@ namespace gpu {
 
 GNormalDistributionsTransform::GNormalDistributionsTransform()
 {
-	GRegistration::GRegistration();
+	//GRegistration::GRegistration();
 
 	gauss_d1_ = gauss_d2_ = 0;
 	outlier_ratio_ = 0.55;
@@ -83,8 +83,71 @@ GNormalDistributionsTransform::GNormalDistributionsTransform()
 	real_iterations_ = 0;
 }
 
+GNormalDistributionsTransform::GNormalDistributionsTransform(const GNormalDistributionsTransform &amp;other)
+{
+	gauss_d1_ = other.gauss_d1_;
+	gauss_d2_ = other.gauss_d2_;
+
+	outlier_ratio_ = other.outlier_ratio_;
+
+	j_ang_a_ = other.j_ang_a_;
+	j_ang_b_ = other.j_ang_b_;
+	j_ang_c_ = other.j_ang_c_;
+	j_ang_d_ = other.j_ang_d_;
+	j_ang_e_ = other.j_ang_e_;
+	j_ang_f_ = other.j_ang_f_;
+	j_ang_g_ = other.j_ang_g_;
+	j_ang_h_ = other.j_ang_h_;
+
+	h_ang_a2_ = other.h_ang_a2_;
+	h_ang_a3_ = other.h_ang_a3_;
+	h_ang_b2_ = other.h_ang_b2_;
+	h_ang_b3_ = other.h_ang_b3_;
+	h_ang_c2_ = other.h_ang_c2_;
+	h_ang_c3_ = other.h_ang_c3_;
+	h_ang_d1_ = other.h_ang_d2_;
+	h_ang_d2_ = other.h_ang_d2_;
+	h_ang_d3_ = other.h_ang_d3_;
+	h_ang_e1_ = other.h_ang_e1_;
+	h_ang_e2_ = other.h_ang_e2_;
+	h_ang_f1_ = other.h_ang_f1_;
+	h_ang_f2_ = other.h_ang_f2_;
+	h_ang_f3_ = other.h_ang_f3_;
+
+	dj_ang_a_ = other.dj_ang_a_;
+	dj_ang_b_ = other.dj_ang_b_;
+	dj_ang_c_ = other.dj_ang_c_;
+	dj_ang_e_ = other.dj_ang_e_;
+	dj_ang_f_ = other.dj_ang_f_;
+	dj_ang_g_ = other.dj_ang_g_;
+	dj_ang_h_ = other.dj_ang_h_;
+
+	dh_ang_a2_ = other.dh_ang_a2_;
+	dh_ang_a3_ = other.dh_ang_a3_;
+	dh_ang_b2_ = other.dh_ang_b2_;
+	dh_ang_b3_ = other.dh_ang_b3_;
+	dh_ang_c2_ = other.dh_ang_c2_;
+	dh_ang_c3_ = other.dh_ang_c3_;
+	dh_ang_d1_ = other.dh_ang_d2_;
+	dh_ang_d2_ = other.dh_ang_d2_;
+	dh_ang_d3_ = other.dh_ang_d3_;
+	dh_ang_e1_ = other.dh_ang_e1_;
+	dh_ang_e2_ = other.dh_ang_e2_;
+	dh_ang_f1_ = other.dh_ang_f1_;
+	dh_ang_f2_ = other.dh_ang_f2_;
+	dh_ang_f3_ = other.dh_ang_f3_;
+
+	step_size_ = other.step_size_;
+	resolution_ = other.resolution_;
+	trans_probability_ = other.trans_probability_;
+	real_iterations_ = other.real_iterations_;
+
+	voxel_grid_ = other.voxel_grid_;
+}
+
 GNormalDistributionsTransform::~GNormalDistributionsTransform()
 {
+	std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
 	dj_ang_a_.memFree();
 	dj_ang_b_.memFree();
 	dj_ang_c_.memFree();
@@ -110,9 +173,59 @@ GNormalDistributionsTransform::~GNormalDistributionsTransform()
 	dh_ang_f2_.memFree();
 	dh_ang_f3_.memFree();
 
-	voxel_grid_.~GVoxelGrid();
+	//voxel_grid_.~GVoxelGrid();
+	std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
+}
+
+void GNormalDistributionsTransform::setStepSize(double step_size)
+{
+	step_size_ = step_size;
+}
+
+void GNormalDistributionsTransform::setResolution(float resolution)
+{
+	resolution_ = resolution;
+}
+
+void GNormalDistributionsTransform::setOutlierRatio(double olr)
+{
+	outlier_ratio_ = olr;
+}
+
+double GNormalDistributionsTransform::getStepSize() const
+{
+	return step_size_;
+}
+
+float GNormalDistributionsTransform::getResolution() const
+{
+	return resolution_;
 }
 
+double GNormalDistributionsTransform::getOutlierRatio() const
+{
+	return outlier_ratio_;
+}
+
+double GNormalDistributionsTransform::getTransformationProbability() const
+{
+	return trans_probability_;
+}
+
+int GNormalDistributionsTransform::getRealIterations()
+{
+	 return real_iterations_;
+}
+
+double GNormalDistributionsTransform::auxilaryFunction_PsiMT(double a, double f_a, double f_0, double g_0, double mu)
+{
+  return (f_a - f_0 - mu * g_0 * a);
+}
+
+double GNormalDistributionsTransform::auxilaryFunction_dPsiMT(double g_a, double g_0, double mu)
+{
+  return (g_a - mu * g_0);
+}
 
 void GNormalDistributionsTransform::setInputTarget(pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr input)
 {
@@ -138,7 +251,7 @@ void GNormalDistributionsTransform::setInputTarget(pcl::PointCloud&lt;pcl::PointXYZ
 	}
 }
 
-void GNormalDistributionsTransform::computeTransformation(Eigen::Matrix&lt;float, 4, 4&gt; &amp;guess)
+void GNormalDistributionsTransform::computeTransformation(const Eigen::Matrix&lt;float, 4, 4&gt; &amp;guess)
 {
 	struct timeval start, end;
 
@@ -155,7 +268,7 @@ void GNormalDistributionsTransform::computeTransformation(Eigen::Matrix&lt;float, 4
 
 	if (guess != Eigen::Matrix4f::Identity()) {
 		final_transformation_ = guess;
-		
+
 		transformPointCloud(x_, y_, z_, trans_x_, trans_y_, trans_z_, points_number_, guess);
 	}
 
@@ -1794,7 +1907,9 @@ __global__ void gpuSum(T *input, int size, int half_size)
 	int stride = blockDim.x * gridDim.x;
 
 	for (int i = idx; i &lt; half_size; i += stride) {
-		input[i] += (half_size &lt; size) ? input[i + half_size] : 0;
+		if (i + half_size &lt; size) {
+			input[i] += (half_size &lt; size) ? input[i + half_size] : 0;
+		}
 	}
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\Registration.cu" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\Registration.cu" added_lines="46" deleted_lines="3">
				<diff>@@ -9,7 +9,7 @@ GRegistration::GRegistration()
 	max_iterations_ = 0;
 	x_ = y_ = z_ = NULL;
 	points_number_ = 0;
-		
+
 	trans_x_ = trans_y_ = trans_z_ = NULL;
 
 	converged_ = false;
@@ -21,6 +21,7 @@ GRegistration::GRegistration()
 
 	target_x_ = target_y_ = target_z_ = NULL;
 	is_copied_ = false;
+
 }
 
 GRegistration::GRegistration(const GRegistration &amp;other)
@@ -58,6 +59,8 @@ GRegistration::GRegistration(const GRegistration &amp;other)
 
 GRegistration::~GRegistration()
 {
+	std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
+
 	if (!is_copied_) {
 		if (x_ != NULL) {
 			checkCudaErrors(cudaFree(x_));
@@ -104,8 +107,46 @@ GRegistration::~GRegistration()
 			target_z_ = NULL;
 		}
 	}
+	std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
+
+}
+
+void GRegistration::setTransformationEpsilon(double trans_eps)
+{
+	transformation_epsilon_ = trans_eps;
+}
+
+double GRegistration::getTransformationEpsilon() const
+{
+	return transformation_epsilon_;
+}
+
+void GRegistration::setMaximumIterations(int max_itr)
+{
+	max_iterations_ = max_itr;
+}
+
+int GRegistration::getMaximumIterations() const
+{
+	return max_iterations_;
+}
+
+Eigen::Matrix&lt;float, 4, 4&gt; GRegistration::getFinalTransformation() const
+{
+	return final_transformation_;
+}
+
+int GRegistration::getFinalNumIteration() const
+{
+	return nr_iterations_;
+}
+
+bool GRegistration::hasConverged() const
+{
+	return converged_;
 }
 
+
 template &lt;typename T&gt;
 __global__ void convertInput(T *input, float *out_x, float *out_y, float *out_z, int point_num)
 {
@@ -361,7 +402,7 @@ void GRegistration::setInputTarget(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr input)
 	}
 }
 
-void GRegistration::align(Eigen::Matrix&lt;float, 4, 4&gt; &amp;guess)
+void GRegistration::align(const Eigen::Matrix&lt;float, 4, 4&gt; &amp;guess)
 {
 	converged_ = false;
 
@@ -370,6 +411,8 @@ void GRegistration::align(Eigen::Matrix&lt;float, 4, 4&gt; &amp;guess)
 	computeTransformation(guess);
 }
 
+void GRegistration::computeTransformation(const Eigen::Matrix&lt;float, 4, 4&gt; &amp;guess) {
+	printf("Unsupported by Registration\n");
 }
 
-
+}
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\SymmetricEigenSolver.cu" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\SymmetricEigenSolver.cu" added_lines="20" deleted_lines="0">
				<diff>@@ -19,6 +19,26 @@ SymmetricEigensolver3x3::SymmetricEigensolver3x3(int offset)
 	is_copied_ = false;
 }
 
+void SymmetricEigensolver3x3::setInputMatrices(double *input_matrices)
+{
+	input_matrices_ = input_matrices;
+}
+
+void SymmetricEigensolver3x3::setEigenvectors(double *eigenvectors)
+{
+	eigenvectors_ = eigenvectors;
+}
+
+void SymmetricEigensolver3x3::setEigenvalues(double *eigenvalues)
+{
+	eigenvalues_ = eigenvalues;
+}
+
+double* SymmetricEigensolver3x3::getBuffer() const
+{
+	return buffer_;
+}
+
 void SymmetricEigensolver3x3::memFree()
 {
 	if (!is_copied_) {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\VoxelGrid.cu" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\VoxelGrid.cu" added_lines="217" deleted_lines="12">
				<diff>@@ -20,6 +20,42 @@
 
 namespace gpu {
 
+GVoxelGrid::GVoxelGrid():
+	x_(NULL),
+	y_(NULL),
+	z_(NULL),
+	points_num_(0),
+	centroid_(NULL),
+	covariance_(NULL),
+	inverse_covariance_(NULL),
+	points_per_voxel_(NULL),
+	voxel_num_(0),
+	max_x_(FLT_MAX),
+	max_y_(FLT_MAX),
+	max_z_(FLT_MAX),
+	min_x_(FLT_MIN),
+	min_y_(FLT_MIN),
+	min_z_(FLT_MIN),
+	voxel_x_(0),
+	voxel_y_(0),
+	voxel_z_(0),
+	max_b_x_(0),
+	max_b_y_(0),
+	max_b_z_(0),
+	min_b_x_(0),
+	min_b_y_(0),
+	min_b_z_(0),
+	vgrid_x_(0),
+	vgrid_y_(0),
+	vgrid_z_(0),
+	min_points_per_voxel_(6),
+	starting_point_ids_(NULL),
+	point_ids_(NULL),
+	is_copied_(false)
+{
+
+};
+
 GVoxelGrid::GVoxelGrid(const GVoxelGrid &amp;other)
 {
 	x_ = other.x_;
@@ -69,11 +105,18 @@ GVoxelGrid::GVoxelGrid(const GVoxelGrid &amp;other)
 
 
 GVoxelGrid::~GVoxelGrid() {
+	std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
 	if (!is_copied_) {
 
 		for (unsigned int i = 1; i &lt; octree_centroids_.size(); i++) {
-			checkCudaErrors(cudaFree(octree_centroids_[i]));
-			checkCudaErrors(cudaFree(octree_points_per_node_[i]));
+			if (octree_centroids_[i] != NULL) {
+				checkCudaErrors(cudaFree(octree_centroids_[i]));
+				octree_centroids_[i] = NULL;
+			}
+			if (octree_points_per_node_[i] != NULL) {
+				checkCudaErrors(cudaFree(octree_points_per_node_[i]));
+				octree_points_per_node_[i] = NULL;
+			}
 		}
 
 		octree_centroids_.clear();
@@ -109,7 +152,24 @@ GVoxelGrid::~GVoxelGrid() {
 			checkCudaErrors(cudaFree(points_per_voxel_));
 			points_per_voxel_ = NULL;
 		}
+
+		if(x_ != NULL) {
+			checkCudaErrors(cudaFree(x_));
+			x_ = NULL;
+		}
+
+		if(y_ != NULL) {
+			checkCudaErrors(cudaFree(y_));
+			y_ = NULL;
+		}
+
+		if(z_ != NULL) {
+			checkCudaErrors(cudaFree(z_));
+			z_ = NULL;
+		}
 	}
+	std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
+
 }
 
 
@@ -145,6 +205,123 @@ void GVoxelGrid::initialize()
 	checkCudaErrors(cudaDeviceSynchronize());
 }
 
+int GVoxelGrid::getVoxelNum() const
+{
+	return voxel_num_;
+}
+
+
+float GVoxelGrid::getMaxX() const
+{
+	return max_x_;
+}
+float GVoxelGrid::getMaxY() const
+{
+	return max_y_;
+}
+float GVoxelGrid::getMaxZ() const
+{
+	return max_z_;
+}
+
+
+float GVoxelGrid::getMinX() const
+{
+	return min_x_;
+}
+float GVoxelGrid::getMinY() const
+{
+	return min_y_;
+}
+float GVoxelGrid::getMinZ() const
+{
+	return min_z_;
+}
+
+
+float GVoxelGrid::getVoxelX() const
+{
+	return voxel_x_;
+}
+float GVoxelGrid::getVoxelY() const
+{
+	return voxel_y_;
+}
+float GVoxelGrid::getVoxelZ() const
+{
+	return voxel_z_;
+}
+
+
+int GVoxelGrid::getMaxBX() const
+{
+	return max_b_x_;
+}
+int GVoxelGrid::getMaxBY() const
+{
+	return max_b_y_;
+}
+int GVoxelGrid::getMaxBZ() const
+{
+	return max_b_z_;
+}
+
+
+int GVoxelGrid::getMinBX() const
+{
+	return min_b_x_;
+}
+int GVoxelGrid::getMinBY() const
+{
+	return min_b_y_;
+}
+int GVoxelGrid::getMinBZ() const
+{
+	return min_b_z_;
+}
+
+
+int GVoxelGrid::getVgridX() const
+{
+	return vgrid_x_;
+}
+int GVoxelGrid::getVgridY() const
+{
+	return vgrid_y_;
+}
+int GVoxelGrid::getVgridZ() const
+{
+	return vgrid_z_;
+}
+
+
+void GVoxelGrid::setLeafSize(float voxel_x, float voxel_y, float voxel_z)
+{
+	voxel_x_ = voxel_x;
+	voxel_y_ = voxel_y;
+	voxel_z_ = voxel_z;
+}
+
+double* GVoxelGrid::getCentroidList() const
+{
+	return centroid_;
+}
+
+double* GVoxelGrid::getCovarianceList() const
+{
+	return covariance_;
+}
+
+double* GVoxelGrid::getInverseCovarianceList() const
+{
+	return inverse_covariance_;
+}
+
+int* GVoxelGrid::getPointsPerVoxelList() const
+{
+	return points_per_voxel_;
+}
+
 
 extern "C" __device__ int voxelId(float x, float y, float z,
 									float voxel_x, float voxel_y, float voxel_z,
@@ -911,7 +1088,6 @@ void GVoxelGrid::radiusSearch(float *qx, float *qy, float *qz, int points_num, f
 															candidate_voxel_num_per_point);
 	checkCudaErrors(cudaGetLastError());
 	checkCudaErrors(cudaDeviceSynchronize());
-
 	//Total candidate voxel num is determined by an exclusive scan on candidate_voxel_num_per_point
 	ExclusiveScan(candidate_voxel_num_per_point, points_num + 1, &amp;total_candidate_voxel_num);
 
@@ -979,13 +1155,16 @@ void GVoxelGrid::radiusSearch(float *qx, float *qy, float *qz, int points_num, f
 	int *valid_points_location;
 
 	checkCudaErrors(cudaMalloc(&amp;valid_points_location, sizeof(int) * (points_num + 1)));
+	checkCudaErrors(cudaMemset(valid_points_location, 0, sizeof(int) * (points_num + 1)));
 	checkCudaErrors(cudaMemcpy(valid_points_location, valid_points_mark, sizeof(int) * points_num, cudaMemcpyDeviceToDevice));
 
 	//Writing location to the output buffer is determined by an exclusive scan
 	ExclusiveScan(valid_points_location, points_num + 1, valid_points_num);
 
 	if (*valid_points_num &lt;= 0) {
-		std::cout &lt;&lt; "No valid point was found. Exiting..." &lt;&lt; std::endl;
+		//std::cout &lt;&lt; "No valid point was found. Exiting..." &lt;&lt; std::endl;
+		std::cout &lt;&lt; "No valid point was found. Exiting...: " &lt;&lt; *valid_points_num &lt;&lt; std::endl;
+
 		checkCudaErrors(cudaFree(max_vid_x));
 		checkCudaErrors(cudaFree(max_vid_y));
 		checkCudaErrors(cudaFree(max_vid_z));
@@ -1038,22 +1217,35 @@ void GVoxelGrid::radiusSearch(float *qx, float *qy, float *qz, int points_num, f
 
 	if (*valid_voxel_num &lt;= 0) {
 		checkCudaErrors(cudaFree(max_vid_x));
+		max_vid_x = NULL;
 		checkCudaErrors(cudaFree(max_vid_y));
+		max_vid_y = NULL;
 		checkCudaErrors(cudaFree(max_vid_z));
+		max_vid_z = NULL;
 
 		checkCudaErrors(cudaFree(min_vid_x));
+		min_vid_x = NULL;
 		checkCudaErrors(cudaFree(min_vid_y));
+		min_vid_y = NULL;
 		checkCudaErrors(cudaFree(min_vid_z));
+		min_vid_z = NULL;
 
 		checkCudaErrors(cudaFree(candidate_voxel_num_per_point));
+		candidate_voxel_num_per_point = NULL;
 		checkCudaErrors(cudaFree(candidate_voxel_id));
+		candidate_voxel_id = NULL;
 
 		checkCudaErrors(cudaFree(valid_voxel_mark));
+		valid_voxel_mark = NULL;
 		checkCudaErrors(cudaFree(valid_voxel_count));
+		valid_voxel_count = NULL;
 		checkCudaErrors(cudaFree(valid_points_mark));
+		valid_points_mark = NULL;
 
 		checkCudaErrors(cudaFree(valid_points_location));
+		valid_points_location = NULL;
 		checkCudaErrors(cudaFree(valid_voxel_location));
+		valid_voxel_location = NULL;
 
 		valid_points = NULL;
 		starting_voxel_id = NULL;
@@ -1142,7 +1334,7 @@ extern "C" __global__ void buildParent(double *child_centroids, int *points_per_
 
 /* Compute the number of points per voxel using atomicAdd */
 extern "C"  __global__ void insertPointsToGrid(float *x, float *y, float *z, int points_num,
-												int *points_per_voxel,
+												int *points_per_voxel, int voxel_num,
 												int vgrid_x, int vgrid_y, int vgrid_z,
 												float voxel_x, float voxel_y, float voxel_z,
 												int min_b_x, int min_b_y, int min_b_z)
@@ -1157,12 +1349,15 @@ extern "C"  __global__ void insertPointsToGrid(float *x, float *y, float *z, int
 		int voxel_id = voxelId(t_x, t_y, t_z, voxel_x, voxel_y, voxel_z, min_b_x, min_b_y, min_b_z, vgrid_x, vgrid_y, vgrid_z);
 
 		// Update number of points in the voxel
-		atomicAdd(points_per_voxel + voxel_id, 1);
+		int ptr_increment = (voxel_id &lt; voxel_num) * voxel_id; // if (voxel_id &lt; voxel_num), then use voxel_id
+		int incremental_value = (voxel_id &lt; voxel_num);
+		//atomicAdd(points_per_voxel + voxel_id, 1);
+		atomicAdd(points_per_voxel + ptr_increment, incremental_value);
 	}
 }
 
 /* Rearrange points to locations corresponding to voxels */
-extern "C" __global__ void scatterPointsToVoxels(float *x, float *y, float *z, int points_num,
+extern "C" __global__ void scatterPointsToVoxels(float *x, float *y, float *z, int points_num, int voxel_num,
 													float voxel_x, float voxel_y, float voxel_z,
 													int min_b_x, int min_b_y, int min_b_z,
 													int vgrid_x, int vgrid_y, int vgrid_z,
@@ -1174,7 +1369,11 @@ extern "C" __global__ void scatterPointsToVoxels(float *x, float *y, float *z, i
 	for (int i = idx; i &lt; points_num; i += stride) {
 		int voxel_id = voxelId(x[i], y[i], z[i], voxel_x, voxel_y, voxel_z,
 								min_b_x, min_b_y, min_b_z, vgrid_x, vgrid_y, vgrid_z);
-		int loc = atomicAdd(writing_locations + voxel_id, 1);
+
+		int ptr_increment = (voxel_id &lt; voxel_num) * voxel_id;
+		int incremental_value = (voxel_id &lt; voxel_num);
+		//int loc = atomicAdd(writing_locations + voxel_id, 1);
+		int loc =  atomicAdd(writing_locations + ptr_increment, incremental_value);
 
 		point_ids[loc] = i;
 	}
@@ -1195,7 +1394,7 @@ void GVoxelGrid::scatterPointsToVoxelGrid()
 	int block_x = (points_num_ &gt; BLOCK_SIZE_X) ? BLOCK_SIZE_X : points_num_;
 	int grid_x = (points_num_ - 1) / block_x + 1;
 
-	insertPointsToGrid&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_num_, points_per_voxel_,
+	insertPointsToGrid&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_num_, points_per_voxel_, voxel_num_,
 												vgrid_x_, vgrid_y_, vgrid_z_,
 												voxel_x_, voxel_y_, voxel_z_,
 												min_b_x_, min_b_y_, min_b_z_);
@@ -1216,7 +1415,7 @@ void GVoxelGrid::scatterPointsToVoxelGrid()
 
 	checkCudaErrors(cudaMalloc(&amp;point_ids_, sizeof(int) * points_num_));
 
-	scatterPointsToVoxels&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_num_,
+	scatterPointsToVoxels&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_num_, voxel_num_,
 												voxel_x_, voxel_y_, voxel_z_,
 												min_b_x_, min_b_y_, min_b_z_,
 												vgrid_x_, vgrid_y_, vgrid_z_,
@@ -1230,8 +1429,14 @@ void GVoxelGrid::scatterPointsToVoxelGrid()
 void GVoxelGrid::buildOctree()
 {
 	for (unsigned int i = 1; i &lt; octree_centroids_.size(); i++) {
-		checkCudaErrors(cudaFree(octree_centroids_[i]));
-		checkCudaErrors(cudaFree(octree_points_per_node_[i]));
+		if (octree_centroids_[i] != NULL) {
+			checkCudaErrors(cudaFree(octree_centroids_[i]));
+			octree_centroids_[i] = NULL;
+		}
+		if (octree_points_per_node_[i] != NULL) {
+			checkCudaErrors(cudaFree(octree_points_per_node_[i]));
+			octree_points_per_node_[i] = NULL;
+		}
 	}
 
 	octree_centroids_.clear();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="69f3c6294eaa9c70c95360f718965fea160cb4dd" author="TomohitoAndo">
		<msg>Fix publishing msg type</msg>
		<modified_files>
			<file old_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface.cpp" new_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -60,7 +60,7 @@ void PacmodInterface::initForROS()
 
   // setup publisher
   steer_mode_pub_    = nh_.advertise&lt;module_comm_msgs::SteerMode&gt;("/as/arbitrated_steering_commands", 10);
-  speed_mode_pub_    = nh_.advertise&lt;module_comm_msgs::SteerMode&gt;("/as/arbitrated_speed_commands", 10);
+  speed_mode_pub_    = nh_.advertise&lt;module_comm_msgs::SpeedMode&gt;("/as/arbitrated_speed_commands", 10);
   current_twist_pub_ = nh_.advertise&lt;geometry_msgs::TwistStamped&gt;("as_current_twist", 10);
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ddaa32086633ef495a6e9ecad10db0ecb23e4d88" author="TomohitoAndo">
		<msg>Change 2015 to 2017</msg>
		<modified_files>
			<file old_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface.cpp" new_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface.cpp" added_lines="1" deleted_lines="2">
				<diff>@@ -1,6 +1,5 @@
 /*
- *  Copyright (c) 2015, Nagoya University
-
+ *  Copyright (c) 2017, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
</diff>
			</file>
			<file old_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface.h" new_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface.h" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2015, Nagoya University
+ *  Copyright (c) 2017, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
</diff>
			</file>
			<file old_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface_node.cpp" new_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface_node.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2015, Nagoya University
+ *  Copyright (c) 2017, Nagoya University
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ed4537e8a7032f8fa5c4e474cb5deb602a574f8c" author="Yamato ANDO">
		<msg>fix memory error</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\NormalDistributionsTransform.cu" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\NormalDistributionsTransform.cu" added_lines="1" deleted_lines="3">
				<diff>@@ -147,7 +147,6 @@ GNormalDistributionsTransform::GNormalDistributionsTransform(const GNormalDistri
 
 GNormalDistributionsTransform::~GNormalDistributionsTransform()
 {
-	std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
 	dj_ang_a_.memFree();
 	dj_ang_b_.memFree();
 	dj_ang_c_.memFree();
@@ -174,7 +173,6 @@ GNormalDistributionsTransform::~GNormalDistributionsTransform()
 	dh_ang_f3_.memFree();
 
 	//voxel_grid_.~GVoxelGrid();
-	std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
 }
 
 void GNormalDistributionsTransform::setStepSize(double step_size)
@@ -1372,7 +1370,7 @@ void GNormalDistributionsTransform::computeAngleDerivatives(MatrixHost pose, boo
 
 		h_ang_e1_(0) = sy * sz;
 		h_ang_e1_(1) = sy * cz;
-		h_ang_e1_(3) = 0;
+		h_ang_e1_(2) = 0;
 
 		h_ang_e2_(0) = -sx * cy * sz;
 		h_ang_e2_(1) = -sx * cy * cz;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\Registration.cu" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\Registration.cu" added_lines="1" deleted_lines="5">
				<diff>@@ -59,8 +59,6 @@ GRegistration::GRegistration(const GRegistration &amp;other)
 
 GRegistration::~GRegistration()
 {
-	std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
-
 	if (!is_copied_) {
 		if (x_ != NULL) {
 			checkCudaErrors(cudaFree(x_));
@@ -93,7 +91,7 @@ GRegistration::~GRegistration()
 		}
 
 		if (target_x_ != NULL) {
-			checkCudaErrors(cudaFree(target_x_));
+				checkCudaErrors(cudaFree(target_x_));
 			target_x_ = NULL;
 		}
 
@@ -107,8 +105,6 @@ GRegistration::~GRegistration()
 			target_z_ = NULL;
 		}
 	}
-	std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
-
 }
 
 void GRegistration::setTransformationEpsilon(double trans_eps)
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\VoxelGrid.cu" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\VoxelGrid.cu" added_lines="0" deleted_lines="18">
				<diff>@@ -105,7 +105,6 @@ GVoxelGrid::GVoxelGrid(const GVoxelGrid &amp;other)
 
 
 GVoxelGrid::~GVoxelGrid() {
-	std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
 	if (!is_copied_) {
 
 		for (unsigned int i = 1; i &lt; octree_centroids_.size(); i++) {
@@ -152,24 +151,7 @@ GVoxelGrid::~GVoxelGrid() {
 			checkCudaErrors(cudaFree(points_per_voxel_));
 			points_per_voxel_ = NULL;
 		}
-
-		if(x_ != NULL) {
-			checkCudaErrors(cudaFree(x_));
-			x_ = NULL;
-		}
-
-		if(y_ != NULL) {
-			checkCudaErrors(cudaFree(y_));
-			y_ = NULL;
-		}
-
-		if(z_ != NULL) {
-			checkCudaErrors(cudaFree(z_));
-			z_ = NULL;
-		}
 	}
-	std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
-
 }
 
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e5d6b0d409c2019c3b77969a5dc1ec4d55e8870e" author="TomohitoAndo">
		<msg>Use correct callback function</msg>
		<modified_files>
			<file old_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface.cpp" new_path="ros\src\actuation\vehicles\packages\as\nodes\pacmod_interface\pacmod_interface.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -55,7 +55,7 @@ void PacmodInterface::initForROS()
   // setup subscriber
   twist_cmd_sub_    = nh_.subscribe("twist_cmd", 10, &amp;PacmodInterface::callbackFromTwistCmd, this);
   control_mode_sub_ = nh_.subscribe("/as/control_mode", 10, &amp;PacmodInterface::callbackFromControlMode, this);
-  speed_sub_        = nh_.subscribe("/vehicle/steering_report", 10, &amp;PacmodInterface::callbackFromTwistCmd, this);
+  speed_sub_        = nh_.subscribe("/vehicle/steering_report", 10, &amp;PacmodInterface::callbackFromSteeringReport, this);
 
   // setup publisher
   steer_mode_pub_    = nh_.advertise&lt;module_comm_msgs::SteerMode&gt;("/as/arbitrated_steering_commands", 10);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="815a5c09e698ea0fc63d1430679aa38f50abf36e" author="Yuki Iida">
		<msg>refactor layout</msg>
		<modified_files>
			<file old_path="ui\web\remote_monitor\public\css\bar.css" new_path="ui\web\remote_monitor\public\css\bar.css" added_lines="3" deleted_lines="3">
				<diff>@@ -32,12 +32,12 @@ progress[value]::-webkit-progress-value {
   background: #fff;
 }
 .seekbar .fill {
-  height: 10px;
+  height: 30px;
   border-radius: 10px;
 }
 .seekbar .handle {
-  width: 15px;
-  height: 15px;
+  width: 2%;
+  height: 0.4vw;
   background: #00a3e0;
   border-radius: 10px;
   transform: scale(2);
</diff>
			</file>
			<file old_path="ui\web\remote_monitor\public\css\button.css" new_path="ui\web\remote_monitor\public\css\button.css" added_lines="1" deleted_lines="1">
				<diff>@@ -252,7 +252,7 @@ select::-ms-expand {
   border-radius: 25px;
   margin: 0 auto;
   display: block;
-  padding: 8px 0 8px 19px;
+  padding: 2px 0 2px 15px;
   letter-spacing: 2em;
   border: 1px solid #db1f46;
   color: #fff;
</diff>
			</file>
			<file old_path="ui\web\remote_monitor\public\css\main.css" new_path="ui\web\remote_monitor\public\css\main.css" added_lines="10" deleted_lines="3">
				<diff>@@ -45,14 +45,14 @@ header {
 }
 
 .row-top {
-  height: 25%;
+  height: 34%;
 }
 
 .row-center {
-  height: 48%;
+  height: 34%;
 }
 .row-bottom {
-  height: 22%;
+  height: 23%;
 }
 
 img#vehicle_steering {
@@ -264,3 +264,10 @@ video {
 *[aria-hidden="true"] {
   display: none;
 }
+
+/* CUSTOM */
+h4.operator {
+  font-size: 85%;
+  margin-top: 0;
+  margin-bottom: 2px;
+}
</diff>
			</file>
			<file old_path="ui\web\remote_monitor\public\css\speed_meters.css" new_path="ui\web\remote_monitor\public\css\speed_meters.css" added_lines="2" deleted_lines="2">
				<diff>@@ -209,9 +209,9 @@ $grad-color: #9affff;
   bottom: -14%;
 }
 .meter--gear div {
-  font-size: 2.5rem;
+  font-size: 2rem;
   text-align: center;
-  line-height: 7.5rem;
+  line-height: 4rem;
   font-family: 'Roboto Mono', monospace;
   font-style: italic;
   font-weight: bold;
</diff>
			</file>
			<file old_path="ui\web\remote_monitor\template\operator_window.html" new_path="ui\web\remote_monitor\template\operator_window.html" added_lines="22" deleted_lines="21">
				<diff>@@ -65,8 +65,8 @@
   &lt;div class="container" id="container"&gt;
     &lt;!-- First row --&gt;
     &lt;div class="row row-eq-height row-top"&gt;
-      &lt;div class="col-lg-2 col-md-2 col-sm-2 col-xs-2"&gt;
-        &lt;div align="left" style="margin-left: 10px"&gt;
+      &lt;div class="col-lg-3 col-md-3 col-sm-3 col-xs-3"&gt;
+        &lt;div align="left" style="margin-left: 5px"&gt;
           &lt;h2&gt;&lt;u&gt;Vehicle Info&lt;/u&gt;&lt;h2&gt;
           &lt;h3 id="text_speed"&gt;Speed: - km/h&lt;/h3&gt;
           &lt;h3 id="text_target_speed"&gt;Target Speed: - km/h&lt;/h3&gt;
@@ -75,13 +75,13 @@
         &lt;/div&gt;
       &lt;/div&gt;
 
-      &lt;div class="col-lg-6 col-md-6 col-sm-6 col-xs-6"&gt;
+      &lt;div class="col-lg-4 col-md-4 col-sm-4 col-xs-4"&gt;
         &lt;div class="streamItemContainer"&gt;
           &lt;video id="remoteView2"&gt;&lt;/video&gt;
         &lt;/div&gt;
       &lt;/div&gt;
 
-      &lt;div class="col-lg-2 col-md-2 col-sm-2 col-xs-2"&gt;
+      &lt;div class="col-lg-3 col-md-3 col-sm-3 col-xs-3"&gt;
         &lt;div class="streamItemContainer"&gt;
           &lt;video id="remoteView5"&gt;&lt;/video&gt;
         &lt;/div&gt;
@@ -96,19 +96,19 @@
 
     &lt;!-- UI Second row --&gt;
     &lt;div class="row row-eq-height row-center"&gt;
-      &lt;div class="col-lg-2 col-md-2 col-sm-2 col-xs-2"&gt;
+      &lt;div class="col-lg-3 col-md-3 col-sm-3 col-xs-3"&gt;
         &lt;div class="streamItemContainer"&gt;
           &lt;video id="remoteView3"&gt;&lt;/video&gt;
         &lt;/div&gt;
       &lt;/div&gt;
 
-      &lt;div class="col-lg-6 col-md-6 col-sm-6 col-xs-6"&gt;
+      &lt;div class="col-lg-4 col-md-4 col-sm-4 col-xs-4"&gt;
         &lt;div class="streamItemContainer"&gt;
           &lt;video id="remoteView1"&gt;&lt;/video&gt;
         &lt;/div&gt;
       &lt;/div&gt;
 
-      &lt;div class="col-lg-2 col-md-2 col-sm-2 col-xs-2"&gt;
+      &lt;div class="col-lg-3 col-md-3 col-sm-3 col-xs-3"&gt;
         &lt;div class="streamItemContainer"&gt;
           &lt;video id="remoteView4"&gt;&lt;/video&gt;
         &lt;/div&gt;
@@ -142,32 +142,33 @@
 
       &lt;div class="col-lg-3 col-md-3 col-sm-3 col-xs-3"&gt;
         &lt;div align="left" style="margin-left: 10px"&gt;
-          &lt;h4&gt;Accel&lt;/h4&gt;
-          &lt;progress id="accel_bar" value="0" max="100"&gt;&lt;/progress&gt;
-          &lt;h4&gt;Brake&lt;/h4&gt;
-          &lt;progress id="brake_bar" value="0" max="100"&gt;&lt;/progress&gt;
-          &lt;h4&gt;Vehicle Steer&lt;/h4&gt;
+          &lt;h4 class="operator"&gt;Accel&lt;/h4&gt;
+          &lt;progress class="operator" id="accel_bar" value="0" max="100"&gt;&lt;/progress&gt;
+          &lt;h4 class="operator"&gt;Brake&lt;/h4&gt;
+          &lt;progress class="operator" id="brake_bar" value="0" max="100"&gt;&lt;/progress&gt;
+          &lt;h4 class="operator"&gt;Vehicle Steer&lt;/h4&gt;
           &lt;div class="seekbar"&gt;
             &lt;div class="fill"&gt;&lt;/div&gt;
             &lt;div class="handle"&gt;&lt;/div&gt;
           &lt;/div&gt;
-          &lt;h4&gt;Controller Accel&lt;/h4&gt;
-          &lt;progress id="controller_accel_bar" value="0" max="100"&gt;&lt;/progress&gt;
-          &lt;h4&gt;Controller Brake&lt;/h4&gt;
-          &lt;progress id="controller_brake_bar" value="0" max="100"&gt;&lt;/progress&gt;
-          &lt;h4&gt;Controller Steer&lt;/h4&gt;
+          &lt;h4 class="operator"&gt;Controller Accel&lt;/h4&gt;
+          &lt;progress class="operator" id="controller_accel_bar" value="0" max="100"&gt;&lt;/progress&gt;
+          &lt;h4 class="operator"&gt;Controller Brake&lt;/h4&gt;
+          &lt;progress class="operator" id="controller_brake_bar" value="0" max="100"&gt;&lt;/progress&gt;
+          &lt;h4 class="operator"&gt;Controller Steer&lt;/h4&gt;
           &lt;div class="seekbar"&gt;
             &lt;div class="cfill"&gt;&lt;/div&gt;
             &lt;div class="handle"&gt;&lt;/div&gt;
           &lt;/div&gt;
 
           &lt;div class="select-wrap select-circle"&gt;
-            &lt;h4&gt;Gear&lt;/h4&gt;
+            &lt;h4 class="operator"&gt;Gear&lt;/h4&gt;
             &lt;select name="gear" id="gear" onChange="select_gear(this);"&gt;
               &lt;option value="0"&gt;P&lt;/option&gt;
-              &lt;option value="1"&gt;N&lt;/option&gt;
-              &lt;option value="2"&gt;D&lt;/option&gt;
-              &lt;option value="3"&gt;R&lt;/option&gt;
+              &lt;option value="1"&gt;D&lt;/option&gt;
+              &lt;option value="2"&gt;R&lt;/option&gt;
+              &lt;option value="3"&gt;N&lt;/option&gt;
+              &lt;option value="3"&gt;B&lt;/option&gt;
             &lt;/select&gt;
           &lt;/div&gt;
         &lt;/div&gt;
</diff>
			</file>
			<file old_path="ui\web\remote_monitor\template\vehicle_window.html" new_path="ui\web\remote_monitor\template\vehicle_window.html" added_lines="7" deleted_lines="7">
				<diff>@@ -64,8 +64,8 @@
   &lt;div class="container" id="container"&gt;
     &lt;!-- First row --&gt;
     &lt;div class="row row-eq-height row-top"&gt;
-      &lt;div class="col-lg-2 col-md-2 col-sm-2 col-xs-2"&gt;
-        &lt;div align="left" style="margin-left: 10px"&gt;
+      &lt;div class="col-lg-3 col-md-3 col-sm-3 col-xs-3"&gt;
+        &lt;div align="left" style="margin-left: 5px"&gt;
           &lt;h2&gt;&lt;u&gt;Vehicle Info&lt;/u&gt;&lt;h2&gt;
           &lt;h3 id="text_speed"&gt;Speed: - km/h&lt;/h3&gt;
           &lt;h3 id="text_target_speed"&gt;Target Speed: - km/h&lt;/h3&gt;
@@ -74,7 +74,7 @@
         &lt;/div&gt;
       &lt;/div&gt;
 
-      &lt;div class="col-lg-6 col-md-6 col-sm-6 col-xs-6"&gt;
+      &lt;div class="col-lg-4 col-md-4 col-sm-4 col-xs-4"&gt;
         &lt;div class="streamItemContainer"&gt;
           &lt;span class="btnRemoveStream glyphicon glyphicon-remove" style="display:none" id="btnRemoveStream2" data-no="2" title="DELETE"&gt;&lt;/span&gt;&lt;br /&gt;
           &lt;button class="btnAddStream" id="btnAddStream2" data-no="2"&gt;
@@ -85,7 +85,7 @@
         &lt;/div&gt;
       &lt;/div&gt;
 
-      &lt;div class="col-lg-2 col-md-2 col-sm-2 col-xs-2"&gt;
+      &lt;div class="col-lg-3 col-md-3 col-sm-3 col-xs-3"&gt;
         &lt;div class="streamItemContainer"&gt;
           &lt;span class="btnRemoveStream glyphicon glyphicon-remove" style="display:none" id="btnRemoveStream5" data-no="5" title="DELETE"&gt;&lt;/span&gt;&lt;br /&gt;
           &lt;button class="btnAddStream" id="btnAddStream5" data-no="5"&gt;
@@ -111,7 +111,7 @@
 
     &lt;!-- UI Second row --&gt;
     &lt;div class="row row-eq-height row-center"&gt;
-      &lt;div class="col-lg-2 col-md-2 col-sm-2 col-xs-2"&gt;
+      &lt;div class="col-lg-3 col-md-3 col-sm-3 col-xs-3"&gt;
         &lt;div class="streamItemContainer"&gt;
           &lt;span class="btnRemoveStream glyphicon glyphicon-remove" style="display:none" id="btnRemoveStream3" data-no="3" title="DELETE"&gt;&lt;/span&gt;&lt;br /&gt;
           &lt;button class="btnAddStream" id="btnAddStream3" data-no="3"&gt;
@@ -122,7 +122,7 @@
         &lt;/div&gt;
       &lt;/div&gt;
 
-      &lt;div class="col-lg-6 col-md-6 col-sm-6 col-xs-6"&gt;
+      &lt;div class="col-lg-4 col-md-4 col-sm-4 col-xs-4"&gt;
         &lt;div class="streamItemContainer"&gt;
           &lt;span class="btnRemoveStream glyphicon glyphicon-remove" style="display:none" id="btnRemoveStream1" data-no="1" title="DELETE"&gt;&lt;/span&gt;&lt;br /&gt;
           &lt;button class="btnAddStream" id="btnAddStream1" data-no="1"&gt;
@@ -133,7 +133,7 @@
         &lt;/div&gt;
       &lt;/div&gt;
 
-      &lt;div class="col-lg-2 col-md-2 col-sm-2 col-xs-2"&gt;
+      &lt;div class="col-lg-3 col-md-3 col-sm-3 col-xs-3"&gt;
         &lt;div class="streamItemContainer"&gt;
           &lt;span class="btnRemoveStream glyphicon glyphicon-remove" style="display:none" id="btnRemoveStream4" data-no="4" title="DELETE"&gt;&lt;/span&gt;&lt;br /&gt;
           &lt;button class="btnAddStream" id="btnAddStream4" data-no="4"&gt;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f00f48dfef9cd4fc0c88a03a771394e40c0032dc" author="yukikitsukawa">
		<msg>apply clang-format</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="113" deleted_lines="118">
				<diff>@@ -36,17 +36,17 @@
 
 #define OUTPUT  // If you want to output "position_log.txt", "#define OUTPUT".
 
+#include &lt;fstream&gt;
 #include &lt;iostream&gt;
 #include &lt;sstream&gt;
-#include &lt;fstream&gt;
 #include &lt;string&gt;
 
-#include &lt;ros/ros.h&gt;
-#include &lt;std_msgs/Bool.h&gt;
-#include &lt;std_msgs/Float32.h&gt;
 #include &lt;nav_msgs/Odometry.h&gt;
+#include &lt;ros/ros.h&gt;
 #include &lt;sensor_msgs/Imu.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
+#include &lt;std_msgs/Bool.h&gt;
+#include &lt;std_msgs/Float32.h&gt;
 #include &lt;velodyne_pointcloud/point_types.h&gt;
 #include &lt;velodyne_pointcloud/rawdata.h&gt;
 
@@ -58,15 +58,15 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 
-#if defined (USE_FAST_PCL) &amp;&amp; defined (CUDA_FOUND)
+#if defined(USE_FAST_PCL) &amp;&amp; defined(CUDA_FOUND)
+#include &lt;fast_pcl/filters/voxel_grid.h&gt;
 #include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
 #include &lt;fast_pcl/registration/ndt.h&gt;
-#include &lt;fast_pcl/filters/voxel_grid.h&gt;
 #endif
 
 #ifndef USE_FAST_PCL
-#include &lt;pcl/registration/ndt.h&gt;
 #include &lt;pcl/filters/voxel_grid.h&gt;
+#include &lt;pcl/registration/ndt.h&gt;
 #endif
 
 #include &lt;autoware_msgs/ConfigNdtMapping.h&gt;
@@ -85,17 +85,19 @@ struct pose
 };
 
 // global variables
-static pose previous_pose, guess_pose, guess_pose_imu, guess_pose_odom, guess_pose_imu_odom,current_pose, current_pose_imu, current_pose_odom, current_pose_imu_odom, ndt_pose, added_pose, localizer_pose;
+static pose previous_pose, guess_pose, guess_pose_imu, guess_pose_odom, guess_pose_imu_odom, current_pose,
+    current_pose_imu, current_pose_odom, current_pose_imu_odom, ndt_pose, added_pose, localizer_pose;
 
 static ros::Time current_scan_time;
 static ros::Time previous_scan_time;
 static ros::Duration scan_duration;
 
 static double diff = 0.0;
-static double diff_x = 0.0, diff_y = 0.0, diff_z = 0.0, diff_yaw; // current_pose - previous_pose
+static double diff_x = 0.0, diff_y = 0.0, diff_z = 0.0, diff_yaw;  // current_pose - previous_pose
 static double offset_imu_x, offset_imu_y, offset_imu_z, offset_imu_roll, offset_imu_pitch, offset_imu_yaw;
 static double offset_odom_x, offset_odom_y, offset_odom_z, offset_odom_roll, offset_odom_pitch, offset_odom_yaw;
-static double offset_imu_odom_x, offset_imu_odom_y, offset_imu_odom_z, offset_imu_odom_roll, offset_imu_odom_pitch, offset_imu_odom_yaw;
+static double offset_imu_odom_x, offset_imu_odom_y, offset_imu_odom_z, offset_imu_odom_roll, offset_imu_odom_pitch,
+    offset_imu_odom_yaw;
 
 static double current_velocity_x = 0.0;
 static double current_velocity_y = 0.0;
@@ -107,15 +109,15 @@ static double current_velocity_imu_z = 0.0;
 
 static pcl::PointCloud&lt;pcl::PointXYZI&gt; map;
 
-//Added for GPU ndt
+// Added for GPU ndt
 #ifdef CUDA_FOUND
 static gpu::GNormalDistributionsTransform gpu_ndt;
 #endif
 static pcl::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt; ndt;
-//end of adding
+// end of adding
 
 // Default values
-static int max_iter = 30;            // Maximum iterations
+static int max_iter = 30;        // Maximum iterations
 static float ndt_res = 1.0;      // Resolution
 static double step_size = 0.1;   // Step size
 static double trans_eps = 0.01;  // Transformation epsilon
@@ -164,13 +166,11 @@ static double fitness_score;
 static bool has_converged;
 static int final_num_iteration;
 
-
 static sensor_msgs::Imu imu;
 static nav_msgs::Odometry odom;
 
 static void param_callback(const autoware_msgs::ConfigNdtMapping::ConstPtr&amp; input)
 {
-
   ndt_res = input-&gt;resolution;
   step_size = input-&gt;step_size;
   trans_eps = input-&gt;trans_epsilon;
@@ -240,85 +240,83 @@ static void imu_odom_calc(ros::Time current_time)
   static ros::Time previous_time = current_time;
   double diff_time = (current_time - previous_time).toSec();
 
-  double diff_imu_roll  = imu.angular_velocity.x * diff_time;
+  double diff_imu_roll = imu.angular_velocity.x * diff_time;
   double diff_imu_pitch = imu.angular_velocity.y * diff_time;
-  double diff_imu_yaw   = imu.angular_velocity.z * diff_time;
+  double diff_imu_yaw = imu.angular_velocity.z * diff_time;
 
-  current_pose_imu_odom.roll  += diff_imu_roll;
+  current_pose_imu_odom.roll += diff_imu_roll;
   current_pose_imu_odom.pitch += diff_imu_pitch;
-  current_pose_imu_odom.yaw   += diff_imu_yaw;
+  current_pose_imu_odom.yaw += diff_imu_yaw;
 
   double diff_distance = odom.twist.twist.linear.x * diff_time;
-  offset_imu_odom_x += diff_distance*cos(-current_pose_imu_odom.pitch)*cos(current_pose_imu_odom.yaw);
-  offset_imu_odom_y += diff_distance*cos(-current_pose_imu_odom.pitch)*sin(current_pose_imu_odom.yaw);
-  offset_imu_odom_z += diff_distance*sin(-current_pose_imu_odom.pitch);
+  offset_imu_odom_x += diff_distance * cos(-current_pose_imu_odom.pitch) * cos(current_pose_imu_odom.yaw);
+  offset_imu_odom_y += diff_distance * cos(-current_pose_imu_odom.pitch) * sin(current_pose_imu_odom.yaw);
+  offset_imu_odom_z += diff_distance * sin(-current_pose_imu_odom.pitch);
 
-  offset_imu_odom_roll  += diff_imu_roll;
+  offset_imu_odom_roll += diff_imu_roll;
   offset_imu_odom_pitch += diff_imu_pitch;
-  offset_imu_odom_yaw   += diff_imu_yaw;
+  offset_imu_odom_yaw += diff_imu_yaw;
 
-  guess_pose_imu_odom.x     = previous_pose.x     + offset_imu_odom_x;
-  guess_pose_imu_odom.y     = previous_pose.y     + offset_imu_odom_y;
-  guess_pose_imu_odom.z     = previous_pose.z     + offset_imu_odom_z;
-  guess_pose_imu_odom.roll  = previous_pose.roll  + offset_imu_odom_roll;
+  guess_pose_imu_odom.x = previous_pose.x + offset_imu_odom_x;
+  guess_pose_imu_odom.y = previous_pose.y + offset_imu_odom_y;
+  guess_pose_imu_odom.z = previous_pose.z + offset_imu_odom_z;
+  guess_pose_imu_odom.roll = previous_pose.roll + offset_imu_odom_roll;
   guess_pose_imu_odom.pitch = previous_pose.pitch + offset_imu_odom_pitch;
-  guess_pose_imu_odom.yaw   = previous_pose.yaw   + offset_imu_odom_yaw;
+  guess_pose_imu_odom.yaw = previous_pose.yaw + offset_imu_odom_yaw;
 
   previous_time = current_time;
 }
 
-
 static void odom_calc(ros::Time current_time)
 {
   static ros::Time previous_time = current_time;
   double diff_time = (current_time - previous_time).toSec();
 
-  double diff_odom_roll  = odom.twist.twist.angular.x * diff_time;
+  double diff_odom_roll = odom.twist.twist.angular.x * diff_time;
   double diff_odom_pitch = odom.twist.twist.angular.y * diff_time;
-  double diff_odom_yaw   = odom.twist.twist.angular.z * diff_time;
+  double diff_odom_yaw = odom.twist.twist.angular.z * diff_time;
 
-  current_pose_odom.roll  += diff_odom_roll;
+  current_pose_odom.roll += diff_odom_roll;
   current_pose_odom.pitch += diff_odom_pitch;
-  current_pose_odom.yaw   += diff_odom_yaw;
+  current_pose_odom.yaw += diff_odom_yaw;
 
   double diff_distance = odom.twist.twist.linear.x * diff_time;
-  offset_odom_x += diff_distance*cos(-current_pose_odom.pitch)*cos(current_pose_odom.yaw);
-  offset_odom_y += diff_distance*cos(-current_pose_odom.pitch)*sin(current_pose_odom.yaw);
-  offset_odom_z += diff_distance*sin(-current_pose_odom.pitch);
+  offset_odom_x += diff_distance * cos(-current_pose_odom.pitch) * cos(current_pose_odom.yaw);
+  offset_odom_y += diff_distance * cos(-current_pose_odom.pitch) * sin(current_pose_odom.yaw);
+  offset_odom_z += diff_distance * sin(-current_pose_odom.pitch);
 
-  offset_odom_roll  += diff_odom_roll;
+  offset_odom_roll += diff_odom_roll;
   offset_odom_pitch += diff_odom_pitch;
-  offset_odom_yaw   += diff_odom_yaw;
+  offset_odom_yaw += diff_odom_yaw;
 
-  guess_pose_odom.x     = previous_pose.x     + offset_odom_x;
-  guess_pose_odom.y     = previous_pose.y     + offset_odom_y;
-  guess_pose_odom.z     = previous_pose.z     + offset_odom_z;
-  guess_pose_odom.roll  = previous_pose.roll  + offset_odom_roll;
+  guess_pose_odom.x = previous_pose.x + offset_odom_x;
+  guess_pose_odom.y = previous_pose.y + offset_odom_y;
+  guess_pose_odom.z = previous_pose.z + offset_odom_z;
+  guess_pose_odom.roll = previous_pose.roll + offset_odom_roll;
   guess_pose_odom.pitch = previous_pose.pitch + offset_odom_pitch;
-  guess_pose_odom.yaw   = previous_pose.yaw   + offset_odom_yaw;
+  guess_pose_odom.yaw = previous_pose.yaw + offset_odom_yaw;
 
   previous_time = current_time;
 }
 
 static void imu_calc(ros::Time current_time)
 {
-
   static ros::Time previous_time = current_time;
   double diff_time = (current_time - previous_time).toSec();
 
-  double diff_imu_roll  = imu.angular_velocity.x * diff_time;
+  double diff_imu_roll = imu.angular_velocity.x * diff_time;
   double diff_imu_pitch = imu.angular_velocity.y * diff_time;
-  double diff_imu_yaw   = imu.angular_velocity.z * diff_time;
+  double diff_imu_yaw = imu.angular_velocity.z * diff_time;
 
   current_pose_imu.roll += diff_imu_roll;
   current_pose_imu.pitch += diff_imu_pitch;
   current_pose_imu.yaw += diff_imu_yaw;
 
   double accX1 = imu.linear_acceleration.x;
-  double accY1 = std::cos(current_pose_imu.roll) * imu.linear_acceleration.y
-                -std::sin(current_pose_imu.roll) * imu.linear_acceleration.z;
-  double accZ1 = std::sin(current_pose_imu.roll) * imu.linear_acceleration.y
-                +std::cos(current_pose_imu.roll) * imu.linear_acceleration.z;
+  double accY1 = std::cos(current_pose_imu.roll) * imu.linear_acceleration.y -
+                 std::sin(current_pose_imu.roll) * imu.linear_acceleration.z;
+  double accZ1 = std::sin(current_pose_imu.roll) * imu.linear_acceleration.y +
+                 std::cos(current_pose_imu.roll) * imu.linear_acceleration.z;
 
   double accX2 = std::sin(current_pose_imu.pitch) * accZ1 + std::cos(current_pose_imu.pitch) * accX1;
   double accY2 = accY1;
@@ -336,44 +334,42 @@ static void imu_calc(ros::Time current_time)
   current_velocity_imu_y += accY * diff_time;
   current_velocity_imu_z += accZ * diff_time;
 
-  offset_imu_roll  += diff_imu_roll;
+  offset_imu_roll += diff_imu_roll;
   offset_imu_pitch += diff_imu_pitch;
-  offset_imu_yaw   += diff_imu_yaw;
+  offset_imu_yaw += diff_imu_yaw;
 
-  guess_pose_imu.x     = previous_pose.x     + offset_imu_x;
-  guess_pose_imu.y     = previous_pose.y     + offset_imu_y;
-  guess_pose_imu.z     = previous_pose.z     + offset_imu_z;
-  guess_pose_imu.roll  = previous_pose.roll  + offset_imu_roll;
+  guess_pose_imu.x = previous_pose.x + offset_imu_x;
+  guess_pose_imu.y = previous_pose.y + offset_imu_y;
+  guess_pose_imu.z = previous_pose.z + offset_imu_z;
+  guess_pose_imu.roll = previous_pose.roll + offset_imu_roll;
   guess_pose_imu.pitch = previous_pose.pitch + offset_imu_pitch;
-  guess_pose_imu.yaw   = previous_pose.yaw   + offset_imu_yaw;
+  guess_pose_imu.yaw = previous_pose.yaw + offset_imu_yaw;
 
   previous_time = current_time;
 }
 
-
 static double wrapToPm(double a_num, const double a_max)
 {
-    if (a_num &gt;= a_max)
-    {
-        a_num -= 2.0 * a_max;
-    }
-    return a_num;
+  if (a_num &gt;= a_max)
+  {
+    a_num -= 2.0 * a_max;
+  }
+  return a_num;
 }
 
 static double wrapToPmPi(double a_angle_rad)
 {
-    return wrapToPm(a_angle_rad, M_PI);
+  return wrapToPm(a_angle_rad, M_PI);
 }
 
 static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
 {
-  //std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
+  // std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
 
   odom = *input;
   odom_calc(input-&gt;header.stamp);
 }
 
-
 static void imuUpsideDown(const sensor_msgs::Imu::Ptr input)
 {
   double input_roll, input_pitch, input_yaw;
@@ -390,24 +386,23 @@ static void imuUpsideDown(const sensor_msgs::Imu::Ptr input)
   input-&gt;linear_acceleration.y *= -1;
   input-&gt;linear_acceleration.z *= -1;
 
-  input_roll  *= -1;
+  input_roll *= -1;
   input_pitch *= -1;
-  input_yaw   *= -1;
+  input_yaw *= -1;
 
   input-&gt;orientation = tf::createQuaternionMsgFromRollPitchYaw(input_roll, input_pitch, input_yaw);
 }
 
-
 static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
 {
-  //std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
+  // std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
 
-  if(_imu_upside_down)
+  if (_imu_upside_down)
     imuUpsideDown(input);
 
   const ros::Time current_time = input-&gt;header.stamp;
   static ros::Time previous_time = current_time;
-  const double diff_time =  (current_time - previous_time).toSec();
+  const double diff_time = (current_time - previous_time).toSec();
 
   double imu_roll, imu_pitch, imu_yaw;
   tf::Quaternion imu_orientation;
@@ -419,33 +414,33 @@ static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
   imu_yaw = wrapToPmPi(imu_yaw);
 
   static double previous_imu_roll = imu_roll, previous_imu_pitch = imu_pitch, previous_imu_yaw = imu_yaw;
-  const double diff_imu_roll  = imu_roll  - previous_imu_roll;
+  const double diff_imu_roll = imu_roll - previous_imu_roll;
 
   const double diff_imu_pitch = imu_pitch - previous_imu_pitch;
 
   double diff_imu_yaw;
-  if(fabs(imu_yaw - previous_imu_yaw) &gt; M_PI)
+  if (fabs(imu_yaw - previous_imu_yaw) &gt; M_PI)
   {
-    if(imu_yaw &gt; 0)
-      diff_imu_yaw = (imu_yaw - previous_imu_yaw) - M_PI*2;
+    if (imu_yaw &gt; 0)
+      diff_imu_yaw = (imu_yaw - previous_imu_yaw) - M_PI * 2;
     else
-      diff_imu_yaw = -M_PI*2 - (imu_yaw - previous_imu_yaw);
+      diff_imu_yaw = -M_PI * 2 - (imu_yaw - previous_imu_yaw);
   }
   else
-  diff_imu_yaw = imu_yaw - previous_imu_yaw;
+    diff_imu_yaw = imu_yaw - previous_imu_yaw;
 
   imu.header = input-&gt;header;
   imu.linear_acceleration.x = input-&gt;linear_acceleration.x;
-  //imu.linear_acceleration.y = input-&gt;linear_acceleration.y;
-  //imu.linear_acceleration.z = input-&gt;linear_acceleration.z;
+  // imu.linear_acceleration.y = input-&gt;linear_acceleration.y;
+  // imu.linear_acceleration.z = input-&gt;linear_acceleration.z;
   imu.linear_acceleration.y = 0;
   imu.linear_acceleration.z = 0;
 
-  if(diff_time != 0)
+  if (diff_time != 0)
   {
-    imu.angular_velocity.x = diff_imu_roll  / diff_time;
+    imu.angular_velocity.x = diff_imu_roll / diff_time;
     imu.angular_velocity.y = diff_imu_pitch / diff_time;
-    imu.angular_velocity.z = diff_imu_yaw   / diff_time;
+    imu.angular_velocity.z = diff_imu_yaw / diff_time;
   }
   else
   {
@@ -457,12 +452,11 @@ static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
   imu_calc(input-&gt;header.stamp);
 
   previous_time = current_time;
-  previous_imu_roll  = imu_roll;
+  previous_imu_roll = imu_roll;
   previous_imu_pitch = imu_pitch;
-  previous_imu_yaw   = imu_yaw;
+  previous_imu_yaw = imu_yaw;
 }
 
-
 static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 {
   double r;
@@ -514,27 +508,32 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(map));
 
 #ifdef CUDA_FOUND
-  if(_use_gpu == true){
+  if (_use_gpu == true)
+  {
     gpu_ndt.setTransformationEpsilon(trans_eps);
     gpu_ndt.setStepSize(step_size);
     gpu_ndt.setResolution(ndt_res);
     gpu_ndt.setMaximumIterations(max_iter);
     gpu_ndt.setInputSource(filtered_scan_ptr);
-  }else
+  }
+  else
 #endif
-{
-  ndt.setTransformationEpsilon(trans_eps);
-  ndt.setStepSize(step_size);
-  ndt.setResolution(ndt_res);
-  ndt.setMaximumIterations(max_iter);
-  ndt.setInputSource(filtered_scan_ptr);
-}
+  {
+    ndt.setTransformationEpsilon(trans_eps);
+    ndt.setStepSize(step_size);
+    ndt.setResolution(ndt_res);
+    ndt.setMaximumIterations(max_iter);
+    ndt.setInputSource(filtered_scan_ptr);
+  }
   if (isMapUpdate == true)
   {
 #ifdef CUDA_FOUND
-    if(_use_gpu == true){
+    if (_use_gpu == true)
+    {
       gpu_ndt.setInputTarget(map_ptr);
-    }else{
+    }
+    else
+    {
       ndt.setInputTarget(map_ptr);
     }
 #else
@@ -551,7 +550,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   guess_pose.pitch = previous_pose.pitch;
   guess_pose.yaw = previous_pose.yaw + diff_yaw;
 
-
   if (_use_imu == true &amp;&amp; _use_odom == true)
     imu_odom_calc(current_scan_time);
   if (_use_imu == true &amp;&amp; _use_odom == false)
@@ -560,16 +558,15 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     odom_calc(current_scan_time);
 
   pose guess_pose_for_ndt;
-  if(_use_imu == true &amp;&amp; _use_odom == true)
+  if (_use_imu == true &amp;&amp; _use_odom == true)
     guess_pose_for_ndt = guess_pose_imu_odom;
-  else if(_use_imu == true &amp;&amp; _use_odom == false)
+  else if (_use_imu == true &amp;&amp; _use_odom == false)
     guess_pose_for_ndt = guess_pose_imu;
-  else if(_use_imu == false &amp;&amp; _use_odom == true)
+  else if (_use_imu == false &amp;&amp; _use_odom == true)
     guess_pose_for_ndt = guess_pose_odom;
   else
     guess_pose_for_ndt = guess_pose;
 
-
   Eigen::AngleAxisf init_rotation_x(guess_pose_for_ndt.roll, Eigen::Vector3f::UnitX());
   Eigen::AngleAxisf init_rotation_y(guess_pose_for_ndt.pitch, Eigen::Vector3f::UnitY());
   Eigen::AngleAxisf init_rotation_z(guess_pose_for_ndt.yaw, Eigen::Vector3f::UnitZ());
@@ -588,7 +585,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   std::cout &lt;&lt; "Start aligning" &lt;&lt; std::endl;
 
 #ifdef CUDA_FOUND
-  if(_use_gpu == true)
+  if (_use_gpu == true)
   {
     gpu_ndt.align(init_guess);
     t_localizer = gpu_ndt.getFinalTransformation();
@@ -596,8 +593,8 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     fitness_score = gpu_ndt.getFitnessScore();
     final_num_iteration = ndt.getFinalNumIteration();
   }
-  #ifdef USE_FAST_PCL
-  else if(_use_openmp == true)
+#ifdef USE_FAST_PCL
+  else if (_use_openmp == true)
   {
     ndt.omp_align(*output_cloud, init_guess);
     t_localizer = ndt.getFinalTransformation();
@@ -605,7 +602,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     fitness_score = ndt.omp_getFitnessScore();
     final_num_iteration = ndt.getFinalNumIteration();
   }
-  #endif
+#endif
   else
   {
     ndt.align(*output_cloud, init_guess);
@@ -615,7 +612,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     final_num_iteration = ndt.getFinalNumIteration();
   }
 #else
-  #ifdef USE_FAST_PCL
+#ifdef USE_FAST_PCL
   if (_use_openmp == true)
   {
     ndt.omp_align(*output_cloud, init_guess);
@@ -626,17 +623,17 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   }
   else
   {
-  #endif
-    //Added for GPU ndt
+#endif
+    // Added for GPU ndt
     ndt.align(*output_cloud, init_guess);
     t_localizer = ndt.getFinalTransformation();
     has_converged = ndt.hasConverged();
     fitness_score = ndt.getFitnessScore();
     final_num_iteration = ndt.getFinalNumIteration();
-    //End of adding GPU ndt
-  #ifdef USE_FAST_PCL
+// End of adding GPU ndt
+#ifdef USE_FAST_PCL
   }
-  #endif
+#endif
 #endif
 
   t_base_link = t_localizer * tf_ltob;
@@ -732,7 +729,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   previous_scan_time.sec = current_scan_time.sec;
   previous_scan_time.nsec = current_scan_time.nsec;
 
-
   offset_imu_x = 0.0;
   offset_imu_y = 0.0;
   offset_imu_z = 0.0;
@@ -785,7 +781,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   current_pose_pub.publish(current_pose_msg);
 
-
   std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
   std::cout &lt;&lt; "Sequence number: " &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
   std::cout &lt;&lt; "Number of scan points: " &lt;&lt; scan_ptr-&gt;size() &lt;&lt; " points." &lt;&lt; std::endl;
@@ -879,7 +874,7 @@ int main(int argc, char** argv)
   ros::NodeHandle nh;
   ros::NodeHandle private_nh("~");
 
-  // setting parameters
+// setting parameters
 #ifdef CUDA_FOUND
   private_nh.getParam("use_gpu", _use_gpu);
   std::cout &lt;&lt; "use_gpu: " &lt;&lt; _use_gpu &lt;&lt; std::endl;
@@ -929,8 +924,8 @@ int main(int argc, char** argv)
     return 1;
   }
 
-#if defined (CUDA_FOUND) &amp;&amp; defined (USE_FAST_PCL)
-  if(_use_gpu == true &amp;&amp; _use_openmp == true)
+#if defined(CUDA_FOUND) &amp;&amp; defined(USE_FAST_PCL)
+  if (_use_gpu == true &amp;&amp; _use_openmp == true)
   {
     std::cout &lt;&lt; "use_gpu and use_openmp are exclusive. Set use_gpu true and use_openmp false." &lt;&lt; std::endl;
     _use_openmp = false;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="106" deleted_lines="115">
				<diff>@@ -34,24 +34,24 @@
  Yuki KITSUKAWA
  */
 
+#include &lt;chrono&gt;
+#include &lt;fstream&gt;
 #include &lt;iostream&gt;
 #include &lt;sstream&gt;
-#include &lt;fstream&gt;
 #include &lt;string&gt;
-#include &lt;chrono&gt;
 
-#include &lt;ros/ros.h&gt;
-#include &lt;std_msgs/Float32.h&gt;
-#include &lt;std_msgs/String.h&gt;
-#include &lt;std_msgs/Bool.h&gt;
 #include &lt;nav_msgs/Odometry.h&gt;
+#include &lt;ros/ros.h&gt;
 #include &lt;sensor_msgs/Imu.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
+#include &lt;std_msgs/Bool.h&gt;
+#include &lt;std_msgs/Float32.h&gt;
+#include &lt;std_msgs/String.h&gt;
 #include &lt;velodyne_pointcloud/point_types.h&gt;
 #include &lt;velodyne_pointcloud/rawdata.h&gt;
 
-#include &lt;geometry_msgs/TwistStamped.h&gt;
 #include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
+#include &lt;geometry_msgs/TwistStamped.h&gt;
 
 #include &lt;tf/tf.h&gt;
 #include &lt;tf/transform_broadcaster.h&gt;
@@ -63,7 +63,7 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 
-#if defined (USE_FAST_PCL) &amp;&amp; defined (CUDA_FOUND)
+#if defined(USE_FAST_PCL) &amp;&amp; defined(CUDA_FOUND)
 #include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
 #include &lt;fast_pcl/registration/ndt.h&gt;
 #endif
@@ -95,13 +95,15 @@ struct pose
   double yaw;
 };
 
-static pose initial_pose, predict_pose, predict_pose_imu, predict_pose_odom, predict_pose_imu_odom, previous_pose, ndt_pose, current_pose, current_pose_imu, current_pose_odom, current_pose_imu_odom, localizer_pose, previous_gnss_pose,
-    current_gnss_pose;
+static pose initial_pose, predict_pose, predict_pose_imu, predict_pose_odom, predict_pose_imu_odom, previous_pose,
+    ndt_pose, current_pose, current_pose_imu, current_pose_odom, current_pose_imu_odom, localizer_pose,
+    previous_gnss_pose, current_gnss_pose;
 
 static double offset_x, offset_y, offset_z, offset_yaw;  // current_pos - previous_pose
 static double offset_imu_x, offset_imu_y, offset_imu_z, offset_imu_roll, offset_imu_pitch, offset_imu_yaw;
 static double offset_odom_x, offset_odom_y, offset_odom_z, offset_odom_roll, offset_odom_pitch, offset_odom_yaw;
-static double offset_imu_odom_x, offset_imu_odom_y, offset_imu_odom_z, offset_imu_odom_roll, offset_imu_odom_pitch, offset_imu_odom_yaw;
+static double offset_imu_odom_x, offset_imu_odom_y, offset_imu_odom_z, offset_imu_odom_roll, offset_imu_odom_pitch,
+    offset_imu_odom_yaw;
 
 // Can't load if typed "pcl::PointCloud&lt;pcl::PointXYZRGB&gt; map, add;"
 static pcl::PointCloud&lt;pcl::PointXYZ&gt; map, add;
@@ -228,7 +230,6 @@ static std::string filename;
 static sensor_msgs::Imu imu;
 static nav_msgs::Odometry odom;
 
-
 // static tf::TransformListener local_transform_listener;
 static tf::StampedTransform local_transform;
 
@@ -252,13 +253,14 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
   {
     ndt_res = input-&gt;resolution;
 #ifdef CUDA_FOUND
-    if(_use_gpu == true){
+    if (_use_gpu == true)
+    {
       gpu_ndt.setResolution(ndt_res);
     }
     else
     {
 #endif
-    ndt.setResolution(ndt_res);
+      ndt.setResolution(ndt_res);
 #ifdef CUDA_FOUND
     }
 #endif
@@ -267,13 +269,14 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
   {
     step_size = input-&gt;step_size;
 #ifdef CUDA_FOUND
-    if(_use_gpu == true){
+    if (_use_gpu == true)
+    {
       gpu_ndt.setStepSize(step_size);
     }
     else
     {
 #endif
-    ndt.setStepSize(step_size);
+      ndt.setStepSize(step_size);
 #ifdef CUDA_FOUND
     }
 #endif
@@ -282,13 +285,14 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
   {
     trans_eps = input-&gt;trans_epsilon;
 #ifdef CUDA_FOUND
-    if(_use_gpu == true){
+    if (_use_gpu == true)
+    {
       gpu_ndt.setTransformationEpsilon(trans_eps);
     }
     else
     {
 #endif
-    ndt.setTransformationEpsilon(trans_eps);
+      ndt.setTransformationEpsilon(trans_eps);
 #ifdef CUDA_FOUND
     }
 #endif
@@ -297,13 +301,14 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
   {
     max_iter = input-&gt;max_iterations;
 #ifdef CUDA_FOUND
-    if(_use_gpu == true){
+    if (_use_gpu == true)
+    {
       gpu_ndt.setMaximumIterations(max_iter);
     }
     else
     {
 #endif
-    ndt.setMaximumIterations(max_iter);
+      ndt.setMaximumIterations(max_iter);
 #ifdef CUDA_FOUND
     }
 #endif
@@ -406,9 +411,9 @@ static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     }
 
     pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(map));
-    // Setting point cloud to be aligned to.
+// Setting point cloud to be aligned to.
 #ifdef CUDA_FOUND
-    if(_use_gpu == true)
+    if (_use_gpu == true)
     {
       gpu_ndt.setInputTarget(map_ptr);
       gpu_ndt.setMaximumIterations(max_iter);
@@ -557,7 +562,6 @@ static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped:
   offset_imu_odom_roll = 0.0;
   offset_imu_odom_pitch = 0.0;
   offset_imu_odom_yaw = 0.0;
-
 }
 
 static void imu_odom_calc(ros::Time current_time)
@@ -565,65 +569,63 @@ static void imu_odom_calc(ros::Time current_time)
   static ros::Time previous_time = current_time;
   double diff_time = (current_time - previous_time).toSec();
 
-  double diff_imu_roll  = imu.angular_velocity.x * diff_time;
+  double diff_imu_roll = imu.angular_velocity.x * diff_time;
   double diff_imu_pitch = imu.angular_velocity.y * diff_time;
-  double diff_imu_yaw   = imu.angular_velocity.z * diff_time;
+  double diff_imu_yaw = imu.angular_velocity.z * diff_time;
 
-  current_pose_imu_odom.roll  += diff_imu_roll;
+  current_pose_imu_odom.roll += diff_imu_roll;
   current_pose_imu_odom.pitch += diff_imu_pitch;
-  current_pose_imu_odom.yaw   += diff_imu_yaw;
+  current_pose_imu_odom.yaw += diff_imu_yaw;
 
   double diff_distance = odom.twist.twist.linear.x * diff_time;
-  offset_imu_odom_x += diff_distance*cos(-current_pose_imu_odom.pitch)*cos(current_pose_imu_odom.yaw);
-  offset_imu_odom_y += diff_distance*cos(-current_pose_imu_odom.pitch)*sin(current_pose_imu_odom.yaw);
-  offset_imu_odom_z += diff_distance*sin(-current_pose_imu_odom.pitch);
+  offset_imu_odom_x += diff_distance * cos(-current_pose_imu_odom.pitch) * cos(current_pose_imu_odom.yaw);
+  offset_imu_odom_y += diff_distance * cos(-current_pose_imu_odom.pitch) * sin(current_pose_imu_odom.yaw);
+  offset_imu_odom_z += diff_distance * sin(-current_pose_imu_odom.pitch);
 
-  offset_imu_odom_roll  += diff_imu_roll;
+  offset_imu_odom_roll += diff_imu_roll;
   offset_imu_odom_pitch += diff_imu_pitch;
-  offset_imu_odom_yaw   += diff_imu_yaw;
+  offset_imu_odom_yaw += diff_imu_yaw;
 
-  predict_pose_imu_odom.x     = previous_pose.x     + offset_imu_odom_x;
-  predict_pose_imu_odom.y     = previous_pose.y     + offset_imu_odom_y;
-  predict_pose_imu_odom.z     = previous_pose.z     + offset_imu_odom_z;
-  predict_pose_imu_odom.roll  = previous_pose.roll  + offset_imu_odom_roll;
+  predict_pose_imu_odom.x = previous_pose.x + offset_imu_odom_x;
+  predict_pose_imu_odom.y = previous_pose.y + offset_imu_odom_y;
+  predict_pose_imu_odom.z = previous_pose.z + offset_imu_odom_z;
+  predict_pose_imu_odom.roll = previous_pose.roll + offset_imu_odom_roll;
   predict_pose_imu_odom.pitch = previous_pose.pitch + offset_imu_odom_pitch;
-  predict_pose_imu_odom.yaw   = previous_pose.yaw   + offset_imu_odom_yaw;
+  predict_pose_imu_odom.yaw = previous_pose.yaw + offset_imu_odom_yaw;
 
   previous_time = current_time;
 }
 
-
 static void odom_calc(ros::Time current_time)
 {
   static ros::Time previous_time = current_time;
   double diff_time = (current_time - previous_time).toSec();
 
-  double diff_odom_roll  = odom.twist.twist.angular.x * diff_time;
+  double diff_odom_roll = odom.twist.twist.angular.x * diff_time;
   double diff_odom_pitch = odom.twist.twist.angular.y * diff_time;
-  double diff_odom_yaw   = odom.twist.twist.angular.z * diff_time;
+  double diff_odom_yaw = odom.twist.twist.angular.z * diff_time;
 
-  current_pose_odom.roll  += diff_odom_roll;
+  current_pose_odom.roll += diff_odom_roll;
   current_pose_odom.pitch += diff_odom_pitch;
-  current_pose_odom.yaw   += diff_odom_yaw;
+  current_pose_odom.yaw += diff_odom_yaw;
 
   double diff_distance = odom.twist.twist.linear.x * diff_time;
-  offset_odom_x += diff_distance*cos(-current_pose_odom.pitch)*cos(current_pose_odom.yaw);
-  offset_odom_y += diff_distance*cos(-current_pose_odom.pitch)*sin(current_pose_odom.yaw);
-  offset_odom_z += diff_distance*sin(-current_pose_odom.pitch);
+  offset_odom_x += diff_distance * cos(-current_pose_odom.pitch) * cos(current_pose_odom.yaw);
+  offset_odom_y += diff_distance * cos(-current_pose_odom.pitch) * sin(current_pose_odom.yaw);
+  offset_odom_z += diff_distance * sin(-current_pose_odom.pitch);
 
-  offset_odom_roll  += diff_odom_roll;
+  offset_odom_roll += diff_odom_roll;
   offset_odom_pitch += diff_odom_pitch;
-  offset_odom_yaw   += diff_odom_yaw;
+  offset_odom_yaw += diff_odom_yaw;
 
-  predict_pose_odom.x     = previous_pose.x     + offset_odom_x;
-  predict_pose_odom.y     = previous_pose.y     + offset_odom_y;
-  predict_pose_odom.z     = previous_pose.z     + offset_odom_z;
-  predict_pose_odom.roll  = previous_pose.roll  + offset_odom_roll;
+  predict_pose_odom.x = previous_pose.x + offset_odom_x;
+  predict_pose_odom.y = previous_pose.y + offset_odom_y;
+  predict_pose_odom.z = previous_pose.z + offset_odom_z;
+  predict_pose_odom.roll = previous_pose.roll + offset_odom_roll;
   predict_pose_odom.pitch = previous_pose.pitch + offset_odom_pitch;
-  predict_pose_odom.yaw   = previous_pose.yaw   + offset_odom_yaw;
+  predict_pose_odom.yaw = previous_pose.yaw + offset_odom_yaw;
 
   previous_time = current_time;
-
 }
 
 static void imu_calc(ros::Time current_time)
@@ -631,19 +633,19 @@ static void imu_calc(ros::Time current_time)
   static ros::Time previous_time = current_time;
   double diff_time = (current_time - previous_time).toSec();
 
-  double diff_imu_roll  = imu.angular_velocity.x * diff_time;
+  double diff_imu_roll = imu.angular_velocity.x * diff_time;
   double diff_imu_pitch = imu.angular_velocity.y * diff_time;
-  double diff_imu_yaw   = imu.angular_velocity.z * diff_time;
+  double diff_imu_yaw = imu.angular_velocity.z * diff_time;
 
   current_pose_imu.roll += diff_imu_roll;
   current_pose_imu.pitch += diff_imu_pitch;
   current_pose_imu.yaw += diff_imu_yaw;
 
   double accX1 = imu.linear_acceleration.x;
-  double accY1 = std::cos(current_pose_imu.roll) * imu.linear_acceleration.y
-                -std::sin(current_pose_imu.roll) * imu.linear_acceleration.z;
-  double accZ1 = std::sin(current_pose_imu.roll) * imu.linear_acceleration.y
-                +std::cos(current_pose_imu.roll) * imu.linear_acceleration.z;
+  double accY1 = std::cos(current_pose_imu.roll) * imu.linear_acceleration.y -
+                 std::sin(current_pose_imu.roll) * imu.linear_acceleration.z;
+  double accZ1 = std::sin(current_pose_imu.roll) * imu.linear_acceleration.y +
+                 std::cos(current_pose_imu.roll) * imu.linear_acceleration.z;
 
   double accX2 = std::sin(current_pose_imu.pitch) * accZ1 + std::cos(current_pose_imu.pitch) * accX1;
   double accY2 = accY1;
@@ -661,39 +663,37 @@ static void imu_calc(ros::Time current_time)
   current_velocity_imu_y += accY * diff_time;
   current_velocity_imu_z += accZ * diff_time;
 
-  offset_imu_roll  += diff_imu_roll;
+  offset_imu_roll += diff_imu_roll;
   offset_imu_pitch += diff_imu_pitch;
-  offset_imu_yaw   += diff_imu_yaw;
+  offset_imu_yaw += diff_imu_yaw;
 
-  predict_pose_imu.x     = previous_pose.x     + offset_imu_x;
-  predict_pose_imu.y     = previous_pose.y     + offset_imu_y;
-  predict_pose_imu.z     = previous_pose.z     + offset_imu_z;
-  predict_pose_imu.roll  = previous_pose.roll  + offset_imu_roll;
+  predict_pose_imu.x = previous_pose.x + offset_imu_x;
+  predict_pose_imu.y = previous_pose.y + offset_imu_y;
+  predict_pose_imu.z = previous_pose.z + offset_imu_z;
+  predict_pose_imu.roll = previous_pose.roll + offset_imu_roll;
   predict_pose_imu.pitch = previous_pose.pitch + offset_imu_pitch;
-  predict_pose_imu.yaw   = previous_pose.yaw   + offset_imu_yaw;
+  predict_pose_imu.yaw = previous_pose.yaw + offset_imu_yaw;
 
   previous_time = current_time;
 }
 
-
 static const double wrapToPm(double a_num, const double a_max)
 {
-    if (a_num &gt;= a_max)
-    {
-        a_num -= 2.0 * a_max;
-    }
-    return a_num;
+  if (a_num &gt;= a_max)
+  {
+    a_num -= 2.0 * a_max;
+  }
+  return a_num;
 }
 
 static const double wrapToPmPi(double a_angle_rad)
 {
-    return wrapToPm(a_angle_rad, M_PI);
+  return wrapToPm(a_angle_rad, M_PI);
 }
 
-
 static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
 {
-  //std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
+  // std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
 
   odom = *input;
   odom_calc(input-&gt;header.stamp);
@@ -715,23 +715,23 @@ static void imuUpsideDown(const sensor_msgs::Imu::Ptr input)
   input-&gt;linear_acceleration.y *= -1;
   input-&gt;linear_acceleration.z *= -1;
 
-  input_roll  *= -1;
+  input_roll *= -1;
   input_pitch *= -1;
-  input_yaw   *= -1;
+  input_yaw *= -1;
 
   input-&gt;orientation = tf::createQuaternionMsgFromRollPitchYaw(input_roll, input_pitch, input_yaw);
 }
 
 static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
 {
-  //std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
+  // std::cout &lt;&lt; __func__ &lt;&lt; std::endl;
 
-  if(_imu_upside_down)
+  if (_imu_upside_down)
     imuUpsideDown(input);
 
   const ros::Time current_time = input-&gt;header.stamp;
   static ros::Time previous_time = current_time;
-  const double diff_time =  (current_time - previous_time).toSec();
+  const double diff_time = (current_time - previous_time).toSec();
 
   double imu_roll, imu_pitch, imu_yaw;
   tf::Quaternion imu_orientation;
@@ -743,33 +743,33 @@ static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
   imu_yaw = wrapToPmPi(imu_yaw);
 
   static double previous_imu_roll = imu_roll, previous_imu_pitch = imu_pitch, previous_imu_yaw = imu_yaw;
-  const double diff_imu_roll  = imu_roll  - previous_imu_roll;
+  const double diff_imu_roll = imu_roll - previous_imu_roll;
 
   const double diff_imu_pitch = imu_pitch - previous_imu_pitch;
 
   double diff_imu_yaw;
-  if(fabs(imu_yaw - previous_imu_yaw) &gt; M_PI)
+  if (fabs(imu_yaw - previous_imu_yaw) &gt; M_PI)
   {
-    if(imu_yaw &gt; 0)
-      diff_imu_yaw = (imu_yaw - previous_imu_yaw) - M_PI*2;
+    if (imu_yaw &gt; 0)
+      diff_imu_yaw = (imu_yaw - previous_imu_yaw) - M_PI * 2;
     else
-      diff_imu_yaw = -M_PI*2 - (imu_yaw - previous_imu_yaw);
+      diff_imu_yaw = -M_PI * 2 - (imu_yaw - previous_imu_yaw);
   }
   else
-  diff_imu_yaw = imu_yaw - previous_imu_yaw;
+    diff_imu_yaw = imu_yaw - previous_imu_yaw;
 
   imu.header = input-&gt;header;
   imu.linear_acceleration.x = input-&gt;linear_acceleration.x;
-  //imu.linear_acceleration.y = input-&gt;linear_acceleration.y;
-  //imu.linear_acceleration.z = input-&gt;linear_acceleration.z;
+  // imu.linear_acceleration.y = input-&gt;linear_acceleration.y;
+  // imu.linear_acceleration.z = input-&gt;linear_acceleration.z;
   imu.linear_acceleration.y = 0;
   imu.linear_acceleration.z = 0;
 
-  if(diff_time != 0)
+  if (diff_time != 0)
   {
-    imu.angular_velocity.x = diff_imu_roll  / diff_time;
+    imu.angular_velocity.x = diff_imu_roll / diff_time;
     imu.angular_velocity.y = diff_imu_pitch / diff_time;
-    imu.angular_velocity.z = diff_imu_yaw   / diff_time;
+    imu.angular_velocity.z = diff_imu_yaw / diff_time;
   }
   else
   {
@@ -781,9 +781,9 @@ static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
   imu_calc(input-&gt;header.stamp);
 
   previous_time = current_time;
-  previous_imu_roll  = imu_roll;
+  previous_imu_roll = imu_roll;
   previous_imu_pitch = imu_pitch;
-  previous_imu_yaw   = imu_yaw;
+  previous_imu_yaw = imu_yaw;
 }
 
 static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
@@ -813,7 +813,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     static double align_time, getFitnessScore_time = 0.0;
 
 #ifdef CUDA_FOUND
-    if(_use_gpu == true)
+    if (_use_gpu == true)
     {
       gpu_ndt.setInputSource(filtered_scan_ptr);
     }
@@ -833,7 +833,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     predict_pose.pitch = previous_pose.pitch;
     predict_pose.yaw = previous_pose.yaw + offset_yaw;
 
-
     if (_use_imu == true &amp;&amp; _use_odom == true)
       imu_odom_calc(current_scan_time);
     if (_use_imu == true &amp;&amp; _use_odom == false)
@@ -857,13 +856,10 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     Eigen::AngleAxisf init_rotation_z(predict_pose_for_ndt.yaw, Eigen::Vector3f::UnitZ());
     Eigen::Matrix4f init_guess = (init_translation * init_rotation_z * init_rotation_y * init_rotation_x) * tf_btol;
 
-
-
-
     pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
 
 #ifdef CUDA_FOUND
-    if(_use_gpu == true)
+    if (_use_gpu == true)
     {
       align_start = std::chrono::system_clock::now();
       gpu_ndt.align(init_guess);
@@ -880,7 +876,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
       trans_probability = gpu_ndt.getTransformationProbability();
     }
-  #ifdef USE_FAST_PCL
+#ifdef USE_FAST_PCL
     else if (_use_openmp == true)
     {
       align_start = std::chrono::system_clock::now();
@@ -898,7 +894,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
       trans_probability = ndt.getTransformationProbability();
     }
-  #endif
+#endif
     else
     {
       align_start = std::chrono::system_clock::now();
@@ -917,8 +913,8 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
       trans_probability = ndt.getTransformationProbability();
     }
 #else
-  #ifdef USE_FAST_PCL
-    if(_use_openmp == true)
+#ifdef USE_FAST_PCL
+    if (_use_openmp == true)
     {
       align_start = std::chrono::system_clock::now();
       ndt.omp_align(*output_cloud, init_guess);
@@ -937,7 +933,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     }
     else
     {
-  #endif
+#endif
       align_start = std::chrono::system_clock::now();
       ndt.align(*output_cloud, init_guess);
       align_end = std::chrono::system_clock::now();
@@ -952,9 +948,9 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
       getFitnessScore_end = std::chrono::system_clock::now();
 
       trans_probability = ndt.getTransformationProbability();
-  #ifdef USE_FAST_PCL
+#ifdef USE_FAST_PCL
     }
-  #endif
+#endif
 #endif
 
     align_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(align_end - align_start).count() / 1000.0;
@@ -1002,7 +998,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     }
     use_predict_pose = 0;
 
-
     if (use_predict_pose == 0)
     {
       current_pose.x = ndt_pose.x;
@@ -1022,7 +1017,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
       current_pose.yaw = predict_pose_for_ndt.yaw;
     }
 
-
     // Compute the velocity and acceleration
     scan_duration = current_scan_time - previous_scan_time;
     double secs = scan_duration.toSec();
@@ -1049,7 +1043,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     current_velocity_imu_y = current_velocity_y;
     current_velocity_imu_z = current_velocity_z;
 
-
     current_pose_odom.x = current_pose.x;
     current_pose_odom.y = current_pose.y;
     current_pose_odom.z = current_pose.z;
@@ -1136,7 +1129,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     predict_pose_odom_msg.pose.orientation.w = predict_q_odom.w();
     predict_pose_odom_pub.publish(predict_pose_odom_msg);
 
-
     tf::Quaternion predict_q_imu_odom;
     predict_q_imu_odom.setRPY(predict_pose_imu_odom.roll, predict_pose_imu_odom.pitch, predict_pose_imu_odom.yaw);
     predict_pose_imu_odom_msg.header.frame_id = "map";
@@ -1276,7 +1268,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
                            Wc * ((2.0 - trans_probability) / 2.0) * 100.0;
     ndt_reliability_pub.publish(ndt_reliability);
 
-
     // Write log
     if (!ofs)
     {
@@ -1417,8 +1408,8 @@ int main(int argc, char** argv)
   private_nh.getParam("imu_upside_down", _imu_upside_down);
   private_nh.getParam("imu_topic", _imu_topic);
 
-#if defined (CUDA_FOUND) &amp;&amp; defined (USE_FAST_PCL)
-  if(_use_gpu == true &amp;&amp; _use_openmp == true)
+#if defined(CUDA_FOUND) &amp;&amp; defined(USE_FAST_PCL)
+  if (_use_gpu == true &amp;&amp; _use_openmp == true)
   {
     std::cout &lt;&lt; "use_gpu and use_openmp are exclusive. Set use_gpu true and use_openmp false." &lt;&lt; std::endl;
     _use_openmp = false;
@@ -1519,8 +1510,8 @@ int main(int argc, char** argv)
   ros::Subscriber map_sub = nh.subscribe("points_map", 10, map_callback);
   ros::Subscriber initialpose_sub = nh.subscribe("initialpose", 1000, initialpose_callback);
   ros::Subscriber points_sub = nh.subscribe("filtered_points", _queue_size, points_callback);
-  ros::Subscriber odom_sub = nh.subscribe("/odom_pose", _queue_size*10, odom_callback);
-  ros::Subscriber imu_sub = nh.subscribe(_imu_topic.c_str(), _queue_size*10, imu_callback);
+  ros::Subscriber odom_sub = nh.subscribe("/odom_pose", _queue_size * 10, odom_callback);
+  ros::Subscriber imu_sub = nh.subscribe(_imu_topic.c_str(), _queue_size * 10, imu_callback);
 
   ros::spin();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="bd8123cce26398f9ca203a61e4eae815fa13244f" author="Yuki Iida">
		<msg>update gear command message</msg>
		<modified_files>
			<file old_path="ros\src\socket\packages\mqtt_socket\include\mqtt_socket\mqtt_setting.hpp" new_path="ros\src\socket\packages\mqtt_socket\include\mqtt_socket\mqtt_setting.hpp" added_lines="4" deleted_lines="0">
				<diff>@@ -17,3 +17,7 @@
 #define BRAKE_MAX_VAL   10000
 #define STEER_MAX_VAL   0.6
 #define DOWNSAMPLE      0.1
+#define GEAR_D          16
+#define GEAR_N          32
+#define GEAR_R          64
+#define GEAR_P          128
</diff>
			</file>
			<file old_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_sender\mqtt_sender.cpp" new_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_sender\mqtt_sender.cpp" added_lines="17" deleted_lines="1">
				<diff>@@ -217,7 +217,23 @@ void MqttSender::canInfoCallback(const autoware_msgs::CanInfoConstPtr &amp;msg)
     publish_msg &lt;&lt; std::to_string(msg-&gt;inputpedalstr) &lt;&lt; ",";
     publish_msg &lt;&lt; std::to_string(msg-&gt;targetveloc) &lt;&lt; ",";
     publish_msg &lt;&lt; std::to_string(msg-&gt;speed) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;driveshift) &lt;&lt; ",";
+    switch (msg-&gt;driveshift) {
+      case GEAR_D:
+        publish_msg &lt;&lt; "D,";
+        break;
+      case GEAR_N:
+        publish_msg &lt;&lt; "N,";
+        break;
+      case GEAR_R:
+        publish_msg &lt;&lt; "R,";
+        break;
+      case GEAR_P:
+        publish_msg &lt;&lt; "P,";
+        break;
+      default:
+        publish_msg &lt;&lt; "Unkwown,";
+        break;
+    }
     publish_msg &lt;&lt; std::to_string(msg-&gt;targetshift) &lt;&lt; ",";
     publish_msg &lt;&lt; std::to_string(msg-&gt;inputshift) &lt;&lt; ",";
     publish_msg &lt;&lt; std::to_string(msg-&gt;strmode) &lt;&lt; ",";
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b9871ead46b7db032f67b7609b32c9bb5c0c8d27" author="Yuki Iida">
		<msg>refactor code</msg>
		<modified_files>
			<file old_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_receiver\mqtt_receiver.cpp" new_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_receiver\mqtt_receiver.cpp" added_lines="17" deleted_lines="23">
				<diff>@@ -44,12 +44,6 @@ static struct mosquitto *mqtt_client_ = NULL;
 static std::string mqtt_topic_;
 static int mqtt_qos_;
 static ros::Publisher remote_cmd_pub_;
-sig_atomic_t volatile g_request_shutdown = 0;
-
-void mySigIntHandler(int sig)
-{
-  g_request_shutdown = 1;
-}
 
 class MqttReceiver
 {
@@ -136,29 +130,29 @@ static void MqttReceiver::on_message(struct mosquitto *mosq, void *obj, const st
     std::vector&lt;std::string&gt; cmds;
     boost::algorithm::split(cmds, msg_str, boost::is_any_of(","));
 
-    autoware_msgs::RemoteCmd msg;
-    msg.steer = std::stof(cmds[0]) * STEER_MAX_VAL;
-    msg.accel = std::stof(cmds[1]) * ACCEL_MAX_VAL;
-    msg.brake = std::stof(cmds[2]) * BRAKE_MAX_VAL;
-    msg.gear = std::stoi(cmds[3]);
-    int blinker = std::stoi(cmds[4]);
-    msg.mode = std::stoi(cmds[5]);
-    int hev_mode = std::stoi(cmds[6]);
-    msg.emergency = std::stoi(cmds[7]);
-    remote_cmd_pub_.publish(msg);
+    if(cmds.size() == 8) {
+      autoware_msgs::RemoteCmd msg;
+      msg.steer = std::stof(cmds[0]) * STEER_MAX_VAL;
+      msg.accel = std::stof(cmds[1]) * ACCEL_MAX_VAL;
+      msg.brake = std::stof(cmds[2]) * BRAKE_MAX_VAL;
+      msg.gear = std::stoi(cmds[3]);
+      int blinker = std::stoi(cmds[4]);
+      msg.mode = std::stoi(cmds[5]);
+      int hev_mode = std::stoi(cmds[6]);
+      msg.emergency = std::stoi(cmds[7]);
+      remote_cmd_pub_.publish(msg);
+    }
+    else {
+      ROS_INFO("Failed to parse remote command.\n");
+    }
   }
 }
 
 int main(int argc, char **argv)
 {
-  ros::init(argc, argv, "mqtt_receiver", ros::init_options::NoSigintHandler);
-  signal(SIGINT, mySigIntHandler);
+  ros::init(argc, argv, "mqtt_receiver");
   MqttReceiver node;
-
-  while (!g_request_shutdown)
-  {
-    sleep(1);
-  }
+  ros::spin();
 
   return 0;
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="490415c10e3d03aaf3b66c41153b6985ec996367" author="AMC">
		<msg>Added Estima model</msg>
		<modified_files>
			<file old_path="ros\src\.config\model\estima_left.png" new_path="ros\src\.config\model\estima_left.png" added_lines="0" deleted_lines="0">
				<diff>Binary files /dev/null and b/ros/src/.config/model/estima_left.png differ
</diff>
			</file>
			<file old_path="ros\src\.config\model\estima_right.png" new_path="ros\src\.config\model\estima_right.png" added_lines="0" deleted_lines="0">
				<diff>Binary files /dev/null and b/ros/src/.config/model/estima_right.png differ
</diff>
			</file>
			<file old_path="ros\src\.config\model\estima_white.jpg" new_path="ros\src\.config\model\estima_white.jpg" added_lines="0" deleted_lines="0">
				<diff>Binary files /dev/null and b/ros/src/.config/model/estima_white.jpg differ
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d984edfa4c020bd0d7952fdcca3f183201337ac7" author="AMC">
		<msg>Added 2 more color models
Updated files and launch files</msg>
		<modified_files>
			<file old_path="ros\src\.config\model\estima_bg_black.jpg" new_path="ros\src\.config\model\estima_bg_black.jpg" added_lines="0" deleted_lines="0">
				<diff>Binary files /dev/null and b/ros/src/.config/model/estima_bg_black.jpg differ
</diff>
			</file>
			<file old_path="ros\src\.config\model\estima_bg_gray.jpg" new_path="ros\src\.config\model\estima_bg_gray.jpg" added_lines="0" deleted_lines="0">
				<diff>Binary files /dev/null and b/ros/src/.config/model/estima_bg_gray.jpg differ
</diff>
			</file>
			<file old_path="ros\src\.config\model\estima_bg_white.jpg" new_path="ros\src\.config\model\estima_bg_white.jpg" added_lines="0" deleted_lines="0">
				<diff>Binary files /dev/null and b/ros/src/.config/model/estima_bg_white.jpg differ
</diff>
			</file>
			<file old_path="ros\src\.config\model\estima.dae" new_path="ros\src\.config\model\estima_black.dae" added_lines="3" deleted_lines="3">
				<diff>@@ -2,9 +2,9 @@
 &lt;COLLADA xmlns="http://www.collada.org/2005/11/COLLADASchema" version="1.4.1"&gt;
   &lt;asset&gt;&lt;contributor&gt;&lt;author&gt;&lt;/author&gt;&lt;authoring_tool&gt;FBX COLLADA exporter&lt;/authoring_tool&gt;&lt;comments&gt;&lt;/comments&gt;&lt;/contributor&gt;&lt;created&gt;2017-10-12T16:27:15Z&lt;/created&gt;&lt;keywords&gt;&lt;/keywords&gt;&lt;modified&gt;2017-10-12T16:27:15Z&lt;/modified&gt;&lt;revision&gt;&lt;/revision&gt;&lt;subject&gt;&lt;/subject&gt;&lt;title&gt;&lt;/title&gt;&lt;unit meter="0.010000" name="centimeter"&gt;&lt;/unit&gt;&lt;up_axis&gt;Y_UP&lt;/up_axis&gt;&lt;/asset&gt;
   &lt;library_images&gt;
-    &lt;image id="pasted__pasted__file1-image" name="pasted__pasted__file1"&gt;&lt;init_from&gt;estima_left.png&lt;/init_from&gt;&lt;/image&gt;
-    &lt;image id="pasted__pasted__file2-image" name="pasted__pasted__file2"&gt;&lt;init_from&gt;estima_right.png&lt;/init_from&gt;&lt;/image&gt;
-    &lt;image id="pasted__pasted__file3-image" name="pasted__pasted__file3"&gt;&lt;init_from&gt;estima_white.jpg&lt;/init_from&gt;&lt;/image&gt;
+    &lt;image id="pasted__pasted__file1-image" name="pasted__pasted__file1"&gt;&lt;init_from&gt;estima_left_black.jpg&lt;/init_from&gt;&lt;/image&gt;
+    &lt;image id="pasted__pasted__file2-image" name="pasted__pasted__file2"&gt;&lt;init_from&gt;estima_right_black.jpg&lt;/init_from&gt;&lt;/image&gt;
+    &lt;image id="pasted__pasted__file3-image" name="pasted__pasted__file3"&gt;&lt;init_from&gt;estima_bg_black.jpg&lt;/init_from&gt;&lt;/image&gt;
   &lt;/library_images&gt;
   &lt;library_materials&gt;
     &lt;material id="pasted__pasted__blinn2" name="pasted__pasted__blinn2"&gt;
</diff>
			</file>
			<file old_path="ros\src\.config\model\estima.urdf" new_path="ros\src\.config\model\estima_gray.urdf" added_lines="1" deleted_lines="1">
				<diff>@@ -4,7 +4,7 @@
     &lt;visual name="base_visual"&gt;
       &lt;origin xyz="1 0 0.0" rpy="1.57 0 4.71" /&gt;
       &lt;geometry&gt;
-        &lt;mesh filename="package://model_publisher/../../../.config/model/estima.dae" scale="1.0 1.0 1.0"/&gt;
+        &lt;mesh filename="package://model_publisher/../../../.config/model/estima_gray.dae" scale="1.0 1.0 1.0"/&gt;
       &lt;/geometry&gt;
     &lt;/visual&gt;
   &lt;/link&gt;
</diff>
			</file>
			<file old_path="ros\src\.config\model\estima_left.png" new_path="ros\src\.config\model\estima_left.png" added_lines="0" deleted_lines="0">
				<diff>Binary files a/ros/src/.config/model/estima_left.png and /dev/null differ
</diff>
			</file>
			<file old_path="ros\src\.config\model\estima_left_black.jpg" new_path="ros\src\.config\model\estima_left_black.jpg" added_lines="0" deleted_lines="0">
				<diff>Binary files /dev/null and b/ros/src/.config/model/estima_left_black.jpg differ
</diff>
			</file>
			<file old_path="ros\src\.config\model\estima_left_gray.jpg" new_path="ros\src\.config\model\estima_left_gray.jpg" added_lines="0" deleted_lines="0">
				<diff>Binary files /dev/null and b/ros/src/.config/model/estima_left_gray.jpg differ
</diff>
			</file>
			<file old_path="ros\src\.config\model\estima_left_white.jpg" new_path="ros\src\.config\model\estima_left_white.jpg" added_lines="0" deleted_lines="0">
				<diff>Binary files /dev/null and b/ros/src/.config/model/estima_left_white.jpg differ
</diff>
			</file>
			<file old_path="ros\src\.config\model\estima_right.png" new_path="ros\src\.config\model\estima_right.png" added_lines="0" deleted_lines="0">
				<diff>Binary files a/ros/src/.config/model/estima_right.png and /dev/null differ
</diff>
			</file>
			<file old_path="ros\src\.config\model\estima_right_black.jpg" new_path="ros\src\.config\model\estima_right_black.jpg" added_lines="0" deleted_lines="0">
				<diff>Binary files /dev/null and b/ros/src/.config/model/estima_right_black.jpg differ
</diff>
			</file>
			<file old_path="ros\src\.config\model\estima_right_gray.jpg" new_path="ros\src\.config\model\estima_right_gray.jpg" added_lines="0" deleted_lines="0">
				<diff>Binary files /dev/null and b/ros/src/.config/model/estima_right_gray.jpg differ
</diff>
			</file>
			<file old_path="ros\src\.config\model\estima_right_white.jpg" new_path="ros\src\.config\model\estima_right_white.jpg" added_lines="0" deleted_lines="0">
				<diff>Binary files /dev/null and b/ros/src/.config/model/estima_right_white.jpg differ
</diff>
			</file>
			<file old_path="ros\src\.config\model\estima_white.jpg" new_path="ros\src\.config\model\estima_white.jpg" added_lines="0" deleted_lines="0">
				<diff>Binary files a/ros/src/.config/model/estima_white.jpg and /dev/null differ
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="fa646c3cabd33da12f254708066c41f76f9d4db9" author="AMC">
		<msg>Added brightness to the model</msg>
		<modified_files>
			<file old_path="ros\src\.config\model\estima_black.dae" new_path="ros\src\.config\model\estima_black.dae" added_lines="7" deleted_lines="7">
				<diff>@@ -1,6 +1,6 @@
 &lt;?xml version="1.0" encoding="utf-8"?&gt;
 &lt;COLLADA xmlns="http://www.collada.org/2005/11/COLLADASchema" version="1.4.1"&gt;
-  &lt;asset&gt;&lt;contributor&gt;&lt;author&gt;&lt;/author&gt;&lt;authoring_tool&gt;FBX COLLADA exporter&lt;/authoring_tool&gt;&lt;comments&gt;&lt;/comments&gt;&lt;/contributor&gt;&lt;created&gt;2017-10-12T16:27:15Z&lt;/created&gt;&lt;keywords&gt;&lt;/keywords&gt;&lt;modified&gt;2017-10-12T16:27:15Z&lt;/modified&gt;&lt;revision&gt;&lt;/revision&gt;&lt;subject&gt;&lt;/subject&gt;&lt;title&gt;&lt;/title&gt;&lt;unit meter="0.010000" name="centimeter"&gt;&lt;/unit&gt;&lt;up_axis&gt;Y_UP&lt;/up_axis&gt;&lt;/asset&gt;
+  &lt;asset&gt;&lt;contributor&gt;&lt;author&gt;&lt;/author&gt;&lt;authoring_tool&gt;FBX COLLADA exporter&lt;/authoring_tool&gt;&lt;comments&gt;&lt;/comments&gt;&lt;/contributor&gt;&lt;created&gt;2017-10-13T16:02:50Z&lt;/created&gt;&lt;keywords&gt;&lt;/keywords&gt;&lt;modified&gt;2017-10-13T16:02:50Z&lt;/modified&gt;&lt;revision&gt;&lt;/revision&gt;&lt;subject&gt;&lt;/subject&gt;&lt;title&gt;&lt;/title&gt;&lt;unit meter="0.010000" name="centimeter"&gt;&lt;/unit&gt;&lt;up_axis&gt;Y_UP&lt;/up_axis&gt;&lt;/asset&gt;
   &lt;library_images&gt;
     &lt;image id="pasted__pasted__file1-image" name="pasted__pasted__file1"&gt;&lt;init_from&gt;estima_left_black.jpg&lt;/init_from&gt;&lt;/image&gt;
     &lt;image id="pasted__pasted__file2-image" name="pasted__pasted__file2"&gt;&lt;init_from&gt;estima_right_black.jpg&lt;/init_from&gt;&lt;/image&gt;
@@ -289,7 +289,7 @@
               &lt;color sid="emission"&gt;0.000000  0.000000 0.000000 1.000000&lt;/color&gt;
             &lt;/emission&gt;
             &lt;ambient&gt;
-              &lt;color sid="ambient"&gt;0.000000  0.000000 0.000000 1.000000&lt;/color&gt;
+              &lt;color sid="ambient"&gt;0.444450  0.444450 0.444450 1.000000&lt;/color&gt;
             &lt;/ambient&gt;
             &lt;diffuse&gt;
               &lt;texture texture="pasted__pasted__file1-image" texcoord="CHANNEL0"&gt;
@@ -332,7 +332,7 @@
               &lt;color sid="emission"&gt;0.000000  0.000000 0.000000 1.000000&lt;/color&gt;
             &lt;/emission&gt;
             &lt;ambient&gt;
-              &lt;color sid="ambient"&gt;0.000000  0.000000 0.000000 1.000000&lt;/color&gt;
+              &lt;color sid="ambient"&gt;0.410254  0.410254 0.410254 1.000000&lt;/color&gt;
             &lt;/ambient&gt;
             &lt;diffuse&gt;
               &lt;texture texture="pasted__pasted__file2-image" texcoord="CHANNEL0"&gt;
@@ -445,7 +445,7 @@
               &lt;color sid="emission"&gt;0.000000  0.000000 0.000000 1.000000&lt;/color&gt;
             &lt;/emission&gt;
             &lt;ambient&gt;
-              &lt;color sid="ambient"&gt;0.000000  0.000000 0.000000 1.000000&lt;/color&gt;
+              &lt;color sid="ambient"&gt;0.435904  0.435904 0.435904 1.000000&lt;/color&gt;
             &lt;/ambient&gt;
             &lt;diffuse&gt;
               &lt;texture texture="pasted__pasted__file3-image" texcoord="CHANNEL0"&gt;
@@ -158233,12 +158233,12 @@
     &lt;/geometry&gt;
   &lt;/library_geometries&gt;
   &lt;library_visual_scenes&gt;
-    &lt;visual_scene id="Estima" name="Estima"&gt;
-      &lt;node name="group" id="group" sid="group"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;node name="pasted__group" id="pasted__group" sid="pasted__group"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;node name="pasted__pasted__polySurface1262" id="pasted__pasted__polySurface1262" sid="pasted__pasted__polySurface1262"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 103.223572 0.000000 1.000000 0.000000 -7.917723 0.000000 0.000000 1.000000 161.941971 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;node name="pasted__pasted__transform2" id="pasted__pasted__transform2" sid="pasted__pasted__transform2"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;0.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;/node&gt;&lt;/node&gt;&lt;node name="webpage1_polySurface88" id="webpage1_polySurface88" sid="webpage1_polySurface88"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 6.547816 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;node name="pasted__pasted__transform1" id="pasted__pasted__transform1" sid="pasted__pasted__transform1"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;0.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;/node&gt;&lt;/node&gt;&lt;node name="pasted__pasted__polySurface1263" id="pasted__pasted__polySurface1263" sid="pasted__pasted__polySurface1263"&gt;&lt;matrix sid="matrix"&gt;3.210565 0.000000 0.000000 -332.619232 0.000000 3.210565 0.000000 25.076717 0.000000 0.000000 3.210565 -726.949219 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;instance_geometry url="#pasted__pasted__polySurface1263-lib"&gt;&lt;bind_material&gt;&lt;technique_common&gt;&lt;instance_material symbol="pasted__pasted__blinn2" target="#pasted__pasted__blinn2"/&gt;&lt;instance_material symbol="pasted__pasted__lambert2" target="#pasted__pasted__lambert2"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_M_0131_Silver1" target="#webpage_Smart_Driver1_M_0131_Silver1"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_Body_Color1" target="#webpage_Smart_Driver1_Body_Color1"/&gt;&lt;instance_material symbol="webpage_pasted__pasted__blinn2" target="#webpage_pasted__pasted__blinn2"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_M_0136_Charcoal1" target="#webpage_Smart_Driver1_M_0136_Charcoal1"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_Brake_Rotors1" target="#webpage_Smart_Driver1_Brake_Rotors1"/&gt;&lt;instance_material symbol="pasted__pasted__blinn6" target="#pasted__pasted__blinn6"/&gt;&lt;instance_material symbol="pasted__pasted__blinn4" target="#pasted__pasted__blinn4"/&gt;&lt;instance_material symbol="pasted__pasted__blinn3" target="#pasted__pasted__blinn3"/&gt;&lt;instance_material symbol="pasted__pasted__blinn1" target="#pasted__pasted__blinn1"/&gt;&lt;instance_material symbol="pasted__pasted__blinn5" target="#pasted__pasted__blinn5"/&gt;&lt;instance_material symbol="webpage1_car1_VRayMtl2" target="#webpage1_car1_VRayMtl2"/&gt;&lt;/technique_common&gt;&lt;/bind_material&gt;&lt;/instance_geometry&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;/node&gt;&lt;/node&gt;&lt;/node&gt;
+    &lt;visual_scene id="EstimaSizeW" name="EstimaSizeW"&gt;
+      &lt;node name="group" id="group" sid="group"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;node name="pasted__group" id="pasted__group" sid="pasted__group"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;node name="pasted__pasted__polySurface1263" id="pasted__pasted__polySurface1263" sid="pasted__pasted__polySurface1263"&gt;&lt;matrix sid="matrix"&gt;3.210565 0.000000 0.000000 -332.619232 0.000000 3.210565 0.000000 25.076717 0.000000 0.000000 3.210565 -726.949219 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;instance_geometry url="#pasted__pasted__polySurface1263-lib"&gt;&lt;bind_material&gt;&lt;technique_common&gt;&lt;instance_material symbol="pasted__pasted__blinn2" target="#pasted__pasted__blinn2"/&gt;&lt;instance_material symbol="pasted__pasted__lambert2" target="#pasted__pasted__lambert2"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_M_0131_Silver1" target="#webpage_Smart_Driver1_M_0131_Silver1"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_Body_Color1" target="#webpage_Smart_Driver1_Body_Color1"/&gt;&lt;instance_material symbol="webpage_pasted__pasted__blinn2" target="#webpage_pasted__pasted__blinn2"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_M_0136_Charcoal1" target="#webpage_Smart_Driver1_M_0136_Charcoal1"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_Brake_Rotors1" target="#webpage_Smart_Driver1_Brake_Rotors1"/&gt;&lt;instance_material symbol="pasted__pasted__blinn6" target="#pasted__pasted__blinn6"/&gt;&lt;instance_material symbol="pasted__pasted__blinn4" target="#pasted__pasted__blinn4"/&gt;&lt;instance_material symbol="pasted__pasted__blinn3" target="#pasted__pasted__blinn3"/&gt;&lt;instance_material symbol="pasted__pasted__blinn1" target="#pasted__pasted__blinn1"/&gt;&lt;instance_material symbol="pasted__pasted__blinn5" target="#pasted__pasted__blinn5"/&gt;&lt;instance_material symbol="webpage1_car1_VRayMtl2" target="#webpage1_car1_VRayMtl2"/&gt;&lt;/technique_common&gt;&lt;/bind_material&gt;&lt;/instance_geometry&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;/node&gt;&lt;/node&gt;&lt;/node&gt;
       &lt;extra&gt;&lt;technique profile="MAX3D"&gt;&lt;frame_rate&gt;24.000000&lt;/frame_rate&gt;&lt;/technique&gt;&lt;technique profile="FCOLLADA"&gt;&lt;start_time&gt;0.041667&lt;/start_time&gt;&lt;end_time&gt;2.000000&lt;/end_time&gt;&lt;/technique&gt;&lt;/extra&gt;
     &lt;/visual_scene&gt;
   &lt;/library_visual_scenes&gt;
   &lt;scene&gt;
-    &lt;instance_visual_scene url="#Estima"&gt;&lt;/instance_visual_scene&gt;
+    &lt;instance_visual_scene url="#EstimaSizeW"&gt;&lt;/instance_visual_scene&gt;
   &lt;/scene&gt;
 &lt;/COLLADA&gt;
</diff>
			</file>
			<file old_path="ros\src\.config\model\estima_gray.dae" new_path="ros\src\.config\model\estima_gray.dae" added_lines="7" deleted_lines="7">
				<diff>@@ -1,6 +1,6 @@
 &lt;?xml version="1.0" encoding="utf-8"?&gt;
 &lt;COLLADA xmlns="http://www.collada.org/2005/11/COLLADASchema" version="1.4.1"&gt;
-  &lt;asset&gt;&lt;contributor&gt;&lt;author&gt;&lt;/author&gt;&lt;authoring_tool&gt;FBX COLLADA exporter&lt;/authoring_tool&gt;&lt;comments&gt;&lt;/comments&gt;&lt;/contributor&gt;&lt;created&gt;2017-10-12T16:27:15Z&lt;/created&gt;&lt;keywords&gt;&lt;/keywords&gt;&lt;modified&gt;2017-10-12T16:27:15Z&lt;/modified&gt;&lt;revision&gt;&lt;/revision&gt;&lt;subject&gt;&lt;/subject&gt;&lt;title&gt;&lt;/title&gt;&lt;unit meter="0.010000" name="centimeter"&gt;&lt;/unit&gt;&lt;up_axis&gt;Y_UP&lt;/up_axis&gt;&lt;/asset&gt;
+  &lt;asset&gt;&lt;contributor&gt;&lt;author&gt;&lt;/author&gt;&lt;authoring_tool&gt;FBX COLLADA exporter&lt;/authoring_tool&gt;&lt;comments&gt;&lt;/comments&gt;&lt;/contributor&gt;&lt;created&gt;2017-10-13T16:02:50Z&lt;/created&gt;&lt;keywords&gt;&lt;/keywords&gt;&lt;modified&gt;2017-10-13T16:02:50Z&lt;/modified&gt;&lt;revision&gt;&lt;/revision&gt;&lt;subject&gt;&lt;/subject&gt;&lt;title&gt;&lt;/title&gt;&lt;unit meter="0.010000" name="centimeter"&gt;&lt;/unit&gt;&lt;up_axis&gt;Y_UP&lt;/up_axis&gt;&lt;/asset&gt;
   &lt;library_images&gt;
     &lt;image id="pasted__pasted__file1-image" name="pasted__pasted__file1"&gt;&lt;init_from&gt;estima_left_gray.jpg&lt;/init_from&gt;&lt;/image&gt;
     &lt;image id="pasted__pasted__file2-image" name="pasted__pasted__file2"&gt;&lt;init_from&gt;estima_right_gray.jpg&lt;/init_from&gt;&lt;/image&gt;
@@ -289,7 +289,7 @@
               &lt;color sid="emission"&gt;0.000000  0.000000 0.000000 1.000000&lt;/color&gt;
             &lt;/emission&gt;
             &lt;ambient&gt;
-              &lt;color sid="ambient"&gt;0.000000  0.000000 0.000000 1.000000&lt;/color&gt;
+              &lt;color sid="ambient"&gt;0.444450  0.444450 0.444450 1.000000&lt;/color&gt;
             &lt;/ambient&gt;
             &lt;diffuse&gt;
               &lt;texture texture="pasted__pasted__file1-image" texcoord="CHANNEL0"&gt;
@@ -332,7 +332,7 @@
               &lt;color sid="emission"&gt;0.000000  0.000000 0.000000 1.000000&lt;/color&gt;
             &lt;/emission&gt;
             &lt;ambient&gt;
-              &lt;color sid="ambient"&gt;0.000000  0.000000 0.000000 1.000000&lt;/color&gt;
+              &lt;color sid="ambient"&gt;0.410254  0.410254 0.410254 1.000000&lt;/color&gt;
             &lt;/ambient&gt;
             &lt;diffuse&gt;
               &lt;texture texture="pasted__pasted__file2-image" texcoord="CHANNEL0"&gt;
@@ -445,7 +445,7 @@
               &lt;color sid="emission"&gt;0.000000  0.000000 0.000000 1.000000&lt;/color&gt;
             &lt;/emission&gt;
             &lt;ambient&gt;
-              &lt;color sid="ambient"&gt;0.000000  0.000000 0.000000 1.000000&lt;/color&gt;
+              &lt;color sid="ambient"&gt;0.435904  0.435904 0.435904 1.000000&lt;/color&gt;
             &lt;/ambient&gt;
             &lt;diffuse&gt;
               &lt;texture texture="pasted__pasted__file3-image" texcoord="CHANNEL0"&gt;
@@ -158233,12 +158233,12 @@
     &lt;/geometry&gt;
   &lt;/library_geometries&gt;
   &lt;library_visual_scenes&gt;
-    &lt;visual_scene id="Estima" name="Estima"&gt;
-      &lt;node name="group" id="group" sid="group"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;node name="pasted__group" id="pasted__group" sid="pasted__group"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;node name="pasted__pasted__polySurface1262" id="pasted__pasted__polySurface1262" sid="pasted__pasted__polySurface1262"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 103.223572 0.000000 1.000000 0.000000 -7.917723 0.000000 0.000000 1.000000 161.941971 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;node name="pasted__pasted__transform2" id="pasted__pasted__transform2" sid="pasted__pasted__transform2"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;0.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;/node&gt;&lt;/node&gt;&lt;node name="webpage1_polySurface88" id="webpage1_polySurface88" sid="webpage1_polySurface88"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 6.547816 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;node name="pasted__pasted__transform1" id="pasted__pasted__transform1" sid="pasted__pasted__transform1"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;0.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;/node&gt;&lt;/node&gt;&lt;node name="pasted__pasted__polySurface1263" id="pasted__pasted__polySurface1263" sid="pasted__pasted__polySurface1263"&gt;&lt;matrix sid="matrix"&gt;3.210565 0.000000 0.000000 -332.619232 0.000000 3.210565 0.000000 25.076717 0.000000 0.000000 3.210565 -726.949219 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;instance_geometry url="#pasted__pasted__polySurface1263-lib"&gt;&lt;bind_material&gt;&lt;technique_common&gt;&lt;instance_material symbol="pasted__pasted__blinn2" target="#pasted__pasted__blinn2"/&gt;&lt;instance_material symbol="pasted__pasted__lambert2" target="#pasted__pasted__lambert2"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_M_0131_Silver1" target="#webpage_Smart_Driver1_M_0131_Silver1"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_Body_Color1" target="#webpage_Smart_Driver1_Body_Color1"/&gt;&lt;instance_material symbol="webpage_pasted__pasted__blinn2" target="#webpage_pasted__pasted__blinn2"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_M_0136_Charcoal1" target="#webpage_Smart_Driver1_M_0136_Charcoal1"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_Brake_Rotors1" target="#webpage_Smart_Driver1_Brake_Rotors1"/&gt;&lt;instance_material symbol="pasted__pasted__blinn6" target="#pasted__pasted__blinn6"/&gt;&lt;instance_material symbol="pasted__pasted__blinn4" target="#pasted__pasted__blinn4"/&gt;&lt;instance_material symbol="pasted__pasted__blinn3" target="#pasted__pasted__blinn3"/&gt;&lt;instance_material symbol="pasted__pasted__blinn1" target="#pasted__pasted__blinn1"/&gt;&lt;instance_material symbol="pasted__pasted__blinn5" target="#pasted__pasted__blinn5"/&gt;&lt;instance_material symbol="webpage1_car1_VRayMtl2" target="#webpage1_car1_VRayMtl2"/&gt;&lt;/technique_common&gt;&lt;/bind_material&gt;&lt;/instance_geometry&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;/node&gt;&lt;/node&gt;&lt;/node&gt;
+    &lt;visual_scene id="EstimaSizeW" name="EstimaSizeW"&gt;
+      &lt;node name="group" id="group" sid="group"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;node name="pasted__group" id="pasted__group" sid="pasted__group"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;node name="pasted__pasted__polySurface1263" id="pasted__pasted__polySurface1263" sid="pasted__pasted__polySurface1263"&gt;&lt;matrix sid="matrix"&gt;3.210565 0.000000 0.000000 -332.619232 0.000000 3.210565 0.000000 25.076717 0.000000 0.000000 3.210565 -726.949219 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;instance_geometry url="#pasted__pasted__polySurface1263-lib"&gt;&lt;bind_material&gt;&lt;technique_common&gt;&lt;instance_material symbol="pasted__pasted__blinn2" target="#pasted__pasted__blinn2"/&gt;&lt;instance_material symbol="pasted__pasted__lambert2" target="#pasted__pasted__lambert2"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_M_0131_Silver1" target="#webpage_Smart_Driver1_M_0131_Silver1"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_Body_Color1" target="#webpage_Smart_Driver1_Body_Color1"/&gt;&lt;instance_material symbol="webpage_pasted__pasted__blinn2" target="#webpage_pasted__pasted__blinn2"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_M_0136_Charcoal1" target="#webpage_Smart_Driver1_M_0136_Charcoal1"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_Brake_Rotors1" target="#webpage_Smart_Driver1_Brake_Rotors1"/&gt;&lt;instance_material symbol="pasted__pasted__blinn6" target="#pasted__pasted__blinn6"/&gt;&lt;instance_material symbol="pasted__pasted__blinn4" target="#pasted__pasted__blinn4"/&gt;&lt;instance_material symbol="pasted__pasted__blinn3" target="#pasted__pasted__blinn3"/&gt;&lt;instance_material symbol="pasted__pasted__blinn1" target="#pasted__pasted__blinn1"/&gt;&lt;instance_material symbol="pasted__pasted__blinn5" target="#pasted__pasted__blinn5"/&gt;&lt;instance_material symbol="webpage1_car1_VRayMtl2" target="#webpage1_car1_VRayMtl2"/&gt;&lt;/technique_common&gt;&lt;/bind_material&gt;&lt;/instance_geometry&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;/node&gt;&lt;/node&gt;&lt;/node&gt;
       &lt;extra&gt;&lt;technique profile="MAX3D"&gt;&lt;frame_rate&gt;24.000000&lt;/frame_rate&gt;&lt;/technique&gt;&lt;technique profile="FCOLLADA"&gt;&lt;start_time&gt;0.041667&lt;/start_time&gt;&lt;end_time&gt;2.000000&lt;/end_time&gt;&lt;/technique&gt;&lt;/extra&gt;
     &lt;/visual_scene&gt;
   &lt;/library_visual_scenes&gt;
   &lt;scene&gt;
-    &lt;instance_visual_scene url="#Estima"&gt;&lt;/instance_visual_scene&gt;
+    &lt;instance_visual_scene url="#EstimaSizeW"&gt;&lt;/instance_visual_scene&gt;
   &lt;/scene&gt;
 &lt;/COLLADA&gt;
</diff>
			</file>
			<file old_path="ros\src\.config\model\estima_white.dae" new_path="ros\src\.config\model\estima_white.dae" added_lines="7" deleted_lines="7">
				<diff>@@ -1,6 +1,6 @@
 &lt;?xml version="1.0" encoding="utf-8"?&gt;
 &lt;COLLADA xmlns="http://www.collada.org/2005/11/COLLADASchema" version="1.4.1"&gt;
-  &lt;asset&gt;&lt;contributor&gt;&lt;author&gt;&lt;/author&gt;&lt;authoring_tool&gt;FBX COLLADA exporter&lt;/authoring_tool&gt;&lt;comments&gt;&lt;/comments&gt;&lt;/contributor&gt;&lt;created&gt;2017-10-12T16:27:15Z&lt;/created&gt;&lt;keywords&gt;&lt;/keywords&gt;&lt;modified&gt;2017-10-12T16:27:15Z&lt;/modified&gt;&lt;revision&gt;&lt;/revision&gt;&lt;subject&gt;&lt;/subject&gt;&lt;title&gt;&lt;/title&gt;&lt;unit meter="0.010000" name="centimeter"&gt;&lt;/unit&gt;&lt;up_axis&gt;Y_UP&lt;/up_axis&gt;&lt;/asset&gt;
+  &lt;asset&gt;&lt;contributor&gt;&lt;author&gt;&lt;/author&gt;&lt;authoring_tool&gt;FBX COLLADA exporter&lt;/authoring_tool&gt;&lt;comments&gt;&lt;/comments&gt;&lt;/contributor&gt;&lt;created&gt;2017-10-13T16:02:50Z&lt;/created&gt;&lt;keywords&gt;&lt;/keywords&gt;&lt;modified&gt;2017-10-13T16:02:50Z&lt;/modified&gt;&lt;revision&gt;&lt;/revision&gt;&lt;subject&gt;&lt;/subject&gt;&lt;title&gt;&lt;/title&gt;&lt;unit meter="0.010000" name="centimeter"&gt;&lt;/unit&gt;&lt;up_axis&gt;Y_UP&lt;/up_axis&gt;&lt;/asset&gt;
   &lt;library_images&gt;
     &lt;image id="pasted__pasted__file1-image" name="pasted__pasted__file1"&gt;&lt;init_from&gt;estima_left_white.jpg&lt;/init_from&gt;&lt;/image&gt;
     &lt;image id="pasted__pasted__file2-image" name="pasted__pasted__file2"&gt;&lt;init_from&gt;estima_right_white.jpg&lt;/init_from&gt;&lt;/image&gt;
@@ -289,7 +289,7 @@
               &lt;color sid="emission"&gt;0.000000  0.000000 0.000000 1.000000&lt;/color&gt;
             &lt;/emission&gt;
             &lt;ambient&gt;
-              &lt;color sid="ambient"&gt;0.000000  0.000000 0.000000 1.000000&lt;/color&gt;
+              &lt;color sid="ambient"&gt;0.444450  0.444450 0.444450 1.000000&lt;/color&gt;
             &lt;/ambient&gt;
             &lt;diffuse&gt;
               &lt;texture texture="pasted__pasted__file1-image" texcoord="CHANNEL0"&gt;
@@ -332,7 +332,7 @@
               &lt;color sid="emission"&gt;0.000000  0.000000 0.000000 1.000000&lt;/color&gt;
             &lt;/emission&gt;
             &lt;ambient&gt;
-              &lt;color sid="ambient"&gt;0.000000  0.000000 0.000000 1.000000&lt;/color&gt;
+              &lt;color sid="ambient"&gt;0.410254  0.410254 0.410254 1.000000&lt;/color&gt;
             &lt;/ambient&gt;
             &lt;diffuse&gt;
               &lt;texture texture="pasted__pasted__file2-image" texcoord="CHANNEL0"&gt;
@@ -445,7 +445,7 @@
               &lt;color sid="emission"&gt;0.000000  0.000000 0.000000 1.000000&lt;/color&gt;
             &lt;/emission&gt;
             &lt;ambient&gt;
-              &lt;color sid="ambient"&gt;0.000000  0.000000 0.000000 1.000000&lt;/color&gt;
+              &lt;color sid="ambient"&gt;0.435904  0.435904 0.435904 1.000000&lt;/color&gt;
             &lt;/ambient&gt;
             &lt;diffuse&gt;
               &lt;texture texture="pasted__pasted__file3-image" texcoord="CHANNEL0"&gt;
@@ -158233,12 +158233,12 @@
     &lt;/geometry&gt;
   &lt;/library_geometries&gt;
   &lt;library_visual_scenes&gt;
-    &lt;visual_scene id="Estima" name="Estima"&gt;
-      &lt;node name="group" id="group" sid="group"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;node name="pasted__group" id="pasted__group" sid="pasted__group"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;node name="pasted__pasted__polySurface1262" id="pasted__pasted__polySurface1262" sid="pasted__pasted__polySurface1262"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 103.223572 0.000000 1.000000 0.000000 -7.917723 0.000000 0.000000 1.000000 161.941971 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;node name="pasted__pasted__transform2" id="pasted__pasted__transform2" sid="pasted__pasted__transform2"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;0.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;/node&gt;&lt;/node&gt;&lt;node name="webpage1_polySurface88" id="webpage1_polySurface88" sid="webpage1_polySurface88"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 6.547816 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;node name="pasted__pasted__transform1" id="pasted__pasted__transform1" sid="pasted__pasted__transform1"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;0.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;/node&gt;&lt;/node&gt;&lt;node name="pasted__pasted__polySurface1263" id="pasted__pasted__polySurface1263" sid="pasted__pasted__polySurface1263"&gt;&lt;matrix sid="matrix"&gt;3.210565 0.000000 0.000000 -332.619232 0.000000 3.210565 0.000000 25.076717 0.000000 0.000000 3.210565 -726.949219 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;instance_geometry url="#pasted__pasted__polySurface1263-lib"&gt;&lt;bind_material&gt;&lt;technique_common&gt;&lt;instance_material symbol="pasted__pasted__blinn2" target="#pasted__pasted__blinn2"/&gt;&lt;instance_material symbol="pasted__pasted__lambert2" target="#pasted__pasted__lambert2"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_M_0131_Silver1" target="#webpage_Smart_Driver1_M_0131_Silver1"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_Body_Color1" target="#webpage_Smart_Driver1_Body_Color1"/&gt;&lt;instance_material symbol="webpage_pasted__pasted__blinn2" target="#webpage_pasted__pasted__blinn2"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_M_0136_Charcoal1" target="#webpage_Smart_Driver1_M_0136_Charcoal1"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_Brake_Rotors1" target="#webpage_Smart_Driver1_Brake_Rotors1"/&gt;&lt;instance_material symbol="pasted__pasted__blinn6" target="#pasted__pasted__blinn6"/&gt;&lt;instance_material symbol="pasted__pasted__blinn4" target="#pasted__pasted__blinn4"/&gt;&lt;instance_material symbol="pasted__pasted__blinn3" target="#pasted__pasted__blinn3"/&gt;&lt;instance_material symbol="pasted__pasted__blinn1" target="#pasted__pasted__blinn1"/&gt;&lt;instance_material symbol="pasted__pasted__blinn5" target="#pasted__pasted__blinn5"/&gt;&lt;instance_material symbol="webpage1_car1_VRayMtl2" target="#webpage1_car1_VRayMtl2"/&gt;&lt;/technique_common&gt;&lt;/bind_material&gt;&lt;/instance_geometry&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;/node&gt;&lt;/node&gt;&lt;/node&gt;
+    &lt;visual_scene id="EstimaSizeW" name="EstimaSizeW"&gt;
+      &lt;node name="group" id="group" sid="group"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;node name="pasted__group" id="pasted__group" sid="pasted__group"&gt;&lt;matrix sid="matrix"&gt;1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;node name="pasted__pasted__polySurface1263" id="pasted__pasted__polySurface1263" sid="pasted__pasted__polySurface1263"&gt;&lt;matrix sid="matrix"&gt;3.210565 0.000000 0.000000 -332.619232 0.000000 3.210565 0.000000 25.076717 0.000000 0.000000 3.210565 -726.949219 0.000000 0.000000 0.000000 1.000000&lt;/matrix&gt;&lt;instance_geometry url="#pasted__pasted__polySurface1263-lib"&gt;&lt;bind_material&gt;&lt;technique_common&gt;&lt;instance_material symbol="pasted__pasted__blinn2" target="#pasted__pasted__blinn2"/&gt;&lt;instance_material symbol="pasted__pasted__lambert2" target="#pasted__pasted__lambert2"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_M_0131_Silver1" target="#webpage_Smart_Driver1_M_0131_Silver1"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_Body_Color1" target="#webpage_Smart_Driver1_Body_Color1"/&gt;&lt;instance_material symbol="webpage_pasted__pasted__blinn2" target="#webpage_pasted__pasted__blinn2"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_M_0136_Charcoal1" target="#webpage_Smart_Driver1_M_0136_Charcoal1"/&gt;&lt;instance_material symbol="webpage_Smart_Driver1_Brake_Rotors1" target="#webpage_Smart_Driver1_Brake_Rotors1"/&gt;&lt;instance_material symbol="pasted__pasted__blinn6" target="#pasted__pasted__blinn6"/&gt;&lt;instance_material symbol="pasted__pasted__blinn4" target="#pasted__pasted__blinn4"/&gt;&lt;instance_material symbol="pasted__pasted__blinn3" target="#pasted__pasted__blinn3"/&gt;&lt;instance_material symbol="pasted__pasted__blinn1" target="#pasted__pasted__blinn1"/&gt;&lt;instance_material symbol="pasted__pasted__blinn5" target="#pasted__pasted__blinn5"/&gt;&lt;instance_material symbol="webpage1_car1_VRayMtl2" target="#webpage1_car1_VRayMtl2"/&gt;&lt;/technique_common&gt;&lt;/bind_material&gt;&lt;/instance_geometry&gt;&lt;extra&gt;&lt;technique profile="FCOLLADA"&gt;&lt;visibility&gt;1.000000&lt;/visibility&gt;&lt;/technique&gt;&lt;/extra&gt;&lt;/node&gt;&lt;/node&gt;&lt;/node&gt;
       &lt;extra&gt;&lt;technique profile="MAX3D"&gt;&lt;frame_rate&gt;24.000000&lt;/frame_rate&gt;&lt;/technique&gt;&lt;technique profile="FCOLLADA"&gt;&lt;start_time&gt;0.041667&lt;/start_time&gt;&lt;end_time&gt;2.000000&lt;/end_time&gt;&lt;/technique&gt;&lt;/extra&gt;
     &lt;/visual_scene&gt;
   &lt;/library_visual_scenes&gt;
   &lt;scene&gt;
-    &lt;instance_visual_scene url="#Estima"&gt;&lt;/instance_visual_scene&gt;
+    &lt;instance_visual_scene url="#EstimaSizeW"&gt;&lt;/instance_visual_scene&gt;
   &lt;/scene&gt;
 &lt;/COLLADA&gt;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="41ef8c2918716757f312068dd099339985cd6645" author="Yuki Iida">
		<msg>update layout and add blinker button</msg>
		<modified_files>
			<file old_path="ui\web\remote_monitor\public\css\button.css" new_path="ui\web\remote_monitor\public\css\button.css" added_lines="19" deleted_lines="1">
				<diff>@@ -28,7 +28,7 @@
 
 .flat_ss .btnttl {
   display: inline-block;
-  width: 200px;
+  width: 300px;
   text-align: center;
   vertical-align: middle;
 }
@@ -319,3 +319,21 @@ select::-ms-expand {
   right: 15px;
   width: 20px;
 }
+
+/*Squre Button*/
+.square_btn {
+display: inline-block;
+padding: 0.3em 1em;
+text-decoration: none;
+color: #67c5ff;
+width: 90%;
+height: 3vw;
+text-align: center;
+border: solid 2px #67c5ff;
+border-radius: 3px;
+transition: .4s;
+background: white;
+}.square_btn:hover {
+background: yellow;
+color: black;
+}
</diff>
			</file>
			<file old_path="ui\web\remote_monitor\public\css\main.css" new_path="ui\web\remote_monitor\public\css\main.css" added_lines="2" deleted_lines="2">
				<diff>@@ -45,11 +45,11 @@ header {
 }
 
 .row-top {
-  height: 34%;
+  height: 23%;
 }
 
 .row-center {
-  height: 34%;
+  height: 45%;
 }
 .row-bottom {
   height: 23%;
</diff>
			</file>
			<file old_path="ui\web\remote_monitor\template\index.html" new_path="ui\web\remote_monitor\template\index.html" added_lines="14" deleted_lines="0">
				<diff>@@ -46,5 +46,19 @@
           &lt;/a&gt;
         &lt;/center&gt;
       &lt;/div&gt;
+      &lt;div class="col-sm-12 col-xs-12"&gt;
+        &lt;center&gt;
+          &lt;a href="/demo_vehicle" class="flat_ss"&gt;
+              &lt;span class="iconback car"&gt;&lt;i class="fa fa-car"&gt;&lt;/i&gt;&lt;/span&gt;&lt;span class="btnttl"&gt;VEHICLE for DEMO&lt;/span&gt;
+          &lt;/a&gt;
+        &lt;/center&gt;
+      &lt;/div&gt;
+      &lt;div class="col-sm-12 col-xs-12"&gt;
+        &lt;center&gt;
+          &lt;a href="/demo_operator" class="flat_ss"&gt;
+              &lt;span class="iconback operator"&gt;&lt;i class="fa fa-user"&gt;&lt;/i&gt;&lt;/span&gt;&lt;span class="btnttl"&gt;OPERATOR for DEMO&lt;/span&gt;
+          &lt;/a&gt;
+        &lt;/center&gt;
+      &lt;/div&gt;
     &lt;/div&gt;
 &lt;/div&gt;
</diff>
			</file>
			<file old_path="ui\web\remote_monitor\template\operator_window.html" new_path="ui\web\remote_monitor\template\operator_window.html" added_lines="17" deleted_lines="21">
				<diff>@@ -18,10 +18,10 @@
   &lt;script src="/js/bootstrap.min.js"&gt;&lt;/script&gt;
   &lt;script src="socket.io/socket.io.js"&gt;&lt;/script&gt;
   &lt;script src="/js/webrtc_polyfill.js"&gt;&lt;/script&gt;
-  &lt;script src="/js/uuid.core.js"&gt;&lt;/script&gt;
   &lt;script src="/js/utility.js"&gt;&lt;/script&gt;
   &lt;script src="/js/remote_ui.js"&gt;&lt;/script&gt;
   &lt;script src="/js/gamepad.js"&gt;&lt;/script&gt;
+  &lt;script src="/js/vehicle_button.js"&gt;&lt;/script&gt;
 &lt;/head&gt;
 
 &lt;body&gt;
@@ -75,7 +75,7 @@
         &lt;/div&gt;
       &lt;/div&gt;
 
-      &lt;div class="col-lg-4 col-md-4 col-sm-4 col-xs-4"&gt;
+      &lt;div class="col-lg-6 col-md-6 col-sm-6 col-xs-6"&gt;
         &lt;div class="streamItemContainer"&gt;
           &lt;video id="remoteView2"&gt;&lt;/video&gt;
         &lt;/div&gt;
@@ -86,12 +86,6 @@
           &lt;video id="remoteView5"&gt;&lt;/video&gt;
         &lt;/div&gt;
       &lt;/div&gt;
-
-      &lt;div class="col-lg-2 col-md-2 col-sm-2 col-xs-2"&gt;
-        &lt;div class="streamItemContainer"&gt;
-          &lt;video id="remoteView6"&gt;&lt;/video&gt;
-        &lt;/div&gt;
-      &lt;/div&gt;
     &lt;/div&gt;
 
     &lt;!-- UI Second row --&gt;
@@ -102,7 +96,7 @@
         &lt;/div&gt;
       &lt;/div&gt;
 
-      &lt;div class="col-lg-4 col-md-4 col-sm-4 col-xs-4"&gt;
+      &lt;div class="col-lg-6 col-md-6 col-sm-6 col-xs-6"&gt;
         &lt;div class="streamItemContainer"&gt;
           &lt;video id="remoteView1"&gt;&lt;/video&gt;
         &lt;/div&gt;
@@ -113,17 +107,6 @@
           &lt;video id="remoteView4"&gt;&lt;/video&gt;
         &lt;/div&gt;
       &lt;/div&gt;
-
-      &lt;div class="col-lg-2 col-md-2 col-sm-2 col-xs-2"&gt;
-        &lt;div class="streamItemContainer"&gt;
-          &lt;span class="btnRemoveStream glyphicon glyphicon-remove" style="display:none" id="btnRemoveStream1" data-no="1" title="DELETE"&gt;&lt;/span&gt;&lt;br /&gt;
-          &lt;button class="btnAddStream" id="btnAddStream1" data-no="1"&gt;
-            &lt;span class="glyphicon glyphicon-remove r45"&gt;&lt;/span&gt;&lt;br /&gt;
-            &lt;span&gt;Add Operator Camera&lt;/span&gt;
-          &lt;/button&gt;
-          &lt;video id="localView1"&gt;&lt;/video&gt;
-        &lt;/div&gt;
-      &lt;/div&gt;
     &lt;/div&gt;
 
     &lt;!-- UI Third row --&gt;
@@ -168,7 +151,7 @@
               &lt;option value="1"&gt;D&lt;/option&gt;
               &lt;option value="2"&gt;R&lt;/option&gt;
               &lt;option value="3"&gt;N&lt;/option&gt;
-              &lt;option value="3"&gt;B&lt;/option&gt;
+              &lt;option value="4"&gt;B&lt;/option&gt;
             &lt;/select&gt;
           &lt;/div&gt;
         &lt;/div&gt;
@@ -188,6 +171,19 @@
               &lt;span class="modeswitch-inner"&gt;&lt;/span&gt;
           &lt;/label&gt;
         &lt;/div&gt;
+
+        &lt;div class="row"&gt;
+          &lt;div class="col-lg-4 col-md-4 col-sm-4 col-xs-4"&gt;
+            &lt;input id="blinker_left" type="button" class="square_btn" value="" onclick="pushBlinker(1)"&gt;
+          &lt;/div&gt;
+          &lt;div class="col-lg-4 col-md-4 col-sm-4 col-xs-4"&gt;
+            &lt;input id="blinker_hazard" type="button" class="square_btn" value="" onclick="pushBlinker(3)"&gt;
+          &lt;/div&gt;
+          &lt;div class="col-lg-4 col-md-4 col-sm-4 col-xs-4"&gt;
+            &lt;input id="blinker_right" type="button" class="square_btn" value="" onclick="pushBlinker(2)"&gt;
+          &lt;/div&gt;
+        &lt;/div&gt;
+
       &lt;/div&gt;
     &lt;/div&gt;
   &lt;/div&gt;
</diff>
			</file>
			<file old_path="ui\web\remote_monitor\template\vehicle_window.html" new_path="ui\web\remote_monitor\template\vehicle_window.html" added_lines="7" deleted_lines="24">
				<diff>@@ -18,7 +18,6 @@
   &lt;script src="/js/bootstrap.min.js"&gt;&lt;/script&gt;
   &lt;script src="socket.io/socket.io.js"&gt;&lt;/script&gt;
   &lt;script src="/js/webrtc_polyfill.js"&gt;&lt;/script&gt;
-  &lt;script src="/js/uuid.core.js"&gt;&lt;/script&gt;
   &lt;script src="/js/utility.js"&gt;&lt;/script&gt;
   &lt;script src="/js/remote_ui.js"&gt;&lt;/script&gt;
 &lt;/head&gt;
@@ -74,7 +73,7 @@
         &lt;/div&gt;
       &lt;/div&gt;
 
-      &lt;div class="col-lg-4 col-md-4 col-sm-4 col-xs-4"&gt;
+      &lt;div class="col-lg-6 col-md-6 col-sm-6 col-xs-6"&gt;
         &lt;div class="streamItemContainer"&gt;
           &lt;span class="btnRemoveStream glyphicon glyphicon-remove" style="display:none" id="btnRemoveStream2" data-no="2" title="DELETE"&gt;&lt;/span&gt;&lt;br /&gt;
           &lt;button class="btnAddStream" id="btnAddStream2" data-no="2"&gt;
@@ -90,23 +89,12 @@
           &lt;span class="btnRemoveStream glyphicon glyphicon-remove" style="display:none" id="btnRemoveStream5" data-no="5" title="DELETE"&gt;&lt;/span&gt;&lt;br /&gt;
           &lt;button class="btnAddStream" id="btnAddStream5" data-no="5"&gt;
             &lt;span class="glyphicon glyphicon-remove r45"&gt;&lt;/span&gt;&lt;br /&gt;
-            &lt;span&gt;Add Internal Camera&lt;/span&gt;
+            &lt;span&gt;Add Dashboard Camera&lt;/span&gt;
           &lt;/button&gt;
           &lt;video id="localView5"&gt;&lt;/video&gt;
         &lt;/div&gt;
       &lt;/div&gt;
 
-      &lt;div class="col-lg-2 col-md-2 col-sm-2 col-xs-2"&gt;
-        &lt;div class="streamItemContainer"&gt;
-          &lt;span class="btnRemoveStream glyphicon glyphicon-remove" style="display:none" id="btnRemoveStream6" data-no="6" title="DELETE"&gt;&lt;/span&gt;&lt;br /&gt;
-          &lt;button class="btnAddStream" id="btnAddStream6" data-no="6"&gt;
-            &lt;span class="glyphicon glyphicon-remove r45"&gt;&lt;/span&gt;&lt;br /&gt;
-            &lt;span&gt;Add Instrument Panel Camera&lt;/span&gt;
-          &lt;/button&gt;
-          &lt;video id="localView6"&gt;&lt;/video&gt;
-        &lt;/div&gt;
-      &lt;/div&gt;
-
     &lt;/div&gt;
 
     &lt;!-- UI Second row --&gt;
@@ -122,7 +110,7 @@
         &lt;/div&gt;
       &lt;/div&gt;
 
-      &lt;div class="col-lg-4 col-md-4 col-sm-4 col-xs-4"&gt;
+      &lt;div class="col-lg-6 col-md-6 col-sm-6 col-xs-6"&gt;
         &lt;div class="streamItemContainer"&gt;
           &lt;span class="btnRemoveStream glyphicon glyphicon-remove" style="display:none" id="btnRemoveStream1" data-no="1" title="DELETE"&gt;&lt;/span&gt;&lt;br /&gt;
           &lt;button class="btnAddStream" id="btnAddStream1" data-no="1"&gt;
@@ -143,12 +131,6 @@
           &lt;video id="localView4"&gt;&lt;/video&gt;
         &lt;/div&gt;
       &lt;/div&gt;
-
-      &lt;div class="col-lg-2 col-md-2 col-sm-2 col-xs-2"&gt;
-        &lt;div class="streamItemContainer"&gt;
-          &lt;video id="remoteView1"&gt;&lt;/video&gt;
-        &lt;/div&gt;
-      &lt;/div&gt;
     &lt;/div&gt;
 
     &lt;!-- UI Third row --&gt;
@@ -181,9 +163,10 @@
             &lt;h4&gt;Gear&lt;/h4&gt;
             &lt;select name="gear" id="gear" onChange="select_gear(this);"&gt;
               &lt;option value="0"&gt;P&lt;/option&gt;
-              &lt;option value="1"&gt;N&lt;/option&gt;
-              &lt;option value="2"&gt;D&lt;/option&gt;
-              &lt;option value="3"&gt;R&lt;/option&gt;
+              &lt;option value="1"&gt;D&lt;/option&gt;
+              &lt;option value="2"&gt;R&lt;/option&gt;
+              &lt;option value="3"&gt;N&lt;/option&gt;
+              &lt;option value="4"&gt;B&lt;/option&gt;
             &lt;/select&gt;
           &lt;/div&gt;
         &lt;/div&gt;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8798b2b5996ef03fe0e1152d1111cf2c2bb227d8" author="Yuki Iida">
		<msg>refactor msg and add blinker to msg</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" added_lines="9" deleted_lines="18">
				<diff>@@ -80,7 +80,7 @@ class TwistGate
     ros::Duration timeout_period_;
 
     std::thread watchdog_timer_thread_;
-    enum class CommandMode{AUTO=3, REMOTE=4} command_mode_;
+    enum class CommandMode{AUTO=1, REMOTE=2} command_mode_;
 };
 
 TwistGate::TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_nh) :
@@ -121,6 +121,7 @@ void TwistGate::reset_select_cmd_msg()
   twist_gate_msg_.angular_z       = 0;
   twist_gate_msg_.mode            = 0;
   twist_gate_msg_.gear            = 0;
+  twist_gate_msg_.blinker         = 0;
   twist_gate_msg_.accel           = 0;
   twist_gate_msg_.brake           = 0;
   twist_gate_msg_.steer           = 0;
@@ -138,20 +139,20 @@ void TwistGate::watchdog_timer()
     // if lost Communication
     if(command_mode_ == CommandMode::REMOTE &amp;&amp; now_time - remote_cmd_time_ &gt;  timeout_period_) {
       emergency_flag = true;
-      std::cout &lt;&lt; "Lost Communication!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" &lt;&lt; std::endl;
+      std::cout &lt;&lt; "Lost Communication!" &lt;&lt; std::endl;
     }
 
     if(emergency_stop_msg_.data == true)
     {
       emergency_flag = true;
-      std::cout &lt;&lt; "Emergency Mode!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" &lt;&lt; std::endl;
+      std::cout &lt;&lt; "Emergency Mode!" &lt;&lt; std::endl;
     }
 
     if(emergency_flag) {
       command_mode_ = CommandMode::AUTO;
       emergency_stop_msg_.data = true;
       emergency_stop_pub_.publish(emergency_stop_msg_);
-      std::cout &lt;&lt; "Emergency Stop!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" &lt;&lt; std::endl;
+      std::cout &lt;&lt; "Emergency Stop!" &lt;&lt; std::endl;
     }
 
     std::this_thread::sleep_for(std::chrono::milliseconds(10));
@@ -164,14 +165,12 @@ void TwistGate::watchdog_timer()
 
 void TwistGate::remote_cmd_callback(const remote_msgs_t::ConstPtr&amp; input_msg)
 {
-  command_mode_ = static_cast&lt;CommandMode&gt;(input_msg-&gt;mode);
-  twist_gate_msg_.mode = input_msg-&gt;mode;
+  command_mode_ = static_cast&lt;CommandMode&gt;(input_msg-&gt;control_mode);
   emergency_stop_msg_.data = static_cast&lt;bool&gt;(input_msg-&gt;emergency);
   remote_cmd_time_ = ros::Time::now();
 
   if(command_mode_ == CommandMode::REMOTE)
   {
-    std::cout &lt;&lt; "Remote Comannd!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" &lt;&lt; std::endl;
     twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
     twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
     twist_gate_msg_.header.seq++;
@@ -181,19 +180,12 @@ void TwistGate::remote_cmd_callback(const remote_msgs_t::ConstPtr&amp; input_msg)
     twist_gate_msg_.accel = input_msg-&gt;accel;
     twist_gate_msg_.brake = input_msg-&gt;brake;
     twist_gate_msg_.steer = input_msg-&gt;steer;
-    // twist_gate_msg_.gear = input_msg-&gt;gear;
-    twist_gate_msg_.gear = 0;
-    // twist_gate_msg_.mode = input_msg-&gt;mode;
-    twist_gate_msg_.mode = 0;
+    twist_gate_msg_.gear = input_msg-&gt;gear;
+    twist_gate_msg_.blinker = input_msg-&gt;blinker;
+    twist_gate_msg_.mode = input_msg-&gt;mode;
     twist_gate_msg_.emergency = input_msg-&gt;emergency;
     select_cmd_pub_.publish(twist_gate_msg_);
   }
-  // if(twist_gate_msg_.emergency == 1)
-  // {
-  //   emergency_stop_msg_.data = true;
-  //   emergency_stop_pub_.publish(emergency_stop_msg_);
-  //   std::cout &lt;&lt; "emergency_stop!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" &lt;&lt; std::endl;
-  // }
 }
 
 void TwistGate::auto_cmd_twist_cmd_callback(const geometry_msgs::TwistStamped::ConstPtr&amp; input_msg)
@@ -280,7 +272,6 @@ void TwistGate::auto_cmd_ctrl_cmd_callback(const autoware_msgs::ControlCommandSt
     twist_gate_msg_.linear_velocity = input_msg-&gt;cmd.linear_velocity;
     twist_gate_msg_.steering_angle = input_msg-&gt;cmd.steering_angle;
     select_cmd_pub_.publish(twist_gate_msg_);
-    std::cout &lt;&lt; "Control Comannd!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" &lt;&lt; std::endl;
   }
 }
 
</diff>
			</file>
			<file old_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_receiver\mqtt_receiver.cpp" new_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_receiver\mqtt_receiver.cpp" added_lines="3" deleted_lines="4">
				<diff>@@ -68,7 +68,7 @@ MqttReceiver::MqttReceiver() :
     node_handle_("~")
 {
   // ROS Publisher
-  remote_cmd_pub_ = node_handle_.advertise&lt;autoware_msgs::RemoteCmd&gt;("/remote_cmd", 5);
+  remote_cmd_pub_ = node_handle_.advertise&lt;autoware_msgs::RemoteCmd&gt;("/remote_cmd", 1);
 
   // MQTT PARAMS
   mosquitto_lib_init();
@@ -124,7 +124,6 @@ static void MqttReceiver::on_disconnect(struct mosquitto *mosq, void *obj, int r
 static void MqttReceiver::on_message(struct mosquitto *mosq, void *obj, const struct mosquitto_message *message)
 {
   if(message-&gt;payloadlen) {
-    ROS_INFO("%s ", message-&gt;topic);
     std::string delim (",");
     std::string msg_str((char *)message-&gt;payload, message-&gt;payloadlen);
     std::vector&lt;std::string&gt; cmds;
@@ -136,9 +135,9 @@ static void MqttReceiver::on_message(struct mosquitto *mosq, void *obj, const st
       msg.accel = std::stof(cmds[1]) * ACCEL_MAX_VAL;
       msg.brake = std::stof(cmds[2]) * BRAKE_MAX_VAL;
       msg.gear = std::stoi(cmds[3]);
-      int blinker = std::stoi(cmds[4]);
+      msg.blinker = std::stoi(cmds[4]);
       msg.mode = std::stoi(cmds[5]);
-      int hev_mode = std::stoi(cmds[6]);
+      msg.control_mode = std::stoi(cmds[6]);
       msg.emergency = std::stoi(cmds[7]);
       remote_cmd_pub_.publish(msg);
     }
</diff>
			</file>
			<file old_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_sender\vehicle_sender.cpp" new_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_sender\vehicle_sender.cpp" added_lines="10" deleted_lines="7">
				<diff>@@ -46,6 +46,7 @@ struct CommandData {
   double angular_z;
   int modeValue;
   int gearValue;
+  int blinkerValue;
   int accellValue;
   int brakeValue;
   int steerValue;
@@ -57,13 +58,14 @@ struct CommandData {
 
 void CommandData::reset()
 {
-  linear_x    = 0;
-  angular_z   = 0;
-  modeValue   = 0;
-  gearValue   = 0;
-  accellValue = 0;
-  brakeValue  = 0;
-  steerValue  = 0;
+  linear_x      = 0;
+  angular_z     = 0;
+  modeValue     = 0;
+  gearValue     = 0;
+  blinkerValue  = 0;
+  accellValue   = 0;
+  brakeValue    = 0;
+  steerValue    = 0;
   linear_velocity = -1;
   steering_angle = 0;
 }
@@ -76,6 +78,7 @@ static void twistGateCallback(const autoware_msgs::TwistGate&amp; msg)
   command_data.angular_z = msg.angular_z;
   command_data.modeValue = msg.mode;
   command_data.gearValue = msg.gear;
+  command_data.blinkerValue = msg.blinker;
   command_data.accellValue = msg.accel;
   command_data.steerValue = msg.steer;
   command_data.brakeValue = msg.brake;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="45004a4ad29c424dc385fe5919026898922433e5" author="Yuki Iida">
		<msg>change max speed of remote control</msg>
		<modified_files>
			<file old_path="ros\src\socket\packages\mqtt_socket\include\mqtt_socket\mqtt_setting.hpp" new_path="ros\src\socket\packages\mqtt_socket\include\mqtt_socket\mqtt_setting.hpp" added_lines="1" deleted_lines="1">
				<diff>@@ -13,7 +13,7 @@
 #define REMOTE_MODE     2
 #define NORMAL_MODE     0
 #define EMERGENCY_MODE  1
-#define ACCEL_MAX_VAL   5 // km/h
+#define ACCEL_MAX_VAL   15 * 1000 / 60 / 60 // 15 km/h
 #define BRAKE_MAX_VAL   10000
 #define STEER_MAX_VAL   0.6
 #define DOWNSAMPLE      0.1
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="42e12bb59fc85107701eeeed76ede66bb79b7577" author="Yuki Iida">
		<msg>refactor code and add ctrl mode topic</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" added_lines="25" deleted_lines="6">
				<diff>@@ -35,6 +35,7 @@
 
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
+#include &lt;std_msgs/String.h&gt;
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 
 #include "autoware_msgs/RemoteCmd.h"
@@ -70,6 +71,7 @@ class TwistGate
     ros::NodeHandle nh_;
     ros::NodeHandle private_nh_;
     ros::Publisher emergency_stop_pub_;
+    ros::Publisher control_command_pub_;
     ros::Publisher select_cmd_pub_;
     ros::Subscriber remote_cmd_sub_;
     std::map&lt;std::string , ros::Subscriber&gt; auto_cmd_sub_stdmap_;
@@ -80,16 +82,19 @@ class TwistGate
     ros::Duration timeout_period_;
 
     std::thread watchdog_timer_thread_;
-    enum class CommandMode{AUTO=1, REMOTE=2} command_mode_;
+    enum class CommandMode{AUTO=1, REMOTE=2} command_mode_, previous_command_mode_;
+    std_msgs::String command_mode_topic_;
 };
 
 TwistGate::TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_nh) :
      nh_(nh)
     ,private_nh_(private_nh)
     ,timeout_period_(1.0)
-    ,command_mode_(CommandMode::REMOTE)
+    ,command_mode_(CommandMode::AUTO)
+    ,previous_command_mode_(CommandMode::AUTO)
 {
   emergency_stop_pub_ = nh_.advertise&lt;std_msgs::Bool&gt;("/emergency_stop", 1, true);
+  control_command_pub_ = nh_.advertise&lt;std_msgs::String&gt;("/ctrl_mode", 1);
   select_cmd_pub_ = nh_.advertise&lt;twist_gate_msgs_t&gt;("/select_cmd", 1, true);
 
   remote_cmd_sub_ = nh_.subscribe("/remote_cmd", 1, &amp;TwistGate::remote_cmd_callback, this);
@@ -136,18 +141,36 @@ void TwistGate::watchdog_timer()
     ros::Time now_time = ros::Time::now();
     bool emergency_flag = false;
 
+    // check command mode
+    if(previous_command_mode_ != command_mode_) {
+      if(command_mode_ == CommandMode::AUTO) {
+        command_mode_topic_.data = "AUTO";
+      }
+      else if(command_mode_ == CommandMode::REMOTE) {
+        command_mode_topic_.data = "REMOTE";
+      }
+      else{
+        command_mode_topic_.data = "UNDEFINED";
+      }
+
+      control_command_pub_.publish(command_mode_topic_);
+      previous_command_mode_ = command_mode_;
+    }
+
     // if lost Communication
     if(command_mode_ == CommandMode::REMOTE &amp;&amp; now_time - remote_cmd_time_ &gt;  timeout_period_) {
       emergency_flag = true;
       std::cout &lt;&lt; "Lost Communication!" &lt;&lt; std::endl;
     }
 
+    // if push emergency stop button
     if(emergency_stop_msg_.data == true)
     {
       emergency_flag = true;
       std::cout &lt;&lt; "Emergency Mode!" &lt;&lt; std::endl;
     }
 
+    // Emergency
     if(emergency_flag) {
       command_mode_ = CommandMode::AUTO;
       emergency_stop_msg_.data = true;
@@ -156,10 +179,6 @@ void TwistGate::watchdog_timer()
     }
 
     std::this_thread::sleep_for(std::chrono::milliseconds(10));
-    std::cout &lt;&lt; "c_mode:"     &lt;&lt; static_cast&lt;int&gt;(command_mode_)
-              &lt;&lt; " e_stop:"    &lt;&lt; static_cast&lt;bool&gt;(emergency_stop_msg_.data)
-              &lt;&lt; " diff_time:" &lt;&lt; (now_time - remote_cmd_time_).toSec()
-              &lt;&lt; std::endl;
   }
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="504e7c1dd1e243921a87975fd54e41a43f9d1b2b" author="Yusuke FUJII">
		<msg>Ensure compatibility of proprietary lib</msg>
		<modified_files>
			<file old_path="ros\src\actuation\vehicles\packages\ymc\node\g30esli_interface\can_utils\cansend.h" new_path="ros\src\actuation\vehicles\packages\ymc\include\can_utils\cansend.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\actuation\vehicles\packages\ymc\node\g30esli_interface\can_utils\cansend_util.h" new_path="ros\src\actuation\vehicles\packages\ymc\include\can_utils\cansend_util.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\actuation\vehicles\packages\ymc\node\g30esli_interface\can_utils\ymc_can.h" new_path="ros\src\actuation\vehicles\packages\ymc\include\can_utils\ymc_can.h" added_lines="3" deleted_lines="3">
				<diff>@@ -33,15 +33,15 @@
 
 #include &lt;iostream&gt;
 #include &lt;cstring&gt;
+#include &lt;vector&gt;
 
-#include &lt;ros/ros.h&gt;
-#include &lt;geometry_msgs/TwistStamped.h&gt;
+#define RET_NO_PUBLISH (double)-1.0
 
 namespace ymc
 {
 
 void setCanData(unsigned char* data, unsigned char d1, unsigned char d2, uint16_t d3, int16_t d4, unsigned char d5, unsigned char d6);
-void translateCanData(const int id, const std::vector&lt;std::string&gt;&amp; data, const ros::Publisher&amp; pub1, int* mode);
+double translateCanData(const int id, const std::vector&lt;std::string&gt;&amp; data, int* mode);
 
 }
 
</diff>
			</file>
			<file old_path="ros\src\actuation\vehicles\packages\ymc\node\g30esli_interface\g30esli_interface.cpp" new_path="ros\src\actuation\vehicles\packages\ymc\node\g30esli_interface\g30esli_interface.cpp" added_lines="8" deleted_lines="1">
				<diff>@@ -122,7 +122,14 @@ void readCanData(FILE* fp)
       data.erase(data.begin(), data.begin() + 3);
 
       int id = std::stoi(parsed_data.at(1), nullptr, 10);
-      ymc::translateCanData(id, data, g_current_twist_pub, &amp;g_mode);
+      double _current_vel_mps = ymc::translateCanData(id, data, &amp;g_mode);
+      if(_current_vel_mps != RET_NO_PUBLISH )
+      {
+	      geometry_msgs::TwistStamped ts;
+	      ts.twist.linear.x = _current_vel_mps;
+	      g_current_twist_pub.publish(ts);
+      } 
+      
     }
 
   }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="61e9e5cb256ee34a62b4bd04a3c5ddef50889218" author="Yusuke FUJII">
		<msg>Add to support manually decision</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" added_lines="5" deleted_lines="0">
				<diff>@@ -5,6 +5,7 @@
 #include &lt;iostream&gt;
 #include &lt;queue&gt;
 #include &lt;thread&gt;
+#include &lt;mutex&gt;
 #include &lt;unordered_map&gt;
 #include &lt;utility&gt;
 #include "state.hpp"
@@ -38,11 +39,15 @@ private:
 
   std::thread *thr_state_dec;
 
+
+  std::mutex change_state_mutex;
+
   void showStateMove(unsigned long long _state_num)
   {
     std::cout &lt;&lt; "State will be [" &lt;&lt; StateStores[_state_num]-&gt;getStateName() &lt;&lt; "]" &lt;&lt; std::endl;
   }
 
+
 public:
   StateContext(void)
   {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="4" deleted_lines="0">
				<diff>@@ -5,6 +5,7 @@
 #include &lt;vector&gt;
 
 #include &lt;cassert&gt;
+#include &lt;mutex&gt;
 
 #include &lt;euclidean_space.hpp&gt;
 #include &lt;state_context.hpp&gt;
@@ -62,6 +63,7 @@ std::string StateContext::getCurrentStateName(void)
  */
 bool StateContext::setCurrentState(BaseState *_state)
 {
+  change_state_mutex.lock();
   BaseState *prevState = current_state_.MainState;
 
   if (!prevState)
@@ -113,9 +115,11 @@ bool StateContext::setCurrentState(BaseState *_state)
                 &lt;&lt; _state-&gt;getStateName() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/"
                 &lt;&lt; current_state_.MainState-&gt;getStateNum() &lt;&lt; "-" &lt;&lt; _state-&gt;getStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
       prevState = nullptr;
+      change_state_mutex.unlock();
       return false;
     }
   }
+  change_state_mutex.unlock();
   return true;
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="6" deleted_lines="2">
				<diff>@@ -42,13 +42,17 @@ void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped
 
 bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
 {
-  return ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
+  bool _ret;
+  ctx-&gt;setEnableForceSetState(true);
+  _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
+  ctx-&gt;setEnableForceSetState(false);
+  return _ret;
 }
 
 void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
 {
   ROS_INFO("Received forcing state changing request");
-  handleStateCmd((unsigned long long)msg.data);
+  handleStateCmd((unsigned long long) 1 &lt;&lt; msg.data);
 }
 
 void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="4" deleted_lines="2">
				<diff>@@ -1,5 +1,6 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;ros/spinner.h&gt;
+#include &lt;std_msgs/Int32.h&gt;
 #include &lt;std_msgs/Float64.h&gt;
 #include &lt;std_msgs/Float64MultiArray.h&gt;
 #include &lt;std_msgs/String.h&gt;
@@ -43,6 +44,7 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   Subs["final_waypoints"] = nh_.subscribe("final_waypoints", 100, &amp;DecisionMakerNode::callbackFromFinalWaypoint, this);
   Subs["twist_cmd"] = nh_.subscribe("twist_cmd", 10, &amp;DecisionMakerNode::callbackFromTwistCmd, this);
   Subs["change_flag"] = nh_.subscribe("change_flag", 1, &amp;DecisionMakerNode::callbackFromLaneChangeFlag, this);
+  Subs["state_cmd"] = nh_.subscribe("state_cmd", 1, &amp;DecisionMakerNode::callbackFromStateCmd, this);
 
   // vector map subscriber
   Subs["vector_map_area"] =
@@ -87,8 +89,8 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   {
     std::cout &lt;&lt; "wait for tf of map to world" &lt;&lt; std::endl;
     tf::TransformListener tf;
-    tf.waitForTransform("map", "world", ros::Time(), ros::Duration(999));
-
+    
+    tf.waitForTransform("map", "world", ros::Time(), ros::Duration(15));
     if (!ctx-&gt;TFInitialized())
       std::cerr &lt;&lt; "failed initialization " &lt;&lt; std::endl;
   }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="091e9a032cd71f2abbd226acc1a9433b193ed4a7" author="Abraham Monrroy">
		<msg>[Feature] Updates to Pointgrey package/Ladybug node (#852)

* Added support for FindXerces on Indigo (and Cmake less than 3.1.3)
Changed default scaling value to 20% of original image size (to improve performance)
Changed published image format from RGB to Bayer(to reduce bag size)

* Tested on real camera, updated</msg>
		<modified_files>
			<file old_path="ros\src\sensing\drivers\camera\packages\pointgrey\nodes\ladybug\ladybug.cpp" new_path="ros\src\sensing\drivers\camera\packages\pointgrey\nodes\ladybug\ladybug.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -269,7 +269,7 @@ LadybugError unlock_image( unsigned int bufferIndex )
 int main (int argc, char **argv)
 {
 	////ROS STUFF
-	ros::init(argc, argv, "lady_bug");
+	ros::init(argc, argv, "ladybug_camera");
 	ros::NodeHandle n;
 	ros::NodeHandle private_nh("~");
 
@@ -316,8 +316,8 @@ int main (int argc, char **argv)
 	}
 	else
 	{
-		ROS_INFO("Ladybug ImageScale scale must be (0,100]. Defaulting to 100 ");
-		image_scale=100;
+		ROS_INFO("Ladybug ImageScale scale must be (0,100]. Defaulting to 20 ");
+		image_scale=20;
 	}
 
 	ros::Publisher camera_info_pub;
@@ -358,11 +358,12 @@ int main (int argc, char **argv)
 			std::ostringstream out;
 			out &lt;&lt; "image" &lt;&lt; i;
 			cv::Mat rawImage(size, CV_8UC1, currentImage.pData + (i * size.width*size.height));
-			//cv::flip(mat, mat, -1);
 			cv::Mat image(size, CV_8UC3);
 			cv::cvtColor(rawImage, image, cv::COLOR_BayerBG2RGB);
 			cv::resize(image,image,cv::Size(size.width*image_scale/100, size.height*image_scale/100));
+			//
 			cv::transpose(image, image);
+
 			if (i==0)
 				image.copyTo(full_size);
 			else
@@ -375,18 +376,17 @@ int main (int argc, char **argv)
 		}
 		//publish stitched one
 		publishImage(full_size, pub[0], count);
-
 		ros::spinOnce();
 		loop_rate.sleep();
 		count++;
 	}
 
-	cout &lt;&lt; "Stopping ladybug..." &lt;&lt; endl;
+	cout &lt;&lt; "Stopping ladybug_camera..." &lt;&lt; endl;
 
 	// Shutdown
 	stop_camera();
 
-	ROS_INFO("ladybug stopped");
+	ROS_INFO("ladybug_camera stopped");
 
 	return 0;
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="72df58c75dd8bcc025450104190e1882ad7437d5" author="Yuki Iida">
		<msg>refactor code</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" added_lines="17" deleted_lines="17">
				<diff>@@ -66,13 +66,13 @@ class TwistGate
     void auto_cmd_brake_cmd_callback(const autoware_msgs::brake_cmd::ConstPtr&amp; input_msg);
     void auto_cmd_ctrl_cmd_callback(const autoware_msgs::ControlCommandStamped::ConstPtr&amp; input_msg);
 
-    void reset_select_cmd_msg();
+    void reset_vehicle_cmd_msg();
 
     ros::NodeHandle nh_;
     ros::NodeHandle private_nh_;
     ros::Publisher emergency_stop_pub_;
     ros::Publisher control_command_pub_;
-    ros::Publisher select_cmd_pub_;
+    ros::Publisher vehicle_cmd_pub_;
     ros::Subscriber remote_cmd_sub_;
     std::map&lt;std::string , ros::Subscriber&gt; auto_cmd_sub_stdmap_;
 
@@ -95,7 +95,7 @@ TwistGate::TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_n
 {
   emergency_stop_pub_ = nh_.advertise&lt;std_msgs::Bool&gt;("/emergency_stop", 1, true);
   control_command_pub_ = nh_.advertise&lt;std_msgs::String&gt;("/ctrl_mode", 1);
-  select_cmd_pub_ = nh_.advertise&lt;twist_gate_msgs_t&gt;("/select_cmd", 1, true);
+  vehicle_cmd_pub_ = nh_.advertise&lt;twist_gate_msgs_t&gt;("/vehicle_cmd", 1, true);
 
   remote_cmd_sub_ = nh_.subscribe("/remote_cmd", 1, &amp;TwistGate::remote_cmd_callback, this);
 
@@ -120,7 +120,7 @@ TwistGate::~TwistGate()
 {
 }
 
-void TwistGate::reset_select_cmd_msg()
+void TwistGate::reset_vehicle_cmd_msg()
 {
   twist_gate_msg_.linear_x        = 0;
   twist_gate_msg_.angular_z       = 0;
@@ -160,14 +160,14 @@ void TwistGate::watchdog_timer()
     // if lost Communication
     if(command_mode_ == CommandMode::REMOTE &amp;&amp; now_time - remote_cmd_time_ &gt;  timeout_period_) {
       emergency_flag = true;
-      std::cout &lt;&lt; "Lost Communication!" &lt;&lt; std::endl;
+      ROS_WARN("Lost Communication!");
     }
 
     // if push emergency stop button
     if(emergency_stop_msg_.data == true)
     {
       emergency_flag = true;
-      std::cout &lt;&lt; "Emergency Mode!" &lt;&lt; std::endl;
+      ROS_WARN("Emergency Mode!");
     }
 
     // Emergency
@@ -175,7 +175,7 @@ void TwistGate::watchdog_timer()
       command_mode_ = CommandMode::AUTO;
       emergency_stop_msg_.data = true;
       emergency_stop_pub_.publish(emergency_stop_msg_);
-      std::cout &lt;&lt; "Emergency Stop!" &lt;&lt; std::endl;
+      ROS_WARN("Emergency Stop!");
     }
 
     std::this_thread::sleep_for(std::chrono::milliseconds(10));
@@ -194,7 +194,7 @@ void TwistGate::remote_cmd_callback(const remote_msgs_t::ConstPtr&amp; input_msg)
     twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
     twist_gate_msg_.header.seq++;
     twist_gate_msg_.linear_x = input_msg-&gt;accel;
-    twist_gate_msg_.angular_z = input_msg-&gt;steer;
+    twist_gate_msg_.angular_z = 0;
     twist_gate_msg_.steering_angle = input_msg-&gt;steer;
     twist_gate_msg_.accel = input_msg-&gt;accel;
     twist_gate_msg_.brake = input_msg-&gt;brake;
@@ -203,7 +203,7 @@ void TwistGate::remote_cmd_callback(const remote_msgs_t::ConstPtr&amp; input_msg)
     twist_gate_msg_.blinker = input_msg-&gt;blinker;
     twist_gate_msg_.mode = input_msg-&gt;mode;
     twist_gate_msg_.emergency = input_msg-&gt;emergency;
-    select_cmd_pub_.publish(twist_gate_msg_);
+    vehicle_cmd_pub_.publish(twist_gate_msg_);
   }
 }
 
@@ -216,7 +216,7 @@ void TwistGate::auto_cmd_twist_cmd_callback(const geometry_msgs::TwistStamped::C
     twist_gate_msg_.header.seq++;
     twist_gate_msg_.linear_x = input_msg-&gt;twist.linear.x;
     twist_gate_msg_.angular_z = input_msg-&gt;twist.angular.z;
-    select_cmd_pub_.publish(twist_gate_msg_);
+    vehicle_cmd_pub_.publish(twist_gate_msg_);
   }
 }
 
@@ -226,13 +226,13 @@ void TwistGate::auto_cmd_mode_cmd_callback(const tablet_socket_msgs::mode_cmd::C
   {
     //TODO:check this if statement
     if(input_msg-&gt;mode == -1 || input_msg-&gt;mode == 0){
-      reset_select_cmd_msg();
+      reset_vehicle_cmd_msg();
     }
     twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
     twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
     twist_gate_msg_.header.seq++;
     twist_gate_msg_.mode = input_msg-&gt;mode;
-    select_cmd_pub_.publish(twist_gate_msg_);
+    vehicle_cmd_pub_.publish(twist_gate_msg_);
   }
 }
 
@@ -241,7 +241,7 @@ void TwistGate::auto_cmd_gear_cmd_callback(const tablet_socket_msgs::gear_cmd::C
   if(command_mode_ == CommandMode::AUTO)
   {
     twist_gate_msg_.gear = input_msg-&gt;gear;
-    select_cmd_pub_.publish(twist_gate_msg_);
+    vehicle_cmd_pub_.publish(twist_gate_msg_);
   }
 }
 
@@ -253,7 +253,7 @@ void TwistGate::auto_cmd_accel_cmd_callback(const autoware_msgs::accel_cmd::Cons
     twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
     twist_gate_msg_.header.seq++;
     twist_gate_msg_.accel = input_msg-&gt;accel;
-    select_cmd_pub_.publish(twist_gate_msg_);
+    vehicle_cmd_pub_.publish(twist_gate_msg_);
   }
 }
 
@@ -265,7 +265,7 @@ void TwistGate::auto_cmd_steer_cmd_callback(const autoware_msgs::steer_cmd::Cons
     twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
     twist_gate_msg_.header.seq++;
     twist_gate_msg_.steer = input_msg-&gt;steer;
-    select_cmd_pub_.publish(twist_gate_msg_);
+    vehicle_cmd_pub_.publish(twist_gate_msg_);
   }
 }
 
@@ -277,7 +277,7 @@ void TwistGate::auto_cmd_brake_cmd_callback(const autoware_msgs::brake_cmd::Cons
     twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
     twist_gate_msg_.header.seq++;
     twist_gate_msg_.brake = input_msg-&gt;brake;
-    select_cmd_pub_.publish(twist_gate_msg_);
+    vehicle_cmd_pub_.publish(twist_gate_msg_);
   }
 }
 
@@ -290,7 +290,7 @@ void TwistGate::auto_cmd_ctrl_cmd_callback(const autoware_msgs::ControlCommandSt
     twist_gate_msg_.header.seq++;
     twist_gate_msg_.linear_velocity = input_msg-&gt;cmd.linear_velocity;
     twist_gate_msg_.steering_angle = input_msg-&gt;cmd.steering_angle;
-    select_cmd_pub_.publish(twist_gate_msg_);
+    vehicle_cmd_pub_.publish(twist_gate_msg_);
   }
 }
 
</diff>
			</file>
			<file old_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_receiver\mqtt_receiver.cpp" new_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_receiver\mqtt_receiver.cpp" added_lines="3" deleted_lines="4">
				<diff>@@ -38,7 +38,6 @@
 #include &lt;vector&gt;
 #include &lt;boost/algorithm/string.hpp&gt;
 #include &lt;string&gt;
-#include &lt;signal.h&gt;
 
 static struct mosquitto *mqtt_client_ = NULL;
 static std::string mqtt_topic_;
@@ -131,9 +130,9 @@ static void MqttReceiver::on_message(struct mosquitto *mosq, void *obj, const st
 
     if(cmds.size() == 8) {
       autoware_msgs::RemoteCmd msg;
-      msg.steer = std::stof(cmds[0]) * STEER_MAX_VAL;
-      msg.accel = std::stof(cmds[1]) * ACCEL_MAX_VAL;
-      msg.brake = std::stof(cmds[2]) * BRAKE_MAX_VAL;
+      msg.steer.steer = std::stof(cmds[0]) * STEER_MAX_VAL;
+      msg.accel.accel = std::stof(cmds[1]) * ACCEL_MAX_VAL;
+      msg.brake.brake = std::stof(cmds[2]) * BRAKE_MAX_VAL;
       msg.gear = std::stoi(cmds[3]);
       msg.blinker = std::stoi(cmds[4]);
       msg.mode = std::stoi(cmds[5]);
</diff>
			</file>
			<file old_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_sender\vehicle_sender.cpp" new_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_sender\vehicle_sender.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -186,7 +186,7 @@ int main(int argc, char **argv)
   ros::NodeHandle nh;
 
   std::cout &lt;&lt; "vehicle sender" &lt;&lt; std::endl;
-  ros::Subscriber sub = nh.subscribe("/select_cmd", 1, twistGateCallback);
+  ros::Subscriber sub = nh.subscribe("/vehicle_cmd", 1, twistGateCallback);
 
   command_data.reset();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ce8d2ac564a8ae12f05180e982009485e5dc7097" author="Yuki Kitsukawa">
		<msg>[fix] NDT_GPU ndt_localizer (#854)

* fix CMakeLists.txt of ndt_localizer

* Fixed CUDA/FAST_PCL conflict

* Fixed ndt_matching</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="9" deleted_lines="8">
				<diff>@@ -58,15 +58,16 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 
-#if defined(USE_FAST_PCL) &amp;&amp; defined(CUDA_FOUND)
-#include &lt;fast_pcl/filters/voxel_grid.h&gt;
-#include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
-#include &lt;fast_pcl/registration/ndt.h&gt;
+#ifdef USE_FAST_PCL
+  #include &lt;fast_pcl/filters/voxel_grid.h&gt;
+  #include &lt;fast_pcl/registration/ndt.h&gt;
+#else
+  #include &lt;pcl/filters/voxel_grid.h&gt;
+  #include &lt;pcl/registration/ndt.h&gt;
 #endif
 
-#ifndef USE_FAST_PCL
-#include &lt;pcl/filters/voxel_grid.h&gt;
-#include &lt;pcl/registration/ndt.h&gt;
+#ifdef CUDA_FOUND
+  #include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
 #endif
 
 #include &lt;autoware_msgs/ConfigNdtMapping.h&gt;
@@ -617,7 +618,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   {
     ndt.omp_align(*output_cloud, init_guess);
     t_localizer = ndt.getFinalTransformation();
-    has_converged = ndt.hasConverged;
+    has_converged = ndt.hasConverged();
     fitness_score = ndt.omp_getFitnessScore();
     final_num_iteration = ndt.getFinalNumIteration();
   }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -63,13 +63,13 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 
-#if defined(USE_FAST_PCL) &amp;&amp; defined(CUDA_FOUND)
-#include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
-#include &lt;fast_pcl/registration/ndt.h&gt;
+#ifdef USE_FAST_PCL
+  #include &lt;fast_pcl/registration/ndt.h&gt;
+#else
+  #include &lt;pcl/registration/ndt.h&gt;
 #endif
-
-#ifndef USE_FAST_PCL
-#include &lt;pcl/registration/ndt.h&gt;
+#ifdef CUDA_FOUND
+  #include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
 #endif
 
 #include &lt;pcl_ros/point_cloud.h&gt;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4fc0a255a5669e7082ab384a4da4579cba88e9fc" author="Yuki Iida">
		<msg>refactor code</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" added_lines="55" deleted_lines="42">
				<diff>@@ -59,12 +59,13 @@ class TwistGate
     void watchdog_timer();
     void remote_cmd_callback(const remote_msgs_t::ConstPtr&amp; input_msg);
     void auto_cmd_twist_cmd_callback(const geometry_msgs::TwistStamped::ConstPtr&amp; input_msg);
-    void auto_cmd_mode_cmd_callback(const tablet_socket_msgs::mode_cmd::ConstPtr&amp; input_msg);
-    void auto_cmd_gear_cmd_callback(const tablet_socket_msgs::gear_cmd::ConstPtr&amp; input_msg);
-    void auto_cmd_accel_cmd_callback(const autoware_msgs::accel_cmd::ConstPtr&amp; input_msg);
-    void auto_cmd_steer_cmd_callback(const autoware_msgs::steer_cmd::ConstPtr&amp; input_msg);
-    void auto_cmd_brake_cmd_callback(const autoware_msgs::brake_cmd::ConstPtr&amp; input_msg);
-    void auto_cmd_ctrl_cmd_callback(const autoware_msgs::ControlCommandStamped::ConstPtr&amp; input_msg);
+    void mode_cmd_callback(const tablet_socket_msgs::mode_cmd::ConstPtr&amp; input_msg);
+    void gear_cmd_callback(const tablet_socket_msgs::gear_cmd::ConstPtr&amp; input_msg);
+    void accel_cmd_callback(const autoware_msgs::accel_cmd::ConstPtr&amp; input_msg);
+    void steer_cmd_callback(const autoware_msgs::steer_cmd::ConstPtr&amp; input_msg);
+    void brake_cmd_callback(const autoware_msgs::brake_cmd::ConstPtr&amp; input_msg);
+    void lamp_cmd_callback(const autoware_msgs::lamp_cmd::ConstPtr&amp; input_msg);
+    void ctrl_cmd_callback(const autoware_msgs::ControlCommandStamped::ConstPtr&amp; input_msg);
 
     void reset_vehicle_cmd_msg();
 
@@ -100,12 +101,13 @@ TwistGate::TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_n
   remote_cmd_sub_ = nh_.subscribe("/remote_cmd", 1, &amp;TwistGate::remote_cmd_callback, this);
 
   auto_cmd_sub_stdmap_["twist_cmd"] = nh_.subscribe("/twist_cmd", 1, &amp;TwistGate::auto_cmd_twist_cmd_callback, this);
-  auto_cmd_sub_stdmap_["mode_cmd"] = nh_.subscribe("/mode_cmd", 1, &amp;TwistGate::auto_cmd_mode_cmd_callback, this);
-  auto_cmd_sub_stdmap_["gear_cmd"] = nh_.subscribe("/gear_cmd", 1, &amp;TwistGate::auto_cmd_gear_cmd_callback, this);
-  auto_cmd_sub_stdmap_["accel_cmd"] = nh_.subscribe("/accel_cmd", 1, &amp;TwistGate::auto_cmd_accel_cmd_callback, this);
-  auto_cmd_sub_stdmap_["steer_cmd"] = nh_.subscribe("/steer_cmd", 1, &amp;TwistGate::auto_cmd_steer_cmd_callback, this);
-  auto_cmd_sub_stdmap_["brake_cmd"] = nh_.subscribe("/brake_cmd", 1, &amp;TwistGate::auto_cmd_brake_cmd_callback, this);
-  auto_cmd_sub_stdmap_["ctrl_cmd"] = nh_.subscribe("/ctrl_cmd", 1, &amp;TwistGate::auto_cmd_ctrl_cmd_callback, this);
+  auto_cmd_sub_stdmap_["mode_cmd"] = nh_.subscribe("/mode_cmd", 1, &amp;TwistGate::mode_cmd_callback, this);
+  auto_cmd_sub_stdmap_["gear_cmd"] = nh_.subscribe("/gear_cmd", 1, &amp;TwistGate::gear_cmd_callback, this);
+  auto_cmd_sub_stdmap_["accel_cmd"] = nh_.subscribe("/accel_cmd", 1, &amp;TwistGate::accel_cmd_callback, this);
+  auto_cmd_sub_stdmap_["steer_cmd"] = nh_.subscribe("/steer_cmd", 1, &amp;TwistGate::steer_cmd_callback, this);
+  auto_cmd_sub_stdmap_["brake_cmd"] = nh_.subscribe("/brake_cmd", 1, &amp;TwistGate::brake_cmd_callback, this);
+  auto_cmd_sub_stdmap_["lamp_cmd"] = nh_.subscribe("/lamp_cmd", 1, &amp;TwistGate::lamp_cmd_callback, this);
+  auto_cmd_sub_stdmap_["ctrl_cmd"] = nh_.subscribe("/ctrl_cmd", 1, &amp;TwistGate::ctrl_cmd_callback, this);
 
   twist_gate_msg_.header.seq = 0;
 
@@ -122,16 +124,17 @@ TwistGate::~TwistGate()
 
 void TwistGate::reset_vehicle_cmd_msg()
 {
-  twist_gate_msg_.linear_x        = 0;
-  twist_gate_msg_.angular_z       = 0;
-  twist_gate_msg_.mode            = 0;
-  twist_gate_msg_.gear            = 0;
-  twist_gate_msg_.blinker         = 0;
-  twist_gate_msg_.accel           = 0;
-  twist_gate_msg_.brake           = 0;
-  twist_gate_msg_.steer           = 0;
-  twist_gate_msg_.linear_velocity = -1;
-  twist_gate_msg_.steering_angle  = 0;
+  twist_gate_msg_.twist_cmd.twist.linear.x  = 0;
+  twist_gate_msg_.twist_cmd.twist.angular.z = 0;
+  twist_gate_msg_.mode                      = 0;
+  twist_gate_msg_.gear                      = 0;
+  twist_gate_msg_.lamp_cmd.l                = 0;
+  twist_gate_msg_.lamp_cmd.r                = 0;
+  twist_gate_msg_.accel_cmd.accel           = 0;
+  twist_gate_msg_.brake_cmd.brake           = 0;
+  twist_gate_msg_.steer_cmd.steer           = 0;
+  twist_gate_msg_.ctrl_cmd.linear_velocity  = -1;
+  twist_gate_msg_.ctrl_cmd.steering_angle   = 0;
 }
 
 void TwistGate::watchdog_timer()
@@ -193,14 +196,13 @@ void TwistGate::remote_cmd_callback(const remote_msgs_t::ConstPtr&amp; input_msg)
     twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
     twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
     twist_gate_msg_.header.seq++;
-    twist_gate_msg_.linear_x = input_msg-&gt;accel;
-    twist_gate_msg_.angular_z = 0;
-    twist_gate_msg_.steering_angle = input_msg-&gt;steer;
-    twist_gate_msg_.accel = input_msg-&gt;accel;
-    twist_gate_msg_.brake = input_msg-&gt;brake;
-    twist_gate_msg_.steer = input_msg-&gt;steer;
+    twist_gate_msg_.twist_cmd.twist = input_msg-&gt;twist_cmd.twist;
+    twist_gate_msg_.ctrl_cmd  = input_msg-&gt;ctrl_cmd;
+    twist_gate_msg_.accel_cmd = input_msg-&gt;accel_cmd;
+    twist_gate_msg_.brake_cmd = input_msg-&gt;brake_cmd;
+    twist_gate_msg_.steer_cmd = input_msg-&gt;steer_cmd;
     twist_gate_msg_.gear = input_msg-&gt;gear;
-    twist_gate_msg_.blinker = input_msg-&gt;blinker;
+    twist_gate_msg_.lamp_cmd = input_msg-&gt;lamp_cmd;
     twist_gate_msg_.mode = input_msg-&gt;mode;
     twist_gate_msg_.emergency = input_msg-&gt;emergency;
     vehicle_cmd_pub_.publish(twist_gate_msg_);
@@ -214,13 +216,12 @@ void TwistGate::auto_cmd_twist_cmd_callback(const geometry_msgs::TwistStamped::C
     twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
     twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
     twist_gate_msg_.header.seq++;
-    twist_gate_msg_.linear_x = input_msg-&gt;twist.linear.x;
-    twist_gate_msg_.angular_z = input_msg-&gt;twist.angular.z;
+    twist_gate_msg_.twist_cmd.twist = input_msg-&gt;twist;
     vehicle_cmd_pub_.publish(twist_gate_msg_);
   }
 }
 
-void TwistGate::auto_cmd_mode_cmd_callback(const tablet_socket_msgs::mode_cmd::ConstPtr&amp; input_msg)
+void TwistGate::mode_cmd_callback(const tablet_socket_msgs::mode_cmd::ConstPtr&amp; input_msg)
 {
   if(command_mode_ == CommandMode::AUTO)
   {
@@ -236,7 +237,7 @@ void TwistGate::auto_cmd_mode_cmd_callback(const tablet_socket_msgs::mode_cmd::C
   }
 }
 
-void TwistGate::auto_cmd_gear_cmd_callback(const tablet_socket_msgs::gear_cmd::ConstPtr&amp; input_msg)
+void TwistGate::gear_cmd_callback(const tablet_socket_msgs::gear_cmd::ConstPtr&amp; input_msg)
 {
   if(command_mode_ == CommandMode::AUTO)
   {
@@ -245,51 +246,63 @@ void TwistGate::auto_cmd_gear_cmd_callback(const tablet_socket_msgs::gear_cmd::C
   }
 }
 
-void TwistGate::auto_cmd_accel_cmd_callback(const autoware_msgs::accel_cmd::ConstPtr&amp; input_msg)
+void TwistGate::accel_cmd_callback(const autoware_msgs::accel_cmd::ConstPtr&amp; input_msg)
 {
   if(command_mode_ == CommandMode::AUTO)
   {
     twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
     twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
     twist_gate_msg_.header.seq++;
-    twist_gate_msg_.accel = input_msg-&gt;accel;
+    twist_gate_msg_.accel_cmd.accel = input_msg-&gt;accel;
     vehicle_cmd_pub_.publish(twist_gate_msg_);
   }
 }
 
-void TwistGate::auto_cmd_steer_cmd_callback(const autoware_msgs::steer_cmd::ConstPtr&amp; input_msg)
+void TwistGate::steer_cmd_callback(const autoware_msgs::steer_cmd::ConstPtr&amp; input_msg)
 {
   if(command_mode_ == CommandMode::AUTO)
   {
     twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
     twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
     twist_gate_msg_.header.seq++;
-    twist_gate_msg_.steer = input_msg-&gt;steer;
+    twist_gate_msg_.steer_cmd.steer = input_msg-&gt;steer;
     vehicle_cmd_pub_.publish(twist_gate_msg_);
   }
 }
 
-void TwistGate::auto_cmd_brake_cmd_callback(const autoware_msgs::brake_cmd::ConstPtr&amp; input_msg)
+void TwistGate::brake_cmd_callback(const autoware_msgs::brake_cmd::ConstPtr&amp; input_msg)
 {
   if(command_mode_ == CommandMode::AUTO)
   {
     twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
     twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
     twist_gate_msg_.header.seq++;
-    twist_gate_msg_.brake = input_msg-&gt;brake;
+    twist_gate_msg_.brake_cmd.brake = input_msg-&gt;brake;
     vehicle_cmd_pub_.publish(twist_gate_msg_);
   }
 }
 
-void TwistGate::auto_cmd_ctrl_cmd_callback(const autoware_msgs::ControlCommandStamped::ConstPtr&amp; input_msg)
+void TwistGate::lamp_cmd_callback(const autoware_msgs::lamp_cmd::ConstPtr&amp; input_msg)
 {
   if(command_mode_ == CommandMode::AUTO)
   {
     twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
     twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
     twist_gate_msg_.header.seq++;
-    twist_gate_msg_.linear_velocity = input_msg-&gt;cmd.linear_velocity;
-    twist_gate_msg_.steering_angle = input_msg-&gt;cmd.steering_angle;
+    twist_gate_msg_.lamp_cmd.l = input_msg-&gt;l;
+    twist_gate_msg_.lamp_cmd.r = input_msg-&gt;r;
+    vehicle_cmd_pub_.publish(twist_gate_msg_);
+  }
+}
+
+void TwistGate::ctrl_cmd_callback(const autoware_msgs::ControlCommandStamped::ConstPtr&amp; input_msg)
+{
+  if(command_mode_ == CommandMode::AUTO)
+  {
+    twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
+    twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
+    twist_gate_msg_.header.seq++;
+    twist_gate_msg_.ctrl_cmd = input_msg-&gt;cmd;
     vehicle_cmd_pub_.publish(twist_gate_msg_);
   }
 }
</diff>
			</file>
			<file old_path="ros\src\socket\packages\mqtt_socket\include\mqtt_socket\mqtt_setting.hpp" new_path="ros\src\socket\packages\mqtt_socket\include\mqtt_socket\mqtt_setting.hpp" added_lines="2" deleted_lines="1">
				<diff>@@ -13,9 +13,10 @@
 #define REMOTE_MODE     2
 #define NORMAL_MODE     0
 #define EMERGENCY_MODE  1
-#define ACCEL_MAX_VAL   15 * 1000 / 60 / 60 // 15 km/h
+#define ACCEL_MAX_VAL   100
 #define BRAKE_MAX_VAL   10000
 #define STEER_MAX_VAL   0.6
+#define LINEAR_X_MAX_VAL 15 * 1000 / 60 / 60 // 15 km/h
 #define DOWNSAMPLE      0.1
 #define GEAR_D          16
 #define GEAR_N          32
</diff>
			</file>
			<file old_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_receiver\mqtt_receiver.cpp" new_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_receiver\mqtt_receiver.cpp" added_lines="27" deleted_lines="4">
				<diff>@@ -130,11 +130,34 @@ static void MqttReceiver::on_message(struct mosquitto *mosq, void *obj, const st
 
     if(cmds.size() == 8) {
       autoware_msgs::RemoteCmd msg;
-      msg.steer.steer = std::stof(cmds[0]) * STEER_MAX_VAL;
-      msg.accel.accel = std::stof(cmds[1]) * ACCEL_MAX_VAL;
-      msg.brake.brake = std::stof(cmds[2]) * BRAKE_MAX_VAL;
+      msg.steer_cmd.steer = std::stof(cmds[0]) * STEER_MAX_VAL;
+      msg.accel_cmd.accel = std::stof(cmds[1]) * ACCEL_MAX_VAL;
+      msg.brake_cmd.brake = std::stof(cmds[2]) * BRAKE_MAX_VAL;
       msg.gear = std::stoi(cmds[3]);
-      msg.blinker = std::stoi(cmds[4]);
+      // lamp
+      switch(std::stoi(cmds[4])) {
+        msg.lamp_cmd.l = 0;
+        msg.lamp_cmd.r = 0;
+        case 0:
+          break;
+        case 1:
+          msg.lamp_cmd.l = 1;
+          break;
+        case 2:
+          msg.lamp_cmd.r = 1;
+          break;
+        case 3:
+          msg.lamp_cmd.l = 1;
+          msg.lamp_cmd.r = 1;
+          break;
+        default:
+          ROS_WARN("Invalid lamp_cmd");
+          break;
+      }
+      msg.twist_cmd.twist.linear.x = std::stof(cmds[1]) * LINEAR_X_MAX_VAL;
+      msg.twist_cmd.twist.angular.z = std::stof(cmds[0]);
+      msg.ctrl_cmd.linear_velocity = std::stof(cmds[1]) * LINEAR_X_MAX_VAL;
+      msg.ctrl_cmd.steering_angle = std::stof(cmds[0]) * STEER_MAX_VAL;
       msg.mode = std::stoi(cmds[5]);
       msg.control_mode = std::stoi(cmds[6]);
       msg.emergency = std::stoi(cmds[7]);
</diff>
			</file>
			<file old_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_sender\vehicle_sender.cpp" new_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_sender\vehicle_sender.cpp" added_lines="21" deleted_lines="10">
				<diff>@@ -46,7 +46,7 @@ struct CommandData {
   double angular_z;
   int modeValue;
   int gearValue;
-  int blinkerValue;
+  int lampValue;
   int accellValue;
   int brakeValue;
   int steerValue;
@@ -62,7 +62,7 @@ void CommandData::reset()
   angular_z     = 0;
   modeValue     = 0;
   gearValue     = 0;
-  blinkerValue  = 0;
+  lampValue     = 0;
   accellValue   = 0;
   brakeValue    = 0;
   steerValue    = 0;
@@ -74,16 +74,27 @@ static CommandData command_data;
 
 static void twistGateCallback(const autoware_msgs::TwistGate&amp; msg)
 {
-  command_data.linear_x = msg.linear_x;
-  command_data.angular_z = msg.angular_z;
+  command_data.linear_x = msg.twist_cmd.twist.linear.x;
+  command_data.angular_z = msg.twist_cmd.twist.angular.z;
   command_data.modeValue = msg.mode;
   command_data.gearValue = msg.gear;
-  command_data.blinkerValue = msg.blinker;
-  command_data.accellValue = msg.accel;
-  command_data.steerValue = msg.steer;
-  command_data.brakeValue = msg.brake;
-  command_data.linear_velocity = msg.linear_velocity;
-  command_data.steering_angle = msg.steering_angle;
+  if(msg.lamp_cmd.l == 0 &amp;&amp; msg.lamp_cmd.r == 0) {
+    command_data.lampValue = 0;
+  }
+  else if (msg.lamp_cmd.l == 1 &amp;&amp; msg.lamp_cmd.r == 0) {
+    command_data.lampValue = 1;
+  }
+  else if (msg.lamp_cmd.l == 0 &amp;&amp; msg.lamp_cmd.r == 1) {
+    command_data.lampValue = 2;
+  }
+  else if (msg.lamp_cmd.l == 1 &amp;&amp; msg.lamp_cmd.r == 1) {
+    command_data.lampValue = 3;
+  }
+  command_data.accellValue = msg.accel_cmd.accel;
+  command_data.steerValue = msg.steer_cmd.steer;
+  command_data.brakeValue = msg.brake_cmd.brake;
+  command_data.linear_velocity = msg.ctrl_cmd.linear_velocity;
+  command_data.steering_angle = msg.ctrl_cmd.steering_angle;
 }
 
 static void *sendCommand(void *arg)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f797cddaba10ec4c33d665dbca94f0c452f46ec3" author="Yuki Iida">
		<msg>support yaml file for mqtt_socket</msg>
		<modified_files>
			<file old_path="ros\src\socket\packages\mqtt_socket\include\mqtt_socket\mqtt_setting.hpp" new_path="ros\src\socket\packages\mqtt_socket\include\mqtt_socket\mqtt_setting.hpp" added_lines="28" deleted_lines="19">
				<diff>@@ -1,24 +1,33 @@
-#include "std_msgs/String.h"
+#define MQTT_NODE_NAME "mqtt_socket"
+#define MQTT_CONFIG_FILE_NAME "/mqtt_config.yaml"
 
-#define VEHICLEID       "1"
-#define MQTT_ADDRESS    "localhost"
-#define MQTT_PORT       1883
-#define CLIENTID        "vehicle"
-#define SENDER_TOPIC    "vehicle/"
-#define RECIEVER_TOPIC  "vehicle/"
-#define PAYLOAD         "Autoware"
-#define QOS             0
-#define TIMEOUT         10000L
+// MODE
 #define AUTO_MODE       1
 #define REMOTE_MODE     2
 #define NORMAL_MODE     0
 #define EMERGENCY_MODE  1
-#define ACCEL_MAX_VAL   100
-#define BRAKE_MAX_VAL   10000
-#define STEER_MAX_VAL   0.6
-#define LINEAR_X_MAX_VAL 15 * 1000 / 60 / 60 // 15 km/h
-#define DOWNSAMPLE      0.1
-#define GEAR_D          16
-#define GEAR_N          32
-#define GEAR_R          64
-#define GEAR_P          128
+
+// REMOTE CMD
+static int vehicle_id;
+static int accel_max_val;
+static int brake_max_val;
+static float steer_max_val;
+static float linear_x_max_val;
+
+// CANINFO
+static float caninfo_downsample;
+
+// GEAR
+int gear_d;
+int gear_n;
+int gear_r;
+int gear_p;
+
+// MQTT
+static struct mosquitto *mqtt_client = NULL;
+static string mqtt_client_id;
+static string mqtt_address;
+static int mqtt_port;
+static string mqtt_topic;
+static int mqtt_qos;
+static int mqtt_timeout;
</diff>
			</file>
			<file old_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_receiver\mqtt_receiver.cpp" new_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_receiver\mqtt_receiver.cpp" added_lines="70" deleted_lines="60">
				<diff>@@ -28,21 +28,20 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-#include "ros/ros.h"
-#include "std_msgs/String.h"
-#include "stdlib.h"
-#include "string.h"
-#include "mqtt_socket/mqtt_setting.hpp"
-#include "autoware_msgs/RemoteCmd.h"
-#include &lt;mosquitto.h&gt;
+#include &lt;ros/ros.h&gt;
+#include &lt;ros/package.h&gt;
+#include &lt;std_msgs/String.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
 #include &lt;vector&gt;
 #include &lt;boost/algorithm/string.hpp&gt;
-#include &lt;string&gt;
+#include &lt;mosquitto.h&gt;
+#include &lt;yaml-cpp/yaml.h&gt;
+using namespace std;
+#include "mqtt_socket/mqtt_setting.hpp"
+#include "autoware_msgs/RemoteCmd.h"
 
-static struct mosquitto *mqtt_client_ = NULL;
-static std::string mqtt_topic_;
-static int mqtt_qos_;
-static ros::Publisher remote_cmd_pub_;
+static ros::Publisher remote_cmd_pub;
 
 class MqttReceiver
 {
@@ -52,67 +51,51 @@ public:
   static void on_connect(struct mosquitto *mosq, void *obj, int result);
   static void on_disconnect(struct mosquitto *mosq, void *obj, int rc);
   static void on_message(struct mosquitto *mosq, void *obj, const struct mosquitto_message *message);
+  static void load_config();
 
 private:
   ros::NodeHandle node_handle_;
-
-  // MQTT
-  std::string mqtt_address_;
-  int mqtt_port_;
-  std::string mqtt_client_id_;
-  int mqtt_timeout_;
 };
 
 MqttReceiver::MqttReceiver() :
     node_handle_("~")
 {
   // ROS Publisher
-  remote_cmd_pub_ = node_handle_.advertise&lt;autoware_msgs::RemoteCmd&gt;("/remote_cmd", 1);
+  remote_cmd_pub = node_handle_.advertise&lt;autoware_msgs::RemoteCmd&gt;("/remote_cmd", 1);
+
+  // Load Config
+  MqttReceiver::load_config();
 
   // MQTT PARAMS
   mosquitto_lib_init();
 
-  mqtt_address_ = MQTT_ADDRESS;
-  mqtt_port_ = MQTT_PORT;
-  mqtt_topic_ = std::string(RECIEVER_TOPIC) + std::string(VEHICLEID) + "/remote_cmd";
-  mqtt_client_id_ = std::string(CLIENTID) + "_" + std::string(VEHICLEID) + "_rcv";
-  mqtt_qos_ = QOS;
-
-  node_handle_.param("/confing/mqtt/address", mqtt_address_, mqtt_address_);
-  node_handle_.param("/confing/mqtt/port", mqtt_port_, mqtt_port_);
-  node_handle_.param("/confing/mqtt/topic", mqtt_topic_, mqtt_topic_);
-  node_handle_.param("/confing/mqtt/client_id", mqtt_client_id_, mqtt_client_id_);
-  node_handle_.param("/confing/mqtt/qos", mqtt_qos_, mqtt_qos_);
-  node_handle_.param("/confing/mqtt/timeout", mqtt_timeout_, mqtt_timeout_);
-  ROS_INFO("MQTT Receiver ADDR: %s:%d, TOPIC: %s, ID: %s\n", mqtt_address_.c_str(), mqtt_port_, mqtt_topic_.c_str(), mqtt_client_id_.c_str());
-
-  mqtt_client_ = mosquitto_new(mqtt_client_id_.c_str(), true, NULL);
-  mosquitto_connect_callback_set(mqtt_client_, &amp;MqttReceiver::on_connect);
-  mosquitto_disconnect_callback_set(mqtt_client_, &amp;MqttReceiver::on_disconnect);
-  mosquitto_message_callback_set(mqtt_client_, &amp;MqttReceiver::on_message);
-
-  if(mosquitto_connect_bind(mqtt_client_, mqtt_address_.c_str(), mqtt_port_, mqtt_timeout_, NULL)){
+  mqtt_client = mosquitto_new(mqtt_client_id.c_str(), true, NULL);
+  mosquitto_connect_callback_set(mqtt_client, &amp;MqttReceiver::on_connect);
+  mosquitto_disconnect_callback_set(mqtt_client, &amp;MqttReceiver::on_disconnect);
+  mosquitto_message_callback_set(mqtt_client, &amp;MqttReceiver::on_message);
+
+  if(mosquitto_connect_bind(mqtt_client, mqtt_address.c_str(), mqtt_port, mqtt_timeout, NULL)){
     ROS_INFO("Failed to connect broker.\n");
     mosquitto_lib_cleanup();
     exit(EXIT_FAILURE);
   }
 
   // Start Subscribe
-  int ret = mosquitto_loop(mqtt_client_, -1, 1);
-  ret = mosquitto_loop_start(mqtt_client_);
+  int ret = mosquitto_loop(mqtt_client, -1, 1);
+  ret = mosquitto_loop_start(mqtt_client);
 }
 
 MqttReceiver::~MqttReceiver()
 {
-  int ret = mosquitto_loop_stop(mqtt_client_, 1);
-  mosquitto_destroy(mqtt_client_);
+  int ret = mosquitto_loop_stop(mqtt_client, 1);
+  mosquitto_destroy(mqtt_client);
   mosquitto_lib_cleanup();
 }
 
 static void MqttReceiver::on_connect(struct mosquitto *mosq, void *obj, int result)
 {
   ROS_INFO("on_connect: %s(%d)\n", __FUNCTION__, __LINE__);
-  mosquitto_subscribe(mqtt_client_, NULL, mqtt_topic_.c_str(), mqtt_qos_);
+  mosquitto_subscribe(mqtt_client, NULL, mqtt_topic.c_str(), mqtt_qos);
 }
 
 static void MqttReceiver::on_disconnect(struct mosquitto *mosq, void *obj, int rc)
@@ -120,22 +103,49 @@ static void MqttReceiver::on_disconnect(struct mosquitto *mosq, void *obj, int r
   ROS_INFO("on_disconnect: %s(%d)\n", __FUNCTION__, __LINE__);
 }
 
+static void MqttReceiver::load_config()
+{
+  string config_file_path = ros::package::getPath(MQTT_NODE_NAME) + MQTT_CONFIG_FILE_NAME;
+  ROS_INFO("Load Config File: %s %s(%d)\n", config_file_path.c_str(), __FUNCTION__, __LINE__);
+
+  YAML::Node config = YAML::LoadFile(config_file_path);
+  vehicle_id = config["mqtt"]["VEHICLEID"].as&lt;int&gt;();
+  mqtt_client_id = "vehicle_" + to_string(vehicle_id) + "_rcv";
+  mqtt_address = config["mqtt"]["ADDRESS"].as&lt;string&gt;();
+  mqtt_port = config["mqtt"]["PORT"].as&lt;int&gt;();
+  mqtt_qos = config["mqtt"]["QOS"].as&lt;int&gt;();
+  mqtt_topic = "vehicle/" + to_string(vehicle_id) + "/remote_cmd";
+  mqtt_timeout = config["mqtt"]["TIMEOUT"].as&lt;int&gt;();
+
+  accel_max_val = config["mqtt"]["ACCEL_MAX_VAL"].as&lt;int&gt;();
+  brake_max_val = config["mqtt"]["BRAKE_MAX_VAL"].as&lt;int&gt;();
+  steer_max_val = config["mqtt"]["STEER_MAX_VAL"].as&lt;float&gt;();
+  linear_x_max_val = config["mqtt"]["LINEAR_X_MAX_VAL"].as&lt;float&gt;();
+
+  ROS_INFO("MQTT Receiver ADDR: %s:%d, TOPIC: %s, ID: %s\n", mqtt_address.c_str(), mqtt_port, mqtt_topic.c_str(), mqtt_client_id.c_str());
+
+  ROS_INFO(
+    "[MQTT Receiver Settings] vehicle_id: %d, accel_max_val: %d, \
+    brake_max_val: %d, steer_max_val: %f, linear_x_max_val: %f,",
+    vehicle_id, accel_max_val, brake_max_val, steer_max_val, linear_x_max_val);
+}
+
 static void MqttReceiver::on_message(struct mosquitto *mosq, void *obj, const struct mosquitto_message *message)
 {
   if(message-&gt;payloadlen) {
-    std::string delim (",");
-    std::string msg_str((char *)message-&gt;payload, message-&gt;payloadlen);
-    std::vector&lt;std::string&gt; cmds;
+    string delim (",");
+    string msg_str((char *)message-&gt;payload, message-&gt;payloadlen);
+    vector&lt;string&gt; cmds;
     boost::algorithm::split(cmds, msg_str, boost::is_any_of(","));
 
     if(cmds.size() == 8) {
       autoware_msgs::RemoteCmd msg;
-      msg.steer_cmd.steer = std::stof(cmds[0]) * STEER_MAX_VAL;
-      msg.accel_cmd.accel = std::stof(cmds[1]) * ACCEL_MAX_VAL;
-      msg.brake_cmd.brake = std::stof(cmds[2]) * BRAKE_MAX_VAL;
-      msg.gear = std::stoi(cmds[3]);
+      msg.steer_cmd.steer = stof(cmds[0]) * steer_max_val;
+      msg.accel_cmd.accel = stof(cmds[1]) * accel_max_val;
+      msg.brake_cmd.brake = stof(cmds[2]) * brake_max_val;
+      msg.gear = stoi(cmds[3]);
       // lamp
-      switch(std::stoi(cmds[4])) {
+      switch(stoi(cmds[4])) {
         msg.lamp_cmd.l = 0;
         msg.lamp_cmd.r = 0;
         case 0:
@@ -154,14 +164,14 @@ static void MqttReceiver::on_message(struct mosquitto *mosq, void *obj, const st
           ROS_WARN("Invalid lamp_cmd");
           break;
       }
-      msg.twist_cmd.twist.linear.x = std::stof(cmds[1]) * LINEAR_X_MAX_VAL;
-      msg.twist_cmd.twist.angular.z = std::stof(cmds[0]);
-      msg.ctrl_cmd.linear_velocity = std::stof(cmds[1]) * LINEAR_X_MAX_VAL;
-      msg.ctrl_cmd.steering_angle = std::stof(cmds[0]) * STEER_MAX_VAL;
-      msg.mode = std::stoi(cmds[5]);
-      msg.control_mode = std::stoi(cmds[6]);
-      msg.emergency = std::stoi(cmds[7]);
-      remote_cmd_pub_.publish(msg);
+      msg.twist_cmd.twist.linear.x = stof(cmds[1]) * linear_x_max_val;
+      msg.twist_cmd.twist.angular.z = stof(cmds[0]);
+      msg.ctrl_cmd.linear_velocity = stof(cmds[1]) * linear_x_max_val;
+      msg.ctrl_cmd.steering_angle = stof(cmds[0]) * steer_max_val;
+      msg.mode = stoi(cmds[5]);
+      msg.control_mode = stoi(cmds[6]);
+      msg.emergency = stoi(cmds[7]);
+      remote_cmd_pub.publish(msg);
     }
     else {
       ROS_INFO("Failed to parse remote command.\n");
</diff>
			</file>
			<file old_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_sender\mqtt_sender.cpp" new_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_sender\mqtt_sender.cpp" added_lines="142" deleted_lines="138">
				<diff>@@ -28,16 +28,21 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-#include "ros/ros.h"
-#include "std_msgs/String.h"
-#include "stdlib.h"
-#include "string.h"
-#include "mqtt_socket/mqtt_setting.hpp"
-#include "autoware_msgs/CanInfo.h"
+#include &lt;ros/ros.h&gt;
+#include &lt;ros/package.h&gt;
+#include &lt;std_msgs/String.h&gt;
 #include &lt;std_msgs/Float64MultiArray.h&gt;
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 #include &lt;unordered_map&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;vector&gt;
+#include &lt;boost/algorithm/string.hpp&gt;
 #include &lt;mosquitto.h&gt;
+#include &lt;yaml-cpp/yaml.h&gt;
+using namespace std;
+#include "mqtt_socket/mqtt_setting.hpp"
+#include "autoware_msgs/CanInfo.h"
 
 class MqttSender
 {
@@ -48,25 +53,20 @@ public:
   static void on_connect(struct mosquitto *mosq, void *obj, int result);
   static void on_disconnect(struct mosquitto *mosq, void *obj, int rc);
   static void on_publish(struct mosquitto *mosq, void *userdata, int mid);
+  static void load_config();
 
 private:
-  std::unordered_map&lt;std::string, ros::Subscriber&gt; Subs;
+  void targetVelocityArrayCallback(const std_msgs::Float64MultiArray &amp;msg);
+  void twistCmdCallback(const geometry_msgs::TwistStamped &amp;msg);
+  void stateCallback(const std_msgs::String &amp;msg);
+  unordered_map&lt;string, ros::Subscriber&gt; Subs;
   ros::NodeHandle node_handle_;
 
-  // MQTT
-  struct mosquitto *mqtt_client_ = NULL;
-  std::string mqtt_address_;
-  int mqtt_port_;
-  std::string mqtt_topic_can_info_;
-  std::string mqtt_topic_state_;
-  std::string mqtt_topic_target_velocity_;
-  std::string mqtt_topic_current_target_velocity_;
-
-  std::string mqtt_client_id_;
-  int mqtt_qos_;
-  int mqtt_timeout_;
-  double mqtt_downsample_;
-  int callback_counter_;
+  // MQTT TOPIC
+  string mqtt_topic_can_info_;
+  string mqtt_topic_state_;
+  string mqtt_topic_target_velocity_;
+  string mqtt_topic_current_target_velocity_;
 
   // current behavior/status
   std_msgs::Float64MultiArray current_target_velocity_array_; //kmph
@@ -74,10 +74,7 @@ private:
   double current_target_velocity_; // mps2kmph(current_twist_cmd_.twist.twist.linear.x);
   std_msgs::String current_state_;
 
-  void targetVelocityArrayCallback(const std_msgs::Float64MultiArray &amp;msg);
-  void twistCmdCallback(const geometry_msgs::TwistStamped &amp;msg);
-  void stateCallback(const std_msgs::String &amp;msg);
-
+  int callback_counter_ = 0;
 };
 
 inline double mps2kmph(double _mpsval)
@@ -97,32 +94,19 @@ MqttSender::MqttSender() :
   // MQTT PARAMS
   mosquitto_lib_init();
 
-  mqtt_address_ = MQTT_ADDRESS;
-  mqtt_port_ = MQTT_PORT;
-  mqtt_topic_can_info_ = std::string(SENDER_TOPIC) + std::string(VEHICLEID) + "/can_info";
-  mqtt_topic_state_ = std::string(SENDER_TOPIC) + std::string(VEHICLEID) + "/state";
-  mqtt_topic_target_velocity_ = std::string(SENDER_TOPIC) + std::string(VEHICLEID) + "/target_velocity";
-  mqtt_topic_current_target_velocity_ = std::string(SENDER_TOPIC) + std::string(VEHICLEID) + "/current_velocity";
-
-  mqtt_client_id_ = std::string(CLIENTID) + "_" + std::string(VEHICLEID) + "_snd";
-  mqtt_qos_ = QOS;
-  mqtt_timeout_ = TIMEOUT;
-  mqtt_downsample_ = DOWNSAMPLE;
-  callback_counter_ = 0;
-
-  node_handle_.param("/confing/mqtt/address", mqtt_address_, mqtt_address_);
-  node_handle_.param("/confing/mqtt/port", mqtt_port_, mqtt_port_);
-  node_handle_.param("/confing/mqtt/client_id", mqtt_client_id_, mqtt_client_id_);
-  node_handle_.param("/confing/mqtt/qos", mqtt_qos_, mqtt_qos_);
-  node_handle_.param("/confing/mqtt/timeout", mqtt_timeout_, mqtt_timeout_);
-  node_handle_.param("/confing/mqtt/downsample", mqtt_downsample_, mqtt_downsample_);
-  ROS_INFO("MQTT Sender ADDR: %s:%d, TOPIC: %s, ID: %s, DOWNSAMPLE: %f\n", mqtt_address_.c_str(), mqtt_port_, mqtt_topic_can_info_.c_str(), mqtt_client_id_.c_str(), mqtt_downsample_);
-
-  mqtt_client_ = mosquitto_new(mqtt_client_id_.c_str(), true, NULL);
-  mosquitto_connect_callback_set(mqtt_client_, &amp;MqttSender::on_connect);
-  mosquitto_disconnect_callback_set(mqtt_client_, &amp;MqttSender::on_disconnect);
-
-  if(mosquitto_connect_bind(mqtt_client_, mqtt_address_.c_str(), mqtt_port_, mqtt_timeout_, NULL)){
+  // Load Config
+  MqttSender::load_config();
+
+  mqtt_topic_can_info_ = "vehicle/" + to_string(vehicle_id) + "/can_info";
+  mqtt_topic_state_ = "vehicle/" + to_string(vehicle_id) + "/state";
+  mqtt_topic_target_velocity_ = "vehicle/" + to_string(vehicle_id) + "/target_velocity";
+  mqtt_topic_current_target_velocity_ = "vehicle/" + to_string(vehicle_id) + "/current_velocity";
+
+  mqtt_client = mosquitto_new(mqtt_client_id.c_str(), true, NULL);
+  mosquitto_connect_callback_set(mqtt_client, &amp;MqttSender::on_connect);
+  mosquitto_disconnect_callback_set(mqtt_client, &amp;MqttSender::on_disconnect);
+
+  if(mosquitto_connect_bind(mqtt_client, mqtt_address.c_str(), mqtt_port, mqtt_timeout, NULL)){
     ROS_INFO("Failed to connect broker.\n");
     mosquitto_lib_cleanup();
     exit(EXIT_FAILURE);
@@ -131,7 +115,7 @@ MqttSender::MqttSender() :
 
 MqttSender::~MqttSender()
 {
-  mosquitto_destroy(mqtt_client_);
+  mosquitto_destroy(mqtt_client);
   mosquitto_lib_cleanup();
 }
 
@@ -145,43 +129,70 @@ void MqttSender::on_disconnect(struct mosquitto *mosq, void *obj, int rc)
     ROS_INFO("on_disconnect: %s(%d)\n", __FUNCTION__, __LINE__);
 }
 
+static void MqttSender::load_config()
+{
+  string config_file_path = ros::package::getPath(MQTT_NODE_NAME) + MQTT_CONFIG_FILE_NAME;
+  ROS_INFO("Load Config File: %s %s(%d)\n", config_file_path.c_str(), __FUNCTION__, __LINE__);
+
+  YAML::Node config = YAML::LoadFile(config_file_path);
+  vehicle_id = config["mqtt"]["VEHICLEID"].as&lt;int&gt;();
+  mqtt_client_id = "vehicle_" + to_string(vehicle_id) + "_snd";
+  mqtt_address = config["mqtt"]["ADDRESS"].as&lt;string&gt;();
+  mqtt_port = config["mqtt"]["PORT"].as&lt;int&gt;();
+  mqtt_qos = config["mqtt"]["QOS"].as&lt;int&gt;();
+  mqtt_timeout = config["mqtt"]["TIMEOUT"].as&lt;int&gt;();
+
+  caninfo_downsample = config["mqtt"]["CANINFO_DOWNSAMPLE"].as&lt;float&gt;();
+  gear_d = config["mqtt"]["GEAR_D"].as&lt;int&gt;();
+  gear_n = config["mqtt"]["GEAR_N"].as&lt;int&gt;();
+  gear_r = config["mqtt"]["GEAR_R"].as&lt;int&gt;();
+  gear_p = config["mqtt"]["GEAR_P"].as&lt;int&gt;();
+
+  ROS_INFO("MQTT Sender ADDR: %s:%d, ID: %s\n", mqtt_address.c_str(), mqtt_port,  mqtt_client_id.c_str());
+
+  ROS_INFO(
+    "[MQTT Receiver Settings] vehicle_id: %d, \
+    caninfo_downsample: %f, gear_d: %d, gear_n: %d, gear_r: %d, \
+    gear_p: %d", vehicle_id, caninfo_downsample, gear_d, gear_n, gear_r, gear_p);
+}
+
 void MqttSender::targetVelocityArrayCallback(const std_msgs::Float64MultiArray &amp;msg)
 {
-  std::ostringstream publish_msg;
+  ostringstream publish_msg;
   current_target_velocity_array_ = msg;
 
   for(int i = 0; i &lt; sizeof(msg.data); i++) {
-    publish_msg &lt;&lt; std::to_string(msg.data[i]) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg.data[i]) &lt;&lt; ",";
   }
-  std::string publish_msg_str = publish_msg.str();
+  string publish_msg_str = publish_msg.str();
 
   int ret = mosquitto_publish(
-    mqtt_client_,
+    mqtt_client,
     NULL,
     mqtt_topic_target_velocity_.c_str(),
     strlen(publish_msg_str.c_str()),
     publish_msg_str.c_str(),
-    mqtt_qos_,
+    mqtt_qos,
     false
   );
 }
 
 void MqttSender::twistCmdCallback(const geometry_msgs::TwistStamped &amp;msg)
 {
-  std::ostringstream publish_msg;
+  ostringstream publish_msg;
   current_twist_cmd_ = msg;
   current_target_velocity_ = mps2kmph(msg.twist.linear.x);
 
-  publish_msg &lt;&lt; std::to_string(current_target_velocity_);
-  std::string publish_msg_str = publish_msg.str();
+  publish_msg &lt;&lt; to_string(current_target_velocity_);
+  string publish_msg_str = publish_msg.str();
 
   int ret = mosquitto_publish(
-    mqtt_client_,
+    mqtt_client,
     NULL,
     mqtt_topic_current_target_velocity_.c_str(),
     strlen(publish_msg_str.c_str()),
     publish_msg_str.c_str(),
-    mqtt_qos_,
+    mqtt_qos,
     false
   );
 }
@@ -191,12 +202,12 @@ void MqttSender::stateCallback(const std_msgs::String &amp;msg)
   ROS_INFO("State: %s\n", msg.data.c_str());
 
   int ret = mosquitto_publish(
-    mqtt_client_,
+    mqtt_client,
     NULL,
     mqtt_topic_state_.c_str(),
     strlen(msg.data.c_str()),
     msg.data.c_str(),
-    mqtt_qos_,
+    mqtt_qos,
     false
   );
 }
@@ -204,87 +215,80 @@ void MqttSender::stateCallback(const std_msgs::String &amp;msg)
 void MqttSender::canInfoCallback(const autoware_msgs::CanInfoConstPtr &amp;msg)
 {
 
-  if(callback_counter_ &gt; mqtt_downsample_ * 100) {
-    std::ostringstream publish_msg;
+  if(callback_counter_ &gt; caninfo_downsample * 100) {
+    ostringstream publish_msg;
 
     publish_msg &lt;&lt; msg-&gt;tm &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;devmode) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;drvcontmode) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;drvoverridemode) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;drvservo) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;drivepedal) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;targetpedalstr) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;inputpedalstr) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;targetveloc) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;speed) &lt;&lt; ",";
-    switch (msg-&gt;driveshift) {
-      case GEAR_D:
-        publish_msg &lt;&lt; "D,";
-        break;
-      case GEAR_N:
-        publish_msg &lt;&lt; "N,";
-        break;
-      case GEAR_R:
-        publish_msg &lt;&lt; "R,";
-        break;
-      case GEAR_P:
-        publish_msg &lt;&lt; "P,";
-        break;
-      default:
-        publish_msg &lt;&lt; "Unkwown,";
-        break;
-    }
-    publish_msg &lt;&lt; std::to_string(msg-&gt;targetshift) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;inputshift) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;strmode) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;strcontmode) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;stroverridemode) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;strservo) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;targettorque) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;torque) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;angle) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;targetangle) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;bbrakepress) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;brakepedal) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;brtargetpedalstr) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;brinputpedalstr) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;battery) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;voltage) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;anp) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;battmaxtemparature) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;battmintemparature) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;maxchgcurrent) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;maxdischgcurrent) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;sideacc) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;accellfromp) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;anglefromp) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;brakepedalfromp) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;speedfr) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;speedfl) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;speedrr) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;speedrl) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;velocfromp2) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;drvmode) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;devpedalstrfromp) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;rpm) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;velocflfromp) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;ev_mode) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;temp) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;shiftfrmprius) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;light) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;gaslevel) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;door) &lt;&lt; ",";
-    publish_msg &lt;&lt; std::to_string(msg-&gt;cluise);
-
-    // std::ostringstream publish_msg = create_message(msg);
-    std::string publish_msg_str = publish_msg.str();
+    publish_msg &lt;&lt; to_string(msg-&gt;devmode) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;drvcontmode) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;drvoverridemode) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;drvservo) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;drivepedal) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;targetpedalstr) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;inputpedalstr) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;targetveloc) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;speed) &lt;&lt; ",";
+    if (msg-&gt;driveshift == gear_d)
+      publish_msg &lt;&lt; "D,";
+    else if (msg-&gt;driveshift == gear_n)
+      publish_msg &lt;&lt; "N,";
+    else if (msg-&gt;driveshift == gear_r)
+      publish_msg &lt;&lt; "R,";
+    else if (msg-&gt;driveshift == gear_p)
+      publish_msg &lt;&lt; "P,";
+    else
+      publish_msg &lt;&lt; "Unkwown,";
+    publish_msg &lt;&lt; to_string(msg-&gt;targetshift) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;inputshift) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;strmode) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;strcontmode) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;stroverridemode) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;strservo) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;targettorque) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;torque) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;angle) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;targetangle) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;bbrakepress) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;brakepedal) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;brtargetpedalstr) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;brinputpedalstr) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;battery) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;voltage) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;anp) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;battmaxtemparature) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;battmintemparature) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;maxchgcurrent) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;maxdischgcurrent) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;sideacc) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;accellfromp) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;anglefromp) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;brakepedalfromp) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;speedfr) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;speedfl) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;speedrr) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;speedrl) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;velocfromp2) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;drvmode) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;devpedalstrfromp) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;rpm) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;velocflfromp) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;ev_mode) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;temp) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;shiftfrmprius) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;light) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;gaslevel) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;door) &lt;&lt; ",";
+    publish_msg &lt;&lt; to_string(msg-&gt;cluise);
+
+    // ostringstream publish_msg = create_message(msg);
+    string publish_msg_str = publish_msg.str();
     int ret = mosquitto_publish(
-      mqtt_client_,
+      mqtt_client,
       NULL,
       mqtt_topic_can_info_.c_str(),
       strlen(publish_msg_str.c_str()),
       publish_msg_str.c_str(),
-      mqtt_qos_,
+      mqtt_qos,
       false
     );
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="addaddf231b8192ee22741375eb0b17244ae8a1d" author="Yusuke FUJII">
		<msg>improve a judge algorithms for right/left-turn in intersection</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\cross_road_area.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\cross_road_area.hpp" added_lines="8" deleted_lines="2">
				<diff>@@ -17,18 +17,24 @@ public:
   int id;
   int area_id;
   std::vector&lt;geometry_msgs::Point&gt; points;
-
   jsk_recognition_msgs::BoundingBox bbox;
 
+  std::vector&lt; autoware_msgs::waypoint&gt; insideWaypoints;
+  std::vector&lt;geometry_msgs::Point&gt; insideWaypoint_points;
+
   CrossRoadArea(void)
   {
     id = 0;
     area_id = 0;
     points.clear();
+    insideWaypoints.clear();
+    insideWaypoint_points.clear();
   }
 
   static CrossRoadArea *findClosestCrossRoad(const autoware_msgs::lane &amp;_finalwaypoints,
-                                             std::vector&lt;CrossRoadArea&gt; &amp;intersects);
+		  std::vector&lt;CrossRoadArea&gt; &amp;intersects);
+  static bool isInsideArea(const CrossRoadArea* _ClosestArea,
+                                             geometry_msgs::Point pt);
 };
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="5" deleted_lines="1">
				<diff>@@ -6,6 +6,7 @@
 
 #include &lt;autoware_msgs/ConfigDecisionMaker.h&gt;
 #include &lt;autoware_msgs/lane.h&gt;
+#include &lt;autoware_msgs/LaneArray.h&gt;
 #include &lt;autoware_msgs/traffic_light.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;geometry_msgs/TwistStamped.h&gt;
@@ -94,6 +95,9 @@ private:
 
   std::vector&lt;geometry_msgs::Point&gt; inside_points_;
 
+
+  autoware_msgs::LaneArray current_lane_array_;
+
   // Current way/behavior status
   double current_velocity_;
   double average_velocity_;
@@ -141,7 +145,6 @@ private:
 
   // judge method
   // in near future, these methods will be deprecate to decision_maker library
-  bool isInsideArea(geometry_msgs::Point pt);
   bool isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
   bool isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch, double _yaw);
 
@@ -156,6 +159,7 @@ private:
   void callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg);
   void callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg);
   void callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg);
+  void callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg);
   void callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg);
   void callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg);
   void callbackFromStateCmd(const std_msgs::Int32 &amp;msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_param.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_param.hpp" added_lines="4" deleted_lines="3">
				<diff>@@ -15,9 +15,10 @@ namespace decision_maker
 #define DOUBLE_MAX 1.7976931348623158e308
 #define DEFAULT_TARGET_WAYPOINT 14
 
-#define ANGLE_STRAIGHT 50.0
-#define ANGLE_LEFT 360.0
-#define ANGLE_RIGHT 180.0
+#define ANGLE_NEUTRAL 180
+#define ANGLE_CURVE 40
+#define ANGLE_LEFT  (ANGLE_NEUTRAL - ANGLE_CURVE)
+#define ANGLE_RIGHT (ANGLE_NEUTRAL + ANGLE_CURVE)
 }
 
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" added_lines="117" deleted_lines="0">
				<diff>@@ -1,3 +1,4 @@
+#include &lt;cmath&gt;
 #include &lt;cross_road_area.hpp&gt;
 #include &lt;euclidean_space.hpp&gt;
 
@@ -47,4 +48,120 @@ CrossRoadArea *CrossRoadArea::findClosestCrossRoad(const autoware_msgs::lane &amp;_f
 
   return _area;
 }
+
+std::vector&lt;geometry_msgs::Point&gt; convhull(const CrossRoadArea *_ClosestArea)
+{
+  std::vector&lt;int&gt; enablePoints;
+
+  // Jarvis's March algorithm
+  int l = 0;
+  for (auto i = begin(_ClosestArea-&gt;points); i != end(_ClosestArea-&gt;points); i++)
+  {
+    if (i-&gt;x &lt; _ClosestArea-&gt;points.at(l).x)
+    {
+      l = std::distance(begin(_ClosestArea-&gt;points), i);
+    }
+  }
+
+  int p = l;
+  int q;
+
+  do
+  {
+    q = (p + 1) % _ClosestArea-&gt;points.size();
+    for (int i = 0; i &lt; _ClosestArea-&gt;points.size(); i++)
+    {
+      geometry_msgs::Point pp = _ClosestArea-&gt;points.at(p);
+      geometry_msgs::Point pi = _ClosestArea-&gt;points.at(i);
+      geometry_msgs::Point pq = _ClosestArea-&gt;points.at(q);
+      if ((pi.y - pp.y) * (pq.x - pi.x) - (pi.x - pp.x) * (pq.y - pi.y) &lt; 0)
+      {
+        q = i;
+      }
+    }
+    enablePoints.push_back(p);
+    p = q;
+  } while (p != l);
+
+  std::vector&lt;geometry_msgs::Point&gt; point_arrays;
+  for (auto p = begin(_ClosestArea-&gt;points); p != end(_ClosestArea-&gt;points); p++)
+  {
+    for (auto &amp;en : enablePoints)
+    {
+      if (std::distance(begin(_ClosestArea-&gt;points), p) == en)
+      {
+        point_arrays.push_back(*p);
+      }
+    }
+  }
+  return point_arrays;
+}
+
+bool CrossRoadArea::isInsideArea(const CrossRoadArea *_ClosestArea, geometry_msgs::Point pt)
+{
+  std::vector&lt;geometry_msgs::Point&gt; point_arrays = convhull(_ClosestArea);
+
+  double rad = 0.0;
+  for (auto it = begin(point_arrays); it != end(point_arrays); ++it)
+  {
+    auto it_n = it + 1;
+    if (it == --point_arrays.end())
+    {
+      it_n = point_arrays.begin();
+    }
+
+    double ax = it-&gt;x - pt.x;
+    double ay = it-&gt;y - pt.y;
+    double bx = it_n-&gt;x - pt.x;
+    double by = it_n-&gt;y - pt.y;
+    double cos_ = (ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by));
+    if (cos_ &gt; 1.0)
+    {
+      cos_ = 1;
+    }
+    else if (cos_ &lt; -1.0)
+    {
+      cos_ = -1.0;
+    }
+
+    // deg += std::acos(cos_)? std::acos(cos_)/ M_PI * 180.0 : 0.0;
+    rad += std::acos(cos_) ? std::acos(cos_) : 0.0;
+  }
+  if (fabs((2 * M_PI) - rad) &lt;= 0.35 /*about 30 degree*/)
+  {
+    return true;
+  }
+
+  return false;
+#if 0
+	// Winding Number Algorithm 
+	// not working
+	int wn = 0;
+	double vt;
+
+	double s = 0;
+
+	for(size_t i = _ClosestArea-&gt;points.size()-1; i &gt; 0 ; i--){
+		auto it = _ClosestArea-&gt;points.at(i);
+		auto it_n = _ClosestArea-&gt;points.at(i-1);
+		std::cout &lt;&lt; "point[" &lt;&lt; i &lt;&lt; "]:" &lt;&lt; it.x &lt;&lt; "," &lt;&lt; it.y &lt;&lt; std::endl;
+		if( (it.y &lt;= pt.y ) &amp;&amp; (it_n.y &gt; pt.y)){
+			vt = (pt.y - it.y) / (it_n.y - pt.y);
+			if(pt.x &lt; it.x + (vt * (it_n.x - it.x))){
+				++wn;
+			}
+		}
+		else if( (it.y &gt; pt.y) &amp;&amp; (it_n.y &lt;= pt.y)) {
+			vt = (pt.y - it.y) / (it_n.y - pt.y);
+			if(pt.x &lt; ( it.x + (vt * (it_n.x - it.x)))){
+				--wn;
+			}
+		}
+
+	}
+	if(wn &gt; 0 ) return true;
+	else return false;
+
+#endif
+}
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="38" deleted_lines="13">
				<diff>@@ -18,7 +18,6 @@ namespace decision_maker
 {
 // TODO for Decision_maker
 // - lane_change
-// - change substate class to state_context
 // - fix a light_color_changed
 // - disable/clear_subclassa
 // - object detection
@@ -52,7 +51,7 @@ bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
 void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
 {
   ROS_INFO("Received forcing state changing request");
-  handleStateCmd((unsigned long long) 1 &lt;&lt; msg.data);
+  handleStateCmd((unsigned long long)1 &lt;&lt; msg.data);
 }
 
 void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
@@ -114,6 +113,32 @@ void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::Co
     Subs["points_raw"].shutdown();
 }
 
+// for based waypoint
+void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg)
+{
+  current_lane_array_ = msg;
+
+  for (auto &amp;area : intersects)
+  {
+    for (auto &amp;lane : msg.lanes)
+    {
+      for (auto &amp;wp : lane.waypoints)
+      {
+        geometry_msgs::Point pp;
+        pp.x = wp.pose.pose.position.x;
+        pp.y = wp.pose.pose.position.y;
+        pp.z = wp.pose.pose.position.z;
+        if (CrossRoadArea::isInsideArea(&amp;area, pp))
+        {
+          std::cout &lt;&lt; "Add to" &lt;&lt; area.area_id &lt;&lt; ": point" &lt;&lt; pp.x &lt;&lt; "," &lt;&lt; pp.y &lt;&lt; std::endl;
+          area.insideWaypoint_points.push_back(pp);
+          area.insideWaypoints.push_back(wp);
+        }
+      }
+    }
+  }
+}
+
 void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
 {
   if (!hasvMap())
@@ -126,21 +151,21 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
     std::cerr &lt;&lt; "State is not DRIVE_STATE[" &lt;&lt; ctx-&gt;getCurrentStateName() &lt;&lt; "]" &lt;&lt; std::endl;
     return;
   }
-
   // steering
   current_finalwaypoints_ = msg;
   ClosestArea_ = CrossRoadArea::findClosestCrossRoad(current_finalwaypoints_, intersects);
   double intersect_wayangle = calcIntersectWayAngle(current_finalwaypoints_, current_pose_);
-  // *Temporary implementation*
+
   // To straight/left/right recognition by using angle
   // between first-waypoint and end-waypoint in intersection area.
-  int temp = (int)std::floor(intersect_wayangle + 360.0) % 360;
-  if (std::abs(temp) &lt;= ANGLE_STRAIGHT)
-    ctx-&gt;setCurrentState(state_machine::DRIVE_STR_STRAIGHT_STATE);
-  else if (temp &lt;= ANGLE_RIGHT)
-    ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
-  else if (temp &lt;= ANGLE_LEFT)
+  int temp = (int)std::floor(intersect_wayangle + 180.0) % 360;
+
+  if (temp &lt;= ANGLE_LEFT)
     ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
+  else if (temp &gt;= ANGLE_RIGHT)
+    ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
+  else
+    ctx-&gt;setCurrentState(state_machine::DRIVE_STR_STRAIGHT_STATE);
 
   // velocity
   double _temp_sum = 0;
@@ -204,8 +229,8 @@ void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistSt
   current_velocity_ = mps2kmph(msg.twist.linear.x);
 }
 #if 0
-	void DecisionMakerNode::callbackFromDynamicReconfigure(decision_maker::decision_makerConfig &amp;config, uint32_t level){
-		ROS_INFO("Reconfigure Request: %d ", config.TARGET_WAYPOINT_COUNT);
-	}
+void DecisionMakerNode::callbackFromDynamicReconfigure(decision_maker::decision_makerConfig &amp;config, uint32_t level){
+	ROS_INFO("Reconfigure Request: %d ", config.TARGET_WAYPOINT_COUNT);
+}
 #endif
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" added_lines="8" deleted_lines="144">
				<diff>@@ -4,7 +4,6 @@
 #include &lt;std_msgs/Float64MultiArray.h&gt;
 #include &lt;std_msgs/String.h&gt;
 #include &lt;stdio.h&gt;
-#include &lt;tf/transform_listener.h&gt;
 
 // lib
 #include &lt;euclidean_space.hpp&gt;
@@ -23,74 +22,9 @@
 #include &lt;geometry_msgs/Pose.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 
+#define DEBUG_PRINT
 namespace decision_maker
 {
-CrossRoadArea *DecisionMakerNode::findClosestCrossRoad(void)
-{
-  CrossRoadArea *_area = nullptr;
-
-  euclidean_space::point _pa;
-  euclidean_space::point _pb;
-
-  double _min_distance = DBL_MAX;
-
-  int _label = 1;
-
-  if (!current_finalwaypoints_.waypoints.empty())
-  {
-    _pa.x = current_finalwaypoints_.waypoints[param_target_waypoint_].pose.pose.position.x;
-    _pa.y = current_finalwaypoints_.waypoints[param_target_waypoint_].pose.pose.position.y;
-    _pa.z = 0.0;
-  }
-
-  for (size_t i = 0; i &lt; intersects.size(); i++)
-  {
-    _pb.x = intersects[i].bbox.pose.position.x;
-    _pb.y = intersects[i].bbox.pose.position.y;
-
-    _pb.z = 0.0;
-
-    double __temp_dis = euclidean_space::EuclideanSpace::find_distance(&amp;_pa, &amp;_pb);
-
-    intersects[i].bbox.label = 0;
-    if (_min_distance &gt;= __temp_dis)
-    {
-      _area = &amp;intersects[i];
-      _min_distance = __temp_dis;  //
-    }
-  }
-
-  if (_area)
-  {
-    _area-&gt;bbox.label = 3;
-  }
-
-  return _area;
-}
-
-bool DecisionMakerNode::isInsideArea(geometry_msgs::Point pt)
-{
-  // simply implementation
-  //
-  if (ClosestArea_ != nullptr)
-  {
-    double x1 = ClosestArea_-&gt;bbox.pose.position.x - (ClosestArea_-&gt;bbox.dimensions.x / 2);
-    double x2 = ClosestArea_-&gt;bbox.pose.position.x + (ClosestArea_-&gt;bbox.dimensions.x / 2);
-
-    double y1 = ClosestArea_-&gt;bbox.pose.position.y - (ClosestArea_-&gt;bbox.dimensions.y / 2);
-    double y2 = ClosestArea_-&gt;bbox.pose.position.y + (ClosestArea_-&gt;bbox.dimensions.y / 2);
-
-    if ((x1 &lt;= pt.x &amp;&amp; pt.x &lt;= x2))
-    {
-      if (y1 &lt;= pt.y &amp;&amp; pt.y &lt;= y2)
-      {
-        return true;
-      }
-    }
-  }
-  return false;
-}
-
 bool DecisionMakerNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg,
                                                      const geometry_msgs::PoseStamped &amp;pose_msg)
 {
@@ -109,87 +43,12 @@ bool DecisionMakerNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;
 
   for (const auto &amp;cross_road_d : cross_road_srv.response.objects.data)
   {
-    //   std::cout &lt;&lt; "EEEEEEEEE" &lt;&lt; cross_road_d.linkid &lt;&lt; std::endl;
+    // for DEBUG
+    //   std::cout &lt;&lt; "DEBUG" &lt;&lt; cross_road_d.linkid &lt;&lt; std::endl;
   }
 #endif
 }
 
-double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_msg,
-                                                const geometry_msgs::PoseStamped &amp;pose_msg)
-{
-  if (vMap_CrossRoads_flag)
-  {
-    int FirstPoint = 0;
-    int EndPoint = 0;
-    int index = 0;
-    int PrevPoint = 0;
-    double diff = 0.0;
-    inside_points_.clear();
-    for (int index = 0; index &lt; lane_msg.waypoints.size(); index++)
-    {
-      if (isInsideArea(lane_msg.waypoints[index].pose.pose.position))
-      {
-        if (!FirstPoint)
-          FirstPoint = index;
-
-        inside_points_.push_back(lane_msg.waypoints[index].pose.pose.position);
-      }
-      else if (FirstPoint &amp;&amp; !EndPoint)
-      {
-        EndPoint = PrevPoint;
-        break;
-      }
-      PrevPoint = index;
-    }
-
-    if (EndPoint == 0)
-    {
-      std::cerr &lt;&lt; "Not inside Cross Road" &lt;&lt; std::endl;
-    }
-    else
-    {
-      geometry_msgs::Pose _end_point;
-      _end_point = lane_msg.waypoints[EndPoint].pose.pose;
-
-      double r, p, y, _y;
-
-      tf::Quaternion quat_end(_end_point.orientation.x, _end_point.orientation.y, _end_point.orientation.z,
-                              _end_point.orientation.w);
-      tf::Quaternion quat_in(pose_msg.pose.orientation.x, pose_msg.pose.orientation.y, pose_msg.pose.orientation.z,
-                             pose_msg.pose.orientation.w);
-
-      tf::Matrix3x3(quat_end).getRPY(r, p, y);
-      tf::Matrix3x3(quat_in).getRPY(r, p, _y);
-
-      diff = std::floor(_y - y) * 180.0 / M_PI;
-
-#ifdef DEBUG_PRINT
-      std::cout &lt;&lt; "Yaw:" &lt;&lt; _y &lt;&lt; "-" &lt;&lt; y &lt;&lt; ":" &lt;&lt; _y - y &lt;&lt; std::endl;
-      if (diff &gt; 50)
-      {
-        std::cout &lt;&lt; "Right Turn" &lt;&lt; diff &lt;&lt; std::endl;
-      }
-      else if (diff &lt; -50)
-      {
-        std::cout &lt;&lt; "Left Turn" &lt;&lt; diff &lt;&lt; std::endl;
-      }
-      else
-      {
-        std::cout &lt;&lt; "Straight" &lt;&lt; diff &lt;&lt; std::endl;
-      }
-      std::cout &lt;&lt; "Size:" &lt;&lt; lane_msg.waypoints.size() &lt;&lt; ":"
-                &lt;&lt; "First Point = " &lt;&lt; FirstPoint &lt;&lt; "/ End Point = " &lt;&lt; EndPoint &lt;&lt; std::endl;
-#endif
-    }
-
-    return diff;
-  }
-  else
-  {
-    return 0.0;
-  }
-}
-
 void DecisionMakerNode::update(void)
 {
   update_msgs();
@@ -204,9 +63,14 @@ void DecisionMakerNode::run(void)
   spinner.start();
   while (ros::ok())
   {
+    ros::Time begin = ros::Time::now();
     update();
     if (enableDisplayMarker)
       displayMarker();
+    ros::Duration exec_time = ros::Time::now() - begin;
+    std_msgs::Float64 exec_time_sec;
+    exec_time_sec.data = exec_time.toSec();
+    Pubs["exectime"].publish(exec_time_sec);
     loop_rate.sleep();
   }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" added_lines="49" deleted_lines="0">
				<diff>@@ -4,6 +4,7 @@
 #include &lt;jsk_rviz_plugins/OverlayText.h&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/String.h&gt;
+#include &lt;tf/transform_listener.h&gt;
 
 #include &lt;autoware_msgs/lane.h&gt;
 #include &lt;autoware_msgs/traffic_light.h&gt;
@@ -16,6 +17,54 @@
 
 namespace decision_maker
 {
+double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_msg,
+                                                const geometry_msgs::PoseStamped &amp;pose_msg)
+{
+  if (vMap_CrossRoads_flag &amp;&amp; ClosestArea_)
+  {
+    double diff = 0.0;
+    if (ClosestArea_-&gt;insideWaypoints.empty())
+    {
+      ROS_INFO("Not inside CrossRoad");
+    }
+    else
+    {
+      const geometry_msgs::Pose InPose = ClosestArea_-&gt;insideWaypoints.front().pose.pose;
+      const geometry_msgs::Pose OutPose = ClosestArea_-&gt;insideWaypoints.back().pose.pose;
+      double r, p, y, _y;
+
+      tf::Quaternion quat_end(OutPose.orientation.x, OutPose.orientation.y, OutPose.orientation.z,
+                              OutPose.orientation.w);
+
+      tf::Quaternion quat_in(InPose.orientation.x, InPose.orientation.y, InPose.orientation.z, InPose.orientation.w);
+
+      tf::Matrix3x3(quat_end).getRPY(r, p, y);
+      tf::Matrix3x3(quat_in).getRPY(r, p, _y);
+
+      diff = (_y - y) * 180.0 / M_PI;
+
+#ifdef DEBUG_PRINT
+      std::cout &lt;&lt; "Yaw:" &lt;&lt; _y &lt;&lt; "-" &lt;&lt; y &lt;&lt; ":" &lt;&lt; _y - y &lt;&lt; std::endl;
+      std::cout &lt;&lt; "In:" &lt;&lt; InPose.position.x &lt;&lt; "," &lt;&lt; InPose.position.y &lt;&lt; std::endl;
+      std::cout &lt;&lt; "End:" &lt;&lt; OutPose.position.x &lt;&lt; "," &lt;&lt; OutPose.position.y &lt;&lt; std::endl;
+      int temp = (int)std::floor(diff + 180) % 360;
+      if (temp &lt;= ANGLE_LEFT)
+        std::cout &lt;&lt; "LEFT :" &lt;&lt; temp &lt;&lt; std::endl;
+      else if (temp &gt;= ANGLE_RIGHT)
+        std::cout &lt;&lt; "RIGHT:" &lt;&lt; temp &lt;&lt; std::endl;
+      else
+        std::cout &lt;&lt; "Straight:" &lt;&lt; temp &lt;&lt; std::endl;
+#endif
+    }
+
+    return diff;
+  }
+  else
+  {
+    return 0.0;
+  }
+}
+
 bool DecisionMakerNode::isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch,
                                                   double _yaw)
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="20" deleted_lines="11">
				<diff>@@ -1,8 +1,8 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;ros/spinner.h&gt;
-#include &lt;std_msgs/Int32.h&gt;
 #include &lt;std_msgs/Float64.h&gt;
 #include &lt;std_msgs/Float64MultiArray.h&gt;
+#include &lt;std_msgs/Int32.h&gt;
 #include &lt;std_msgs/String.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;tf/transform_listener.h&gt;
@@ -62,15 +62,17 @@ void DecisionMakerNode::initROS(int argc, char **argv)
 
   // pub
   Pubs["state"] = nh_.advertise&lt;std_msgs::String&gt;("state", 1);
-  Pubs["state_overlay"] = nh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;("/state/overlay_text", 1);
 
-  Pubs["state_local_diffdistance"] = nh_.advertise&lt;std_msgs::Float64&gt;("/state/val_diff_distance", 1);
+  // for visualize
+  Pubs["state_overlay"] = nh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;("/state/overlay_text", 1);
+  Pubs["crossroad_marker"] = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("/state/cross_road_marker", 1);
+  Pubs["crossroad_inside_marker"] = nh_.advertise&lt;visualization_msgs::Marker&gt;("/state/cross_inside_marker", 1);
+  Pubs["crossroad_bbox"] = nh_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("/state/crossroad_bbox", 10);
 
-  Pubs["crossroad_visual"] = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("/state/cross_road_marker", 1);
-  Pubs["crossroad_inside_visual"] = nh_.advertise&lt;visualization_msgs::Marker&gt;("/state/cross_inside_marker", 1);
-  Pubs["crossroad_bbox"] = nh_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("/state/bbox", 10);
+  // for debug
   Pubs["target_velocity_array"] = nh_.advertise&lt;std_msgs::Float64MultiArray&gt;("/target_velocity_array", 1);
-
+  Pubs["state_local_diffdistance"] = nh_.advertise&lt;std_msgs::Float64&gt;("/state/val_diff_distance", 1);
+  Pubs["exectime"] = nh_.advertise&lt;std_msgs::Float64&gt;("/state/exectime", 1);
   // message setup
   state_text_msg.text_size = 18;
   state_text_msg.line_width = 0;
@@ -89,7 +91,7 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   {
     std::cout &lt;&lt; "wait for tf of map to world" &lt;&lt; std::endl;
     tf::TransformListener tf;
-    
+
     tf.waitForTransform("map", "world", ros::Time(), ros::Duration(15));
     if (!ctx-&gt;TFInitialized())
       std::cerr &lt;&lt; "failed initialization " &lt;&lt; std::endl;
@@ -131,6 +133,7 @@ void DecisionMakerNode::initVectorMap(void)
             {
               if (area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid)
               {
+                geometry_msgs::Point _prev_point;
                 for (const auto &amp;point : vMap_Points.data)
                 {
                   if (line.fpid &lt;= point.pid &amp;&amp; point.pid &lt;= line.fpid)
@@ -140,17 +143,21 @@ void DecisionMakerNode::initVectorMap(void)
                     _point.y = point.bx;
                     _point.z = point.h;
 
+                    if (_prev_point.x == _point.x &amp;&amp; _prev_point.y == _point.y)
+                      continue;
+
+                    _prev_point = _point;
+                    points_count++;
+                    carea.points.push_back(_point);
+
                     x_avg += _point.x;
                     y_avg += _point.y;
-
                     x_min = (x_min == 0.0) ? _point.x : std::min(_point.x, x_min);
                     x_max = (x_max == 0.0) ? _point.x : std::max(_point.x, x_max);
                     y_min = (y_min == 0.0) ? _point.y : std::min(_point.y, y_min);
                     y_max = (y_max == 0.0) ? _point.y : std::max(_point.y, y_max);
                     z = _point.z;
-                    points_count++;
 
-                    carea.points.push_back(_point);
                   }  // if pid
                 }    // points iter
               }      // if lid
@@ -168,6 +175,8 @@ void DecisionMakerNode::initVectorMap(void)
       }
     }
     vMap_mutex.unlock();
+    Subs["lane_waypoints_array"] =
+        nh_.subscribe("lane_waypoints_array", 100, &amp;DecisionMakerNode::callbackFromLaneWaypoint, this);
   }
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="11" deleted_lines="17">
				<diff>@@ -62,39 +62,33 @@ void DecisionMakerNode::displayMarker(void)
   crossroad_marker.lifetime = ros::Duration(0.3);
 
   inside_marker = crossroad_marker;
+  inside_marker.scale.x = scale / 3;
+  inside_marker.scale.y = scale / 3;
+  inside_marker.scale.z = 0.5;
   inside_marker.color.a = 0.5;
   inside_marker.color.r = 1.0;
-  inside_marker.color.g = 1.0;
+  inside_marker.color.g = 0.0;
   inside_marker.color.b = 0.0;
   inside_marker.ns = "inside";
   inside_marker.lifetime = ros::Duration();
 
   bbox_array.header = crossroad_marker.header;
 
+  inside_marker.points.clear();
+
   for (auto &amp;area : intersects)
   {
-    for (const auto &amp;p : area.points)
-    {
-      // if(isInsideArea(p))
-      // inside_marker.points.push_back(p);
-      crossroad_marker.points.push_back(p);
-    }
     area.bbox.header = crossroad_marker.header;
     bbox_array.boxes.push_back(area.bbox);
+    for (const auto &amp;p : area.insideWaypoint_points)
+    {
+      inside_marker.points.push_back(p);
+    }
   }
 
   Pubs["crossroad_bbox"].publish(bbox_array);
   bbox_array.boxes.clear();
-
-  // marker_array.markers.push_back(inside_marker);
-  marker_array.markers.push_back(crossroad_marker);
-
-  Pubs["crossroad_visual"].publish(marker_array);
-
-  for (const auto &amp;p : inside_points_)
-    inside_marker.points.push_back(p);
-
-  Pubs["crossroad_inside_visual"].publish(inside_marker);
+  Pubs["crossroad_inside_marker"].publish(inside_marker);
 
   marker_array.markers.clear();
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8836bab6d7a8337d7eddb7d3bb16d9938b428674" author="Yuki Iida">
		<msg>change filename extension yaml to yml</msg>
		<modified_files>
			<file old_path="ros\src\socket\packages\mqtt_socket\include\mqtt_socket\mqtt_setting.hpp" new_path="ros\src\socket\packages\mqtt_socket\include\mqtt_socket\mqtt_setting.hpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,5 +1,5 @@
 #define MQTT_NODE_NAME "mqtt_socket"
-#define MQTT_CONFIG_FILE_NAME "/mqtt_config.yaml"
+#define MQTT_CONFIG_FILE_NAME "/mqtt_config.yml"
 
 // MODE
 #define AUTO_MODE       1
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d84a0823a72cc6b215ef6c52110e42a57f73ef53" author="Yusuke FUJII">
		<msg>add waypoint relay</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="6" deleted_lines="1">
				<diff>@@ -48,13 +48,18 @@ WaypointLoaderNode::~WaypointLoaderNode()
 void WaypointLoaderNode::initPublisher()
 {
   // setup publisher
-  lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("lane_waypoints_array", 10, true);
+  if(disableDicisionMaker_){
+	  lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("/lane_waypoints_array", 10, true);
+  }else{
+	  lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("/based/lane_waypoints_array", 10, true);
+  }
 }
 
 void WaypointLoaderNode::initParameter()
 {
   // parameter settings
   private_nh_.param&lt;double&gt;("decelerate", decelerate_, double(0));
+  private_nh_.param&lt;bool&gt;("disableDicisionMaker", disableDicisionMaker_, true);
   ROS_INFO_STREAM("decelerate :" &lt;&lt; decelerate_);
   private_nh_.param&lt;std::string&gt;("multi_lane_csv", multi_lane_csv_, MULTI_LANE_CSV);
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" added_lines="1" deleted_lines="0">
				<diff>@@ -89,6 +89,7 @@ private:
   // variables
   std::string multi_lane_csv_;
   double decelerate_;
+  bool disableDecisionMaker_;
 
   // initializer
   void initPublisher();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d1c4f85afc0a73ddca71270e5eacbf58b48bad95" author="Yusuke FUJII">
		<msg>add path velocity smoothing</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_rule\lane_rule.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_rule\lane_rule.cpp" added_lines="19" deleted_lines="0">
				<diff>@@ -48,6 +48,7 @@ double config_acceleration = 1; // m/s^2
 double config_stopline_search_radius = 1; // meter
 int config_number_of_zeros_ahead = 0;
 int config_number_of_zeros_behind = 0;
+int config_number_of_smoothing_count = 0;
 
 int waypoint_max;
 double search_radius; // meter
@@ -420,6 +421,23 @@ void create_waypoint(const autoware_msgs::LaneArray&amp; msg)
 			}
 		}
 
+		/* velocity smoothing */
+		for(int k = 0; k &lt; config_number_of_smoothing_count; ++k){
+			autoware_msgs::lane temp_lane = lane;
+			if(lane.waypoints.size() &gt;= 3){
+				for (size_t j = 1; j &lt; lane.waypoints.size()-1; ++j) {
+					if(lane.waypoints.at(j).twist.twist.linear.x != 0)
+					{
+						lane.waypoints[j].twist.twist.linear.x = 
+							(temp_lane.waypoints.at(j-1).twist.twist.linear.x + 
+							 temp_lane.waypoints.at(j).twist.twist.linear.x + 
+							 temp_lane.waypoints.at(j+1).twist.twist.linear.x) / 3 ;
+					}
+				}
+			}
+		}
+
+
 		lane = apply_crossroad_acceleration(lane, config_acceleration);
 
 		traffic_waypoint.lanes.push_back(lane);
@@ -529,6 +547,7 @@ void config_parameter(const autoware_msgs::ConfigLaneRule&amp; msg)
 	config_stopline_search_radius = msg.stopline_search_radius;
 	config_number_of_zeros_ahead = msg.number_of_zeros_ahead;
 	config_number_of_zeros_behind = msg.number_of_zeros_behind;
+	config_number_of_smoothing_count = msg.number_of_smoothing_count;
 
 	if (!cached_waypoint.lanes.empty()) {
 		autoware_msgs::LaneArray update_waypoint = cached_waypoint;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d4d24e5fe7c40a415808f1e01450d025a32c539f" author="Akihito Ohsato">
		<msg>Rename and merge msgs</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" added_lines="15" deleted_lines="15">
				<diff>@@ -50,7 +50,7 @@
 class TwistGate
 {
   using remote_msgs_t = autoware_msgs::RemoteCmd;
-  using twist_gate_msgs_t = autoware_msgs::TwistGate;
+  using vehicle_cmd_msg_t = autoware_msgs::VehicleCmd;
 
   public:
     TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_nh);
@@ -77,7 +77,7 @@ class TwistGate
     ros::Subscriber remote_cmd_sub_;
     std::map&lt;std::string , ros::Subscriber&gt; auto_cmd_sub_stdmap_;
 
-    twist_gate_msgs_t twist_gate_msg_;
+    vehicle_cmd_msg_t twist_gate_msg_;
     std_msgs::Bool emergency_stop_msg_;
     ros::Time remote_cmd_time_;
     ros::Duration timeout_period_;
@@ -96,7 +96,7 @@ TwistGate::TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_n
 {
   emergency_stop_pub_ = nh_.advertise&lt;std_msgs::Bool&gt;("/emergency_stop", 1, true);
   control_command_pub_ = nh_.advertise&lt;std_msgs::String&gt;("/ctrl_mode", 1);
-  vehicle_cmd_pub_ = nh_.advertise&lt;twist_gate_msgs_t&gt;("/vehicle_cmd", 1, true);
+  vehicle_cmd_pub_ = nh_.advertise&lt;vehicle_cmd_msg_t&gt;("/vehicle_cmd", 1, true);
 
   remote_cmd_sub_ = nh_.subscribe("/remote_cmd", 1, &amp;TwistGate::remote_cmd_callback, this);
 
@@ -188,23 +188,23 @@ void TwistGate::watchdog_timer()
 void TwistGate::remote_cmd_callback(const remote_msgs_t::ConstPtr&amp; input_msg)
 {
   command_mode_ = static_cast&lt;CommandMode&gt;(input_msg-&gt;control_mode);
-  emergency_stop_msg_.data = static_cast&lt;bool&gt;(input_msg-&gt;emergency);
+  emergency_stop_msg_.data = static_cast&lt;bool&gt;(input_msg-&gt;vehicle_cmd.emergency);
   remote_cmd_time_ = ros::Time::now();
 
   if(command_mode_ == CommandMode::REMOTE)
   {
-    twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
-    twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
+    twist_gate_msg_.header.frame_id = input_msg-&gt;vehicle_cmd.header.frame_id;
+    twist_gate_msg_.header.stamp = input_msg-&gt;vehicle_cmd.header.stamp;
     twist_gate_msg_.header.seq++;
-    twist_gate_msg_.twist_cmd.twist = input_msg-&gt;twist_cmd.twist;
-    twist_gate_msg_.ctrl_cmd  = input_msg-&gt;ctrl_cmd;
-    twist_gate_msg_.accel_cmd = input_msg-&gt;accel_cmd;
-    twist_gate_msg_.brake_cmd = input_msg-&gt;brake_cmd;
-    twist_gate_msg_.steer_cmd = input_msg-&gt;steer_cmd;
-    twist_gate_msg_.gear = input_msg-&gt;gear;
-    twist_gate_msg_.lamp_cmd = input_msg-&gt;lamp_cmd;
-    twist_gate_msg_.mode = input_msg-&gt;mode;
-    twist_gate_msg_.emergency = input_msg-&gt;emergency;
+    twist_gate_msg_.twist_cmd.twist = input_msg-&gt;vehicle_cmd.twist_cmd.twist;
+    twist_gate_msg_.ctrl_cmd  = input_msg-&gt;vehicle_cmd.ctrl_cmd;
+    twist_gate_msg_.accel_cmd = input_msg-&gt;vehicle_cmd.accel_cmd;
+    twist_gate_msg_.brake_cmd = input_msg-&gt;vehicle_cmd.brake_cmd;
+    twist_gate_msg_.steer_cmd = input_msg-&gt;vehicle_cmd.steer_cmd;
+    twist_gate_msg_.gear = input_msg-&gt;vehicle_cmd.gear;
+    twist_gate_msg_.lamp_cmd = input_msg-&gt;vehicle_cmd.lamp_cmd;
+    twist_gate_msg_.mode = input_msg-&gt;vehicle_cmd.mode;
+    twist_gate_msg_.emergency = input_msg-&gt;vehicle_cmd.emergency;
     vehicle_cmd_pub_.publish(twist_gate_msg_);
   }
 }
</diff>
			</file>
			<file old_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_receiver\mqtt_receiver.cpp" new_path="ros\src\socket\packages\mqtt_socket\nodes\mqtt_receiver\mqtt_receiver.cpp" added_lines="16" deleted_lines="16">
				<diff>@@ -140,37 +140,37 @@ static void MqttReceiver::on_message(struct mosquitto *mosq, void *obj, const st
 
     if(cmds.size() == 8) {
       autoware_msgs::RemoteCmd msg;
-      msg.steer_cmd.steer = stof(cmds[0]) * steer_max_val;
-      msg.accel_cmd.accel = stof(cmds[1]) * accel_max_val;
-      msg.brake_cmd.brake = stof(cmds[2]) * brake_max_val;
-      msg.gear = stoi(cmds[3]);
+      msg.vehicle_cmd.steer_cmd.steer = stof(cmds[0]) * steer_max_val;
+      msg.vehicle_cmd.accel_cmd.accel = stof(cmds[1]) * accel_max_val;
+      msg.vehicle_cmd.brake_cmd.brake = stof(cmds[2]) * brake_max_val;
+      msg.vehicle_cmd.gear = stoi(cmds[3]);
       // lamp
       switch(stoi(cmds[4])) {
-        msg.lamp_cmd.l = 0;
-        msg.lamp_cmd.r = 0;
+        msg.vehicle_cmd.lamp_cmd.l = 0;
+        msg.vehicle_cmd.lamp_cmd.r = 0;
         case 0:
           break;
         case 1:
-          msg.lamp_cmd.l = 1;
+          msg.vehicle_cmd.lamp_cmd.l = 1;
           break;
         case 2:
-          msg.lamp_cmd.r = 1;
+          msg.vehicle_cmd.lamp_cmd.r = 1;
           break;
         case 3:
-          msg.lamp_cmd.l = 1;
-          msg.lamp_cmd.r = 1;
+          msg.vehicle_cmd.lamp_cmd.l = 1;
+          msg.vehicle_cmd.lamp_cmd.r = 1;
           break;
         default:
           ROS_WARN("Invalid lamp_cmd");
           break;
       }
-      msg.twist_cmd.twist.linear.x = stof(cmds[1]) * linear_x_max_val;
-      msg.twist_cmd.twist.angular.z = stof(cmds[0]);
-      msg.ctrl_cmd.linear_velocity = stof(cmds[1]) * linear_x_max_val;
-      msg.ctrl_cmd.steering_angle = stof(cmds[0]) * steer_max_val;
-      msg.mode = stoi(cmds[5]);
+      msg.vehicle_cmd.twist_cmd.twist.linear.x = stof(cmds[1]) * linear_x_max_val;
+      msg.vehicle_cmd.twist_cmd.twist.angular.z = stof(cmds[0]);
+      msg.vehicle_cmd.ctrl_cmd.linear_velocity = stof(cmds[1]) * linear_x_max_val;
+      msg.vehicle_cmd.ctrl_cmd.steering_angle = stof(cmds[0]) * steer_max_val;
+      msg.vehicle_cmd.mode = stoi(cmds[5]);
+      msg.vehicle_cmd.emergency = stoi(cmds[7]);
       msg.control_mode = stoi(cmds[6]);
-      msg.emergency = stoi(cmds[7]);
       remote_cmd_pub.publish(msg);
     }
     else {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6bbd0a4727968820791e6f925f16818ca03673df" author="Akihito Ohsato">
		<msg>Fix build error</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\twist_gate\twist_gate.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -39,7 +39,7 @@
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 
 #include "autoware_msgs/RemoteCmd.h"
-#include "autoware_msgs/TwistGate.h"
+#include "autoware_msgs/VehicleCmd.h"
 #include "tablet_socket_msgs/mode_cmd.h"
 #include "tablet_socket_msgs/gear_cmd.h"
 #include "autoware_msgs/accel_cmd.h"
</diff>
			</file>
			<file old_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_sender\vehicle_sender.cpp" new_path="ros\src\socket\packages\vehicle_socket\nodes\vehicle_sender\vehicle_sender.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -29,7 +29,7 @@
 */
 
 #include &lt;ros/ros.h&gt;
-#include "autoware_msgs/TwistGate.h"
+#include "autoware_msgs/VehicleCmd.h"
 
 #include &lt;iostream&gt;
 #include &lt;string&gt;
@@ -72,7 +72,7 @@ void CommandData::reset()
 
 static CommandData command_data;
 
-static void twistGateCallback(const autoware_msgs::TwistGate&amp; msg)
+static void vehicleCmdCallback(const autoware_msgs::VehicleCmd&amp; msg)
 {
   command_data.linear_x = msg.twist_cmd.twist.linear.x;
   command_data.angular_z = msg.twist_cmd.twist.angular.z;
@@ -197,7 +197,7 @@ int main(int argc, char **argv)
   ros::NodeHandle nh;
 
   std::cout &lt;&lt; "vehicle sender" &lt;&lt; std::endl;
-  ros::Subscriber sub = nh.subscribe("/vehicle_cmd", 1, twistGateCallback);
+  ros::Subscriber sub = nh.subscribe("/vehicle_cmd", 1, vehicleCmdCallback);
 
   command_data.reset();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="42092c4d7cee3be6e4a640033379978f49fd1015" author="Yusuke FUJII">
		<msg>add smoothing on waypoint loader</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.cpp" added_lines="16" deleted_lines="2">
				<diff>@@ -48,7 +48,7 @@ WaypointLoaderNode::~WaypointLoaderNode()
 void WaypointLoaderNode::initPublisher()
 {
   // setup publisher
-  if(disableDicisionMaker_){
+  if(disableDecisionMaker_){
 	  lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("/lane_waypoints_array", 10, true);
   }else{
 	  lane_pub_ = nh_.advertise&lt;autoware_msgs::LaneArray&gt;("/based/lane_waypoints_array", 10, true);
@@ -59,7 +59,8 @@ void WaypointLoaderNode::initParameter()
 {
   // parameter settings
   private_nh_.param&lt;double&gt;("decelerate", decelerate_, double(0));
-  private_nh_.param&lt;bool&gt;("disableDicisionMaker", disableDicisionMaker_, true);
+  private_nh_.param&lt;bool&gt;("disableDecisionMaker", disableDecisionMaker_, true);
+  private_nh_.param&lt;bool&gt;("disableVelocitySmoothing", disableVelocitySmoothing_, false);
   ROS_INFO_STREAM("decelerate :" &lt;&lt; decelerate_);
   private_nh_.param&lt;std::string&gt;("multi_lane_csv", multi_lane_csv_, MULTI_LANE_CSV);
 }
@@ -262,11 +263,24 @@ FileFormat WaypointLoaderNode::checkFileFormat(const char *filename)
 
 void WaypointLoaderNode::planningVelocity(std::vector&lt;autoware_msgs::waypoint&gt; *wps)
 {
+
   for (size_t i = 0; i &lt; wps-&gt;size(); ++i)
   {
     wps-&gt;at(i).twist.twist.linear.x = decelerate(
       wps-&gt;at(i).pose.pose.position, wps-&gt;at(wps-&gt;size() - 1).pose.pose.position, wps-&gt;at(i).twist.twist.linear.x);
   }
+
+  if(!disableVelocitySmoothing_){
+	  std::vector&lt;autoware_msgs::waypoint&gt; temp = *wps;
+	  if(temp.size() &gt; 3){
+		  for (size_t i = 1; i&lt; wps-&gt;size()-1; ++i){
+			  wps-&gt;at(i).twist.twist.linear.x = 
+				  (temp.at(i-1).twist.twist.linear.x + 
+				   temp.at(i-1).twist.twist.linear.x + 
+				   temp.at(i-1).twist.twist.linear.x) / 3;
+		  }
+	  }
+  }
 }
 
 double WaypointLoaderNode::decelerate(geometry_msgs::Point p1, geometry_msgs::Point p2, double original_velocity_mps)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" new_path="ros\src\computing\planning\motion\packages\waypoint_maker\nodes\waypoint_loader\waypoint_loader_core.h" added_lines="1" deleted_lines="0">
				<diff>@@ -90,6 +90,7 @@ private:
   std::string multi_lane_csv_;
   double decelerate_;
   bool disableDecisionMaker_;
+  bool disableVelocitySmoothing_;
 
   // initializer
   void initPublisher();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4f98cd64f134e77de5144f67fd287713ba955199" author="anhnv-3991">
		<msg>Add ndt_cpu library</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="86" deleted_lines="21">
				<diff>@@ -64,16 +64,24 @@
 #include &lt;fast_pcl/registration/ndt.h&gt;
 #endif
 
+
 #ifndef USE_FAST_PCL
 #include &lt;pcl/filters/voxel_grid.h&gt;
 #include &lt;pcl/registration/ndt.h&gt;
 #endif
 
+
 #include &lt;autoware_msgs/ConfigNdtMapping.h&gt;
 #include &lt;autoware_msgs/ConfigNdtMappingOutput.h&gt;
 
 #include &lt;time.h&gt;
 
+
+#include &lt;fast_pcl/ndt_cpu/NormalDistributionsTransform.h&gt;
+#include &lt;fast_pcl/filters/voxel_grid.h&gt; //??
+#include &lt;fast_pcl/registration/ndt.h&gt;	//??
+
+
 struct pose
 {
   double x;
@@ -113,6 +121,10 @@ static pcl::PointCloud&lt;pcl::PointXYZI&gt; map;
 #ifdef CUDA_FOUND
 static gpu::GNormalDistributionsTransform gpu_ndt;
 #endif
+
+// Added for CPU ndt testing version
+static cpu::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt; cpu_ndt;
+
 static pcl::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt; ndt;
 // end of adding
 
@@ -156,6 +168,8 @@ static bool _use_openmp = false;
 static bool _use_gpu = false;
 #endif
 
+static bool _use_fast_pcl = false;
+
 static bool _use_imu = false;
 static bool _use_odom = false;
 static bool _imu_upside_down = false;
@@ -519,11 +533,22 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   else
 #endif
   {
-    ndt.setTransformationEpsilon(trans_eps);
-    ndt.setStepSize(step_size);
-    ndt.setResolution(ndt_res);
-    ndt.setMaximumIterations(max_iter);
-    ndt.setInputSource(filtered_scan_ptr);
+	  if (!_use_fast_pcl)
+	  {
+		ndt.setTransformationEpsilon(trans_eps);
+		ndt.setStepSize(step_size);
+		ndt.setResolution(ndt_res);
+		ndt.setMaximumIterations(max_iter);
+		ndt.setInputSource(filtered_scan_ptr);
+	  }
+	  else
+	  {
+		cpu_ndt.setTransformationEpsilon(trans_eps);
+		cpu_ndt.setStepSize(step_size);
+		cpu_ndt.setResolution(ndt_res);
+		cpu_ndt.setMaximumIterations(max_iter);
+		cpu_ndt.setInputSource(filtered_scan_ptr);
+	  }
   }
   if (isMapUpdate == true)
   {
@@ -534,10 +559,24 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     }
     else
     {
-      ndt.setInputTarget(map_ptr);
+    	if (!_use_fast_pcl)
+    	{
+    		ndt.setInputTarget(map_ptr);
+    	}
+		else
+		{
+			cpu_ndt.setInputTarget(map_ptr);
+		}
     }
 #else
-    ndt.setInputTarget(map_ptr);
+    	if (!_use_fast_pcl)
+    	{
+    		ndt.setInputTarget(map_ptr);
+    	}
+    	else
+    	{
+    		cpu_ndt.setInputTarget(map_ptr);
+    	}
 #endif
 
     isMapUpdate = false;
@@ -582,16 +621,16 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   t4_start = ros::Time::now();
 
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
-  std::cout &lt;&lt; "Start aligning" &lt;&lt; std::endl;
 
 #ifdef CUDA_FOUND
+
   if (_use_gpu == true)
   {
     gpu_ndt.align(init_guess);
     t_localizer = gpu_ndt.getFinalTransformation();
     has_converged = gpu_ndt.hasConverged();
     fitness_score = gpu_ndt.getFitnessScore();
-    final_num_iteration = ndt.getFinalNumIteration();
+    final_num_iteration = gpu_ndt.getFinalNumIteration();
   }
 #ifdef USE_FAST_PCL
   else if (_use_openmp == true)
@@ -605,16 +644,28 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 #endif
   else
   {
-    ndt.align(*output_cloud, init_guess);
-    t_localizer = ndt.getFinalTransformation();
-    has_converged = ndt.hasConverged();
-    fitness_score = ndt.getFitnessScore();
-    final_num_iteration = ndt.getFinalNumIteration();
+	  if (!_use_fast_pcl)
+	  {
+		ndt.align(*output_cloud, init_guess);
+		t_localizer = ndt.getFinalTransformation();
+		has_converged = ndt.hasConverged();
+		fitness_score = ndt.getFitnessScore();
+		final_num_iteration = ndt.getFinalNumIteration();
+	  }
+	  else
+	  {
+		cpu_ndt.align(init_guess);
+		t_localizer = cpu_ndt.getFinalTransformation();
+		has_converged = cpu_ndt.hasConverged();
+		fitness_score = cpu_ndt.getFitnessScore();
+		final_num_iteration = cpu_ndt.getFinalNumIteration();
+	  }
   }
 #else
 #ifdef USE_FAST_PCL
   if (_use_openmp == true)
   {
+
     ndt.omp_align(*output_cloud, init_guess);
     t_localizer = ndt.getFinalTransformation();
     has_converged = ndt.hasConverged;
@@ -624,18 +675,29 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   else
   {
 #endif
-    // Added for GPU ndt
-    ndt.align(*output_cloud, init_guess);
-    t_localizer = ndt.getFinalTransformation();
-    has_converged = ndt.hasConverged();
-    fitness_score = ndt.getFitnessScore();
-    final_num_iteration = ndt.getFinalNumIteration();
-// End of adding GPU ndt
+	  if (!_use_fast_pcl)
+	  {
+		ndt.align(*output_cloud, init_guess);
+		t_localizer = ndt.getFinalTransformation();
+		has_converged = ndt.hasConverged();
+		fitness_score = ndt.getFitnessScore();
+		final_num_iteration = ndt.getFinalNumIteration();
+	  }
+	  else
+	  {
+		cpu_ndt.align(init_guess);
+		t_localizer = cpu_ndt.getFinalTransformation();
+		has_converged = cpu_ndt.hasConverged();
+		fitness_score = cpu_ndt.getFitnessScore();
+		final_num_iteration = cpu_ndt.getFinalNumIteration();
+	  }
 #ifdef USE_FAST_PCL
   }
 #endif
 #endif
 
+
+
   t_base_link = t_localizer * tf_ltob;
 
   pcl::transformPointCloud(*scan_ptr, *transformed_scan_ptr, t_localizer);
@@ -869,6 +931,7 @@ int main(int argc, char** argv)
   offset_imu_odom_pitch = 0.0;
   offset_imu_odom_yaw = 0.0;
 
+  std::cout &lt;&lt; "INITIALILZEEEEEEEEEEEEEEEEEEEEEEEE" &lt;&lt; std::endl;
   ros::init(argc, argv, "ndt_mapping");
 
   ros::NodeHandle nh;
@@ -883,6 +946,8 @@ int main(int argc, char** argv)
   private_nh.getParam("use_openmp", _use_openmp);
   std::cout &lt;&lt; "use_openmp: " &lt;&lt; _use_openmp &lt;&lt; std::endl;
 #endif
+
+  private_nh.getParam("use_fast_pcl", _use_fast_pcl);
   private_nh.getParam("use_imu", _use_imu);
   private_nh.getParam("use_odom", _use_odom);
   private_nh.getParam("imu_upside_down", _imu_upside_down);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="102" deleted_lines="20">
				<diff>@@ -68,10 +68,13 @@
 #include &lt;fast_pcl/registration/ndt.h&gt;
 #endif
 
+
 #ifndef USE_FAST_PCL
 #include &lt;pcl/registration/ndt.h&gt;
 #endif
 
+//End of adding
+
 #include &lt;pcl_ros/point_cloud.h&gt;
 #include &lt;pcl_ros/transforms.h&gt;
 
@@ -79,6 +82,10 @@
 
 #include &lt;autoware_msgs/ndt_stat.h&gt;
 
+//Added for testing on cpu
+#include &lt;fast_pcl/ndt_cpu/NormalDistributionsTransform.h&gt;
+//End of adding
+
 #define PREDICT_POSE_THRESHOLD 0.5
 
 #define Wa 0.4
@@ -116,6 +123,10 @@ static int init_pos_set = 0;
 #ifdef CUDA_FOUND
 static gpu::GNormalDistributionsTransform gpu_ndt;
 #endif
+
+
+static cpu::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; cpu_ndt;
+
 static pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt;
 
 // Default values
@@ -216,6 +227,8 @@ static bool _use_gpu = false;
 static bool _use_openmp = false;
 #endif
 
+static bool _use_fast_pcl = true;
+
 static bool _get_height = false;
 static bool _use_local_transform = false;
 static bool _use_imu = false;
@@ -260,7 +273,14 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
     else
     {
 #endif
-      ndt.setResolution(ndt_res);
+		if (!_use_fast_pcl)
+		{
+		  ndt.setResolution(ndt_res);
+		}
+		else
+		{
+		  cpu_ndt.setResolution(ndt_res);
+		}
 #ifdef CUDA_FOUND
     }
 #endif
@@ -276,7 +296,14 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
     else
     {
 #endif
-      ndt.setStepSize(step_size);
+		if (!_use_fast_pcl)
+		{
+		  ndt.setStepSize(step_size);
+		}
+		else
+		{
+		  cpu_ndt.setStepSize(step_size);
+		}
 #ifdef CUDA_FOUND
     }
 #endif
@@ -292,7 +319,14 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
     else
     {
 #endif
-      ndt.setTransformationEpsilon(trans_eps);
+		if (!_use_fast_pcl)
+		{
+		  ndt.setTransformationEpsilon(trans_eps);
+		}
+		else
+		{
+		  cpu_ndt.setTransformationEpsilon(trans_eps);
+		}
 #ifdef CUDA_FOUND
     }
 #endif
@@ -308,7 +342,14 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
     else
     {
 #endif
-      ndt.setMaximumIterations(max_iter);
+		if (!_use_fast_pcl)
+		{
+		  ndt.setMaximumIterations(max_iter);
+		}
+		else
+		{
+		  cpu_ndt.setMaximumIterations(max_iter);
+		}
 #ifdef CUDA_FOUND
     }
 #endif
@@ -411,6 +452,8 @@ static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     }
 
     pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(map));
+
+
 // Setting point cloud to be aligned to.
 #ifdef CUDA_FOUND
     if (_use_gpu == true)
@@ -424,11 +467,22 @@ static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     else
     {
 #endif
-      ndt.setInputTarget(map_ptr);
-      ndt.setMaximumIterations(max_iter);
-      ndt.setResolution(ndt_res);
-      ndt.setStepSize(step_size);
-      ndt.setTransformationEpsilon(trans_eps);
+		if (!_use_fast_pcl)
+		{
+		  ndt.setInputTarget(map_ptr);
+		  ndt.setMaximumIterations(max_iter);
+		  ndt.setResolution(ndt_res);
+		  ndt.setStepSize(step_size);
+		  ndt.setTransformationEpsilon(trans_eps);
+		}
+		else
+		{
+		  cpu_ndt.setInputTarget(map_ptr);
+		  cpu_ndt.setMaximumIterations(max_iter);
+		  cpu_ndt.setResolution(ndt_res);
+		  cpu_ndt.setStepSize(step_size);
+		  cpu_ndt.setTransformationEpsilon(trans_eps);
+		}
 #ifdef CUDA_FOUND
     }
 #endif
@@ -820,7 +874,14 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     else
     {
 #endif
-      ndt.setInputSource(filtered_scan_ptr);
+		if (!_use_fast_pcl)
+		{
+		  ndt.setInputSource(filtered_scan_ptr);
+		}
+		else
+		{
+		  cpu_ndt.setInputSource(filtered_scan_ptr);
+		}
 #ifdef CUDA_FOUND
     }
 #endif
@@ -897,20 +958,40 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 #endif
     else
     {
-      align_start = std::chrono::system_clock::now();
-      ndt.align(*output_cloud, init_guess);
-      align_end = std::chrono::system_clock::now();
+    	if (!_use_fast_pcl)
+    	{
+		  align_start = std::chrono::system_clock::now();
+		  ndt.align(*output_cloud, init_guess);
+		  align_end = std::chrono::system_clock::now();
 
-      has_converged = ndt.hasConverged();
+		  has_converged = ndt.hasConverged();
 
-      t = ndt.getFinalTransformation();
-      iteration = ndt.getFinalNumIteration();
+		  t = ndt.getFinalTransformation();
+		  iteration = ndt.getFinalNumIteration();
 
-      getFitnessScore_start = std::chrono::system_clock::now();
-      fitness_score = ndt.getFitnessScore();
-      getFitnessScore_end = std::chrono::system_clock::now();
+		  getFitnessScore_start = std::chrono::system_clock::now();
+		  fitness_score = ndt.getFitnessScore();
+		  getFitnessScore_end = std::chrono::system_clock::now();
 
-      trans_probability = ndt.getTransformationProbability();
+		  trans_probability = ndt.getTransformationProbability();
+    	}
+    	else
+    	{
+		  align_start = std::chrono::system_clock::now();
+		  cpu_ndt.align(init_guess);
+		  align_end = std::chrono::system_clock::now();
+
+		  has_converged = cpu_ndt.hasConverged();
+
+		  t = cpu_ndt.getFinalTransformation();
+		  iteration = cpu_ndt.getFinalNumIteration();
+
+		  getFitnessScore_start = std::chrono::system_clock::now();
+		  fitness_score = cpu_ndt.getFitnessScore();
+		  getFitnessScore_end = std::chrono::system_clock::now();
+
+		  trans_probability = cpu_ndt.getTransformationProbability();
+    	}
     }
 #else
 #ifdef USE_FAST_PCL
@@ -1401,6 +1482,7 @@ int main(int argc, char** argv)
 #ifdef CUDA_FOUND
   private_nh.getParam("use_gpu", _use_gpu);
 #endif
+  private_nh.getParam("use_fast_pcl", _use_fast_pcl);
   private_nh.getParam("get_height", _get_height);
   private_nh.getParam("use_local_transform", _use_local_transform);
   private_nh.getParam("use_imu", _use_imu);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f42a35efcadc41b015e7525b4cb4b031c5b2b220" author="hatem-darweesh">
		<msg>- Update OpenPlanner libraries (plannerh, simuh, utilityh) with the latest modifications
- Fix inconsistency after library update, make sure old (way_planner, dp_planner) are working fine
- Create new package (op_local_planner)
- Create common launch file for local planning params
- Create new node (op_trajectory_generator)
- Create launch file for trajectory generation only
- Test generating trajectories (rollouts) in simulation with way_planner
- Test generating trajectories with real rosbag data with way_planner
- Test generating trajectories with real rosbag data and waypoints_loader</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\GridMap.h" new_path="" added_lines="0" deleted_lines="230">
				<diff>@@ -1,230 +0,0 @@
-/*
- * GridMap.h
- *
- *  Created on: May 14, 2016
- *      Author: hatem
- */
-
-#ifndef GRIDMAPSA_H_
-#define GRIDMAPSA_H_
-
-#include "RoadNetwork.h"
-
-namespace PlannerHNS
-{
-
-#define get2dIndex(r,c,w) r*w + c
-#define checkGridLimit(r,c,h,w) r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt; h &amp;&amp; c &lt; w
-#define checkGridIndex(i, nCells) i &gt;= 0 &amp;&amp; i &lt; nCells
-#define SUBCELL_L 10 //subcell lenth in centimeter
-
-
-class CELL_Info
-{
-public:
-  int r,c,index;
-  GPSPoint center;
-  int nCells;
-  double heuristic;
-  double forwardHeuristic;
-  double backwardHeuristic;
-  double heuristicValue;
-  double forward_heuristicValue;
-  double backward_heuristicValue;
-  int expanded; // used in path planning
-  bool closed;
-  double value;
-  int action;
-  double localize_val;
-  double localize_prob;
-  std::vector&lt;double&gt; localize_features;
-  GPSPoint forwardCenter;
-  GPSPoint backwardCenter;
-  DIRECTION_TYPE bDir;
-  POINT2D bottom_left;
-  POINT2D top_right;
-  POINT2D bottom_right;
-  POINT2D top_left;
-  int nStaticPoints;
-  int nMovingPoints;
-
-  CELL_Info* pInnerMap;
-
-  std::vector&lt;POINT2D&gt; innerStaticPointsList;
-  std::vector&lt;POINT2D&gt; innerMovingPointsList;
-
-  std::vector&lt;GPSPoint&gt; path;
-
-
-public:
-  void InitSubCells(double cell_l, double sub_cell_l);
-/**
- * @brief Clear the map contents including obstacle data if bMovingOnly parameter = -1
- * @param bMovingOnly , 1 : clear cell data and moving only points, 0 clear all data including moving and static points, -1 clear data only.
- */
-  void Clear(int bMovingOnly);
-  void ClearSubCells(bool bMovingOnly);
-
-  CELL_Info();
-
-  virtual ~CELL_Info();
-
-  /*
-   * Cell initialization
-   */
-  void Initialize(POINT2D bottom_left, double cell_l, int row, int col, bool bDefaultEmpty);
-
-  /*
-   * assignment operator
-   */
-  bool operator==(const CELL_Info&amp; cell);
-
-  bool operator!=(const CELL_Info&amp; cell);
-
-  inline bool PointInRect(const POINT2D&amp; p)
-   {
-     return p.x &gt;= bottom_left.x &amp;&amp; p.x &lt;= top_right.x &amp;&amp; p.y &gt;= bottom_left.y &amp;&amp; p.y &lt;= top_right.y;
-   }
-
-  bool TestWithRectangle(RECTANGLE&amp; rec);
-  bool TestWithCircle(POINT2D _center,double  width);
-   inline bool HitTest(const POINT2D&amp; p);
-
-   void UpdateSubCellCostValue(const std::vector&lt;POINT2D&gt;&amp; ps, const double&amp; cell_l, const double&amp; sub_cell_l);
-   void UpdateCostValue(const std::vector&lt;POINT2D&gt;&amp; ps);
-
-   void SaveCell(std::ostream&amp; f);
-   void LoadCell(std::ifstream&amp; f);
-
-};
-
-class GridMap
-{
-  public:
-
-	  pthread_mutex_t update_map_mutex;
-
-    double w, inner_w; // current world width
-    double h, inner_h; // current world height
-    double cell_l; // cell or block length, if this is an inner cell measurements will be in meter
-    double sub_cell_l;
-    double origin_x , origin_y;
-
-
-
-    int inner_start_row;
-    int inner_start_col;
-    int inner_end_row;
-    int inner_end_col;
-
-    bool m_bEnableInnerMap;
-    bool m_bUpdatedMap;
-
-
-
-    int wCells, nInnerWCells; // width, number of cells per row
-    int hCells, nInnerHCells; // height, number of cells per column
-	//POINT2D center;
-	int m_MaxHeuristics;
-
-	int m_DisplayResolution;
-
-	POINT2D* delta;
-
-
-    // This method map obstacles from real world space to Grid space , marking each cell or internal cells as obstacle
-	void UpdateMapObstacleValue(const Obstacle&amp; ob);
-	void UpdateMapDrivablesValue(const DrivableArea&amp; dr);
-	void UpdateMapDrivablesValuePlygon(const std::vector&lt;std::vector&lt;POINT2D&gt; &gt;&amp; points);
-	void UpdateMapObstaclesValuePlygon(const std::vector&lt;POINT2D&gt;&amp; poly, std::vector&lt;CELL_Info*&gt;&amp; modifiedCell);
-
-	/**
-	 * @brief update cell to indicate that there is an obstacle @ absolute point p
-	 * @param p absolute x,y point
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateMapObstaclePoint(const POINT2D&amp; p);
-
-	/**
-	 * @brief update cell to indicate that there is an obstacle @ absolute point p , and make the map thiner according to a giving threshold
-	 * @param p absolute x,y point
-	 * @param thiningTHreshold distance to search for old obstacles
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateThinMapObstaclePoint(const POINT2D&amp; p, const GPSPoint&amp; carPos, const double&amp; thiningTHreshold);
-
-	/**
-	 * @brief update cell to indicate that there is an moving obstacle @ absolute point p
-	 * @param p absolute x,y point
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateMapMovingObstaclePoint(const POINT2D&amp; p);
-
-	/**
-	 * @brief update subcells cost values to reflect the effect of obstacle @ absolute pint p
-	 * @param p obstacle point (x,y)
-	 * @param currPos current car location to apply the effect of obstacle on p
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateMapCostValueRange(const std::vector&lt;POINT2D&gt;&amp; ps, const GPSPoint&amp; currPos, const std::vector&lt;double&gt;&amp; features);
-	/**
-	 * @brief find the cell @ p then update its localization cost and probability which were read from a map file
-	 * @param p absolute position of the cell center
-	 * @param localize_val cost value
-	 * @param localize_prob probability value (should be zero in case of updating from map file
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateSubMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob);
-
-	CELL_Info* UpdateMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob);
-
-	CELL_Info* GetCellFromPointInnerMap(const POINT2D&amp; p);
-	CELL_Info* GetCellFromPoint(const POINT2D&amp; p, bool bExpand = false); // return cell information from (x,y) coordinates
-	CELL_Info* GetSubCellFromPoint(const POINT2D&amp; p); // return sub cell information from (x,y) coordinates
-	CELL_Info* GetSubCellFromCell(CELL_Info* const parent, const POINT2D&amp; p); // return sub cell information from parent cell
-
-	bool CheckSubCellsInTheWay(const POINT2D&amp; p, const GPSPoint&amp; carPos, const double&amp; thiningTHreshold, std::vector&lt;CELL_Info*&gt;&amp; pSubCellsList);
-
-	/**
-	 * @brief Clear the map contents including obstacle data if bMovingOnly parameter = -1
-	 * @param bMovingOnly , 1 : clear cell data and moving only points, 0 clear all data including moving and static points, -1 clear data only.
-	 */
-	void ClearMap(int bMovingOnly);
-	void OpenClosedCells();
-	void BackupMap();
-
-	GridMap();
-    GridMap(double start_x, double start_y, double  map_w, double map_h, double cell_length, bool bDefaultEmpty); // initialize and construct the 2D array of the Grid cells
-    void InitInnerMap(double  map_l, GridMap* const pParentMap, const POINT2D&amp; center); // initialize and construct map from another map (cells will point to cells from the other map , width and hight will be maximum available limited by the parameters
-    virtual ~GridMap();
-
-    CELL_Info* pCells;
-    int nCells;
-
-    void SaveMap(const std::string&amp; mapFilePath, const std::string&amp; mapName);
-    void LoadMap(const std::string&amp; mapFilePath, const POINT2D&amp; pos, const double&amp; loadingRadius, const GPSPoint&amp; mapTransformation);
-
-    int GetSurroundingMainCells(const POINT2D&amp; pos, std::vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range=5);
-    int GetSurroundingNonObstacleCells(const POINT2D&amp; pos, std::vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range=5);
-    int GetSurroundingMainCellsRectangle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect);
-    int GetSurroundingMainCellsCircle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, double radius);
-    int GetSurroundingMainCellsRectangleNoObstacle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect);
-
-    bool IsUpdated()
-    {
-    	return m_bUpdatedMap;
-    }
-
-    void ObservedMap()
-    {
-    	m_bUpdatedMap = false;
-    }
-
-  private:
-    int InsidePolygon(const std::vector&lt;POINT2D&gt;&amp; polygon,const POINT2D&amp; p);
-
-    //vector&lt;CELL_Info*&gt; pDrivableCells;
-  };
-
-}
-#endif /* GRIDMAP_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\HMIStateMachine.h" new_path="" added_lines="0" deleted_lines="99">
				<diff>@@ -1,99 +0,0 @@
-/*
- * HMIStateMachine.h
- *
- *  Created on: February 14, 2017
- *      Author: Hatem Darweesh
- */
-
-#ifndef HMIStateMachine_H_
-#define HMIStateMachine_H_
-
-#include "RoadNetwork.h"
-#include &lt;sstream&gt;
-
-namespace PlannerHNS
-{
-
-class HMIStateMachine
-{
-public:
-	virtual HMIStateMachine* GetNextState() = 0;
-	virtual void Init();
-	virtual void ResetTimer();
-	virtual void InsertNextState(HMIStateMachine* nextState);
-	HMIStateMachine(HMIStateMachine* nextState);
-	virtual ~HMIStateMachine() ;
-
-	GLOBAL_STATE_TYPE m_Behavior;
-	double decisionMakingTime;
-
-	HMIPreCalculatedConditions* GetCalcParams()
-	{
-		if(!m_pCalculatedValues)
-				m_pCalculatedValues = new HMIPreCalculatedConditions();
-
-		return m_pCalculatedValues;
-	}
-
-	void SetBehaviorsParams(const PlanningParams&amp; params)
-	{
-		m_PlanningParams = params;
-	}
-
-	static HMIPreCalculatedConditions* m_pCalculatedValues;
-	timespec m_StateTimer;
-	std::vector&lt;HMIStateMachine*&gt; pNextStates;
-	static PlanningParams m_PlanningParams;
-
-	HMIStateMachine* FindBehaviorState(const GLOBAL_STATE_TYPE&amp; behavior);
-};
-
-class GWaitingState : public HMIStateMachine
-{
-public:
-	GWaitingState(GWaitingState* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_WAITING_STATE;}
-	virtual ~GWaitingState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GPlanningState : public HMIStateMachine
-{
-public:
-	GPlanningState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_PLANING_STATE;}
-	virtual ~GPlanningState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GForwardState : public HMIStateMachine
-{
-public:
-	GForwardState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_FORWARD_STATE;}
-	virtual ~GForwardState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GBranchingState : public HMIStateMachine
-{
-public:
-	GBranchingState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_BRANCHING_STATE;}
-	virtual ~GBranchingState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GEndState : public HMIStateMachine
-{
-public:
-	GEndState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_FINISH_STATE;}
-	virtual ~GEndState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-
-} /* namespace PlannerHNS */
-
-#endif /* HMIStateMachine_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\LocalPlannerH.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\LocalPlannerH.h" added_lines="34" deleted_lines="21">
				<diff>@@ -12,7 +12,9 @@
 #include "PlannerCommonDef.h"
 #include "RoadNetwork.h"
 #include "TrajectoryCosts.h"
+#include "TrajectoryPrediction.h"
 
+#define AVOIDANCE_SPEED_FACTOR 0.75
 namespace PlannerHNS
 {
 
@@ -24,11 +26,15 @@ public:
 	ControllerParams m_ControlParams;
 	std::vector&lt;GPSPoint&gt; m_CarShapePolygon;
 	std::vector&lt;WayPoint&gt; m_Path;
+	std::vector&lt;WayPoint&gt; m_OriginalLocalPath;
 	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; m_TotalPath;
+	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; m_TotalOriginalPath;
+	std::vector&lt;DetectedObject&gt; m_PredictedTrajectoryObstacles;
 	int m_iCurrentTotalPathId;
 	int m_iSafeTrajectory;
+	double m_InitialFollowingDistance;
 //	int m_iGlobalPathPrevID;
-	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; m_PredictedPath;
+//	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; m_PredictedPath;
 	std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt; m_RollOuts;
 	std::string carId;
 	Lane* pLane;
@@ -38,6 +44,7 @@ public:
 	double m_CostCalculationTime;
 	double m_BehaviorGenTime;
 	double m_RollOutsGenerationTime;
+	int m_PrevBrakingWayPoint;
 
 	BehaviorStateMachine* 		m_pCurrentBehaviorState;
 	ForwardState * 				m_pGoToGoalState;
@@ -54,15 +61,16 @@ public:
 	StopSignWaitState* 			m_pStopSignWaitState;
 
 	TrajectoryCosts m_TrajectoryCostsCalculatotor;
-
-
+	TrajectoryPrediction m_TrajectoryPredictionForMovingObstacles;
 
 	//for debugging
-	std::vector&lt;WayPoint&gt; m_PathSection;
+
 	std::vector&lt;WayPoint&gt; m_SampledPoints;
 
 	void InitBehaviorStates();
 
+	void ReInitializePlanner(const WayPoint&amp; start_pose);
+
 	void SetSimulatedTargetOdometryReadings(const double&amp; velocity_d, const double&amp; steering_d, const SHIFT_POS&amp; shift_d)
 	{
 		m_CurrentVelocityD = velocity_d;
@@ -96,6 +104,9 @@ public:
 	double m_CurrentAccVelocity; // kilometer/hour
 	//std::vector&lt;TrafficLight&gt; m_TrafficLights;
 
+	UtilityHNS::PIDController 	m_pidVelocity;
+	UtilityHNS::PIDController 	m_pidStopping;
+
 public:
 
 	LocalPlannerH();
@@ -106,7 +117,7 @@ public:
 	void LocalizeMe(const double&amp; dt); // in seconds
 	void UpdateState(const VehicleState&amp; state, const bool&amp; bUseDelay = false);
 	void CalculateImportantParameterForDecisionMaking(const VehicleState&amp; car_state,
-			const int&amp; goalID, const bool&amp; bEmergencyStop, const bool&amp; bGreenTrafficLight,
+			const int&amp; goalID, const bool&amp; bEmergencyStop, const vector&lt;TrafficLight&gt;&amp; detectedLights,
 			const TrajectoryCost&amp; bestTrajectory);
 
 	BehaviorState DoOneStep(
@@ -116,7 +127,7 @@ public:
 			const int&amp; goalID,
 			RoadNetwork&amp; map,
 			const bool&amp; bEmergencyStop,
-			const bool&amp; bGreenTrafficLight,
+			const std::vector&lt;TrafficLight&gt;&amp; trafficLight,
 			const bool&amp; bLive = false);
 
 	void SimulateOdoPosition(const double&amp; dt, const VehicleState&amp; vehicleState);
@@ -124,20 +135,20 @@ public:
 private:
 
 	//Obstacle avoidance functionalities
-	bool CalculateObstacleCosts(RoadNetwork&amp; map, const VehicleState&amp; vstatus, const std::vector&lt;DetectedObject&gt;&amp; obj_list);
-
-	double PredictTimeCostForTrajectory(std::vector&lt;WayPoint&gt;&amp; path,
-			const VehicleState&amp; vstatus,
-			const WayPoint&amp; currState);
-
-	void PredictObstacleTrajectory(RoadNetwork&amp; map,
-			const WayPoint&amp; pos,
-			const double&amp; predTime,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
-
-	bool CalculateIntersectionVelocities(std::vector&lt;WayPoint&gt;&amp; path,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; predctedPath,
-			const DetectedObject&amp; obj);
+//	bool CalculateObstacleCosts(RoadNetwork&amp; map, const VehicleState&amp; vstatus, const std::vector&lt;DetectedObject&gt;&amp; obj_list);
+//
+//	double PredictTimeCostForTrajectory(std::vector&lt;WayPoint&gt;&amp; path,
+//			const VehicleState&amp; vstatus,
+//			const WayPoint&amp; currState);
+//
+//	void PredictObstacleTrajectory(RoadNetwork&amp; map,
+//			const WayPoint&amp; pos,
+//			const double&amp; predTime,
+//			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
+//
+//	bool CalculateIntersectionVelocities(std::vector&lt;WayPoint&gt;&amp; path,
+//			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; predctedPath,
+//			const DetectedObject&amp; obj);
 
 	bool GetNextTrafficLight(const int&amp; prevTrafficLightId, const std::vector&lt;TrafficLight&gt;&amp; trafficLights, TrafficLight&amp; trafficL);
 	void UpdateCurrentLane(RoadNetwork&amp; map, const double&amp; search_distance);
@@ -145,7 +156,9 @@ private:
 	BehaviorState GenerateBehaviorState(const VehicleState&amp; vehicleState);
 	void TransformPoint(const WayPoint&amp; refPose, GPSPoint&amp; p);
 	void AddAndTransformContourPoints(const DetectedObject&amp; obj, std::vector&lt;WayPoint&gt;&amp; contourPoints);
-	void UpdateVelocityDirectlyToTrajectory(const BehaviorState&amp; beh, const VehicleState&amp; CurrStatus, const double&amp; dt);
+	double UpdateVelocityDirectlyToTrajectory(const BehaviorState&amp; beh, const VehicleState&amp; CurrStatus, const double&amp; dt);
+
+	void ExtractHorizonAndCalculateRecommendedSpeed();
 
 	bool NoWayTest(const double&amp; min_distance, const int&amp; iGlobalPathIndex);
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\MappingHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\MappingHelpers.h" added_lines="30" deleted_lines="15">
				<diff>@@ -32,12 +32,14 @@ public:
 			const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
 			const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
 			const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
+			const std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt;&amp; curb_data,
+			const std::vector&lt;UtilityHNS::AisanRoadEdgeFileReader::AisanRoadEdge&gt;&amp; roadedge_data,
 			const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
 			const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag = false);
 
 	static void ConstructRoadNetworkFromDataFiles(const std::string vectoMapPath, RoadNetwork&amp; map, const bool&amp; bZeroOrigin = false);
 
-	static void SaveTrajectoryLonLatToKMLFile(const std::string&amp; fileName, const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectory);
+	//static void SaveTrajectoryLonLatToKMLFile(const std::string&amp; fileName, const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectory);
 
 	static void GetWayPoint(const int&amp; pid, const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points, std::vector&lt;WayPoint&gt;&amp; path);
 	static bool GetWayPoint(const int&amp; id, const int&amp; laneID,const double&amp; refVel, const int&amp; did,
@@ -45,32 +47,45 @@ public:
 			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points,
 			const GPSPoint&amp; origin, WayPoint&amp; way_point);
 
-	static void WriteKML(const std::string&amp; kmlFile, const std::string&amp; kmlTemplat, RoadNetwork&amp; ap);
+	//static void WriteKML(const std::string&amp; kmlFile, const std::string&amp; kmlTemplat, RoadNetwork&amp; ap);
 	static void LoadKML(const std::string&amp; kmlMap, RoadNetwork&amp; map);
 
-	static void SetRoadLinksList(TiXmlElement* pElem, std::vector&lt;RoadSegment&gt;&amp; roadSegments);
-	static void SetLaneLinksList(TiXmlElement* pElem, std::vector&lt;Lane&gt;&amp; lanes);
-	static void SetStopLinesList(TiXmlElement* pElem, std::vector&lt;StopLine&gt;&amp; stopLines);
-	static void SetTrafficLightsList(TiXmlElement* pElem, std::vector&lt;TrafficLight&gt;&amp; trafficLights);
-	static void SetTrafficSignsList(TiXmlElement* pElem, std::vector&lt;TrafficSign&gt;&amp; trafficSignes);
-
 	static TiXmlElement* GetHeadElement(TiXmlElement* pMainElem);
 	static TiXmlElement* GetDataFolder(const std::string&amp; folderName, TiXmlElement* pMainElem);
 
 
-	static Lane* GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
+	static Lane* GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0, const bool bDirectionBased = true);
+	static std::vector&lt;Lane*&gt; GetClosestLanesListFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 2.0, const bool bDirectionBased = true);
 	static Lane* GetClosestLaneFromMapDirectionBased(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
 	static std::vector&lt;Lane*&gt; GetClosestMultipleLanesFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
-	static WayPoint* GetClosestWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map);
+	static WayPoint* GetClosestWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const bool bDirectionBased = true);
+
+	static std::vector&lt;WayPoint*&gt; GetClosestWaypointsListFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 2.0, const bool bDirectionBased = true);
+
 	static WayPoint* GetClosestBackWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map);
 	static WayPoint GetFirstWaypoint(RoadNetwork&amp; map);
 	static WayPoint* GetLastWaypoint(RoadNetwork&amp; map);
+	static void FindAdjacentLanes(RoadNetwork&amp; map);
+	static void ExtractSignalData(const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
+			const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
+			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
+			const GPSPoint&amp; origin, RoadNetwork&amp; map);
+
+	static void ExtractStopLinesData(const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
+			const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
+			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
+			const GPSPoint&amp; origin, RoadNetwork&amp; map);
+
+	static void ExtractCurbData(const std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt;&amp; curb_data,
+				const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
+				const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
+				const GPSPoint&amp; origin, RoadNetwork&amp; map);
 
+	static void LinkMissingBranchingWayPoints(RoadNetwork&amp; map);
+	static void LinkTrafficLightsAndStopLinesConData(const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
+			const std::vector&lt;std::pair&lt;int,int&gt; &gt;&amp; id_replace_list, RoadNetwork&amp; map);
 
-	static void llaToxyz(GPSPoint&amp; lla_p, const GPSPoint&amp; origin);
-	static void llaToxyzSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset);
-	static void xyzTolla(GPSPoint&amp; xyz_p, const GPSPoint&amp; origin);
-	static void xyzTollaSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset);
+	static void LinkTrafficLightsAndStopLines(RoadNetwork&amp; map);
 
 	static void GetUniqueNextLanes(const Lane* l,  const std::vector&lt;Lane*&gt;&amp; traversed_lanes, std::vector&lt;Lane*&gt;&amp; lanes_list);
 
@@ -95,7 +110,7 @@ public:
 	static std::vector&lt;GPSPoint&gt; GetPointsData(TiXmlElement* pElem);
 	static std::vector&lt;std::string&gt; SplitString(const std::string&amp; str, const std::string&amp; token);
 
-	static void CreateKmlFromLocalizationPathFile(const std::string&amp; pathFileName,const double&amp; maxLaneDistance, const double&amp; density,const std::vector&lt;TrafficLight&gt;&amp; trafficLights, const std::vector&lt;GPSPoint&gt;&amp; stopLines);
+	//static void CreateKmlFromLocalizationPathFile(const std::string&amp; pathFileName,const double&amp; maxLaneDistance, const double&amp; density,const std::vector&lt;TrafficLight&gt;&amp; trafficLights, const std::vector&lt;GPSPoint&gt;&amp; stopLines);
 
 	static int ReplaceMyID(int&amp; id, const std::vector&lt;std::pair&lt;int,int&gt; &gt;&amp; rep_list);
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\MatrixOperations.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\MatrixOperations.h" added_lines="4" deleted_lines="56">
				<diff>@@ -17,39 +17,21 @@ namespace PlannerHNS {
 
 class Mat3
 {
-	double m11, m12, m13;
-	double m21, m22, m23;
-	double m31, m32, m33;
-
 	double m[3][3];
 
 public:
 	Mat3()
 	{
 		//initialize Identity by default
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-	}
+		for(int i=0;i&lt;3;i++)
+			for(int j=0;j&lt;3;j++)
+				m[i][j] = 0;
 
-	Mat3(double angle, POINT2D trans)
-	{
-		//Initialize Rotation Matrix
-		double c = cos(angle);
-		double s = sin(angle);
-		m11 = c;
-		m12 = s;
-		m21 = -s;
-		m22 = c;
-		m31 = trans.x;
-		m32 = trans.y;
-		m13 = m23= 0;
-		m33 = 1;
+		m[0][0] = m[1][1] = m[2][2] = 1;
 	}
 
 	Mat3(double transX, double transY, bool mirrorX, bool mirrorY )
 	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
 		m[0][0] = (mirrorX == true ) ? -1 : 1; m[0][1] =  0; m[0][2] =  transX;
 		m[1][0] = 0; m[1][1] =  (mirrorY==true) ? -1 : 1; m[1][2] =  transY;
 		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
@@ -57,8 +39,6 @@ public:
 
 	Mat3(double transX, double transY)
 	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
 		m[0][0] = 1; m[0][1] =  0; m[0][2] =  transX;
 		m[1][0] = 0; m[1][1] =  1; m[1][2] =  transY;
 		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
@@ -66,8 +46,6 @@ public:
 
 	Mat3(double rotation_angle)
 	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
 		double c = cos(rotation_angle);
 		double s = sin(rotation_angle);
 		m[0][0] = c; m[0][1] = -s; m[0][2] =  0;
@@ -77,8 +55,6 @@ public:
 
 	Mat3(GPSPoint rotationCenter)
 	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
 		double c = cos(rotationCenter.a);
 		double s = sin(rotationCenter.a);
 		double u = rotationCenter.x;
@@ -96,34 +72,6 @@ public:
 		v.y = m[1][0]*_v.x + m[1][1]*_v.y + m[1][2]*1;
 		return v;
 	}
-
-	POINT2D operator * (POINT2D v)
-	{
-		Mat3 m = *this;
-		POINT2D r;
-		r.x = m.m11 * v.x + m.m21 * v.y + m.m31 * 1;
-		r.y = m.m12 * v.x + m.m22 * v.y + m.m32 * 1;
-		return r;
-	}
-
-	Mat3 operator *(Mat3 m2)
-	{
-		Mat3 m1 = *this;
-		Mat3 r;
-		r.m11 = m1.m11 * m2.m11 + m1.m12 * m2.m21 + m1.m13 * m2.m31;
-		r.m12 = m1.m11 * m2.m12 + m1.m12 * m2.m22 + m1.m13 * m2.m32;
-		r.m13 = m1.m11 * m2.m13 + m1.m12 * m2.m23 + m1.m13 * m2.m33;
-
-		r.m21 = m1.m21 * m2.m11 + m1.m22 * m2.m21 + m1.m23 * m2.m31;
-		r.m22 = m1.m21 * m2.m12 + m1.m22 * m2.m22 + m1.m23 * m2.m32;
-		r.m23 = m1.m21 * m2.m13 + m1.m22 * m2.m23 + m1.m23 * m2.m33;
-
-		r.m31 = m1.m31 * m2.m11 + m1.m32 * m2.m21 + m1.m33 * m2.m31;
-		r.m32 = m1.m31 * m2.m12 + m1.m32 * m2.m22 + m1.m33 * m2.m32;
-		r.m33 = m1.m31 * m2.m13 + m1.m32 * m2.m23 + m1.m33 * m2.m33;
-
-		return r;
-	}
 };
 
 } /* namespace PlannerHNS */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\PlannerCommonDef.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\PlannerCommonDef.h" added_lines="7" deleted_lines="0">
				<diff>@@ -14,6 +14,13 @@
 namespace PlannerHNS
 {
 
+enum MAP_SOURCE_TYPE
+{
+	MAP_AUTOWARE,
+	MAP_FOLDER,
+	MAP_KML_FILE
+};
+
 enum CAR_TYPE
 {
   Mv2Car, //!&lt; Mv2Car
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\PlannerH.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\PlannerH.h" added_lines="5" deleted_lines="14">
				<diff>@@ -6,7 +6,6 @@
  */
 
 #include "RSPlanner.h"
-#include "GridMap.h"
 
 #define START_POINT_MAX_DISTANCE 8 // meters
 #define GOAL_POINT_MAX_DISTANCE 8 // meters
@@ -24,18 +23,6 @@ public:
 	PlannerH();
 	virtual ~PlannerH(); 
 
-
-	/**
-	 * @brief Generates Trajectory using Reeds Shepp, this method will not try to avoid obstacles
-	 * @param start: Start position for the trajectory (x,y,theta)
-	 * @param goal:  Goal position (Destination point) (x,y,theta)
-	 * @param map:  2d grid map, ( cost map or occupancy grid.
-	 * @param generatedPath: pointer to return the smooth trajectory. - Better Not to use this
-	 * @return path length
-	 */
-	double PlanUsingReedSheppWithObstacleDetection(const WayPoint&amp; start, const WayPoint&amp; goal, GridMap&amp; map, std::vector&lt;WayPoint&gt;&amp; genSmoothedPath,
-			const double pathDensity = 0.25, const double smoothFactor = 12.0);
-
 	/**
 	 * @brief Generates Trajectory using Reeds Shepp, this method will not try to avoid obstacles , but if there an obstacle on the trajectory function will fail. , also this function does not guaranteed to generate trajectories
 	 * @param start: Start position for the trajectory (x,y,theta)
@@ -75,7 +62,7 @@ public:
 				const double&amp; SmoothTolerance, const double&amp; speedProfileFactor, const bool&amp; bHeadingSmooth,
 				const int&amp; iCurrGlobalPath, const int&amp; iCurrLocalTraj,
 				std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOutsPaths,
-				std::vector&lt;WayPoint&gt;&amp; sectionPath, std::vector&lt;WayPoint&gt;&amp; sampledPoints);
+				std::vector&lt;WayPoint&gt;&amp; sampledPoints);
 
 	/**
 	 * @brief Path planning for structured environment using dynamic programming
@@ -109,6 +96,10 @@ public:
 	double PredictPlanUsingDP(Lane* lane, const WayPoint&amp; carPos, const double&amp; maxPlanningDistance,
 			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
 
+	double PredictPlanUsingDP(const WayPoint&amp; startPose, WayPoint* closestWP, const double&amp; maxPlanningDistance, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, const bool&amp; bFindBranches = true);
+
+	double PredictTrajectoriesUsingDP(const WayPoint&amp; startPose, std::vector&lt;WayPoint*&gt; closestWPs, const double&amp; maxPlanningDistance, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, const bool&amp; bFindBranches = true, const bool bDirectionBased = false);
+
 	void DeleteWaypoints(std::vector&lt;WayPoint*&gt;&amp; wps);
 
 	//PlanningInternalParams m_Params;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\PlanningHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\PlanningHelpers.h" added_lines="28" deleted_lines="5">
				<diff>@@ -25,7 +25,12 @@ namespace PlannerHNS {
 #define LANE_CHANGE_COST 3.0 // meters
 #define BACKUP_STRAIGHT_PLAN_DISTANCE 75 //meters
 
-class PlanningHelpers {
+class PlanningHelpers
+{
+
+public:
+	static std::vector&lt;std::pair&lt;GPSPoint, GPSPoint&gt; &gt; m_TestingClosestPoint;
+
 public:
 	PlanningHelpers();
 	virtual ~PlanningHelpers();
@@ -40,6 +45,7 @@ public:
 	 */
 	static bool GetRelativeInfo(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, RelativeInfo&amp; info, const int&amp; prevIndex = 0);
 
+
 	static bool GetRelativeInfoRange(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectories, const WayPoint&amp; p, const double&amp; searchDistance, RelativeInfo&amp; info);
 
 	/**
@@ -67,10 +73,15 @@ public:
 	 * @param prevIndex initial search index
 	 * @return index of the closest next point from trajectory
 	 */
-	static int GetClosestNextPointIndex(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
+	static int GetClosestNextPointIndex_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
+
+	static int GetClosestNextPointIndexFast(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
+
+	static int GetClosestNextPointIndexFastV2(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
 
-	static int GetClosestNextPointIndexDirection(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
+	static int GetClosestNextPointIndexDirectionFast(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
 
+	static int GetClosestNextPointIndexDirectionFastV2(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
 
 	static int GetClosestPointIndex_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex = 0 );
 	static WayPoint GetPerpendicularOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, double&amp; distance, const int&amp; prevIndex = 0);
@@ -80,6 +91,9 @@ public:
 	static double GetDistanceOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; path, const int&amp; start_index, const WayPoint&amp; p);
 
 
+	static void CreateManualBranch(std::vector&lt;WayPoint&gt;&amp; path, const int&amp; degree, const DIRECTION_TYPE&amp; direction);
+	static void CreateManualBranchFromTwoPoints(WayPoint&amp; p1,WayPoint&amp; p2 , const double&amp; distance, const DIRECTION_TYPE&amp; direction, std::vector&lt;WayPoint&gt;&amp; path);
+
 	static void FixPathDensity(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; distanceDensity);
 	static void SmoothPath(std::vector&lt;WayPoint&gt;&amp; path, double weight_data =0.25,double weight_smooth = 0.25,double tolerance = 0.01);
 	static double CalcCircle(const GPSPoint&amp; pt1, const GPSPoint&amp; pt2, const GPSPoint&amp; pt3, GPSPoint&amp; center);
@@ -92,6 +106,9 @@ public:
 	static void ExtractPartFromPointToDistance(const std::vector&lt;WayPoint&gt;&amp; originalPath, const WayPoint&amp; pos, const double&amp; minDistance,
 			const double&amp; pathDensity, std::vector&lt;WayPoint&gt;&amp; extractedPath, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight, const double&amp; SmoothTolerance);
 
+	static void ExtractPartFromPointToDistanceFast(const std::vector&lt;WayPoint&gt;&amp; originalPath, const WayPoint&amp; pos, const double&amp; minDistance,
+				const double&amp; pathDensity, std::vector&lt;WayPoint&gt;&amp; extractedPath, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight, const double&amp; SmoothTolerance);
+
 	static void CalculateRollInTrajectories(const WayPoint&amp; carPos, const double&amp; speed, const std::vector&lt;WayPoint&gt;&amp; originalCenter, int&amp; start_index,
 			int&amp; end_index, std::vector&lt;double&gt;&amp; end_laterals ,
 			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; rollInPaths, const double&amp; max_roll_distance,
@@ -101,11 +118,12 @@ public:
 			const double&amp; SmoothTolerance, const bool&amp; bHeadingSmooth,
 			std::vector&lt;WayPoint&gt;&amp; sampledPoints);
 
-
 	static void SmoothSpeedProfiles(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	= 0.1);
 	static void SmoothCurvatureProfiles(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance = 0.1);
 	static void SmoothWayPointsDirections(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	= 0.1);
 
+	static void SmoothGlobalPathSpeed(std::vector&lt;WayPoint&gt;&amp; path);
+
 	static void GenerateRecommendedSpeed(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; max_speed, const double&amp; speedProfileFactor);
 //	static WayPoint* BuildPlanningSearchTree(Lane* l, const WayPoint&amp; prevWayPointIndex,
 //			const WayPoint&amp; startPos, const WayPoint&amp; goalPos,
@@ -126,6 +144,9 @@ public:
 	static int PredictiveDP(WayPoint* pStart, const double&amp; DistanceLimit,
 			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete, std::vector&lt;WayPoint*&gt;&amp; end_waypoints);
 
+	static int PredictiveIgnorIdsDP(WayPoint* pStart, const double&amp; DistanceLimit,
+				std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete, std::vector&lt;WayPoint*&gt;&amp; end_waypoints, std::vector&lt;int&gt;&amp; lanes_ids);
+
 	static bool CheckLaneIdExits(const std::vector&lt;int&gt;&amp; lanes, const Lane* pL);
 	static WayPoint* CheckLaneExits(const std::vector&lt;WayPoint*&gt;&amp; nodes, const Lane* pL);
 	static WayPoint* CheckNodeExits(const std::vector&lt;WayPoint*&gt;&amp; nodes, const WayPoint* pL);
@@ -151,11 +172,13 @@ public:
 
 	static void CalcContourPointsForDetectedObjects(const WayPoint&amp; currPose, std::vector&lt;DetectedObject&gt;&amp; obj_list, const double&amp; filterDistance = 100);
 
-	static double GetVelocityAhead(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; pose, const double&amp; distance);
+	static double GetVelocityAhead(const std::vector&lt;WayPoint&gt;&amp; path, const RelativeInfo&amp; info,int&amp; prev_index, const double&amp; reasonable_brake_distance);
 	static bool CompareTrajectories(const std::vector&lt;WayPoint&gt;&amp; path1, const std::vector&lt;WayPoint&gt;&amp; path2);
 
 	static double GetDistanceToClosestStopLineAndCheck(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; p, int&amp; stopLineID,int&amp; stopSignID, int&amp; trafficLightID, const int&amp; prevIndex = 0);
 
+	static bool GetThreePointsInfo(const WayPoint&amp; p0, const WayPoint&amp; p1, const WayPoint&amp; p2, WayPoint&amp; perp_p, double&amp; long_d, double lat_d);
+
 	static void WritePathToFile(const std::string&amp; fileName, const std::vector&lt;WayPoint&gt;&amp; path);
 
 	static void TestQuadraticSpline(const std::vector&lt;WayPoint&gt;&amp; center_line, std::vector&lt;WayPoint&gt;&amp; path);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\RoadNetwork.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\RoadNetwork.h" added_lines="113" deleted_lines="67">
				<diff>@@ -29,7 +29,7 @@ enum DRIVABLE_TYPE {DIRT, TARMAC, PARKINGAREA, INDOOR, GENERAL_AREA};
 enum GLOBAL_STATE_TYPE {G_WAITING_STATE, G_PLANING_STATE, G_FORWARD_STATE, G_BRANCHING_STATE, G_FINISH_STATE};
 
 enum STATE_TYPE {INITIAL_STATE, WAITING_STATE, FORWARD_STATE, STOPPING_STATE, EMERGENCY_STATE,
-	TRAFFIC_LIGHT_STOP_STATE,TRAFFIC_LIGHT_WAIT_STATE, STOP_SIGN_STOP_STATE, STOP_SIGN_WAIT_STATE, FOLLOW_STATE, LANE_CHANGE_STATE, OBSTACLE_AVOIDANCE_STATE, GOAL_STATE, FINISH_STATE};
+	TRAFFIC_LIGHT_STOP_STATE,TRAFFIC_LIGHT_WAIT_STATE, STOP_SIGN_STOP_STATE, STOP_SIGN_WAIT_STATE, FOLLOW_STATE, LANE_CHANGE_STATE, OBSTACLE_AVOIDANCE_STATE, GOAL_STATE, FINISH_STATE, YIELDING_STATE, BRANCH_LEFT_STATE, BRANCH_RIGHT_STATE};
 
 enum LIGHT_INDICATOR {INDICATOR_LEFT, INDICATOR_RIGHT, INDICATOR_BOTH , INDICATOR_NONE};
 
@@ -37,8 +37,9 @@ enum SHIFT_POS {SHIFT_POS_PP = 0x60, SHIFT_POS_RR = 0x40, SHIFT_POS_NN = 0x20,
 	SHIFT_POS_DD = 0x10, SHIFT_POS_BB = 0xA0, SHIFT_POS_SS = 0x0f, SHIFT_POS_UU = 0xff };
 
 enum ACTION_TYPE {FORWARD_ACTION, BACKWARD_ACTION, STOP_ACTION, LEFT_TURN_ACTION,
-	RIGHT_TURN_ACTION, U_TURN_ACTION, SWERVE_ACTION, OVERTACK_ACTION};
+	RIGHT_TURN_ACTION, U_TURN_ACTION, SWERVE_ACTION, OVERTACK_ACTION, START_ACTION, SLOWDOWN_ACTION, CHANGE_DESTINATION, WAITING_ACTION, DESTINATION_REACHED,  UNKOWN_ACTION};
 
+enum BEH_STATE_TYPE {BEH_FORWARD_STATE=0,BEH_STOPPING_STATE=1, BEH_BRANCH_LEFT_STATE=2, BEH_BRANCH_RIGHT_STATE=3, BEH_YIELDING_STATE=4, BEH_ACCELERATING_STATE=5, BEH_SLOWDOWN_STATE=6};
 
 class Lane;
 class TrafficLight;
@@ -55,56 +56,23 @@ public:
 	}
 };
 
-class POINT2D
-{
-public:
-    double x;
-    double y;
-    double z;
-    POINT2D()
-    {
-      x=0;y=0;z=0;
-    }
-    POINT2D(double px, double py, double pz = 0)
-    {
-      x = px;
-      y = py;
-      z = pz;
-    }
-};
-
-
-
-class RECTANGLE
-
-{
-public:
-  POINT2D bottom_left;
-  POINT2D top_right;
-  double width;
-  double length;
-  bool bObstacle;
-
-
-  inline bool PointInRect(POINT2D p)
-  {
-    return p.x &gt;= bottom_left.x &amp;&amp; p.x &lt;= top_right.x &amp;&amp; p.y &gt;= bottom_left.y &amp;&amp; p.y &lt;= top_right.y;
-  }
-
-  inline bool HitTest(POINT2D p)
-  {
-    return PointInRect(p) &amp;&amp; bObstacle;
-  }
-
-  RECTANGLE()
-  {
-	  width=0;
-	  length = 0;
-    bObstacle = true;
-  }
-
-  virtual ~RECTANGLE(){}
-};
+//class POINT2D
+//{
+//public:
+//    double x;
+//    double y;
+//    double z;
+//    POINT2D()
+//    {
+//      x=0;y=0;z=0;
+//    }
+//    POINT2D(double px, double py, double pz = 0)
+//    {
+//      x = px;
+//      y = py;
+//      z = pz;
+//    }
+//};
 
 class GPSPoint
 {
@@ -145,6 +113,37 @@ public:
 	}
 };
 
+class RECTANGLE
+
+{
+public:
+  GPSPoint bottom_left;
+  GPSPoint top_right;
+  double width;
+  double length;
+  bool bObstacle;
+
+
+  inline bool PointInRect(GPSPoint p)
+  {
+    return p.x &gt;= bottom_left.x &amp;&amp; p.x &lt;= top_right.x &amp;&amp; p.y &gt;= bottom_left.y &amp;&amp; p.y &lt;= top_right.y;
+  }
+
+  inline bool HitTest(GPSPoint p)
+  {
+    return PointInRect(p) &amp;&amp; bObstacle;
+  }
+
+  RECTANGLE()
+  {
+	  width=0;
+	  length = 0;
+    bObstacle = true;
+  }
+
+  virtual ~RECTANGLE(){}
+};
+
 class PolygonShape
 {
 public:
@@ -193,17 +192,17 @@ class MapItem
 {
 public:
   int id;
-  POINT2D sp; //start point
-  POINT2D ep; // end point
+  GPSPoint sp; //start point
+  GPSPoint ep; // end point
   GPSPoint center;
   double c; //curvature
   double w; //width
   double l; //length
   std::string fileName; //
-  std::vector&lt;POINT2D&gt; polygon;
+  std::vector&lt;GPSPoint&gt; polygon;
 
 
-  MapItem(int ID, POINT2D start, POINT2D end, double curvature, double width, double length, std::string objName)
+  MapItem(int ID, GPSPoint start, GPSPoint end, double curvature, double width, double length, std::string objName)
   {
     id = ID;
     sp = start;
@@ -255,7 +254,7 @@ class Obstacle : public MapItem
   public:
     OBSTACLE_TYPE t;
 
-    Obstacle(int ID, POINT2D start, POINT2D end, double curvature, double width, double length,OBSTACLE_TYPE type, std::string fileName ) : MapItem(ID, start, end, curvature, width, length, fileName)
+    Obstacle(int ID, GPSPoint start, GPSPoint end, double curvature, double width, double length,OBSTACLE_TYPE type, std::string fileName ) : MapItem(ID, start, end, curvature, width, length, fileName)
   {
       t = type;
   }
@@ -297,7 +296,7 @@ class DrivableArea : public MapItem
 public:
   DRIVABLE_TYPE t; // drivable area type
 
-  DrivableArea(int ID, POINT2D start, POINT2D end, double curvature, double width, double length,DRIVABLE_TYPE type, std::string fileName ) : MapItem( ID, start, end, curvature, width, length, fileName)
+  DrivableArea(int ID, GPSPoint start, GPSPoint end, double curvature, double width, double length,DRIVABLE_TYPE type, std::string fileName ) : MapItem( ID, start, end, curvature, width, length, fileName)
   {
     t = type;
   }
@@ -373,6 +372,9 @@ public:
 	int 		RightLaneId;
 	int 		stopLineID;
 	DIRECTION_TYPE bDir;
+	STATE_TYPE	state;
+	BEH_STATE_TYPE beh_state;
+	int 		iOriginalIndex;
 
 	Lane* pLane;
 	WayPoint* pLeft;
@@ -400,6 +402,9 @@ public:
 		collisionCost = 0;
 		laneChangeCost = 0;
 		stopLineID = -1;
+		state = INITIAL_STATE;
+		beh_state = BEH_STOPPING_STATE;
+		iOriginalIndex = 0;
 	}
 
 	WayPoint(const double&amp; x, const double&amp; y, const double&amp; z, const double&amp; a)
@@ -424,6 +429,9 @@ public:
 		collisionCost = 0;
 		laneChangeCost = 0;
 		stopLineID = -1;
+		iOriginalIndex = 0;
+		state = INITIAL_STATE;
+		beh_state = BEH_STOPPING_STATE;
 	}
 };
 
@@ -451,6 +459,24 @@ public:
 	}
 };
 
+class Curb
+{
+public:
+	int id;
+	int laneId;
+	int roadId;
+	std::vector&lt;GPSPoint&gt; points;
+	Lane* pLane;
+
+	Curb()
+	{
+		id    = 0;
+		laneId =0;
+		roadId =0;
+		pLane = 0;
+	}
+};
+
 class StopLine
 {
 public:
@@ -461,6 +487,7 @@ public:
 	int stopSignID;
 	std::vector&lt;GPSPoint&gt; points;
 	Lane* pLane;
+	int linkID;
 
 	StopLine()
 	{
@@ -470,6 +497,7 @@ public:
 		pLane = 0;
 		trafficLightID = -1;
 		stopSignID = -1;
+		linkID = 0;
 	}
 };
 
@@ -528,7 +556,7 @@ public:
 	}
 };
 
-enum TrafficLightState {UNKNOWN_LIGHT, RED_LIGHT, GREEN_LIGHT, YELLOW_LIGHT, LEFT_GREEN, FORWARD_GREEN, RIGHT_GREEN, FLASH_YELLOW, FLAH_RED};
+enum TrafficLightState {UNKNOWN_LIGHT, RED_LIGHT, GREEN_LIGHT, YELLOW_LIGHT, LEFT_GREEN, FORWARD_GREEN, RIGHT_GREEN, FLASH_YELLOW, FLASH_RED};
 
 class TrafficLight
 {
@@ -539,12 +567,14 @@ public:
 	double stoppingDistance;
 	std::vector&lt;int&gt; laneIds;
 	std::vector&lt;Lane*&gt; pLanes;
+	int linkID;
 
 	TrafficLight()
 	{
 		stoppingDistance = 2;
 		id 			= 0;
 		lightState	= GREEN_LIGHT;
+		linkID 		= 0;
 	}
 
 	bool CheckLane(const int&amp; laneId)
@@ -637,6 +667,7 @@ public:
 	std::vector&lt;RoadSegment&gt; roadSegments;
 	std::vector&lt;TrafficLight&gt; trafficLights;
 	std::vector&lt;StopLine&gt; stopLines;
+	std::vector&lt;Curb&gt; curbs;
 
 };
 
@@ -691,19 +722,36 @@ public:
 	OBSTACLE_TYPE t;
 	WayPoint center;
 	WayPoint predicted_center;
+	WayPoint noisy_center;
+	STATE_TYPE predicted_behavior;
 	std::vector&lt;GPSPoint&gt; contour;
+	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; predTrajectories;
+	std::vector&lt;WayPoint*&gt; pClosestWaypoints;
 	double w;
 	double l;
 	double h;
 	double distance_to_center;
+
+	double actual_speed;
+	double actual_yaw;
+
+	bool bDirection;
+	bool bVelocity;
+	int acceleration;
 	DetectedObject()
 	{
+		bDirection = false;
+		bVelocity = false;
+		acceleration = 0;
 		id = 0;
 		w = 0;
 		l = 0;
 		h = 0;
 		t = GENERAL_OBSTACLE;
 		distance_to_center = 0;
+		predicted_behavior = INITIAL_STATE;
+		actual_speed = 0;
+		actual_yaw = 0;
 	}
 
 };
@@ -730,6 +778,8 @@ public:
 	double 	smoothingSmoothWeight;
 	double 	smoothingToleranceError;
 
+
+	double additionalBrakingDistance;
 	double verticalSafetyDistance;
 	double horizontalSafetyDistancel;
 
@@ -739,8 +789,6 @@ public:
 	bool 	enableHeadingSmoothing;
 	bool 	enableTrafficLightBehavior;
 	bool 	enableStopSignBehavior;
-	
-	bool	enableDynamicPlannerSwitch;
 
 	bool 	enabTrajectoryVelocities;
 
@@ -761,10 +809,11 @@ public:
 		minDistanceToAvoid				= 15;
 		maxDistanceToAvoid				= 5;
 		speedProfileFactor				= 1.0;
-		smoothingDataWeight				= 0.45;
-		smoothingSmoothWeight			= 0.3;
+		smoothingDataWeight				= 0.47;
+		smoothingSmoothWeight			= 0.2;
 		smoothingToleranceError			= 0.05;
 
+		additionalBrakingDistance		= 10.0;
 		verticalSafetyDistance 			= 0.0;
 		horizontalSafetyDistancel		= 0.0;
 
@@ -774,10 +823,7 @@ public:
 		enableTrafficLightBehavior		= false;
 		enableLaneChange 				= false;
 		enableStopSignBehavior			= false;
-		enabTrajectoryVelocities		= false;
-
-		enableDynamicPlannerSwitch 		= false;
-
+		enabTrajectoryVelocities 		= false;
 	}
 };
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\TrajectoryCosts.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\TrajectoryCosts.h" added_lines="9" deleted_lines="1">
				<diff>@@ -32,7 +32,14 @@ public:
 	vector&lt;TrajectoryCost&gt; m_TrajectoryCosts;
 	PlanningParams m_Params;
 	PolygonShape m_SafetyBorder;
-	//vector&lt;GPSPoint&gt; m_SafetyBox;
+	vector&lt;WayPoint&gt; m_AllContourPoints;
+	vector&lt;WayPoint&gt; m_CollisionPoints;
+	double m_WeightPriority;
+	double m_WeightTransition;
+	double m_WeightLong;
+	double m_WeightLat;
+	double m_WeightLaneChange;
+	double m_LateralSkipDistance;
 
 
 
@@ -42,6 +49,7 @@ private:
 	void NormalizeCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts);
 	void CalculateLateralAndLongitudinalCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts, const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts, const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; totalPaths, const WayPoint&amp; currState, const vector&lt;WayPoint&gt;&amp; contourPoints, const PlanningParams&amp; params, const CAR_BASIC_INFO&amp; carInfo, const VehicleState&amp; vehicleState);
 	void CalculateTransitionCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts, const int&amp; currTrajectoryIndex, const PlanningParams&amp; params);
+	bool CalculateIntersectionVelocities(const std::vector&lt;WayPoint&gt;&amp; path, const DetectedObject&amp; obj, const WayPoint&amp; currState,const CAR_BASIC_INFO&amp; carInfo, WayPoint&amp; collisionPoint);
 
 };
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\geo_pos_conv.hh" new_path="" added_lines="0" deleted_lines="40">
				<diff>@@ -1,40 +0,0 @@
-#ifndef __GEO_POS_CONV__
-#define __GEO_POS_CONV__
-
-#include &lt;math.h&gt;
-
-class geo_pos_conv {
-private:
-	double m_x;  //m
-	double m_y;  //m
-	double m_z;  //m
-
-	double m_lat;  //latitude
-	double m_lon; //longitude
-	double m_h;
-  
-	double m_PLato;        //plane lat
-	double m_PLo;          //plane lon
-
-public:
-	double x() const;
-	double y() const;
-	double z() const;
-  
-	void set_plane(double lat,   double lon);
-	void set_plane(int num);
-	void set_xyz(double cx,   double cy,   double cz);
-
-	//set llh in radians
-	void set_llh(double lat, double lon, double h);
-
-	//set llh in nmea degrees
-	void set_llh_nmea_degrees(double latd,double lond, double h);
-
-        void llh_to_xyz(double lat, double lon, double ele);
-
-	void conv_llh2xyz(void);
-	void conv_xyz2llh(void);
-};
-
-#endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\BehaviorStateMachine.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\BehaviorStateMachine.cpp" added_lines="13" deleted_lines="2">
				<diff>@@ -218,7 +218,7 @@ BehaviorStateMachine* WaitState::GetNextState()
 	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
 		return this;
 
-	PreCalculatedConditions* pCParams = GetCalcParams();
+	//PreCalculatedConditions* pCParams = GetCalcParams();
 
 	return FindBehaviorState(FORWARD_STATE);
 }
@@ -249,7 +249,18 @@ BehaviorStateMachine* FollowState::GetNextState()
 
 	//std::cout &lt;&lt; "Following State &gt;&gt; followDistance: " &lt;&lt; pCParams-&gt;distanceToNext &lt;&lt; ", followSpeed: " &lt;&lt; pCParams-&gt;velocityOfNext &lt;&lt; std::endl;
 
-	if(pCParams-&gt;currentGoalID != pCParams-&gt;prevGoalID
+	if(m_pParams-&gt;enableTrafficLightBehavior
+				&amp;&amp; pCParams-&gt;currentTrafficLightID &gt; 0
+				&amp;&amp; pCParams-&gt;bTrafficIsRed
+				&amp;&amp; pCParams-&gt;currentTrafficLightID != pCParams-&gt;prevTrafficLightID)
+			return FindBehaviorState(TRAFFIC_LIGHT_STOP_STATE);
+
+	else if(m_pParams-&gt;enableStopSignBehavior
+			&amp;&amp; pCParams-&gt;currentStopSignID &gt; 0
+			&amp;&amp; pCParams-&gt;currentStopSignID != pCParams-&gt;prevStopSignID)
+			return FindBehaviorState(STOP_SIGN_STOP_STATE);
+
+	else if(pCParams-&gt;currentGoalID != pCParams-&gt;prevGoalID
 			|| !pCParams-&gt;bFullyBlock)
 		return FindBehaviorState(FORWARD_STATE);
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\GridMap.cpp" new_path="" added_lines="0" deleted_lines="1674">
				<diff>@@ -1,1674 +0,0 @@
-/*
- * GridMap.cpp
- *
- *  Created on: Oct 22, 2013
- *      Author: hatem
- */
-
-#include "GridMap.h"
-#include "PlanningHelpers.h"
-#include &lt;fstream&gt;
-
-using namespace std;
-
-namespace PlannerHNS
-{
-
-GridMap::GridMap(double start_x, double start_y, double map_w, double map_h, double cell_length, bool bDefaultEmpty)
- {
-	assert(cell_length &gt; 0);
-    assert(map_w&gt;0);
-    assert(map_h&gt;0);
-
-    m_bUpdatedMap = false;
-    origin_x = start_x ;
-    origin_y = start_y;
-    m_DisplayResolution = 1;
-    sub_cell_l = 0;
-	nInnerWCells = nInnerHCells = 0;
-	m_bEnableInnerMap = false;
-	inner_end_col = inner_end_row = inner_h = inner_start_col = inner_start_row = inner_w = 0;
-
-	w = map_w;
-    h = map_h;
-
-    cell_l = cell_length;
-    sub_cell_l = cell_l/(double)SUBCELL_L;
-
-    wCells =  w/cell_l;
-    hCells =  h/cell_l;
-
-    nCells = wCells*hCells;
-	m_MaxHeuristics = w*h*cell_l;
-
-    pCells =  new CELL_Info[nCells];
-    POINT2D p;
-    int index = 0;
-
-    for(int r=0; r&lt;hCells; r++)
-    {
-       for(int c=0; c&lt;wCells; c++)
-	   {
-		 index = get2dIndex(r,c,wCells);
-		 p.x = ((double)c * cell_l) + origin_x;
-		 p.y = ((double)r * cell_l) + origin_y;
-		 pCells[index].Initialize(p, cell_l, r, c,bDefaultEmpty);
-		 pCells[index].index = index;
-
-	   }
-    }
-
-    double temp[8][3] = { { -1, 0, 1 }, { 0, -1, 1 }, { 1, 0, 1 }, { 0, 1, 1 }, { -1, -1, 1.5 }, { 1, -1, 1.5 }, { 1, 1, 1.5 }, { -1, 1, 1.5 } }; // left, down, right, top, left down, right down, top right, left top
-    delta = new POINT2D[8];
-    for (int i = 0; i &lt; 8; i++)
-    	delta[i] = POINT2D(temp[i][0], temp[i][1]);
- }
-
-int GridMap::InsidePolygon(const vector&lt;POINT2D&gt;&amp; polygon,const POINT2D&amp; p)
-{
-  int counter = 0;
-  int i;
-  double xinters;
-  POINT2D p1,p2;
-  int N = polygon.size();
-  if(N &lt;=0 ) return -1;
-
-  p1 = polygon.at(0);
-  for (i=1;i&lt;=N;i++)
-  {
-    p2 = polygon.at(i % N);
-
-    if (p.y &gt; MIN(p1.y,p2.y))
-    {
-      if (p.y &lt;= MAX(p1.y,p2.y))
-      {
-        if (p.x &lt;= MAX(p1.x,p2.x))
-        {
-          if (p1.y != p2.y)
-          {
-            xinters = (p.y-p1.y)*(p2.x-p1.x)/(p2.y-p1.y)+p1.x;
-            if (p1.x == p2.x || p.x &lt;= xinters)
-              counter++;
-          }
-        }
-      }
-    }
-    p1 = p2;
-  }
-
-  if (counter % 2 == 0)
-    return 0;
-  else
-    return 1;
-}
-
-
-  void GridMap::OpenClosedCells()
-  {
-	int loop_size =  nCells;
-	int index = 0;
-	while(index != loop_size)
-	{
-			pCells[index].closed = false;
-			pCells[index].expanded = -1;
-			index++;
-	}
-  }
-
-  void GridMap::ClearMap(int bMovingOnly)
-  {
-  	int loop_size =  nCells;
-  	int index = 0;
-	  while(index != loop_size)
-		{
-		  pCells[index].Clear(bMovingOnly);
-		index++;
-	  }
-	  m_bUpdatedMap = true;
-  }
-
-  void GridMap::UpdateMapObstacleValue(const Obstacle&amp; ob)
-  {
-	  POINT2D p1, p2, p3, p4;
-		p1 = ob.sp;
-		p2 = ob.ep;
-
-		if(ob.polygon.size() == 0)
-		{
-			int loop_size =  nCells;
-			int index = 0;
-			while(index != loop_size)
-			{
-					p3 = pCells[index].bottom_left;
-					p4 = pCells[index].top_right;
-
-					if(! ( p2.y &lt; p3.y || p1.y &gt; p4.y || p2.x &lt; p3.x || p1.x &gt; p4.x ))
-					{
-						pCells[index].nStaticPoints++;
-						m_bUpdatedMap = true;
-					}
-
-					index++;
-			}
-		}
-		else
-		{
-			vector&lt;CELL_Info*&gt; modList;
-			UpdateMapObstaclesValuePlygon(ob.polygon, modList);
-		}
-  }
-
-  void GridMap::UpdateMapObstaclesValuePlygon(const vector&lt;POINT2D&gt;&amp; poly, vector&lt;CELL_Info*&gt;&amp; modifiedCell)
-  {
-
-	  POINT2D minP, maxP;
-	  CELL_Info* minC, *maxC;
-	  int index = 0;
-
-	  minP = poly[0];
-	  maxP = poly[0];
-
-		for(unsigned int j=1; j&lt; poly.size(); j++)
-		{
-			if(poly[j].x &lt; minP.x) minP.x = poly[j].x;
-			if(poly[j].y &lt; minP.y) minP.y = poly[j].y;
-
-			if(poly[j].x &gt; maxP.x) maxP.x = poly[j].x;
-			if(poly[j].y &gt; maxP.y) maxP.y = poly[j].y;
-		}
-
-
-		minC = GetCellFromPoint(minP,false);
-		maxC = GetCellFromPoint(maxP, false);
-
-		if(!maxC || ! minC)
-		{
-			printf("Obstacle Polygon is outside the Map !!");
-			return;
-		}
-
-		for(int r=minC-&gt;r; r&lt;=maxC-&gt;r; r++)
-		{
-			for(int c=minC-&gt;c; c&lt;=maxC-&gt;c; c++)
-			{
-				index = get2dIndex(r,c,wCells);
-				//CELL_Info* pSub = &amp;pCells[index];
-
-//					if(pSub-&gt;pInnerMap == 0)
-//					{
-//						pSub-&gt;InitSubCells(cell_l, sub_cell_l);
-//					}
-//						int index_sub = 0;
-//						bool bUpdatedSubCell = false;
-//						while(index_sub &lt; pSub-&gt;nCells)
-//						{
-//							if(InsidePolygon(&amp;poly, poly.size(), pSub-&gt;pInnerMap[index_sub].bottom_left)==1 || InsidePolygon(&amp;poly, poly.size(), pSub-&gt;pInnerMap[index_sub].top_right)==1)
-//							{
-//								pSub-&gt;pInnerMap[index_sub].nStaticPoints = 1;
-//								m_bUpdatedMap = true;
-//								bUpdatedSubCell = true;
-//							}
-//							index_sub++;
-//						}
-
-
-				//if(bUpdatedSubCell)
-				{
-					POINT2D bl= pCells[index].bottom_left;
-					bl.x += 0.01;
-					bl.y += 0.01;
-					POINT2D tr= pCells[index].top_right;
-					tr.x -= 0.01;
-					tr.y -= 0.01;
-					if(InsidePolygon(poly, bl)==1 || InsidePolygon(poly, tr)==1)
-					{
-
-							pCells[index].nMovingPoints = 1;
-							pCells[index].nStaticPoints = 1;
-//							pCells[index].forwardHeuristic = nCells;
-//							pCells[index].backwardHeuristic = nCells;
-//							pCells[index].heuristic = nCells;
-							modifiedCell.push_back(&amp;pCells[index]);
-							m_bUpdatedMap = true;
-							//pDrivableCells.push_back(&amp;pCells[r][c]);
-					}
-				}
-			}
-		}
-  }
-
-  void GridMap::UpdateMapDrivablesValuePlygon(const vector&lt;vector&lt;POINT2D&gt; &gt;&amp; points)
-  {
-//		for(int r=0; r&lt;nColCells; r++)
-//		{
-//			for(int c=0; c&lt;nRowCells; c++)
-//			{
-//				if(pCells[r][c].cell.bObstacle)
-//				{
-//					for(unsigned int i=0; i&lt; points-&gt;size(); i++)
-//					{
-//						vector&lt;POINT2D&gt;* poly = &amp;((*points)[i]);
-//						if(InsidePolygon(poly, poly-&gt;size(), pCells[r][c].cell.bottom_left)==1 || InsidePolygon(poly, poly-&gt;size(), pCells[r][c].cell.top_right)==1)
-//								pCells[r][c].cell.bObstacle = false;
-//					}
-//				}
-//
-//			}
-//		}
-
-	  POINT2D minP, maxP;
-	  CELL_Info* minC, *maxC;
-	  int index = 0;
-
-	  for(unsigned int i=0; i&lt; points.size(); i++)
-		{
-			vector&lt;POINT2D&gt; poly = points.at(i);
-			maxP = minP = poly[0];
-
-			for(unsigned int j=1; j&lt; poly.size(); j++)
-			{
-				if(poly[j].x &lt; minP.x) minP.x = poly[j].x;
-				if(poly[j].y &lt; minP.y) minP.y = poly[j].y;
-
-				if(poly[j].x &gt; maxP.x) maxP.x = poly[j].x;
-				if(poly[j].y &gt; maxP.y) maxP.y = poly[j].y;
-			}
-
-
-			minC = GetCellFromPoint(minP,false);
-			maxC = GetCellFromPoint(maxP, false);
-
-			for(int r=minC-&gt;r; r&lt;maxC-&gt;r; r++)
-			{
-				for(int c=minC-&gt;c; c&lt;maxC-&gt;c; c++)
-				{
-					index = get2dIndex(r,c,wCells);
-
-					CELL_Info* pSub = &amp;pCells[index];
-
-					if(pSub-&gt;pInnerMap != 0)
-					{
-						pSub-&gt;InitSubCells(cell_l, sub_cell_l);
-					}
-						int index_sub = 0;
-						//bool bUpdatedSubCell = false;
-						while(index_sub &lt; pSub-&gt;nCells)
-						{
-							if(InsidePolygon(poly, pSub-&gt;pInnerMap[index_sub].bottom_left)==1 || InsidePolygon(poly, pSub-&gt;pInnerMap[index_sub].top_right)==1)
-							{
-								pSub-&gt;pInnerMap[index_sub].nStaticPoints = 0;
-								m_bUpdatedMap = true;
-								//bUpdatedSubCell = true;
-							}
-							index_sub++;
-						}
-
-
-					//if(bUpdatedSubCell)
-					{
-						if(InsidePolygon(poly, pCells[index].bottom_left)==1 || InsidePolygon(poly, pCells[index].top_right)==1)
-						{
-
-								pCells[index].nStaticPoints = 0;
-								m_bUpdatedMap = true;
-								//pDrivableCells.push_back(&amp;pCells[r][c]);
-						}
-					}
-				}
-			}
-		}
-  }
-
-  void GridMap::UpdateMapDrivablesValue(const DrivableArea&amp; dr)
-    {
-  	  POINT2D p1, p2, p3, p4;
-  	  p1 = dr.sp;
-  	  p2 = dr.ep;
-
-  		int loop_size =  nCells;
-  	int index = 0;
-	  while(index != loop_size)
-		{
-				p3 = pCells[index].bottom_left;
-				p4 = pCells[index].top_right;
-
-				if(! ( p2.y &lt; p3.y || p1.y &gt; p4.y || p2.x &lt; p3.x || p1.x &gt; p4.x ))
-				{
-					pCells[index].nStaticPoints = 0;
-					m_bUpdatedMap = true;
-				}
-
-				index++;
-		}
-    }
-
-  void GridMap::InitInnerMap(double  map_l, GridMap* const pParentMap, const POINT2D&amp; center)
-  {
-	  int min_row, min_col, max_row, max_col;
-	  CELL_Info* scell = GetCellFromPoint(center);
-		if(!scell) return;
-
-		//Get First Left Cell
-		double max_left = scell-&gt;c * pParentMap-&gt;cell_l;
-		if(max_left &lt; map_l)
-		{
-			min_row = 0;
-		}
-		else
-		{
-			POINT2D p(center.x-map_l, center.y);
-			min_row = GetCellFromPoint(p)-&gt;r;
-		}
-
-		double max_right = (pParentMap-&gt;hCells - scell-&gt;c) * pParentMap-&gt;cell_l;
-		if(max_right &lt; map_l)
-		{
-			max_row = pParentMap-&gt;hCells;
-		}
-		else
-		{
-			POINT2D p(center.x+map_l, center.y);
-			max_row = GetCellFromPoint(p)-&gt;r;
-		}
-
-		double max_bottom = scell-&gt;r * pParentMap-&gt;cell_l;
-		if(max_bottom &lt; map_l)
-		{
-			min_col = 0;
-		}
-		else
-		{
-			POINT2D p(center.x, center.y-map_l);
-			min_col = GetCellFromPoint(p)-&gt;c;
-		}
-
-		double max_top = (pParentMap-&gt;wCells- scell-&gt;r) * pParentMap-&gt;cell_l;
-		if(max_top &lt; map_l)
-		{
-			max_col = pParentMap-&gt;wCells;
-		}
-		else
-		{
-			POINT2D p(center.x, center.y+map_l);
-			max_col = GetCellFromPoint(p)-&gt;c;
-		}
-
-		inner_start_row = min_row;
-		inner_start_col = min_col;
-		inner_end_row = max_row;
-		inner_end_col = max_col;
-		nInnerWCells =max_col-min_col;
-		nInnerHCells = max_row-min_row;
-		inner_w =  nInnerWCells* pParentMap-&gt;cell_l;
-		inner_h =  nInnerHCells* pParentMap-&gt;cell_l;
-		cell_l = pParentMap-&gt;cell_l;
-		sub_cell_l = pParentMap-&gt;sub_cell_l;
-
-
-  }
-
- CELL_Info* GridMap::UpdateMapCostValueRange(const vector&lt;POINT2D&gt;&amp; ps, const GPSPoint&amp; currPos, const vector&lt;double&gt;&amp; features)
-  {
-	 POINT2D pos(currPos.x, currPos.y);
-	CELL_Info* pC = GetCellFromPoint(pos);
-
-
-
-	if(pC)
-	{
-		//Update Affected cells value from this new point
-		vector&lt;CELL_Info*&gt; cells;
-		GetSurroundingMainCells(pos, cells, 1);
-		for(unsigned int i=0; i&lt; cells.size(); i++)
-		{
-			cells[i]-&gt;UpdateSubCellCostValue(ps, cell_l, sub_cell_l);
-			cells[i]-&gt;UpdateCostValue(ps);
-			m_bUpdatedMap = true;
-		}
-		//only one level
-//			pC-&gt;UpdateSubCellCostValue(p, cell_l, sub_cell_l);
-
-	}
-
-	return pC;
-  }
-
- bool GridMap::CheckSubCellsInTheWay(const POINT2D&amp; p, const GPSPoint&amp; carPos, const double&amp; thiningThreshold, vector&lt;CELL_Info*&gt;&amp; pSubCellsList)
- {
-	 POINT2D v(p.x - carPos.x, p.y - carPos.y);
-	 double v_norm = pointNorm(v);
-
-
-	 //Number of search iteration will be a ratio between the thining threshold   and the sub cell length
-	 double step_d = sub_cell_l;
-	 double start_d = -thiningThreshold/ 2.0;
-	 pSubCellsList.clear();
-	 CELL_Info* pSubCell = 0;
-	 while(start_d &lt; thiningThreshold)
-	 {
-		 POINT2D p_obstacle = p;
-		 p_obstacle.x += v.x/v_norm * start_d;
-		 p_obstacle.y += v.y/v_norm * start_d;
-		 pSubCell = GetSubCellFromPoint(p_obstacle);
-		 if(pSubCell &amp;&amp; pSubCell-&gt;nStaticPoints&gt;0)
-			 return true;
-
-		pSubCellsList.push_back(pSubCell);
-		 start_d += step_d;
-	 }
-
-	 return false;
- }
-
- CELL_Info* GridMap::UpdateThinMapObstaclePoint(const POINT2D&amp; p, const GPSPoint&amp; carPos,const double&amp; thiningTHreshold)
- {
-	 CELL_Info* pC = GetCellFromPoint(p);
-	if(pC)
-	{
-		vector&lt;CELL_Info*&gt; subcells_list;
-
-		if(!CheckSubCellsInTheWay(p, carPos, thiningTHreshold, subcells_list))
-		{
-			pC-&gt;nStaticPoints++;
-			CELL_Info* pSubc = GetSubCellFromCell(pC, p);
-			if(pSubc)
-			{
-				if(pSubc-&gt;nStaticPoints&lt;1)
-				{
-					pSubc-&gt;innerStaticPointsList.push_back(p);
-					m_bUpdatedMap = true;
-				}
-
-				pSubc-&gt;nStaticPoints++;
-			}
-		}
-	}
-	return pC;
- }
-
- CELL_Info* GridMap::UpdateMapObstaclePoint(const POINT2D&amp; p)
-{
-	CELL_Info* pC = GetCellFromPoint(p);
-	if(pC)
-	{
-		if(pC-&gt;nStaticPoints &lt; 5)
-			pC-&gt;nStaticPoints++;
-		CELL_Info* pSubc = GetSubCellFromCell(pC, p);
-		if(pSubc)
-		{
-			if(pSubc-&gt;nStaticPoints&lt;1)
-			{
-				//pthread_mutex_lock(&amp;update_map_mutex);
-				pSubc-&gt;innerStaticPointsList.push_back(p);
-				m_bUpdatedMap = true;
-				//pthread_mutex_unlock(&amp;update_map_mutex);
-			}
-
-			if(pSubc-&gt;nStaticPoints &lt; 5)
-				pSubc-&gt;nStaticPoints++;
-		}
-	}
-	return pC;
-}
-
-CELL_Info* GridMap::UpdateMapMovingObstaclePoint(const POINT2D&amp; p)
-{
-	CELL_Info* pC = GetCellFromPoint(p);
-	if(pC)
-	{
-		if(pC-&gt;nMovingPoints &lt; 5)
-			pC-&gt;nMovingPoints++;
-		CELL_Info* pSubc = GetSubCellFromCell(pC, p);
-		if(pSubc)
-		{
-			if(pSubc-&gt;nMovingPoints&lt;1)
-			{
-				//pthread_mutex_lock(&amp;update_map_mutex);
-				pSubc-&gt;innerMovingPointsList.push_back(p);
-				m_bUpdatedMap = true;
-				//pthread_mutex_unlock(&amp;update_map_mutex);
-			}
-
-			if(pSubc-&gt;nMovingPoints&lt;5)
-				pSubc-&gt;nMovingPoints++;
-		}
-	}
-	return pC;
-}
-
- CELL_Info* GridMap::UpdateMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob)
- {
- 	CELL_Info* pC = GetCellFromPoint(p);
- 	if(pC)
- 	{
- 		pC-&gt;localize_val = localize_val;
- 		pC-&gt;localize_prob = localize_prob;
- 		m_bUpdatedMap = true;
- 	}
-
- 	return pC;
- }
-
- CELL_Info* GridMap::UpdateSubMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob)
- {
- 	CELL_Info* pC = GetCellFromPoint(p);
- 	if(pC)
- 	{
-
- 		CELL_Info* pSubc = GetSubCellFromCell(pC, p);
- 		if(pSubc)
- 		{
- 			pSubc-&gt;localize_val = localize_val;
- 			pSubc-&gt;localize_prob = localize_prob;
- 			m_bUpdatedMap = true;
- 		}
- 	}
-
- 	return pC;
- }
-
-CELL_Info* GridMap::GetSubCellFromCell(CELL_Info* const parent, const POINT2D&amp; p)
-{
-	if(!parent) return 0;
-
-	if(!parent-&gt;pInnerMap)
-		parent-&gt;InitSubCells(cell_l, sub_cell_l);
-
-	int row = floor((p.y - parent-&gt;bottom_left.y)/sub_cell_l);
-	int col = floor((p.x - parent-&gt;bottom_left.x)/sub_cell_l);
-
-	if(row&gt;=0 &amp;&amp; row&lt;SUBCELL_L &amp;&amp; col &gt;=0 &amp;&amp; col &lt; SUBCELL_L)
-		return &amp;parent-&gt;pInnerMap[get2dIndex(row,col,SUBCELL_L)];
-	else
-		return 0;
-}
-
-CELL_Info* GridMap::GetSubCellFromPoint(const POINT2D&amp; p)
-{
-	CELL_Info* pMainCell = GetCellFromPoint(p);
-	if(pMainCell)
-	{
-		if(!pMainCell-&gt;pInnerMap)
-			pMainCell-&gt;InitSubCells(cell_l, sub_cell_l);
-
-		int row = floor((p.y - pMainCell-&gt;bottom_left.y)/sub_cell_l);
-		int col = floor((p.x - pMainCell-&gt;bottom_left.x)/sub_cell_l);
-
-		return &amp;pMainCell-&gt;pInnerMap[get2dIndex(row,col,SUBCELL_L)];
-	}
-	else
-		return 0;
-}
-
-CELL_Info* GridMap::GetCellFromPoint(const POINT2D&amp; p, bool bExpand)
-{
-
-	  int row = floor((p.y-origin_y) /cell_l);
-	  int col = floor((p.x-origin_x) /cell_l);
-
-	  if(row&gt;=0 &amp;&amp; row &lt; hCells &amp;&amp; col &gt;=0 &amp;&amp; col &lt; wCells)
-	  {
-//		  POINT2D _p(p.x , p.y );
-//		bool exist = pCells[get2dIndex(row,col,nColCells)].PointInRect(p);
-//
-//		if(!exist)
-//			return 0;
-
-		  //retCell = pCells[row][col];
-		  //retCell.center.a = p.a;
-		  int index = get2dIndex(row,col,wCells);
-		  if(index &gt;= 0 &amp;&amp; index &lt; nCells)
-			  return &amp;pCells[index];
-		  else
-			  printf("Error Getting Cell with Info: P(%f,%f) , C(%d,%d), index = %d", p.x, p.y, row, col, index);
-	  }
-	  else if(bExpand)
-	  {
-		  //first get extend direction and factor
-		  double lf=0, rf=0,tf=0,bf=0;
-		  int nRC=0,nCC=0;
-		  if(fabsf(p.x) &gt;= 0)
-			nRC= (fabsf(p.x) - 0)/cell_l + 1;
-
-		  if(fabsf(p.y) &gt;= 0)
-			nCC= (fabsf(p.y) - 0)/cell_l + 1;
-
-		  if(p.x &gt; 0)
-			  rf = nRC*4.0;
-		  else
-			  lf = nRC*4.0;
-
-		  if(p.y &gt; 0)
-			  tf = nCC*4.0;
-		  else
-			  bf = nCC*4.0;
-
-	  }
-
-    return 0;
-  }
-
-
-CELL_Info* GridMap::GetCellFromPointInnerMap(const POINT2D&amp; p)
-{
-  int row = floor((p.y - origin_y) /cell_l);
-  int col = floor((p.x - origin_x)/cell_l);
-
-  if(row&gt;=inner_start_row &amp;&amp; row &lt; inner_end_row &amp;&amp; col &gt;=inner_start_col &amp;&amp; col &lt; inner_end_col)
-  {
-
-	  POINT2D _p(p.x , p.y );
-
-	bool exist = pCells[get2dIndex(row,col,wCells)].PointInRect(p);
-
-	if(!exist)
-		return 0;
-
-	  //retCell = pCells[row][col];
-	  //retCell.center.a = p.a;
-	  return &amp;pCells[get2dIndex(row,col,wCells)];
-  }
-
-  return 0;
-
-}
-
-  void GridMap::BackupMap()
-  {
-  }
-
-  GridMap::GridMap()
-	{
-	  //update_map_mutex = PTHREAD_MUTEX_INITIALIZER;
-		sub_cell_l = 0;
-		nCells = 0;
-		nInnerWCells = nInnerHCells = 0;
-		m_bEnableInnerMap = false;
-		inner_end_col = inner_end_row = inner_h = inner_start_col = inner_start_row = inner_w = 0;
-		w = h = cell_l  = wCells = hCells = m_MaxHeuristics = 0;
-		pCells = 0;
-		m_DisplayResolution = 1;
-		delta = 0;
-		origin_y = 0;
-		origin_x =0;
-		m_bUpdatedMap  = false;
-	}
-
-  GridMap::~GridMap()
-  {
-    if(pCells)
-    {
-      delete [] pCells;
-      pCells = 0;
-    }
-    if(delta)
-    {
-    	delete [] delta;
-    	delta = 0;
-    }
-  }
-
-  int GridMap::GetSurroundingNonObstacleCells(const POINT2D&amp; pos, vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range)
-  {
-	  int nMaxLevels = max_range/cell_l;
-
-	int r, c;
-	vector&lt;CELL_Info*&gt; nextLevel;
-	vector&lt;CELL_Info*&gt; currentLevel;
-	vector&lt;CELL_Info*&gt; tempLevel;
-
-	CELL_Info* originalGoal = GetCellFromPoint(pos);
-	if(!originalGoal) return 0;
-
-	CELL_Info* tempCell;
-
-
-	currentLevel.push_back(originalGoal);
-	cells_list.push_back(originalGoal);
-	int counter = 0;
-	int index = 0;
-
-	while (currentLevel.size() &gt; 0 &amp;&amp; nMaxLevels&gt;0)
-	{
-		tempCell = currentLevel.back();
-		currentLevel.pop_back();
-
-		for (int i = 0; i &lt; 8; i++)
-		{
-			counter++;
-			r = tempCell-&gt;r + delta[i].x;
-			c = tempCell-&gt;c + delta[i].y;
-			index = get2dIndex(r,c,wCells);
-
-			if (r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt; hCells &amp;&amp; c &lt; wCells)
-			{
-				if(pCells[index].nMovingPoints&gt;0 || pCells[index].nStaticPoints &gt; 0 || pCells[index].heuristic == m_MaxHeuristics)
-					continue;
-				//insert unique
-				bool bFound = false;
-				for(unsigned int j=0; j&lt; cells_list.size();j++)
-				{
-					if(cells_list[j] == &amp;pCells[index])
-					{
-						bFound = true;
-						break;
-					}
-				}
-				if(!bFound)
-				{
-					cells_list.push_back(&amp;pCells[index]);
-					nextLevel.push_back(&amp;pCells[index]);
-				}
-			}
-		}
-
-		if (currentLevel.size() == 0 &amp;&amp; nextLevel.size() &gt; 0)
-		{
-			tempLevel = currentLevel;
-			currentLevel = nextLevel;
-			nextLevel = tempLevel;
-			nMaxLevels--;
-		}
-	}
-
-	return counter;
-  }
-
-  int GridMap::GetSurroundingMainCellsRectangleNoObstacle(const POINT2D&amp; pos,	vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect)
-    {
-
-    	//calculate the number of levels that satisfy the max range criteria
-    	int nMaxLevels = hypot(rect.width, rect.length) / cell_l;
-
-    	CELL_Info* originalGoal = GetCellFromPoint(pos);
-
-    	if (!originalGoal)
-    		return 0;
-
-    	cells_list.push_back(originalGoal);
-
-    	if (nMaxLevels &lt;= 1)
-    		return 1;
-
-    	nMaxLevels--;
-
-    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; straitCells;
-    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; diagonalCells;
-    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; straitCellsL2;
-    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; diagonalCellsL2;
-    	int r, c;
-    	CELL_Info* tempCell = 0;
-    	int counter = 1;
-    	int index = 0;
-
-    	POINT2D mask;
-    	//first level , // left, down, right, top, left down, right down, top right, left top
-    	//strait degree
-    	for (unsigned int i = 0; i &lt; 4; i++)
-    	{
-    		mask.x = delta[i].x;
-    		mask.y = delta[i].y;
-    		r = originalGoal-&gt;r + mask.x;
-    		c = originalGoal-&gt;c + mask.y;
-    		index = get2dIndex(r, c, wCells);
-
-    		if(checkGridIndex(index, nCells) &amp;&amp; pCells[index].nMovingPoints == 0 &amp;&amp; pCells[index].nStaticPoints == 0 &amp;&amp; pCells[index].heuristic != m_MaxHeuristics)
-  		{
-  			straitCells.push_back(make_pair(&amp;pCells[index], mask));
-  			if (!pCells[index].TestWithRectangle(rect))
-  				cells_list.push_back(&amp;pCells[index]);
-  		}
-    	}
-
-    	//diagonal degree
-    	for (unsigned int i = 4; i &lt; 8; i++)
-    	{
-    		mask.x = delta[i].x;
-    		mask.y = delta[i].y;
-    		r = originalGoal-&gt;r + mask.x;
-    		c = originalGoal-&gt;c + mask.y;
-    		index = get2dIndex(r, c, wCells);
-    		if(checkGridIndex(index, nCells) &amp;&amp; pCells[index].nMovingPoints == 0 &amp;&amp; pCells[index].nStaticPoints == 0 &amp;&amp; pCells[index].heuristic != m_MaxHeuristics)
-    		{
-    			diagonalCells.push_back(make_pair(&amp;pCells[index], mask));
-  			if (!pCells[index].TestWithRectangle(rect))
-  				cells_list.push_back(&amp;pCells[index]);
-    		}
-    	}
-
-    	nMaxLevels--;
-    	counter++;
-
-    	while (nMaxLevels &gt; 0)
-    	{
-    		straitCellsL2.clear();
-    		diagonalCellsL2.clear();
-    		while (straitCells.size() &gt; 0)
-    		{
-    			mask = straitCells.back().second;
-    			tempCell = straitCells.back().first;
-    			r = tempCell-&gt;r + mask.x;
-    			c = tempCell-&gt;c + mask.y;
-    			index = get2dIndex(r, c, wCells);
-    			if(checkGridIndex(index, nCells) &amp;&amp; pCells[index].nMovingPoints == 0 &amp;&amp; pCells[index].nStaticPoints == 0 &amp;&amp; pCells[index].heuristic != m_MaxHeuristics)
-    			{
-  				straitCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-  				if (!pCells[index].TestWithRectangle(rect))
-  					cells_list.push_back(&amp;pCells[index]);
-    			}
-
-    			//diagonal 1
-    			if (straitCells.back().second.x == 0)
-    				mask.x += 1;
-    			else
-    				mask.y += 1;
-    			r = tempCell-&gt;r + mask.x;
-    			c = tempCell-&gt;c + mask.y;
-    			index = get2dIndex(r, c, wCells);
-    			if(checkGridIndex(index, nCells) &amp;&amp; pCells[index].nMovingPoints == 0 &amp;&amp; pCells[index].nStaticPoints == 0 &amp;&amp; pCells[index].heuristic != m_MaxHeuristics)
-    			{
-  				diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-  				if (!pCells[index].TestWithRectangle(rect))
-  					cells_list.push_back(&amp;pCells[index]);
-    			}
-
-    			//diagonal 2
-    			if (straitCells.back().second.x == 0)
-    				mask.x += -2;
-    			else
-    				mask.y += -2;
-    			r = tempCell-&gt;r + mask.x;
-    			c = tempCell-&gt;c + mask.y;
-    			index = get2dIndex(r, c, wCells);
-    			if(checkGridIndex(index, nCells) &amp;&amp; pCells[index].nMovingPoints == 0 &amp;&amp; pCells[index].nStaticPoints == 0 &amp;&amp; pCells[index].heuristic != m_MaxHeuristics)
-    			{
-  				diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-  				if (!pCells[index].TestWithRectangle(rect))
-  					cells_list.push_back(&amp;pCells[index]);
-    			}
-
-    			straitCells.pop_back();
-    		}
-
-    		//Diagonal
-    		while (diagonalCells.size() &gt; 0)
-    		{
-    			mask = diagonalCells.back().second;
-    			tempCell = diagonalCells.back().first;
-    			r = tempCell-&gt;r + mask.x;
-    			c = tempCell-&gt;c + mask.y;
-    			index = get2dIndex(r, c, wCells);
-    			if(checkGridIndex(index, nCells) &amp;&amp; pCells[index].nMovingPoints == 0 &amp;&amp; pCells[index].nStaticPoints == 0 &amp;&amp; pCells[index].heuristic != m_MaxHeuristics)
-    			{
-  				diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-  				if (!pCells[index].TestWithRectangle(rect))
-  					cells_list.push_back(&amp;pCells[index]);
-    			}
-
-    			diagonalCells.pop_back();
-    		}
-
-    		nMaxLevels--;
-    		counter++;
-    		if (nMaxLevels &lt;= 0)
-    			break;
-
-    		straitCells = straitCellsL2;
-    		diagonalCells = diagonalCellsL2;
-
-    	}
-
-    	return counter;
-
-    }
-
-  int GridMap::GetSurroundingMainCellsRectangle(const POINT2D&amp; pos,	vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect)
-  {
-
-  	//calculate the number of levels that satisfy the max range criteria
-  	int nMaxLevels = hypot(rect.width, rect.length) / cell_l;
-
-  	CELL_Info* originalGoal = GetCellFromPoint(pos);
-
-  	if (!originalGoal)
-  		return 0;
-
-  	cells_list.push_back(originalGoal);
-
-  	if (nMaxLevels &lt;= 1)
-  		return 1;
-
-  	nMaxLevels--;
-
-  	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; straitCells;
-  	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; diagonalCells;
-  	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; straitCellsL2;
-  	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; diagonalCellsL2;
-  	int r, c;
-  	CELL_Info* tempCell = 0;
-  	int counter = 1;
-  	int index = 0;
-
-  	POINT2D mask;
-  	//first level , // left, down, right, top, left down, right down, top right, left top
-  	//strait degree
-  	for (unsigned int i = 0; i &lt; 4; i++)
-  	{
-  		mask.x = delta[i].x;
-  		mask.y = delta[i].y;
-  		r = originalGoal-&gt;r + mask.x;
-  		c = originalGoal-&gt;c + mask.y;
-  		index = get2dIndex(r, c, wCells);
-  		if(checkGridIndex(index, nCells))
-		{
-			straitCells.push_back(make_pair(&amp;pCells[index], mask));
-			if (!pCells[index].TestWithRectangle(rect))
-				cells_list.push_back(&amp;pCells[index]);
-		}
-  	}
-
-  	//diagonal degree
-  	for (unsigned int i = 4; i &lt; 8; i++)
-  	{
-  		mask.x = delta[i].x;
-  		mask.y = delta[i].y;
-  		r = originalGoal-&gt;r + mask.x;
-  		c = originalGoal-&gt;c + mask.y;
-  		index = get2dIndex(r, c, wCells);
-  		if(checkGridIndex(index, nCells))
-  		{
-  			diagonalCells.push_back(make_pair(&amp;pCells[index], mask));
-			if (!pCells[index].TestWithRectangle(rect))
-				cells_list.push_back(&amp;pCells[index]);
-  		}
-  	}
-
-  	nMaxLevels--;
-  	counter++;
-
-  	while (nMaxLevels &gt; 0)
-  	{
-  		straitCellsL2.clear();
-  		diagonalCellsL2.clear();
-  		while (straitCells.size() &gt; 0)
-  		{
-  			mask = straitCells.back().second;
-  			tempCell = straitCells.back().first;
-  			r = tempCell-&gt;r + mask.x;
-  			c = tempCell-&gt;c + mask.y;
-  			index = get2dIndex(r, c, wCells);
-  			if(checkGridIndex(index, nCells))
-  			{
-				straitCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-				if (!pCells[index].TestWithRectangle(rect))
-					cells_list.push_back(&amp;pCells[index]);
-  			}
-
-  			//diagonal 1
-  			if (straitCells.back().second.x == 0)
-  				mask.x += 1;
-  			else
-  				mask.y += 1;
-  			r = tempCell-&gt;r + mask.x;
-  			c = tempCell-&gt;c + mask.y;
-  			index = get2dIndex(r, c, wCells);
-  			if(checkGridIndex(index, nCells))
-  			{
-				diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-				if (!pCells[index].TestWithRectangle(rect))
-					cells_list.push_back(&amp;pCells[index]);
-  			}
-
-  			//diagonal 2
-  			if (straitCells.back().second.x == 0)
-  				mask.x += -2;
-  			else
-  				mask.y += -2;
-  			r = tempCell-&gt;r + mask.x;
-  			c = tempCell-&gt;c + mask.y;
-  			index = get2dIndex(r, c, wCells);
-  			if(checkGridIndex(index, nCells))
-  			{
-				diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-				if (!pCells[index].TestWithRectangle(rect))
-					cells_list.push_back(&amp;pCells[index]);
-  			}
-
-  			straitCells.pop_back();
-  		}
-
-  		//Diagonal
-  		while (diagonalCells.size() &gt; 0)
-  		{
-  			mask = diagonalCells.back().second;
-  			tempCell = diagonalCells.back().first;
-  			r = tempCell-&gt;r + mask.x;
-  			c = tempCell-&gt;c + mask.y;
-  			index = get2dIndex(r, c, wCells);
-  			if(checkGridIndex(index, nCells))
-  			{
-				diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-				if (!pCells[index].TestWithRectangle(rect))
-					cells_list.push_back(&amp;pCells[index]);
-  			}
-
-  			diagonalCells.pop_back();
-  		}
-
-  		nMaxLevels--;
-  		counter++;
-  		if (nMaxLevels &lt;= 0)
-  			break;
-
-  		straitCells = straitCellsL2;
-  		diagonalCells = diagonalCellsL2;
-
-  	}
-
-  	return counter;
-
-  }
-
-  int GridMap::GetSurroundingMainCellsCircle(const POINT2D&amp; pos,	vector&lt;CELL_Info*&gt;&amp; cells_list, double radius)
-    {
-
-    	//calculate the number of levels that satisfy the max range criteria
-    	int nMaxLevels = radius * 2.0 / cell_l;
-
-    	CELL_Info* originalGoal = GetCellFromPoint(pos);
-
-    	if (!originalGoal)
-    		return 0;
-
-    	cells_list.push_back(originalGoal);
-
-    	if (nMaxLevels &lt;= 1)
-    		return 1;
-
-    	nMaxLevels--;
-
-    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; straitCells;
-    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; diagonalCells;
-    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; straitCellsL2;
-    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; diagonalCellsL2;
-    	int r, c;
-    	CELL_Info* tempCell = 0;
-    	int counter = 1;
-    	int index = 0;
-
-    	POINT2D mask;
-    	//first level , // left, down, right, top, left down, right down, top right, left top
-    	//strait degree
-    	for (unsigned int i = 0; i &lt; 4; i++)
-    	{
-    		mask.x = delta[i].x;
-    		mask.y = delta[i].y;
-    		r = originalGoal-&gt;r + mask.x;
-    		c = originalGoal-&gt;c + mask.y;
-    		index = get2dIndex(r, c, wCells);
-    		if(checkGridIndex(index, nCells))
-  		{
-  			straitCells.push_back(make_pair(&amp;pCells[index], mask));
-  			if (pCells[index].TestWithCircle(pos, radius))
-  				cells_list.push_back(&amp;pCells[index]);
-  		}
-    	}
-
-    	//diagonal degree
-    	for (unsigned int i = 4; i &lt; 8; i++)
-    	{
-    		mask.x = delta[i].x;
-    		mask.y = delta[i].y;
-    		r = originalGoal-&gt;r + mask.x;
-    		c = originalGoal-&gt;c + mask.y;
-    		index = get2dIndex(r, c, wCells);
-    		if(checkGridIndex(index, nCells))
-    		{
-    			diagonalCells.push_back(make_pair(&amp;pCells[index], mask));
-    			if (pCells[index].TestWithCircle(pos, radius))
-    				cells_list.push_back(&amp;pCells[index]);
-    		}
-    	}
-
-    	nMaxLevels--;
-    	counter++;
-
-    	while (nMaxLevels &gt; 0)
-    	{
-    		straitCellsL2.clear();
-    		diagonalCellsL2.clear();
-    		while (straitCells.size() &gt; 0)
-    		{
-    			mask = straitCells.back().second;
-    			tempCell = straitCells.back().first;
-    			r = tempCell-&gt;r + mask.x;
-    			c = tempCell-&gt;c + mask.y;
-    			index = get2dIndex(r, c, wCells);
-    			if(checkGridIndex(index, nCells))
-    			{
-    				straitCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-    				if (pCells[index].TestWithCircle(pos, radius))
-    					cells_list.push_back(&amp;pCells[index]);
-    			}
-
-    			//diagonal 1
-    			if (straitCells.back().second.x == 0)
-    				mask.x += 1;
-    			else
-    				mask.y += 1;
-    			r = tempCell-&gt;r + mask.x;
-    			c = tempCell-&gt;c + mask.y;
-    			index = get2dIndex(r, c, wCells);
-    			if(checkGridIndex(index, nCells))
-    			{
-					diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-					if (pCells[index].TestWithCircle(pos, radius))
-						cells_list.push_back(&amp;pCells[index]);
-    			}
-
-    			//diagonal 2
-    			if (straitCells.back().second.x == 0)
-    				mask.x += -2;
-    			else
-    				mask.y += -2;
-    			r = tempCell-&gt;r + mask.x;
-    			c = tempCell-&gt;c + mask.y;
-    			index = get2dIndex(r, c, wCells);
-    			if(checkGridIndex(index, nCells))
-    			{
-    				diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-    				if (pCells[index].TestWithCircle(pos, radius))
-    					cells_list.push_back(&amp;pCells[index]);
-    			}
-
-    			straitCells.pop_back();
-    		}
-
-    		//Diagonal
-    		while (diagonalCells.size() &gt; 0)
-    		{
-    			mask = diagonalCells.back().second;
-    			tempCell = diagonalCells.back().first;
-    			r = tempCell-&gt;r + mask.x;
-    			c = tempCell-&gt;c + mask.y;
-    			index = get2dIndex(r, c, wCells);
-    			if(checkGridIndex(index, nCells))
-    			{
-					diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-					if (pCells[index].TestWithCircle(pos, radius))
-						cells_list.push_back(&amp;pCells[index]);
-    			}
-
-    			diagonalCells.pop_back();
-    		}
-
-    		nMaxLevels--;
-    		counter++;
-    		if (nMaxLevels &lt;= 0)
-    			break;
-
-    		straitCells = straitCellsL2;
-    		diagonalCells = diagonalCellsL2;
-
-    	}
-
-    	return counter;
-
-    }
-
-  int GridMap::GetSurroundingMainCells(const POINT2D&amp; pos, vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range)
-  {
-
-	  //calculate the number of levels that satisfy the max range criteria
-	int nMaxLevels = max_range/cell_l;
-
-  	int r, c;
-  	vector&lt;CELL_Info*&gt; nextLevel;
-  	vector&lt;CELL_Info*&gt; currentLevel;
-  	vector&lt;CELL_Info*&gt; tempLevel;
-
-  	CELL_Info* originalGoal = GetCellFromPoint(pos);
-  	if(!originalGoal) return 0;
-
-  	CELL_Info* tempCell;
-
-
-  	currentLevel.push_back(originalGoal);
-  	cells_list.push_back(originalGoal);
-  	int counter = 0;
-  	int index = 0;
-
-  	while (currentLevel.size() &gt; 0 &amp;&amp; nMaxLevels&gt;0)
-  	{
-  		tempCell = currentLevel.back();
-  		currentLevel.pop_back();
-
-  		for (int i = 0; i &lt; 8; i++)
-  		{
-  			counter++;
-  			r = tempCell-&gt;r + delta[i].x;
-  			c = tempCell-&gt;c + delta[i].y;
-  			index = get2dIndex(r,c,wCells);
-
-  			if (r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt; hCells &amp;&amp; c &lt; wCells)
-  			{
-  				//insert unique
-  				bool bFound = false;
-  				for(unsigned int j=0; j&lt; cells_list.size();j++)
-  				{
-  					if(cells_list[j] == &amp;pCells[index])
-  					{
-  						bFound = true;
-  						break;
-  					}
-  				}
-  				if(!bFound)
-  				{
-  					cells_list.push_back(&amp;pCells[index]);
-  					nextLevel.push_back(&amp;pCells[index]);
-  				}
-  			}
-  		}
-
-  		if (currentLevel.size() == 0 &amp;&amp; nextLevel.size() &gt; 0)
-  		{
-  			tempLevel = currentLevel;
-  			currentLevel = nextLevel;
-  			nextLevel = tempLevel;
-  			nMaxLevels--;
-  		}
-  	}
-
-  	return counter;
-
-  }
-
-  void GridMap::SaveMap(const string&amp; mapFilePath, const string&amp; mapName)
-  {
-	  ofstream f(mapFilePath.c_str(),ios::out);
-	  if(!f.is_open())
-	  {
-		  printf("\n Can't Open Map File to Save!, %s", mapFilePath.c_str());
-		  return;
-	  }
-	  f.precision(8);
-
-	  if(nCells&gt;0)
-	  {
-		  int loop_size =  nCells;
-		  int index = 0;
-			while(index != loop_size)
-			{
-				if(pCells[index].nStaticPoints &gt; 0 )
-				{
-					int subindex = 0;
-					int sub_loop_size = pCells[index].nCells;
-					while(subindex != sub_loop_size)
-					{
-						if(pCells[index].pInnerMap[subindex].nStaticPoints &gt; 0)
-						{
-							for(unsigned int p=0; p&lt;pCells[index].pInnerMap[subindex].innerStaticPointsList.size(); p++)
-							{
-								f&lt;&lt;pCells[index].pInnerMap[subindex].innerStaticPointsList[p].x&lt;&lt;","&lt;&lt;pCells[index].pInnerMap[subindex].innerStaticPointsList[p].y&lt;&lt;" ";
-							}
-							f&lt;&lt;endl;
-						}
-
-						subindex++;
-					}
-				}
-
-			index++;
-			}
-	  }
-
-	  f.close();
-
-	  //save Values Map
-//	  string cost_file = mapFilePath + "_cost.grd";
-//	  ofstream f2(cost_file.c_str(),ios::out);
-//  	  f2.precision(8);
-//  	if(nCells&gt;0)
-//	  {
-//		  int loop_size =  nCells;
-//		  int index = 0;
-//			while(index != loop_size)
-//			{
-//				if(pCells[index].nCells&gt;0)
-//				{
-//					if(pCells[index].localize_val&gt;0)
-//					{
-//						f2&lt;&lt;"C,"&lt;&lt;pCells[index].center.p.x&lt;&lt;","&lt;&lt;pCells[index].center.p.y&lt;&lt;","&lt;&lt;pCells[index].localize_val &lt;&lt; " ";
-//						f2&lt;&lt;endl;
-//					}
-//
-//					int subIndex = 0;
-//					while(subIndex != pCells[index].nCells)
-//					{
-//						f2&lt;&lt;"S,"&lt;&lt;pCells[index].pInnerMap[subIndex].center.p.x&lt;&lt;","&lt;&lt;pCells[index].pInnerMap[subIndex].center.p.y&lt;&lt;","&lt;&lt;pCells[index].pInnerMap[subIndex].localize_val &lt;&lt; " ";
-//						subIndex++;
-//					}
-//					f2&lt;&lt;endl;
-//				}
-//
-//				index++;
-//			}
-//	  }
-//
-//  	f2.close();
-
-  }
-
-  void GridMap::LoadMap(const string&amp; mapFilePath, const POINT2D&amp; pos, const double&amp; loadingRadius, const GPSPoint&amp; mapTransformation)
-  {
-
-//	  GPSPoint point;
-//	  ifstream f(mapFilePath.c_str(), ios::in);
-//	  if(!f.is_open())
-//	  {
-//		  printf("\n Can't Open Map File !, %s", mapFilePath.c_str());
-//		  return;
-//	  }
-//
-//	  f.precision(8);
-//	  string token, temp, innerToken;
-//	  string strLine;
-//
-//	while(!f.eof())
-//	{
-//		getline(f, strLine);
-//		istringstream str_stream(strLine);
-//		while(getline(str_stream, innerToken, ' '))
-//		{
-//
-//			string str_x, str_y;
-//
-//			istringstream ss(innerToken);
-//
-//			getline(ss, str_x, ',');
-//			getline(ss, str_y, ',');
-//
-//			point.p.x = atof(str_x.c_str());
-//			point.p.y = atof(str_y.c_str());
-//
-//			MathUtil::CoordinateTransform(point, mapTransformation);
-//
-//			UpdateMapObstaclePoint(point);
-//		}
-//	}
-//
-//	  f.close();
-
-//	  string cost_file = mapFilePath + "_cost.grd";
-//	  ifstream f2(cost_file.c_str(),ios::in);
-//	  f2.precision(8);
-//	  double cost_val = 0;
-//	  while(!f2.eof())
-//	  	{
-//	  		getline(f2, strLine);
-//	  		istringstream str_stream(strLine);
-//
-//	  		while(getline(str_stream, innerToken, ' '))
-//			{
-//				string str_key, str_x, str_y, str_val;
-//				istringstream ss(innerToken);
-//				getline(ss, str_key, ',');
-//				getline(ss, str_x, ',');
-//				getline(ss, str_y, ',');
-//				getline(ss, str_val, ',');
-//
-//				point.x = atof(str_x.c_str());
-//				point.y = atof(str_y.c_str());
-//				cost_val = atof(str_val.c_str());
-//
-//				if(str_key.compare("S")==0)
-//					UpdateSubMapCostValue(point, cost_val, 0);
-//				else
-//					UpdateMapCostValue(point, cost_val, 0);
-//			}
-//
-//	  	}
-//
-//	  f2.close();
-  }
-
-  CELL_Info::CELL_Info()
-    {
-		index = 0;
-		r=0;
-		c=0;
-
-		nCells = 0;
-		pInnerMap = 0;
-		heuristicValue = 0;
-		forwardHeuristic = 0;
-		backwardHeuristic = 0;
-		heuristic = 0;
-		expanded = -1;
-		value = 0;
-		action = -1;
-		forward_heuristicValue = 0;
-		backward_heuristicValue = 0;
-		bDir = STANDSTILL_DIR;
-		closed = false;
-		nMovingPoints = 0;
-		nStaticPoints = 0;
-		localize_val = 0;
-		localize_prob = 0;
-    }
-
-  CELL_Info::~CELL_Info()
-     {
-  //     if(pInnerCells)
-  //       delete [] pInnerCells;
-  	if(pInnerMap)
-  		delete [] pInnerMap;
-     }
-
-  void CELL_Info::ClearSubCells(bool bMovingOnly)
-  {
-  	for(int i=0; i&lt;nCells; i++)
-  	{
-  		if(!bMovingOnly)
-  		{
-  			pInnerMap[i].nStaticPoints = 0;
-  			pInnerMap[i].innerStaticPointsList.clear();
-  		}
-  		pInnerMap[i].nMovingPoints = 0;
-  		pInnerMap[i].innerMovingPointsList.clear();
-  	}
-  }
-
-  void CELL_Info::Clear(int bMovingOnly)
-  {
-  	//forwardCenter = center;
-  	//backwardCenter = center;
-
-  	heuristicValue = 0;
-  	heuristic = 0;
-  	forwardHeuristic  = 0;
-  	backwardHeuristic  = 0;
-  	forward_heuristicValue = 0;
-  	backward_heuristicValue = 0;
-  	expanded = -1;
-  	value = 0;
-  	closed = false;
-  	action = -1;
-  	bDir = STANDSTILL_DIR;
-  	if(bMovingOnly == 1)
-  	{
-  		if(nMovingPoints&gt;0)
-  		{
-  			nMovingPoints = 0;
-  			ClearSubCells(true);
-  		}
-  	}
-  	else if(bMovingOnly == 0)
-  	{
-  		if(nMovingPoints&gt;0 || nStaticPoints&gt;0)
-  		{
-  			nMovingPoints = 0;
-  			nStaticPoints = 0;
-  			ClearSubCells(false);
-  		}
-  	}
-
-  }
-
-  void CELL_Info::InitSubCells(double cell_l, double sub_cell_l)
-  {
-  	nCells = SUBCELL_L*SUBCELL_L;
-  	pInnerMap =  new CELL_Info[nCells];
-  	 POINT2D p;
-  	 int index = 0;
-
-  	 for(int rr=0; rr&lt;SUBCELL_L; rr++)
-  	 {
-  		 for(int cc=0; cc&lt;SUBCELL_L; cc++)
-  		   {
-  			 index = get2dIndex(rr,cc,SUBCELL_L);
-  			 p.x = this-&gt;bottom_left.x +  ((double)cc * sub_cell_l );
-  			 p.y = this-&gt;bottom_left.y + ((double)rr * sub_cell_l );
-  			 pInnerMap[index].Initialize(p, sub_cell_l, rr, cc,true);
-  			 pInnerMap[index].index = index;
-  		   }
-  	 }
-  }
-
-  void CELL_Info::UpdateCostValue(const vector&lt;POINT2D&gt;&amp; ps)
-  {
-  	index = 0;
-  	double cost = 0;
-  	for(unsigned int i=0; i&lt;ps.size() ; i++)
-  	{
-  		cost += sqrt(distance2points(center, ps[i]));
-  	}
-  	if(localize_val==0)
-  		localize_val = cost;
-  	else
-  		localize_val = (localize_val + cost) / 2.0;
-  }
-
-  void CELL_Info::UpdateSubCellCostValue(const vector&lt;POINT2D&gt;&amp; ps, const double&amp; cell_l, const double&amp; sub_cell_l)
-  {
-  	if(!pInnerMap)
-  		InitSubCells(cell_l, sub_cell_l);
-
-  	index = 0;
-  	double cost = 0;
-  	while(index &lt; nCells)
-  	{
-  		//if(pInnerMap[index].localize_val == 0)
-  		{
-  			cost = 0;
-  			for(unsigned int i=0; i&lt;ps.size() ; i++)
-  			{
-  				//cost += abs(ps[i].x - pInnerMap[index].center.p.x) + abs(ps[i].y - pInnerMap[index].center.p.y);//sqrt(MathUtil::Distance(pInnerMap[index].center.p, ps[i]));
-  				cost += sqrt(distance2points(pInnerMap[index].center, ps[i]));
-  			}
-  			if(pInnerMap[index].localize_val == 0)
-  				pInnerMap[index].localize_val = cost;
-  			else
-  				pInnerMap[index].localize_val = (pInnerMap[index].localize_val+cost)/2.0;
-  		}
-  		 index++;
-  	 }
-
-  }
-
-  void CELL_Info::Initialize(POINT2D bottom_l, double cell_l, int row, int col, bool bDefaultEmpty)
-    {
-		double half = cell_l / 2.0;
-		center.x = bottom_l.x + half;
-		center.y = bottom_l.y + half;
-		bottom_left = bottom_l;
-		top_right.x = bottom_left.x + cell_l;
-		top_right.y = bottom_left.y + cell_l;
-		bottom_right.x = top_right.x;
-		bottom_right.y = bottom_left.y;
-		top_left.x = bottom_left.x;
-		top_left.y = top_right.y;
-		nMovingPoints = !bDefaultEmpty;
-		nStaticPoints = !bDefaultEmpty;
-		r = row;
-		c = col;
-    }
-
-bool CELL_Info::operator==(const CELL_Info&amp; cell)
-  {
-	if((this-&gt;r == cell.r &amp;&amp; this-&gt;c == cell.c) || this-&gt;index == cell.index)
-	  return true;
-	else
-	  return false;
-  }
-
-bool CELL_Info::operator!=(const CELL_Info&amp; cell)
-  {
-	if((this-&gt;r != cell.r || this-&gt;c != cell.c) || this-&gt;index != cell.index)
-	  return true;
-	else
-	  return false;
-  }
-
-
-    /*
-     * Check for point to lie in the cell and cell this is an obstacle
-     */
-   inline bool CELL_Info::HitTest(const POINT2D&amp; p)
-    {
-
-  	 bool bHit = PointInRect(p);
-
-  	     if(pInnerMap &amp;&amp; bHit)
-  	       {
-  	         for(int i=0; i&lt;nCells; i++)
-  	           {
-  	             if(pInnerMap[i].PointInRect(p) == true) return true;
-  	           }
-  	       }
-
-  	     return bHit;
-    }
-
-   bool CELL_Info::TestWithRectangle(RECTANGLE&amp; rec)
-   {
-  	 if(!rec.PointInRect(bottom_left))
-  		 return true;
-  	 if(!rec.PointInRect(bottom_right))
-  		 return true;
-  	 if(!rec.PointInRect(top_right))
-  		 return true;
-  	 if(!rec.PointInRect(top_left))
-  		 return true;
-
-  	 return false;
-   }
-
-   bool CELL_Info::TestWithCircle(POINT2D _center, double width)
-   {
-  	 if(distance2points(center, _center) &lt;= width)
-  		 return true;
-  	 else
-  		 return false;
-   }
-   void CELL_Info::SaveCell(ostream&amp; f)
-   {
-  //	 f&lt;&lt;"#CELL_Info:"&lt;&lt;r&lt;&lt;c&lt;&lt;index&lt;nPoints&lt;&lt;bottom_left.x&lt;&lt;bottom_left.y&lt;&lt;top_right.x&lt;&lt;top_right.y;
-  //	 f&lt;&lt;endl;
-  //	 if(pInnerMap)
-  //	 {
-  //		 f&lt;&lt;"#InnerMap:";
-  //		 for(int i=0; i&lt;nCells; i++)
-  //		   {
-  //			 pInnerMap[i].SaveCell(f);
-  //		   }
-  //	 }
-
-   }
-
-   void CELL_Info::LoadCell(ifstream&amp; f)
-   {
-
-   }
-
-}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\HMIStateMachine.cpp" new_path="" added_lines="0" deleted_lines="109">
				<diff>@@ -1,109 +0,0 @@
-/*
- * BehaviorStateMachine.cpp
- *
- *  Created on: Jun 19, 2016
- *      Author: hatem
- */
-
-#include "HMIStateMachine.h"
-#include "UtilityH.h"
-
-using namespace UtilityHNS;
-
-namespace PlannerHNS {
-
-HMIPreCalculatedConditions* HMIStateMachine::m_pCalculatedValues = 0;
-PlanningParams HMIStateMachine::m_PlanningParams;
-
-HMIStateMachine::HMIStateMachine(HMIStateMachine* nextState)
-{
-	m_Behavior = G_WAITING_STATE;
-
-	decisionMakingTime		= 0.0;
-
-	if(nextState)
-		pNextStates.push_back(nextState);
-
-	pNextStates.push_back(this);
-
-	Init();
-}
-
-void HMIStateMachine::InsertNextState(HMIStateMachine* nextState)
-{
-	if(nextState)
-		pNextStates.push_back(nextState);
-}
-
-HMIStateMachine* HMIStateMachine::FindBehaviorState(const GLOBAL_STATE_TYPE&amp; behavior)
-{
-	for(unsigned int i = 0 ; i &lt; pNextStates.size(); i++)
-	{
-		HMIStateMachine* pState = pNextStates.at(i);
-		if(pState &amp;&amp; behavior == pState-&gt;m_Behavior )
-		{
-			pState-&gt;ResetTimer();
-			return pState;
-		}
-	}
-
-	return 0;
-}
-
-void HMIStateMachine::Init()
-{
-	UtilityH::GetTickCount(m_StateTimer);
-}
-
-void HMIStateMachine::ResetTimer()
-{
-	UtilityH::GetTickCount(m_StateTimer);
-}
-
-HMIStateMachine::~HMIStateMachine()
-{
-}
-
-HMIStateMachine* GPlanningState::GetNextState()
-{
-	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
-		return this; //return this behavior only , without reset
-
-	HMIPreCalculatedConditions* pCParams = GetCalcParams();
-
-	return FindBehaviorState(this-&gt;m_Behavior); // return and reset
-}
-
-HMIStateMachine* GWaitingState::GetNextState()
-{
-	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
-		return this; //return this behavior only , without reset
-
-	return FindBehaviorState(this-&gt;m_Behavior); // return and reset
-}
-
-HMIStateMachine* GForwardState::GetNextState()
-{
-	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
-		return this; //return this behavior only , without reset
-
-	return FindBehaviorState(this-&gt;m_Behavior); // return and reset
-}
-
-HMIStateMachine* GBranchingState::GetNextState()
-{
-	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
-		return this; //return this behavior only , without reset
-
-	return FindBehaviorState(this-&gt;m_Behavior); // return and reset
-}
-
-HMIStateMachine* GEndState::GetNextState()
-{
-	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
-		return this; //return this behavior only , without reset
-
-	return FindBehaviorState(this-&gt;m_Behavior); // return and reset
-}
-
-} /* namespace PlannerHNS */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\LocalPlannerH.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\LocalPlannerH.cpp" added_lines="282" deleted_lines="397">
				<diff>@@ -19,6 +19,8 @@ namespace PlannerHNS
 
 LocalPlannerH::LocalPlannerH()
 {
+
+	m_PrevBrakingWayPoint = 0;
 	m_iSafeTrajectory = 0;
 	m_iCurrentTotalPathId = 0;
 	pLane = 0;
@@ -40,6 +42,7 @@ LocalPlannerH::LocalPlannerH()
 	m_SimulationSteeringDelayFactor = 0.1;
 	UtilityH::GetTickCount(m_SteerDelayTimer);
 	m_PredictionTime = 0;
+
 	InitBehaviorStates();
 }
 
@@ -61,6 +64,7 @@ LocalPlannerH::~LocalPlannerH()
 
 void LocalPlannerH::Init(const ControllerParams&amp; ctrlParams, const PlannerHNS::PlanningParams&amp; params,const CAR_BASIC_INFO&amp; carInfo)
  	{
+
  		m_CarInfo = carInfo;
  		m_ControlParams = ctrlParams;
  		m_CurrentVelocity =  m_CurrentVelocityD =0;
@@ -68,9 +72,17 @@ void LocalPlannerH::Init(const ControllerParams&amp; ctrlParams, const PlannerHNS::P
  		m_CurrentShift 		=  m_CurrentShiftD = SHIFT_POS_NN;
  		m_CurrentAccSteerAngle = m_CurrentAccVelocity = 0;
  		m_params = params;
+ 		m_InitialFollowingDistance = m_params.minFollowingDistance;
+
+ 		m_pidVelocity.Init(0.005, 0.005, 0.05);
+		m_pidVelocity.Setlimit(m_params.maxSpeed, 0);
+
+		m_pidStopping.Init(0.1, 0.05, 0.1);
+		m_pidStopping.Setlimit(m_params.horizonDistance, 0);
+
+		if(m_pCurrentBehaviorState)
+			m_pCurrentBehaviorState-&gt;SetBehaviorsParams(&amp;m_params);
 
- 		if(m_pCurrentBehaviorState)
- 			m_pCurrentBehaviorState-&gt;SetBehaviorsParams(&amp;m_params);
  	}
 
 void LocalPlannerH::InitBehaviorStates()
@@ -104,6 +116,12 @@ void LocalPlannerH::InitBehaviorStates()
 	m_pStopSignWaitState-&gt;decisionMakingTime = 5.0;
 	m_pStopSignWaitState-&gt;InsertNextState(m_pStopSignStopState);
 
+	m_pFollowState-&gt;InsertNextState(m_pStopState);
+	m_pFollowState-&gt;InsertNextState(m_pTrafficLightStopState);
+	m_pFollowState-&gt;InsertNextState(m_pStopSignStopState);
+
+	m_pAvoidObstacleState-&gt;decisionMakingTime = 0.1;
+
 	m_pCurrentBehaviorState = m_pInitState;
 }
 
@@ -118,6 +136,35 @@ void LocalPlannerH::InitPolygons()
 	m_CarShapePolygon.push_back(GPSPoint(-w2, l2, 0,0));
 }
 
+void LocalPlannerH::ReInitializePlanner(const WayPoint&amp; start_pose)
+{
+
+	m_pidVelocity.Init(0.005, 0.005, 0.05);
+	m_pidVelocity.Setlimit(m_params.maxSpeed, 0);
+
+	m_pidStopping.Init(0.1, 0.05, 0.1);
+	m_pidStopping.Setlimit(m_params.horizonDistance, 0);
+
+	m_PrevBrakingWayPoint = 0;
+	m_iSafeTrajectory = 0;
+	m_iCurrentTotalPathId = 0;
+	m_CurrentVelocity =  m_CurrentVelocityD =0;
+	m_CurrentSteering = m_CurrentSteeringD =0;
+	m_CurrentShift 		=  m_CurrentShiftD = SHIFT_POS_NN;
+	m_CurrentAccSteerAngle = m_CurrentAccVelocity = 0;
+
+	m_pCurrentBehaviorState = m_pFollowState;
+	m_TotalPath.clear();
+	m_OriginalLocalPath.clear();
+	m_TotalOriginalPath.clear();
+	m_Path.clear();
+	m_RollOuts.clear();
+	m_pCurrentBehaviorState-&gt;m_Behavior = PlannerHNS::FORWARD_STATE;
+	m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl = 1;
+	FirstLocalizeMe(start_pose);
+	LocalizeMe(0);
+}
+
  void LocalPlannerH::FirstLocalizeMe(const WayPoint&amp; initCarPos)
  {
 	pLane = initCarPos.pLane;
@@ -236,7 +283,7 @@ void LocalPlannerH::InitPolygons()
  }
 
  void LocalPlannerH::CalculateImportantParameterForDecisionMaking(const PlannerHNS::VehicleState&amp; car_state,
-		 const int&amp; goalID, const bool&amp; bEmergencyStop, const bool&amp; bGreenTrafficLight,
+		 const int&amp; goalID, const bool&amp; bEmergencyStop, const vector&lt;TrafficLight&gt;&amp; detectedLights,
 		 const TrajectoryCost&amp; bestTrajectory)
  {
  	PreCalculatedConditions* pValues = m_pCurrentBehaviorState-&gt;GetCalcParams();
@@ -244,7 +291,7 @@ void LocalPlannerH::InitPolygons()
  	double critical_long_front_distance =  m_CarInfo.wheel_base/2.0 + m_CarInfo.length/2.0 + m_params.verticalSafetyDistance;
 	//double critical_long_back_distance =  m_CarInfo.length/2.0 + m_params.verticalSafetyDistance - m_CarInfo.wheel_base/2.0;
 
- 	pValues-&gt;minStoppingDistance = -pow(car_state.speed, 2)/m_CarInfo.max_deceleration;
+ 	pValues-&gt;minStoppingDistance = -pow(car_state.speed, 2)/(m_CarInfo.max_deceleration);
 
  	pValues-&gt;iCentralTrajectory		= m_pCurrentBehaviorState-&gt;m_pParams-&gt;rollOutNumber/2;
 
@@ -301,6 +348,7 @@ void LocalPlannerH::InitPolygons()
  	int stopSignID = -1;
  	int trafficLightID = -1;
  	double distanceToClosestStopLine = 0;
+ 	bool bGreenTrafficLight = true;
 
  	if(m_TotalPath.size()&gt;0)
  		distanceToClosestStopLine = PlanningHelpers::GetDistanceToClosestStopLineAndCheck(m_TotalPath.at(pValues-&gt;iCurrSafeLane), state, stopLineID, stopSignID, trafficLightID) - critical_long_front_distance;
@@ -308,13 +356,21 @@ void LocalPlannerH::InitPolygons()
  	if(distanceToClosestStopLine &gt; 0 &amp;&amp; distanceToClosestStopLine &lt; pValues-&gt;minStoppingDistance)
  	{
  		if(m_pCurrentBehaviorState-&gt;m_pParams-&gt;enableTrafficLightBehavior)
+ 		{
  			pValues-&gt;currentTrafficLightID = trafficLightID;
+ 			//cout &lt;&lt; "Detected Traffic Light: " &lt;&lt; trafficLightID &lt;&lt; endl;
+ 			for(unsigned int i=0; i&lt; detectedLights.size(); i++)
+ 			{
+ 				if(detectedLights.at(i).id == trafficLightID)
+ 					bGreenTrafficLight = (detectedLights.at(i).lightState == GREEN_LIGHT);
+ 			}
+ 		}
 
  		if(m_pCurrentBehaviorState-&gt;m_pParams-&gt;enableStopSignBehavior)
  			pValues-&gt;currentStopSignID = stopSignID;
 
 		pValues-&gt;stoppingDistances.push_back(distanceToClosestStopLine);
-		//std::cout &lt;&lt; "From Local Planner =&gt; D: " &lt;&lt; pValues-&gt;distanceToStop() &lt;&lt; ", Prev SignID: " &lt;&lt; pValues-&gt;prevStopSignID &lt;&lt; ", Curr SignID: " &lt;&lt; pValues-&gt;currentStopSignID &lt;&lt; endl;
+		//std::cout &lt;&lt; "LP =&gt; D: " &lt;&lt; pValues-&gt;distanceToStop() &lt;&lt; ", PrevSignID: " &lt;&lt; pValues-&gt;prevTrafficLightID &lt;&lt; ", CurrSignID: " &lt;&lt; pValues-&gt;currentTrafficLightID &lt;&lt; ", Green: " &lt;&lt; bGreenTrafficLight &lt;&lt; endl;
  	}
 
 
@@ -331,250 +387,18 @@ void LocalPlannerH::InitPolygons()
  	//cout &lt;&lt; "Distances: " &lt;&lt; pValues-&gt;stoppingDistances.size() &lt;&lt; ", Distance To Stop : " &lt;&lt; pValues-&gt;distanceToStop &lt;&lt; endl;
  }
 
-double LocalPlannerH::PredictTimeCostForTrajectory(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const PlannerHNS::VehicleState&amp; vstatus, const PlannerHNS::WayPoint&amp; currState)
-{
-	PlanningParams* pParams = m_pCurrentBehaviorState-&gt;m_pParams;
-
-		//1- Calculate time prediction for each trajectory
-	if(path.size() == 0) return 0;
-
-//	SimulatedTrajectoryFollower predControl;
-//	ControllerParams params;
-//	params.Steering_Gain = PID_CONST(1.5, 0.0, 0.0);
-//	params.Velocity_Gain = PID_CONST(0.2, 0.01, 0.1);
-//	params.minPursuiteDistance = 3.0;
-//
-//	predControl.Init(params, m_CarInfo);
-//	//double totalDistance = 0;
-//	VehicleState CurrentState = vstatus;
-//	VehicleState CurrentSteeringD;
-//	bool bNewPath = true;
-//	WayPoint localState = currState;
-//	WayPoint prevState = currState;
-//	int iPrevIndex = 0;
-	double accum_time = 0;
-//	double pred_max_time = 10.0;
-//	double endDistance = pParams-&gt;microPlanDistance/2.0;
-//
-//	for(unsigned int i = 0 ; i &lt; path.size(); i++)
-//	{
-//		path.at(i).collisionCost = 0;
-//		path.at(i).timeCost = -1;
-//	}
-//
-//	int startIndex = PlanningHelpers::GetClosestPointIndex(path, state);
-//	double total_distance = 0;
-//	path.at(startIndex).timeCost = 0;
-//	for(unsigned int i=startIndex+1; i&lt;path.size(); i++)
-//	{
-//		total_distance += hypot(path.at(i).pos.x- path.at(i-1).pos.x,path.at(i).pos.y- path.at(i-1).pos.y);
-//		if(m_CurrentVelocity &gt; 0.1 &amp;&amp; total_distance &gt; 0.1)
-//			accum_time = total_distance/m_CurrentVelocity;
-//		path.at(i).timeCost = accum_time;
-//		if(total_distance &gt; endDistance)
-//			break;
-//	}
-
-//	while(totalDistance &lt; pParams-&gt;microPlanDistance/2.0 &amp;&amp; accum_time &lt; pred_max_time)
-//	{
-//		double dt = 0.05;
-//		PlannerHNS::BehaviorState currMessage;
-//		currMessage.state = FORWARD_STATE;
-//		currMessage.maxVelocity = PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, 1.5*CurrentState.speed*3.6);
-//
-//		ControllerParams c_params = m_ControlParams;
-//		c_params.SteeringDelay = m_ControlParams.SteeringDelay / (1.0-UtilityH::GetMomentumScaleFactor(CurrentState.speed));
-//		predControl.Init(c_params, m_CarInfo);
-//		CurrentSteeringD = predControl.DoOneStep(dt, currMessage, path, localState, CurrentState, bNewPath);
-//
-//		if(bNewPath) // first call
-//		{
-//			if(predControl.m_iCalculatedIndex &gt; 0)
-//			{
-//				for(unsigned int j=0; j &lt; predControl.m_iCalculatedIndex; j++)
-//					path.at(j).timeCost = -1;
-//			}
-//		}
-//		else
-//		{
-//			if(predControl.m_iCalculatedIndex != iPrevIndex)
-//				path.at(iPrevIndex).timeCost = accum_time;
-//		}
-//
-//		accum_time+=dt;
-//		bNewPath = false;
-//
-//		//Update State
-//		CurrentState = CurrentSteeringD;
-//
-//		//Localize Me
-//		localState.pos.x	 +=  CurrentState.speed * dt * cos(localState.pos.a);
-//		localState.pos.y	 +=  CurrentState.speed * dt * sin(localState.pos.a);
-//		localState.pos.a	 +=  CurrentState.speed * dt * tan(CurrentState.steer)  / m_CarInfo.wheel_base;
-//
-//		totalDistance += distance2points(prevState.pos, localState.pos);
-//
-//		prevState = localState;
-//		iPrevIndex = predControl.m_iCalculatedIndex;
-//	}
-
-	return accum_time;
-}
-
-void LocalPlannerH::PredictObstacleTrajectory(PlannerHNS::RoadNetwork&amp; map, const PlannerHNS::WayPoint&amp; pos, const double&amp; predTime, std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; paths)
-{
-	PlannerHNS::PlanningParams planningDefaultParams;
-	planningDefaultParams.rollOutNumber = 0;
-	planningDefaultParams.microPlanDistance = predTime*pos.v;
-
-	planningDefaultParams.pathDensity = 0.5;
-	//PlannerHNS::Lane* pMapLane  = MappingHelpers::GetClosestLaneFromMapDirectionBased(pos, map, 3.0);
-	std::vector&lt;PlannerHNS::Lane*&gt; pMapLanes = MappingHelpers::GetClosestMultipleLanesFromMap(pos, map, 1.5);
-
-	PlannerHNS::PlannerH planner;
-	std::vector&lt;int&gt; LanesIds;
-	std::vector&lt; std::vector&lt;PlannerHNS::WayPoint&gt; &gt;  rollOuts;
-	std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; generatedPath;
-
-	if(planningDefaultParams.microPlanDistance &gt; 0)
-	{
-		for(unsigned int i = 0; i &lt; pMapLanes.size(); i++)
-		{
-			std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; loca_generatedPath;
-			planner.PredictPlanUsingDP(pMapLanes.at(i), pos, planningDefaultParams.microPlanDistance, loca_generatedPath);
-			if(loca_generatedPath.size() &gt; 0)
-				generatedPath.insert(generatedPath.begin(),loca_generatedPath.begin(), loca_generatedPath.end());
-		}
-	}
-
-//	planner.GenerateRunoffTrajectory(generatedPath, pos,
-//			planningDefaultParams.enableLaneChange,
-//			pos.v,
-//			planningDefaultParams.microPlanDistance,
-//			m_CarInfo.max_speed_forward,
-//			planningDefaultParams.minSpeed,
-//			planningDefaultParams.carTipMargin,
-//			planningDefaultParams.rollInMargin,
-//			planningDefaultParams.rollInSpeedFactor,
-//			planningDefaultParams.pathDensity,
-//			planningDefaultParams.rollOutDensity,
-//			planningDefaultParams.rollOutNumber,
-//			planningDefaultParams.smoothingDataWeight,
-//			planningDefaultParams.smoothingSmoothWeight,
-//			planningDefaultParams.smoothingToleranceError,
-//			planningDefaultParams.speedProfileFactor,
-//			planningDefaultParams.enableHeadingSmoothing,
-//			rollOuts);
-
-	if(generatedPath.size() &gt; 0)
-	{
-		//path = rollOuts.at(0);
-		paths = generatedPath;
-
-//		PlanningHelpers::GenerateRecommendedSpeed(path,
-//				m_CarInfo.max_speed_forward,
-//				planningDefaultParams.speedProfileFactor);
-//		PlanningHelpers::SmoothSpeedProfiles(path, 0.15,0.35, 0.1);
-	}
-
-	if(pMapLanes.size() ==0 || paths.size() == 0)
-	{
-		paths.clear();
-		generatedPath.clear();
-	}
-	else
-	{
-		//std::cout &lt;&lt; "------------------------------------------------" &lt;&lt;  std::endl;
-		//std::cout &lt;&lt; "Predicted Trajectories for Distance : " &lt;&lt;  planningDefaultParams.microPlanDistance &lt;&lt; std::endl;
-		for(unsigned int j=0; j &lt; paths.size(); j++)
-		{
-			if(paths.at(j).size()==0)
-				continue;
-
-			double timeDelay = 0;
-			double total_distance = 0;
-			paths.at(j).at(0).timeCost = 0;
-			paths.at(j).at(0).v = pos.v;
-			for(unsigned int i=1; i&lt;paths.at(j).size(); i++)
-			{
-				paths.at(j).at(i).v = pos.v;
-				paths.at(j).at(i).pos.a = atan2(paths.at(j).at(i).pos.y - paths.at(j).at(i-1).pos.y, paths.at(j).at(i).pos.x - paths.at(j).at(i-1).pos.x);
-				total_distance += distance2points(paths.at(j).at(i).pos, paths.at(j).at(i-1).pos);
-				if(pos.v &gt; 0.1 &amp;&amp; total_distance &gt; 0.1)
-					timeDelay = total_distance/pos.v;
-				paths.at(j).at(i).timeCost = timeDelay;
-			}
-
-			//std::cout &lt;&lt; "ID : " &lt;&lt;  j &lt;&lt; ", timeDelay : " &lt;&lt; timeDelay &lt;&lt; ", Distance : " &lt;&lt; total_distance &lt;&lt; std::endl;
-		}
-
-		//std::cout &lt;&lt; "------------------------------------------------" &lt;&lt;  std::endl;
-	}
-}
-
-bool LocalPlannerH::CalculateIntersectionVelocities(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; ego_path, std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; predctedPath, const PlannerHNS::DetectedObject&amp; obj)
-{
-	bool bCollisionDetected = false;
-	for(unsigned int k = 0; k &lt; predctedPath.size(); k++)
-	{
-		for(unsigned int j = 0; j &lt; predctedPath.at(k).size(); j++)
-		{
-			bool bCollisionFound =false;
-			for(unsigned int i = 0; i &lt; ego_path.size(); i++)
-			{
-				if(ego_path.at(i).timeCost &gt; 0.0)
-				{
-					double collision_distance = hypot(ego_path.at(i).pos.x-predctedPath.at(k).at(j).pos.x, ego_path.at(i).pos.y-predctedPath.at(k).at(j).pos.y);
-					double contact_distance = hypot(state.pos.x - ego_path.at(i).pos.x,state.pos.y - ego_path.at(i).pos.y);
-					if(collision_distance &lt;= m_CarInfo.width  &amp;&amp; fabs(ego_path.at(i).timeCost - predctedPath.at(k).at(j).timeCost)&lt;4.0)
-					{
-						ego_path.at(i).collisionCost = 1;
-						double a = UtilityH::AngleBetweenTwoAnglesPositive(ego_path.at(i).pos.a, predctedPath.at(k).at(j).pos.a);
-						if(a &lt; M_PI_4/2.0)
-							ego_path.at(i).v = obj.center.v;
-						else
-							ego_path.at(i).v = 0;
-						predctedPath.at(k).at(j).collisionCost = 1;
-						bCollisionFound = true;
-						bCollisionDetected = true;
-						break;
-					}
-				}
-			}
-
-			if(bCollisionFound)
-				break;
-		}
-	}
-
-	return bCollisionDetected;
-}
-
-bool LocalPlannerH::CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const PlannerHNS::VehicleState&amp; vstatus, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list)
-{
-	double predTime = PredictTimeCostForTrajectory(m_Path, vstatus, state);
-	m_PredictedPath.clear();
-	bool bObstacleDetected = false;
-	for(unsigned int i = 0; i &lt; obj_list.size(); i++)
-	{
-		//std::vector&lt;WayPoint&gt; predPath;
-		PredictObstacleTrajectory(map, obj_list.at(i).center, 10.0, m_PredictedPath);
-		bool bObstacle = CalculateIntersectionVelocities(m_Path, m_PredictedPath, obj_list.at(i));
-		if(bObstacle)
-			bObstacleDetected = true;
-	}
-
-	return bObstacleDetected;
-}
-
  void LocalPlannerH::UpdateCurrentLane(PlannerHNS::RoadNetwork&amp; map, const double&amp; search_distance)
  {
 	 PlannerHNS::Lane* pMapLane = 0;
 	PlannerHNS::Lane* pPathLane = 0;
 	pPathLane = MappingHelpers::GetLaneFromPath(state, m_Path);
 	if(!pPathLane)
+	{
+		cout &lt;&lt; "Performance Alert: Can't Find Lane Information in Global Path, Searching the Map :( " &lt;&lt; endl;
 		pMapLane  = MappingHelpers::GetClosestLaneFromMap(state, map, search_distance);
 
+	}
+
 	if(pPathLane)
 		pLane = pPathLane;
 	else if(pMapLane)
@@ -586,7 +410,7 @@ bool LocalPlannerH::CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const P
  void LocalPlannerH::SimulateOdoPosition(const double&amp; dt, const PlannerHNS::VehicleState&amp; vehicleState)
  {
 	SetSimulatedTargetOdometryReadings(vehicleState.speed, vehicleState.steer, vehicleState.shift);
-	UpdateState(vehicleState, true);
+	UpdateState(vehicleState, false);
 	LocalizeMe(dt);
  }
 
@@ -616,7 +440,7 @@ bool LocalPlannerH::CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const P
 
 	if(m_TotalPath.size()&gt;0)
 	{
-		int currIndex = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(m_Path, state);
+		int currIndex = PlannerHNS::PlanningHelpers::GetClosestNextPointIndexFast(m_Path, state);
 		int index_limit = 0;//m_Path.size() - 20;
 		if(index_limit&lt;=0)
 			index_limit =  m_Path.size()/2.0;
@@ -645,13 +469,11 @@ bool LocalPlannerH::CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const P
 					m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor,
 					m_pCurrentBehaviorState-&gt;m_pParams-&gt;enableHeadingSmoothing,
 					preCalcPrams-&gt;iCurrSafeLane , preCalcPrams-&gt;iCurrSafeTrajectory,
-					m_RollOuts, m_PathSection, m_SampledPoints);
+					m_RollOuts, m_SampledPoints);
 
 			m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bRePlan = false;
 			m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bNewGlobalPath = false;
 
-			//cout &lt;&lt; "Generating New Trajectories ! iPrev: " &lt;&lt; preCalcPrams-&gt;iPrevSafeTrajectory &lt;&lt; " , iSafe: " &lt;&lt; preCalcPrams-&gt;iCurrSafeTrajectory &lt;&lt; endl;
-
 			if(m_pCurrentBehaviorState-&gt;m_Behavior == OBSTACLE_AVOIDANCE_STATE)
 				preCalcPrams-&gt;iPrevSafeTrajectory = preCalcPrams-&gt;iCurrSafeTrajectory;
 			else
@@ -660,16 +482,12 @@ bool LocalPlannerH::CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const P
 			preCalcPrams-&gt;iPrevSafeLane = preCalcPrams-&gt;iCurrSafeLane;
 
 			if(preCalcPrams-&gt;iPrevSafeLane &gt;= 0
-					&amp;&amp; preCalcPrams-&gt;iPrevSafeLane &lt; m_RollOuts.size()
+					&amp;&amp; preCalcPrams-&gt;iPrevSafeLane &lt; (int)m_RollOuts.size()
 					&amp;&amp; preCalcPrams-&gt;iPrevSafeTrajectory &gt;= 0
-					&amp;&amp; preCalcPrams-&gt;iPrevSafeTrajectory &lt; m_RollOuts.at(preCalcPrams-&gt;iPrevSafeLane).size())
+					&amp;&amp; preCalcPrams-&gt;iPrevSafeTrajectory &lt; (int)m_RollOuts.at(preCalcPrams-&gt;iPrevSafeLane).size())
 			{
-				//cout &lt;&lt; "Select New Trajectories ! iPrev: " &lt;&lt; preCalcPrams-&gt;iPrevSafeTrajectory &lt;&lt; " , iSafe: " &lt;&lt; preCalcPrams-&gt;iCurrSafeTrajectory &lt;&lt; endl;
-
 				m_Path = m_RollOuts.at(preCalcPrams-&gt;iPrevSafeLane).at(preCalcPrams-&gt;iPrevSafeTrajectory);
-//				PlanningHelpers::GenerateRecommendedSpeed(m_Path,
-//						m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed,
-//						m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);
+				m_OriginalLocalPath = m_TotalPath.at(m_iCurrentTotalPathId);
 				bNewTrajectory = true;
 			}
 		}
@@ -686,10 +504,7 @@ bool LocalPlannerH::CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const P
 	PlannerHNS::BehaviorState currentBehavior;
 
 	currentBehavior.state = m_pCurrentBehaviorState-&gt;m_Behavior;
-	//if(currentBehavior.state == PlannerHNS::FOLLOW_STATE)
-		currentBehavior.followDistance = preCalcPrams-&gt;distanceToNext;
-	//else
-	//	currentBehavior.followDistance = 0;
+	currentBehavior.followDistance = preCalcPrams-&gt;distanceToNext;
 
 	if(preCalcPrams-&gt;bUpcomingRight)
 		currentBehavior.indicator = PlannerHNS::INDICATOR_RIGHT;
@@ -697,7 +512,7 @@ bool LocalPlannerH::CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const P
 		currentBehavior.indicator = PlannerHNS::INDICATOR_LEFT;
 	else
 		currentBehavior.indicator = PlannerHNS::INDICATOR_NONE;
-	currentBehavior.maxVelocity 	= PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, vehicleState.speed*3.6);
+
 	currentBehavior.minVelocity		= 0;
 	currentBehavior.stopDistance 	= preCalcPrams-&gt;distanceToStop();
 	currentBehavior.followVelocity 	= preCalcPrams-&gt;velocityOfNext;
@@ -705,145 +520,237 @@ bool LocalPlannerH::CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const P
 	return currentBehavior;
  }
 
- void LocalPlannerH::UpdateVelocityDirectlyToTrajectory(const BehaviorState&amp; beh, const VehicleState&amp; CurrStatus, const double&amp; dt)
+// double LocalPlannerH::UpdateVelocityDirectlyToTrajectory(const BehaviorState&amp; beh, const VehicleState&amp; CurrStatus, const double&amp; dt)
+// {
+//	RelativeInfo info, total_info;
+//	PlanningHelpers::GetRelativeInfo(m_TotalPath.at(m_iCurrentTotalPathId), state, total_info);
+//	PlanningHelpers::GetRelativeInfo(m_Path, state, info);
+//	double average_braking_distance = -pow(CurrStatus.speed, 2)/(m_CarInfo.max_deceleration);
+//	double max_velocity	= PlannerHNS::PlanningHelpers::GetVelocityAhead(m_TotalPath.at(m_iCurrentTotalPathId), total_info, average_braking_distance);
+//
+//	unsigned int point_index = 0;
+//	double critical_long_front_distance = 2.0;
+//
+//	if(m_Path.size() &lt;= 5)
+//	{
+//		double target_velocity = 0;
+//		for(unsigned int i = 0; i &lt; m_Path.size(); i++)
+//			m_Path.at(i).v = target_velocity;
+//	}
+//	else if(beh.state == TRAFFIC_LIGHT_STOP_STATE || beh.state == STOP_SIGN_STOP_STATE || beh.state == STOP_SIGN_WAIT_STATE || beh.state == TRAFFIC_LIGHT_WAIT_STATE)
+//	{
+//		PlanningHelpers::GetFollowPointOnTrajectory(m_Path, info, beh.stopDistance - critical_long_front_distance, point_index);
+//
+//		double inc = CurrStatus.speed;
+//		int iRange = point_index - info.iBack;
+//		if(iRange &gt; 0)
+//			inc = inc / (double)iRange;
+//		else
+//			inc = 0;
+//
+//		double target_velocity = CurrStatus.speed - inc;
+//		for(unsigned int i =  info.iBack; i &lt; point_index; i++)
+//		{
+//			 if(i &lt; m_Path.size() &amp;&amp; i &gt;= 0)
+//				 m_Path.at(i).v = target_velocity;
+//			 target_velocity -= inc;
+//		}
+//	}
+//	else if(beh.state == FOLLOW_STATE)
+//	{
+//		double targe_acceleration = -pow(CurrStatus.speed, 2)/(2.0*(beh.followDistance - critical_long_front_distance));
+//		if(targe_acceleration &lt;= 0 &amp;&amp;  targe_acceleration &gt; m_CarInfo.max_deceleration/2.0)
+//		{
+//			double target_velocity = (targe_acceleration * dt) + CurrStatus.speed;
+//			for(unsigned int i = 0; i &lt; m_Path.size(); i++)
+//			{
+//				if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory == m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
+//					m_Path.at(i).v = target_velocity;
+//				else
+//					m_Path.at(i).v = target_velocity*AVOIDANCE_SPEED_FACTOR;
+//			}
+//
+//			//cout &lt;&lt; "Accelerate -&gt; Target V: " &lt;&lt; target_velocity &lt;&lt; ", Brake D: " &lt;&lt;  average_braking_distance &lt;&lt; ", Acceleration: " &lt;&lt; targe_acceleration &lt;&lt; endl;
+//		}
+//		else
+//		{
+//			WayPoint pursuite_point = PlanningHelpers::GetFollowPointOnTrajectory(m_Path, info, beh.followDistance - critical_long_front_distance, point_index);
+//			double inc = CurrStatus.speed;
+//			int iRange = point_index - info.iBack;
+//
+//			if(iRange &gt; 0)
+//				inc = inc / (double)iRange;
+//			else
+//				inc = 0;
+//
+//			double target_velocity = CurrStatus.speed - inc;
+//			for(unsigned int i =  info.iBack; i &lt; point_index; i++)
+//			{
+//				 if(i &lt; m_Path.size() &amp;&amp; i &gt;= 0)
+//				 {
+//					 target_velocity = target_velocity &lt; 0 ? 0 : target_velocity;
+//					 if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory == m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
+//						 m_Path.at(i).v = target_velocity;
+//					 else
+//						 m_Path.at(i).v = target_velocity*AVOIDANCE_SPEED_FACTOR;
+//				 }
+//
+//				 target_velocity -= inc;
+//			}
+//
+//			//cout &lt;&lt; "Decelerate -&gt; Target V: " &lt;&lt; target_velocity &lt;&lt; ", Brake D: " &lt;&lt;  average_braking_distance &lt;&lt; ", Start I" &lt;&lt; info.iBack &lt;&lt; endl;
+//		}
+//
+//	}
+//	else if(beh.state == FORWARD_STATE || beh.state == OBSTACLE_AVOIDANCE_STATE )
+//	{
+//		double target_velocity = max_velocity;
+//
+//		for(unsigned int i = 0; i &lt; m_Path.size(); i++)
+//		{
+//			if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory == m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
+//				m_Path.at(i).v = target_velocity;
+//			else
+//				m_Path.at(i).v = target_velocity*AVOIDANCE_SPEED_FACTOR;
+//		}
+//	}
+//	else
+//	{
+//		double target_velocity = 0;
+//		for(unsigned int i = 0; i &lt; m_Path.size(); i++)
+//			m_Path.at(i).v = target_velocity;
+//	}
+//
+//	return max_velocity;
+// }
+
+ double LocalPlannerH::UpdateVelocityDirectlyToTrajectory(const BehaviorState&amp; beh, const VehicleState&amp; CurrStatus, const double&amp; dt)
  {
+	if(m_TotalOriginalPath.size() ==0 ) return 0;
 
-	 RelativeInfo info;
+	RelativeInfo info, total_info;
+	PlanningHelpers::GetRelativeInfo(m_TotalOriginalPath.at(m_iCurrentTotalPathId), state, total_info);
 	PlanningHelpers::GetRelativeInfo(m_Path, state, info);
+	double average_braking_distance = -pow(CurrStatus.speed, 2)/(m_CarInfo.max_deceleration) + m_params.additionalBrakingDistance;
+	double max_velocity	= PlannerHNS::PlanningHelpers::GetVelocityAhead(m_TotalOriginalPath.at(m_iCurrentTotalPathId), total_info, m_PrevBrakingWayPoint, average_braking_distance);
+
 	unsigned int point_index = 0;
 	double critical_long_front_distance = 2.0;
-	for(unsigned int i = 0; i &lt; m_Path.size(); i++)
-		m_Path.at(i).v = m_CarInfo.min_speed_forward;
 
-	if(beh.state == TRAFFIC_LIGHT_STOP_STATE || beh.state == STOP_SIGN_STOP_STATE)
+	if(m_Path.size() &lt;= 5)
+	{
+		double target_velocity = 0;
+		for(unsigned int i = 0; i &lt; m_Path.size(); i++)
+			m_Path.at(i).v = target_velocity;
+	}
+	else if(beh.state == TRAFFIC_LIGHT_STOP_STATE || beh.state == STOP_SIGN_STOP_STATE || beh.state == STOP_SIGN_WAIT_STATE || beh.state == TRAFFIC_LIGHT_WAIT_STATE)
 	{
 		PlanningHelpers::GetFollowPointOnTrajectory(m_Path, info, beh.stopDistance - critical_long_front_distance, point_index);
 
-		double inc = CurrStatus.speed;
-		int iRange = point_index - info.iBack;
-		//cout &lt;&lt; "Range : " &lt;&lt; iRange;
-		if(iRange &gt; 0)
-			inc = inc / (double)iRange;
-		else
-			inc = 0;
+		double e = -beh.stopDistance;
+		double desiredVelocity = m_pidStopping.getPID(e);
 
-	//	cout &lt;&lt; "Target Stopping Velocity: "  &lt;&lt;  endl ;
-		double target_velocity = CurrStatus.speed - inc;
 		for(unsigned int i =  info.iBack; i &lt; point_index; i++)
 		{
-			if(target_velocity &gt; m_CarInfo.max_speed_forward)
-				target_velocity = m_CarInfo.max_speed_forward;
-
-			if(target_velocity &lt; m_CarInfo.min_speed_forward)
-				target_velocity = m_CarInfo.min_speed_forward;
-
 			 if(i &lt; m_Path.size() &amp;&amp; i &gt;= 0)
-			 {
-			//	 cout &lt;&lt; target_velocity &lt;&lt; ", " ;
-				 m_Path.at(i).v = target_velocity;
-			 }
-
-			 target_velocity -= inc;
+				 m_Path.at(i).v = desiredVelocity;
 		}
 
-		//cout &lt;&lt; endl &lt;&lt; endl;
+		return desiredVelocity;
 	}
 	else if(beh.state == FOLLOW_STATE)
 	{
 		double targe_acceleration = -pow(CurrStatus.speed, 2)/(2.0*(beh.followDistance - critical_long_front_distance));
 		if(targe_acceleration &lt;= 0 &amp;&amp;  targe_acceleration &gt; m_CarInfo.max_deceleration/2.0)
 		{
-			PlanningHelpers::GenerateRecommendedSpeed(m_Path, m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed, m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);
-
-			double follow_distance = fabs(CurrStatus.speed) * (m_ControlParams.SteeringDelay+1);
-			if(follow_distance &lt; m_ControlParams.minPursuiteDistance)
-				follow_distance = m_ControlParams.minPursuiteDistance;
+			double target_velocity = (targe_acceleration * dt) + CurrStatus.speed;
 
-			RelativeInfo info;
-			PlanningHelpers::GetRelativeInfo(m_Path, state, info);
-			unsigned int point_index = 0;
-			WayPoint pursuite_point = PlanningHelpers::GetFollowPointOnTrajectory(m_Path, info, follow_distance, point_index);
-			double target_velocity = pursuite_point.v;
-			if(target_velocity &gt; m_CarInfo.max_speed_forward)
-				target_velocity = m_CarInfo.max_speed_forward;
+			double e = target_velocity - CurrStatus.speed;
+			double desiredVelocity = m_pidVelocity.getPID(e);
 
-
-			for(unsigned int i = 0; i &lt; m_Path.size(); i++)
+			for(unsigned int i = info.iBack; i &lt; m_Path.size(); i++)
 			{
-				if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory == m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
-					m_Path.at(i).v = target_velocity;
-				else
-					m_Path.at(i).v = target_velocity*0.75;
+				if(i &lt; m_Path.size() &amp;&amp; i &gt;= 0)
+					m_Path.at(i).v = desiredVelocity;
 			}
+
+			return desiredVelocity;
+			//cout &lt;&lt; "Accelerate -&gt; Target V: " &lt;&lt; target_velocity &lt;&lt; ", Brake D: " &lt;&lt;  average_braking_distance &lt;&lt; ", Acceleration: " &lt;&lt; targe_acceleration &lt;&lt; endl;
 		}
 		else
 		{
-			PlanningHelpers::GenerateRecommendedSpeed(m_Path, m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed, m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);
-
 			WayPoint pursuite_point = PlanningHelpers::GetFollowPointOnTrajectory(m_Path, info, beh.followDistance - critical_long_front_distance, point_index);
 
-			double inc = CurrStatus.speed;
-			int iRange = point_index - info.iBack;
-			//cout &lt;&lt; "Range : " &lt;&lt; iRange;
-			if(iRange &gt; 0)
-				inc = inc / (double)iRange;
-			else
-				inc = 0;
+			double e = beh.followDistance - m_params.minFollowingDistance;
+			double desiredVelocity = m_pidStopping.getPID(e);
 
-			//cout &lt;&lt; "Target Follow Velocity: " &lt;&lt;  endl ;
-			double target_velocity = CurrStatus.speed - inc;
 			for(unsigned int i =  info.iBack; i &lt; point_index; i++)
 			{
-				if(target_velocity &gt; m_CarInfo.max_speed_forward)
-					target_velocity = m_CarInfo.max_speed_forward;
-
-				if(target_velocity &lt; m_CarInfo.min_speed_forward)
-					target_velocity = m_CarInfo.min_speed_forward;
-
-				 if(i &lt; m_Path.size() &amp;&amp; i &gt;= 0)
-				 {
-				//	 cout &lt;&lt; target_velocity &lt;&lt; ", " ;
-					 if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory == m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
-						 m_Path.at(i).v = target_velocity;
-					 else
-						 m_Path.at(i).v = target_velocity*0.75;
-				 }
-
-				 target_velocity -= inc;
+				if(i &lt; m_Path.size() &amp;&amp; i &gt;= 0)
+					m_Path.at(i).v = desiredVelocity;
 			}
+
+			return desiredVelocity;
+			//cout &lt;&lt; "Decelerate -&gt; Target V: " &lt;&lt; target_velocity &lt;&lt; ", Brake D: " &lt;&lt;  average_braking_distance &lt;&lt; ", Start I" &lt;&lt; info.iBack &lt;&lt; endl;
 		}
+
 	}
 	else if(beh.state == FORWARD_STATE || beh.state == OBSTACLE_AVOIDANCE_STATE )
 	{
-		PlanningHelpers::GenerateRecommendedSpeed(m_Path, m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed, m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);
+		double target_velocity = max_velocity;
+		if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory != m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
+			target_velocity*=AVOIDANCE_SPEED_FACTOR;
 
-		double follow_distance = fabs(CurrStatus.speed) * (m_ControlParams.SteeringDelay+1);
-		if(follow_distance &lt; m_ControlParams.minPursuiteDistance)
-			follow_distance = m_ControlParams.minPursuiteDistance;
+		double e = target_velocity - CurrStatus.speed;
+		double desiredVelocity = m_pidVelocity.getPID(e);
 
-		RelativeInfo info;
-		PlanningHelpers::GetRelativeInfo(m_Path, state, info);
-		unsigned int point_index = 0;
-		WayPoint pursuite_point = PlanningHelpers::GetFollowPointOnTrajectory(m_Path, info, follow_distance, point_index);
-		double target_velocity = pursuite_point.v;
-		if(target_velocity &gt; m_CarInfo.max_speed_forward)
-			target_velocity = m_CarInfo.max_speed_forward;
-
-		for(unsigned int i = 0; i &lt; m_Path.size(); i++)
+		for(unsigned int i = info.iBack; i &lt; m_Path.size(); i++)
 		{
-			if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory == m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
-				m_Path.at(i).v = target_velocity;
-			else
-				m_Path.at(i).v = target_velocity*0.75;
-
+			m_Path.at(i).v = desiredVelocity;
 		}
+
+		return desiredVelocity;
 	}
 	else
 	{
 		double target_velocity = 0;
-		for(unsigned int i = 0; i &lt; m_Path.size(); i++)
+		for(unsigned int i = info.iBack; i &lt; m_Path.size(); i++)
 			m_Path.at(i).v = target_velocity;
+
+		return target_velocity;
 	}
+
+	return max_velocity;
+ }
+
+ void LocalPlannerH::ExtractHorizonAndCalculateRecommendedSpeed()
+ {
+	 if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bNewGlobalPath &amp;&amp; m_TotalOriginalPath.size() &gt; 0)
+		{
+		 	m_PrevBrakingWayPoint = 0;
+		 	PlanningHelpers::FixPathDensity(m_TotalOriginalPath.at(m_iCurrentTotalPathId), m_pCurrentBehaviorState-&gt;m_pParams-&gt;pathDensity);
+		 	PlanningHelpers::SmoothPath(m_TotalOriginalPath.at(m_iCurrentTotalPathId), 0.49, 0.25, 0.05);
+		 	
+			PlanningHelpers::GenerateRecommendedSpeed(m_TotalOriginalPath.at(m_iCurrentTotalPathId), m_CarInfo.max_speed_forward, m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);
+			m_TotalOriginalPath.at(m_iCurrentTotalPathId).at(m_TotalOriginalPath.at(m_iCurrentTotalPathId).size()-1).v = 0;
+
+		}
+
+		 m_TotalPath.clear();
+
+		 for(unsigned int i = 0; i &lt; m_TotalOriginalPath.size(); i++)
+		{
+			vector&lt;WayPoint&gt; centerTrajectorySmoothed;
+			PlanningHelpers::ExtractPartFromPointToDistanceFast(m_TotalOriginalPath.at(i), state,
+					m_pCurrentBehaviorState-&gt;m_pParams-&gt;horizonDistance ,
+					m_pCurrentBehaviorState-&gt;m_pParams-&gt;pathDensity ,
+					centerTrajectorySmoothed,
+					m_pCurrentBehaviorState-&gt;m_pParams-&gt;smoothingDataWeight,
+					m_pCurrentBehaviorState-&gt;m_pParams-&gt;smoothingSmoothWeight,
+					m_pCurrentBehaviorState-&gt;m_pParams-&gt;smoothingToleranceError);
+
+			m_TotalPath.push_back(centerTrajectorySmoothed);
+		}
  }
 
  PlannerHNS::BehaviorState LocalPlannerH::DoOneStep(
@@ -852,73 +759,51 @@ bool LocalPlannerH::CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const P
 		const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list,
 		const int&amp; goalID, PlannerHNS::RoadNetwork&amp; map	,
 		const bool&amp; bEmergencyStop,
-		const bool&amp; bGreenTrafficLight,
+		const std::vector&lt;TrafficLight&gt;&amp; trafficLight,
 		const bool&amp; bLive)
 {
 
+	 m_params.minFollowingDistance = m_InitialFollowingDistance + vehicleState.speed*1.5;
+
 	 if(!bLive)
 		 SimulateOdoPosition(dt, vehicleState);
 
 	UpdateCurrentLane(map, 3.0);
 
-	timespec costTimer;
-	UtilityH::GetTickCount(costTimer);
+
+	ExtractHorizonAndCalculateRecommendedSpeed();
+
+
+	m_PredictedTrajectoryObstacles = obj_list;
+	//m_TrajectoryPredictionForMovingObstacles.DoOneStep(map, vehicleState, state, m_TotalPath.at(m_iCurrentTotalPathId), m_PredictedTrajectoryObstacles, m_params.minFollowingDistance);
+
+	timespec t;
+	UtilityH::GetTickCount(t);
 	TrajectoryCost tc = m_TrajectoryCostsCalculatotor.DoOneStep(m_RollOuts, m_TotalPath, state,
 			m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory, m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeLane, *m_pCurrentBehaviorState-&gt;m_pParams,
-			m_CarInfo,vehicleState, obj_list);
-	m_CostCalculationTime = UtilityH::GetTimeDiffNow(costTimer);
+			m_CarInfo,vehicleState, m_PredictedTrajectoryObstacles);
+	m_CostCalculationTime = UtilityH::GetTimeDiffNow(t);
+
+
+
+
+	UtilityH::GetTickCount(t);
+	CalculateImportantParameterForDecisionMaking(vehicleState, goalID, bEmergencyStop, trafficLight, tc);
 
 
-	timespec behTimer;
-	UtilityH::GetTickCount(behTimer);
-	CalculateImportantParameterForDecisionMaking(vehicleState, goalID, bEmergencyStop, bGreenTrafficLight, tc);
 
 	PlannerHNS::BehaviorState beh = GenerateBehaviorState(vehicleState);
-	m_BehaviorGenTime = UtilityH::GetTimeDiffNow(behTimer);
+	m_BehaviorGenTime = UtilityH::GetTimeDiffNow(t);
+
 
-	timespec t;
 	UtilityH::GetTickCount(t);
 	beh.bNewPlan = SelectSafeTrajectoryAndSpeedProfile(vehicleState);
-	m_RollOutsGenerationTime = UtilityH::GetTimeDiffNow(t);
 
-	if(m_pCurrentBehaviorState-&gt;m_pParams-&gt;enabTrajectoryVelocities)
-	{
-		UpdateVelocityDirectlyToTrajectory(beh, vehicleState, dt);
-	}
-	else if(beh.bNewPlan == true)
-	{
-		if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory == m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
-			PlanningHelpers::GenerateRecommendedSpeed(m_Path, m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed, m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);
-		else
-			PlanningHelpers::GenerateRecommendedSpeed(m_Path, m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed*0.25, m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);
-	}
 
-/**
- * Usage of predictive planning
- */
-//	timespec predictionTime;
-//	UtilityH::GetTickCount(predictionTime);
-//	if(UtilityH::GetTimeDiffNow(m_PredictionTimer) &gt; 0.5 || beh.bNewPlan)
-//	{
-//		CalculateObstacleCosts(map, vehicleState, obj_list);
-//		m_PredictionTime = UtilityH::GetTimeDiffNow(predictionTime);
-//	}
-//	bool bCollision = false;
-//	int wp_id = -1;
-//	for(unsigned int i=0; i &lt; m_Path.size(); i++)
-//	{
-//		if(m_Path.at(i).collisionCost &gt; 0)
-//		{
-//			bCollision = true;
-//			wp_id = i;
-//			beh.maxVelocity = m_Path.at(i).v;//PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, 1.5*vehicleState.speed*3.6);
-//			break;
-//		}
-//	}
-//	std::cout &lt;&lt; "------------------------------------------------" &lt;&lt;  std::endl;
-//	std::cout &lt;&lt; "Max Velocity = " &lt;&lt; beh.maxVelocity &lt;&lt; ", New Plan : " &lt;&lt; beh.bNewPlan &lt;&lt;  std::endl;
-//	std::cout &lt;&lt; "Collision = " &lt;&lt; bCollision &lt;&lt; ", @ WayPoint : " &lt;&lt; wp_id &lt;&lt;  std::endl;
-//	std::cout &lt;&lt; "------------------------------------------------" &lt;&lt;  std::endl;
+
+	m_RollOutsGenerationTime = UtilityH::GetTimeDiffNow(t);
+
+	beh.maxVelocity = UpdateVelocityDirectlyToTrajectory(beh, vehicleState, dt);
 
 	return beh;
  }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MappingHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\MappingHelpers.cpp" added_lines="395" deleted_lines="734">
				<diff>@@ -5,27 +5,19 @@
  *      Author: Hatem
  */
 
-#define _ENABLE_GPS_CONVERSIONS
 
 #include "MappingHelpers.h"
 #include "MatrixOperations.h"
 #include "PlanningHelpers.h"
 
-#include "geo_pos_conv.hh"
 #include "math.h"
 #include &lt;fstream&gt;
 
-#ifdef ENABLE_GPS_CONVERSIONS
-#include "proj_api.h"
-#endif
-
-
 using namespace UtilityHNS;
 using namespace std;
-#define FIND_LEFT_RIGHT_LANES
-#define _SMOOTH_MAP_WAYPOINTS
-#define RIGHT_INITIAL_TURNS_COST 100
-#define LEFT_INITIAL_TURNS_COST 100
+#define _FIND_LEFT_RIGHT_LANES
+#define RIGHT_INITIAL_TURNS_COST 0
+#define LEFT_INITIAL_TURNS_COST 0
 
 
 namespace PlannerHNS {
@@ -40,11 +32,11 @@ MappingHelpers::~MappingHelpers() {
 
 GPSPoint MappingHelpers::GetTransformationOrigin(const int&amp; bToyotaCityMap)
 {
-	if(bToyotaCityMap == 1)
-		return GPSPoint(-3700, 99427, -88,0); //toyota city
-	else if(bToyotaCityMap == 2)
-		return GPSPoint(14805.945, 84680.211, -39.59, 0); // for moriyama map
-	else
+//	if(bToyotaCityMap == 1)
+//		return GPSPoint(-3700, 99427, -88,0); //toyota city
+//	else if(bToyotaCityMap == 2)
+//		return GPSPoint(14805.945, 84680.211, -39.59, 0); // for moriyama map
+//	else
 		return GPSPoint();
 	//return GPSPoint(18221.1, 93546.1, -36.19, 0);
 }
@@ -102,6 +94,8 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 		const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
 		const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
 		const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
+		const std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt;&amp; curb_data,
+		const std::vector&lt;UtilityHNS::AisanRoadEdgeFileReader::AisanRoadEdge&gt;&amp; roadedge_data,
 		const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
 		const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag)
 {
@@ -183,10 +177,6 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 			if(laneIDSeq != 0) //first lane
 			{
 				lane_obj.toIds.push_back(prev_lane_point.FLID);
-#ifdef SMOOTH_MAP_WAYPOINTS
-				PlanningHelpers::SmoothPath(lane_obj.points, 0.49, 0.15 , 0.01);
-				PlanningHelpers::CalcAngleAndCost(lane_obj.points);
-#endif
 				roadLanes.push_back(lane_obj);
 //				if(lane_obj.points.size() &lt;= 1)
 //					prev_FLID = 0;
@@ -204,7 +194,6 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 		bool bFound = GetWayPoint(curr_lane_point.LnID, lane_obj.id, curr_lane_point.RefVel,curr_lane_point.DID,
 				dt_data, points_data,origin, wp);
 
-
 		if(curr_lane_point.LaneDir == 'L')
 		{
 			wp.actionCost.push_back(make_pair(LEFT_TURN_ACTION, LEFT_INITIAL_TURNS_COST));
@@ -257,18 +246,18 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 		}
 
 		//if(prev_lane_point.DID == curr_lane_point.DID &amp;&amp; curr_lane_point.LnID == prev_lane_point.FLID)
-		if(prevWayPoint.pos.x == wp.pos.x &amp;&amp; prevWayPoint.pos.y == wp.pos.y)
-		{
-			//if((prev_lane_point.FLID2 != 0 &amp;&amp; curr_lane_point.FLID2 != 0) || (prev_lane_point.FLID3 != 0 &amp;&amp; curr_lane_point.FLID3 != 0) || (prev_lane_point.FLID4 != 0 &amp;&amp; curr_lane_point.FLID4 != 0))
-			{
-				cout &lt;&lt; "Prev WP, LnID: " &lt;&lt; prev_lane_point.LnID &lt;&lt; ",BLID: " &lt;&lt; prev_lane_point.BLID &lt;&lt; ",FLID: " &lt;&lt; prev_lane_point.FLID &lt;&lt; ",DID: " &lt;&lt; prev_lane_point.DID
-						&lt;&lt; ", Begin: " &lt;&lt; prev_lane_point.BLID2 &lt;&lt; "," &lt;&lt; prev_lane_point.BLID3 &lt;&lt; "," &lt;&lt; prev_lane_point.BLID4
-						&lt;&lt; ", End: " &lt;&lt; prev_lane_point.FLID2 &lt;&lt; "," &lt;&lt; prev_lane_point.FLID3 &lt;&lt; "," &lt;&lt; prev_lane_point.FLID4 &lt;&lt; ": " &lt;&lt; prev_lane_point.LaneDir &lt;&lt;   endl;
-				cout &lt;&lt; "Curr WP, LnID: " &lt;&lt; curr_lane_point.LnID &lt;&lt; ",BLID: " &lt;&lt; curr_lane_point.BLID &lt;&lt; ",FLID: " &lt;&lt; curr_lane_point.FLID &lt;&lt; ",DID: " &lt;&lt; curr_lane_point.DID
-						&lt;&lt; ", Begin: " &lt;&lt; curr_lane_point.BLID2 &lt;&lt;  "," &lt;&lt; curr_lane_point.BLID3 &lt;&lt;  "," &lt;&lt; curr_lane_point.BLID4
-						&lt;&lt; ", End: " &lt;&lt; curr_lane_point.FLID2 &lt;&lt;  "," &lt;&lt;curr_lane_point.FLID3 &lt;&lt;  "," &lt;&lt; curr_lane_point.FLID4 &lt;&lt;   ": " &lt;&lt; curr_lane_point.LaneDir &lt;&lt; endl &lt;&lt; endl;
-			}
-		}
+//		if(prevWayPoint.pos.x == wp.pos.x &amp;&amp; prevWayPoint.pos.y == wp.pos.y)
+//		{
+//			//if((prev_lane_point.FLID2 != 0 &amp;&amp; curr_lane_point.FLID2 != 0) || (prev_lane_point.FLID3 != 0 &amp;&amp; curr_lane_point.FLID3 != 0) || (prev_lane_point.FLID4 != 0 &amp;&amp; curr_lane_point.FLID4 != 0))
+//			{
+//				cout &lt;&lt; "Prev WP, LnID: " &lt;&lt; prev_lane_point.LnID &lt;&lt; ",BLID: " &lt;&lt; prev_lane_point.BLID &lt;&lt; ",FLID: " &lt;&lt; prev_lane_point.FLID &lt;&lt; ",DID: " &lt;&lt; prev_lane_point.DID
+//						&lt;&lt; ", Begin: " &lt;&lt; prev_lane_point.BLID2 &lt;&lt; "," &lt;&lt; prev_lane_point.BLID3 &lt;&lt; "," &lt;&lt; prev_lane_point.BLID4
+//						&lt;&lt; ", End: " &lt;&lt; prev_lane_point.FLID2 &lt;&lt; "," &lt;&lt; prev_lane_point.FLID3 &lt;&lt; "," &lt;&lt; prev_lane_point.FLID4 &lt;&lt; ": " &lt;&lt; prev_lane_point.LaneDir &lt;&lt;   endl;
+//				cout &lt;&lt; "Curr WP, LnID: " &lt;&lt; curr_lane_point.LnID &lt;&lt; ",BLID: " &lt;&lt; curr_lane_point.BLID &lt;&lt; ",FLID: " &lt;&lt; curr_lane_point.FLID &lt;&lt; ",DID: " &lt;&lt; curr_lane_point.DID
+//						&lt;&lt; ", Begin: " &lt;&lt; curr_lane_point.BLID2 &lt;&lt;  "," &lt;&lt; curr_lane_point.BLID3 &lt;&lt;  "," &lt;&lt; curr_lane_point.BLID4
+//						&lt;&lt; ", End: " &lt;&lt; curr_lane_point.FLID2 &lt;&lt;  "," &lt;&lt;curr_lane_point.FLID3 &lt;&lt;  "," &lt;&lt; curr_lane_point.FLID4 &lt;&lt;   ": " &lt;&lt; curr_lane_point.LaneDir &lt;&lt; endl &lt;&lt; endl;
+//			}
+//		}
 
 		if(bFound)
 		{
@@ -394,167 +383,32 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 			{
 				pL-&gt;points.at(j).pLane  = pL;
 			}
+		}
+	}
 
 #ifdef FIND_LEFT_RIGHT_LANES
-			//Link left and right lanes
-			for(unsigned int rs_2 = 0; rs_2 &lt; map.roadSegments.size(); rs_2++)
-			{
-				for(unsigned int i2 =0; i2 &lt; map.roadSegments.at(rs_2).Lanes.size(); i2++)
-				{
-					int iCenter1 = pL-&gt;points.size()/2;
-					WayPoint wp_1 = pL-&gt;points.at(iCenter1);
-					int iCenter2 = PlanningHelpers::GetClosestNextPointIndex(map.roadSegments.at(rs_2).Lanes.at(i2).points, wp_1 );
-					WayPoint closest_p = map.roadSegments.at(rs_2).Lanes.at(i2).points.at(iCenter2);
-					double mid_a1 = wp_1.pos.a;
-					double mid_a2 = closest_p.pos.a;
-					double angle_diff = UtilityH::AngleBetweenTwoAnglesPositive(mid_a1, mid_a2);
-					double distance = distance2points(wp_1.pos, closest_p.pos);
-
-					if(pL-&gt;id != map.roadSegments.at(rs_2).Lanes.at(i2).id &amp;&amp; angle_diff &lt; 0.05 &amp;&amp; distance &lt; 3.5 &amp;&amp; distance &gt; 2.5)
-					{
-						double perp_distance = 99999;
-						if(pL-&gt;points.size() &gt; 2 &amp;&amp; map.roadSegments.at(rs_2).Lanes.at(i2).points.size()&gt;2)
-						{
-							RelativeInfo info;
-							PlanningHelpers::GetRelativeInfo(pL-&gt;points, closest_p, info);
-							perp_distance = info.perp_distance;
-							//perp_distance = PlanningHelpers::GetPerpDistanceToVectorSimple(pL-&gt;points.at(iCenter1-1), pL-&gt;points.at(iCenter1+1), closest_p);
-						}
-
-						if(perp_distance &gt; 1.0 &amp;&amp; perp_distance &lt; 10.0)
-						{
-							pL-&gt;pRightLane = &amp;map.roadSegments.at(rs_2).Lanes.at(i2);
-							for(unsigned int i_internal = 0; i_internal&lt; pL-&gt;points.size(); i_internal++)
-							{
-								if(i_internal&lt;map.roadSegments.at(rs_2).Lanes.at(i2).points.size())
-								{
-									pL-&gt;points.at(i_internal).RightLaneId = map.roadSegments.at(rs_2).Lanes.at(i2).id;
-									pL-&gt;points.at(i_internal).pRight = &amp;map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal);
-//									map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal).pLeft = &amp;pL-&gt;points.at(i_internal);
-								}
-							}
-						}
-						else if(perp_distance &lt; -1.0 &amp;&amp; perp_distance &gt; -10.0)
-						{
-							pL-&gt;pLeftLane = &amp;map.roadSegments.at(rs_2).Lanes.at(i2);
-							for(unsigned int i_internal = 0; i_internal&lt; pL-&gt;points.size(); i_internal++)
-							{
-								if(i_internal&lt;map.roadSegments.at(rs_2).Lanes.at(i2).points.size())
-								{
-									pL-&gt;points.at(i_internal).LeftLaneId = map.roadSegments.at(rs_2).Lanes.at(i2).id;
-									pL-&gt;points.at(i_internal).pLeft = &amp;map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal);
-//									map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal).pRight = &amp;pL-&gt;points.at(i_internal);
-								}
-							}
-						}
-					}
-				}
-			}
+	FindAdjacentLanes(map);
 #endif
-		}
-	}
 
 	//Extract Signals and StopLines
 	// Signals
-	for(unsigned int is=0; is&lt; signal_data.size(); is++)
-	{
-		if(signal_data.at(is).Type == 2)
-		{
-			TrafficLight tl;
-			tl.id = signal_data.at(is).ID;
-			tl.stoppingDistance = 0;
+	ExtractSignalData(signal_data, vector_data, points_data, origin, map);
 
-			for(unsigned int iv = 0; iv &lt; vector_data.size(); iv++)
-			{
-				if(signal_data.at(is).VID == vector_data.at(iv).VID)
-				{
-					for(unsigned int ip = 0; ip &lt; points_data.size(); ip++)
-					{
-						if(vector_data.at(iv).PID == points_data.at(ip).PID)
-						{
-							tl.pos = GPSPoint(points_data.at(ip).Ly + origin.x, points_data.at(ip).Bx + origin.y, points_data.at(ip).H + origin.z, vector_data.at(iv).Hang*DEG2RAD);
-							break;
-						}
-					}
-				}
-			}
-			map.trafficLights.push_back(tl);
-		}
-	}
 
 	//Stop Lines
-	for(unsigned int ist=0; ist &lt; stop_line_data.size(); ist++)
-	{
-		StopLine sl;
-		sl.id = stop_line_data.at(ist).ID;
-
-		for(unsigned int il=0; il &lt; line_data.size(); il++)
-		{
-			if(stop_line_data.at(ist).LID == line_data.at(il).LID)
-			{
-				int s_id = line_data.at(il).BPID;
-				int e_id = line_data.at(il).FPID;
-				for(unsigned int ip = 0; ip &lt; points_data.size(); ip++)
-				{
-					if(points_data.at(ip).PID == s_id || points_data.at(ip).PID == e_id)
-					{
-						sl.points.push_back(GPSPoint(points_data.at(ip).Ly + origin.x, points_data.at(ip).Bx + origin.y, points_data.at(ip).H + origin.z, 0));
-					}
-				}
-			}
-		}
-		map.stopLines.push_back(sl);
-	}
+	ExtractStopLinesData(stop_line_data, line_data, points_data, origin, map);
 
-	//Link waypoints &amp;&amp; StopLines
-	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
-	{
-		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
-		{
-			for(unsigned int p= 0; p &lt; map.roadSegments.at(rs).Lanes.at(i).points.size(); p++)
-			{
-				WayPoint* pWP = &amp;map.roadSegments.at(rs).Lanes.at(i).points.at(p);
-				for(unsigned int j = 0 ; j &lt; pWP-&gt;toIds.size(); j++)
-				{
-					pWP-&gt;pFronts.push_back(FindWaypoint(pWP-&gt;toIds.at(j), map));
-				}
-			}
 
-			for(unsigned int ic = 0; ic &lt; conn_data.size(); ic++)
-			{
-				UtilityHNS::AisanDataConnFileReader::DataConn data_conn = conn_data.at(ic);
-				ReplaceMyID(data_conn.LID , id_replace_list);
+	//Link waypoints
+	LinkMissingBranchingWayPoints(map);
 
-				if(map.roadSegments.at(rs).Lanes.at(i).id == data_conn.LID)
-				{
-					for(unsigned int itl = 0; itl &lt; map.trafficLights.size(); itl++)
-					{
-						if(map.trafficLights.at(itl).id == data_conn.SID)
-						{
-							map.trafficLights.at(itl).laneIds.push_back(map.roadSegments.at(rs).Lanes.at(i).id);
-							map.trafficLights.at(itl).pLanes.push_back(&amp;map.roadSegments.at(rs).Lanes.at(i));
-							map.roadSegments.at(rs).Lanes.at(i).trafficlights.push_back(map.trafficLights.at(itl));
-						}
-					}
+	//Link StopLines and Traffic Lights
+	LinkTrafficLightsAndStopLines(map);
+	//LinkTrafficLightsAndStopLinesConData(conn_data, id_replace_list, map);
 
-					for(unsigned int isl = 0; isl &lt; map.stopLines.size(); isl++)
-					{
-						if(map.stopLines.at(isl).id == data_conn.SLID)
-						{
-							map.stopLines.at(isl).laneId = map.roadSegments.at(rs).Lanes.at(i).id;
-							map.stopLines.at(isl).pLane = &amp;map.roadSegments.at(rs).Lanes.at(i);
-							map.stopLines.at(isl).trafficLightID = data_conn.SID;
-							map.stopLines.at(isl).stopSignID = data_conn.SSID;
-							map.roadSegments.at(rs).Lanes.at(i).stopLines.push_back(map.stopLines.at(isl));
-							WayPoint wp((map.stopLines.at(isl).points.at(0).x+map.stopLines.at(isl).points.at(1).x)/2.0, (map.stopLines.at(isl).points.at(0).y+map.stopLines.at(isl).points.at(1).y)/2.0, (map.stopLines.at(isl).points.at(0).z+map.stopLines.at(isl).points.at(1).z)/2.0, (map.stopLines.at(isl).points.at(0).a+map.stopLines.at(isl).points.at(1).a)/2.0);
-							map.roadSegments.at(rs).Lanes.at(i).points.at(PlanningHelpers::GetClosestNextPointIndex(map.roadSegments.at(rs).Lanes.at(i).points, wp)).stopLineID = map.stopLines.at(isl).id;
-						}
-					}
-				}
-			}
+	//Curbs
+	ExtractCurbData(curb_data, line_data, points_data, origin, map);
 
-		}
-	}
 
 	cout &lt;&lt; "Map loaded from data with " &lt;&lt; roadLanes.size()  &lt;&lt; " lanes" &lt;&lt; endl;
 }
@@ -590,8 +444,12 @@ void MappingHelpers::ConstructRoadNetworkFromDataFiles(const std::string vectoMa
 	string signal_info = vectoMapPath + "signaldata.csv";
 	string stop_line_info = vectoMapPath + "stopline.csv";
 	string vector_info = vectoMapPath + "vector.csv";
+	string curb_info = vectoMapPath + "curb.csv";
+	string roadedge_info = vectoMapPath + "roadedge.csv";
+
 	string conn_info = vectoMapPath + "dataconnection.csv";
 
+
 	string intersection_info = vectoMapPath + "intersection.csv";
 
 	AisanCenterLinesFileReader  center_lanes(center_lines_info);
@@ -602,6 +460,8 @@ void MappingHelpers::ConstructRoadNetworkFromDataFiles(const std::string vectoMa
 	AisanStopLineFileReader stop_line(stop_line_info);
 	AisanSignalFileReader signal(signal_info);
 	AisanVectorFileReader vec(vector_info);
+	AisanCurbFileReader curb(curb_info);
+	AisanRoadEdgeFileReader roadedge(roadedge_info);
 	AisanDataConnFileReader conn(conn_info);
 
 	//AisanAreasFileReader areas(node_info);
@@ -631,6 +491,13 @@ void MappingHelpers::ConstructRoadNetworkFromDataFiles(const std::string vectoMa
 	signal.ReadAllData(signal_data);
 	vector&lt;AisanVectorFileReader::AisanVector&gt; vector_data;
 	vec.ReadAllData(vector_data);
+
+	vector&lt;AisanCurbFileReader::AisanCurb&gt; curb_data;
+	curb.ReadAllData(curb_data);
+
+	vector&lt;AisanRoadEdgeFileReader::AisanRoadEdge&gt; roadedge_data;
+	roadedge.ReadAllData(roadedge_data);
+
 	vector&lt;AisanDataConnFileReader::DataConn&gt; conn_data;
 	conn.ReadAllData(conn_data);
 
@@ -646,7 +513,9 @@ void MappingHelpers::ConstructRoadNetworkFromDataFiles(const std::string vectoMa
 		bToyotaCityMap = 2;
 
 	// use this to transform data to origin (0,0,0)
-	ConstructRoadNetworkFromRosMessage(lanes_data, points_data, dt_data, intersection_data, area_data, line_data, stop_line_data, signal_data, vector_data,conn_data, GetTransformationOrigin(bToyotaCityMap), map, bToyotaCityMap == 1);
+	ConstructRoadNetworkFromRosMessage(lanes_data, points_data, dt_data, intersection_data, area_data,
+			line_data, stop_line_data, signal_data, vector_data, curb_data, roadedge_data, conn_data,
+			GetTransformationOrigin(bToyotaCityMap), map, bToyotaCityMap == 1);
 
 	//use this when using the same coordinates as the map
 //	ConstructRoadNetworkFromRosMessage(lanes_data, points_data, dt_data, intersection_data, area_data, GPSPoint(), map);
@@ -663,47 +532,8 @@ void MappingHelpers::ConstructRoadNetworkFromDataFiles(const std::string vectoMa
 //	double distance = distance2points(origin.pos, lastPoint.pos);
 //
 	cout &lt;&lt; origin.pos.ToString() ;
-//
-//
-//	geo_pos_conv geo;
-//	geo.set_plane(6);
-//	geo.llh_to_xyz(origin2.pos.lon, origin2.pos.lat, 0);
-//
-//	origin2.pos.x = geo.x();
-//	origin2.pos.y = geo.y();
-//
-//	geo.llh_to_xyz(lastPoint2.pos.lon, lastPoint2.pos.lat, 0);
-//
-//	lastPoint2.pos.x = geo.x();
-//	lastPoint2.pos.y = geo.y();
-//
-//	double distance2 = distance2points(origin2.pos, lastPoint2.pos);
-//	cout &lt;&lt; origin2.pos.ToString() ;
-
 }
 
-void MappingHelpers::SaveTrajectoryLonLatToKMLFile(const string&amp; fileName, const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; trajectory)
-  {
-  	vector&lt;vector&lt;string&gt; &gt; m_str_kml;
-
-  	for(unsigned l = 0 ; l &lt; trajectory.size(); l++)
-  	{
-  		vector&lt;string&gt;  lane_str_kml;
-		for(unsigned k = 0 ; k &lt; trajectory.at(l).size(); k++)
-		{
-			ostringstream gps_str;
-			gps_str.precision(12);
-			GPSPoint gps_p = trajectory.at(l).at(k).pos;
-			gps_str &lt;&lt; gps_p.x &lt;&lt; "," &lt;&lt; gps_p.y &lt;&lt; "," &lt;&lt; gps_p.z;
-			lane_str_kml.push_back(gps_str.str());
-		}
-		m_str_kml.push_back(lane_str_kml);
-  	}
-
-  	if(m_str_kml.size() &gt; 0)
-  		DataRW::WriteKMLFile(fileName, m_str_kml);
-  }
-
 void MappingHelpers::GetWayPoint(const int&amp; pid, const vector&lt;AisanPointsFileReader::AisanPoints&gt;&amp; points, std::vector&lt;WayPoint&gt;&amp; path)
 {
 
@@ -751,11 +581,11 @@ bool MappingHelpers::GetWayPoint(const int&amp; id, const int&amp; laneID,const double&amp;
 
 					wp.pos = GPSPoint(points.at(p).Ly + origin.x, points.at(p).Bx + origin.y, points.at(p).H + origin.z, dtpoints.at(dtp).Dir);
 
-
 					wp.pos.lat = points.at(p).L;
 					wp.pos.lon = points.at(p).B;
 					wp.pos.alt = points.at(p).H;
 					wp.pos.dir = dtpoints.at(dtp).Dir;
+					wp.iOriginalIndex = p;
 
 
 					way_point = wp;
@@ -810,9 +640,6 @@ void MappingHelpers::LoadKML(const std::string&amp; kmlFile, RoadNetwork&amp; map)
 		{
 			//if(laneLinksList.at(j).roadId == roadLinksList.at(i).id)
 			{
-#ifdef SMOOTH_MAP_WAYPOINTS
-				PlanningHelpers::SmoothPath(laneLinksList.at(j).points, 0.49, 0.15 , 0.01);
-#endif
 				PlanningHelpers::CalcAngleAndCost(laneLinksList.at(j).points);
 				roadLinksList.at(i).Lanes.push_back(laneLinksList.at(j));
 			}
@@ -917,7 +744,7 @@ void MappingHelpers::LoadKML(const std::string&amp; kmlFile, RoadNetwork&amp; map)
 					map.stopLines.at(isl).pLane = &amp;map.roadSegments.at(rs).Lanes.at(i);
 					map.roadSegments.at(rs).Lanes.at(i).stopLines.push_back(map.stopLines.at(isl));
 					WayPoint wp((map.stopLines.at(isl).points.at(0).x+map.stopLines.at(isl).points.at(1).x)/2.0, (map.stopLines.at(isl).points.at(0).y+map.stopLines.at(isl).points.at(1).y)/2.0, (map.stopLines.at(isl).points.at(0).z+map.stopLines.at(isl).points.at(1).z)/2.0, (map.stopLines.at(isl).points.at(0).a+map.stopLines.at(isl).points.at(1).a)/2.0);
-					map.roadSegments.at(rs).Lanes.at(i).points.at(PlanningHelpers::GetClosestNextPointIndex(map.roadSegments.at(rs).Lanes.at(i).points, wp)).stopLineID = map.stopLines.at(isl).id;
+					map.roadSegments.at(rs).Lanes.at(i).points.at(PlanningHelpers::GetClosestNextPointIndexFast(map.roadSegments.at(rs).Lanes.at(i).points, wp)).stopLineID = map.stopLines.at(isl).id;
 				}
 			}
 		}
@@ -927,46 +754,6 @@ void MappingHelpers::LoadKML(const std::string&amp; kmlFile, RoadNetwork&amp; map)
 
 }
 
-void MappingHelpers::WriteKML(const string&amp; kmlFile, const string&amp; kmlTemplat, RoadNetwork&amp; map)
-{
-	//First, Get the main element
-	TiXmlElement* pHeadElem = 0;
-	TiXmlElement* pElem = 0;
-
-	ifstream f(kmlTemplat.c_str());
-	if(!f.good())
-	{
-		cout &lt;&lt; "Can't Open KML Template File: (" &lt;&lt; kmlFile &lt;&lt; ")" &lt;&lt; endl;
-		return;
-	}
-
-	TiXmlDocument doc(kmlTemplat);
-	if(!doc.LoadFile())
-	{
-		cout &lt;&lt; doc.ErrorDesc() &lt;&lt; endl;
-	}
-	else
-		pElem = doc.FirstChildElement();
-
-	pHeadElem = GetHeadElement(pElem);
-
-	vector&lt;Lane&gt; allLanes;
-	vector&lt;RoadSegment&gt; roadSegments;
-
-	for(unsigned int j=0; j&lt; map.roadSegments.size(); j++)
-	{
-		allLanes.insert(allLanes.end(), map.roadSegments.at(j).Lanes.begin(),
-				map.roadSegments.at(j).Lanes.end());
-		roadSegments.push_back(map.roadSegments.at(j));
-	}
-
-	SetLaneLinksList(pHeadElem, allLanes);
-	SetRoadLinksList(pHeadElem, roadSegments);
-	SetStopLinesList(pHeadElem, map.stopLines);
-	SetTrafficLightsList(pHeadElem, map.trafficLights);
-
-	doc.SaveFile(kmlFile.c_str());
-}
 
 TiXmlElement* MappingHelpers::GetHeadElement(TiXmlElement* pMainElem)
 {
@@ -1001,319 +788,120 @@ TiXmlElement* MappingHelpers::GetDataFolder(const string&amp; folderName, TiXmlEleme
 	return 0;
 }
 
-void MappingHelpers::SetLaneLinksList(TiXmlElement* pElem, vector&lt;Lane&gt;&amp; lanes)
+WayPoint* MappingHelpers::GetClosestWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const bool bDirectionBased)
 {
-	TiXmlElement* pLaneLinks = GetDataFolder("Lanes", pElem);
-	TiXmlNode* pE = pLaneLinks-&gt;FirstChild("Folder");
-	TiXmlNode* pN = pE;
-	TiXmlText * pText = 0;
-	TiXmlElement* pElement = 0;
-	int roadId = -1;
-	int roadsCount = 0;
-
-	if(lanes.size() ==0)
-		pE-&gt;Clear();
-
-	for(unsigned int i=0; i&lt; lanes.size(); i++)
+	double distance_to_nearest_lane = 1;
+	Lane* pLane = 0;
+	while(distance_to_nearest_lane &lt; 100 &amp;&amp; pLane == 0)
 	{
-		Lane* pLane = &amp;lanes.at(i);
-
-		if(pLane-&gt;roadId != roadId)
-		{
-			roadId = pLane-&gt;roadId;
-			roadsCount++;
-		}
-
-		if(i&gt;0)
-			pN = pE-&gt;Clone();
-
-		ostringstream name, desc;
-		name &lt;&lt; "LID_" &lt;&lt; pLane-&gt;id;
-		pElement = pN-&gt;FirstChild("name")-&gt;ToElement();
-		pText = new TiXmlText(name.str());
-		pElement-&gt;Clear();
-		pElement-&gt;LinkEndChild(pText);
-
-		desc &lt;&lt; "LID_" &lt;&lt; pLane-&gt;id &lt;&lt; "_RSID_" &lt;&lt; pLane-&gt;roadId &lt;&lt; "_NUM_" &lt;&lt; pLane-&gt;num &lt;&lt; "_From_";
-		for(unsigned int j=0; j&lt; pLane-&gt;fromIds.size(); j++)
-			desc &lt;&lt; pLane-&gt;fromIds.at(j) &lt;&lt; "_";
-
-		desc &lt;&lt; "To";
-		for(unsigned int j=0; j&lt; pLane-&gt;toIds.size(); j++)
-			desc &lt;&lt; "_" &lt;&lt; pLane-&gt;toIds.at(j);
+		pLane = GetClosestLaneFromMap(pos, map, distance_to_nearest_lane, bDirectionBased);
+		distance_to_nearest_lane += 1;
+	}
 
-		desc &lt;&lt; "_Vel_" &lt;&lt; pLane-&gt;speed;
+	if(!pLane) return 0;
 
-		pElement = pN-&gt;FirstChild("description")-&gt;ToElement();
-		pText = new TiXmlText(desc.str());
-		pElement-&gt;Clear();
-		pElement-&gt;LinkEndChild(pText);
+	int closest_index = PlanningHelpers::GetClosestNextPointIndexFast(pLane-&gt;points, pos);
 
-		ostringstream style;
-		pElement = pN-&gt;FirstChild("Placemark")-&gt;FirstChild("styleUrl")-&gt;ToElement();
-		style &lt;&lt; "#mms_route_line_" &lt;&lt; roadsCount%4;
-		pText = new TiXmlText(style.str());
-		pElement-&gt;Clear();
-		pElement-&gt;LinkEndChild(pText);
+	return &amp;pLane-&gt;points.at(closest_index);
+}
 
+vector&lt;WayPoint*&gt; MappingHelpers::GetClosestWaypointsListFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance, const bool bDirectionBased)
+{
+	vector&lt;Lane*&gt; pLanes = GetClosestLanesListFromMap(pos, map, distance, bDirectionBased);
 
-		pElement = pN-&gt;FirstChild("Placemark")-&gt;FirstChild("LineString")-&gt;FirstChild("coordinates")-&gt;ToElement();
+	vector&lt;WayPoint*&gt; waypoints_list;
 
-		ostringstream val;
-		val.precision(18);
+	if(pLanes.size() == 0) return waypoints_list;
 
-		for(unsigned int j =0; j &lt; pLane-&gt;points.size() ; j++)
+	for(unsigned int i = 0; i &lt; pLanes.size(); i++)
+	{
+		if(pLanes.at(i))
 		{
-			GPSPoint p = pLane-&gt;points.at(j).pos;
-			val &lt;&lt; p.x &lt;&lt; "," &lt;&lt; p.y &lt;&lt; "," &lt;&lt; p.z &lt;&lt;  " ";
+			int closest_index = PlanningHelpers::GetClosestNextPointIndexFast(pLanes.at(i)-&gt;points, pos);
+			waypoints_list.push_back(&amp;pLanes.at(i)-&gt;points.at(closest_index));
 		}
+	}
 
-		pText = new TiXmlText(val.str());
-		pElement-&gt;Clear();
-		pElement-&gt;LinkEndChild(pText);
-
-		TiXmlNode* pWPNode = pN-&gt;FirstChild("Folder");
-		TiXmlNode* pWPNodeCopy =  pWPNode;
-
-		ostringstream valInfo;
-		for(unsigned int j =0; j &lt; pLane-&gt;points.size() ; j++)
-		{
-			char action = 'F';
-			int cost = 0;
-
-			if(pLane-&gt;points.at(j).actionCost.size() &gt; 0)
-			{
-				if(pLane-&gt;points.at(j).actionCost.at(0).first == FORWARD_ACTION)
-					action = 'F';
-				else if(pLane-&gt;points.at(j).actionCost.at(0).first == LEFT_TURN_ACTION)
-					action = 'L';
-				else if(pLane-&gt;points.at(j).actionCost.at(0).first == RIGHT_TURN_ACTION)
-					action = 'R';
-
-				cost = 	pLane-&gt;points.at(j).actionCost.at(0).second;
-			}
+	return waypoints_list;
+}
 
-if(m_USING_VER_ZERO == 1)
+WayPoint* MappingHelpers::GetClosestBackWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map)
 {
-			valInfo &lt;&lt; "WPID_" &lt;&lt; pLane-&gt;points.at(j).id
-					&lt;&lt; "_C_" &lt;&lt; action &lt;&lt; "_" &lt;&lt; cost &lt;&lt; "_From_";
+	double distance_to_nearest_lane = 1;
+	Lane* pLane = 0;
+	while(distance_to_nearest_lane &lt; 100 &amp;&amp; pLane == 0)
+	{
+		pLane = GetClosestLaneFromMap(pos, map, distance_to_nearest_lane);
+		distance_to_nearest_lane += 1;
+	}
 
-			for(unsigned int k=0; k&lt; pLane-&gt;points.at(j).fromIds.size(); k++)
-				valInfo &lt;&lt; pLane-&gt;points.at(j).fromIds.at(k) &lt;&lt; "_";
+	if(!pLane) return 0;
 
-			valInfo &lt;&lt; "To";
-			for(unsigned int k=0; k&lt; pLane-&gt;points.at(j).toIds.size(); k++)
-				valInfo &lt;&lt; "_" &lt;&lt; pLane-&gt;points.at(j).toIds.at(k);
+	int closest_index = PlanningHelpers::GetClosestNextPointIndexFast(pLane-&gt;points, pos);
 
+	if(closest_index&gt;2)
+		return &amp;pLane-&gt;points.at(closest_index-3);
+	else if(closest_index&gt;1)
+		return &amp;pLane-&gt;points.at(closest_index-2);
+	else if(closest_index&gt;0)
+		return &amp;pLane-&gt;points.at(closest_index-1);
+	else
+		return &amp;pLane-&gt;points.at(closest_index);
 }
-else
-{
-			valInfo &lt;&lt; "WPID_" &lt;&lt; pLane-&gt;points.at(j).id
-					&lt;&lt; "_AC_" &lt;&lt; action &lt;&lt; "_" &lt;&lt; cost &lt;&lt; "_From_";
-
-			for(unsigned int k=0; k&lt; pLane-&gt;points.at(j).fromIds.size(); k++)
-				valInfo &lt;&lt; pLane-&gt;points.at(j).fromIds.at(k) &lt;&lt; "_";
-
-			valInfo &lt;&lt; "To";
-			for(unsigned int k=0; k&lt; pLane-&gt;points.at(j).toIds.size(); k++)
-				valInfo &lt;&lt; "_" &lt;&lt; pLane-&gt;points.at(j).toIds.at(k);
 
-			if(pLane-&gt;points.at(j).pLeft)
-				valInfo &lt;&lt; "_Lid_" &lt;&lt; pLane-&gt;points.at(j).pLeft-&gt;id;
-			else
-				valInfo &lt;&lt; "_Lid_" &lt;&lt; 0;
-
-			if(pLane-&gt;points.at(j).pRight)
-				valInfo &lt;&lt; "_Rid_" &lt;&lt; pLane-&gt;points.at(j).pRight-&gt;id;
-			else
-				valInfo &lt;&lt; "_Rid_" &lt;&lt; 0;
-}
+Lane* MappingHelpers::GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance, const bool bDirectionBased)
+{
+	vector&lt;pair&lt;double, Lane*&gt; &gt; laneLinksList;
+	double d = 0;
+	double min_d = 9999999999;
+	for(unsigned int j=0; j&lt; map.roadSegments.size(); j ++)
+	{
+		for(unsigned int k=0; k&lt; map.roadSegments.at(j).Lanes.size(); k ++)
+		{
+			//Lane* pLane = &amp;pEdge-&gt;lanes.at(k);
+			 d = 0;
+			min_d = 9999999999;
+			for(unsigned int pindex=0; pindex&lt; map.roadSegments.at(j).Lanes.at(k).points.size(); pindex ++)
+			{
 
-			valInfo &lt;&lt; "_Vel_" &lt;&lt; pLane-&gt;points.at(j).v;
-			valInfo &lt;&lt; "_Dir_" &lt;&lt; pLane-&gt;points.at(j).pos.a;
+				d = distance2points(map.roadSegments.at(j).Lanes.at(k).points.at(pindex).pos, pos.pos);
+				if(d &lt; min_d)
+					min_d = d;
+			}
 
-			valInfo &lt;&lt; ",";
+			if(min_d &lt; distance)
+				laneLinksList.push_back(make_pair(min_d, &amp;map.roadSegments.at(j).Lanes.at(k)));
 		}
-
-		TiXmlElement* pWPElem = pWPNodeCopy-&gt;FirstChild("description")-&gt;ToElement();
-		pText = new TiXmlText(valInfo.str());
-		pWPElem-&gt;Clear();
-		pWPElem-&gt;LinkEndChild(pText);
-
-		if(i&gt;0)
-			pLaneLinks-&gt;InsertEndChild(*pN);
 	}
-}
 
-void MappingHelpers::SetRoadLinksList(TiXmlElement* pElem, vector&lt;RoadSegment&gt;&amp; roadSegments)
-{
-	TiXmlElement* pRoadLinks = GetDataFolder("RoadSegments", pElem);
-	TiXmlNode* pE = pRoadLinks-&gt;FirstChild("Placemark");
-	TiXmlNode* pN = pE;
-	TiXmlText * pText = 0;
-	TiXmlElement* pElement = 0;
-
-	if(roadSegments.size() ==0)
-		pE-&gt;Clear();
-
-	for(unsigned int i=0; i&lt; roadSegments.size(); i++)
-	{
-		RoadSegment* pRS = &amp;roadSegments.at(i);
-
-		if(i&gt;0)
-			pN = pE-&gt;Clone();
-
-		ostringstream name, desc;
-		name &lt;&lt; "RSID_" &lt;&lt; pRS-&gt;id;
-		pElement = pN-&gt;FirstChild("name")-&gt;ToElement();
-		pElement-&gt;Clear();
-		pText = new TiXmlText(name.str());
-		pElement-&gt;LinkEndChild(pText);
-
-		desc &lt;&lt; "RSID_" &lt;&lt; pRS-&gt;id;
-		pElement = pN-&gt;FirstChild("description")-&gt;ToElement();
-		pElement-&gt;Clear();
-		pText = new TiXmlText(desc.str());
-		pElement-&gt;LinkEndChild(pText);
-		if(i&gt;0)
-			pRoadLinks-&gt;InsertEndChild(*pN);
-	}
-}
-
-void MappingHelpers::SetStopLinesList(TiXmlElement* pElem, std::vector&lt;StopLine&gt;&amp; stopLines)
-{
-	TiXmlElement* pStopLiness = GetDataFolder("StopLines", pElem);
-	TiXmlNode* pE = pStopLiness-&gt;FirstChild("Placemark");
-	TiXmlNode* pN = pE;
-	TiXmlText * pText = 0;
-	TiXmlElement* pElement = 0;
-
-	if(stopLines.size() ==0)
-		pE-&gt;Clear();
+	if(laneLinksList.size() == 0) return 0;
 
-	for(unsigned int i=0; i&lt; stopLines.size(); i++)
+	min_d = 999999999;
+	Lane* closest_lane = 0;
+	for(unsigned int i = 0; i &lt; laneLinksList.size(); i++)
 	{
-		StopLine* pSL = &amp;stopLines.at(i);
-		if(i&gt;0)
-			pN = pE-&gt;Clone();
-
-		ostringstream name, desc;
-		name &lt;&lt; "SLID_" &lt;&lt; pSL-&gt;id &lt;&lt; "_LnID_" &lt;&lt; pSL-&gt;laneId &lt;&lt; "_TSID_" &lt;&lt; pSL-&gt;stopSignID &lt;&lt; "_TLTID_" &lt;&lt; pSL-&gt;trafficLightID;
-		pElement = pN-&gt;FirstChild("name")-&gt;ToElement();
-		pText = new TiXmlText(name.str());
-		pElement-&gt;Clear();
-		pElement-&gt;LinkEndChild(pText);
-
-
-		pElement = pN-&gt;FirstChild("LineString")-&gt;FirstChild("coordinates")-&gt;ToElement();
+		RelativeInfo info;
+		PlanningHelpers::GetRelativeInfo(laneLinksList.at(i).second-&gt;points, pos, info);
 
-		ostringstream val;
-		val.precision(18);
+		if(info.perp_distance == 0 &amp;&amp; laneLinksList.at(i).first != 0)
+			continue;
 
-		for(unsigned int j =0; j &lt; pSL-&gt;points.size() ; j++)
+		if(bDirectionBased &amp;&amp; fabs(info.perp_distance) &lt; min_d &amp;&amp; fabs(info.angle_diff) &lt; 45)
 		{
-			GPSPoint p = pSL-&gt;points.at(j);
-			val &lt;&lt; p.x &lt;&lt; "," &lt;&lt; p.y &lt;&lt; "," &lt;&lt; p.z &lt;&lt;  " ";
+			min_d = fabs(info.perp_distance);
+			closest_lane = laneLinksList.at(i).second;
+		}
+		else if(!bDirectionBased &amp;&amp; fabs(info.perp_distance) &lt; min_d)
+		{
+			min_d = fabs(info.perp_distance);
+			closest_lane = laneLinksList.at(i).second;
 		}
-
-		pText = new TiXmlText(val.str());
-		pElement-&gt;Clear();
-		pElement-&gt;LinkEndChild(pText);
-
-		if(i&gt;0)
-			pStopLiness-&gt;InsertEndChild(*pN);
-	}
-}
-
-void MappingHelpers::SetTrafficLightsList(TiXmlElement* pElem, std::vector&lt;TrafficLight&gt;&amp; trafficLights)
-{
-	TiXmlElement* pTrafficLights = GetDataFolder("TrafficLights", pElem);
-	TiXmlNode* pE = pTrafficLights-&gt;FirstChild("Placemark");
-	TiXmlNode* pN = pE;
-	TiXmlText * pText = 0;
-	TiXmlElement* pElement = 0;
-
-	if(trafficLights.size() ==0)
-		pE-&gt;Clear();
-
-	for(unsigned int i=0; i&lt; trafficLights.size(); i++)
-	{
-		TrafficLight* pTL = &amp;trafficLights.at(i);
-		if(i&gt;0)
-			pN = pE-&gt;Clone();
-
-		ostringstream name, desc;
-		name &lt;&lt; "TLID_" &lt;&lt; pTL-&gt;id &lt;&lt; "_LnID";
-		for(unsigned int j=0; j&lt; pTL-&gt;laneIds.size(); j++)
-			name &lt;&lt; "_" &lt;&lt; pTL-&gt;laneIds.at(j);
-
-		pElement = pN-&gt;FirstChild("name")-&gt;ToElement();
-		pText = new TiXmlText(name.str());
-		pElement-&gt;Clear();
-		pElement-&gt;LinkEndChild(pText);
-
-		pElement = pN-&gt;FirstChild("Point")-&gt;FirstChild("coordinates")-&gt;ToElement();
-
-		ostringstream val;
-		val.precision(18);
-		val &lt;&lt; pTL-&gt;pos.x &lt;&lt; "," &lt;&lt; pTL-&gt;pos.y &lt;&lt; "," &lt;&lt; pTL-&gt;pos.z &lt;&lt;  " ";
-
-		pText = new TiXmlText(val.str());
-		pElement-&gt;Clear();
-		pElement-&gt;LinkEndChild(pText);
-
-		if(i&gt;0)
-			pTrafficLights-&gt;InsertEndChild(*pN);
-	}
-}
-
-void MappingHelpers::SetTrafficSignsList(TiXmlElement* pElem, std::vector&lt;TrafficSign&gt;&amp; trafficSignes)
-{
-
-}
-
-WayPoint* MappingHelpers::GetClosestWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map)
-{
-	double distance_to_nearest_lane = 1;
-	Lane* pLane = 0;
-	while(distance_to_nearest_lane &lt; 100 &amp;&amp; pLane == 0)
-	{
-		pLane = GetClosestLaneFromMap(pos, map, distance_to_nearest_lane);
-		distance_to_nearest_lane += 1;
-	}
-
-	if(!pLane) return 0;
-
-	int closest_index = PlanningHelpers::GetClosestNextPointIndex(pLane-&gt;points, pos);
-
-	return &amp;pLane-&gt;points.at(closest_index);
-}
-
-WayPoint* MappingHelpers::GetClosestBackWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map)
-{
-	double distance_to_nearest_lane = 1;
-	Lane* pLane = 0;
-	while(distance_to_nearest_lane &lt; 100 &amp;&amp; pLane == 0)
-	{
-		pLane = GetClosestLaneFromMap(pos, map, distance_to_nearest_lane);
-		distance_to_nearest_lane += 1;
 	}
 
-	if(!pLane) return 0;
-
-	int closest_index = PlanningHelpers::GetClosestNextPointIndex(pLane-&gt;points, pos);
-
-	if(closest_index&gt;2)
-		return &amp;pLane-&gt;points.at(closest_index-3);
-	else if(closest_index&gt;1)
-		return &amp;pLane-&gt;points.at(closest_index-2);
-	else if(closest_index&gt;0)
-		return &amp;pLane-&gt;points.at(closest_index-1);
-	else
-		return &amp;pLane-&gt;points.at(closest_index);
+	return closest_lane;
 }
 
-Lane* MappingHelpers::GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance)
+vector&lt;Lane*&gt; MappingHelpers::GetClosestLanesListFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance, const bool bDirectionBased)
 {
 	vector&lt;pair&lt;double, Lane*&gt; &gt; laneLinksList;
 	double d = 0;
@@ -1338,10 +926,10 @@ Lane* MappingHelpers::GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; ma
 		}
 	}
 
-	if(laneLinksList.size() == 0) return 0;
+	vector&lt;Lane*&gt; closest_lanes;
+	if(laneLinksList.size() == 0) return closest_lanes;
+
 
-	min_d = 999999999;
-	Lane* closest_lane = 0;
 	for(unsigned int i = 0; i &lt; laneLinksList.size(); i++)
 	{
 		RelativeInfo info;
@@ -1350,14 +938,17 @@ Lane* MappingHelpers::GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; ma
 		if(info.perp_distance == 0 &amp;&amp; laneLinksList.at(i).first != 0)
 			continue;
 
-		if(fabs(info.perp_distance) &lt; min_d &amp;&amp; fabs(info.angle_diff) &lt; 45)
+		if(bDirectionBased &amp;&amp; fabs(info.perp_distance) &lt; distance &amp;&amp; fabs(info.angle_diff) &lt; 45)
 		{
-			min_d = fabs(info.perp_distance);
-			closest_lane = laneLinksList.at(i).second;
+			closest_lanes.push_back(laneLinksList.at(i).second);
+		}
+		else if(!bDirectionBased &amp;&amp; fabs(info.perp_distance) &lt; distance)
+		{
+			closest_lanes.push_back(laneLinksList.at(i).second);
 		}
 	}
 
-	return closest_lane;
+	return closest_lanes;
 }
 
 Lane* MappingHelpers::GetClosestLaneFromMapDirectionBased(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance)
@@ -1481,110 +1072,6 @@ WayPoint* MappingHelpers::GetLastWaypoint(RoadNetwork&amp; map)
 	return 0;
 }
 
-
-void MappingHelpers::llaToxyzSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset)
-{
-#ifdef ENABLE_GPS_CONVERSIONS
-	projPJ pj_latlong, pj_utm;
-	pj_latlong = pj_init_plus("+proj=latlong +ellps=WGS84");
-	pj_utm = pj_init_plus("+proj=utm +zone=53 +ellps=WGS84 +datum=WGS84");
-
-	projUV p_gps;
-	p_gps.u = lla_p.lon - netOffset.x;
-	p_gps.v = lla_p.lat - netOffset.y;
-
-	p_gps = pj_inv(p_gps, pj_utm);
-	p_gps.u *= DEG2RAD;
-	p_gps.v *= DEG2RAD;
-
-	GPSPoint p = lla_p;
-	p.x = p_gps.u;
-	p.y = p_gps.v;
-
-	if(pj_latlong != 0 &amp;&amp; pj_utm !=0 )
-	{
-		pj_transform(pj_latlong, pj_utm, 1, 1, &amp;p.y, &amp;p.x, &amp;p.z);
-		p.x += netOffset.x;
-		p.y += netOffset.y;
-	}
-
-	lla_p = p;
-#endif
-}
-
-void MappingHelpers::llaToxyz(GPSPoint&amp; lla_p, const GPSPoint&amp; origin)
-{
-#ifdef ENABLE_GPS_CONVERSIONS
-	projPJ pj_latlong, pj_utm;
-	pj_latlong = pj_init_plus("+proj=latlong +ellps=WGS84");
-	pj_utm = pj_init_plus("+proj=utm +zone=53 +ellps=WGS84 +datum=WGS84");
-
-	GPSPoint p = lla_p;
-
-	p.x = lla_p.lon * DEG2RAD;
-	p.y = lla_p.lat * DEG2RAD;
-
-	if(pj_latlong != 0 &amp;&amp; pj_utm !=0 )
-	{
-		pj_transform(pj_latlong, pj_utm, 1, 1, &amp;p.y, &amp;p.x, &amp;p.z);
-		p.x -= origin.x;
-		p.y -= origin.y;
-		p.z -= origin.z;
-	}
-
-	lla_p = p;
-#endif
-
-}
-
-void MappingHelpers::xyzTollaSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset)
-{
-#ifdef ENABLE_GPS_CONVERSIONS
-	projPJ pj_latlong, pj_utm;
-	pj_latlong = pj_init_plus("+proj=latlong +ellps=WGS84");
-	pj_utm = pj_init_plus("+proj=utm +zone=53 +ellps=WGS84 +datum=WGS84");
-
-	projUV p_gps;
-	p_gps.u = lla_p.y - netOffset.x;
-	p_gps.v = lla_p.x - netOffset.y;
-
-	p_gps = pj_inv(p_gps, pj_utm);
-	p_gps.u *= RAD2DEG;
-	p_gps.v *= RAD2DEG;
-
-	GPSPoint p = lla_p;
-	p.lon = p_gps.u;
-	p.lat = p_gps.v;
-
-	lla_p = p;
-#endif
-}
-
-void MappingHelpers::xyzTolla(GPSPoint&amp; xyz_p, const GPSPoint&amp; origin)
-{
-#ifdef ENABLE_GPS_CONVERSIONS
-	projPJ pj_latlong, pj_utm;
-	pj_latlong = pj_init_plus("+proj=latlong +ellps=WGS84");
-	pj_utm = pj_init_plus("+proj=utm +ellps=WGS84 +datum=WGS84 +units=m");
-
-	GPSPoint p = xyz_p;
-
-	if(pj_latlong != 0 &amp;&amp; pj_utm !=0 )
-	{
-		pj_transform(pj_utm,pj_latlong, 1, 1, &amp;p.lon, &amp;p.lat, &amp;p.alt);
-		p.lon = p.lon * RAD2DEG;
-		p.lat = p.lat * RAD2DEG;
-
-		p.lon -= origin.lon;
-		p.lat -= origin.lat;
-		p.alt -= origin.alt;
-	}
-
-	xyz_p = p;
-#endif
-
-}
-
 void MappingHelpers::GetUniqueNextLanes(const Lane* l,  const vector&lt;Lane*&gt;&amp; traversed_lanes, vector&lt;Lane*&gt;&amp; lanes_list)
 {
 	if(!l) return;
@@ -1608,7 +1095,7 @@ Lane* MappingHelpers::GetLaneFromPath(const WayPoint&amp; currPos, const std::vector
 {
 	if(currPath.size() &lt; 1) return 0;
 
-	int closest_index = PlanningHelpers::GetClosestNextPointIndex(currPath, currPos);
+	int closest_index = PlanningHelpers::GetClosestNextPointIndexFast(currPath, currPos);
 
 	return currPath.at(closest_index).pLane;
 }
@@ -1995,7 +1482,8 @@ pair&lt;ACTION_TYPE, double&gt; MappingHelpers::GetActionPairFromPrefix(const string&amp;
 	act_cost.second = 0;
 
 	vector&lt;string&gt; idstr = SplitString(str_ids, "_");
-	if(idstr.size() == 2)
+
+	if(idstr.size() &gt;= 2)
 	{
 		if(idstr.at(0).size() &gt; 0 &amp;&amp; idstr.at(0).at(0) == 'L')
 			act_cost.first = LEFT_TURN_ACTION;
@@ -2032,110 +1520,283 @@ vector&lt;string&gt; MappingHelpers::SplitString(const string&amp; str, const string&amp; toke
 	return str_parts;
 }
 
-void MappingHelpers::CreateKmlFromLocalizationPathFile(const std::string&amp; pathFileName,
-		const double&amp; maxLaneDistance, const double&amp; density,
-		const std::vector&lt;TrafficLight&gt;&amp; trafficLights,
-		const std::vector&lt;GPSPoint&gt;&amp; stopLines)
+void MappingHelpers::FindAdjacentLanes(RoadNetwork&amp; map)
 {
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+	{
+		//Link Lanes
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
+		{
+			Lane* pL = &amp;map.roadSegments.at(rs).Lanes.at(i);
+			//Link left and right lanes
+			for(unsigned int rs_2 = 0; rs_2 &lt; map.roadSegments.size(); rs_2++)
+			{
+				for(unsigned int i2 =0; i2 &lt; map.roadSegments.at(rs_2).Lanes.size(); i2++)
+				{
+					int iCenter1 = pL-&gt;points.size()/2;
+					WayPoint wp_1 = pL-&gt;points.at(iCenter1);
+					int iCenter2 = PlanningHelpers::GetClosestNextPointIndexFast(map.roadSegments.at(rs_2).Lanes.at(i2).points, wp_1 );
+					WayPoint closest_p = map.roadSegments.at(rs_2).Lanes.at(i2).points.at(iCenter2);
+					double mid_a1 = wp_1.pos.a;
+					double mid_a2 = closest_p.pos.a;
+					double angle_diff = UtilityH::AngleBetweenTwoAnglesPositive(mid_a1, mid_a2);
+					double distance = distance2points(wp_1.pos, closest_p.pos);
 
-	//Read Data From csv file
-	LocalizationPathReader pathReader(pathFileName, ',');
-	vector&lt;LocalizationPathReader::LocalizationWayPoint&gt; path_data;
-	pathReader.ReadAllData(path_data);
-	PlannerHNS::RoadSegment segment;
-	segment.id = 1;
-
-	double d_accum = 0;
-	double laneMaxLength = maxLaneDistance;
-
-	std::vector&lt;WayPoint&gt; wayPointsList;
+					if(pL-&gt;id != map.roadSegments.at(rs_2).Lanes.at(i2).id &amp;&amp; angle_diff &lt; 0.05 &amp;&amp; distance &lt; 3.5 &amp;&amp; distance &gt; 2.5)
+					{
+						double perp_distance = 99999;
+						if(pL-&gt;points.size() &gt; 2 &amp;&amp; map.roadSegments.at(rs_2).Lanes.at(i2).points.size()&gt;2)
+						{
+							RelativeInfo info;
+							PlanningHelpers::GetRelativeInfo(pL-&gt;points, closest_p, info);
+							perp_distance = info.perp_distance;
+							//perp_distance = PlanningHelpers::GetPerpDistanceToVectorSimple(pL-&gt;points.at(iCenter1-1), pL-&gt;points.at(iCenter1+1), closest_p);
+						}
 
-	PlannerHNS::Lane lane;
-	lane.id = 1;
-	lane.num = 0;
-	lane.roadId = 1;
-	WayPoint p_prev;
+						if(perp_distance &gt; 1.0 &amp;&amp; perp_distance &lt; 10.0)
+						{
+							pL-&gt;pRightLane = &amp;map.roadSegments.at(rs_2).Lanes.at(i2);
+							for(unsigned int i_internal = 0; i_internal&lt; pL-&gt;points.size(); i_internal++)
+							{
+								if(i_internal&lt;map.roadSegments.at(rs_2).Lanes.at(i2).points.size())
+								{
+									pL-&gt;points.at(i_internal).RightLaneId = map.roadSegments.at(rs_2).Lanes.at(i2).id;
+									pL-&gt;points.at(i_internal).pRight = &amp;map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal);
+//									map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal).pLeft = &amp;pL-&gt;points.at(i_internal);
+								}
+							}
+						}
+						else if(perp_distance &lt; -1.0 &amp;&amp; perp_distance &gt; -10.0)
+						{
+							pL-&gt;pLeftLane = &amp;map.roadSegments.at(rs_2).Lanes.at(i2);
+							for(unsigned int i_internal = 0; i_internal&lt; pL-&gt;points.size(); i_internal++)
+							{
+								if(i_internal&lt;map.roadSegments.at(rs_2).Lanes.at(i2).points.size())
+								{
+									pL-&gt;points.at(i_internal).LeftLaneId = map.roadSegments.at(rs_2).Lanes.at(i2).id;
+									pL-&gt;points.at(i_internal).pLeft = &amp;map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal);
+//									map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal).pRight = &amp;pL-&gt;points.at(i_internal);
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+}
 
-	for(unsigned int i=0; i&lt; path_data.size() ; i++)
+void MappingHelpers::ExtractSignalData(const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
+			const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
+			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
+			const GPSPoint&amp; origin, RoadNetwork&amp; map)
+{
+	for(unsigned int is=0; is&lt; signal_data.size(); is++)
 	{
-		WayPoint p(path_data.at(i).x,path_data.at(i).y,path_data.at(i).z,0);
-		p.pos.lat = p.pos.x;
-		p.pos.lon = p.pos.y;
-		p.pos.alt = p.pos.z;
-		//p.pos.dir = p.pos.a;
-		//p.v = path_data.at(i).v;
-		p.laneId = lane.id;
-		p.id = i+1;
-		if(i&gt;0)
+		if(signal_data.at(is).Type == 2)
 		{
-			p.fromIds.push_back(i);
-			d_accum += hypot(p.pos.y-p_prev.pos.y, p.pos.x-p_prev.pos.x);
+			TrafficLight tl;
+			tl.id = signal_data.at(is).ID;
+			tl.linkID = signal_data.at(is).LinkID;
+			tl.stoppingDistance = 0;
+
+			for(unsigned int iv = 0; iv &lt; vector_data.size(); iv++)
+			{
+				if(signal_data.at(is).VID == vector_data.at(iv).VID)
+				{
+					for(unsigned int ip = 0; ip &lt; points_data.size(); ip++)
+					{
+						if(vector_data.at(iv).PID == points_data.at(ip).PID)
+						{
+							tl.pos = GPSPoint(points_data.at(ip).Ly + origin.x, points_data.at(ip).Bx + origin.y, points_data.at(ip).H + origin.z, vector_data.at(iv).Hang*DEG2RAD);
+							break;
+						}
+					}
+				}
+			}
+			map.trafficLights.push_back(tl);
 		}
+	}
+}
+
+void MappingHelpers::ExtractStopLinesData(const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
+			const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
+			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
+			const GPSPoint&amp; origin, RoadNetwork&amp; map)
+{
+	for(unsigned int ist=0; ist &lt; stop_line_data.size(); ist++)
+		{
+		StopLine sl;
+		sl.linkID = stop_line_data.at(ist).LinkID;
+		sl.id = stop_line_data.at(ist).ID;
 
-		if(i&lt;path_data.size()-1)
-			p.toIds.push_back(i+2);
+		for(unsigned int il=0; il &lt; line_data.size(); il++)
+		{
+			if(stop_line_data.at(ist).LID == line_data.at(il).LID)
+			{
+				int s_id = line_data.at(il).BPID;
+				int e_id = line_data.at(il).FPID;
+				for(unsigned int ip = 0; ip &lt; points_data.size(); ip++)
+				{
+					if(points_data.at(ip).PID == s_id || points_data.at(ip).PID == e_id)
+					{
+						sl.points.push_back(GPSPoint(points_data.at(ip).Ly + origin.x, points_data.at(ip).Bx + origin.y, points_data.at(ip).H + origin.z, 0));
+					}
+				}
+			}
+		}
+		map.stopLines.push_back(sl);
+	}
+}
 
-		wayPointsList.push_back(p);
+void MappingHelpers::ExtractCurbData(const std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt;&amp; curb_data,
+				const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
+				const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
+				const GPSPoint&amp; origin, RoadNetwork&amp; map)
+{
+	for(unsigned int ic=0; ic &lt; curb_data.size(); ic++)
+		{
+			Curb c;
+			c.id = curb_data.at(ic).ID;
 
-		p_prev = p;
+			for(unsigned int il=0; il &lt; line_data.size(); il++)
+			{
+				if(curb_data.at(ic).LID == line_data.at(il).LID)
+				{
+					int s_id = line_data.at(il).BPID;
+					int e_id = line_data.at(il).FPID;
+					for(unsigned int ip = 0; ip &lt; points_data.size(); ip++)
+					{
+						if(points_data.at(ip).PID == s_id)
+						{
+							c.points.push_back(GPSPoint(points_data.at(ip).Ly + origin.x, points_data.at(ip).Bx + origin.y, points_data.at(ip).H + origin.z, 0));
+							WayPoint wp;
+							wp.pos = c.points.at(0);
+							Lane* pLane = GetClosestLaneFromMap(wp, map, 5);
+							if(pLane)
+							{
+								c.laneId = pLane-&gt;id;
+								c.pLane = pLane;
+							}
+						}
+					}
+				}
+			}
+			map.curbs.push_back(c);
+		}
+}
 
-		if(d_accum &gt; laneMaxLength || i+1 == path_data.size())
+void MappingHelpers::LinkMissingBranchingWayPoints(RoadNetwork&amp; map)
+{
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+	{
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
 		{
-			if(segment.Lanes.size()&gt;0)
-				lane.fromIds.push_back(segment.Lanes.at(segment.Lanes.size()-1).id);
-			lane.toIds.push_back(lane.id+1);
-			lane.points = wayPointsList;
-			segment.Lanes.push_back(lane);
-
-			d_accum = 0;
-			PlannerHNS::Lane n_lane;
-			n_lane.id = lane.id+1;
-			n_lane.num = 0;
-			n_lane.roadId = 1;
-			lane = n_lane;
-			wayPointsList.clear();
+			for(unsigned int p= 0; p &lt; map.roadSegments.at(rs).Lanes.at(i).points.size(); p++)
+			{
+				WayPoint* pWP = &amp;map.roadSegments.at(rs).Lanes.at(i).points.at(p);
+				for(unsigned int j = 0 ; j &lt; pWP-&gt;toIds.size(); j++)
+				{
+					pWP-&gt;pFronts.push_back(FindWaypoint(pWP-&gt;toIds.at(j), map));
+				}
+			}
 		}
 	}
+}
 
-	if(segment.Lanes.size()&gt;0)
+void MappingHelpers::LinkTrafficLightsAndStopLines(RoadNetwork&amp; map)
+{
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
 	{
-		segment.Lanes.at(segment.Lanes.size()-1).toIds.clear();
-		if(density &gt; 0)
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
 		{
-			for(unsigned int i=0; i &lt; segment.Lanes.size(); i++)
-				PlanningHelpers::FixPathDensity(segment.Lanes.at(i).points, density);
-
-			int fnID=0;
-			for(unsigned int i=0; i &lt; segment.Lanes.size(); i++)
+			for(unsigned int itl = 0; itl &lt; map.trafficLights.size(); itl++)
 			{
-				if(segment.Lanes.at(i).points.size() &gt; 0)
+				for(unsigned int p= 0; p &lt; map.roadSegments.at(rs).Lanes.at(i).points.size(); p++)
 				{
-					for(unsigned int j =0; j &lt; segment.Lanes.at(i).points.size(); j++)
+					WayPoint* pWP = &amp;map.roadSegments.at(rs).Lanes.at(i).points.at(p);
+					if(map.trafficLights.at(itl).linkID == pWP-&gt;id)
 					{
-						fnID ++;
-						segment.Lanes.at(i).points.at(j).id = fnID ;
-						segment.Lanes.at(i).points.at(j).fromIds.clear();
-						segment.Lanes.at(i).points.at(j).toIds.clear();
-						if(!(i == 0 &amp;&amp; j == 0))
-							segment.Lanes.at(i).points.at(j).fromIds.push_back(fnID - 1);
-						if(!(i+1 ==  segment.Lanes.size() &amp;&amp; j+1 == segment.Lanes.at(i).points.size()))
-							segment.Lanes.at(i).points.at(j).toIds.push_back(fnID + 1);
+						map.trafficLights.at(itl).laneIds.push_back(pWP-&gt;laneId);
+						map.trafficLights.at(itl).pLanes.push_back(pWP-&gt;pLane);
+						map.roadSegments.at(rs).Lanes.at(i).trafficlights.push_back(map.trafficLights.at(itl));
+						break;
 					}
 				}
 			}
 		}
 	}
 
-	PlannerHNS::RoadNetwork roadMap;
-	roadMap.roadSegments.push_back(segment);
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+		{
+			for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
+			{
+				for(unsigned int isl = 0; isl &lt; map.stopLines.size(); isl++)
+				{
+					for(unsigned int p= 0; p &lt; map.roadSegments.at(rs).Lanes.at(i).points.size(); p++)
+					{
+						WayPoint* pWP = &amp;map.roadSegments.at(rs).Lanes.at(i).points.at(p);
+						if(map.stopLines.at(isl).linkID == pWP-&gt;id)
+						{
+							map.stopLines.at(isl).laneId = pWP-&gt;laneId;
+							map.stopLines.at(isl).pLane = pWP-&gt;pLane;
+							if(pWP-&gt;pLane-&gt;trafficlights.size() &gt; 0)
+								map.stopLines.at(isl).trafficLightID = pWP-&gt;pLane-&gt;trafficlights.at(0).id;
+							map.stopLines.at(isl).stopSignID = 100+isl;
+							map.roadSegments.at(rs).Lanes.at(i).stopLines.push_back(map.stopLines.at(isl));
+							WayPoint wp((map.stopLines.at(isl).points.at(0).x+map.stopLines.at(isl).points.at(1).x)/2.0, (map.stopLines.at(isl).points.at(0).y+map.stopLines.at(isl).points.at(1).y)/2.0, (map.stopLines.at(isl).points.at(0).z+map.stopLines.at(isl).points.at(1).z)/2.0, (map.stopLines.at(isl).points.at(0).a+map.stopLines.at(isl).points.at(1).a)/2.0);
+							map.roadSegments.at(rs).Lanes.at(i).points.at(PlanningHelpers::GetClosestNextPointIndexFast(map.roadSegments.at(rs).Lanes.at(i).points, wp)).stopLineID = map.stopLines.at(isl).id;
+							break;
+						}
+					}
+				}
+			}
+		}
+}
 
-	ostringstream fileName;
-	fileName &lt;&lt; UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName;
-	fileName &lt;&lt; UtilityHNS:: UtilityH::GetFilePrefixHourMinuteSeconds();
-	fileName &lt;&lt; "_RoadNetwork.kml";
-	string kml_templateFilePath = UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName + UtilityHNS::DataRW::KmlMapsFolderName+"PlannerX_MapTemplate.kml";
+void MappingHelpers::LinkTrafficLightsAndStopLinesConData(const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
+		const std::vector&lt;std::pair&lt;int,int&gt; &gt;&amp; id_replace_list, RoadNetwork&amp; map)
+{
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+		{
+			for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
+			{
 
-	PlannerHNS::MappingHelpers::WriteKML("/home/hatem/SimuLogs/YardKML.kml",kml_templateFilePath , roadMap);
-}
+				for(unsigned int ic = 0; ic &lt; conn_data.size(); ic++)
+				{
+					UtilityHNS::AisanDataConnFileReader::DataConn data_conn = conn_data.at(ic);
+					ReplaceMyID(data_conn.LID , id_replace_list);
+
+					if(map.roadSegments.at(rs).Lanes.at(i).id == data_conn.LID)
+					{
+						for(unsigned int itl = 0; itl &lt; map.trafficLights.size(); itl++)
+						{
+							if(map.trafficLights.at(itl).id == data_conn.SID)
+							{
+								map.trafficLights.at(itl).laneIds.push_back(map.roadSegments.at(rs).Lanes.at(i).id);
+								map.trafficLights.at(itl).pLanes.push_back(&amp;map.roadSegments.at(rs).Lanes.at(i));
+								map.roadSegments.at(rs).Lanes.at(i).trafficlights.push_back(map.trafficLights.at(itl));
+							}
+						}
 
+						for(unsigned int isl = 0; isl &lt; map.stopLines.size(); isl++)
+						{
+							if(map.stopLines.at(isl).id == data_conn.SLID)
+							{
+								map.stopLines.at(isl).laneId = map.roadSegments.at(rs).Lanes.at(i).id;
+								map.stopLines.at(isl).pLane = &amp;map.roadSegments.at(rs).Lanes.at(i);
+								map.stopLines.at(isl).trafficLightID = data_conn.SID;
+								map.stopLines.at(isl).stopSignID = data_conn.SSID;
+								map.roadSegments.at(rs).Lanes.at(i).stopLines.push_back(map.stopLines.at(isl));
+								WayPoint wp((map.stopLines.at(isl).points.at(0).x+map.stopLines.at(isl).points.at(1).x)/2.0, (map.stopLines.at(isl).points.at(0).y+map.stopLines.at(isl).points.at(1).y)/2.0, (map.stopLines.at(isl).points.at(0).z+map.stopLines.at(isl).points.at(1).z)/2.0, (map.stopLines.at(isl).points.at(0).a+map.stopLines.at(isl).points.at(1).a)/2.0);
+								map.roadSegments.at(rs).Lanes.at(i).points.at(PlanningHelpers::GetClosestNextPointIndexFast(map.roadSegments.at(rs).Lanes.at(i).points, wp)).stopLineID = map.stopLines.at(isl).id;
+							}
+						}
+					}
+				}
+
+			}
+		}
+
+}
 } /* namespace PlannerHNS */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlannerH.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlannerH.cpp" added_lines="394" deleted_lines="368">
				<diff>@@ -20,11 +20,11 @@ PlannerH::PlannerH()
 	//m_Params = params;
 }
 
- PlannerH::~PlannerH()
+PlannerH::~PlannerH()
 {
 }
 
- double PlannerH::PlanUsingReedShepp(const WayPoint&amp; start, const WayPoint&amp; goal, vector&lt;WayPoint&gt;&amp; generatedPath, const double pathDensity, const double smoothFactor)
+double PlannerH::PlanUsingReedShepp(const WayPoint&amp; start, const WayPoint&amp; goal, vector&lt;WayPoint&gt;&amp; generatedPath, const double pathDensity, const double smoothFactor)
  {
  	RSPlanner rs_planner(smoothFactor);
  	int numero = 0;
@@ -35,278 +35,126 @@ PlannerH::PlannerH()
  	return length;
  }
 
- double PlannerH::PlanUsingReedSheppWithObstacleDetection(const WayPoint&amp; start, const WayPoint&amp; goal,GridMap&amp; map, vector&lt;WayPoint&gt;&amp; genSmoothedPath,
-		 const double pathDensity , const double smoothFactor )
- {
- 	RSPlanner rs_planner(smoothFactor);
- 	int numero = 0;
- 	double t=0, u=0 , v=0;
- 	rs_planner.PATHDENSITY = pathDensity;
-
- 	genSmoothedPath.clear();
- 	genSmoothedPath.clear();
-
- 	double length = rs_planner.min_length_rs(start.pos.x, start.pos.y, UtilityHNS::UtilityH::SplitPositiveAngle(start.pos.a), goal.pos.x, goal.pos.y, UtilityHNS::UtilityH::SplitPositiveAngle(goal.pos.a), numero, t , u , v);
- 	rs_planner.constRS(numero, t, u , v, start.pos.x, start.pos.y, UtilityHNS::UtilityH::SplitPositiveAngle(start.pos.a), rs_planner.PATHDENSITY, genSmoothedPath);
-
- 	if(genSmoothedPath.size() == 0)
- 		return length;
-
- 	CELL_Info* pCellRet = 0;
-
- 	WayPoint p = genSmoothedPath.at(0);
- 	int nChanges = 0;
- 	double nMinChangeDistance = length;
- 	double d = 0;
-
- 	for(unsigned int i=0; i&lt;genSmoothedPath.size(); i++)
- 	{
- 		if(p.bDir != genSmoothedPath.at(i).bDir)
- 		{
- 			if(d &lt; nMinChangeDistance)
- 				nMinChangeDistance = d;
-
- 			d = 0;
-
- 			nChanges++;
- 		}
-
- 		d+= distance2points(p.pos, genSmoothedPath.at(i).pos);
-
- 		p = genSmoothedPath.at(i);
-
-// 		if(map.)
-// 			pCellRet = map.GetCellFromPointInnerMap(p.p);
-// 		else
- 		pCellRet = map.GetCellFromPoint(POINT2D(p.pos.x, p.pos.y));
-
- 		if(pCellRet)
- 		{
- 			if(pCellRet-&gt;nMovingPoints &gt; 0|| pCellRet-&gt;nStaticPoints &gt; 0 || pCellRet-&gt;heuristic == map.m_MaxHeuristics)
- 			{
- 				cout &lt;&lt; "\n Obstacle Detected \n";
- 				genSmoothedPath.clear();
- 				return -1;
- 			}
- 		}
- 		else
- 		{
- 			cout &lt;&lt; "\n Outside the Main Grid \n";
- 			genSmoothedPath.clear();
- 			return -1;
- 		}
- 	}
-
- 	if(nChanges &gt; 3 || nMinChangeDistance &lt; 3.2)
- 	{
- 		cout &lt;&lt; "\n Too much gear changes \n";
- 		genSmoothedPath.clear();
- 		return -1;
- 	}
-
- //	pthread_mutex_lock(&amp;planning_mutex);
- //	m_CurrentPath.assign(genSmoothedPath.begin(), genSmoothedPath.end());
- //	m_CurrentSmoothPath.clear();
- //	//m_TotalPath.assign(m_CurrentPath.begin(), m_CurrentPath.end());
- //	m_CurrentSmoothPath.assign(m_CurrentPath.begin(), m_CurrentPath.end());
- //	//m_TotalSmoothPath.assign(m_CurrentSmoothPath.begin(), m_CurrentSmoothPath.end());
- //	pthread_mutex_unlock(&amp;planning_mutex);
+void PlannerH::GenerateRunoffTrajectory(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; referencePaths,const WayPoint&amp; carPos, const bool&amp; bEnableLaneChange, const double&amp; speed, const double&amp; microPlanDistance,
+		const double&amp; maxSpeed,const double&amp; minSpeed, const double&amp;  carTipMargin, const double&amp; rollInMargin,
+		const double&amp; rollInSpeedFactor, const double&amp; pathDensity, const double&amp; rollOutDensity,
+		const int&amp; rollOutNumber, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight,
+		const double&amp; SmoothTolerance, const double&amp; speedProfileFactor, const bool&amp; bHeadingSmooth,
+		const int&amp; iCurrGlobalPath, const int&amp; iCurrLocalTraj,
+		std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOutsPaths,
+		std::vector&lt;WayPoint&gt;&amp; sampledPoints_debug)
+{
 
- 	return length;
+	if(referencePaths.size()==0) return;
+	if(microPlanDistance &lt;=0 ) return;
+	rollOutsPaths.clear();
 
- }
-
- void PlannerH::GenerateRunoffTrajectory(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; referencePaths,const WayPoint&amp; carPos, const bool&amp; bEnableLaneChange, const double&amp; speed, const double&amp; microPlanDistance,
- 				const double&amp; maxSpeed,const double&amp; minSpeed, const double&amp;  carTipMargin, const double&amp; rollInMargin,
- 				const double&amp; rollInSpeedFactor, const double&amp; pathDensity, const double&amp; rollOutDensity,
- 				const int&amp; rollOutNumber, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight,
- 				const double&amp; SmoothTolerance, const double&amp; speedProfileFactor, const bool&amp; bHeadingSmooth,
- 				const int&amp; iCurrGlobalPath, const int&amp; iCurrLocalTraj,
- 				std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOutsPaths,
- 				std::vector&lt;WayPoint&gt;&amp; sectionPath, std::vector&lt;WayPoint&gt;&amp; sampledPoints)
- {
+	sampledPoints_debug.clear(); //for visualization only
 
-	 if(referencePaths.size()==0) return;
-	 if(microPlanDistance &lt;=0 ) return;
-	 rollOutsPaths.clear();
-	 vector&lt;vector&lt;WayPoint&gt; &gt; referenceSections;
-
-	 if(iCurrGlobalPath &gt; -1 &amp;&amp; iCurrGlobalPath &lt; referencePaths.size())
-	 {
-		 //1- extract current
-		 vector&lt;WayPoint&gt; currExtracted;
-		 vector&lt;WayPoint&gt; sideExtracted;
-
-		 PlanningHelpers::ExtractPartFromPointToDistance(referencePaths.at(iCurrGlobalPath), carPos,
-				 microPlanDistance, pathDensity, currExtracted,
-				 SmoothDataWeight, SmoothWeight, SmoothTolerance);
-
-		 //2- Find Left and Right lane change options Ids
-		 vector&lt;int&gt; sideLanes = PlanningHelpers::GetUniqueLeftRightIds(currExtracted);
-//		 cout &lt;&lt; "Current Global ID: " &lt;&lt; iCurrGlobalPath;
-//		 for(int k=0; k &lt; sideLanes.size(); k++)
-//			 cout &lt;&lt; sideLanes.at(k);
-//		 cout &lt;&lt; endl;
-
-		 for(unsigned int i = 0; i &lt; referencePaths.size(); i++)
-		 {
-			 if(i == iCurrGlobalPath)
-				 referenceSections.push_back(currExtracted);
-			 else
-			 {
-				 sideExtracted.clear();
-				 PlanningHelpers::ExtractPartFromPointToDistance(referencePaths.at(i), carPos,
-						 microPlanDistance, pathDensity, sideExtracted,
-						 SmoothDataWeight, SmoothWeight, SmoothTolerance);
-
-				 double d = 0;
-				 double can_lane_id = 0;
-				 bool bCanChangeLane = false;
-				 for(unsigned int iwp = 1; iwp &lt; sideExtracted.size(); iwp++)
-				 {
-					 d += hypot(sideExtracted.at(iwp).pos.y - sideExtracted.at(iwp-1).pos.y,
-							 sideExtracted.at(iwp).pos.x - sideExtracted.at(iwp-1).pos.x);
-					 if(d &gt; LANE_CHANGE_SMOOTH_FACTOR_DISTANCE)
-					 {
-						 if(PlanningHelpers::FindInList(sideLanes, sideExtracted.at(iwp).laneId) == true)
-						 {
-							 can_lane_id = sideExtracted.at(iwp).laneId;
-							 bCanChangeLane = true;
-							 break;
-						 }
-					 }
-				 }
-
-				 if(bCanChangeLane)
-				 {
-					 referenceSections.push_back(sideExtracted);
-					// cout &lt;&lt; "Can Change To This Lane : " &lt;&lt; can_lane_id  &lt;&lt; ", Index: " &lt;&lt; i &lt;&lt; endl;
-				 }
-				 else
-				 {
-					// cout &lt;&lt; "Skip This Lane Index : " &lt;&lt; i &lt;&lt; endl;
-					 referenceSections.push_back(vector&lt;WayPoint&gt;());
-				 }
-			 }
-		 }
-	 }
-	 else
-	 {
-		 for(unsigned int i = 0; i &lt; referencePaths.size(); i++)
-		 {
-			vector&lt;WayPoint&gt; centerTrajectorySmoothed;
-			 //Get position of the rear axe:
-			 PlanningHelpers::ExtractPartFromPointToDistance(referencePaths.at(i), carPos,
-					 microPlanDistance, pathDensity, centerTrajectorySmoothed,
-					 SmoothDataWeight, SmoothWeight, SmoothTolerance);
-
-			//sectionPath = centerTrajectorySmoothed; // for testing and visualization
-			 referenceSections.push_back(centerTrajectorySmoothed);
-		 }
-	 }
-
-	 for(unsigned int i = 0; i &lt; referenceSections.size(); i++)
-	 {
+	for(unsigned int i = 0; i &lt; referencePaths.size(); i++)
+	{
 		std::vector&lt;std::vector&lt;WayPoint&gt; &gt; local_rollOutPaths;
 		int s_index = 0, e_index = 0;
 		vector&lt;double&gt; e_distances;
-		if(referenceSections.at(i).size()&gt;0)
+		if(referencePaths.at(i).size()&gt;0)
 		{
-			PlanningHelpers::CalculateRollInTrajectories(carPos, speed, referenceSections.at(i), s_index, e_index, e_distances,
+			PlanningHelpers::CalculateRollInTrajectories(carPos, speed, referencePaths.at(i), s_index, e_index, e_distances,
 					local_rollOutPaths, microPlanDistance, maxSpeed, carTipMargin, rollInMargin,
-						 rollInSpeedFactor, pathDensity, rollOutDensity,rollOutNumber,
-						 SmoothDataWeight, SmoothWeight, SmoothTolerance, bHeadingSmooth, sampledPoints);
+					rollInSpeedFactor, pathDensity, rollOutDensity,rollOutNumber,
+					SmoothDataWeight, SmoothWeight, SmoothTolerance, bHeadingSmooth, sampledPoints_debug);
 		}
 		else
 		{
-			for(unsigned int j=0; j&lt; rollOutNumber+1; j++)
+			for(int j=0; j&lt; rollOutNumber+1; j++)
 			{
 				local_rollOutPaths.push_back(vector&lt;WayPoint&gt;());
 			}
 		}
 
 		rollOutsPaths.push_back(local_rollOutPaths);
-	 }
- }
+	}
+}
 
- double PlannerH::PlanUsingDPRandom(const WayPoint&amp; start,
- 		 const double&amp; maxPlanningDistance,
- 		 RoadNetwork&amp; map,
- 		 std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths)
-  {
- 	PlannerHNS::WayPoint* pStart = PlannerHNS::MappingHelpers::GetClosestBackWaypointFromMap(start, map);
-
- 	if(!pStart)
- 	{
- 		GPSPoint sp = start.pos;
- 		cout &lt;&lt; endl &lt;&lt; "Error: PlannerH -&gt; Can't Find Global Waypoint Nodes in the Map for Start (" &lt;&lt;  sp.ToString() &lt;&lt; ")" &lt;&lt; endl;
- 		return 0;
- 	}
-
- 	if(!pStart-&gt;pLane)
- 	{
- 		cout &lt;&lt; endl &lt;&lt; "Error: PlannerH -&gt; Null Lane, Start (" &lt;&lt; pStart-&gt;pLane &lt;&lt; ")" &lt;&lt; endl;
- 		return 0;
- 	}
-
-  	RelativeInfo start_info;
-  	PlanningHelpers::GetRelativeInfo(pStart-&gt;pLane-&gt;points, start, start_info);
-
-  	if(start_info.perp_distance &gt; START_POINT_MAX_DISTANCE)
-  	{
-  		GPSPoint sp = start.pos;
- 		cout &lt;&lt; endl &lt;&lt; "Error: PlannerH -&gt; Start Distance to Lane is: " &lt;&lt; start_info.perp_distance
- 		&lt;&lt; ", Pose: " &lt;&lt; sp.ToString() &lt;&lt; ", LanePose:" &lt;&lt; start_info.perp_point.pos.ToString()
- 		&lt;&lt; ", LaneID: " &lt;&lt; pStart-&gt;pLane-&gt;id &lt;&lt; " -&gt; Check origin and vector map. " &lt;&lt; endl;
-  		return 0;
-  	}
-
-  	vector&lt;WayPoint*&gt; local_cell_to_delete;
-  	WayPoint* pLaneCell = 0;
- 	pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeStraight(pStart, BACKUP_STRAIGHT_PLAN_DISTANCE, local_cell_to_delete);
+double PlannerH::PlanUsingDPRandom(const WayPoint&amp; start,
+		const double&amp; maxPlanningDistance,
+		RoadNetwork&amp; map,
+		std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths)
+{
+	PlannerHNS::WayPoint* pStart = PlannerHNS::MappingHelpers::GetClosestBackWaypointFromMap(start, map);
 
-	if(!pLaneCell)
+	if(!pStart)
 	{
-		cout &lt;&lt; endl &lt;&lt; "PlannerH -&gt; Plan (B) Failed, Sorry we Don't have plan (C) This is the END." &lt;&lt; endl;
+		GPSPoint sp = start.pos;
+		cout &lt;&lt; endl &lt;&lt; "Error: PlannerH -&gt; Can't Find Global Waypoint Nodes in the Map for Start (" &lt;&lt;  sp.ToString() &lt;&lt; ")" &lt;&lt; endl;
 		return 0;
 	}
 
+	if(!pStart-&gt;pLane)
+	{
+		cout &lt;&lt; endl &lt;&lt; "Error: PlannerH -&gt; Null Lane, Start (" &lt;&lt; pStart-&gt;pLane &lt;&lt; ")" &lt;&lt; endl;
+		return 0;
+	}
+
+	RelativeInfo start_info;
+	PlanningHelpers::GetRelativeInfo(pStart-&gt;pLane-&gt;points, start, start_info);
+
+	if(start_info.perp_distance &gt; START_POINT_MAX_DISTANCE)
+	{
+		GPSPoint sp = start.pos;
+		cout &lt;&lt; endl &lt;&lt; "Error: PlannerH -&gt; Start Distance to Lane is: " &lt;&lt; start_info.perp_distance
+				&lt;&lt; ", Pose: " &lt;&lt; sp.ToString() &lt;&lt; ", LanePose:" &lt;&lt; start_info.perp_point.pos.ToString()
+				&lt;&lt; ", LaneID: " &lt;&lt; pStart-&gt;pLane-&gt;id &lt;&lt; " -&gt; Check origin and vector map. " &lt;&lt; endl;
+		return 0;
+	}
 
-  	vector&lt;WayPoint&gt; path;
-  	vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
-  	const std::vector&lt;int&gt; globalPath;
-  	PlanningHelpers::TraversePathTreeBackwards(pLaneCell, pStart, globalPath, path, tempCurrentForwardPathss);
-  	paths.push_back(path);
+	vector&lt;WayPoint*&gt; local_cell_to_delete;
+	WayPoint* pLaneCell = 0;
+	pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeStraight(pStart, maxPlanningDistance, local_cell_to_delete);
+
+	if(!pLaneCell)
+	{
+		cout &lt;&lt; endl &lt;&lt; "PlannerH -&gt; Plan (B) Failed, Sorry we Don't have plan (C) This is the END." &lt;&lt; endl;
+		return 0;
+	}
 
 
-  	cout &lt;&lt; endl &lt;&lt;"Info: PlannerH -&gt; Plan (B) Path With Size (" &lt;&lt; (int)path.size() &lt;&lt; "), MultiPaths No(" &lt;&lt; paths.size() &lt;&lt; ") Extraction Time : " &lt;&lt; endl;
+	vector&lt;WayPoint&gt; path;
+	vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
+	const std::vector&lt;int&gt; globalPath;
+	PlanningHelpers::TraversePathTreeBackwards(pLaneCell, pStart, globalPath, path, tempCurrentForwardPathss);
+	cout &lt;&lt; endl &lt;&lt;"Info: PlannerH -&gt; Plan (B) Path With Size (" &lt;&lt; (int)path.size() &lt;&lt; "), MultiPaths No(" &lt;&lt; paths.size() &lt;&lt; ") Extraction Time : " &lt;&lt; endl;
 
+	//PlanningHelpers::CreateManualBranch(path, 0, FORWARD_RIGHT_DIR);
+	//cout &lt;&lt; "Right Branch Created with Size: " &lt;&lt; path.size()  &lt;&lt; endl;
+	//PlanningHelpers::CreateManualBranch(path, 0, FORWARD_LEFT_DIR);
+	paths.push_back(path);
 
-  	if(path.size()&lt;2)
-  	{
-  		cout &lt;&lt; endl &lt;&lt; "Err: PlannerH -&gt; Invalid Path, Car Should Stop." &lt;&lt; endl;
-  		if(pLaneCell)
-  			DeleteWaypoints(local_cell_to_delete);
-  		return 0 ;
-  	}
+	if(path.size()&lt;2)
+	{
+		cout &lt;&lt; endl &lt;&lt; "Err: PlannerH -&gt; Invalid Path, Car Should Stop." &lt;&lt; endl;
+		if(pLaneCell)
+			DeleteWaypoints(local_cell_to_delete);
+		return 0 ;
+	}
 
-  	if(pLaneCell)
-  		DeleteWaypoints(local_cell_to_delete);
+	if(pLaneCell)
+		DeleteWaypoints(local_cell_to_delete);
 
-  	double totalPlanningDistance = path.at(path.size()-1).cost;
-  	return totalPlanningDistance;
-  }
+	double totalPlanningDistance = path.at(path.size()-1).cost;
+	return totalPlanningDistance;
+}
 
 double PlannerH::PlanUsingDP(const WayPoint&amp; start,
-		 const WayPoint&amp; goalPos,
-		 const double&amp; maxPlanningDistance,
-		 const bool bEnableLaneChange,
-		 const std::vector&lt;int&gt;&amp; globalPath,
-		 RoadNetwork&amp; map,
-		 std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, vector&lt;WayPoint*&gt;* all_cell_to_delete)
- {
+		const WayPoint&amp; goalPos,
+		const double&amp; maxPlanningDistance,
+		const bool bEnableLaneChange,
+		const std::vector&lt;int&gt;&amp; globalPath,
+		RoadNetwork&amp; map,
+		std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, vector&lt;WayPoint*&gt;* all_cell_to_delete)
+{
 	PlannerHNS::WayPoint* pStart = PlannerHNS::MappingHelpers::GetClosestWaypointFromMap(start, map);
 	PlannerHNS::WayPoint* pGoal = PlannerHNS::MappingHelpers::GetClosestWaypointFromMap(goalPos, map);
+	bool bEnableGoalBranching = false;
 
 	if(!pStart ||  !pGoal)
 	{
@@ -322,151 +170,329 @@ double PlannerH::PlanUsingDP(const WayPoint&amp; start,
 		return 0;
 	}
 
- 	RelativeInfo start_info, goal_info;
- 	PlanningHelpers::GetRelativeInfo(pStart-&gt;pLane-&gt;points, start, start_info);
- 	PlanningHelpers::GetRelativeInfo(pGoal-&gt;pLane-&gt;points, goalPos, goal_info);
+	RelativeInfo start_info, goal_info;
+	PlanningHelpers::GetRelativeInfo(pStart-&gt;pLane-&gt;points, start, start_info);
+	PlanningHelpers::GetRelativeInfo(pGoal-&gt;pLane-&gt;points, goalPos, goal_info);
 
- 	if(start_info.perp_distance &gt; START_POINT_MAX_DISTANCE)
- 	{
- 		GPSPoint sp = start.pos;
-		cout &lt;&lt; endl &lt;&lt; "Error: PlannerH -&gt; Start Distance to Lane is: " &lt;&lt; start_info.perp_distance
-		&lt;&lt; ", Pose: " &lt;&lt; sp.ToString() &lt;&lt; ", LanePose:" &lt;&lt; start_info.perp_point.pos.ToString()
-		&lt;&lt; ", LaneID: " &lt;&lt; pStart-&gt;pLane-&gt;id &lt;&lt; " -&gt; Check origin and vector map. " &lt;&lt; endl;
- 		return 0;
- 	}
+	vector&lt;WayPoint&gt; start_path, goal_path;
 
- 	if(goal_info.perp_distance &gt; GOAL_POINT_MAX_DISTANCE)
+	if(fabs(start_info.perp_distance) &gt; START_POINT_MAX_DISTANCE)
 	{
-		GPSPoint gp = goalPos.pos;
-		cout &lt;&lt; endl &lt;&lt; "Error: PlannerH -&gt; Goal Distance to Lane is: " &lt;&lt; goal_info.perp_distance
-		&lt;&lt; ", Pose: " &lt;&lt; gp.ToString() &lt;&lt; ", LanePose:" &lt;&lt; goal_info.perp_point.pos.ToString()
-		&lt;&lt; ", LaneID: " &lt;&lt; pGoal-&gt;pLane-&gt;id &lt;&lt; " -&gt; Check origin and vector map. " &lt;&lt; endl;
-		return 0;
+		//if(fabs(start_info.perp_distance) &gt; 20)
+		{
+			GPSPoint sp = start.pos;
+			cout &lt;&lt; endl &lt;&lt; "Error: PlannerH -&gt; Start Distance to Lane is: " &lt;&lt; start_info.perp_distance
+					&lt;&lt; ", Pose: " &lt;&lt; sp.ToString() &lt;&lt; ", LanePose:" &lt;&lt; start_info.perp_point.pos.ToString()
+					&lt;&lt; ", LaneID: " &lt;&lt; pStart-&gt;pLane-&gt;id &lt;&lt; " -&gt; Check origin and vector map. " &lt;&lt; endl;
+			return 0;
+		}
+		// 		else
+		// 		{
+		// 			//PlanUsingReedShepp(start, *pStart, start_path, 1.0, 1);
+		// 		}
+	}
+
+	if(fabs(goal_info.perp_distance) &gt; GOAL_POINT_MAX_DISTANCE)
+	{
+		if(fabs(start_info.perp_distance) &gt; 20)
+		{
+			GPSPoint gp = goalPos.pos;
+			cout &lt;&lt; endl &lt;&lt; "Error: PlannerH -&gt; Goal Distance to Lane is: " &lt;&lt; goal_info.perp_distance
+					&lt;&lt; ", Pose: " &lt;&lt; gp.ToString() &lt;&lt; ", LanePose:" &lt;&lt; goal_info.perp_point.pos.ToString()
+					&lt;&lt; ", LaneID: " &lt;&lt; pGoal-&gt;pLane-&gt;id &lt;&lt; " -&gt; Check origin and vector map. " &lt;&lt; endl;
+			return 0;
+		}
+		else
+		{
+			WayPoint wp = *pGoal;
+			wp.pos.x = (goalPos.pos.x+pGoal-&gt;pos.x)/2.0;
+			wp.pos.y = (goalPos.pos.y+pGoal-&gt;pos.y)/2.0;
+			goal_path.push_back(wp);
+			goal_path.push_back(goalPos);
+		}
 	}
 
- 	vector&lt;WayPoint*&gt; local_cell_to_delete;
- 	WayPoint* pLaneCell = 0;
- 	char bPlan = 'A';
+	vector&lt;WayPoint*&gt; local_cell_to_delete;
+	WayPoint* pLaneCell = 0;
+	char bPlan = 'A';
 
- 	if(all_cell_to_delete)
- 		pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeV2(pStart, *pGoal, globalPath, maxPlanningDistance,bEnableLaneChange, *all_cell_to_delete);
- 	else
- 		pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeV2(pStart, *pGoal, globalPath, maxPlanningDistance,bEnableLaneChange, local_cell_to_delete);
+	if(all_cell_to_delete)
+		pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeV2(pStart, *pGoal, globalPath, maxPlanningDistance,bEnableLaneChange, *all_cell_to_delete);
+	else
+		pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeV2(pStart, *pGoal, globalPath, maxPlanningDistance,bEnableLaneChange, local_cell_to_delete);
 
- 	if(!pLaneCell)
- 	{
- 		bPlan = 'B';
- 		cout &lt;&lt; endl &lt;&lt; "PlannerH -&gt; Plan (A) Failed, Trying Plan (B)." &lt;&lt; endl;
+	if(!pLaneCell)
+	{
+		bPlan = 'B';
+		cout &lt;&lt; endl &lt;&lt; "PlannerH -&gt; Plan (A) Failed, Trying Plan (B)." &lt;&lt; endl;
 
- 		if(all_cell_to_delete)
- 		 	pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeStraight(pStart, BACKUP_STRAIGHT_PLAN_DISTANCE, *all_cell_to_delete);
+		if(all_cell_to_delete)
+			pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeStraight(pStart, BACKUP_STRAIGHT_PLAN_DISTANCE, *all_cell_to_delete);
 		else
 			pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeStraight(pStart, BACKUP_STRAIGHT_PLAN_DISTANCE, local_cell_to_delete);
 
- 		if(!pLaneCell)
- 		{
- 			bPlan = 'Z';
- 			cout &lt;&lt; endl &lt;&lt; "PlannerH -&gt; Plan (B) Failed, Sorry we Don't have plan (C) This is the END." &lt;&lt; endl;
- 			return 0;
- 		}
- 	}
-
- 	vector&lt;WayPoint&gt; path;
- 	vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
- 	PlanningHelpers::TraversePathTreeBackwards(pLaneCell, pStart, globalPath, path, tempCurrentForwardPathss);
- 	if(bPlan == 'A')
- 	{
- 		PlanningHelpers::ExtractPlanAlernatives(path, paths);
- 	}
- 	else if (bPlan == 'B')
- 	{
+		if(!pLaneCell)
+		{
+			bPlan = 'Z';
+			cout &lt;&lt; endl &lt;&lt; "PlannerH -&gt; Plan (B) Failed, Sorry we Don't have plan (C) This is the END." &lt;&lt; endl;
+			return 0;
+		}
+	}
+
+	vector&lt;WayPoint&gt; path;
+	vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
+	PlanningHelpers::TraversePathTreeBackwards(pLaneCell, pStart, globalPath, path, tempCurrentForwardPathss);
+	if(path.size()==0) return 0;
+
+	paths.clear();
+
+	if(bPlan == 'A')
+	{
+		PlanningHelpers::ExtractPlanAlernatives(path, paths);
+	}
+	else if (bPlan == 'B')
+	{
 		paths.push_back(path);
- 	}
+	}
+
+	//attach start path to beginning of all paths, but goal path to only the path connected to the goal path.
+	for(unsigned int i=0; i&lt; paths.size(); i++ )
+	{
+		paths.at(i).insert(paths.at(i).begin(), start_path.begin(), start_path.end());
+		if(paths.at(i).size() &gt; 0)
+		{
+			//if(hypot(paths.at(i).at(paths.at(i).size()-1).pos.y-goal_info.perp_point.pos.y, paths.at(i).at(paths.at(i).size()-1).pos.x-goal_info.perp_point.pos.x) &lt; 1.5)
+			{
+
+				if(paths.at(i).size() &gt; 0 &amp;&amp; goal_path.size() &gt; 0)
+				{
+					goal_path.insert(goal_path.begin(), paths.at(i).end()-5, paths.at(i).end());
+					PlanningHelpers::SmoothPath(goal_path, 0.25, 0.25);
+					PlanningHelpers::FixPathDensity(goal_path, 0.75);
+					PlanningHelpers::SmoothPath(goal_path, 0.25, 0.35);
+					paths.at(i).erase(paths.at(i).end()-5, paths.at(i).end());
+					paths.at(i).insert(paths.at(i).end(), goal_path.begin(), goal_path.end());
+				}
+			}
+		}
+	}
 
- 	cout &lt;&lt; endl &lt;&lt;"Info: PlannerH -&gt; Plan (" &lt;&lt; bPlan &lt;&lt; ") Path With Size (" &lt;&lt; (int)path.size() &lt;&lt; "), MultiPaths No(" &lt;&lt; paths.size() &lt;&lt; ") Extraction Time : " &lt;&lt; endl;
+	cout &lt;&lt; endl &lt;&lt;"Info: PlannerH -&gt; Plan (" &lt;&lt; bPlan &lt;&lt; ") Path With Size (" &lt;&lt; (int)path.size() &lt;&lt; "), MultiPaths No(" &lt;&lt; paths.size() &lt;&lt; ") Extraction Time : " &lt;&lt; endl;
 
 
- 	if(path.size()&lt;2)
- 	{
- 		cout &lt;&lt; endl &lt;&lt; "Err: PlannerH -&gt; Invalid Path, Car Should Stop." &lt;&lt; endl;
- 		if(pLaneCell &amp;&amp; !all_cell_to_delete)
- 			DeleteWaypoints(local_cell_to_delete);
- 		return 0 ;
- 	}
+	if(path.size()&lt;2)
+	{
+		cout &lt;&lt; endl &lt;&lt; "Err: PlannerH -&gt; Invalid Path, Car Should Stop." &lt;&lt; endl;
+		if(pLaneCell &amp;&amp; !all_cell_to_delete)
+			DeleteWaypoints(local_cell_to_delete);
+		return 0 ;
+	}
 
- 	if(pLaneCell &amp;&amp; !all_cell_to_delete)
- 		DeleteWaypoints(local_cell_to_delete);
+	if(pLaneCell &amp;&amp; !all_cell_to_delete)
+		DeleteWaypoints(local_cell_to_delete);
 
- 	double totalPlanningDistance = path.at(path.size()-1).cost;
- 	return totalPlanningDistance;
- }
+	double totalPlanningDistance = path.at(path.size()-1).cost;
+	return totalPlanningDistance;
+}
 
- double PlannerH::PredictPlanUsingDP(Lane* l, const WayPoint&amp; start, const double&amp; maxPlanningDistance,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths)
-  {
-  	if(!l)
-  	{
-  		cout &lt;&lt;endl&lt;&lt; "Err: PredictPlanUsingDP, PlannerH -&gt; Null Lane !!" &lt;&lt; endl;
-  		return 0;
-  	}
-
-  	WayPoint carPos = start;
-  	vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
-  	vector&lt;WayPoint*&gt; all_cell_to_delete;
-  	vector&lt;int&gt; globalPath;
-
-  	RelativeInfo info;
-  	PlanningHelpers::GetRelativeInfo(l-&gt;points, carPos, info);
-  	WayPoint closest_p = l-&gt;points.at(info.iBack);
-  	WayPoint* pStartWP = &amp;l-&gt;points.at(info.iBack);
-
-  	if(distance2points(closest_p.pos, carPos.pos) &gt; 8)
-  	{
- 		cout &lt;&lt;endl&lt;&lt; "Err: PredictiveDP PlannerH -&gt; Distance to Lane is: " &lt;&lt; distance2points(closest_p.pos, carPos.pos)
- 		&lt;&lt; ", Pose: " &lt;&lt; carPos.pos.ToString() &lt;&lt; ", LanePose:" &lt;&lt; closest_p.pos.ToString()
- 		&lt;&lt; ", LaneID: " &lt;&lt; l-&gt;id &lt;&lt; " -&gt; Check origin and vector map. " &lt;&lt; endl;
-  		return 0;
-  	}
-
-  	vector&lt;WayPoint*&gt; pLaneCells;
-  	int nPaths =  PlanningHelpers::PredictiveDP(pStartWP, maxPlanningDistance, all_cell_to_delete, pLaneCells);
-
-  	if(nPaths==0)
-  	{
-  		cout &lt;&lt;endl&lt;&lt; "Err PlannerH -&gt; Null Tree Head." &lt;&lt; endl;
-  		return 0;
-  	}
-
-  	double totalPlanDistance  = 0;
-  	for(unsigned int i = 0; i&lt; pLaneCells.size(); i++)
-  	{
-  		std::vector&lt;WayPoint&gt; path;
-  		PlanningHelpers::TraversePathTreeBackwards(pLaneCells.at(i), pStartWP, globalPath, path, tempCurrentForwardPathss);
-  		if(path.size()&gt;0)
-  			totalPlanDistance+= path.at(path.size()-1).cost;
-
-  		PlanningHelpers::FixPathDensity(path, 0.5);
-  		PlanningHelpers::SmoothPath(path, 0.3 , 0.3,0.1);
-
-  		paths.push_back(path);
-  	}
-
-  	DeleteWaypoints(all_cell_to_delete);
-
-  	return totalPlanDistance;
-  }
-
- void PlannerH::DeleteWaypoints(vector&lt;WayPoint*&gt;&amp; wps)
- {
- 	for(unsigned int i=0; i&lt;wps.size(); i++)
- 	{
- 		if(wps.at(i))
- 		{
- 			delete wps.at(i);
- 			wps.at(i) = 0;
- 		}
- 	}
- 	wps.clear();
- }
+double PlannerH::PredictPlanUsingDP(Lane* l, const WayPoint&amp; start, const double&amp; maxPlanningDistance, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths)
+{
+	if(!l)
+	{
+		cout &lt;&lt;endl&lt;&lt; "Err: PredictPlanUsingDP, PlannerH -&gt; Null Lane !!" &lt;&lt; endl;
+		return 0;
+	}
+
+	WayPoint carPos = start;
+	vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
+	vector&lt;WayPoint*&gt; all_cell_to_delete;
+	vector&lt;int&gt; globalPath;
+
+	RelativeInfo info;
+	PlanningHelpers::GetRelativeInfo(l-&gt;points, carPos, info);
+	WayPoint closest_p = l-&gt;points.at(info.iBack);
+	WayPoint* pStartWP = &amp;l-&gt;points.at(info.iBack);
+
+	if(distance2points(closest_p.pos, carPos.pos) &gt; 8)
+	{
+		cout &lt;&lt;endl&lt;&lt; "Err: PredictiveDP PlannerH -&gt; Distance to Lane is: " &lt;&lt; distance2points(closest_p.pos, carPos.pos)
+ 				&lt;&lt; ", Pose: " &lt;&lt; carPos.pos.ToString() &lt;&lt; ", LanePose:" &lt;&lt; closest_p.pos.ToString()
+ 				&lt;&lt; ", LaneID: " &lt;&lt; l-&gt;id &lt;&lt; " -&gt; Check origin and vector map. " &lt;&lt; endl;
+		return 0;
+	}
+
+	vector&lt;WayPoint*&gt; pLaneCells;
+	int nPaths =  PlanningHelpers::PredictiveDP(pStartWP, maxPlanningDistance, all_cell_to_delete, pLaneCells);
+
+	if(nPaths==0)
+	{
+		cout &lt;&lt;endl&lt;&lt; "Err PlannerH -&gt; Null Tree Head." &lt;&lt; endl;
+		return 0;
+	}
+
+	double totalPlanDistance  = 0;
+	for(unsigned int i = 0; i&lt; pLaneCells.size(); i++)
+	{
+		std::vector&lt;WayPoint&gt; path;
+		PlanningHelpers::TraversePathTreeBackwards(pLaneCells.at(i), pStartWP, globalPath, path, tempCurrentForwardPathss);
+		if(path.size()&gt;0)
+			totalPlanDistance+= path.at(path.size()-1).cost;
+
+		PlanningHelpers::FixPathDensity(path, 0.5);
+		PlanningHelpers::SmoothPath(path, 0.3 , 0.3,0.1);
+		PlanningHelpers::CalcAngleAndCost(path);
+
+		paths.push_back(path);
+	}
+
+	DeleteWaypoints(all_cell_to_delete);
+
+	return totalPlanDistance;
+}
+
+double PlannerH::PredictTrajectoriesUsingDP(const WayPoint&amp; startPose, std::vector&lt;WayPoint*&gt; closestWPs, const double&amp; maxPlanningDistance, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, const bool&amp; bFindBranches , const bool bDirectionBased)
+{
+	vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
+	vector&lt;WayPoint*&gt; all_cell_to_delete;
+	vector&lt;int&gt; globalPath;
+
+	vector&lt;WayPoint*&gt; pLaneCells;
+	vector&lt;int&gt; unique_lanes;
+	std::vector&lt;WayPoint&gt; path;
+	for(unsigned int j = 0 ; j &lt; closestWPs.size(); j++)
+	{
+		pLaneCells.clear();
+		int nPaths =  PlanningHelpers::PredictiveIgnorIdsDP(closestWPs.at(j), maxPlanningDistance, all_cell_to_delete, pLaneCells, unique_lanes);
+		for(unsigned int i = 0; i&lt; pLaneCells.size(); i++)
+		{
+			path.clear();
+			PlanningHelpers::TraversePathTreeBackwards(pLaneCells.at(i), closestWPs.at(j), globalPath, path, tempCurrentForwardPathss);
+
+			for(unsigned int k = 0; k&lt; path.size(); k++)
+			{
+				bool bFoundLaneID = false;
+				for(unsigned int l_id = 0 ; l_id &lt; unique_lanes.size(); l_id++)
+				{
+					if(path.at(k).laneId == unique_lanes.at(l_id))
+					{
+						bFoundLaneID = true;
+						break;
+					}
+				}
+
+				if(!bFoundLaneID)
+					unique_lanes.push_back(path.at(k).laneId);
+			}
+
+			if(path.size()&gt;0)
+			{
+				path.insert(path.begin(), startPose);
+				if(!bDirectionBased)
+					path.at(0).pos.a = path.at(1).pos.a;
+
+				PlanningHelpers::FixPathDensity(path, 1.0);
+				PlanningHelpers::SmoothPath(path, 0.3 , 0.3,0.1);
+				paths.push_back(path);
+			}
+		}
+	}
+
+	if(bDirectionBased &amp;&amp; bFindBranches)
+	{
+		WayPoint p1, p2;
+		if(paths.size()&gt; 0 &amp;&amp; paths.at(0).size() &gt; 0)
+			p2 = p1 = paths.at(0).at(0);
+		else
+			p2 = p1 = startPose;
+
+		p2.pos.y = p1.pos.y + maxPlanningDistance*0.5*sin(p1.pos.a);
+		p2.pos.x = p1.pos.x + maxPlanningDistance*0.5*cos(p1.pos.a);
+
+		vector&lt;WayPoint&gt; l_branch;
+		vector&lt;WayPoint&gt; r_branch;
+
+		PlanningHelpers::CreateManualBranchFromTwoPoints(p1, p2, maxPlanningDistance*0.75, FORWARD_RIGHT_DIR,r_branch);
+		PlanningHelpers::CreateManualBranchFromTwoPoints(p1, p2, maxPlanningDistance*0.75, FORWARD_LEFT_DIR, l_branch);
+
+		paths.push_back(l_branch);
+		paths.push_back(r_branch);
+	}
+
+	DeleteWaypoints(all_cell_to_delete);
+
+	return 1;
+}
+
+double PlannerH::PredictPlanUsingDP(const WayPoint&amp; startPose, WayPoint* closestWP, const double&amp; maxPlanningDistance, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, const bool&amp; bFindBranches)
+{
+	if(!closestWP || !closestWP-&gt;pLane)
+	{
+		cout &lt;&lt;endl&lt;&lt; "Err: PredictPlanUsingDP, PlannerH -&gt; Null Lane !!" &lt;&lt; endl;
+		return 0;
+	}
+
+	vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
+	vector&lt;WayPoint*&gt; all_cell_to_delete;
+	vector&lt;int&gt; globalPath;
+
+	vector&lt;WayPoint*&gt; pLaneCells;
+	int nPaths =  PlanningHelpers::PredictiveDP(closestWP, maxPlanningDistance, all_cell_to_delete, pLaneCells);
+
+	if(nPaths==0)
+	{
+		cout &lt;&lt;endl&lt;&lt; "Err PlannerH -&gt; Null Tree Head." &lt;&lt; endl;
+		return 0;
+	}
+
+	double totalPlanDistance  = 0;
+	for(unsigned int i = 0; i&lt; pLaneCells.size(); i++)
+	{
+		std::vector&lt;WayPoint&gt; path;
+		PlanningHelpers::TraversePathTreeBackwards(pLaneCells.at(i), closestWP, globalPath, path, tempCurrentForwardPathss);
+		if(path.size()&gt;0)
+		{
+			totalPlanDistance+= path.at(path.size()-1).cost;
+			path.insert(path.begin(), startPose);
+			//path.at(0).pos.a = path.at(1).pos.a;;
+		}
+
+
+		PlanningHelpers::FixPathDensity(path, 0.5);
+		PlanningHelpers::SmoothPath(path, 0.3 , 0.3,0.1);
+		paths.push_back(path);
+
+		if(bFindBranches)
+		{
+			int max_branch_index = path.size() &gt; 5 ? 5 : path.size();
+			vector&lt;WayPoint&gt; l_branch;
+			vector&lt;WayPoint&gt; r_branch;
+			l_branch.insert(l_branch.begin(), path.begin(), path.begin()+5);
+			r_branch.insert(r_branch.begin(), path.begin(), path.begin()+5);
+
+			PlanningHelpers::CreateManualBranch(r_branch, 0, FORWARD_RIGHT_DIR);
+			PlanningHelpers::CreateManualBranch(l_branch, 0, FORWARD_LEFT_DIR);
+
+			paths.push_back(l_branch);
+			paths.push_back(r_branch);
+		}
+	}
+
+	DeleteWaypoints(all_cell_to_delete);
+
+	return totalPlanDistance;
+}
+
+void PlannerH::DeleteWaypoints(vector&lt;WayPoint*&gt;&amp; wps)
+{
+	for(unsigned int i=0; i&lt;wps.size(); i++)
+	{
+		if(wps.at(i))
+		{
+			delete wps.at(i);
+			wps.at(i) = 0;
+		}
+	}
+	wps.clear();
+}
 
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlanningHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlanningHelpers.cpp" added_lines="557" deleted_lines="59">
				<diff>@@ -20,6 +20,7 @@ using namespace std;
 namespace PlannerHNS {
 
 
+std::vector&lt;std::pair&lt;GPSPoint, GPSPoint&gt; &gt; PlanningHelpers::m_TestingClosestPoint;
 
 PlanningHelpers::PlanningHelpers()
 {
@@ -83,6 +84,7 @@ bool PlanningHelpers::GetRelativeInfoRange(const std::vector&lt;std::vector&lt;WayPoin
 	return true;
 }
 
+
 bool PlanningHelpers::GetRelativeInfo(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, RelativeInfo&amp; info, const int&amp; prevIndex )
 {
 	if(trajectory.size() &lt; 2) return false;
@@ -99,7 +101,11 @@ bool PlanningHelpers::GetRelativeInfo(const std::vector&lt;WayPoint&gt;&amp; trajectory, c
 	}
 	else
 	{
-		info.iFront = GetClosestNextPointIndex(trajectory, p, prevIndex);
+		info.iFront = GetClosestNextPointIndexFast(trajectory, p, prevIndex);
+//		WayPoint p2 = p;
+//		int old_index = GetClosestNextPointIndex(trajectory, p2, prevIndex);
+//		if(old_index != info.iFront)
+//			cout &lt;&lt; " Alert Alert !!!! fast: " &lt;&lt; info.iFront &lt;&lt; ", slow: " &lt;&lt; old_index  &lt;&lt; endl;
 
 		if(info.iFront &gt; 0)
 			info.iBack = info.iFront -1;
@@ -157,6 +163,49 @@ bool PlanningHelpers::GetRelativeInfo(const std::vector&lt;WayPoint&gt;&amp; trajectory, c
 	return true;
 }
 
+bool PlanningHelpers::GetThreePointsInfo(const WayPoint&amp; p0, const WayPoint&amp; p1, const WayPoint&amp; p2, WayPoint&amp; perp_p, double&amp; long_d, double lat_d)
+{
+
+	if(p0.pos.x == p1.pos.x &amp;&amp; p0.pos.y == p1.pos.y) return false;
+	if(p0.pos.x == p2.pos.x &amp;&amp; p0.pos.y == p2.pos.y) return false;
+	if(p1.pos.x == p2.pos.x &amp;&amp; p1.pos.y == p2.pos.y) return false;
+
+	perp_p = p1;
+	WayPoint first_p = p0;
+	double angle_x = atan2(p1.pos.y-p0.pos.y, p1.pos.x-p0.pos.x);
+
+	Mat3 rotationMat(-angle_x);
+	Mat3 translationMat(-p2.pos.x, -p2.pos.y);
+	Mat3 invRotationMat(angle_x);
+	Mat3 invTranslationMat(p2.pos.x, p2.pos.y);
+
+	first_p.pos = translationMat*first_p.pos;
+	first_p.pos = rotationMat*first_p.pos;
+
+	perp_p.pos = translationMat*perp_p.pos;
+	perp_p.pos = rotationMat*perp_p.pos;
+
+	if(perp_p.pos.x-first_p.pos.x == 0) return false;
+
+	double m = (perp_p.pos.y-first_p.pos.y)/(perp_p.pos.x-first_p.pos.x);
+	lat_d = perp_p.pos.y - m*perp_p.pos.x; // solve for x = 0
+
+	if(isnan(lat_d) || isinf(lat_d)) return false;
+
+	if(perp_p.pos.x &lt; 0)
+		return false;
+
+	perp_p.pos.x = 0; // on the same y axis of the car
+	perp_p.pos.y = lat_d; //perp distance between the car and the trajectory
+
+	perp_p.pos = invRotationMat  * perp_p.pos;
+	perp_p.pos = invTranslationMat  * perp_p.pos;
+
+	long_d = hypot(perp_p.pos.y - first_p.pos.y, perp_p.pos.x - first_p.pos.x);
+
+	return true;
+}
+
 WayPoint PlanningHelpers::GetFollowPointOnTrajectory(const std::vector&lt;WayPoint&gt;&amp; trajectory, const RelativeInfo&amp; init_p, const double&amp; distance, unsigned int&amp; point_index)
 {
 	WayPoint follow_point;
@@ -173,7 +222,7 @@ WayPoint PlanningHelpers::GetFollowPointOnTrajectory(const std::vector&lt;WayPoint&gt;
 		follow_point.pos.y = init_p.perp_point.pos.y + distance * sin(follow_point.pos.a);
 	}
 	//condition 2, if far after the last point on the trajectory
-	else if(init_p.iFront == trajectory.size() -1)
+	else if(init_p.iFront == (int)trajectory.size() - 1)
 	{
 		follow_point = trajectory.at(init_p.iFront);
 		follow_point.pos.x = init_p.perp_point.pos.x + distance * cos(follow_point.pos.a);
@@ -182,7 +231,7 @@ WayPoint PlanningHelpers::GetFollowPointOnTrajectory(const std::vector&lt;WayPoint&gt;
 	else
 	{
 		double d = init_p.to_front_distance;
-		while(local_i &lt; trajectory.size()-1 &amp;&amp; d &lt; distance)
+		while(local_i &lt; (int)trajectory.size()-1 &amp;&amp; d &lt; distance)
 		{
 			local_i++;
 			d += hypot(trajectory.at(local_i).pos.y - trajectory.at(local_i-1).pos.y, trajectory.at(local_i).pos.x - trajectory.at(local_i-1).pos.x);
@@ -211,7 +260,7 @@ double PlanningHelpers::GetExactDistanceOnTrajectory(const std::vector&lt;WayPoint&gt;
 	else if(p2.iBack &gt;= p1.iFront)
 	{
 		double d_on_path = p1.to_front_distance + p2.from_back_distance;
-		for(unsigned int i = p1.iFront; i &lt; p2.iBack; i++)
+		for(int i = p1.iFront; i &lt; p2.iBack; i++)
 			d_on_path += hypot(trajectory.at(i+1).pos.y - trajectory.at(i).pos.y, trajectory.at(i+1).pos.x - trajectory.at(i).pos.x);
 
 		return d_on_path;
@@ -219,7 +268,7 @@ double PlanningHelpers::GetExactDistanceOnTrajectory(const std::vector&lt;WayPoint&gt;
 	else if(p2.iFront &lt;= p1.iBack)
 	{
 		double d_on_path = p1.from_back_distance + p2.to_front_distance;
-		for(unsigned int i = p2.iFront; i &lt; p1.iBack; i++)
+		for(int i = p2.iFront; i &lt; p1.iBack; i++)
 			d_on_path += hypot(trajectory.at(i+1).pos.y - trajectory.at(i).pos.y, trajectory.at(i+1).pos.x - trajectory.at(i).pos.x);
 
 		return -d_on_path;
@@ -230,7 +279,7 @@ double PlanningHelpers::GetExactDistanceOnTrajectory(const std::vector&lt;WayPoint&gt;
 	}
 }
 
-int PlanningHelpers::GetClosestNextPointIndex(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex )
+int PlanningHelpers::GetClosestNextPointIndex_obsolete(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex )
 {
 	if(trajectory.size() == 0 || prevIndex &lt; 0) return 0;
 
@@ -247,14 +296,18 @@ int PlanningHelpers::GetClosestNextPointIndex(const vector&lt;WayPoint&gt;&amp; trajectory
 		}
 	}
 
+//	cout &lt;&lt; "Slow=&gt; Start: " &lt;&lt; 0;
+//	cout &lt;&lt; ", End: " &lt;&lt; trajectory.size();
+//	cout &lt;&lt; ", Minimum Before: " &lt;&lt; min_index;
+
 	if(min_index &lt; (int)trajectory.size()-2)
 	{
 		GPSPoint curr, next;
 		curr = trajectory.at(min_index).pos;
 		next = trajectory.at(min_index+1).pos;
-		POINT2D v_1(p.pos.x - curr.x   ,p.pos.y - curr.y);
+		GPSPoint v_1(p.pos.x - curr.x   ,p.pos.y - curr.y,0,0);
 		double norm1 = pointNorm(v_1);
-		POINT2D v_2(next.x - curr.x,next.y - curr.y);
+		GPSPoint v_2(next.x - curr.x,next.y - curr.y,0,0);
 		double norm2 = pointNorm(v_2);
 		double dot_pro = v_1.x*v_2.x + v_1.y*v_2.y;
 		double a = UtilityH::FixNegativeAngle(acos(dot_pro/(norm1*norm2)));
@@ -262,20 +315,220 @@ int PlanningHelpers::GetClosestNextPointIndex(const vector&lt;WayPoint&gt;&amp; trajectory
 			min_index = min_index+1;
 	}
 
+//	cout &lt;&lt; ", Minimum After: " &lt;&lt; min_index &lt;&lt; ", Big O: " &lt;&lt; trajectory.size() &lt;&lt; endl;
+
 	return min_index;
 }
 
-int PlanningHelpers::GetClosestNextPointIndexDirection(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex )
+int PlanningHelpers::GetClosestNextPointIndexFastV2(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex)
 {
-	if(trajectory.size() == 0 || prevIndex &lt; 0) return 0;
+
+	int size = (int)trajectory.size();
+
+		if(size &lt; 2 || prevIndex &lt; 0) return 0;
+
+		double d = 0, minD = 9999999999;
+
+
+		double resolution = hypot(trajectory[1].pos.y -trajectory[0].pos.y , trajectory[1].pos.x -trajectory[0].pos.x);
+		double d_to_zero = hypot(p.pos.y -trajectory[0].pos.y , p.pos.x - trajectory[0].pos.x);
+		double d_to_size = hypot(trajectory[size-1].pos.y - p.pos.y , trajectory[size-1].pos.x - p.pos.x);
+
+		int iStart = d_to_zero / resolution;
+		WayPoint perp_p;
+		double lat_d = 0;
+		double long_d = 0;
+
+		if(iStart &gt; 0 &amp;&amp; iStart &lt; size-1 &amp;&amp;  GetThreePointsInfo(trajectory.at(0), trajectory.at(iStart), p, perp_p, long_d, lat_d))
+		{
+	//		m_TestingClosestPoint.push_back(make_pair(trajectory.at(0).pos, p.pos));
+	//		m_TestingClosestPoint.push_back(make_pair(trajectory.at(iStart).pos, p.pos));
+			iStart = long_d / resolution;
+		}
+
+		if(iStart&gt;0)
+			iStart--;
+
+		int iEnd = size - (d_to_size / resolution);
+
+		if(iEnd &gt;= 0 &amp;&amp; iEnd &lt; size-2 &amp;&amp;  GetThreePointsInfo(trajectory.at(size-1), trajectory.at(iEnd), p, perp_p, long_d, lat_d))
+		{
+	//		m_TestingClosestPoint.push_back(make_pair(trajectory.at(size-1).pos, p.pos));
+	//		m_TestingClosestPoint.push_back(make_pair(trajectory.at(iEnd).pos, p.pos));
+			iEnd = size - (long_d / resolution);
+		}
+
+		if(iEnd &lt; size-1)
+			iEnd++;
+
+	//	cout &lt;&lt; "Fast=&gt;";
+	//	cout &lt;&lt; " Start: " &lt;&lt; iStart;
+	//	cout &lt;&lt; ", End: " &lt;&lt; iEnd;
+
+		double d_from_start = d_to_zero;
+		if(iStart &lt; size)
+			d_from_start = hypot(trajectory[iStart].pos.y - p.pos.y , trajectory[iStart].pos.x - p.pos.x);
+
+		double d_from_end = d_to_size;
+		if(iEnd &gt;= 0)
+			d_from_end = hypot(trajectory[iEnd].pos.y - p.pos.y , trajectory[iEnd].pos.x - p.pos.x);
+
+		if(iStart &gt;= size &amp;&amp; iEnd &lt; 0)
+		{
+			if(d_to_zero &lt; d_to_size)
+			{
+				iStart = 0;
+				iEnd = size/2 -1;
+			}
+			else
+			{
+				iStart = size/2;
+				iEnd = size - 1;
+			}
+		}
+		else
+		{
+			if(iStart &gt;=size || (d_from_start &gt; d_to_zero))
+				iStart = 0;
+
+			if(iEnd &lt; 0 || (d_from_end &gt; d_to_size))
+				iEnd = size-1;
+		}
+
+		if(iStart &gt; iEnd)
+			iEnd = size-1;
+
+		int min_index  =  iStart;
+
+		int ncout = 0;
+		for(int i=iStart; i&lt;= iEnd; i++)
+		{
+			d  = distance2pointsSqr(trajectory[i].pos, p.pos);
+			if(d &lt; minD)
+			{
+				min_index = i;
+				minD = d;
+			}
+			ncout++;
+		}
+
+	//	cout &lt;&lt; ", Minimum Before: " &lt;&lt; min_index;
+
+		if(min_index &lt; size-2)
+		{
+			GPSPoint curr, next;
+			curr = trajectory[min_index].pos;
+			next = trajectory[min_index+1].pos;
+			GPSPoint v_1(p.pos.x - curr.x   ,p.pos.y - curr.y,0,0);
+			double norm1 = pointNorm(v_1);
+			GPSPoint v_2(next.x - curr.x,next.y - curr.y,0,0);
+			double norm2 = pointNorm(v_2);
+			double dot_pro = v_1.x*v_2.x + v_1.y*v_2.y;
+			double a = UtilityH::FixNegativeAngle(acos(dot_pro/(norm1*norm2)));
+			if(a &lt;= M_PI_2)
+				min_index = min_index+1;
+		}
+
+	//	m_TestingClosestPoint.push_back(make_pair(trajectory.at(min_index).pos, p.pos));
+
+	//	cout &lt;&lt; ", Minimum After: " &lt;&lt; min_index &lt;&lt; ", Big O: " &lt;&lt; ncout &lt;&lt; endl;
+	//	cout &lt;&lt; "d_zero: " &lt;&lt; d_to_zero &lt;&lt; ", d_start: " &lt;&lt; d_from_start &lt;&lt; endl;
+	//	cout &lt;&lt; "d_size: " &lt;&lt; d_to_size &lt;&lt; ", d_end: " &lt;&lt; d_from_end &lt;&lt; endl;
+		return min_index;
+
+
+}
+
+int PlanningHelpers::GetClosestNextPointIndexFast(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex )
+{
+	int size = (int)trajectory.size();
+
+		if(size &lt; 2 || prevIndex &lt; 0) return 0;
+
+		double d = 0, minD = 9999999999;
+		int min_index  = prevIndex;
+		int iStart = prevIndex;
+		int iEnd = size;
+		double resolution = hypot(trajectory[1].pos.y -trajectory[0].pos.y , trajectory[1].pos.x -trajectory[0].pos.x);
+
+		//divide every 5 meters
+		int skip_factor = 5;
+		int skip = skip_factor/resolution;
+
+		for(int i=0; i&lt; size; i+=skip)
+		{
+			if(i+skip/2 &lt; size)
+				d  = (distance2pointsSqr(trajectory[i].pos, p.pos) + distance2pointsSqr(trajectory[i+skip/2].pos, p.pos))/2.0;
+			else
+				d  = distance2pointsSqr(trajectory[i].pos, p.pos);
+			if(d &lt; minD)
+			{
+				iStart = i-skip;
+				iEnd = i+skip;
+				minD = d;
+				min_index = i;
+			}
+		}
+
+		if((size - skip/2 - 1) &gt; 0)
+			d  = (distance2pointsSqr(trajectory[size-1].pos, p.pos) + distance2pointsSqr(trajectory[size - skip/2 -1 ].pos, p.pos))/2.0;
+		else
+			d  = distance2pointsSqr(trajectory[size-1].pos, p.pos);
+
+		if(d &lt; minD)
+		{
+			iStart = size-skip;
+			iEnd = size+skip;
+			minD = d;
+			min_index = size-1;
+		}
+
+		if(iStart &lt; 0) iStart = 0;
+		if(iEnd &gt;= size) iEnd = size -1;
+
+		for(int i=iStart; i&lt; iEnd; i++)
+		{
+			d  = distance2pointsSqr(trajectory[i].pos, p.pos);
+			if(d &lt; minD)
+			{
+				min_index = i;
+				minD = d;
+			}
+		}
+
+		if(min_index &lt; size-2)
+		{
+			GPSPoint curr, next;
+			curr = trajectory[min_index].pos;
+			next = trajectory[min_index+1].pos;
+			GPSPoint v_1(p.pos.x - curr.x   ,p.pos.y - curr.y,0,0);
+			double norm1 = pointNorm(v_1);
+			GPSPoint v_2(next.x - curr.x,next.y - curr.y,0,0);
+			double norm2 = pointNorm(v_2);
+			double dot_pro = v_1.x*v_2.x + v_1.y*v_2.y;
+			double a = UtilityH::FixNegativeAngle(acos(dot_pro/(norm1*norm2)));
+			if(a &lt;= M_PI_2)
+				min_index = min_index+1;
+		}
+
+		//m_TestingClosestPoint.push_back(make_pair(trajectory.at(min_index).pos, p.pos));
+
+		return min_index;
+}
+
+int PlanningHelpers::GetClosestNextPointIndexDirectionFast(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex )
+{
+	int size = (int)trajectory.size();
+
+	if(size &lt; 2 || prevIndex &lt; 0) return 0;
 
 	double d = 0, minD = 9999999999;
 	int min_index  = prevIndex;
 
-	for(unsigned int i=prevIndex; i&lt; trajectory.size(); i++)
+	for(unsigned int i=prevIndex; i&lt; size; i++)
 	{
-		d  = distance2pointsSqr(trajectory.at(i).pos, p.pos);
-		double angle_diff = UtilityH::AngleBetweenTwoAnglesPositive(trajectory.at(i).pos.a, p.pos.a)*RAD2DEG;
+		d  = distance2pointsSqr(trajectory[i].pos, p.pos);
+		double angle_diff = UtilityH::AngleBetweenTwoAnglesPositive(trajectory[i].pos.a, p.pos.a)*RAD2DEG;
 
 		if(d &lt; minD &amp;&amp; angle_diff &lt; 45)
 		{
@@ -289,9 +542,9 @@ int PlanningHelpers::GetClosestNextPointIndexDirection(const vector&lt;WayPoint&gt;&amp; t
 		GPSPoint curr, next;
 		curr = trajectory.at(min_index).pos;
 		next = trajectory.at(min_index+1).pos;
-		POINT2D v_1(p.pos.x - curr.x   ,p.pos.y - curr.y);
+		GPSPoint v_1(p.pos.x - curr.x   ,p.pos.y - curr.y,0,0);
 		double norm1 = pointNorm(v_1);
-		POINT2D v_2(next.x - curr.x,next.y - curr.y);
+		GPSPoint v_2(next.x - curr.x,next.y - curr.y,0,0);
 		double norm2 = pointNorm(v_2);
 		double dot_pro = v_1.x*v_2.x + v_1.y*v_2.y;
 		double a = UtilityH::FixNegativeAngle(acos(dot_pro/(norm1*norm2)));
@@ -337,7 +590,7 @@ WayPoint PlanningHelpers::GetPerpendicularOnTrajectory_obsolete(const vector&lt;Way
 	}
 	else
 	{
-		int next_index = GetClosestNextPointIndex(trajectory, p, prevIndex);
+		int next_index = GetClosestNextPointIndexFast(trajectory, p, prevIndex);
 
 		if(next_index == 0)
 		{
@@ -406,7 +659,7 @@ double PlanningHelpers::GetPerpDistanceToTrajectorySimple_obsolete(const vector&lt;
 	}
 	else
 	{
-		next_index = GetClosestNextPointIndex(trajectory, p, prevIndex);
+		next_index = GetClosestNextPointIndexFast(trajectory, p, prevIndex);
 		if(next_index == 0)
 		{
 			p0 = trajectory[next_index];
@@ -508,7 +761,7 @@ WayPoint PlanningHelpers::GetNextPointOnTrajectory_obsolete(const vector&lt;WayPoin
 	p2 = trajectory.at(local_currIndex);
 	p1 = trajectory.at(local_currIndex+1);
 
-	POINT2D uv(p1.pos.x - p2.pos.x, p1.pos.y - p2.pos.y);
+	GPSPoint uv(p1.pos.x - p2.pos.x, p1.pos.y - p2.pos.y ,0,0);
 	double v_norm = pointNorm(uv);
 
 	assert(v_norm != 0);
@@ -638,6 +891,115 @@ double PlanningHelpers::GetDistanceToClosestStopLineAndCheck(const std::vector&lt;W
 	return -1;
 }
 
+void PlanningHelpers::CreateManualBranchFromTwoPoints(WayPoint&amp; p1,WayPoint&amp; p2 , const double&amp; distance, const DIRECTION_TYPE&amp; direction, std::vector&lt;WayPoint&gt;&amp; path)
+{
+	WayPoint endWP, midWP;
+
+	double branch_angle = 0;
+	if(direction == FORWARD_RIGHT_DIR)
+	{
+		branch_angle = p1.pos.a-M_PI_2;
+	}
+	else if(direction == FORWARD_LEFT_DIR)
+	{
+		branch_angle = p1.pos.a+M_PI_2;
+	}
+	endWP.pos.y = p2.pos.y + distance*sin(branch_angle);
+	endWP.pos.x = p2.pos.x + distance*cos(branch_angle);
+
+	midWP = p2;
+	midWP.pos.x = (p1.pos.x+p2.pos.x)/2.0;
+	midWP.pos.y = (p1.pos.y+p2.pos.y)/2.0;
+	endWP.bDir = midWP.bDir = direction;
+
+	path.clear();
+	path.push_back(p1);
+	path.push_back(p2);
+	path.push_back(endWP);
+
+	PlanningHelpers::SmoothPath(path, 0.35, 0.25);
+	PlanningHelpers::FixPathDensity(path, 1.5);
+	PlanningHelpers::SmoothPath(path, 0.35, 0.25);
+	PlanningHelpers::FixPathDensity(path, 1);
+	PlanningHelpers::SmoothPath(path, 0.25, 0.35);
+
+
+	PlanningHelpers::CalcAngleAndCost(path);
+
+	for(unsigned int i=0; i &lt; path.size(); i++)
+	{
+		if(direction == FORWARD_LEFT_DIR)
+		{
+			path.at(i).state = INITIAL_STATE;
+			path.at(i).beh_state = BEH_BRANCH_LEFT_STATE;
+			path.at(i).laneId = -1;
+		}
+		if(direction == FORWARD_RIGHT_DIR)
+		{
+			path.at(i).state = INITIAL_STATE;
+			path.at(i).beh_state = BEH_BRANCH_RIGHT_STATE;
+			path.at(i).laneId = -2;
+		}
+	}
+}
+
+void PlanningHelpers::CreateManualBranch(std::vector&lt;WayPoint&gt;&amp; path, const int&amp; degree, const DIRECTION_TYPE&amp; direction)
+{
+	if(path.size() &lt; 5) return;
+
+	//start branch point
+	WayPoint branch_start = path.at(path.size()-5);
+	WayPoint last_wp = path.at(path.size()-1);
+
+
+	WayPoint endWP;
+	vector&lt;WayPoint&gt; goal_path;
+	double branch_angle = 0;
+	if(direction == FORWARD_RIGHT_DIR)
+	{
+		branch_angle = last_wp.pos.a-M_PI_2;
+	}
+	else if(direction == FORWARD_LEFT_DIR)
+	{
+		branch_angle = last_wp.pos.a+M_PI_2;
+	}
+	endWP.pos.y = last_wp.pos.y + 10*sin(branch_angle);
+	endWP.pos.x = last_wp.pos.x + 10*cos(branch_angle);
+
+	WayPoint wp = last_wp;
+	wp.pos.x = (last_wp.pos.x+endWP.pos.x)/2.0;
+	wp.pos.y = (last_wp.pos.y+endWP.pos.y)/2.0;
+	endWP.bDir = wp.bDir = direction;
+	goal_path.push_back(wp);
+	goal_path.push_back(endWP);
+
+	goal_path.insert(goal_path.begin(), path.end()-5, path.end());
+	PlanningHelpers::SmoothPath(goal_path, 0.25, 0.25);
+	PlanningHelpers::FixPathDensity(goal_path, 0.75);
+	PlanningHelpers::SmoothPath(goal_path, 0.25, 0.35);
+
+	path.erase(path.end()-5, path.end());
+	path.insert(path.end(), goal_path.begin(), goal_path.end());
+
+	PlanningHelpers::CalcAngleAndCost(path);
+
+	for(unsigned int i=0; i &lt; path.size(); i++)
+	{
+		if(direction == FORWARD_LEFT_DIR)
+		{
+			path.at(i).state = INITIAL_STATE;
+			path.at(i).beh_state = BEH_BRANCH_LEFT_STATE;
+		}
+		if(direction == FORWARD_RIGHT_DIR)
+		{
+			path.at(i).state = INITIAL_STATE;
+			path.at(i).beh_state = BEH_BRANCH_RIGHT_STATE;
+		}
+	}
+
+
+}
+
 void PlanningHelpers::FixPathDensity(vector&lt;WayPoint&gt;&amp; path, const double&amp; distanceDensity)
 {
 	if(path.size() == 0 || distanceDensity==0) return;
@@ -855,15 +1217,18 @@ void PlanningHelpers::ExtractPartFromPointToDistance(const vector&lt;WayPoint&gt;&amp; ori
 		const double&amp; pathDensity, vector&lt;WayPoint&gt;&amp; extractedPath, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight, const double&amp; SmoothTolerance)
 {
 	extractedPath.clear();
-	unsigned int close_index = GetClosestNextPointIndexDirection(originalPath, pos);
-	vector&lt;WayPoint&gt; tempPath;
+	unsigned int close_index = GetClosestNextPointIndexDirectionFast(originalPath, pos);
+//	int i_slow = GetClosestNextPointIndexDirection(originalPath, pos);
+//	if(close_index != i_slow)
+//		cout &lt;&lt; "Aler Alert !!! fast: " &lt;&lt; close_index &lt;&lt; ", slow: " &lt;&lt; i_slow  &lt;&lt; endl;
+	//vector&lt;WayPoint&gt; tempPath;
 	double d_limit = 0;
 	if(close_index &gt;= 5) close_index -=5;
 	else close_index = 0;
 
 	for(unsigned int i=close_index; i&lt; originalPath.size(); i++)
 	{
-		tempPath.push_back(originalPath.at(i));
+		extractedPath.push_back(originalPath.at(i));
 
 		if(i&gt;0)
 			d_limit += hypot(originalPath.at(i).pos.y - originalPath.at(i-1).pos.y, originalPath.at(i).pos.x - originalPath.at(i-1).pos.x);
@@ -872,21 +1237,61 @@ void PlanningHelpers::ExtractPartFromPointToDistance(const vector&lt;WayPoint&gt;&amp; ori
 			break;
 	}
 
-	if(tempPath.size() &lt; 2)
+	if(extractedPath.size() &lt; 2)
 	{
-		cout &lt;&lt; endl &lt;&lt; "### Planner Z . Extracted Rollout Path is too Small, Size = " &lt;&lt; tempPath.size() &lt;&lt; endl;
+		cout &lt;&lt; endl &lt;&lt; "### Planner Z . Extracted Rollout Path is too Small, Size = " &lt;&lt; extractedPath.size() &lt;&lt; endl;
 		return;
 	}
 
-	FixPathDensity(tempPath, pathDensity);
-	SmoothPath(tempPath, SmoothDataWeight, SmoothWeight , SmoothTolerance);
-	CalcAngleAndCost(tempPath);
+	FixPathDensity(extractedPath, pathDensity);
+	SmoothPath(extractedPath, SmoothDataWeight, SmoothWeight , SmoothTolerance);
+	CalcAngleAndCost(extractedPath);
 
-	extractedPath = tempPath;
+	//extractedPath = tempPath;
 	//tempPath.clear();
 	//TestQuadraticSpline(extractedPath, tempPath);
 }
 
+void PlanningHelpers::ExtractPartFromPointToDistanceFast(const vector&lt;WayPoint&gt;&amp; originalPath, const WayPoint&amp; pos, const double&amp; minDistance,
+		const double&amp; pathDensity, vector&lt;WayPoint&gt;&amp; extractedPath, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight, const double&amp; SmoothTolerance)
+{
+	extractedPath.clear();
+	RelativeInfo info;
+	GetRelativeInfo(originalPath, pos, info);
+	double d = 0;
+	if(info.iBack &gt; 0)
+		info.iBack--;
+
+	for(int i=info.iBack; i &gt;=  0; i--)
+	{
+		extractedPath.insert(extractedPath.begin(),  originalPath.at(i));
+		if(i &lt; originalPath.size())
+			d += hypot(originalPath.at(i).pos.y - originalPath.at(i+1).pos.y, originalPath.at(i).pos.x - originalPath.at(i+1).pos.x);
+		if(d &gt; 10)
+			break;
+	}
+
+	//extractedPath.push_back(info.perp_point);
+	d = 0;
+	for(int i=info.iBack+1; i &lt; (int)originalPath.size(); i++)
+	{
+		extractedPath.push_back(originalPath.at(i));
+		if(i &gt; 0)
+			d += hypot(originalPath.at(i).pos.y - originalPath.at(i-1).pos.y, originalPath.at(i).pos.x - originalPath.at(i-1).pos.x);
+		if(d &gt; minDistance)
+			break;
+	}
+
+	if(extractedPath.size() &lt; 2)
+	{
+		cout &lt;&lt; endl &lt;&lt; "### Planner Z . Extracted Rollout Path is too Small, Size = " &lt;&lt; extractedPath.size() &lt;&lt; endl;
+		return;
+	}
+
+	FixPathDensity(extractedPath, pathDensity);
+	CalcAngleAndCost(extractedPath);
+}
+
 void PlanningHelpers::CalculateRollInTrajectories(const WayPoint&amp; carPos, const double&amp; speed, const vector&lt;WayPoint&gt;&amp; originalCenter, int&amp; start_index,
 		int&amp; end_index, vector&lt;double&gt;&amp; end_laterals ,
 		vector&lt;vector&lt;WayPoint&gt; &gt;&amp; rollInPaths, const double&amp; max_roll_distance,
@@ -923,8 +1328,8 @@ void PlanningHelpers::CalculateRollInTrajectories(const WayPoint&amp; carPos, const
 //	{
 //		unsigned int num_of_strait_points = carTipMargin / pathDensity;
 //		int closest_for_each_iteration = 0;
-//		WayPoint np = GetPerpendicularOnTrajectory(originalCenter, rearPos, dummyd, closest_for_each_iteration);
-//		np.pos = rearPos.pos;
+//		WayPoint np = GetPerpendicularOnTrajectory_obsolete(originalCenter, carPos, dummyd, closest_for_each_iteration);
+//		np.pos = carPos.pos;
 //
 //		RollOutStratPath.push_back(np);
 //		for(unsigned int i = 0; i &lt; num_of_strait_points; i++)
@@ -932,12 +1337,12 @@ void PlanningHelpers::CalculateRollInTrajectories(const WayPoint&amp; carPos, const
 //			p = RollOutStratPath.at(i);
 //			p.pos.x = p.pos.x +  pathDensity*cos(p.pos.a);
 //			p.pos.y = p.pos.y +  pathDensity*sin(p.pos.a);
-//			np = GetPerpendicularOnTrajectory(originalCenter, p, dummyd, closest_for_each_iteration);
+//			np = GetPerpendicularOnTrajectory_obsolete(originalCenter, p, dummyd, closest_for_each_iteration);
 //			np.pos = p.pos;
 //			RollOutStratPath.push_back(np);
 //		}
 //
-//		initial_roll_in_distance = GetPerpDistanceToTrajectorySimple(originalCenter, RollOutStratPath.at(RollOutStratPath.size()-1), close_index);
+//		initial_roll_in_distance = GetPerpDistanceToTrajectorySimple_obsolete(originalCenter, RollOutStratPath.at(RollOutStratPath.size()-1), close_index);
 //	}
 	///***   -------------------------------- ***///
 
@@ -1290,35 +1695,42 @@ void PlanningHelpers::SmoothWayPointsDirections(vector&lt;WayPoint&gt;&amp; path_in, doubl
 	path_in = newpath;
 }
 
-void PlanningHelpers::GenerateRecommendedSpeed(vector&lt;WayPoint&gt;&amp; path, const double&amp; max_speed, const double&amp; speedProfileFactor)
+void PlanningHelpers::SmoothGlobalPathSpeed(vector&lt;WayPoint&gt;&amp; path)
 {
-	FixPathDensity(path, 0.5);
-
 	CalcAngleAndCostAndCurvatureAnd2D(path);
+	SmoothSpeedProfiles(path, 0.45,0.25, 0.01);
+}
 
-	SmoothCurvatureProfiles(path, 0.3, 0.49, 0.01);
+void PlanningHelpers::GenerateRecommendedSpeed(vector&lt;WayPoint&gt;&amp; path, const double&amp; max_speed, const double&amp; speedProfileFactor)
+{
+	CalcAngleAndCostAndCurvatureAnd2D(path);
+	SmoothCurvatureProfiles(path, 0.4, 0.3, 0.01);
+	double v = 0;
 
 	for(unsigned int i = 0 ; i &lt; path.size(); i++)
 	{
 		double k_ratio = path.at(i).cost*10.0;
+		double local_max = (path.at(i).v &gt;= 0 &amp;&amp; max_speed &gt; path.at(i).v) ? path.at(i).v : max_speed;
 
 		if(k_ratio &gt;= 9.5)
-			path.at(i).v = max_speed;
+			v = local_max;
 		else if(k_ratio &lt;= 8.5)
-			path.at(i).v = 1.0*speedProfileFactor;
+			v = 1.0*speedProfileFactor;
 		else
 		{
 			k_ratio = k_ratio - 8.5;
-			path.at(i).v = (max_speed - 1.0) * k_ratio + 1.0;
-			path.at(i).v = path.at(i).v*speedProfileFactor;
+			v = (local_max - 1.0) * k_ratio + 1.0;
+			v = v*speedProfileFactor;
 		}
 
-		if(path.at(i).v &gt; max_speed)
-			path.at(i).v = max_speed;
+		if(v &gt; local_max)
+			path.at(i).v = local_max;
+		else
+			path.at(i).v = v;
 
 	}
 
-	//SmoothSpeedProfiles(path, 0.15,0.45, 0.1);
+	SmoothSpeedProfiles(path, 0.4,0.3, 0.01);
 }
 
 WayPoint* PlanningHelpers::BuildPlanningSearchTreeV2(WayPoint* pStart,
@@ -1471,6 +1883,7 @@ WayPoint* PlanningHelpers::BuildPlanningSearchTreeStraight(WayPoint* pStart,
 	WayPoint* pZero = 0;
 	WayPoint* wp    = new WayPoint();
 	*wp = *pStart;
+	wp-&gt;cost = 0;
 	nextLeafToTrace.push_back(make_pair(pZero, wp));
 	all_cells_to_delete.push_back(wp);
 
@@ -1509,11 +1922,11 @@ WayPoint* PlanningHelpers::BuildPlanningSearchTreeStraight(WayPoint* pStart,
 				double d = hypot(wp-&gt;pos.y - pH-&gt;pos.y, wp-&gt;pos.x - pH-&gt;pos.x);
 				distance += d;
 
-				for(unsigned int a = 0; a &lt; wp-&gt;actionCost.size(); a++)
-				{
-					//if(wp-&gt;actionCost.at(a).first == FORWARD_ACTION)
-						d += wp-&gt;actionCost.at(a).second;
-				}
+//				for(unsigned int a = 0; a &lt; wp-&gt;actionCost.size(); a++)
+//				{
+//					//if(wp-&gt;actionCost.at(a).first == FORWARD_ACTION)
+//						d += wp-&gt;actionCost.at(a).second;
+//				}
 
 				wp-&gt;cost = pH-&gt;cost + d;
 				wp-&gt;pBacks.push_back(pH);
@@ -1575,6 +1988,80 @@ WayPoint* PlanningHelpers::BuildPlanningSearchTreeStraight(WayPoint* pStart,
 	return pGoalCell;
 }
 
+int PlanningHelpers::PredictiveIgnorIdsDP(WayPoint* pStart, const double&amp; DistanceLimit,
+		vector&lt;WayPoint*&gt;&amp; all_cells_to_delete,vector&lt;WayPoint*&gt;&amp; end_waypoints, std::vector&lt;int&gt;&amp; lanes_ids)
+{
+	if(!pStart) return 0;
+
+		vector&lt;pair&lt;WayPoint*, WayPoint*&gt; &gt;nextLeafToTrace;
+
+		WayPoint* pZero = 0;
+		WayPoint* wp    = new WayPoint();
+		*wp = *pStart;
+		wp-&gt;pLeft = 0;
+		wp-&gt;pRight = 0;
+		nextLeafToTrace.push_back(make_pair(pZero, wp));
+		all_cells_to_delete.push_back(wp);
+
+		double 		distance 		= 0;
+		end_waypoints.clear();
+		double 		nCounter 		= 0;
+
+		while(nextLeafToTrace.size()&gt;0)
+		{
+			nCounter++;
+
+			WayPoint* pH 	= nextLeafToTrace.at(0).second;
+
+			assert(pH != 0);
+
+			nextLeafToTrace.erase(nextLeafToTrace.begin()+0);
+
+			for(unsigned int i =0; i&lt; pH-&gt;pFronts.size(); i++)
+			{
+				if(pH-&gt;pFronts.at(i) &amp;&amp; !CheckNodeExits(all_cells_to_delete, pH-&gt;pFronts.at(i)))
+				{
+					if(pH-&gt;cost &lt; DistanceLimit)
+					{
+						wp = new WayPoint();
+						*wp = *pH-&gt;pFronts.at(i);
+
+						double d = distance2points(wp-&gt;pos, pH-&gt;pos);
+						distance += d;
+						wp-&gt;cost = pH-&gt;cost + d;
+						wp-&gt;pBacks.push_back(pH);
+						wp-&gt;pLeft = 0;
+						wp-&gt;pRight = 0;
+
+						bool bFoundLane = false;
+						for(unsigned int k = 0 ; k &lt; lanes_ids.size(); k++)
+						{
+							if(wp-&gt;laneId == lanes_ids.at(k))
+							{
+								bFoundLane = true;
+								break;
+							}
+						}
+
+						if(!bFoundLane)
+							nextLeafToTrace.push_back(make_pair(pH, wp));
+						all_cells_to_delete.push_back(wp);
+					}
+					else
+					{
+						end_waypoints.push_back(pH);
+					}
+				}
+			}
+		}
+
+		while(nextLeafToTrace.size()!=0)
+			nextLeafToTrace.pop_back();
+		//closed_nodes.clear();
+
+		return end_waypoints.size();
+}
+
 int PlanningHelpers::PredictiveDP(WayPoint* pStart, const double&amp; DistanceLimit,
 		vector&lt;WayPoint*&gt;&amp; all_cells_to_delete,vector&lt;WayPoint*&gt;&amp; end_waypoints)
 {
@@ -1782,6 +2269,9 @@ WayPoint* PlanningHelpers::GetMinCostCell(const vector&lt;WayPoint*&gt;&amp; cells, const
 
 void PlanningHelpers::ExtractPlanAlernatives(const std::vector&lt;WayPoint&gt;&amp; singlePath, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; allPaths)
 {
+	if(singlePath.size() == 0)
+		return;
+
 	allPaths.clear();
 	std::vector&lt;WayPoint&gt; path;
 	path.push_back(singlePath.at(0));
@@ -1957,23 +2447,31 @@ void PlanningHelpers::CalcContourPointsForDetectedObjects(const WayPoint&amp; currPo
 	obj_list = res_list;
 }
 
-double PlanningHelpers::GetVelocityAhead(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; pose, const double&amp; distance)
+double PlanningHelpers::GetVelocityAhead(const std::vector&lt;WayPoint&gt;&amp; path, const RelativeInfo&amp; info, int&amp; prev_index, const double&amp; reasonable_brake_distance)
 {
-	int iStart = GetClosestNextPointIndex(path, pose);
+	if(path.size()==0) return 0;
 
-	double d = 0;
-	double min_v = 99999;
-	for(unsigned int i=iStart; i&lt; path.size(); i++)
-	{
-		d  += distance2points(path.at(i).pos, pose.pos);
 
-		if(path.at(i).v &lt; min_v)
-			min_v = path.at(i).v;
+	double min_v = path.at(info.iBack).v;
+	double d = info.to_front_distance;
 
-		if(d &gt;= distance)
-			return min_v;
+	int local_i = info.iFront;
+	while(local_i &lt; path.size()-1 &amp;&amp; d &lt; reasonable_brake_distance)
+	{
+		local_i++;
+		d += hypot(path.at(local_i).pos.y - path.at(local_i-1).pos.y, path.at(local_i).pos.x - path.at(local_i-1).pos.x);
+		if(path.at(local_i).v &lt; min_v)
+			min_v = path.at(local_i).v;
 	}
-	return 0;
+
+	if(local_i &lt; prev_index &amp;&amp; prev_index &lt; path.size())
+	{
+		min_v = path.at(prev_index).v;
+	}
+	else
+		prev_index = local_i;
+
+	return min_v;
 }
 
 void PlanningHelpers::WritePathToFile(const string&amp; fileName, const vector&lt;WayPoint&gt;&amp; path)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\TrajectoryCosts.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\TrajectoryCosts.cpp" added_lines="95" deleted_lines="21">
				<diff>@@ -15,6 +15,12 @@ namespace PlannerHNS
 TrajectoryCosts::TrajectoryCosts()
 {
 	m_PrevCostIndex = -1;
+	m_WeightPriority = 0.125;
+	m_WeightTransition = 0.13;
+	m_WeightLong = 1.0;
+	m_WeightLat = 1.0;
+	m_WeightLaneChange = 1.0;
+	m_LateralSkipDistance = 10;
 }
 
 TrajectoryCosts::~TrajectoryCosts()
@@ -51,19 +57,22 @@ TrajectoryCost TrajectoryCosts::DoOneStep(const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt;
 
 	CalculateTransitionCosts(m_TrajectoryCosts, currIndex, params);
 
-	vector&lt;WayPoint&gt; contourPoints;
+
 	WayPoint p;
+	m_AllContourPoints.clear();
 	for(unsigned int io=0; io&lt;obj_list.size(); io++)
 	{
 		for(unsigned int icon=0; icon &lt; obj_list.at(io).contour.size(); icon++)
 		{
 			p.pos = obj_list.at(io).contour.at(icon);
 			p.v = obj_list.at(io).center.v;
-			contourPoints.push_back(p);
+			p.id = io;
+			p.cost = sqrt(obj_list.at(io).w*obj_list.at(io).w + obj_list.at(io).l*obj_list.at(io).l);
+			m_AllContourPoints.push_back(p);
 		}
 	}
 
-	CalculateLateralAndLongitudinalCosts(m_TrajectoryCosts, rollOuts, totalPaths, currState, contourPoints, params, carInfo, vehicleState);
+	CalculateLateralAndLongitudinalCosts(m_TrajectoryCosts, rollOuts, totalPaths, currState, m_AllContourPoints, params, carInfo, vehicleState);
 
 	NormalizeCosts(m_TrajectoryCosts);
 
@@ -72,10 +81,10 @@ TrajectoryCost TrajectoryCosts::DoOneStep(const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt;
 	double smallestDistance = 9999999999;
 	double velo_of_next = 0;
 
-//	cout &lt;&lt; "Trajectory Costs Log : CurrIndex: " &lt;&lt; currIndex &lt;&lt; " --------------------- " &lt;&lt; endl;
+	//cout &lt;&lt; "Trajectory Costs Log : CurrIndex: " &lt;&lt; currIndex &lt;&lt; " --------------------- " &lt;&lt; endl;
 	for(unsigned int ic = 0; ic &lt; m_TrajectoryCosts.size(); ic++)
 	{
-//		cout &lt;&lt; m_TrajectoryCosts.at(ic).ToString();
+		//cout &lt;&lt; m_TrajectoryCosts.at(ic).ToString();
 		if(!m_TrajectoryCosts.at(ic).bBlocked &amp;&amp; m_TrajectoryCosts.at(ic).cost &lt; smallestCost)
 		{
 			smallestCost = m_TrajectoryCosts.at(ic).cost;
@@ -89,7 +98,7 @@ TrajectoryCost TrajectoryCosts::DoOneStep(const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt;
 		}
 	}
 
-//	cout &lt;&lt; "Smallest Distance: " &lt;&lt;  smallestDistance &lt;&lt; "------------------------------------------------------------- " &lt;&lt; endl;
+	//cout &lt;&lt; "Smallest Distance: " &lt;&lt;  smallestDistance &lt;&lt; "------------------------------------------------------------- " &lt;&lt; endl;
 
 	//All is blocked !
 	if(smallestIndex == -1 &amp;&amp; m_PrevCostIndex &lt; (int)m_TrajectoryCosts.size())
@@ -127,8 +136,7 @@ void TrajectoryCosts::CalculateLateralAndLongitudinalCosts(vector&lt;TrajectoryCost
 	double critical_long_front_distance =  carInfo.wheel_base/2.0 + carInfo.length/2.0 + params.verticalSafetyDistance;
 	double critical_long_back_distance =  carInfo.length/2.0 + params.verticalSafetyDistance - carInfo.wheel_base/2.0;
 	int iCostIndex = 0;
-	PlannerHNS::Mat3 rotationMat(-currState.pos.a);
-	PlannerHNS::Mat3 translationMat(-currState.pos.x, -currState.pos.y);
+
 	PlannerHNS::Mat3 invRotationMat(currState.pos.a-M_PI_2);
 	PlannerHNS::Mat3 invTranslationMat(currState.pos.x, currState.pos.y);
 
@@ -163,12 +171,6 @@ void TrajectoryCosts::CalculateLateralAndLongitudinalCosts(vector&lt;TrajectoryCost
 	top_left_car = invRotationMat*top_left_car;
 	top_left_car = invTranslationMat*top_left_car;
 
-//	m_SafetyBox.clear();
-//	m_SafetyBox.push_back(bottom_left);
-//	m_SafetyBox.push_back(bottom_right);
-//	m_SafetyBox.push_back(top_right);
-//	m_SafetyBox.push_back(top_left);
-
 	m_SafetyBorder.points.clear();
 	m_SafetyBorder.points.push_back(bottom_left) ;
 	m_SafetyBorder.points.push_back(bottom_right) ;
@@ -184,16 +186,28 @@ void TrajectoryCosts::CalculateLateralAndLongitudinalCosts(vector&lt;TrajectoryCost
 			RelativeInfo car_info;
 			PlanningHelpers::GetRelativeInfo(totalPaths.at(il), currState, car_info);
 
+
 			for(unsigned int it=0; it&lt; rollOuts.at(il).size(); it++)
 			{
+				int skip_id = -1;
 				for(unsigned int icon = 0; icon &lt; contourPoints.size(); icon++)
 				{
+					if(skip_id == contourPoints.at(icon).id)
+						continue;
+
 					RelativeInfo obj_info;
 					PlanningHelpers::GetRelativeInfo(totalPaths.at(il), contourPoints.at(icon), obj_info);
 					double longitudinalDist = PlanningHelpers::GetExactDistanceOnTrajectory(totalPaths.at(il), car_info, obj_info);
 					if(obj_info.iFront == 0 &amp;&amp; longitudinalDist &gt; 0)
 						longitudinalDist = -longitudinalDist;
 
+					double direct_distance = hypot(obj_info.perp_point.pos.y-contourPoints.at(icon).pos.y, obj_info.perp_point.pos.x-contourPoints.at(icon).pos.x);
+					if(contourPoints.at(icon).v &lt; 0.1 &amp;&amp; direct_distance &gt; (m_LateralSkipDistance+contourPoints.at(icon).cost))
+					{
+						skip_id = contourPoints.at(icon).id;
+						continue;
+					}
+
 					double close_in_percentage = 1;
 //					close_in_percentage = ((longitudinalDist- critical_long_front_distance)/params.rollInMargin)*4.0;
 //
@@ -206,7 +220,7 @@ void TrajectoryCosts::CalculateLateralAndLongitudinalCosts(vector&lt;TrajectoryCost
 
 					double lateralDist = fabs(obj_info.perp_distance - distance_from_center);
 
-					if(longitudinalDist &lt; -carInfo.length || lateralDist &gt; 6)
+					if(longitudinalDist &lt; -carInfo.length || longitudinalDist &gt; params.minFollowingDistance || lateralDist &gt; m_LateralSkipDistance)
 					{
 						continue;
 					}
@@ -261,6 +275,7 @@ void TrajectoryCosts::NormalizeCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts)
 		totalLongitudinalCosts += trajectoryCosts.at(ic).longitudinal_cost;
 	}
 
+//	cout &lt;&lt; "------ Normalizing Step " &lt;&lt; endl;
 	for(unsigned int ic = 0; ic&lt; trajectoryCosts.size(); ic++)
 	{
 		if(totalPriorities != 0)
@@ -288,13 +303,30 @@ void TrajectoryCosts::NormalizeCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts)
 		else
 			trajectoryCosts.at(ic).longitudinal_cost = 0;
 
-		trajectoryCosts.at(ic).cost = (
-				trajectoryCosts.at(ic).priority_cost +
-				trajectoryCosts.at(ic).lane_change_cost +
-				trajectoryCosts.at(ic).lateral_cost +
-				trajectoryCosts.at(ic).longitudinal_cost +
-				1.5*trajectoryCosts.at(ic).transition_cost) / 5.0;
+		trajectoryCosts.at(ic).priority_cost = m_WeightPriority*trajectoryCosts.at(ic).priority_cost;
+		trajectoryCosts.at(ic).transition_cost = m_WeightTransition*trajectoryCosts.at(ic).transition_cost;
+		trajectoryCosts.at(ic).lane_change_cost = m_WeightLaneChange*trajectoryCosts.at(ic).lane_change_cost;
+		trajectoryCosts.at(ic).lateral_cost = m_WeightLat*trajectoryCosts.at(ic).lateral_cost;
+		trajectoryCosts.at(ic).longitudinal_cost = m_WeightLong*trajectoryCosts.at(ic).longitudinal_cost;
+
+
+		trajectoryCosts.at(ic).cost = m_WeightPriority*trajectoryCosts.at(ic).priority_cost/5.0 +
+				m_WeightLaneChange*trajectoryCosts.at(ic).lane_change_cost/5.0 +
+				m_WeightLat*trajectoryCosts.at(ic).lateral_cost/5.0 +
+				m_WeightLong*trajectoryCosts.at(ic).longitudinal_cost/5.0 +
+				m_WeightTransition*trajectoryCosts.at(ic).transition_cost/5.0;
+
+//		cout &lt;&lt; "Index: " &lt;&lt; ic
+//						&lt;&lt; ", Priority: " &lt;&lt; trajectoryCosts.at(ic).priority_cost
+//						&lt;&lt; ", Transition: " &lt;&lt; trajectoryCosts.at(ic).transition_cost
+//						&lt;&lt; ", Lat: " &lt;&lt; trajectoryCosts.at(ic).lateral_cost
+//						&lt;&lt; ", Long: " &lt;&lt; trajectoryCosts.at(ic).longitudinal_cost
+//						&lt;&lt; ", Change: " &lt;&lt; trajectoryCosts.at(ic).lane_change_cost
+//						&lt;&lt; ", Avg: " &lt;&lt; trajectoryCosts.at(ic).cost
+//						&lt;&lt; endl;
 	}
+
+//	cout &lt;&lt; "------------------------ " &lt;&lt; endl;
 }
 
 vector&lt;TrajectoryCost&gt; TrajectoryCosts::CalculatePriorityAndLaneChangeCosts(const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; laneRollOuts,
@@ -355,6 +387,48 @@ bool TrajectoryCosts::ValidateRollOutsInput(const vector&lt;vector&lt;vector&lt;WayPoint&gt;
 }
 
 
+bool TrajectoryCosts::CalculateIntersectionVelocities(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const PlannerHNS::DetectedObject&amp; obj, const WayPoint&amp; currState,const CAR_BASIC_INFO&amp; carInfo, WayPoint&amp; collisionPoint)
+{
+	bool bCollisionDetected = false;
+	m_CollisionPoints.clear();
+
+	for(unsigned int k = 0; k &lt; obj.predTrajectories.size(); k++)
+	{
+		for(unsigned int j = 0; j &lt; obj.predTrajectories.at(k).size(); j++)
+		{
+			bool bCollisionFound =false;
+			for(unsigned int i = 0; i &lt; path.size(); i++)
+			{
+				if(path.at(i).timeCost &gt; 0.0)
+				{
+					double collision_distance = hypot(path.at(i).pos.x-obj.predTrajectories.at(k).at(j).pos.x, path.at(i).pos.y-obj.predTrajectories.at(k).at(j).pos.y);
+					double contact_distance = hypot(currState.pos.x - path.at(i).pos.x,currState.pos.y - path.at(i).pos.y);
+					if(collision_distance &lt;= carInfo.width  &amp;&amp; fabs(path.at(i).timeCost - obj.predTrajectories.at(k).at(j).timeCost)&lt;3.0)
+					{
+						//m_CollisionPoints.push_back(path.at(i));
+						collisionPoint = path.at(i);
+						return true;
+//						double a = UtilityHNS::UtilityH::AngleBetweenTwoAnglesPositive(path.at(i).pos.a, obj.predTrajectories.at(k).at(j).pos.a)*RAD2DEG;
+//						if(a &lt; 10)
+//							path.at(i).v = obj.center.v;
+//						else
+//							path.at(i).v = 0;
+//						//obj.predTrajectories.at(k).at(j).collisionCost = 1;
+						bCollisionFound = true;
+						bCollisionDetected = true;
+						break;
+					}
+				}
+			}
+
+			if(bCollisionFound)
+				break;
+		}
+	}
+
+	return bCollisionDetected;
+}
+
 
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\geo_pos_conv.cpp" new_path="" added_lines="0" deleted_lines="197">
				<diff>@@ -1,197 +0,0 @@
-/*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include &lt;geo_pos_conv.hh&gt;
-
-double geo_pos_conv::x() const
-{
-	return m_x;
-}
-
-double geo_pos_conv::y() const
-{
-	return m_y;
-}
-
-double geo_pos_conv::z() const
-{
-	return m_z;
-}
-
-void geo_pos_conv::set_plane(double lat,   double lon)
-{
-	m_PLato = lat;
-	m_PLo = lon;
-}
-
-void geo_pos_conv::set_plane(int num)
-{
-        if(num==6){
-		m_PLo = 2.373647782712;   //
-		m_PLato= 0.628318530717;  //
-        }else if(num==7) {
-		m_PLo = 2.39400995732;   //
-		m_PLato=  0.628318530717;  //
-	} else if(num==9){
-		m_PLo =  2.4405520707;    //
-		m_PLato =  0.628318530717;  //
-	}
-}
-
-void geo_pos_conv::set_xyz(double cx, double cy, double cz)
-{
-	m_x = cx;
-	m_y = cy;
-	m_z = cz;
-	conv_xyz2llh();
-}
-
-void geo_pos_conv::set_llh_nmea_degrees(double latd,double lond, double h)
-{
-	double lat, lad, lod, lon;
-	//1234.56 -&gt; 12'34.56 -&gt; 12+ 34.56/60
-
-	lad = floor(latd/100.);
-	lat = latd-lad*100.;
-	lod = floor(lond/100.);
-	lon = lond-lod*100.;
-
-	//Changing Longitude and Latitude to Radians
-	m_lat= (lad+lat/60.0) *M_PI/180;
-	m_lon= (lod+lon/60.0) *M_PI/180;
-	m_h  =  h;
-
-	conv_llh2xyz();
-}
-
-void geo_pos_conv::llh_to_xyz(double lat, double lon, double ele)
-{
-	m_lat = lat * M_PI/180;
-	m_lon = lon * M_PI/180;
-	m_h = ele;
-
-	conv_llh2xyz();
-}
-
-void geo_pos_conv::conv_llh2xyz(void)
-{
-	double PS;           //
-	double PSo;          //
-	double PDL;          //
-	double Pt;           //
-	double PN;           //
-	double PW;           // 
-    
-	double PB1, PB2, PB3, PB4, PB5, PB6, PB7, PB8, PB9;
-	double PA, PB, PC, PD, PE, PF, PG, PH, PI;
-	double Pe;           //
-	double Pet;          //
-	double Pnn;          //  
-	double AW,FW,Pmo;
-
-	Pmo = 0.9999;
-
-	/*WGS84 Parameters*/
-	AW = 6378137.0; //Semimajor Axis
-	FW = 1.0/298.257222101; //298.257223563 //Geometrical flattening
-    
-	Pe  = (double) sqrt(2.0*FW - pow(FW,2));
-	Pet = (double) sqrt( pow(Pe,2) / (1.0 - pow(Pe,2)) );
-    
-	PA = (double) 1.0 + 3.0/4.0*pow(Pe,2) + 45.0/64.0* pow(Pe,4) + 175.0/256.0*pow(Pe,6) 
-		+ 11025.0/16384.0*pow(Pe,8) + 43659.0/65536.0*pow(Pe,10) + 693693.0/1048576.0*pow(Pe,12)
-		+ 19324305.0/29360128.0*pow(Pe,14) + 4927697775.0/7516192768.0*pow(Pe,16);
-    
-	PB = (double) 3.0/4.0*pow(Pe,2) + 15.0/16.0*pow(Pe,4) + 525.0/512.0*pow(Pe,6) + 2205.0/2048.0*pow(Pe,8)
-		+ 72765.0/65536.0*pow(Pe,10) + 297297.0/262144.0*pow(Pe,12) + 135270135.0/117440512.0*pow(Pe,14) 
-		+ 547521975.0/469762048.0*pow(Pe,16);
-    
-	PC = (double) 15.0/64.0*pow(Pe,4) + 105.0/256.0*pow(Pe,6) + 2205.0/4096.0*pow(Pe,8) + 10395.0/16384.0*pow(Pe,10)
-		+ 1486485.0/2097152.0*pow(Pe,12) + 45090045.0/58720256.0*pow(Pe,14)+ 766530765.0/939524096.0*pow(Pe,16);
-    
-	PD = (double) 35.0/512.0*pow(Pe,6) + 315.0/2048.0*pow(Pe,8) + 31185.0/131072.0*pow(Pe,10)
-		+ 165165.0/524288.0*pow(Pe,12) + 45090045.0/117440512.0*pow(Pe,14) + 209053845.0/469762048.0*pow(Pe,16);
-    
-	PE = (double) 315.0/16384.0*pow(Pe,8) + 3465.0/65536.0*pow(Pe,10) + 99099.0/1048576.0*pow(Pe,12) + 
-		4099095.0/29360128.0*pow(Pe,14) + 348423075.0/1879048192.0*pow(Pe,16);
-    
-	PF = (double) 693.0/131072.0*pow(Pe,10) + 9009.0/524288.0*pow(Pe,12) +  4099095.0/117440512.0*pow(Pe,14)
-		+ 26801775.0/469762048.0*pow(Pe,16);
-    
-	PG = (double) 3003.0/2097152.0*pow(Pe,12) + 315315.0/58720256.0*pow(Pe,14) + 11486475.0/939524096.0*pow(Pe,16);
-    
-	PH = (double) 45045.0/117440512.0*pow(Pe,14) + 765765.0/469762048.0*pow(Pe,16);
-    
-	PI = (double) 765765.0/7516192768.0*pow(Pe,16);
-    
-    
-	PB1 = (double) AW * (1.0 - pow(Pe,2)) * PA;
-	PB2 = (double) AW * (1.0 - pow(Pe,2)) * PB/-2.0;
-	PB3 = (double) AW * (1.0 - pow(Pe,2)) * PC/4.0;
-	PB4 = (double) AW * (1.0 - pow(Pe,2)) * PD/-6.0;
-	PB5 = (double) AW * (1.0 - pow(Pe,2)) * PE/8.0;
-	PB6 = (double) AW * (1.0 - pow(Pe,2)) * PF/-10.0;
-	PB7 = (double) AW * (1.0 - pow(Pe,2)) * PG/12.0;
-	PB8 = (double) AW * (1.0 - pow(Pe,2)) * PH/-14.0;
-	PB9 = (double) AW * (1.0 - pow(Pe,2)) * PI/16.0;
-    
-    
-	PS = (double) PB1*m_lat + PB2*sin(2.0*m_lat) + PB3*sin(4.0*m_lat) + PB4*sin(6.0*m_lat) 
-		+ PB5*sin(8.0*m_lat) + PB6*sin(10.0*m_lat) + PB7*sin(12.0*m_lat) + PB8*sin(14.0*m_lat)
-		+ PB9*sin(16.0*m_lat);
-    
-	PSo = (double) PB1*m_PLato + PB2*sin(2.0*m_PLato) + PB3*sin(4.0*m_PLato) + PB4*sin(6.0*m_PLato) 
-		+ PB5*sin(8.0*m_PLato) + PB6*sin(10.0*m_PLato) + PB7*sin(12.0*m_PLato) + PB8*sin(14.0*m_PLato)
-		+ PB9*sin(16.0*m_PLato);
-    
-	PDL = (double) m_lon - m_PLo;
-	Pt  = (double) tan(m_lat);
-	PW  = (double) sqrt(1.0 - pow(Pe,2)*pow(sin(m_lat),2));
-	PN  = (double) AW / PW;
-	Pnn = (double) sqrt( pow(Pet,2) * pow(cos(m_lat),2));
-    
-	m_x = (double) ( (PS - PSo) + (1.0/2.0)*PN*pow(cos(m_lat),2.0)*Pt*pow(PDL,2.0) 
-			 + (1.0/24.0) * PN * pow(cos(m_lat),4) * Pt * (5.0-pow(Pt,2) + 9.0*pow(Pnn,2) + 4.0*pow(Pnn,4))*pow(PDL,4)
-			 - (1.0/720.0) * PN * pow(cos(m_lat),6) * Pt * 
-			 (-61.0 + 58.0*pow(Pt,2) - pow(Pt,4) - 270.0*pow(Pnn,2) + 330.0*pow(Pt,2)*pow(Pnn,2))*pow(PDL,6)
-			 - (1.0/40320.0) * PN * pow(cos(m_lat),8) * Pt * 
-			 (-1385.0 + 3111*pow(Pt,2) - 543*pow(Pt,4) + pow(Pt,6)) * pow(PDL,8) ) * Pmo ; 
-    
-	m_y = (double) ( PN*cos(m_lat)*PDL - 1.0/6.0* PN * pow(cos(m_lat),3) * (-1 + pow(Pt,2) - pow(Pnn,2))*pow(PDL,3)
-			 -1.0/120.0*PN*pow(cos(m_lat),5) * (-5.0+18.0*pow(Pt,2)-pow(Pt,4)-14.0*pow(Pnn,2)+58.0*pow(Pt,2)*pow(Pnn,2))*pow(PDL,5)
-			 -1.0/5040.0*PN*pow(cos(m_lat),7)* (-61.0+479.0*pow(Pt,2)-179.0*pow(Pt,4)+pow(Pt,6))*pow(PDL,7) ) * Pmo;
-    
-	m_z = m_h;
-}
-
-void geo_pos_conv::conv_xyz2llh(void)
-{
-	// n/a
-}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\AlternativeVisualizer.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\AlternativeVisualizer.h" added_lines="0" deleted_lines="2">
				<diff>@@ -9,7 +9,6 @@
 #define AlternativeVisualizer_H_
 #include &lt;iostream&gt;
 #include "DrawObjBase.h"
-#include "GridMap.h"
 #include "RoadNetwork.h"
 #include "CarState.h"
 #include "DrawingHelpers.h"
@@ -40,7 +39,6 @@ public:
 
 public:
     PlannerHNS::RoadNetwork m_RoadMap;
-	PlannerHNS::GridMap* m_pMap;
 	PlannerHNS::WayPoint m_start;
 	PlannerHNS::WayPoint m_goal;
 	std::vector&lt;std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; &gt; m_ReadyToDrawLanes;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\Graph2dBase.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\Graph2dBase.h" added_lines="5" deleted_lines="5">
				<diff>@@ -23,14 +23,14 @@ public:
 	double DrawGraph();
 	void InsertPoint(const double&amp; x, const double&amp; y);
 	void InsertPointTimeStamp(const timespec&amp; tStamp, const double&amp; y);
-	void InsertPointsList(const std::vector&lt;PlannerHNS::POINT2D&gt;&amp; points);
+	void InsertPointsList(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; points);
 
 
 protected:
 	double w,h;
 	double nPoints;
-	std::vector&lt;PlannerHNS::POINT2D&gt; xy_arr;
-	std::vector&lt;PlannerHNS::POINT2D&gt; xy_arr_original;
+	std::vector&lt;PlannerHNS::GPSPoint&gt; xy_arr;
+	std::vector&lt;PlannerHNS::GPSPoint&gt; xy_arr_original;
 
 	double axes_color[3];
 	double graph_color[3];
@@ -38,8 +38,8 @@ protected:
 	std::string x_name;
 	std::string y_name;
 	std::string str_comment;
-	PlannerHNS::POINT2D max_point;
-	PlannerHNS::POINT2D min_point;
+	PlannerHNS::GPSPoint max_point;
+	PlannerHNS::GPSPoint min_point;
 
 	timespec m_PrevTimeStamp;
 };
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\PlannerTestDraw.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\PlannerTestDraw.h" added_lines="17" deleted_lines="5">
				<diff>@@ -9,7 +9,6 @@
 #define PLANNERTESTDRAW_H_
 #include &lt;iostream&gt;
 #include "DrawObjBase.h"
-#include "GridMap.h"
 #include "RoadNetwork.h"
 #include "CarState.h"
 #include "DrawingHelpers.h"
@@ -21,6 +20,12 @@
 namespace Graphics
 {
 
+#define STEERING_AXIS 0
+#define ACCELERATION_AXIS 1
+#define BRAKE_AXIS 2
+#define BUTTON_INDEX 0
+#define START_BUTTON_VALUE 512
+
 class PlannerTestDraw : public DrawObjBase
 {
 public:
@@ -41,6 +46,7 @@ public:
 	 static void* PlanningThreadStaticEntryPoint(void* pThis);
 	 static void* ControlThreadStaticEntryPoint(void* pThis);
 	 static void* SimulationThreadStaticEntryPoint(void* pThis);
+	 static void* GameWheelThreadStaticEntryPoint(void* pThis);
 
 
 	 void InitStartAndGoal(const double&amp; x1,const double&amp; y1, const double&amp; a1, const double&amp; x2,const double&amp; y2, const double&amp; a2);
@@ -48,13 +54,13 @@ public:
 
 public:
 	 PlannerHNS::RoadNetwork m_RoadMap;
-	PlannerHNS::GridMap* m_pMap;
+
 	std::vector&lt;PlannerHNS::WayPoint&gt; m_goals;
 	int m_iCurrentGoal;
 	PlannerHNS::WayPoint m_start;
 	bool				 m_bMakeNewPlan;
-	bool 				m_bResetForSimulation;
-	bool			m_bGreenTrafficLight;
+	bool 				 m_bResetForSimulation;
+	bool				 m_bGreenTrafficLight;
 //	PlannerHNS::WayPoint m_SlowDown;
 //	PlannerHNS::WayPoint m_GoNormal;
 	bool m_bStartSlow;
@@ -66,6 +72,8 @@ public:
 	pthread_t planning_thread_tid;
 	pthread_t control_thread_tid;
 	pthread_t simulation_thread_tid;
+	pthread_t game_wheel_thread_tid;
+
 	bool m_bCancelThread;
 	PlannerHNS::ControllerParams m_ControlParams;
 	PlannerHNS::CAR_BASIC_INFO m_CarInfo;
@@ -95,7 +103,11 @@ public:
 
 	std::vector&lt;PlannerHNS::WayPoint*&gt; m_all_cell_to_delete;
 
-
+	//Game Wheel Controller
+	double m_SteeringAngle;
+	double m_Acceleration;
+	double m_Braking;
+	bool   m_bStart;
 
 private:
 	void PrepareVectorMapForDrawing();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\SimpleTracker.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\SimpleTracker.h" added_lines="42" deleted_lines="29">
				<diff>@@ -21,6 +21,7 @@ namespace SimulationNS
 #define DEBUG_TRACKER 0
 #define NEVER_GORGET_TIME -1000
 #define MIN_EVIDENCE_NUMBER 3
+#define TRACKING_HORIZON 150
 
 struct Kalman1dState
 {
@@ -133,12 +134,13 @@ public:
 		cv::setIdentity(m_filter.processNoiseCov, cv::Scalar::all(0.0001));
 		cv::setIdentity(m_filter.errorCovPost, cv::Scalar::all(0.075));
 
+
 		m_filter.predict();
 
 		errorSmoother.Update(a);
 	}
 
-	void UpdateTracking(double _dt, const double&amp; x, const double&amp; y, const double&amp; a, double&amp; x_new, double &amp; y_new , double&amp; a_new, double&amp; v)
+	void UpdateTracking(double _dt, const PlannerHNS::DetectedObject&amp; oldObj, PlannerHNS::DetectedObject&amp; predObj)
 	{
 		dt = _dt;
 #if (CV_MAJOR_VERSION == 2)
@@ -152,50 +154,58 @@ public:
 				0	,0	,1	,0	,
 				0	,0	,0	,1	);
 #endif		
-		double a_old = a;
+		double a_old = oldObj.center.pos.a;
 
 		cv::Mat_&lt;float&gt; measurement(nMeasure,1);
 		cv::Mat_&lt;float&gt; prediction(nStates,1);
 
-		measurement(0) = x;
-		measurement(1) = y;
+		measurement(0) = oldObj.center.pos.x;
+		measurement(1) = oldObj.center.pos.y;
 
 		prediction = m_filter.correct(measurement);
 
-		x_new = prediction.at&lt;float&gt;(0);
-		y_new = prediction.at&lt;float&gt;(1);
+		predObj.center.pos.x = prediction.at&lt;float&gt;(0);
+		predObj.center.pos.y = prediction.at&lt;float&gt;(1);
 		double vx  = prediction.at&lt;float&gt;(2);
 		double vy  = prediction.at&lt;float&gt;(3);
 
-		if(m_iLife &gt; 2)
+		if(m_iLife &gt; 10)
 		{
-			v = sqrt(vx*vx+vy*vy);
-			double diff_y = y_new - prev_y;
-			double diff_x = x_new - prev_x;
-			if(hypot(diff_y, diff_x) &gt; 0.5)
+			predObj.center.v = sqrt(vx*vx+vy*vy);
+			double diff_y = predObj.center.pos.y - prev_y;
+			double diff_x = predObj.center.pos.x - prev_x;
+			if(hypot(diff_y, diff_x) &gt; 0.15)
 			{
-				prev_y = y;
-				prev_x = x;
-				a_new = atan2(diff_y, diff_x);
+				prev_y = oldObj.center.pos.y;
+				prev_x = oldObj.center.pos.x;
+				predObj.center.pos.a = atan2(diff_y, diff_x);
 			}
 			else
-				a_new = a;
+			{
+				predObj.center.pos.a = oldObj.center.pos.a;
+			}
+
+			//if(predObj.center.v &gt; 0.1)
+			{
+				predObj.bDirection = true;
+				predObj.bVelocity = true;
+			}
+			predObj.acceleration = UtilityHNS::UtilityH::GetSign(predObj.center.v - oldObj.center.v);
 
 		}
 		else
 		{
-			v = 0;
-			a_new = a;
+			predObj.center.v = 0;
+			//predObj.center.pos.a = oldObj.center.pos.a;
+			predObj.center.pos.a = predObj.actual_yaw;
 		}
 
-		circ_angle = UtilityHNS::UtilityH::GetCircularAngle(circ_angle, UtilityHNS::UtilityH::FixNegativeAngle(a_old), UtilityHNS::UtilityH::FixNegativeAngle(a_new));
-
-		circ_angle =  errorSmoother.Update(circ_angle).x;
-
-		a_new = UtilityHNS::UtilityH::SplitPositiveAngle(circ_angle);
+		//circ_angle = UtilityHNS::UtilityH::GetCircularAngle(circ_angle, UtilityHNS::UtilityH::FixNegativeAngle(a_old), UtilityHNS::UtilityH::FixNegativeAngle(predObj.center.pos.a));
+		//circ_angle =  errorSmoother.Update(circ_angle).x;
+		//predObj.center.pos.a = UtilityHNS::UtilityH::SplitPositiveAngle(circ_angle);
 
-		if(v &lt; 0.1)
-			v = 0;
+		if(predObj.center.v &lt; 0.1)
+			predObj.center.v = 0;
 
 		//std::cout &lt;&lt; "Track: Old (" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; "), New (" &lt;&lt; x_new &lt;&lt; ", " &lt;&lt; y_new &lt;&lt; ")" &lt;&lt; std::endl;
 		//std::cout &lt;&lt; "Track: " &lt;&lt; m_id &lt;&lt; ", A: " &lt;&lt; a &lt;&lt; ", A_new:(" &lt;&lt; circ_angle &lt;&lt; "," &lt;&lt;  a_new &lt;&lt; ") , V" &lt;&lt; v &lt;&lt; ", dt: " &lt;&lt; dt &lt;&lt; ", forget_time: " &lt;&lt; forget_time &lt;&lt; std::endl;
@@ -217,16 +227,16 @@ public:
 	double radius;
 	double forget_time;
 	std::vector&lt;KFTrackV*&gt; pTrackers;
-	InterestCircle* pPrevCircle;
-	InterestCircle* pNextCircle;
+//	InterestCircle* pPrevCircle;
+//	InterestCircle* pNextCircle;
 
 	InterestCircle(int _id)
 	{
 		id = _id;
 		radius = 0;
 		forget_time = NEVER_GORGET_TIME; // never forget
-		pPrevCircle = 0;
-		pNextCircle = 0;
+//		pPrevCircle = 0;
+//		pNextCircle = 0;
 	}
 };
 
@@ -249,6 +259,7 @@ class SimpleTracker
 public:
 	std::vector&lt;InterestCircle*&gt; m_InterestRegions;
 	std::vector&lt;KFTrackV*&gt; m_Tracks;
+	std::vector&lt;KFTrackV&gt; m_TrackSimply;
 	timespec m_TrackTimer;
 	long iTracksNumber;
 	PlannerHNS::WayPoint m_PrevState;
@@ -265,13 +276,15 @@ public:
 	void AssociateObjects();
 	void InitializeInterestRegions(double horizon, double init_raduis, double init_time, std::vector&lt;InterestCircle*&gt;&amp; regions);
 	void AssociateAndTrack();
+	void AssociateSimply();
 	void AssociateToRegions(KFTrackV&amp; detectedObject);
 	void CleanOldTracks();
 
 	void DoOneStep(const PlannerHNS::WayPoint&amp; currPose, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
 
-	SimpleTracker(double horizon = 100);
+	SimpleTracker();
 	virtual ~SimpleTracker();
+	void InitSimpleTracker();
 
 public:
 	double m_DT;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\TrajectoryFollower.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\TrajectoryFollower.h" added_lines="1" deleted_lines="1">
				<diff>@@ -12,7 +12,7 @@
 #include "PlannerCommonDef.h"
 
 
-#define MAX_ACCELERATION_2G 20 // meter /sec/sec
+#define MAX_ACCELERATION_2G 5 // meter /sec/sec
 namespace SimulationNS
 {
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\AlternativeVisualizer.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\AlternativeVisualizer.cpp" added_lines="22" deleted_lines="28">
				<diff>@@ -49,11 +49,6 @@ void AlternativeVisualizer::LoadMaterials()
 
 AlternativeVisualizer::~AlternativeVisualizer()
 {
-	if(m_pMap)
-	{
-		delete m_pMap;
-		m_pMap = 0;
-	}
 }
 
 bool AlternativeVisualizer::IsInitState()
@@ -192,21 +187,21 @@ void AlternativeVisualizer::DrawGPSData()
 	}
 
 	// 4- Convert to Cartesian and scale Up
-	MappingHelpers::llaToxyz(origin, GPSPoint());
-	GPSPoint prevP = origin;
-	vector&lt;double&gt; x_signal;
-	vector&lt;double&gt; y_signal;
-	for(unsigned int i = 0 ; i &lt; gpsDataPath.size(); i++)
-	{
-		MappingHelpers::llaToxyz(gpsDataPath.at(i).pos, origin);
-		gpsDataPath.at(i).pos.x = gpsDataPath.at(i).pos.x * 100000;
-		gpsDataPath.at(i).pos.y = gpsDataPath.at(i).pos.y * 100000;
-
-		x_signal.push_back(gpsDataPath.at(i).pos.x);
-		y_signal.push_back(gpsDataPath.at(i).pos.y);
-
-		prevP = gpsDataPath.at(i).pos;
-	}
+//	MappingHelpers::llaToxyz(origin, GPSPoint());
+//	GPSPoint prevP = origin;
+//	vector&lt;double&gt; x_signal;
+//	vector&lt;double&gt; y_signal;
+//	for(unsigned int i = 0 ; i &lt; gpsDataPath.size(); i++)
+//	{
+//		MappingHelpers::llaToxyz(gpsDataPath.at(i).pos, origin);
+//		gpsDataPath.at(i).pos.x = gpsDataPath.at(i).pos.x * 100000;
+//		gpsDataPath.at(i).pos.y = gpsDataPath.at(i).pos.y * 100000;
+//
+//		x_signal.push_back(gpsDataPath.at(i).pos.x);
+//		y_signal.push_back(gpsDataPath.at(i).pos.y);
+//
+//		prevP = gpsDataPath.at(i).pos;
+//	}
 
 
 	// 5- using cojugate grandient
@@ -219,21 +214,21 @@ void AlternativeVisualizer::DrawGPSData()
 
 	// 6- using kalman filter
 	vector&lt;WayPoint&gt; gpsDataPathSmoothedKalman = gpsDataPath;
-	KFTrackV kf(origin.x, origin.y, origin.a, 0, 1);
+/*	KFTrackV kf(origin.x, origin.y, origin.a, 0, 1);
 	for(unsigned int i = 0 ; i &lt; gpsDataPathSmoothedKalman.size(); i++)
 	{
 		GPSPoint p = gpsDataPathSmoothedKalman.at(i).pos;
 		kf.UpdateTracking(0.1, p.x, p.y, p.a, p.x, p.y, p.a, gpsDataPathSmoothedKalman.at(i).v);
 		gpsDataPathSmoothedKalman.at(i).pos = p;
 	}
-
+*/
 	// 7- using median filter with order n
 	vector&lt;double&gt; x_signal_res;
 	vector&lt;double&gt; y_signal_res;
 	vector&lt;WayPoint&gt; gpsDataPathSmoothedMedian;
 
-	medianfilter(x_signal, x_signal_res, 3);
-	medianfilter(y_signal, y_signal_res, 3);
+	//medianfilter(x_signal, x_signal_res, 3);
+	//medianfilter(y_signal, y_signal_res, 3);
 
 	for(unsigned int i =0 ; i &lt; x_signal_res.size(); i++)
 	{
@@ -274,9 +269,6 @@ void AlternativeVisualizer::DrawGPSData()
 
 	glEnable(GL_LIGHTING);
 
-
-
-
 }
 
 void AlternativeVisualizer::DrawVectorMap()
@@ -336,8 +328,10 @@ void AlternativeVisualizer::DrawVectorMap()
 
 void AlternativeVisualizer::DrawSimu()
 {
+
+
 	//DrawGPSData();
-	DrawVectorMap();
+	//DrawVectorMap();
 	float color[] = {0, 1, 0};
 	DrawingHelpers::DrawWidePath(m_GeneratedPath, 0.5, 0.5, color);
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\CarState.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\CarState.cpp" added_lines="7" deleted_lines="5">
				<diff>@@ -367,7 +367,7 @@ double CarState::PredictTimeCostForTrajectory(std::vector&lt;PlannerHNS::WayPoint&gt;&amp;
 		path.at(i).timeCost = -1;
 	}
 
-	int startIndex = PlanningHelpers::GetClosestNextPointIndex(path, state);
+	int startIndex = PlanningHelpers::GetClosestNextPointIndexFast(path, state);
 	double total_distance = 0;
 	path.at(startIndex).timeCost = 0;
 	for(unsigned int i=startIndex+1; i&lt;path.size(); i++)
@@ -737,7 +737,7 @@ void CarState::FindNextBestSafeTrajectory(int&amp; safe_index)
 	bool bNewTrajectory = false;
 //	if(m_TotalPath.size()&gt;0)
 //	{
-//		int currIndex = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(m_Path, state);
+//		int currIndex = PlannerHNS::PlanningHelpers::GetClosestNextPointIndexFast(m_Path, state);
 //		int index_limit = 0;//m_Path.size() - 20;
 //		if(index_limit&lt;=0)
 //			index_limit =  m_Path.size()/2.0;
@@ -825,7 +825,8 @@ void CarState::FindNextBestSafeTrajectory(int&amp; safe_index)
 		currentBehavior.indicator = PlannerHNS::INDICATOR_LEFT;
 	else
 		currentBehavior.indicator = PlannerHNS::INDICATOR_NONE;
-	currentBehavior.maxVelocity 	= PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, vehicleState.speed*3.6);
+	//currentBehavior.maxVelocity 	= PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, vehicleState.speed*3.6);
+	currentBehavior.maxVelocity = 0;
 	currentBehavior.minVelocity		= 0;
 	currentBehavior.stopDistance 	= preCalcPrams-&gt;distanceToStop();
 	currentBehavior.followVelocity 	= preCalcPrams-&gt;velocityOfNext;
@@ -1028,7 +1029,8 @@ PlannerHNS::BehaviorState SimulatedCarState::GenerateBehaviorState(const Planner
 	//    	else
 	//    		currentBehavior.indicator = PlannerHNS::INDICATOR_NONE;
 
-	currentBehavior.maxVelocity 	= PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, 1.5*vehicleState.speed*3.6);
+	//currentBehavior.maxVelocity 	= PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, 1.5*vehicleState.speed*3.6);
+	currentBehavior.maxVelocity  = 0;
 	currentBehavior.minVelocity		= 0;
 	currentBehavior.stopDistance 	= 0;
 	currentBehavior.followVelocity 	= 0;
@@ -1041,7 +1043,7 @@ bool SimulatedCarState::SelectSafeTrajectoryAndSpeedProfile(const PlannerHNS::Ve
 	PlannerHNS::PlanningParams planningDefaultParams;
 	planningDefaultParams.rollOutNumber = 0;
 
-	int currIndex = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(m_Path, state);
+	int currIndex = PlannerHNS::PlanningHelpers::GetClosestNextPointIndexFast(m_Path, state);
 	int index_limit = 0;//m_Path.size() - 15;
 	if(index_limit&lt;=0)
 		index_limit =  m_Path.size()/2.0;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\DrawingHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\DrawingHelpers.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -356,7 +356,7 @@ void DrawingHelpers::DrawWidePath(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path_
 
 void DrawingHelpers::DrawLinePoygonline(const PlannerHNS::GPSPoint&amp; p1, const PlannerHNS::GPSPoint&amp; p2, const double&amp; w)
 {
-	POINT2D center, prev_center ,pa, pb, pc, pd, prev_pa,prev_pb;
+	GPSPoint center, prev_center ,pa, pb, pc, pd, prev_pa,prev_pb;
 	double a = 0;
 
 	center.x = p1.x + (p2.x-p1.x)/2.0;
@@ -390,7 +390,7 @@ void DrawingHelpers::DrawLinePoygonFromCenterX(const PlannerHNS::WayPoint&amp; p1, c
 		const PlannerHNS::WayPoint&amp; p2, const double&amp; z2, const double&amp; w, const double&amp; h,
 		PlannerHNS::WayPoint&amp; prev_point)
 {
-	POINT2D center, prev_center ,pa, pb, pc, pd, prev_pa,prev_pb;
+	GPSPoint center, prev_center ,pa, pb, pc, pd, prev_pa,prev_pb;
 	double a = 0;
 	double prev_angle = 0;
 
@@ -615,7 +615,7 @@ void DrawingHelpers::DrawSimpleEllipse(float x, float y, float z, float outer_wi
 
 void DrawingHelpers::DrawPedal(float x, float y, float z, float width, float height, float inner_height, float color[3])
 {
-	POINT2D pa, pb, pc, pd;
+	GPSPoint pa, pb, pc, pd;
 	double w2 = width/2.0;
 	double h2 = height/2.0;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\Graph2dBase.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\Graph2dBase.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -121,7 +121,7 @@ double Graph2dBase::DrawGraph()
 
 void Graph2dBase::InsertPointTimeStamp(const timespec&amp; tStamp, const double&amp; y)
 {
-	POINT2D p(0,y,0);
+	GPSPoint p(0,y,0,0);
 	if(xy_arr_original.size() == 0)
 	{
 		xy_arr_original.push_back(p);
@@ -188,7 +188,7 @@ void Graph2dBase::InsertPoint(const double&amp; x, const double&amp; y)
 
 }
 
-void Graph2dBase::InsertPointsList(const std::vector&lt;PlannerHNS::POINT2D&gt;&amp; points)
+void Graph2dBase::InsertPointsList(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; points)
 {
 
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\PlannerTestDraw.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\PlannerTestDraw.cpp" added_lines="72" deleted_lines="13">
				<diff>@@ -14,6 +14,7 @@
 #include "SimpleTracker.h"
 #include "DataRW.h"
 #include "PlannerCommonDef.h"
+//#include &lt;plib/js.h&gt;
 
 
 using namespace std;
@@ -44,6 +45,7 @@ PlannerTestDraw::PlannerTestDraw()
 	m_pVelocityGraph = 0;
 	planning_thread_tid = 0;
 	control_thread_tid = 0;
+	game_wheel_thread_tid = 0;
 	simulation_thread_tid = 0;
 	m_bCancelThread = false;
 	m_PlanningCycleTime = 0.01;
@@ -242,8 +244,6 @@ PlannerTestDraw::PlannerTestDraw()
 //	PlannerHNS::MappingHelpers::WriteKML(kml_fileToSave, kml_templateFilePath, m_RoadMap);
 
 
-	m_pMap = new PlannerHNS::GridMap(0,0,60,60,5.0, true);
-
 	m_CarInfo.width = 2.0;
 	m_CarInfo.length = 4.2;
 	m_CarInfo.wheel_base = 2.5;
@@ -309,7 +309,8 @@ PlannerTestDraw::PlannerTestDraw()
 	m_pLateralErrGraph  = new Graph2dBase(20, 200,1000, 1.0, -1.0, "Lateral Error", "T s", "D meter", axes_color, graph_color );
 
 	pthread_create(&amp;planning_thread_tid, NULL, &amp;PlannerTestDraw::PlanningThreadStaticEntryPoint, this);
-	pthread_create(&amp;control_thread_tid, NULL, &amp;PlannerTestDraw::ControlThreadStaticEntryPoint, this);
+	//pthread_create(&amp;control_thread_tid, NULL, &amp;PlannerTestDraw::ControlThreadStaticEntryPoint, this);
+	//pthread_create(&amp;game_wheel_thread_tid, NULL, &amp;PlannerTestDraw::GameWheelThreadStaticEntryPoint, this);
 	//pthread_create(&amp;simulation_thread_tid, NULL, &amp;PlannerTestDraw::SimulationThreadStaticEntryPoint, this);
 	//InitStartAndGoal(2, -50, M_PI, 100, 100, M_PI_2);
 
@@ -476,11 +477,8 @@ PlannerTestDraw::~PlannerTestDraw()
 	if(simulation_thread_tid&gt;0)
 		pthread_join(simulation_thread_tid, (void**)&amp;pRet);
 
-	if(m_pMap)
-	{
-		delete m_pMap;
-		m_pMap = 0;
-	}
+	if(game_wheel_thread_tid&gt;0)
+		pthread_join(game_wheel_thread_tid, (void**)&amp;pRet);
 
 }
 
@@ -754,8 +752,6 @@ void PlannerTestDraw::DrawSimu()
 
 	DrawVectorMap();
 
-	//	if(m_pMap)
-	//		DrawingHelpers::DrawGrid(m_pMap-&gt;origin_x, m_pMap-&gt;origin_y, m_pMap-&gt;w, m_pMap-&gt;h, m_pMap-&gt;cell_l);
 
 	DrawPaths();
 	DrawStartsAndGoals();
@@ -941,7 +937,7 @@ void PlannerTestDraw::DrawPaths()
 
 	if(m_iStepNumber%4 == 0)
 	{
-		DrawingHelpers::DrawWidePath(m_LocalPlanner.m_PathSection, 0.08, 0.25, TotalPathColor);
+		//DrawingHelpers::DrawWidePath(m_LocalPlanner.m_PathSection, 0.08, 0.25, TotalPathColor);
 
 		//DrawingHelpers::DrawCostPath(m_all_cell_to_delete, 0.5, 0.5);
 
@@ -1445,7 +1441,7 @@ void* PlannerTestDraw::PlanningThreadStaticEntryPoint(void* pThis)
 			 */
 			int currIndexToGoal = 0;
 			if(pR-&gt;m_LocalPlanner.m_TotalPath.size()&gt;0)
-				currIndexToGoal = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(pR-&gt;m_LocalPlanner.m_TotalPath.at(0), pR-&gt;m_LocalPlanner.state);
+				currIndexToGoal = PlannerHNS::PlanningHelpers::GetClosestNextPointIndexFast(pR-&gt;m_LocalPlanner.m_TotalPath.at(0), pR-&gt;m_LocalPlanner.state);
 //			int index_limit_total = pR-&gt;m_LocalPlanner.m_TotalPath.size() - 25;
 //			if(index_limit_total&lt;=0)
 //				index_limit_total =  pR-&gt;m_LocalPlanner.m_TotalPath.size()/2.0;
@@ -1527,7 +1523,16 @@ void* PlannerTestDraw::PlanningThreadStaticEntryPoint(void* pThis)
 			if(pR-&gt;m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl == 1 &amp;&amp; pR-&gt;m_CurrentBehavior.state != PlannerHNS::INITIAL_STATE)
 				bEmergencyStop = true;
 
-			pR-&gt;m_CurrentBehavior = pR-&gt;m_LocalPlanner.DoOneStep(dt, currTargetState, obj_list, 1, pR-&gt;m_RoadMap, bEmergencyStop, pR-&gt;m_bGreenTrafficLight);
+			PlannerHNS::TrafficLight tl;
+			vector&lt;PlannerHNS::TrafficLight&gt; tls;
+			if(pR-&gt;m_bGreenTrafficLight)
+				tl.lightState = PlannerHNS::GREEN_LIGHT;
+			else
+				tl.lightState = PlannerHNS::RED_LIGHT;
+
+			tls.push_back(tl);
+
+			pR-&gt;m_CurrentBehavior = pR-&gt;m_LocalPlanner.DoOneStep(dt, currTargetState, obj_list, 1, pR-&gt;m_RoadMap, bEmergencyStop, tls);
 
 			PlannerHNS::PlanningHelpers::WritePathToFile("/home/hatem/SimuLogs/Test", pR-&gt;m_LocalPlanner.m_Path);
 
@@ -1813,4 +1818,58 @@ void* PlannerTestDraw::SimulationThreadStaticEntryPoint(void* pThis)
 	return 0;
 }
 
+
+void* PlannerTestDraw::GameWheelThreadStaticEntryPoint(void* pThis)
+{
+
+	PlannerTestDraw* pR = (PlannerTestDraw*)pThis;
+	/*jsJoystick* pWheel = new jsJoystick(0);
+	int nAxis = pWheel-&gt;getNumAxes();
+	float* pAxis = new float[nAxis];
+	int nButtons = pWheel-&gt;getNumButtons();
+	int* pButtons = new int[nButtons];
+
+	cout &lt;&lt; "Axis Number: " &lt;&lt; nAxis &lt;&lt; endl;
+
+	while(!pR-&gt;m_bCancelThread)
+	{
+		pWheel-&gt;read(pButtons, pAxis);
+
+		if(pButtons[BUTTON_INDEX] == START_BUTTON_VALUE)
+			cout &lt;&lt; "Start Button Value: " &lt;&lt; 1 &lt;&lt; endl;
+		else
+			cout &lt;&lt; "Start Button Value: " &lt;&lt; 0 &lt;&lt; endl;
+
+		cout &lt;&lt; "Steering Axis Value: " &lt;&lt; -pAxis[STEERING_AXIS] &lt;&lt; endl;
+		cout &lt;&lt; "Acceleration Axis Value: " &lt;&lt; 1 - pAxis[ACCELERATION_AXIS] &lt;&lt; endl;
+		cout &lt;&lt; "Braking Axis Value: " &lt;&lt; 1 - pAxis[BRAKE_AXIS] &lt;&lt; endl;
+
+		pR-&gt;m_SteeringAngle = -pAxis[STEERING_AXIS];
+		pR-&gt;m_Acceleration = 1 - pAxis[ACCELERATION_AXIS];
+		pR-&gt;m_Braking = 1 - pAxis[BRAKE_AXIS];
+
+		pthread_mutex_lock(&amp;pR-&gt;control_mutex);
+		if(pR-&gt;m_Acceleration &gt; 0)
+			pR-&gt;m_VehicleTargetState.shift = PlannerHNS::SHIFT_POS_DD;
+		pR-&gt;m_VehicleTargetState.speed = pR-&gt;m_LocalPlanner.m_CarInfo.max_speed_forward * pR-&gt;m_Acceleration;
+
+		if(pR-&gt;m_Braking &gt; 0)
+			pR-&gt;m_VehicleTargetState.speed = 0;
+
+		pR-&gt;m_VehicleTargetState.steer = pR-&gt;m_SteeringAngle*pR-&gt;m_LocalPlanner.m_CarInfo.max_steer_angle;
+
+		pthread_mutex_unlock(&amp;pR-&gt;control_mutex);
+
+		usleep(10000);
+	}
+
+	delete [] pAxis;
+	delete [] pButtons;
+	delete pWheel;
+
+	cout &lt;&lt; "Exit Game Wheel Loop." &lt;&lt; endl;
+	*/
+	return pR;
+}
+
 } /* namespace Graphics */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\SimpleTracker.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\SimpleTracker.cpp" added_lines="67" deleted_lines="25">
				<diff>@@ -23,18 +23,22 @@ namespace SimulationNS
 
 using namespace PlannerHNS;
 
-SimpleTracker::SimpleTracker(double horizon)
+SimpleTracker::SimpleTracker()
 {
 	iTracksNumber = 1;
 	m_DT = 0.1;
 	m_MAX_ASSOCIATION_DISTANCE = 3.0;
 	m_MAX_TRACKS_AFTER_LOSING = 10;
-	m_MaxKeepTime = 15; // seconds
+	m_MaxKeepTime = 2; // seconds
 	m_bUseCenterOnly = true;
 	m_bFirstCall = true;
 	UtilityHNS::UtilityH::GetTickCount(m_TrackTimer);
+}
 
-	InitializeInterestRegions(horizon, 5, 5, m_InterestRegions);
+void SimpleTracker::InitSimpleTracker()
+{
+	UtilityHNS::UtilityH::GetTickCount(m_TrackTimer);
+	InitializeInterestRegions(TRACKING_HORIZON, 5, 5, m_InterestRegions);
 }
 
 SimpleTracker::~SimpleTracker()
@@ -63,9 +67,10 @@ void SimpleTracker::InitializeInterestRegions(double horizon, double init_raduis
 		if(regions.size() == 0)
 		{
 			pCir-&gt;radius = 5;
-			pCir-&gt;pPrevCircle = 0;
-			//pCir-&gt;forget_time = NEVER_GORGET_TIME;
+			//pCir-&gt;pPrevCircle = 0;
+			pCir-&gt;forget_time = NEVER_GORGET_TIME;
 			pCir-&gt;forget_time = m_MaxKeepTime*2.0;
+			pCir-&gt;forget_time = m_MaxKeepTime;
 			regions.push_back(pCir);
 			std::cout &lt;&lt; "Region No: " &lt;&lt; regions.size() &lt;&lt; ", Radius: " &lt;&lt; pCir-&gt;radius &lt;&lt; ", F time: " &lt;&lt; pCir-&gt;forget_time &lt;&lt; std::endl;
 		}
@@ -77,9 +82,10 @@ void SimpleTracker::InitializeInterestRegions(double horizon, double init_raduis
 			else
 				pCir-&gt;radius = regions.at(iPrev)-&gt;radius + regions.at(iPrev)-&gt;radius;
 
-			regions.at(iPrev)-&gt;pNextCircle = pCir;
-			pCir-&gt;pPrevCircle = regions.at(iPrev);
+//			regions.at(iPrev)-&gt;pNextCircle = pCir;
+//			pCir-&gt;pPrevCircle = regions.at(iPrev);
 			pCir-&gt;forget_time = m_MaxKeepTime-iPrev-2;
+			pCir-&gt;forget_time = m_MaxKeepTime;
 			if(pCir-&gt;forget_time &lt;= 0 )
 				pCir-&gt;forget_time = 0.2;
 			regions.push_back(pCir);
@@ -205,6 +211,50 @@ void SimpleTracker::AssociateAndTrack()
 	}
 }
 
+void SimpleTracker::AssociateSimply()
+{
+	std::vector&lt;KFTrackV&gt; newObjects;
+	for(unsigned int j = 0; j &lt; m_DetectedObjects.size(); j++)
+	{
+		double iCloseset = 0;
+		double dCloseset = 9999999;
+		for(unsigned int i = 0; i &lt; m_TrackSimply.size(); i++)
+		{
+			double d = hypot(m_DetectedObjects.at(j).center.pos.y-m_TrackSimply.at(i).obj.center.pos.y, m_DetectedObjects.at(j).center.pos.x-m_TrackSimply.at(i).obj.center.pos.x);
+			if(d &lt; dCloseset)
+			{
+				dCloseset = d;
+				iCloseset = i;
+			}
+		}
+
+		if(dCloseset &lt;= m_MAX_ASSOCIATION_DISTANCE)
+		{
+			m_DetectedObjects.at(j).id = m_TrackSimply.at(iCloseset).obj.id;
+			m_DetectedObjects.at(j).center.pos.a = m_TrackSimply.at(iCloseset).obj.center.pos.a;
+			m_TrackSimply.at(iCloseset).obj = m_DetectedObjects.at(j);
+			newObjects.push_back(m_TrackSimply.at(iCloseset));
+		}
+		else
+		{
+			iTracksNumber = iTracksNumber + 1;
+			m_DetectedObjects.at(j).id = iTracksNumber;
+			KFTrackV track(m_DetectedObjects.at(j).center.pos.x, m_DetectedObjects.at(j).center.pos.y,m_DetectedObjects.at(j).center.pos.a, m_DetectedObjects.at(j).id, m_DT);
+			track.obj = m_DetectedObjects.at(j);
+			newObjects.push_back(track);
+		}
+	}
+
+	m_TrackSimply = newObjects;
+
+	for(unsigned int i =0; i&lt; m_TrackSimply.size(); i++)
+		m_TrackSimply.at(i).UpdateTracking(m_DT, m_TrackSimply.at(i).obj, m_TrackSimply.at(i).obj);
+
+	m_DetectedObjects.clear();
+	for(unsigned int i = 0; i&lt; m_TrackSimply.size(); i++)
+		m_DetectedObjects.push_back(m_TrackSimply.at(i).obj);
+}
+
 void SimpleTracker::CreateTrackV2(DetectedObject&amp; o)
 {
 	iTracksNumber = iTracksNumber + 1;
@@ -219,9 +269,7 @@ void SimpleTracker::TrackV2()
 {
 	for(unsigned int i =0; i&lt; m_Tracks.size(); i++)
 	{
-		m_Tracks.at(i)-&gt;UpdateTracking(m_DT, m_Tracks.at(i)-&gt;obj.center.pos.x, m_Tracks.at(i)-&gt;obj.center.pos.y, m_Tracks.at(i)-&gt;obj.center.pos.a,
-				m_Tracks.at(i)-&gt;obj.center.pos.x, m_Tracks.at(i)-&gt;obj.center.pos.y, m_Tracks.at(i)-&gt;obj.center.pos.a,
-				m_Tracks.at(i)-&gt;obj.center.v);
+		m_Tracks.at(i)-&gt;UpdateTracking(m_DT, m_Tracks.at(i)-&gt;obj, m_Tracks.at(i)-&gt;obj);
 
 		//std::cout&lt;&lt; "Obj ID: " &lt;&lt; m_Tracks.at(i)-&gt;GetTrackID() &lt;&lt; ", Remaining Time: " &lt;&lt;  m_Tracks.at(i)-&gt;forget_time  &lt;&lt; std::endl;
 	}
@@ -230,7 +278,7 @@ void SimpleTracker::TrackV2()
 void SimpleTracker::CleanOldTracks()
 {
 	m_DetectedObjects.clear();
-	for(int i = 0; i&lt; m_Tracks.size(); i++)
+	for(int i = 0; i&lt; (int)m_Tracks.size(); i++)
 	{
 		if(m_Tracks.at(i)-&gt;forget_time &lt; 0 &amp;&amp; m_Tracks.at(i)-&gt;forget_time &gt; NEVER_GORGET_TIME)
 		{
@@ -255,25 +303,20 @@ void SimpleTracker::DoOneStep(const WayPoint&amp; currPose, const std::vector&lt;Detect
 	UtilityHNS::UtilityH::GetTickCount(m_TrackTimer);
 
 	//std::cout &lt;&lt; " Tracking Time : " &lt;&lt; m_DT &lt;&lt; std::endl;
-
 	m_DetectedObjects = obj_list;
 
-	AssociateAndTrack();
-
-	TrackV2();
+	AssociateSimply();
 
-	CleanOldTracks();
+//	AssociateAndTrack();
+//	TrackV2();
+//	CleanOldTracks();
 
 
 
 //	AssociateObjects();
-//
 //	Track(m_DetectedObjects);
-//
 //	m_PrevDetectedObjects = m_DetectedObjects;
-//
 //	m_PrevState = currPose;
-
 }
 
 void SimpleTracker::AssociateObjects()
@@ -361,8 +404,7 @@ void SimpleTracker::CreateTrack(DetectedObject&amp; o)
 {
 	KFTrackV* pT = new KFTrackV(o.center.pos.x, o.center.pos.y,o.center.pos.a, o.id, m_DT);
 	o.id = pT-&gt;GetTrackID();
-	pT-&gt;UpdateTracking(m_DT, o.center.pos.x, o.center.pos.y, o.center.pos.a,
-			o.center.pos.x, o.center.pos.y,o.center.pos.a, o.center.v);
+	pT-&gt;UpdateTracking(m_DT, o, o);
 	m_Tracks.push_back(pT);
 }
 
@@ -386,9 +428,9 @@ void SimpleTracker::Track(std::vector&lt;DetectedObject&gt;&amp; objects_list)
 			KFTrackV* pT = FindTrack(objects_list[i].id);
 			if(pT)
 			{
-				pT-&gt;UpdateTracking(m_DT, objects_list[i].center.pos.x, objects_list[i].center.pos.y, objects_list[i].center.pos.a,
-						objects_list[i].center.pos.x, objects_list[i].center.pos.y, objects_list[i].center.pos.a,
-						objects_list[i].center.v);
+//				pT-&gt;UpdateTracking(m_DT, objects_list[i].center.pos.x, objects_list//[i].center.pos.y, objects_list[i].center.pos.a,
+						//objects_list[i].center.pos.x, objects_list[i].center.pos.y, //objects_list[i].center.pos.a,
+//						objects_list[i].center.v);
 				//std::cout &lt;&lt; "Update Current Track " &lt;&lt; objects_list[i].id &lt;&lt; std::endl;
 			}
 			else
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\TrajectoryFollower.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\TrajectoryFollower.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -134,7 +134,7 @@ bool TrajectoryFollower::FindNextWayPoint(const std::vector&lt;PlannerHNS::WayPoint
 	if(totalD &lt;= 1 || totalD &lt;= d_critical)
 	{
 		m_bEndPath = true;
-		cout &lt;&lt; "Critical Distance: " &lt;&lt; d_critical &lt;&lt; endl;
+		//cout &lt;&lt; "Critical Distance: " &lt;&lt; d_critical &lt;&lt; endl;
 	}
 	else
 		m_bEndPath = false;
@@ -276,7 +276,7 @@ int TrajectoryFollower::VeclocityControllerUpdate(const double&amp; dt, const Planne
 		if((desiredVelocity &lt; 0.1 &amp;&amp; desiredVelocity &gt; -0.1) || CurrBehavior.followDistance &lt;= 0) //use only effective velocities
 			desiredVelocity = 0;
 
-		cout &lt;&lt; "Follow State:  acceleration = " &lt;&lt; deceleration_critical &lt;&lt; ", speed = " &lt;&lt; desiredVelocity &lt;&lt;  ", Distance = " &lt;&lt; CurrBehavior.followDistance&lt;&lt; endl;
+		//cout &lt;&lt; "Follow State:  acceleration = " &lt;&lt; deceleration_critical &lt;&lt; ", speed = " &lt;&lt; CurrStatus.speed &lt;&lt;  ", Distance = " &lt;&lt; CurrBehavior.followDistance&lt;&lt; endl;
 	}
 	else
 	{
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\DataRW.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\include\DataRW.h" added_lines="41" deleted_lines="0">
				<diff>@@ -25,6 +25,7 @@ public:
 	static std::string LoggingMainfolderName;
 	static std::string ControlLogFolderName;
 	static std::string PathLogFolderName;
+	static std::string GlobalPathLogFolderName;
 	static std::string StatesLogFolderName;
 	static std::string SimulationFolderName;
 	static std::string KmlMapsFolderName;
@@ -134,6 +135,7 @@ public:
 		double a;
 		double c;
 		double v;
+		std::string name;
 	};
 
 	struct SimulationData
@@ -413,6 +415,45 @@ public:
 	int ReadAllData(std::vector&lt;AisanVector&gt;&amp; data_list);
 };
 
+class AisanCurbFileReader : public SimpleReaderBase
+{
+public:
+
+	struct AisanCurb
+	{
+		int 	ID;
+		int 	LID;
+		double 	Height;
+		double 	Width;
+		int 	dir;
+		int 	LinkID;
+	};
+
+	AisanCurbFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	~AisanCurbFileReader(){}
+
+	bool ReadNextLine(AisanCurb&amp; data);
+	int ReadAllData(std::vector&lt;AisanCurb&gt;&amp; data_list);
+};
+
+class AisanRoadEdgeFileReader : public SimpleReaderBase
+{
+public:
+
+	struct AisanRoadEdge
+	{
+		int 	ID;
+		int 	LID;
+		int 	LinkID;
+	};
+
+	AisanRoadEdgeFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	~AisanRoadEdgeFileReader(){}
+
+	bool ReadNextLine(AisanRoadEdge&amp; data);
+	int ReadAllData(std::vector&lt;AisanRoadEdge&gt;&amp; data_list);
+};
+
 class AisanDataConnFileReader : public SimpleReaderBase
 {
 public:
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_utility\src\DataRW.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_utility\src\DataRW.cpp" added_lines="72" deleted_lines="1">
				<diff>@@ -17,6 +17,7 @@ namespace UtilityHNS
 
 std::string DataRW::LoggingMainfolderName 	= "/SimuLogs/";
 std::string DataRW::ControlLogFolderName 	= "ControlLogs/";
+std::string DataRW::GlobalPathLogFolderName = "GlobalPathLogs/";
 std::string DataRW::PathLogFolderName 		= "TrajectoriesLogs/";
 std::string DataRW::StatesLogFolderName 	= "BehaviorsLogs/";
 std::string DataRW::SimulationFolderName 	= "SimulationData/";
@@ -329,7 +330,7 @@ bool SimulationFileReader::ReadNextLine(SimulationPoint&amp; data)
 	if(ReadSingleLine(lineData))
 	{
 		if(lineData.size()==0) return false;
-		if(lineData.at(0).size() &lt; 5) return false;
+		if(lineData.at(0).size() &lt; 6) return false;
 
 		data.x = strtod(lineData.at(0).at(0).c_str(), NULL);
 		data.y = strtod(lineData.at(0).at(1).c_str(), NULL);
@@ -337,6 +338,7 @@ bool SimulationFileReader::ReadNextLine(SimulationPoint&amp; data)
 		data.a = strtod(lineData.at(0).at(3).c_str(), NULL);
 		data.c = strtod(lineData.at(0).at(4).c_str(), NULL);
 		data.v = strtod(lineData.at(0).at(5).c_str(), NULL);
+		data.name = lineData.at(0).at(6);
 
 		return true;
 
@@ -827,6 +829,75 @@ int AisanVectorFileReader::ReadAllData(vector&lt;AisanVector&gt;&amp; data_list)
 	return count;
 }
 
+bool AisanCurbFileReader::ReadNextLine(AisanCurb&amp; data)
+{
+	vector&lt;vector&lt;string&gt; &gt; lineData;
+	if(ReadSingleLine(lineData))
+	{
+		if(lineData.size()==0) return false;
+		if(lineData.at(0).size() &lt; 6) return false;
+
+		data.ID 	= strtol(lineData.at(0).at(0).c_str(), NULL, 10);
+		data.LID 	= strtol(lineData.at(0).at(1).c_str(), NULL, 10);
+		data.Height = strtod(lineData.at(0).at(2).c_str(), NULL);
+		data.Width 	= strtod(lineData.at(0).at(3).c_str(), NULL);
+		data.dir 	= strtol(lineData.at(0).at(0).c_str(), NULL, 10);
+		data.LinkID = strtol(lineData.at(0).at(1).c_str(), NULL, 10);
+
+		return true;
+
+	}
+	else
+		return false;
+}
+
+int AisanCurbFileReader::ReadAllData(vector&lt;AisanCurb&gt;&amp; data_list)
+{
+	data_list.clear();
+	AisanCurb data;
+	//double logTime = 0;
+	int count = 0;
+	while(ReadNextLine(data))
+	{
+		data_list.push_back(data);
+		count++;
+	}
+	return count;
+}
+
+bool AisanRoadEdgeFileReader::ReadNextLine(AisanRoadEdge&amp; data)
+{
+	vector&lt;vector&lt;string&gt; &gt; lineData;
+	if(ReadSingleLine(lineData))
+	{
+		if(lineData.size()==0) return false;
+		if(lineData.at(0).size() &lt; 3) return false;
+
+		data.ID 	= strtol(lineData.at(0).at(0).c_str(), NULL, 10);
+		data.LID 	= strtol(lineData.at(0).at(1).c_str(), NULL, 10);
+		data.LinkID = strtol(lineData.at(0).at(1).c_str(), NULL, 10);
+
+		return true;
+
+	}
+	else
+		return false;
+}
+
+int AisanRoadEdgeFileReader::ReadAllData(vector&lt;AisanRoadEdge&gt;&amp; data_list)
+{
+	data_list.clear();
+	AisanRoadEdge data;
+	//double logTime = 0;
+	int count = 0;
+	while(ReadNextLine(data))
+	{
+		data_list.push_back(data);
+		count++;
+	}
+	return count;
+}
+
 bool AisanDataConnFileReader::ReadNextLine(DataConn&amp; data)
 {
 	vector&lt;vector&lt;string&gt; &gt; lineData;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\nodes\RosHelpers.cpp" new_path="ros\src\computing\planning\mission\packages\way_planner\nodes\RosHelpers.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -491,7 +491,7 @@ void RosHelpers::FindIncommingBranches(const std::vector&lt;std::vector&lt;PlannerHNS:
 	static int detection_range = 30; // meter
 	if(globalPaths.size() &gt; 0)
 	{
-		int close_index = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(globalPaths.at(0), currPose);
+		int close_index = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex_obsolete(globalPaths.at(0), currPose);
 		PlannerHNS::WayPoint closest_wp = globalPaths.at(0).at(close_index);
 		double d = 0;
 		for(unsigned int i=close_index+1; i &lt; globalPaths.at(0).size(); i++)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner_core.cpp" new_path="ros\src\computing\planning\mission\packages\way_planner\nodes\way_planner_core.cpp" added_lines="4" deleted_lines="2">
				<diff>@@ -362,10 +362,12 @@ void way_planner_core::UpdateRoadMap(const AutowareRoadNetwork&amp; src_map, Planner
 	std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt; stop_line_data;
 	std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt; signal_data;
 	std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt; vector_data;
+	std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt; curb_data;
+	std::vector&lt;UtilityHNS::AisanRoadEdgeFileReader::AisanRoadEdge&gt; roadedge_data;
 	std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt; conn_data;
 
 	PlannerHNS::GPSPoint origin;//(m_OriginPos.position.x, m_OriginPos.position.y, m_OriginPos.position.z, 0);
-	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(lanes, points, dts,inters, areas, line_data, stop_line_data, signal_data, vector_data,conn_data, origin, out_map);
+	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(lanes, points, dts, inters, areas, line_data, stop_line_data, signal_data, vector_data, curb_data, roadedge_data, conn_data, origin, out_map);
 }
 
 bool way_planner_core::GenerateGlobalPlan(PlannerHNS::WayPoint&amp; startPoint, PlannerHNS::WayPoint&amp; goalPoint, std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; generatedTotalPaths)
@@ -586,7 +588,7 @@ bool way_planner_core::HMI_DoOneStep()
 
 		std::cout &lt;&lt; ")" &lt;&lt; std::endl;
 
-		int close_index = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(m_GeneratedTotalPaths.at(0), startPoint);
+		int close_index = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex_obsolete(m_GeneratedTotalPaths.at(0), startPoint);
 
 		for(unsigned int i=close_index+1; i &lt; m_GeneratedTotalPaths.at(0).size(); i++)
 		{
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\include\PolygonGenerator.h" new_path="ros\src\computing\planning\motion\packages\dp_planner\include\PolygonGenerator.h" added_lines="1" deleted_lines="0">
				<diff>@@ -9,6 +9,7 @@
 #define POLYGONGENERATOR_H_
 
 #include "RoadNetwork.h"
+#include "PlanningHelpers.h"
 #include &lt;sensor_msgs/PointCloud2.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\PolygonGenerator.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\PolygonGenerator.cpp" added_lines="9" deleted_lines="10">
				<diff>@@ -6,7 +6,6 @@
  */
 
 #include "PolygonGenerator.h"
-#include "PlanningHelpers.h"
 
 namespace PlannerXNS
 {
@@ -21,9 +20,9 @@ PolygonGenerator::~PolygonGenerator() {
 	// TODO Auto-generated destructor stub
 }
 
-GPSPoint PolygonGenerator::CalculateCentroid(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster)
+PlannerHNS::GPSPoint PolygonGenerator::CalculateCentroid(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster)
 {
-	GPSPoint c;
+	PlannerHNS::GPSPoint c;
 
 	for(unsigned int i=0; i&lt; cluster.points.size(); i++)
 	{
@@ -37,21 +36,21 @@ GPSPoint PolygonGenerator::CalculateCentroid(const pcl::PointCloud&lt;pcl::PointXYZ
 	return c;
 }
 
-std::vector&lt;GPSPoint&gt; PolygonGenerator::EstimateClusterPolygon(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster, const GPSPoint&amp; original_centroid )
+std::vector&lt;PlannerHNS::GPSPoint&gt; PolygonGenerator::EstimateClusterPolygon(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster, const PlannerHNS::GPSPoint&amp; original_centroid )
 {
 	std::vector&lt;QuarterView&gt; quarters = CreateQuarterViews(QUARTERS_NUMBER);
 
 
 	for(unsigned int i=0; i&lt; cluster.points.size(); i++)
 	{
-		WayPoint p;
+		PlannerHNS::WayPoint p;
 		p.pos.x = cluster.points.at(i).x;
 		p.pos.y = cluster.points.at(i).y;
 		p.pos.z = original_centroid.z;
 
-		POINT2D v(p.pos.x - original_centroid.x , p.pos.y - original_centroid.y);
+		PlannerHNS::GPSPoint v(p.pos.x - original_centroid.x , p.pos.y - original_centroid.y,p.pos.z,0);
 		p.cost = pointNorm(v);
-		p.pos.a = UtilityHNS::UtilityH::FixNegativeAngle(atan2(v.y, v.x))*RAD2DEG;
+		p.pos.a = UtilityHNS::UtilityH::FixNegativeAngle(atan2(v.y, v.x))*(180. / M_PI);
 
 		for(unsigned int j = 0 ; j &lt; quarters.size(); j++)
 		{
@@ -60,12 +59,12 @@ std::vector&lt;GPSPoint&gt; PolygonGenerator::EstimateClusterPolygon(const pcl::PointC
 		}
 	}
 
-	std::vector&lt;GPSPoint&gt; polygon;
+	std::vector&lt;PlannerHNS::GPSPoint&gt; polygon;
 
 	for(unsigned int j = 0 ; j &lt; quarters.size(); j++)
 	{
 
-		WayPoint wp;
+		PlannerHNS::WayPoint wp;
 		int nPoints = quarters.at(j).GetMaxPoint(wp);
 		if(nPoints &gt;= MIN_POINTS_PER_QUARTER)
 		{
@@ -119,7 +118,7 @@ std::vector&lt;QuarterView&gt; PolygonGenerator::CreateQuarterViews(const int&amp; nResolu
 	return quarters;
 }
 
-void CheckConvexPoligon(std::vector&lt;WayPoint&gt;&amp; polygon)
+void CheckConvexPoligon(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; polygon)
 {
 
 //	if(polygon.size() &lt;= 3)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\RosHelpers.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\RosHelpers.cpp" added_lines="7" deleted_lines="5">
				<diff>@@ -62,11 +62,11 @@ void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;Plann
 		wp.pose.pose.position.z = path.at(i).pos.z;
 		wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(UtilityHNS::UtilityH::SplitPositiveAngle(path.at(i).pos.a));
 		wp.twist.twist.linear.x = path.at(i).v;
-		if(path.at(i).bDir == FORWARD_DIR)
+		if(path.at(i).bDir == PlannerHNS::FORWARD_DIR)
 			wp.dtlane.dir = 0;
-		else if(path.at(i).bDir == FORWARD_LEFT_DIR)
+		else if(path.at(i).bDir == PlannerHNS::FORWARD_LEFT_DIR)
 			wp.dtlane.dir = 1;
-		else if(path.at(i).bDir == FORWARD_RIGHT_DIR)
+		else if(path.at(i).bDir == PlannerHNS::FORWARD_RIGHT_DIR)
 			wp.dtlane.dir = 2;
 		//PlannerHNS::GPSPoint p = path.at(i).pos;
 		//std::cout &lt;&lt; p.ToString() &lt;&lt; std::endl;
@@ -621,7 +621,7 @@ void RosHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(const Planne
 	{
 		PolygonGenerator polyGen;
 		PlannerHNS::DetectedObject obj;
-		obj.center.pos = GPSPoint(clusters.clusters.at(i).centroid_point.point.x,
+		obj.center.pos = PlannerHNS::GPSPoint(clusters.clusters.at(i).centroid_point.point.x,
 				clusters.clusters.at(i).centroid_point.point.y,
 				clusters.clusters.at(i).centroid_point.point.z,0);
 				//tf::getYaw(clusters.clusters.at(i).bounding_box.pose.orientation));
@@ -839,10 +839,12 @@ void RosHelpers::UpdateRoadMap(const AutowareRoadNetwork&amp; src_map, PlannerHNS::R
 	std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt; stop_line_data;
 	std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt; signal_data;
 	std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt; vector_data;
+	std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt; curb_data;
+	std::vector&lt;UtilityHNS::AisanRoadEdgeFileReader::AisanRoadEdge&gt; roadedge_data;
 	std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt; conn_data;
 
 	PlannerHNS::GPSPoint origin;//(m_OriginPos.position.x, m_OriginPos.position.y, m_OriginPos.position.z, 0);
-	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(lanes, points, dts, inters, areas, line_data, stop_line_data, signal_data, vector_data,conn_data, origin, out_map);
+	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(lanes, points, dts, inters, areas, line_data, stop_line_data, signal_data, vector_data,curb_data, roadedge_data, conn_data, origin, out_map);
 }
 
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" added_lines="6" deleted_lines="7">
				<diff>@@ -29,8 +29,6 @@
 #include "dp_planner_core.h"
 
 #include &lt;visualization_msgs/MarkerArray.h&gt;
-#include "geo_pos_conv.hh"
-
 
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 #include &lt;pcl/io/io.h&gt;
@@ -771,7 +769,7 @@ void PlannerX::callbackGetWayPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp;
 	if(msg-&gt;lanes.size() &gt; 0)
 	{
 		m_WayPlannerPaths.clear();
-		bool bOldGlobalPath = m_LocalPlanner.m_TotalPath.size() == msg-&gt;lanes.size();
+		bool bOldGlobalPath = m_LocalPlanner.m_TotalOriginalPath.size() == msg-&gt;lanes.size();
 		for(unsigned int i = 0 ; i &lt; msg-&gt;lanes.size(); i++)
 		{
 			std::vector&lt;PlannerHNS::WayPoint&gt; path;
@@ -851,7 +849,7 @@ void PlannerX::callbackGetWayPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp;
 
 			if(bOldGlobalPath)
 			{
-				bOldGlobalPath = PlannerHNS::PlanningHelpers::CompareTrajectories(path, m_LocalPlanner.m_TotalPath.at(i));
+				bOldGlobalPath = PlannerHNS::PlanningHelpers::CompareTrajectories(path, m_LocalPlanner.m_TotalOriginalPath.at(i));
 			}
 		}
 
@@ -861,7 +859,7 @@ void PlannerX::callbackGetWayPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp;
 			bWayPlannerPath = true;
 			m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bNewGlobalPath = true;
 			//m_CurrentGoal = m_WayPlannerPaths.at(0).at(m_WayPlannerPaths.at(0).size()-1);
-			m_LocalPlanner.m_TotalPath = m_WayPlannerPaths;
+			m_LocalPlanner.m_TotalOriginalPath = m_WayPlannerPaths;
 
 			cout &lt;&lt; "Global Lanes Size = " &lt;&lt; msg-&gt;lanes.size() &lt;&lt;", Conv Size= " &lt;&lt; m_WayPlannerPaths.size() &lt;&lt; ", First Lane Size: " &lt;&lt; m_WayPlannerPaths.at(0).size() &lt;&lt; endl;
 
@@ -916,7 +914,7 @@ void PlannerX::PlannerMainLoop()
 		}
 
 		int iDirection = 0;
-		if(bInitPos &amp;&amp; m_LocalPlanner.m_TotalPath.size()&gt;0)
+		if(bInitPos &amp;&amp; m_LocalPlanner.m_TotalOriginalPath.size()&gt;0)
 		{
 //			bool bMakeNewPlan = false;
 //			double drift = hypot(m_LocalPlanner.state.pos.y-m_CurrentPos.pos.y, m_LocalPlanner.state .pos.x-m_CurrentPos.pos.x);
@@ -929,7 +927,8 @@ void PlannerX::PlannerMainLoop()
 			double dt  = UtilityHNS::UtilityH::GetTimeDiffNow(m_PlanningTimer);
 			UtilityHNS::UtilityH::GetTickCount(m_PlanningTimer);
 
-			m_CurrentBehavior = m_LocalPlanner.DoOneStep(dt, m_VehicleState, m_TrackedClusters, 1, m_Map, m_bEmergencyStop, m_bGreenLight, true);
+			std::vector&lt;PlannerHNS::TrafficLight&gt; trafficLight;
+			m_CurrentBehavior = m_LocalPlanner.DoOneStep(dt, m_VehicleState, m_TrackedClusters, 1, m_Map, m_bEmergencyStop, trafficLight, true);
 
 			visualization_msgs::Marker behavior_rviz;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\nodes\ff_waypoint_follower_core.cpp" new_path="ros\src\computing\planning\motion\packages\ff_waypoint_follower\nodes\ff_waypoint_follower_core.cpp" added_lines="30" deleted_lines="31">
				<diff>@@ -33,7 +33,6 @@
 #include &lt;visualization_msgs/InteractiveMarkerPose.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
 #include &lt;std_msgs/Float32.h&gt;
-#include "geo_pos_conv.hh"
 #include "UtilityH.h"
 #include "math.h"
 
@@ -658,36 +657,36 @@ void FFSteerControl::PlannerMainLoop()
 				std::cout &lt;&lt; "Record One Point To Path: " &lt;&lt;  m_CurrentPos.pos.ToString() &lt;&lt; std::endl;
 			}
 
-			if(totalDistance &gt; m_CmdParams.recordDistance || m_bOutsideControl != 0)
-			{
-				PlannerHNS::RoadNetwork roadMap;
-				PlannerHNS::RoadSegment segment;
-
-				segment.id = 1;
-
-				PlannerHNS::Lane lane;
-				lane.id = 1;
-				lane.num = 0;
-				lane.roadId = 1;
-				lane.points = path;
-
-				segment.Lanes.push_back(lane);
-				roadMap.roadSegments.push_back(segment);
-
-				ostringstream fileName;
-				fileName &lt;&lt; UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName;
-				fileName &lt;&lt; UtilityHNS:: UtilityH::GetFilePrefixHourMinuteSeconds();
-				fileName &lt;&lt; "_RoadNetwork.kml";
-				string kml_templateFilePath = UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName + UtilityHNS::DataRW::KmlMapsFolderName+"PlannerX_MapTemplate.kml";
-
-				PlannerHNS::MappingHelpers::WriteKML(fileName.str(),kml_templateFilePath , roadMap);
-
-										//string kml_fileToSave =UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName + DataRW::KmlMapsFolderName+kmltargetFile;
-					//PlannerHNS::MappingHelpers::WriteKML(kml_fileToSave, kml_templateFilePath, m_RoadMap);
-
-				std::cout &lt;&lt; " Mapped Saved Successfuly ... " &lt;&lt; std::endl;
-				break;
-			}
+//			if(totalDistance &gt; m_CmdParams.recordDistance || m_bOutsideControl != 0)
+//			{
+//				PlannerHNS::RoadNetwork roadMap;
+//				PlannerHNS::RoadSegment segment;
+//
+//				segment.id = 1;
+//
+//				PlannerHNS::Lane lane;
+//				lane.id = 1;
+//				lane.num = 0;
+//				lane.roadId = 1;
+//				lane.points = path;
+//
+//				segment.Lanes.push_back(lane);
+//				roadMap.roadSegments.push_back(segment);
+//
+//				ostringstream fileName;
+//				fileName &lt;&lt; UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName;
+//				fileName &lt;&lt; UtilityHNS:: UtilityH::GetFilePrefixHourMinuteSeconds();
+//				fileName &lt;&lt; "_RoadNetwork.kml";
+//				string kml_templateFilePath = UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName + UtilityHNS::DataRW::KmlMapsFolderName+"PlannerX_MapTemplate.kml";
+//
+//				//PlannerHNS::MappingHelpers::WriteKML(fileName.str(),kml_templateFilePath , roadMap);
+//
+//										//string kml_fileToSave =UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName + DataRW::KmlMapsFolderName+kmltargetFile;
+//					//PlannerHNS::MappingHelpers::WriteKML(kml_fileToSave, kml_templateFilePath, m_RoadMap);
+//
+//				std::cout &lt;&lt; " Mapped Saved Successfuly ... " &lt;&lt; std::endl;
+//				break;
+//			}
 		 }
 
 		loop_rate.sleep();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\include\PolygonGenerator.h" new_path="ros\src\computing\planning\motion\packages\op_simulator\include\PolygonGenerator.h" added_lines="4" deleted_lines="2">
				<diff>@@ -8,6 +8,10 @@
 #ifndef POLYGONGENERATORSIMU_H_
 #define POLYGONGENERATORSIMU_H_
 
+#include "RoadNetwork.h"
+#include "PlanningHelpers.h"
+
+
 #include &lt;sensor_msgs/PointCloud2.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
@@ -15,8 +19,6 @@
 #include &lt;pcl/io/pcd_io.h&gt;
 #include &lt;pcl/point_types.h&gt;
 
-#include &lt;RoadNetwork.h&gt;
-
 namespace OpenPlannerSimulatorNS
 {
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\nodes\OpenPlannerSimulator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulator\nodes\OpenPlannerSimulator_core.cpp" added_lines="3" deleted_lines="2">
				<diff>@@ -29,7 +29,7 @@
 */
 #include "../include/OpenPlannerSimulator_core.h"
 
-#include "geo_pos_conv.hh"
+
 #include "UtilityH.h"
 #include "math.h"
 #include "MatrixOperations.h"
@@ -633,7 +633,8 @@ void OpenPlannerSimulator::PlannerMainLoop()
 			}
 
 			//Local Planning
-			currBehavior = m_LocalPlanner.DoOneStep(dt, currStatus, m_TrackedClusters, 1, m_Map, 0, 1, true);
+			std::vector&lt;TrafficLight&gt; trafficLight;
+			currBehavior = m_LocalPlanner.DoOneStep(dt, currStatus, m_TrackedClusters, 1, m_Map, 0, trafficLight, true);
 
 			 //Odometry Simulation and Update
 			m_LocalPlanner.SetSimulatedTargetOdometryReadings(desiredStatus.speed, desiredStatus.steer, desiredStatus.shift);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\nodes\PolygonGenerator.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulator\nodes\PolygonGenerator.cpp" added_lines="4" deleted_lines="3">
				<diff>@@ -5,8 +5,9 @@
  *      Author: ai-driver
  */
 
+
 #include "PolygonGenerator.h"
-#include "PlanningHelpers.h"
+
 
 namespace OpenPlannerSimulatorNS
 {
@@ -49,9 +50,9 @@ std::vector&lt;GPSPoint&gt; PolygonGenerator::EstimateClusterPolygon(const pcl::PointC
 		p.pos.y = cluster.points.at(i).y;
 		p.pos.z = original_centroid.z;
 
-		POINT2D v(p.pos.x - original_centroid.x , p.pos.y - original_centroid.y);
+		GPSPoint v(p.pos.x - original_centroid.x , p.pos.y - original_centroid.y, p.pos.z,0);
 		p.cost = pointNorm(v);
-		p.pos.a = UtilityHNS::UtilityH::FixNegativeAngle(atan2(v.y, v.x))*RAD2DEG;
+		p.pos.a = UtilityHNS::UtilityH::FixNegativeAngle(atan2(v.y, v.x))*(180. / M_PI);
 
 		for(unsigned int j = 0 ; j &lt; quarters.size(); j++)
 		{
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator_perception\nodes\OpenPlannerSimulatorPerception_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulator_perception\nodes\OpenPlannerSimulatorPerception_core.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -29,7 +29,6 @@
 */
 #include "../include/OpenPlannerSimulatorPerception_core.h"
 
-#include "geo_pos_conv.hh"
 #include "UtilityH.h"
 #include "math.h"
 #include "MatrixOperations.h"
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="71bbef3a5f54672114ee98811648d67d812c637b" author="Yusuke FUJII">
		<msg>Changed path state recognition to the way based on /lane_waypoints_array</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\cross_road_area.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\cross_road_area.hpp" added_lines="17" deleted_lines="3">
				<diff>@@ -19,7 +19,7 @@ public:
   std::vector&lt;geometry_msgs::Point&gt; points;
   jsk_recognition_msgs::BoundingBox bbox;
 
-  std::vector&lt; autoware_msgs::waypoint&gt; insideWaypoints;
+  std::vector&lt;autoware_msgs::waypoint&gt; insideWaypoints;
   std::vector&lt;geometry_msgs::Point&gt; insideWaypoint_points;
 
   CrossRoadArea(void)
@@ -33,8 +33,22 @@ public:
 
   static CrossRoadArea *findClosestCrossRoad(const autoware_msgs::lane &amp;_finalwaypoints,
 		  std::vector&lt;CrossRoadArea&gt; &amp;intersects);
-  static bool isInsideArea(const CrossRoadArea* _ClosestArea,
-                                             geometry_msgs::Point pt);
+  static bool isInsideArea(const CrossRoadArea* _TargetArea,
+ 		  geometry_msgs::Point pt);
+
+
+  static CrossRoadArea *getCrossRoadArea(std::vector&lt;CrossRoadArea&gt; &amp;areas, int aid)
+  {
+	  CrossRoadArea *ret = nullptr;
+	  for( auto &amp;area : areas){
+		  if(area.area_id == aid){
+			  ret = &amp;area;
+			  break;
+		  }
+	  }
+	  return ret;
+  }
+
 };
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="12" deleted_lines="7">
				<diff>@@ -16,6 +16,8 @@
 #include &lt;std_msgs/Int32.h&gt;
 #include &lt;std_msgs/String.h&gt;
 
+#include &lt;visualization_msgs/MarkerArray.h&gt;
+
 //#include &lt;vector_map_server/GetCrossRoad.h&gt;
 
 #include &lt;vector_map_msgs/AreaArray.h&gt;
@@ -96,7 +98,8 @@ private:
   std::vector&lt;geometry_msgs::Point&gt; inside_points_;
 
 
-  autoware_msgs::LaneArray current_lane_array_;
+  autoware_msgs::LaneArray current_based_lane_array_;
+  autoware_msgs::LaneArray current_controlled_lane_array_;
 
   // Current way/behavior status
   double current_velocity_;
@@ -111,9 +114,9 @@ private:
   // Param
   bool enableDisplayMarker;
   bool enableForceStateChange;
-  double param_convergence_threshold_;
   int param_convergence_count_;
   int param_target_waypoint_;
+  double param_convergence_threshold_;
 
   // for vectormap server
   // ros::ServiceClient cross_road_cli;
@@ -142,15 +145,20 @@ private:
 
   void publishToVelocityArray();
   std::string createStateMessageText();
+  int createCrossRoadAreaMarker(visualization_msgs::Marker &amp;crossroad_marker, double scale);
+
 
   // judge method
   // in near future, these methods will be deprecate to decision_maker library
   bool isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
   bool isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch, double _yaw);
-
   bool handleStateCmd(const unsigned long long _state_num);
+  double calcIntersectWayAngle(const CrossRoadArea&amp; area);
+
+  void insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects, autoware_msgs::LaneArray &amp;lane_array);
+
+  void setWaypointState(autoware_msgs::LaneArray &amp;lane_array);
 
-  double calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
 
   // callback by topic subscribing
   void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
@@ -170,9 +178,6 @@ private:
   void callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg);
   void callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg);
 
-  // in near future, these methods will be deprecate to ADAS library
-  CrossRoadArea *findClosestCrossRoad(void);
-
 public:
   state_machine::StateContext *ctx;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_param.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_param.hpp" added_lines="1" deleted_lines="1">
				<diff>@@ -15,7 +15,7 @@ namespace decision_maker
 #define DOUBLE_MAX 1.7976931348623158e308
 #define DEFAULT_TARGET_WAYPOINT 14
 
-#define ANGLE_NEUTRAL 180
+#define ANGLE_NEUTRAL 0
 #define ANGLE_CURVE 40
 #define ANGLE_LEFT  (ANGLE_NEUTRAL - ANGLE_CURVE)
 #define ANGLE_RIGHT (ANGLE_NEUTRAL + ANGLE_CURVE)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" added_lines="13" deleted_lines="13">
				<diff>@@ -49,17 +49,17 @@ CrossRoadArea *CrossRoadArea::findClosestCrossRoad(const autoware_msgs::lane &amp;_f
   return _area;
 }
 
-std::vector&lt;geometry_msgs::Point&gt; convhull(const CrossRoadArea *_ClosestArea)
+std::vector&lt;geometry_msgs::Point&gt; convhull(const CrossRoadArea *_TargetArea)
 {
   std::vector&lt;int&gt; enablePoints;
 
   // Jarvis's March algorithm
   int l = 0;
-  for (auto i = begin(_ClosestArea-&gt;points); i != end(_ClosestArea-&gt;points); i++)
+  for (auto i = begin(_TargetArea-&gt;points); i != end(_TargetArea-&gt;points); i++)
   {
-    if (i-&gt;x &lt; _ClosestArea-&gt;points.at(l).x)
+    if (i-&gt;x &lt; _TargetArea-&gt;points.at(l).x)
     {
-      l = std::distance(begin(_ClosestArea-&gt;points), i);
+      l = std::distance(begin(_TargetArea-&gt;points), i);
     }
   }
 
@@ -68,12 +68,12 @@ std::vector&lt;geometry_msgs::Point&gt; convhull(const CrossRoadArea *_ClosestArea)
 
   do
   {
-    q = (p + 1) % _ClosestArea-&gt;points.size();
-    for (int i = 0; i &lt; _ClosestArea-&gt;points.size(); i++)
+    q = (p + 1) % _TargetArea-&gt;points.size();
+    for (int i = 0; i &lt; _TargetArea-&gt;points.size(); i++)
     {
-      geometry_msgs::Point pp = _ClosestArea-&gt;points.at(p);
-      geometry_msgs::Point pi = _ClosestArea-&gt;points.at(i);
-      geometry_msgs::Point pq = _ClosestArea-&gt;points.at(q);
+      geometry_msgs::Point pp = _TargetArea-&gt;points.at(p);
+      geometry_msgs::Point pi = _TargetArea-&gt;points.at(i);
+      geometry_msgs::Point pq = _TargetArea-&gt;points.at(q);
       if ((pi.y - pp.y) * (pq.x - pi.x) - (pi.x - pp.x) * (pq.y - pi.y) &lt; 0)
       {
         q = i;
@@ -84,11 +84,11 @@ std::vector&lt;geometry_msgs::Point&gt; convhull(const CrossRoadArea *_ClosestArea)
   } while (p != l);
 
   std::vector&lt;geometry_msgs::Point&gt; point_arrays;
-  for (auto p = begin(_ClosestArea-&gt;points); p != end(_ClosestArea-&gt;points); p++)
+  for (auto p = begin(_TargetArea-&gt;points); p != end(_TargetArea-&gt;points); p++)
   {
     for (auto &amp;en : enablePoints)
     {
-      if (std::distance(begin(_ClosestArea-&gt;points), p) == en)
+      if (std::distance(begin(_TargetArea-&gt;points), p) == en)
       {
         point_arrays.push_back(*p);
       }
@@ -97,9 +97,9 @@ std::vector&lt;geometry_msgs::Point&gt; convhull(const CrossRoadArea *_ClosestArea)
   return point_arrays;
 }
 
-bool CrossRoadArea::isInsideArea(const CrossRoadArea *_ClosestArea, geometry_msgs::Point pt)
+bool CrossRoadArea::isInsideArea(const CrossRoadArea *_TargetArea, geometry_msgs::Point pt)
 {
-  std::vector&lt;geometry_msgs::Point&gt; point_arrays = convhull(_ClosestArea);
+  std::vector&lt;geometry_msgs::Point&gt; point_arrays = convhull(_TargetArea);
 
   double rad = 0.0;
   for (auto it = begin(point_arrays); it != end(point_arrays); ++it)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="199" deleted_lines="143">
				<diff>@@ -26,207 +26,263 @@ namespace decision_maker
 
 void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
 {
-  geometry_msgs::PoseStamped _pose = current_pose_ = msg;
-  bool initLocalizationFlag = ctx-&gt;isCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
-  if (initLocalizationFlag &amp;&amp;
-      isLocalizationConvergence(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
-                                _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
-  {
-    ROS_INFO("Localization was convergence");
-  }
+	geometry_msgs::PoseStamped _pose = current_pose_ = msg;
+	bool initLocalizationFlag = ctx-&gt;isCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
+	if (initLocalizationFlag &amp;&amp;
+			isLocalizationConvergence(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
+				_pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
+	{
+		ROS_INFO("Localization was convergence");
+	}
 
-  // displacement_from_path_ =  getDisplacementFromPath(_pose.pose.position.x, _pose.pose.position.y,
-  // _pose.pose.position.z);
+	// displacement_from_path_ =  getDisplacementFromPath(_pose.pose.position.x, _pose.pose.position.y,
+	// _pose.pose.position.z);
 }
 
 bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
 {
-  bool _ret;
-  ctx-&gt;setEnableForceSetState(true);
-  _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
-  ctx-&gt;setEnableForceSetState(false);
-  return _ret;
+	bool _ret;
+	ctx-&gt;setEnableForceSetState(true);
+	_ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
+	ctx-&gt;setEnableForceSetState(false);
+	return _ret;
 }
 
 void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
 {
-  ROS_INFO("Received forcing state changing request");
-  handleStateCmd((unsigned long long)1 &lt;&lt; msg.data);
+	ROS_INFO("Received forcing state changing request");
+	handleStateCmd((unsigned long long)1 &lt;&lt; msg.data);
 }
 
 void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
 {
-  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
-    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
-  else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
-    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
-  else
-  {
-    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
-    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
-  }
+	if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
+		ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
+	else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
+		ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
+	else
+	{
+		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
+		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
+	}
 }
 
 void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg)
 {
-  ROS_INFO("Param setted by Runtime Manager");
-  enableDisplayMarker = msg.enable_display_marker;
-  ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);
-  if (msg.enable_force_state_change)
-  {
-    if (msg.MainState_ChangeFlag)
-      handleStateCmd((unsigned long long)1 &lt;&lt; msg.MainState_ChangeFlag);
-    if (msg.SubState_Acc_ChangeFlag)
-      handleStateCmd(state_machine::DRIVE_ACC_ACCELERATION_STATE &lt;&lt; (msg.SubState_Acc_ChangeFlag - 1));
-    if (msg.SubState_Str_ChangeFlag)
-      handleStateCmd(state_machine::DRIVE_STR_STRAIGHT_STATE &lt;&lt; (msg.SubState_Str_ChangeFlag - 1));
-    if (msg.SubState_Behavior_ChangeFlag)
-      handleStateCmd(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE &lt;&lt; (msg.SubState_Behavior_ChangeFlag - 1));
-    if (msg.SubState_Perception_ChangeFlag)
-      handleStateCmd(state_machine::DRIVE_DETECT_OBSTACLE_STATE &lt;&lt; (msg.SubState_Perception_ChangeFlag - 1));
-  }
-}
-
-// void DecisionMakerNode::callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg)
+	ROS_INFO("Param setted by Runtime Manager");
+	enableDisplayMarker = msg.enable_display_marker;
+	ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);
+	if (msg.enable_force_state_change)
+	{
+		if (msg.MainState_ChangeFlag)
+			handleStateCmd((unsigned long long)1 &lt;&lt; msg.MainState_ChangeFlag);
+		if (msg.SubState_Acc_ChangeFlag)
+			handleStateCmd(state_machine::DRIVE_ACC_ACCELERATION_STATE &lt;&lt; (msg.SubState_Acc_ChangeFlag - 1));
+		if (msg.SubState_Str_ChangeFlag)
+			handleStateCmd(state_machine::DRIVE_STR_STRAIGHT_STATE &lt;&lt; (msg.SubState_Str_ChangeFlag - 1));
+		if (msg.SubState_Behavior_ChangeFlag)
+			handleStateCmd(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE &lt;&lt; (msg.SubState_Behavior_ChangeFlag - 1));
+		if (msg.SubState_Perception_ChangeFlag)
+			handleStateCmd(state_machine::DRIVE_DETECT_OBSTACLE_STATE &lt;&lt; (msg.SubState_Perception_ChangeFlag - 1));
+	}
+}
+
 void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
 {
-  const ros::M_string &amp;header = event.getConnectionHeader();
-  std::string topic = header.at("topic");
-  const autoware_msgs::traffic_light *light = event.getMessage().get();
+	const ros::M_string &amp;header = event.getConnectionHeader();
+	std::string topic = header.at("topic");
+	const autoware_msgs::traffic_light *light = event.getMessage().get();
 
-  current_traffic_light = light-&gt;traffic_light;
-  if (current_traffic_light == state_machine::E_RED || current_traffic_light == state_machine::E_YELLOW)
-  {
-    ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
-  }
-  else
-  {
-    ctx-&gt;disableCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
-  }
-  // ctx-&gt;handleTrafficLight(CurrentTrafficlight);
+	current_traffic_light = light-&gt;traffic_light;
+	if (current_traffic_light == state_machine::E_RED || current_traffic_light == state_machine::E_YELLOW)
+	{
+		ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
+	}
+	else
+	{
+		ctx-&gt;disableCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
+	}
+	// ctx-&gt;handleTrafficLight(CurrentTrafficlight);
 }
 
 //
 void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
 {
-  if (ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
-    Subs["points_raw"].shutdown();
+	if (ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
+		Subs["points_raw"].shutdown();
 }
 
+
+void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects, autoware_msgs::LaneArray &amp;lane_array)
+{
+	for (auto &amp;lane : lane_array.lanes)
+	{
+		for (auto &amp;wp : lane.waypoints)
+		{
+			geometry_msgs::Point pp;
+			pp.x = wp.pose.pose.position.x;
+			pp.y = wp.pose.pose.position.y;
+			pp.z = wp.pose.pose.position.z;
+
+			for (auto &amp;area : intersects)
+			{
+				if (CrossRoadArea::isInsideArea(&amp;area, pp))
+				{ 
+					//area's
+					area.insideWaypoint_points.push_back(pp); //geometry_msgs::point
+					area.insideWaypoints.push_back(wp);//autoware_msgs::waypoint
+					//lane's wp
+					wp.wpstate.aid = area.area_id;
+				}
+			}
+		}
+	}
+}
+
+void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
+{
+	for(auto &amp;area : intersects){
+		// To straight/left/right recognition by using angle
+		// between first-waypoint and end-waypoint in intersection area.
+		//
+		//
+		int angle_deg = ((int)std::floor(calcIntersectWayAngle(area))); //normalized
+		int steering_state;
+
+		if (angle_deg &lt;= ANGLE_LEFT)
+			steering_state = autoware_msgs::WaypointState::STR_LEFT;
+		else if (angle_deg &gt;= ANGLE_RIGHT)
+			steering_state = autoware_msgs::WaypointState::STR_RIGHT;
+		else
+			steering_state = autoware_msgs::WaypointState::STR_STRAIGHT;
+
+		for (auto &amp;lane : lane_array.lanes)
+		{
+			for (auto &amp;wp : lane.waypoints)
+			{
+				if(area.area_id == wp.wpstate.aid)
+				{
+					wp.wpstate.steering_state = steering_state;
+				}
+			}
+		}
+		fprintf(stderr,"%d: %d  angle_deg :%d\n",area.area_id, steering_state, angle_deg);
+	}
+}
+
+
 // for based waypoint
 void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg)
 {
-  current_lane_array_ = msg;
-
-  for (auto &amp;area : intersects)
-  {
-    for (auto &amp;lane : msg.lanes)
-    {
-      for (auto &amp;wp : lane.waypoints)
-      {
-        geometry_msgs::Point pp;
-        pp.x = wp.pose.pose.position.x;
-        pp.y = wp.pose.pose.position.y;
-        pp.z = wp.pose.pose.position.z;
-        if (CrossRoadArea::isInsideArea(&amp;area, pp))
-        {
-          std::cout &lt;&lt; "Add to" &lt;&lt; area.area_id &lt;&lt; ": point" &lt;&lt; pp.x &lt;&lt; "," &lt;&lt; pp.y &lt;&lt; std::endl;
-          area.insideWaypoint_points.push_back(pp);
-          area.insideWaypoints.push_back(wp);
-        }
-      }
-    }
-  }
+	current_based_lane_array_ = msg; //cached based path
+
+	//indexing
+	for(auto &amp;lane: current_based_lane_array_.lanes){
+		int gid = 0;
+		for(auto &amp;wp : lane.waypoints){
+			int lid = 0;
+			wp.gid = gid++;
+			wp.lid = lid++;
+			wp.wpstate.aid = 0;
+			wp.wpstate.steering_state= autoware_msgs::WaypointState::NULLSTATE;
+			wp.wpstate.accel_state = autoware_msgs::WaypointState::NULLSTATE;
+			wp.wpstate.stopline_state= autoware_msgs::WaypointState::NULLSTATE;
+			wp.wpstate.lanechange_state= autoware_msgs::WaypointState::NULLSTATE;
+			wp.wpstate.event_state = 0;
+		}
+	}
+
+	current_controlled_lane_array_ = current_based_lane_array_; //controlled path
+	insertPointWithinCrossRoad(intersects, current_controlled_lane_array_);
+	setWaypointState(current_controlled_lane_array_);
+
+	Pubs["lane_waypoints_array"].publish(current_controlled_lane_array_);
 }
 
 void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
 {
-  if (!hasvMap())
-  {
-    std::cerr &lt;&lt; "Not found vmap subscribe" &lt;&lt; std::endl;
-    return;
-  }
-  if (!ctx-&gt;isCurrentState(state_machine::DRIVE_STATE))
-  {
-    std::cerr &lt;&lt; "State is not DRIVE_STATE[" &lt;&lt; ctx-&gt;getCurrentStateName() &lt;&lt; "]" &lt;&lt; std::endl;
-    return;
-  }
-  // steering
-  current_finalwaypoints_ = msg;
-  ClosestArea_ = CrossRoadArea::findClosestCrossRoad(current_finalwaypoints_, intersects);
-  double intersect_wayangle = calcIntersectWayAngle(current_finalwaypoints_, current_pose_);
-
-  // To straight/left/right recognition by using angle
-  // between first-waypoint and end-waypoint in intersection area.
-  int temp = (int)std::floor(intersect_wayangle + 180.0) % 360;
-
-  if (temp &lt;= ANGLE_LEFT)
-    ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
-  else if (temp &gt;= ANGLE_RIGHT)
-    ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
-  else
-    ctx-&gt;setCurrentState(state_machine::DRIVE_STR_STRAIGHT_STATE);
-
-  // velocity
-  double _temp_sum = 0;
-  for (int i = 0; i &lt; VEL_AVERAGE_COUNT; i++)
-  {
-    _temp_sum += mps2kmph(msg.waypoints[i].twist.twist.linear.x);
-  }
-  average_velocity_ = _temp_sum / VEL_AVERAGE_COUNT;
-
-  if (std::fabs(average_velocity_ - current_velocity_) &lt;= 2.0)
-    ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE);
-  else if (average_velocity_ - current_velocity_)
-    ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE);
-  else
-    ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE);
-
-  // for publish plan of velocity
-  publishToVelocityArray();
+	if (!hasvMap())
+	{
+		std::cerr &lt;&lt; "Not found vmap subscribe" &lt;&lt; std::endl;
+		return;
+	}
+	if (!ctx-&gt;isCurrentState(state_machine::DRIVE_STATE))
+	{
+		std::cerr &lt;&lt; "State is not DRIVE_STATE[" &lt;&lt; ctx-&gt;getCurrentStateName() &lt;&lt; "]" &lt;&lt; std::endl;
+		return;
+	}
+	// steering
+	current_finalwaypoints_ = msg;
+
+	uint8_t steering_state = current_finalwaypoints_.waypoints.at(param_target_waypoint_).wpstate.steering_state;
+
+	if (steering_state == autoware_msgs::WaypointState::STR_LEFT)
+		ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
+	else if (steering_state == autoware_msgs::WaypointState::STR_RIGHT)
+		ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
+	else
+		ctx-&gt;setCurrentState(state_machine::DRIVE_STR_STRAIGHT_STATE);
+
+	// velocity
+	double _temp_sum = 0;
+	for (int i = 0; i &lt; VEL_AVERAGE_COUNT; i++)
+	{
+		_temp_sum += mps2kmph(msg.waypoints[i].twist.twist.linear.x);
+	}
+	average_velocity_ = _temp_sum / VEL_AVERAGE_COUNT;
+
+	if (std::fabs(average_velocity_ - current_velocity_) &lt;= 2.0)
+		ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE);
+	else if (average_velocity_ - current_velocity_)
+		ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE);
+	else
+		ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE);
+
+	// for publish plan of velocity
+	publishToVelocityArray();
 
 #ifdef DEBUG_PRINT
-  std::cout &lt;&lt; "Velocity: " &lt;&lt; current_velocity_ &lt;&lt; " to " &lt;&lt; average_velocity_ &lt;&lt; std::endl;
+	std::cout &lt;&lt; "Velocity: " &lt;&lt; current_velocity_ &lt;&lt; " to " &lt;&lt; average_velocity_ &lt;&lt; std::endl;
 #endif
 }
 void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
 {
-  static bool Twistflag = false;
+	static bool Twistflag = false;
 
-  if (Twistflag)
-    ctx-&gt;handleTwistCmd(false);
-  else
-    Twistflag = true;
+	if (Twistflag)
+		ctx-&gt;handleTwistCmd(false);
+	else
+		Twistflag = true;
 }
 
 void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
 {
-  vMap_Areas = msg;
-  vMap_Areas_flag = true;
-  initVectorMap();
+	vMap_Areas = msg;
+	vMap_Areas_flag = true;
+	initVectorMap();
 }
 void DecisionMakerNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
 {
-  vMap_Points = msg;
-  vMap_Points_flag = true;
-  initVectorMap();
+	vMap_Points = msg;
+	vMap_Points_flag = true;
+	initVectorMap();
 }
 void DecisionMakerNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
 {
-  vMap_Lines = msg;
-  vMap_Lines_flag = true;
-  initVectorMap();
+	vMap_Lines = msg;
+	vMap_Lines_flag = true;
+	initVectorMap();
 }
 void DecisionMakerNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
 {
-  vMap_CrossRoads = msg;
-  vMap_CrossRoads_flag = true;
-  initVectorMap();
+	vMap_CrossRoads = msg;
+	vMap_CrossRoads_flag = true;
+	initVectorMap();
 }
 
 void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
 {
-  current_velocity_ = mps2kmph(msg.twist.linear.x);
+	current_velocity_ = mps2kmph(msg.twist.linear.x);
 }
 #if 0
 void DecisionMakerNode::callbackFromDynamicReconfigure(decision_maker::decision_makerConfig &amp;config, uint32_t level){
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" added_lines="6" deleted_lines="0">
				<diff>@@ -67,10 +67,16 @@ void DecisionMakerNode::run(void)
     update();
     if (enableDisplayMarker)
       displayMarker();
+
+ 
+#ifdef DEBUG_PRINT
+    // debug status
     ros::Duration exec_time = ros::Time::now() - begin;
     std_msgs::Float64 exec_time_sec;
     exec_time_sec.data = exec_time.toSec();
     Pubs["exectime"].publish(exec_time_sec);
+#endif
+
     loop_rate.sleep();
   }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" added_lines="60" deleted_lines="67">
				<diff>@@ -17,85 +17,78 @@
 
 namespace decision_maker
 {
-double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_msg,
-                                                const geometry_msgs::PoseStamped &amp;pose_msg)
-{
-  if (vMap_CrossRoads_flag &amp;&amp; ClosestArea_)
-  {
-    double diff = 0.0;
-    if (ClosestArea_-&gt;insideWaypoints.empty())
-    {
-      ROS_INFO("Not inside CrossRoad");
-    }
-    else
-    {
-      const geometry_msgs::Pose InPose = ClosestArea_-&gt;insideWaypoints.front().pose.pose;
-      const geometry_msgs::Pose OutPose = ClosestArea_-&gt;insideWaypoints.back().pose.pose;
-      double r, p, y, _y;
-
-      tf::Quaternion quat_end(OutPose.orientation.x, OutPose.orientation.y, OutPose.orientation.z,
-                              OutPose.orientation.w);
-
-      tf::Quaternion quat_in(InPose.orientation.x, InPose.orientation.y, InPose.orientation.z, InPose.orientation.w);
-
-      tf::Matrix3x3(quat_end).getRPY(r, p, y);
-      tf::Matrix3x3(quat_in).getRPY(r, p, _y);
+	double DecisionMakerNode::calcIntersectWayAngle(const CrossRoadArea &amp;area)
+	{
+		double diff = 0.0;
+		if(area.insideWaypoints.empty())
+		{
+			ROS_INFO("Not inside CrossRoad");
+		}
+		else
+		{
+			const geometry_msgs::Pose InPose = area.insideWaypoints.front().pose.pose;
+			const geometry_msgs::Pose OutPose = area.insideWaypoints.back().pose.pose;
+			double r, p, y, _y;
 
-      diff = (_y - y) * 180.0 / M_PI;
+			tf::Quaternion quat_end(OutPose.orientation.x, OutPose.orientation.y, OutPose.orientation.z,
+					OutPose.orientation.w);
+			tf::Quaternion quat_in(InPose.orientation.x, InPose.orientation.y, InPose.orientation.z, InPose.orientation.w);
+			tf::Matrix3x3(quat_in).getRPY(r, p, y);
+			tf::Matrix3x3(quat_end).getRPY(r, p, _y);
+			diff = y - _y;
+			diff = diff &gt; M_PI? 
+				diff - 2 * M_PI : diff &lt; -M_PI?
+				2 * M_PI - diff : diff;
+			diff = (int)std::floor(diff *180/M_PI);
 
 #ifdef DEBUG_PRINT
-      std::cout &lt;&lt; "Yaw:" &lt;&lt; _y &lt;&lt; "-" &lt;&lt; y &lt;&lt; ":" &lt;&lt; _y - y &lt;&lt; std::endl;
-      std::cout &lt;&lt; "In:" &lt;&lt; InPose.position.x &lt;&lt; "," &lt;&lt; InPose.position.y &lt;&lt; std::endl;
-      std::cout &lt;&lt; "End:" &lt;&lt; OutPose.position.x &lt;&lt; "," &lt;&lt; OutPose.position.y &lt;&lt; std::endl;
-      int temp = (int)std::floor(diff + 180) % 360;
-      if (temp &lt;= ANGLE_LEFT)
-        std::cout &lt;&lt; "LEFT :" &lt;&lt; temp &lt;&lt; std::endl;
-      else if (temp &gt;= ANGLE_RIGHT)
-        std::cout &lt;&lt; "RIGHT:" &lt;&lt; temp &lt;&lt; std::endl;
-      else
-        std::cout &lt;&lt; "Straight:" &lt;&lt; temp &lt;&lt; std::endl;
+			std::cout &lt;&lt; "Yaw:" &lt;&lt; _y &lt;&lt; "-" &lt;&lt; y &lt;&lt; ":" &lt;&lt; _y - y &lt;&lt; std::endl;
+			std::cout &lt;&lt; "In:" &lt;&lt; InPose.position.x &lt;&lt; "," &lt;&lt; InPose.position.y &lt;&lt; std::endl;
+			std::cout &lt;&lt; "End:" &lt;&lt; OutPose.position.x &lt;&lt; "," &lt;&lt; OutPose.position.y &lt;&lt; std::endl;
+			if (diff &lt;= ANGLE_LEFT)
+				std::cout &lt;&lt; "LEFT :" &lt;&lt; diff &lt;&lt; std::endl;
+			else if (diff &gt;= ANGLE_RIGHT)
+				std::cout &lt;&lt; "RIGHT:" &lt;&lt; diff &lt;&lt; std::endl;
+			else
+				std::cout &lt;&lt; "Straight:" &lt;&lt; diff &lt;&lt; std::endl;
 #endif
-    }
+		
+		}
 
-    return diff;
-  }
-  else
-  {
-    return 0.0;
-  }
+		return diff;
 }
 
 bool DecisionMakerNode::isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch,
-                                                  double _yaw)
+		double _yaw)
 {
-  static int _init_count = 0;
-  static euclidean_space::point *a = new euclidean_space::point();
-  static euclidean_space::point *b = new euclidean_space::point();
+	static int _init_count = 0;
+	static euclidean_space::point *a = new euclidean_space::point();
+	static euclidean_space::point *b = new euclidean_space::point();
 
-  static std::vector&lt;double&gt; distances;
-  static int distances_count = 0;
-  double avg_distances = 0.0;
+	static std::vector&lt;double&gt; distances;
+	static int distances_count = 0;
+	double avg_distances = 0.0;
 
-  a-&gt;x = b-&gt;x;
-  a-&gt;y = b-&gt;y;
-  a-&gt;z = b-&gt;z;
+	a-&gt;x = b-&gt;x;
+	a-&gt;y = b-&gt;y;
+	a-&gt;z = b-&gt;z;
 
-  b-&gt;x = _x;
-  b-&gt;y = _y;
-  b-&gt;z = _z;
+	b-&gt;x = _x;
+	b-&gt;y = _y;
+	b-&gt;z = _z;
 
-  distances.push_back(euclidean_space::EuclideanSpace::find_distance(a, b));
-  if (++distances_count &gt; param_convergence_count_)
-  {
-    distances.erase(distances.begin());
-    distances_count--;
-    avg_distances = std::accumulate(distances.begin(), distances.end(), 0) / distances.size();
-    if (avg_distances &lt;= param_convergence_threshold_)
-      return ctx-&gt;setCurrentState(state_machine::DRIVE_STATE);
-  }
-  else
-  {
-    return false;
-  }
+	distances.push_back(euclidean_space::EuclideanSpace::find_distance(a, b));
+	if (++distances_count &gt; param_convergence_count_)
+	{
+		distances.erase(distances.begin());
+		distances_count--;
+		avg_distances = std::accumulate(distances.begin(), distances.end(), 0) / distances.size();
+		if (avg_distances &lt;= param_convergence_threshold_)
+			return ctx-&gt;setCurrentState(state_machine::DRIVE_STATE);
+	}
+	else
+	{
+		return false;
+	}
 }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="11" deleted_lines="4">
				<diff>@@ -27,6 +27,11 @@
 
 namespace decision_maker
 {
+
+#define  TPNAME_BASED_LANE_WAYPOINTS_ARRAY "/based/lane_waypoints_array"
+#define  TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY "/lane_waypoints_array"
+
+
 void DecisionMakerNode::initStateMsgs(void)
 {
 }
@@ -62,6 +67,7 @@ void DecisionMakerNode::initROS(int argc, char **argv)
 
   // pub
   Pubs["state"] = nh_.advertise&lt;std_msgs::String&gt;("state", 1);
+  Pubs["lane_waypoints_array"] = nh_.advertise&lt;autoware_msgs::LaneArray&gt;(TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY, 10, true);
 
   // for visualize
   Pubs["state_overlay"] = nh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;("/state/overlay_text", 1);
@@ -114,6 +120,7 @@ void DecisionMakerNode::initVectorMap(void)
 
       int _index = 0;
 
+      // parse vmap
       for (const auto &amp;cross_road : vMap_CrossRoads.data)
       {
         for (const auto &amp;area : vMap_Areas.data)
@@ -127,8 +134,8 @@ void DecisionMakerNode::initVectorMap(void)
             double x_avg = 0.0, x_min = 0.0, x_max = 0.0;
             double y_avg = 0.0, y_min = 0.0, y_max = 0.0;
             double z = 0.0;
-
             int points_count = 0;
+	    
             for (const auto &amp;line : vMap_Lines.data)
             {
               if (area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid)
@@ -148,8 +155,9 @@ void DecisionMakerNode::initVectorMap(void)
 
                     _prev_point = _point;
                     points_count++;
-                    carea.points.push_back(_point);
+		    carea.points.push_back(_point);
 
+		    // calc a centroid point and about intersects size
                     x_avg += _point.x;
                     y_avg += _point.y;
                     x_min = (x_min == 0.0) ? _point.x : std::min(_point.x, x_min);
@@ -175,8 +183,7 @@ void DecisionMakerNode::initVectorMap(void)
       }
     }
     vMap_mutex.unlock();
-    Subs["lane_waypoints_array"] =
-        nh_.subscribe("lane_waypoints_array", 100, &amp;DecisionMakerNode::callbackFromLaneWaypoint, this);
+    Subs["lane_waypoints_array"] = nh_.subscribe( TPNAME_BASED_LANE_WAYPOINTS_ARRAY, 100, &amp;DecisionMakerNode::callbackFromLaneWaypoint, this);
   }
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="20" deleted_lines="13">
				<diff>@@ -30,17 +30,8 @@ void DecisionMakerNode::update_pubsub(void)
   // this function will re-definition subscriber.
 }
 
-void DecisionMakerNode::displayMarker(void)
-{
-  // vector_map init
-  // parse vectormap
-  initVectorMap();
 
-  jsk_recognition_msgs::BoundingBoxArray bbox_array;
-
-  static visualization_msgs::MarkerArray marker_array;
-  static visualization_msgs::Marker crossroad_marker;
-  static visualization_msgs::Marker inside_marker;
+int DecisionMakerNode::createCrossRoadAreaMarker(visualization_msgs::Marker &amp;crossroad_marker, double scale){
 
   crossroad_marker.header.frame_id = "/map";
   crossroad_marker.header.stamp = ros::Time();
@@ -48,19 +39,35 @@ void DecisionMakerNode::displayMarker(void)
   crossroad_marker.type = visualization_msgs::Marker::SPHERE_LIST;
   crossroad_marker.action = visualization_msgs::Marker::ADD;
   crossroad_marker.ns = "crossroad";
-
-  double scale = 3.0;
+  
   crossroad_marker.scale.x = scale;
   crossroad_marker.scale.y = scale;
   crossroad_marker.scale.z = 0.5;
   crossroad_marker.color.a = 0.15;
   crossroad_marker.color.r = 1.0;
   crossroad_marker.color.g = 0.0;
-  /// www.sinet.ad.jp/aboutsinettd::cout &lt;&lt; "x: "&lt;&lt; _point.x &lt;&lt; std::endl;
   crossroad_marker.color.b = 0.0;
   crossroad_marker.frame_locked = true;
   crossroad_marker.lifetime = ros::Duration(0.3);
 
+}
+
+void DecisionMakerNode::displayMarker(void)
+{
+  // vector_map init
+  // parse vectormap
+  initVectorMap();
+
+  jsk_recognition_msgs::BoundingBoxArray bbox_array;
+
+  static visualization_msgs::MarkerArray marker_array;
+  static visualization_msgs::Marker crossroad_marker;
+  static visualization_msgs::Marker inside_marker;
+
+
+  double scale = 3.0;
+  createCrossRoadAreaMarker(crossroad_marker, scale);
+
   inside_marker = crossroad_marker;
   inside_marker.scale.x = scale / 3;
   inside_marker.scale.y = scale / 3;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9c0b00d6a6e5cd878600f0b6c698a32158eefffd" author="anhnv-3991">
		<msg>Fix redeclaration error when compiling ndt_mapping.cpp and ndt_matching.cpp</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="0" deleted_lines="8">
				<diff>@@ -67,14 +67,6 @@
 #endif
 
 
-#ifndef USE_FAST_PCL
-  #include &lt;fast_pcl/filters/voxel_grid.h&gt;
-  #include &lt;fast_pcl/registration/ndt.h&gt;
-#else
-  #include &lt;pcl/filters/voxel_grid.h&gt;
-  #include &lt;pcl/registration/ndt.h&gt;
-#endif
-
 #ifdef CUDA_FOUND
   #include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="0" deleted_lines="6">
				<diff>@@ -69,12 +69,6 @@
   #include &lt;pcl/registration/ndt.h&gt;
 #endif
 
-
-#ifdef USE_FAST_PCL
-  #include &lt;fast_pcl/registration/ndt.h&gt;
-#else
-  #include &lt;pcl/registration/ndt.h&gt;
-#endif
 #ifdef CUDA_FOUND
   #include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
 #endif
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="30eb2c2445846567595cf437bec5349c0f423946" author="Yusuke FUJII">
		<msg>update decisionmaker and related library
- add multiplelane path recognition
- renamed euc</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libeuc\include\euclidean_space.hpp" new_path="" added_lines="0" deleted_lines="51">
				<diff>@@ -1,51 +0,0 @@
-#ifndef __EUCLIDEAN_SPACE_HPP
-#define __EUCLIDEAN_SPACE_HPP
-
-#include &lt;cmath&gt;
-#include &lt;iostream&gt;
-
-using namespace std;
-
-namespace euclidean_space
-{
-class point
-{
-private:
-public:
-  double x, y, z;
-
-  point(void)
-  {
-    x = y = z = 0.0;
-  }
-
-  point(double _x, double _y, double _z)
-  {
-    x = _x;
-    y = _y;
-    z = _z;
-  }
-};
-class EuclideanSpace
-{
-private:
-  EuclideanSpace(void){};
-
-public:
-  static double find_distance(point *_a, point *_b)
-  {
-    return std::hypot(std::hypot(_a-&gt;x - _b-&gt;x, _a-&gt;y - _b-&gt;y), _a-&gt;z - _b-&gt;z);
-  }
-
-  static double find_angle(point *_a, point *_b)
-  {
-    double _angle = std::atan2(_b-&gt;y - _a-&gt;y, _b-&gt;x - _a-&gt;x);
-    if (_angle &lt; 0.0)
-      _angle = _angle + 2 * M_PI;
-
-    return _angle * 360 / (2 * M_PI);
-  }
-};
-}  // namespace euclidean_space
-
-#endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libeuc\src\main.cpp" new_path="" added_lines="0" deleted_lines="19">
				<diff>@@ -1,19 +0,0 @@
-#include "euclidean_space.hpp"
-
-using namespace euclidean_space;
-
-int main(void)
-{
-  double distance = 0;
-
-  point *a = new point(5.0, 5.0, 1.0);
-  point *b = new point(0.0, 0.0, 0.0);
-
-  distance = EuclideanSpace::find_distance(a, b);
-  std::cout &lt;&lt; "distance = " &lt;&lt; distance &lt;&lt; std::endl;
-
-  double angle = 0.0;
-
-  angle = EuclideanSpace::find_angle(b, a);
-  std::cout &lt;&lt; "angle = " &lt;&lt; angle &lt;&lt; std::endl;
-}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="2" deleted_lines="26">
				<diff>@@ -7,7 +7,6 @@
 #include &lt;cassert&gt;
 #include &lt;mutex&gt;
 
-#include &lt;euclidean_space.hpp&gt;
 #include &lt;state_context.hpp&gt;
 
 #include &lt;state.hpp&gt;
@@ -212,33 +211,10 @@ bool StateContext::inState(unsigned long long _state_num)
   }
 }
 
-#define ANGLE_STRAIGHT 50.0
-#define ANGLE_LEFT 360.0
-#define ANGLE_RIGHT 180.0
 bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
 {
-  if (_hasIntersection)
-  {
-    // *Temporary implementation*
-    // To straight/left/right recognition by using angle between
-    // first-waypoint
-    // and end-waypoint in intersection area.
-    int temp = (int)std::floor(_angle + 360.0) % 360;
-#if 0
-    if (std::abs(temp) &lt;= ANGLE_STRAIGHT)
-      return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_STRAIGHT_STATE]);
-    else if (temp &lt;= ANGLE_RIGHT)
-      return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_RIGHT_STATE]);
-    else if (temp &lt;= ANGLE_LEFT)
-      return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_LEFT_STATE]);
-    else
-      return false;
-#endif
-  }
-  else
-  {
-    return false;
-  }
+    /* deprecated */
+	return false;
 }
 
 std::string StateContext::createStateMessageText(void)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\cross_road_area.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\cross_road_area.hpp" added_lines="2" deleted_lines="2">
				<diff>@@ -19,7 +19,7 @@ public:
   std::vector&lt;geometry_msgs::Point&gt; points;
   jsk_recognition_msgs::BoundingBox bbox;
 
-  std::vector&lt;autoware_msgs::waypoint&gt; insideWaypoints;
+  std::vector&lt;autoware_msgs::lane&gt; insideLanes;
   std::vector&lt;geometry_msgs::Point&gt; insideWaypoint_points;
 
   CrossRoadArea(void)
@@ -27,7 +27,7 @@ public:
     id = 0;
     area_id = 0;
     points.clear();
-    insideWaypoints.clear();
+    insideLanes.clear();
     insideWaypoint_points.clear();
   }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="3" deleted_lines="2">
				<diff>@@ -29,7 +29,7 @@
 
 // lib
 #include &lt;cross_road_area.hpp&gt;
-#include &lt;euclidean_space.hpp&gt;
+#include &lt;amathutils.hpp&gt;
 #include &lt;state.hpp&gt;
 #include &lt;state_context.hpp&gt;
 
@@ -153,7 +153,8 @@ private:
   bool isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
   bool isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch, double _yaw);
   bool handleStateCmd(const unsigned long long _state_num);
-  double calcIntersectWayAngle(const CrossRoadArea&amp; area);
+  //double calcIntersectWayAngle(const CrossRoadArea&amp; area);
+  double calcIntersectWayAngle(const autoware_msgs::lane&amp; laneinArea);
 
   void insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects, autoware_msgs::LaneArray &amp;lane_array);
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\planner_selector.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\planner_selector.hpp" added_lines="1" deleted_lines="1">
				<diff>@@ -10,7 +10,7 @@
 #include &lt;thread&gt;
 #include &lt;unordered_map&gt;
 
-#include &lt;euclidean_space.hpp&gt;
+#include &lt;amathutils.hpp&gt;
 
 namespace decision_maker
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -1,6 +1,6 @@
 #include &lt;cmath&gt;
 #include &lt;cross_road_area.hpp&gt;
-#include &lt;euclidean_space.hpp&gt;
+#include &lt;amathutils.hpp&gt;
 
 namespace decision_maker
 {
@@ -10,8 +10,8 @@ CrossRoadArea *CrossRoadArea::findClosestCrossRoad(const autoware_msgs::lane &amp;_f
 {
   CrossRoadArea *_area = nullptr;
 
-  euclidean_space::point _pa;
-  euclidean_space::point _pb;
+  amathutils::point _pa;
+  amathutils::point _pb;
 
   double _min_distance = DBL_MAX;
 
@@ -31,7 +31,7 @@ CrossRoadArea *CrossRoadArea::findClosestCrossRoad(const autoware_msgs::lane &amp;_f
 
     _pb.z = 0.0;
 
-    double __temp_dis = euclidean_space::EuclideanSpace::find_distance(&amp;_pa, &amp;_pb);
+    double __temp_dis = amathutils::find_distance(&amp;_pa, &amp;_pb);
 
     intersects[i].bbox.label = 0;
     if (_min_distance &gt;= __temp_dis)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="10" deleted_lines="5">
				<diff>@@ -10,7 +10,6 @@
 
 #include &lt;cross_road_area.hpp&gt;
 #include &lt;decision_maker_node.hpp&gt;
-#include &lt;euclidean_space.hpp&gt;
 #include &lt;state.hpp&gt;
 #include &lt;state_context.hpp&gt;
 
@@ -129,8 +128,13 @@ void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadAr
 				if (CrossRoadArea::isInsideArea(&amp;area, pp))
 				{ 
 					//area's
+					if(area.insideLanes.empty() ||  wp.gid  != area.insideLanes.back().waypoints.back().gid + 1 ){
+						autoware_msgs::lane nlane;;
+						area.insideLanes.push_back(nlane);
+					}
+					area.insideLanes.back().waypoints.push_back(wp);
 					area.insideWaypoint_points.push_back(pp); //geometry_msgs::point
-					area.insideWaypoints.push_back(wp);//autoware_msgs::waypoint
+					//area.insideLanes.Waypoints.push_back(wp);//autoware_msgs::waypoint
 					//lane's wp
 					wp.wpstate.aid = area.area_id;
 				}
@@ -142,11 +146,11 @@ void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadAr
 void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
 {
 	for(auto &amp;area : intersects){
+
+		for(auto &amp;laneinArea : area.insideLanes){
 		// To straight/left/right recognition by using angle
 		// between first-waypoint and end-waypoint in intersection area.
-		//
-		//
-		int angle_deg = ((int)std::floor(calcIntersectWayAngle(area))); //normalized
+		int angle_deg = ((int)std::floor(calcIntersectWayAngle(laneinArea))); //normalized
 		int steering_state;
 
 		if (angle_deg &lt;= ANGLE_LEFT)
@@ -169,6 +173,7 @@ void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
 		fprintf(stderr,"%d: %d  angle_deg :%d\n",area.area_id, steering_state, angle_deg);
 	}
 }
+}
 
 
 // for based waypoint
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -6,7 +6,6 @@
 #include &lt;stdio.h&gt;
 
 // lib
-#include &lt;euclidean_space.hpp&gt;
 #include &lt;state.hpp&gt;
 #include &lt;state_context.hpp&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" added_lines="12" deleted_lines="11">
				<diff>@@ -11,23 +11,22 @@
 
 #include &lt;cross_road_area.hpp&gt;
 #include &lt;decision_maker_node.hpp&gt;
-#include &lt;euclidean_space.hpp&gt;
 #include &lt;state.hpp&gt;
 #include &lt;state_context.hpp&gt;
 
 namespace decision_maker
 {
-	double DecisionMakerNode::calcIntersectWayAngle(const CrossRoadArea &amp;area)
+	double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;laneinArea)
 	{
 		double diff = 0.0;
-		if(area.insideWaypoints.empty())
+		if(laneinArea.waypoints.empty())
 		{
 			ROS_INFO("Not inside CrossRoad");
 		}
 		else
 		{
-			const geometry_msgs::Pose InPose = area.insideWaypoints.front().pose.pose;
-			const geometry_msgs::Pose OutPose = area.insideWaypoints.back().pose.pose;
+			const geometry_msgs::Pose InPose = laneinArea.waypoints.front().pose.pose;
+			const geometry_msgs::Pose OutPose = laneinArea.waypoints.back().pose.pose;
 			double r, p, y, _y;
 
 			tf::Quaternion quat_end(OutPose.orientation.x, OutPose.orientation.y, OutPose.orientation.z,
@@ -35,11 +34,13 @@ namespace decision_maker
 			tf::Quaternion quat_in(InPose.orientation.x, InPose.orientation.y, InPose.orientation.z, InPose.orientation.w);
 			tf::Matrix3x3(quat_in).getRPY(r, p, y);
 			tf::Matrix3x3(quat_end).getRPY(r, p, _y);
-			diff = y - _y;
+			
+			// convert to [-pi : pi]
+			diff = std::fmod(y - _y, 2 * M_PI);
 			diff = diff &gt; M_PI? 
 				diff - 2 * M_PI : diff &lt; -M_PI?
-				2 * M_PI - diff : diff;
-			diff = (int)std::floor(diff *180/M_PI);
+				2 * M_PI + diff : diff;
+			diff = diff *180/M_PI;
 
 #ifdef DEBUG_PRINT
 			std::cout &lt;&lt; "Yaw:" &lt;&lt; _y &lt;&lt; "-" &lt;&lt; y &lt;&lt; ":" &lt;&lt; _y - y &lt;&lt; std::endl;
@@ -62,8 +63,8 @@ bool DecisionMakerNode::isLocalizationConvergence(double _x, double _y, double _
 		double _yaw)
 {
 	static int _init_count = 0;
-	static euclidean_space::point *a = new euclidean_space::point();
-	static euclidean_space::point *b = new euclidean_space::point();
+	static amathutils::point *a = new amathutils::point();
+	static amathutils::point *b = new amathutils::point();
 
 	static std::vector&lt;double&gt; distances;
 	static int distances_count = 0;
@@ -77,7 +78,7 @@ bool DecisionMakerNode::isLocalizationConvergence(double _x, double _y, double _
 	b-&gt;y = _y;
 	b-&gt;z = _z;
 
-	distances.push_back(euclidean_space::EuclideanSpace::find_distance(a, b));
+	distances.push_back(amathutils::find_distance(a, b));
 	if (++distances_count &gt; param_convergence_count_)
 	{
 		distances.erase(distances.begin());
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -9,7 +9,6 @@
 #include &lt;mutex&gt;
 
 // lib
-#include &lt;euclidean_space.hpp&gt;
 #include &lt;state.hpp&gt;
 #include &lt;state_context.hpp&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -7,7 +7,6 @@
 #include &lt;tf/transform_listener.h&gt;
 
 // lib
-#include &lt;euclidean_space.hpp&gt;
 #include &lt;state.hpp&gt;
 #include &lt;state_context.hpp&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\planner_selector\planner_selector_node.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\planner_selector\planner_selector_node.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -7,7 +7,7 @@
 #include &lt;thread&gt;
 #include &lt;unordered_map&gt;
 
-#include &lt;euclidean_space.hpp&gt;
+#include &lt;amathutils.hpp&gt;
 #include &lt;planner_selector.hpp&gt;
 
 namespace decision_maker
@@ -51,7 +51,7 @@ void PlannerSelector::callbackFromLattice(const std_msgs::Int32 &amp;msg)
     autoware_msgs::waypoint dp_point = final_waypoints_dp_.waypoints.at(config_waypoints_num_);
     autoware_msgs::waypoint astar_point = final_waypoints_astar_.waypoints.at(config_waypoints_num_);
 
-    euclidean_space::point p_dp, p_astar;
+    amathutils::point p_dp, p_astar;
     p_dp.x = dp_point.pose.pose.position.x;
     p_dp.x = dp_point.pose.pose.position.y;
     p_dp.z = 0.0;
@@ -60,7 +60,7 @@ void PlannerSelector::callbackFromLattice(const std_msgs::Int32 &amp;msg)
     p_astar.x = astar_point.pose.pose.position.y;
     p_astar.z = 0.0;
 
-    _distance = euclidean_space::EuclideanSpace::find_distance(&amp;p_dp, &amp;p_astar);
+    _distance = amathutils::find_distance(&amp;p_dp, &amp;p_astar);
     //  ROS_INFO("distance=%f. %d:%d", _distance, dp_point.dtlane.dist,astar_point.dtlane.dist);
   }
   catch (const std::out_of_range &amp;ex)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="010cc5db4df080a21a579813bdf04ee37b66ef61" author="Yusuke FUJII">
		<msg>add mps2kmph</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libamathutils\include\amathutils.hpp" new_path="ros\src\computing\planning\decision\libs\libamathutils\include\amathutils.hpp" added_lines="6" deleted_lines="0">
				<diff>@@ -8,6 +8,7 @@ using namespace std;
 
 namespace amathutils
 {
+
 class point
 {
 private:
@@ -29,6 +30,11 @@ public:
 double find_distance(point *_a, point *_b);
 double find_angle(point *_a, point *_b);
 
+inline double mps2kmph(double _mpsval)
+{
+  return (_mpsval * 0.36 );// mps * 60secs * 60minutes / 1000m
+}
+
 } 
 
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libamathutils\src\Amathutils.cpp" new_path="ros\src\computing\planning\decision\libs\libamathutils\src\Amathutils.cpp" added_lines="2" deleted_lines="0">
				<diff>@@ -16,4 +16,6 @@ namespace amathutils
     return _angle * 360 / (2 * M_PI);
   }
 
+
+
 } 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="3" deleted_lines="7">
				<diff>@@ -58,19 +58,15 @@ enum class E_ChangeFlags : int32_t
   UNKNOWN = -1,
 };
 
-template &lt;class T&gt;
-typename std::underlying_type&lt;T&gt;::type enumToInteger(T t)
-{
-  return static_cast&lt;typename std::underlying_type&lt;T&gt;::type&gt;(t);
-}
 inline bool hasvMap(void)
 {
   return true;
 }
 
-inline double mps2kmph(double _mpsval)
+template &lt;class T&gt;
+typename std::underlying_type&lt;T&gt;::type enumToInteger(T t)
 {
-  return (_mpsval * 60 * 60) / 1000;  // mps * 60sec * 60m / 1000m
+  return static_cast&lt;typename std::underlying_type&lt;T&gt;::type&gt;(t);
 }
 
 class DecisionMakerNode
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -232,7 +232,7 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
 	double _temp_sum = 0;
 	for (int i = 0; i &lt; VEL_AVERAGE_COUNT; i++)
 	{
-		_temp_sum += mps2kmph(msg.waypoints[i].twist.twist.linear.x);
+		_temp_sum += amathutils::mps2kmph(msg.waypoints[i].twist.twist.linear.x);
 	}
 	average_velocity_ = _temp_sum / VEL_AVERAGE_COUNT;
 
@@ -287,7 +287,7 @@ void DecisionMakerNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::Cr
 
 void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
 {
-	current_velocity_ = mps2kmph(msg.twist.linear.x);
+	current_velocity_ = amathutils::mps2kmph(msg.twist.linear.x);
 }
 #if 0
 void DecisionMakerNode::callbackFromDynamicReconfigure(decision_maker::decision_makerConfig &amp;config, uint32_t level){
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -134,7 +134,7 @@ void DecisionMakerNode::publishToVelocityArray()
 
   for (const auto &amp;i : current_finalwaypoints_.waypoints)
   {
-    msg.data.push_back(mps2kmph(i.twist.twist.linear.x));
+    msg.data.push_back(amathutils::mps2kmph(i.twist.twist.linear.x));
     if (++count &gt;= 10)
       break;
   }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\planner_selector\planner_selector_node.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\planner_selector\planner_selector_node.cpp" added_lines="0" deleted_lines="4">
				<diff>@@ -116,10 +116,6 @@ void PlannerSelector::callbackFromLattice(const std_msgs::Int32 &amp;msg)
   // for debug
   //	ROS_INFO("\n***** EnableLattice = %d  **** \n",enableLattice_,msg.data);
 }
-inline double mps2kmph(double _mpsval)
-{
-  return (_mpsval * 60 * 60) / 1000;  // mps * 60sec * 60m / 1000m
-}
 
 void PlannerSelector::callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::lane const&gt; &amp;event)
 {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="14e6d16f12cc16e07efcfa480c987f174232cd0d" author="Yusuke FUJII">
		<msg>add support to waypoint velocity control by state</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libamathutils\include\amathutils.hpp" new_path="ros\src\computing\planning\decision\libs\libamathutils\include\amathutils.hpp" added_lines="19" deleted_lines="3">
				<diff>@@ -1,5 +1,5 @@
-#ifndef __EUCLIDEAN_SPACE_HPP
-#define __EUCLIDEAN_SPACE_HPP
+#ifndef __AMATHUTILS_HPP
+#define __AMATHUTILS_HPP
 
 #include &lt;cmath&gt;
 #include &lt;iostream&gt;
@@ -35,6 +35,22 @@ inline double mps2kmph(double _mpsval)
   return (_mpsval * 0.36 );// mps * 60secs * 60minutes / 1000m
 }
 
-} 
+#define G_MPSS 9.80665 // m/s^2
+
+
+inline double getGravityAcceleration(double acceleration_mpss)
+{
+	return acceleration_mpss /  G_MPSS;
+}
 
+inline double getAcceleration(double v0, double v, double x)
+{
+	return  (v * v - v0 * v0) / 2 / x;
+}
+
+inline double getTimefromAcceleration(double v0, double v, double a)
+{
+	return  (v - v0) / a;
+} 
+}
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libamathutils\src\Amathutils.cpp" new_path="ros\src\computing\planning\decision\libs\libamathutils\src\Amathutils.cpp" added_lines="4" deleted_lines="0">
				<diff>@@ -6,6 +6,10 @@ namespace amathutils
   {
     return std::hypot(std::hypot(_a-&gt;x - _b-&gt;x, _a-&gt;y - _b-&gt;y), _a-&gt;z - _b-&gt;z);
   }
+  double find_distance(point &amp;_a, point &amp;_b)
+  {
+    return std::hypot(std::hypot(_a.x - _b.x, _a.y - _b.y), _a.z - _b.z);
+  }
 
   double find_angle(point *_a, point *_b)
   {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="3" deleted_lines="2">
				<diff>@@ -190,13 +190,14 @@ bool StateContext::disableCurrentState(unsigned long long _state_num)
 bool StateContext::isCurrentState(unsigned long long _state_num)
 {
   BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
-  return (*state_ptr) ? (*state_ptr)-&gt;getStateNum() == _state_num ? true : false : false;
+  fprintf(stderr,"(*state_ptr)-&gt;getStateNum():%d:state_num=%d \n",(*state_ptr)?(*state_ptr)-&gt;getStateNum():false, _state_num);
+  return (*state_ptr) ? (*state_ptr)-&gt;getStateNum() &amp; _state_num ? true : false : false;
   // return current_state_.MainState?current_state_.MainState-&gt;getStateNum() == _state_num?true:false:false;
 }
 
 bool StateContext::isState(BaseState *base, unsigned long long _state_num)
 {
-  return base ? base-&gt;getStateNum() == _state_num ? true : false : false;
+  return base ? base-&gt;getStateNum() &amp; _state_num ? true : false : false;
 }
 
 bool StateContext::inState(unsigned long long _state_num)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="46" deleted_lines="1">
				<diff>@@ -1,4 +1,5 @@
 #include &lt;stdio.h&gt;
+#include &lt;cmath&gt;
 
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;jsk_rviz_plugins/OverlayText.h&gt;
@@ -44,6 +45,49 @@ bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
 	ctx-&gt;setEnableForceSetState(true);
 	_ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
 	ctx-&gt;setEnableForceSetState(false);
+
+
+	if(ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE) ||
+		ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE)){
+		
+		int count = 0;
+		for (auto &amp;lane : current_controlled_lane_array_.lanes)
+		{
+			fprintf(stderr,"%d \n", count++);
+			autoware_msgs::lane temp_lane = lane;
+				for(size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++){
+
+					double v0 =  temp_lane.waypoints.at(wpi-1).twist.twist.linear.x;
+					double v =  temp_lane.waypoints.at(wpi).twist.twist.linear.x;
+
+					amathutils::point p0(
+							temp_lane.waypoints.at(wpi).pose.pose.position.x,
+							temp_lane.waypoints.at(wpi).pose.pose.position.y,
+							temp_lane.waypoints.at(wpi).pose.pose.position.z);
+					amathutils::point p1(
+							temp_lane.waypoints.at(wpi-1).pose.pose.position.x,
+							temp_lane.waypoints.at(wpi-1).pose.pose.position.y,
+							temp_lane.waypoints.at(wpi-1).pose.pose.position.z);
+
+
+					double distance = amathutils::find_distance(&amp;p0,&amp;p1);
+					double _weight = distance * 0.05; 
+					if(ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE)){
+						_weight *= 1;
+					}
+					else if(ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE)){
+						_weight *= -1;
+					}
+					lane.waypoints.at(wpi).twist.twist.linear.x =  
+						lane.waypoints.at(wpi).twist.twist.linear.x + 
+						lane.waypoints.at(wpi).twist.twist.linear.x * _weight;
+				}
+
+		}
+		Pubs["lane_waypoints_array"].publish(current_controlled_lane_array_);
+	}else{
+		fprintf(stderr,"not waypoint control\n");
+	}
 	return _ret;
 }
 
@@ -228,6 +272,7 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
 	else
 		ctx-&gt;setCurrentState(state_machine::DRIVE_STR_STRAIGHT_STATE);
 
+#if 0
 	// velocity
 	double _temp_sum = 0;
 	for (int i = 0; i &lt; VEL_AVERAGE_COUNT; i++)
@@ -242,7 +287,7 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
 		ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE);
 	else
 		ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE);
-
+#endif
 	// for publish plan of velocity
 	publishToVelocityArray();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="636bc3531d4b1b371d0cfcba662a65a7260ea5b4" author="Yamato ANDO">
		<msg>refactor CMakeLists.txt. use automoc, autouic and autorcc</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_lidar_track\mainwindow.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_lidar_track\mainwindow.cpp" added_lines="1" deleted_lines="2">
				<diff>@@ -1,6 +1,5 @@
 #include "mainwindow.h"
 #include "ui_mainwindow.h"
-#include "moc_mainwindow.cpp"
 
 InitTrackerView::InitTrackerView(QWidget * parent)
     : QGraphicsView(parent)
@@ -209,7 +208,7 @@ void UpdateTrackerView::slotUpdateTrackerFinish(LaserScan scan, QMap&lt;int, Tracke
     {
         bool flag=trackidlist.contains(curidlist[i]);
         if(!flag)
-        {            
+        {
             pathmap.remove(curidlist[i]);
         }
     }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_lidar_track\rbsspfvehicletracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\vscan_lidar_track\rbsspfvehicletracker.cpp" added_lines="1" deleted_lines="2">
				<diff>@@ -1,5 +1,4 @@
 #include "rbsspfvehicletracker.h"
-#include "moc_rbsspfvehicletracker.cpp"
 
 
 RBSSPFVehicleTrackerInstance::RBSSPFVehicleTrackerInstance(int vehicleID, QThread *thread)
@@ -114,7 +113,7 @@ void RBSSPFVehicleTracker::addTrackerData(LaserScan &amp; scan, QVector&lt;VehicleState
             }
         }
         else if(trackerthreadmap.size()&gt;0)
-        {            
+        {
             initstatemap.clear();
             trackercount=trackerthreadmap.size();
             emit signalUpdateTracker(&amp;initstatemap);
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\tlr_tuner\mainwindow.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\tlr_tuner\mainwindow.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -4,7 +4,6 @@
 #include &lt;QtCore/QString&gt;
 #include &lt;QFileDialog&gt;
 #include &lt;QMessageBox&gt;
-#include "mainwindow_moc.cpp"
 
 MainWindow::MainWindow(QWidget *parent) :
   QMainWindow(parent),
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\CalibrationToolkit\calibrationtoolkit.cpp" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\CalibrationToolkit\calibrationtoolkit.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -1,5 +1,4 @@
 #include "calibrationtoolkit.h"
-#include "calibrationtoolkit_moc.cpp"
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
 
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\CalibrationToolkit\selectionwidget.cpp" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\CalibrationToolkit\selectionwidget.cpp" added_lines="1" deleted_lines="2">
				<diff>@@ -1,5 +1,4 @@
 #include"selectionwidget.h"
-#include"selectionwidget_moc.cpp"
 
 PlaneExtractor::PlaneExtractor(sensor_msgs::PointCloud2ConstPtr velodynePoints, int id, double neighborRadius, double distanceThreshold, QWidget *parent)
     : GLViewer(parent)
@@ -343,7 +342,7 @@ void PlaneExtractor::extractPlane(Eigen::Vector3d seed, Eigen::Matrix3d eigenvec
 }
 
 PointsExtractor::PointsExtractor(int imageSize, double maxRange, double gridSize)
-{    
+{
     pointsid=-1;
     imagesize=imageSize;
     maxrange=maxRange;
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_toolkit\main.cpp" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_toolkit\main.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -1,5 +1,4 @@
 #include "mainwindow.h"
-#include "mainwindow_moc.cpp"
 #include &lt;QApplication&gt;
 
 int main(int argc, char *argv[])
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\points2image\nodes\points2vscan\main.cpp" new_path="ros\src\sensing\fusion\packages\points2image\nodes\points2vscan\main.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -1,5 +1,4 @@
 #include "mainwindow.h"
-#include "mainwindow_moc.cpp"
 #include &lt;QApplication&gt;
 
 int main(int argc, char *argv[])
</diff>
			</file>
			<file old_path="ros\src\util\packages\RobotSDK\glviewer\GLViewer\glviewer.cpp" new_path="ros\src\util\packages\RobotSDK\glviewer\GLViewer\glviewer.cpp" added_lines="1" deleted_lines="2">
				<diff>@@ -29,7 +29,6 @@
 */
 
 #include "glviewer.h"
-#include "glviewer_moc.cpp"
 
 #define GL_PI 3.1415926535897932384626433832795
 
@@ -101,7 +100,7 @@ void GLViewer::paintGL()
     glClearColor(cameraparameters.background(0),cameraparameters.background(1),cameraparameters.background(2),0.0);
     glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
     glMatrixMode(GL_MODELVIEW);
-	glLoadIdentity();   
+	glLoadIdentity();
     gluLookAt(eye(0),eye(1),eye(2),center(0),center(1),center(2),up(0),up(1),up(2));
 	glPushMatrix();
     int i,n=displaylist.size();
</diff>
			</file>
			<file old_path="ros\src\util\packages\RobotSDK\rosinterface\ROSInterface\rosinterface.cpp" new_path="ros\src\util\packages\RobotSDK\rosinterface\ROSInterface\rosinterface.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -29,7 +29,6 @@
 */
 
 #include "rosinterface.h"
-#include "rosinterface_moc.cpp"
 
 //using namespace RobotSDK;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="bc5b8440b91fb65ad769a8b4dae4cf123847f98b" author="Abraham Monrroy">
		<msg>Fix feature/points2image bug multicam support (#886)

* pointgrey

* Added New Calibration node

* Added parameters, plane fitting

* added mirror node, etc

* Points2Image
Calibration Publisher
now works with multiple cameras using ros namespaces

* Including only points2image

* Added Launch file for points2 image specific for the ladybug camera</msg>
		<modified_files>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_publisher\calibration_publisher.cpp" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_publisher\calibration_publisher.cpp" added_lines="49" deleted_lines="40">
				<diff>@@ -11,6 +11,7 @@ static cv::Mat  CameraExtrinsicMat;
 static cv::Mat  CameraMat;
 static cv::Mat  DistCoeff;
 static cv::Size ImageSize;
+static std::string DistModel;
 
 static ros::Publisher camera_info_pub;
 static ros::Publisher projection_matrix_pub;
@@ -47,39 +48,27 @@ void tfRegistration (const cv::Mat &amp;camExtMat, const ros::Time&amp; timeStamp)
   //broadcaster.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "velodyne", "camera"));
 }
 
-
-static void image_raw_cb(const sensor_msgs::Image&amp; image_msg)
+void projectionMatrix_sender(const cv::Mat  &amp;projMat, const ros::Time&amp; timeStamp)
 {
-  //ros::Time timeStampOfImage = image_msg.header.stamp;
-
-  ros::Time timeStampOfImage;
-  timeStampOfImage.sec = image_msg.header.stamp.sec;
-  timeStampOfImage.nsec = image_msg.header.stamp.nsec;
-
-
-  /* create TF between velodyne and camera with time stamp of /image_raw */
-  tfRegistration(CameraExtrinsicMat, timeStampOfImage);
+  autoware_msgs::projection_matrix projMsg;
 
-}
+  projMsg.header.frame_id=camera_id_str;
 
-void projectionMatrix_sender(const cv::Mat  &amp;projMat)
-{
-	autoware_msgs::projection_matrix projMsg;
-
-	projMsg.header.frame_id=camera_id_str;
-
-	for (int row=0; row&lt;4; row++) {
-	      for (int col=0; col&lt;4; col++) {
-	    	  	  projMsg.projection_matrix[row * 4 + col] = projMat.at&lt;double&gt;(row, col);
+  for (int row=0; row&lt;4; row++) {
+    for (int col=0; col&lt;4; col++) {
+      projMsg.projection_matrix[row * 4 + col] = projMat.at&lt;double&gt;(row, col);
 
-	      }
-	}
-	projection_matrix_pub.publish(projMsg);
+    }
+  }
+  projMsg.header.stamp = timeStamp;
+  projection_matrix_pub.publish(projMsg);
 }
 
 void cameraInfo_sender(const cv::Mat  &amp;camMat,
                        const cv::Mat  &amp;distCoeff,
-                       const cv::Size &amp;imgSize)
+                       const cv::Size &amp;imgSize,
+                       const std::string&amp; distModel,
+                       const ros::Time&amp; timeStamp)
 {
   sensor_msgs::CameraInfo msg;
 
@@ -89,10 +78,10 @@ void cameraInfo_sender(const cv::Mat  &amp;camMat,
   msg.width  = imgSize.width;
 
   for (int row=0; row&lt;3; row++) {
-      for (int col=0; col&lt;3; col++) {
-        msg.K[row * 3 + col] = camMat.at&lt;double&gt;(row, col);
-        }
+    for (int col=0; col&lt;3; col++) {
+      msg.K[row * 3 + col] = camMat.at&lt;double&gt;(row, col);
     }
+  }
 
   for (int row=0; row&lt;3; row++) {
     for (int col=0; col&lt;4; col++) {
@@ -109,10 +98,35 @@ void cameraInfo_sender(const cv::Mat  &amp;camMat,
       msg.D.push_back(distCoeff.at&lt;double&gt;(row, col));
     }
   }
+  msg.header.stamp = timeStamp;
+  msg.distortion_model = distModel;
 
   camera_info_pub.publish(msg);
 }
 
+static void image_raw_cb(const sensor_msgs::Image&amp; image_msg)
+{
+  //ros::Time timeStampOfImage = image_msg.header.stamp;
+
+  ros::Time timeStampOfImage;
+  timeStampOfImage.sec = image_msg.header.stamp.sec;
+  timeStampOfImage.nsec = image_msg.header.stamp.nsec;
+
+
+  /* create TF between velodyne and camera with time stamp of /image_raw */
+  if (isRegister_tf) {
+    tfRegistration(CameraExtrinsicMat, timeStampOfImage);
+  }
+
+  if (isPublish_cameraInfo) {
+    cameraInfo_sender(CameraMat, DistCoeff, ImageSize, DistModel, timeStampOfImage);
+  }
+  if (isPublish_extrinsic) {
+    projectionMatrix_sender(CameraExtrinsicMat, timeStampOfImage);
+  }
+
+}
+
 
 int main(int argc, char* argv[])
 {
@@ -149,9 +163,10 @@ int main(int argc, char* argv[])
   fs["CameraMat"] &gt;&gt; CameraMat;
   fs["DistCoeff"] &gt;&gt; DistCoeff;
   fs["ImageSize"] &gt;&gt; ImageSize;
+  fs["DistModel"] &gt;&gt; DistModel;
 
   std::string image_topic_name("/image_raw");
-  std::string camera_info_name("/camera/camera_info");
+  std::string camera_info_name("/camera_info");
   std::string projection_matrix_name("/projection_matrix");
 
   std::string name_space_str = ros::this_node::getNamespace();
@@ -169,19 +184,13 @@ int main(int argc, char* argv[])
   }
 
   ros::Subscriber image_sub;
-  if (isRegister_tf) {
-    image_sub = n.subscribe(image_topic_name, 10, image_raw_cb);
-  }
 
-  if (isPublish_cameraInfo) {
-    camera_info_pub = n.advertise&lt;sensor_msgs::CameraInfo&gt;(camera_info_name, 10, true);
-    cameraInfo_sender(CameraMat, DistCoeff, ImageSize);
-  }
+  image_sub = n.subscribe(image_topic_name, 10, image_raw_cb);
+
+  camera_info_pub = n.advertise&lt;sensor_msgs::CameraInfo&gt;(camera_info_name, 10, false);
+
+  projection_matrix_pub = n.advertise&lt;autoware_msgs::projection_matrix&gt;(projection_matrix_name, 10, false);
 
-  if (isPublish_extrinsic) {
-    projection_matrix_pub = n.advertise&lt;autoware_msgs::projection_matrix&gt;(projection_matrix_name, 10, true);
-    projectionMatrix_sender(CameraExtrinsicMat);
-  }
 
   ros::spin();
 
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_toolkit\mainwindow.cpp" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_toolkit\mainwindow.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -18,7 +18,7 @@ MainWindow::MainWindow(QWidget *parent) :
     std::vector&lt;std::string&gt; image_raw_topics;
     FILE *fp;
 
-    if(!(fp = popen("rostopic list | grep image_raw", "r"))) {
+    if(!(fp = popen("rostopic list", "r"))) {
       fprintf(stderr, "cannot get image_raw topic list\n");
       exit(EXIT_FAILURE);
     }
@@ -27,7 +27,7 @@ MainWindow::MainWindow(QWidget *parent) :
     char topic[256];
     while((fgets(topic, 256, fp)) != NULL)
     {
-     if ((strstr(topic, "image_raw")) != NULL)
+     //if ((strstr(topic, "image_raw")) != NULL)
      {
        strtok(topic, "\n\0");  // delete line feed code ('\n')
        image_raw_topics.push_back(std::string(topic));
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\points2image\lib\points_image\points_image.cpp" new_path="ros\src\sensing\fusion\packages\points2image\lib\points_image\points_image.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -72,7 +72,7 @@ pointcloud2_to_image(const sensor_msgs::PointCloud2ConstPtr&amp; pointcloud2,
 			point.at&lt;double&gt;(2) = double(fp[2]);
 			point = point * invR.t() + invT.t();
 
-			if (point.at&lt;double&gt;(2) &lt;= 2.5) {
+			if (point.at&lt;double&gt;(2) &lt;= 1) {
 				continue;
 			}
 
</diff>
			</file>
			<file old_path="ros\src\sensing\fusion\packages\points2image\nodes\points2image\points2image.cpp" new_path="ros\src\sensing\fusion\packages\points2image\nodes\points2image\points2image.cpp" added_lines="30" deleted_lines="50">
				<diff>@@ -81,7 +81,7 @@ static void callback(const sensor_msgs::PointCloud2ConstPtr&amp; msg)
 {
 	if (cameraExtrinsicMat.empty() || cameraMat.empty() || distCoeff.empty() || imageSize.height == 0 || imageSize.width == 0)
 	{
-		ROS_INFO("Looks like /camera/camera_info or /projection_matrix are not being published.. Please check that both are running..");
+		ROS_INFO("[points2image]Looks like camera_info or projection_matrix are not being published.. Please check that both are running..");
 		return;
 	}
 
@@ -89,10 +89,6 @@ static void callback(const sensor_msgs::PointCloud2ConstPtr&amp; msg)
 		= pointcloud2_to_image(msg, cameraExtrinsicMat, cameraMat,
 				       distCoeff, imageSize);
 	pub.publish(pub_msg);
-
-	/*autoware_msgs::CameraExtrinsic cpub_msg
-		= pointcloud2_to_3d_calibration(msg, cameraExtrinsicMat);
-	cpub.publish(cpub_msg);*/
 }
 
 int main(int argc, char *argv[])
@@ -100,64 +96,48 @@ int main(int argc, char *argv[])
 	ros::init(argc, argv, "points2image");
 	ros::NodeHandle n;
 
-	/*if(argc &lt; 2){
-		std::cout&lt;&lt;"Need calibration filename as the first parameter.";
-		return 0;
-	}*/
-
-	/*cv::FileStorage fs(argv[1], cv::FileStorage::READ);
-	if(!fs.isOpened()){
-		std::cout&lt;&lt;"Invalid calibration filename.";
-		return 0;
-	}*/
-
-	/*fs[CAMERAEXTRINSICMAT] &gt;&gt; cameraExtrinsicMat;
-	fs[CAMERAMAT] &gt;&gt; cameraMat;
-	fs[DISTCOEFF] &gt;&gt; distCoeff;
-	fs[IMAGESIZE] &gt;&gt; imageSize;*/
-	//imageSize.width = IMAGE_WIDTH;
-	//imageSize.height = IMAGE_HEIGHT;
-
-	pub = n.advertise&lt;autoware_msgs::PointsImage&gt;("points_image", 10);
-	//cpub = n.advertise&lt;autoware_msgs::CameraExtrinsic&gt;("threeD_calibration", 1);
 	ros::NodeHandle private_nh("~");
 
-	std::string points_topic;
-	if (private_nh.getParam("points_node", points_topic))
-	{
-		ROS_INFO("Setting points node to %s", points_topic.c_str());
-	}
-	else
-	{
-		ROS_INFO("No points node received, defaulting to points_raw, you can use _points_node:=YOUR_TOPIC");
-		points_topic = "points_raw";
-	}
+	std::string camera_info_topic_str;
+	std::string projection_matrix_topic;
+	std::string pub_topic_str="/points_image";
 
-	std::string camera_info_topic;
-	if (private_nh.getParam("camera_info_topic", camera_info_topic))
-	{
-		ROS_INFO("Setting camera_info topic to %s", camera_info_topic.c_str());
-	}
-	else
-	{
-		ROS_INFO("No camera info topic received, defaulting to /camera/camera_info, you can use _camera_info_topic:=YOUR_TOPIC");
-		camera_info_topic = "/camera/camera_info";
+	private_nh.param&lt;std::string&gt;("projection_matrix_topic", projection_matrix_topic, "/projection_matrix");
+	private_nh.param&lt;std::string&gt;("camera_info_topic", camera_info_topic_str, "/camera_info");
+
+	std::string name_space_str = ros::this_node::getNamespace();
+
+	if (name_space_str != "/") {
+		if (name_space_str.substr(0, 2) == "//") {
+			/* if name space obtained by ros::this::node::getNamespace()
+			   starts with "//", delete one of them */
+			name_space_str.erase(name_space_str.begin());
+		}
+		pub_topic_str = name_space_str + pub_topic_str;
+		projection_matrix_topic = name_space_str+projection_matrix_topic;
+		camera_info_topic_str = name_space_str + camera_info_topic_str;
 	}
 
-	std::string projection_matrix_topic;
-	if (private_nh.getParam("projection_matrix_topic", projection_matrix_topic))
+	std::string points_topic;
+	if (private_nh.getParam("points_node", points_topic))
 	{
-		ROS_INFO("Setting projection_matrix topic to %s", projection_matrix_topic.c_str());
+		ROS_INFO("[points2image]Setting points node to %s", points_topic.c_str());
 	}
 	else
 	{
-		ROS_INFO("No projection matrix topic received, defaulting to /projection_matrix, you can use _projection_matrix_topic:=YOUR_TOPIC");
-		projection_matrix_topic = "/projection_matrix";
+		ROS_INFO("[points2image]No points node received, defaulting to points_raw, you can use _points_node:=YOUR_TOPIC");
+		points_topic = "/points_raw";
 	}
 
+	ROS_INFO("[points2image]Publishing to... %s", pub_topic_str.c_str());
+	pub = n.advertise&lt;autoware_msgs::PointsImage&gt;(pub_topic_str, 10);
+
 	ros::Subscriber sub = n.subscribe(points_topic, 1, callback);
+
+	ROS_INFO("[points2image]Subscribing to... %s", projection_matrix_topic.c_str());
 	ros::Subscriber projection = n.subscribe(projection_matrix_topic, 1, projection_callback);
-	ros::Subscriber intrinsic = n.subscribe(camera_info_topic, 1, intrinsic_callback);
+	ROS_INFO("[points2image]Subscribing to... %s", camera_info_topic_str.c_str());
+	ros::Subscriber intrinsic = n.subscribe(camera_info_topic_str, 1, intrinsic_callback);
 
 	ros::spin();
 	return 0;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7fb0cd3a01b83ffbfd9b2f33de2675b98e38f884" author="Yusuke FUJII">
		<msg>remove unnecessary code from decisionmaker</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" added_lines="8" deleted_lines="62">
				<diff>@@ -41,10 +41,11 @@ class EmergencyState;
 class BaseState
 {
 protected:
-public:
   BaseState()
   {
   }
+public:
+  virtual void update(void) = 0;
   virtual void showStateName(void) = 0;
   virtual unsigned long long getStateTransMask() = 0;
   virtual unsigned long long getStateNum() = 0;
@@ -69,6 +70,12 @@ public:
     StateTransMask = (unsigned long long)STATE_END - 1;
     StateKind = UNKNOWN_STATE;
   }
+
+public:
+  virtual void update(void){
+	std::cout &lt;&lt; "update:"&lt;&lt; StateNum &lt;&lt; std::endl;
+  }
+
   void showStateName(void)
   {
     std::cout &lt;&lt; StateName &lt;&lt; "-";
@@ -99,67 +106,6 @@ public:
     return StateNum;
   }
 };
-
-// StartState
-class StartState : public State&lt;StartState&gt;
-{
-private:
-  friend class State&lt;StartState&gt;;
-  StartState(void)
-  {
-    StateName = "Start";
-    StateNum = START_STATE;
-    StateTransMask = (unsigned long long)STATE_END - 1;
-    StateKind = MAIN_STATE;
-  }
-
-public:
-};
-
-// InitialState
-class InitialState : public State&lt;InitialState&gt;
-{
-private:
-  friend class State&lt;InitialState&gt;;
-  InitialState(void)
-  {
-    StateName = "Initial";
-    StateNum = StateTransMask = INITIAL_STATE;
-    StateTransMask |= START_STATE | EMERGENCY_STATE | MISSION_COMPLETE_STATE;
-    StateKind = MAIN_STATE;
-  }
-
-public:
-};
-class LocateVehicleState : public State&lt;LocateVehicleState&gt;
-{
-private:
-  friend class State&lt;LocateVehicleState&gt;;
-  LocateVehicleState(void)
-  {
-    StateName = "Locate Vehicle";
-    StateNum = StateTransMask = INITIAL_LOCATEVEHICLE_STATE;
-    StateTransMask |= INITIAL_STATE;
-    StateKind = MAIN_STATE;
-  }
-
-public:
-};
-// MissionCompleteState
-class MissionCompleteState : public State&lt;MissionCompleteState&gt;
-{
-private:
-  friend class State&lt;MissionCompleteState&gt;;
-  MissionCompleteState(void)
-  {
-    StateName = "MissionComplete";
-    StateNum = MISSION_COMPLETE_STATE;
-    StateTransMask = DRIVE_STATE;
-    StateKind = MAIN_STATE;
-  }
-
-public:
-};
 }
 
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" added_lines="6" deleted_lines="0">
				<diff>@@ -8,7 +8,10 @@
 #include &lt;mutex&gt;
 #include &lt;unordered_map&gt;
 #include &lt;utility&gt;
+
+
 #include "state.hpp"
+#include "state_main.hpp"
 #include "state_drive.hpp"
 #include "state_emg.hpp"
 
@@ -17,6 +20,7 @@ namespace state_machine
 class StateContext
 {
 private:
+
   class StateHolder
   {
   public:
@@ -98,6 +102,8 @@ public:
   {
     thread_loop = false;
   }
+
+  void update(void);
   void stateDecider(void);
 
   bool isState(BaseState *base, unsigned long long _state_num);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" added_lines="4" deleted_lines="1">
				<diff>@@ -12,6 +12,7 @@
 
 namespace state_machine
 {
+
 // DriveState
 class DriveState : public State&lt;DriveState&gt;
 {
@@ -130,8 +131,10 @@ private:
     StateTransMask = DRIVE_STATE;
     StateKind = STR_STATE;
   }
-
 public:
+  void update(void){
+
+  }
 };
 class DriveStrStraightState : public State&lt;DriveStrStraightState&gt;
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_emg.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_emg.hpp" added_lines="0" deleted_lines="13">
				<diff>@@ -5,19 +5,6 @@
 
 namespace state_machine
 {
-// EmergencyState
-class EmergencyState : public State&lt;EmergencyState&gt;
-{
-private:
-  friend class State&lt;EmergencyState&gt;;
-  EmergencyState(void)
-  {
-    StateName = "Emergency";
-    StateTransMask = 0;
-  }
-
-public:
-};
 class EmergencyHWState : public State&lt;EmergencyHWState&gt;
 {
 private:
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state.cpp" new_path="" added_lines="0" deleted_lines="15">
				<diff>@@ -1,15 +0,0 @@
-
-/**
-*
-* @file state.cpp
-* @brief main function
-* @author Yusuke Fujii
-* @date  2017/07/25
-*
-**/
-
-#include "state.hpp"
-#include &lt;iostream&gt;
-#include "StateContext.hpp"
-
-using namespace state_machine;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="0" deleted_lines="2">
				<diff>@@ -190,9 +190,7 @@ bool StateContext::disableCurrentState(unsigned long long _state_num)
 bool StateContext::isCurrentState(unsigned long long _state_num)
 {
   BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
-  fprintf(stderr,"(*state_ptr)-&gt;getStateNum():%d:state_num=%d \n",(*state_ptr)?(*state_ptr)-&gt;getStateNum():false, _state_num);
   return (*state_ptr) ? (*state_ptr)-&gt;getStateNum() &amp; _state_num ? true : false : false;
-  // return current_state_.MainState?current_state_.MainState-&gt;getStateNum() == _state_num?true:false:false;
 }
 
 bool StateContext::isState(BaseState *base, unsigned long long _state_num)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="22" deleted_lines="23">
				<diff>@@ -5,6 +5,7 @@
 #include &lt;jsk_rviz_plugins/OverlayText.h&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/String.h&gt;
+#include &lt;std_msgs/UInt8.h&gt;
 
 #include &lt;autoware_msgs/lane.h&gt;
 #include &lt;autoware_msgs/traffic_light.h&gt;
@@ -16,13 +17,6 @@
 
 namespace decision_maker
 {
-// TODO for Decision_maker
-// - lane_change
-// - fix a light_color_changed
-// - disable/clear_subclassa
-// - object detection
-// - changed subscribing waypoint topic to base_waypoints from final_waypoints
-//
 
 void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
 {
@@ -34,9 +28,6 @@ void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped
 	{
 		ROS_INFO("Localization was convergence");
 	}
-
-	// displacement_from_path_ =  getDisplacementFromPath(_pose.pose.position.x, _pose.pose.position.y,
-	// _pose.pose.position.z);
 }
 
 bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
@@ -53,7 +44,6 @@ bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
 		int count = 0;
 		for (auto &amp;lane : current_controlled_lane_array_.lanes)
 		{
-			fprintf(stderr,"%d \n", count++);
 			autoware_msgs::lane temp_lane = lane;
 				for(size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++){
 
@@ -85,12 +75,17 @@ bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
 
 		}
 		Pubs["lane_waypoints_array"].publish(current_controlled_lane_array_);
-	}else{
-		fprintf(stderr,"not waypoint control\n");
 	}
 	return _ret;
 }
 
+void DecisionMakerNode::callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg)
+{
+	ROS_INFO("Received system is going to simulation mode");
+	handleStateCmd(state_machine::DRIVE_STATE);
+	Subs["sim_pose"].shutdown();
+}
+
 void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
 {
 	ROS_INFO("Received forcing state changing request");
@@ -214,7 +209,7 @@ void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
 				}
 			}
 		}
-		fprintf(stderr,"%d: %d  angle_deg :%d\n",area.area_id, steering_state, angle_deg);
+		ROS_INFO("%d: %d  angle_deg :%d\n",area.area_id, steering_state, angle_deg);
 	}
 }
 }
@@ -248,6 +243,17 @@ void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray
 	Pubs["lane_waypoints_array"].publish(current_controlled_lane_array_);
 }
 
+state_machine::StateFlags getStateFlags(uint8_t msg_state)
+{
+	if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_LEFT)
+		return state_machine::DRIVE_STR_LEFT_STATE;
+	else if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_RIGHT)
+		return state_machine::DRIVE_STR_RIGHT_STATE;
+	else
+		return state_machine::DRIVE_STR_STRAIGHT_STATE;
+}
+
+
 void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
 {
 	if (!hasvMap())
@@ -262,15 +268,7 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
 	}
 	// steering
 	current_finalwaypoints_ = msg;
-
-	uint8_t steering_state = current_finalwaypoints_.waypoints.at(param_target_waypoint_).wpstate.steering_state;
-
-	if (steering_state == autoware_msgs::WaypointState::STR_LEFT)
-		ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
-	else if (steering_state == autoware_msgs::WaypointState::STR_RIGHT)
-		ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
-	else
-		ctx-&gt;setCurrentState(state_machine::DRIVE_STR_STRAIGHT_STATE);
+	ctx-&gt;setCurrentState(getStateFlags(current_finalwaypoints_.waypoints.at(param_target_waypoint_).wpstate.steering_state));
 
 #if 0
 	// velocity
@@ -288,6 +286,7 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
 	else
 		ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE);
 #endif
+
 	// for publish plan of velocity
 	publishToVelocityArray();
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" added_lines="2" deleted_lines="1">
				<diff>@@ -51,11 +51,12 @@ bool DecisionMakerNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;
 void DecisionMakerNode::update(void)
 {
   update_msgs();
+  if(ctx) ctx-&gt;update();
 }
 
 void DecisionMakerNode::run(void)
 {
-  ros::Rate loop_rate(0.3);
+  ros::Rate loop_rate(6);
 
   // for subscribe callback function
   ros::AsyncSpinner spinner(1);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" added_lines="0" deleted_lines="12">
				<diff>@@ -42,18 +42,6 @@ namespace decision_maker
 				2 * M_PI + diff : diff;
 			diff = diff *180/M_PI;
 
-#ifdef DEBUG_PRINT
-			std::cout &lt;&lt; "Yaw:" &lt;&lt; _y &lt;&lt; "-" &lt;&lt; y &lt;&lt; ":" &lt;&lt; _y - y &lt;&lt; std::endl;
-			std::cout &lt;&lt; "In:" &lt;&lt; InPose.position.x &lt;&lt; "," &lt;&lt; InPose.position.y &lt;&lt; std::endl;
-			std::cout &lt;&lt; "End:" &lt;&lt; OutPose.position.x &lt;&lt; "," &lt;&lt; OutPose.position.y &lt;&lt; std::endl;
-			if (diff &lt;= ANGLE_LEFT)
-				std::cout &lt;&lt; "LEFT :" &lt;&lt; diff &lt;&lt; std::endl;
-			else if (diff &gt;= ANGLE_RIGHT)
-				std::cout &lt;&lt; "RIGHT:" &lt;&lt; diff &lt;&lt; std::endl;
-			else
-				std::cout &lt;&lt; "Straight:" &lt;&lt; diff &lt;&lt; std::endl;
-#endif
-		
 		}
 
 		return diff;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="1" deleted_lines="0">
				<diff>@@ -38,6 +38,7 @@ void DecisionMakerNode::initStateMsgs(void)
 void DecisionMakerNode::initROS(int argc, char **argv)
 {
   // status subscriber
+  Subs["sim_pose"] = nh_.subscribe("sim_pose", 20, &amp;DecisionMakerNode::callbackFromSimPose, this);
   Subs["current_pose"] = nh_.subscribe("current_pose", 20, &amp;DecisionMakerNode::callbackFromCurrentPose, this);
   Subs["current_velocity"] =
       nh_.subscribe("current_velocity", 20, &amp;DecisionMakerNode::callbackFromCurrentVelocity, this);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a9d2ce175b42271fcf08a95743f7b82975d60a7b" author="Yusuke FUJII">
		<msg>Add support to switch on/off directional indicator</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" added_lines="14" deleted_lines="6">
				<diff>@@ -4,7 +4,7 @@
 #include &lt;iostream&gt;
 #include &lt;memory&gt;
 #include &lt;vector&gt;
-
+#include &lt;functional&gt;
 #include &lt;state_flags.hpp&gt;
 
 namespace state_machine
@@ -47,10 +47,11 @@ protected:
 public:
   virtual void update(void) = 0;
   virtual void showStateName(void) = 0;
-  virtual unsigned long long getStateTransMask() = 0;
-  virtual unsigned long long getStateNum() = 0;
-  virtual std::string getStateName() = 0;
-  virtual unsigned char getStateKind() = 0;
+  virtual unsigned long long getStateTransMask(void) = 0;
+  virtual unsigned long long getStateNum(void) = 0;
+  virtual std::string getStateName(void) = 0;
+  virtual unsigned char getStateKind(void) = 0;
+  virtual void setCallbackFunc(std::function&lt;void(void)&gt; _f)=0;
 };
 
 // Interface
@@ -63,7 +64,8 @@ protected:
   unsigned long long StateTransMask;
   unsigned char StateKind;
 
-public:
+  std::function&lt;void(void)&gt; StateCallbackFunc;
+  
   State()
   {
     StateNum = 0;
@@ -74,6 +76,12 @@ public:
 public:
   virtual void update(void){
 	std::cout &lt;&lt; "update:"&lt;&lt; StateNum &lt;&lt; std::endl;
+	if(StateCallbackFunc)
+		StateCallbackFunc();
+  }
+
+  virtual void setCallbackFunc(std::function&lt;void(void)&gt; _f){
+	StateCallbackFunc = _f;
   }
 
   void showStateName(void)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" added_lines="0" deleted_lines="4">
				<diff>@@ -117,7 +117,6 @@ private:
     StateTransMask = DRIVE_STATE;
     StateKind = STR_STATE;
   }
-
 public:
 };
 class DriveStrRightState : public State&lt;DriveStrRightState&gt;
@@ -132,9 +131,6 @@ private:
     StateKind = STR_STATE;
   }
 public:
-  void update(void){
-
-  }
 };
 class DriveStrStraightState : public State&lt;DriveStrStraightState&gt;
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="11" deleted_lines="6">
				<diff>@@ -23,12 +23,17 @@
 
 namespace state_machine
 {
-/**
- * @fn
- *
- * @brief
- * @return
- */
+void StateContext::update(void)
+{
+	for(auto &amp;&amp;p : HolderList){
+		if(*p){
+			(*p)-&gt;update();
+		}
+	}
+
+}
+
+
 void StateContext::showCurrentStateName(void)
 {
   for (auto &amp;&amp;p : HolderList)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="2" deleted_lines="0">
				<diff>@@ -157,6 +157,8 @@ private:
   void setWaypointState(autoware_msgs::LaneArray &amp;lane_array);
 
 
+  void callbackStateSTR(int status);
+  void setupStateCallback(void);
   // callback by topic subscribing
   void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
   void callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="6" deleted_lines="2">
				<diff>@@ -261,14 +261,18 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
 		std::cerr &lt;&lt; "Not found vmap subscribe" &lt;&lt; std::endl;
 		return;
 	}
+	
 	if (!ctx-&gt;isCurrentState(state_machine::DRIVE_STATE))
 	{
 		std::cerr &lt;&lt; "State is not DRIVE_STATE[" &lt;&lt; ctx-&gt;getCurrentStateName() &lt;&lt; "]" &lt;&lt; std::endl;
 		return;
 	}
-	// steering
+	//cached
 	current_finalwaypoints_ = msg;
-	ctx-&gt;setCurrentState(getStateFlags(current_finalwaypoints_.waypoints.at(param_target_waypoint_).wpstate.steering_state));
+	
+	// steering
+	if(current_finalwaypoints_.waypoints.size() &gt; param_target_waypoint_)
+		ctx-&gt;setCurrentState(getStateFlags(current_finalwaypoints_.waypoints.at(param_target_waypoint_).wpstate.steering_state));
 
 #if 0
 	// velocity
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="29" deleted_lines="1">
				<diff>@@ -16,6 +16,7 @@
 //#include &lt;vector_map/vector_map.h&gt;
 
 #include &lt;autoware_msgs/lane.h&gt;
+#include &lt;autoware_msgs/lamp_cmd.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;random&gt;
@@ -30,9 +31,29 @@ namespace decision_maker
 #define  TPNAME_BASED_LANE_WAYPOINTS_ARRAY "/based/lane_waypoints_array"
 #define  TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY "/lane_waypoints_array"
 
+void DecisionMakerNode::callbackStateSTR(int status){
+	ROS_INFO("[%s]:%d\n",__func__,status);
+	autoware_msgs::lamp_cmd lamp_msg;
+	
+	if(status == 0){
+		lamp_msg.l = 0; 
+		lamp_msg.r = 0;
+	}else if(status == 1){
+		lamp_msg.l = 1;
+		lamp_msg.r = 0;
+	}else if(status == 2){
+		lamp_msg.l = 0;
+		lamp_msg.r = 0;
+	}	
+	Pubs["lamp_cmd"].publish(lamp_msg);
 
-void DecisionMakerNode::initStateMsgs(void)
+}
+
+void DecisionMakerNode::setupStateCallback(void)
 {
+	ctx-&gt;getStateObject(state_machine::DRIVE_STR_LEFT_STATE)-&gt;setCallbackFunc(std::bind(&amp;DecisionMakerNode::callbackStateSTR, this, 1));
+	ctx-&gt;getStateObject(state_machine::DRIVE_STR_RIGHT_STATE)-&gt;setCallbackFunc(std::bind(&amp;DecisionMakerNode::callbackStateSTR, this, 2));
+	ctx-&gt;getStateObject(state_machine::DRIVE_STR_STRAIGHT_STATE)-&gt;setCallbackFunc(std::bind(&amp;DecisionMakerNode::callbackStateSTR, this, 0));
 }
 
 void DecisionMakerNode::initROS(int argc, char **argv)
@@ -69,6 +90,9 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   Pubs["state"] = nh_.advertise&lt;std_msgs::String&gt;("state", 1);
   Pubs["lane_waypoints_array"] = nh_.advertise&lt;autoware_msgs::LaneArray&gt;(TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY, 10, true);
 
+
+  Pubs["lamp_cmd"] = nh_.advertise&lt;autoware_msgs::lamp_cmd&gt;("/lamp_cmd", 1);
+  
   // for visualize
   Pubs["state_overlay"] = nh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;("/state/overlay_text", 1);
   Pubs["crossroad_marker"] = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("/state/cross_road_marker", 1);
@@ -92,6 +116,10 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   // initial publishing state message
   update_msgs();
 
+
+  // setup a callback for state update();
+  setupStateCallback();
+
   // to move initial state from start state
   // this part confirm broadcasting tf(map to world)
   {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="76a359ed7c4dfc1d6858f331efb6226f2bee9907" author="Yusuke FUJII">
		<msg>:put_litter_in_its_place:</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" added_lines="0" deleted_lines="1">
				<diff>@@ -75,7 +75,6 @@ protected:
 
 public:
   virtual void update(void){
-	std::cout &lt;&lt; "update:"&lt;&lt; StateNum &lt;&lt; std::endl;
 	if(StateCallbackFunc)
 		StateCallbackFunc();
   }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" added_lines="1" deleted_lines="9">
				<diff>@@ -37,7 +37,6 @@ private:
   std::unordered_map&lt;uint64_t, BaseState *&gt; StateStores;
 
   bool enableForceSetState;
-  // unsigned long long ChangeStateFlags;
   std::queue&lt;unsigned long long&gt; ChangeStateFlags;
   std::atomic&lt;bool&gt; thread_loop;
 
@@ -86,18 +85,11 @@ public:
     {
       *p = nullptr;
     }
-#if 0
-    current_state_.MainState = nullptr;
-    current_state_.AccState = nullptr;
-    current_state_.StrState = nullptr;
-    current_state_.BehaviorState = nullptr;
-    current_state_.PerceptionState = nullptr;
-    current_state_.OtherState = nullptr;
-#endif
     thread_loop = true;
 
     this-&gt;InitContext();
   }
+
   ~StateContext()
   {
     thread_loop = false;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3f8adcee1eca76d8007be4766904e9c80ab96f12" author="yukikitsukawa">
		<msg>support all plane(1-19) in geo_pos_conv</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\gnss\src\geo_pos_conv.cpp" new_path="ros\src\computing\perception\localization\lib\gnss\src\geo_pos_conv.cpp" added_lines="261" deleted_lines="124">
				<diff>@@ -32,166 +32,303 @@
 
 double geo_pos_conv::x() const
 {
-	return m_x;
+  return m_x;
 }
 
 double geo_pos_conv::y() const
 {
-	return m_y;
+  return m_y;
 }
 
 double geo_pos_conv::z() const
 {
-	return m_z;
+  return m_z;
 }
 
-void geo_pos_conv::set_plane(double lat,   double lon)
+void geo_pos_conv::set_plane(double lat, double lon)
 {
-	m_PLato = lat;
-	m_PLo = lon;
+  m_PLato = lat;
+  m_PLo = lon;
 }
 
 void geo_pos_conv::set_plane(int num)
 {
-        if(num==6){
-		m_PLo = 2.373647782712;   //
-		m_PLato= 0.628318530717;  //
-        }else if(num==7) {
-		m_PLo = 2.39400995732;   //
-		m_PLato=  0.628318530717;  //
-	} else if(num==9){
-		m_PLo =  2.4405520707;    //
-		m_PLato =  0.628318530717;  //
-	}
+  int lon_deg, lon_min, lat_deg, lat_min; // longitude and latitude of origin of each plane in Japan
+  if (num == 1)
+  {
+    lon_deg = 33;
+    lon_min = 0;
+    lat_deg = 129;
+    lat_min = 30;
+  }
+  else if (num == 2)
+  {
+    lon_deg = 33;
+    lon_min = 0;
+    lat_deg = 131;
+    lat_min = 0;
+  }
+  else if (num == 3)
+  {
+    lon_deg = 36;
+    lon_min = 0;
+    lat_deg = 132;
+    lat_min = 10;
+  }
+  else if (num == 4)
+  {
+    lon_deg = 33;
+    lon_min = 0;
+    lat_deg = 133;
+    lat_min = 30;
+  }
+  else if (num == 5)
+  {
+    lon_deg = 36;
+    lon_min = 0;
+    lat_deg = 134;
+    lat_min = 20;
+  }
+  else if (num == 6)
+  {
+    lon_deg = 36;
+    lon_min = 0;
+    lat_deg = 136;
+    lat_min = 0;
+  }
+  else if (num == 7)
+  {
+    lon_deg = 36;
+    lon_min = 0;
+    lat_deg = 137;
+    lat_min = 10;
+  }
+  else if (num == 8)
+  {
+    lon_deg = 36;
+    lon_min = 0;
+    lat_deg = 138;
+    lat_min = 30;
+  }
+  else if (num == 9)
+  {
+    lon_deg = 36;
+    lon_min = 0;
+    lat_deg = 139;
+    lat_min = 50;
+  }
+  else if (num == 10)
+  {
+    lon_deg = 40;
+    lon_min = 0;
+    lat_deg = 140;
+    lat_min = 50;
+  }
+  else if (num == 11)
+  {
+    lon_deg = 44;
+    lon_min = 0;
+    lat_deg = 140;
+    lat_min = 15;
+  }
+  else if (num == 12)
+  {
+    lon_deg = 44;
+    lon_min = 0;
+    lat_deg = 142;
+    lat_min = 15;
+  }
+  else if (num == 13)
+  {
+    lon_deg = 44;
+    lon_min = 0;
+    lat_deg = 144;
+    lat_min = 15;
+  }
+  else if (num == 14)
+  {
+    lon_deg = 26;
+    lon_min = 0;
+    lat_deg = 142;
+    lat_min = 0;
+  }
+  else if (num == 15)
+  {
+    lon_deg = 26;
+    lon_min = 0;
+    lat_deg = 127;
+    lat_min = 30;
+  }
+  else if (num == 16)
+  {
+    lon_deg = 26;
+    lon_min = 0;
+    lat_deg = 124;
+    lat_min = 0;
+  }
+  else if (num == 17)
+  {
+    lon_deg = 26;
+    lon_min = 0;
+    lat_deg = 131;
+    lat_min = 0;
+  }
+  else if (num == 18)
+  {
+    lon_deg = 20;
+    lon_min = 0;
+    lat_deg = 136;
+    lat_min = 0;
+  }
+  else if (num == 19)
+  {
+    lon_deg = 26;
+    lon_min = 0;
+    lat_deg = 154;
+    lat_min = 0;
+  }
+
+  // swap longitude and latitude
+  m_PLo = M_PI * ((double)lat_deg + (double)lat_min / 60.0) / 180.0;
+  m_PLato = M_PI * ((double)lon_deg + (double)lon_min / 60.0) / 180;
 }
 
 void geo_pos_conv::set_xyz(double cx, double cy, double cz)
 {
-	m_x = cx;
-	m_y = cy;
-	m_z = cz;
-	conv_xyz2llh();
+  m_x = cx;
+  m_y = cy;
+  m_z = cz;
+  conv_xyz2llh();
 }
 
-void geo_pos_conv::set_llh_nmea_degrees(double latd,double lond, double h)
+void geo_pos_conv::set_llh_nmea_degrees(double latd, double lond, double h)
 {
-	double lat, lad, lod, lon;
-	//1234.56 -&gt; 12'34.56 -&gt; 12+ 34.56/60
+  double lat, lad, lod, lon;
+  // 1234.56 -&gt; 12'34.56 -&gt; 12+ 34.56/60
 
-	lad = floor(latd/100.);
-	lat = latd-lad*100.;
-	lod = floor(lond/100.);
-	lon = lond-lod*100.;
+  lad = floor(latd / 100.);
+  lat = latd - lad * 100.;
+  lod = floor(lond / 100.);
+  lon = lond - lod * 100.;
 
-	//Changing Longitude and Latitude to Radians
-	m_lat= (lad+lat/60.0) *M_PI/180;
-	m_lon= (lod+lon/60.0) *M_PI/180;
-	m_h  =  h;
+  // Changing Longitude and Latitude to Radians
+  m_lat = (lad + lat / 60.0) * M_PI / 180;
+  m_lon = (lod + lon / 60.0) * M_PI / 180;
+  m_h = h;
 
-	conv_llh2xyz();
+  conv_llh2xyz();
 }
 
 void geo_pos_conv::llh_to_xyz(double lat, double lon, double ele)
 {
-	m_lat = lat * M_PI/180;
-	m_lon = lon * M_PI/180;
-	m_h = ele;
+  m_lat = lat * M_PI / 180;
+  m_lon = lon * M_PI / 180;
+  m_h = ele;
 
-	conv_llh2xyz();
+  conv_llh2xyz();
 }
 
 void geo_pos_conv::conv_llh2xyz(void)
 {
-	double PS;           //
-	double PSo;          //
-	double PDL;          //
-	double Pt;           //
-	double PN;           //
-	double PW;           // 
-    
-	double PB1, PB2, PB3, PB4, PB5, PB6, PB7, PB8, PB9;
-	double PA, PB, PC, PD, PE, PF, PG, PH, PI;
-	double Pe;           //
-	double Pet;          //
-	double Pnn;          //  
-	double AW,FW,Pmo;
-
-	Pmo = 0.9999;
-
-	/*WGS84 Parameters*/
-	AW = 6378137.0; //Semimajor Axis
-	FW = 1.0/298.257222101; //298.257223563 //Geometrical flattening
-    
-	Pe  = (double) sqrt(2.0*FW - pow(FW,2));
-	Pet = (double) sqrt( pow(Pe,2) / (1.0 - pow(Pe,2)) );
-    
-	PA = (double) 1.0 + 3.0/4.0*pow(Pe,2) + 45.0/64.0* pow(Pe,4) + 175.0/256.0*pow(Pe,6) 
-		+ 11025.0/16384.0*pow(Pe,8) + 43659.0/65536.0*pow(Pe,10) + 693693.0/1048576.0*pow(Pe,12)
-		+ 19324305.0/29360128.0*pow(Pe,14) + 4927697775.0/7516192768.0*pow(Pe,16);
-    
-	PB = (double) 3.0/4.0*pow(Pe,2) + 15.0/16.0*pow(Pe,4) + 525.0/512.0*pow(Pe,6) + 2205.0/2048.0*pow(Pe,8)
-		+ 72765.0/65536.0*pow(Pe,10) + 297297.0/262144.0*pow(Pe,12) + 135270135.0/117440512.0*pow(Pe,14) 
-		+ 547521975.0/469762048.0*pow(Pe,16);
-    
-	PC = (double) 15.0/64.0*pow(Pe,4) + 105.0/256.0*pow(Pe,6) + 2205.0/4096.0*pow(Pe,8) + 10395.0/16384.0*pow(Pe,10)
-		+ 1486485.0/2097152.0*pow(Pe,12) + 45090045.0/58720256.0*pow(Pe,14)+ 766530765.0/939524096.0*pow(Pe,16);
-    
-	PD = (double) 35.0/512.0*pow(Pe,6) + 315.0/2048.0*pow(Pe,8) + 31185.0/131072.0*pow(Pe,10)
-		+ 165165.0/524288.0*pow(Pe,12) + 45090045.0/117440512.0*pow(Pe,14) + 209053845.0/469762048.0*pow(Pe,16);
-    
-	PE = (double) 315.0/16384.0*pow(Pe,8) + 3465.0/65536.0*pow(Pe,10) + 99099.0/1048576.0*pow(Pe,12) + 
-		4099095.0/29360128.0*pow(Pe,14) + 348423075.0/1879048192.0*pow(Pe,16);
-    
-	PF = (double) 693.0/131072.0*pow(Pe,10) + 9009.0/524288.0*pow(Pe,12) +  4099095.0/117440512.0*pow(Pe,14)
-		+ 26801775.0/469762048.0*pow(Pe,16);
-    
-	PG = (double) 3003.0/2097152.0*pow(Pe,12) + 315315.0/58720256.0*pow(Pe,14) + 11486475.0/939524096.0*pow(Pe,16);
-    
-	PH = (double) 45045.0/117440512.0*pow(Pe,14) + 765765.0/469762048.0*pow(Pe,16);
-    
-	PI = (double) 765765.0/7516192768.0*pow(Pe,16);
-    
-    
-	PB1 = (double) AW * (1.0 - pow(Pe,2)) * PA;
-	PB2 = (double) AW * (1.0 - pow(Pe,2)) * PB/-2.0;
-	PB3 = (double) AW * (1.0 - pow(Pe,2)) * PC/4.0;
-	PB4 = (double) AW * (1.0 - pow(Pe,2)) * PD/-6.0;
-	PB5 = (double) AW * (1.0 - pow(Pe,2)) * PE/8.0;
-	PB6 = (double) AW * (1.0 - pow(Pe,2)) * PF/-10.0;
-	PB7 = (double) AW * (1.0 - pow(Pe,2)) * PG/12.0;
-	PB8 = (double) AW * (1.0 - pow(Pe,2)) * PH/-14.0;
-	PB9 = (double) AW * (1.0 - pow(Pe,2)) * PI/16.0;
-    
-    
-	PS = (double) PB1*m_lat + PB2*sin(2.0*m_lat) + PB3*sin(4.0*m_lat) + PB4*sin(6.0*m_lat) 
-		+ PB5*sin(8.0*m_lat) + PB6*sin(10.0*m_lat) + PB7*sin(12.0*m_lat) + PB8*sin(14.0*m_lat)
-		+ PB9*sin(16.0*m_lat);
-    
-	PSo = (double) PB1*m_PLato + PB2*sin(2.0*m_PLato) + PB3*sin(4.0*m_PLato) + PB4*sin(6.0*m_PLato) 
-		+ PB5*sin(8.0*m_PLato) + PB6*sin(10.0*m_PLato) + PB7*sin(12.0*m_PLato) + PB8*sin(14.0*m_PLato)
-		+ PB9*sin(16.0*m_PLato);
-    
-	PDL = (double) m_lon - m_PLo;
-	Pt  = (double) tan(m_lat);
-	PW  = (double) sqrt(1.0 - pow(Pe,2)*pow(sin(m_lat),2));
-	PN  = (double) AW / PW;
-	Pnn = (double) sqrt( pow(Pet,2) * pow(cos(m_lat),2));
-    
-	m_x = (double) ( (PS - PSo) + (1.0/2.0)*PN*pow(cos(m_lat),2.0)*Pt*pow(PDL,2.0) 
-			 + (1.0/24.0) * PN * pow(cos(m_lat),4) * Pt * (5.0-pow(Pt,2) + 9.0*pow(Pnn,2) + 4.0*pow(Pnn,4))*pow(PDL,4)
-			 - (1.0/720.0) * PN * pow(cos(m_lat),6) * Pt * 
-			 (-61.0 + 58.0*pow(Pt,2) - pow(Pt,4) - 270.0*pow(Pnn,2) + 330.0*pow(Pt,2)*pow(Pnn,2))*pow(PDL,6)
-			 - (1.0/40320.0) * PN * pow(cos(m_lat),8) * Pt * 
-			 (-1385.0 + 3111*pow(Pt,2) - 543*pow(Pt,4) + pow(Pt,6)) * pow(PDL,8) ) * Pmo ; 
-    
-	m_y = (double) ( PN*cos(m_lat)*PDL - 1.0/6.0* PN * pow(cos(m_lat),3) * (-1 + pow(Pt,2) - pow(Pnn,2))*pow(PDL,3)
-			 -1.0/120.0*PN*pow(cos(m_lat),5) * (-5.0+18.0*pow(Pt,2)-pow(Pt,4)-14.0*pow(Pnn,2)+58.0*pow(Pt,2)*pow(Pnn,2))*pow(PDL,5)
-			 -1.0/5040.0*PN*pow(cos(m_lat),7)* (-61.0+479.0*pow(Pt,2)-179.0*pow(Pt,4)+pow(Pt,6))*pow(PDL,7) ) * Pmo;
-    
-	m_z = m_h;
+  double PS;   //
+  double PSo;  //
+  double PDL;  //
+  double Pt;   //
+  double PN;   //
+  double PW;   //
+
+  double PB1, PB2, PB3, PB4, PB5, PB6, PB7, PB8, PB9;
+  double PA, PB, PC, PD, PE, PF, PG, PH, PI;
+  double Pe;   //
+  double Pet;  //
+  double Pnn;  //
+  double AW, FW, Pmo;
+
+  Pmo = 0.9999;
+
+  /*WGS84 Parameters*/
+  AW = 6378137.0;            // Semimajor Axis
+  FW = 1.0 / 298.257222101;  // 298.257223563 //Geometrical flattening
+
+  Pe = (double)sqrt(2.0 * FW - pow(FW, 2));
+  Pet = (double)sqrt(pow(Pe, 2) / (1.0 - pow(Pe, 2)));
+
+  PA = (double)1.0 + 3.0 / 4.0 * pow(Pe, 2) + 45.0 / 64.0 * pow(Pe, 4) + 175.0 / 256.0 * pow(Pe, 6) +
+       11025.0 / 16384.0 * pow(Pe, 8) + 43659.0 / 65536.0 * pow(Pe, 10) + 693693.0 / 1048576.0 * pow(Pe, 12) +
+       19324305.0 / 29360128.0 * pow(Pe, 14) + 4927697775.0 / 7516192768.0 * pow(Pe, 16);
+
+  PB = (double)3.0 / 4.0 * pow(Pe, 2) + 15.0 / 16.0 * pow(Pe, 4) + 525.0 / 512.0 * pow(Pe, 6) +
+       2205.0 / 2048.0 * pow(Pe, 8) + 72765.0 / 65536.0 * pow(Pe, 10) + 297297.0 / 262144.0 * pow(Pe, 12) +
+       135270135.0 / 117440512.0 * pow(Pe, 14) + 547521975.0 / 469762048.0 * pow(Pe, 16);
+
+  PC = (double)15.0 / 64.0 * pow(Pe, 4) + 105.0 / 256.0 * pow(Pe, 6) + 2205.0 / 4096.0 * pow(Pe, 8) +
+       10395.0 / 16384.0 * pow(Pe, 10) + 1486485.0 / 2097152.0 * pow(Pe, 12) + 45090045.0 / 58720256.0 * pow(Pe, 14) +
+       766530765.0 / 939524096.0 * pow(Pe, 16);
+
+  PD = (double)35.0 / 512.0 * pow(Pe, 6) + 315.0 / 2048.0 * pow(Pe, 8) + 31185.0 / 131072.0 * pow(Pe, 10) +
+       165165.0 / 524288.0 * pow(Pe, 12) + 45090045.0 / 117440512.0 * pow(Pe, 14) +
+       209053845.0 / 469762048.0 * pow(Pe, 16);
+
+  PE = (double)315.0 / 16384.0 * pow(Pe, 8) + 3465.0 / 65536.0 * pow(Pe, 10) + 99099.0 / 1048576.0 * pow(Pe, 12) +
+       4099095.0 / 29360128.0 * pow(Pe, 14) + 348423075.0 / 1879048192.0 * pow(Pe, 16);
+
+  PF = (double)693.0 / 131072.0 * pow(Pe, 10) + 9009.0 / 524288.0 * pow(Pe, 12) +
+       4099095.0 / 117440512.0 * pow(Pe, 14) + 26801775.0 / 469762048.0 * pow(Pe, 16);
+
+  PG = (double)3003.0 / 2097152.0 * pow(Pe, 12) + 315315.0 / 58720256.0 * pow(Pe, 14) +
+       11486475.0 / 939524096.0 * pow(Pe, 16);
+
+  PH = (double)45045.0 / 117440512.0 * pow(Pe, 14) + 765765.0 / 469762048.0 * pow(Pe, 16);
+
+  PI = (double)765765.0 / 7516192768.0 * pow(Pe, 16);
+
+  PB1 = (double)AW * (1.0 - pow(Pe, 2)) * PA;
+  PB2 = (double)AW * (1.0 - pow(Pe, 2)) * PB / -2.0;
+  PB3 = (double)AW * (1.0 - pow(Pe, 2)) * PC / 4.0;
+  PB4 = (double)AW * (1.0 - pow(Pe, 2)) * PD / -6.0;
+  PB5 = (double)AW * (1.0 - pow(Pe, 2)) * PE / 8.0;
+  PB6 = (double)AW * (1.0 - pow(Pe, 2)) * PF / -10.0;
+  PB7 = (double)AW * (1.0 - pow(Pe, 2)) * PG / 12.0;
+  PB8 = (double)AW * (1.0 - pow(Pe, 2)) * PH / -14.0;
+  PB9 = (double)AW * (1.0 - pow(Pe, 2)) * PI / 16.0;
+
+  PS = (double)PB1 * m_lat + PB2 * sin(2.0 * m_lat) + PB3 * sin(4.0 * m_lat) + PB4 * sin(6.0 * m_lat) +
+       PB5 * sin(8.0 * m_lat) + PB6 * sin(10.0 * m_lat) + PB7 * sin(12.0 * m_lat) + PB8 * sin(14.0 * m_lat) +
+       PB9 * sin(16.0 * m_lat);
+
+  PSo = (double)PB1 * m_PLato + PB2 * sin(2.0 * m_PLato) + PB3 * sin(4.0 * m_PLato) + PB4 * sin(6.0 * m_PLato) +
+        PB5 * sin(8.0 * m_PLato) + PB6 * sin(10.0 * m_PLato) + PB7 * sin(12.0 * m_PLato) + PB8 * sin(14.0 * m_PLato) +
+        PB9 * sin(16.0 * m_PLato);
+
+  PDL = (double)m_lon - m_PLo;
+  Pt = (double)tan(m_lat);
+  PW = (double)sqrt(1.0 - pow(Pe, 2) * pow(sin(m_lat), 2));
+  PN = (double)AW / PW;
+  Pnn = (double)sqrt(pow(Pet, 2) * pow(cos(m_lat), 2));
+
+  m_x = (double)((PS - PSo) + (1.0 / 2.0) * PN * pow(cos(m_lat), 2.0) * Pt * pow(PDL, 2.0) +
+                 (1.0 / 24.0) * PN * pow(cos(m_lat), 4) * Pt *
+                     (5.0 - pow(Pt, 2) + 9.0 * pow(Pnn, 2) + 4.0 * pow(Pnn, 4)) * pow(PDL, 4) -
+                 (1.0 / 720.0) * PN * pow(cos(m_lat), 6) * Pt *
+                     (-61.0 + 58.0 * pow(Pt, 2) - pow(Pt, 4) - 270.0 * pow(Pnn, 2) + 330.0 * pow(Pt, 2) * pow(Pnn, 2)) *
+                     pow(PDL, 6) -
+                 (1.0 / 40320.0) * PN * pow(cos(m_lat), 8) * Pt *
+                     (-1385.0 + 3111 * pow(Pt, 2) - 543 * pow(Pt, 4) + pow(Pt, 6)) * pow(PDL, 8)) *
+        Pmo;
+
+  m_y = (double)(PN * cos(m_lat) * PDL -
+                 1.0 / 6.0 * PN * pow(cos(m_lat), 3) * (-1 + pow(Pt, 2) - pow(Pnn, 2)) * pow(PDL, 3) -
+                 1.0 / 120.0 * PN * pow(cos(m_lat), 5) *
+                     (-5.0 + 18.0 * pow(Pt, 2) - pow(Pt, 4) - 14.0 * pow(Pnn, 2) + 58.0 * pow(Pt, 2) * pow(Pnn, 2)) *
+                     pow(PDL, 5) -
+                 1.0 / 5040.0 * PN * pow(cos(m_lat), 7) *
+                     (-61.0 + 479.0 * pow(Pt, 2) - 179.0 * pow(Pt, 4) + pow(Pt, 6)) * pow(PDL, 7)) *
+        Pmo;
+
+  m_z = m_h;
 }
 
 void geo_pos_conv::conv_xyz2llh(void)
 {
-	// n/a
+  // n/a
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e11218575c498c7534bbbd2bb8510ea27e2dc80c" author="yukikitsukawa">
		<msg>add fix2tfpose.launch</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\fix2tfpose\fix2tfpose.cpp" new_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\fix2tfpose\fix2tfpose.cpp" added_lines="64" deleted_lines="65">
				<diff>@@ -28,11 +28,11 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-#include &lt;ros/ros.h&gt;
 #include &lt;geometry_msgs/PointStamped.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
-#include &lt;sensor_msgs/NavSatFix.h&gt;
 #include &lt;geometry_msgs/Twist.h&gt;
+#include &lt;ros/ros.h&gt;
+#include &lt;sensor_msgs/NavSatFix.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
 #include &lt;tf/transform_broadcaster.h&gt;
 
@@ -49,73 +49,72 @@ static geometry_msgs::PoseStamped _prev_pose;
 static geometry_msgs::Quaternion _quat;
 static double yaw;
 
+static int _plane;
+
 static void GNSSCallback(const sensor_msgs::NavSatFixConstPtr &amp;msg)
 {
-    geo_pos_conv geo;
-
-    geo.set_plane(7);
-    geo.llh_to_xyz(msg-&gt;latitude, msg-&gt;longitude, msg-&gt;altitude);
-
-    static tf::TransformBroadcaster pose_broadcaster;
-    tf::Transform pose_transform;
-    tf::Quaternion pose_q;
-
-    geometry_msgs::PoseStamped pose;
-    pose.header = msg-&gt;header;
-   // pose.header.stamp = ros::Time::now();
-    pose.header.frame_id = "map";
-    pose.pose.position.x = geo.y();
-    pose.pose.position.y = geo.x();
-    pose.pose.position.z = geo.z();
-
-    // set gnss_stat
-    if(pose.pose.position.x == 0.0 || pose.pose.position.y == 0.0 || pose.pose.position.z == 0.0){
-      gnss_stat_msg.data = false;
-    } else{
-      gnss_stat_msg.data = true;
-    }
-    
-    double distance = sqrt(
-            pow(pose.pose.position.y - _prev_pose.pose.position.y, 2)
-                    + pow(pose.pose.position.x - _prev_pose.pose.position.x,
-                            2));
-    std::cout &lt;&lt; "distance : " &lt;&lt; distance &lt;&lt; std::endl;
-
-    if (distance &gt; 0.2) {
-        yaw = atan2(pose.pose.position.y - _prev_pose.pose.position.y,
-                pose.pose.position.x - _prev_pose.pose.position.x);
-        _quat = tf::createQuaternionMsgFromYaw(yaw);
-        _prev_pose = pose;
-    }
-
-    pose.pose.orientation = _quat;
-    pose_publisher.publish(pose);
-    stat_publisher.publish(gnss_stat_msg);
-
-    //
-    static tf::TransformBroadcaster br;
-    tf::Transform transform;
-    tf::Quaternion q;
-    transform.setOrigin(
-            tf::Vector3(pose.pose.position.x, pose.pose.position.y,
-                    pose.pose.position.z));
-    q.setRPY(0, 0, yaw);
-    transform.setRotation(q);
-    br.sendTransform(
-            tf::StampedTransform(transform, msg-&gt;header.stamp, "map",
-                    "gps"));
+  geo_pos_conv geo;
+
+  geo.set_plane(_plane);
+  geo.llh_to_xyz(msg-&gt;latitude, msg-&gt;longitude, msg-&gt;altitude);
+
+  static tf::TransformBroadcaster pose_broadcaster;
+  tf::Transform pose_transform;
+  tf::Quaternion pose_q;
+
+  geometry_msgs::PoseStamped pose;
+  pose.header = msg-&gt;header;
+  // pose.header.stamp = ros::Time::now();
+  pose.header.frame_id = "map";
+  pose.pose.position.x = geo.y();
+  pose.pose.position.y = geo.x();
+  pose.pose.position.z = geo.z();
+
+  // set gnss_stat
+  if (pose.pose.position.x == 0.0 || pose.pose.position.y == 0.0 || pose.pose.position.z == 0.0)
+  {
+    gnss_stat_msg.data = false;
+  }
+  else
+  {
+    gnss_stat_msg.data = true;
+  }
+
+  double distance = sqrt(pow(pose.pose.position.y - _prev_pose.pose.position.y, 2) +
+                         pow(pose.pose.position.x - _prev_pose.pose.position.x, 2));
+  std::cout &lt;&lt; "distance : " &lt;&lt; distance &lt;&lt; std::endl;
+
+  if (distance &gt; 0.2)
+  {
+    yaw = atan2(pose.pose.position.y - _prev_pose.pose.position.y, pose.pose.position.x - _prev_pose.pose.position.x);
+    _quat = tf::createQuaternionMsgFromYaw(yaw);
+    _prev_pose = pose;
+  }
+
+  pose.pose.orientation = _quat;
+  pose_publisher.publish(pose);
+  stat_publisher.publish(gnss_stat_msg);
+
+  //
+  static tf::TransformBroadcaster br;
+  tf::Transform transform;
+  tf::Quaternion q;
+  transform.setOrigin(tf::Vector3(pose.pose.position.x, pose.pose.position.y, pose.pose.position.z));
+  q.setRPY(0, 0, yaw);
+  transform.setRotation(q);
+  br.sendTransform(tf::StampedTransform(transform, msg-&gt;header.stamp, "map", "gps"));
 }
 
 int main(int argc, char **argv)
 {
-    ros::init(argc, argv, "gnss_pos");
-    ros::NodeHandle nh;
-    pose_publisher = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("gnss_pose",
-            1000);
-    stat_publisher = nh.advertise&lt;std_msgs::Bool&gt;("/gnss_stat", 1000);
-    ros::Subscriber gnss_pose_subscriber = nh.subscribe("fix", 100,
-            GNSSCallback);
-
-    ros::spin();
-    return 0;
+  ros::init(argc, argv, "fix2tfpose");
+  ros::NodeHandle nh;
+  ros::NodeHandle private_nh("~");
+  private_nh.getParam("plane", _plane);
+  pose_publisher = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("gnss_pose", 1000);
+  stat_publisher = nh.advertise&lt;std_msgs::Bool&gt;("/gnss_stat", 1000);
+  ros::Subscriber gnss_pose_subscriber = nh.subscribe("fix", 100, GNSSCallback);
+
+  ros::spin();
+  return 0;
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c40a4432847db27ddae955a4c9f9a815597fff7a" author="Yusuke FUJII">
		<msg>Support to lanechange similar to state_machine(old) package</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" added_lines="2" deleted_lines="0">
				<diff>@@ -115,6 +115,8 @@ public:
   void showCurrentStateName(void);
   std::string createStateMessageText(void);
 
+  std::string getCurrentStateName(StateKinds en);
+
   bool setEnableForceSetState(bool force_flag);
   BaseState *getStateObject(unsigned long long _state_num);
   void InitContext(void);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="15" deleted_lines="6">
				<diff>@@ -36,8 +36,7 @@ void StateContext::update(void)
 
 void StateContext::showCurrentStateName(void)
 {
-  for (auto &amp;&amp;p : HolderList)
-  {
+  for (auto &amp;&amp;p : HolderList) {
     if (*p)
     {
       (*p)-&gt;showStateName();
@@ -53,10 +52,6 @@ void StateContext::showCurrentStateName(void)
   std::cout &lt;&lt; std::endl;
 }
 
-std::string StateContext::getCurrentStateName(void)
-{
-  return current_state_.MainState-&gt;getStateName();
-}
 
 /**
  * @fn
@@ -138,6 +133,20 @@ bool StateContext::setEnableForceSetState(bool force_flag)
   return true;
 }
 
+std::string StateContext::getCurrentStateName(StateKinds en)
+{
+  for (auto &amp;&amp;p : HolderList)
+  {
+    if (*p &amp;&amp; (*p)-&gt;getStateKind() == en)
+	      return (*p)-&gt;getStateName();
+  }
+  return std::string("");
+}
+std::string StateContext::getCurrentStateName(void)
+{
+	return this-&gt;getCurrentStateName(MAIN_STATE);
+}
+
 BaseState *StateContext::getCurrentMainState(void)
 {
   return current_state_.MainState;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="1" deleted_lines="1">
				<diff>@@ -52,8 +52,8 @@ enum class EControl : int32_t
 enum class E_ChangeFlags : int32_t
 {
   STRAIGHT,
-  LEFT,
   RIGHT,
+  LEFT,
 
   UNKNOWN = -1,
 };
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="2" deleted_lines="1">
				<diff>@@ -17,6 +17,7 @@
 
 #include &lt;autoware_msgs/lane.h&gt;
 #include &lt;autoware_msgs/lamp_cmd.h&gt;
+#include &lt;autoware_msgs/state.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;random&gt;
@@ -89,6 +90,7 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   // pub
   Pubs["state"] = nh_.advertise&lt;std_msgs::String&gt;("state", 1);
   Pubs["lane_waypoints_array"] = nh_.advertise&lt;autoware_msgs::LaneArray&gt;(TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY, 10, true);
+  Pubs["states"] = nh_.advertise&lt;autoware_msgs::state&gt;("/decisionmaker/states", 1, true);
 
 
   Pubs["lamp_cmd"] = nh_.advertise&lt;autoware_msgs::lamp_cmd&gt;("/lamp_cmd", 1);
@@ -116,7 +118,6 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   // initial publishing state message
   update_msgs();
 
-
   // setup a callback for state update();
   setupStateCallback();
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="8" deleted_lines="0">
				<diff>@@ -13,6 +13,7 @@
 #include &lt;decision_maker_node.hpp&gt;
 
 #include &lt;autoware_msgs/lane.h&gt;
+#include &lt;autoware_msgs/state.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;random&gt;
@@ -115,6 +116,13 @@ void DecisionMakerNode::update_msgs(void)
     state_string_msg.data = CurrentStateName;
     state_text_msg.text = createStateMessageText();
 
+    autoware_msgs::state state_msg;
+    state_msg.main_state = ctx-&gt;getCurrentStateName(state_machine::StateKinds::MAIN_STATE);
+    state_msg.acc_state = ctx-&gt;getCurrentStateName(state_machine::StateKinds::ACC_STATE);
+    state_msg.str_state = ctx-&gt;getCurrentStateName(state_machine::StateKinds::STR_STATE);
+    state_msg.behavior_state = ctx-&gt;getCurrentStateName(state_machine::StateKinds::BEHAVIOR_STATE);
+    
+    Pubs["states"].publish(state_msg);
     Pubs["state"].publish(state_string_msg);
     Pubs["state_overlay"].publish(state_text_msg);
   }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="19" deleted_lines="0">
				<diff>@@ -67,6 +67,7 @@ void LaneSelectNode::initForROS()
   sub3_ = nh_.subscribe("current_velocity", 1, &amp;LaneSelectNode::callbackFromTwistStamped, this);
   sub4_ = nh_.subscribe("state", 1, &amp;LaneSelectNode::callbackFromState, this);
   sub5_ = nh_.subscribe("/config/lane_select", 1, &amp;LaneSelectNode::callbackFromConfig, this);
+  sub6_ = nh_.subscribe("/decisionmaker/states", 1, &amp;LaneSelectNode::callbackFromStates, this);
 
   
   bool enablePlannerDynamicSwitch;
@@ -667,6 +668,24 @@ void LaneSelectNode::callbackFromState(const std_msgs::StringConstPtr &amp;msg)
   else
     processing();
 }
+void LaneSelectNode::callbackFromStates(const autoware_msgs::stateConstPtr &amp;msg)
+{
+  is_current_state_subscribed_ = true;
+  
+  if(msg-&gt;behavior_state == "LaneChangeRight" || 
+		  msg-&gt;behavior_state == "LaneChangeLeft") 
+  {
+	  current_state_ = std::string("LANE_CHANGE");;
+  }else{
+	  current_state_ = msg-&gt;main_state;
+  }
+
+  if(current_lane_idx_ == -1)
+    initForLaneSelect();
+  else
+    processing();
+}
+
 
 void LaneSelectNode::callbackFromConfig(const autoware_msgs::ConfigLaneSelectConstPtr &amp;msg)
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="3" deleted_lines="1">
				<diff>@@ -46,6 +46,7 @@
 
 // User defined includes
 #include "autoware_msgs/LaneArray.h"
+#include "autoware_msgs/state.h"
 #include "waypoint_follower/libwaypoint_follower.h"
 #include "autoware_msgs/ConfigLaneSelect.h"
 #include "hermite_curve.h"
@@ -85,7 +86,7 @@ private:
   ros::Publisher vis_pub1_;
 
   // subscriber
-  ros::Subscriber sub1_, sub2_, sub3_, sub4_, sub5_;
+  ros::Subscriber sub1_, sub2_, sub3_, sub4_, sub5_, sub6_;
 
   // variables
   int32_t current_lane_idx_;  // the index of the lane we are driving
@@ -109,6 +110,7 @@ private:
   void callbackFromPoseStamped(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void callbackFromTwistStamped(const geometry_msgs::TwistStampedConstPtr &amp;msg);
   void callbackFromState(const std_msgs::StringConstPtr &amp;msg);
+  void callbackFromStates(const autoware_msgs::stateConstPtr &amp;msg);
   void callbackFromConfig(const autoware_msgs::ConfigLaneSelectConstPtr &amp;msg);
 
   // initializer
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="07940994760c4343ac1f36c2d1db0002c4db031b" author="hatem-darweesh">
		<msg>- Add user interface option in runtime manage for local_planner and op_trajectory_generator</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_trajectory_generator_core.h" new_path="ros\src\computing\planning\motion\packages\op_local_planner\include\op_trajectory_generator_core.h" added_lines="1" deleted_lines="1">
				<diff>@@ -103,7 +103,7 @@ protected: // Callback function for subscriber.
 	void callbackGetGlobalPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp; msg);
 
 protected: //Helper Functions
-  void UpdatePlanningParams();
+  void UpdatePlanningParams(ros::NodeHandle&amp; _nh);
 
 public:
 	TrajectoryGen();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_local_planner\src\op_trajectory_generator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_local_planner\nodes\op_trajectory_generator\op_trajectory_generator_core.cpp" added_lines="32" deleted_lines="31">
				<diff>@@ -40,7 +40,8 @@ TrajectoryGen::TrajectoryGen()
 	bVehicleStatus = false;
 	bWayGlobalPath = false;
 
-	UpdatePlanningParams();
+	ros::NodeHandle _nh;
+	UpdatePlanningParams(_nh);
 
 	tf::StampedTransform transform;
 	PlannerHNS::RosHelpers::GetTransformFromTF("map", "world", transform);
@@ -56,7 +57,7 @@ TrajectoryGen::TrajectoryGen()
 	sub_current_pose 	= nh.subscribe("/current_pose", 			1,		&amp;TrajectoryGen::callbackGetCurrentPose, 		this);
 
 	int bVelSource = 1;
-	nh.getParam("/velocitySource", bVelSource);
+	_nh.getParam("/op_trajectory_generator/velocitySource", bVelSource);
 	if(bVelSource == 0)
 		sub_robot_odom 			= nh.subscribe("/odom", 					100,	&amp;TrajectoryGen::callbackGetRobotOdom, 	this);
 	else if(bVelSource == 1)
@@ -72,49 +73,49 @@ TrajectoryGen::~TrajectoryGen()
 }
 
 
-void TrajectoryGen::UpdatePlanningParams()
+void TrajectoryGen::UpdatePlanningParams(ros::NodeHandle&amp; _nh)
 {
-	nh.getParam("enableSwerving", m_PlanningParams.enableSwerving);
+	_nh.getParam("/op_trajectory_generator/enableSwerving", m_PlanningParams.enableSwerving);
 	if(m_PlanningParams.enableSwerving)
 		m_PlanningParams.enableFollowing = true;
 	else
-		nh.getParam("enableFollowing", m_PlanningParams.enableFollowing);
+		_nh.getParam("/op_trajectory_generator/enableFollowing", m_PlanningParams.enableFollowing);
 
-	nh.getParam("enableHeadingSmoothing", m_PlanningParams.enableHeadingSmoothing);
-	nh.getParam("enableTrafficLightBehavior", m_PlanningParams.enableTrafficLightBehavior);
-	nh.getParam("enableStopSignBehavior", m_PlanningParams.enableStopSignBehavior);
+	_nh.getParam("/op_trajectory_generator/enableHeadingSmoothing", m_PlanningParams.enableHeadingSmoothing);
+	_nh.getParam("/op_trajectory_generator/enableTrafficLightBehavior", m_PlanningParams.enableTrafficLightBehavior);
+	_nh.getParam("/op_trajectory_generator/enableStopSignBehavior", m_PlanningParams.enableStopSignBehavior);
 
-	nh.getParam("maxVelocity", m_PlanningParams.maxSpeed);
-	nh.getParam("minVelocity", m_PlanningParams.minSpeed);
-	nh.getParam("maxLocalPlanDistance", m_PlanningParams.microPlanDistance);
-	nh.getParam("samplingTipMargin", m_PlanningParams.carTipMargin);
-	nh.getParam("samplingOutMargin", m_PlanningParams.rollInMargin);
-	nh.getParam("samplingSpeedFactor", m_PlanningParams.rollInSpeedFactor);
+	_nh.getParam("/op_trajectory_generator/maxVelocity", m_PlanningParams.maxSpeed);
+	_nh.getParam("/op_trajectory_generator/minVelocity", m_PlanningParams.minSpeed);
+	_nh.getParam("/op_trajectory_generator/maxLocalPlanDistance", m_PlanningParams.microPlanDistance);
+	_nh.getParam("/op_trajectory_generator/samplingTipMargin", m_PlanningParams.carTipMargin);
+	_nh.getParam("/op_trajectory_generator/samplingOutMargin", m_PlanningParams.rollInMargin);
+	_nh.getParam("/op_trajectory_generator/samplingSpeedFactor", m_PlanningParams.rollInSpeedFactor);
 
-	nh.getParam("pathDensity", m_PlanningParams.pathDensity);
-	nh.getParam("rollOutDensity", m_PlanningParams.rollOutDensity);
+	_nh.getParam("/op_trajectory_generator/pathDensity", m_PlanningParams.pathDensity);
+	_nh.getParam("/op_trajectory_generator/rollOutDensity", m_PlanningParams.rollOutDensity);
 	if(m_PlanningParams.enableSwerving)
-		nh.getParam("rollOutsNumber", m_PlanningParams.rollOutNumber);
+		_nh.getParam("/op_trajectory_generator/rollOutsNumber", m_PlanningParams.rollOutNumber);
 	else
 		m_PlanningParams.rollOutNumber = 0;
 
-	nh.getParam("horizonDistance", m_PlanningParams.horizonDistance);
-	nh.getParam("minFollowingDistance", m_PlanningParams.minFollowingDistance);
-	nh.getParam("minDistanceToAvoid", m_PlanningParams.minDistanceToAvoid);
-	nh.getParam("maxDistanceToAvoid", m_PlanningParams.maxDistanceToAvoid);
-	nh.getParam("speedProfileFactor", m_PlanningParams.speedProfileFactor);
+	_nh.getParam("/op_trajectory_generator/horizonDistance", m_PlanningParams.horizonDistance);
+	_nh.getParam("/op_trajectory_generator/minFollowingDistance", m_PlanningParams.minFollowingDistance);
+	_nh.getParam("/op_trajectory_generator/minDistanceToAvoid", m_PlanningParams.minDistanceToAvoid);
+	_nh.getParam("/op_trajectory_generator/maxDistanceToAvoid", m_PlanningParams.maxDistanceToAvoid);
+	_nh.getParam("/op_trajectory_generator/speedProfileFactor", m_PlanningParams.speedProfileFactor);
 
-	nh.getParam("horizontalSafetyDistance", m_PlanningParams.horizontalSafetyDistancel);
-	nh.getParam("verticalSafetyDistance", m_PlanningParams.verticalSafetyDistance);
+	_nh.getParam("/op_trajectory_generator/horizontalSafetyDistance", m_PlanningParams.horizontalSafetyDistancel);
+	_nh.getParam("/op_trajectory_generator/verticalSafetyDistance", m_PlanningParams.verticalSafetyDistance);
 
-	nh.getParam("enableLaneChange", m_PlanningParams.enableLaneChange);
-	nh.getParam("enabTrajectoryVelocities", m_PlanningParams.enabTrajectoryVelocities);
+	_nh.getParam("/op_trajectory_generator/enableLaneChange", m_PlanningParams.enableLaneChange);
+	_nh.getParam("/op_trajectory_generator/enabTrajectoryVelocities", m_PlanningParams.enabTrajectoryVelocities);
 
-	nh.getParam("width", m_CarInfo.width);
-	nh.getParam("length", m_CarInfo.length);
-	nh.getParam("wheelBaseLength", m_CarInfo.wheel_base);
-	nh.getParam("turningRadius", m_CarInfo.turning_radius);
-	nh.getParam("maxSteerAngle", m_CarInfo.max_steer_angle);
+	_nh.getParam("/op_trajectory_generator/width", m_CarInfo.width);
+	_nh.getParam("/op_trajectory_generator/length", m_CarInfo.length);
+	_nh.getParam("/op_trajectory_generator/wheelBaseLength", m_CarInfo.wheel_base);
+	_nh.getParam("/op_trajectory_generator/turningRadius", m_CarInfo.turning_radius);
+	_nh.getParam("/op_trajectory_generator/maxSteerAngle", m_CarInfo.max_steer_angle);
 	m_CarInfo.max_speed_forward = m_PlanningParams.maxSpeed;
 	m_CarInfo.min_speed_forward = m_PlanningParams.minSpeed;
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4f04916e9d095db8484135f19032dca0cbcb84be" author="Yusuke FUJII">
		<msg>apply clang-format</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,6 +1,6 @@
+#include &lt;amathutils.hpp&gt;
 #include &lt;cmath&gt;
 #include &lt;cross_road_area.hpp&gt;
-#include &lt;amathutils.hpp&gt;
 
 namespace decision_maker
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="225" deleted_lines="226">
				<diff>@@ -17,262 +17,261 @@
 
 namespace decision_maker
 {
-
 void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
 {
-	geometry_msgs::PoseStamped _pose = current_pose_ = msg;
-	bool initLocalizationFlag = ctx-&gt;isCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
-	if (initLocalizationFlag &amp;&amp;
-			isLocalizationConvergence(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
-				_pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
-	{
-		ROS_INFO("Localization was convergence");
-	}
+  geometry_msgs::PoseStamped _pose = current_pose_ = msg;
+  bool initLocalizationFlag = ctx-&gt;isCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
+  if (initLocalizationFlag &amp;&amp;
+      isLocalizationConvergence(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
+                                _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
+  {
+    ROS_INFO("Localization was convergence");
+  }
 }
 
 bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
 {
-	bool _ret;
-	ctx-&gt;setEnableForceSetState(true);
-	_ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
-	ctx-&gt;setEnableForceSetState(false);
-
-
-	if(ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE) ||
-		ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE)){
-		
-		int count = 0;
-		for (auto &amp;lane : current_controlled_lane_array_.lanes)
-		{
-			autoware_msgs::lane temp_lane = lane;
-				for(size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++){
-
-					double v0 =  temp_lane.waypoints.at(wpi-1).twist.twist.linear.x;
-					double v =  temp_lane.waypoints.at(wpi).twist.twist.linear.x;
-
-					amathutils::point p0(
-							temp_lane.waypoints.at(wpi).pose.pose.position.x,
-							temp_lane.waypoints.at(wpi).pose.pose.position.y,
-							temp_lane.waypoints.at(wpi).pose.pose.position.z);
-					amathutils::point p1(
-							temp_lane.waypoints.at(wpi-1).pose.pose.position.x,
-							temp_lane.waypoints.at(wpi-1).pose.pose.position.y,
-							temp_lane.waypoints.at(wpi-1).pose.pose.position.z);
-
-
-					double distance = amathutils::find_distance(&amp;p0,&amp;p1);
-					double _weight = distance * 0.05; 
-					if(ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE)){
-						_weight *= 1;
-					}
-					else if(ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE)){
-						_weight *= -1;
-					}
-					lane.waypoints.at(wpi).twist.twist.linear.x =  
-						lane.waypoints.at(wpi).twist.twist.linear.x + 
-						lane.waypoints.at(wpi).twist.twist.linear.x * _weight;
-				}
-
-		}
-		Pubs["lane_waypoints_array"].publish(current_controlled_lane_array_);
-	}
-	return _ret;
+  bool _ret;
+  ctx-&gt;setEnableForceSetState(true);
+  _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
+  ctx-&gt;setEnableForceSetState(false);
+
+  if (ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE) ||
+      ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE))
+  {
+    int count = 0;
+    for (auto &amp;lane : current_controlled_lane_array_.lanes)
+    {
+      autoware_msgs::lane temp_lane = lane;
+      for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
+      {
+        double v0 = temp_lane.waypoints.at(wpi - 1).twist.twist.linear.x;
+        double v = temp_lane.waypoints.at(wpi).twist.twist.linear.x;
+
+        amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
+                             temp_lane.waypoints.at(wpi).pose.pose.position.y,
+                             temp_lane.waypoints.at(wpi).pose.pose.position.z);
+        amathutils::point p1(temp_lane.waypoints.at(wpi - 1).pose.pose.position.x,
+                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.y,
+                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);
+
+        double distance = amathutils::find_distance(&amp;p0, &amp;p1);
+        double _weight = distance * 0.05;
+        if (ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE))
+        {
+          _weight *= 1;
+        }
+        else if (ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE))
+        {
+          _weight *= -1;
+        }
+        lane.waypoints.at(wpi).twist.twist.linear.x =
+            lane.waypoints.at(wpi).twist.twist.linear.x + lane.waypoints.at(wpi).twist.twist.linear.x * _weight;
+      }
+    }
+    Pubs["lane_waypoints_array"].publish(current_controlled_lane_array_);
+  }
+  return _ret;
 }
 
 void DecisionMakerNode::callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg)
 {
-	ROS_INFO("Received system is going to simulation mode");
-	handleStateCmd(state_machine::DRIVE_STATE);
-	Subs["sim_pose"].shutdown();
+  ROS_INFO("Received system is going to simulation mode");
+  handleStateCmd(state_machine::DRIVE_STATE);
+  Subs["sim_pose"].shutdown();
 }
 
 void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
 {
-	ROS_INFO("Received forcing state changing request");
-	handleStateCmd((unsigned long long)1 &lt;&lt; msg.data);
+  ROS_INFO("Received forcing state changing request");
+  handleStateCmd((unsigned long long)1 &lt;&lt; msg.data);
 }
 
 void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
 {
-	if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
-		ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
-	else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
-		ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
-	else
-	{
-		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
-		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
-	}
+  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
+    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
+  else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
+    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
+  else
+  {
+    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
+    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
+  }
 }
 
 void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg)
 {
-	ROS_INFO("Param setted by Runtime Manager");
-	enableDisplayMarker = msg.enable_display_marker;
-	ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);
-	if (msg.enable_force_state_change)
-	{
-		if (msg.MainState_ChangeFlag)
-			handleStateCmd((unsigned long long)1 &lt;&lt; msg.MainState_ChangeFlag);
-		if (msg.SubState_Acc_ChangeFlag)
-			handleStateCmd(state_machine::DRIVE_ACC_ACCELERATION_STATE &lt;&lt; (msg.SubState_Acc_ChangeFlag - 1));
-		if (msg.SubState_Str_ChangeFlag)
-			handleStateCmd(state_machine::DRIVE_STR_STRAIGHT_STATE &lt;&lt; (msg.SubState_Str_ChangeFlag - 1));
-		if (msg.SubState_Behavior_ChangeFlag)
-			handleStateCmd(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE &lt;&lt; (msg.SubState_Behavior_ChangeFlag - 1));
-		if (msg.SubState_Perception_ChangeFlag)
-			handleStateCmd(state_machine::DRIVE_DETECT_OBSTACLE_STATE &lt;&lt; (msg.SubState_Perception_ChangeFlag - 1));
-	}
+  ROS_INFO("Param setted by Runtime Manager");
+  enableDisplayMarker = msg.enable_display_marker;
+  ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);
+  if (msg.enable_force_state_change)
+  {
+    if (msg.MainState_ChangeFlag)
+      handleStateCmd((unsigned long long)1 &lt;&lt; msg.MainState_ChangeFlag);
+    if (msg.SubState_Acc_ChangeFlag)
+      handleStateCmd(state_machine::DRIVE_ACC_ACCELERATION_STATE &lt;&lt; (msg.SubState_Acc_ChangeFlag - 1));
+    if (msg.SubState_Str_ChangeFlag)
+      handleStateCmd(state_machine::DRIVE_STR_STRAIGHT_STATE &lt;&lt; (msg.SubState_Str_ChangeFlag - 1));
+    if (msg.SubState_Behavior_ChangeFlag)
+      handleStateCmd(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE &lt;&lt; (msg.SubState_Behavior_ChangeFlag - 1));
+    if (msg.SubState_Perception_ChangeFlag)
+      handleStateCmd(state_machine::DRIVE_DETECT_OBSTACLE_STATE &lt;&lt; (msg.SubState_Perception_ChangeFlag - 1));
+  }
 }
 
 void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
 {
-	const ros::M_string &amp;header = event.getConnectionHeader();
-	std::string topic = header.at("topic");
-	const autoware_msgs::traffic_light *light = event.getMessage().get();
-
-	current_traffic_light = light-&gt;traffic_light;
-	if (current_traffic_light == state_machine::E_RED || current_traffic_light == state_machine::E_YELLOW)
-	{
-		ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
-	}
-	else
-	{
-		ctx-&gt;disableCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
-	}
-	// ctx-&gt;handleTrafficLight(CurrentTrafficlight);
+  const ros::M_string &amp;header = event.getConnectionHeader();
+  std::string topic = header.at("topic");
+  const autoware_msgs::traffic_light *light = event.getMessage().get();
+
+  current_traffic_light = light-&gt;traffic_light;
+  if (current_traffic_light == state_machine::E_RED || current_traffic_light == state_machine::E_YELLOW)
+  {
+    ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
+  }
+  else
+  {
+    ctx-&gt;disableCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
+  }
+  // ctx-&gt;handleTrafficLight(CurrentTrafficlight);
 }
 
 //
 void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
 {
-	if (ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
-		Subs["points_raw"].shutdown();
+  if (ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
+    Subs["points_raw"].shutdown();
 }
 
-
-void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects, autoware_msgs::LaneArray &amp;lane_array)
+void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects,
+                                                   autoware_msgs::LaneArray &amp;lane_array)
 {
-	for (auto &amp;lane : lane_array.lanes)
-	{
-		for (auto &amp;wp : lane.waypoints)
-		{
-			geometry_msgs::Point pp;
-			pp.x = wp.pose.pose.position.x;
-			pp.y = wp.pose.pose.position.y;
-			pp.z = wp.pose.pose.position.z;
-
-			for (auto &amp;area : intersects)
-			{
-				if (CrossRoadArea::isInsideArea(&amp;area, pp))
-				{ 
-					//area's
-					if(area.insideLanes.empty() ||  wp.gid  != area.insideLanes.back().waypoints.back().gid + 1 ){
-						autoware_msgs::lane nlane;;
-						area.insideLanes.push_back(nlane);
-					}
-					area.insideLanes.back().waypoints.push_back(wp);
-					area.insideWaypoint_points.push_back(pp); //geometry_msgs::point
-					//area.insideLanes.Waypoints.push_back(wp);//autoware_msgs::waypoint
-					//lane's wp
-					wp.wpstate.aid = area.area_id;
-				}
-			}
-		}
-	}
+  for (auto &amp;lane : lane_array.lanes)
+  {
+    for (auto &amp;wp : lane.waypoints)
+    {
+      geometry_msgs::Point pp;
+      pp.x = wp.pose.pose.position.x;
+      pp.y = wp.pose.pose.position.y;
+      pp.z = wp.pose.pose.position.z;
+
+      for (auto &amp;area : intersects)
+      {
+        if (CrossRoadArea::isInsideArea(&amp;area, pp))
+        {
+          // area's
+          if (area.insideLanes.empty() || wp.gid != area.insideLanes.back().waypoints.back().gid + 1)
+          {
+            autoware_msgs::lane nlane;
+            ;
+            area.insideLanes.push_back(nlane);
+          }
+          area.insideLanes.back().waypoints.push_back(wp);
+          area.insideWaypoint_points.push_back(pp);  // geometry_msgs::point
+          // area.insideLanes.Waypoints.push_back(wp);//autoware_msgs::waypoint
+          // lane's wp
+          wp.wpstate.aid = area.area_id;
+        }
+      }
+    }
+  }
 }
 
 void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
 {
-	for(auto &amp;area : intersects){
-
-		for(auto &amp;laneinArea : area.insideLanes){
-		// To straight/left/right recognition by using angle
-		// between first-waypoint and end-waypoint in intersection area.
-		int angle_deg = ((int)std::floor(calcIntersectWayAngle(laneinArea))); //normalized
-		int steering_state;
-
-		if (angle_deg &lt;= ANGLE_LEFT)
-			steering_state = autoware_msgs::WaypointState::STR_LEFT;
-		else if (angle_deg &gt;= ANGLE_RIGHT)
-			steering_state = autoware_msgs::WaypointState::STR_RIGHT;
-		else
-			steering_state = autoware_msgs::WaypointState::STR_STRAIGHT;
-
-		for (auto &amp;lane : lane_array.lanes)
-		{
-			for (auto &amp;wp : lane.waypoints)
-			{
-				if(area.area_id == wp.wpstate.aid)
-				{
-					wp.wpstate.steering_state = steering_state;
-				}
-			}
-		}
-		ROS_INFO("%d: %d  angle_deg :%d\n",area.area_id, steering_state, angle_deg);
-	}
-}
+  for (auto &amp;area : intersects)
+  {
+    for (auto &amp;laneinArea : area.insideLanes)
+    {
+      // To straight/left/right recognition by using angle
+      // between first-waypoint and end-waypoint in intersection area.
+      int angle_deg = ((int)std::floor(calcIntersectWayAngle(laneinArea)));  // normalized
+      int steering_state;
+
+      if (angle_deg &lt;= ANGLE_LEFT)
+        steering_state = autoware_msgs::WaypointState::STR_LEFT;
+      else if (angle_deg &gt;= ANGLE_RIGHT)
+        steering_state = autoware_msgs::WaypointState::STR_RIGHT;
+      else
+        steering_state = autoware_msgs::WaypointState::STR_STRAIGHT;
+
+      for (auto &amp;lane : lane_array.lanes)
+      {
+        for (auto &amp;wp : lane.waypoints)
+        {
+          if (area.area_id == wp.wpstate.aid)
+          {
+            wp.wpstate.steering_state = steering_state;
+          }
+        }
+      }
+      ROS_INFO("%d: %d  angle_deg :%d\n", area.area_id, steering_state, angle_deg);
+    }
+  }
 }
 
-
 // for based waypoint
 void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg)
 {
-	current_based_lane_array_ = msg; //cached based path
-
-	//indexing
-	for(auto &amp;lane: current_based_lane_array_.lanes){
-		int gid = 0;
-		for(auto &amp;wp : lane.waypoints){
-			int lid = 0;
-			wp.gid = gid++;
-			wp.lid = lid++;
-			wp.wpstate.aid = 0;
-			wp.wpstate.steering_state= autoware_msgs::WaypointState::NULLSTATE;
-			wp.wpstate.accel_state = autoware_msgs::WaypointState::NULLSTATE;
-			wp.wpstate.stopline_state= autoware_msgs::WaypointState::NULLSTATE;
-			wp.wpstate.lanechange_state= autoware_msgs::WaypointState::NULLSTATE;
-			wp.wpstate.event_state = 0;
-		}
-	}
-
-	current_controlled_lane_array_ = current_based_lane_array_; //controlled path
-	insertPointWithinCrossRoad(intersects, current_controlled_lane_array_);
-	setWaypointState(current_controlled_lane_array_);
-
-	Pubs["lane_waypoints_array"].publish(current_controlled_lane_array_);
+  current_based_lane_array_ = msg;  // cached based path
+
+  // indexing
+  for (auto &amp;lane : current_based_lane_array_.lanes)
+  {
+    int gid = 0;
+    for (auto &amp;wp : lane.waypoints)
+    {
+      int lid = 0;
+      wp.gid = gid++;
+      wp.lid = lid++;
+      wp.wpstate.aid = 0;
+      wp.wpstate.steering_state = autoware_msgs::WaypointState::NULLSTATE;
+      wp.wpstate.accel_state = autoware_msgs::WaypointState::NULLSTATE;
+      wp.wpstate.stopline_state = autoware_msgs::WaypointState::NULLSTATE;
+      wp.wpstate.lanechange_state = autoware_msgs::WaypointState::NULLSTATE;
+      wp.wpstate.event_state = 0;
+    }
+  }
+
+  current_controlled_lane_array_ = current_based_lane_array_;  // controlled path
+  insertPointWithinCrossRoad(intersects, current_controlled_lane_array_);
+  setWaypointState(current_controlled_lane_array_);
+
+  Pubs["lane_waypoints_array"].publish(current_controlled_lane_array_);
 }
 
 state_machine::StateFlags getStateFlags(uint8_t msg_state)
 {
-	if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_LEFT)
-		return state_machine::DRIVE_STR_LEFT_STATE;
-	else if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_RIGHT)
-		return state_machine::DRIVE_STR_RIGHT_STATE;
-	else
-		return state_machine::DRIVE_STR_STRAIGHT_STATE;
+  if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_LEFT)
+    return state_machine::DRIVE_STR_LEFT_STATE;
+  else if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_RIGHT)
+    return state_machine::DRIVE_STR_RIGHT_STATE;
+  else
+    return state_machine::DRIVE_STR_STRAIGHT_STATE;
 }
 
-
 void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
 {
-	if (!hasvMap())
-	{
-		std::cerr &lt;&lt; "Not found vmap subscribe" &lt;&lt; std::endl;
-		return;
-	}
-	
-	if (!ctx-&gt;isCurrentState(state_machine::DRIVE_STATE))
-	{
-		std::cerr &lt;&lt; "State is not DRIVE_STATE[" &lt;&lt; ctx-&gt;getCurrentStateName() &lt;&lt; "]" &lt;&lt; std::endl;
-		return;
-	}
-	//cached
-	current_finalwaypoints_ = msg;
-	
-	// steering
-	if(current_finalwaypoints_.waypoints.size() &gt; param_target_waypoint_)
-		ctx-&gt;setCurrentState(getStateFlags(current_finalwaypoints_.waypoints.at(param_target_waypoint_).wpstate.steering_state));
+  if (!hasvMap())
+  {
+    std::cerr &lt;&lt; "Not found vmap subscribe" &lt;&lt; std::endl;
+    return;
+  }
+
+  if (!ctx-&gt;isCurrentState(state_machine::DRIVE_STATE))
+  {
+    std::cerr &lt;&lt; "State is not DRIVE_STATE[" &lt;&lt; ctx-&gt;getCurrentStateName() &lt;&lt; "]" &lt;&lt; std::endl;
+    return;
+  }
+  // cached
+  current_finalwaypoints_ = msg;
+
+  // steering
+  if (current_finalwaypoints_.waypoints.size() &gt; param_target_waypoint_)
+    ctx-&gt;setCurrentState(
+        getStateFlags(current_finalwaypoints_.waypoints.at(param_target_waypoint_).wpstate.steering_state));
 
 #if 0
 	// velocity
@@ -291,51 +290,51 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
 		ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE);
 #endif
 
-	// for publish plan of velocity
-	publishToVelocityArray();
+  // for publish plan of velocity
+  publishToVelocityArray();
 
 #ifdef DEBUG_PRINT
-	std::cout &lt;&lt; "Velocity: " &lt;&lt; current_velocity_ &lt;&lt; " to " &lt;&lt; average_velocity_ &lt;&lt; std::endl;
+  std::cout &lt;&lt; "Velocity: " &lt;&lt; current_velocity_ &lt;&lt; " to " &lt;&lt; average_velocity_ &lt;&lt; std::endl;
 #endif
 }
 void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
 {
-	static bool Twistflag = false;
+  static bool Twistflag = false;
 
-	if (Twistflag)
-		ctx-&gt;handleTwistCmd(false);
-	else
-		Twistflag = true;
+  if (Twistflag)
+    ctx-&gt;handleTwistCmd(false);
+  else
+    Twistflag = true;
 }
 
 void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
 {
-	vMap_Areas = msg;
-	vMap_Areas_flag = true;
-	initVectorMap();
+  vMap_Areas = msg;
+  vMap_Areas_flag = true;
+  initVectorMap();
 }
 void DecisionMakerNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
 {
-	vMap_Points = msg;
-	vMap_Points_flag = true;
-	initVectorMap();
+  vMap_Points = msg;
+  vMap_Points_flag = true;
+  initVectorMap();
 }
 void DecisionMakerNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
 {
-	vMap_Lines = msg;
-	vMap_Lines_flag = true;
-	initVectorMap();
+  vMap_Lines = msg;
+  vMap_Lines_flag = true;
+  initVectorMap();
 }
 void DecisionMakerNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
 {
-	vMap_CrossRoads = msg;
-	vMap_CrossRoads_flag = true;
-	initVectorMap();
+  vMap_CrossRoads = msg;
+  vMap_CrossRoads_flag = true;
+  initVectorMap();
 }
 
 void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
 {
-	current_velocity_ = amathutils::mps2kmph(msg.twist.linear.x);
+  current_velocity_ = amathutils::mps2kmph(msg.twist.linear.x);
 }
 #if 0
 void DecisionMakerNode::callbackFromDynamicReconfigure(decision_maker::decision_makerConfig &amp;config, uint32_t level){
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" added_lines="2" deleted_lines="3">
				<diff>@@ -21,7 +21,6 @@
 #include &lt;geometry_msgs/Pose.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 
-#define DEBUG_PRINT
 namespace decision_maker
 {
 bool DecisionMakerNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg,
@@ -51,7 +50,8 @@ bool DecisionMakerNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;
 void DecisionMakerNode::update(void)
 {
   update_msgs();
-  if(ctx) ctx-&gt;update();
+  if (ctx)
+    ctx-&gt;update();
 }
 
 void DecisionMakerNode::run(void)
@@ -68,7 +68,6 @@ void DecisionMakerNode::run(void)
     if (enableDisplayMarker)
       displayMarker();
 
- 
 #ifdef DEBUG_PRINT
     // debug status
     ros::Duration exec_time = ros::Time::now() - begin;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" added_lines="48" deleted_lines="52">
				<diff>@@ -16,68 +16,64 @@
 
 namespace decision_maker
 {
-	double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;laneinArea)
-	{
-		double diff = 0.0;
-		if(laneinArea.waypoints.empty())
-		{
-			ROS_INFO("Not inside CrossRoad");
-		}
-		else
-		{
-			const geometry_msgs::Pose InPose = laneinArea.waypoints.front().pose.pose;
-			const geometry_msgs::Pose OutPose = laneinArea.waypoints.back().pose.pose;
-			double r, p, y, _y;
+double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;laneinArea)
+{
+  double diff = 0.0;
+  if (laneinArea.waypoints.empty())
+  {
+    ROS_INFO("Not inside CrossRoad");
+  }
+  else
+  {
+    const geometry_msgs::Pose InPose = laneinArea.waypoints.front().pose.pose;
+    const geometry_msgs::Pose OutPose = laneinArea.waypoints.back().pose.pose;
+    double r, p, y, _y;
 
-			tf::Quaternion quat_end(OutPose.orientation.x, OutPose.orientation.y, OutPose.orientation.z,
-					OutPose.orientation.w);
-			tf::Quaternion quat_in(InPose.orientation.x, InPose.orientation.y, InPose.orientation.z, InPose.orientation.w);
-			tf::Matrix3x3(quat_in).getRPY(r, p, y);
-			tf::Matrix3x3(quat_end).getRPY(r, p, _y);
-			
-			// convert to [-pi : pi]
-			diff = std::fmod(y - _y, 2 * M_PI);
-			diff = diff &gt; M_PI? 
-				diff - 2 * M_PI : diff &lt; -M_PI?
-				2 * M_PI + diff : diff;
-			diff = diff *180/M_PI;
+    tf::Quaternion quat_end(OutPose.orientation.x, OutPose.orientation.y, OutPose.orientation.z, OutPose.orientation.w);
+    tf::Quaternion quat_in(InPose.orientation.x, InPose.orientation.y, InPose.orientation.z, InPose.orientation.w);
+    tf::Matrix3x3(quat_in).getRPY(r, p, y);
+    tf::Matrix3x3(quat_end).getRPY(r, p, _y);
 
-		}
+    // convert to [-pi : pi]
+    diff = std::fmod(y - _y, 2 * M_PI);
+    diff = diff &gt; M_PI ? diff - 2 * M_PI : diff &lt; -M_PI ? 2 * M_PI + diff : diff;
+    diff = diff * 180 / M_PI;
+  }
 
-		return diff;
+  return diff;
 }
 
 bool DecisionMakerNode::isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch,
-		double _yaw)
+                                                  double _yaw)
 {
-	static int _init_count = 0;
-	static amathutils::point *a = new amathutils::point();
-	static amathutils::point *b = new amathutils::point();
+  static int _init_count = 0;
+  static amathutils::point *a = new amathutils::point();
+  static amathutils::point *b = new amathutils::point();
 
-	static std::vector&lt;double&gt; distances;
-	static int distances_count = 0;
-	double avg_distances = 0.0;
+  static std::vector&lt;double&gt; distances;
+  static int distances_count = 0;
+  double avg_distances = 0.0;
 
-	a-&gt;x = b-&gt;x;
-	a-&gt;y = b-&gt;y;
-	a-&gt;z = b-&gt;z;
+  a-&gt;x = b-&gt;x;
+  a-&gt;y = b-&gt;y;
+  a-&gt;z = b-&gt;z;
 
-	b-&gt;x = _x;
-	b-&gt;y = _y;
-	b-&gt;z = _z;
+  b-&gt;x = _x;
+  b-&gt;y = _y;
+  b-&gt;z = _z;
 
-	distances.push_back(amathutils::find_distance(a, b));
-	if (++distances_count &gt; param_convergence_count_)
-	{
-		distances.erase(distances.begin());
-		distances_count--;
-		avg_distances = std::accumulate(distances.begin(), distances.end(), 0) / distances.size();
-		if (avg_distances &lt;= param_convergence_threshold_)
-			return ctx-&gt;setCurrentState(state_machine::DRIVE_STATE);
-	}
-	else
-	{
-		return false;
-	}
+  distances.push_back(amathutils::find_distance(a, b));
+  if (++distances_count &gt; param_convergence_count_)
+  {
+    distances.erase(distances.begin());
+    distances_count--;
+    avg_distances = std::accumulate(distances.begin(), distances.end(), 0) / distances.size();
+    if (avg_distances &lt;= param_convergence_threshold_)
+      return ctx-&gt;setCurrentState(state_machine::DRIVE_STATE);
+  }
+  else
+  {
+    return false;
+  }
 }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="35" deleted_lines="29">
				<diff>@@ -15,8 +15,8 @@
 #include &lt;decision_maker_node.hpp&gt;
 //#include &lt;vector_map/vector_map.h&gt;
 
-#include &lt;autoware_msgs/lane.h&gt;
 #include &lt;autoware_msgs/lamp_cmd.h&gt;
+#include &lt;autoware_msgs/lane.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;random&gt;
@@ -27,33 +27,40 @@
 
 namespace decision_maker
 {
+#define TPNAME_BASED_LANE_WAYPOINTS_ARRAY "/based/lane_waypoints_array"
+#define TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY "/lane_waypoints_array"
 
-#define  TPNAME_BASED_LANE_WAYPOINTS_ARRAY "/based/lane_waypoints_array"
-#define  TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY "/lane_waypoints_array"
-
-void DecisionMakerNode::callbackStateSTR(int status){
-	ROS_INFO("[%s]:%d\n",__func__,status);
-	autoware_msgs::lamp_cmd lamp_msg;
-	
-	if(status == 0){
-		lamp_msg.l = 0; 
-		lamp_msg.r = 0;
-	}else if(status == 1){
-		lamp_msg.l = 1;
-		lamp_msg.r = 0;
-	}else if(status == 2){
-		lamp_msg.l = 0;
-		lamp_msg.r = 0;
-	}	
-	Pubs["lamp_cmd"].publish(lamp_msg);
+void DecisionMakerNode::callbackStateSTR(int status)
+{
+  ROS_INFO("[%s]:%d\n", __func__, status);
+  autoware_msgs::lamp_cmd lamp_msg;
 
+  if (status == 0)
+  {
+    lamp_msg.l = 0;
+    lamp_msg.r = 0;
+  }
+  else if (status == 1)
+  {
+    lamp_msg.l = 1;
+    lamp_msg.r = 0;
+  }
+  else if (status == 2)
+  {
+    lamp_msg.l = 0;
+    lamp_msg.r = 0;
+  }
+  Pubs["lamp_cmd"].publish(lamp_msg);
 }
 
 void DecisionMakerNode::setupStateCallback(void)
 {
-	ctx-&gt;getStateObject(state_machine::DRIVE_STR_LEFT_STATE)-&gt;setCallbackFunc(std::bind(&amp;DecisionMakerNode::callbackStateSTR, this, 1));
-	ctx-&gt;getStateObject(state_machine::DRIVE_STR_RIGHT_STATE)-&gt;setCallbackFunc(std::bind(&amp;DecisionMakerNode::callbackStateSTR, this, 2));
-	ctx-&gt;getStateObject(state_machine::DRIVE_STR_STRAIGHT_STATE)-&gt;setCallbackFunc(std::bind(&amp;DecisionMakerNode::callbackStateSTR, this, 0));
+  ctx-&gt;getStateObject(state_machine::DRIVE_STR_LEFT_STATE)
+      -&gt;setCallbackFunc(std::bind(&amp;DecisionMakerNode::callbackStateSTR, this, 1));
+  ctx-&gt;getStateObject(state_machine::DRIVE_STR_RIGHT_STATE)
+      -&gt;setCallbackFunc(std::bind(&amp;DecisionMakerNode::callbackStateSTR, this, 2));
+  ctx-&gt;getStateObject(state_machine::DRIVE_STR_STRAIGHT_STATE)
+      -&gt;setCallbackFunc(std::bind(&amp;DecisionMakerNode::callbackStateSTR, this, 0));
 }
 
 void DecisionMakerNode::initROS(int argc, char **argv)
@@ -90,9 +97,8 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   Pubs["state"] = nh_.advertise&lt;std_msgs::String&gt;("state", 1);
   Pubs["lane_waypoints_array"] = nh_.advertise&lt;autoware_msgs::LaneArray&gt;(TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY, 10, true);
 
-
   Pubs["lamp_cmd"] = nh_.advertise&lt;autoware_msgs::lamp_cmd&gt;("/lamp_cmd", 1);
-  
+
   // for visualize
   Pubs["state_overlay"] = nh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;("/state/overlay_text", 1);
   Pubs["crossroad_marker"] = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("/state/cross_road_marker", 1);
@@ -116,7 +122,6 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   // initial publishing state message
   update_msgs();
 
-
   // setup a callback for state update();
   setupStateCallback();
 
@@ -163,7 +168,7 @@ void DecisionMakerNode::initVectorMap(void)
             double y_avg = 0.0, y_min = 0.0, y_max = 0.0;
             double z = 0.0;
             int points_count = 0;
-	    
+
             for (const auto &amp;line : vMap_Lines.data)
             {
               if (area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid)
@@ -183,9 +188,9 @@ void DecisionMakerNode::initVectorMap(void)
 
                     _prev_point = _point;
                     points_count++;
-		    carea.points.push_back(_point);
+                    carea.points.push_back(_point);
 
-		    // calc a centroid point and about intersects size
+                    // calc a centroid point and about intersects size
                     x_avg += _point.x;
                     y_avg += _point.y;
                     x_min = (x_min == 0.0) ? _point.x : std::min(_point.x, x_min);
@@ -211,7 +216,8 @@ void DecisionMakerNode::initVectorMap(void)
       }
     }
     vMap_mutex.unlock();
-    Subs["lane_waypoints_array"] = nh_.subscribe( TPNAME_BASED_LANE_WAYPOINTS_ARRAY, 100, &amp;DecisionMakerNode::callbackFromLaneWaypoint, this);
+    Subs["lane_waypoints_array"] =
+        nh_.subscribe(TPNAME_BASED_LANE_WAYPOINTS_ARRAY, 100, &amp;DecisionMakerNode::callbackFromLaneWaypoint, this);
   }
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="3" deleted_lines="6">
				<diff>@@ -29,16 +29,15 @@ void DecisionMakerNode::update_pubsub(void)
   // this function will re-definition subscriber.
 }
 
-
-int DecisionMakerNode::createCrossRoadAreaMarker(visualization_msgs::Marker &amp;crossroad_marker, double scale){
-
+int DecisionMakerNode::createCrossRoadAreaMarker(visualization_msgs::Marker &amp;crossroad_marker, double scale)
+{
   crossroad_marker.header.frame_id = "/map";
   crossroad_marker.header.stamp = ros::Time();
   crossroad_marker.id = 1;
   crossroad_marker.type = visualization_msgs::Marker::SPHERE_LIST;
   crossroad_marker.action = visualization_msgs::Marker::ADD;
   crossroad_marker.ns = "crossroad";
-  
+
   crossroad_marker.scale.x = scale;
   crossroad_marker.scale.y = scale;
   crossroad_marker.scale.z = 0.5;
@@ -48,7 +47,6 @@ int DecisionMakerNode::createCrossRoadAreaMarker(visualization_msgs::Marker &amp;cro
   crossroad_marker.color.b = 0.0;
   crossroad_marker.frame_locked = true;
   crossroad_marker.lifetime = ros::Duration(0.3);
-
 }
 
 void DecisionMakerNode::displayMarker(void)
@@ -63,7 +61,6 @@ void DecisionMakerNode::displayMarker(void)
   static visualization_msgs::Marker crossroad_marker;
   static visualization_msgs::Marker inside_marker;
 
-
   double scale = 3.0;
   createCrossRoadAreaMarker(crossroad_marker, scale);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6b58584a6427821fc68ce12d7fdfff978de9a6db" author="anhnv-3991">
		<msg>GPU NormalDistributionsTransform optimization</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\NormalDistributionsTransform.h" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\include\fast_pcl\ndt_gpu\NormalDistributionsTransform.h" added_lines="11" deleted_lines="6">
				<diff>@@ -77,16 +77,21 @@ private:
 
 	double gauss_d1_, gauss_d2_;
 	double outlier_ratio_;
-	MatrixHost j_ang_a_, j_ang_b_, j_ang_c_, j_ang_d_, j_ang_e_, j_ang_f_, j_ang_g_, j_ang_h_;
+	//MatrixHost j_ang_a_, j_ang_b_, j_ang_c_, j_ang_d_, j_ang_e_, j_ang_f_, j_ang_g_, j_ang_h_;
+	MatrixHost j_ang_;
 
-	MatrixHost h_ang_a2_, h_ang_a3_, h_ang_b2_, h_ang_b3_, h_ang_c2_, h_ang_c3_, h_ang_d1_, h_ang_d2_, h_ang_d3_,
-				h_ang_e1_, h_ang_e2_, h_ang_e3_, h_ang_f1_, h_ang_f2_, h_ang_f3_;
+	//MatrixHost h_ang_a2_, h_ang_a3_, h_ang_b2_, h_ang_b3_, h_ang_c2_, h_ang_c3_, h_ang_d1_, h_ang_d2_, h_ang_d3_,
+	//			h_ang_e1_, h_ang_e2_, h_ang_e3_, h_ang_f1_, h_ang_f2_, h_ang_f3_;
+	MatrixHost h_ang_;
 
 
-	MatrixDevice dj_ang_a_, dj_ang_b_, dj_ang_c_, dj_ang_d_, dj_ang_e_, dj_ang_f_, dj_ang_g_, dj_ang_h_;
+	//MatrixDevice dj_ang_a_, dj_ang_b_, dj_ang_c_, dj_ang_d_, dj_ang_e_, dj_ang_f_, dj_ang_g_, dj_ang_h_;
+	MatrixDevice dj_ang_;
 
-	MatrixDevice dh_ang_a2_, dh_ang_a3_, dh_ang_b2_, dh_ang_b3_, dh_ang_c2_, dh_ang_c3_, dh_ang_d1_, dh_ang_d2_, dh_ang_d3_,
-				dh_ang_e1_, dh_ang_e2_, dh_ang_e3_, dh_ang_f1_, dh_ang_f2_, dh_ang_f3_;
+
+	//MatrixDevice dh_ang_a2_, dh_ang_a3_, dh_ang_b2_, dh_ang_b3_, dh_ang_c2_, dh_ang_c3_, dh_ang_d1_, dh_ang_d2_, dh_ang_d3_,
+	//			dh_ang_e1_, dh_ang_e2_, dh_ang_e3_, dh_ang_f1_, dh_ang_f2_, dh_ang_f3_;
+	MatrixDevice dh_ang_;
 
 	double step_size_;
 	float resolution_;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\NormalDistributionsTransform.cu" new_path="ros\src\computing\perception\localization\lib\fast_pcl\ndt_gpu\src\NormalDistributionsTransform.cu" added_lines="470" deleted_lines="795">
				<diff>@@ -4,8 +4,6 @@
 #include &lt;iostream&gt;
 #include &lt;pcl/common/transforms.h&gt;
 
-#define V2_ 1
-
 namespace gpu {
 
 GNormalDistributionsTransform::GNormalDistributionsTransform()
@@ -30,55 +28,13 @@ GNormalDistributionsTransform::GNormalDistributionsTransform()
 	transformation_epsilon_ = 0.1;
 	max_iterations_ = 35;
 
-	j_ang_a_ = MatrixHost(3, 1);
-	j_ang_b_ = MatrixHost(3, 1);
-	j_ang_c_ = MatrixHost(3, 1);
-	j_ang_d_ = MatrixHost(3, 1);
-	j_ang_e_ = MatrixHost(3, 1);
-	j_ang_f_ = MatrixHost(3, 1);
-	j_ang_g_ = MatrixHost(3, 1);
-	j_ang_h_ = MatrixHost(3, 1);
-
-	h_ang_a2_ = MatrixHost(3, 1);
-	h_ang_a3_ = MatrixHost(3, 1);
-	h_ang_b2_ = MatrixHost(3, 1);
-	h_ang_b3_ = MatrixHost(3, 1);
-	h_ang_c2_ = MatrixHost(3, 1);
-	h_ang_c3_ = MatrixHost(3, 1);
-	h_ang_d1_ = MatrixHost(3, 1);
-	h_ang_d2_ = MatrixHost(3, 1);
-	h_ang_d3_ = MatrixHost(3, 1);
-	h_ang_e1_ = MatrixHost(3, 1);
-	h_ang_e2_ = MatrixHost(3, 1);
-	h_ang_e3_ = MatrixHost(3, 1);
-	h_ang_f1_ = MatrixHost(3, 1);
-	h_ang_f2_ = MatrixHost(3, 1);
-	h_ang_f3_ = MatrixHost(3, 1);
-
-	dj_ang_a_ = MatrixDevice(3, 1);
-	dj_ang_b_ = MatrixDevice(3, 1);
-	dj_ang_c_ = MatrixDevice(3, 1);
-	dj_ang_d_ = MatrixDevice(3, 1);
-	dj_ang_e_ = MatrixDevice(3, 1);
-	dj_ang_f_ = MatrixDevice(3, 1);
-	dj_ang_g_ = MatrixDevice(3, 1);
-	dj_ang_h_ = MatrixDevice(3, 1);
-
-	dh_ang_a2_ = MatrixDevice(3, 1);
-	dh_ang_a3_ = MatrixDevice(3, 1);
-	dh_ang_b2_ = MatrixDevice(3, 1);
-	dh_ang_b3_ = MatrixDevice(3, 1);
-	dh_ang_c2_ = MatrixDevice(3, 1);
-	dh_ang_c3_ = MatrixDevice(3, 1);
-	dh_ang_d1_ = MatrixDevice(3, 1);
-	dh_ang_d2_ = MatrixDevice(3, 1);
-	dh_ang_d3_ = MatrixDevice(3, 1);
-	dh_ang_e1_ = MatrixDevice(3, 1);
-	dh_ang_e2_ = MatrixDevice(3, 1);
-	dh_ang_e3_ = MatrixDevice(3, 1);
-	dh_ang_f1_ = MatrixDevice(3, 1);
-	dh_ang_f2_ = MatrixDevice(3, 1);
-	dh_ang_f3_ = MatrixDevice(3, 1);
+	j_ang_ = MatrixHost(24, 1);
+
+	h_ang_ = MatrixHost(45, 1);
+
+	dj_ang_ = MatrixDevice(24, 1);
+
+	dh_ang_ = MatrixDevice(45, 1);
 
 	real_iterations_ = 0;
 }
@@ -90,52 +46,10 @@ GNormalDistributionsTransform::GNormalDistributionsTransform(const GNormalDistri
 
 	outlier_ratio_ = other.outlier_ratio_;
 
-	j_ang_a_ = other.j_ang_a_;
-	j_ang_b_ = other.j_ang_b_;
-	j_ang_c_ = other.j_ang_c_;
-	j_ang_d_ = other.j_ang_d_;
-	j_ang_e_ = other.j_ang_e_;
-	j_ang_f_ = other.j_ang_f_;
-	j_ang_g_ = other.j_ang_g_;
-	j_ang_h_ = other.j_ang_h_;
-
-	h_ang_a2_ = other.h_ang_a2_;
-	h_ang_a3_ = other.h_ang_a3_;
-	h_ang_b2_ = other.h_ang_b2_;
-	h_ang_b3_ = other.h_ang_b3_;
-	h_ang_c2_ = other.h_ang_c2_;
-	h_ang_c3_ = other.h_ang_c3_;
-	h_ang_d1_ = other.h_ang_d2_;
-	h_ang_d2_ = other.h_ang_d2_;
-	h_ang_d3_ = other.h_ang_d3_;
-	h_ang_e1_ = other.h_ang_e1_;
-	h_ang_e2_ = other.h_ang_e2_;
-	h_ang_f1_ = other.h_ang_f1_;
-	h_ang_f2_ = other.h_ang_f2_;
-	h_ang_f3_ = other.h_ang_f3_;
-
-	dj_ang_a_ = other.dj_ang_a_;
-	dj_ang_b_ = other.dj_ang_b_;
-	dj_ang_c_ = other.dj_ang_c_;
-	dj_ang_e_ = other.dj_ang_e_;
-	dj_ang_f_ = other.dj_ang_f_;
-	dj_ang_g_ = other.dj_ang_g_;
-	dj_ang_h_ = other.dj_ang_h_;
-
-	dh_ang_a2_ = other.dh_ang_a2_;
-	dh_ang_a3_ = other.dh_ang_a3_;
-	dh_ang_b2_ = other.dh_ang_b2_;
-	dh_ang_b3_ = other.dh_ang_b3_;
-	dh_ang_c2_ = other.dh_ang_c2_;
-	dh_ang_c3_ = other.dh_ang_c3_;
-	dh_ang_d1_ = other.dh_ang_d2_;
-	dh_ang_d2_ = other.dh_ang_d2_;
-	dh_ang_d3_ = other.dh_ang_d3_;
-	dh_ang_e1_ = other.dh_ang_e1_;
-	dh_ang_e2_ = other.dh_ang_e2_;
-	dh_ang_f1_ = other.dh_ang_f1_;
-	dh_ang_f2_ = other.dh_ang_f2_;
-	dh_ang_f3_ = other.dh_ang_f3_;
+	j_ang_ = other.j_ang_;
+	h_ang_ = other.h_ang_;
+	dj_ang_ = other.dj_ang_;
+	dh_ang_ = other.dh_ang_;
 
 	step_size_ = other.step_size_;
 	resolution_ = other.resolution_;
@@ -147,32 +61,9 @@ GNormalDistributionsTransform::GNormalDistributionsTransform(const GNormalDistri
 
 GNormalDistributionsTransform::~GNormalDistributionsTransform()
 {
-	dj_ang_a_.memFree();
-	dj_ang_b_.memFree();
-	dj_ang_c_.memFree();
-	dj_ang_d_.memFree();
-	dj_ang_e_.memFree();
-	dj_ang_f_.memFree();
-	dj_ang_g_.memFree();
-	dj_ang_h_.memFree();
-
-	dh_ang_a2_.memFree();
-	dh_ang_a3_.memFree();
-	dh_ang_b2_.memFree();
-	dh_ang_b3_.memFree();
-	dh_ang_c2_.memFree();
-	dh_ang_c3_.memFree();
-	dh_ang_d1_.memFree();
-	dh_ang_d2_.memFree();
-	dh_ang_d3_.memFree();
-	dh_ang_e1_.memFree();
-	dh_ang_e2_.memFree();
-	dh_ang_e3_.memFree();
-	dh_ang_f1_.memFree();
-	dh_ang_f2_.memFree();
-	dh_ang_f3_.memFree();
-
-	//voxel_grid_.~GVoxelGrid();
+	dj_ang_.memFree();
+	dh_ang_.memFree();
+
 }
 
 void GNormalDistributionsTransform::setStepSize(double step_size)
@@ -251,7 +142,6 @@ void GNormalDistributionsTransform::setInputTarget(pcl::PointCloud&lt;pcl::PointXYZ
 
 void GNormalDistributionsTransform::computeTransformation(const Eigen::Matrix&lt;float, 4, 4&gt; &amp;guess)
 {
-	struct timeval start, end;
 
 	nr_iterations_ = 0;
 	converged_ = false;
@@ -270,7 +160,6 @@ void GNormalDistributionsTransform::computeTransformation(const Eigen::Matrix&lt;fl
 		transformPointCloud(x_, y_, z_, trans_x_, trans_y_, trans_z_, points_number_, guess);
 	}
 
-
 	Eigen::Transform&lt;float, 3, Eigen::Affine, Eigen::ColMajor&gt; eig_transformation;
 	eig_transformation.matrix() = final_transformation_;
 
@@ -285,11 +174,10 @@ void GNormalDistributionsTransform::computeTransformation(const Eigen::Matrix&lt;fl
 	double score = 0;
 	double delta_p_norm;
 
-	gettimeofday(&amp;start, NULL);
 	score = computeDerivatives(score_gradient, hessian, trans_x_, trans_y_, trans_z_, points_number_, p);
-	gettimeofday(&amp;end, NULL);
 
-	gettimeofday(&amp;start, NULL);
+	int loop_time = 0;
+
 	while (!converged_) {
 		previous_transformation_ = transformation_;
 
@@ -308,6 +196,7 @@ void GNormalDistributionsTransform::computeTransformation(const Eigen::Matrix&lt;fl
 
 		delta_p.normalize();
 		delta_p_norm = computeStepLengthMT(p, delta_p, delta_p_norm, step_size_, transformation_epsilon_ / 2, score, score_gradient, hessian, trans_x_, trans_y_, trans_z_, points_number_);
+
 		delta_p *= delta_p_norm;
 
 		transformation_ = (Eigen::Translation&lt;float, 3&gt;(static_cast&lt;float&gt;(delta_p(0)), static_cast&lt;float&gt;(delta_p(1)), static_cast&lt;float&gt;(delta_p(2))) *
@@ -323,52 +212,31 @@ void GNormalDistributionsTransform::computeTransformation(const Eigen::Matrix&lt;fl
 			converged_ = true;
 
 		nr_iterations_++;
+
+		loop_time++;
 	}
-	gettimeofday(&amp;end, NULL);
 
 	trans_probability_ = score / static_cast&lt;double&gt;(points_number_);
 }
 
 /* First step of computing point gradients */
-extern "C" __global__ void computePointGradients0(float *x, float *y, float *z, int points_num,
+__global__ void computePointGradients(float *x, float *y, float *z, int points_num,
 													int *valid_points, int valid_points_num,
-													MatrixDevice j_ang_a, MatrixDevice j_ang_b, MatrixDevice j_ang_c, MatrixDevice j_ang_d,
-													double *point_gradients)
+													double *dj_ang,
+													double *pg00, double *pg11, double *pg22,
+													double *pg13, double *pg23, double *pg04, double *pg14,
+													double *pg24, double *pg05, double *pg15, double *pg25)
 {
 	int id = threadIdx.x + blockIdx.x * blockDim.x;
 	int stride = blockDim.x * gridDim.x;
+	__shared__ double j_ang[24];
 
-	for (int i = id; i &lt; valid_points_num; i += stride) {
-		int pid = valid_points[i];
-
-		//Orignal coordinates
-		double o_x = static_cast&lt;double&gt;(x[pid]);
-		double o_y = static_cast&lt;double&gt;(y[pid]);
-		double o_z = static_cast&lt;double&gt;(z[pid]);
-
-		MatrixDevice pg(3, 6, valid_points_num, point_gradients + i);		//3x6 Matrix
 
-		//Set the 3x3 block start from (0, 0) to identity matrix
-		pg(0, 0) = 1;
-		pg(1, 1) = 1;
-		pg(2, 2) = 1;
-
-		//Compute point derivatives
-		pg(1, 3) = o_x * j_ang_a(0) + o_y * j_ang_a(1) + o_z * j_ang_a(2);
-		pg(2, 3) = o_x * j_ang_b(0) + o_y * j_ang_b(1) + o_z * j_ang_b(2);
-		pg(0, 4) = o_x * j_ang_c(0) + o_y * j_ang_c(1) + o_z * j_ang_c(2);
-		pg(1, 4) = o_x * j_ang_d(0) + o_y * j_ang_d(1) + o_z * j_ang_d(2);
+	if (threadIdx.x &lt; 24) {
+		j_ang[threadIdx.x] = dj_ang[threadIdx.x];
 	}
-}
 
-/* Second step of computing point gradients */
-extern "C" __global__ void computePointGradients1(float *x, float *y, float *z, int points_num,
-										int *valid_points, int valid_points_num,
-										MatrixDevice j_ang_e, MatrixDevice j_ang_f, MatrixDevice j_ang_g, MatrixDevice j_ang_h,
-										double *point_gradients)
-{
-	int id = threadIdx.x + blockIdx.x * blockDim.x;
-	int stride = blockDim.x * gridDim.x;
+	__syncthreads();
 
 	for (int i = id; i &lt; valid_points_num; i += stride) {
 		int pid = valid_points[i];
@@ -378,25 +246,44 @@ extern "C" __global__ void computePointGradients1(float *x, float *y, float *z,
 		double o_y = static_cast&lt;double&gt;(y[pid]);
 		double o_z = static_cast&lt;double&gt;(z[pid]);
 
-		MatrixDevice pg(3, 6, valid_points_num, point_gradients + i);		//3x6 Matrix
+		//Set the 3x3 block start from (0, 0) to identity matrix
+		pg00[i] = 1;
+		pg11[i] = 1;
+		pg22[i] = 1;
 
 		//Compute point derivatives
-		pg(2, 4) = o_x * j_ang_e(0) + o_y * j_ang_e(1) + o_z * j_ang_e(2);
-		pg(0, 5) = o_x * j_ang_f(0) + o_y * j_ang_f(1) + o_z * j_ang_f(2);
-		pg(1, 5) = o_x * j_ang_g(0) + o_y * j_ang_g(1) + o_z * j_ang_g(2);
-		pg(2, 5) = o_x * j_ang_h(0) + o_y * j_ang_h(1) + o_z * j_ang_h(2);
+		pg13[i] = o_x * j_ang[0] + o_y * j_ang[1] + o_z * j_ang[2];
+		pg23[i] = o_x * j_ang[3] + o_y * j_ang[4] + o_z * j_ang[5];
+		pg04[i] = o_x * j_ang[6] + o_y * j_ang[7] + o_z * j_ang[8];
+		pg14[i] = o_x * j_ang[9] + o_y * j_ang[10] + o_z * j_ang[11];
+
+		pg24[i] = o_x * j_ang[12] + o_y * j_ang[13] + o_z * j_ang[14];
+		pg05[i] = o_x * j_ang[15] + o_y * j_ang[16] + o_z * j_ang[17];
+		pg15[i] = o_x * j_ang[18] + o_y * j_ang[19] + o_z * j_ang[20];
+		pg25[i] = o_x * j_ang[21] + o_y * j_ang[22] + o_z * j_ang[23];
 	}
 }
 
+
 /* First step of computing point hessians */
-extern "C" __global__ void computePointHessian0(float *x, float *y, float *z, int points_num,
+__global__ void computePointHessian0(float *x, float *y, float *z, int points_num,
 												int *valid_points, int valid_points_num,
-												MatrixDevice h_ang_a2, MatrixDevice h_ang_a3,
-												MatrixDevice h_ang_b2, MatrixDevice h_ang_b3,
-												double *point_hessians)
+												double *dh_ang,
+												double *ph93, double *ph103, double *ph113,
+												double *ph123, double *ph94, double *ph133,
+												double *ph104, double *ph143, double *ph114,
+												double *ph153, double *ph95, double *ph163,
+												double *ph105, double *ph173, double *ph115)
 {
 	int id = threadIdx.x + blockIdx.x * blockDim.x;
 	int stride = blockDim.x * gridDim.x;
+	__shared__ double h_ang[18];
+
+	if (threadIdx.x &lt; 18) {
+		h_ang[threadIdx.x] = dh_ang[threadIdx.x];
+	}
+
+	__syncthreads();
 
 	for (int i = id; i &lt; valid_points_num; i += stride) {
 		int pid = valid_points[i];
@@ -406,29 +293,38 @@ extern "C" __global__ void computePointHessian0(float *x, float *y, float *z, in
 		double o_y = static_cast&lt;double&gt;(y[pid]);
 		double o_z = static_cast&lt;double&gt;(z[pid]);
 
-		MatrixDevice ph(18, 6, valid_points_num, point_hessians + i);		//18x6 Matrix
 
-		ph(9, 3) = 0;
-		ph(10, 3) = o_x * h_ang_a2(0) + o_y * h_ang_a2(1) + o_z * h_ang_a2(2);
-		ph(11, 3) = o_x * h_ang_a3(0) + o_y * h_ang_a3(1) + o_z * h_ang_a3(2);
+		ph93[i] = 0;
+		ph103[i] = o_x * h_ang[0] + o_y * h_ang[1] + o_z * h_ang[2];
+		ph113[i] = o_x * h_ang[3] + o_y * h_ang[4] + o_z * h_ang[5];
 
-		ph(12, 3) = ph(9, 4) = 0;
-		ph(13, 3) = ph(10, 4) = o_x * h_ang_b2(0) + o_y * h_ang_b2(1) + o_z * h_ang_b2(2);
-		ph(14, 3) = ph(11, 4) = o_x * h_ang_b3(0) + o_y * h_ang_b3(1) + o_z * h_ang_b3(2);
+		ph123[i] = ph94[i] = 0;
+		ph133[i] = ph104[i] = o_x * h_ang[6] + o_y * h_ang[7] + o_z * h_ang[8];
+		ph143[i] = ph114[i] = o_x * h_ang[9] + o_y * h_ang[10] + o_z * h_ang[11];
+
+		ph153[i] = ph95[i] = 0;
+		ph163[i] = ph105[i] = o_x * h_ang[12] + o_y * h_ang[13] + o_z * h_ang[14];
+		ph173[i] = ph115[i] = o_x * h_ang[15] + o_y * h_ang[16] + o_z * h_ang[17];
 
 	}
 }
 
-/* Second step of computing point hessians */
-extern "C" __global__ void computePointHessian1(float *x, float *y, float *z, int points_num,
+__global__ void computePointHessian1(float *x, float *y, float *z, int points_num,
 												int *valid_points, int valid_points_num,
-												MatrixDevice h_ang_c2, MatrixDevice h_ang_c3,
-												MatrixDevice h_ang_d1, MatrixDevice h_ang_d2,
-												MatrixDevice h_ang_d3,
-												double *point_hessians)
+												double *dh_ang,
+												double *ph124, double *ph134, double *ph144,
+												double *ph154, double *ph125, double *ph164,
+												double *ph135, double *ph174, double *ph145)
 {
 	int id = threadIdx.x + blockIdx.x * blockDim.x;
 	int stride = blockDim.x * gridDim.x;
+	__shared__ double h_ang[18];
+
+	if (threadIdx.x &lt; 18) {
+		h_ang[threadIdx.x] = dh_ang[18 + threadIdx.x];
+	}
+
+	__syncthreads();
 
 	for (int i = id; i &lt; valid_points_num; i += stride) {
 		int pid = valid_points[i];
@@ -438,27 +334,30 @@ extern "C" __global__ void computePointHessian1(float *x, float *y, float *z, in
 		double o_y = static_cast&lt;double&gt;(y[pid]);
 		double o_z = static_cast&lt;double&gt;(z[pid]);
 
-		MatrixDevice ph(18, 6, valid_points_num, point_hessians + i);		//18x6 Matrix
+		ph124[i] = o_x * h_ang[0] + o_y * h_ang[1] + o_z * h_ang[2];
+		ph134[i] = o_x * h_ang[3] + o_y * h_ang[4] + o_z * h_ang[5];
+		ph144[i] = o_x * h_ang[6] + o_y * h_ang[7] + o_z * h_ang[8];
 
-		ph(15, 3) = ph(9, 5) = 0;
-		ph(16, 3) = ph(10, 5) = o_x * h_ang_c2(0) + o_y * h_ang_c2(1) + o_z * h_ang_c2(2);
-		ph(17, 3) = ph(11, 5) = o_x * h_ang_c3(0) + o_y * h_ang_c3(1) + o_z * h_ang_c3(2);
-
-		ph(12, 4) = o_x * h_ang_d1(0) + o_y * h_ang_d1(1) + o_z * h_ang_d1(2);
-		ph(13, 4) = o_x * h_ang_d2(0) + o_y * h_ang_d2(1) + o_z * h_ang_d2(2);
-		ph(14, 4) = o_x * h_ang_d3(0) + o_y * h_ang_d3(1) + o_z * h_ang_d3(2);
+		ph154[i] = ph125[i] = o_x * h_ang[9] + o_y * h_ang[10] + o_z * h_ang[11];
+		ph164[i] = ph135[i] = o_x * h_ang[12] + o_y * h_ang[13] + o_z * h_ang[14];
+		ph174[i] = ph145[i] = o_x * h_ang[15] + o_y * h_ang[16] + o_z * h_ang[17];
 	}
 }
 
-/* Final step of computing point hessians */
-extern "C" __global__ void computePointHessian2(float *x, float *y, float *z, int points_num,
+__global__ void computePointHessian2(float *x, float *y, float *z, int points_num,
 												int *valid_points, int valid_points_num,
-												MatrixDevice h_ang_e1, MatrixDevice h_ang_e2, MatrixDevice h_ang_e3,
-												MatrixDevice h_ang_f1, MatrixDevice h_ang_f2, MatrixDevice h_ang_f3,
-												double *point_hessians)
+												double *dh_ang,
+												double *ph155, double *ph165, double *ph175)
 {
 	int id = threadIdx.x + blockIdx.x * blockDim.x;
 	int stride = blockDim.x * gridDim.x;
+	__shared__ double h_ang[9];
+
+	if (threadIdx.x &lt; 9) {
+		h_ang[threadIdx.x] = dh_ang[36 + threadIdx.x];
+	}
+
+	__syncthreads();
 
 	for (int i = id; i &lt; valid_points_num; i += stride) {
 		int pid = valid_points[i];
@@ -468,22 +367,17 @@ extern "C" __global__ void computePointHessian2(float *x, float *y, float *z, in
 		double o_y = static_cast&lt;double&gt;(y[pid]);
 		double o_z = static_cast&lt;double&gt;(z[pid]);
 
-		MatrixDevice ph(18, 6, valid_points_num, point_hessians + i);		//18x6 Matrix
-
-		ph(15, 4) = ph(12, 5) = o_x * h_ang_e1(0) + o_y * h_ang_e1(1) + o_z * h_ang_e1(2);
-		ph(16, 4) = ph(13, 5) = o_x * h_ang_e2(0) + o_y * h_ang_e2(1) + o_z * h_ang_e2(2);
-		ph(17, 4) = ph(14, 5) = o_x * h_ang_e3(0) + o_y * h_ang_e3(1) + o_z * h_ang_e3(2);
+		ph155[i] = o_x * h_ang[0] + o_y * h_ang[1] + o_z * h_ang[2];
+		ph165[i] = o_x * h_ang[3] + o_y * h_ang[4] + o_z * h_ang[5];
+		ph175[i] = o_x * h_ang[6] + o_y * h_ang[7] + o_z * h_ang[8];
 
-		ph(15, 5) = o_x * h_ang_f1(0) + o_y * h_ang_f1(1) + o_z * h_ang_f1(2);
-		ph(16, 5) = o_x * h_ang_f2(0) + o_y * h_ang_f2(1) + o_z * h_ang_f2(2);
-		ph(17, 5) = o_x * h_ang_f3(0) + o_y * h_ang_f3(1) + o_z * h_ang_f3(2);
 	}
 }
 
 /* compute score_inc list for input points.
  * The final score_inc is calculated by a reduction sum
  * on this score_inc list. */
-extern "C" __global__ void computeScoreList(int *starting_voxel_id, int *voxel_id, int valid_points_num,
+__global__ void computeScoreList(int *starting_voxel_id, int *voxel_id, int valid_points_num,
 												double *e_x_cov_x, double gauss_d1, double *score)
 {
 	int id = threadIdx.x + blockIdx.x * blockDim.x;
@@ -494,7 +388,6 @@ extern "C" __global__ void computeScoreList(int *starting_voxel_id, int *voxel_i
 		double score_inc = 0;
 
 		for (int vid = starting_voxel_id[i]; vid &lt; starting_voxel_id[i + 1]; vid++) {
-			//Transformed coordinates
 			double tmp_ex = e_x_cov_x[vid];
 
 			score_inc += (tmp_ex &gt; 1 || tmp_ex &lt; 0 || tmp_ex != tmp_ex) ? 0 : -gauss_d1 * tmp_ex;
@@ -505,10 +398,11 @@ extern "C" __global__ void computeScoreList(int *starting_voxel_id, int *voxel_i
 }
 
 /* First step to compute score gradient list for input points */
-extern "C" __global__ void computeScoreGradientList(float *trans_x, float *trans_y, float *trans_z,
+__global__ void computeScoreGradientList(float *trans_x, float *trans_y, float *trans_z,
 														int *valid_points,
 														int *starting_voxel_id, int *voxel_id, int valid_points_num,
-														double *centroid, int voxel_num, double *e_x_cov_x,
+														double *centroid_x, double *centroid_y, double *centroid_z,
+														int voxel_num, double *e_x_cov_x,
 														double *cov_dxd_pi, double gauss_d1, int valid_voxel_num,
 														double *score_gradients)
 {
@@ -516,108 +410,73 @@ extern "C" __global__ void computeScoreGradientList(float *trans_x, float *trans
 	int stride = blockDim.x * gridDim.x;
 	int col = blockIdx.y;
 
-	for (int i = id; i &lt; valid_points_num &amp;&amp; col &lt; 6; i += stride) {
-		int pid = valid_points[i];
-
-		MatrixDevice sg(6, 1, valid_points_num, score_gradients + i);		//6x1 Matrix
+	if (col &lt; 6) {
+		double *sg = score_gradients + col * valid_points_num;
+		double *cov_dxd_pi_mat0 = cov_dxd_pi + col * valid_voxel_num;
+		double *cov_dxd_pi_mat1 = cov_dxd_pi_mat0 + 6 * valid_voxel_num;
+		double *cov_dxd_pi_mat2 = cov_dxd_pi_mat1 + 6 * valid_voxel_num;
 
-		for ( int vid = starting_voxel_id[i]; vid &lt; starting_voxel_id[i + 1]; vid++) {
-			//Transformed coordinates
-			double t_x = static_cast&lt;double&gt;(trans_x[pid]);
-			double t_y = static_cast&lt;double&gt;(trans_y[pid]);
-			double t_z = static_cast&lt;double&gt;(trans_z[pid]);
-			MatrixDevice centr(3, 1, voxel_num, centroid + voxel_id[vid]);
-			MatrixDevice cov_dxd_pi_mat(3, 6, valid_voxel_num, cov_dxd_pi + vid);
+		for (int i = id; i &lt; valid_points_num; i += stride) {
+			int pid = valid_points[i];
+			double d_x = static_cast&lt;double&gt;(trans_x[pid]);
+			double d_y = static_cast&lt;double&gt;(trans_y[pid]);
+			double d_z = static_cast&lt;double&gt;(trans_z[pid]);
 
-			t_x -= centr(0);
-			t_y -= centr(1);
-			t_z -= centr(2);
+			double tmp_sg = 0.0;
 
-			double tmp_ex = e_x_cov_x[vid];
+			for ( int j = starting_voxel_id[i]; j &lt; starting_voxel_id[i + 1]; j++) {
+				int vid = voxel_id[j];
+				double tmp_ex = e_x_cov_x[j];
 
-			if (!(tmp_ex &gt; 1 || tmp_ex &lt; 0 || tmp_ex != tmp_ex)) {
-				tmp_ex *= gauss_d1;
+				if (!(tmp_ex &gt; 1 || tmp_ex &lt; 0 || tmp_ex != tmp_ex)) {
+					tmp_ex *= gauss_d1;
 
-				sg(col) += (t_x * cov_dxd_pi_mat(0, col) + t_y * cov_dxd_pi_mat(1, col) + t_z * cov_dxd_pi_mat(2, col)) * tmp_ex;
+					tmp_sg += ((d_x - centroid_x[vid]) * cov_dxd_pi_mat0[j] + (d_y - centroid_y[vid]) * cov_dxd_pi_mat1[j] + (d_z - centroid_z[vid]) * cov_dxd_pi_mat2[j]) * tmp_ex;
+				}
 			}
-		}
-	}
-}
 
-/* Second step to compute score gradient list */
-extern "C" __global__ void computeScoreGradientListS2(float *trans_x, float *trans_y, float *trans_z,
-														int *valid_points,
-														int *starting_voxel_id, int *voxel_id, int valid_points_num,
-														double *centroid, int voxel_num, double *e_x_cov_x,
-														double *cov_dxd_pi, double gauss_d1, int valid_voxel_num,
-														double *score_gradients)
-{
-	int id = threadIdx.x + blockIdx.x * blockDim.x;
-	int stride = blockDim.x * gridDim.x;
-
-	for (int i = id; i &lt; valid_points_num; i += stride) {
-		int pid = valid_points[i];
-
-		MatrixDevice sg(6, 1, valid_points_num, score_gradients + i);		//6x1 Matrix
-
-		for ( int vid = starting_voxel_id[i]; vid &lt; starting_voxel_id[i + 1]; vid++) {
-			//Transformed coordinates
-			double t_x = static_cast&lt;double&gt;(trans_x[pid]);
-			double t_y = static_cast&lt;double&gt;(trans_y[pid]);
-			double t_z = static_cast&lt;double&gt;(trans_z[pid]);
-			MatrixDevice centr(3, 1, voxel_num, centroid + voxel_id[vid]);
-			MatrixDevice cov_dxd_pi_mat(3, 6, valid_voxel_num, cov_dxd_pi + vid);
-
-			t_x -= centr(0);
-			t_y -= centr(1);
-			t_z -= centr(2);
-
-			double tmp_ex = e_x_cov_x[vid];
-
-			if (!(tmp_ex &gt; 1 || tmp_ex &lt; 0 || tmp_ex != tmp_ex)) {
-				tmp_ex *= gauss_d1;
-
-				for (int col = 0; col &lt; 6; col++)
-					sg(col) += (t_x * cov_dxd_pi_mat(0, col) + t_y * cov_dxd_pi_mat(1, col) + t_z * cov_dxd_pi_mat(2, col)) * tmp_ex;
-			}
+			sg[i] = tmp_sg;
 		}
 	}
 }
 
 /* Intermediate step to compute e_x_cov_x */
-extern "C" __global__ void computeExCovX(float *trans_x, float *trans_y, float *trans_z, int *valid_points,
+__global__ void computeExCovX(float *trans_x, float *trans_y, float *trans_z, int *valid_points,
 											int *starting_voxel_id, int *voxel_id, int valid_points_num,
-											double *centroid, double *inverse_covariance, int voxel_num,
+											double *centr_x, double *centr_y, double *centr_z,
 											double gauss_d1, double gauss_d2,
-											double *e_x_cov_x)
+											double *e_x_cov_x,
+											double *icov00, double *icov01, double *icov02,
+											double *icov10, double *icov11, double *icov12,
+											double *icov20, double *icov21, double *icov22)
 {
 	int id = threadIdx.x + blockIdx.x * blockDim.x;
 	int stride = blockDim.x * gridDim.x;
 
 	for (int i = id; i &lt; valid_points_num; i += stride) {
 		int pid = valid_points[i];
+		double d_x = static_cast&lt;double&gt;(trans_x[pid]);
+		double d_y = static_cast&lt;double&gt;(trans_y[pid]);
+		double d_z = static_cast&lt;double&gt;(trans_z[pid]);
+		double t_x, t_y, t_z;
+
+
+		for ( int j = starting_voxel_id[i]; j &lt; starting_voxel_id[i + 1]; j++) {
+			int vid = voxel_id[j];
 
-		for ( int vid = starting_voxel_id[i]; vid &lt; starting_voxel_id[i + 1]; vid++) {
-			//Transformed coordinates
-			double t_x = static_cast&lt;double&gt;(trans_x[pid]);
-			double t_y = static_cast&lt;double&gt;(trans_y[pid]);
-			double t_z = static_cast&lt;double&gt;(trans_z[pid]);
-			MatrixDevice centr(3, 1, voxel_num, centroid + voxel_id[vid]);
-			MatrixDevice icov(3, 3, voxel_num, inverse_covariance + voxel_id[vid]);	//3x3 matrix
-
-			t_x -= centr(0);
-			t_y -= centr(1);
-			t_z -= centr(2);
-
-			e_x_cov_x[vid] =  exp(-gauss_d2 * ((t_x * icov(0, 0) + t_y * icov(0, 1) + t_z * icov(0, 2)) * t_x
-										+ ((t_x * icov(1, 0) + t_y * icov(1, 1) + t_z * icov(1, 2)) * t_y)
-										+ ((t_x * icov(2, 0) + t_y * icov(2, 1) + t_z * icov(2, 2)) * t_z)) / 2.0);
+			t_x = d_x - centr_x[vid];
+			t_y = d_y - centr_y[vid];
+			t_z = d_z - centr_z[vid];
+
+			e_x_cov_x[j] =  exp(-gauss_d2 * ((t_x * icov00[vid] + t_y * icov01[vid] + t_z * icov02[vid]) * t_x
+										+ ((t_x * icov10[vid] + t_y * icov11[vid] + t_z * icov12[vid]) * t_y)
+										+ ((t_x * icov20[vid] + t_y * icov21[vid] + t_z * icov22[vid]) * t_z)) / 2.0);
 		}
 	}
 }
 
 /* update e_x_cov_x - Reusable portion of Equation 6.12 and 6.13 [Magnusson 2009] */
-extern "C" __global__ void updateExCovX(double *e_x_cov_x, double gauss_d2, int valid_voxel_num)
+__global__ void updateExCovX(double *e_x_cov_x, double gauss_d2, int valid_voxel_num)
 {
 	int id = threadIdx.x + blockIdx.x * blockDim.x;
 	int stride = blockDim.x * gridDim.x;
@@ -628,7 +487,7 @@ extern "C" __global__ void updateExCovX(double *e_x_cov_x, double gauss_d2, int
 }
 
 /* compute cov_dxd_pi as reusable portion of Equation 6.12 and 6.13 [Magnusson 2009]*/
-extern "C" __global__ void computeCovDxdPi(int *valid_points, int *starting_voxel_id, int *voxel_id, int valid_points_num,
+__global__ void computeCovDxdPi(int *valid_points, int *starting_voxel_id, int *voxel_id, int valid_points_num,
 											double *inverse_covariance, int voxel_num,
 											double gauss_d1, double gauss_d2, double *point_gradients,
 											double *cov_dxd_pi, int valid_voxel_num)
@@ -638,127 +497,81 @@ extern "C" __global__ void computeCovDxdPi(int *valid_points, int *starting_voxe
 	int row = blockIdx.y;
 	int col = blockIdx.z;
 
-	for (int i = id; i &lt; valid_points_num &amp;&amp; row &lt; 3 &amp;&amp; col &lt; 6; i += stride) {
-		MatrixDevice pg(3, 6, valid_points_num, point_gradients + i);		//3x6 Matrix
+	if (row &lt; 3 &amp;&amp; col &lt; 6) {
+		double *icov0 = inverse_covariance + row * 3 * voxel_num;
+		double *icov1 = icov0 + voxel_num;
+		double *icov2 = icov1 + voxel_num;
+		double *cov_dxd_pi_tmp = cov_dxd_pi + (row * 6 + col) * valid_voxel_num;
+		double *pg_tmp0 = point_gradients + col * valid_points_num;
+		double *pg_tmp1 = pg_tmp0 + 6 * valid_points_num;
+		double *pg_tmp2 = pg_tmp1 + 6 * valid_points_num;
 
-		for ( int vid = starting_voxel_id[i]; vid &lt; starting_voxel_id[i + 1]; vid++) {
-			//Transformed coordinates
-			MatrixDevice icov(3, 3, voxel_num, inverse_covariance + voxel_id[vid]);	//3x3 matrix
-			MatrixDevice cov_dxd_pi_mat(3, 6, valid_voxel_num, cov_dxd_pi + vid);
+		for (int i = id; i &lt; valid_points_num; i += stride) {
+			double pg0 = pg_tmp0[i];
+			double pg1 = pg_tmp1[i];
+			double pg2 = pg_tmp2[i];
 
-			cov_dxd_pi_mat(row, col) = icov(row, 0) * pg(0, col) + icov(row, 1) * pg(1, col) + icov(row, 2) * pg(2, col);
-		}
-	}
-}
+			for ( int j = starting_voxel_id[i]; j &lt; starting_voxel_id[i + 1]; j++) {
+				int vid = voxel_id[j];
 
-/* First step to compute hessian list for input points */
-extern "C" __global__ void computeHessianListS0(float *trans_x, float *trans_y, float *trans_z,
-													int *valid_points,
-													int *starting_voxel_id, int *voxel_id, int valid_points_num,
-													double *centroid, double *inverse_covariance, int voxel_num,
-													double gauss_d1, double gauss_d2,
-													double *point_gradients,
-													double *tmp_hessian, int valid_voxel_num)
-{
-	int id = threadIdx.x + blockIdx.x * blockDim.x;
-	int stride = blockDim.x * gridDim.x;
-	int col = blockIdx.y;
-
-	for (int i = id; i &lt; valid_points_num &amp;&amp; col &lt; 6; i += stride) {
-		int pid = valid_points[i];
-
-		MatrixDevice pg(3, 6, valid_points_num, point_gradients + i);		//3x6 Matrix
-
-		for ( int j = starting_voxel_id[i]; j &lt; starting_voxel_id[i + 1]; j++) {
-			//Transformed coordinates
-			int vid = voxel_id[j];
-			double t_x = static_cast&lt;double&gt;(trans_x[pid]);
-			MatrixDevice centr(3, 1, voxel_num, centroid + vid);
-			MatrixDevice icov(3, 3, voxel_num, inverse_covariance + vid);	//3x3 matrix
-			MatrixDevice tmp(6, 1, valid_voxel_num, tmp_hessian + j);
-
-			t_x -= centr(0);
-
-			tmp(col) = t_x * (icov(0, 0) * pg(0, col) + icov(0, 1) * pg(1, col) + icov(0, 2) * pg(2, col));
-		}
+				cov_dxd_pi_tmp[j] = icov0[vid] * pg0 + icov1[vid] * pg1 + icov2[vid] * pg2;
+			}
 	}
-}
-
-/* Second step to compute hessian list for input points */
-extern "C" __global__ void computeHessianListS1(float *trans_x, float *trans_y, float *trans_z,
-													int *valid_points,
-													int *starting_voxel_id, int *voxel_id, int valid_points_num,
-													double *centroid, double *inverse_covariance, int voxel_num,
-													double gauss_d1, double gauss_d2,
-													double *point_gradients,
-													double *tmp_hessian, int valid_voxel_num)
-{
-	int id = threadIdx.x + blockIdx.x * blockDim.x;
-	int stride = blockDim.x * gridDim.x;
-	int col = blockIdx.y;
-
-	for (int i = id; i &lt; valid_points_num &amp;&amp; col &lt; 6; i += stride) {
-		int pid = valid_points[i];
-
-		MatrixDevice pg(3, 6, valid_points_num, point_gradients + i);		//3x6 Matrix
-
-		for ( int j = starting_voxel_id[i]; j &lt; starting_voxel_id[i + 1]; j++) {
-			//Transformed coordinates
-			int vid = voxel_id[j];
-			double t_y = static_cast&lt;double&gt;(trans_y[pid]);
-			MatrixDevice centr(3, 1, voxel_num, centroid + vid);
-			MatrixDevice icov(3, 3, voxel_num, inverse_covariance + vid);	//3x3 matrix
-			MatrixDevice tmp(6, 1, valid_voxel_num, tmp_hessian + j);
-
-			t_y -= centr(1);
-
-			tmp(col) += t_y * (icov(1, 0) * pg(0, col) + icov(1, 1) * pg(1, col) + icov(1, 2) * pg(2, col));
-		}
 	}
 }
 
 
-/* Third step to compute hessian list for input points */
-extern "C" __global__ void computeHessianListS2(float *trans_x, float *trans_y, float *trans_z,
+/* First step to compute hessian list for input points */
+__global__ void computeHessianListS0(float *trans_x, float *trans_y, float *trans_z,
 													int *valid_points,
 													int *starting_voxel_id, int *voxel_id, int valid_points_num,
-													double *centroid, double *inverse_covariance, int voxel_num,
-													double gauss_d1, double gauss_d2,
-													double *point_gradients,
-													double *tmp_hessian, int valid_voxel_num)
+													double *centroid_x, double *centroid_y, double *centroid_z,
+													double *icov00, double *icov01, double *icov02,
+													double *icov10, double *icov11, double *icov12,
+													double *icov20, double *icov21, double *icov22,
+													double *point_gradients0, double *point_gradients1, double *point_gradients2,
+													double *tmp_hessian,
+													int valid_voxel_num)
 {
 	int id = threadIdx.x + blockIdx.x * blockDim.x;
 	int stride = blockDim.x * gridDim.x;
 	int col = blockIdx.y;
 
-	for (int i = id; i &lt; valid_points_num &amp;&amp; col &lt; 6; i += stride) {
-		int pid = valid_points[i];
+	if (col &lt; 6) {
+		double *tmp_pg0 = point_gradients0 + col * valid_points_num;
+		double *tmp_pg1 = point_gradients1 + 6 * valid_points_num;
+		double *tmp_pg2 = point_gradients2 + 6 * valid_points_num;
+		double *tmp_h = tmp_hessian + col * valid_voxel_num;
 
-		MatrixDevice pg(3, 6, valid_points_num, point_gradients + i);		//3x6 Matrix
+		for (int i = id; i &lt; valid_points_num &amp;&amp; col &lt; 6; i += stride) {
+			int pid = valid_points[i];
+			double d_x = static_cast&lt;double&gt;(trans_x[pid]);
+			double d_y = static_cast&lt;double&gt;(trans_y[pid]);
+			double d_z = static_cast&lt;double&gt;(trans_z[pid]);
 
-		for ( int j = starting_voxel_id[i]; j &lt; starting_voxel_id[i + 1]; j++) {
-			//Transformed coordinates
-			int vid = voxel_id[j];
-			double t_z = static_cast&lt;double&gt;(trans_z[pid]);
-			MatrixDevice centr(3, 1, voxel_num, centroid + vid);
-			MatrixDevice icov(3, 3, voxel_num, inverse_covariance + vid);	//3x3 matrix
-			MatrixDevice tmp(6, 1, valid_voxel_num, tmp_hessian + j);
+			double pg0 = tmp_pg0[i];
+			double pg1 = tmp_pg1[i];
+			double pg2 = tmp_pg2[i];
 
-			t_z -= centr(2);
+			for ( int j = starting_voxel_id[i]; j &lt; starting_voxel_id[i + 1]; j++) {
+				int vid = voxel_id[j];
 
-			tmp(col) += t_z * (icov(2, 0) * pg(0, col) + icov(2, 1) * pg(1, col) + icov(2, 2) * pg(2, col));
-		}
+				tmp_h[j] = (d_x - centroid_x[vid]) * (icov00[vid] * pg0 + icov01[vid] * pg1 + icov02[vid] * pg2)
+							+ (d_y - centroid_y[vid]) * (icov10[vid] * pg0 + icov11[vid] * pg1 + icov12[vid] * pg2)
+							+ (d_z - centroid_z[vid]) * (icov20[vid] * pg0 + icov21[vid] * pg1 + icov22[vid] * pg2);
+			}
+	}
 	}
 }
 
 /* Fourth step to compute hessian list */
-extern "C" __global__ void computeHessianListS3(float *trans_x, float *trans_y, float *trans_z,
+__global__ void computeHessianListS1(float *trans_x, float *trans_y, float *trans_z,
 												int *valid_points,
 												int *starting_voxel_id, int *voxel_id, int valid_points_num,
-												double *centroid, int voxel_num,
-												double gauss_d1, double gauss_d2,
-												double *hessians,
+												double *centroid_x, double *centroid_y, double *centroid_z,
+												double gauss_d1, double gauss_d2, double *hessians,
 												double *e_x_cov_x, double *tmp_hessian, double *cov_dxd_pi,
+												double *point_gradients,
 												int valid_voxel_num)
 {
 	int id = threadIdx.x + blockIdx.x * blockDim.x;
@@ -766,198 +579,107 @@ extern "C" __global__ void computeHessianListS3(float *trans_x, float *trans_y,
 	int row = blockIdx.y;
 	int col = blockIdx.z;
 
-	for (int i = id; i &lt; valid_points_num &amp;&amp; row &lt; 6 &amp;&amp; col &lt; 6; i += stride) {
-		int pid = valid_points[i];
+	if (row &lt; 6 &amp;&amp; col &lt; 6) {
+		double *cov_dxd_pi_mat0 = cov_dxd_pi + row * valid_voxel_num;
+		double *cov_dxd_pi_mat1 = cov_dxd_pi_mat0 + 6 * valid_voxel_num;
+		double *cov_dxd_pi_mat2 = cov_dxd_pi_mat1 + 6 * valid_voxel_num;
+		double *tmp_h = tmp_hessian + col * valid_voxel_num;
+		double *h = hessians + (row * 6 + col) * valid_points_num;
+		double *tmp_pg0 = point_gradients + col * valid_points_num;
+		double *tmp_pg1 = tmp_pg0 + 6 * valid_points_num;
+		double *tmp_pg2 = tmp_pg1 + 6 * valid_points_num;
 
-		MatrixDevice h(6, 6, valid_points_num, hessians + i);				//6x6 Matrix
+		for (int i = id; i &lt; valid_points_num; i += stride) {
+			int pid = valid_points[i];
+			double d_x = static_cast&lt;double&gt;(trans_x[pid]);
+			double d_y = static_cast&lt;double&gt;(trans_y[pid]);
+			double d_z = static_cast&lt;double&gt;(trans_z[pid]);
 
-		for ( int j = starting_voxel_id[i]; j &lt; starting_voxel_id[i + 1]; j++) {
-			//Transformed coordinates
-			double t_x = static_cast&lt;double&gt;(trans_x[pid]);
-			double t_y = static_cast&lt;double&gt;(trans_y[pid]);
-			double t_z = static_cast&lt;double&gt;(trans_z[pid]);
-			MatrixDevice centr(3, 1, voxel_num, centroid + voxel_id[j]);
-			MatrixDevice tmp(6, 1, valid_voxel_num, tmp_hessian + j);
-			MatrixDevice cov_dxd_pi_mat(3, 6, valid_voxel_num, cov_dxd_pi + j);
+			double pg0 = tmp_pg0[i];
+			double pg1 = tmp_pg1[i];
+			double pg2 = tmp_pg2[i];
 
-			t_x -= centr(0);
-			t_y -= centr(1);
-			t_z -= centr(2);
+			double final_hessian = 0.0;
 
-			double tmp_ex, tmp_cov_dxd_x, tmp_cov_dxd_y, tmp_cov_dxd_z;
+			for ( int j = starting_voxel_id[i]; j &lt; starting_voxel_id[i + 1]; j++) {
+				//Transformed coordinates
+				int vid = voxel_id[j];
 
-			tmp_ex = e_x_cov_x[j];
+				double tmp_ex = e_x_cov_x[j];
 
-			if (!(tmp_ex &gt; 1 || tmp_ex &lt; 0 || tmp_ex != tmp_ex)) {
-				tmp_ex *= gauss_d1;
+				if (!(tmp_ex &gt; 1 || tmp_ex &lt; 0 || tmp_ex != tmp_ex)) {
+					double cov_dxd0 = cov_dxd_pi_mat0[j];
+					double cov_dxd1 = cov_dxd_pi_mat1[j];
+					double cov_dxd2 = cov_dxd_pi_mat2[j];
 
-				tmp_cov_dxd_x = cov_dxd_pi_mat(0, row);
-				tmp_cov_dxd_y = cov_dxd_pi_mat(1, row);
-				tmp_cov_dxd_z = cov_dxd_pi_mat(2, row);
+					tmp_ex *= gauss_d1;
 
-				h(row, col) += -gauss_d2 * (t_x * tmp_cov_dxd_x + t_y * tmp_cov_dxd_y + t_z * tmp_cov_dxd_z) * tmp(col) * tmp_ex;
+					final_hessian += -gauss_d2 * ((d_x - centroid_x[vid]) * cov_dxd0 + (d_y - centroid_y[vid]) * cov_dxd1 + (d_z - centroid_z[vid]) * cov_dxd2) * tmp_h[j] * tmp_ex;
+					final_hessian += (pg0 * cov_dxd0 + pg1 * cov_dxd1 + pg2 * cov_dxd2) * tmp_ex;
+				}
 			}
+
+			h[i] = final_hessian;
 		}
 	}
 }
 
-/* Fifth step to compute hessian list */
-extern "C" __global__ void computeHessianListS4(float *trans_x, float *trans_y, float *trans_z,
-													int *valid_points,
-													int *starting_voxel_id, int *voxel_id, int valid_points_num,
-													double *centroid, double *inverse_covariance, int voxel_num,
-													double gauss_d1, double gauss_d2,
-													double *point_hessians, double *hessians,
-													double *e_x_cov_x)
+__global__ void computeHessianListS2(float *trans_x, float *trans_y, float *trans_z,
+												int *valid_points,
+												int *starting_voxel_id, int *voxel_id, int valid_points_num,
+												double *centroid_x, double *centroid_y, double *centroid_z,
+												double gauss_d1, double *e_x_cov_x,
+												double *icov00, double *icov01, double *icov02,
+												double *icov10, double *icov11, double *icov12,
+												double *icov20, double *icov21, double *icov22,
+												double *point_hessians, double *hessians,
+												int valid_voxel_num)
 {
 	int id = threadIdx.x + blockIdx.x * blockDim.x;
 	int stride = blockDim.x * gridDim.x;
 	int row = blockIdx.y;
 	int col = blockIdx.z;
 
-	for (int i = id; i &lt; valid_points_num &amp;&amp; row &lt; 6 &amp;&amp; col &lt; 6; i += stride) {
-		int pid = valid_points[i];
-
-		MatrixDevice ph(18, 6, valid_points_num, point_hessians + i);		//18x6 Matrix
-		MatrixDevice h(6, 6, valid_points_num, hessians + i);				//6x6 Matrix
+	if (row &lt; 6 &amp;&amp; col &lt; 6) {
+		double *h = hessians + (row * 6 + col) * valid_points_num;
+		double *tmp_ph0 = point_hessians + ((3 * row) * 6 + col) * valid_points_num;
+		double *tmp_ph1 = tmp_ph0 + 6 * valid_points_num;
+		double *tmp_ph2 = tmp_ph1 + 6 * valid_points_num;
 
-		for ( int vid = starting_voxel_id[i]; vid &lt; starting_voxel_id[i + 1]; vid++) {
-			//Transformed coordinates
-			double t_x = static_cast&lt;double&gt;(trans_x[pid]);
-			MatrixDevice centr(3, 1, voxel_num, centroid + voxel_id[vid]);
-			MatrixDevice icov(3, 3, voxel_num, inverse_covariance + voxel_id[vid]);	//3x3 matrix
+		for (int i = id; i &lt; valid_points_num; i += stride) {
+			int pid = valid_points[i];
+			double d_x = static_cast&lt;double&gt;(trans_x[pid]);
+			double d_y = static_cast&lt;double&gt;(trans_y[pid]);
+			double d_z = static_cast&lt;double&gt;(trans_z[pid]);
+			double ph0 = tmp_ph0[i];
+			double ph1 = tmp_ph1[i];
+			double ph2 = tmp_ph2[i];
 
-			t_x -= centr(0);
+			double final_hessian = h[i];
 
-			double tmp_ex = e_x_cov_x[vid];	//e_x_cov_x
+			for ( int j = starting_voxel_id[i]; j &lt; starting_voxel_id[i + 1]; j++) {
+				//Transformed coordinates
+				int vid = voxel_id[j];
+				double tmp_ex = e_x_cov_x[j];
 
-			if (!(tmp_ex &gt; 1 || tmp_ex &lt; 0 || tmp_ex != tmp_ex)) {
-				tmp_ex *= gauss_d1;
-						//Compute hessian
-				h(row, col) += t_x * (icov(0, 0) * ph(3 * row, col) + icov(0, 1) * ph(3 * row + 1, col) + icov(0, 2) * ph(3 * row + 2, col)) * tmp_ex;
-			}
-		}
-	}
-}
+				if (!(tmp_ex &gt; 1 || tmp_ex &lt; 0 || tmp_ex != tmp_ex)) {
+					tmp_ex *= gauss_d1;
 
-/* Sixth step to compute hessian list */
-extern "C" __global__ void computeHessianListS5(float *trans_x, float *trans_y, float *trans_z,
-													int *valid_points,
-													int *starting_voxel_id, int *voxel_id, int valid_points_num,
-													double *centroid, double *inverse_covariance, int voxel_num,
-													double gauss_d1, double gauss_d2,
-													double *point_hessians, double *hessians,
-													double *e_x_cov_x)
-{
-	int id = threadIdx.x + blockIdx.x * blockDim.x;
-	int row = blockIdx.y;
-	int col = blockIdx.z;
-	int stride = blockDim.x * gridDim.x;
+					final_hessian += (d_x - centroid_x[vid]) * (icov00[vid] * ph0 + icov01[vid] * ph1 + icov02[vid] * ph2) * tmp_ex;
+					final_hessian += (d_y - centroid_y[vid]) * (icov10[vid] * ph0 + icov11[vid] * ph1 + icov12[vid] * ph2) * tmp_ex;
+					final_hessian += (d_z - centroid_z[vid]) * (icov20[vid] * ph0 + icov21[vid] * ph1 + icov22[vid] * ph2) * tmp_ex;
 
-	for (int i = id; i &lt; valid_points_num &amp;&amp; row &lt; 6 &amp;&amp; col &lt; 6; i += stride) {
-		int pid = valid_points[i];
-
-		MatrixDevice ph(18, 6, valid_points_num, point_hessians + i);		//18x6 Matrix
-		MatrixDevice h(6, 6, valid_points_num, hessians + i);				//6x6 Matrix
-
-		for ( int vid = starting_voxel_id[i]; vid &lt; starting_voxel_id[i + 1]; vid++) {
-			//Transformed coordinates
-			double t_y = static_cast&lt;double&gt;(trans_y[pid]);
-			MatrixDevice centr(3, 1, voxel_num, centroid + voxel_id[vid]);
-			MatrixDevice icov(3, 3, voxel_num, inverse_covariance + voxel_id[vid]);	//3x3 matrix
-
-			t_y -= centr(1);
-
-			double tmp_ex = e_x_cov_x[vid];	//e_x_cov_x
-
-			if (!(tmp_ex &gt; 1 || tmp_ex &lt; 0 || tmp_ex != tmp_ex)) {
-				tmp_ex *= gauss_d1;
-				//Compute hessian
-				h(row, col) += t_y * (icov(1, 0) * ph(3 * row, col) + icov(1, 1) * ph(3 * row + 1, col) + icov(1, 2) * ph(3 * row + 2, col)) * tmp_ex;
+				}
 			}
-		}
-	}
-}
-
-/* Seventh step to compute hessian list */
-extern "C" __global__ void computeHessianListS6(float *trans_x, float *trans_y, float *trans_z,
-													int *valid_points,
-													int *starting_voxel_id, int *voxel_id, int valid_points_num,
-													double *centroid, double *inverse_covariance, int voxel_num,
-													double gauss_d1, double gauss_d2,
-													double *point_hessians, double *hessians,
-													double *e_x_cov_x)
-{
-	int id = threadIdx.x + blockIdx.x * blockDim.x;
-	int stride = blockDim.x * gridDim.x;
-	int row = blockIdx.y;
-	int col = blockIdx.z;
 
-	for (int i = id; i &lt; valid_points_num &amp;&amp; row &lt; 6 &amp;&amp; col &lt; 6; i += stride) {
-		int pid = valid_points[i];
-
-		MatrixDevice ph(18, 6, valid_points_num, point_hessians + i);		//18x6 Matrix
-		MatrixDevice h(6, 6, valid_points_num, hessians + i);				//6x6 Matrix
-
-		for ( int vid = starting_voxel_id[i]; vid &lt; starting_voxel_id[i + 1]; vid++) {
-			//Transformed coordinates
-			double t_z = static_cast&lt;double&gt;(trans_z[pid]);
-			MatrixDevice centr(3, 1, voxel_num, centroid + voxel_id[vid]);
-			MatrixDevice icov(3, 3, voxel_num, inverse_covariance + voxel_id[vid]);	//3x3 matrix
-
-			t_z -= centr(2);
-
-			double tmp_ex = e_x_cov_x[vid];	//e_x_cov_x
-
-			if (!(tmp_ex &gt; 1 || tmp_ex &lt; 0 || tmp_ex != tmp_ex)) {
-				tmp_ex *= gauss_d1;
-				//Compute hessian
-				h(row, col) += t_z * (icov(2, 0) * ph(3 * row, col) + icov(2, 1) * ph(3 * row + 1, col) + icov(2, 2) * ph(3 * row + 2, col)) * tmp_ex;
-			}
+			h[i] = final_hessian;
 		}
 	}
 }
 
-/* Eighth step to compute hessian list */
-extern "C" __global__ void computeHessianListS7(float *trans_x, float *trans_y, float *trans_z,
-													int *valid_points,
-													int *starting_voxel_id, int *voxel_id, int valid_points_num,
-													double gauss_d1, double gauss_d2,
-													double *point_gradients, double *hessians,
-													double *e_x_cov_x,
-													double *cov_dxd_pi, int valid_voxel_num)
-{
-	int id = threadIdx.x + blockIdx.x * blockDim.x;
-	int stride = blockDim.x * gridDim.x;
-	int row = blockIdx.y;
-	int col = blockIdx.z;
-
-	for (int i = id; i &lt; valid_points_num &amp;&amp; row &lt; 6 &amp;&amp; col &lt; 6; i += stride) {
-		MatrixDevice pg(3, 6, valid_points_num, point_gradients + i);
-		MatrixDevice h(6, 6, valid_points_num, hessians + i);				//6x6 Matrix
-
-		for ( int vid = starting_voxel_id[i]; vid &lt; starting_voxel_id[i + 1]; vid++) {
-			MatrixDevice cov_dxd_pi_mat(3, 6, valid_voxel_num, cov_dxd_pi + vid);
-			//Transformed coordinates
-			double tmp_ex = e_x_cov_x[vid];
-			double tmp_cov_dxd_x, tmp_cov_dxd_y, tmp_cov_dxd_z;
-
-			if (!(tmp_ex &gt; 1 || tmp_ex &lt; 0 || tmp_ex != tmp_ex)) {
-				tmp_ex *= gauss_d1;
-
-				tmp_cov_dxd_x = cov_dxd_pi_mat(0, row);
-				tmp_cov_dxd_y = cov_dxd_pi_mat(1, row);
-				tmp_cov_dxd_z = cov_dxd_pi_mat(2, row);
-
-				//Compute hessian
-				h(row, col) += (pg(0, col) * tmp_cov_dxd_x + pg(1, col) * tmp_cov_dxd_y + pg(2, col) * tmp_cov_dxd_z) * tmp_ex;
-			}
-		}
-	}
-}
 
 /* Compute sum of a list of matrices */
-extern "C" __global__ void matrixSum(double *matrix_list, int full_size, int half_size, int rows, int cols, int offset)
+__global__ void matrixSum(double *matrix_list, int full_size, int half_size, int rows, int cols, int offset)
 {
 	int index = threadIdx.x + blockIdx.x * blockDim.x;
 	int stride = blockDim.x * gridDim.x;
@@ -976,7 +698,7 @@ extern "C" __global__ void matrixSum(double *matrix_list, int full_size, int hal
 }
 
 /* Compute sum of score_inc list */
-extern "C" __global__ void sumScore(double *score, int full_size, int half_size)
+__global__ void sumScore(double *score, int full_size, int half_size)
 {
 	int index = threadIdx.x + blockIdx.x * blockDim.x;
 	int stride = blockDim.x * gridDim.x;
@@ -1025,61 +747,69 @@ double GNormalDistributionsTransform::computeDerivatives(Eigen::Matrix&lt;double, 6
 	double *gradients, *hessians, *point_gradients, *point_hessians, *score;
 
 	checkCudaErrors(cudaMalloc(&amp;gradients, sizeof(double) * valid_points_num * 6));
-	checkCudaErrors(cudaMemset(gradients, 0, sizeof(double) * valid_points_num * 6));
-
 	checkCudaErrors(cudaMalloc(&amp;hessians, sizeof(double) * valid_points_num * 6 * 6));
-	checkCudaErrors(cudaMemset(hessians, 0, sizeof(double) * valid_points_num * 6 * 6));
-
 	checkCudaErrors(cudaMalloc(&amp;point_gradients, sizeof(double) * valid_points_num * 3 * 6));
-	checkCudaErrors(cudaMemset(point_gradients, 0, sizeof(double) * valid_points_num * 3 * 6));
-
 	checkCudaErrors(cudaMalloc(&amp;point_hessians, sizeof(double) * valid_points_num * 18 * 6));
-	checkCudaErrors(cudaMemset(point_hessians, 0, sizeof(double) * valid_points_num * 18 * 6));
-
 	checkCudaErrors(cudaMalloc(&amp;score, sizeof(double) * valid_points_num));
 
+	checkCudaErrors(cudaMemset(gradients, 0, sizeof(double) * valid_points_num * 6));
+	checkCudaErrors(cudaMemset(hessians, 0, sizeof(double) * valid_points_num * 6 * 6));
+	checkCudaErrors(cudaMemset(point_gradients, 0, sizeof(double) * valid_points_num * 3 * 6));
+	checkCudaErrors(cudaMemset(point_hessians, 0, sizeof(double) * valid_points_num * 18 * 6));
+
 	int block_x = (valid_points_num &gt; BLOCK_SIZE_X) ? BLOCK_SIZE_X : valid_points_num;
 
 	int grid_x = (valid_points_num - 1) / block_x + 1;
 
 	dim3 grid;
 
-	computePointGradients0&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_number_,
+	computePointGradients&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_number_,
 												valid_points, valid_points_num,
-												dj_ang_a_, dj_ang_b_, dj_ang_c_, dj_ang_d_,
-												point_gradients);
-	checkCudaErrors(cudaGetLastError());
-
-	computePointGradients1&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_number_,
-												valid_points, valid_points_num,
-												dj_ang_e_, dj_ang_f_, dj_ang_g_, dj_ang_h_,
-												point_gradients);
+												dj_ang_.buffer(),
+												point_gradients,
+												point_gradients + valid_points_num * 7,
+												point_gradients + valid_points_num * 14,
+												point_gradients + valid_points_num * 9,
+												point_gradients + valid_points_num * 15,
+												point_gradients + valid_points_num * 4,
+												point_gradients + valid_points_num * 10,
+												point_gradients + valid_points_num * 16,
+												point_gradients + valid_points_num * 5,
+												point_gradients + valid_points_num * 11,
+												point_gradients + valid_points_num * 17);
 	checkCudaErrors(cudaGetLastError());
 
 	if (compute_hessian) {
 		computePointHessian0&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_number_,
 												valid_points, valid_points_num,
-												dh_ang_a2_, dh_ang_a3_,
-												dh_ang_b2_, dh_ang_b3_,
-												point_hessians);
+												dh_ang_.buffer(),
+												point_hessians + valid_points_num * 57, point_hessians + valid_points_num * 63, point_hessians + valid_points_num * 69,
+												point_hessians + valid_points_num * 75, point_hessians + valid_points_num * 58, point_hessians + valid_points_num * 81,
+												point_hessians + valid_points_num * 64, point_hessians + valid_points_num * 87, point_hessians + valid_points_num * 70,
+												point_hessians + valid_points_num * 93, point_hessians + valid_points_num * 59, point_hessians + valid_points_num * 99,
+												point_hessians + valid_points_num * 65, point_hessians + valid_points_num * 105, point_hessians + valid_points_num * 71);
+
 		checkCudaErrors(cudaGetLastError());
 
 		computePointHessian1&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_number_,
 												valid_points, valid_points_num,
-												dh_ang_c2_, dh_ang_c3_,
-												dh_ang_d1_, dh_ang_d2_, dh_ang_d3_,
-												point_hessians);
+												dh_ang_.buffer(),
+												point_hessians + valid_points_num * 76, point_hessians + valid_points_num * 82, point_hessians + valid_points_num * 88,
+												point_hessians + valid_points_num * 94, point_hessians + valid_points_num * 77, point_hessians + valid_points_num * 100,
+												point_hessians + valid_points_num * 83, point_hessians + valid_points_num * 106, point_hessians + valid_points_num * 89);
 		checkCudaErrors(cudaGetLastError());
 
 		computePointHessian2&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_number_,
 												valid_points, valid_points_num,
-												dh_ang_e1_, dh_ang_e2_, dh_ang_e3_,
-												dh_ang_f1_, dh_ang_f2_, dh_ang_f3_,
-												point_hessians);
+												dh_ang_.buffer(),
+												point_hessians + valid_points_num * 95, point_hessians + valid_points_num * 101, point_hessians + valid_points_num * 107);
 		checkCudaErrors(cudaGetLastError());
+
 	}
+
 	checkCudaErrors(cudaDeviceSynchronize());
 
+
 	double *tmp_hessian;
 
 	checkCudaErrors(cudaMalloc(&amp;tmp_hessian, sizeof(double) * valid_voxel_num * 6));
@@ -1094,9 +824,12 @@ double GNormalDistributionsTransform::computeDerivatives(Eigen::Matrix&lt;double, 6
 
 	computeExCovX&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
 										starting_voxel_id, voxel_id, valid_points_num,
-										centroid, inverse_covariance, voxel_num,
+										centroid, centroid + voxel_num, centroid + 2 * voxel_num,
 										gauss_d1_, gauss_d2_,
-										e_x_cov_x);
+										e_x_cov_x,
+										inverse_covariance, inverse_covariance + voxel_num, inverse_covariance + 2 * voxel_num,
+										inverse_covariance + 3 * voxel_num, inverse_covariance + 4 * voxel_num, inverse_covariance + 5 * voxel_num,
+										inverse_covariance + 6 * voxel_num, inverse_covariance + 7 * voxel_num, inverse_covariance + 8 * voxel_num);
 	checkCudaErrors(cudaGetLastError());
 
 	computeScoreList&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(starting_voxel_id, voxel_id, valid_points_num, e_x_cov_x, gauss_d1_, score);
@@ -1121,76 +854,52 @@ double GNormalDistributionsTransform::computeDerivatives(Eigen::Matrix&lt;double, 6
 	grid.x = grid_x;
 	grid.y = 6;
 	grid.z = 1;
+
 	computeScoreGradientList&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
 													starting_voxel_id, voxel_id, valid_points_num,
-													centroid, voxel_num, e_x_cov_x,
+													centroid, centroid + voxel_num, centroid + 2 * voxel_num,
+													voxel_num, e_x_cov_x,
 													cov_dxd_pi, gauss_d1_, valid_voxel_num, gradients);
+
 	checkCudaErrors(cudaGetLastError());
 
+
 	if (compute_hessian) {
+
 		grid.y = 6;
 		grid.z = 1;
-		computeHessianListS0&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
-													starting_voxel_id, voxel_id, valid_points_num,
-													centroid, inverse_covariance, voxel_num,
-													gauss_d1_, gauss_d2_,
-													point_gradients, tmp_hessian, valid_voxel_num);
-		checkCudaErrors(cudaGetLastError());
 
-		computeHessianListS1&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
-													starting_voxel_id, voxel_id, valid_points_num,
-													centroid, inverse_covariance, voxel_num,
-													gauss_d1_, gauss_d2_,
-													point_gradients, tmp_hessian, valid_voxel_num);
-		checkCudaErrors(cudaGetLastError());
 
-		computeHessianListS2&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
-													starting_voxel_id, voxel_id, valid_points_num,
-													centroid, inverse_covariance, voxel_num,
-													gauss_d1_, gauss_d2_,
-													point_gradients, tmp_hessian, valid_voxel_num);
+		computeHessianListS0&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
+												starting_voxel_id, voxel_id, valid_points_num,
+												centroid, centroid + voxel_num, centroid + 2 * voxel_num,
+												inverse_covariance, inverse_covariance + voxel_num, inverse_covariance + 2 * voxel_num,
+												inverse_covariance + 3 * voxel_num, inverse_covariance + 4 * voxel_num, inverse_covariance + 5 * voxel_num,
+												inverse_covariance + 6 * voxel_num, inverse_covariance + 7 * voxel_num, inverse_covariance + 8 * voxel_num,
+												point_gradients, point_gradients + 6 * valid_points_num, point_gradients + 12 * valid_points_num,
+												tmp_hessian, valid_voxel_num);
 		checkCudaErrors(cudaGetLastError());
-
 		grid.z = 6;
-		computeHessianListS3&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
+
+		computeHessianListS1&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
 													starting_voxel_id, voxel_id, valid_points_num,
-													centroid, voxel_num,
-													gauss_d1_, gauss_d2_,
-													hessians,
+													centroid, centroid + voxel_num, centroid + 2 * voxel_num,
+													gauss_d1_, gauss_d2_, hessians,
 													e_x_cov_x, tmp_hessian, cov_dxd_pi,
+													point_gradients,
 													valid_voxel_num);
 		checkCudaErrors(cudaGetLastError());
 
-		computeHessianListS4&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
+		computeHessianListS2&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
 													starting_voxel_id, voxel_id, valid_points_num,
-													centroid, inverse_covariance, voxel_num,
-													gauss_d1_, gauss_d2_,
-													point_hessians, hessians,
-													e_x_cov_x);
-		checkCudaErrors(cudaGetLastError());
-
-		computeHessianListS5&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
-														starting_voxel_id, voxel_id, valid_points_num,
-														centroid, inverse_covariance, voxel_num,
-														gauss_d1_, gauss_d2_,
-														point_hessians, hessians,
-														e_x_cov_x);
-		checkCudaErrors(cudaGetLastError());
-
-		computeHessianListS6&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
-														starting_voxel_id, voxel_id, valid_points_num,
-														centroid, inverse_covariance, voxel_num,
-														gauss_d1_, gauss_d2_,
-														point_hessians, hessians,
-														e_x_cov_x);
+													centroid, centroid + voxel_num, centroid + 2 * voxel_num,
+													gauss_d1_, e_x_cov_x,
+													inverse_covariance, inverse_covariance + voxel_num, inverse_covariance + 2 * voxel_num,
+													inverse_covariance + 3 * voxel_num, inverse_covariance + 4 * voxel_num, inverse_covariance + 5 * voxel_num,
+													inverse_covariance + 6 * voxel_num, inverse_covariance + 7 * voxel_num, inverse_covariance + 8 * voxel_num,
+													point_hessians, hessians, valid_voxel_num);
 		checkCudaErrors(cudaGetLastError());
 
-		computeHessianListS7&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
-													starting_voxel_id, voxel_id, valid_points_num,
-													gauss_d1_, gauss_d2_,
-													point_gradients, hessians,
-													e_x_cov_x, cov_dxd_pi, valid_voxel_num);
-		checkCudaErrors(cudaGetLastError());
 	}
 
 	int full_size = valid_points_num;
@@ -1290,123 +999,105 @@ void GNormalDistributionsTransform::computeAngleDerivatives(MatrixHost pose, boo
 		sz = sin(pose(5));
 	}
 
-	j_ang_a_(0) = -sx * sz + cx * sy * cz;
-	j_ang_a_(1) = -sx * cz - cx * sy * sz;
-	j_ang_a_(2) = -cx * cy;
 
-	j_ang_b_(0) = cx * sz + sx * sy * cz;
-	j_ang_b_(1) = cx * cz - sx * sy * sz;
-	j_ang_b_(2) = -sx * cy;
+	j_ang_(0) = -sx * sz + cx * sy * cz;
+	j_ang_(1) = -sx * cz - cx * sy * sz;
+	j_ang_(2) = -cx * cy;
 
-	j_ang_c_(0) = -sy * cz;
-	j_ang_c_(1) = sy * sz;
-	j_ang_c_(2) = cy;
+	j_ang_(3) = cx * sz + sx * sy * cz;
+	j_ang_(4) = cx * cz - sx * sy * sz;
+	j_ang_(5) = -sx * cy;
 
-	j_ang_d_(0) = sx * cy * cz;
-	j_ang_d_(1) = -sx * cy * sz;
-	j_ang_d_(2) = sx * sy;
+	j_ang_(6) = -sy * cz;
+	j_ang_(7) = sy * sz;
+	j_ang_(8) = cy;
 
-	j_ang_e_(0) = -cx * cy * cz;
-	j_ang_e_(1) = cx * cy * sz;
-	j_ang_e_(2) = -cx * sy;
+	j_ang_(9) = sx * cy * cz;
+	j_ang_(10) = -sx * cy * sz;
+	j_ang_(11) = sx * sy;
 
-	j_ang_f_(0) = -cy * sz;
-	j_ang_f_(1) = -cy * cz;
-	j_ang_f_(2) = 0;
+	j_ang_(12) = -cx * cy * cz;
+	j_ang_(13) = cx * cy * sz;
+	j_ang_(14) = -cx * sy;
 
-	j_ang_g_(0) = cx * cz - sx * sy * sz;
-	j_ang_g_(1) = -cx * sz - sx * sy * cz;
-	j_ang_g_(2) = 0;
+	j_ang_(15) = -cy * sz;
+	j_ang_(16) = -cy * cz;
+	j_ang_(17) = 0;
 
-	j_ang_h_(0) = sx * cz + cx * sy * sz;
-	j_ang_h_(1) = cx * sy * cz - sx * sz;
-	j_ang_h_(2) = 0;
+	j_ang_(18) = cx * cz - sx * sy * sz;
+	j_ang_(19) = -cx * sz - sx * sy * cz;
+	j_ang_(20) = 0;
 
-	j_ang_a_.moveToGpu(dj_ang_a_);
-	j_ang_b_.moveToGpu(dj_ang_b_);
-	j_ang_c_.moveToGpu(dj_ang_c_);
-	j_ang_d_.moveToGpu(dj_ang_d_);
-	j_ang_e_.moveToGpu(dj_ang_e_);
-	j_ang_f_.moveToGpu(dj_ang_f_);
-	j_ang_g_.moveToGpu(dj_ang_g_);
-	j_ang_h_.moveToGpu(dj_ang_h_);
+	j_ang_(21) = sx * cz + cx * sy * sz;
+	j_ang_(22) = cx * sy * cz - sx * sz;
+	j_ang_(23) = 0;
+
+	j_ang_.moveToGpu(dj_ang_);
 
 	if (compute_hessian) {
-		h_ang_a2_(0) = -cx * sz - sx * sy * cz;
-		h_ang_a2_(1) = -cx * cz + sx * sy * sz;
-		h_ang_a2_(2) = sx * cy;
-
-		h_ang_a3_(0) = -sx * sz + cx * sy * cz;
-		h_ang_a3_(1) = -cx * sy * sz - sx * cz;
-		h_ang_a3_(2) = -cx * cy;
-
-		h_ang_b2_(0) = cx * cy * cz;
-		h_ang_b2_(1) = -cx * cy * sz;
-		h_ang_b2_(2) = cx * sy;
-
-		h_ang_b3_(0) = sx * cy * cz;
-		h_ang_b3_(1) = -sx * cy * sz;
-		h_ang_b3_(2) = sx * sy;
-
-		h_ang_c2_(0) = -sx * cz - cx * sy * sz;
-		h_ang_c2_(1) = sx * sz - cx * sy * cz;
-		h_ang_c2_(2) = 0;
-
-		h_ang_c3_(0) = cx * cz - sx * sy * sz;
-		h_ang_c3_(1) = -sx * sy * cz - cx * sz;
-		h_ang_c3_(2) = 0;
-
-		h_ang_d1_(0) = -cy * cz;
-		h_ang_d1_(1) = cy * sz;
-		h_ang_d1_(2) = sy;
-
-		h_ang_d2_(0) = -sx * sy * cz;
-		h_ang_d2_(1) = sx * sy * sz;
-		h_ang_d2_(2) = sx * cy;
-
-		h_ang_d3_(0) = cx * sy * cz;
-		h_ang_d3_(1) = -cx * sy * sz;
-		h_ang_d3_(2) = -cx * cy;
-
-		h_ang_e1_(0) = sy * sz;
-		h_ang_e1_(1) = sy * cz;
-		h_ang_e1_(2) = 0;
-
-		h_ang_e2_(0) = -sx * cy * sz;
-		h_ang_e2_(1) = -sx * cy * cz;
-		h_ang_e2_(2) = 0;
-
-		h_ang_e3_(0) = cx * cy * sz;
-		h_ang_e3_(1) = cx * cy * cz;
-		h_ang_e3_(2) = 0;
-
-		h_ang_f1_(0) = -cy * cz;
-		h_ang_f1_(1) = cy * sz;
-		h_ang_f1_(2) = 0;
-
-		h_ang_f2_(0) = -cx * sz - sx * sy * cz;
-		h_ang_f2_(1) = -cx * cz + sx * sy * sz;
-		h_ang_f2_(2) = 0;
-
-		h_ang_f3_(0) = -sx * sz + cx * sy * cz;
-		h_ang_f3_(1) = -cx * sy * sz - sx * cz;
-		h_ang_f3_(2) = 0;
-
-		h_ang_a2_.moveToGpu(dh_ang_a2_);
-		h_ang_a3_.moveToGpu(dh_ang_a3_);
-		h_ang_b2_.moveToGpu(dh_ang_b2_);
-		h_ang_b3_.moveToGpu(dh_ang_b3_);
-		h_ang_c2_.moveToGpu(dh_ang_c2_);
-		h_ang_c3_.moveToGpu(dh_ang_c3_);
-		h_ang_d1_.moveToGpu(dh_ang_d1_);
-		h_ang_d2_.moveToGpu(dh_ang_d2_);
-		h_ang_d3_.moveToGpu(dh_ang_d3_);
-		h_ang_e1_.moveToGpu(dh_ang_e1_);
-		h_ang_e2_.moveToGpu(dh_ang_e2_);
-		h_ang_e3_.moveToGpu(dh_ang_e3_);
-		h_ang_f1_.moveToGpu(dh_ang_f1_);
-		h_ang_f2_.moveToGpu(dh_ang_f2_);
-		h_ang_f3_.moveToGpu(dh_ang_f3_);
+
+		h_ang_(0) = -cx * sz - sx * sy * cz;
+		h_ang_(1) = -cx * cz + sx * sy * sz;
+		h_ang_(2) = sx * cy;
+
+		h_ang_(3) = -sx * sz + cx * sy * cz;
+		h_ang_(4) = -cx * sy * sz - sx * cz;
+		h_ang_(5) = -cx * cy;
+
+		h_ang_(6) = cx * cy * cz;
+		h_ang_(7) = -cx * cy * sz;
+		h_ang_(8) = cx * sy;
+
+		h_ang_(9) = sx * cy * cz;
+		h_ang_(10) = -sx * cy * sz;
+		h_ang_(11) = sx * sy;
+
+		h_ang_(12) = -sx * cz - cx * sy * sz;
+		h_ang_(13) = sx * sz - cx * sy * cz;
+		h_ang_(14) = 0;
+
+		h_ang_(15) = cx * cz - sx * sy * sz;
+		h_ang_(16) = -sx * sy * cz - cx * sz;
+		h_ang_(17) = 0;
+
+		h_ang_(18) = -cy * cz;
+		h_ang_(19) = cy * sz;
+		h_ang_(20) = sy;
+
+		h_ang_(21) = -sx * sy * cz;
+		h_ang_(22) = sx * sy * sz;
+		h_ang_(23) = sx * cy;
+
+		h_ang_(24) = cx * sy * cz;
+		h_ang_(25) = -cx * sy * sz;
+		h_ang_(26) = -cx * cy;
+
+		h_ang_(27) = sy * sz;
+		h_ang_(28) = sy * cz;
+		h_ang_(29) = 0;
+
+		h_ang_(30) = -sx * cy * sz;
+		h_ang_(31) = -sx * cy * cz;
+		h_ang_(32) = 0;
+
+		h_ang_(33) = cx * cy * sz;
+		h_ang_(34) = cx * cy * cz;
+		h_ang_(35) = 0;
+
+		h_ang_(36) = -cy * cz;
+		h_ang_(37) = cy * sz;
+		h_ang_(38) = 0;
+
+		h_ang_(39) = -cx * sz - sx * sy * cz;
+		h_ang_(40) = -cx * cz + sx * sy * sz;
+		h_ang_(41) = 0;
+
+		h_ang_(42) = -sx * sz + cx * sy * cz;
+		h_ang_(43) = -cx * sy * sz - sx * cz;
+		h_ang_(44) = 0;
+
+
+		h_ang_.moveToGpu(dh_ang_);
 	}
 
 }
@@ -1414,7 +1105,7 @@ void GNormalDistributionsTransform::computeAngleDerivatives(MatrixHost pose, boo
 
 
 
-extern "C" __global__ void gpuTransform(float *in_x, float *in_y, float *in_z,
+__global__ void gpuTransform(float *in_x, float *in_y, float *in_z,
 										float *trans_x, float *trans_y, float *trans_z,
 										int point_num, MatrixDevice transform)
 {
@@ -1702,49 +1393,58 @@ void GNormalDistributionsTransform::computeHessian(Eigen::Matrix&lt;double, 6, 6&gt; &amp;
 	double *hessians, *point_gradients, *point_hessians;
 
 	checkCudaErrors(cudaMalloc(&amp;hessians, sizeof(double) * valid_points_num * 6 * 6));
-	checkCudaErrors(cudaMemset(hessians, 0, sizeof(double) * valid_points_num * 6 * 6));
 
 	checkCudaErrors(cudaMalloc(&amp;point_gradients, sizeof(double) * valid_points_num * 3 * 6));
-	checkCudaErrors(cudaMemset(point_gradients, 0, sizeof(double) * valid_points_num * 3 * 6));
 
 	checkCudaErrors(cudaMalloc(&amp;point_hessians, sizeof(double) * valid_points_num * 18 * 6));
+
+	checkCudaErrors(cudaMemset(hessians, 0, sizeof(double) * valid_points_num * 6 * 6));
+	checkCudaErrors(cudaMemset(point_gradients, 0, sizeof(double) * valid_points_num * 3 * 6));
 	checkCudaErrors(cudaMemset(point_hessians, 0, sizeof(double) * valid_points_num * 18 * 6));
 
 	int block_x = (valid_points_num &gt; BLOCK_SIZE_X) ? BLOCK_SIZE_X : valid_points_num;
 	int grid_x = (valid_points_num - 1) / block_x + 1;
 	dim3 grid;
 
-	computePointGradients0&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_number_,
+	computePointGradients&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_number_,
 												valid_points, valid_points_num,
-												dj_ang_a_, dj_ang_b_, dj_ang_c_, dj_ang_d_,
-												point_gradients);
+												dj_ang_.buffer(),
+												point_gradients,
+												point_gradients + valid_points_num * 7,
+												point_gradients + valid_points_num * 14,
+												point_gradients + valid_points_num * 9,
+												point_gradients + valid_points_num * 15,
+												point_gradients + valid_points_num * 4,
+												point_gradients + valid_points_num * 10,
+												point_gradients + valid_points_num * 16,
+												point_gradients + valid_points_num * 5,
+												point_gradients + valid_points_num * 11,
+												point_gradients + valid_points_num * 17);
 	checkCudaErrors(cudaGetLastError());
 
-	computePointGradients1&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_number_,
-												valid_points, valid_points_num,
-												dj_ang_e_, dj_ang_f_, dj_ang_g_, dj_ang_h_,
-												point_gradients);
-	checkCudaErrors(cudaGetLastError());
 
 	computePointHessian0&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_number_,
 												valid_points, valid_points_num,
-												dh_ang_a2_, dh_ang_a3_,
-												dh_ang_b2_, dh_ang_b3_,
-												point_hessians);
+												dh_ang_.buffer(),
+												point_hessians + valid_points_num * 57, point_hessians + valid_points_num * 63, point_hessians + valid_points_num * 69,
+												point_hessians + valid_points_num * 75, point_hessians + valid_points_num * 58, point_hessians + valid_points_num * 81,
+												point_hessians + valid_points_num * 64, point_hessians + valid_points_num * 87, point_hessians + valid_points_num * 70,
+												point_hessians + valid_points_num * 93, point_hessians + valid_points_num * 59, point_hessians + valid_points_num * 99,
+												point_hessians + valid_points_num * 65, point_hessians + valid_points_num * 105, point_hessians + valid_points_num * 71);
 	checkCudaErrors(cudaGetLastError());
 
 	computePointHessian1&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_number_,
 												valid_points, valid_points_num,
-												dh_ang_c2_, dh_ang_c3_,
-												dh_ang_d1_, dh_ang_d2_, dh_ang_d3_,
-												point_hessians);
+												dh_ang_.buffer(),
+												point_hessians + valid_points_num * 76, point_hessians + valid_points_num * 82, point_hessians + valid_points_num * 88,
+												point_hessians + valid_points_num * 94, point_hessians + valid_points_num * 77, point_hessians + valid_points_num * 100,
+												point_hessians + valid_points_num * 83, point_hessians + valid_points_num * 106, point_hessians + valid_points_num * 89);
 	checkCudaErrors(cudaGetLastError());
 
 	computePointHessian2&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(x_, y_, z_, points_number_,
 												valid_points, valid_points_num,
-												dh_ang_e1_, dh_ang_e2_, dh_ang_e3_,
-												dh_ang_f1_, dh_ang_f2_, dh_ang_f3_,
-												point_hessians);
+												dh_ang_.buffer(),
+												point_hessians + valid_points_num * 95, point_hessians + valid_points_num * 101, point_hessians + valid_points_num * 107);
 	checkCudaErrors(cudaGetLastError());
 
 	double *tmp_hessian;
@@ -1761,9 +1461,13 @@ void GNormalDistributionsTransform::computeHessian(Eigen::Matrix&lt;double, 6, 6&gt; &amp;
 
 	computeExCovX&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
 										starting_voxel_id, voxel_id, valid_points_num,
-										centroid, inverse_covariance, voxel_num,
+										centroid, centroid + voxel_num, centroid + 2 * voxel_num,
 										gauss_d1_, gauss_d2_,
-										e_x_cov_x);
+										e_x_cov_x,
+										inverse_covariance, inverse_covariance + voxel_num, inverse_covariance + 2 * voxel_num,
+										inverse_covariance + 3 * voxel_num, inverse_covariance + 4 * voxel_num, inverse_covariance + 5 * voxel_num,
+										inverse_covariance + 6 * voxel_num, inverse_covariance + 7 * voxel_num, inverse_covariance + 8 * voxel_num);
+
 	checkCudaErrors(cudaGetLastError());
 
 	grid.x = grid_x;
@@ -1778,73 +1482,44 @@ void GNormalDistributionsTransform::computeHessian(Eigen::Matrix&lt;double, 6, 6&gt; &amp;
 	int block_x2 = (valid_voxel_num &gt; BLOCK_SIZE_X) ? BLOCK_SIZE_X : valid_voxel_num;
 	int grid_x2 = (valid_voxel_num - 1) / block_x2 + 1;
 
+
 	updateExCovX&lt;&lt;&lt;grid_x2, block_x2&gt;&gt;&gt;(e_x_cov_x, gauss_d2_, valid_voxel_num);
 	checkCudaErrors(cudaGetLastError());
 
 	grid.y = 6;
 	grid.z = 1;
-	computeHessianListS0&lt;&lt;&lt;grid_x, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
-												starting_voxel_id, voxel_id, valid_points_num,
-												centroid, inverse_covariance, voxel_num,
-												gauss_d1_, gauss_d2_,
-												point_gradients, tmp_hessian, valid_voxel_num);
-	checkCudaErrors(cudaGetLastError());
-
-	computeHessianListS1&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
-												starting_voxel_id, voxel_id, valid_points_num,
-												centroid, inverse_covariance, voxel_num,
-												gauss_d1_, gauss_d2_,
-												point_gradients, tmp_hessian, valid_voxel_num);
-	checkCudaErrors(cudaGetLastError());
 
-	computeHessianListS2&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
+	computeHessianListS0&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
 												starting_voxel_id, voxel_id, valid_points_num,
-												centroid, inverse_covariance, voxel_num,
-												gauss_d1_, gauss_d2_,
-												point_gradients, tmp_hessian, valid_voxel_num);
+												centroid, centroid + voxel_num, centroid + 2 * voxel_num,
+												inverse_covariance, inverse_covariance + voxel_num, inverse_covariance + 2 * voxel_num,
+												inverse_covariance + 3 * voxel_num, inverse_covariance + 4 * voxel_num, inverse_covariance + 5 * voxel_num,
+												inverse_covariance + 6 * voxel_num, inverse_covariance + 7 * voxel_num, inverse_covariance + 8 * voxel_num,
+												point_gradients, point_gradients + 6 * valid_points_num, point_gradients + 12 * valid_points_num,
+												tmp_hessian, valid_voxel_num);
 	checkCudaErrors(cudaGetLastError());
 
 	grid.z = 6;
-	computeHessianListS3&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
+
+	computeHessianListS1&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
 												starting_voxel_id, voxel_id, valid_points_num,
-												centroid, voxel_num,
-												gauss_d1_, gauss_d2_,
-												hessians,
+												centroid, centroid + voxel_num, centroid + 2 * voxel_num,
+												gauss_d1_, gauss_d2_, hessians,
 												e_x_cov_x, tmp_hessian, cov_dxd_pi,
+												point_gradients,
 												valid_voxel_num);
 	checkCudaErrors(cudaGetLastError());
 
-
-	computeHessianListS4&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
+	computeHessianListS2&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
 												starting_voxel_id, voxel_id, valid_points_num,
-												centroid, inverse_covariance, voxel_num,
-												gauss_d1_, gauss_d2_,
-												point_hessians, hessians,
-												e_x_cov_x);
+												centroid, centroid + voxel_num, centroid + 2 * voxel_num,
+												gauss_d1_, e_x_cov_x,
+												inverse_covariance, inverse_covariance + voxel_num, inverse_covariance + 2 * voxel_num,
+												inverse_covariance + 3 * voxel_num, inverse_covariance + 4 * voxel_num, inverse_covariance + 5 * voxel_num,
+												inverse_covariance + 6 * voxel_num, inverse_covariance + 7 * voxel_num, inverse_covariance + 8 * voxel_num,
+												point_hessians, hessians, valid_voxel_num);
 	checkCudaErrors(cudaGetLastError());
 
-	computeHessianListS5&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
-													starting_voxel_id, voxel_id, valid_points_num,
-													centroid, inverse_covariance, voxel_num,
-													gauss_d1_, gauss_d2_,
-													point_hessians, hessians,
-													e_x_cov_x);
-	checkCudaErrors(cudaGetLastError());
-
-	computeHessianListS6&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
-													starting_voxel_id, voxel_id, valid_points_num,
-													centroid, inverse_covariance, voxel_num,
-													gauss_d1_, gauss_d2_,
-													point_hessians, hessians,
-													e_x_cov_x);
-	checkCudaErrors(cudaGetLastError());
-
-	computeHessianListS7&lt;&lt;&lt;grid, block_x&gt;&gt;&gt;(trans_x, trans_y, trans_z, valid_points,
-												starting_voxel_id, voxel_id, valid_points_num,
-												gauss_d1_, gauss_d2_,
-												point_gradients, hessians,
-												e_x_cov_x, cov_dxd_pi, valid_voxel_num);
-	checkCudaErrors(cudaGetLastError());
 
 	int full_size = valid_points_num;
 	int half_size = (full_size - 1) / 2 + 1;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="45ef5921f23aa52e7fa197156f724fad3ea2ac76" author="Akihito Ohsato">
		<msg>change specification according PCL ver.</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\lib\ndt_tku\include\ndt.h" new_path="ros\src\computing\perception\localization\lib\ndt_tku\include\ndt.h" added_lines="107" deleted_lines="98">
				<diff>@@ -1,27 +1,29 @@
- /***************************************************************************
- *   Copyright (C) 2005 by TAKEUCHI Eijiro,,,   *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-#include&lt;GL/glut.h&gt;
+/***************************************************************************
+*   Copyright (C) 2005 by TAKEUCHI Eijiro,,,   *
+*                                                                         *
+*   This program is free software; you can redistribute it and/or modify  *
+*   it under the terms of the GNU General Public License as published by  *
+*   the Free Software Foundation; either version 2 of the License, or     *
+*   (at your option) any later version.                                   *
+*                                                                         *
+*   This program is distributed in the hope that it will be useful,       *
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+*   GNU General Public License for more details.                          *
+*                                                                         *
+*   You should have received a copy of the GNU General Public License     *
+*   along with this program; if not, write to the                         *
+*   Free Software Foundation, Inc.,                                       *
+*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+***************************************************************************/
+#ifndef __NDT_TKU__
+#define __NDT_TKU__
+
+#include &lt;GL/glut.h&gt;
 /*root cell size*/
 /*
   #define MAP_CELLSIZE 0.2 //m
-  
+
   #define MAP_X 128
   #define MAP_Y 80
   #define MAP_Z 48
@@ -30,12 +32,11 @@
 //#define MAP_CELLSIZE 1.0 //m
 #define MAX_ND_NUM (20000000)
 
-
-//map origin//
-//meidai_map
+// map origin//
+// meidai_map
 #if 0
-#define MAP_CENTER_X (-18407.4+215)
-#define MAP_CENTER_Y (-93444.9-400)
+#define MAP_CENTER_X (-18407.4 + 215)
+#define MAP_CENTER_Y (-93444.9 - 400)
 #define MAP_CENTER_Z 33
 #define MAP_ROTATION 0.0
 //map size
@@ -44,7 +45,7 @@
 #define MAP_Z 200
 #endif
 
-//meidai_map_all
+// meidai_map_all
 #if 0
 #define MAP_CENTER_X (-18500)
 #define MAP_CENTER_Y (-93800)
@@ -57,9 +58,9 @@
 
 #endif
 
-//moriyama_map
+// moriyama_map
 #if 0
-#define MAP_CENTER_X -15741 
+#define MAP_CENTER_X -15741
 #define MAP_CENTER_Y -85697
 #define MAP_CENTER_Z 70
 #define MAP_ROTATION 0.7
@@ -69,7 +70,7 @@
 #define MAP_Z 200
 #endif
 
-//tctslc map
+// tctslc map
 #if 0
 #define MAP_CENTER_X 3702
 #define MAP_CENTER_Y -99430
@@ -93,85 +94,83 @@
 #define MAP_Z 200
 #endif
 
-//initial position
-//meidai IB (141117_run01,run02)
+// initial position
+// meidai IB (141117_run01,run02)
 #if 0
 #define INITIAL_X -18354.1
 #define INITIAL_Y -93693.4
 #define INITIAL_Z 43
-#define INITIAL_ROLL  0
+#define INITIAL_ROLL 0
 #define INITIAL_PITCH 0
 #define INITIAL_YAW -0.5
 #endif
-//meidai  (141205_outdoor1)
+// meidai  (141205_outdoor1)
 #if 0
 #define INITIAL_X -18526.5
 #define INITIAL_Y -93646.0
 #define INITIAL_Z 39
-#define INITIAL_ROLL  0
+#define INITIAL_ROLL 0
 #define INITIAL_PITCH 0.03
 #define INITIAL_YAW -0.45
 #endif
-//incubation(0826)
+// incubation(0826)
 #if 0
-#define INITIAL_X (-18407.4+215-215+0.6)
-#define INITIAL_Y (-93444.9 -400+400+0.65)
+#define INITIAL_X (-18407.4 + 215 - 215 + 0.6)
+#define INITIAL_Y (-93444.9 - 400 + 400 + 0.65)
 #define INITIAL_Z 33
-#define INITIAL_ROLL  0
+#define INITIAL_ROLL 0
 #define INITIAL_PITCH -0.063
 #define INITIAL_YAW -1.976
 #endif
-//incubation parking(1224)
+// incubation parking(1224)
 #if 0
 #define INITIAL_X (-18389.8)
 #define INITIAL_Y (-93499.1)
 #define INITIAL_Z 33
-#define INITIAL_ROLL  0
+#define INITIAL_ROLL 0
 #define INITIAL_PITCH 0
 #define INITIAL_YAW 1.107
 #endif
 
-
-//moriyama
+// moriyama
 #if 0
 #define INITIAL_X -14771
 #define INITIAL_Y -84757
 #define INITIAL_Z (39.8)
-#define INITIAL_ROLL  0
+#define INITIAL_ROLL 0
 #define INITIAL_PITCH 0
 //#define INITIAL_YAW 0
 #define INITIAL_YAW 2.324
 #endif
 
-//tctslc
+// tctslc
 #if 0
 #define INITIAL_X 3702
-#define INITIAL_Y -99430  //matsu
+#define INITIAL_Y -99430  // matsu
 //#define INITIAL_Y -99426   //zmp
 #define INITIAL_Z 87
-#define INITIAL_ROLL  0
+#define INITIAL_ROLL 0
 #define INITIAL_PITCH 0
-#define INITIAL_YAW 0      //matsu
+#define INITIAL_YAW 0  // matsu
 //#define INITIAL_YAW 3.14   //zmp
 #endif
 
-//no map
+// no map
 #if 0
 #define INITIAL_X 0
 #define INITIAL_Y 0
 #define INITIAL_Z 0
-#define INITIAL_ROLL  0
+#define INITIAL_ROLL 0
 #define INITIAL_PITCH 0
 #define INITIAL_YAW 0
 #endif
 
+// x=-14763
+// y=-84780
+// q=-2.34
+#define LAYER_NUM 2  // 0.2 0.4 0.8 1.6 3.2(128*80*48)
 
-//x=-14763
-//y=-84780
-//q=-2.34
-#define LAYER_NUM 2 //0.2 0.4 0.8 1.6 3.2(128*80*48)
-
-#define ND_MIN  40
+#define ND_MIN 40
 
 //#define CELL_X (MAP_X*(1&lt;&lt;LAYER_NUM))
 //#define CELL_Y (MAP_Y*(1&lt;&lt;LAYER_NUM))
@@ -180,43 +179,46 @@
 /*point*/
 typedef struct point_type *PointPtr;
 
-typedef struct point_type{
+typedef struct point_type
+{
   double x;
   double y;
   double z;
-}Point;
+} Point;
 
 /*point*/
 typedef struct postuer_type *PosturePtr;
 
-typedef struct postuer_type{
+typedef struct postuer_type
+{
   double x;
   double y;
   double z;
   double theta;
   double theta2;
   double theta3;
-}Posture;
+} Posture;
 
 /*Normal Distribution  data type*/
 typedef struct Normaldistribution *NDPtr;
 
-typedef struct Normaldistribution{
+typedef struct Normaldistribution
+{
   /*covariances*/
-  Point  mean;
+  Point mean;
   double covariance[3][3];
-  double inv_covariance[3][3];	
+  double inv_covariance[3][3];
   /*for calcurate covariances*/
-  int flag;	/*is updated*/
+  int flag; /*is updated*/
   int sign;
 
-  int num;   /*data num*/
-  
-  double m_x;/*mean*/
+  int num; /*data num*/
+
+  double m_x; /*mean*/
   double m_y;
   double m_z;
-  
-  double c_xx;/*covariance*/
+
+  double c_xx; /*covariance*/
   double c_yy;
   double c_zz;
   double c_xy;
@@ -229,15 +231,16 @@ typedef struct Normaldistribution{
 
   double w;
 
-  double l[3];/*eigen value*/
-  
-  int   is_source;/**/
+  double l[3]; /*eigen value*/
+
+  int is_source; /**/
   //  NDPtr child[8]; /*upper level layer*/
-}NormalDistribution;
+} NormalDistribution;
 
 typedef struct nd_map *NDMapPtr;
 
-typedef struct nd_map{
+typedef struct nd_map
+{
   NDPtr *nd;
   int layer;
   int x;
@@ -249,48 +252,54 @@ typedef struct nd_map{
   char name[30];
 
   NDMapPtr next;
-}NDMap;
+} NDMap;
 
 typedef struct nd_data *NDDatPtr;
 
-typedef struct nd_data{
+typedef struct nd_data
+{
   NormalDistribution nd;
   int x;
   int y;
   int z;
   int layer;
-}NDData;
+} NDData;
 
-int add_point_covariance(NDPtr nd,PointPtr p);
+int add_point_covariance(NDPtr nd, PointPtr p);
 int update_covariance(NDPtr nd);
-int add_point_map(NDMapPtr ndmap,PointPtr point);
-int get_ND(NDMapPtr ndmap, PointPtr point,NDPtr *nd,int mode);
+int add_point_map(NDMapPtr ndmap, PointPtr point);
+int get_ND(NDMapPtr ndmap, PointPtr point, NDPtr *nd, int mode);
 
 NDMapPtr initialize_NDmap(void);
 NDMapPtr initialize_NDmap_layer(int layer, NDMapPtr parent);
 int round_covariance(NDPtr nd);
-int  print_ellipse(FILE* output_file, double mat[3][3],double cx,double cy);
-int  print_ellipse_nd(FILE* output_file,NDPtr nd);
-void glstart(int argc ,char* argv[]);
-void DrawString(GLfloat x,GLfloat y,double size_x,double size_y,void *font, char *string);
-void DrawLine(GLfloat x1,GLfloat y1,GLfloat x2,GLfloat y2);
-void display (void);
-void reshape (int w, int h);
-void draw_all (void);
+int print_ellipse(FILE *output_file, double mat[3][3], double cx, double cy);
+int print_ellipse_nd(FILE *output_file, NDPtr nd);
+void glstart(int argc, char *argv[]);
+void DrawString(GLfloat x, GLfloat y, double size_x, double size_y, void *font, char *string);
+void DrawLine(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
+void display(void);
+void reshape(int w, int h);
+void draw_all(void);
 void draw_map(void);
-void keyfunc (unsigned char key, int x, int y);
-void mousefunc (int button, int status, int x, int y);
+void keyfunc(unsigned char key, int x, int y);
+void mousefunc(int button, int status, int x, int y);
 void motionfunc(int x, int y);
-void idle (void);
+void idle(void);
 void draw_cell(NDPtr nd);
-double probability_on_ND(NDPtr nd,double x,double y,double z);
+double probability_on_ND(NDPtr nd, double x, double y, double z);
 
-//void add_ND(NDPtr);
+// void add_ND(NDPtr);
 NDPtr add_ND(void);
-double calc_summand2d(PointPtr p,NDPtr nd,PosturePtr pose,double *g,double H[3][3]);
+double calc_summand2d(PointPtr p, NDPtr nd, PosturePtr pose, double *g, double H[3][3]);
 int adjust2d(PointPtr scan, int num, PosturePtr initial);
 
-double calc_summand3d(PointPtr p,NDPtr nd,PosturePtr pose,double *g,double H[6][6],double qd3[6][3],double dist);
-double adjust3d(PointPtr scan, int num, PosturePtr initial,int target);
-void set_sincos2(double a,double b,double g,double sc[3][3]);
-void scan_transrate(PointPtr src, PointPtr dst ,PosturePtr pose, int num);
+double calc_summand3d(PointPtr p, NDPtr nd, PosturePtr pose, double *g, double H[6][6], double qd3[6][3], double dist);
+double adjust3d(PointPtr scan, int num, PosturePtr initial, int target);
+void set_sincos2(double a, double b, double g, double sc[3][3]);
+void scan_transrate(PointPtr src, PointPtr dst, PosturePtr pose, int num);
+
+// values
+extern int g_map_x, g_map_y, g_map_z;
+extern double g_map_cellsize;
+#endif
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\ndt_tku\src\algebra.cpp" new_path="ros\src\computing\perception\localization\lib\ndt_tku\src\algebra.cpp" added_lines="20" deleted_lines="20">
				<diff>@@ -69,7 +69,7 @@ int mux_matrix(double *s1, double *s2, double *dst, int in, int kn, int jn)
   return 1;
 }
 
-/**/
+
 int add_matrix2d(double s1[2][2], double s2[2][2], double dst[2][2])
 {
   dst[0][0] = s1[0][0] + s2[0][0];
@@ -339,15 +339,15 @@ int eigenvalue_matrix3d(double mat[3][3], double l1[2], double l2[2], double l3[
   return 0;
 }
 /*****************************************************************/
-/*                   */
-/*          n :                                              */
-/*          ct :                                 */
-/*          eps :                                    */
-/*          A :                                    */
-/*          A1, A2 : nxnA1   */
-/*          X1, X2 : nxnX1 */
-/*          return : =0 :                                    */
-/*                   =1 :                                */
+/*                   */
+/*          n :                                              */
+/*          ct :                                 */
+/*          eps :                                    */
+/*          A :                                    */
+/*          A1, A2 : nxnA1   */
+/*          X1, X2 : nxnX1 */
+/*          return : =0 :                                    */
+/*                   =1 :                                */
 /*          coded by Y.Suganuma                                  */
 /*****************************************************************/
 
@@ -356,7 +356,7 @@ int jacobi_matrix3d(int ct, double eps, double A[3][3], double A1[3][3], double
   double A2[3][3], X2[3][3];
   double max, s, t, v, sn, cs;
   int i1, i2, k = 0, ind = 1, p = 0, q = 0, n = 3;
-  // 
+  // 
   for (i1 = 0; i1 &lt; n; i1++)
   {
     for (i2 = 0; i2 &lt; n; i2++)
@@ -366,10 +366,10 @@ int jacobi_matrix3d(int ct, double eps, double A[3][3], double A1[3][3], double
     }
     X1[i1][i1] = 1.0;
   }
-  // 
+  // 
   while (ind &gt; 0 &amp;&amp; k &lt; ct)
   {
-    // 
+    // 
     max = 0.0;
     for (i1 = 0; i1 &lt; n; i1++)
     {
@@ -386,14 +386,14 @@ int jacobi_matrix3d(int ct, double eps, double A[3][3], double A1[3][3], double
         }
       }
     }
-    // 
-    // 
+    // 
+    // 
     if (max &lt; eps)
       ind = 0;
-    // 
+    // 
     else
     {
-      // 
+      // 
       s = -A1[p][q];
       t = 0.5 * (A1[p][p] - A1[q][q]);
       v = fabs(t) / sqrt(s * s + t * t);
@@ -401,7 +401,7 @@ int jacobi_matrix3d(int ct, double eps, double A[3][3], double A1[3][3], double
       if (s * t &lt; 0.0)
         sn = -sn;
       cs = sqrt(1.0 - sn * sn);
-      // Ak
+      // Ak
       for (i1 = 0; i1 &lt; n; i1++)
       {
         if (i1 == p)
@@ -441,7 +441,7 @@ int jacobi_matrix3d(int ct, double eps, double A[3][3], double A1[3][3], double
           }
         }
       }
-      // Xk
+      // Xk
       for (i1 = 0; i1 &lt; n; i1++)
       {
         for (i2 = 0; i2 &lt; n; i2++)
@@ -454,7 +454,7 @@ int jacobi_matrix3d(int ct, double eps, double A[3][3], double A1[3][3], double
             X2[i1][i2] = X1[i1][i2];
         }
       }
-      // 
+      // 
       k++;
       for (i1 = 0; i1 &lt; n; i1++)
       {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\lib\ndt_tku\src\newton.cpp" new_path="ros\src\computing\perception\localization\lib\ndt_tku\src\newton.cpp" added_lines="75" deleted_lines="368">
				<diff>@@ -3,14 +3,11 @@
 #include &lt;stdlib.h&gt;
 #include &lt;string&gt;
 
-#include "ndt.h"
 #include "algebra.h"
+#include "ndt.h"
 
 #define E_THETA 0.0001
 
-//#define WEIGHTED_SELECT 1
-#define WEIGHTED_SELECT 0
-
 extern int point_num;
 extern NDMapPtr NDmap;
 extern int layer_select;
@@ -18,8 +15,6 @@ extern int layer_select;
 extern double scan_points_weight[];
 extern double scan_points_totalweight;
 
-extern int _downsampler_num;
-
 double qdd[3][3][2];
 double qd[3][2];
 double qd3[6][3];
@@ -31,10 +26,6 @@ int check_Hessian(double H[3][3]);
 void save_data(PointPtr scan, int num, PosturePtr pose);
 void depth(PointPtr scan, int num, PosturePtr pose);
 
-/*
-
-
-*/
 double calc_summand3d(PointPtr p, NDPtr nd, PosturePtr pose, double *g, double H[6][6], double qd3_d[6][3], double dist)
 {
   double a[3];
@@ -43,13 +34,10 @@ double calc_summand3d(PointPtr p, NDPtr nd, PosturePtr pose, double *g, double H
   double qda[6][3], *qda_p;  //,*qdd_p;
   int i, j;
 
-  /*q*/
   q[0] = p-&gt;x - nd-&gt;mean.x;
   q[1] = p-&gt;y - nd-&gt;mean.y;
   q[2] = p-&gt;z - nd-&gt;mean.z;
 
-  /*exp*/
-  //  e = probability_on_ND(nd, p-&gt;x, p-&gt;y, p-&gt;z);
   e = probability_on_ND(nd, q[0], q[1], q[2]) * dist;
 
   if (e &lt; 0.000000001)
@@ -64,7 +52,7 @@ double calc_summand3d(PointPtr p, NDPtr nd, PosturePtr pose, double *g, double H
     }
     return 0;
   }
-  /*  */
+
   a[0] = q[0] * nd-&gt;inv_covariance[0][0] + q[1] * nd-&gt;inv_covariance[1][0] + q[2] * nd-&gt;inv_covariance[2][0];
   a[1] = q[0] * nd-&gt;inv_covariance[0][1] + q[1] * nd-&gt;inv_covariance[1][1] + q[2] * nd-&gt;inv_covariance[2][1];
   a[2] = q[0] * nd-&gt;inv_covariance[0][2] + q[1] * nd-&gt;inv_covariance[1][2] + q[2] * nd-&gt;inv_covariance[2][2];
@@ -104,7 +92,6 @@ double calc_summand3d(PointPtr p, NDPtr nd, PosturePtr pose, double *g, double H
   return e;
 }
 
-/**/
 int check_Hessian(double H[3][3])
 {
   int i, j;
@@ -119,7 +106,6 @@ int check_Hessian(double H[3][3])
   return 1;
 }
 
-/**/
 void save_data(PointPtr scan, int num, PosturePtr pose)
 {
   double sc[3][3], x, y, z;
@@ -170,7 +156,6 @@ void scan_transrate(PointPtr src, PointPtr dst, PosturePtr pose, int num)
   }
 }
 
-/**/
 void depth(PointPtr scan, int num, PosturePtr pose)
 {
   double sc[3][3], x, y, z;
@@ -191,28 +176,22 @@ void depth(PointPtr scan, int num, PosturePtr pose)
   }
 }
 
-/**/
 double adjust3d(PointPtr scan, int num, PosturePtr initial, int target)
 {
-  // double gsum[6], Hsum[6][6],Hsumh[6][6],Hinv[6][6],g[6],gd[6],ge[6][6],H[6][6],hH[6][6];
   double gsum[6], Hsum[6][6], Hsumh[6][6], Hinv[6][6], g[6], H[6][6], hH[6][6];
-  // double sc[3][3],sc_d[3][3][3],sc_dd[3][3][3][3],sce[3][3][3];
   double sc[3][3], sc_d[3][3][3], sc_dd[3][3][3][3];
-  // double *work,*work2,*work3;
   double *work;
   double esum = 0, gnum = 0;
   NDPtr nd[8];
   NDMapPtr nd_map;
   int i, j, n, m, k, layer;
-  double x, y, z;  //,sa,ca,sb,cb,sg,cg;
+  double x, y, z;
   PosturePtr pose;
-  // Point p,pe[6],pd;
   Point p;
   PointPtr scanptr;
-  // int inc,count;
   int inc;
   int ndmode;
-  double dist, weight_total, weight_sum, weight_next;
+  double dist;
 
   /*initialize*/
   gsum[0] = 0;
@@ -226,16 +205,13 @@ double adjust3d(PointPtr scan, int num, PosturePtr initial, int target)
   zero_matrix6d(Hsumh);
   pose = initial;
 
-  /*1*/
   set_sincos(pose-&gt;theta, pose-&gt;theta2, pose-&gt;theta3, sc_d);
   set_sincos(pose-&gt;theta + E_THETA, pose-&gt;theta2, pose-&gt;theta3, sc_dd[0]);
   set_sincos(pose-&gt;theta, pose-&gt;theta2 + E_THETA, pose-&gt;theta3, sc_dd[1]);
   set_sincos(pose-&gt;theta, pose-&gt;theta2, pose-&gt;theta3 + E_THETA, sc_dd[2]);
 
-  /**/
   set_sincos2(pose-&gt;theta, pose-&gt;theta2, pose-&gt;theta3, sc);
 
-  /**/
   qd3[0][0] = 1;
   qd3[0][1] = 0;
   qd3[0][2] = 0;
@@ -258,255 +234,103 @@ double adjust3d(PointPtr scan, int num, PosturePtr initial, int target)
     }
   }
 
-  //#if WEIGHTED_SELECT
-  if (_downsampler_num == 0)
+  // using voxel grid filter
+  switch (target)
   {
-    /*1=*/
-    switch (target)
-    {
-      case 3:
-        inc = 1;
-        ndmode = 0;
-        break;
-      case 2:
-        inc = 500;
-        ndmode = 1;
-        break;
-      case 1:
-        inc = 5000;
-        ndmode = 0;
-        break;
-      default:
-        inc = 5000;
-        ndmode = 0;
-        break;
-    }
-  }
-  //#else
-  if (_downsampler_num == 1)
-  {
-    /*1=*/
-    switch (target)
-    {
-      case 3:
-        inc = 1;
-        ndmode = 0;
-        break;
-      case 2:
-        inc = 1;
-        ndmode = 1;
-        break;
-      case 1:
-        inc = 1;
-        ndmode = 0;
-        break;
-      default:
-        inc = 1;
-        ndmode = 0;
-        break;
-    }
+    case 3:
+      inc = 1;
+      ndmode = 0;
+      break;
+    case 2:
+      inc = 1;
+      ndmode = 1;
+      break;
+    case 1:
+      inc = 1;
+      ndmode = 0;
+      break;
+    default:
+      inc = 1;
+      ndmode = 0;
+      break;
   }
+
   //#endif
 
   scanptr = scan;
 
-  /**/
-
-  //#if WEIGHTED_SELECT
-  if (_downsampler_num == 0)
+  // case of voxel grid filter used
+  for (i = 0; i &lt; num; i += inc)
   {
-    weight_total = scan_points_totalweight;
-    ;
-    weight_next = 0;
-    weight_sum = 0;
-
-    //  FILE *point_fp;
-    // point_fp=fopen("/tmp/range","w");
-    for (i = 0; i &lt; num; i++)
-    {
-      weight_sum += scan_points_weight[i];
-      if (weight_sum &lt; weight_next)
-      {
-        scanptr++;
-        continue;
-      }
-
-      /**/
-      x = scanptr-&gt;x;
-      y = scanptr-&gt;y;
-      z = scanptr-&gt;z;
-      //    fprintf(point_fp,"%f %f %f \n",x,y,z);
+    x = scanptr-&gt;x;
+    y = scanptr-&gt;y;
+    z = scanptr-&gt;z;
+    dist = 1;
+    scanptr += inc;
 
-      scanptr++;
-      weight_next += weight_total / (double)inc;  // 1000;
-      dist = 1;
-
-      p.x = x * sc[0][0] + y * sc[0][1] + z * sc[0][2] + pose-&gt;x;
-      p.y = x * sc[1][0] + y * sc[1][1] + z * sc[1][2] + pose-&gt;y;
-      p.z = x * sc[2][0] + y * sc[2][1] + z * sc[2][2] + pose-&gt;z;
-
-      /**/
-      if (ndmode == 1)
-        layer = 1;  // layer_select;
-      if (ndmode == 0)
-        layer = 0;  // layer_select;
-      nd_map = NDmap;
-
-      while (layer &gt; 0)
-      {
-        if (nd_map-&gt;next)
-          nd_map = nd_map-&gt;next;
-        layer--;
-      }
+    p.x = x * sc[0][0] + y * sc[0][1] + z * sc[0][2] + pose-&gt;x;
+    p.y = x * sc[1][0] + y * sc[1][1] + z * sc[1][2] + pose-&gt;y;
+    p.z = x * sc[2][0] + y * sc[2][1] + z * sc[2][2] + pose-&gt;z;
 
-      /*NDND
-        */
+    if (ndmode == 1)
+      layer = 1;  // layer_select;
+    if (ndmode == 0)
+      layer = 0;  // layer_select;
+    nd_map = NDmap;
 
-      if (!get_ND(nd_map, &amp;p, nd, target))
-        continue;
+    while (layer &gt; 0)
+    {
+      if (nd_map-&gt;next)
+        nd_map = nd_map-&gt;next;
+      layer--;
+    }
 
-      /*q()*/
-      work = (double *)sc_d;
-      for (m = 0; m &lt; 3; m++)
-      {
-        for (k = 0; k &lt; 3; k++)
-        {
-          // qd3[txtytzabg][xyz]
-          qd3[m + 3][k] = x * (*work) + y * (*(work + 1)) + z * (*(work + 2));
-          // x*sc_d[m][k][0] + y*sc_d[m][k][1] + z*sc_d[m][k][2];
-          work += 3;
-        }
-      }
 
-      /*q*/
-      work = (double *)sc_dd;
-      for (n = 0; n &lt; 3; n++)
-      {
-        for (m = 0; m &lt; 3; m++)
-        {
-          for (k = 0; k &lt; 3; k++)
-          {
-            qdd3[n + 3][m + 3][k] = (*work * x + *(work + 1) * y + *(work + 2) * z - qd3[m + 3][k]) / E_THETA;
-            work += 3;
-          }
-        }
-      }
-
-      /**/
-      if (nd[j])
-      {
-        if (nd[j]-&gt;num &gt; 10 &amp;&amp; nd[j]-&gt;sign == 1)
-        {
-          //	double e;
-          esum += calc_summand3d(&amp;p, nd[j], pose, g, hH, qd3, dist);
-          add_matrix6d(Hsumh, hH, Hsumh);
-
-          //	  dist =1;
-          gsum[0] += g[0];                //*nd[j]-&gt;w;
-          gsum[1] += g[1];                //*nd[j]-&gt;w;
-          gsum[2] += g[2] + pose-&gt;z * 0;  //*nd[j]-&gt;w;
-          gsum[3] += g[3];                //*nd[j]-&gt;w;
-          gsum[4] += g[4];                //+(pose-&gt;theta2-(0.0))*1;//*nd[j]-&gt;w;
-          gsum[5] += g[5];                //*nd[j]-&gt;w;
-          gnum += 1;  // nd[j]-&gt;w;
-        }
-      }
-    }
-  }
+    if (!get_ND(nd_map, &amp;p, nd, target))
+      continue;
 
-  //#else
-  if (_downsampler_num == 1)
-  {
-    for (i = 0; i &lt; num; i += inc)
+    work = (double *)sc_d;
+    for (m = 0; m &lt; 3; m++)
     {
-      //    dist = (x*x+y*y+z*z);
-      // dist *= (1.2-exp(-1*(-1 - z)*(-1 - z)/4.0));
-      //    if(dist&gt;2500)dist=2500;
-      /**/
-      x = scanptr-&gt;x;
-      y = scanptr-&gt;y;
-      z = scanptr-&gt;z;
-      dist = 1;
-      scanptr += inc;
-
-      p.x = x * sc[0][0] + y * sc[0][1] + z * sc[0][2] + pose-&gt;x;
-      p.y = x * sc[1][0] + y * sc[1][1] + z * sc[1][2] + pose-&gt;y;
-      p.z = x * sc[2][0] + y * sc[2][1] + z * sc[2][2] + pose-&gt;z;
-
-      /**/
-      if (ndmode == 1)
-        layer = 1;  // layer_select;
-      if (ndmode == 0)
-        layer = 0;  // layer_select;
-      nd_map = NDmap;
-
-      while (layer &gt; 0)
+      for (k = 0; k &lt; 3; k++)
       {
-        if (nd_map-&gt;next)
-          nd_map = nd_map-&gt;next;
-        layer--;
+        qd3[m + 3][k] = x * (*work) + y * (*(work + 1)) + z * (*(work + 2));
+        work += 3;
       }
+    }
 
-      /*NDND
-        */
-
-      if (!get_ND(nd_map, &amp;p, nd, target))
-        continue;
-
-      /*q()*/
-      work = (double *)sc_d;
-      for (m = 0; m &lt; 3; m++)
-      {
-        for (k = 0; k &lt; 3; k++)
-        {
-          // qd3[txtytzabg][xyz]
-          qd3[m + 3][k] = x * (*work) + y * (*(work + 1)) + z * (*(work + 2));
-          // x*sc_d[m][k][0] + y*sc_d[m][k][1] + z*sc_d[m][k][2];
+    work = (double *)sc_dd;
+    for (n = 0; n &lt; 3; n++) {
+      for (m = 0; m &lt; 3; m++) {
+        for (k = 0; k &lt; 3; k++) {
+          qdd3[n + 3][m + 3][k] = (*work * x + *(work + 1) * y + *(work + 2) * z - qd3[m + 3][k]) / E_THETA;
           work += 3;
         }
       }
+    }
 
-      /*q*/
-      work = (double *)sc_dd;
-      for (n = 0; n &lt; 3; n++)
-      {
-        for (m = 0; m &lt; 3; m++)
-        {
-          for (k = 0; k &lt; 3; k++)
-          {
-            qdd3[n + 3][m + 3][k] = (*work * x + *(work + 1) * y + *(work + 2) * z - qd3[m + 3][k]) / E_THETA;
-            work += 3;
-          }
-        }
-      }
-
-      /**/
-      if (nd[j])
+    if (nd[j])
+    {
+      if (nd[j]-&gt;num &gt; 10 &amp;&amp; nd[j]-&gt;sign == 1)
       {
-        if (nd[j]-&gt;num &gt; 10 &amp;&amp; nd[j]-&gt;sign == 1)
-        {
-          //	double e;
-          esum += calc_summand3d(&amp;p, nd[j], pose, g, hH, qd3, dist);
-          add_matrix6d(Hsumh, hH, Hsumh);
-
-          //	  dist =1;
-          gsum[0] += g[0];                //*nd[j]-&gt;w;
-          gsum[1] += g[1];                //*nd[j]-&gt;w;
-          gsum[2] += g[2] + pose-&gt;z * 0;  //*nd[j]-&gt;w;
-          gsum[3] += g[3];                //*nd[j]-&gt;w;
-          gsum[4] += g[4];                //+(pose-&gt;theta2-(0.0))*1;//*nd[j]-&gt;w;
-          gsum[5] += g[5];                //*nd[j]-&gt;w;
-          gnum += 1;  // nd[j]-&gt;w;
-        }
+        //	double e;
+        esum += calc_summand3d(&amp;p, nd[j], pose, g, hH, qd3, dist);
+        add_matrix6d(Hsumh, hH, Hsumh);
+
+        //	  dist =1;
+        gsum[0] += g[0];                //*nd[j]-&gt;w;
+        gsum[1] += g[1];                //*nd[j]-&gt;w;
+        gsum[2] += g[2] + pose-&gt;z * 0;  //*nd[j]-&gt;w;
+        gsum[3] += g[3];                //*nd[j]-&gt;w;
+        gsum[4] += g[4];                //+(pose-&gt;theta2-(0.0))*1;//*nd[j]-&gt;w;
+        gsum[5] += g[5];                //*nd[j]-&gt;w;
+        gnum += 1;                      // nd[j]-&gt;w;
       }
     }
   }
-  //#endif
 
   if (gnum &gt; 1)
   {
-    //  printf("gnum=%lf\n",gnum);
-    //    fclose(point_fp);
     identity_matrix6d(H);
     H[0][0] = H[0][0] / (gnum * gnum * 1000.001);
     H[1][1] = H[1][1] / (gnum * gnum * 1000.001);
@@ -519,7 +343,7 @@ double adjust3d(PointPtr scan, int num, PosturePtr initial, int target)
 
     ginverse_matrix6d(Hsumh, Hinv);
 
-    /*----------------------------------------*/
+
     pose-&gt;x -= (Hinv[0][0] * gsum[0] + Hinv[0][1] * gsum[1] + Hinv[0][2] * gsum[2] + Hinv[0][3] * gsum[3] +
                 Hinv[0][4] * gsum[4] + Hinv[0][5] * gsum[5]);
     pose-&gt;y -= (Hinv[1][0] * gsum[0] + Hinv[1][1] * gsum[1] + Hinv[1][2] * gsum[2] + Hinv[1][3] * gsum[3] +
@@ -581,35 +405,10 @@ void set_sincos2(double a, double b, double g, double sc[3][3])
   mux_matrix3d(W, Rz, R);
   mux_matrix3d(R, Ry, W);
   mux_matrix3d(W, Rx, sc);
-
-  /*
-  sc[0][0] =  ca*cb*cg-sa*sg;
-  sc[0][1] = -ca*cb*sg -sa*cg;
-  sc[0][2] =  ca*sb;
-  sc[1][0] =  sa*cb*cg+ca*sg;
-  sc[1][1] = -sa*cb*sg+ca*cg;
-  sc[1][2] =  sa*sb;
-  sc[2][0] = -sb*cg;
-  sc[2][1] =  sb*sg;
-  sc[2][2] =  cb;
-  */
-
-  /*
-  sc[0][0] =  ca*cb*cg-sa*sg;
-  sc[0][1] = -ca*cb*sg -sa*cg;
-  sc[0][2] =  ca*sb;
-  sc[1][0] =  sa*cb*cg+ca*sg;
-  sc[1][1] = -sa*cb*sg+ca*cg;
-  sc[1][2] =  sa*sb;
-  sc[2][0] = -sb*cg;
-  sc[2][1] =  sb*sg;
-  sc[2][2] =  cb;
-  */
 }
 
 void set_sincos(double a, double b, double g, double sc[3][3][3])
 {
-  //  double sa,ca,sb,cb,sg,cg;
   double dd[3][3][3], d[3][3];
   int i, j, k;
 
@@ -628,96 +427,4 @@ void set_sincos(double a, double b, double g, double sc[3][3][3])
       }
     }
   }
-
-  /*
-  sa = sin(a);
-  ca = cos(a);
-  sb = sin(b);
-  cb = cos(b);
-  sg = sin(g);
-  cg = cos(g);
-
-  //sc[tx ty tz a b g][x y z][x+y+z ]
-  sc[0][0][0] = -sa*cb*cg-ca*sg;
-  sc[0][0][1] =  sa*cb*sg-ca*cg;
-  sc[0][0][2] = -sa*sb;
-  sc[0][1][0] =  ca*cb*cg-sa*sg;
-  sc[0][1][1] = -ca*cb*sg-sa*cg;
-  sc[0][1][2] =  ca*sb;
-  sc[0][2][0] =  0;
-  sc[0][2][1] =  0;
-  sc[0][2][2] =  0;
-
-  sc[1][0][0] = -ca*sb*cg;
-  sc[1][0][1] =  ca*sb*sg;
-  sc[1][0][2] =  ca*cb;
-  sc[1][1][0] = -sa*sb*cg;
-  sc[1][1][1] =  sa*sb*sg;
-  sc[1][1][2] =  sa*cb;
-  sc[1][2][0] = -cb*cg;
-  sc[1][2][1] =  cb*sg;
-  sc[1][2][2] = -sb;
-
-
-  sc[2][0][0] = -ca*cb*sg-sa*cg;
-  sc[2][0][1] = -ca*cb*cg+sa*sg;
-  sc[2][0][2] =  0;
-  sc[2][1][0] = -sa*cb*sg+ca*cg;
-  sc[2][1][1] = -sa*cb*cg-ca*sg;
-  sc[2][1][2] =  0;
-  sc[2][2][0] =  sb*sg;
-  sc[2][2][1] =  sb*cg;
-  sc[2][2][2] =  0;
-  */
-}
-/*
-void set_sincos(double a,double b,double g,double sc_d[3][3][3]){
-  double sa,ca,sb,cb,sg,cg;
-
-  sa = sin(a);
-  ca = cos(a);
-  sb = sin(b);
-  cb = cos(b);
-  sg = sin(g);
-  cg = cos(g);
-
-  sc_d[0][0][0] = -sa*cb*cg - ca*sg;
-  sc_d[0][0][1] =  ca*sb*sg - sa*cg;
-  sc_d[0][0][2] = -sa*sb;
-
-  sc_d[1][0][0] =  ca*sb*cg;
-  sc_d[1][0][1] =  ca*sb*sg;
-  sc_d[1][0][2] =  ca*cb;
-
-  sc_d[2][0][0] =  -ca*cb*sg-sa*cg;
-  sc_d[2][0][1] =  -ca*cb*cg+sa*sg;
-  sc_d[2][0][2] =  0;
-
-
-  sc_d[0][1][0] =  ca*cb*cg - sa*sg;
-  sc_d[0][1][1] = -ca*cb*sg - sa*cg;
-  sc_d[0][1][2] =  ca*sb;
-
-  sc_d[1][1][0] =  -sa*sb*cg;
-  sc_d[1][1][1] =  sa*sb*sg;
-  sc_d[1][1][2] =  sa*cb;
-
-  sc_d[2][1][0] =  -sa*cb*sg+ca*cg;
-  sc_d[2][1][1] =  -sa*cb*cg-ca*sg;
-  sc_d[2][1][2] =  0;
-
-  sc_d[0][2][0] =  0;
-  sc_d[0][2][1] =  0;
-  sc_d[0][2][2] =  0;
-
-  sc_d[1][2][0] =  -cb*cg;
-  sc_d[1][2][1] =  cb*sg;
-  sc_d[1][2][2] =  -sb;
-
-  sc_d[2][2][0] =  sb*sg;
-  sc_d[2][2][1] =  sb*cg;
-  sc_d[2][2][2] =  0;
-
-}
-
-*/
+}
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping_tku\mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping_tku\mapping.cpp" added_lines="9" deleted_lines="9">
				<diff>@@ -1,21 +1,21 @@
 
+#include &lt;fstream&gt;
 #include &lt;iostream&gt;
 #include &lt;sstream&gt;
-#include &lt;fstream&gt;
 #include &lt;string&gt;
 
-#include "ros/ros.h"
-#include "std_msgs/String.h"
-#include "sensor_msgs/PointCloud2.h"
-#include "velodyne_pointcloud/point_types.h"
-#include "velodyne_pointcloud/rawdata.h"
+#include &lt;pcl_conversions/pcl_conversions.h&gt;
+#include &lt;pcl_ros/point_cloud.h&gt;
+#include &lt;pcl_ros/transforms.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;tf/transform_listener.h&gt;
+#include "ros/ros.h"
+#include "sensor_msgs/PointCloud2.h"
+#include "std_msgs/String.h"
 #include "tf/message_filter.h"
-#include &lt;pcl_ros/point_cloud.h&gt;
-#include &lt;pcl_ros/transforms.h&gt;
-#include &lt;pcl_conversions/pcl_conversions.h&gt;
+#include "velodyne_pointcloud/point_types.h"
+#include "velodyne_pointcloud/rawdata.h"
 
 #include &lt;message_filters/subscriber.h&gt;
 #include &lt;message_filters/time_synchronizer.h&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping_tku\ndt_mapping_tku.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping_tku\ndt_mapping_tku.cpp" added_lines="77" deleted_lines="711">
				<diff>@@ -14,42 +14,37 @@
 #include &lt;config.h&gt;
 #endif
 
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string&gt;
-#include &lt;unistd.h&gt;
-#include &lt;math.h&gt;
 #include &lt;GL/glut.h&gt;
+#include &lt;math.h&gt;
+#include &lt;stdio.h&gt;
 #include &lt;chrono&gt;
-#include "ndt.h"
+#include &lt;string&gt;
 #include "algebra.h"
+#include "ndt.h"
 
-#include "ros/ros.h"
-#include "std_msgs/String.h"
-#include "sensor_msgs/PointCloud2.h"
-#include &lt;geometry_msgs/TwistStamped.h&gt;
 #include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
-#include "velodyne_pointcloud/point_types.h"
-#include "velodyne_pointcloud/rawdata.h"
+#include &lt;geometry_msgs/TwistStamped.h&gt;
+#include &lt;pcl/filters/voxel_grid.h&gt;
+#include &lt;pcl/io/io.h&gt;
+#include &lt;pcl/io/pcd_io.h&gt;
+#include &lt;pcl_conversions/pcl_conversions.h&gt;
+#include &lt;tf/tf.h&gt;
 #include &lt;tf/transform_broadcaster.h&gt;
 #include &lt;tf/transform_listener.h&gt;
 #include &lt;iostream&gt;
-#include &lt;pcl/io/pcd_io.h&gt;
-#include &lt;pcl/point_types.h&gt;
-#include &lt;pcl/filters/voxel_grid.h&gt;
-
-#define DEFAULT_NDMAP_FILE "../data/nd_dat"
+#include "ros/ros.h"
+#include "sensor_msgs/PointCloud2.h"
+#include "std_msgs/String.h"
+#include "velodyne_pointcloud/point_types.h"
+#include "velodyne_pointcloud/rawdata.h"
 
 /*grobal variables*/
-NDMapPtr NDmap; /**/
+NDMapPtr NDmap;
 NDPtr NDs;
 int NDs_num;
 
-char scan_file_base_name[100];
-
 Point scan_points[130000];
 double scan_points_i[130000];
-double scan_points_e[130000];
 int scan_points_num;
 
 int is_first_time = 1;
@@ -60,9 +55,7 @@ double scan_points_totalweight;
 
 Point map_points[130000];
 double map_points_i[130000];
-int mapping_points_num;
 
-int scan_num;
 int layer_select = LAYER_NUM - 1;
 
 Posture prev_pose, prev_pose2;
@@ -70,39 +63,28 @@ Posture prev_pose, prev_pose2;
 // params
 double g_map_center_x, g_map_center_y, g_map_center_z;
 double g_map_rotation;
-int g_map_x, g_map_y, g_map_z;
-double g_map_cellsize;
 char g_ndmap_name[500];
 int g_use_gnss;
 int g_map_update = 1;
 double g_ini_x, g_ini_y, g_ini_z, g_ini_roll, g_ini_pitch, g_ini_yaw;
 
 static double _tf_x, _tf_y, _tf_z, _tf_roll, _tf_pitch, _tf_yaw;
-static Eigen::Matrix4f tf_btol, tf_ltob; // tf between base_link and localizer
+static Eigen::Matrix4f tf_btol, tf_ltob;  // tf between base_link and localizer
 static tf::Quaternion q_local_to_global;
 static Eigen::Matrix4f tf_local_to_global;
 
-void print_matrix3d(double mat[3][3]);
-void matrix_test(void);
-void print_matrix6d(double mat[6][6]);
-
 void save_nd_map(char *name);
 
 static pcl::PointCloud&lt;pcl::PointXYZ&gt; map;
-static int map_loaded = 0;
 
 static ros::Publisher ndmap_pub;
 
 static std::chrono::time_point&lt;std::chrono::system_clock&gt; matching_start, matching_end;
 static double exe_time = 0.0;
 
-std::string _downsampler = "voxel_grid";
-int _downsampler_num = 1;
-
 static ros::Publisher localizer_pose_pub, ndt_pose_pub;
 static geometry_msgs::PoseStamped localizer_pose_msg, ndt_pose_msg;
 
-
 // double pose_mod(Posture *pose){
 void pose_mod(Posture *pose)
 {
@@ -127,56 +109,7 @@ double nrand(double n)
   return r;
 }
 
-static void map_callback(const sensor_msgs::PointCloud2::ConstPtr &amp;input)
-{
-  if (map_loaded == 0)
-  {
-    // Convert the data type(from sensor_msgs to pcl).
-    pcl::fromROSMsg(*input, map);
-
-    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(map));
-    /*
-    // Setting point cloud to be aligned to.
-    ndt.setInputTarget(map_ptr);
-
-    // Setting NDT parameters to default values
-    ndt.setMaximumIterations(iter);
-    ndt.setResolution(ndt_res);
-    ndt.setStepSize(step_size);
-    ndt.setTransformationEpsilon(trans_eps);
-*/
-
-    /*
-        for(int i=2;i&lt;argc;i++){
-            printf("load(%d/%d) %s\n",i-2,argc-2,argv[i]);
-            load(argv[i]);
-          }
-    */
-    Point p;
-    for (pcl::PointCloud&lt;pcl::PointXYZ&gt;::const_iterator item = map_ptr-&gt;begin(); item != map_ptr-&gt;end(); item++)
-    {
-      p.x = (item-&gt;x - g_map_center_x) * cos(-g_map_rotation) - (item-&gt;y - g_map_center_y) * sin(-g_map_rotation);
-      p.y = (item-&gt;x - g_map_center_x) * sin(-g_map_rotation) + (item-&gt;y - g_map_center_y) * cos(-g_map_rotation);
-      p.z = item-&gt;z - g_map_center_z;
-
-      /*
-      p.x = item-&gt;x;
-      p.y = item-&gt;y;
-      p.z = item-&gt;z;
-      */
-      add_point_map(NDmap, &amp;p);
-    }
-    std::cout &lt;&lt; "Finished loading point cloud map." &lt;&lt; std::endl;
-    std::cout &lt;&lt; "Map points num: " &lt;&lt; map_ptr-&gt;size() &lt;&lt; " points." &lt;&lt; std::endl;
-
-    save_nd_map(g_ndmap_name);
-    is_map_exist = 1;
-
-    map_loaded = 1;
-  }
-}
-
-void points_callback(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::ConstPtr &amp;msg)
+void points_callback(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
 {
   matching_start = std::chrono::system_clock::now();
   static int count = 0;
@@ -184,115 +117,58 @@ void points_callback(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::ConstPtr &amp;msg)
   static FILE *log_fp;
   ros::Time time;
   static tf::TransformListener listener;
-  std_msgs::Header header;
+  static ros::Time current_scan_time;
+  current_scan_time = msg-&gt;header.stamp;
 
   static int iteration;
   int j = 0;
 
   Posture pose, bpose, initial_pose;
   static Posture key_pose;
-  //  double e=0,theta,x2,y2;
   double e = 0;
   double x_offset, y_offset, z_offset, theta_offset;
-  //  double distance,diff;
   double distance;
 
   tf::Quaternion ndt_q, localizer_q;
 
-  //  pcl_conversions::fromPCL(msg-&gt;header.stamp,time);
-  pcl_conversions::fromPCL(msg-&gt;header, header);
-
-  //  ROS_INFO("%s",msg-&gt;header.frame_id.c_str());
-  //  ROS_INFO("%f",msg-&gt;header.stamp.toSec());// + (double)msg-&gt;header.stamp.nsec/1000000000.);
-
-  /*  ros::Time stamp;
-  stamp = msg-&gt;header.stamp;
-  double now = ros::Time::now().toSec();
-  */
   if (!log_fp)
     log_fp = fopen("/tmp/ndt_log", "w");
 
-  //  ROS_INFO("get data %d",msg-&gt;points.size());
   count++;
   scan_points_totalweight = 0;
 
-  if (_downsampler == "voxel_grid")
-  {
-    pcl::PointCloud&lt;pcl::PointXYZ&gt; scan;
-
-    for (int i = 0; i &lt; (int)msg-&gt;points.size(); i++)
-    {
-      scan.points.push_back(pcl::PointXYZ(msg-&gt;points[i].x, msg-&gt;points[i].y, msg-&gt;points[i].z));
-    }
-    scan.header = msg-&gt;header;
-
-    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(scan));
-    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+  pcl::PointCloud&lt;pcl::PointXYZ&gt; scan;
+  pcl::fromROSMsg(*msg, scan);
 
-    pcl::VoxelGrid&lt;pcl::PointXYZ&gt; voxel_grid_filter;
-    voxel_grid_filter.setLeafSize(0.5, 0.5, 0.5);
-    voxel_grid_filter.setInputCloud(scan_ptr);
-    voxel_grid_filter.filter(*filtered_scan_ptr);
-    j = 0;
-    for (int i = 0; i &lt; (int)filtered_scan_ptr-&gt;points.size(); i++)
-    {
-      scan_points[j].x = filtered_scan_ptr-&gt;points[i].x + nrand(0.01);
-      scan_points[j].y = filtered_scan_ptr-&gt;points[i].y + nrand(0.01);
-      scan_points[j].z = filtered_scan_ptr-&gt;points[i].z + nrand(0.01);
-      scan_points_i[j] = 100;  // filterd_scan_ptr-&gt;points[i].intensity;
-
-      double dist = scan_points[j].x * scan_points[j].x + scan_points[j].y * scan_points[j].y +
-                    scan_points[j].z * scan_points[j].z;
-      if (dist &lt; 3 * 3)
-        continue;
-
-      scan_points_weight[j] = 1;
-      scan_points_totalweight += scan_points_weight[j];
-      j++;
-      if (j &gt; 130000)
-        break;
-    }
-    scan_points_num = j;
-    mapping_points_num = j;
-    //    printf("points_num = %d \n",scan_points_num);
-  }
+  pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(scan));
+  pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
 
-  if (_downsampler == "distance")
+  pcl::VoxelGrid&lt;pcl::PointXYZ&gt; voxel_grid_filter;
+  voxel_grid_filter.setLeafSize(0.5, 0.5, 0.5);
+  voxel_grid_filter.setInputCloud(scan_ptr);
+  voxel_grid_filter.filter(*filtered_scan_ptr);
+  j = 0;
+  for (int i = 0; i &lt; (int)filtered_scan_ptr-&gt;points.size(); i++)
   {
-    /*-------------------*/
-    j = 0;
-    for (int i = 0; i &lt; (int)msg-&gt;points.size(); i++)
-    {
-      scan_points[j].x = msg-&gt;points[i].x + nrand(0.01);
-      scan_points[j].y = msg-&gt;points[i].y + nrand(0.01);
-      scan_points[j].z = msg-&gt;points[i].z + nrand(0.01);
-      scan_points_i[j] = msg-&gt;points[i].intensity;
-
-      double dist = scan_points[j].x * scan_points[j].x + scan_points[j].y * scan_points[j].y +
-                    scan_points[j].z * scan_points[j].z;
-      if (dist &lt; 3 * 3)
-        continue;
-      scan_points_weight[j] = (dist) * (1.2 - exp(-1 * (-0.5 - scan_points[j].z) * (-0.5 - scan_points[j].z) / 2.0));
-      // scan_points_weight[j]= (1.2-exp(-1*(-0.5 - scan_points[j].z)*(-0.5 - scan_points[j].z)/2.0));
-      scan_points_totalweight += scan_points_weight[j];
-
-      j++;
-      if (j &gt; 130000)
-        break;
-    }
-    scan_points_num = j;
-    mapping_points_num = j;
-    //    printf("points_num = %d \n",scan_points_num);
+    scan_points[j].x = filtered_scan_ptr-&gt;points[i].x + nrand(0.01);
+    scan_points[j].y = filtered_scan_ptr-&gt;points[i].y + nrand(0.01);
+    scan_points[j].z = filtered_scan_ptr-&gt;points[i].z + nrand(0.01);
+    scan_points_i[j] = 100;  // filterd_scan_ptr-&gt;points[i].intensity;
+
+    double dist =
+        scan_points[j].x * scan_points[j].x + scan_points[j].y * scan_points[j].y + scan_points[j].z * scan_points[j].z;
+    if (dist &lt; 3 * 3)
+      continue;
+
+    scan_points_weight[j] = 1;
+    scan_points_totalweight += scan_points_weight[j];
+    j++;
+    if (j &gt; 130000)
+      break;
   }
+  scan_points_num = j;
 
   /*--matching---*/
-  /*
-  Posture pose, bpose,initial_pose;
-  static Posture key_pose;
-  double e=0,theta,x2,y2;
-  double x_offset,y_offset,z_offset,theta_offset;
-  double distance,diff;
-*/
   // calc offset
   x_offset = prev_pose.x - prev_pose2.x;
   y_offset = prev_pose.y - prev_pose2.y;
@@ -317,7 +193,6 @@ void points_callback(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::ConstPtr &amp;msg)
   // matching
   for (layer_select = 1; layer_select &gt;= 1; layer_select -= 1)
   {
-    //    	printf("layer=%d\n",layer_select);
     for (j = 0; j &lt; 100; j++)
     {
       if (layer_select != 1 &amp;&amp; j &gt; 2)
@@ -327,7 +202,6 @@ void points_callback(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::ConstPtr &amp;msg)
       bpose = pose;
 
       e = adjust3d(scan_points, scan_points_num, &amp;pose, layer_select);
-      //	printf("%f\n",e);
 
       pose_mod(&amp;pose);
 
@@ -378,23 +252,14 @@ void points_callback(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::ConstPtr &amp;msg)
         pose.theta3 = yaw + nrand(0.7);
         prev_pose2 = prev_pose = pose;
         printf("reset %f %f %f %f %f %f\n", pose.x, pose.y, pose.z, pose.theta, pose.theta2, pose.theta3);
-        // reset
-
-        /*	tf::Transform transform;
-  //tf::Quaternion q;
-transform.setOrigin( tf::Vector3(pose.x, pose.y, pose.z) );
-q.setRPY(pose.theta,pose.theta2,pose.theta3);
-transform.setRotation(q);
-br.sendTransform(tf::StampedTransform(transform, ros::Time::now(),  "world", "ndt_frame"));
-*/
+
         return;
       }
     }
-    // unti-distotion
 
-    if (layer_select == 2 &amp;&amp; 1)
+    // unti-distotion
+    if (layer_select == 2)
     {
-      //    		double rate,angle,xrate,yrate,dx,dy,dtheta;
       double rate, xrate, yrate, dx, dy, dtheta;
       double tempx, tempy;
       int i;
@@ -446,13 +311,14 @@ br.sendTransform(tf::StampedTransform(transform, ros::Time::now(),  "world", "nd
   Eigen::Matrix4f global_t = tf_local_to_global * local_t;
 
   tf::Matrix3x3 mat_l;
-  mat_l.setValue(static_cast&lt;double&gt;(global_t(0, 0)), static_cast&lt;double&gt;(global_t(0, 1)), static_cast&lt;double&gt;(global_t(0, 2)),
-                 static_cast&lt;double&gt;(global_t(1, 0)), static_cast&lt;double&gt;(global_t(1, 1)), static_cast&lt;double&gt;(global_t(1, 2)),
-                 static_cast&lt;double&gt;(global_t(2, 0)), static_cast&lt;double&gt;(global_t(2, 1)), static_cast&lt;double&gt;(global_t(2, 2)));
+  mat_l.setValue(
+      static_cast&lt;double&gt;(global_t(0, 0)), static_cast&lt;double&gt;(global_t(0, 1)), static_cast&lt;double&gt;(global_t(0, 2)),
+      static_cast&lt;double&gt;(global_t(1, 0)), static_cast&lt;double&gt;(global_t(1, 1)), static_cast&lt;double&gt;(global_t(1, 2)),
+      static_cast&lt;double&gt;(global_t(2, 0)), static_cast&lt;double&gt;(global_t(2, 1)), static_cast&lt;double&gt;(global_t(2, 2)));
 
   mat_l.getRotation(localizer_q);
   localizer_pose_msg.header.frame_id = "/map";
-  localizer_pose_msg.header.stamp = header.stamp;
+  localizer_pose_msg.header.stamp = current_scan_time;
   localizer_pose_msg.pose.position.x = global_t(0, 3);
   localizer_pose_msg.pose.position.y = global_t(1, 3);
   localizer_pose_msg.pose.position.z = global_t(2, 3);
@@ -464,13 +330,14 @@ br.sendTransform(tf::StampedTransform(transform, ros::Time::now(),  "world", "nd
   // base_link
   Eigen::Matrix4f global_t2 = global_t * tf_ltob;
   tf::Matrix3x3 mat_b;  // base_link
-  mat_b.setValue(static_cast&lt;double&gt;(global_t2(0, 0)), static_cast&lt;double&gt;(global_t2(0, 1)), static_cast&lt;double&gt;(global_t2(0, 2)),
-                 static_cast&lt;double&gt;(global_t2(1, 0)), static_cast&lt;double&gt;(global_t2(1, 1)), static_cast&lt;double&gt;(global_t2(1, 2)),
-                 static_cast&lt;double&gt;(global_t2(2, 0)), static_cast&lt;double&gt;(global_t2(2, 1)), static_cast&lt;double&gt;(global_t2(2, 2)));
+  mat_b.setValue(
+      static_cast&lt;double&gt;(global_t2(0, 0)), static_cast&lt;double&gt;(global_t2(0, 1)), static_cast&lt;double&gt;(global_t2(0, 2)),
+      static_cast&lt;double&gt;(global_t2(1, 0)), static_cast&lt;double&gt;(global_t2(1, 1)), static_cast&lt;double&gt;(global_t2(1, 2)),
+      static_cast&lt;double&gt;(global_t2(2, 0)), static_cast&lt;double&gt;(global_t2(2, 1)), static_cast&lt;double&gt;(global_t2(2, 2)));
   mat_b.getRotation(ndt_q);
 
   ndt_pose_msg.header.frame_id = "/map";
-  ndt_pose_msg.header.stamp = header.stamp;
+  ndt_pose_msg.header.stamp = current_scan_time;
   ndt_pose_msg.pose.position.x = global_t2(0, 3);
   ndt_pose_msg.pose.position.y = global_t2(1, 3);
   ndt_pose_msg.pose.position.z = global_t2(2, 3);
@@ -512,34 +379,24 @@ br.sendTransform(tf::StampedTransform(transform, ros::Time::now(),  "world", "nd
     prev_pose2 = prev_pose;
     is_first_time = 0;
   }
-  /*
-  printf("%f %f %f %f %f %f %f %d \n",0,//(double)msg-&gt;header.stamp.toSec(),
-   pose.x,pose.y,pose.z,pose.theta,pose.theta2,pose.theta3,NDs_num) ;
-*/
-  fprintf(log_fp, "%f %f %f %f %f %f %f\n", (double)header.stamp.toSec(),
+
+  fprintf(log_fp, "%f %f %f %f %f %f %f\n", current_scan_time.toSec(),
           pose.x * cos(g_map_rotation) - pose.y * sin(g_map_rotation) + g_map_center_x,
           pose.x * sin(g_map_rotation) + pose.y * cos(g_map_rotation) + g_map_center_y, pose.z + g_map_center_z,
           pose.theta, pose.theta2, pose.theta3 + g_map_rotation);
 
   fflush(log_fp);
   tf::Transform transform;
-//  tf::Quaternion q;
-//  transform.setOrigin(tf::Vector3(pose.x, pose.y, pose.z));
-//  transform.setOrigin(tf::Vector3(pose.x + g_map_center_x, pose.y + g_map_center_y, pose.z + g_map_center_z));
   transform.setOrigin(tf::Vector3(global_t2(0, 3), global_t2(1, 3), global_t2(2, 3)));
-//  q.setRPY(pose.theta, pose.theta2, pose.theta3);
-//  transform.setRotation(q_local_to_global * q);
   transform.setRotation(ndt_q);
 
-//  br.sendTransform(tf::StampedTransform(transform, header.stamp, "map", "velodyne"));
-  br.sendTransform(tf::StampedTransform(transform, header.stamp, "map", "base_link"));
+  br.sendTransform(tf::StampedTransform(transform, current_scan_time, "map", "base_link"));
 
   matching_end = std::chrono::system_clock::now();
   exe_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(matching_end - matching_start).count() / 1000.0;
 
   std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
   std::cout &lt;&lt; "Sequence number: " &lt;&lt; msg-&gt;header.seq &lt;&lt; std::endl;
-  std::cout &lt;&lt; "Number of scan points: " &lt;&lt; msg-&gt;size() &lt;&lt; " points." &lt;&lt; std::endl;
   std::cout &lt;&lt; "Number of filtered scan points: " &lt;&lt; scan_points_num &lt;&lt; " points." &lt;&lt; std::endl;
   std::cout &lt;&lt; "Number of iteration: " &lt;&lt; iteration &lt;&lt; std::endl;
   std::cout &lt;&lt; "Execution time: " &lt;&lt; exe_time &lt;&lt; std::endl;
@@ -547,404 +404,6 @@ br.sendTransform(tf::StampedTransform(transform, ros::Time::now(),  "world", "nd
   std::cout &lt;&lt; "(" &lt;&lt; pose.x &lt;&lt; ", " &lt;&lt; pose.y &lt;&lt; ", " &lt;&lt; pose.z &lt;&lt; ", " &lt;&lt; pose.theta &lt;&lt; ", " &lt;&lt; pose.theta2 &lt;&lt; ", "
             &lt;&lt; pose.theta3 &lt;&lt; ")" &lt;&lt; std::endl;
   std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
-
-  //  ROS_INFO("get data %d",msg-&gt;points.size());
-}
-
-/*add point to ndcell */
-int add_point_covariance(NDPtr nd, PointPtr p)
-{
-  /*add data num*/
-  nd-&gt;num++;
-  nd-&gt;flag = 0; /*need to update*/
-  // printf("%d \n",nd-&gt;num);
-
-  /*calcurate means*/
-  nd-&gt;m_x += p-&gt;x;
-  nd-&gt;m_y += p-&gt;y;
-  nd-&gt;m_z += p-&gt;z;
-
-  /*calcurate covariances*/
-  nd-&gt;c_xx += p-&gt;x * p-&gt;x;
-  nd-&gt;c_yy += p-&gt;y * p-&gt;y;
-  nd-&gt;c_zz += p-&gt;z * p-&gt;z;
-
-  nd-&gt;c_xy += p-&gt;x * p-&gt;y;
-  nd-&gt;c_yz += p-&gt;y * p-&gt;z;
-  nd-&gt;c_zx += p-&gt;z * p-&gt;x;
-
-  return 1;
-}
-
-int inv_check(double inv[3][3])
-{
-  for (int i = 0; i &lt; 3; i++)
-  {
-    for (int j = 0; j &lt; 3; j++)
-    {
-      if (std::isnan(inv[i][j]))
-        return 0;
-      if (fabs(inv[i][j]) &gt; 1000)
-        return 0;
-    }
-  }
-  return 1;
-}
-
-/*calcurate covariances*/
-int update_covariance(NDPtr nd)
-{
-  double a, b, c; /*for calcurate*/
-  if (!nd-&gt;flag)
-  { /*need calcurate?*/
-    /*means*/
-    nd-&gt;mean.x = a = nd-&gt;m_x / nd-&gt;num;
-    nd-&gt;mean.y = b = nd-&gt;m_y / nd-&gt;num;
-    nd-&gt;mean.z = c = nd-&gt;m_z / nd-&gt;num;
-
-    /*covariances*/
-    nd-&gt;covariance[0][0] = (nd-&gt;c_xx - 2 * a * nd-&gt;m_x) / nd-&gt;num + a * a;
-    nd-&gt;covariance[1][1] = (nd-&gt;c_yy - 2 * b * nd-&gt;m_y) / nd-&gt;num + b * b;
-    nd-&gt;covariance[2][2] = (nd-&gt;c_zz - 2 * c * nd-&gt;m_z) / nd-&gt;num + c * c;
-    nd-&gt;covariance[0][1] = nd-&gt;covariance[1][0] = (nd-&gt;c_xy - nd-&gt;m_x * b - nd-&gt;m_y * a) / nd-&gt;num + a * b;
-    nd-&gt;covariance[1][2] = nd-&gt;covariance[2][1] = (nd-&gt;c_yz - nd-&gt;m_y * c - nd-&gt;m_z * b) / nd-&gt;num + b * c;
-    nd-&gt;covariance[2][0] = nd-&gt;covariance[0][2] = (nd-&gt;c_zx - nd-&gt;m_z * a - nd-&gt;m_x * c) / nd-&gt;num + c * a;
-    nd-&gt;sign = 0;
-    nd-&gt;flag = 1; /*this ND updated*/
-    if (nd-&gt;num &gt;= 5)
-    {
-      if (1 || round_covariance(nd) == 1)
-      {
-        if (ginverse_matrix3d(nd-&gt;covariance, nd-&gt;inv_covariance))
-          if (inv_check(nd-&gt;inv_covariance))
-            nd-&gt;sign = 1;
-      }
-    }
-  }
-
-  return 1;
-}
-
-/*add point to ndmap*/
-int add_point_map(NDMapPtr ndmap, PointPtr point)
-{
-  int x, y, z, i;
-  NDPtr *ndp[8];
-
-  /*
-
-  +---+---+
-  |   |   |
-  +---+---+
-  |   |###|
-  +---+---+
-
-  */
-
-  /*mapping*/
-  x = (point-&gt;x / ndmap-&gt;size) + ndmap-&gt;x / 2;
-  y = (point-&gt;y / ndmap-&gt;size) + ndmap-&gt;y / 2;
-  z = (point-&gt;z / ndmap-&gt;size) + ndmap-&gt;z / 2;
-
-  /*clipping*/
-  if (x &lt; 1 || x &gt;= ndmap-&gt;x)
-    return 0;
-  if (y &lt; 1 || y &gt;= ndmap-&gt;y)
-    return 0;
-  if (z &lt; 1 || z &gt;= ndmap-&gt;z)
-    return 0;
-
-  /*select root ND*/
-  ndp[0] = ndmap-&gt;nd + x * ndmap-&gt;to_x + y * ndmap-&gt;to_y + z;
-  ndp[1] = ndp[0] - ndmap-&gt;to_x;
-  ndp[2] = ndp[0] - ndmap-&gt;to_y;
-  ndp[4] = ndp[0] - 1;
-  ndp[3] = ndp[2] - ndmap-&gt;to_x;
-  ndp[5] = ndp[4] - ndmap-&gt;to_x;
-  ndp[6] = ndp[4] - ndmap-&gt;to_y;
-  ndp[7] = ndp[3] - 1;
-
-  /*add  point to map */
-  for (i = 0; i &lt; 8; i++)
-  {
-    if ((*ndp[i]) == 0)
-      *ndp[i] = add_ND();
-    if ((*ndp[i]) != 0)
-      add_point_covariance(*ndp[i], point);
-  }
-
-  if (ndmap-&gt;next)
-  {
-    add_point_map(ndmap-&gt;next, point);
-  }
-
-  return 0;
-}
-
-/*get nd cell at point*/
-int get_ND(NDMapPtr ndmap, PointPtr point, NDPtr *nd, int ndmode)
-{
-  int x, y, z;
-  int i;
-  NDPtr *ndp[8];
-
-  /*
-    
-  +---+---+
-  |   |   |
-  +---+---+
-  |   |###|
-  +---+---+
-  
-  */ /*
-   layer = layer_select;
-   while(layer &gt; 0){
-     if(ndmap-&gt;next)ndmap = ndmap-&gt;next;
-     layer--;
-   }
-     */
-  /*mapping*/
-  if (ndmode &lt; 3)
-  {
-    x = (double)((point-&gt;x / ndmap-&gt;size) + ndmap-&gt;x / 2 - 0.5);
-    y = (double)((point-&gt;y / ndmap-&gt;size) + ndmap-&gt;y / 2 - 0.5);
-    z = (double)((point-&gt;z / ndmap-&gt;size) + ndmap-&gt;z / 2 - 0.5);
-  }
-  else
-  {
-    x = (point-&gt;x / ndmap-&gt;size) + ndmap-&gt;x / 2;
-    y = (point-&gt;y / ndmap-&gt;size) + ndmap-&gt;y / 2;
-    z = (point-&gt;z / ndmap-&gt;size) + ndmap-&gt;z / 2;
-  }
-
-  /*clipping*/
-  if (x &lt; 1 || x &gt;= ndmap-&gt;x)
-    return 0;
-  if (y &lt; 1 || y &gt;= ndmap-&gt;y)
-    return 0;
-  if (z &lt; 1 || z &gt;= ndmap-&gt;z)
-    return 0;
-
-  /*select root ND*/
-  ndp[0] = ndmap-&gt;nd + x * ndmap-&gt;to_x + y * ndmap-&gt;to_y + z;
-  ndp[1] = ndp[0] - ndmap-&gt;to_x;
-  ndp[2] = ndp[0] - ndmap-&gt;to_y;
-  ndp[4] = ndp[0] - 1;
-  ndp[3] = ndp[2] - ndmap-&gt;to_x;
-  ndp[5] = ndp[4] - ndmap-&gt;to_x;
-  ndp[6] = ndp[4] - ndmap-&gt;to_y;
-  ndp[7] = ndp[3] - 1;
-
-  for (i = 0; i &lt; 8; i++)
-  {
-    if (*ndp[i] != 0)
-    {
-      if (!(*ndp[i])-&gt;flag)
-        update_covariance(*ndp[i]);
-      nd[i] = *ndp[i];
-    }
-    else
-    {
-      nd[i] = NDs;
-      // return 0;
-    }
-  }
-
-  return 1;
-}
-
-NDPtr add_ND(void)
-{
-  NDPtr ndp;
-  // int m;
-
-  if (NDs_num &gt;= MAX_ND_NUM)
-  {
-    printf("over flow\n");
-    return 0;
-  }
-
-  ndp = NDs + NDs_num;
-  NDs_num++;
-
-  ndp-&gt;flag = 0;
-  ndp-&gt;sign = 0;
-  ndp-&gt;num = 0;
-  ndp-&gt;m_x = 0;
-  ndp-&gt;m_y = 0;
-  ndp-&gt;m_z = 0;
-  ndp-&gt;c_xx = 0;
-  ndp-&gt;c_yy = 0;
-  ndp-&gt;c_zz = 0;
-  ndp-&gt;c_xy = 0;
-  ndp-&gt;c_yz = 0;
-  ndp-&gt;c_zx = 0;
-  ndp-&gt;w = 1;
-  ndp-&gt;is_source = 0;
-
-  return ndp;
-}
-
-NDMapPtr initialize_NDmap_layer(int layer, NDMapPtr child)
-{
-  // int i,j,k,i2,i3,m;
-  int i, j, k;
-  int x, y, z;
-  NDPtr *nd, *ndp;
-  NDMapPtr ndmap;
-
-  //  i2 = i3 = 0;
-  //  printf("Initializing...layer %d\n",layer);
-
-  x = (g_map_x &gt;&gt; layer) + 1;
-  y = (g_map_y &gt;&gt; layer) + 1;
-  z = (g_map_z &gt;&gt; layer) + 1;
-
-  /**/
-  nd = (NDPtr *)malloc(x * y * z * sizeof(NDPtr));
-  ndmap = (NDMapPtr)malloc(sizeof(NDMap));
-
-  ndmap-&gt;x = x;
-  ndmap-&gt;y = y;
-  ndmap-&gt;z = z;
-  ndmap-&gt;to_x = y * z;
-  ndmap-&gt;to_y = z;
-  ndmap-&gt;layer = layer;
-  ndmap-&gt;nd = nd;
-  ndmap-&gt;next = child;
-  ndmap-&gt;size = g_map_cellsize * ((int)1 &lt;&lt; layer);
-  //  printf("size %f\n",ndmap-&gt;size);
-
-  ndp = nd;
-
-  /**/
-  for (i = 0; i &lt; x; i++)
-  {
-    for (j = 0; j &lt; y; j++)
-    {
-      for (k = 0; k &lt; z; k++)
-      {
-        *ndp = 0;
-        ndp++;
-      }
-    }
-  }
-
-  /**/
-  return ndmap;
-}
-
-/*ND*/
-NDMapPtr initialize_NDmap(void)
-{
-  int i;
-  NDMapPtr ndmap;
-  NDPtr null_nd;
-
-  printf("Initialize NDmap\n");
-  ndmap = 0;
-
-  // init NDs
-  NDs = (NDPtr)malloc(sizeof(NormalDistribution) * MAX_ND_NUM);
-  NDs_num = 0;
-
-  null_nd = add_ND();
-
-  for (i = LAYER_NUM - 1; i &gt;= 0; i--)
-  {
-    ndmap = initialize_NDmap_layer(i, ndmap);
-
-    /*progress dots*/
-    //    printf("layer %d\n",i);
-  }
-
-  //  printf("done\n");
-
-  return ndmap; /**/
-}
-
-int round_covariance(NDPtr nd)
-{
-  double v[3][3], a;
-
-  eigenvecter_matrix3d(nd-&gt;covariance, v, nd-&gt;l);
-  //  print_matrix3d(v);
-  if (fabs(v[0][0] * v[0][0] + v[1][0] * v[1][0] + v[2][0] * v[2][0] - 1) &gt; 0.1)
-    printf("!1");
-  if (fabs(v[0][0] * v[0][1] + v[1][0] * v[1][1] + v[2][0] * v[2][1]) &gt; 0.01)
-    printf("!01");
-  if (fabs(v[0][1] * v[0][2] + v[1][1] * v[1][2] + v[2][1] * v[2][2]) &gt; 0.01)
-    printf("!02");
-  if (fabs(v[0][2] * v[0][0] + v[1][2] * v[1][0] + v[2][2] * v[2][0]) &gt; 0.01)
-    printf("!03");
-
-  a = fabs(nd-&gt;l[1] / nd-&gt;l[0]);
-  if (a &lt; 0.001)
-  {
-    return 0;
-    if (nd-&gt;l[1] &gt; 0)
-      nd-&gt;l[1] = fabs(nd-&gt;l[0]) / 10.0;
-    else
-      nd-&gt;l[1] = -fabs(nd-&gt;l[0]) / 10.0;
-
-    a = fabs(nd-&gt;l[2] / nd-&gt;l[0]);
-    if (a &lt; 0.01)
-    {
-      if (nd-&gt;l[2] &gt; 0)
-        nd-&gt;l[2] = fabs(nd-&gt;l[0]) / 10.0;
-      else
-        nd-&gt;l[2] = -fabs(nd-&gt;l[0]) / 10.0;
-    }
-    //    printf("r");
-    matrix3d_eigen(v, nd-&gt;l[0], nd-&gt;l[1], nd-&gt;l[2], nd-&gt;covariance);
-  }
-  return 1;
-}
-
-/*ND*/
-double probability_on_ND(NDPtr nd, double xp, double yp, double zp)
-{
-  //  double xp,yp,zp;
-  double e;
-
-  if (nd-&gt;num &lt; 5)
-    return 0;
-  /*
-  xp = x - nd-&gt;mean.x;
-  yp = y - nd-&gt;mean.y;
-  zp = z - nd-&gt;mean.z;
-  */
-  e = exp((xp * xp * nd-&gt;inv_covariance[0][0] + yp * yp * nd-&gt;inv_covariance[1][1] +
-           zp * zp * nd-&gt;inv_covariance[2][2] + 2.0 * xp * yp * nd-&gt;inv_covariance[0][1] +
-           2.0 * yp * zp * nd-&gt;inv_covariance[1][2] + 2.0 * zp * xp * nd-&gt;inv_covariance[2][0]) /
-          -2.0);
-
-  if (e &gt; 1)
-    return 1;
-  if (e &lt; 0)
-    return 0;
-  return (e);
-}
-
-void load(char *name)
-{
-  FILE *fp;
-  double x, y, z, q;
-  Point p;
-
-  fp = fopen(name, "r");
-  int i = 0;
-  while (fscanf(fp, "%lf %lf %lf %lf", &amp;y, &amp;x, &amp;z, &amp;q) != EOF)
-  {  // x,y swaped
-    p.x = (x - g_map_center_x) * cos(-g_map_rotation) - (y - g_map_center_y) * sin(-g_map_rotation);
-    p.y = (x - g_map_center_x) * sin(-g_map_rotation) + (y - g_map_center_y) * cos(-g_map_rotation);
-    p.z = z - g_map_center_z;
-    add_point_map(NDmap, &amp;p);
-    std::cout &lt;&lt; i &lt;&lt; std::endl;
-    i++;
-  }
-  std::cout &lt;&lt; "Finished loading " &lt;&lt; name &lt;&lt; std::endl;
-  fclose(fp);
 }
 
 void save_nd_map(char *name)
@@ -955,23 +414,15 @@ void save_nd_map(char *name)
   NDPtr *ndp;
   FILE *ofp;
 
-  // for pcd
   pcl::PointCloud&lt;pcl::PointXYZ&gt; cloud;
   pcl::PointXYZ p;
 
-  // cloud.is_dense = false;
-  // cloud.points.resize (cloud.width * cloud.height);
-  // ros::Time stamp;
-  // stamp = msg-&gt;header.stamp;
-  // double now = ros::Time::now().toSec();
-
   ndmap = NDmap;
   ofp = fopen(name, "w");
 
   for (layer = 0; layer &lt; 2; layer++)
   {
     ndp = ndmap-&gt;nd;
-    /**/
     for (i = 0; i &lt; ndmap-&gt;x; i++)
     {
       for (j = 0; j &lt; ndmap-&gt;y; j++)
@@ -998,15 +449,13 @@ void save_nd_map(char *name)
           ndp++;
         }
       }
-      //      printf("a\n");
     }
     ndmap = ndmap-&gt;next;
   }
-  //  printf("done\n");
   fclose(ofp);
 
   // save pcd
-/*
+
   cloud.header.frame_id = "/map";
   cloud.width = cloud.points.size();
   cloud.height = 1;
@@ -1016,85 +465,17 @@ void save_nd_map(char *name)
   sensor_msgs::PointCloud2::Ptr ndmap_ptr(new sensor_msgs::PointCloud2);
   pcl::toROSMsg(cloud, *ndmap_ptr);
   ndmap_pub.publish(*ndmap_ptr);
-  */
-}
-
-// load ndt setting file
-int load_ndt_ini(char *name)
-{
-  FILE *ifp;
-
-  ifp = fopen(name, "r");
-  if (!ifp)
-    return 0;
-
-  // map path
-  if (fscanf(ifp, "%s", g_ndmap_name) == EOF)
-    return 0;
-  // map size
-  if (fscanf(ifp, "%d %d %d %lf", &amp;g_map_x, &amp;g_map_y, &amp;g_map_z, &amp;g_map_cellsize) == EOF)
-    return 0;
-  // map center
-  if (fscanf(ifp, "%lf %lf %lf %lf", &amp;g_map_center_x, &amp;g_map_center_y, &amp;g_map_center_z, &amp;g_map_rotation) == EOF)
-    return 0;
-  // use gnss
-  if (fscanf(ifp, "%d", &amp;g_use_gnss) == EOF)
-    return 0;
-  if (!g_use_gnss)
-  {
-    if (fscanf(ifp, "%lf %lf %lf %lf %lf %lf", &amp;g_ini_x, &amp;g_ini_y, &amp;g_ini_z, &amp;g_ini_roll, &amp;g_ini_pitch, &amp;g_ini_yaw) ==
-        EOF)
-      return 0;
-  }
-
-  //
-  return 1;
 }
 
-int load_nd_map(char *name)
-{
-  //  int i,j,k,layer;
-  NDData nddat;
-  NDMapPtr ndmap[2];
-  NDPtr ndp;
-  FILE *ifp;
-  //  FILE *logfp;
-
-  ndmap[0] = NDmap;
-  ndmap[1] = NDmap-&gt;next;
-
-  ifp = fopen(name, "r");
-  if (!ifp)
-    return 0;
-
-  while (fread(&amp;nddat, sizeof(NDData), 1, ifp) &gt; 0)
-  {
-    ndp = add_ND();
-    *ndp = nddat.nd;
-    *(ndmap[nddat.layer]-&gt;nd + nddat.x * ndmap[nddat.layer]-&gt;to_x + nddat.y * ndmap[nddat.layer]-&gt;to_y + nddat.z) = ndp;
-    ndp-&gt;flag = 0;
-    update_covariance(ndp);
-    // fprintf(logfp,"%f %f %f \n",ndp-&gt;mean.x, ndp-&gt;mean.y, ndp-&gt;mean.z);
-  }
-
-  printf("%d NDVoxels are loaded\n", NDs_num);
-  fclose(ifp);
-  return 1;
-}
-
-/**/
 int main(int argc, char *argv[])
 {
-  printf("----------------------\n");
-  printf(" 3D NDT scan matching \n");
-  printf("----------------------\n");
+  std::cout &lt;&lt; " 3D NDT scan mapping" &lt;&lt; std::endl;
 
-  ros::init(argc, argv, "ndt_matching_tku");
+  ros::init(argc, argv, "ndt_mapping_tku");
 
   ros::NodeHandle nh;
   ros::NodeHandle private_nh("~");
 
-  private_nh.getParam("downsampler", _downsampler);
   private_nh.getParam("init_x", g_ini_x);
   private_nh.getParam("init_y", g_ini_y);
   private_nh.getParam("init_z", g_ini_z);
@@ -1102,55 +483,45 @@ int main(int argc, char *argv[])
   private_nh.getParam("init_pitch", g_ini_pitch);
   private_nh.getParam("init_yaw", g_ini_yaw);
 
-  std::cout &lt;&lt; "Downsampler: " &lt;&lt; _downsampler &lt;&lt; std::endl;
-  if (_downsampler == "voxel_grid")
-  {
-    _downsampler_num = 1;
-  }
-  if (_downsampler == "distance")
-  {
-    _downsampler_num = 0;
-  }
-
-  if (nh.getParam("tf_x", _tf_x) == false)
+  if (!nh.getParam("tf_x", _tf_x))
   {
     std::cout &lt;&lt; "tf_x is not set." &lt;&lt; std::endl;
     return 1;
   }
-  if (nh.getParam("tf_y", _tf_y) == false)
+  if (!nh.getParam("tf_y", _tf_y))
   {
     std::cout &lt;&lt; "tf_y is not set." &lt;&lt; std::endl;
     return 1;
   }
-  if (nh.getParam("tf_z", _tf_z) == false)
+  if (!nh.getParam("tf_z", _tf_z))
   {
     std::cout &lt;&lt; "tf_z is not set." &lt;&lt; std::endl;
     return 1;
   }
-  if (nh.getParam("tf_roll", _tf_roll) == false)
+  if (!nh.getParam("tf_roll", _tf_roll))
   {
     std::cout &lt;&lt; "tf_roll is not set." &lt;&lt; std::endl;
     return 1;
   }
-  if (nh.getParam("tf_pitch", _tf_pitch) == false)
+  if (!nh.getParam("tf_pitch", _tf_pitch))
   {
     std::cout &lt;&lt; "tf_pitch is not set." &lt;&lt; std::endl;
     return 1;
   }
-  if (nh.getParam("tf_yaw", _tf_yaw) == false)
+  if (!nh.getParam("tf_yaw", _tf_yaw))
   {
     std::cout &lt;&lt; "tf_yaw is not set." &lt;&lt; std::endl;
     return 1;
   }
 
-  Eigen::Translation3f tl_btol(_tf_x, _tf_y, _tf_z);  // tl: translation
+  Eigen::Translation3f tl_btol(_tf_x, _tf_y, _tf_z);                 // tl: translation
   Eigen::AngleAxisf rot_x_btol(_tf_roll, Eigen::Vector3f::UnitX());  // rot: rotation
   Eigen::AngleAxisf rot_y_btol(_tf_pitch, Eigen::Vector3f::UnitY());
   Eigen::AngleAxisf rot_z_btol(_tf_yaw, Eigen::Vector3f::UnitZ());
   tf_btol = (tl_btol * rot_z_btol * rot_y_btol * rot_x_btol).matrix();
 
   Eigen::Translation3f tl_ltob((-1.0) * _tf_x, (-1.0) * _tf_y, (-1.0) * _tf_z);  // tl: translation
-  Eigen::AngleAxisf rot_x_ltob((-1.0) * _tf_roll, Eigen::Vector3f::UnitX());  // rot: rotation
+  Eigen::AngleAxisf rot_x_ltob((-1.0) * _tf_roll, Eigen::Vector3f::UnitX());     // rot: rotation
   Eigen::AngleAxisf rot_y_ltob((-1.0) * _tf_pitch, Eigen::Vector3f::UnitY());
   Eigen::AngleAxisf rot_z_ltob((-1.0) * _tf_yaw, Eigen::Vector3f::UnitZ());
   tf_ltob = (tl_ltob * rot_z_ltob * rot_y_ltob * rot_x_ltob).matrix();
@@ -1172,11 +543,12 @@ int main(int argc, char *argv[])
   g_use_gnss = 0;
 
   Eigen::Translation3f tl_local_to_global(g_map_center_x, g_map_center_y, g_map_center_z);  // tl: translation
-  Eigen::AngleAxisf rot_x_local_to_global(0.0, Eigen::Vector3f::UnitX());  // rot: rotation
+  Eigen::AngleAxisf rot_x_local_to_global(0.0, Eigen::Vector3f::UnitX());                   // rot: rotation
   Eigen::AngleAxisf rot_y_local_to_global(0.0, Eigen::Vector3f::UnitY());
   Eigen::AngleAxisf rot_z_local_to_global(g_map_rotation, Eigen::Vector3f::UnitZ());
   q_local_to_global.setRPY(0.0, 0.0, g_map_rotation);
-  tf_local_to_global = (tl_local_to_global * rot_z_local_to_global * rot_y_local_to_global * rot_x_local_to_global).matrix();
+  tf_local_to_global =
+      (tl_local_to_global * rot_z_local_to_global * rot_y_local_to_global * rot_x_local_to_global).matrix();
 
   /*initialize(clear) NDmap data*/
   NDmap = initialize_NDmap();
@@ -1196,16 +568,10 @@ int main(int argc, char *argv[])
   ndt_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/ndt_pose", 1000);
   localizer_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/localizer_pose", 1000);
 
-//  ros::Subscriber map_sub = nh.subscribe("points_map", 10, map_callback);
   ros::Subscriber points_sub = nh.subscribe("points_raw", 1000, points_callback);
 
-  /*
-    while (ros::ok()){
-      ros::spinOnce();
-    }
-  */
   ros::spin();
 
   save_nd_map((char *)"/tmp/ndmap");
   return 1;
-}
+}
\ No newline at end of file
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching_tku\ndt_matching_tku.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching_tku\ndt_matching_tku.cpp" added_lines="140" deleted_lines="792">
				<diff>@@ -1,8 +1,8 @@
 /*
-  Normal Distributions Transform test program.
-
-  2005/4/24 tku
-*/
+ * Normal Distributions Transform program
+ * 205/04/24 tku
+ * ndt_matching for ROS
+ */
 
 // number of cells
 #define G_MAP_X 2000
@@ -14,55 +14,47 @@
 #include &lt;config.h&gt;
 #endif
 
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string&gt;
-#include &lt;unistd.h&gt;
-#include &lt;math.h&gt;
 #include &lt;GL/glut.h&gt;
+#include &lt;math.h&gt;
+#include &lt;stdio.h&gt;
 #include &lt;chrono&gt;
-#include "ndt.h"
+#include &lt;fstream&gt;
+#include &lt;iostream&gt;
+#include &lt;sstream&gt;
+#include &lt;string&gt;
 #include "algebra.h"
+#include "ndt.h"
 
+#include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
+#include &lt;geometry_msgs/TwistStamped.h&gt;
+#include &lt;pcl/io/io.h&gt;
+#include &lt;pcl/io/pcd_io.h&gt;
+#include &lt;pcl_conversions/pcl_conversions.h&gt;
+#include &lt;tf/tf.h&gt;
+#include &lt;tf/transform_broadcaster.h&gt;
+#include &lt;tf/transform_listener.h&gt;
 #include "ros/ros.h"
-#include "std_msgs/String.h"
 #include "sensor_msgs/PointCloud2.h"
-#include &lt;geometry_msgs/TwistStamped.h&gt;
-#include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
+#include "std_msgs/String.h"
 #include "velodyne_pointcloud/point_types.h"
 #include "velodyne_pointcloud/rawdata.h"
-#include &lt;tf/transform_broadcaster.h&gt;
-#include &lt;tf/transform_listener.h&gt;
-#include &lt;iostream&gt;
-#include &lt;pcl/io/pcd_io.h&gt;
-#include &lt;pcl/point_types.h&gt;
-#include &lt;pcl/filters/voxel_grid.h&gt;
-
-#define DEFAULT_NDMAP_FILE "../data/nd_dat"
 
 /*grobal variables*/
-NDMapPtr NDmap; /**/
+NDMapPtr NDmap;
 NDPtr NDs;
 int NDs_num;
 
-char scan_file_base_name[100];
-
 Point scan_points[130000];
-double scan_points_i[130000];
-double scan_points_e[130000];
 int scan_points_num;
 
 int is_first_time = 1;
 int is_map_exist = 0;
 
 double scan_points_weight[130000];
-double scan_points_totalweight;
 
 Point map_points[130000];
 double map_points_i[130000];
-int mapping_points_num;
 
-int scan_num;
 int layer_select = LAYER_NUM - 1;
 
 Posture prev_pose, prev_pose2;
@@ -70,39 +62,25 @@ Posture prev_pose, prev_pose2;
 // params
 double g_map_center_x, g_map_center_y, g_map_center_z;
 double g_map_rotation;
-int g_map_x, g_map_y, g_map_z;
-double g_map_cellsize;
 char g_ndmap_name[500];
 int g_use_gnss;
 int g_map_update = 1;
 double g_ini_x, g_ini_y, g_ini_z, g_ini_roll, g_ini_pitch, g_ini_yaw;
 
 static double _tf_x, _tf_y, _tf_z, _tf_roll, _tf_pitch, _tf_yaw;
-static Eigen::Matrix4f tf_btol, tf_ltob; // tf between base_link and localizer
-static tf::Quaternion q_local_to_global;
-static Eigen::Matrix4f tf_local_to_global;
-
-void print_matrix3d(double mat[3][3]);
-void matrix_test(void);
-void print_matrix6d(double mat[6][6]);
-
-void save_nd_map(char *name);
+static Eigen::Matrix4f tf_btol, tf_ltob;  // tf between base_link and localizer
+static tf::Quaternion q_local_to_global, q_global_to_local;
+static Eigen::Matrix4f tf_local_to_global, tf_global_to_local;
 
 static pcl::PointCloud&lt;pcl::PointXYZ&gt; map;
 static int map_loaded = 0;
 
-static ros::Publisher ndmap_pub;
-
 static std::chrono::time_point&lt;std::chrono::system_clock&gt; matching_start, matching_end;
 static double exe_time = 0.0;
 
-std::string _downsampler = "voxel_grid";
-int _downsampler_num = 1;
-
 static ros::Publisher localizer_pose_pub, ndt_pose_pub;
 static geometry_msgs::PoseStamped localizer_pose_msg, ndt_pose_msg;
 
-
 // double pose_mod(Posture *pose){
 void pose_mod(Posture *pose)
 {
@@ -131,168 +109,122 @@ static void map_callback(const sensor_msgs::PointCloud2::ConstPtr &amp;input)
 {
   if (map_loaded == 0)
   {
-    // Convert the data type(from sensor_msgs to pcl).
     pcl::fromROSMsg(*input, map);
 
     pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(map));
-    /*
-    // Setting point cloud to be aligned to.
-    ndt.setInputTarget(map_ptr);
-
-    // Setting NDT parameters to default values
-    ndt.setMaximumIterations(iter);
-    ndt.setResolution(ndt_res);
-    ndt.setStepSize(step_size);
-    ndt.setTransformationEpsilon(trans_eps);
-*/
-
-    /*
-        for(int i=2;i&lt;argc;i++){
-            printf("load(%d/%d) %s\n",i-2,argc-2,argv[i]);
-            load(argv[i]);
-          }
-    */
+
     Point p;
     for (pcl::PointCloud&lt;pcl::PointXYZ&gt;::const_iterator item = map_ptr-&gt;begin(); item != map_ptr-&gt;end(); item++)
     {
       p.x = (item-&gt;x - g_map_center_x) * cos(-g_map_rotation) - (item-&gt;y - g_map_center_y) * sin(-g_map_rotation);
       p.y = (item-&gt;x - g_map_center_x) * sin(-g_map_rotation) + (item-&gt;y - g_map_center_y) * cos(-g_map_rotation);
       p.z = item-&gt;z - g_map_center_z;
-
-      /*
-      p.x = item-&gt;x;
-      p.y = item-&gt;y;
-      p.z = item-&gt;z;
-      */
       add_point_map(NDmap, &amp;p);
     }
     std::cout &lt;&lt; "Finished loading point cloud map." &lt;&lt; std::endl;
     std::cout &lt;&lt; "Map points num: " &lt;&lt; map_ptr-&gt;size() &lt;&lt; " points." &lt;&lt; std::endl;
 
-    save_nd_map(g_ndmap_name);
     is_map_exist = 1;
-
     map_loaded = 1;
   }
 }
 
-void points_callback(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::ConstPtr &amp;msg)
+static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr &amp;input)
+{
+  tf::TransformListener listener;
+  tf::StampedTransform transform;
+  std::cout &lt;&lt; "call 2D pose estimate" &lt;&lt; std::endl;
+  try
+  {
+    ros::Time now = ros::Time(0);
+    listener.waitForTransform("/map", "/world", now, ros::Duration(10.0));
+    listener.lookupTransform("/map", "world", now, transform);
+  }
+  catch (tf::TransformException &amp;ex)
+  {
+    ROS_ERROR("%s", ex.what());
+  }
+
+  tf::Quaternion q(input-&gt;pose.pose.orientation.x, input-&gt;pose.pose.orientation.y, input-&gt;pose.pose.orientation.z,
+                   input-&gt;pose.pose.orientation.w);
+  tf::Matrix3x3 m(q);
+
+  g_ini_x = input-&gt;pose.pose.position.x + transform.getOrigin().x();
+  g_ini_y = input-&gt;pose.pose.position.y + transform.getOrigin().y();
+  g_ini_z = input-&gt;pose.pose.position.z + transform.getOrigin().z();
+
+  m.getRPY(g_ini_roll, g_ini_pitch, g_ini_yaw);
+
+  // global(map) to local(map center)
+  Eigen::Translation3f translation(g_ini_x, g_ini_y, g_ini_z);
+  Eigen::AngleAxisf rotation_x(g_ini_roll, Eigen::Vector3f::UnitX());
+  Eigen::AngleAxisf rotation_y(g_ini_pitch, Eigen::Vector3f::UnitY());
+  Eigen::AngleAxisf rotation_z(g_ini_yaw, Eigen::Vector3f::UnitZ());
+  Eigen::Matrix4f global_t = (translation * rotation_z * rotation_y * rotation_x).matrix();
+  Eigen::Matrix4f local_t = tf_global_to_local * global_t;
+
+  tf::Quaternion q_g_to_l;
+  tf::Matrix3x3 mat_g;
+  mat_g.setValue(
+      static_cast&lt;double&gt;(local_t(0, 0)), static_cast&lt;double&gt;(local_t(0, 1)), static_cast&lt;double&gt;(local_t(0, 2)),
+      static_cast&lt;double&gt;(local_t(1, 0)), static_cast&lt;double&gt;(local_t(1, 1)), static_cast&lt;double&gt;(local_t(1, 2)),
+      static_cast&lt;double&gt;(local_t(2, 0)), static_cast&lt;double&gt;(local_t(2, 1)), static_cast&lt;double&gt;(local_t(2, 2)));
+
+  mat_g.getRotation(q_g_to_l);
+
+  prev_pose.x = local_t(0, 3);
+  prev_pose.y = local_t(1, 3);
+  prev_pose.z = local_t(2, 3);
+  prev_pose.theta = q_g_to_l.x();
+  prev_pose.theta2 = q_g_to_l.y();
+  prev_pose.theta3 = q_g_to_l.z();
+
+  prev_pose2 = prev_pose;
+}
+
+void points_callback(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
 {
   matching_start = std::chrono::system_clock::now();
-  static int count = 0;
   static tf::TransformBroadcaster br;
   static FILE *log_fp;
   ros::Time time;
   static tf::TransformListener listener;
-  std_msgs::Header header;
+  static ros::Time current_scan_time;
+  current_scan_time = msg-&gt;header.stamp;
 
   static int iteration;
-  int j = 0;
 
-  Posture pose, bpose, initial_pose;
-  static Posture key_pose;
-  //  double e=0,theta,x2,y2;
+  Posture pose, bpose;
   double e = 0;
   double x_offset, y_offset, z_offset, theta_offset;
-  //  double distance,diff;
-  double distance;
 
   tf::Quaternion ndt_q, localizer_q;
 
-  //  pcl_conversions::fromPCL(msg-&gt;header.stamp,time);
-  pcl_conversions::fromPCL(msg-&gt;header, header);
-
-  //  ROS_INFO("%s",msg-&gt;header.frame_id.c_str());
-  //  ROS_INFO("%f",msg-&gt;header.stamp.toSec());// + (double)msg-&gt;header.stamp.nsec/1000000000.);
+  pcl::PointCloud&lt;pcl::PointXYZ&gt; filtered_scan;
+  pcl::fromROSMsg(*msg, filtered_scan);
+  pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(filtered_scan));
 
-  /*  ros::Time stamp;
-  stamp = msg-&gt;header.stamp;
-  double now = ros::Time::now().toSec();
-  */
   if (!log_fp)
     log_fp = fopen("/tmp/ndt_log", "w");
 
-  //  ROS_INFO("get data %d",msg-&gt;points.size());
-  count++;
-  scan_points_totalweight = 0;
-
-  if (_downsampler == "voxel_grid")
-  {
-    pcl::PointCloud&lt;pcl::PointXYZ&gt; scan;
-
-    for (int i = 0; i &lt; (int)msg-&gt;points.size(); i++)
-    {
-      scan.points.push_back(pcl::PointXYZ(msg-&gt;points[i].x, msg-&gt;points[i].y, msg-&gt;points[i].z));
-    }
-    scan.header = msg-&gt;header;
-
-    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(scan));
-    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
-
-    pcl::VoxelGrid&lt;pcl::PointXYZ&gt; voxel_grid_filter;
-    voxel_grid_filter.setLeafSize(0.5, 0.5, 0.5);
-    voxel_grid_filter.setInputCloud(scan_ptr);
-    voxel_grid_filter.filter(*filtered_scan_ptr);
-    j = 0;
-    for (int i = 0; i &lt; (int)filtered_scan_ptr-&gt;points.size(); i++)
-    {
-      scan_points[j].x = filtered_scan_ptr-&gt;points[i].x + nrand(0.01);
-      scan_points[j].y = filtered_scan_ptr-&gt;points[i].y + nrand(0.01);
-      scan_points[j].z = filtered_scan_ptr-&gt;points[i].z + nrand(0.01);
-      scan_points_i[j] = 100;  // filterd_scan_ptr-&gt;points[i].intensity;
-
-      double dist = scan_points[j].x * scan_points[j].x + scan_points[j].y * scan_points[j].y +
-                    scan_points[j].z * scan_points[j].z;
-      if (dist &lt; 3 * 3)
-        continue;
-
-      scan_points_weight[j] = 1;
-      scan_points_totalweight += scan_points_weight[j];
-      j++;
-      if (j &gt; 130000)
-        break;
-    }
-    scan_points_num = j;
-    mapping_points_num = j;
-    //    printf("points_num = %d \n",scan_points_num);
-  }
-
-  if (_downsampler == "distance")
+  int j = 0;
+  for (int i = 0; i &lt; (int)filtered_scan_ptr-&gt;points.size(); i++)
   {
-    /*-------------------*/
-    j = 0;
-    for (int i = 0; i &lt; (int)msg-&gt;points.size(); i++)
-    {
-      scan_points[j].x = msg-&gt;points[i].x + nrand(0.01);
-      scan_points[j].y = msg-&gt;points[i].y + nrand(0.01);
-      scan_points[j].z = msg-&gt;points[i].z + nrand(0.01);
-      scan_points_i[j] = msg-&gt;points[i].intensity;
-
-      double dist = scan_points[j].x * scan_points[j].x + scan_points[j].y * scan_points[j].y +
-                    scan_points[j].z * scan_points[j].z;
-      if (dist &lt; 3 * 3)
-        continue;
-      scan_points_weight[j] = (dist) * (1.2 - exp(-1 * (-0.5 - scan_points[j].z) * (-0.5 - scan_points[j].z) / 2.0));
-      // scan_points_weight[j]= (1.2-exp(-1*(-0.5 - scan_points[j].z)*(-0.5 - scan_points[j].z)/2.0));
-      scan_points_totalweight += scan_points_weight[j];
-
-      j++;
-      if (j &gt; 130000)
-        break;
-    }
-    scan_points_num = j;
-    mapping_points_num = j;
-    //    printf("points_num = %d \n",scan_points_num);
+    scan_points[j].x = filtered_scan_ptr-&gt;points[i].x + nrand(0.01);
+    scan_points[j].y = filtered_scan_ptr-&gt;points[i].y + nrand(0.01);
+    scan_points[j].z = filtered_scan_ptr-&gt;points[i].z + nrand(0.01);
+    double dist =
+        scan_points[j].x * scan_points[j].x + scan_points[j].y * scan_points[j].y + scan_points[j].z * scan_points[j].z;
+    if (dist &lt; 3 * 3)
+      continue;
+
+    j++;
+    if (j &gt; 130000)
+      break;
   }
+  scan_points_num = j;
 
   /*--matching---*/
-  /*
-  Posture pose, bpose,initial_pose;
-  static Posture key_pose;
-  double e=0,theta,x2,y2;
-  double x_offset,y_offset,z_offset,theta_offset;
-  double distance,diff;
-*/
   // calc offset
   x_offset = prev_pose.x - prev_pose2.x;
   y_offset = prev_pose.y - prev_pose2.y;
@@ -312,12 +244,9 @@ void points_callback(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::ConstPtr &amp;msg)
   pose.theta2 = prev_pose.theta2;
   pose.theta3 = prev_pose.theta3 + theta_offset;
 
-  initial_pose = pose;
-
   // matching
   for (layer_select = 1; layer_select &gt;= 1; layer_select -= 1)
   {
-    //    	printf("layer=%d\n",layer_select);
     for (j = 0; j &lt; 100; j++)
     {
       if (layer_select != 1 &amp;&amp; j &gt; 2)
@@ -327,7 +256,6 @@ void points_callback(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::ConstPtr &amp;msg)
       bpose = pose;
 
       e = adjust3d(scan_points, scan_points_num, &amp;pose, layer_select);
-      //	printf("%f\n",e);
 
       pose_mod(&amp;pose);
 
@@ -378,23 +306,14 @@ void points_callback(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::ConstPtr &amp;msg)
         pose.theta3 = yaw + nrand(0.7);
         prev_pose2 = prev_pose = pose;
         printf("reset %f %f %f %f %f %f\n", pose.x, pose.y, pose.z, pose.theta, pose.theta2, pose.theta3);
-        // reset
-
-        /*	tf::Transform transform;
-  //tf::Quaternion q;
-transform.setOrigin( tf::Vector3(pose.x, pose.y, pose.z) );
-q.setRPY(pose.theta,pose.theta2,pose.theta3);
-transform.setRotation(q);
-br.sendTransform(tf::StampedTransform(transform, ros::Time::now(),  "world", "ndt_frame"));
-*/
+
         return;
       }
     }
-    // unti-distotion
 
-    if (layer_select == 2 &amp;&amp; 1)
+    // unti-distotion
+    if (layer_select == 2)
     {
-      //    		double rate,angle,xrate,yrate,dx,dy,dtheta;
       double rate, xrate, yrate, dx, dy, dtheta;
       double tempx, tempy;
       int i;
@@ -446,13 +365,14 @@ br.sendTransform(tf::StampedTransform(transform, ros::Time::now(),  "world", "nd
   Eigen::Matrix4f global_t = tf_local_to_global * local_t;
 
   tf::Matrix3x3 mat_l;
-  mat_l.setValue(static_cast&lt;double&gt;(global_t(0, 0)), static_cast&lt;double&gt;(global_t(0, 1)), static_cast&lt;double&gt;(global_t(0, 2)),
-                 static_cast&lt;double&gt;(global_t(1, 0)), static_cast&lt;double&gt;(global_t(1, 1)), static_cast&lt;double&gt;(global_t(1, 2)),
-                 static_cast&lt;double&gt;(global_t(2, 0)), static_cast&lt;double&gt;(global_t(2, 1)), static_cast&lt;double&gt;(global_t(2, 2)));
+  mat_l.setValue(
+      static_cast&lt;double&gt;(global_t(0, 0)), static_cast&lt;double&gt;(global_t(0, 1)), static_cast&lt;double&gt;(global_t(0, 2)),
+      static_cast&lt;double&gt;(global_t(1, 0)), static_cast&lt;double&gt;(global_t(1, 1)), static_cast&lt;double&gt;(global_t(1, 2)),
+      static_cast&lt;double&gt;(global_t(2, 0)), static_cast&lt;double&gt;(global_t(2, 1)), static_cast&lt;double&gt;(global_t(2, 2)));
 
   mat_l.getRotation(localizer_q);
   localizer_pose_msg.header.frame_id = "/map";
-  localizer_pose_msg.header.stamp = header.stamp;
+  localizer_pose_msg.header.stamp = current_scan_time;
   localizer_pose_msg.pose.position.x = global_t(0, 3);
   localizer_pose_msg.pose.position.y = global_t(1, 3);
   localizer_pose_msg.pose.position.z = global_t(2, 3);
@@ -464,13 +384,14 @@ br.sendTransform(tf::StampedTransform(transform, ros::Time::now(),  "world", "nd
   // base_link
   Eigen::Matrix4f global_t2 = global_t * tf_ltob;
   tf::Matrix3x3 mat_b;  // base_link
-  mat_b.setValue(static_cast&lt;double&gt;(global_t2(0, 0)), static_cast&lt;double&gt;(global_t2(0, 1)), static_cast&lt;double&gt;(global_t2(0, 2)),
-                 static_cast&lt;double&gt;(global_t2(1, 0)), static_cast&lt;double&gt;(global_t2(1, 1)), static_cast&lt;double&gt;(global_t2(1, 2)),
-                 static_cast&lt;double&gt;(global_t2(2, 0)), static_cast&lt;double&gt;(global_t2(2, 1)), static_cast&lt;double&gt;(global_t2(2, 2)));
+  mat_b.setValue(
+      static_cast&lt;double&gt;(global_t2(0, 0)), static_cast&lt;double&gt;(global_t2(0, 1)), static_cast&lt;double&gt;(global_t2(0, 2)),
+      static_cast&lt;double&gt;(global_t2(1, 0)), static_cast&lt;double&gt;(global_t2(1, 1)), static_cast&lt;double&gt;(global_t2(1, 2)),
+      static_cast&lt;double&gt;(global_t2(2, 0)), static_cast&lt;double&gt;(global_t2(2, 1)), static_cast&lt;double&gt;(global_t2(2, 2)));
   mat_b.getRotation(ndt_q);
 
   ndt_pose_msg.header.frame_id = "/map";
-  ndt_pose_msg.header.stamp = header.stamp;
+  ndt_pose_msg.header.stamp = current_scan_time;
   ndt_pose_msg.pose.position.x = global_t2(0, 3);
   ndt_pose_msg.pose.position.y = global_t2(1, 3);
   ndt_pose_msg.pose.position.z = global_t2(2, 3);
@@ -484,26 +405,6 @@ br.sendTransform(tf::StampedTransform(transform, ros::Time::now(),  "world", "nd
 
   scan_transrate(scan_points, map_points, &amp;pose, scan_points_num);
 
-  for (int i = 0; i &lt; scan_points_num; i++)
-  {
-    map_points_i[i] = scan_points_i[i];
-  }
-
-  // update ND map
-  distance = (key_pose.x - pose.x) * (key_pose.x - pose.x) + (key_pose.y - pose.y) * (key_pose.y - pose.y) +
-             (key_pose.z - pose.z) * (key_pose.z - pose.z);
-
-  if (g_map_update &amp;&amp; (!is_map_exist || (distance &gt; 0.1 * 0.1 &amp;&amp; scan_points_num &gt; 100)))
-  {
-    int i;
-    for (i = 0; i &lt; scan_points_num; i++)
-    {
-      add_point_map(NDmap, &amp;map_points[i]);
-    }
-    key_pose = pose;
-    is_map_exist = 1;
-  }
-
   prev_pose2 = prev_pose;
   prev_pose = pose;
 
@@ -512,34 +413,24 @@ br.sendTransform(tf::StampedTransform(transform, ros::Time::now(),  "world", "nd
     prev_pose2 = prev_pose;
     is_first_time = 0;
   }
-  /*
-  printf("%f %f %f %f %f %f %f %d \n",0,//(double)msg-&gt;header.stamp.toSec(),
-   pose.x,pose.y,pose.z,pose.theta,pose.theta2,pose.theta3,NDs_num) ;
-*/
-  fprintf(log_fp, "%f %f %f %f %f %f %f\n", (double)header.stamp.toSec(),
+
+  fprintf(log_fp, "%f %f %f %f %f %f %f\n", current_scan_time.toSec(),
           pose.x * cos(g_map_rotation) - pose.y * sin(g_map_rotation) + g_map_center_x,
           pose.x * sin(g_map_rotation) + pose.y * cos(g_map_rotation) + g_map_center_y, pose.z + g_map_center_z,
           pose.theta, pose.theta2, pose.theta3 + g_map_rotation);
 
   fflush(log_fp);
   tf::Transform transform;
-//  tf::Quaternion q;
-//  transform.setOrigin(tf::Vector3(pose.x, pose.y, pose.z));
-//  transform.setOrigin(tf::Vector3(pose.x + g_map_center_x, pose.y + g_map_center_y, pose.z + g_map_center_z));
   transform.setOrigin(tf::Vector3(global_t2(0, 3), global_t2(1, 3), global_t2(2, 3)));
-//  q.setRPY(pose.theta, pose.theta2, pose.theta3);
-//  transform.setRotation(q_local_to_global * q);
   transform.setRotation(ndt_q);
 
-//  br.sendTransform(tf::StampedTransform(transform, header.stamp, "map", "velodyne"));
-  br.sendTransform(tf::StampedTransform(transform, header.stamp, "map", "base_link"));
+  br.sendTransform(tf::StampedTransform(transform, current_scan_time, "map", "base_link"));
 
   matching_end = std::chrono::system_clock::now();
   exe_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(matching_end - matching_start).count() / 1000.0;
 
   std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
   std::cout &lt;&lt; "Sequence number: " &lt;&lt; msg-&gt;header.seq &lt;&lt; std::endl;
-  std::cout &lt;&lt; "Number of scan points: " &lt;&lt; msg-&gt;size() &lt;&lt; " points." &lt;&lt; std::endl;
   std::cout &lt;&lt; "Number of filtered scan points: " &lt;&lt; scan_points_num &lt;&lt; " points." &lt;&lt; std::endl;
   std::cout &lt;&lt; "Number of iteration: " &lt;&lt; iteration &lt;&lt; std::endl;
   std::cout &lt;&lt; "Execution time: " &lt;&lt; exe_time &lt;&lt; std::endl;
@@ -547,609 +438,64 @@ br.sendTransform(tf::StampedTransform(transform, ros::Time::now(),  "world", "nd
   std::cout &lt;&lt; "(" &lt;&lt; pose.x &lt;&lt; ", " &lt;&lt; pose.y &lt;&lt; ", " &lt;&lt; pose.z &lt;&lt; ", " &lt;&lt; pose.theta &lt;&lt; ", " &lt;&lt; pose.theta2 &lt;&lt; ", "
             &lt;&lt; pose.theta3 &lt;&lt; ")" &lt;&lt; std::endl;
   std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
-
-  //  ROS_INFO("get data %d",msg-&gt;points.size());
-}
-
-/*add point to ndcell */
-int add_point_covariance(NDPtr nd, PointPtr p)
-{
-  /*add data num*/
-  nd-&gt;num++;
-  nd-&gt;flag = 0; /*need to update*/
-  // printf("%d \n",nd-&gt;num);
-
-  /*calcurate means*/
-  nd-&gt;m_x += p-&gt;x;
-  nd-&gt;m_y += p-&gt;y;
-  nd-&gt;m_z += p-&gt;z;
-
-  /*calcurate covariances*/
-  nd-&gt;c_xx += p-&gt;x * p-&gt;x;
-  nd-&gt;c_yy += p-&gt;y * p-&gt;y;
-  nd-&gt;c_zz += p-&gt;z * p-&gt;z;
-
-  nd-&gt;c_xy += p-&gt;x * p-&gt;y;
-  nd-&gt;c_yz += p-&gt;y * p-&gt;z;
-  nd-&gt;c_zx += p-&gt;z * p-&gt;x;
-
-  return 1;
-}
-
-int inv_check(double inv[3][3])
-{
-  for (int i = 0; i &lt; 3; i++)
-  {
-    for (int j = 0; j &lt; 3; j++)
-    {
-      if (std::isnan(inv[i][j]))
-        return 0;
-      if (fabs(inv[i][j]) &gt; 1000)
-        return 0;
-    }
-  }
-  return 1;
-}
-
-/*calcurate covariances*/
-int update_covariance(NDPtr nd)
-{
-  double a, b, c; /*for calcurate*/
-  if (!nd-&gt;flag)
-  { /*need calcurate?*/
-    /*means*/
-    nd-&gt;mean.x = a = nd-&gt;m_x / nd-&gt;num;
-    nd-&gt;mean.y = b = nd-&gt;m_y / nd-&gt;num;
-    nd-&gt;mean.z = c = nd-&gt;m_z / nd-&gt;num;
-
-    /*covariances*/
-    nd-&gt;covariance[0][0] = (nd-&gt;c_xx - 2 * a * nd-&gt;m_x) / nd-&gt;num + a * a;
-    nd-&gt;covariance[1][1] = (nd-&gt;c_yy - 2 * b * nd-&gt;m_y) / nd-&gt;num + b * b;
-    nd-&gt;covariance[2][2] = (nd-&gt;c_zz - 2 * c * nd-&gt;m_z) / nd-&gt;num + c * c;
-    nd-&gt;covariance[0][1] = nd-&gt;covariance[1][0] = (nd-&gt;c_xy - nd-&gt;m_x * b - nd-&gt;m_y * a) / nd-&gt;num + a * b;
-    nd-&gt;covariance[1][2] = nd-&gt;covariance[2][1] = (nd-&gt;c_yz - nd-&gt;m_y * c - nd-&gt;m_z * b) / nd-&gt;num + b * c;
-    nd-&gt;covariance[2][0] = nd-&gt;covariance[0][2] = (nd-&gt;c_zx - nd-&gt;m_z * a - nd-&gt;m_x * c) / nd-&gt;num + c * a;
-    nd-&gt;sign = 0;
-    nd-&gt;flag = 1; /*this ND updated*/
-    if (nd-&gt;num &gt;= 5)
-    {
-      if (1 || round_covariance(nd) == 1)
-      {
-        if (ginverse_matrix3d(nd-&gt;covariance, nd-&gt;inv_covariance))
-          if (inv_check(nd-&gt;inv_covariance))
-            nd-&gt;sign = 1;
-      }
-    }
-  }
-
-  return 1;
-}
-
-/*add point to ndmap*/
-int add_point_map(NDMapPtr ndmap, PointPtr point)
-{
-  int x, y, z, i;
-  NDPtr *ndp[8];
-
-  /*
-
-  +---+---+
-  |   |   |
-  +---+---+
-  |   |###|
-  +---+---+
-
-  */
-
-  /*mapping*/
-  x = (point-&gt;x / ndmap-&gt;size) + ndmap-&gt;x / 2;
-  y = (point-&gt;y / ndmap-&gt;size) + ndmap-&gt;y / 2;
-  z = (point-&gt;z / ndmap-&gt;size) + ndmap-&gt;z / 2;
-
-  /*clipping*/
-  if (x &lt; 1 || x &gt;= ndmap-&gt;x)
-    return 0;
-  if (y &lt; 1 || y &gt;= ndmap-&gt;y)
-    return 0;
-  if (z &lt; 1 || z &gt;= ndmap-&gt;z)
-    return 0;
-
-  /*select root ND*/
-  ndp[0] = ndmap-&gt;nd + x * ndmap-&gt;to_x + y * ndmap-&gt;to_y + z;
-  ndp[1] = ndp[0] - ndmap-&gt;to_x;
-  ndp[2] = ndp[0] - ndmap-&gt;to_y;
-  ndp[4] = ndp[0] - 1;
-  ndp[3] = ndp[2] - ndmap-&gt;to_x;
-  ndp[5] = ndp[4] - ndmap-&gt;to_x;
-  ndp[6] = ndp[4] - ndmap-&gt;to_y;
-  ndp[7] = ndp[3] - 1;
-
-  /*add  point to map */
-  for (i = 0; i &lt; 8; i++)
-  {
-    if ((*ndp[i]) == 0)
-      *ndp[i] = add_ND();
-    if ((*ndp[i]) != 0)
-      add_point_covariance(*ndp[i], point);
-  }
-
-  if (ndmap-&gt;next)
-  {
-    add_point_map(ndmap-&gt;next, point);
-  }
-
-  return 0;
-}
-
-/*get nd cell at point*/
-int get_ND(NDMapPtr ndmap, PointPtr point, NDPtr *nd, int ndmode)
-{
-  int x, y, z;
-  int i;
-  NDPtr *ndp[8];
-
-  /*
-    
-  +---+---+
-  |   |   |
-  +---+---+
-  |   |###|
-  +---+---+
-  
-  */ /*
-   layer = layer_select;
-   while(layer &gt; 0){
-     if(ndmap-&gt;next)ndmap = ndmap-&gt;next;
-     layer--;
-   }
-     */
-  /*mapping*/
-  if (ndmode &lt; 3)
-  {
-    x = (double)((point-&gt;x / ndmap-&gt;size) + ndmap-&gt;x / 2 - 0.5);
-    y = (double)((point-&gt;y / ndmap-&gt;size) + ndmap-&gt;y / 2 - 0.5);
-    z = (double)((point-&gt;z / ndmap-&gt;size) + ndmap-&gt;z / 2 - 0.5);
-  }
-  else
-  {
-    x = (point-&gt;x / ndmap-&gt;size) + ndmap-&gt;x / 2;
-    y = (point-&gt;y / ndmap-&gt;size) + ndmap-&gt;y / 2;
-    z = (point-&gt;z / ndmap-&gt;size) + ndmap-&gt;z / 2;
-  }
-
-  /*clipping*/
-  if (x &lt; 1 || x &gt;= ndmap-&gt;x)
-    return 0;
-  if (y &lt; 1 || y &gt;= ndmap-&gt;y)
-    return 0;
-  if (z &lt; 1 || z &gt;= ndmap-&gt;z)
-    return 0;
-
-  /*select root ND*/
-  ndp[0] = ndmap-&gt;nd + x * ndmap-&gt;to_x + y * ndmap-&gt;to_y + z;
-  ndp[1] = ndp[0] - ndmap-&gt;to_x;
-  ndp[2] = ndp[0] - ndmap-&gt;to_y;
-  ndp[4] = ndp[0] - 1;
-  ndp[3] = ndp[2] - ndmap-&gt;to_x;
-  ndp[5] = ndp[4] - ndmap-&gt;to_x;
-  ndp[6] = ndp[4] - ndmap-&gt;to_y;
-  ndp[7] = ndp[3] - 1;
-
-  for (i = 0; i &lt; 8; i++)
-  {
-    if (*ndp[i] != 0)
-    {
-      if (!(*ndp[i])-&gt;flag)
-        update_covariance(*ndp[i]);
-      nd[i] = *ndp[i];
-    }
-    else
-    {
-      nd[i] = NDs;
-      // return 0;
-    }
-  }
-
-  return 1;
-}
-
-NDPtr add_ND(void)
-{
-  NDPtr ndp;
-  // int m;
-
-  if (NDs_num &gt;= MAX_ND_NUM)
-  {
-    printf("over flow\n");
-    return 0;
-  }
-
-  ndp = NDs + NDs_num;
-  NDs_num++;
-
-  ndp-&gt;flag = 0;
-  ndp-&gt;sign = 0;
-  ndp-&gt;num = 0;
-  ndp-&gt;m_x = 0;
-  ndp-&gt;m_y = 0;
-  ndp-&gt;m_z = 0;
-  ndp-&gt;c_xx = 0;
-  ndp-&gt;c_yy = 0;
-  ndp-&gt;c_zz = 0;
-  ndp-&gt;c_xy = 0;
-  ndp-&gt;c_yz = 0;
-  ndp-&gt;c_zx = 0;
-  ndp-&gt;w = 1;
-  ndp-&gt;is_source = 0;
-
-  return ndp;
-}
-
-NDMapPtr initialize_NDmap_layer(int layer, NDMapPtr child)
-{
-  // int i,j,k,i2,i3,m;
-  int i, j, k;
-  int x, y, z;
-  NDPtr *nd, *ndp;
-  NDMapPtr ndmap;
-
-  //  i2 = i3 = 0;
-  //  printf("Initializing...layer %d\n",layer);
-
-  x = (g_map_x &gt;&gt; layer) + 1;
-  y = (g_map_y &gt;&gt; layer) + 1;
-  z = (g_map_z &gt;&gt; layer) + 1;
-
-  /**/
-  nd = (NDPtr *)malloc(x * y * z * sizeof(NDPtr));
-  ndmap = (NDMapPtr)malloc(sizeof(NDMap));
-
-  ndmap-&gt;x = x;
-  ndmap-&gt;y = y;
-  ndmap-&gt;z = z;
-  ndmap-&gt;to_x = y * z;
-  ndmap-&gt;to_y = z;
-  ndmap-&gt;layer = layer;
-  ndmap-&gt;nd = nd;
-  ndmap-&gt;next = child;
-  ndmap-&gt;size = g_map_cellsize * ((int)1 &lt;&lt; layer);
-  //  printf("size %f\n",ndmap-&gt;size);
-
-  ndp = nd;
-
-  /**/
-  for (i = 0; i &lt; x; i++)
-  {
-    for (j = 0; j &lt; y; j++)
-    {
-      for (k = 0; k &lt; z; k++)
-      {
-        *ndp = 0;
-        ndp++;
-      }
-    }
-  }
-
-  /**/
-  return ndmap;
-}
-
-/*ND*/
-NDMapPtr initialize_NDmap(void)
-{
-  int i;
-  NDMapPtr ndmap;
-  NDPtr null_nd;
-
-  printf("Initialize NDmap\n");
-  ndmap = 0;
-
-  // init NDs
-  NDs = (NDPtr)malloc(sizeof(NormalDistribution) * MAX_ND_NUM);
-  NDs_num = 0;
-
-  null_nd = add_ND();
-
-  for (i = LAYER_NUM - 1; i &gt;= 0; i--)
-  {
-    ndmap = initialize_NDmap_layer(i, ndmap);
-
-    /*progress dots*/
-    //    printf("layer %d\n",i);
-  }
-
-  //  printf("done\n");
-
-  return ndmap; /**/
 }
 
-int round_covariance(NDPtr nd)
-{
-  double v[3][3], a;
-
-  eigenvecter_matrix3d(nd-&gt;covariance, v, nd-&gt;l);
-  //  print_matrix3d(v);
-  if (fabs(v[0][0] * v[0][0] + v[1][0] * v[1][0] + v[2][0] * v[2][0] - 1) &gt; 0.1)
-    printf("!1");
-  if (fabs(v[0][0] * v[0][1] + v[1][0] * v[1][1] + v[2][0] * v[2][1]) &gt; 0.01)
-    printf("!01");
-  if (fabs(v[0][1] * v[0][2] + v[1][1] * v[1][2] + v[2][1] * v[2][2]) &gt; 0.01)
-    printf("!02");
-  if (fabs(v[0][2] * v[0][0] + v[1][2] * v[1][0] + v[2][2] * v[2][0]) &gt; 0.01)
-    printf("!03");
-
-  a = fabs(nd-&gt;l[1] / nd-&gt;l[0]);
-  if (a &lt; 0.001)
-  {
-    return 0;
-    if (nd-&gt;l[1] &gt; 0)
-      nd-&gt;l[1] = fabs(nd-&gt;l[0]) / 10.0;
-    else
-      nd-&gt;l[1] = -fabs(nd-&gt;l[0]) / 10.0;
-
-    a = fabs(nd-&gt;l[2] / nd-&gt;l[0]);
-    if (a &lt; 0.01)
-    {
-      if (nd-&gt;l[2] &gt; 0)
-        nd-&gt;l[2] = fabs(nd-&gt;l[0]) / 10.0;
-      else
-        nd-&gt;l[2] = -fabs(nd-&gt;l[0]) / 10.0;
-    }
-    //    printf("r");
-    matrix3d_eigen(v, nd-&gt;l[0], nd-&gt;l[1], nd-&gt;l[2], nd-&gt;covariance);
-  }
-  return 1;
-}
-
-/*ND*/
-double probability_on_ND(NDPtr nd, double xp, double yp, double zp)
-{
-  //  double xp,yp,zp;
-  double e;
-
-  if (nd-&gt;num &lt; 5)
-    return 0;
-  /*
-  xp = x - nd-&gt;mean.x;
-  yp = y - nd-&gt;mean.y;
-  zp = z - nd-&gt;mean.z;
-  */
-  e = exp((xp * xp * nd-&gt;inv_covariance[0][0] + yp * yp * nd-&gt;inv_covariance[1][1] +
-           zp * zp * nd-&gt;inv_covariance[2][2] + 2.0 * xp * yp * nd-&gt;inv_covariance[0][1] +
-           2.0 * yp * zp * nd-&gt;inv_covariance[1][2] + 2.0 * zp * xp * nd-&gt;inv_covariance[2][0]) /
-          -2.0);
-
-  if (e &gt; 1)
-    return 1;
-  if (e &lt; 0)
-    return 0;
-  return (e);
-}
-
-void load(char *name)
-{
-  FILE *fp;
-  double x, y, z, q;
-  Point p;
-
-  fp = fopen(name, "r");
-  int i = 0;
-  while (fscanf(fp, "%lf %lf %lf %lf", &amp;y, &amp;x, &amp;z, &amp;q) != EOF)
-  {  // x,y swaped
-    p.x = (x - g_map_center_x) * cos(-g_map_rotation) - (y - g_map_center_y) * sin(-g_map_rotation);
-    p.y = (x - g_map_center_x) * sin(-g_map_rotation) + (y - g_map_center_y) * cos(-g_map_rotation);
-    p.z = z - g_map_center_z;
-    add_point_map(NDmap, &amp;p);
-    std::cout &lt;&lt; i &lt;&lt; std::endl;
-    i++;
-  }
-  std::cout &lt;&lt; "Finished loading " &lt;&lt; name &lt;&lt; std::endl;
-  fclose(fp);
-}
-
-void save_nd_map(char *name)
-{
-  int i, j, k, layer;
-  NDData nddat;
-  NDMapPtr ndmap;
-  NDPtr *ndp;
-  FILE *ofp;
-
-  // for pcd
-  pcl::PointCloud&lt;pcl::PointXYZ&gt; cloud;
-  pcl::PointXYZ p;
-
-  // cloud.is_dense = false;
-  // cloud.points.resize (cloud.width * cloud.height);
-  // ros::Time stamp;
-  // stamp = msg-&gt;header.stamp;
-  // double now = ros::Time::now().toSec();
-
-  ndmap = NDmap;
-  ofp = fopen(name, "w");
-
-  for (layer = 0; layer &lt; 2; layer++)
-  {
-    ndp = ndmap-&gt;nd;
-    /**/
-    for (i = 0; i &lt; ndmap-&gt;x; i++)
-    {
-      for (j = 0; j &lt; ndmap-&gt;y; j++)
-      {
-        for (k = 0; k &lt; ndmap-&gt;z; k++)
-        {
-          if (*ndp)
-          {
-            update_covariance(*ndp);
-            nddat.nd = **ndp;
-            nddat.x = i;
-            nddat.y = j;
-            nddat.z = k;
-            nddat.layer = layer;
-
-            fwrite(&amp;nddat, sizeof(NDData), 1, ofp);
-
-            // regist the point to pcd data;
-            p.x = (*ndp)-&gt;mean.x;
-            p.y = (*ndp)-&gt;mean.y;
-            p.z = (*ndp)-&gt;mean.z;
-            cloud.points.push_back(p);
-          }
-          ndp++;
-        }
-      }
-      //      printf("a\n");
-    }
-    ndmap = ndmap-&gt;next;
-  }
-  //  printf("done\n");
-  fclose(ofp);
-
-  // save pcd
-
-  cloud.header.frame_id = "/map";
-  cloud.width = cloud.points.size();
-  cloud.height = 1;
-  pcl::io::savePCDFileASCII("/tmp/ndmap.pcd", cloud);
-  printf("NDMap points num: %d points.\n", (int)cloud.points.size());
-
-  sensor_msgs::PointCloud2::Ptr ndmap_ptr(new sensor_msgs::PointCloud2);
-  pcl::toROSMsg(cloud, *ndmap_ptr);
-  ndmap_pub.publish(*ndmap_ptr);
-}
-
-// load ndt setting file
-int load_ndt_ini(char *name)
-{
-  FILE *ifp;
-
-  ifp = fopen(name, "r");
-  if (!ifp)
-    return 0;
-
-  // map path
-  if (fscanf(ifp, "%s", g_ndmap_name) == EOF)
-    return 0;
-  // map size
-  if (fscanf(ifp, "%d %d %d %lf", &amp;g_map_x, &amp;g_map_y, &amp;g_map_z, &amp;g_map_cellsize) == EOF)
-    return 0;
-  // map center
-  if (fscanf(ifp, "%lf %lf %lf %lf", &amp;g_map_center_x, &amp;g_map_center_y, &amp;g_map_center_z, &amp;g_map_rotation) == EOF)
-    return 0;
-  // use gnss
-  if (fscanf(ifp, "%d", &amp;g_use_gnss) == EOF)
-    return 0;
-  if (!g_use_gnss)
-  {
-    if (fscanf(ifp, "%lf %lf %lf %lf %lf %lf", &amp;g_ini_x, &amp;g_ini_y, &amp;g_ini_z, &amp;g_ini_roll, &amp;g_ini_pitch, &amp;g_ini_yaw) ==
-        EOF)
-      return 0;
-  }
-
-  //
-  return 1;
-}
-
-int load_nd_map(char *name)
-{
-  //  int i,j,k,layer;
-  NDData nddat;
-  NDMapPtr ndmap[2];
-  NDPtr ndp;
-  FILE *ifp;
-  //  FILE *logfp;
-
-  ndmap[0] = NDmap;
-  ndmap[1] = NDmap-&gt;next;
-
-  ifp = fopen(name, "r");
-  if (!ifp)
-    return 0;
-
-  while (fread(&amp;nddat, sizeof(NDData), 1, ifp) &gt; 0)
-  {
-    ndp = add_ND();
-    *ndp = nddat.nd;
-    *(ndmap[nddat.layer]-&gt;nd + nddat.x * ndmap[nddat.layer]-&gt;to_x + nddat.y * ndmap[nddat.layer]-&gt;to_y + nddat.z) = ndp;
-    ndp-&gt;flag = 0;
-    update_covariance(ndp);
-    // fprintf(logfp,"%f %f %f \n",ndp-&gt;mean.x, ndp-&gt;mean.y, ndp-&gt;mean.z);
-  }
-
-  printf("%d NDVoxels are loaded\n", NDs_num);
-  fclose(ifp);
-  return 1;
-}
-
-/**/
 int main(int argc, char *argv[])
 {
-  printf("----------------------\n");
-  printf(" 3D NDT scan matching \n");
-  printf("----------------------\n");
+  std::cout &lt;&lt; "3D NDT scan matching" &lt;&lt; std::endl;
 
   ros::init(argc, argv, "ndt_matching_tku");
 
   ros::NodeHandle nh;
   ros::NodeHandle private_nh("~");
 
-  private_nh.getParam("downsampler", _downsampler);
   private_nh.getParam("init_x", g_ini_x);
   private_nh.getParam("init_y", g_ini_y);
   private_nh.getParam("init_z", g_ini_z);
   private_nh.getParam("init_roll", g_ini_roll);
   private_nh.getParam("init_pitch", g_ini_pitch);
   private_nh.getParam("init_yaw", g_ini_yaw);
+  private_nh.getParam("use_gnss", g_use_gnss);
 
-  std::cout &lt;&lt; "Downsampler: " &lt;&lt; _downsampler &lt;&lt; std::endl;
-  if (_downsampler == "voxel_grid")
-  {
-    _downsampler_num = 1;
-  }
-  if (_downsampler == "distance")
-  {
-    _downsampler_num = 0;
-  }
-
-  if (nh.getParam("tf_x", _tf_x) == false)
+  if (!nh.getParam("tf_x", _tf_x))
   {
     std::cout &lt;&lt; "tf_x is not set." &lt;&lt; std::endl;
     return 1;
   }
-  if (nh.getParam("tf_y", _tf_y) == false)
+  if (!nh.getParam("tf_y", _tf_y))
   {
     std::cout &lt;&lt; "tf_y is not set." &lt;&lt; std::endl;
     return 1;
   }
-  if (nh.getParam("tf_z", _tf_z) == false)
+  if (!nh.getParam("tf_z", _tf_z))
   {
     std::cout &lt;&lt; "tf_z is not set." &lt;&lt; std::endl;
     return 1;
   }
-  if (nh.getParam("tf_roll", _tf_roll) == false)
+  if (!nh.getParam("tf_roll", _tf_roll))
   {
     std::cout &lt;&lt; "tf_roll is not set." &lt;&lt; std::endl;
     return 1;
   }
-  if (nh.getParam("tf_pitch", _tf_pitch) == false)
+  if (!nh.getParam("tf_pitch", _tf_pitch))
   {
     std::cout &lt;&lt; "tf_pitch is not set." &lt;&lt; std::endl;
     return 1;
   }
-  if (nh.getParam("tf_yaw", _tf_yaw) == false)
+  if (!nh.getParam("tf_yaw", _tf_yaw))
   {
     std::cout &lt;&lt; "tf_yaw is not set." &lt;&lt; std::endl;
     return 1;
   }
 
-  Eigen::Translation3f tl_btol(_tf_x, _tf_y, _tf_z);  // tl: translation
+  Eigen::Translation3f tl_btol(_tf_x, _tf_y, _tf_z);                 // tl: translation
   Eigen::AngleAxisf rot_x_btol(_tf_roll, Eigen::Vector3f::UnitX());  // rot: rotation
   Eigen::AngleAxisf rot_y_btol(_tf_pitch, Eigen::Vector3f::UnitY());
   Eigen::AngleAxisf rot_z_btol(_tf_yaw, Eigen::Vector3f::UnitZ());
   tf_btol = (tl_btol * rot_z_btol * rot_y_btol * rot_x_btol).matrix();
 
   Eigen::Translation3f tl_ltob((-1.0) * _tf_x, (-1.0) * _tf_y, (-1.0) * _tf_z);  // tl: translation
-  Eigen::AngleAxisf rot_x_ltob((-1.0) * _tf_roll, Eigen::Vector3f::UnitX());  // rot: rotation
+  Eigen::AngleAxisf rot_x_ltob((-1.0) * _tf_roll, Eigen::Vector3f::UnitX());     // rot: rotation
   Eigen::AngleAxisf rot_y_ltob((-1.0) * _tf_pitch, Eigen::Vector3f::UnitY());
   Eigen::AngleAxisf rot_z_ltob((-1.0) * _tf_yaw, Eigen::Vector3f::UnitZ());
   tf_ltob = (tl_ltob * rot_z_ltob * rot_y_ltob * rot_x_ltob).matrix();
@@ -1167,15 +513,23 @@ int main(int argc, char *argv[])
   g_map_center_y = g_ini_y;
   g_map_center_z = g_ini_z;
   g_map_rotation = 0.0;
-  // use gnss
-  g_use_gnss = 0;
 
   Eigen::Translation3f tl_local_to_global(g_map_center_x, g_map_center_y, g_map_center_z);  // tl: translation
-  Eigen::AngleAxisf rot_x_local_to_global(0.0, Eigen::Vector3f::UnitX());  // rot: rotation
+  Eigen::AngleAxisf rot_x_local_to_global(0.0, Eigen::Vector3f::UnitX());                   // rot: rotation
   Eigen::AngleAxisf rot_y_local_to_global(0.0, Eigen::Vector3f::UnitY());
   Eigen::AngleAxisf rot_z_local_to_global(g_map_rotation, Eigen::Vector3f::UnitZ());
   q_local_to_global.setRPY(0.0, 0.0, g_map_rotation);
-  tf_local_to_global = (tl_local_to_global * rot_z_local_to_global * rot_y_local_to_global * rot_x_local_to_global).matrix();
+  tf_local_to_global =
+      (tl_local_to_global * rot_z_local_to_global * rot_y_local_to_global * rot_x_local_to_global).matrix();
+
+  Eigen::Translation3f tl_global_to_local((-1.0) * g_map_center_x, (-1.0) * g_map_center_y,
+                                          (-1.0) * g_map_center_z);      // tl: translation
+  Eigen::AngleAxisf rot_x_global_to_local(0, Eigen::Vector3f::UnitX());  // rot: rotation
+  Eigen::AngleAxisf rot_y_global_to_local(0, Eigen::Vector3f::UnitY());
+  Eigen::AngleAxisf rot_z_global_to_local((-1.0) * g_map_rotation, Eigen::Vector3f::UnitZ());
+  q_global_to_local.setRPY(0.0, 0.0, (-1.0) * g_map_rotation);
+  tf_global_to_local =
+      (tl_global_to_local * rot_z_global_to_local * rot_y_global_to_local * rot_x_global_to_local).matrix();
 
   /*initialize(clear) NDmap data*/
   NDmap = initialize_NDmap();
@@ -1191,20 +545,14 @@ int main(int argc, char *argv[])
   prev_pose2 = prev_pose;
   is_first_time = 1;
 
-  ndmap_pub = nh.advertise&lt;sensor_msgs::PointCloud2&gt;("/ndmap", 1000);
   ndt_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/ndt_pose", 1000);
   localizer_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/localizer_pose", 1000);
 
   ros::Subscriber map_sub = nh.subscribe("points_map", 10, map_callback);
-  ros::Subscriber points_sub = nh.subscribe("points_raw", 1000, points_callback);
+  ros::Subscriber initialpose_sub = nh.subscribe("initialpose", 1000, initialpose_callback);
+  ros::Subscriber points_sub = nh.subscribe("filtered_points", 1000, points_callback);
 
-  /*
-    while (ros::ok()){
-      ros::spinOnce();
-    }
-  */
   ros::spin();
 
-  save_nd_map((char *)"/tmp/ndmap");
   return 1;
-}
+}
\ No newline at end of file
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3e2dfed2580bc7edff80c27142a95a9a07e0b3a6" author="Yusuke FUJII">
		<msg>refactor lamp control</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="26" deleted_lines="17">
				<diff>@@ -29,28 +29,37 @@ namespace decision_maker
 {
 #define TPNAME_BASED_LANE_WAYPOINTS_ARRAY "/based/lane_waypoints_array"
 #define TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY "/lane_waypoints_array"
+#define LAMP_EMPTY  0
+#define LAMP_LEFT   1
+#define LAMP_RIGHT  2
+#define LAMP_HAZARD 3
+#define LAMP_ON 1
+#define LAMP_OFF 0
 
 void DecisionMakerNode::callbackStateSTR(int status)
 {
   ROS_INFO("[%s]:%d\n", __func__, status);
   autoware_msgs::lamp_cmd lamp_msg;
 
-  if (status == 0)
-  {
-    lamp_msg.l = 0;
-    lamp_msg.r = 0;
-  }
-  else if (status == 1)
-  {
-    lamp_msg.l = 1;
-    lamp_msg.r = 0;
-  }
-  else if (status == 2)
-  {
-    lamp_msg.l = 0;
-    lamp_msg.r = 0;
+  switch(status){
+	  case LAMP_LEFT:
+		  lamp_msg.l = LAMP_ON;
+		  lamp_msg.r = LAMP_OFF;
+		  break;
+	  case LAMP_RIGHT:
+		  lamp_msg.l = LAMP_OFF;
+		  lamp_msg.r = LAMP_ON;
+		  break;
+	  case LAMP_HAZARD:
+		  lamp_msg.l = LAMP_ON;
+		  lamp_msg.r = LAMP_ON;
+		  break;
+	  case LAMP_EMPTY:
+	  default:
+		  lamp_msg.l = LAMP_OFF;
+		  lamp_msg.r = LAMP_OFF;
+		  break;
   }
-  Pubs["lamp_cmd"].publish(lamp_msg);
 }
 
 void DecisionMakerNode::setupStateCallback(void)
@@ -179,8 +188,8 @@ void DecisionMakerNode::initVectorMap(void)
                   if (line.fpid &lt;= point.pid &amp;&amp; point.pid &lt;= line.fpid)
                   {
                     geometry_msgs::Point _point;
-                    _point.x = point.ly;
-                    _point.y = point.bx;
+                    _point.x = point.bx;
+                    _point.y = point.ly;
                     _point.z = point.h;
 
                     if (_prev_point.x == _point.x &amp;&amp; _prev_point.y == _point.y)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9b16d08867b160038e073bbe0c107ba491d776fe" author="Yusuke FUJII">
		<msg>Add feature of to find stopline. and following minor fixes
- to change vectormap operation to vectormap lib.
- to change state operation</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libamathutils\include\amathutils.hpp" new_path="ros\src\computing\planning\decision\libs\libamathutils\include\amathutils.hpp" added_lines="8" deleted_lines="1">
				<diff>@@ -51,6 +51,13 @@ inline double getAcceleration(double v0, double v, double x)
 inline double getTimefromAcceleration(double v0, double v, double a)
 {
 	return  (v - v0) / a;
-} 
 }
+
+
+bool isIntersectLine(double p1x, double p1y, double p2x, double p2y,
+			double p3x, double p3y, double p4x, double p4y);
+
+}
+ int isPointLeftFromLine(double p1x, double p1y, double line_p1x, double line_p1y,
+		  double line_p2x, double line_p2y);
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libamathutils\src\Amathutils.cpp" new_path="ros\src\computing\planning\decision\libs\libamathutils\src\Amathutils.cpp" added_lines="29" deleted_lines="0">
				<diff>@@ -20,6 +20,35 @@ namespace amathutils
     return _angle * 360 / (2 * M_PI);
   }
 
+  bool isIntersectLine(double p1x, double p1y, double p2x, double p2y,
+		  double p3x, double p3y, double p4x, double p4y)
+  {
+	  double ta = (p3x - p4x) * (p1y-p3y) + (p3y - p4y) * (p3x - p4x);
+	  double tb = (p3x - p4x) * (p2y-p3y) + (p3y - p4y) * (p3x - p2x);
+	  double tc = (p1x - p2x) * (p3y-p1y) + (p1y - p2y) * (p1x - p3x);
+	  double td = (p1x - p2x) * (p4y-p1y) + (p1y - p2y) * (p1x - p4x);
+
+
+	  if( tc * td &lt; 0 &amp;&amp; ta * tb &lt; 0)
+		  return true;
+	  else
+		  return false;
+  }
+#define LEFT 1
+#define RIGHT -1
+#define ONLINE 0
+
+  int isPointLeftFromLine(double p1x, double p1y, double line_p1x, double line_p1y,
+		  double line_p2x, double line_p2y){
+
+	  double n = p1x * (line_p1y - line_p2y) + 
+		  line_p1x * (line_p2y - p1y) + 
+		  line_p2x * (p1y - line_p1y);
+
+	  return n &gt; 0? 1:
+		  n &lt; 0? -1: 0;
+
+  }
 
 
 } 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" added_lines="12" deleted_lines="6">
				<diff>@@ -51,7 +51,8 @@ public:
   virtual unsigned long long getStateNum(void) = 0;
   virtual std::string getStateName(void) = 0;
   virtual unsigned char getStateKind(void) = 0;
-  virtual void setCallbackFunc(std::function&lt;void(void)&gt; _f)=0;
+  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f)=0;
+  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f)=0;
 };
 
 // Interface
@@ -64,7 +65,8 @@ protected:
   unsigned long long StateTransMask;
   unsigned char StateKind;
 
-  std::function&lt;void(void)&gt; StateCallbackFunc;
+  std::function&lt;void(void)&gt; StateUpdateFunc;
+  std::function&lt;void(void)&gt; StateChangedFunc;
   
   State()
   {
@@ -75,12 +77,16 @@ protected:
 
 public:
   virtual void update(void){
-	if(StateCallbackFunc)
-		StateCallbackFunc();
+	if(StateUpdateFunc)
+		StateUpdateFunc();
   }
 
-  virtual void setCallbackFunc(std::function&lt;void(void)&gt; _f){
-	StateCallbackFunc = _f;
+  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f){
+	StateUpdateFunc = _f;
+  }
+
+  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f){
+	StateChangedFunc = _f;
   }
 
   void showStateName(void)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" added_lines="7" deleted_lines="3">
				<diff>@@ -41,14 +41,13 @@ private:
   std::atomic&lt;bool&gt; thread_loop;
 
   std::thread *thr_state_dec;
-
-
   std::mutex change_state_mutex;
 
   void showStateMove(unsigned long long _state_num)
   {
     std::cout &lt;&lt; "State will be [" &lt;&lt; StateStores[_state_num]-&gt;getStateName() &lt;&lt; "]" &lt;&lt; std::endl;
   }
+  bool setCurrentState(BaseState *state);
 
 
 public:
@@ -104,7 +103,6 @@ public:
   bool inState(unsigned long long _state_num);
 
   bool setCurrentState(StateFlags flag);
-  bool setCurrentState(BaseState *state);
   bool disableCurrentState(unsigned long long);
 
   BaseState *getCurrentMainState(void);
@@ -115,6 +113,12 @@ public:
   void showCurrentStateName(void);
   std::string createStateMessageText(void);
 
+  unsigned long long getStateStateNum(BaseState *_state);
+  unsigned long long getStateTransMask(BaseState *_state);
+  bool isEmptyMainState(void);
+  bool isDifferentState(BaseState *_state_a, BaseState *_state_b);
+  unsigned char getStateFlags(BaseState *_state);
+
   std::string getCurrentStateName(StateKinds en);
 
   bool setEnableForceSetState(bool force_flag);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="107" deleted_lines="22">
				<diff>@@ -53,16 +53,110 @@ void StateContext::showCurrentStateName(void)
 }
 
 
-/**
- * @fn
- * set to current state
- * @brief standard out a state name
- * @param (state) Setting class
- * @return void
- */
+bool StateContext::isDifferentState(BaseState *_state_a, BaseState *_state_b)
+{
+	return _state_a == _state_b;
+}
+
+bool StateContext::isEmptyMainState(void){
+	if(current_state_.MainState)
+		return false;
+	return true;
+}
+
+unsigned char StateContext::getStateFlags(BaseState *_state)
+{
+	if(_state)
+		return _state-&gt;getStateKind();
+	else
+		return NULL_STATE;
+}
+
+unsigned long long StateContext::getStateTransMask(BaseState *_state)
+{
+	if(_state)
+		return _state-&gt;getStateTransMask();
+	else
+		return 0;
+}
+
+unsigned long long StateContext::getStateStateNum(BaseState *_state)
+{
+	if(_state)
+		return _state-&gt;getStateNum();
+	else
+		return 0;
+}
+
+
+bool StateContext::setCurrentState(BaseState *_state)
+{
+  change_state_mutex.lock();
+
+  BaseState *prevState = current_state_.MainState;
+
+  if (isEmptyMainState() &amp;&amp; _state )
+  {
+    current_state_.MainState = _state;
+    std::cout &lt;&lt; "Successed to set state \""
+              &lt;&lt; "NULL"
+              &lt;&lt; "\" to \"" &lt;&lt; _state-&gt;getStateName() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/"
+              &lt;&lt; "NULL"
+              &lt;&lt; "-" &lt;&lt; _state-&gt;getStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
+  }
+  else
+  {
+    if (_state &amp;&amp; (enableForceSetState || (_state-&gt;getStateTransMask() &amp; prevState-&gt;getStateNum())))
+    {
+      switch (getStateFlags(_state))
+      {
+        case MAIN_STATE:
+          current_state_.MainState = _state;
+          current_state_.AccState = nullptr;
+          current_state_.StrState = nullptr;
+          current_state_.BehaviorState = nullptr;
+          current_state_.PerceptionState = nullptr;
+          current_state_.OtherState = nullptr;
+          break;
+        case ACC_STATE:
+          current_state_.AccState = _state;
+          break;
+        case STR_STATE:
+          current_state_.StrState = _state;
+          break;
+        case BEHAVIOR_STATE:
+          current_state_.BehaviorState = _state;
+          break;
+        case PERCEPTION_STATE:
+          current_state_.PerceptionState = _state;
+          break;
+        case OTHER_STATE:
+          current_state_.OtherState = _state;
+          break;
+      }
+      std::cout &lt;&lt; "Successed to set state \"" &lt;&lt; prevState-&gt;getStateName() &lt;&lt; "\" to \"" &lt;&lt; _state-&gt;getStateName()
+                &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/" &lt;&lt; prevState-&gt;getStateNum() &lt;&lt; "-"
+                &lt;&lt; _state-&gt;getStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
+    }
+    else
+    {
+      std::cerr &lt;&lt; "Failed to set state \"" &lt;&lt; current_state_.MainState-&gt;getStateName() &lt;&lt; "\" to \""
+                &lt;&lt; _state-&gt;getStateName() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/"
+                &lt;&lt; current_state_.MainState-&gt;getStateNum() &lt;&lt; "-" &lt;&lt; _state-&gt;getStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
+      prevState = nullptr;
+      change_state_mutex.unlock();
+      return false;
+    }
+  }
+  change_state_mutex.unlock();
+  return true;
+}
+
+#if 0
 bool StateContext::setCurrentState(BaseState *_state)
 {
   change_state_mutex.lock();
+
   BaseState *prevState = current_state_.MainState;
 
   if (!prevState)
@@ -121,10 +215,12 @@ bool StateContext::setCurrentState(BaseState *_state)
   change_state_mutex.unlock();
   return true;
 }
+#endif
 
 bool StateContext::setCurrentState(StateFlags flag)
 {
-  this-&gt;setCurrentState(StateStores[flag]);
+  bool ret = this-&gt;setCurrentState(StateStores[flag]);
+  return ret;
 }
 
 bool StateContext::setEnableForceSetState(bool force_flag)
@@ -247,7 +343,7 @@ std::string StateContext::createStateMessageText(void)
 bool StateContext::handleTwistCmd(bool _hasTwistCmd)
 {
   if (_hasTwistCmd)
-    return this-&gt;setCurrentState(StateStores[DRIVE_STATE]);
+    return this-&gt;setCurrentState(DRIVE_STATE);
   else
     return false;
 }
@@ -255,28 +351,17 @@ bool StateContext::handleTwistCmd(bool _hasTwistCmd)
 void StateContext::stateDecider(void)
 {
   // not running
-  while (thread_loop)
-  {
-    if (!ChangeStateFlags.empty())
-    {
-      this-&gt;setCurrentState(StateStores[ChangeStateFlags.front()]);
-      ChangeStateFlags.pop();
-    }
-    std::this_thread::sleep_for(std::chrono::microseconds(1000));
-  }
-  std::cerr &lt;&lt; "StateDecider thread will be closed" &lt;&lt; std::endl;
-  return;
 }
 
 void StateContext::InitContext(void)
 {
   thr_state_dec = new std::thread(&amp;StateContext::stateDecider, this);
   thr_state_dec-&gt;detach();
-  this-&gt;setCurrentState(StateStores[START_STATE]);
+  this-&gt;setCurrentState(START_STATE);
   return;
 }
 bool StateContext::TFInitialized(void)
 {
-  return this-&gt;setCurrentState(StateStores[INITIAL_STATE]);
+  return this-&gt;setCurrentState(INITIAL_STATE);
 }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\cross_road_area.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\cross_road_area.hpp" added_lines="1" deleted_lines="1">
				<diff>@@ -10,7 +10,7 @@
 
 namespace decision_maker
 {
-#define CROSS_ROAD 3232
+
 class CrossRoadArea
 {
 public:
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="8" deleted_lines="8">
				<diff>@@ -18,13 +18,13 @@
 
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 
-//#include &lt;vector_map_server/GetCrossRoad.h&gt;
-
 #include &lt;vector_map_msgs/AreaArray.h&gt;
 #include &lt;vector_map_msgs/CrossRoadArray.h&gt;
 #include &lt;vector_map_msgs/LineArray.h&gt;
 #include &lt;vector_map_msgs/PointArray.h&gt;
 
+#include &lt;vector_map/vector_map.h&gt;
+
 #include &lt;geometry_msgs/Point.h&gt;
 
 // lib
@@ -32,14 +32,12 @@
 #include &lt;amathutils.hpp&gt;
 #include &lt;state.hpp&gt;
 #include &lt;state_context.hpp&gt;
-
 #include &lt;decision_maker_param.hpp&gt;
 
-//#include &lt;dynamic_reconfigure/server.h&gt;
-//#include &lt;decision_maker/decision_makerConfig.h&gt;
-
 namespace decision_maker
 {
+using namespace vector_map;
+
 enum class EControl : int32_t
 {
   KEEP = -1,
@@ -93,10 +91,10 @@ private:
 
   std::vector&lt;geometry_msgs::Point&gt; inside_points_;
 
-
   autoware_msgs::LaneArray current_based_lane_array_;
   autoware_msgs::LaneArray current_controlled_lane_array_;
 
+
   // Current way/behavior status
   double current_velocity_;
   double average_velocity_;
@@ -157,7 +155,8 @@ private:
   void setWaypointState(autoware_msgs::LaneArray &amp;lane_array);
 
 
-  void callbackStateSTR(int status);
+  void updateStateSTR(int status);
+  void updateStateStop(int status);
   void setupStateCallback(void);
   // callback by topic subscribing
   void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
@@ -179,6 +178,7 @@ private:
 
 public:
   state_machine::StateContext *ctx;
+  VectorMap g_vmap;
 
   DecisionMakerNode(int argc, char **argv)
   {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_param.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_param.hpp" added_lines="9" deleted_lines="0">
				<diff>@@ -19,6 +19,15 @@ namespace decision_maker
 #define ANGLE_CURVE 40
 #define ANGLE_LEFT  (ANGLE_NEUTRAL - ANGLE_CURVE)
 #define ANGLE_RIGHT (ANGLE_NEUTRAL + ANGLE_CURVE)
+
+#define TPNAME_BASED_LANE_WAYPOINTS_ARRAY "/based/lane_waypoints_array"
+#define TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY "/lane_waypoints_array"
+#define LAMP_EMPTY  0
+#define LAMP_LEFT   1
+#define LAMP_RIGHT  2
+#define LAMP_HAZARD 3
+#define LAMP_ON 1
+#define LAMP_OFF 0
 }
 
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="46" deleted_lines="0">
				<diff>@@ -179,8 +179,18 @@ void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadAr
   }
 }
 
+geometry_msgs::Point to_geoPoint(const vector_map_msgs::Point &amp;vp)
+{
+  geometry_msgs::Point gp;
+  gp.x = vp.ly;
+  gp.y = vp.bx;
+  gp.z = vp.h;
+  return gp;
+}
+
 void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
 {
+  // STR
   for (auto &amp;area : intersects)
   {
     for (auto &amp;laneinArea : area.insideLanes)
@@ -210,6 +220,42 @@ void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
       ROS_INFO("%d: %d  angle_deg :%d\n", area.area_id, steering_state, angle_deg);
     }
   }
+
+  // STOP
+  std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([](const StopLine &amp;stopline) { return true; });
+  for (auto &amp;lane : lane_array.lanes)
+  {
+    for (size_t wp_idx = 0; wp_idx &lt; lane.waypoints.size() - 1; wp_idx++)
+    {
+      for (auto &amp;stopline : stoplines)
+      {
+        if (g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type == vector_map_msgs::RoadSign::TYPE_STOP)
+        {
+          geometry_msgs::Point bp =
+              to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).bpid)));
+          geometry_msgs::Point fp =
+              to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).fpid)));
+	 
+
+          if (amathutils::isIntersectLine(lane.waypoints.at(wp_idx).pose.pose.position.x,
+                                          lane.waypoints.at(wp_idx).pose.pose.position.y,
+                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
+                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.y, bp.x, bp.y, fp.x, fp.y))
+          {
+	    geometry_msgs::Point center_point;
+	    center_point.x = (bp.x*2 + fp.x)/3;
+	    center_point.y = (bp.y*2 + fp.y)/3;
+
+	    if(isPointLeftFromLine){
+		    lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
+		    lane.waypoints.at(wp_idx + 1).wpstate.stopline_state = 1;
+	    }
+
+	  }
+	}
+      }
+    }
+  }
 }
 
 // for based waypoint
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="89" deleted_lines="142">
				<diff>@@ -15,9 +15,9 @@
 #include &lt;decision_maker_node.hpp&gt;
 //#include &lt;vector_map/vector_map.h&gt;
 
-#include &lt;autoware_msgs/lamp_cmd.h&gt;
 #include &lt;autoware_msgs/lane.h&gt;
 #include &lt;autoware_msgs/state.h&gt;
+#include &lt;autoware_msgs/lamp_cmd.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;random&gt;
@@ -28,50 +28,6 @@
 
 namespace decision_maker
 {
-#define TPNAME_BASED_LANE_WAYPOINTS_ARRAY "/based/lane_waypoints_array"
-#define TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY "/lane_waypoints_array"
-#define LAMP_EMPTY  0
-#define LAMP_LEFT   1
-#define LAMP_RIGHT  2
-#define LAMP_HAZARD 3
-#define LAMP_ON 1
-#define LAMP_OFF 0
-
-void DecisionMakerNode::callbackStateSTR(int status)
-{
-  ROS_INFO("[%s]:%d\n", __func__, status);
-  autoware_msgs::lamp_cmd lamp_msg;
-
-  switch(status){
-	  case LAMP_LEFT:
-		  lamp_msg.l = LAMP_ON;
-		  lamp_msg.r = LAMP_OFF;
-		  break;
-	  case LAMP_RIGHT:
-		  lamp_msg.l = LAMP_OFF;
-		  lamp_msg.r = LAMP_ON;
-		  break;
-	  case LAMP_HAZARD:
-		  lamp_msg.l = LAMP_ON;
-		  lamp_msg.r = LAMP_ON;
-		  break;
-	  case LAMP_EMPTY:
-	  default:
-		  lamp_msg.l = LAMP_OFF;
-		  lamp_msg.r = LAMP_OFF;
-		  break;
-  }
-}
-
-void DecisionMakerNode::setupStateCallback(void)
-{
-  ctx-&gt;getStateObject(state_machine::DRIVE_STR_LEFT_STATE)
-      -&gt;setCallbackFunc(std::bind(&amp;DecisionMakerNode::callbackStateSTR, this, 1));
-  ctx-&gt;getStateObject(state_machine::DRIVE_STR_RIGHT_STATE)
-      -&gt;setCallbackFunc(std::bind(&amp;DecisionMakerNode::callbackStateSTR, this, 2));
-  ctx-&gt;getStateObject(state_machine::DRIVE_STR_STRAIGHT_STATE)
-      -&gt;setCallbackFunc(std::bind(&amp;DecisionMakerNode::callbackStateSTR, this, 0));
-}
 
 void DecisionMakerNode::initROS(int argc, char **argv)
 {
@@ -89,16 +45,16 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   Subs["change_flag"] = nh_.subscribe("change_flag", 1, &amp;DecisionMakerNode::callbackFromLaneChangeFlag, this);
   Subs["state_cmd"] = nh_.subscribe("state_cmd", 1, &amp;DecisionMakerNode::callbackFromStateCmd, this);
 
-  // vector map subscriber
-  Subs["vector_map_area"] =
-      nh_.subscribe("/vector_map_info/area", 1, &amp;DecisionMakerNode::callbackFromVectorMapArea, this);
-  Subs["vector_map_point"] =
-      nh_.subscribe("/vector_map_info/point", 1, &amp;DecisionMakerNode::callbackFromVectorMapPoint, this);
-  Subs["vector_map_line"] =
-      nh_.subscribe("/vector_map_info/line", 1, &amp;DecisionMakerNode::callbackFromVectorMapLine, this);
-  Subs["vector_map_crossroad"] =
-      nh_.subscribe("/vector_map_info/cross_road", 1, &amp;DecisionMakerNode::callbackFromVectorMapCrossRoad, this);
-
+//  // vector map subscriber
+//  Subs["vector_map_area"] =
+//      nh_.subscribe("/vector_map_info/area", 1, &amp;DecisionMakerNode::callbackFromVectorMapArea, this);
+//  Subs["vector_map_point"] =
+//      nh_.subscribe("/vector_map_info/point", 1, &amp;DecisionMakerNode::callbackFromVectorMapPoint, this);
+//  Subs["vector_map_line"] =
+//      nh_.subscribe("/vector_map_info/line", 1, &amp;DecisionMakerNode::callbackFromVectorMapLine, this);
+//  Subs["vector_map_crossroad"] =
+//      nh_.subscribe("/vector_map_info/cross_road", 1, &amp;DecisionMakerNode::callbackFromVectorMapCrossRoad, this);
+//
   // Config subscriber
   Subs["config/decision_maker"] =
       nh_.subscribe("/config/decision_maker", 3, &amp;DecisionMakerNode::callbackFromConfig, this);
@@ -138,16 +94,17 @@ void DecisionMakerNode::initROS(int argc, char **argv)
 
   // to move initial state from start state
   // this part confirm broadcasting tf(map to world)
-  {
-    std::cout &lt;&lt; "wait for tf of map to world" &lt;&lt; std::endl;
-    tf::TransformListener tf;
+  std::cout &lt;&lt; "wait for tf of map to world" &lt;&lt; std::endl;
+  tf::TransformListener tf;
+  tf.waitForTransform("map", "world", ros::Time(), ros::Duration(15));
+  if (!ctx-&gt;TFInitialized())
+	  std::cerr &lt;&lt; "failed initialization " &lt;&lt; std::endl;
+  g_vmap.subscribe(nh_, 
+		  Category::POINT |  Category::LINE |  Category::VECTOR | Category::AREA | Category::POLE | //basic class
+		  Category::DTLANE | Category::STOP_LINE | Category::ROAD_SIGN | Category::CROSS_ROAD);
+  initVectorMap();
 
-    tf.waitForTransform("map", "world", ros::Time(), ros::Duration(15));
-    if (!ctx-&gt;TFInitialized())
-      std::cerr &lt;&lt; "failed initialization " &lt;&lt; std::endl;
-  }
   {
-    initVectorMapClient();
     if (enableDisplayMarker)
       displayMarker();
   }
@@ -155,98 +112,88 @@ void DecisionMakerNode::initROS(int argc, char **argv)
 
 void DecisionMakerNode::initVectorMap(void)
 {
-  if (!vector_map_init)
-  {
-    vMap_mutex.lock();
-    if (!vector_map_init &amp;&amp; vMap_Areas_flag &amp; vMap_Points_flag &amp; vMap_Lines_flag &amp; vMap_CrossRoads_flag)
-    {
-      vector_map_init = true;
-
       int _index = 0;
+      if(vector_map_init)
+	      return;
 
-      // parse vmap
-      for (const auto &amp;cross_road : vMap_CrossRoads.data)
+      std::vector&lt;CrossRoad&gt; crossroads = g_vmap.findByFilter([](const CrossRoad &amp;crossroad){return true;});
+      if(crossroads.empty()){
+	      ROS_INFO("crossroad have not found\n");
+	      return;
+      }
+
+      vector_map_init = true; //loaded flag
+      for(const auto &amp;cross_road : crossroads)
       {
-        for (const auto &amp;area : vMap_Areas.data)
-        {
-          if (cross_road.aid == area.aid)
-          {
-            CrossRoadArea carea;
-            carea.id = _index++;
-            carea.area_id = area.aid;
-
-            double x_avg = 0.0, x_min = 0.0, x_max = 0.0;
-            double y_avg = 0.0, y_min = 0.0, y_max = 0.0;
-            double z = 0.0;
-            int points_count = 0;
-
-            for (const auto &amp;line : vMap_Lines.data)
-            {
-              if (area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid)
-              {
-                geometry_msgs::Point _prev_point;
-                for (const auto &amp;point : vMap_Points.data)
-                {
-                  if (line.fpid &lt;= point.pid &amp;&amp; point.pid &lt;= line.fpid)
-                  {
-                    geometry_msgs::Point _point;
-                    _point.x = point.bx;
-                    _point.y = point.ly;
-                    _point.z = point.h;
-
-                    if (_prev_point.x == _point.x &amp;&amp; _prev_point.y == _point.y)
-                      continue;
-
-                    _prev_point = _point;
-                    points_count++;
-                    carea.points.push_back(_point);
-
-                    // calc a centroid point and about intersects size
-                    x_avg += _point.x;
-                    y_avg += _point.y;
-                    x_min = (x_min == 0.0) ? _point.x : std::min(_point.x, x_min);
-                    x_max = (x_max == 0.0) ? _point.x : std::max(_point.x, x_max);
-                    y_min = (y_min == 0.0) ? _point.y : std::min(_point.y, y_min);
-                    y_max = (y_max == 0.0) ? _point.y : std::max(_point.y, y_max);
-                    z = _point.z;
-
-                  }  // if pid
-                }    // points iter
-              }      // if lid
-            }        // line iter
-            carea.bbox.pose.position.x = x_avg / (double)points_count;
-            carea.bbox.pose.position.y = y_avg / (double)points_count;
-            carea.bbox.pose.position.z = z;
-            carea.bbox.dimensions.x = x_max - x_min;
-            carea.bbox.dimensions.y = y_max - y_min;
-            carea.bbox.dimensions.z = 2;
-            carea.bbox.label = 1;
-            intersects.push_back(carea);
-          }
-        }
+	Area area = g_vmap.findByKey(Key&lt;Area&gt;(cross_road.aid));
+	CrossRoadArea carea;
+	carea.id = _index++;
+	carea.area_id = area.aid;
+	
+	double x_avg = 0.0, x_min = 0.0, x_max = 0.0;
+	double y_avg = 0.0, y_min = 0.0, y_max = 0.0;
+	double z = 0.0;
+	int points_count = 0;
+
+	std::vector&lt;Line&gt; lines = g_vmap.findByFilter([&amp;area](const Line &amp;line){return area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid;});
+	for (const auto &amp;line : lines)
+	{
+		geometry_msgs::Point _prev_point;
+		std::vector&lt;Point&gt; points = g_vmap.findByFilter([&amp;line](const Point &amp;point){return line.bpid == point.pid || point.pid == line.fpid;});
+		for (const auto &amp;point : points)
+		{
+			geometry_msgs::Point _point;
+			_point.x = point.ly;
+			_point.y = point.bx;
+			_point.z = point.h;
+
+			if (_prev_point.x == _point.x &amp;&amp; _prev_point.y == _point.y)
+				continue;
+
+			_prev_point = _point;
+			points_count++;
+			carea.points.push_back(_point);
+
+			// calc a centroid point and about intersects size
+			x_avg += _point.x;
+			y_avg += _point.y;
+			x_min = (x_min == 0.0) ? _point.x : std::min(_point.x, x_min);
+			x_max = (x_max == 0.0) ? _point.x : std::max(_point.x, x_max);
+			y_min = (y_min == 0.0) ? _point.y : std::min(_point.y, y_min);
+			y_max = (y_max == 0.0) ? _point.y : std::max(_point.y, y_max);
+			z = _point.z;
+
+		}    // points iter
+	}        // line iter
+	carea.bbox.pose.position.x = x_avg / (double)points_count;
+	carea.bbox.pose.position.y = y_avg / (double)points_count;
+	carea.bbox.pose.position.z = z;
+	carea.bbox.dimensions.x = x_max - x_min;
+	carea.bbox.dimensions.y = y_max - y_min;
+	carea.bbox.dimensions.z = 2;
+	carea.bbox.label = 1;
+	intersects.push_back(carea);
       }
-    }
-    vMap_mutex.unlock();
-    Subs["lane_waypoints_array"] =
-        nh_.subscribe(TPNAME_BASED_LANE_WAYPOINTS_ARRAY, 100, &amp;DecisionMakerNode::callbackFromLaneWaypoint, this);
-  }
+
+      Subs["lane_waypoints_array"] =
+	      nh_.subscribe(TPNAME_BASED_LANE_WAYPOINTS_ARRAY, 100, &amp;DecisionMakerNode::callbackFromLaneWaypoint, this);
 }
 
 bool DecisionMakerNode::initVectorMapClient()
 {
 #ifdef USE_VMAP_SERVER  // This is not successfully run due to failing vmap
-  // server
+	// server
 
-  vector_map::VectorMap vmap;
-  vmap.subscribe(nh_, vector_map::Category::AREA, ros::Duration(0));
+	vector_map::VectorMap vmap;
+	vmap.subscribe(nh_, vector_map::Category::AREA, ros::Duration(0));
 
-  cross_road_srv.request.pose = current_pose_;
-  cross_road_srv.request.waypoints = current_finalwaypoints_;
+	cross_road_srv.request.pose = current_pose_;
+	cross_road_srv.request.waypoints = current_finalwaypoints_;
 
-  cross_road_cli = nh_.serviceClient&lt;vector_map_server::GetCrossRoad&gt;("vector_map_server/get_cross_road");
+	cross_road_cli = nh_.serviceClient&lt;vector_map_server::GetCrossRoad&gt;("vector_map_server/get_cross_road");
 
-  return cross_road_cli.call(cross_road_srv);
+	return cross_road_cli.call(cross_road_srv);
 #endif
-  return false;
+	return false;
 }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="0" deleted_lines="2">
				<diff>@@ -54,8 +54,6 @@ void DecisionMakerNode::displayMarker(void)
 {
   // vector_map init
   // parse vectormap
-  initVectorMap();
-
   jsk_recognition_msgs::BoundingBoxArray bbox_array;
 
   static visualization_msgs::MarkerArray marker_array;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a9fa5d7fcaee47e29921e8741ddb119ad8baf26e" author="Yusuke FUJII">
		<msg>minor fixes</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" added_lines="26" deleted_lines="22">
				<diff>@@ -1,11 +1,11 @@
 #ifndef __STATE_HPP__
 #define __STATE_HPP__
 
+#include &lt;functional&gt;
 #include &lt;iostream&gt;
 #include &lt;memory&gt;
-#include &lt;vector&gt;
-#include &lt;functional&gt;
 #include &lt;state_flags.hpp&gt;
+#include &lt;vector&gt;
 
 namespace state_machine
 {
@@ -44,15 +44,16 @@ protected:
   BaseState()
   {
   }
+
 public:
   virtual void update(void) = 0;
   virtual void showStateName(void) = 0;
-  virtual unsigned long long getStateTransMask(void) = 0;
-  virtual unsigned long long getStateNum(void) = 0;
+  virtual uint64_t getStateTransMask(void) = 0;
+  virtual uint64_t getStateNum(void) = 0;
   virtual std::string getStateName(void) = 0;
-  virtual unsigned char getStateKind(void) = 0;
-  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f)=0;
-  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f)=0;
+  virtual uint8_t getStateKind(void) = 0;
+  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f) = 0;
+  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f) = 0;
 };
 
 // Interface
@@ -61,32 +62,35 @@ class State : public BaseState
 {
 protected:
   std::string StateName = "Base";
-  unsigned long long StateNum;
-  unsigned long long StateTransMask;
-  unsigned char StateKind;
+  uint64_t StateNum;
+  uint64_t StateTransMask;
+  uint8_t StateKind;
 
   std::function&lt;void(void)&gt; StateUpdateFunc;
   std::function&lt;void(void)&gt; StateChangedFunc;
-  
+
   State()
   {
     StateNum = 0;
-    StateTransMask = (unsigned long long)STATE_END - 1;
+    StateTransMask = (uint64_t)STATE_END - 1;
     StateKind = UNKNOWN_STATE;
   }
 
 public:
-  virtual void update(void){
-	if(StateUpdateFunc)
-		StateUpdateFunc();
+  virtual void update(void)
+  {
+    if (StateUpdateFunc)
+      StateUpdateFunc();
   }
 
-  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f){
-	StateUpdateFunc = _f;
+  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f)
+  {
+    StateUpdateFunc = _f;
   }
 
-  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f){
-	StateChangedFunc = _f;
+  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f)
+  {
+    StateChangedFunc = _f;
   }
 
   void showStateName(void)
@@ -105,16 +109,16 @@ public:
     return std::string(StateName);
   }
 
-  unsigned char getStateKind(void)
+  uint8_t getStateKind(void)
   {
     return StateKind;
   }
 
-  unsigned long long getStateTransMask(void)
+  uint64_t getStateTransMask(void)
   {
     return StateTransMask;
   }
-  unsigned long long getStateNum(void)
+  uint64_t getStateNum(void)
   {
     return StateNum;
   }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" added_lines="27" deleted_lines="29">
				<diff>@@ -3,24 +3,23 @@
 
 #include &lt;atomic&gt;
 #include &lt;iostream&gt;
+#include &lt;map&gt;
+#include &lt;mutex&gt;
 #include &lt;queue&gt;
 #include &lt;thread&gt;
-#include &lt;mutex&gt;
 #include &lt;unordered_map&gt;
 #include &lt;utility&gt;
 
-
 #include "state.hpp"
-#include "state_main.hpp"
 #include "state_drive.hpp"
 #include "state_emg.hpp"
+#include "state_main.hpp"
 
 namespace state_machine
 {
 class StateContext
 {
 private:
-
   class StateHolder
   {
   public:
@@ -32,24 +31,22 @@ private:
     BaseState *OtherState;
   } current_state_;
 
-  std::vector&lt;BaseState **&gt; HolderList;
-
+  std::map&lt;uint8_t, BaseState **&gt; HolderMap;
   std::unordered_map&lt;uint64_t, BaseState *&gt; StateStores;
 
   bool enableForceSetState;
-  std::queue&lt;unsigned long long&gt; ChangeStateFlags;
+  std::queue&lt;uint64_t&gt; ChangeStateFlags;
   std::atomic&lt;bool&gt; thread_loop;
 
   std::thread *thr_state_dec;
   std::mutex change_state_mutex;
 
-  void showStateMove(unsigned long long _state_num)
+  void showStateMove(uint64_t _state_num)
   {
     std::cout &lt;&lt; "State will be [" &lt;&lt; StateStores[_state_num]-&gt;getStateName() &lt;&lt; "]" &lt;&lt; std::endl;
   }
   bool setCurrentState(BaseState *state);
 
-
 public:
   StateContext(void)
   {
@@ -73,16 +70,16 @@ public:
     StateStores[MISSION_COMPLETE_STATE] = MissionCompleteState::getInstance();
     StateStores[EMERGENCY_STATE] = EmergencyState::getInstance();
 
-    HolderList.push_back(&amp;current_state_.MainState);
-    HolderList.push_back(&amp;current_state_.AccState);
-    HolderList.push_back(&amp;current_state_.StrState);
-    HolderList.push_back(&amp;current_state_.BehaviorState);
-    HolderList.push_back(&amp;current_state_.PerceptionState);
-    HolderList.push_back(&amp;current_state_.OtherState);
+    HolderMap[MAIN_STATE] = &amp;current_state_.MainState;
+    HolderMap[ACC_STATE] = &amp;current_state_.AccState;
+    HolderMap[STR_STATE] = &amp;current_state_.StrState;
+    HolderMap[BEHAVIOR_STATE] = &amp;current_state_.BehaviorState;
+    HolderMap[PERCEPTION_STATE] = &amp;current_state_.PerceptionState;
+    HolderMap[OTHER_STATE] = &amp;current_state_.OtherState;
 
-    for (auto &amp;&amp;p : HolderList)
+    for (auto &amp;p : HolderMap)
     {
-      *p = nullptr;
+      *p.second = nullptr;
     }
     thread_loop = true;
 
@@ -97,32 +94,33 @@ public:
   void update(void);
   void stateDecider(void);
 
-  bool isState(BaseState *base, unsigned long long _state_num);
-  bool isCurrentState(unsigned long long _state_num);
-  bool isCurrentState(unsigned char _state_kind, unsigned long long _state_num);
-  bool inState(unsigned long long _state_num);
+  bool isState(BaseState *base, uint64_t _state_num);
+  bool isCurrentState(uint64_t _state_num);
+  bool isCurrentState(uint8_t _state_kind, uint64_t _state_num);
+  bool inState(uint64_t _state_num);
 
-  bool setCurrentState(StateFlags flag);
-  bool disableCurrentState(unsigned long long);
+  bool setCurrentState(uint64_t flag);
+  bool disableCurrentState(uint64_t);
 
   BaseState *getCurrentMainState(void);
   BaseState *getCurrentState(void);
   std::string getCurrentStateName(void);
   std::string getStateName(void);
-  BaseState **getCurrentStateHolderPtr(unsigned long long _state_num);
+  BaseState **getCurrentStateHolderPtr(uint64_t _state_num);
   void showCurrentStateName(void);
   std::string createStateMessageText(void);
 
-  unsigned long long getStateStateNum(BaseState *_state);
-  unsigned long long getStateTransMask(BaseState *_state);
+  uint64_t getStateNum(BaseState *_state);
+  uint64_t getStateTransMask(BaseState *_state);
   bool isEmptyMainState(void);
   bool isDifferentState(BaseState *_state_a, BaseState *_state_b);
-  unsigned char getStateFlags(BaseState *_state);
+  uint8_t getStateKind(BaseState *_state);
+  bool isMainState(BaseState *_state);
 
-  std::string getCurrentStateName(StateKinds en);
+  std::string getCurrentStateName(uint8_t kind);
 
   bool setEnableForceSetState(bool force_flag);
-  BaseState *getStateObject(unsigned long long _state_num);
+  BaseState *getStateObject(uint64_t _state_num);
   void InitContext(void);
 
   bool TFInitialized(void);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" added_lines="2" deleted_lines="1">
				<diff>@@ -12,7 +12,6 @@
 
 namespace state_machine
 {
-
 // DriveState
 class DriveState : public State&lt;DriveState&gt;
 {
@@ -117,6 +116,7 @@ private:
     StateTransMask = DRIVE_STATE;
     StateKind = STR_STATE;
   }
+
 public:
 };
 class DriveStrRightState : public State&lt;DriveStrRightState&gt;
@@ -130,6 +130,7 @@ private:
     StateTransMask = DRIVE_STATE;
     StateKind = STR_STATE;
   }
+
 public:
 };
 class DriveStrStraightState : public State&lt;DriveStrStraightState&gt;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_main.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_main.hpp" added_lines="4" deleted_lines="3">
				<diff>@@ -9,7 +9,6 @@
 
 namespace state_machine
 {
-
 // StartState
 class StartState : public State&lt;StartState&gt;
 {
@@ -19,11 +18,13 @@ private:
   {
     StateName = "Start";
     StateNum = START_STATE;
-    StateTransMask = (unsigned long long)STATE_END - 1;
+    StateTransMask = (uint64_t)STATE_END - 1;
     StateKind = MAIN_STATE;
   }
+
 public:
-  virtual void update (void) override{
+  virtual void update(void) override
+  {
   }
 };
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="66" deleted_lines="161">
				<diff>@@ -25,21 +25,22 @@ namespace state_machine
 {
 void StateContext::update(void)
 {
-	for(auto &amp;&amp;p : HolderList){
-		if(*p){
-			(*p)-&gt;update();
-		}
-	}
-
+  for (auto &amp;p : HolderMap)
+  {
+    if (*p.second)
+    {
+      (*p.second)-&gt;update();
+    }
+  }
 }
 
-
 void StateContext::showCurrentStateName(void)
 {
-  for (auto &amp;&amp;p : HolderList) {
-    if (*p)
+  for (auto &amp;p : HolderMap)
+  {
+    if (*p.second)
     {
-      (*p)-&gt;showStateName();
+      (*p.second)-&gt;showStateName();
     }
   }
 
@@ -52,172 +53,79 @@ void StateContext::showCurrentStateName(void)
   std::cout &lt;&lt; std::endl;
 }
 
-
 bool StateContext::isDifferentState(BaseState *_state_a, BaseState *_state_b)
 {
-	return _state_a == _state_b;
+  return _state_a == _state_b;
 }
 
-bool StateContext::isEmptyMainState(void){
-	if(current_state_.MainState)
-		return false;
-	return true;
+bool StateContext::isEmptyMainState(void)
+{
+  if (current_state_.MainState)
+    return false;
+  return true;
 }
 
-unsigned char StateContext::getStateFlags(BaseState *_state)
+uint8_t StateContext::getStateKind(BaseState *_state)
 {
-	if(_state)
-		return _state-&gt;getStateKind();
-	else
-		return NULL_STATE;
+  if (_state)
+    return _state-&gt;getStateKind();
+  else
+    return NULL_STATE;
 }
 
-unsigned long long StateContext::getStateTransMask(BaseState *_state)
+uint64_t StateContext::getStateTransMask(BaseState *_state)
 {
-	if(_state)
-		return _state-&gt;getStateTransMask();
-	else
-		return 0;
+  if (_state)
+    return _state-&gt;getStateTransMask();
+  else
+    return 0;
 }
 
-unsigned long long StateContext::getStateStateNum(BaseState *_state)
+uint64_t StateContext::getStateNum(BaseState *_state)
 {
-	if(_state)
-		return _state-&gt;getStateNum();
-	else
-		return 0;
+  if (_state)
+    return _state-&gt;getStateNum();
+  else
+    return 0;
 }
 
+bool StateContext::isMainState(BaseState *_state)
+{
+  return getStateKind(_state) == MAIN_STATE;
+}
 
 bool StateContext::setCurrentState(BaseState *_state)
 {
   change_state_mutex.lock();
 
-  BaseState *prevState = current_state_.MainState;
+  bool ret = true;
 
-  if (isEmptyMainState() &amp;&amp; _state )
+  if (isMainState(_state))
   {
-    current_state_.MainState = _state;
-    std::cout &lt;&lt; "Successed to set state \""
-              &lt;&lt; "NULL"
-              &lt;&lt; "\" to \"" &lt;&lt; _state-&gt;getStateName() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/"
-              &lt;&lt; "NULL"
-              &lt;&lt; "-" &lt;&lt; _state-&gt;getStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
-  }
-  else
-  {
-    if (_state &amp;&amp; (enableForceSetState || (_state-&gt;getStateTransMask() &amp; prevState-&gt;getStateNum())))
+    if (isEmptyMainState() || enableForceSetState ||
+        (getStateTransMask(_state) &amp; getStateNum(current_state_.MainState)))
     {
-      switch (getStateFlags(_state))
-      {
-        case MAIN_STATE:
-          current_state_.MainState = _state;
-          current_state_.AccState = nullptr;
-          current_state_.StrState = nullptr;
-          current_state_.BehaviorState = nullptr;
-          current_state_.PerceptionState = nullptr;
-          current_state_.OtherState = nullptr;
-          break;
-        case ACC_STATE:
-          current_state_.AccState = _state;
-          break;
-        case STR_STATE:
-          current_state_.StrState = _state;
-          break;
-        case BEHAVIOR_STATE:
-          current_state_.BehaviorState = _state;
-          break;
-        case PERCEPTION_STATE:
-          current_state_.PerceptionState = _state;
-          break;
-        case OTHER_STATE:
-          current_state_.OtherState = _state;
-          break;
-      }
-      std::cout &lt;&lt; "Successed to set state \"" &lt;&lt; prevState-&gt;getStateName() &lt;&lt; "\" to \"" &lt;&lt; _state-&gt;getStateName()
-                &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/" &lt;&lt; prevState-&gt;getStateNum() &lt;&lt; "-"
-                &lt;&lt; _state-&gt;getStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
+      current_state_.MainState = _state;
+      current_state_.AccState = nullptr;
+      current_state_.StrState = nullptr;
+      current_state_.BehaviorState = nullptr;
+      current_state_.PerceptionState = nullptr;
+      current_state_.OtherState = nullptr;
     }
     else
     {
-      std::cerr &lt;&lt; "Failed to set state \"" &lt;&lt; current_state_.MainState-&gt;getStateName() &lt;&lt; "\" to \""
-                &lt;&lt; _state-&gt;getStateName() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/"
-                &lt;&lt; current_state_.MainState-&gt;getStateNum() &lt;&lt; "-" &lt;&lt; _state-&gt;getStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
-      prevState = nullptr;
-      change_state_mutex.unlock();
-      return false;
+      ret = false;
     }
   }
-  change_state_mutex.unlock();
-  return true;
-}
-
-#if 0
-bool StateContext::setCurrentState(BaseState *_state)
-{
-  change_state_mutex.lock();
-
-  BaseState *prevState = current_state_.MainState;
-
-  if (!prevState)
-  {
-    current_state_.MainState = _state;
-    std::cout &lt;&lt; "Successed to set state \""
-              &lt;&lt; "NULL"
-              &lt;&lt; "\" to \"" &lt;&lt; _state-&gt;getStateName() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/"
-              &lt;&lt; "NULL"
-              &lt;&lt; "-" &lt;&lt; _state-&gt;getStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
-  }
   else
   {
-    if (_state &amp;&amp; (enableForceSetState || (_state-&gt;getStateTransMask() &amp; prevState-&gt;getStateNum())))
-    {
-      switch (_state-&gt;getStateKind())
-      {
-        case MAIN_STATE:
-          current_state_.MainState = _state;
-          current_state_.AccState = nullptr;
-          current_state_.StrState = nullptr;
-          current_state_.BehaviorState = nullptr;
-          current_state_.PerceptionState = nullptr;
-          current_state_.OtherState = nullptr;
-          break;
-        case ACC_STATE:
-          current_state_.AccState = _state;
-          break;
-        case STR_STATE:
-          current_state_.StrState = _state;
-          break;
-        case BEHAVIOR_STATE:
-          current_state_.BehaviorState = _state;
-          break;
-        case PERCEPTION_STATE:
-          current_state_.PerceptionState = _state;
-          break;
-        case OTHER_STATE:
-          current_state_.OtherState = _state;
-          break;
-      }
-      std::cout &lt;&lt; "Successed to set state \"" &lt;&lt; prevState-&gt;getStateName() &lt;&lt; "\" to \"" &lt;&lt; _state-&gt;getStateName()
-                &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/" &lt;&lt; prevState-&gt;getStateNum() &lt;&lt; "-"
-                &lt;&lt; _state-&gt;getStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
-    }
-    else
-    {
-      std::cerr &lt;&lt; "Failed to set state \"" &lt;&lt; current_state_.MainState-&gt;getStateName() &lt;&lt; "\" to \""
-                &lt;&lt; _state-&gt;getStateName() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/"
-                &lt;&lt; current_state_.MainState-&gt;getStateNum() &lt;&lt; "-" &lt;&lt; _state-&gt;getStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
-      prevState = nullptr;
-      change_state_mutex.unlock();
-      return false;
-    }
+    *HolderMap[getStateKind(_state)] = _state;
   }
   change_state_mutex.unlock();
-  return true;
+  return ret;
 }
-#endif
 
-bool StateContext::setCurrentState(StateFlags flag)
+bool StateContext::setCurrentState(uint64_t flag)
 {
   bool ret = this-&gt;setCurrentState(StateStores[flag]);
   return ret;
@@ -229,18 +137,15 @@ bool StateContext::setEnableForceSetState(bool force_flag)
   return true;
 }
 
-std::string StateContext::getCurrentStateName(StateKinds en)
+std::string StateContext::getCurrentStateName(uint8_t kind)
 {
-  for (auto &amp;&amp;p : HolderList)
-  {
-    if (*p &amp;&amp; (*p)-&gt;getStateKind() == en)
-	      return (*p)-&gt;getStateName();
-  }
+  if (*HolderMap[kind])
+    return (*HolderMap[kind])-&gt;getStateName();
   return std::string("");
 }
 std::string StateContext::getCurrentStateName(void)
 {
-	return this-&gt;getCurrentStateName(MAIN_STATE);
+  return this-&gt;getCurrentStateName(MAIN_STATE);
 }
 
 BaseState *StateContext::getCurrentMainState(void)
@@ -248,15 +153,15 @@ BaseState *StateContext::getCurrentMainState(void)
   return current_state_.MainState;
 }
 
-BaseState *StateContext::getStateObject(unsigned long long _state_num)
+BaseState *StateContext::getStateObject(uint64_t _state_num)
 {
   return StateStores[_state_num];
 }
 
-BaseState **StateContext::getCurrentStateHolderPtr(unsigned long long _state_num)
+BaseState **StateContext::getCurrentStateHolderPtr(uint64_t _state_num)
 {
   BaseState **state_ptr;
-  switch (getStateObject(_state_num)-&gt;getStateKind())
+  switch (getStateKind(getStateObject(_state_num)))
   {
     case MAIN_STATE:
       state_ptr = &amp;current_state_.MainState;
@@ -283,7 +188,7 @@ BaseState **StateContext::getCurrentStateHolderPtr(unsigned long long _state_num
   return state_ptr;
 }
 
-bool StateContext::disableCurrentState(unsigned long long _state_num)
+bool StateContext::disableCurrentState(uint64_t _state_num)
 {
   BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
   if (state_ptr &amp;&amp; this-&gt;isState((*state_ptr), _state_num))
@@ -297,18 +202,18 @@ bool StateContext::disableCurrentState(unsigned long long _state_num)
   }
 }
 
-bool StateContext::isCurrentState(unsigned long long _state_num)
+bool StateContext::isCurrentState(uint64_t _state_num)
 {
   BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
   return (*state_ptr) ? (*state_ptr)-&gt;getStateNum() &amp; _state_num ? true : false : false;
 }
 
-bool StateContext::isState(BaseState *base, unsigned long long _state_num)
+bool StateContext::isState(BaseState *base, uint64_t _state_num)
 {
   return base ? base-&gt;getStateNum() &amp; _state_num ? true : false : false;
 }
 
-bool StateContext::inState(unsigned long long _state_num)
+bool StateContext::inState(uint64_t _state_num)
 {
   if (current_state_.MainState)
   {
@@ -322,19 +227,19 @@ bool StateContext::inState(unsigned long long _state_num)
 
 bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
 {
-    /* deprecated */
-	return false;
+  /* deprecated */
+  return false;
 }
 
 std::string StateContext::createStateMessageText(void)
 {
   std::string ret;
 
-  for (auto &amp;&amp;p : HolderList)
+  for (auto &amp;p : HolderMap)
   {
-    if (*p)
+    if (*p.second)
     {
-      ret = ret + "\n" + (*p)-&gt;getStateName();
+      ret = ret + "\n" + (*p.second)-&gt;getStateName();
     }
   }
   return ret;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="15e261c5b5a5f63bdc11bf86b4b5b0d62a0e7801" author="Yusuke FUJII">
		<msg>add state changed callback</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="70" deleted_lines="63">
				<diff>@@ -34,6 +34,17 @@ void StateContext::update(void)
   }
 }
 
+void StateContext::changed(uint8_t _kind)
+{
+	if(_kind &gt;  NULL_STATE){
+		return;
+	}
+
+	if(*HolderMap[_kind])
+		(*HolderMap[_kind])-&gt;changed();
+}
+
+
 void StateContext::showCurrentStateName(void)
 {
   for (auto &amp;p : HolderMap)
@@ -43,19 +54,15 @@ void StateContext::showCurrentStateName(void)
       (*p.second)-&gt;showStateName();
     }
   }
-
-#if 0
-  if (sub_state)
-    sub_state-&gt;showStateName();
-  if (sub_sub_state)
-    sub_sub_state-&gt;showStateName();
-#endif
-  std::cout &lt;&lt; std::endl;
 }
 
-bool StateContext::isDifferentState(BaseState *_state_a, BaseState *_state_b)
+bool StateContext::isDifferentState(BaseState *_state_a, BaseState **_state_b)
 {
-  return _state_a == _state_b;
+	if(_state_b){
+		return _state_a == *_state_b;
+	}else{
+		return false;
+	}
 }
 
 bool StateContext::isEmptyMainState(void)
@@ -97,32 +104,38 @@ bool StateContext::isMainState(BaseState *_state)
 bool StateContext::setCurrentState(BaseState *_state)
 {
   change_state_mutex.lock();
-
   bool ret = true;
-
-  if (isMainState(_state))
-  {
-    if (isEmptyMainState() || enableForceSetState ||
-        (getStateTransMask(_state) &amp; getStateNum(current_state_.MainState)))
-    {
-      current_state_.MainState = _state;
-      current_state_.AccState = nullptr;
-      current_state_.StrState = nullptr;
-      current_state_.BehaviorState = nullptr;
-      current_state_.PerceptionState = nullptr;
-      current_state_.OtherState = nullptr;
-    }
-    else
-    {
-      ret = false;
-    }
+  if(_state){
+	  bool diff = isDifferentState(_state, getCurrentStateHolderPtr(_state));
+	  if (isMainState(_state))
+	  {
+		  if (isEmptyMainState() || enableForceSetState ||
+				  (getStateTransMask(_state) &amp; getStateNum(current_state_.MainState)))
+		  {
+			  current_state_.MainState = _state;
+			  current_state_.AccState = nullptr;
+			  current_state_.StrState = nullptr;
+			  current_state_.BehaviorState = nullptr;
+			  current_state_.PerceptionState = nullptr;
+			  current_state_.OtherState = nullptr;
+		  }
+		  else
+		  {
+			  ret = false;
+		  }
+	  }
+	  else
+	  {
+		  *HolderMap[getStateKind(_state)] = _state;
+	  }
+	  change_state_mutex.unlock();
+	  if(ret)
+		  this-&gt;changed(getStateKind(_state));
+  }else{
+	  ret = false;
   }
-  else
-  {
-    *HolderMap[getStateKind(_state)] = _state;
-  }
-  change_state_mutex.unlock();
   return ret;
+
 }
 
 bool StateContext::setCurrentState(uint64_t flag)
@@ -137,11 +150,13 @@ bool StateContext::setEnableForceSetState(bool force_flag)
   return true;
 }
 
-std::string StateContext::getCurrentStateName(uint8_t kind)
+std::string StateContext::getCurrentStateName(uint8_t _kind)
 {
-  if (*HolderMap[kind])
-    return (*HolderMap[kind])-&gt;getStateName();
-  return std::string("");
+	if(_kind&lt;= NULL_STATE){
+		if (*HolderMap[_kind])
+			return (*HolderMap[_kind])-&gt;getStateName();
+	}
+	return std::string("");
 }
 std::string StateContext::getCurrentStateName(void)
 {
@@ -158,34 +173,26 @@ BaseState *StateContext::getStateObject(uint64_t _state_num)
   return StateStores[_state_num];
 }
 
+
+BaseState **StateContext::getCurrentStateHolderPtr(uint8_t _kind)
+{
+	if(_kind &gt;  NULL_STATE){
+		return nullptr;
+	}
+  return HolderMap[_kind];
+}
+
 BaseState **StateContext::getCurrentStateHolderPtr(uint64_t _state_num)
 {
-  BaseState **state_ptr;
-  switch (getStateKind(getStateObject(_state_num)))
-  {
-    case MAIN_STATE:
-      state_ptr = &amp;current_state_.MainState;
-      break;
-    case ACC_STATE:
-      state_ptr = &amp;current_state_.AccState;
-      break;
-    case STR_STATE:
-      state_ptr = &amp;current_state_.StrState;
-      break;
-    case BEHAVIOR_STATE:
-      state_ptr = &amp;current_state_.BehaviorState;
-      break;
-    case PERCEPTION_STATE:
-      state_ptr = &amp;current_state_.PerceptionState;
-      break;
-    case OTHER_STATE:
-      state_ptr = &amp;current_state_.OtherState;
-      break;
-    default:
-      state_ptr = nullptr;
-      break;
-  }
-  return state_ptr;
+  return getCurrentStateHolderPtr(getStateKind(getStateObject(_state_num)));
+}
+
+BaseState **StateContext::getCurrentStateHolderPtr(BaseState *_state)
+{
+	if(_state)
+		return getCurrentStateHolderPtr(getStateKind(_state));
+	else
+		return nullptr;
 }
 
 bool StateContext::disableCurrentState(uint64_t _state_num)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f5e79a823995ead09dff2606db4b6fa9da704a98" author="Yusuke FUJII">
		<msg>fix segv</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" added_lines="7" deleted_lines="0">
				<diff>@@ -47,6 +47,7 @@ protected:
 
 public:
   virtual void update(void) = 0;
+  virtual void changed(void) = 0;
   virtual void showStateName(void) = 0;
   virtual uint64_t getStateTransMask(void) = 0;
   virtual uint64_t getStateNum(void) = 0;
@@ -83,6 +84,12 @@ public:
       StateUpdateFunc();
   }
 
+  virtual void changed(void)
+  {
+    if (StateChangedFunc)
+	    StateChangedFunc();
+  }
+
   virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f)
   {
     StateUpdateFunc = _f;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" added_lines="5" deleted_lines="1">
				<diff>@@ -92,6 +92,7 @@ public:
   }
 
   void update(void);
+  void changed(uint8_t _kind);
   void stateDecider(void);
 
   bool isState(BaseState *base, uint64_t _state_num);
@@ -106,14 +107,17 @@ public:
   BaseState *getCurrentState(void);
   std::string getCurrentStateName(void);
   std::string getStateName(void);
+  
+  BaseState **getCurrentStateHolderPtr(uint8_t _kind);
   BaseState **getCurrentStateHolderPtr(uint64_t _state_num);
+  BaseState **getCurrentStateHolderPtr(BaseState *_state);
   void showCurrentStateName(void);
   std::string createStateMessageText(void);
 
   uint64_t getStateNum(BaseState *_state);
   uint64_t getStateTransMask(BaseState *_state);
   bool isEmptyMainState(void);
-  bool isDifferentState(BaseState *_state_a, BaseState *_state_b);
+  bool isDifferentState(BaseState *_state_a, BaseState **_state_b);
   uint8_t getStateKind(BaseState *_state);
   bool isMainState(BaseState *_state);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="af9f41f9547c07470c14c9819a1d010fb1966f6c" author="Yamato ANDO">
		<msg>separate executable</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_mapping\ndt_mapping.cpp" added_lines="7" deleted_lines="17">
				<diff>@@ -135,7 +135,6 @@ static double _tf_x, _tf_y, _tf_z, _tf_roll, _tf_pitch, _tf_yaw;
 static Eigen::Matrix4f tf_btol, tf_ltob;
 
 static bool isMapUpdate = true;
-static bool _use_openmp = false;
 static bool _use_imu = false;
 static bool _use_odom = false;
 static bool _imu_upside_down = false;
@@ -243,7 +242,7 @@ static void imu_odom_calc(ros::Time current_time)
   guess_pose_imu_odom.roll  = previous_pose.roll  + offset_imu_odom_roll;
   guess_pose_imu_odom.pitch = previous_pose.pitch + offset_imu_odom_pitch;
   guess_pose_imu_odom.yaw   = previous_pose.yaw   + offset_imu_odom_yaw;
- 
+
   previous_time = current_time;
 }
 
@@ -276,7 +275,7 @@ static void odom_calc(ros::Time current_time)
   guess_pose_odom.roll  = previous_pose.roll  + offset_odom_roll;
   guess_pose_odom.pitch = previous_pose.pitch + offset_odom_pitch;
   guess_pose_odom.yaw   = previous_pose.yaw   + offset_odom_yaw;
- 
+
   previous_time = current_time;
 }
 
@@ -325,7 +324,7 @@ static void imu_calc(ros::Time current_time)
   guess_pose_imu.z     = previous_pose.z     + offset_imu_z;
   guess_pose_imu.roll  = previous_pose.roll  + offset_imu_roll;
   guess_pose_imu.pitch = previous_pose.pitch + offset_imu_pitch;
-  guess_pose_imu.yaw   = previous_pose.yaw   + offset_imu_yaw;  
+  guess_pose_imu.yaw   = previous_pose.yaw   + offset_imu_yaw;
 
   previous_time = current_time;
 }
@@ -492,7 +491,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   voxel_grid_filter.filter(*filtered_scan_ptr);
 
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(map));
-  
+
   ndt.setTransformationEpsilon(trans_eps);
   ndt.setStepSize(step_size);
   ndt.setResolution(ndt_res);
@@ -547,18 +546,11 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
 #ifdef USE_FAST_PCL
-  if (_use_openmp == true)
-  {
     ndt.omp_align(*output_cloud, init_guess);
     fitness_score = ndt.omp_getFitnessScore();
-  }
-  else
-  {
-#endif
+#else
     ndt.align(*output_cloud, init_guess);
     fitness_score = ndt.getFitnessScore();
-#ifdef USE_FAST_PCL
-  }
 #endif
 
   t_localizer = ndt.getFinalTransformation();
@@ -654,7 +646,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   previous_scan_time.sec = current_scan_time.sec;
   previous_scan_time.nsec = current_scan_time.nsec;
-  
+
 
   offset_imu_x = 0.0;
   offset_imu_y = 0.0;
@@ -676,7 +668,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   offset_imu_odom_roll = 0.0;
   offset_imu_odom_pitch = 0.0;
   offset_imu_odom_yaw = 0.0;
-  
+
   // Calculate the shift between added_pos and current_pos
   double shift = sqrt(pow(current_pose.x - added_pose.x, 2.0) + pow(current_pose.y - added_pose.y, 2.0));
   if (shift &gt;= min_add_scan_shift)
@@ -803,13 +795,11 @@ int main(int argc, char** argv)
   ros::NodeHandle private_nh("~");
 
   // setting parameters
-  private_nh.getParam("use_openmp", _use_openmp);
   private_nh.getParam("use_imu", _use_imu);
   private_nh.getParam("use_odom", _use_odom);
   private_nh.getParam("imu_upside_down", _imu_upside_down);
   private_nh.getParam("imu_topic", _imu_topic);
 
-  std::cout &lt;&lt; "use_openmp: " &lt;&lt; _use_openmp &lt;&lt; std::endl;
   std::cout &lt;&lt; "use_imu: " &lt;&lt; _use_imu &lt;&lt; std::endl;
   std::cout &lt;&lt; "imu_upside_down: " &lt;&lt; _imu_upside_down &lt;&lt; std::endl;
   std::cout &lt;&lt; "use_odom: " &lt;&lt; _use_odom &lt;&lt; std::endl;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="12" deleted_lines="26">
				<diff>@@ -95,7 +95,7 @@ static pose initial_pose, predict_pose, predict_pose_imu, predict_pose_odom, pre
     current_gnss_pose;
 
 static double offset_x, offset_y, offset_z, offset_yaw;  // current_pos - previous_pose
-static double offset_imu_x, offset_imu_y, offset_imu_z, offset_imu_roll, offset_imu_pitch, offset_imu_yaw; 
+static double offset_imu_x, offset_imu_y, offset_imu_z, offset_imu_roll, offset_imu_pitch, offset_imu_yaw;
 static double offset_odom_x, offset_odom_y, offset_odom_z, offset_odom_roll, offset_odom_pitch, offset_odom_yaw;
 static double offset_imu_odom_x, offset_imu_odom_y, offset_imu_odom_z, offset_imu_odom_roll, offset_imu_odom_pitch, offset_imu_odom_yaw;
 
@@ -198,7 +198,6 @@ static std::string _offset = "linear";  // linear, zero, quadratic
 static ros::Publisher ndt_reliability_pub;
 static std_msgs::Float32 ndt_reliability;
 
-static bool _use_openmp = false;
 static bool _get_height = false;
 static bool _use_local_transform = false;
 static bool _use_imu = false;
@@ -456,7 +455,7 @@ static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped:
     }
     current_pose.z = nearest_z;
   }
-  
+
   current_pose_imu = current_pose_odom = current_pose_imu_odom = current_pose;
   previous_pose.x = current_pose.x;
   previous_pose.y = current_pose.y;
@@ -521,7 +520,7 @@ static void imu_odom_calc(ros::Time current_time)
   predict_pose_imu_odom.roll  = previous_pose.roll  + offset_imu_odom_roll;
   predict_pose_imu_odom.pitch = previous_pose.pitch + offset_imu_odom_pitch;
   predict_pose_imu_odom.yaw   = previous_pose.yaw   + offset_imu_odom_yaw;
- 
+
   previous_time = current_time;
 }
 
@@ -554,7 +553,7 @@ static void odom_calc(ros::Time current_time)
   predict_pose_odom.roll  = previous_pose.roll  + offset_odom_roll;
   predict_pose_odom.pitch = previous_pose.pitch + offset_odom_pitch;
   predict_pose_odom.yaw   = previous_pose.yaw   + offset_odom_yaw;
- 
+
   previous_time = current_time;
 
 }
@@ -603,7 +602,7 @@ static void imu_calc(ros::Time current_time)
   predict_pose_imu.z     = previous_pose.z     + offset_imu_z;
   predict_pose_imu.roll  = previous_pose.roll  + offset_imu_roll;
   predict_pose_imu.pitch = previous_pose.pitch + offset_imu_pitch;
-  predict_pose_imu.yaw   = previous_pose.yaw   + offset_imu_yaw;  
+  predict_pose_imu.yaw   = previous_pose.yaw   + offset_imu_yaw;
 
   previous_time = current_time;
 }
@@ -763,7 +762,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
       imu_calc(current_scan_time);
     if (_use_imu == false &amp;&amp; _use_odom == true)
       odom_calc(current_scan_time);
-    
+
     pose predict_pose_for_ndt;
     if (_use_imu == true &amp;&amp; _use_odom == true)
       predict_pose_for_ndt = predict_pose_imu_odom;
@@ -784,21 +783,15 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
 
     pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+
 #ifdef USE_FAST_PCL
-    if (_use_openmp == true)
-    {
       align_start = std::chrono::system_clock::now();
       ndt.omp_align(*output_cloud, init_guess);
       align_end = std::chrono::system_clock::now();
-    }
-    else
-    {
-#endif
+#else
       align_start = std::chrono::system_clock::now();
       ndt.align(*output_cloud, init_guess);
       align_end = std::chrono::system_clock::now();
-#ifdef USE_FAST_PCL
-    }
 #endif
 
     align_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(align_end - align_start).count() / 1000.0;
@@ -808,22 +801,17 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     t2 = t * tf_ltob;                  // base_link
 
     iteration = ndt.getFinalNumIteration();
+
 #ifdef USE_FAST_PCL
-    if (_use_openmp == true)
-    {
       getFitnessScore_start = std::chrono::system_clock::now();
       fitness_score = ndt.omp_getFitnessScore();
       getFitnessScore_end = std::chrono::system_clock::now();
-    }
-    else
-    {
-#endif
+#else
       getFitnessScore_start = std::chrono::system_clock::now();
       fitness_score = ndt.getFitnessScore();
       getFitnessScore_end = std::chrono::system_clock::now();
-#ifdef USE_FAST_PCL
-    }
 #endif
+
     getFitnessScore_time =
         std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(getFitnessScore_end - getFitnessScore_start).count() /
         1000.0;
@@ -1206,7 +1194,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
       offset_z = 0.0;
       offset_yaw = 0.0;
     }
-   
+
     offset_imu_x = 0.0;
     offset_imu_y = 0.0;
     offset_imu_z = 0.0;
@@ -1269,7 +1257,6 @@ int main(int argc, char** argv)
   private_nh.getParam("use_gnss", _use_gnss);
   private_nh.getParam("queue_size", _queue_size);
   private_nh.getParam("offset", _offset);
-  private_nh.getParam("use_openmp", _use_openmp);
   private_nh.getParam("get_height", _get_height);
   private_nh.getParam("use_local_transform", _use_local_transform);
   private_nh.getParam("use_imu", _use_imu);
@@ -1318,7 +1305,6 @@ int main(int argc, char** argv)
   std::cout &lt;&lt; "use_gnss: " &lt;&lt; _use_gnss &lt;&lt; std::endl;
   std::cout &lt;&lt; "queue_size: " &lt;&lt; _queue_size &lt;&lt; std::endl;
   std::cout &lt;&lt; "offset: " &lt;&lt; _offset &lt;&lt; std::endl;
-  std::cout &lt;&lt; "use_openmp: " &lt;&lt; _use_openmp &lt;&lt; std::endl;
   std::cout &lt;&lt; "get_height: " &lt;&lt; _get_height &lt;&lt; std::endl;
   std::cout &lt;&lt; "use_local_transform: " &lt;&lt; _use_local_transform &lt;&lt; std::endl;
   std::cout &lt;&lt; "use_imu: " &lt;&lt; _use_imu &lt;&lt; std::endl;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6729e2f7903c9083b180d9f627138878e0cfac13" author="Yusuke FUJII">
		<msg>add support to stopline</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libamathutils\include\amathutils.hpp" new_path="ros\src\computing\planning\decision\libs\libamathutils\include\amathutils.hpp" added_lines="2" deleted_lines="2">
				<diff>@@ -57,7 +57,7 @@ inline double getTimefromAcceleration(double v0, double v, double a)
 bool isIntersectLine(double p1x, double p1y, double p2x, double p2y,
 			double p3x, double p3y, double p4x, double p4y);
 
+int isPointLeftFromLine(double p1x, double p1y, double line_p1x, double line_p1y,
+		double line_p2x, double line_p2y);
 }
- int isPointLeftFromLine(double p1x, double p1y, double line_p1x, double line_p1y,
-		  double line_p2x, double line_p2y);
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="2" deleted_lines="4">
				<diff>@@ -152,10 +152,8 @@ bool StateContext::setEnableForceSetState(bool force_flag)
 
 std::string StateContext::getCurrentStateName(uint8_t _kind)
 {
-	if(_kind&lt;= NULL_STATE){
-		if (*HolderMap[_kind])
-			return (*HolderMap[_kind])-&gt;getStateName();
-	}
+	if (*HolderMap[_kind])
+		return (*HolderMap[_kind])-&gt;getStateName();
 	return std::string("");
 }
 std::string StateContext::getCurrentStateName(void)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="12" deleted_lines="1">
				<diff>@@ -93,6 +93,7 @@ private:
 
   autoware_msgs::LaneArray current_based_lane_array_;
   autoware_msgs::LaneArray current_controlled_lane_array_;
+  autoware_msgs::LaneArray current_stopped_lane_array_;
 
 
   // Current way/behavior status
@@ -154,9 +155,18 @@ private:
 
   void setWaypointState(autoware_msgs::LaneArray &amp;lane_array);
 
-
+  void publishStoppedLaneArray(void);
+  void publishControlledLaneArray(void);
+  void updateLaneWaypointsArray(void);
+  void changeVelocityBasedLane(void);
+  void changeVelocityLane(int dir);
+  
   void updateStateSTR(int status);
   void updateStateStop(int status);
+  void changedStateStop(int status);
+  void changedStateAcc(int status);
+  void changedStateDec(int status);
+  void changedStateKeep(int status);
   void setupStateCallback(void);
   // callback by topic subscribing
   void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
@@ -192,6 +202,7 @@ public:
     this-&gt;initROS(argc, argv);
 
     vector_map_init = false;
+
     vMap_Areas_flag = vMap_Lines_flag = vMap_Points_flag = vMap_CrossRoads_flag = false;
 
     ClosestArea_ = nullptr;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="28" deleted_lines="21">
				<diff>@@ -36,6 +36,7 @@ bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
   _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
   ctx-&gt;setEnableForceSetState(false);
 
+#if 0
   if (ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE) ||
       ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE))
   {
@@ -69,8 +70,8 @@ bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
             lane.waypoints.at(wpi).twist.twist.linear.x + lane.waypoints.at(wpi).twist.twist.linear.x * _weight;
       }
     }
-    Pubs["lane_waypoints_array"].publish(current_controlled_lane_array_);
   }
+#endif
   return _ret;
 }
 
@@ -165,9 +166,8 @@ void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadAr
           if (area.insideLanes.empty() || wp.gid != area.insideLanes.back().waypoints.back().gid + 1)
           {
             autoware_msgs::lane nlane;
-            ;
             area.insideLanes.push_back(nlane);
-          }
+	  }
           area.insideLanes.back().waypoints.push_back(wp);
           area.insideWaypoint_points.push_back(pp);  // geometry_msgs::point
           // area.insideLanes.Waypoints.push_back(wp);//autoware_msgs::waypoint
@@ -190,6 +190,7 @@ geometry_msgs::Point to_geoPoint(const vector_map_msgs::Point &amp;vp)
 
 void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
 {
+  insertPointWithinCrossRoad(intersects, lane_array);
   // STR
   for (auto &amp;area : intersects)
   {
@@ -217,26 +218,24 @@ void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
           }
         }
       }
-      ROS_INFO("%d: %d  angle_deg :%d\n", area.area_id, steering_state, angle_deg);
     }
   }
 
   // STOP
-  std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([](const StopLine &amp;stopline) { return true; });
+  std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([&amp;](const StopLine &amp;stopline) { 
+        return (g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type == (int)vector_map_msgs::RoadSign::TYPE_STOP);});
+  
   for (auto &amp;lane : lane_array.lanes)
   {
     for (size_t wp_idx = 0; wp_idx &lt; lane.waypoints.size() - 1; wp_idx++)
     {
       for (auto &amp;stopline : stoplines)
       {
-        if (g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type == vector_map_msgs::RoadSign::TYPE_STOP)
-        {
           geometry_msgs::Point bp =
               to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).bpid)));
           geometry_msgs::Point fp =
               to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).fpid)));
 	 
-
           if (amathutils::isIntersectLine(lane.waypoints.at(wp_idx).pose.pose.position.x,
                                           lane.waypoints.at(wp_idx).pose.pose.position.y,
                                           lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
@@ -245,24 +244,28 @@ void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
 	    geometry_msgs::Point center_point;
 	    center_point.x = (bp.x*2 + fp.x)/3;
 	    center_point.y = (bp.y*2 + fp.y)/3;
-
-	    if(isPointLeftFromLine){
+	    if(amathutils::isPointLeftFromLine( 
+				          center_point.x,
+					  center_point.y,
+           			          lane.waypoints.at(wp_idx).pose.pose.position.x,
+                                          lane.waypoints.at(wp_idx).pose.pose.position.y,
+                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
+                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.y)){
 		    lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
-		    lane.waypoints.at(wp_idx + 1).wpstate.stopline_state = 1;
+		    //lane.waypoints.at(wp_idx + 1).wpstate.stopline_state = 1;
 	    }
-
 	  }
-	}
       }
     }
   }
+
 }
 
 // for based waypoint
 void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg)
 {
+  ROS_INFO("[%s]:LoadedWaypointLaneArray\n", __func__);
   current_based_lane_array_ = msg;  // cached based path
-
   // indexing
   for (auto &amp;lane : current_based_lane_array_.lanes)
   {
@@ -280,12 +283,11 @@ void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray
       wp.wpstate.event_state = 0;
     }
   }
-
+  setWaypointState(current_based_lane_array_);
   current_controlled_lane_array_ = current_based_lane_array_;  // controlled path
-  insertPointWithinCrossRoad(intersects, current_controlled_lane_array_);
-  setWaypointState(current_controlled_lane_array_);
 
-  Pubs["lane_waypoints_array"].publish(current_controlled_lane_array_);
+  publishControlledLaneArray();
+  updateLaneWaypointsArray();
 }
 
 state_machine::StateFlags getStateFlags(uint8_t msg_state)
@@ -315,9 +317,14 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
   current_finalwaypoints_ = msg;
 
   // steering
-  if (current_finalwaypoints_.waypoints.size() &gt; param_target_waypoint_)
-    ctx-&gt;setCurrentState(
-        getStateFlags(current_finalwaypoints_.waypoints.at(param_target_waypoint_).wpstate.steering_state));
+  size_t idx = current_finalwaypoints_.waypoints.size()-1 &gt; param_target_waypoint_?
+	  param_target_waypoint_ : current_finalwaypoints_.waypoints.size()-1; 
+  if(idx){
+	  ctx-&gt;setCurrentState(
+			  getStateFlags(current_finalwaypoints_.waypoints.at(idx).wpstate.steering_state));
+	  if(current_finalwaypoints_.waypoints.at(idx).wpstate.stopline_state)
+		  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOP_STATE);
+  }
 
 #if 0
 	// velocity
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="11" deleted_lines="10">
				<diff>@@ -94,11 +94,11 @@ void DecisionMakerNode::initROS(int argc, char **argv)
 
   // to move initial state from start state
   // this part confirm broadcasting tf(map to world)
-  std::cout &lt;&lt; "wait for tf of map to world" &lt;&lt; std::endl;
-  tf::TransformListener tf;
-  tf.waitForTransform("map", "world", ros::Time(), ros::Duration(15));
-  if (!ctx-&gt;TFInitialized())
-	  std::cerr &lt;&lt; "failed initialization " &lt;&lt; std::endl;
+ // std::cout &lt;&lt; "wait for tf of map to world" &lt;&lt; std::endl;
+ // tf::TransformListener tf;
+ // tf.waitForTransform("map", "world", ros::Time(), ros::Duration(15));
+ // if (!ctx-&gt;TFInitialized())
+ //	  std::cerr &lt;&lt; "failed initialization " &lt;&lt; std::endl;
   g_vmap.subscribe(nh_, 
 		  Category::POINT |  Category::LINE |  Category::VECTOR | Category::AREA | Category::POLE | //basic class
 		  Category::DTLANE | Category::STOP_LINE | Category::ROAD_SIGN | Category::CROSS_ROAD);
@@ -108,14 +108,17 @@ void DecisionMakerNode::initROS(int argc, char **argv)
     if (enableDisplayMarker)
       displayMarker();
   }
+
+  ROS_INFO("Initialized OUT\n");
+  Subs["lane_waypoints_array"] =
+	  nh_.subscribe(TPNAME_BASED_LANE_WAYPOINTS_ARRAY, 100, &amp;DecisionMakerNode::callbackFromLaneWaypoint, this);
 }
 
 void DecisionMakerNode::initVectorMap(void)
 {
       int _index = 0;
-      if(vector_map_init)
-	      return;
-
+      //if(vector_map_init)
+	//      return;
       std::vector&lt;CrossRoad&gt; crossroads = g_vmap.findByFilter([](const CrossRoad &amp;crossroad){return true;});
       if(crossroads.empty()){
 	      ROS_INFO("crossroad have not found\n");
@@ -175,8 +178,6 @@ void DecisionMakerNode::initVectorMap(void)
 	intersects.push_back(carea);
       }
 
-      Subs["lane_waypoints_array"] =
-	      nh_.subscribe(TPNAME_BASED_LANE_WAYPOINTS_ARRAY, 100, &amp;DecisionMakerNode::callbackFromLaneWaypoint, this);
 }
 
 bool DecisionMakerNode::initVectorMapClient()
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="5" deleted_lines="5">
				<diff>@@ -112,13 +112,13 @@ void DecisionMakerNode::update_msgs(void)
     state_text_msg.text = createStateMessageText();
 
     autoware_msgs::state state_msg;
-    state_msg.main_state = ctx-&gt;getCurrentStateName(state_machine::StateKinds::MAIN_STATE);
-    state_msg.acc_state = ctx-&gt;getCurrentStateName(state_machine::StateKinds::ACC_STATE);
-    state_msg.str_state = ctx-&gt;getCurrentStateName(state_machine::StateKinds::STR_STATE);
-    state_msg.behavior_state = ctx-&gt;getCurrentStateName(state_machine::StateKinds::BEHAVIOR_STATE);
+    state_msg.main_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::MAIN_STATE);
+    state_msg.acc_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::ACC_STATE);
+    state_msg.str_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::STR_STATE);
+    state_msg.behavior_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::BEHAVIOR_STATE);
     
     Pubs["states"].publish(state_msg);
-    Pubs["state"].publish(state_string_msg);
+    //Pubs["state"].publish(state_string_msg);
     Pubs["state_overlay"].publish(state_text_msg);
   }
   else
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="83" deleted_lines="3">
				<diff>@@ -21,17 +21,97 @@ void DecisionMakerNode::setupStateCallback(void)
   ctx-&gt;getStateObject(state_machine::DRIVE_ACC_STOP_STATE)
        -&gt;setUpdateFunc(std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
   ctx-&gt;getStateObject(state_machine::DRIVE_ACC_STOP_STATE)
-       -&gt;setUpdateFunc(std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
+       -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateStop, this, 1));
+  
+  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_KEEP_STATE)
+       -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateKeep, this, 1));
+  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_ACCELERATION_STATE)
+       -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateAcc, this, 1));
+  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_DECELERATION_STATE)
+       -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateAcc, this, -1));
+}
+
+
+void DecisionMakerNode::updateLaneWaypointsArray(void)
+{
+	current_stopped_lane_array_ = current_controlled_lane_array_;
+	for(auto &amp;lane : current_stopped_lane_array_.lanes)
+		for(auto &amp;wp: lane.waypoints){
+			wp.twist.twist.linear.x = 0.0;
+			wp.wpstate.stopline_state = 0;
+		}
+
+}
+
+void DecisionMakerNode::publishControlledLaneArray(void)
+{
+  Pubs["lane_waypoints_array"].publish(current_controlled_lane_array_);
+}
+void DecisionMakerNode::publishStoppedLaneArray(void)
+{
+  updateLaneWaypointsArray();
+  Pubs["lane_waypoints_array"].publish(current_stopped_lane_array_);
 }
 
-void DecisionMakerNode::updateStateStop(int status){
+void DecisionMakerNode::changeVelocityBasedLane(void)
+{
+	current_controlled_lane_array_ = current_based_lane_array_;
+}
 
+void DecisionMakerNode::changeVelocityLane(int dir)
+{
+	for (auto &amp;lane : current_controlled_lane_array_.lanes)
+	{
+		autoware_msgs::lane temp_lane = lane;
+		for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
+		{
+			double v0 = temp_lane.waypoints.at(wpi - 1).twist.twist.linear.x;
+			double v = temp_lane.waypoints.at(wpi).twist.twist.linear.x;
 
+			amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
+					temp_lane.waypoints.at(wpi).pose.pose.position.y,
+					temp_lane.waypoints.at(wpi).pose.pose.position.z);
+			amathutils::point p1(temp_lane.waypoints.at(wpi - 1).pose.pose.position.x,
+					temp_lane.waypoints.at(wpi - 1).pose.pose.position.y,
+					temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);
+
+			double distance = amathutils::find_distance(&amp;p0, &amp;p1);
+			double _weight = distance * 0.05 * dir;
+			lane.waypoints.at(wpi).twist.twist.linear.x =
+				lane.waypoints.at(wpi).twist.twist.linear.x + lane.waypoints.at(wpi).twist.twist.linear.x * _weight;
+		}
+	}
+}
+
+void DecisionMakerNode::changedStateKeep(int status)
+{
+	changeVelocityBasedLane();
+	publishControlledLaneArray();
+}
+
+void DecisionMakerNode::changedStateAcc(int status)
+{
+	changeVelocityLane(status);
+	publishControlledLaneArray();
+}
+void DecisionMakerNode::updateStateStop(int status)
+{
+	static ros::Timer stopping_timer;
+	static bool timerflag = false;
+	if(current_velocity_ == 0.0 &amp;&amp; !timerflag){
+		stopping_timer = nh_.createTimer(ros::Duration(1), [&amp;](const ros::TimerEvent&amp;){ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE); ROS_INFO("Change state to keep from stop\n");timerflag=false; }, this, true);
+		timerflag = true;
+	}
+
+}
+
+void DecisionMakerNode::changedStateStop(int status)
+{
+	publishStoppedLaneArray();
 }
 
 void DecisionMakerNode::updateStateSTR(int status)
 {
-  ROS_INFO("[%s]:%d\n", __func__, status);
   autoware_msgs::lamp_cmd lamp_msg;
 
   switch(status){
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b446f05c33d111b4d4f41245dc39ae132e9f8fe8" author="Yusuke FUJII">
		<msg>Fix a state changing bug</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="17" deleted_lines="16">
				<diff>@@ -36,7 +36,7 @@ void StateContext::update(void)
 
 void StateContext::changed(uint8_t _kind)
 {
-	if(_kind &gt;  NULL_STATE){
+	if(_kind &gt;  UNKNOWN_STATE){
 		return;
 	}
 
@@ -77,7 +77,7 @@ uint8_t StateContext::getStateKind(BaseState *_state)
   if (_state)
     return _state-&gt;getStateKind();
   else
-    return NULL_STATE;
+    return UNKNOWN_STATE;
 }
 
 uint64_t StateContext::getStateTransMask(BaseState *_state)
@@ -156,6 +156,7 @@ std::string StateContext::getCurrentStateName(uint8_t _kind)
 		return (*HolderMap[_kind])-&gt;getStateName();
 	return std::string("");
 }
+
 std::string StateContext::getCurrentStateName(void)
 {
   return this-&gt;getCurrentStateName(MAIN_STATE);
@@ -172,12 +173,13 @@ BaseState *StateContext::getStateObject(uint64_t _state_num)
 }
 
 
+
 BaseState **StateContext::getCurrentStateHolderPtr(uint8_t _kind)
 {
-	if(_kind &gt;  NULL_STATE){
+	if(_kind &gt;  UNKNOWN_STATE){
 		return nullptr;
 	}
-  return HolderMap[_kind];
+	return HolderMap[_kind];
 }
 
 BaseState **StateContext::getCurrentStateHolderPtr(uint64_t _state_num)
@@ -195,22 +197,21 @@ BaseState **StateContext::getCurrentStateHolderPtr(BaseState *_state)
 
 bool StateContext::disableCurrentState(uint64_t _state_num)
 {
-  BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
-  if (state_ptr &amp;&amp; this-&gt;isState((*state_ptr), _state_num))
-  {
-    *state_ptr = nullptr;
-    return true;
-  }
-  else
-  {
-    return false;
-  }
+	if(isMainState(getStateObject(_state_num))){
+		return false;
+	}
+	if(isCurrentState(_state_num)){
+		(*getCurrentStateHolderPtr(_state_num)) = nullptr;
+		return true;
+	}else{
+		return false;
+	}
 }
 
 bool StateContext::isCurrentState(uint64_t _state_num)
 {
-  BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
-  return (*state_ptr) ? (*state_ptr)-&gt;getStateNum() &amp; _state_num ? true : false : false;
+	  BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
+	  return  (state_ptr) ?isState(*state_ptr, _state_num):false;
 }
 
 bool StateContext::isState(BaseState *base, uint64_t _state_num)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="1" deleted_lines="61">
				<diff>@@ -35,43 +35,6 @@ bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
   ctx-&gt;setEnableForceSetState(true);
   _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
   ctx-&gt;setEnableForceSetState(false);
-
-#if 0
-  if (ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE) ||
-      ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE))
-  {
-    int count = 0;
-    for (auto &amp;lane : current_controlled_lane_array_.lanes)
-    {
-      autoware_msgs::lane temp_lane = lane;
-      for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
-      {
-        double v0 = temp_lane.waypoints.at(wpi - 1).twist.twist.linear.x;
-        double v = temp_lane.waypoints.at(wpi).twist.twist.linear.x;
-
-        amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
-                             temp_lane.waypoints.at(wpi).pose.pose.position.y,
-                             temp_lane.waypoints.at(wpi).pose.pose.position.z);
-        amathutils::point p1(temp_lane.waypoints.at(wpi - 1).pose.pose.position.x,
-                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.y,
-                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);
-
-        double distance = amathutils::find_distance(&amp;p0, &amp;p1);
-        double _weight = distance * 0.05;
-        if (ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE))
-        {
-          _weight *= 1;
-        }
-        else if (ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE))
-        {
-          _weight *= -1;
-        }
-        lane.waypoints.at(wpi).twist.twist.linear.x =
-            lane.waypoints.at(wpi).twist.twist.linear.x + lane.waypoints.at(wpi).twist.twist.linear.x * _weight;
-      }
-    }
-  }
-#endif
   return _ret;
 }
 
@@ -96,6 +59,7 @@ void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
     ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
   else
   {
+	  fprintf(stderr,"disable lanechange\n");
     ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
     ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
   }
@@ -136,10 +100,8 @@ void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_
   {
     ctx-&gt;disableCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
   }
-  // ctx-&gt;handleTrafficLight(CurrentTrafficlight);
 }
 
-//
 void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
 {
   if (ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
@@ -326,23 +288,6 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
 		  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOP_STATE);
   }
 
-#if 0
-	// velocity
-	double _temp_sum = 0;
-	for (int i = 0; i &lt; VEL_AVERAGE_COUNT; i++)
-	{
-		_temp_sum += amathutils::mps2kmph(msg.waypoints[i].twist.twist.linear.x);
-	}
-	average_velocity_ = _temp_sum / VEL_AVERAGE_COUNT;
-
-	if (std::fabs(average_velocity_ - current_velocity_) &lt;= 2.0)
-		ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE);
-	else if (average_velocity_ - current_velocity_)
-		ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE);
-	else
-		ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE);
-#endif
-
   // for publish plan of velocity
   publishToVelocityArray();
 
@@ -389,9 +334,4 @@ void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistSt
 {
   current_velocity_ = amathutils::mps2kmph(msg.twist.linear.x);
 }
-#if 0
-void DecisionMakerNode::callbackFromDynamicReconfigure(decision_maker::decision_makerConfig &amp;config, uint32_t level){
-	ROS_INFO("Reconfigure Request: %d ", config.TARGET_WAYPOINT_COUNT);
-}
-#endif
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -56,7 +56,7 @@ void DecisionMakerNode::update(void)
 
 void DecisionMakerNode::run(void)
 {
-  ros::Rate loop_rate(6);
+  ros::Rate loop_rate(1);
 
   // for subscribe callback function
   ros::AsyncSpinner spinner(1);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="0" deleted_lines="17">
				<diff>@@ -45,16 +45,6 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   Subs["change_flag"] = nh_.subscribe("change_flag", 1, &amp;DecisionMakerNode::callbackFromLaneChangeFlag, this);
   Subs["state_cmd"] = nh_.subscribe("state_cmd", 1, &amp;DecisionMakerNode::callbackFromStateCmd, this);
 
-//  // vector map subscriber
-//  Subs["vector_map_area"] =
-//      nh_.subscribe("/vector_map_info/area", 1, &amp;DecisionMakerNode::callbackFromVectorMapArea, this);
-//  Subs["vector_map_point"] =
-//      nh_.subscribe("/vector_map_info/point", 1, &amp;DecisionMakerNode::callbackFromVectorMapPoint, this);
-//  Subs["vector_map_line"] =
-//      nh_.subscribe("/vector_map_info/line", 1, &amp;DecisionMakerNode::callbackFromVectorMapLine, this);
-//  Subs["vector_map_crossroad"] =
-//      nh_.subscribe("/vector_map_info/cross_road", 1, &amp;DecisionMakerNode::callbackFromVectorMapCrossRoad, this);
-//
   // Config subscriber
   Subs["config/decision_maker"] =
       nh_.subscribe("/config/decision_maker", 3, &amp;DecisionMakerNode::callbackFromConfig, this);
@@ -92,13 +82,6 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   // setup a callback for state update();
   setupStateCallback();
 
-  // to move initial state from start state
-  // this part confirm broadcasting tf(map to world)
- // std::cout &lt;&lt; "wait for tf of map to world" &lt;&lt; std::endl;
- // tf::TransformListener tf;
- // tf.waitForTransform("map", "world", ros::Time(), ros::Duration(15));
- // if (!ctx-&gt;TFInitialized())
- //	  std::cerr &lt;&lt; "failed initialization " &lt;&lt; std::endl;
   g_vmap.subscribe(nh_, 
 		  Category::POINT |  Category::LINE |  Category::VECTOR | Category::AREA | Category::POLE | //basic class
 		  Category::DTLANE | Category::STOP_LINE | Category::ROAD_SIGN | Category::CROSS_ROAD);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="9" deleted_lines="2">
				<diff>@@ -108,8 +108,6 @@ void DecisionMakerNode::update_msgs(void)
       update_pubsub();
     }
 
-    state_string_msg.data = CurrentStateName;
-    state_text_msg.text = createStateMessageText();
 
     autoware_msgs::state state_msg;
     state_msg.main_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::MAIN_STATE);
@@ -117,6 +115,15 @@ void DecisionMakerNode::update_msgs(void)
     state_msg.str_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::STR_STATE);
     state_msg.behavior_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::BEHAVIOR_STATE);
     
+    state_string_msg.data = CurrentStateName;
+    //state_text_msg.text = createStateMessageText();
+    state_text_msg.text = state_msg.main_state + "\n"
+	    		 + state_msg.acc_state + "\n"
+	    		 + state_msg.str_state + "\n"
+	    		 + state_msg.behavior_state + "\n";
+
+    
+
     Pubs["states"].publish(state_msg);
     //Pubs["state"].publish(state_string_msg);
     Pubs["state_overlay"].publish(state_text_msg);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="cca1b6a8f9bad3954cab4bd7eb3b5cc50b09569e" author="Yusuke FUJII">
		<msg>fix a judge left/right</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="20" deleted_lines="12">
				<diff>@@ -170,19 +170,20 @@ void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
       else
         steering_state = autoware_msgs::WaypointState::STR_STRAIGHT;
 
-      for (auto &amp;lane : lane_array.lanes)
+      for (auto &amp;wp_lane : laneinArea.waypoints)
       {
-        for (auto &amp;wp : lane.waypoints)
-        {
-          if (area.area_id == wp.wpstate.aid)
-          {
-            wp.wpstate.steering_state = steering_state;
-          }
-        }
+	      for (auto &amp;lane : lane_array.lanes)
+	      {
+		      for(auto &amp;wp : lane.waypoints){
+			      if(wp.gid == wp_lane.gid &amp;&amp; wp.wpstate.aid == area.area_id){
+				      wp.wpstate.steering_state = steering_state;
+			      }
+		      }
+		      //lane.waypoints.at(wp_lane.lid).wpstate.steering_state = steering_state;
+	      }
       }
     }
   }
-
   // STOP
   std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([&amp;](const StopLine &amp;stopline) { 
         return (g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type == (int)vector_map_msgs::RoadSign::TYPE_STOP);});
@@ -229,12 +230,12 @@ void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray
   ROS_INFO("[%s]:LoadedWaypointLaneArray\n", __func__);
   current_based_lane_array_ = msg;  // cached based path
   // indexing
+  int gid = 0;
   for (auto &amp;lane : current_based_lane_array_.lanes)
   {
-    int gid = 0;
+    int lid = 0;
     for (auto &amp;wp : lane.waypoints)
     {
-      int lid = 0;
       wp.gid = gid++;
       wp.lid = lid++;
       wp.wpstate.aid = 0;
@@ -282,8 +283,15 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
   size_t idx = current_finalwaypoints_.waypoints.size()-1 &gt; param_target_waypoint_?
 	  param_target_waypoint_ : current_finalwaypoints_.waypoints.size()-1; 
   if(idx){
-	  ctx-&gt;setCurrentState(
+	  if(isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE)){
+		  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
+	  }
+	  if(isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE)){
+		  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
+	  }else{ 
+		  ctx-&gt;setCurrentState(
 			  getStateFlags(current_finalwaypoints_.waypoints.at(idx).wpstate.steering_state));
+	  }
 	  if(current_finalwaypoints_.waypoints.at(idx).wpstate.stopline_state)
 		  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOP_STATE);
   }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="24" deleted_lines="9">
				<diff>@@ -55,10 +55,10 @@ void DecisionMakerNode::displayMarker(void)
   // vector_map init
   // parse vectormap
   jsk_recognition_msgs::BoundingBoxArray bbox_array;
-
-  static visualization_msgs::MarkerArray marker_array;
-  static visualization_msgs::Marker crossroad_marker;
-  static visualization_msgs::Marker inside_marker;
+  visualization_msgs::MarkerArray marker_array;
+  visualization_msgs::Marker crossroad_marker;
+  visualization_msgs::Marker inside_marker;
+  visualization_msgs::Marker inside_line_marker;
 
   double scale = 3.0;
   createCrossRoadAreaMarker(crossroad_marker, scale);
@@ -75,8 +75,10 @@ void DecisionMakerNode::displayMarker(void)
   inside_marker.lifetime = ros::Duration();
 
   bbox_array.header = crossroad_marker.header;
-
   inside_marker.points.clear();
+  
+  inside_line_marker = inside_marker;
+  inside_line_marker.type = visualization_msgs::Marker::LINE_STRIP;
 
   for (auto &amp;area : intersects)
   {
@@ -86,13 +88,26 @@ void DecisionMakerNode::displayMarker(void)
     {
       inside_marker.points.push_back(p);
     }
-  }
 
+    for (const auto &amp;lane : area.insideLanes)
+    {
+	    inside_line_marker.points.clear();
+	    inside_line_marker.id +=1;
+	    int id = inside_line_marker.id;
+	    inside_line_marker.color.r = std::fmod(0.12345 * (id), 1.0);
+	    inside_line_marker.color.g = std::fmod(0.32345 * (5 - (id%5)), 1.0);
+	    inside_line_marker.color.b = std::fmod(0.52345 * (10- (id % 10)), 1.0);
+	    for(const auto &amp;wp : lane.waypoints){
+		    inside_line_marker.points.push_back(wp.pose.pose.position);
+	    } 
+	    marker_array.markers.push_back(inside_line_marker);
+    }
+  }
   Pubs["crossroad_bbox"].publish(bbox_array);
+  Pubs["crossroad_marker"].publish(marker_array);
   bbox_array.boxes.clear();
-  Pubs["crossroad_inside_marker"].publish(inside_marker);
-
-  marker_array.markers.clear();
+  //Pubs["crossroad_inside_marker"].publish(inside_marker);
+  Pubs["crossroad_inside_marker"].publish(inside_line_marker);
 }
 
 void DecisionMakerNode::update_msgs(void)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="be16dc58cd6ef7fdbe2601bd009598b26905cbae" author="Yusuke FUJII">
		<msg>fix a segv bug when currentpose was changed a lot</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="17" deleted_lines="10">
				<diff>@@ -170,16 +170,23 @@ void LaneSelectNode::processing()
 
   if (current_state_ == "LANE_CHANGE")
   {
-    changeLane();
-    std::get&lt;1&gt;(lane_for_change_) =
-        getClosestWaypointNumber(std::get&lt;0&gt;(lane_for_change_), current_pose_.pose, current_velocity_.twist,
-                                 std::get&lt;1&gt;(lane_for_change_), distance_threshold_);
-    std::get&lt;2&gt;(lane_for_change_) =
-        static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(lane_for_change_).waypoints.at(std::get&lt;1&gt;(lane_for_change_)).change_flag);
-    ROS_INFO("closest: %d", std::get&lt;1&gt;(lane_for_change_));
-    publishLane(std::get&lt;0&gt;(lane_for_change_));
-    publishClosestWaypoint(std::get&lt;1&gt;(lane_for_change_));
-    publishChangeFlag(std::get&lt;2&gt;(lane_for_change_));
+    try
+    {
+	    changeLane();
+	    std::get&lt;1&gt;(lane_for_change_) =
+		    getClosestWaypointNumber(std::get&lt;0&gt;(lane_for_change_), current_pose_.pose, current_velocity_.twist,
+				    std::get&lt;1&gt;(lane_for_change_), distance_threshold_);
+	    std::get&lt;2&gt;(lane_for_change_) =
+		    static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(lane_for_change_).waypoints.at(std::get&lt;1&gt;(lane_for_change_)).change_flag);
+	    ROS_INFO("closest: %d", std::get&lt;1&gt;(lane_for_change_));
+	    publishLane(std::get&lt;0&gt;(lane_for_change_));
+	    publishClosestWaypoint(std::get&lt;1&gt;(lane_for_change_));
+	    publishChangeFlag(std::get&lt;2&gt;(lane_for_change_));
+    }
+    catch (std::out_of_range)
+    {
+      ROS_WARN("Failed to get closest waypoint num\n");
+    }
   }
   else
   {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1296beaa0319114c3ebdc8e4fecd13fea2aaeb34" author="Abraham Monrroy">
		<msg>Fixed mirrored images on Ladybug camera (#906)</msg>
		<modified_files>
			<file old_path="ros\src\sensing\drivers\camera\packages\pointgrey\nodes\ladybug\ladybug.cpp" new_path="ros\src\sensing\drivers\camera\packages\pointgrey\nodes\ladybug\ladybug.cpp" added_lines="1" deleted_lines="0">
				<diff>@@ -363,6 +363,7 @@ int main (int argc, char **argv)
 			cv::resize(image,image,cv::Size(size.width*image_scale/100, size.height*image_scale/100));
 			//
 			cv::transpose(image, image);
+			cv::flip(image, image, 1);
 
 			if (i==0)
 				image.copyTo(full_size);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="870579a525431b9d33f09934c06f229cfb6d6061" author="Yusuke FUJII">
		<msg>apply clang-format</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.cpp" added_lines="6" deleted_lines="6">
				<diff>@@ -51,8 +51,8 @@ void getPointAndVectorFromPose(const geometry_msgs::Pose &amp;pose, Element2D *point
 }
 
 std::vector&lt;autoware_msgs::waypoint&gt; generateHermiteCurveForROS(const geometry_msgs::Pose &amp;start,
-                                                                    const geometry_msgs::Pose &amp;end,
-                                                                    const double velocity_mps, const double vlength)
+                                                                const geometry_msgs::Pose &amp;end,
+                                                                const double velocity_mps, const double vlength)
 {
   std::vector&lt;autoware_msgs::waypoint&gt; wps;
   Element2D p0(0, 0), v0(0, 0), p1(0, 0), v1(0, 0);
@@ -70,10 +70,10 @@ std::vector&lt;autoware_msgs::waypoint&gt; generateHermiteCurveForROS(const geometry_m
     wp.twist.twist.linear.x = velocity_mps;
 
     // height
-    wp.pose.pose.position.z = (i == 0) ? start.position.z : (i == result.size() - 1)
-                                       ? end.position.z : start.position.z &lt; end.position.z
-                                       ? start.position.z + height_d * i / result.size()
-                                       : start.position.z - height_d * i / result.size();
+    wp.pose.pose.position.z =
+        (i == 0) ? start.position.z : (i == result.size() - 1) ? end.position.z : start.position.z &lt; end.position.z ?
+                                                                 start.position.z + height_d * i / result.size() :
+                                                                 start.position.z - height_d * i / result.size();
 
     // orientation
     if (i != result.size() - 1)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\hermite_curve.h" added_lines="5" deleted_lines="5">
				<diff>@@ -33,15 +33,15 @@
 #define HERMITE_CURVE_H
 
 // C++ includes
-#include &lt;iostream&gt;
-#include &lt;vector&gt;
 #include &lt;cmath&gt;
 #include &lt;cstdio&gt;
+#include &lt;iostream&gt;
+#include &lt;vector&gt;
 
 // ROS includes
+#include &lt;geometry_msgs/Pose.h&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;tf/transform_datatypes.h&gt;
-#include &lt;geometry_msgs/Pose.h&gt;
 
 #include "autoware_msgs/waypoint.h"
 
@@ -66,8 +66,8 @@ struct Element2D
 std::vector&lt;Element2D&gt; generateHermiteCurve(const Element2D &amp;p0, const Element2D &amp;v0, const Element2D &amp;p1,
                                             const Element2D &amp;v1, const double vlength = 20);
 std::vector&lt;autoware_msgs::waypoint&gt; generateHermiteCurveForROS(const geometry_msgs::Pose &amp;start,
-                                                                    const geometry_msgs::Pose &amp;end,
-                                                                    const double velocity, const double vlength);
+                                                                const geometry_msgs::Pose &amp;end, const double velocity,
+                                                                const double vlength);
 void createVectorFromPose(const geometry_msgs::Pose &amp;p, tf::Vector3 *v);
 }  // namespace
 #endif  // HERMITE_CURVE_H
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="67" deleted_lines="63">
				<diff>@@ -69,19 +69,21 @@ void LaneSelectNode::initForROS()
   sub5_ = nh_.subscribe("/config/lane_select", 1, &amp;LaneSelectNode::callbackFromConfig, this);
   sub6_ = nh_.subscribe("/decisionmaker/states", 1, &amp;LaneSelectNode::callbackFromStates, this);
 
-  
   bool enablePlannerDynamicSwitch;
   private_nh_.param&lt;bool&gt;("enablePlannerDynamicSwitch", enablePlannerDynamicSwitch, false);
   // setup publisher
-  
+
   pub1_ = nh_.advertise&lt;autoware_msgs::lane&gt;("base_waypoints", 1);
-  
-  if(enablePlannerDynamicSwitch){
-	  pub2_ = nh_.advertise&lt;std_msgs::Int32&gt;("/astar/closest_waypoint", 1);
-  }else{
-	  pub2_ = nh_.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 1);
+
+  if (enablePlannerDynamicSwitch)
+  {
+    pub2_ = nh_.advertise&lt;std_msgs::Int32&gt;("/astar/closest_waypoint", 1);
   }
-  
+  else
+  {
+    pub2_ = nh_.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 1);
+  }
+
   pub3_ = nh_.advertise&lt;std_msgs::Int32&gt;("change_flag", 1);
   vis_pub1_ = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("lane_select_marker", 1);
 
@@ -102,7 +104,7 @@ bool LaneSelectNode::isAllTopicsSubscribed()
 
 void LaneSelectNode::initForLaneSelect()
 {
-  if(!isAllTopicsSubscribed())
+  if (!isAllTopicsSubscribed())
     return;
 
   // search closest waypoint number for each lanes
@@ -144,7 +146,7 @@ void LaneSelectNode::resetSubscriptionFlag()
 
 void LaneSelectNode::processing()
 {
-  if(!isAllTopicsSubscribed())
+  if (!isAllTopicsSubscribed())
     return;
 
   // search closest waypoint number for each lanes
@@ -172,16 +174,16 @@ void LaneSelectNode::processing()
   {
     try
     {
-	    changeLane();
-	    std::get&lt;1&gt;(lane_for_change_) =
-		    getClosestWaypointNumber(std::get&lt;0&gt;(lane_for_change_), current_pose_.pose, current_velocity_.twist,
-				    std::get&lt;1&gt;(lane_for_change_), distance_threshold_);
-	    std::get&lt;2&gt;(lane_for_change_) =
-		    static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(lane_for_change_).waypoints.at(std::get&lt;1&gt;(lane_for_change_)).change_flag);
-	    ROS_INFO("closest: %d", std::get&lt;1&gt;(lane_for_change_));
-	    publishLane(std::get&lt;0&gt;(lane_for_change_));
-	    publishClosestWaypoint(std::get&lt;1&gt;(lane_for_change_));
-	    publishChangeFlag(std::get&lt;2&gt;(lane_for_change_));
+      changeLane();
+      std::get&lt;1&gt;(lane_for_change_) =
+          getClosestWaypointNumber(std::get&lt;0&gt;(lane_for_change_), current_pose_.pose, current_velocity_.twist,
+                                   std::get&lt;1&gt;(lane_for_change_), distance_threshold_);
+      std::get&lt;2&gt;(lane_for_change_) = static_cast&lt;ChangeFlag&gt;(
+          std::get&lt;0&gt;(lane_for_change_).waypoints.at(std::get&lt;1&gt;(lane_for_change_)).change_flag);
+      ROS_INFO("closest: %d", std::get&lt;1&gt;(lane_for_change_));
+      publishLane(std::get&lt;0&gt;(lane_for_change_));
+      publishClosestWaypoint(std::get&lt;1&gt;(lane_for_change_));
+      publishChangeFlag(std::get&lt;2&gt;(lane_for_change_));
     }
     catch (std::out_of_range)
     {
@@ -201,13 +203,13 @@ void LaneSelectNode::processing()
   resetSubscriptionFlag();
 }
 
-int32_t LaneSelectNode::getClosestLaneChangeWaypointNumber(const std::vector&lt;autoware_msgs::waypoint&gt; &amp;wps, int32_t cl_wp)
+int32_t LaneSelectNode::getClosestLaneChangeWaypointNumber(const std::vector&lt;autoware_msgs::waypoint&gt; &amp;wps,
+                                                           int32_t cl_wp)
 {
-
   for (uint32_t i = cl_wp; i &lt; wps.size(); i++)
   {
     if (static_cast&lt;ChangeFlag&gt;(wps.at(i).change_flag) == ChangeFlag::right ||
-      static_cast&lt;ChangeFlag&gt;(wps.at(i).change_flag) == ChangeFlag::left)
+        static_cast&lt;ChangeFlag&gt;(wps.at(i).change_flag) == ChangeFlag::left)
     {
       return i;
     }
@@ -243,18 +245,18 @@ void LaneSelectNode::createLaneForChange()
 
   double dt = getTwoDimensionalDistance(cur_lane.waypoints.at(num_lane_change).pose.pose.position,
                                         cur_lane.waypoints.at(clst_wp).pose.pose.position);
-  double dt_by_vel = current_velocity_.twist.linear.x * lane_change_target_ratio_ &gt; lane_change_target_minimum_
-                         ? current_velocity_.twist.linear.x * lane_change_target_ratio_
-                         : lane_change_target_minimum_;
+  double dt_by_vel = current_velocity_.twist.linear.x * lane_change_target_ratio_ &gt; lane_change_target_minimum_ ?
+                         current_velocity_.twist.linear.x * lane_change_target_ratio_ :
+                         lane_change_target_minimum_;
   ROS_INFO("dt : %lf, dt_by_vel : %lf", dt, dt_by_vel);
   autoware_msgs::lane &amp;nghbr_lane =
-      static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right
-          ? std::get&lt;0&gt;(tuple_vec_.at(right_lane_idx_))
-          : std::get&lt;0&gt;(tuple_vec_.at(left_lane_idx_));
+      static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right ?
+          std::get&lt;0&gt;(tuple_vec_.at(right_lane_idx_)) :
+          std::get&lt;0&gt;(tuple_vec_.at(left_lane_idx_));
   const int32_t &amp;nghbr_clst_wp =
-      static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right
-          ? std::get&lt;1&gt;(tuple_vec_.at(right_lane_idx_))
-          : std::get&lt;1&gt;(tuple_vec_.at(left_lane_idx_));
+      static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right ?
+          std::get&lt;1&gt;(tuple_vec_.at(right_lane_idx_)) :
+          std::get&lt;1&gt;(tuple_vec_.at(left_lane_idx_));
 
   int32_t target_num = -1;
   for (uint32_t i = nghbr_clst_wp; i &lt; nghbr_lane.waypoints.size(); i++)
@@ -298,13 +300,13 @@ void LaneSelectNode::updateChangeFlag()
 {
   for (auto &amp;el : tuple_vec_)
   {
-    std::get&lt;2&gt;(el) = (std::get&lt;1&gt;(el) != -1)
-                          ? static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(el).waypoints.at(std::get&lt;1&gt;(el)).change_flag)
-                          : ChangeFlag::unknown;
+    std::get&lt;2&gt;(el) = (std::get&lt;1&gt;(el) != -1) ?
+                          static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(el).waypoints.at(std::get&lt;1&gt;(el)).change_flag) :
+                          ChangeFlag::unknown;
 
-    if(std::get&lt;2&gt;(el) == ChangeFlag::right &amp;&amp; right_lane_idx_ == -1)
+    if (std::get&lt;2&gt;(el) == ChangeFlag::right &amp;&amp; right_lane_idx_ == -1)
       std::get&lt;2&gt;(el) = ChangeFlag::unknown;
-    else if(std::get&lt;2&gt;(el) == ChangeFlag::left &amp;&amp; left_lane_idx_ == -1)
+    else if (std::get&lt;2&gt;(el) == ChangeFlag::left &amp;&amp; left_lane_idx_ == -1)
       std::get&lt;2&gt;(el) = ChangeFlag::unknown;
 
     ROS_INFO("change_flag: %d", enumToInteger(std::get&lt;2&gt;(el)));
@@ -445,7 +447,7 @@ visualization_msgs::Marker LaneSelectNode::createCurrentLaneMarker()
   color_current.a = 1.0;
   marker.color = color_current;
 
-  for(const auto &amp;em : std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints)
+  for (const auto &amp;em : std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints)
     marker.points.push_back(em.pose.pose.position);
 
   return marker;
@@ -482,7 +484,7 @@ visualization_msgs::Marker LaneSelectNode::createRightLaneMarker()
   const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_));
   marker.color = change_flag == ChangeFlag::right ? color_neighbor_change : color_neighbor;
 
-  for(const auto &amp;em : std::get&lt;0&gt;(tuple_vec_.at(right_lane_idx_)).waypoints)
+  for (const auto &amp;em : std::get&lt;0&gt;(tuple_vec_.at(right_lane_idx_)).waypoints)
     marker.points.push_back(em.pose.pose.position);
 
   return marker;
@@ -519,7 +521,7 @@ visualization_msgs::Marker LaneSelectNode::createLeftLaneMarker()
   const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_));
   marker.color = change_flag == ChangeFlag::left ? color_neighbor_change : color_neighbor;
 
-  for(const auto &amp;em : std::get&lt;0&gt;(tuple_vec_.at((left_lane_idx_))).waypoints)
+  for (const auto &amp;em : std::get&lt;0&gt;(tuple_vec_.at((left_lane_idx_))).waypoints)
     marker.points.push_back(em.pose.pose.position);
 
   return marker;
@@ -552,7 +554,7 @@ visualization_msgs::Marker LaneSelectNode::createChangeLaneMarker()
   color_current.a = 1.0;
 
   marker.color = current_state_ == "LANE_CHANGE" ? color_current : color;
-  for(const auto &amp;em : std::get&lt;0&gt;(lane_for_change_).waypoints)
+  for (const auto &amp;em : std::get&lt;0&gt;(lane_for_change_).waypoints)
     marker.points.push_back(em.pose.pose.position);
 
   return marker;
@@ -637,7 +639,7 @@ void LaneSelectNode::callbackFromLaneArray(const autoware_msgs::LaneArrayConstPt
   left_lane_idx_ = -1;
   is_lane_array_subscribed_ = true;
 
-  if(current_lane_idx_ == -1)
+  if (current_lane_idx_ == -1)
     initForLaneSelect();
   else
     processing();
@@ -648,7 +650,7 @@ void LaneSelectNode::callbackFromPoseStamped(const geometry_msgs::PoseStampedCon
   current_pose_ = *msg;
   is_current_pose_subscribed_ = true;
 
-  if(current_lane_idx_ == -1)
+  if (current_lane_idx_ == -1)
     initForLaneSelect();
   else
     processing();
@@ -659,7 +661,7 @@ void LaneSelectNode::callbackFromTwistStamped(const geometry_msgs::TwistStampedC
   current_velocity_ = *msg;
   is_current_velocity_subscribed_ = true;
 
-  if(current_lane_idx_ == -1)
+  if (current_lane_idx_ == -1)
     initForLaneSelect();
   else
     processing();
@@ -670,7 +672,7 @@ void LaneSelectNode::callbackFromState(const std_msgs::StringConstPtr &amp;msg)
   current_state_ = msg-&gt;data;
   is_current_state_subscribed_ = true;
 
-  if(current_lane_idx_ == -1)
+  if (current_lane_idx_ == -1)
     initForLaneSelect();
   else
     processing();
@@ -678,32 +680,33 @@ void LaneSelectNode::callbackFromState(const std_msgs::StringConstPtr &amp;msg)
 void LaneSelectNode::callbackFromStates(const autoware_msgs::stateConstPtr &amp;msg)
 {
   is_current_state_subscribed_ = true;
-  
-  if(msg-&gt;behavior_state == "LaneChangeRight" || 
-		  msg-&gt;behavior_state == "LaneChangeLeft") 
+
+  if (msg-&gt;behavior_state == "LaneChangeRight" || msg-&gt;behavior_state == "LaneChangeLeft")
+  {
+    current_state_ = std::string("LANE_CHANGE");
+    ;
+  }
+  else
   {
-	  current_state_ = std::string("LANE_CHANGE");;
-  }else{
-	  current_state_ = msg-&gt;main_state;
+    current_state_ = msg-&gt;main_state;
   }
 
-  if(current_lane_idx_ == -1)
+  if (current_lane_idx_ == -1)
     initForLaneSelect();
   else
     processing();
 }
 
-
 void LaneSelectNode::callbackFromConfig(const autoware_msgs::ConfigLaneSelectConstPtr &amp;msg)
 {
-  distance_threshold_ = msg-&gt; distance_threshold_neighbor_lanes;
-  lane_change_interval_= msg-&gt;lane_change_interval;
-    lane_change_target_ratio_ = msg-&gt;lane_change_target_ratio;
+  distance_threshold_ = msg-&gt;distance_threshold_neighbor_lanes;
+  lane_change_interval_ = msg-&gt;lane_change_interval;
+  lane_change_target_ratio_ = msg-&gt;lane_change_target_ratio;
   lane_change_target_minimum_ = msg-&gt;lane_change_target_minimum;
-    vlength_hermite_curve_= msg-&gt;vector_length_hermite_curve;
+  vlength_hermite_curve_ = msg-&gt;vector_length_hermite_curve;
   is_config_subscribed_ = true;
 
-  if(current_lane_idx_ == -1)
+  if (current_lane_idx_ == -1)
     initForLaneSelect();
   else
     processing();
@@ -721,7 +724,8 @@ double getTwoDimensionalDistance(const geometry_msgs::Point &amp;target1, const geom
   return distance;
 }
 
-geometry_msgs::Point convertPointIntoRelativeCoordinate(const geometry_msgs::Point &amp;input_point, const geometry_msgs::Pose &amp;pose)
+geometry_msgs::Point convertPointIntoRelativeCoordinate(const geometry_msgs::Point &amp;input_point,
+                                                        const geometry_msgs::Pose &amp;pose)
 {
   tf::Transform inverse;
   tf::poseMsgToTF(pose, inverse);
@@ -736,7 +740,7 @@ geometry_msgs::Point convertPointIntoRelativeCoordinate(const geometry_msgs::Poi
 }
 
 geometry_msgs::Point convertPointIntoWorldCoordinate(const geometry_msgs::Point &amp;input_point,
-                                                                      const geometry_msgs::Pose &amp;pose)
+                                                     const geometry_msgs::Pose &amp;pose)
 {
   tf::Transform inverse;
   tf::poseMsgToTF(pose, inverse);
@@ -798,9 +802,9 @@ int32_t getClosestWaypointNumber(const autoware_msgs::lane &amp;current_lane, const
     double minimum_dt = 2.0;
     double dt = current_velocity.linear.x * ratio &gt; minimum_dt ? current_velocity.linear.x * ratio : minimum_dt;
 
-    auto range_max = static_cast&lt;uint32_t&gt;(previous_number + dt) &lt; current_lane.waypoints.size()
-                         ? static_cast&lt;uint32_t&gt;(previous_number + dt)
-                         : current_lane.waypoints.size();
+    auto range_max = static_cast&lt;uint32_t&gt;(previous_number + dt) &lt; current_lane.waypoints.size() ?
+                         static_cast&lt;uint32_t&gt;(previous_number + dt) :
+                         current_lane.waypoints.size();
     for (uint32_t i = static_cast&lt;uint32_t&gt;(previous_number); i &lt; range_max; i++)
     {
       geometry_msgs::Point converted_p =
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="14" deleted_lines="10">
				<diff>@@ -34,10 +34,10 @@
 
 // ROS includes
 #include &lt;ros/ros.h&gt;
-#include &lt;tf/transform_datatypes.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
-#include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;std_msgs/String.h&gt;
+#include &lt;tf/transform_datatypes.h&gt;
+#include &lt;visualization_msgs/MarkerArray.h&gt;
 
 // C++ includes
 #include &lt;iostream&gt;
@@ -45,11 +45,11 @@
 #include &lt;tuple&gt;
 
 // User defined includes
+#include "autoware_msgs/ConfigLaneSelect.h"
 #include "autoware_msgs/LaneArray.h"
 #include "autoware_msgs/state.h"
-#include "waypoint_follower/libwaypoint_follower.h"
-#include "autoware_msgs/ConfigLaneSelect.h"
 #include "hermite_curve.h"
+#include "waypoint_follower/libwaypoint_follower.h"
 
 namespace lane_planner
 {
@@ -93,12 +93,14 @@ private:
   int32_t right_lane_idx_;
   int32_t left_lane_idx_;
   std::vector&lt;std::tuple&lt;autoware_msgs::lane, int32_t, ChangeFlag&gt;&gt; tuple_vec_;  // lane, closest_waypoint,
-                                                                                     // change_flag
+                                                                                 // change_flag
   std::tuple&lt;autoware_msgs::lane, int32_t, ChangeFlag&gt; lane_for_change_;
-  bool is_lane_array_subscribed_, is_current_pose_subscribed_, is_current_velocity_subscribed_, is_current_state_subscribed_, is_config_subscribed_;
+  bool is_lane_array_subscribed_, is_current_pose_subscribed_, is_current_velocity_subscribed_,
+      is_current_state_subscribed_, is_config_subscribed_;
 
   // parameter from runtime manager
-  double distance_threshold_, lane_change_interval_, lane_change_target_ratio_, lane_change_target_minimum_, vlength_hermite_curve_;
+  double distance_threshold_, lane_change_interval_, lane_change_target_ratio_, lane_change_target_minimum_,
+      vlength_hermite_curve_;
 
   // topics
   geometry_msgs::PoseStamped current_pose_;
@@ -144,14 +146,16 @@ private:
 };
 
 int32_t getClosestWaypointNumber(const autoware_msgs::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
-                                 const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number, const double distance_threshold);
+                                 const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number,
+                                 const double distance_threshold);
 
 double getTwoDimensionalDistance(const geometry_msgs::Point &amp;target1, const geometry_msgs::Point &amp;target2);
 
-geometry_msgs::Point convertPointIntoRelativeCoordinate(const geometry_msgs::Point &amp;input_point, const geometry_msgs::Pose &amp;pose);
+geometry_msgs::Point convertPointIntoRelativeCoordinate(const geometry_msgs::Point &amp;input_point,
+                                                        const geometry_msgs::Pose &amp;pose);
 
 geometry_msgs::Point convertPointIntoWorldCoordinate(const geometry_msgs::Point &amp;input_point,
-                                                                      const geometry_msgs::Pose &amp;pose);
+                                                     const geometry_msgs::Pose &amp;pose);
 double getRelativeAngle(const geometry_msgs::Pose &amp;waypoint_pose, const geometry_msgs::Pose &amp;current_pose);
 bool getLinearEquation(geometry_msgs::Point start, geometry_msgs::Point end, double *a, double *b, double *c);
 double getDistanceBetweenLineAndPoint(geometry_msgs::Point point, double sa, double b, double c);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="53cc0a9b89e9875531e72c36354491c703f614d9" author="Yusuke FUJII">
		<msg>fix a build error</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_param.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_param.hpp" added_lines="4" deleted_lines="0">
				<diff>@@ -15,6 +15,10 @@ namespace decision_maker
 #define DOUBLE_MAX 1.7976931348623158e308
 #define DEFAULT_TARGET_WAYPOINT 14
 
+
+#define DEFAULT_STOP_DECELERATION 0.2
+#define DEFAULT_STOP_TIME 1 
+
 #define ANGLE_NEUTRAL 0
 #define ANGLE_CURVE 40
 #define ANGLE_LEFT  (ANGLE_NEUTRAL - ANGLE_CURVE)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="4" deleted_lines="3">
				<diff>@@ -283,16 +283,17 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
   size_t idx = current_finalwaypoints_.waypoints.size()-1 &gt; param_target_waypoint_?
 	  param_target_waypoint_ : current_finalwaypoints_.waypoints.size()-1; 
   if(idx){
-	  if(isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE)){
+	  if(ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE)){
 		  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
 	  }
-	  if(isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE)){
+	  if(ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE)){
 		  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
 	  }else{ 
 		  ctx-&gt;setCurrentState(
 			  getStateFlags(current_finalwaypoints_.waypoints.at(idx).wpstate.steering_state));
 	  }
-	  if(current_finalwaypoints_.waypoints.at(idx).wpstate.stopline_state)
+
+	  if(current_finalwaypoints_.waypoints.at((int)idx/2).wpstate.stopline_state)
 		  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOP_STATE);
   }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="3" deleted_lines="1">
				<diff>@@ -36,11 +36,13 @@ void DecisionMakerNode::updateLaneWaypointsArray(void)
 {
 	current_stopped_lane_array_ = current_controlled_lane_array_;
 	for(auto &amp;lane : current_stopped_lane_array_.lanes)
+	{
+
 		for(auto &amp;wp: lane.waypoints){
 			wp.twist.twist.linear.x = 0.0;
 			wp.wpstate.stopline_state = 0;
 		}
-
+	}
 }
 
 void DecisionMakerNode::publishControlledLaneArray(void)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8aa974ad9dafdc261474d95349dbfc661bdd5d48" author="Yusuke FUJII">
		<msg>update state and remove detection state</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" added_lines="1" deleted_lines="3">
				<diff>@@ -58,15 +58,13 @@ public:
     StateStores[DRIVE_ACC_DECELERATION_STATE] = DriveAccDecelerationState::getInstance();
     StateStores[DRIVE_ACC_KEEP_STATE] = DriveAccKeepState::getInstance();
     StateStores[DRIVE_ACC_STOP_STATE] = DriveAccStopState::getInstance();
+    StateStores[DRIVE_ACC_STOPLINE_STATE] = DriveAccStopLineState::getInstance();
     StateStores[DRIVE_STR_STRAIGHT_STATE] = DriveStrStraightState::getInstance();
     StateStores[DRIVE_STR_LEFT_STATE] = DriveStrLeftState::getInstance();
     StateStores[DRIVE_STR_RIGHT_STATE] = DriveStrRightState::getInstance();
     StateStores[DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE] = DriveBehaviorLaneChangeLeftState::getInstance();
     StateStores[DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE] = DriveBehaviorLaneChangeRightState::getInstance();
     StateStores[DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE] = DriveBehaviorObstacleAvoidanceState::getInstance();
-    StateStores[DRIVE_DETECT_OBSTACLE_STATE] = DriveDetectObstacleState::getInstance();
-    StateStores[DRIVE_DETECT_STOPLINE_STATE] = DriveDetectStoplineState::getInstance();
-    StateStores[DRIVE_DETECT_TRAFFICLIGHT_RED_STATE] = DriveDetectTrafficlightRedState::getInstance();
     StateStores[MISSION_COMPLETE_STATE] = MissionCompleteState::getInstance();
     StateStores[EMERGENCY_STATE] = EmergencyState::getInstance();
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" added_lines="15" deleted_lines="57">
				<diff>@@ -35,7 +35,7 @@ private:
   friend class State&lt;DriveAccAccelerationState&gt;;
   DriveAccAccelerationState(void)
   {
-    StateName = "Acceleration";
+    StateName = "Accelerate";
     StateNum = DRIVE_STATE | DRIVE_ACC_ACCELERATION_STATE;
     StateTransMask = DRIVE_STATE;
     StateKind = ACC_STATE;
@@ -54,17 +54,13 @@ private:
   friend class State&lt;DriveAccDecelerationState&gt;;
   DriveAccDecelerationState(void)
   {
-    StateName = "Deceleration";
+    StateName = "Decelerate";
     StateNum = DRIVE_STATE | DRIVE_ACC_DECELERATION_STATE;
     StateTransMask = DRIVE_STATE;
     StateKind = ACC_STATE;
   }
 
 public:
-  void ShowStateName(void)
-  {
-    std::cout &lt;&lt; StateName &lt;&lt; "-";
-  }
 };
 
 class DriveAccKeepState : public State&lt;DriveAccKeepState&gt;
@@ -80,10 +76,6 @@ private:
   }
 
 public:
-  void ShowStateName(void)
-  {
-    std::cout &lt;&lt; StateName &lt;&lt; "-";
-  }
 };
 
 class DriveAccStopState : public State&lt;DriveAccStopState&gt;
@@ -99,10 +91,21 @@ private:
   }
 
 public:
-  void ShowStateName(void)
+};
+
+class DriveAccStopLineState : public State&lt;DriveAccStopLineState&gt;
+{
+private:
+  friend class State&lt;DriveAccStopLineState&gt;;
+  DriveAccStopLineState(void)
   {
-    std::cout &lt;&lt; StateName &lt;&lt; "-";
+    StateName = "StopLine";
+    StateNum = DRIVE_STATE |  DRIVE_ACC_STOPLINE_STATE;
+    StateTransMask = DRIVE_STATE;
+    StateKind = ACC_STATE;
   }
+
+public:
 };
 
 class DriveStrLeftState : public State&lt;DriveStrLeftState&gt;
@@ -189,51 +192,6 @@ private:
     StateKind = BEHAVIOR_STATE;
   }
 
-public:
-};
-
-class DriveDetectObstacleState : public State&lt;DriveDetectObstacleState&gt;
-{
-private:
-  friend class State&lt;DriveDetectObstacleState&gt;;
-  DriveDetectObstacleState(void)
-  {
-    StateName = "DetectObstacle";
-    StateNum = DRIVE_STATE | DRIVE_DETECT_OBSTACLE_STATE;
-    StateTransMask = DRIVE_STATE;
-    StateKind = PERCEPTION_STATE;
-  }
-
-public:
-};
-
-class DriveDetectStoplineState : public State&lt;DriveDetectStoplineState&gt;
-{
-private:
-  friend class State&lt;DriveDetectStoplineState&gt;;
-  DriveDetectStoplineState(void)
-  {
-    StateName = "DetectStopline";
-    StateNum = DRIVE_STATE | DRIVE_DETECT_STOPLINE_STATE;
-    StateTransMask = DRIVE_STATE;
-    StateKind = PERCEPTION_STATE;
-  }
-
-public:
-};
-
-class DriveDetectTrafficlightRedState : public State&lt;DriveDetectTrafficlightRedState&gt;
-{
-private:
-  friend class State&lt;DriveDetectTrafficlightRedState&gt;;
-  DriveDetectTrafficlightRedState(void)
-  {
-    StateName = "DetectTrafficLightRed";
-    StateNum = DRIVE_STATE | DRIVE_DETECT_TRAFFICLIGHT_RED_STATE;
-    StateTransMask = DRIVE_STATE;
-    StateKind = PERCEPTION_STATE;
-  }
-
 public:
 };
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" added_lines="21" deleted_lines="20">
				<diff>@@ -5,26 +5,27 @@ namespace state_machine
 {
 enum StateFlags
 {
-  NULL_STATE = 1 &lt;&lt; 0,
-  START_STATE = 1 &lt;&lt; 1,
-  INITIAL_STATE = 1 &lt;&lt; 2,
-  INITIAL_LOCATEVEHICLE_STATE = 1 &lt;&lt; 3,
-  DRIVE_STATE = 1 &lt;&lt; 4,
-  MISSION_COMPLETE_STATE = 1 &lt;&lt; 5,
-  EMERGENCY_STATE = 1 &lt;&lt; 6,
-  DRIVE_ACC_ACCELERATION_STATE = 1 &lt;&lt; 7,
-  DRIVE_ACC_DECELERATION_STATE = 1 &lt;&lt; 8,
-  DRIVE_ACC_KEEP_STATE = 1 &lt;&lt; 9,
-  DRIVE_ACC_STOP_STATE = 1 &lt;&lt; 10,
-  DRIVE_STR_STRAIGHT_STATE = 1 &lt;&lt; 11,
-  DRIVE_STR_LEFT_STATE = 1 &lt;&lt; 12,
-  DRIVE_STR_RIGHT_STATE = 1 &lt;&lt; 13,
-  DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE = 1 &lt;&lt; 14,
-  DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE = 1 &lt;&lt; 15,
-  DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE = 1 &lt;&lt; 16,
-  DRIVE_DETECT_OBSTACLE_STATE = 1 &lt;&lt; 17,
-  DRIVE_DETECT_STOPLINE_STATE = 1 &lt;&lt; 18,
-  DRIVE_DETECT_TRAFFICLIGHT_RED_STATE = 1 &lt;&lt; 19,
+  NULL_STATE 			= 1UL &lt;&lt; 0,
+  START_STATE 			= 1UL &lt;&lt; 1,
+  INITIAL_STATE 		= 1UL &lt;&lt; 2,
+  INITIAL_LOCATEVEHICLE_STATE 	= 1UL &lt;&lt; 3,
+  DRIVE_STATE 			= 1UL &lt;&lt; 4,
+  MISSION_COMPLETE_STATE 	= 1UL &lt;&lt; 5,
+  EMERGENCY_STATE 		= 1UL &lt;&lt; 6,
+ 
+  DRIVE_ACC_ACCELERATION_STATE 	= 1UL &lt;&lt; 10,
+  DRIVE_ACC_DECELERATION_STATE 	= 1UL &lt;&lt; 11,
+  DRIVE_ACC_KEEP_STATE		= 1UL &lt;&lt; 12,
+  DRIVE_ACC_STOP_STATE 		= 1UL &lt;&lt; 13,
+  DRIVE_ACC_STOPLINE_STATE 	= 1UL &lt;&lt; 14,
+  
+  DRIVE_STR_STRAIGHT_STATE 	= 1UL &lt;&lt; 20,
+  DRIVE_STR_LEFT_STATE 		= 1UL &lt;&lt; 21,
+  DRIVE_STR_RIGHT_STATE 	= 1UL &lt;&lt; 22,
+ 
+  DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE 		= 1UL &lt;&lt; 30,
+  DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE 	= 1UL &lt;&lt; 31,
+  DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE 	= 1UL &lt;&lt; 32,
   STATE_END = 1 &lt;&lt; 20,
 };
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="2" deleted_lines="15">
				<diff>@@ -70,19 +70,6 @@ void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMa
   ROS_INFO("Param setted by Runtime Manager");
   enableDisplayMarker = msg.enable_display_marker;
   ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);
-  if (msg.enable_force_state_change)
-  {
-    if (msg.MainState_ChangeFlag)
-      handleStateCmd((unsigned long long)1 &lt;&lt; msg.MainState_ChangeFlag);
-    if (msg.SubState_Acc_ChangeFlag)
-      handleStateCmd(state_machine::DRIVE_ACC_ACCELERATION_STATE &lt;&lt; (msg.SubState_Acc_ChangeFlag - 1));
-    if (msg.SubState_Str_ChangeFlag)
-      handleStateCmd(state_machine::DRIVE_STR_STRAIGHT_STATE &lt;&lt; (msg.SubState_Str_ChangeFlag - 1));
-    if (msg.SubState_Behavior_ChangeFlag)
-      handleStateCmd(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE &lt;&lt; (msg.SubState_Behavior_ChangeFlag - 1));
-    if (msg.SubState_Perception_ChangeFlag)
-      handleStateCmd(state_machine::DRIVE_DETECT_OBSTACLE_STATE &lt;&lt; (msg.SubState_Perception_ChangeFlag - 1));
-  }
 }
 
 void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
@@ -94,11 +81,11 @@ void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_
   current_traffic_light = light-&gt;traffic_light;
   if (current_traffic_light == state_machine::E_RED || current_traffic_light == state_machine::E_YELLOW)
   {
-    ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
+   // ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
   }
   else
   {
-    ctx-&gt;disableCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
+   //ctx-&gt;disableCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
   }
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="13" deleted_lines="8">
				<diff>@@ -18,10 +18,14 @@ void DecisionMakerNode::setupStateCallback(void)
       -&gt;setUpdateFunc(std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));
   ctx-&gt;getStateObject(state_machine::DRIVE_STR_STRAIGHT_STATE)
       -&gt;setUpdateFunc(std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
-  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_STOP_STATE)
+  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_STOPLINE_STATE)
        -&gt;setUpdateFunc(std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
-  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_STOP_STATE)
+  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_STOPLINE_STATE)
        -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateStop, this, 1));
+  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_STOP_STATE)
+       -&gt;setUpdateFunc(std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));
+  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_STOP_STATE)
+       -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateStop, this, 0));
   
   ctx-&gt;getStateObject(state_machine::DRIVE_ACC_KEEP_STATE)
        -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateKeep, this, 1));
@@ -98,13 +102,14 @@ void DecisionMakerNode::changedStateAcc(int status)
 }
 void DecisionMakerNode::updateStateStop(int status)
 {
-	static ros::Timer stopping_timer;
-	static bool timerflag = false;
-	if(current_velocity_ == 0.0 &amp;&amp; !timerflag){
-		stopping_timer = nh_.createTimer(ros::Duration(1), [&amp;](const ros::TimerEvent&amp;){ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE); ROS_INFO("Change state to keep from stop\n");timerflag=false; }, this, true);
-		timerflag = true;
+	if(status){
+		static ros::Timer stopping_timer;
+		static bool timerflag = false;
+		if(current_velocity_ == 0.0 &amp;&amp; !timerflag){
+			stopping_timer = nh_.createTimer(ros::Duration(1), [&amp;](const ros::TimerEvent&amp;){ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE); ROS_INFO("Change state to keep from stop\n");timerflag=false; }, this, true);
+			timerflag = true;
+		}
 	}
-
 }
 
 void DecisionMakerNode::changedStateStop(int status)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="cf9188a65495a47367df4ba572ba69af4744ce4c" author="Yusuke FUJII">
		<msg>delete build warning, and change stopline</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -129,13 +129,13 @@ bool StateContext::setCurrentState(BaseState *_state)
 		  *HolderMap[getStateKind(_state)] = _state;
 	  }
 	  change_state_mutex.unlock();
-	  if(ret)
+	  if(ret &amp;&amp; diff)
 		  this-&gt;changed(getStateKind(_state));
   }else{
+	  change_state_mutex.unlock();
 	  ret = false;
   }
   return ret;
-
 }
 
 bool StateContext::setCurrentState(uint64_t flag)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="2" deleted_lines="2">
				<diff>@@ -109,8 +109,8 @@ private:
   // Param
   bool enableDisplayMarker;
   bool enableForceStateChange;
-  int param_convergence_count_;
-  int param_target_waypoint_;
+  uint32_t param_convergence_count_;
+  uint32_t param_target_waypoint_;
   double param_convergence_threshold_;
 
   // for vectormap server
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" added_lines="4" deleted_lines="5">
				<diff>@@ -15,7 +15,6 @@ CrossRoadArea *CrossRoadArea::findClosestCrossRoad(const autoware_msgs::lane &amp;_f
 
   double _min_distance = DBL_MAX;
 
-  int _label = 1;
 
   if (!_finalwaypoints.waypoints.empty())
   {
@@ -54,7 +53,7 @@ std::vector&lt;geometry_msgs::Point&gt; convhull(const CrossRoadArea *_TargetArea)
   std::vector&lt;int&gt; enablePoints;
 
   // Jarvis's March algorithm
-  int l = 0;
+  size_t l = 0;
   for (auto i = begin(_TargetArea-&gt;points); i != end(_TargetArea-&gt;points); i++)
   {
     if (i-&gt;x &lt; _TargetArea-&gt;points.at(l).x)
@@ -63,13 +62,13 @@ std::vector&lt;geometry_msgs::Point&gt; convhull(const CrossRoadArea *_TargetArea)
     }
   }
 
-  int p = l;
-  int q;
+  size_t p = l;
+  size_t q;
 
   do
   {
     q = (p + 1) % _TargetArea-&gt;points.size();
-    for (int i = 0; i &lt; _TargetArea-&gt;points.size(); i++)
+    for (size_t i = 0; i &lt; _TargetArea-&gt;points.size(); i++)
     {
       geometry_msgs::Point pp = _TargetArea-&gt;points.at(p);
       geometry_msgs::Point pi = _TargetArea-&gt;points.at(i);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="1" deleted_lines="4">
				<diff>@@ -281,15 +281,12 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
 	  }
 
 	  if(current_finalwaypoints_.waypoints.at((int)idx/2).wpstate.stopline_state)
-		  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOP_STATE);
+		  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
   }
 
   // for publish plan of velocity
   publishToVelocityArray();
 
-#ifdef DEBUG_PRINT
-  std::cout &lt;&lt; "Velocity: " &lt;&lt; current_velocity_ &lt;&lt; " to " &lt;&lt; average_velocity_ &lt;&lt; std::endl;
-#endif
 }
 void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" added_lines="1" deleted_lines="0">
				<diff>@@ -45,6 +45,7 @@ bool DecisionMakerNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;
     //   std::cout &lt;&lt; "DEBUG" &lt;&lt; cross_road_d.linkid &lt;&lt; std::endl;
   }
 #endif
+  return false;
 }
 
 void DecisionMakerNode::update(void)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" added_lines="7" deleted_lines="7">
				<diff>@@ -46,12 +46,11 @@ double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;lanei
 bool DecisionMakerNode::isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch,
                                                   double _yaw)
 {
-  static int _init_count = 0;
   static amathutils::point *a = new amathutils::point();
   static amathutils::point *b = new amathutils::point();
 
   static std::vector&lt;double&gt; distances;
-  static int distances_count = 0;
+  static uint32_t distances_count = 0;
   double avg_distances = 0.0;
 
   a-&gt;x = b-&gt;x;
@@ -65,11 +64,12 @@ bool DecisionMakerNode::isLocalizationConvergence(double _x, double _y, double _
   distances.push_back(amathutils::find_distance(a, b));
   if (++distances_count &gt; param_convergence_count_)
   {
-    distances.erase(distances.begin());
-    distances_count--;
-    avg_distances = std::accumulate(distances.begin(), distances.end(), 0) / distances.size();
-    if (avg_distances &lt;= param_convergence_threshold_)
-      return ctx-&gt;setCurrentState(state_machine::DRIVE_STATE);
+	  distances.erase(distances.begin());
+	  distances_count--;
+	  avg_distances = std::accumulate(distances.begin(), distances.end(), 0) / distances.size();
+	  if (avg_distances &lt;= param_convergence_threshold_){
+		  return ctx-&gt;setCurrentState(state_machine::DRIVE_STATE);
+	  }
   }
   else
   {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="2" deleted_lines="0">
				<diff>@@ -48,6 +48,8 @@ int DecisionMakerNode::createCrossRoadAreaMarker(visualization_msgs::Marker &amp;cro
   crossroad_marker.color.b = 0.0;
   crossroad_marker.frame_locked = true;
   crossroad_marker.lifetime = ros::Duration(0.3);
+
+  return 0;
 }
 
 void DecisionMakerNode::displayMarker(void)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="1" deleted_lines="4">
				<diff>@@ -71,9 +71,6 @@ void DecisionMakerNode::changeVelocityLane(int dir)
 		autoware_msgs::lane temp_lane = lane;
 		for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
 		{
-			double v0 = temp_lane.waypoints.at(wpi - 1).twist.twist.linear.x;
-			double v = temp_lane.waypoints.at(wpi).twist.twist.linear.x;
-
 			amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
 					temp_lane.waypoints.at(wpi).pose.pose.position.y,
 					temp_lane.waypoints.at(wpi).pose.pose.position.z);
@@ -84,7 +81,7 @@ void DecisionMakerNode::changeVelocityLane(int dir)
 			double distance = amathutils::find_distance(&amp;p0, &amp;p1);
 			double _weight = distance * 0.05 * dir;
 			lane.waypoints.at(wpi).twist.twist.linear.x =
-				lane.waypoints.at(wpi).twist.twist.linear.x + lane.waypoints.at(wpi).twist.twist.linear.x * _weight;
+				lane.waypoints.at(wpi).twist.twist.linear.x + (lane.waypoints.at(wpi).twist.twist.linear.x * _weight);
 		}
 	}
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ad2598f405ac9dd0a275370b9aa66a027418f86b" author="Yusuke FUJII">
		<msg>add to insert shift lane</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="7" deleted_lines="0">
				<diff>@@ -112,6 +112,8 @@ private:
   uint32_t param_convergence_count_;
   uint32_t param_target_waypoint_;
   double param_convergence_threshold_;
+  uint32_t param_stopline_target_waypoint_;
+  double param_shift_width_;
 
   // for vectormap server
   // ros::ServiceClient cross_road_cli;
@@ -154,6 +156,9 @@ private:
   void insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects, autoware_msgs::LaneArray &amp;lane_array);
 
   void setWaypointState(autoware_msgs::LaneArray &amp;lane_array);
+  double calcPosesAngleDiff(const geometry_msgs::Pose &amp;p_from, const geometry_msgs::Pose &amp;p_to);
+  double calcPosesAngleDiffN(const geometry_msgs::Pose &amp;p_from, const geometry_msgs::Pose &amp;p_to);
+  double getPoseAngle(const geometry_msgs::Pose &amp;p);
 
   void publishStoppedLaneArray(void);
   void publishControlledLaneArray(void);
@@ -197,6 +202,8 @@ public:
     param_convergence_threshold_ = DEFAULT_CONVERGENCE_THRESHOLD;
     param_convergence_count_ = DEFAULT_CONVERGENCE_COUNT;
     param_target_waypoint_ = DEFAULT_TARGET_WAYPOINT;
+    param_shift_width_ = DEFAULT_SHIFT_WIDTH;
+    param_stopline_target_waypoint_ = DEFAULT_STOPLINE_TARGET_WAYPOINT;
 
     ctx = new state_machine::StateContext();
     this-&gt;initROS(argc, argv);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_param.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_param.hpp" added_lines="3" deleted_lines="0">
				<diff>@@ -18,6 +18,9 @@ namespace decision_maker
 
 #define DEFAULT_STOP_DECELERATION 0.2
 #define DEFAULT_STOP_TIME 1 
+#define DEFAULT_STOPLINE_TARGET_WAYPOINT 10
+
+#define DEFAULT_SHIFT_WIDTH 1.0
 
 #define ANGLE_NEUTRAL 0
 #define ANGLE_CURVE 40
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="12" deleted_lines="1">
				<diff>@@ -70,6 +70,12 @@ void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMa
   ROS_INFO("Param setted by Runtime Manager");
   enableDisplayMarker = msg.enable_display_marker;
   ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);
+
+  param_target_waypoint_ = msg.target_waypoint;
+  param_stopline_target_waypoint_ = msg.stopline_target_waypoint;
+  param_shift_width_ =  msg.shift_width;
+
+
 }
 
 void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
@@ -279,8 +285,13 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
 		  ctx-&gt;setCurrentState(
 			  getStateFlags(current_finalwaypoints_.waypoints.at(idx).wpstate.steering_state));
 	  }
+  }
+
+  idx = current_finalwaypoints_.waypoints.size()-1 &gt; param_stopline_target_waypoint_?
+	  param_stopline_target_waypoint_ : current_finalwaypoints_.waypoints.size()-1;
 
-	  if(current_finalwaypoints_.waypoints.at((int)idx/2).wpstate.stopline_state)
+  if(idx){
+	  if(current_finalwaypoints_.waypoints.at((int)idx).wpstate.stopline_state)
 		  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
   }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" added_lines="32" deleted_lines="11">
				<diff>@@ -16,6 +16,36 @@
 
 namespace decision_maker
 {
+
+double DecisionMakerNode::getPoseAngle(const geometry_msgs::Pose &amp;pose)
+{
+    double r, p, y;
+
+    tf::Quaternion quat(pose.orientation.x, pose.orientation.y, pose.orientation.z, pose.orientation.w);
+    tf::Matrix3x3(quat).getRPY(r, p, y);
+
+    // convert to [-pi : pi]
+    return y;
+
+}
+
+double DecisionMakerNode::calcPosesAngleDiffN(const geometry_msgs::Pose &amp;p_from, const geometry_msgs::Pose &amp;p_to)
+{
+    // convert to [-pi : pi]
+    return getPoseAngle(p_from) - getPoseAngle(p_to);
+}
+
+
+double DecisionMakerNode::calcPosesAngleDiff(const geometry_msgs::Pose &amp;p_from, const geometry_msgs::Pose &amp;p_to)
+{
+    // convert to [-pi : pi]
+    double diff = std::fmod(calcPosesAngleDiffN(p_from, p_to), 2 * M_PI);
+    diff = diff &gt; M_PI ? diff - 2 * M_PI : diff &lt; -M_PI ? 2 * M_PI + diff : diff;
+    diff = diff * 180 / M_PI;
+    return diff;
+}
+
+
 double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;laneinArea)
 {
   double diff = 0.0;
@@ -27,17 +57,8 @@ double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;lanei
   {
     const geometry_msgs::Pose InPose = laneinArea.waypoints.front().pose.pose;
     const geometry_msgs::Pose OutPose = laneinArea.waypoints.back().pose.pose;
-    double r, p, y, _y;
-
-    tf::Quaternion quat_end(OutPose.orientation.x, OutPose.orientation.y, OutPose.orientation.z, OutPose.orientation.w);
-    tf::Quaternion quat_in(InPose.orientation.x, InPose.orientation.y, InPose.orientation.z, InPose.orientation.w);
-    tf::Matrix3x3(quat_in).getRPY(r, p, y);
-    tf::Matrix3x3(quat_end).getRPY(r, p, _y);
-
-    // convert to [-pi : pi]
-    diff = std::fmod(y - _y, 2 * M_PI);
-    diff = diff &gt; M_PI ? diff - 2 * M_PI : diff &lt; -M_PI ? 2 * M_PI + diff : diff;
-    diff = diff * 180 / M_PI;
+    
+    diff = calcPosesAngleDiff(InPose, OutPose);
   }
 
   return diff;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="28" deleted_lines="1">
				<diff>@@ -94,8 +94,10 @@ void DecisionMakerNode::displayMarker(void)
     for (const auto &amp;lane : area.insideLanes)
     {
 	    inside_line_marker.points.clear();
-	    inside_line_marker.id +=1;
 	    int id = inside_line_marker.id;
+	    inside_line_marker.id +=1;
+	    inside_marker.scale.x = scale / 3;
+	    inside_marker.scale.y = scale / 3;
 	    inside_line_marker.color.r = std::fmod(0.12345 * (id), 1.0);
 	    inside_line_marker.color.g = std::fmod(0.32345 * (5 - (id%5)), 1.0);
 	    inside_line_marker.color.b = std::fmod(0.52345 * (10- (id % 10)), 1.0);
@@ -105,6 +107,31 @@ void DecisionMakerNode::displayMarker(void)
 	    marker_array.markers.push_back(inside_line_marker);
     }
   }
+  inside_line_marker.scale.x =0.3; //0.3;
+  inside_line_marker.scale.y =0.3;// 0.3;
+  int id = inside_line_marker.id;
+  inside_line_marker.color.r = 0;
+  inside_line_marker.color.g = 1;
+  inside_line_marker.color.b = 0.3;
+  inside_line_marker.color.a = 1;
+  inside_line_marker.ns = "shiftline";
+  for (const auto &amp;lane : current_controlled_lane_array_.lanes)
+  {
+	  inside_line_marker.points.clear();
+	  for (size_t idx = 0; idx &lt; lane.waypoints.size(); idx++){
+		  inside_line_marker.id +=1;
+
+		  geometry_msgs::Pose shift_p = lane.waypoints.at(idx).pose.pose;
+
+		  double current_angle = getPoseAngle(shift_p);
+
+		  shift_p.position.x -= param_shift_width_ * cos(current_angle + M_PI / 2);
+		  shift_p.position.y -= param_shift_width_ * sin(current_angle + M_PI / 2);
+
+		  inside_line_marker.points.push_back(shift_p.position);
+	  }
+	  marker_array.markers.push_back(inside_line_marker);
+  }
   Pubs["crossroad_bbox"].publish(bbox_array);
   Pubs["crossroad_marker"].publish(marker_array);
   bbox_array.boxes.clear();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -10,6 +10,7 @@
 namespace decision_maker
 {
 
+
 void DecisionMakerNode::setupStateCallback(void)
 {
   ctx-&gt;getStateObject(state_machine::DRIVE_STR_LEFT_STATE)
@@ -41,7 +42,6 @@ void DecisionMakerNode::updateLaneWaypointsArray(void)
 	current_stopped_lane_array_ = current_controlled_lane_array_;
 	for(auto &amp;lane : current_stopped_lane_array_.lanes)
 	{
-
 		for(auto &amp;wp: lane.waypoints){
 			wp.twist.twist.linear.x = 0.0;
 			wp.wpstate.stopline_state = 0;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="51e0d689e6951686767966829a43fc8ff17f216b" author="Yusuke FUJII">
		<msg>:put_litter_in_its_place:</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -59,7 +59,6 @@ void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
     ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
   else
   {
-	  fprintf(stderr,"disable lanechange\n");
     ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
     ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
   }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="df63fd03969b3d9583e4121e028e1e42bbb237fc" author="Yusuke FUJII">
		<msg>Fix not working changed callback</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -129,7 +129,7 @@ bool StateContext::setCurrentState(BaseState *_state)
 		  *HolderMap[getStateKind(_state)] = _state;
 	  }
 	  change_state_mutex.unlock();
-	  if(ret &amp;&amp; diff)
+	  if(ret &amp;&amp; !diff)
 		  this-&gt;changed(getStateKind(_state));
   }else{
 	  change_state_mutex.unlock();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -99,9 +99,9 @@ void DecisionMakerNode::changedStateAcc(int status)
 }
 void DecisionMakerNode::updateStateStop(int status)
 {
+	static ros::Timer stopping_timer;
+	static bool timerflag = false;
 	if(status){
-		static ros::Timer stopping_timer;
-		static bool timerflag = false;
 		if(current_velocity_ == 0.0 &amp;&amp; !timerflag){
 			stopping_timer = nh_.createTimer(ros::Duration(1), [&amp;](const ros::TimerEvent&amp;){ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE); ROS_INFO("Change state to keep from stop\n");timerflag=false; }, this, true);
 			timerflag = true;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6ff78e1069648ddde6e86cc7a2c447abf2590d59" author="Yusuke FUJII">
		<msg>add simple obstacle avoid based shifting lane</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="3" deleted_lines="0">
				<diff>@@ -165,6 +165,9 @@ private:
   void updateLaneWaypointsArray(void);
   void changeVelocityBasedLane(void);
   void changeVelocityLane(int dir);
+  void createShiftLane(void);
+  
+  void changedStateObstacleAvoid(int status);
   
   void updateStateSTR(int status);
   void updateStateStop(int status);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="44" deleted_lines="1">
				<diff>@@ -34,12 +34,49 @@ void DecisionMakerNode::setupStateCallback(void)
        -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateAcc, this, 1));
   ctx-&gt;getStateObject(state_machine::DRIVE_ACC_DECELERATION_STATE)
        -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateAcc, this, -1));
+ 
+  ctx-&gt;getStateObject(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE)
+       -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateObstacleAvoid, this, -1));
 }
 
+void DecisionMakerNode::createShiftLane(void)
+{
+	autoware_msgs::lane shift_lane;
+	if(!current_controlled_lane_array_.lanes.empty()){
+		shift_lane = current_controlled_lane_array_.lanes.at(0);
+		for(auto &amp;wp : shift_lane.waypoints){
+			double current_angle = getPoseAngle(wp.pose.pose);
+			wp.pose.pose.position.x -= param_shift_width_ * cos(current_angle + M_PI / 2);
+			wp.pose.pose.position.y -= param_shift_width_ * sin(current_angle + M_PI / 2);
+		}
+		auto it = current_controlled_lane_array_.lanes.insert(current_controlled_lane_array_.lanes.begin() + 1, shift_lane);
+
+		for(auto &amp;wp : current_controlled_lane_array_.lanes.at(0).waypoints){
+			wp.change_flag = 1;
+		}
+	}
+
+}
 
 void DecisionMakerNode::updateLaneWaypointsArray(void)
 {
 	current_stopped_lane_array_ = current_controlled_lane_array_;
+#if 0
+	size_t idx	= current_finalwaypoints_.waypoints.at(0).gid;
+	for(auto &amp;lane : current_stopped_lane_array_.lanes)
+	{
+		for(auto &amp;wp: lane.waypoints){
+			fprintf(stderr,"%d:%d\n",idx, wp.gid);
+			if(idx - 5 &lt;= wp.gid &amp;&amp;  wp.gid  &lt; idx){
+				wp.twist.twist.linear.x /= 5 - (idx-wp.gid);
+			}else{
+				wp.twist.twist.linear.x = 0;
+			}
+			wp.wpstate.stopline_state = 0;
+		}
+	}
+#else
+
 	for(auto &amp;lane : current_stopped_lane_array_.lanes)
 	{
 		for(auto &amp;wp: lane.waypoints){
@@ -47,6 +84,7 @@ void DecisionMakerNode::updateLaneWaypointsArray(void)
 			wp.wpstate.stopline_state = 0;
 		}
 	}
+#endif
 }
 
 void DecisionMakerNode::publishControlledLaneArray(void)
@@ -59,6 +97,7 @@ void DecisionMakerNode::publishStoppedLaneArray(void)
   Pubs["lane_waypoints_array"].publish(current_stopped_lane_array_);
 }
 
+
 void DecisionMakerNode::changeVelocityBasedLane(void)
 {
 	current_controlled_lane_array_ = current_based_lane_array_;
@@ -108,7 +147,11 @@ void DecisionMakerNode::updateStateStop(int status)
 		}
 	}
 }
-
+void DecisionMakerNode::changedStateObstacleAvoid(int status)
+{
+	createShiftLane();
+	publishControlledLaneArray();
+}
 void DecisionMakerNode::changedStateStop(int status)
 {
 	publishStoppedLaneArray();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c40c0a56402837637800ecb851e923107648be99" author="Yusuke FUJII">
		<msg>add shifted lanes</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="4" deleted_lines="3">
				<diff>@@ -91,9 +91,10 @@ private:
 
   std::vector&lt;geometry_msgs::Point&gt; inside_points_;
 
-  autoware_msgs::LaneArray current_based_lane_array_;
-  autoware_msgs::LaneArray current_controlled_lane_array_;
-  autoware_msgs::LaneArray current_stopped_lane_array_;
+  autoware_msgs::LaneArray current_based_lane_array_; // with wpstate
+  autoware_msgs::LaneArray current_shifted_lane_array_; // with shiftedLane
+  autoware_msgs::LaneArray current_controlled_lane_array_; // modified lane
+  autoware_msgs::LaneArray current_stopped_lane_array_; // 0velocity
 
 
   // Current way/behavior status
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -239,7 +239,7 @@ void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray
     }
   }
   setWaypointState(current_based_lane_array_);
-  current_controlled_lane_array_ = current_based_lane_array_;  // controlled path
+  current_controlled_lane_array_ = current_shifted_lane_array_ = current_based_lane_array_;  // controlled path
 
   publishControlledLaneArray();
   updateLaneWaypointsArray();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -107,8 +107,8 @@ void DecisionMakerNode::displayMarker(void)
 	    marker_array.markers.push_back(inside_line_marker);
     }
   }
-  inside_line_marker.scale.x =0.3; //0.3;
-  inside_line_marker.scale.y =0.3;// 0.3;
+  inside_line_marker.scale.x =0.1; //0.3;
+  inside_line_marker.scale.y =0.1;// 0.3;
   int id = inside_line_marker.id;
   inside_line_marker.color.r = 0;
   inside_line_marker.color.g = 1;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="15" deleted_lines="6">
				<diff>@@ -27,7 +27,6 @@ void DecisionMakerNode::setupStateCallback(void)
        -&gt;setUpdateFunc(std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));
   ctx-&gt;getStateObject(state_machine::DRIVE_ACC_STOP_STATE)
        -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateStop, this, 0));
-  
   ctx-&gt;getStateObject(state_machine::DRIVE_ACC_KEEP_STATE)
        -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateKeep, this, 1));
   ctx-&gt;getStateObject(state_machine::DRIVE_ACC_ACCELERATION_STATE)
@@ -42,16 +41,19 @@ void DecisionMakerNode::setupStateCallback(void)
 void DecisionMakerNode::createShiftLane(void)
 {
 	autoware_msgs::lane shift_lane;
-	if(!current_controlled_lane_array_.lanes.empty()){
-		shift_lane = current_controlled_lane_array_.lanes.at(0);
+	if(!current_shifted_lane_array_.lanes.empty()){
+		shift_lane = current_shifted_lane_array_.lanes.at(0);
+		size_t idx = 0;
 		for(auto &amp;wp : shift_lane.waypoints){
 			double current_angle = getPoseAngle(wp.pose.pose);
 			wp.pose.pose.position.x -= param_shift_width_ * cos(current_angle + M_PI / 2);
 			wp.pose.pose.position.y -= param_shift_width_ * sin(current_angle + M_PI / 2);
+			wp.change_flag = current_based_lane_array.lanes.at(0).waypoints.at(idx++).change_flag;
+
 		}
-		auto it = current_controlled_lane_array_.lanes.insert(current_controlled_lane_array_.lanes.begin() + 1, shift_lane);
+		auto it = current_shifted_lane_array_.lanes.insert(current_shifted_lane_array_.lanes.begin() + 1, shift_lane);
 
-		for(auto &amp;wp : current_controlled_lane_array_.lanes.at(0).waypoints){
+		for(auto &amp;wp : current_shifted_lane_array_.lanes.at(0).waypoints){
 			wp.change_flag = 1;
 		}
 	}
@@ -60,6 +62,7 @@ void DecisionMakerNode::createShiftLane(void)
 
 void DecisionMakerNode::updateLaneWaypointsArray(void)
 {
+	//current_stopped_lane_array_ = current_controlled_lane_array_;
 	current_stopped_lane_array_ = current_controlled_lane_array_;
 #if 0
 	size_t idx	= current_finalwaypoints_.waypoints.at(0).gid;
@@ -100,7 +103,8 @@ void DecisionMakerNode::publishStoppedLaneArray(void)
 
 void DecisionMakerNode::changeVelocityBasedLane(void)
 {
-	current_controlled_lane_array_ = current_based_lane_array_;
+	current_controlled_lane_array_ = current_shifted_lane_array_;
+	//current_controlled_lane_array_ = current_based_lane_array_;
 }
 
 void DecisionMakerNode::changeVelocityLane(int dir)
@@ -131,10 +135,15 @@ void DecisionMakerNode::changedStateKeep(int status)
 	publishControlledLaneArray();
 }
 
+
 void DecisionMakerNode::changedStateAcc(int status)
 {
 	changeVelocityLane(status);
 	publishControlledLaneArray();
+	
+	static ros::Timer stopping_timer;
+	static bool timerflag = false;
+	stopping_timer = nh_.createTimer(ros::Duration(1), [&amp;](const ros::TimerEvent&amp;){ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE); ROS_INFO("Change state to null from obstacle avoid\n"); }, this, true);
 }
 void DecisionMakerNode::updateStateStop(int status)
 {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="df4b95593f10d2a0db5070afdd76ed61e71dbde6" author="Yamato ANDO">
		<msg>fixed CMakeLists and compile error</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="30" deleted_lines="23">
				<diff>@@ -39,6 +39,7 @@
 #include &lt;iostream&gt;
 #include &lt;sstream&gt;
 #include &lt;string&gt;
+#include &lt;memory&gt;
 #include &lt;pthread.h&gt;
 
 #include &lt;ros/ros.h&gt;
@@ -115,7 +116,7 @@ static int _use_gnss = 1;
 static int init_pos_set = 0;
 
 #ifdef CUDA_FOUND
-static gpu::GNormalDistributionsTransform gpu_ndt;
+static std::shared_ptr&lt;gpu::GNormalDistributionsTransform&gt; gpu_ndt_ptr = std::make_shared&lt;gpu::GNormalDistributionsTransform&gt;();
 #endif
 static pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt;
 
@@ -260,7 +261,7 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
 #ifdef CUDA_FOUND
     if (_use_gpu == true)
     {
-      gpu_ndt.setResolution(ndt_res);
+      gpu_ndt_ptr-&gt;setResolution(ndt_res);
     }
     else
     {
@@ -276,7 +277,7 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
 #ifdef CUDA_FOUND
     if (_use_gpu == true)
     {
-      gpu_ndt.setStepSize(step_size);
+      gpu_ndt_ptr-&gt;setStepSize(step_size);
     }
     else
     {
@@ -292,7 +293,7 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
 #ifdef CUDA_FOUND
     if (_use_gpu == true)
     {
-      gpu_ndt.setTransformationEpsilon(trans_eps);
+      gpu_ndt_ptr-&gt;setTransformationEpsilon(trans_eps);
     }
     else
     {
@@ -308,7 +309,7 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
 #ifdef CUDA_FOUND
     if (_use_gpu == true)
     {
-      gpu_ndt.setMaximumIterations(max_iter);
+      gpu_ndt_ptr-&gt;setMaximumIterations(max_iter);
     }
     else
     {
@@ -426,19 +427,27 @@ static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 #ifdef CUDA_FOUND
     if (_use_gpu == true)
     {
-      pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; new_gpu_ndt;
-      new_gpu_ndt.setInputTarget(map_ptr);
-      new_gpu_ndt.setMaximumIterations(max_iter);
-      new_gpu_ndt.setResolution(ndt_res);
-      new_gpu_ndt.setStepSize(step_size);
-      new_gpu_ndt.setTransformationEpsilon(trans_eps);
-      new_gpu_ndt.align(Eigen::Matrix4f::Identity());
+      std::shared_ptr&lt;gpu::GNormalDistributionsTransform&gt; new_gpu_ndt_ptr = std::make_shared&lt;gpu::GNormalDistributionsTransform&gt;();
+      new_gpu_ndt_ptr-&gt;setInputTarget(map_ptr);
+      new_gpu_ndt_ptr-&gt;setMaximumIterations(max_iter);
+      new_gpu_ndt_ptr-&gt;setResolution(ndt_res);
+      new_gpu_ndt_ptr-&gt;setStepSize(step_size);
+      new_gpu_ndt_ptr-&gt;setTransformationEpsilon(trans_eps);
+
+      pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr dummy_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;());
+      pcl::PointXYZ dummy_point;
+      dummy_scan_ptr-&gt;push_back(dummy_point);
+      new_gpu_ndt_ptr-&gt;setInputSource(dummy_scan_ptr);
+
+      new_gpu_ndt_ptr-&gt;align(Eigen::Matrix4f::Identity());
+
       pthread_mutex_lock(&amp;mutex);
-      gpu_ndt = new_gpu_ndt;
+      gpu_ndt_ptr = new_gpu_ndt_ptr;
       pthread_mutex_unlock(&amp;mutex);
+    }
     else
-    {
 #endif
+    {
       pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; new_ndt;
       pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
       new_ndt.setInputTarget(map_ptr);
@@ -456,9 +465,7 @@ static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
       pthread_mutex_lock(&amp;mutex);
       ndt = new_ndt;
       pthread_mutex_unlock(&amp;mutex);
-#ifdef CUDA_FOUND
     }
-#endif
 
     map_loaded = 1;
   }
@@ -844,7 +851,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 #ifdef CUDA_FOUND
     if (_use_gpu == true)
     {
-      gpu_ndt.setInputSource(filtered_scan_ptr);
+      gpu_ndt_ptr-&gt;setInputSource(filtered_scan_ptr);
     }
     else
     {
@@ -891,19 +898,19 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     if (_use_gpu == true)
     {
       align_start = std::chrono::system_clock::now();
-      gpu_ndt.align(init_guess);
+      gpu_ndt_ptr-&gt;align(init_guess);
       align_end = std::chrono::system_clock::now();
 
-      has_converged = gpu_ndt.hasConverged();
+      has_converged = gpu_ndt_ptr-&gt;hasConverged();
 
-      t = gpu_ndt.getFinalTransformation();
-      iteration = gpu_ndt.getFinalNumIteration();
+      t = gpu_ndt_ptr-&gt;getFinalTransformation();
+      iteration = gpu_ndt_ptr-&gt;getFinalNumIteration();
 
       getFitnessScore_start = std::chrono::system_clock::now();
-      fitness_score = gpu_ndt.getFitnessScore();
+      fitness_score = gpu_ndt_ptr-&gt;getFitnessScore();
       getFitnessScore_end = std::chrono::system_clock::now();
 
-      trans_probability = gpu_ndt.getTransformationProbability();
+      trans_probability = gpu_ndt_ptr-&gt;getTransformationProbability();
     }
 #ifdef USE_FAST_PCL
     else if (_use_openmp == true)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f62d1fe4c4c7554fd1c5412bcd4b8dd868e37f14" author="Yusuke FUJII">
		<msg>cosme</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" added_lines="3" deleted_lines="0">
				<diff>@@ -106,6 +106,9 @@ public:
   std::string getCurrentStateName(void);
   std::string getStateName(void);
   
+  bool setChangedFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
+  bool setUpdateFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
+  
   BaseState **getCurrentStateHolderPtr(uint8_t _kind);
   BaseState **getCurrentStateHolderPtr(uint64_t _state_num);
   BaseState **getCurrentStateHolderPtr(BaseState *_state);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="12" deleted_lines="0">
				<diff>@@ -44,6 +44,18 @@ void StateContext::changed(uint8_t _kind)
 		(*HolderMap[_kind])-&gt;changed();
 }
 
+bool StateContext::setUpdateFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f)
+{
+	if(getStateObject(_state_num))
+			getStateObject(_state_num)-&gt;setUpdateFunc(_f);
+}
+bool StateContext::setChangedFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f)
+{
+	if(getStateObject(_state_num))
+			getStateObject(_state_num)-&gt;setChangedFunc(_f);
+}
+
+
 
 void StateContext::showCurrentStateName(void)
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -15,7 +15,6 @@ CrossRoadArea *CrossRoadArea::findClosestCrossRoad(const autoware_msgs::lane &amp;_f
 
   double _min_distance = DBL_MAX;
 
-
   if (!_finalwaypoints.waypoints.empty())
   {
     _pa.x = _finalwaypoints.waypoints[TARGET_WAYPOINTS_NUM].pose.pose.position.x;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="66" deleted_lines="64">
				<diff>@@ -71,10 +71,8 @@ void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMa
   ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);
 
   param_target_waypoint_ = msg.target_waypoint;
-  param_stopline_target_waypoint_ = msg.stopline_target_waypoint;
-  param_shift_width_ =  msg.shift_width;
-
-
+  // param_stopline_target_waypoint_ = msg.stopline_target_waypoint;
+  param_shift_width_ = msg.shift_width;
 }
 
 void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
@@ -86,11 +84,11 @@ void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_
   current_traffic_light = light-&gt;traffic_light;
   if (current_traffic_light == state_machine::E_RED || current_traffic_light == state_machine::E_YELLOW)
   {
-   // ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
+    // ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
   }
   else
   {
-   //ctx-&gt;disableCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
+    // ctx-&gt;disableCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
   }
 }
 
@@ -121,7 +119,7 @@ void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadAr
           {
             autoware_msgs::lane nlane;
             area.insideLanes.push_back(nlane);
-	  }
+          }
           area.insideLanes.back().waypoints.push_back(wp);
           area.insideWaypoint_points.push_back(pp);  // geometry_msgs::point
           // area.insideLanes.Waypoints.push_back(wp);//autoware_msgs::waypoint
@@ -164,56 +162,56 @@ void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
 
       for (auto &amp;wp_lane : laneinArea.waypoints)
       {
-	      for (auto &amp;lane : lane_array.lanes)
-	      {
-		      for(auto &amp;wp : lane.waypoints){
-			      if(wp.gid == wp_lane.gid &amp;&amp; wp.wpstate.aid == area.area_id){
-				      wp.wpstate.steering_state = steering_state;
-			      }
-		      }
-		      //lane.waypoints.at(wp_lane.lid).wpstate.steering_state = steering_state;
-	      }
+        for (auto &amp;lane : lane_array.lanes)
+        {
+          for (auto &amp;wp : lane.waypoints)
+          {
+            if (wp.gid == wp_lane.gid &amp;&amp; wp.wpstate.aid == area.area_id)
+            {
+              wp.wpstate.steering_state = steering_state;
+            }
+          }
+          // lane.waypoints.at(wp_lane.lid).wpstate.steering_state = steering_state;
+        }
       }
     }
   }
   // STOP
-  std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([&amp;](const StopLine &amp;stopline) { 
-        return (g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type == (int)vector_map_msgs::RoadSign::TYPE_STOP);});
-  
+  std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([&amp;](const StopLine &amp;stopline) {
+    return (g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type == (int)vector_map_msgs::RoadSign::TYPE_STOP);
+  });
+
   for (auto &amp;lane : lane_array.lanes)
   {
     for (size_t wp_idx = 0; wp_idx &lt; lane.waypoints.size() - 1; wp_idx++)
     {
       for (auto &amp;stopline : stoplines)
       {
-          geometry_msgs::Point bp =
-              to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).bpid)));
-          geometry_msgs::Point fp =
-              to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).fpid)));
-	 
-          if (amathutils::isIntersectLine(lane.waypoints.at(wp_idx).pose.pose.position.x,
-                                          lane.waypoints.at(wp_idx).pose.pose.position.y,
-                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
-                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.y, bp.x, bp.y, fp.x, fp.y))
+        geometry_msgs::Point bp =
+            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).bpid)));
+        geometry_msgs::Point fp =
+            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).fpid)));
+
+        if (amathutils::isIntersectLine(lane.waypoints.at(wp_idx).pose.pose.position.x,
+                                        lane.waypoints.at(wp_idx).pose.pose.position.y,
+                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
+                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.y, bp.x, bp.y, fp.x, fp.y))
+        {
+          geometry_msgs::Point center_point;
+          center_point.x = (bp.x * 2 + fp.x) / 3;
+          center_point.y = (bp.y * 2 + fp.y) / 3;
+          if (amathutils::isPointLeftFromLine(
+                  center_point.x, center_point.y, lane.waypoints.at(wp_idx).pose.pose.position.x,
+                  lane.waypoints.at(wp_idx).pose.pose.position.y, lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
+                  lane.waypoints.at(wp_idx + 1).pose.pose.position.y))
           {
-	    geometry_msgs::Point center_point;
-	    center_point.x = (bp.x*2 + fp.x)/3;
-	    center_point.y = (bp.y*2 + fp.y)/3;
-	    if(amathutils::isPointLeftFromLine( 
-				          center_point.x,
-					  center_point.y,
-           			          lane.waypoints.at(wp_idx).pose.pose.position.x,
-                                          lane.waypoints.at(wp_idx).pose.pose.position.y,
-                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
-                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.y)){
-		    lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
-		    //lane.waypoints.at(wp_idx + 1).wpstate.stopline_state = 1;
-	    }
-	  }
+            lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
+            // lane.waypoints.at(wp_idx + 1).wpstate.stopline_state = 1;
+          }
+        }
       }
     }
   }
-
 }
 
 // for based waypoint
@@ -271,32 +269,36 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
   // cached
   current_finalwaypoints_ = msg;
 
-  // steering
-  size_t idx = current_finalwaypoints_.waypoints.size()-1 &gt; param_target_waypoint_?
-	  param_target_waypoint_ : current_finalwaypoints_.waypoints.size()-1; 
-  if(idx){
-	  if(ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE)){
-		  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
-	  }
-	  if(ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE)){
-		  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
-	  }else{ 
-		  ctx-&gt;setCurrentState(
-			  getStateFlags(current_finalwaypoints_.waypoints.at(idx).wpstate.steering_state));
-	  }
+  size_t idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_stopline_target_waypoint_ ?
+                   param_stopline_target_waypoint_ :
+                   current_finalwaypoints_.waypoints.size() - 1;
+  if (idx &gt;= 0)
+  {
+    if (current_finalwaypoints_.waypoints.at(idx).wpstate.stopline_state)
+      ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
   }
-
-  idx = current_finalwaypoints_.waypoints.size()-1 &gt; param_stopline_target_waypoint_?
-	  param_stopline_target_waypoint_ : current_finalwaypoints_.waypoints.size()-1;
-
-  if(idx){
-	  if(current_finalwaypoints_.waypoints.at((int)idx).wpstate.stopline_state)
-		  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
+  // steering
+  idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_target_waypoint_ ?
+            param_target_waypoint_ :
+            current_finalwaypoints_.waypoints.size() - 1;
+  if (idx &gt;= 0)
+  {
+    if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE))
+    {
+      ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
+    }
+    if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE))
+    {
+      ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
+    }
+    else
+    {
+      ctx-&gt;setCurrentState(getStateFlags(current_finalwaypoints_.waypoints.at(idx).wpstate.steering_state));
+    }
   }
 
   // for publish plan of velocity
   publishToVelocityArray();
-
 }
 void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" added_lines="20" deleted_lines="23">
				<diff>@@ -16,36 +16,32 @@
 
 namespace decision_maker
 {
-
 double DecisionMakerNode::getPoseAngle(const geometry_msgs::Pose &amp;pose)
 {
-    double r, p, y;
-
-    tf::Quaternion quat(pose.orientation.x, pose.orientation.y, pose.orientation.z, pose.orientation.w);
-    tf::Matrix3x3(quat).getRPY(r, p, y);
+  double r, p, y;
 
-    // convert to [-pi : pi]
-    return y;
+  tf::Quaternion quat(pose.orientation.x, pose.orientation.y, pose.orientation.z, pose.orientation.w);
+  tf::Matrix3x3(quat).getRPY(r, p, y);
 
+  // convert to [-pi : pi]
+  return y;
 }
 
 double DecisionMakerNode::calcPosesAngleDiffN(const geometry_msgs::Pose &amp;p_from, const geometry_msgs::Pose &amp;p_to)
 {
-    // convert to [-pi : pi]
-    return getPoseAngle(p_from) - getPoseAngle(p_to);
+  // convert to [-pi : pi]
+  return getPoseAngle(p_from) - getPoseAngle(p_to);
 }
 
-
 double DecisionMakerNode::calcPosesAngleDiff(const geometry_msgs::Pose &amp;p_from, const geometry_msgs::Pose &amp;p_to)
 {
-    // convert to [-pi : pi]
-    double diff = std::fmod(calcPosesAngleDiffN(p_from, p_to), 2 * M_PI);
-    diff = diff &gt; M_PI ? diff - 2 * M_PI : diff &lt; -M_PI ? 2 * M_PI + diff : diff;
-    diff = diff * 180 / M_PI;
-    return diff;
+  // convert to [-pi : pi]
+  double diff = std::fmod(calcPosesAngleDiffN(p_from, p_to), 2 * M_PI);
+  diff = diff &gt; M_PI ? diff - 2 * M_PI : diff &lt; -M_PI ? 2 * M_PI + diff : diff;
+  diff = diff * 180 / M_PI;
+  return diff;
 }
 
-
 double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;laneinArea)
 {
   double diff = 0.0;
@@ -57,7 +53,7 @@ double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;lanei
   {
     const geometry_msgs::Pose InPose = laneinArea.waypoints.front().pose.pose;
     const geometry_msgs::Pose OutPose = laneinArea.waypoints.back().pose.pose;
-    
+
     diff = calcPosesAngleDiff(InPose, OutPose);
   }
 
@@ -85,12 +81,13 @@ bool DecisionMakerNode::isLocalizationConvergence(double _x, double _y, double _
   distances.push_back(amathutils::find_distance(a, b));
   if (++distances_count &gt; param_convergence_count_)
   {
-	  distances.erase(distances.begin());
-	  distances_count--;
-	  avg_distances = std::accumulate(distances.begin(), distances.end(), 0) / distances.size();
-	  if (avg_distances &lt;= param_convergence_threshold_){
-		  return ctx-&gt;setCurrentState(state_machine::DRIVE_STATE);
-	  }
+    distances.erase(distances.begin());
+    distances_count--;
+    avg_distances = std::accumulate(distances.begin(), distances.end(), 0) / distances.size();
+    if (avg_distances &lt;= param_convergence_threshold_)
+    {
+      return ctx-&gt;setCurrentState(state_machine::DRIVE_STATE);
+    }
   }
   else
   {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="77" deleted_lines="75">
				<diff>@@ -15,9 +15,9 @@
 #include &lt;decision_maker_node.hpp&gt;
 //#include &lt;vector_map/vector_map.h&gt;
 
+#include &lt;autoware_msgs/lamp_cmd.h&gt;
 #include &lt;autoware_msgs/lane.h&gt;
 #include &lt;autoware_msgs/state.h&gt;
-#include &lt;autoware_msgs/lamp_cmd.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;random&gt;
@@ -28,7 +28,6 @@
 
 namespace decision_maker
 {
-
 void DecisionMakerNode::initROS(int argc, char **argv)
 {
   // status subscriber
@@ -82,9 +81,10 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   // setup a callback for state update();
   setupStateCallback();
 
-  g_vmap.subscribe(nh_, 
-		  Category::POINT |  Category::LINE |  Category::VECTOR | Category::AREA | Category::POLE | //basic class
-		  Category::DTLANE | Category::STOP_LINE | Category::ROAD_SIGN | Category::CROSS_ROAD);
+  g_vmap.subscribe(nh_,
+                   Category::POINT | Category::LINE | Category::VECTOR | Category::AREA |
+                       Category::POLE |  // basic class
+                       Category::DTLANE | Category::STOP_LINE | Category::ROAD_SIGN | Category::CROSS_ROAD);
   initVectorMap();
 
   {
@@ -94,90 +94,92 @@ void DecisionMakerNode::initROS(int argc, char **argv)
 
   ROS_INFO("Initialized OUT\n");
   Subs["lane_waypoints_array"] =
-	  nh_.subscribe(TPNAME_BASED_LANE_WAYPOINTS_ARRAY, 100, &amp;DecisionMakerNode::callbackFromLaneWaypoint, this);
+      nh_.subscribe(TPNAME_BASED_LANE_WAYPOINTS_ARRAY, 100, &amp;DecisionMakerNode::callbackFromLaneWaypoint, this);
 }
 
 void DecisionMakerNode::initVectorMap(void)
 {
-      int _index = 0;
-      //if(vector_map_init)
-	//      return;
-      std::vector&lt;CrossRoad&gt; crossroads = g_vmap.findByFilter([](const CrossRoad &amp;crossroad){return true;});
-      if(crossroads.empty()){
-	      ROS_INFO("crossroad have not found\n");
-	      return;
-      }
-
-      vector_map_init = true; //loaded flag
-      for(const auto &amp;cross_road : crossroads)
-      {
-	Area area = g_vmap.findByKey(Key&lt;Area&gt;(cross_road.aid));
-	CrossRoadArea carea;
-	carea.id = _index++;
-	carea.area_id = area.aid;
-	
-	double x_avg = 0.0, x_min = 0.0, x_max = 0.0;
-	double y_avg = 0.0, y_min = 0.0, y_max = 0.0;
-	double z = 0.0;
-	int points_count = 0;
-
-	std::vector&lt;Line&gt; lines = g_vmap.findByFilter([&amp;area](const Line &amp;line){return area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid;});
-	for (const auto &amp;line : lines)
-	{
-		geometry_msgs::Point _prev_point;
-		std::vector&lt;Point&gt; points = g_vmap.findByFilter([&amp;line](const Point &amp;point){return line.bpid == point.pid || point.pid == line.fpid;});
-		for (const auto &amp;point : points)
-		{
-			geometry_msgs::Point _point;
-			_point.x = point.ly;
-			_point.y = point.bx;
-			_point.z = point.h;
-
-			if (_prev_point.x == _point.x &amp;&amp; _prev_point.y == _point.y)
-				continue;
-
-			_prev_point = _point;
-			points_count++;
-			carea.points.push_back(_point);
-
-			// calc a centroid point and about intersects size
-			x_avg += _point.x;
-			y_avg += _point.y;
-			x_min = (x_min == 0.0) ? _point.x : std::min(_point.x, x_min);
-			x_max = (x_max == 0.0) ? _point.x : std::max(_point.x, x_max);
-			y_min = (y_min == 0.0) ? _point.y : std::min(_point.y, y_min);
-			y_max = (y_max == 0.0) ? _point.y : std::max(_point.y, y_max);
-			z = _point.z;
-
-		}    // points iter
-	}        // line iter
-	carea.bbox.pose.position.x = x_avg / (double)points_count;
-	carea.bbox.pose.position.y = y_avg / (double)points_count;
-	carea.bbox.pose.position.z = z;
-	carea.bbox.dimensions.x = x_max - x_min;
-	carea.bbox.dimensions.y = y_max - y_min;
-	carea.bbox.dimensions.z = 2;
-	carea.bbox.label = 1;
-	intersects.push_back(carea);
-      }
+  int _index = 0;
+  // if(vector_map_init)
+  //      return;
+  std::vector&lt;CrossRoad&gt; crossroads = g_vmap.findByFilter([](const CrossRoad &amp;crossroad) { return true; });
+  if (crossroads.empty())
+  {
+    ROS_INFO("crossroad have not found\n");
+    return;
+  }
 
+  vector_map_init = true;  // loaded flag
+  for (const auto &amp;cross_road : crossroads)
+  {
+    Area area = g_vmap.findByKey(Key&lt;Area&gt;(cross_road.aid));
+    CrossRoadArea carea;
+    carea.id = _index++;
+    carea.area_id = area.aid;
+
+    double x_avg = 0.0, x_min = 0.0, x_max = 0.0;
+    double y_avg = 0.0, y_min = 0.0, y_max = 0.0;
+    double z = 0.0;
+    int points_count = 0;
+
+    std::vector&lt;Line&gt; lines =
+        g_vmap.findByFilter([&amp;area](const Line &amp;line) { return area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid; });
+    for (const auto &amp;line : lines)
+    {
+      geometry_msgs::Point _prev_point;
+      std::vector&lt;Point&gt; points =
+          g_vmap.findByFilter([&amp;line](const Point &amp;point) { return line.bpid == point.pid || point.pid == line.fpid; });
+      for (const auto &amp;point : points)
+      {
+        geometry_msgs::Point _point;
+        _point.x = point.ly;
+        _point.y = point.bx;
+        _point.z = point.h;
+
+        if (_prev_point.x == _point.x &amp;&amp; _prev_point.y == _point.y)
+          continue;
+
+        _prev_point = _point;
+        points_count++;
+        carea.points.push_back(_point);
+
+        // calc a centroid point and about intersects size
+        x_avg += _point.x;
+        y_avg += _point.y;
+        x_min = (x_min == 0.0) ? _point.x : std::min(_point.x, x_min);
+        x_max = (x_max == 0.0) ? _point.x : std::max(_point.x, x_max);
+        y_min = (y_min == 0.0) ? _point.y : std::min(_point.y, y_min);
+        y_max = (y_max == 0.0) ? _point.y : std::max(_point.y, y_max);
+        z = _point.z;
+
+      }  // points iter
+    }    // line iter
+    carea.bbox.pose.position.x = x_avg / (double)points_count;
+    carea.bbox.pose.position.y = y_avg / (double)points_count;
+    carea.bbox.pose.position.z = z;
+    carea.bbox.dimensions.x = x_max - x_min;
+    carea.bbox.dimensions.y = y_max - y_min;
+    carea.bbox.dimensions.z = 2;
+    carea.bbox.label = 1;
+    intersects.push_back(carea);
+  }
 }
 
 bool DecisionMakerNode::initVectorMapClient()
 {
 #ifdef USE_VMAP_SERVER  // This is not successfully run due to failing vmap
-	// server
+  // server
 
-	vector_map::VectorMap vmap;
-	vmap.subscribe(nh_, vector_map::Category::AREA, ros::Duration(0));
+  vector_map::VectorMap vmap;
+  vmap.subscribe(nh_, vector_map::Category::AREA, ros::Duration(0));
 
-	cross_road_srv.request.pose = current_pose_;
-	cross_road_srv.request.waypoints = current_finalwaypoints_;
+  cross_road_srv.request.pose = current_pose_;
+  cross_road_srv.request.waypoints = current_finalwaypoints_;
 
-	cross_road_cli = nh_.serviceClient&lt;vector_map_server::GetCrossRoad&gt;("vector_map_server/get_cross_road");
+  cross_road_cli = nh_.serviceClient&lt;vector_map_server::GetCrossRoad&gt;("vector_map_server/get_cross_road");
 
-	return cross_road_cli.call(cross_road_srv);
+  return cross_road_cli.call(cross_road_srv);
 #endif
-	return false;
+  return false;
 }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="33" deleted_lines="36">
				<diff>@@ -78,7 +78,7 @@ void DecisionMakerNode::displayMarker(void)
 
   bbox_array.header = crossroad_marker.header;
   inside_marker.points.clear();
-  
+
   inside_line_marker = inside_marker;
   inside_line_marker.type = visualization_msgs::Marker::LINE_STRIP;
 
@@ -93,22 +93,23 @@ void DecisionMakerNode::displayMarker(void)
 
     for (const auto &amp;lane : area.insideLanes)
     {
-	    inside_line_marker.points.clear();
-	    int id = inside_line_marker.id;
-	    inside_line_marker.id +=1;
-	    inside_marker.scale.x = scale / 3;
-	    inside_marker.scale.y = scale / 3;
-	    inside_line_marker.color.r = std::fmod(0.12345 * (id), 1.0);
-	    inside_line_marker.color.g = std::fmod(0.32345 * (5 - (id%5)), 1.0);
-	    inside_line_marker.color.b = std::fmod(0.52345 * (10- (id % 10)), 1.0);
-	    for(const auto &amp;wp : lane.waypoints){
-		    inside_line_marker.points.push_back(wp.pose.pose.position);
-	    } 
-	    marker_array.markers.push_back(inside_line_marker);
+      inside_line_marker.points.clear();
+      int id = inside_line_marker.id;
+      inside_line_marker.id += 1;
+      inside_marker.scale.x = scale / 3;
+      inside_marker.scale.y = scale / 3;
+      inside_line_marker.color.r = std::fmod(0.12345 * (id), 1.0);
+      inside_line_marker.color.g = std::fmod(0.32345 * (5 - (id % 5)), 1.0);
+      inside_line_marker.color.b = std::fmod(0.52345 * (10 - (id % 10)), 1.0);
+      for (const auto &amp;wp : lane.waypoints)
+      {
+        inside_line_marker.points.push_back(wp.pose.pose.position);
+      }
+      marker_array.markers.push_back(inside_line_marker);
     }
   }
-  inside_line_marker.scale.x =0.1; //0.3;
-  inside_line_marker.scale.y =0.1;// 0.3;
+  inside_line_marker.scale.x = 0.1;  // 0.3;
+  inside_line_marker.scale.y = 0.1;  // 0.3;
   int id = inside_line_marker.id;
   inside_line_marker.color.r = 0;
   inside_line_marker.color.g = 1;
@@ -117,25 +118,26 @@ void DecisionMakerNode::displayMarker(void)
   inside_line_marker.ns = "shiftline";
   for (const auto &amp;lane : current_controlled_lane_array_.lanes)
   {
-	  inside_line_marker.points.clear();
-	  for (size_t idx = 0; idx &lt; lane.waypoints.size(); idx++){
-		  inside_line_marker.id +=1;
+    inside_line_marker.points.clear();
+    for (size_t idx = 0; idx &lt; lane.waypoints.size(); idx++)
+    {
+      inside_line_marker.id += 1;
 
-		  geometry_msgs::Pose shift_p = lane.waypoints.at(idx).pose.pose;
+      geometry_msgs::Pose shift_p = lane.waypoints.at(idx).pose.pose;
 
-		  double current_angle = getPoseAngle(shift_p);
+      double current_angle = getPoseAngle(shift_p);
 
-		  shift_p.position.x -= param_shift_width_ * cos(current_angle + M_PI / 2);
-		  shift_p.position.y -= param_shift_width_ * sin(current_angle + M_PI / 2);
+      shift_p.position.x -= param_shift_width_ * cos(current_angle + M_PI / 2);
+      shift_p.position.y -= param_shift_width_ * sin(current_angle + M_PI / 2);
 
-		  inside_line_marker.points.push_back(shift_p.position);
-	  }
-	  marker_array.markers.push_back(inside_line_marker);
+      inside_line_marker.points.push_back(shift_p.position);
+    }
+    marker_array.markers.push_back(inside_line_marker);
   }
   Pubs["crossroad_bbox"].publish(bbox_array);
   Pubs["crossroad_marker"].publish(marker_array);
   bbox_array.boxes.clear();
-  //Pubs["crossroad_inside_marker"].publish(inside_marker);
+  // Pubs["crossroad_inside_marker"].publish(inside_marker);
   Pubs["crossroad_inside_marker"].publish(inside_line_marker);
 }
 
@@ -152,24 +154,19 @@ void DecisionMakerNode::update_msgs(void)
       update_pubsub();
     }
 
-
     autoware_msgs::state state_msg;
     state_msg.main_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::MAIN_STATE);
     state_msg.acc_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::ACC_STATE);
     state_msg.str_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::STR_STATE);
     state_msg.behavior_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::BEHAVIOR_STATE);
-    
-    state_string_msg.data = CurrentStateName;
-    //state_text_msg.text = createStateMessageText();
-    state_text_msg.text = state_msg.main_state + "\n"
-	    		 + state_msg.acc_state + "\n"
-	    		 + state_msg.str_state + "\n"
-	    		 + state_msg.behavior_state + "\n";
 
-    
+    state_string_msg.data = CurrentStateName;
+    // state_text_msg.text = createStateMessageText();
+    state_text_msg.text = state_msg.main_state + "\n" + state_msg.acc_state + "\n" + state_msg.str_state + "\n" +
+                          state_msg.behavior_state + "\n";
 
     Pubs["states"].publish(state_msg);
-    //Pubs["state"].publish(state_string_msg);
+    // Pubs["state"].publish(state_string_msg);
     Pubs["state_overlay"].publish(state_text_msg);
   }
   else
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="118" deleted_lines="112">
				<diff>@@ -4,66 +4,59 @@
 #include &lt;state.hpp&gt;
 #include &lt;state_context.hpp&gt;
 
-#include &lt;decision_maker_node.hpp&gt;
 #include &lt;autoware_msgs/lamp_cmd.h&gt;
+#include &lt;decision_maker_node.hpp&gt;
 
 namespace decision_maker
 {
-
-
 void DecisionMakerNode::setupStateCallback(void)
 {
-  ctx-&gt;getStateObject(state_machine::DRIVE_STR_LEFT_STATE)
-      -&gt;setUpdateFunc(std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 1));
-  ctx-&gt;getStateObject(state_machine::DRIVE_STR_RIGHT_STATE)
-      -&gt;setUpdateFunc(std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));
-  ctx-&gt;getStateObject(state_machine::DRIVE_STR_STRAIGHT_STATE)
-      -&gt;setUpdateFunc(std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
-  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_STOPLINE_STATE)
-       -&gt;setUpdateFunc(std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
-  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_STOPLINE_STATE)
-       -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateStop, this, 1));
-  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_STOP_STATE)
-       -&gt;setUpdateFunc(std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));
-  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_STOP_STATE)
-       -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateStop, this, 0));
-  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_KEEP_STATE)
-       -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateKeep, this, 1));
-  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_ACCELERATION_STATE)
-       -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateAcc, this, 1));
-  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_DECELERATION_STATE)
-       -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateAcc, this, -1));
- 
-  ctx-&gt;getStateObject(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE)
-       -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateObstacleAvoid, this, -1));
+  ctx-&gt;setUpdateFunc(state_machine::DRIVE_STR_LEFT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 1));
+  ctx-&gt;setUpdateFunc(state_machine::DRIVE_STR_RIGHT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));
+  ctx-&gt;setUpdateFunc(state_machine::DRIVE_STR_STRAIGHT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
+  ctx-&gt;setUpdateFunc(state_machine::DRIVE_ACC_STOPLINE_STATE, std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
+  ctx-&gt;setUpdateFunc(state_machine::DRIVE_ACC_STOP_STATE, std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));
+
+  ctx-&gt;setChangedFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
+                      std::bind(&amp;DecisionMakerNode::changedStateStop, this, 1));
+  ctx-&gt;setChangedFunc(state_machine::DRIVE_ACC_STOP_STATE, std::bind(&amp;DecisionMakerNode::changedStateStop, this, 0));
+  ctx-&gt;setChangedFunc(state_machine::DRIVE_ACC_KEEP_STATE, std::bind(&amp;DecisionMakerNode::changedStateKeep, this, 1));
+  ctx-&gt;setChangedFunc(state_machine::DRIVE_ACC_ACCELERATION_STATE,
+                      std::bind(&amp;DecisionMakerNode::changedStateAcc, this, 1));
+  ctx-&gt;setChangedFunc(state_machine::DRIVE_ACC_DECELERATION_STATE,
+                      std::bind(&amp;DecisionMakerNode::changedStateAcc, this, -1));
+
+  ctx-&gt;setChangedFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
+                      std::bind(&amp;DecisionMakerNode::changedStateObstacleAvoid, this, -1));
 }
 
 void DecisionMakerNode::createShiftLane(void)
 {
-	autoware_msgs::lane shift_lane;
-	if(!current_shifted_lane_array_.lanes.empty()){
-		shift_lane = current_shifted_lane_array_.lanes.at(0);
-		size_t idx = 0;
-		for(auto &amp;wp : shift_lane.waypoints){
-			double current_angle = getPoseAngle(wp.pose.pose);
-			wp.pose.pose.position.x -= param_shift_width_ * cos(current_angle + M_PI / 2);
-			wp.pose.pose.position.y -= param_shift_width_ * sin(current_angle + M_PI / 2);
-			wp.change_flag = current_based_lane_array.lanes.at(0).waypoints.at(idx++).change_flag;
-
-		}
-		auto it = current_shifted_lane_array_.lanes.insert(current_shifted_lane_array_.lanes.begin() + 1, shift_lane);
-
-		for(auto &amp;wp : current_shifted_lane_array_.lanes.at(0).waypoints){
-			wp.change_flag = 1;
-		}
-	}
-
+  autoware_msgs::lane shift_lane;
+  if (!current_shifted_lane_array_.lanes.empty())
+  {
+    shift_lane = current_shifted_lane_array_.lanes.at(0);
+    size_t idx = 0;
+    for (auto &amp;wp : shift_lane.waypoints)
+    {
+      double current_angle = getPoseAngle(wp.pose.pose);
+      wp.pose.pose.position.x -= param_shift_width_ * cos(current_angle + M_PI / 2);
+      wp.pose.pose.position.y -= param_shift_width_ * sin(current_angle + M_PI / 2);
+      wp.change_flag = current_based_lane_array_.lanes.at(0).waypoints.at(idx++).change_flag;
+    }
+    auto it = current_shifted_lane_array_.lanes.insert(current_shifted_lane_array_.lanes.begin() + 1, shift_lane);
+
+    for (auto &amp;wp : current_shifted_lane_array_.lanes.at(0).waypoints)
+    {
+      wp.change_flag = 1;
+    }
+  }
 }
 
 void DecisionMakerNode::updateLaneWaypointsArray(void)
 {
-	//current_stopped_lane_array_ = current_controlled_lane_array_;
-	current_stopped_lane_array_ = current_controlled_lane_array_;
+  // current_stopped_lane_array_ = current_controlled_lane_array_;
+  current_stopped_lane_array_ = current_controlled_lane_array_;
 #if 0
 	size_t idx	= current_finalwaypoints_.waypoints.at(0).gid;
 	for(auto &amp;lane : current_stopped_lane_array_.lanes)
@@ -80,13 +73,14 @@ void DecisionMakerNode::updateLaneWaypointsArray(void)
 	}
 #else
 
-	for(auto &amp;lane : current_stopped_lane_array_.lanes)
-	{
-		for(auto &amp;wp: lane.waypoints){
-			wp.twist.twist.linear.x = 0.0;
-			wp.wpstate.stopline_state = 0;
-		}
-	}
+  for (auto &amp;lane : current_stopped_lane_array_.lanes)
+  {
+    for (auto &amp;wp : lane.waypoints)
+    {
+      wp.twist.twist.linear.x = 0.0;
+      wp.wpstate.stopline_state = 0;
+    }
+  }
 #endif
 }
 
@@ -100,94 +94,106 @@ void DecisionMakerNode::publishStoppedLaneArray(void)
   Pubs["lane_waypoints_array"].publish(current_stopped_lane_array_);
 }
 
-
 void DecisionMakerNode::changeVelocityBasedLane(void)
 {
-	current_controlled_lane_array_ = current_shifted_lane_array_;
-	//current_controlled_lane_array_ = current_based_lane_array_;
+  current_controlled_lane_array_ = current_shifted_lane_array_;
+  // current_controlled_lane_array_ = current_based_lane_array_;
 }
 
 void DecisionMakerNode::changeVelocityLane(int dir)
 {
-	for (auto &amp;lane : current_controlled_lane_array_.lanes)
-	{
-		autoware_msgs::lane temp_lane = lane;
-		for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
-		{
-			amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
-					temp_lane.waypoints.at(wpi).pose.pose.position.y,
-					temp_lane.waypoints.at(wpi).pose.pose.position.z);
-			amathutils::point p1(temp_lane.waypoints.at(wpi - 1).pose.pose.position.x,
-					temp_lane.waypoints.at(wpi - 1).pose.pose.position.y,
-					temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);
-
-			double distance = amathutils::find_distance(&amp;p0, &amp;p1);
-			double _weight = distance * 0.05 * dir;
-			lane.waypoints.at(wpi).twist.twist.linear.x =
-				lane.waypoints.at(wpi).twist.twist.linear.x + (lane.waypoints.at(wpi).twist.twist.linear.x * _weight);
-		}
-	}
+  for (auto &amp;lane : current_controlled_lane_array_.lanes)
+  {
+    autoware_msgs::lane temp_lane = lane;
+    for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
+    {
+      amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
+                           temp_lane.waypoints.at(wpi).pose.pose.position.y,
+                           temp_lane.waypoints.at(wpi).pose.pose.position.z);
+      amathutils::point p1(temp_lane.waypoints.at(wpi - 1).pose.pose.position.x,
+                           temp_lane.waypoints.at(wpi - 1).pose.pose.position.y,
+                           temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);
+
+      double distance = amathutils::find_distance(&amp;p0, &amp;p1);
+      double _weight = distance * 0.05 * dir;
+      lane.waypoints.at(wpi).twist.twist.linear.x =
+          lane.waypoints.at(wpi).twist.twist.linear.x + (lane.waypoints.at(wpi).twist.twist.linear.x * _weight);
+    }
+  }
 }
 
 void DecisionMakerNode::changedStateKeep(int status)
 {
-	changeVelocityBasedLane();
-	publishControlledLaneArray();
+  changeVelocityBasedLane();
+  publishControlledLaneArray();
 }
 
-
 void DecisionMakerNode::changedStateAcc(int status)
 {
-	changeVelocityLane(status);
-	publishControlledLaneArray();
-	
-	static ros::Timer stopping_timer;
-	static bool timerflag = false;
-	stopping_timer = nh_.createTimer(ros::Duration(1), [&amp;](const ros::TimerEvent&amp;){ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE); ROS_INFO("Change state to null from obstacle avoid\n"); }, this, true);
+  changeVelocityLane(status);
+  publishControlledLaneArray();
 }
 void DecisionMakerNode::updateStateStop(int status)
 {
-	static ros::Timer stopping_timer;
-	static bool timerflag = false;
-	if(status){
-		if(current_velocity_ == 0.0 &amp;&amp; !timerflag){
-			stopping_timer = nh_.createTimer(ros::Duration(1), [&amp;](const ros::TimerEvent&amp;){ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE); ROS_INFO("Change state to keep from stop\n");timerflag=false; }, this, true);
-			timerflag = true;
-		}
-	}
+  static ros::Timer stopping_timer;
+  static bool timerflag = false;
+  if (status)
+  {
+    if (current_velocity_ == 0.0 &amp;&amp; !timerflag)
+    {
+      stopping_timer = nh_.createTimer(ros::Duration(1),
+                                       [&amp;](const ros::TimerEvent &amp;) {
+                                         ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE);
+                                         ROS_INFO("Change state to keep from stop\n");
+                                         timerflag = false;
+                                       },
+                                       this, true);
+      timerflag = true;
+    }
+  }
 }
 void DecisionMakerNode::changedStateObstacleAvoid(int status)
 {
-	createShiftLane();
-	publishControlledLaneArray();
+  createShiftLane();
+  publishControlledLaneArray();
+
+  static ros::Timer stopping_timer;
+  static bool timerflag = false;
+  stopping_timer = nh_.createTimer(ros::Duration(1),
+                                   [&amp;](const ros::TimerEvent &amp;) {
+                                     ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE);
+                                     ROS_INFO("Change state to null from obstacle avoid\n");
+                                   },
+                                   this, true);
 }
 void DecisionMakerNode::changedStateStop(int status)
 {
-	publishStoppedLaneArray();
+  publishStoppedLaneArray();
 }
 
 void DecisionMakerNode::updateStateSTR(int status)
 {
   autoware_msgs::lamp_cmd lamp_msg;
 
-  switch(status){
-	  case LAMP_LEFT:
-		  lamp_msg.l = LAMP_ON;
-		  lamp_msg.r = LAMP_OFF;
-		  break;
-	  case LAMP_RIGHT:
-		  lamp_msg.l = LAMP_OFF;
-		  lamp_msg.r = LAMP_ON;
-		  break;
-	  case LAMP_HAZARD:
-		  lamp_msg.l = LAMP_ON;
-		  lamp_msg.r = LAMP_ON;
-		  break;
-	  case LAMP_EMPTY:
-	  default:
-		  lamp_msg.l = LAMP_OFF;
-		  lamp_msg.r = LAMP_OFF;
-		  break;
+  switch (status)
+  {
+    case LAMP_LEFT:
+      lamp_msg.l = LAMP_ON;
+      lamp_msg.r = LAMP_OFF;
+      break;
+    case LAMP_RIGHT:
+      lamp_msg.l = LAMP_OFF;
+      lamp_msg.r = LAMP_ON;
+      break;
+    case LAMP_HAZARD:
+      lamp_msg.l = LAMP_ON;
+      lamp_msg.r = LAMP_ON;
+      break;
+    case LAMP_EMPTY:
+    default:
+      lamp_msg.l = LAMP_OFF;
+      lamp_msg.r = LAMP_OFF;
+      break;
   }
   Pubs["lamp_cmd"].publish(lamp_msg);
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9c9440b41c08ce3d1ff9dab315cf9b52390da1d1" author="Yusuke FUJII">
		<msg>change way to state management</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" added_lines="25" deleted_lines="22">
				<diff>@@ -20,18 +20,20 @@ namespace state_machine
 class StateContext
 {
 private:
+#if 0
   class StateHolder
   {
   public:
-    BaseState *MainState;
-    BaseState *AccState;
-    BaseState *StrState;
-    BaseState *BehaviorState;
-    BaseState *PerceptionState;
-    BaseState *OtherState;
+	  uint64_t MainState;
+	  uint64_t AccState;
+	  uint64_t StrState;
+	  uint64_t BehaviorState;
+	  uint64_t PerceptionState;
+	  uint64_t OtherState;
   } current_state_;
-
-  std::map&lt;uint8_t, BaseState **&gt; HolderMap;
+#endif
+  //std::map&lt;uint8_t, BaseState **&gt; HolderMap;
+  std::map&lt;uint8_t, uint64_t&gt; HolderMap;
   std::unordered_map&lt;uint64_t, BaseState *&gt; StateStores;
 
   bool enableForceSetState;
@@ -50,6 +52,7 @@ private:
 public:
   StateContext(void)
   {
+
     StateStores[START_STATE] = StartState::getInstance();
     StateStores[INITIAL_STATE] = InitialState::getInstance();
     StateStores[INITIAL_LOCATEVEHICLE_STATE] = LocateVehicleState::getInstance();
@@ -68,17 +71,13 @@ public:
     StateStores[MISSION_COMPLETE_STATE] = MissionCompleteState::getInstance();
     StateStores[EMERGENCY_STATE] = EmergencyState::getInstance();
 
-    HolderMap[MAIN_STATE] = &amp;current_state_.MainState;
-    HolderMap[ACC_STATE] = &amp;current_state_.AccState;
-    HolderMap[STR_STATE] = &amp;current_state_.StrState;
-    HolderMap[BEHAVIOR_STATE] = &amp;current_state_.BehaviorState;
-    HolderMap[PERCEPTION_STATE] = &amp;current_state_.PerceptionState;
-    HolderMap[OTHER_STATE] = &amp;current_state_.OtherState;
-
-    for (auto &amp;p : HolderMap)
-    {
-      *p.second = nullptr;
-    }
+    HolderMap[MAIN_STATE] 	=  0ULL;
+    HolderMap[ACC_STATE] 	=  0ULL;
+    HolderMap[STR_STATE] 	=  0ULL;
+    HolderMap[BEHAVIOR_STATE] 	=  0ULL;
+    HolderMap[PERCEPTION_STATE] =  0ULL;
+    HolderMap[OTHER_STATE] 	=  0ULL;
+
     thread_loop = true;
 
     this-&gt;InitContext();
@@ -97,18 +96,24 @@ public:
   bool isCurrentState(uint64_t _state_num);
   bool isCurrentState(uint8_t _state_kind, uint64_t _state_num);
   bool inState(uint64_t _state_num);
+  bool isDifferentState(uint64_t _state_a, uint64_t _state_b);
 
   bool setCurrentState(uint64_t flag);
   bool disableCurrentState(uint64_t);
 
+  BaseState *getStateObject(const uint64_t &amp;_state_num);
+  std::string getStateName(const uint64_t &amp;_state_num); 
+  uint8_t getStateKind(const uint64_t &amp;_state_num );
+
   BaseState *getCurrentMainState(void);
   BaseState *getCurrentState(void);
   std::string getCurrentStateName(void);
   std::string getStateName(void);
-  
+
   bool setChangedFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
   bool setUpdateFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
   
+  
   BaseState **getCurrentStateHolderPtr(uint8_t _kind);
   BaseState **getCurrentStateHolderPtr(uint64_t _state_num);
   BaseState **getCurrentStateHolderPtr(BaseState *_state);
@@ -118,14 +123,12 @@ public:
   uint64_t getStateNum(BaseState *_state);
   uint64_t getStateTransMask(BaseState *_state);
   bool isEmptyMainState(void);
-  bool isDifferentState(BaseState *_state_a, BaseState **_state_b);
   uint8_t getStateKind(BaseState *_state);
   bool isMainState(BaseState *_state);
 
   std::string getCurrentStateName(uint8_t kind);
 
   bool setEnableForceSetState(bool force_flag);
-  BaseState *getStateObject(uint64_t _state_num);
   void InitContext(void);
 
   bool TFInitialized(void);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" added_lines="8" deleted_lines="8">
				<diff>@@ -26,18 +26,18 @@ enum StateFlags
   DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE 		= 1UL &lt;&lt; 30,
   DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE 	= 1UL &lt;&lt; 31,
   DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE 	= 1UL &lt;&lt; 32,
-  STATE_END = 1 &lt;&lt; 20,
+  STATE_END = 1UL &lt;&lt; 33,
 };
 
 enum StateKinds
 {
-  MAIN_STATE,
-  ACC_STATE,
-  STR_STATE,
-  BEHAVIOR_STATE,
-  PERCEPTION_STATE,
-  OTHER_STATE,
-  UNKNOWN_STATE,
+  MAIN_STATE = 1,
+  ACC_STATE = 2,
+  STR_STATE = 3,
+  BEHAVIOR_STATE = 4,
+  PERCEPTION_STATE = 5,
+  OTHER_STATE = 6,
+  UNKNOWN_STATE = 7,
 };
 
 enum TrafficLightColors
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="92" deleted_lines="82">
				<diff>@@ -23,14 +23,15 @@
 
 namespace state_machine
 {
+
+
 void StateContext::update(void)
 {
   for (auto &amp;p : HolderMap)
   {
-    if (*p.second)
-    {
-      (*p.second)-&gt;update();
-    }
+    if (p.second)
+	    if(getStateObject(p.second))
+		    getStateObject(p.second)-&gt;update();
   }
 }
 
@@ -39,9 +40,31 @@ void StateContext::changed(uint8_t _kind)
 	if(_kind &gt;  UNKNOWN_STATE){
 		return;
 	}
+	if(getStateObject(HolderMap[_kind]))
+		getStateObject(HolderMap[_kind])-&gt;changed();
+}
+
+
+BaseState *StateContext::getStateObject(const uint64_t &amp;_state_num)
+{
+	uint64_t _state_num_MSB = _state_num;
+	if(_state_num){
+		if(StateStores[_state_num]){
+			return StateStores[_state_num];
+		}else{
+			for(uint64_t mask = STATE_END; mask &gt; 0; mask&gt;&gt;=1){
+				if(mask &amp; _state_num)
+				{
+					_state_num_MSB = mask;
+					break;
+				}
+			}
+			return StateStores[_state_num_MSB];
+
+		}
 
-	if(*HolderMap[_kind])
-		(*HolderMap[_kind])-&gt;changed();
+	}
+	return nullptr;
 }
 
 bool StateContext::setUpdateFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f)
@@ -55,43 +78,61 @@ bool StateContext::setChangedFunc(const uint64_t &amp;_state_num, const std::functio
 			getStateObject(_state_num)-&gt;setChangedFunc(_f);
 }
 
+std::string StateContext::getStateName(const uint64_t &amp;_state_num)
+{
+	if(getStateObject(_state_num)){
+		return getStateObject(_state_num)-&gt;getStateName();
+	}else 
+		return "";
+}
+
+uint64_t StateContext::getStateNum(BaseState *_state)
+{
+  if (_state){
+	  return _state-&gt;getStateNum();
+  }else
+	  return 0;
+}
+
+uint8_t StateContext::getStateKind(BaseState *_state)
+{
+	if (_state){
+		return _state-&gt;getStateKind();
+	}else
+		return UNKNOWN_STATE;
+}
+
+uint8_t StateContext::getStateKind(const uint64_t &amp;_state_num)
+{
+	if (_state_num){
+		return getStateKind(getStateObject(_state_num));
+	}
+	return UNKNOWN_STATE;
+}
 
 
 void StateContext::showCurrentStateName(void)
 {
   for (auto &amp;p : HolderMap)
   {
-    if (*p.second)
-    {
-      (*p.second)-&gt;showStateName();
-    }
+    if (p.second)
+	    if(getStateObject(p.second))
+		    getStateObject(p.second)-&gt;showStateName();
   }
 }
 
-bool StateContext::isDifferentState(BaseState *_state_a, BaseState **_state_b)
+bool StateContext::isDifferentState(uint64_t _state_a, uint64_t _state_b)
 {
-	if(_state_b){
-		return _state_a == *_state_b;
-	}else{
-		return false;
-	}
+	return _state_a == _state_b;
 }
 
 bool StateContext::isEmptyMainState(void)
 {
-  if (current_state_.MainState)
+  if (HolderMap[MAIN_STATE])
     return false;
   return true;
 }
 
-uint8_t StateContext::getStateKind(BaseState *_state)
-{
-  if (_state)
-    return _state-&gt;getStateKind();
-  else
-    return UNKNOWN_STATE;
-}
-
 uint64_t StateContext::getStateTransMask(BaseState *_state)
 {
   if (_state)
@@ -100,14 +141,6 @@ uint64_t StateContext::getStateTransMask(BaseState *_state)
     return 0;
 }
 
-uint64_t StateContext::getStateNum(BaseState *_state)
-{
-  if (_state)
-    return _state-&gt;getStateNum();
-  else
-    return 0;
-}
-
 bool StateContext::isMainState(BaseState *_state)
 {
   return getStateKind(_state) == MAIN_STATE;
@@ -118,18 +151,19 @@ bool StateContext::setCurrentState(BaseState *_state)
   change_state_mutex.lock();
   bool ret = true;
   if(_state){
-	  bool diff = isDifferentState(_state, getCurrentStateHolderPtr(_state));
+	  bool diff = isDifferentState(getStateNum(_state), HolderMap[getStateKind(_state)]);
 	  if (isMainState(_state))
 	  {
 		  if (isEmptyMainState() || enableForceSetState ||
-				  (getStateTransMask(_state) &amp; getStateNum(current_state_.MainState)))
+				  (getStateTransMask(_state) &amp; HolderMap[MAIN_STATE]))
 		  {
-			  current_state_.MainState = _state;
-			  current_state_.AccState = nullptr;
-			  current_state_.StrState = nullptr;
-			  current_state_.BehaviorState = nullptr;
-			  current_state_.PerceptionState = nullptr;
-			  current_state_.OtherState = nullptr;
+			  for(auto &amp;state : HolderMap){
+				  if(state.first == MAIN_STATE){
+					  state.second = getStateNum(_state);
+				  }else{
+					  state.second = 0ULL;
+				  }
+			  }
 		  }
 		  else
 		  {
@@ -138,7 +172,8 @@ bool StateContext::setCurrentState(BaseState *_state)
 	  }
 	  else
 	  {
-		  *HolderMap[getStateKind(_state)] = _state;
+		  fprintf(stderr,"[%s]:%lx:%s\n",__func__, getStateNum(_state), getStateName(getStateNum(_state)).c_str());
+		  HolderMap[getStateKind(_state)] = getStateNum(_state);
 	  }
 	  change_state_mutex.unlock();
 	  if(ret &amp;&amp; !diff)
@@ -162,49 +197,22 @@ bool StateContext::setEnableForceSetState(bool force_flag)
   return true;
 }
 
-std::string StateContext::getCurrentStateName(uint8_t _kind)
-{
-	if (*HolderMap[_kind])
-		return (*HolderMap[_kind])-&gt;getStateName();
-	return std::string("");
-}
-
 std::string StateContext::getCurrentStateName(void)
 {
   return this-&gt;getCurrentStateName(MAIN_STATE);
 }
 
-BaseState *StateContext::getCurrentMainState(void)
-{
-  return current_state_.MainState;
-}
-
-BaseState *StateContext::getStateObject(uint64_t _state_num)
-{
-  return StateStores[_state_num];
-}
-
-
-
-BaseState **StateContext::getCurrentStateHolderPtr(uint8_t _kind)
+std::string StateContext::getCurrentStateName(uint8_t _kind)
 {
-	if(_kind &gt;  UNKNOWN_STATE){
-		return nullptr;
+	if (HolderMap[_kind]){
+		return getStateName(HolderMap[_kind]);
 	}
-	return HolderMap[_kind];
-}
-
-BaseState **StateContext::getCurrentStateHolderPtr(uint64_t _state_num)
-{
-  return getCurrentStateHolderPtr(getStateKind(getStateObject(_state_num)));
+	return std::string("");
 }
 
-BaseState **StateContext::getCurrentStateHolderPtr(BaseState *_state)
+BaseState *StateContext::getCurrentMainState(void)
 {
-	if(_state)
-		return getCurrentStateHolderPtr(getStateKind(_state));
-	else
-		return nullptr;
+	return getStateObject(HolderMap[MAIN_STATE]);
 }
 
 bool StateContext::disableCurrentState(uint64_t _state_num)
@@ -213,7 +221,7 @@ bool StateContext::disableCurrentState(uint64_t _state_num)
 		return false;
 	}
 	if(isCurrentState(_state_num)){
-		(*getCurrentStateHolderPtr(_state_num)) = nullptr;
+		HolderMap[getStateKind(_state_num)] &amp;= _state_num;
 		return true;
 	}else{
 		return false;
@@ -222,8 +230,10 @@ bool StateContext::disableCurrentState(uint64_t _state_num)
 
 bool StateContext::isCurrentState(uint64_t _state_num)
 {
-	  BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
-	  return  (state_ptr) ?isState(*state_ptr, _state_num):false;
+	if(_state_num)
+	  return HolderMap[getStateKind(_state_num)] &amp; _state_num;
+	else
+	  return false;
 }
 
 bool StateContext::isState(BaseState *base, uint64_t _state_num)
@@ -233,9 +243,9 @@ bool StateContext::isState(BaseState *base, uint64_t _state_num)
 
 bool StateContext::inState(uint64_t _state_num)
 {
-  if (current_state_.MainState)
+  if (HolderMap[MAIN_STATE])
   {
-    return ((current_state_.MainState-&gt;getStateNum() &amp; _state_num) != 0) ? true : false;
+    return ((HolderMap[MAIN_STATE] &amp; _state_num) != 0) ? true : false;
   }
   else
   {
@@ -255,9 +265,9 @@ std::string StateContext::createStateMessageText(void)
 
   for (auto &amp;p : HolderMap)
   {
-    if (*p.second)
+    if (p.second)
     {
-      ret = ret + "\n" + (*p.second)-&gt;getStateName();
+      ret = ret + "\n" + getStateName(p.second);
     }
   }
   return ret;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="0ebaa0eb4da1c7545eafce7d7fa4bde07657b679" author="Yusuke FUJII">
		<msg>add to able to have multiple-state</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" added_lines="11" deleted_lines="21">
				<diff>@@ -36,8 +36,7 @@ private:
   DriveAccAccelerationState(void)
   {
     StateName = "Accelerate";
-    StateNum = DRIVE_STATE | DRIVE_ACC_ACCELERATION_STATE;
-    StateTransMask = DRIVE_STATE;
+    StateNum = DRIVE_ACC_ACCELERATION_STATE;
     StateKind = ACC_STATE;
   }
 
@@ -55,8 +54,7 @@ private:
   DriveAccDecelerationState(void)
   {
     StateName = "Decelerate";
-    StateNum = DRIVE_STATE | DRIVE_ACC_DECELERATION_STATE;
-    StateTransMask = DRIVE_STATE;
+    StateNum = DRIVE_ACC_DECELERATION_STATE;
     StateKind = ACC_STATE;
   }
 
@@ -70,8 +68,7 @@ private:
   DriveAccKeepState(void)
   {
     StateName = "Keep";
-    StateNum = DRIVE_STATE | DRIVE_ACC_KEEP_STATE;
-    StateTransMask = DRIVE_STATE;
+    StateNum = DRIVE_ACC_KEEP_STATE;
     StateKind = ACC_STATE;
   }
 
@@ -85,8 +82,7 @@ private:
   DriveAccStopState(void)
   {
     StateName = "Stop";
-    StateNum = DRIVE_STATE | DRIVE_ACC_STOP_STATE;
-    StateTransMask = DRIVE_STATE;
+    StateNum =  DRIVE_ACC_STOP_STATE;
     StateKind = ACC_STATE;
   }
 
@@ -100,8 +96,7 @@ private:
   DriveAccStopLineState(void)
   {
     StateName = "StopLine";
-    StateNum = DRIVE_STATE |  DRIVE_ACC_STOPLINE_STATE;
-    StateTransMask = DRIVE_STATE;
+    StateNum =  DRIVE_ACC_STOPLINE_STATE;
     StateKind = ACC_STATE;
   }
 
@@ -115,8 +110,7 @@ private:
   DriveStrLeftState(void)
   {
     StateName = "Left Turn";
-    StateNum = DRIVE_STATE | DRIVE_STR_LEFT_STATE;
-    StateTransMask = DRIVE_STATE;
+    StateNum = DRIVE_STR_LEFT_STATE;
     StateKind = STR_STATE;
   }
 
@@ -129,8 +123,7 @@ private:
   DriveStrRightState(void)
   {
     StateName = "Right Turn";
-    StateNum = DRIVE_STATE | DRIVE_STR_RIGHT_STATE;
-    StateTransMask = DRIVE_STATE;
+    StateNum = DRIVE_STR_RIGHT_STATE;
     StateKind = STR_STATE;
   }
 
@@ -143,8 +136,7 @@ private:
   DriveStrStraightState(void)
   {
     StateName = "Straight";
-    StateNum = DRIVE_STATE | DRIVE_STR_STRAIGHT_STATE;
-    StateTransMask = DRIVE_STATE;
+    StateNum = DRIVE_STR_STRAIGHT_STATE;
     StateKind = STR_STATE;
   }
 
@@ -158,8 +150,7 @@ private:
   DriveBehaviorLaneChangeLeftState(void)
   {
     StateName = "LaneChangeLeft";
-    StateNum = DRIVE_STATE | DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE;
-    StateTransMask = DRIVE_STATE;
+    StateNum = DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE;
     StateKind = BEHAVIOR_STATE;
   }
 
@@ -173,8 +164,7 @@ private:
   DriveBehaviorLaneChangeRightState(void)
   {
     StateName = "LaneChangeRight";
-    StateNum = DRIVE_STATE | DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE;
-    StateTransMask = DRIVE_STATE;
+    StateNum = DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE;
     StateKind = BEHAVIOR_STATE;
   }
 
@@ -188,7 +178,7 @@ private:
   DriveBehaviorObstacleAvoidanceState(void)
   {
     StateName = "ObstacleAvoidance";
-    StateTransMask = DRIVE_STATE;
+    StateNum = DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE;
     StateKind = BEHAVIOR_STATE;
   }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" added_lines="15" deleted_lines="12">
				<diff>@@ -13,20 +13,23 @@ enum StateFlags
   MISSION_COMPLETE_STATE 	= 1UL &lt;&lt; 5,
   EMERGENCY_STATE 		= 1UL &lt;&lt; 6,
  
-  DRIVE_ACC_ACCELERATION_STATE 	= 1UL &lt;&lt; 10,
-  DRIVE_ACC_DECELERATION_STATE 	= 1UL &lt;&lt; 11,
-  DRIVE_ACC_KEEP_STATE		= 1UL &lt;&lt; 12,
-  DRIVE_ACC_STOP_STATE 		= 1UL &lt;&lt; 13,
-  DRIVE_ACC_STOPLINE_STATE 	= 1UL &lt;&lt; 14,
+  DRIVE_SUB_STATE_START		= 1UL &lt;&lt; 10,
+
+  DRIVE_ACC_ACCELERATION_STATE 	= 1UL &lt;&lt; 11,
+  DRIVE_ACC_DECELERATION_STATE 	= 1UL &lt;&lt; 12,
+  DRIVE_ACC_KEEP_STATE		= 1UL &lt;&lt; 13,
+  DRIVE_ACC_STOP_STATE 		= 1UL &lt;&lt; 14,
+  DRIVE_ACC_STOPLINE_STATE 	= 1UL &lt;&lt; 15,
   
-  DRIVE_STR_STRAIGHT_STATE 	= 1UL &lt;&lt; 20,
-  DRIVE_STR_LEFT_STATE 		= 1UL &lt;&lt; 21,
-  DRIVE_STR_RIGHT_STATE 	= 1UL &lt;&lt; 22,
+  DRIVE_STR_STRAIGHT_STATE 	= 1UL &lt;&lt; 21,
+  DRIVE_STR_LEFT_STATE 		= 1UL &lt;&lt; 22,
+  DRIVE_STR_RIGHT_STATE 	= 1UL &lt;&lt; 23,
  
-  DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE 		= 1UL &lt;&lt; 30,
-  DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE 	= 1UL &lt;&lt; 31,
-  DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE 	= 1UL &lt;&lt; 32,
-  STATE_END = 1UL &lt;&lt; 33,
+  DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE 		= 1UL &lt;&lt; 31,
+  DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE 	= 1UL &lt;&lt; 32,
+  DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE 	= 1UL &lt;&lt; 33,
+  STATE_SUB_END = 1UL &lt;&lt; 40,
+  STATE_END = 1UL &lt;&lt; 41,
 };
 
 enum StateKinds
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="24" deleted_lines="18">
				<diff>@@ -47,22 +47,10 @@ void StateContext::changed(uint8_t _kind)
 
 BaseState *StateContext::getStateObject(const uint64_t &amp;_state_num)
 {
-	uint64_t _state_num_MSB = _state_num;
 	if(_state_num){
 		if(StateStores[_state_num]){
 			return StateStores[_state_num];
-		}else{
-			for(uint64_t mask = STATE_END; mask &gt; 0; mask&gt;&gt;=1){
-				if(mask &amp; _state_num)
-				{
-					_state_num_MSB = mask;
-					break;
-				}
-			}
-			return StateStores[_state_num_MSB];
-
 		}
-
 	}
 	return nullptr;
 }
@@ -172,8 +160,11 @@ bool StateContext::setCurrentState(BaseState *_state)
 	  }
 	  else
 	  {
-		  fprintf(stderr,"[%s]:%lx:%s\n",__func__, getStateNum(_state), getStateName(getStateNum(_state)).c_str());
-		  HolderMap[getStateKind(_state)] = getStateNum(_state);
+		  if(getStateKind(_state) == BEHAVIOR_STATE){
+			  HolderMap[getStateKind(_state)] |= getStateNum(_state);
+		  }else{
+			  HolderMap[getStateKind(_state)] = getStateNum(_state);
+		  }
 	  }
 	  change_state_mutex.unlock();
 	  if(ret &amp;&amp; !diff)
@@ -187,8 +178,8 @@ bool StateContext::setCurrentState(BaseState *_state)
 
 bool StateContext::setCurrentState(uint64_t flag)
 {
-  bool ret = this-&gt;setCurrentState(StateStores[flag]);
-  return ret;
+	bool ret = this-&gt;setCurrentState(getStateObject(flag));
+	return ret;
 }
 
 bool StateContext::setEnableForceSetState(bool force_flag)
@@ -205,7 +196,22 @@ std::string StateContext::getCurrentStateName(void)
 std::string StateContext::getCurrentStateName(uint8_t _kind)
 {
 	if (HolderMap[_kind]){
-		return getStateName(HolderMap[_kind]);
+		if(_kind == BEHAVIOR_STATE){
+			uint64_t _current_state = HolderMap[_kind];
+			std::string ret = "";
+			for(uint64_t mask = STATE_SUB_END; _current_state != 0 &amp;&amp; mask != 0; mask &gt;&gt;=1){
+				if(mask &amp; _current_state){
+					ret += "\n" + getStateName(mask);
+					_current_state &amp;= ~mask;
+					fprintf(stderr,"[%s]:::::%s\n",__func__,getStateName(mask).c_str());
+				}
+				fprintf(stderr,"[%s]:%lx:%lx\n",__func__,_current_state, mask);
+			}
+			return ret;
+
+		}else{
+			return getStateName(HolderMap[_kind]);
+		}
 	}
 	return std::string("");
 }
@@ -221,7 +227,7 @@ bool StateContext::disableCurrentState(uint64_t _state_num)
 		return false;
 	}
 	if(isCurrentState(_state_num)){
-		HolderMap[getStateKind(_state_num)] &amp;= _state_num;
+		HolderMap[getStateKind(_state_num)] &amp;= ~_state_num;
 		return true;
 	}else{
 		return false;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b49bb5c01b6553c6f5954a6703587b2729107e11" author="Yusuke FUJII">
		<msg>Fixed:
- callback
- laneshift
Added:
- publisher for laneid
- new lanechange flag
- new param for decisionMaker</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" added_lines="26" deleted_lines="14">
				<diff>@@ -47,14 +47,16 @@ protected:
 
 public:
   virtual void update(void) = 0;
-  virtual void changed(void) = 0;
+  virtual void inState(void) = 0;
+  virtual void outState(void) = 0;
   virtual void showStateName(void) = 0;
   virtual uint64_t getStateTransMask(void) = 0;
   virtual uint64_t getStateNum(void) = 0;
   virtual std::string getStateName(void) = 0;
   virtual uint8_t getStateKind(void) = 0;
-  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f) = 0;
-  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f) = 0;
+  virtual void setCallbackUpdateFunc(std::function&lt;void(void)&gt; _f) = 0;
+  virtual void setCallbackInFunc(std::function&lt;void(void)&gt; _f) = 0;
+  virtual void setCallbackOutFunc(std::function&lt;void(void)&gt; _f) = 0;
 };
 
 // Interface
@@ -67,8 +69,9 @@ protected:
   uint64_t StateTransMask;
   uint8_t StateKind;
 
-  std::function&lt;void(void)&gt; StateUpdateFunc;
-  std::function&lt;void(void)&gt; StateChangedFunc;
+  std::function&lt;void(void)&gt; StateCallbackUpdateFunc;
+  std::function&lt;void(void)&gt; StateCallbackInFunc;
+  std::function&lt;void(void)&gt; StateCallbackOutFunc;
 
   State()
   {
@@ -80,24 +83,33 @@ protected:
 public:
   virtual void update(void)
   {
-    if (StateUpdateFunc)
-      StateUpdateFunc();
+    if (StateCallbackUpdateFunc)
+      StateCallbackUpdateFunc();
   }
 
-  virtual void changed(void)
+  virtual void inState(void)
   {
-    if (StateChangedFunc)
-	    StateChangedFunc();
+    if (StateCallbackInFunc)
+	    StateCallbackInFunc();
+  }
+  virtual void outState(void)
+  {
+    if (StateCallbackOutFunc)
+	    StateCallbackOutFunc();
+  }
+  virtual void setCallbackUpdateFunc(std::function&lt;void(void)&gt; _f)
+  {
+    StateCallbackUpdateFunc = _f;
   }
 
-  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f)
+  virtual void setCallbackOutFunc(std::function&lt;void(void)&gt; _f)
   {
-    StateUpdateFunc = _f;
+    StateCallbackOutFunc = _f;
   }
 
-  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f)
+  virtual void setCallbackInFunc(std::function&lt;void(void)&gt; _f)
   {
-    StateChangedFunc = _f;
+    StateCallbackInFunc = _f;
   }
 
   void showStateName(void)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" added_lines="9" deleted_lines="17">
				<diff>@@ -20,19 +20,7 @@ namespace state_machine
 class StateContext
 {
 private:
-#if 0
-  class StateHolder
-  {
-  public:
-	  uint64_t MainState;
-	  uint64_t AccState;
-	  uint64_t StrState;
-	  uint64_t BehaviorState;
-	  uint64_t PerceptionState;
-	  uint64_t OtherState;
-  } current_state_;
-#endif
-  //std::map&lt;uint8_t, BaseState **&gt; HolderMap;
+  
   std::map&lt;uint8_t, uint64_t&gt; HolderMap;
   std::unordered_map&lt;uint64_t, BaseState *&gt; StateStores;
 
@@ -89,13 +77,13 @@ public:
   }
 
   void update(void);
-  void changed(uint8_t _kind);
+  void inState(uint8_t _kind, uint64_t _prev_state_num);
+  void OutState(uint8_t _kind);
   void stateDecider(void);
 
   bool isState(BaseState *base, uint64_t _state_num);
   bool isCurrentState(uint64_t _state_num);
   bool isCurrentState(uint8_t _state_kind, uint64_t _state_num);
-  bool inState(uint64_t _state_num);
   bool isDifferentState(uint64_t _state_a, uint64_t _state_b);
 
   bool setCurrentState(uint64_t flag);
@@ -110,8 +98,12 @@ public:
   std::string getCurrentStateName(void);
   std::string getStateName(void);
 
-  bool setChangedFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
-  bool setUpdateFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
+
+  std::vector&lt;BaseState*&gt; getMultipleStates(uint64_t _state_num_set);
+
+  bool setCallbackInFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
+  bool setCallbackOutFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
+  bool setCallbackUpdateFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
   
   
   BaseState **getCurrentStateHolderPtr(uint8_t _kind);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="52" deleted_lines="28">
				<diff>@@ -24,24 +24,47 @@
 namespace state_machine
 {
 
+std::vector&lt;BaseState *&gt; StateContext::getMultipleStates(uint64_t _state_num_set)
+{
+	std::vector&lt;BaseState *&gt; ret;
+	for(uint64_t mask = STATE_SUB_END; _state_num_set!= 0 &amp;&amp; mask != 0; mask &gt;&gt;=1){
+		if(mask &amp; _state_num_set){
+			ret.push_back(getStateObject(mask));
+			_state_num_set &amp;= ~mask;
+		}
+	}
+	return ret;
+}
 
 void StateContext::update(void)
 {
   for (auto &amp;p : HolderMap)
   {
-    if (p.second)
-	    if(getStateObject(p.second))
-		    getStateObject(p.second)-&gt;update();
+    if (p.first == BEHAVIOR_STATE){
+	    for(auto &amp;&amp;state :  getMultipleStates(p.second)){
+			state-&gt;update();
+	    }
+    }else{
+	    if (p.second)
+		    if(getStateObject(p.second))
+			    getStateObject(p.second)-&gt;update();
+    }
   }
 }
 
-void StateContext::changed(uint8_t _kind)
+void StateContext::inState(uint8_t _kind, uint64_t _prev_state_num)
 {
 	if(_kind &gt;  UNKNOWN_STATE){
 		return;
+	}else if(_kind == BEHAVIOR_STATE){
+	    for(auto &amp;&amp;state :  getMultipleStates(HolderMap[_kind])){
+	    	if(!(_prev_state_num &amp; getStateNum(state)))
+		    state-&gt;inState();
+	    }
+	}else{
+		if(getStateObject(HolderMap[_kind]))
+			getStateObject(HolderMap[_kind])-&gt;inState();
 	}
-	if(getStateObject(HolderMap[_kind]))
-		getStateObject(HolderMap[_kind])-&gt;changed();
 }
 
 
@@ -55,17 +78,23 @@ BaseState *StateContext::getStateObject(const uint64_t &amp;_state_num)
 	return nullptr;
 }
 
-bool StateContext::setUpdateFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f)
+bool StateContext::setCallbackUpdateFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f)
+{
+	if(getStateObject(_state_num))
+			getStateObject(_state_num)-&gt;setCallbackUpdateFunc(_f);
+}
+bool StateContext::setCallbackInFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f)
 {
 	if(getStateObject(_state_num))
-			getStateObject(_state_num)-&gt;setUpdateFunc(_f);
+			getStateObject(_state_num)-&gt;setCallbackInFunc(_f);
 }
-bool StateContext::setChangedFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f)
+bool StateContext::setCallbackOutFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f)
 {
 	if(getStateObject(_state_num))
-			getStateObject(_state_num)-&gt;setChangedFunc(_f);
+			getStateObject(_state_num)-&gt;setCallbackOutFunc(_f);
 }
 
+
 std::string StateContext::getStateName(const uint64_t &amp;_state_num)
 {
 	if(getStateObject(_state_num)){
@@ -111,7 +140,7 @@ void StateContext::showCurrentStateName(void)
 
 bool StateContext::isDifferentState(uint64_t _state_a, uint64_t _state_b)
 {
-	return _state_a == _state_b;
+	return !(_state_a &amp; _state_b);
 }
 
 bool StateContext::isEmptyMainState(void)
@@ -139,7 +168,8 @@ bool StateContext::setCurrentState(BaseState *_state)
   change_state_mutex.lock();
   bool ret = true;
   if(_state){
-	  bool diff = isDifferentState(getStateNum(_state), HolderMap[getStateKind(_state)]);
+	  uint64_t prev_state = HolderMap[getStateKind(_state)];
+	  bool diff =  isDifferentState(getStateNum(_state), HolderMap[getStateKind(_state)]);
 	  if (isMainState(_state))
 	  {
 		  if (isEmptyMainState() || enableForceSetState ||
@@ -167,8 +197,14 @@ bool StateContext::setCurrentState(BaseState *_state)
 		  }
 	  }
 	  change_state_mutex.unlock();
-	  if(ret &amp;&amp; !diff)
-		  this-&gt;changed(getStateKind(_state));
+	  if(ret &amp;&amp; diff){
+		  this-&gt;inState(getStateKind(_state), prev_state);
+		  
+		  if(getStateKind(_state) == getStateKind(prev_state) &amp;&amp; 
+				  getStateKind(_state)!= BEHAVIOR_STATE)
+			  if(getStateObject(prev_state))
+					  getStateObject(prev_state)-&gt;outState();
+	  }
   }else{
 	  change_state_mutex.unlock();
 	  ret = false;
@@ -203,9 +239,7 @@ std::string StateContext::getCurrentStateName(uint8_t _kind)
 				if(mask &amp; _current_state){
 					ret += "\n" + getStateName(mask);
 					_current_state &amp;= ~mask;
-					fprintf(stderr,"[%s]:::::%s\n",__func__,getStateName(mask).c_str());
 				}
-				fprintf(stderr,"[%s]:%lx:%lx\n",__func__,_current_state, mask);
 			}
 			return ret;
 
@@ -228,6 +262,8 @@ bool StateContext::disableCurrentState(uint64_t _state_num)
 	}
 	if(isCurrentState(_state_num)){
 		HolderMap[getStateKind(_state_num)] &amp;= ~_state_num;
+		getStateObject(_state_num)-&gt;outState();
+		fprintf(stderr,"[%s]:%d:%lx\n",__func__,__LINE__,_state_num);
 		return true;
 	}else{
 		return false;
@@ -247,18 +283,6 @@ bool StateContext::isState(BaseState *base, uint64_t _state_num)
   return base ? base-&gt;getStateNum() &amp; _state_num ? true : false : false;
 }
 
-bool StateContext::inState(uint64_t _state_num)
-{
-  if (HolderMap[MAIN_STATE])
-  {
-    return ((HolderMap[MAIN_STATE] &amp; _state_num) != 0) ? true : false;
-  }
-  else
-  {
-    return false;
-  }
-}
-
 bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
 {
   /* deprecated */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="12" deleted_lines="5">
				<diff>@@ -97,6 +97,7 @@ private:
   autoware_msgs::LaneArray current_stopped_lane_array_; // 0velocity
 
 
+
   // Current way/behavior status
   double current_velocity_;
   double average_velocity_;
@@ -128,6 +129,7 @@ private:
   bool vMap_CrossRoads_flag;
   bool SimulationMode;
   std::mutex vMap_mutex;
+  bool created_shift_lane_flag_;
 
   // initialization method
   void initROS(int argc, char **argv);
@@ -167,15 +169,19 @@ private:
   void changeVelocityBasedLane(void);
   void changeVelocityLane(int dir);
   void createShiftLane(void);
+  void changeShiftLane(void);
+  void removeShiftLane(void);
   
-  void changedStateObstacleAvoid(int status);
+  void callbackInStateObstacleAvoid(int status);
+  void callbackOutStateObstacleAvoid(int status);
+  void updateStateObstacleAvoid(int status);
   
   void updateStateSTR(int status);
   void updateStateStop(int status);
-  void changedStateStop(int status);
-  void changedStateAcc(int status);
-  void changedStateDec(int status);
-  void changedStateKeep(int status);
+  void callbackInStateStop(int status);
+  void callbackInStateAcc(int status);
+  void callbackInStateDec(int status);
+  void callbackInStateKeep(int status);
   void setupStateCallback(void);
   // callback by topic subscribing
   void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
@@ -213,6 +219,7 @@ public:
     this-&gt;initROS(argc, argv);
 
     vector_map_init = false;
+    created_shift_lane_flag_ = false;
 
     vMap_Areas_flag = vMap_Lines_flag = vMap_Points_flag = vMap_CrossRoads_flag = false;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="20" deleted_lines="12">
				<diff>@@ -33,7 +33,11 @@ bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
 {
   bool _ret;
   ctx-&gt;setEnableForceSetState(true);
-  _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
+  if(!ctx-&gt;isCurrentState(_state_num)){
+	  _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
+  }else{
+	  _ret = ctx-&gt;disableCurrentState((state_machine::StateFlags)_state_num);
+  }
   ctx-&gt;setEnableForceSetState(false);
   return _ret;
 }
@@ -47,21 +51,25 @@ void DecisionMakerNode::callbackFromSimPose(const geometry_msgs::PoseStamped &amp;ms
 
 void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
 {
-  ROS_INFO("Received forcing state changing request");
-  handleStateCmd((unsigned long long)1 &lt;&lt; msg.data);
+  ROS_INFO("Received forcing state changing request: %lx", 1ULL &lt;&lt; (uint64_t)msg.data);
+  handleStateCmd((uint64_t)1ULL &lt;&lt; (uint64_t)msg.data);
 }
 
 void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
 {
-  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
-    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
-  else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
-    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
-  else
-  {
-    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
-    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
-  }
+	if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT)){
+		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
+		ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
+	}
+	else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT)){
+		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
+		ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
+	}
+	else
+	{
+		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
+		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
+	}
 }
 
 void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -108,8 +108,8 @@ void DecisionMakerNode::displayMarker(void)
       marker_array.markers.push_back(inside_line_marker);
     }
   }
-  inside_line_marker.scale.x = 0.1;  // 0.3;
-  inside_line_marker.scale.y = 0.1;  // 0.3;
+  inside_line_marker.scale.x = 0.2;  // 0.3;
+  inside_line_marker.scale.y = 0.2;  // 0.3;
   int id = inside_line_marker.id;
   inside_line_marker.color.r = 0;
   inside_line_marker.color.g = 1;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="128" deleted_lines="62">
				<diff>@@ -11,67 +11,89 @@ namespace decision_maker
 {
 void DecisionMakerNode::setupStateCallback(void)
 {
-  ctx-&gt;setUpdateFunc(state_machine::DRIVE_STR_LEFT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 1));
-  ctx-&gt;setUpdateFunc(state_machine::DRIVE_STR_RIGHT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));
-  ctx-&gt;setUpdateFunc(state_machine::DRIVE_STR_STRAIGHT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
-  ctx-&gt;setUpdateFunc(state_machine::DRIVE_ACC_STOPLINE_STATE, std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
-  ctx-&gt;setUpdateFunc(state_machine::DRIVE_ACC_STOP_STATE, std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_LEFT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 1));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_RIGHT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_STRAIGHT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOPLINE_STATE, std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOP_STATE, std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));
 
-  ctx-&gt;setChangedFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
-                      std::bind(&amp;DecisionMakerNode::changedStateStop, this, 1));
-  ctx-&gt;setChangedFunc(state_machine::DRIVE_ACC_STOP_STATE, std::bind(&amp;DecisionMakerNode::changedStateStop, this, 0));
-  ctx-&gt;setChangedFunc(state_machine::DRIVE_ACC_KEEP_STATE, std::bind(&amp;DecisionMakerNode::changedStateKeep, this, 1));
-  ctx-&gt;setChangedFunc(state_machine::DRIVE_ACC_ACCELERATION_STATE,
-                      std::bind(&amp;DecisionMakerNode::changedStateAcc, this, 1));
-  ctx-&gt;setChangedFunc(state_machine::DRIVE_ACC_DECELERATION_STATE,
-                      std::bind(&amp;DecisionMakerNode::changedStateAcc, this, -1));
+  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
+                      std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 1));
+  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOP_STATE, std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 0));
+  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_KEEP_STATE, std::bind(&amp;DecisionMakerNode::callbackInStateKeep, this, 1));
+  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_ACCELERATION_STATE,
+                      std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 1));
+  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_DECELERATION_STATE,
+                      std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, -1));
 
-  ctx-&gt;setChangedFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
-                      std::bind(&amp;DecisionMakerNode::changedStateObstacleAvoid, this, -1));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
+                      std::bind(&amp;DecisionMakerNode::updateStateObstacleAvoid, this, -1));
+  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
+                      std::bind(&amp;DecisionMakerNode::callbackInStateObstacleAvoid, this, -1));
+  ctx-&gt;setCallbackOutFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
+                      std::bind(&amp;DecisionMakerNode::callbackOutStateObstacleAvoid, this, 1));
 }
 
 void DecisionMakerNode::createShiftLane(void)
 {
-  autoware_msgs::lane shift_lane;
-  if (!current_shifted_lane_array_.lanes.empty())
+  if(!created_shift_lane_flag_)
   {
-    shift_lane = current_shifted_lane_array_.lanes.at(0);
-    size_t idx = 0;
-    for (auto &amp;wp : shift_lane.waypoints)
-    {
-      double current_angle = getPoseAngle(wp.pose.pose);
-      wp.pose.pose.position.x -= param_shift_width_ * cos(current_angle + M_PI / 2);
-      wp.pose.pose.position.y -= param_shift_width_ * sin(current_angle + M_PI / 2);
-      wp.change_flag = current_based_lane_array_.lanes.at(0).waypoints.at(idx++).change_flag;
-    }
-    auto it = current_shifted_lane_array_.lanes.insert(current_shifted_lane_array_.lanes.begin() + 1, shift_lane);
+	  created_shift_lane_flag_ = true;
+	  autoware_msgs::lane shift_lane;
+	  current_shifted_lane_array_ = current_based_lane_array_;
+	  if (!current_shifted_lane_array_.lanes.empty())
+	  {
+		  shift_lane = current_shifted_lane_array_.lanes.at(0);
+		  size_t idx = 0;
+		  for (auto &amp;wp : shift_lane.waypoints)
+		  {
+			  double current_angle = getPoseAngle(wp.pose.pose);
+			  wp.pose.pose.position.x -= param_shift_width_ * cos(current_angle + M_PI / 2);
+			  wp.pose.pose.position.y -= param_shift_width_ * sin(current_angle + M_PI / 2);
+			  wp.change_flag = current_based_lane_array_.lanes.at(0).waypoints.at(idx++).change_flag;
+		  }
+		  auto it = current_shifted_lane_array_.lanes.insert(current_shifted_lane_array_.lanes.begin() + 1, shift_lane);
 
-    for (auto &amp;wp : current_shifted_lane_array_.lanes.at(0).waypoints)
-    {
-      wp.change_flag = 1;
-    }
+		  for (auto &amp;wp : current_shifted_lane_array_.lanes.at(0).waypoints)
+		  {
+			  wp.change_flag = 1;
+		  }
+	  }
   }
 }
 
+void DecisionMakerNode::changeShiftLane(void){
+	try{
+		for(size_t idx = 0; idx &lt; current_shifted_lane_array_.lanes.size(); idx+=2){
+			for(size_t wp_idx; wp_idx &lt; current_shifted_lane_array_.lanes.at(idx).waypoints.size(); wp_idx++){
+				current_shifted_lane_array_.lanes.at(idx).waypoints.at(wp_idx).change_flag = current_shifted_lane_array_.lanes.at(idx+1).waypoints.at(wp_idx).change_flag;
+				current_shifted_lane_array_.lanes.at(idx+1).waypoints.at(wp_idx).change_flag = 2;
+			}
+		}
+	}
+	catch(std::out_of_range){
+		fprintf(stderr,"out\n");
+	}
+}
+
+void DecisionMakerNode::removeShiftLane(void){
+	current_shifted_lane_array_ = current_based_lane_array_;
+	created_shift_lane_flag_ = false;
+#if 0
+	if(created_shift_lane_flag_){
+		if(!current_shifted_lane_array_.lanes.size()&gt;=2){
+			for(auto it = begin(current_shifted_lane_array_.lanes)+1; it!=end(current_shifted_lane_array_.lanes); it+=2)
+				current_shifted_lane_array_.lanes.erase(it);
+		}
+		created_shift_lane_flag_ = false;
+	}
+#endif
+}
+
 void DecisionMakerNode::updateLaneWaypointsArray(void)
 {
   // current_stopped_lane_array_ = current_controlled_lane_array_;
   current_stopped_lane_array_ = current_controlled_lane_array_;
-#if 0
-	size_t idx	= current_finalwaypoints_.waypoints.at(0).gid;
-	for(auto &amp;lane : current_stopped_lane_array_.lanes)
-	{
-		for(auto &amp;wp: lane.waypoints){
-			fprintf(stderr,"%d:%d\n",idx, wp.gid);
-			if(idx - 5 &lt;= wp.gid &amp;&amp;  wp.gid  &lt; idx){
-				wp.twist.twist.linear.x /= 5 - (idx-wp.gid);
-			}else{
-				wp.twist.twist.linear.x = 0;
-			}
-			wp.wpstate.stopline_state = 0;
-		}
-	}
-#else
 
   for (auto &amp;lane : current_stopped_lane_array_.lanes)
   {
@@ -81,27 +103,29 @@ void DecisionMakerNode::updateLaneWaypointsArray(void)
       wp.wpstate.stopline_state = 0;
     }
   }
-#endif
 }
 
 void DecisionMakerNode::publishControlledLaneArray(void)
 {
+	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
   Pubs["lane_waypoints_array"].publish(current_controlled_lane_array_);
 }
 void DecisionMakerNode::publishStoppedLaneArray(void)
 {
+	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
   updateLaneWaypointsArray();
   Pubs["lane_waypoints_array"].publish(current_stopped_lane_array_);
 }
 
 void DecisionMakerNode::changeVelocityBasedLane(void)
 {
+	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
   current_controlled_lane_array_ = current_shifted_lane_array_;
-  // current_controlled_lane_array_ = current_based_lane_array_;
 }
 
 void DecisionMakerNode::changeVelocityLane(int dir)
 {
+	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
   for (auto &amp;lane : current_controlled_lane_array_.lanes)
   {
     autoware_msgs::lane temp_lane = lane;
@@ -122,19 +146,22 @@ void DecisionMakerNode::changeVelocityLane(int dir)
   }
 }
 
-void DecisionMakerNode::changedStateKeep(int status)
+void DecisionMakerNode::callbackInStateKeep(int status)
 {
+	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
   changeVelocityBasedLane();
   publishControlledLaneArray();
 }
 
-void DecisionMakerNode::changedStateAcc(int status)
+void DecisionMakerNode::callbackInStateAcc(int status)
 {
+	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
   changeVelocityLane(status);
   publishControlledLaneArray();
 }
 void DecisionMakerNode::updateStateStop(int status)
 {
+	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
   static ros::Timer stopping_timer;
   static bool timerflag = false;
   if (status)
@@ -152,22 +179,61 @@ void DecisionMakerNode::updateStateStop(int status)
     }
   }
 }
-void DecisionMakerNode::changedStateObstacleAvoid(int status)
+
+void DecisionMakerNode::updateStateObstacleAvoid(int status)
 {
-  createShiftLane();
-  publishControlledLaneArray();
+	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
+  static ros::Timer avoidance_timer;
+  static bool stopped_flag = false;
 
-  static ros::Timer stopping_timer;
-  static bool timerflag = false;
-  stopping_timer = nh_.createTimer(ros::Duration(1),
-                                   [&amp;](const ros::TimerEvent &amp;) {
-                                     ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE);
-                                     ROS_INFO("Change state to null from obstacle avoid\n");
-                                   },
-                                   this, true);
+  if(current_velocity_ == 0.0){
+	stopped_flag = true;
+  }
+}
+
+void DecisionMakerNode::callbackOutStateObstacleAvoid(int status)
+{
+	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
+	static ros::Timer avoidance_timer_2;
+	ROS_INFO("End of Avoidance\n");
+	changeShiftLane();
+	changeVelocityBasedLane();
+	publishControlledLaneArray();
+
+	ros::Rate loop_rate(1);
+	//blocking
+	
+	
+	do{
+		ros::spinOnce();
+		loop_rate.sleep();
+	}
+	while(!ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) &amp;&amp;
+				       	!ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) &amp;&amp; ros::ok());
+	do{
+		ros::spinOnce();
+		loop_rate.sleep();
+	}
+	while((ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) ||
+				       	ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) ||
+				       	ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE) )&amp;&amp; ros::ok() );
+
+	removeShiftLane();
+	changeVelocityBasedLane();
+	publishControlledLaneArray();
+	return;
+}
+
+void DecisionMakerNode::callbackInStateObstacleAvoid(int status)
+{
+	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
+  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
+  createShiftLane();
+  changeVelocityBasedLane();
 }
-void DecisionMakerNode::changedStateStop(int status)
+void DecisionMakerNode::callbackInStateStop(int status)
 {
+	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
   publishStoppedLaneArray();
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="11" deleted_lines="1">
				<diff>@@ -85,6 +85,8 @@ void LaneSelectNode::initForROS()
   }
 
   pub3_ = nh_.advertise&lt;std_msgs::Int32&gt;("change_flag", 1);
+  pub4_ = nh_.advertise&lt;std_msgs::Int32&gt;("/current_lane_id",1);
+
   vis_pub1_ = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("lane_select_marker", 1);
 
   // get from rosparam
@@ -182,6 +184,7 @@ void LaneSelectNode::processing()
           std::get&lt;0&gt;(lane_for_change_).waypoints.at(std::get&lt;1&gt;(lane_for_change_)).change_flag);
       ROS_INFO("closest: %d", std::get&lt;1&gt;(lane_for_change_));
       publishLane(std::get&lt;0&gt;(lane_for_change_));
+      publishLaneID(std::get&lt;0&gt;(lane_for_change_));
       publishClosestWaypoint(std::get&lt;1&gt;(lane_for_change_));
       publishChangeFlag(std::get&lt;2&gt;(lane_for_change_));
     }
@@ -608,6 +611,13 @@ void LaneSelectNode::publishLane(const autoware_msgs::lane &amp;lane)
   pub1_.publish(lane);
 }
 
+void LaneSelectNode::publishLaneID(const autoware_msgs::lane &amp;lane)
+{
+  std_msgs::Int32 msg;
+  msg.data = lane.lane_id;
+  pub4_.publish(msg);
+}
+
 void LaneSelectNode::publishClosestWaypoint(const int32_t clst_wp)
 {
   // publish closest waypoint
@@ -681,7 +691,7 @@ void LaneSelectNode::callbackFromStates(const autoware_msgs::stateConstPtr &amp;msg)
 {
   is_current_state_subscribed_ = true;
 
-  if (msg-&gt;behavior_state == "LaneChangeRight" || msg-&gt;behavior_state == "LaneChangeLeft")
+  if (msg-&gt;behavior_state.find("LaneChange") != std::string::npos)
   {
     current_state_ = std::string("LANE_CHANGE");
     ;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.h" added_lines="2" deleted_lines="1">
				<diff>@@ -82,7 +82,7 @@ private:
   ros::NodeHandle private_nh_;
 
   // publisher
-  ros::Publisher pub1_, pub2_, pub3_;
+  ros::Publisher pub1_, pub2_, pub3_, pub4_;
   ros::Publisher vis_pub1_;
 
   // subscriber
@@ -133,6 +133,7 @@ private:
   bool isAllTopicsSubscribed();
   void processing();
   void publishLane(const autoware_msgs::lane &amp;lane);
+  void publishLaneID(const autoware_msgs::lane &amp;lane);
   void publishClosestWaypoint(const int32_t clst_wp);
   void publishChangeFlag(const ChangeFlag flag);
   bool getClosestWaypointNumberForEachLanes();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="efe17abbb7b831d0e826fb881c365f9ce34cf1d4" author="hatem-darweesh">
		<msg>- Add new Node for object polygon representation and tracking (kf_contour_tracker)
- Add launch file and tune tracking parameters
- Test with Moriyama rosbag</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\euclidean_cluster\euclidean_cluster.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -918,7 +918,7 @@ void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr&amp; in_sensor_cloud)
 	}
 	_end = std::chrono::system_clock::now();  // 
   double elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(_end-_start).count(); //
-  ROS_INFO("Euclidean Clustering : %f", elapsed);
+  //ROS_INFO("Euclidean Clustering : %f", elapsed);
 }
 
 /*
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\RoadNetwork.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\RoadNetwork.h" added_lines="2" deleted_lines="0">
				<diff>@@ -719,11 +719,13 @@ class DetectedObject
 {
 public:
 	int id;
+	std::string label;
 	OBSTACLE_TYPE t;
 	WayPoint center;
 	WayPoint predicted_center;
 	WayPoint noisy_center;
 	STATE_TYPE predicted_behavior;
+	std::vector&lt;WayPoint&gt; centers_list;
 	std::vector&lt;GPSPoint&gt; contour;
 	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; predTrajectories;
 	std::vector&lt;WayPoint*&gt; pClosestWaypoints;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlanningHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\src\PlanningHelpers.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1055,7 +1055,7 @@ void PlanningHelpers::SmoothPath(vector&lt;WayPoint&gt;&amp; path, double weight_data,
 
 	if (path.size() &lt;= 2 )
 	{
-		cout &lt;&lt; "Can't Smooth Path, Path_in Size=" &lt;&lt; path.size() &lt;&lt; endl;
+		//cout &lt;&lt; "Can't Smooth Path, Path_in Size=" &lt;&lt; path.size() &lt;&lt; endl;
 		return;
 	}
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\include\PolygonGenerator.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\include\PolygonGenerator.h" added_lines="23" deleted_lines="37">
				<diff>@@ -19,23 +19,21 @@
 namespace PlannerHNS
 {
 
-#define QUARTERS_NUMBER 8
-#define MIN_POINTS_PER_QUARTER 1
-#define MIN_DISTANCE_BETWEEN_CORNERS 0.5
-
 class QuarterView
 {
 public:
 	int id;
 	int min_ang;
 	int max_ang;
-	std::vector&lt;WayPoint&gt; vectorsFromCenter;
+	WayPoint max_from_center;
+	bool bFirst;
 
 	QuarterView(const int&amp; min_a, const int&amp; max_a, const int&amp; index)
 	{
 		min_ang = min_a;
 		max_ang = max_a;
 		id = index;
+		bFirst = true;
 	}
 
 	void InitQuarterView(const int&amp; min_a, const int&amp; max_a, const int&amp; index)
@@ -43,6 +41,12 @@ public:
 		min_ang = min_a;
 		max_ang = max_a;
 		id = index;
+		bFirst = true;
+	}
+
+	void ResetQuarterView()
+	{
+		bFirst = true;
 	}
 
 	bool UpdateQuarterView(const WayPoint&amp; v)
@@ -50,44 +54,25 @@ public:
 		if(v.pos.a &lt;= min_ang || v.pos.a &gt; max_ang)
 			return false;
 
-		bool bGreaterFound = false;
-		unsigned int greaterIndex = 0;
-		for(unsigned int i=0; i&lt; vectorsFromCenter.size(); i++)
+		if(bFirst)
 		{
-			if(vectorsFromCenter.at(i).cost &gt; v.cost)
-			{
-				bGreaterFound = true;
-				greaterIndex = i;
-				break;
-			}
+			max_from_center = v;
+			bFirst = false;
 		}
-
-		if(bGreaterFound)
-		{
-			if(greaterIndex &lt; vectorsFromCenter.size())
-				vectorsFromCenter.insert(vectorsFromCenter.begin()+greaterIndex, v);
-			else
-				vectorsFromCenter.push_back(v);
-		}
-		else
-			vectorsFromCenter.push_back(v);
+		else if(v.cost &gt; max_from_center.cost)
+			max_from_center = v;
 
 		return true;
-
 	}
 
 	bool GetMaxPoint(WayPoint&amp; maxPoint)
 	{
-		if(vectorsFromCenter.size()==0)
+		if(bFirst)
 			return false;
+		else
+			maxPoint = max_from_center;
 
-		maxPoint = vectorsFromCenter.at(vectorsFromCenter.size()-1);
-		return vectorsFromCenter.size();
-	}
-
-	int GetPointsNumber()
-	{
-		return vectorsFromCenter.size();
+		return true;
 	}
 };
 
@@ -97,12 +82,13 @@ class PolygonGenerator
 public:
 
 	GPSPoint m_Centroid;
-	PolygonGenerator();
+	std::vector&lt;QuarterView&gt; m_Quarters;
+	std::vector&lt;GPSPoint&gt; m_Polygon;
+
+	PolygonGenerator(int nQuarters);
 	virtual ~PolygonGenerator();
-	void CheckConvexPoligon(std::vector&lt;WayPoint&gt;&amp; polygon);
-	GPSPoint CalculateCentroid(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster);
 	std::vector&lt;QuarterView&gt; CreateQuarterViews(const int&amp; nResolution);
-	std::vector&lt;GPSPoint&gt; EstimateClusterPolygon(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster, const GPSPoint&amp; original_centroid );
+	std::vector&lt;GPSPoint&gt; EstimateClusterPolygon(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster, const GPSPoint&amp; original_centroid, GPSPoint&amp; new_centroid, const double&amp; polygon_resolution = 1.0);
 };
 
 } /* namespace PlannerXNS */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\include\op_RosHelpers.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\include\op_RosHelpers.h" added_lines="51" deleted_lines="3">
				<diff>@@ -173,8 +173,58 @@ class RosHelpers
 public:
 	RosHelpers();
 	virtual ~RosHelpers();
+	/**
+	 * Used
+	 */
 	static void GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform);
 
+	/**
+	 * Used
+	 */
+	static void ConvertFromAutowareCloudClusterObstaclesToPlannerH(const PlannerHNS::WayPoint&amp; currState, const double&amp; car_width,
+			const double&amp; car_length, const autoware_msgs::CloudClusterArray&amp; clusters,
+			std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; impObstacles, const double max_obj_size, const double&amp; min_obj_size, const double&amp; detection_radius,
+			const int&amp; n_poly_quarters,const double&amp; poly_resolution, int&amp; nOriginalPoints, int&amp; nContourPoints);
+
+
+	/**
+	 * Used
+	 */
+	static visualization_msgs::Marker CreateGenMarker(const double&amp; x, const double&amp; y, const double&amp; z,const double&amp; a,
+			const double&amp; r, const double&amp; g, const double&amp; b, const double&amp; scale, const int&amp; id, const std::string&amp; ns, const int&amp; type);
+
+	/**
+	 * Used
+	 */
+	static void InitMarkers(const int&amp; nMarkers,
+			visualization_msgs::MarkerArray&amp; centers,
+			visualization_msgs::MarkerArray&amp; dirs,
+			visualization_msgs::MarkerArray&amp; text_info,
+			visualization_msgs::MarkerArray&amp; polygons,
+			visualization_msgs::MarkerArray&amp; trajectories);
+
+
+	/**
+	 * Used
+	 */
+	static void ConvertTrackedObjectsMarkers(const PlannerHNS::WayPoint&amp; currState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; trackedObstacles,
+			visualization_msgs::MarkerArray&amp; centers_d,
+			visualization_msgs::MarkerArray&amp; dirs_d,
+			visualization_msgs::MarkerArray&amp; text_info_d,
+			visualization_msgs::MarkerArray&amp; polygons_d,
+			visualization_msgs::MarkerArray&amp; tracked_traj_d,
+			visualization_msgs::MarkerArray&amp; centers,
+			visualization_msgs::MarkerArray&amp; dirs,
+			visualization_msgs::MarkerArray&amp; text_info,
+			visualization_msgs::MarkerArray&amp; polygons,
+			visualization_msgs::MarkerArray&amp; tracked_traj);
+
+	/**
+	 * Used
+	 */
+	static void CreateCircleMarker(const PlannerHNS::WayPoint&amp; _center, const double&amp; radius, const int&amp; start_id, visualization_msgs::Marker&amp; circle_points);
+
+
 	static void TrajectoriesToMarkers(const std::vector&lt;std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; &gt;&amp; paths, visualization_msgs::MarkerArray&amp; markerArray);
 
 	static void ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const int&amp; iStart,
@@ -194,9 +244,7 @@ public:
 	static void ConvertFromAutowareBoundingBoxObstaclesToPlannerH(const jsk_recognition_msgs::BoundingBoxArray&amp; detectedObstacles,
 			std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; impObstacles);
 
-	static void ConvertFromAutowareCloudClusterObstaclesToPlannerH(const PlannerHNS::WayPoint&amp; currState, const PlannerHNS::CAR_BASIC_INFO&amp; car_info,
-			const autoware_msgs::CloudClusterArray&amp; clusters,
-			std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; impObstacles, int&amp; nOriginalPoints, int&amp; nContourPoints);
+
 
 	static void ConvertFromPlannerObstaclesToAutoware(const PlannerHNS::WayPoint&amp; currState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; trackedObstacles,
 			visualization_msgs::MarkerArray&amp; detectedPolygons);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\src\PolygonGenerator.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\src\PolygonGenerator.cpp" added_lines="52" deleted_lines="87">
				<diff>@@ -11,93 +11,85 @@
 namespace PlannerHNS
 {
 
-
-PolygonGenerator::PolygonGenerator() {
-	// TODO Auto-generated constructor stub
-
-}
-
-PolygonGenerator::~PolygonGenerator() {
-	// TODO Auto-generated destructor stub
+PolygonGenerator::PolygonGenerator(int nQuarters)
+{
+	m_Quarters = CreateQuarterViews(nQuarters);
 }
 
-GPSPoint PolygonGenerator::CalculateCentroid(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster)
+PolygonGenerator::~PolygonGenerator()
 {
-	GPSPoint c;
-
-	for(unsigned int i=0; i&lt; cluster.points.size(); i++)
-	{
-		c.x += cluster.points.at(i).x;
-		c.y += cluster.points.at(i).y;
-	}
-
-	c.x = c.x/cluster.points.size();
-	c.y = c.y/cluster.points.size();
-
-	return c;
 }
 
-std::vector&lt;GPSPoint&gt; PolygonGenerator::EstimateClusterPolygon(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster, const GPSPoint&amp; original_centroid )
+std::vector&lt;GPSPoint&gt; PolygonGenerator::EstimateClusterPolygon(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster, const GPSPoint&amp; original_centroid, GPSPoint&amp; new_centroid, const double&amp; polygon_resolution)
 {
-	std::vector&lt;QuarterView&gt; quarters = CreateQuarterViews(QUARTERS_NUMBER);
-
+	for(unsigned int i=0; i &lt; m_Quarters.size(); i++)
+			m_Quarters.at(i).ResetQuarterView();
 
+	WayPoint p;
 	for(unsigned int i=0; i&lt; cluster.points.size(); i++)
 	{
-		WayPoint p;
 		p.pos.x = cluster.points.at(i).x;
 		p.pos.y = cluster.points.at(i).y;
 		p.pos.z = original_centroid.z;
 
-		GPSPoint v(p.pos.x - original_centroid.x , p.pos.y - original_centroid.y,0,0);
+		GPSPoint v(p.pos.x - original_centroid.x , p.pos.y - original_centroid.y, 0, 0);
 		p.cost = pointNorm(v);
 		p.pos.a = UtilityHNS::UtilityH::FixNegativeAngle(atan2(v.y, v.x))*(180. / M_PI);
 
-		for(unsigned int j = 0 ; j &lt; quarters.size(); j++)
+		for(unsigned int j = 0 ; j &lt; m_Quarters.size(); j++)
 		{
-			if(quarters.at(j).UpdateQuarterView(p))
+			if(m_Quarters.at(j).UpdateQuarterView(p))
 				break;
 		}
 	}
 
-	std::vector&lt;GPSPoint&gt; polygon;
-
-	for(unsigned int j = 0 ; j &lt; quarters.size(); j++)
+	m_Polygon.clear();
+	WayPoint wp;
+	for(unsigned int j = 0 ; j &lt; m_Quarters.size(); j++)
 	{
+		if(m_Quarters.at(j).GetMaxPoint(wp))
+			m_Polygon.push_back(wp.pos);
+	}
 
-		WayPoint wp;
-		int nPoints = quarters.at(j).GetMaxPoint(wp);
-		if(nPoints &gt;= MIN_POINTS_PER_QUARTER)
+//	//Fix Resolution:
+	bool bChange = true;
+	while (bChange &amp;&amp; m_Polygon.size()&gt;1)
+	{
+		bChange = false;
+		GPSPoint p1 =  m_Polygon.at(m_Polygon.size()-1);
+		for(unsigned int i=0; i&lt; m_Polygon.size(); i++)
 		{
-			polygon.push_back(wp.pos);
+			GPSPoint p2 = m_Polygon.at(i);
+			double d = hypot(p2.y- p1.y, p2.x - p1.x);
+			if(d &gt; polygon_resolution)
+			{
+				GPSPoint center_p = p1;
+				center_p.x = (p2.x + p1.x)/2.0;
+				center_p.y = (p2.y + p1.y)/2.0;
+				m_Polygon.insert(m_Polygon.begin()+i, center_p);
+				bChange = true;
+				break;
+			}
+
+			p1 = p2;
 		}
 	}
+	GPSPoint sum_p;
+	for(unsigned int i = 0 ; i&lt; m_Polygon.size(); i++)
+	{
+		sum_p.x += m_Polygon.at(i).x;
+		sum_p.y += m_Polygon.at(i).y;
+	}
 
-//	//Fix Resolution:
-//	bool bChange = true;
-//	while (bChange &amp;&amp; polygon.size()&gt;1)
-//	{
-//		bChange = false;
-//		GPSPoint p1 =  polygon.at(polygon.size()-1);
-//		for(unsigned int i=0; i&lt; polygon.size(); i++)
-//		{
-//			GPSPoint p2 = polygon.at(i);
-//			double d = hypot(p2.y- p1.y, p2.x - p1.x);
-//			if(d &gt; MIN_DISTANCE_BETWEEN_CORNERS)
-//			{
-//				GPSPoint center_p = p1;
-//				center_p.x = (p2.x + p1.x)/2.0;
-//				center_p.y = (p2.y + p1.y)/2.0;
-//				polygon.insert(polygon.begin()+i, center_p);
-//				bChange = true;
-//				break;
-//			}
-//
-//			p1 = p2;
-//		}
-//	}
-
-	return polygon;
+	new_centroid = original_centroid;
+
+	if(m_Polygon.size() &gt; 0)
+	{
+		new_centroid.x = sum_p.x / (double)m_Polygon.size();
+		new_centroid.y = sum_p.y / (double)m_Polygon.size();
+	}
+
+	return m_Polygon;
 
 }
 
@@ -119,31 +111,4 @@ std::vector&lt;QuarterView&gt; PolygonGenerator::CreateQuarterViews(const int&amp; nResolu
 	return quarters;
 }
 
-void CheckConvexPoligon(std::vector&lt;WayPoint&gt;&amp; polygon)
-{
-
-//	if(polygon.size() &lt;= 3)
-//		return;
-//
-//	WayPoint p1 = polygon.at(0);
-//	WayPoint p3;
-//	WayPoint p2;
-//
-//	for(int i=1; i&lt; polygon.size()-1; i++)
-//	{
-//		p1 = polygon.at(i-1);
-//		if(i+2 == polygon.size())
-//		{
-//			p2 = polygon.at(polygon.size()-1);
-//			p3 = polygon.at(0);
-//		}
-//		else
-//		{
-//			p2 = polygon.at(i);
-//			p3 = polygon.at(i+1);
-//		}
-//
-//	}
-}
-
 } /* namespace PlannerXNS */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\src\op_RosHelpers.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_ros_helpers\src\op_RosHelpers.cpp" added_lines="224" deleted_lines="29">
				<diff>@@ -50,6 +50,194 @@ void RosHelpers::GetTransformFromTF(const std::string parent_frame, const std::s
 	}
 }
 
+visualization_msgs::Marker RosHelpers::CreateGenMarker(const double&amp; x, const double&amp; y, const double&amp; z,const double&amp; a,
+		const double&amp; r, const double&amp; g, const double&amp; b, const double&amp; scale, const int&amp; id, const std::string&amp; ns, const int&amp; type)
+{
+	visualization_msgs::Marker mkr;
+	mkr.header.frame_id = "map";
+	mkr.header.stamp = ros::Time();
+	mkr.ns = ns;
+	mkr.type = type;
+	mkr.action = visualization_msgs::Marker::ADD;
+	mkr.scale.x = scale;
+	mkr.scale.y = scale;
+	mkr.scale.z = scale;
+	mkr.color.a = 0.8;
+	mkr.color.r = r;
+	mkr.color.g = g;
+	mkr.color.b = b;
+	mkr.pose.position.x = x;
+	mkr.pose.position.y = y;
+	mkr.pose.position.z = z;
+	mkr.pose.orientation = tf::createQuaternionMsgFromYaw(a);
+	mkr.id = id;
+	return mkr;
+}
+
+void RosHelpers::InitMarkers(const int&amp; nMarkers,
+		visualization_msgs::MarkerArray&amp; centers,
+		visualization_msgs::MarkerArray&amp; dirs,
+		visualization_msgs::MarkerArray&amp; text_info,
+		visualization_msgs::MarkerArray&amp; polygons,
+		visualization_msgs::MarkerArray&amp; trajectories)
+{
+	centers.markers.clear();
+	dirs.markers.clear();
+	text_info.markers.clear();
+	polygons.markers.clear();
+	trajectories.markers.clear();
+
+	for(int i=0; i&lt;nMarkers; i++)
+	{
+		visualization_msgs::Marker mkr = CreateGenMarker(0,0,0,0,1,1,1,1,i,"CenterMarker", visualization_msgs::Marker::SPHERE);
+		centers.markers.push_back(mkr);
+	}
+
+	for(int i=nMarkers; i&lt;nMarkers*2; i++)
+	{
+		visualization_msgs::Marker mkr = CreateGenMarker(0,0,0,0,1,1,1,1,i,"Directions", visualization_msgs::Marker::ARROW);
+		dirs.markers.push_back(mkr);
+	}
+
+	for(int i=nMarkers*2; i&lt;nMarkers*3; i++)
+	{
+		visualization_msgs::Marker mkr = CreateGenMarker(0,0,0,0,1,1,1,1,i,"InfoText", visualization_msgs::Marker::TEXT_VIEW_FACING);
+		text_info.markers.push_back(mkr);
+	}
+
+	for(int i=nMarkers*3; i&lt;nMarkers*4; i++)
+	{
+		visualization_msgs::Marker mkr = CreateGenMarker(0,0,0,0,1,1,1,1,i,"detected_polygons", visualization_msgs::Marker::LINE_STRIP);
+		polygons.markers.push_back(mkr);
+	}
+
+	for(int i=nMarkers*4; i&lt;nMarkers*5; i++)
+	{
+		visualization_msgs::Marker mkr = CreateGenMarker(0,0,0,0,1,1,1,1,i,"tracked_trajectories", visualization_msgs::Marker::LINE_STRIP);
+		trajectories.markers.push_back(mkr);
+	}
+}
+
+void RosHelpers::ConvertTrackedObjectsMarkers(const PlannerHNS::WayPoint&amp; currState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; trackedObstacles,
+		visualization_msgs::MarkerArray&amp; centers_d,
+		visualization_msgs::MarkerArray&amp; dirs_d,
+		visualization_msgs::MarkerArray&amp; text_info_d,
+		visualization_msgs::MarkerArray&amp; polygons_d,
+		visualization_msgs::MarkerArray&amp; tracked_traj_d,
+		visualization_msgs::MarkerArray&amp; centers,
+		visualization_msgs::MarkerArray&amp; dirs,
+		visualization_msgs::MarkerArray&amp; text_info,
+		visualization_msgs::MarkerArray&amp; polygons,
+		visualization_msgs::MarkerArray&amp; tracked_traj)
+{
+
+	centers = centers_d;
+	dirs = dirs_d;
+	text_info = text_info_d;
+	polygons = polygons_d;
+	tracked_traj = tracked_traj_d;
+
+	for(unsigned int i =0; i &lt; trackedObstacles.size(); i++)
+	{
+		int speed = (trackedObstacles.at(i).center.v*3.6);
+
+		//Update Stage
+		visualization_msgs::Marker center_mkr = CreateGenMarker(trackedObstacles.at(i).center.pos.x,trackedObstacles.at(i).center.pos.y,trackedObstacles.at(i).center.pos.z,
+				trackedObstacles.at(i).center.pos.a,1,0,0,0.5,i,"CenterMarker", visualization_msgs::Marker::SPHERE);
+		if(i &lt; centers.markers.size())
+			centers.markers.at(i) = center_mkr;
+		else
+			centers.markers.push_back(center_mkr);
+
+		if(trackedObstacles.at(i).bDirection)
+		{
+			visualization_msgs::Marker dir_mkr = CreateGenMarker(trackedObstacles.at(i).center.pos.x,trackedObstacles.at(i).center.pos.y,trackedObstacles.at(i).center.pos.z+0.5,
+					trackedObstacles.at(i).center.pos.a,0,1,0,0.1,centers.markers.size()+i,"Directions", visualization_msgs::Marker::ARROW);
+			dir_mkr.scale.x = 0.4;
+			if(i &lt; dirs.markers.size())
+				dirs.markers.at(i) = dir_mkr;
+			else
+				dirs.markers.push_back(dir_mkr);
+		}
+
+
+		visualization_msgs::Marker text_mkr;
+		if(speed &gt; 3.0)
+			text_mkr = CreateGenMarker(trackedObstacles.at(i).center.pos.x+0.5,trackedObstacles.at(i).center.pos.y+0.5,trackedObstacles.at(i).center.pos.z+1,
+					trackedObstacles.at(i).center.pos.a,1,0,0,0.75,centers.markers.size()*2+i,"InfoText", visualization_msgs::Marker::TEXT_VIEW_FACING);
+		else
+			text_mkr = CreateGenMarker(trackedObstacles.at(i).center.pos.x+0.5,trackedObstacles.at(i).center.pos.y+0.5,trackedObstacles.at(i).center.pos.z+1,
+								trackedObstacles.at(i).center.pos.a,1,1,1,0.75,centers.markers.size()*2+i,"InfoText", visualization_msgs::Marker::TEXT_VIEW_FACING);
+
+		std::ostringstream str_out;
+		str_out &lt;&lt; trackedObstacles.at(i).id &lt;&lt; " ( " &lt;&lt; speed &lt;&lt; " )";
+		text_mkr.text = str_out.str();
+
+		if(i &lt; text_info.markers.size())
+			text_info.markers.at(i) = text_mkr;
+		else
+			text_info.markers.push_back(text_mkr);
+
+
+		visualization_msgs::Marker poly_mkr = CreateGenMarker(0,0,0,0, 0,0,1,0.1,centers.markers.size()*3+i,"detected_polygons", visualization_msgs::Marker::LINE_STRIP);
+
+		for(unsigned int p = 0; p &lt; trackedObstacles.at(i).contour.size(); p++)
+		{
+			geometry_msgs::Point point;
+			point.x = trackedObstacles.at(i).contour.at(p).x;
+			point.y = trackedObstacles.at(i).contour.at(p).y;
+			point.z = trackedObstacles.at(i).contour.at(p).z;
+			poly_mkr.points.push_back(point);
+		}
+
+		if(trackedObstacles.at(i).contour.size()&gt;0)
+		{
+			geometry_msgs::Point point;
+			point.x = trackedObstacles.at(i).contour.at(0).x;
+			point.y = trackedObstacles.at(i).contour.at(0).y;
+			point.z = trackedObstacles.at(i).contour.at(0).z;
+			poly_mkr.points.push_back(point);
+		}
+
+		if(i &lt; polygons.markers.size())
+			polygons.markers.at(i) = poly_mkr;
+		else
+			polygons.markers.push_back(poly_mkr);
+
+
+		visualization_msgs::Marker traj_mkr = CreateGenMarker(0,0,0,0,1,1,0,0.1,centers.markers.size()*4+i,"tracked_trajectories", visualization_msgs::Marker::LINE_STRIP);
+
+		for(unsigned int p = 0; p &lt; trackedObstacles.at(i).centers_list.size(); p++)
+		{
+			geometry_msgs::Point point;
+			point.x = trackedObstacles.at(i).centers_list.at(p).pos.x;
+			point.y = trackedObstacles.at(i).centers_list.at(p).pos.y;
+			point.z = trackedObstacles.at(i).centers_list.at(p).pos.z;
+			traj_mkr.points.push_back(point);
+		}
+
+
+		if(i &lt; tracked_traj.markers.size())
+			tracked_traj.markers.at(i) = traj_mkr;
+		else
+			tracked_traj.markers.push_back(traj_mkr);
+
+	}
+}
+
+void RosHelpers::CreateCircleMarker(const PlannerHNS::WayPoint&amp; _center, const double&amp; radius, const int&amp; start_id, visualization_msgs::Marker&amp; circle_points)
+{
+	circle_points = CreateGenMarker(0,0,0,0,1,1,1,0.2,start_id,"Detection_Circles", visualization_msgs::Marker::LINE_STRIP);
+	for (float i = 0; i &lt; M_PI*2.0+0.05; i+=0.05)
+	{
+		geometry_msgs::Point point;
+		point.x = _center.pos.x + (radius * cos(i));
+		point.y = _center.pos.y + (radius * sin(i));
+		point.z = _center.pos.z;
+		circle_points.points.push_back(point);
+	}
+}
+
 void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const int&amp; iStart,
 		autoware_msgs::lane&amp; trajectory)
 {
@@ -139,7 +327,6 @@ void RosHelpers::ConvertFromPlannerHRectangleToAutowareRviz(const std::vector&lt;Pl
 	lane_waypoint_marker.color.b = 0.0;
 	lane_waypoint_marker.color.a = 0.6;
 
-	int id = 0;
 	for(unsigned int i = 0; i &lt; safety_rect.size(); i++)
 	{
 		geometry_msgs::Point p;
@@ -287,7 +474,7 @@ void RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vec
 				lane_waypoint_marker.color.g = 1.0;
 			}
 
-			if(i == localPlanner.m_iSafeTrajectory &amp;&amp; il == localPlanner.m_iCurrentTotalPathId)
+			if((int)i == localPlanner.m_iSafeTrajectory &amp;&amp; (int)il == localPlanner.m_iCurrentTotalPathId)
 			{
 				lane_waypoint_marker.color.r = 1.0;
 				lane_waypoint_marker.color.g = 0.0;
@@ -652,56 +839,64 @@ void RosHelpers::ConvertFromAutowareBoundingBoxObstaclesToPlannerH(const jsk_rec
 	}
 }
 
-void RosHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(const PlannerHNS::WayPoint&amp; currState, const PlannerHNS::CAR_BASIC_INFO&amp; car_info,
-		const autoware_msgs::CloudClusterArray&amp; clusters, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obstacles_list,
-		int&amp; nOriginalPoints, int&amp; nContourPoints)
+void RosHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(const PlannerHNS::WayPoint&amp; currState, const double&amp; car_width,
+		const double&amp; car_length, const autoware_msgs::CloudClusterArray&amp; clusters, vector&lt;PlannerHNS::DetectedObject&gt;&amp; obstacles_list,
+		const double max_obj_size, const double&amp; min_obj_size, const double&amp; detection_radius,
+		const int&amp; n_poly_quarters,const double&amp; poly_resolution, int&amp; nOriginalPoints, int&amp; nContourPoints)
 {
 	PlannerHNS::Mat3 rotationMat(-currState.pos.a);
 	PlannerHNS::Mat3 translationMat(-currState.pos.x, -currState.pos.y);
 
 	int nPoints = 0;
 	int nOrPoints = 0;
+	double object_size = 0;
+	PlannerHNS::GPSPoint relative_point;
+	PlannerHNS::GPSPoint avg_center;
+	PolygonGenerator polyGen(n_poly_quarters);
+	PlannerHNS::DetectedObject obj;
+
 	for(unsigned int i =0; i &lt; clusters.clusters.size(); i++)
 	{
-		PolygonGenerator polyGen;
-		PlannerHNS::DetectedObject obj;
-		obj.center.pos = GPSPoint(clusters.clusters.at(i).centroid_point.point.x,
-				clusters.clusters.at(i).centroid_point.point.y,
-				clusters.clusters.at(i).centroid_point.point.z,0);
-				//tf::getYaw(clusters.clusters.at(i).bounding_box.pose.orientation));
+		obj.id = clusters.clusters.at(i).id;
+		obj.label = clusters.clusters.at(i).label;
+
+		obj.center.pos.x = clusters.clusters.at(i).centroid_point.point.x;
+		obj.center.pos.y = clusters.clusters.at(i).centroid_point.point.y;
+		obj.center.pos.z = clusters.clusters.at(i).centroid_point.point.z;
+		obj.center.pos.a = 0;
+		obj.center.v = 0;
+		obj.actual_yaw = clusters.clusters.at(i).estimated_angle;
+
+		obj.w = clusters.clusters.at(i).dimensions.x;
+		obj.l = clusters.clusters.at(i).dimensions.y;
+		obj.h = clusters.clusters.at(i).dimensions.z;
 
 		pcl::PointCloud&lt;pcl::PointXYZ&gt; point_cloud;
 		pcl::fromROSMsg(clusters.clusters.at(i).cloud, point_cloud);
-		obj.contour = polyGen.EstimateClusterPolygon(point_cloud ,obj.center.pos);
-		obj.w = clusters.clusters.at(i).dimensions.y;
-		obj.l = clusters.clusters.at(i).dimensions.x;
-		obj.h = clusters.clusters.at(i).dimensions.z;
-		obj.id = 0;
+
+
+		obj.contour = polyGen.EstimateClusterPolygon(point_cloud ,obj.center.pos,avg_center, poly_resolution);
+
 		obj.distance_to_center = hypot(obj.center.pos.y-currState.pos.y, obj.center.pos.x-currState.pos.x);
 
+		object_size = hypot(obj.w, obj.l);
+
+		if(obj.distance_to_center &gt; detection_radius || object_size &lt; min_obj_size || object_size &gt; max_obj_size)
+			continue;
 
-		PlannerHNS::GPSPoint relative_point;
 		relative_point = translationMat*obj.center.pos;
 		relative_point = rotationMat*relative_point;
 
-		double distance_x = fabs(relative_point.x - car_info.wheel_base/2.0);
+		double distance_x = fabs(relative_point.x - car_length/3.0);
 		double distance_y = fabs(relative_point.y);
 
-		double size = (obj.w+obj.l)/2.0;
-//		if(size &lt;= 0.25 || size &gt;= 5 || distance_y &gt; 20.0 || distance_x &gt; 20.0)
-//			continue;
-
-//		if(distance_y &gt; 10.0 || distance_x &gt; 10.0)
-//			continue;
-
-		if(distance_x  &lt;= car_info.length/1.5 &amp;&amp; distance_y &lt;= car_info.width/1.5) // don't detect yourself
+		if(distance_x  &lt;= car_length*0.5 &amp;&amp; distance_y &lt;= car_width*0.5) // don't detect yourself
 			continue;
 
-
+		//obj.center.pos = avg_center;
 		nOrPoints += point_cloud.points.size();
 		nPoints += obj.contour.size();
-		//std::cout &lt;&lt; " Distance_X: " &lt;&lt; distance_x &lt;&lt; ", " &lt;&lt; " Distance_Y: " &lt;&lt; distance_y &lt;&lt; ", " &lt;&lt; " Size: " &lt;&lt; size &lt;&lt; std::endl;
-
+		//std::cout &lt;&lt; " Distance_X: " &lt;&lt; distance_x &lt;&lt; ", " &lt;&lt; " Distance_Y: " &lt;&lt; distance_y &lt;&lt; ", " &lt;&lt; " Size: " &lt;&lt; object_size &lt;&lt; std::endl;
 		obstacles_list.push_back(obj);
 	}
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\SimpleTracker.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\SimpleTracker.h" added_lines="252" deleted_lines="69">
				<diff>@@ -9,6 +9,7 @@
 #define SimpleTracker_H_
 
 #include "RoadNetwork.h"
+#include "PlanningHelpers.h"
 #include "opencv2/video/tracking.hpp"
 #include &lt;vector&gt;
 #include "UtilityH.h"
@@ -20,8 +21,8 @@ namespace SimulationNS
 
 #define DEBUG_TRACKER 0
 #define NEVER_GORGET_TIME -1000
-#define MIN_EVIDENCE_NUMBER 3
-#define TRACKING_HORIZON 150
+
+enum TRACKING_TYPE {ASSOCIATE_ONLY = 0, SIMPLE_TRACKER = 1, CONTOUR_TRACKER = 2};
 
 struct Kalman1dState
 {
@@ -53,7 +54,6 @@ public:
     Kalman1dState Update(double measurement)
     {
     	//prediction update
-		//omit x = x
 		result.p = result.p + result.MovCov;
 
 		//measurement update
@@ -71,34 +71,32 @@ private:
 	cv::KalmanFilter m_filter;
 	double prev_x, prev_y, prev_v, prev_a;
 	long m_id;
-	double dt;
 	int nStates;
 	int nMeasure;
-	double circ_angle;
+	int MinAppearanceCount;
 
 public:
+	int m_bUpdated;
 	int region_id;
 	double forget_time;
 	int m_iLife;
-	PlannerHNS::DetectedObject obj;
-	kalmanFilter1D errorSmoother;
+	PlannerHNS::DetectedObject obj; // Used for associate only , don't remove
+	//kalmanFilter1D errorSmoother;
 
 	long GetTrackID()
 	{
 		return m_id;
 	}
 
-	KFTrackV(double x, double y, double a, long id, double _dt)
+	KFTrackV(double x, double y, double a, long id, double _dt, int _MinAppearanceCount = 1)
 	{
-		circ_angle = 0;
-		errorSmoother.result.MovCov = 0.125;
-		errorSmoother.result.MeasureCov = 0.1;
-		errorSmoother.result.p = 1;
-		errorSmoother.result.x = 0;
+//		errorSmoother.result.MovCov = 0.125;
+//		errorSmoother.result.MeasureCov = 0.1;
+//		errorSmoother.result.p = 1;
+//		errorSmoother.result.x = 0;
 		region_id = -1;
 		forget_time = NEVER_GORGET_TIME; // this is very bad , dangerous
 		m_iLife = 0;
-		dt = _dt;
 		prev_x = x;
 		prev_y = y;
 		prev_v = 0;
@@ -106,17 +104,20 @@ public:
 		nStates = 4;
 		nMeasure = 2;
 
+		MinAppearanceCount = _MinAppearanceCount;
+
 		m_id = id;
+		m_bUpdated = true;
 
 		m_filter = cv::KalmanFilter(nStates,nMeasure);
 #if (CV_MAJOR_VERSION == 2)
-		m_filter.transitionMatrix = *(cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,dt	,0  ,
-				0	,1	,0	,dt	,
+		m_filter.transitionMatrix = *(cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,_dt	,0  ,
+				0	,1	,0	,_dt	,
 				0	,0	,1	,0	,
 				0	,0	,0	,1	);
 #elif (CV_MAJOR_VERSION == 3)
-		m_filter.transitionMatrix = (cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,dt	,0  ,
-				0	,1	,0	,dt	,
+		m_filter.transitionMatrix = (cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,_dt	,0  ,
+				0	,1	,0	,_dt	,
 				0	,0	,1	,0	,
 				0	,0	,0	,1	);
 #endif		
@@ -134,27 +135,25 @@ public:
 		cv::setIdentity(m_filter.processNoiseCov, cv::Scalar::all(0.0001));
 		cv::setIdentity(m_filter.errorCovPost, cv::Scalar::all(0.075));
 
-
 		m_filter.predict();
 
-		errorSmoother.Update(a);
+		//errorSmoother.Update(a);
 	}
 
 	void UpdateTracking(double _dt, const PlannerHNS::DetectedObject&amp; oldObj, PlannerHNS::DetectedObject&amp; predObj)
 	{
-		dt = _dt;
+
 #if (CV_MAJOR_VERSION == 2)
-		m_filter.transitionMatrix = *(cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,dt	,0  ,
-				0	,1	,0	,dt	,
+		m_filter.transitionMatrix = *(cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,_dt	,0  ,
+				0	,1	,0	,_dt	,
 				0	,0	,1	,0	,
 				0	,0	,0	,1	);
 #elif (CV_MAJOR_VERSION == 3)
-		m_filter.transitionMatrix = (cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,dt	,0  ,
-				0	,1	,0	,dt	,
+		m_filter.transitionMatrix = (cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,_dt	,0  ,
+				0	,1	,0	,_dt	,
 				0	,0	,1	,0	,
 				0	,0	,0	,1	);
 #endif		
-		double a_old = oldObj.center.pos.a;
 
 		cv::Mat_&lt;float&gt; measurement(nMeasure,1);
 		cv::Mat_&lt;float&gt; prediction(nStates,1);
@@ -169,54 +168,237 @@ public:
 		double vx  = prediction.at&lt;float&gt;(2);
 		double vy  = prediction.at&lt;float&gt;(3);
 
-		if(m_iLife &gt; 10)
+		double currA = 0;
+		double currV = 0;
+
+		if(m_iLife &gt; 1)
 		{
-			predObj.center.v = sqrt(vx*vx+vy*vy);
+			currV = sqrt(vx*vx+vy*vy);
+
 			double diff_y = predObj.center.pos.y - prev_y;
 			double diff_x = predObj.center.pos.x - prev_x;
-			if(hypot(diff_y, diff_x) &gt; 0.15)
+			if(hypot(diff_y, diff_x) &gt; 0.2)
+			{
+				currA = atan2(diff_y, diff_x);
+			}
+			else
+			{
+				currA = prev_a;
+			}
+		}
+
+
+		if(m_iLife &gt; MinAppearanceCount)
+		{
+			predObj.center.pos.a = currA;
+			predObj.center.v = currV;
+			predObj.bVelocity = true;
+			predObj.acceleration = UtilityHNS::UtilityH::GetSign(predObj.center.v - prev_v);
+		}
+		else
+		{
+			predObj.bDirection = false;
+			predObj.bVelocity = false;
+		}
+
+		if(predObj.centers_list.size() &gt; 30)
+					predObj.centers_list.erase(predObj.centers_list.begin()+0);
+
+		if(predObj.centers_list.size() &gt; 1)
+		{
+			double diff_y = predObj.center.pos.y - predObj.centers_list.at(predObj.centers_list.size()-1).pos.y;
+			double diff_x = predObj.center.pos.x - predObj.centers_list.at(predObj.centers_list.size()-1).pos.x;
+			if(hypot(diff_y, diff_x) &gt; 0.1)
+			{
+				predObj.centers_list.push_back(predObj.center);
+				PlannerHNS::PlanningHelpers::SmoothPath(predObj.centers_list, 0.3, 0.4, 0.1);
+				PlannerHNS::PlanningHelpers::CalcAngleAndCost(predObj.centers_list);
+			}
+		}
+		else
+			predObj.centers_list.push_back(predObj.center);
+
+		if(predObj.centers_list.size()&gt;3)
+		{
+			predObj.bDirection = true;
+			predObj.center.pos.a = (predObj.centers_list.at(predObj.centers_list.size()-1).pos.a + predObj.centers_list.at(predObj.centers_list.size()-2).pos.a + predObj.centers_list.at(predObj.centers_list.size()-3).pos.a)/3.0;
+		}
+		else if(predObj.centers_list.size()&gt;2)
+		{
+			predObj.center.pos.a = (predObj.centers_list.at(predObj.centers_list.size()-1).pos.a + predObj.centers_list.at(predObj.centers_list.size()-2).pos.a)/2.0;
+		}
+		else if(predObj.centers_list.size()&gt;1)
+		{
+			predObj.center.pos.a = predObj.centers_list.at(predObj.centers_list.size()-1).pos.a;
+		}
+
+
+		m_filter.predict();
+		m_filter.statePre.copyTo(m_filter.statePost);
+		m_filter.errorCovPre.copyTo(m_filter.errorCovPost);
+
+		prev_a = currA;
+		prev_y = predObj.center.pos.y;
+		prev_x = predObj.center.pos.x;
+		prev_v = currV;
+		forget_time -= _dt;
+		m_iLife++;
+	}
+
+	void PredictTracking(double _dt, const PlannerHNS::DetectedObject&amp; oldObj, PlannerHNS::DetectedObject&amp; predObj)
+	{
+		if(m_iLife &lt; MinAppearanceCount)
+		{
+			forget_time -= _dt;
+			return;
+		}
+
+#if (CV_MAJOR_VERSION == 2)
+		m_filter.transitionMatrix = *(cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,_dt	,0  ,
+				0	,1	,0	,_dt	,
+				0	,0	,1	,0	,
+				0	,0	,0	,1	);
+#elif (CV_MAJOR_VERSION == 3)
+		m_filter.transitionMatrix = (cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,_dt	,0  ,
+				0	,1	,0	,_dt	,
+				0	,0	,1	,0	,
+				0	,0	,0	,1	);
+#endif
+
+
+		cv::Mat_&lt;float&gt; prediction(nStates,1);
+
+		prediction = m_filter.predict();
+
+		predObj.center.pos.x = prediction.at&lt;float&gt;(0);
+		predObj.center.pos.y = prediction.at&lt;float&gt;(1);
+		double vx  = prediction.at&lt;float&gt;(2);
+		double vy  = prediction.at&lt;float&gt;(3);
+
+		double currA = 0;
+		double currV = 0;
+
+		if(m_iLife &gt; 1)
+		{
+			currV = sqrt(vx*vx+vy*vy);
+
+			double diff_y = predObj.center.pos.y - prev_y;
+			double diff_x = predObj.center.pos.x - prev_x;
+			if(hypot(diff_y, diff_x) &gt; 0.2)
 			{
 				prev_y = oldObj.center.pos.y;
 				prev_x = oldObj.center.pos.x;
-				predObj.center.pos.a = atan2(diff_y, diff_x);
+				currA = atan2(diff_y, diff_x);
+				prev_a = currA;
 			}
 			else
 			{
-				predObj.center.pos.a = oldObj.center.pos.a;
+				currA = prev_a;
 			}
 
-			//if(predObj.center.v &gt; 0.1)
+			for(unsigned int k=0; k &lt; obj.contour.size(); k++)
 			{
-				predObj.bDirection = true;
-				predObj.bVelocity = true;
+				obj.contour.at(k).x += diff_x;
+				obj.contour.at(k).y += diff_y;
 			}
-			predObj.acceleration = UtilityHNS::UtilityH::GetSign(predObj.center.v - oldObj.center.v);
+		}
+
+
+		if(m_iLife &gt; MinAppearanceCount)
+		{
+			predObj.center.pos.a = currA;
+			predObj.center.v = currV;
 
+			predObj.bVelocity = true;
+			predObj.acceleration = UtilityHNS::UtilityH::GetSign(predObj.center.v - oldObj.center.v);
 		}
 		else
 		{
-			predObj.center.v = 0;
-			//predObj.center.pos.a = oldObj.center.pos.a;
-			predObj.center.pos.a = predObj.actual_yaw;
+			predObj.bDirection = false;
+			predObj.bVelocity = false;
 		}
 
-		//circ_angle = UtilityHNS::UtilityH::GetCircularAngle(circ_angle, UtilityHNS::UtilityH::FixNegativeAngle(a_old), UtilityHNS::UtilityH::FixNegativeAngle(predObj.center.pos.a));
-		//circ_angle =  errorSmoother.Update(circ_angle).x;
-		//predObj.center.pos.a = UtilityHNS::UtilityH::SplitPositiveAngle(circ_angle);
+		if(predObj.centers_list.size() &gt; 30)
+					predObj.centers_list.erase(predObj.centers_list.begin()+0);
+
+		if(predObj.centers_list.size() &gt; 1)
+		{
+			double diff_y = predObj.center.pos.y - predObj.centers_list.at(predObj.centers_list.size()-1).pos.y;
+			double diff_x = predObj.center.pos.x - predObj.centers_list.at(predObj.centers_list.size()-1).pos.x;
+			if(hypot(diff_y, diff_x) &gt; 0.1)
+			{
+				predObj.centers_list.push_back(predObj.center);
+				PlannerHNS::PlanningHelpers::SmoothPath(predObj.centers_list, 0.3, 0.4, 0.1);
+				PlannerHNS::PlanningHelpers::CalcAngleAndCost(predObj.centers_list);
+			}
+		}
+		else
+			predObj.centers_list.push_back(predObj.center);
 
-		if(predObj.center.v &lt; 0.1)
-			predObj.center.v = 0;
+		if(predObj.centers_list.size()&gt;3)
+		{
+			predObj.bDirection = true;
+			predObj.center.pos.a = (predObj.centers_list.at(predObj.centers_list.size()-1).pos.a + predObj.centers_list.at(predObj.centers_list.size()-2).pos.a + predObj.centers_list.at(predObj.centers_list.size()-3).pos.a)/3.0;
+		}
+		else if(predObj.centers_list.size()&gt;2)
+		{
+			predObj.center.pos.a = (predObj.centers_list.at(predObj.centers_list.size()-1).pos.a + predObj.centers_list.at(predObj.centers_list.size()-2).pos.a)/2.0;
+		}
+		else if(predObj.centers_list.size()&gt;1)
+		{
+			predObj.center.pos.a = predObj.centers_list.at(predObj.centers_list.size()-1).pos.a;
+		}
 
-		//std::cout &lt;&lt; "Track: Old (" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; "), New (" &lt;&lt; x_new &lt;&lt; ", " &lt;&lt; y_new &lt;&lt; ")" &lt;&lt; std::endl;
-		//std::cout &lt;&lt; "Track: " &lt;&lt; m_id &lt;&lt; ", A: " &lt;&lt; a &lt;&lt; ", A_new:(" &lt;&lt; circ_angle &lt;&lt; "," &lt;&lt;  a_new &lt;&lt; ") , V" &lt;&lt; v &lt;&lt; ", dt: " &lt;&lt; dt &lt;&lt; ", forget_time: " &lt;&lt; forget_time &lt;&lt; std::endl;
 
-		m_filter.predict();
+		//m_filter.predict();
 		m_filter.statePre.copyTo(m_filter.statePost);
 		m_filter.errorCovPre.copyTo(m_filter.errorCovPost);
 
-		forget_time -= dt;
+		prev_v = currV;
+
+		forget_time -= _dt;
 		m_iLife++;
 	}
+
+	void UpdateAssociateOnly(double _dt, const PlannerHNS::DetectedObject&amp; oldObj, PlannerHNS::DetectedObject&amp; predObj)
+	{
+		if(predObj.centers_list.size() &gt; 30)
+			predObj.centers_list.erase(predObj.centers_list.begin()+0);
+
+		if(predObj.centers_list.size() &gt; 1)
+		{
+			double diff_y = predObj.center.pos.y - predObj.centers_list.at(predObj.centers_list.size()-1).pos.y;
+			double diff_x = predObj.center.pos.x - predObj.centers_list.at(predObj.centers_list.size()-1).pos.x;
+			if(hypot(diff_y, diff_x) &gt; 0.1)
+			{
+				predObj.centers_list.push_back(predObj.center);
+				PlannerHNS::PlanningHelpers::SmoothPath(predObj.centers_list, 0.3, 0.4, 0.1);
+				PlannerHNS::PlanningHelpers::CalcAngleAndCost(predObj.centers_list);
+			}
+		}
+		else
+			predObj.centers_list.push_back(predObj.center);
+
+		if(predObj.centers_list.size()&gt;3)
+		{
+			predObj.bDirection = true;
+			predObj.center.pos.a = (predObj.centers_list.at(predObj.centers_list.size()-1).pos.a + predObj.centers_list.at(predObj.centers_list.size()-2).pos.a + predObj.centers_list.at(predObj.centers_list.size()-3).pos.a)/3.0;
+		}
+		else if(predObj.centers_list.size()&gt;2)
+		{
+			predObj.bDirection = true;
+			predObj.center.pos.a = (predObj.centers_list.at(predObj.centers_list.size()-1).pos.a + predObj.centers_list.at(predObj.centers_list.size()-2).pos.a)/2.0;
+		}
+		else if(predObj.centers_list.size()&gt;1)
+		{
+			predObj.bDirection = false;
+			predObj.center.pos.a = predObj.centers_list.at(predObj.centers_list.size()-1).pos.a;
+		}
+		else
+			predObj.bDirection = false;
+
+	}
+
 	virtual ~KFTrackV(){}
 };
 
@@ -227,16 +409,12 @@ public:
 	double radius;
 	double forget_time;
 	std::vector&lt;KFTrackV*&gt; pTrackers;
-//	InterestCircle* pPrevCircle;
-//	InterestCircle* pNextCircle;
 
 	InterestCircle(int _id)
 	{
 		id = _id;
 		radius = 0;
 		forget_time = NEVER_GORGET_TIME; // never forget
-//		pPrevCircle = 0;
-//		pNextCircle = 0;
 	}
 };
 
@@ -263,38 +441,43 @@ public:
 	timespec m_TrackTimer;
 	long iTracksNumber;
 	PlannerHNS::WayPoint m_PrevState;
+	PlannerHNS::WayPoint m_StateDiff;
 	std::vector&lt;PlannerHNS::DetectedObject&gt; m_PrevDetectedObjects;
 	std::vector&lt;PlannerHNS::DetectedObject&gt; m_DetectedObjects;
 
-	void CreateTrack(PlannerHNS::DetectedObject&amp; o);
-	void CreateTrackV2(PlannerHNS::DetectedObject&amp; o);
-	KFTrackV* FindTrack(long index);
-	void Track(std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; objects_list);
-	void TrackV2();
-	void CoordinateTransform(const PlannerHNS::WayPoint&amp; refCoordinate, PlannerHNS::DetectedObject&amp; obj);
-	void CoordinateTransformPoint(const PlannerHNS::WayPoint&amp; refCoordinate, PlannerHNS::GPSPoint&amp; obj);
-	void AssociateObjects();
-	void InitializeInterestRegions(double horizon, double init_raduis, double init_time, std::vector&lt;InterestCircle*&gt;&amp; regions);
-	void AssociateAndTrack();
-	void AssociateSimply();
-	void AssociateToRegions(KFTrackV&amp; detectedObject);
-	void CleanOldTracks();
-
-	void DoOneStep(const PlannerHNS::WayPoint&amp; currPose, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
+	void DoOneStep(const PlannerHNS::WayPoint&amp; currPose, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list, const TRACKING_TYPE&amp; type = SIMPLE_TRACKER);
 
 	SimpleTracker();
 	virtual ~SimpleTracker();
 	void InitSimpleTracker();
+	void InitializeInterestRegions(std::vector&lt;InterestCircle*&gt;&amp; regions);
 
 public:
-	double m_DT;
+	double m_dt;
 	double m_MAX_ASSOCIATION_DISTANCE;
-	int m_MAX_TRACKS_AFTER_LOSING;
 	bool m_bUseCenterOnly;
 	double m_MaxKeepTime;
 	bool m_bFirstCall;
+	int m_nMinTrustAppearances;
+	double m_Horizon;
+	double m_CirclesResolution;
+	double m_MAX_ASSOCIATION_SIZE_DIFF;
+	double m_MAX_ASSOCIATION_ANGLE_DIFF;
+
+private:
+	std::vector&lt;KFTrackV&gt; newObjects;
+	void AssociateAndTrack();
+	void AssociateSimply();
+	void AssociateToRegions(KFTrackV&amp; detectedObject);
+	void CleanOldTracks();
+	void AssociateOnly();
+	void MergeObjectAndTrack(KFTrackV&amp; track, PlannerHNS::DetectedObject&amp; obj);
+	int InsidePolygon(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; polygon,const PlannerHNS::GPSPoint&amp; p);
+
+	void MatchClosest();
+
 };
 
-} /* namespace BehaviorsNS */
+}
 
 #endif /* SimpleTracker_H_ */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\PlannerTestDraw.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\PlannerTestDraw.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -1415,7 +1415,6 @@ void* PlannerTestDraw::PlanningThreadStaticEntryPoint(void* pThis)
 	PlannerHNS::PlannerH planner;
 	SimpleTracker obstacleTracking;
 	obstacleTracking.m_MAX_ASSOCIATION_DISTANCE = 1;
-	obstacleTracking.m_MAX_TRACKS_AFTER_LOSING = 5;
 	obstacleTracking.m_bUseCenterOnly = true;
 
 	vector&lt;string&gt; behaviorsLogData;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\SimpleTracker.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\SimpleTracker.cpp" added_lines="282" deleted_lines="295">
				<diff>@@ -7,7 +7,6 @@
 
 #include "SimpleTracker.h"
 #include "MatrixOperations.h"
-#include "PlanningHelpers.h"
 #include "UtilityH.h"
 
 #include &lt;iostream&gt;
@@ -26,19 +25,23 @@ using namespace PlannerHNS;
 SimpleTracker::SimpleTracker()
 {
 	iTracksNumber = 1;
-	m_DT = 0.1;
-	m_MAX_ASSOCIATION_DISTANCE = 3.0;
-	m_MAX_TRACKS_AFTER_LOSING = 10;
+	m_dt = 0.1;
+	m_MAX_ASSOCIATION_DISTANCE = 2.0;
+	m_MAX_ASSOCIATION_SIZE_DIFF = 1.0;
+	m_MAX_ASSOCIATION_ANGLE_DIFF = 0.44;
 	m_MaxKeepTime = 2; // seconds
 	m_bUseCenterOnly = true;
 	m_bFirstCall = true;
+	m_nMinTrustAppearances = 5;
+	m_Horizon = 100.0;
+	m_CirclesResolution = 5.0;
 	UtilityHNS::UtilityH::GetTickCount(m_TrackTimer);
 }
 
 void SimpleTracker::InitSimpleTracker()
 {
 	UtilityHNS::UtilityH::GetTickCount(m_TrackTimer);
-	InitializeInterestRegions(TRACKING_HORIZON, 5, 5, m_InterestRegions);
+	InitializeInterestRegions(m_InterestRegions);
 }
 
 SimpleTracker::~SimpleTracker()
@@ -57,410 +60,394 @@ SimpleTracker::~SimpleTracker()
 
 }
 
-void SimpleTracker::InitializeInterestRegions(double horizon, double init_raduis, double init_time, std::vector&lt;InterestCircle*&gt;&amp; regions)
+void SimpleTracker::InitializeInterestRegions(std::vector&lt;InterestCircle*&gt;&amp; regions)
 {
 	//initialize interest regions
-	double distance = 0;
-	while(distance &lt;= horizon)
+	double next_raduis = m_CirclesResolution;
+	double next_foget_time = m_MaxKeepTime;
+	while(1)
 	{
 		InterestCircle* pCir = new InterestCircle(regions.size()+1);
 		if(regions.size() == 0)
 		{
-			pCir-&gt;radius = 5;
-			//pCir-&gt;pPrevCircle = 0;
-			pCir-&gt;forget_time = NEVER_GORGET_TIME;
-			pCir-&gt;forget_time = m_MaxKeepTime*2.0;
-			pCir-&gt;forget_time = m_MaxKeepTime;
+			pCir-&gt;radius = next_raduis;
+			pCir-&gt;forget_time = next_foget_time;
 			regions.push_back(pCir);
 			std::cout &lt;&lt; "Region No: " &lt;&lt; regions.size() &lt;&lt; ", Radius: " &lt;&lt; pCir-&gt;radius &lt;&lt; ", F time: " &lt;&lt; pCir-&gt;forget_time &lt;&lt; std::endl;
 		}
 		else
 		{
-			int iPrev = regions.size()-1;
-			if(regions.size() &gt; 1)
-				pCir-&gt;radius = regions.at(iPrev)-&gt;radius + regions.at(iPrev-1)-&gt;radius;
-			else
-				pCir-&gt;radius = regions.at(iPrev)-&gt;radius + regions.at(iPrev)-&gt;radius;
-
-//			regions.at(iPrev)-&gt;pNextCircle = pCir;
-//			pCir-&gt;pPrevCircle = regions.at(iPrev);
-			pCir-&gt;forget_time = m_MaxKeepTime-iPrev-2;
-			pCir-&gt;forget_time = m_MaxKeepTime;
-			if(pCir-&gt;forget_time &lt;= 0 )
-				pCir-&gt;forget_time = 0.2;
+			pCir-&gt;radius = next_raduis;
+			pCir-&gt;forget_time = next_foget_time;
 			regions.push_back(pCir);
 
 			std::cout &lt;&lt; "Region No: " &lt;&lt; regions.size() &lt;&lt; ", Radius: " &lt;&lt; pCir-&gt;radius &lt;&lt; ", F time: " &lt;&lt; pCir-&gt;forget_time &lt;&lt; std::endl;
 		}
 
-		distance = pCir-&gt;radius;
+		if(next_raduis &gt;= m_Horizon)
+			break;
+
+		next_raduis += next_raduis * 0.8;
+		if(next_raduis &gt; m_Horizon)
+			next_raduis = m_Horizon;
+		next_foget_time -= next_foget_time * 0.25;
+		if(next_foget_time &lt; 0.1)
+			next_foget_time = 0.1;
 	}
 }
 
-void SimpleTracker::AssociateToRegions(KFTrackV&amp; detectedObject)
+void SimpleTracker::DoOneStep(const WayPoint&amp; currPose, const std::vector&lt;DetectedObject&gt;&amp; obj_list, const TRACKING_TYPE&amp; type)
 {
-	for(unsigned int i = 0; i &lt; m_InterestRegions.size(); i++)
+	if(!m_bFirstCall)
 	{
-		m_InterestRegions.at(i)-&gt;pTrackers.clear();
-		if(detectedObject.obj.distance_to_center &lt;= m_InterestRegions.at(i)-&gt;radius)
-		{
-			detectedObject.region_id = m_InterestRegions.at(i)-&gt;id;
-			detectedObject.forget_time = m_InterestRegions.at(i)-&gt;forget_time;
-			//std::cout &lt;&lt; "Associate Object: " &lt;&lt; detectedObject.obj.id &lt;&lt; ", With Region: " &lt;&lt; detectedObject.region_id &lt;&lt; ", And Time: " &lt;&lt; detectedObject.forget_time &lt;&lt; std::endl;
-			return;
-		}
+		m_dt = UtilityHNS::UtilityH::GetTimeDiffNow(m_TrackTimer);
+		m_StateDiff.pos.x = m_PrevState.pos.x - currPose.pos.x ;
+		m_StateDiff.pos.y = m_PrevState.pos.y - currPose.pos.y;
+		m_StateDiff.pos.a = UtilityHNS::UtilityH::AngleBetweenTwoAnglesPositive(currPose.pos.a, m_PrevState.pos.a) * UtilityHNS::UtilityH::GetSign(m_PrevState.pos.a - currPose.pos.a);
+		//std::cout &lt;&lt; "(" &lt;&lt; m_StateDiff.pos.x &lt;&lt; ", " &lt;&lt; m_StateDiff.pos.y &lt;&lt; ", " &lt;&lt; m_StateDiff.pos.a &lt;&lt; std::endl;
 	}
+	else
+		m_bFirstCall = false;
 
-	if(m_InterestRegions.size() &gt; 0)
+	UtilityHNS::UtilityH::GetTickCount(m_TrackTimer);
+
+	m_DetectedObjects = obj_list;
+
+	if(type == ASSOCIATE_ONLY)
 	{
-		detectedObject.region_id = m_InterestRegions.at(m_InterestRegions.size()-1)-&gt;id;
-		detectedObject.forget_time = m_InterestRegions.at(m_InterestRegions.size()-1)-&gt;forget_time;
-		//std::cout &lt;&lt; "Associate Object: " &lt;&lt; detectedObject.obj.id &lt;&lt; ", With Region: " &lt;&lt; detectedObject.region_id &lt;&lt; ", And Time: " &lt;&lt; detectedObject.forget_time &lt;&lt; std::endl;
+		AssociateOnly();
 	}
+	else if (type == SIMPLE_TRACKER)
+	{
+		AssociateSimply();
+	}
+	else
+	{
+		AssociateAndTrack();
+		CleanOldTracks();
+	}
+
+	m_PrevState = currPose;
+
 }
 
-void SimpleTracker::AssociateAndTrack()
+void SimpleTracker::MatchClosest()
 {
-	DetectedObject* prev_obj;
-	DetectedObject* curr_obj;
-
-	std::vector&lt;CostRecordSet&gt; matching_matrix;
+	newObjects.clear();
 
-	for(unsigned int i = 0 ; i &lt; m_DetectedObjects.size(); i++)
+	while(m_DetectedObjects.size() &gt; 0)
 	{
-		double minCost = 99999999;
-		double minID = -1;
-
-		curr_obj = &amp;m_DetectedObjects.at(i);
-		curr_obj-&gt;center.cost = 0;
-
-		matching_matrix.push_back(CostRecordSet(i, -1, 0));
-
-		for(unsigned int j = 0; j &lt; m_Tracks.size(); j++)
+		double iCloseset_track = -1;
+		double iCloseset_obj = -1;
+		double dCloseset = 99999999;
+		bool bFoundMatch = false;
+		double min_size = -1;
+		//std::cout &lt;&lt; "DetObjSize: " &lt;&lt;  m_DetectedObjects.size() &lt;&lt;  ", TracksSize: " &lt;&lt; m_TrackSimply.size() &lt;&lt; std::endl;
+		for(unsigned int jj = 0; jj &lt; m_DetectedObjects.size(); jj++)
 		{
-			prev_obj = &amp;m_Tracks.at(j)-&gt;obj;
-			double expected_d = prev_obj-&gt;center.v * m_DT;
+			double object_size = hypot(m_DetectedObjects.at(jj).w, m_DetectedObjects.at(jj).l);
 
-			if(m_bUseCenterOnly)
+			for(unsigned int i = 0; i &lt; m_TrackSimply.size(); i++)
 			{
-				curr_obj-&gt;center.cost = fabs(hypot(curr_obj-&gt;center.pos.y- prev_obj-&gt;center.pos.y, curr_obj-&gt;center.pos.x- prev_obj-&gt;center.pos.x) - expected_d);
-			}
-			else
-			{
-				for(unsigned int k = 0; k &lt; curr_obj-&gt;contour.size(); k++)
-					for(unsigned int pk = 0; pk &lt; prev_obj-&gt;contour.size(); pk++)
-						curr_obj-&gt;center.cost += fabs(hypot(curr_obj-&gt;contour.at(k).y -prev_obj-&gt;contour.at(pk).y, curr_obj-&gt;contour.at(k).x -prev_obj-&gt;contour.at(pk).x) - expected_d);
-
-				curr_obj-&gt;center.cost = curr_obj-&gt;center.cost/(double)(curr_obj-&gt;contour.size()*prev_obj-&gt;contour.size());
-			}
+				double old_size = hypot(m_TrackSimply.at(i).obj.w, m_TrackSimply.at(i).obj.l);
+				double obj_diff = fabs(object_size - old_size);
+				double d = hypot(m_DetectedObjects.at(jj).center.pos.y-m_TrackSimply.at(i).obj.center.pos.y, m_DetectedObjects.at(jj).center.pos.x-m_TrackSimply.at(i).obj.center.pos.x);
 
-			if(DEBUG_TRACKER)
-				std::cout &lt;&lt; "Cost Cost (" &lt;&lt; i &lt;&lt; "), " &lt;&lt; prev_obj-&gt;center.pos.ToString() &lt;&lt; ","
-						&lt;&lt; curr_obj-&gt;center.cost &lt;&lt;  ", contour: " &lt;&lt; curr_obj-&gt;contour.size()
-						&lt;&lt; ", " &lt;&lt; curr_obj-&gt;center.pos.ToString() &lt;&lt; std::endl;
+				bool bInsidePolygon = (InsidePolygon(m_TrackSimply.at(i).obj.contour, m_DetectedObjects.at(jj).center.pos) == 1 || InsidePolygon(m_DetectedObjects.at(jj).contour, m_TrackSimply.at(i).obj.center.pos) == 1);
+				bool bDirectionMatch = false;
+				if(m_TrackSimply.at(i).obj.bDirection)
+				{
+					double diff_y = m_DetectedObjects.at(jj).center.pos.y - m_TrackSimply.at(i).obj.center.pos.y;
+					double diff_x = m_DetectedObjects.at(jj).center.pos.x - m_TrackSimply.at(i).obj.center.pos.x;
+					double angle_diff = 100;
+					if(hypot(diff_y, diff_x) &gt; 0.2)
+					{
+						angle_diff = UtilityHNS::UtilityH::FixNegativeAngle(atan2(diff_y, diff_x));
+						if(UtilityHNS::UtilityH::AngleBetweenTwoAnglesPositive(angle_diff,m_TrackSimply.at(i).obj.center.pos.a) &lt; m_MAX_ASSOCIATION_ANGLE_DIFF)
+							bDirectionMatch = true;
+					}
+				}
 
-			if(curr_obj-&gt;center.cost &lt; minCost)
-			{
-				minCost = curr_obj-&gt;center.cost;
-				minID = j;
-			}
-		}
+				//std::cout &lt;&lt; "Test: " &lt;&lt; m_TrackSimply.at(i).obj.id &lt;&lt; ", MinD: " &lt;&lt; d &lt;&lt; ", ObjS: " &lt;&lt; object_size &lt;&lt; ", ObjI: " &lt;&lt; jj &lt;&lt; ", TrackS: " &lt;&lt; old_size &lt;&lt; ", TrackI: " &lt;&lt; i &lt;&lt; std::endl;
 
-		bool bSkip = false;
+				if(obj_diff &lt; m_MAX_ASSOCIATION_SIZE_DIFF &amp;&amp;  bInsidePolygon)
+				 {
+					 bFoundMatch = true;
+					 iCloseset_track = i;
+					 iCloseset_obj = jj;
+					 break;
+				 }
 
-		for(unsigned int k = 0; k &lt; matching_matrix.size(); k++)
-		{
-			if(matching_matrix.at(k).prevObj == minID)
-			{
-				if(minCost &lt; matching_matrix.at(k).cost)
+				if(obj_diff &lt; m_MAX_ASSOCIATION_SIZE_DIFF &amp;&amp; d &lt; dCloseset)
 				{
-					matching_matrix.at(k).prevObj = minID;
-					matching_matrix.at(k).cost = minCost;
+					dCloseset = d;
+					iCloseset_track = i;
+					iCloseset_obj = jj;
+					min_size = obj_diff;
 				}
-				bSkip = true;
-				break;
 			}
-		}
 
-		if(!bSkip &amp;&amp; minID &gt;= 0 &amp;&amp; minCost &lt;= m_MAX_ASSOCIATION_DISTANCE)
-		{
-			matching_matrix.at(i).prevObj = minID;
-			matching_matrix.at(i).cost = minCost;
+			if(bFoundMatch)
+				break;
 		}
-	}
 
-	for(unsigned int i = 0 ; i &lt; matching_matrix.size(); i ++)
-	{
-		curr_obj =  &amp;m_DetectedObjects.at(matching_matrix.at(i).currobj);
 
-		if(matching_matrix.at(i).prevObj == -1)
-		{
-			 CreateTrackV2(*curr_obj);
-			if(DEBUG_TRACKER)
-				std::cout &lt;&lt; "New Matching Index: " &lt;&lt; matching_matrix.at(i).currobj &lt;&lt; ", "&lt;&lt; matching_matrix.at(i).cost&lt;&lt; ", " &lt;&lt; iTracksNumber &lt;&lt; std::endl;
-		}
-		else
-		{
-			curr_obj-&gt;id = m_Tracks.at(matching_matrix.at(i).prevObj)-&gt;obj.id;
-			curr_obj-&gt;center.pos.a = m_Tracks.at(matching_matrix.at(i).prevObj)-&gt;obj.center.pos.a;
-			m_Tracks.at(matching_matrix.at(i).prevObj)-&gt;obj = *curr_obj;
-			AssociateToRegions(*m_Tracks.at(matching_matrix.at(i).prevObj));
-			if(DEBUG_TRACKER)
-				std::cout &lt;&lt; "ObjIndex: " &lt;&lt;  matching_matrix.at(i).currobj &lt;&lt;  ", Matched with ID  " &lt;&lt; prev_obj-&gt;id &lt;&lt; ", "&lt;&lt; matching_matrix.at(i).cost &lt;&lt; std::endl;
-		}
-	}
-}
-
-void SimpleTracker::AssociateSimply()
-{
-	std::vector&lt;KFTrackV&gt; newObjects;
-	for(unsigned int j = 0; j &lt; m_DetectedObjects.size(); j++)
-	{
-		double iCloseset = 0;
-		double dCloseset = 9999999;
-		for(unsigned int i = 0; i &lt; m_TrackSimply.size(); i++)
-		{
-			double d = hypot(m_DetectedObjects.at(j).center.pos.y-m_TrackSimply.at(i).obj.center.pos.y, m_DetectedObjects.at(j).center.pos.x-m_TrackSimply.at(i).obj.center.pos.x);
-			if(d &lt; dCloseset)
-			{
-				dCloseset = d;
-				iCloseset = i;
-			}
-		}
 
-		if(dCloseset &lt;= m_MAX_ASSOCIATION_DISTANCE)
+		if(iCloseset_obj != -1 &amp;&amp; iCloseset_track != -1 &amp;&amp; (dCloseset &lt;= m_MAX_ASSOCIATION_DISTANCE || bFoundMatch == true))
 		{
-			m_DetectedObjects.at(j).id = m_TrackSimply.at(iCloseset).obj.id;
-			m_DetectedObjects.at(j).center.pos.a = m_TrackSimply.at(iCloseset).obj.center.pos.a;
-			m_TrackSimply.at(iCloseset).obj = m_DetectedObjects.at(j);
-			newObjects.push_back(m_TrackSimply.at(iCloseset));
+			//std::cout &lt;&lt; "MatchObj: " &lt;&lt; m_TrackSimply.at(iCloseset_track).obj.id &lt;&lt; ", MinD: " &lt;&lt; dCloseset &lt;&lt; ", MinS: " &lt;&lt; min_size &lt;&lt; ", ObjI" &lt;&lt; iCloseset_obj &lt;&lt;", TrackI: " &lt;&lt; iCloseset_track &lt;&lt; ", ContourMatch: " &lt;&lt; bFoundMatch &lt;&lt; std::endl;
+			m_DetectedObjects.at(iCloseset_obj).id = m_TrackSimply.at(iCloseset_track).obj.id;
+			MergeObjectAndTrack(m_TrackSimply.at(iCloseset_track), m_DetectedObjects.at(iCloseset_obj));
+			newObjects.push_back(m_TrackSimply.at(iCloseset_track));
+			m_TrackSimply.erase(m_TrackSimply.begin()+iCloseset_track);
+			m_DetectedObjects.erase(m_DetectedObjects.begin()+iCloseset_obj);
 		}
 		else
 		{
 			iTracksNumber = iTracksNumber + 1;
-			m_DetectedObjects.at(j).id = iTracksNumber;
-			KFTrackV track(m_DetectedObjects.at(j).center.pos.x, m_DetectedObjects.at(j).center.pos.y,m_DetectedObjects.at(j).center.pos.a, m_DetectedObjects.at(j).id, m_DT);
-			track.obj = m_DetectedObjects.at(j);
-			newObjects.push_back(track);
+			if(iCloseset_obj != -1)
+			{
+				m_DetectedObjects.at(iCloseset_obj).id = iTracksNumber;
+				KFTrackV track(m_DetectedObjects.at(iCloseset_obj).center.pos.x, m_DetectedObjects.at(iCloseset_obj).center.pos.y,m_DetectedObjects.at(iCloseset_obj).actual_yaw, m_DetectedObjects.at(iCloseset_obj).id, m_dt, m_nMinTrustAppearances);
+				track.obj = m_DetectedObjects.at(iCloseset_obj);
+				newObjects.push_back(track);
+				//std::cout &lt;&lt; "NewObj: " &lt;&lt; iTracksNumber  &lt;&lt; ", MinD: " &lt;&lt; dCloseset &lt;&lt; ", MinS: " &lt;&lt; min_size &lt;&lt; ", ObjI:" &lt;&lt; iCloseset_obj &lt;&lt;", TrackI: " &lt;&lt; iCloseset_track &lt;&lt; ", ContMatch: " &lt;&lt; bFoundMatch &lt;&lt; std::endl;
+				m_DetectedObjects.erase(m_DetectedObjects.begin()+iCloseset_obj);
+			}
+			else
+			{
+				m_DetectedObjects.at(0).id = iTracksNumber;
+				KFTrackV track(m_DetectedObjects.at(0).center.pos.x, m_DetectedObjects.at(0).center.pos.y,m_DetectedObjects.at(0).actual_yaw, m_DetectedObjects.at(0).id, m_dt, m_nMinTrustAppearances);
+				track.obj = m_DetectedObjects.at(0);
+				newObjects.push_back(track);
+				//std::cout &lt;&lt; "NewObj: " &lt;&lt; iTracksNumber  &lt;&lt; ", MinD: " &lt;&lt; dCloseset &lt;&lt; ", MinS: " &lt;&lt; min_size &lt;&lt; ", ObjI:" &lt;&lt; 0 &lt;&lt;", TrackI: " &lt;&lt; iCloseset_track &lt;&lt; ", ContMatch: " &lt;&lt; bFoundMatch &lt;&lt; std::endl;
+				m_DetectedObjects.erase(m_DetectedObjects.begin()+0);
+			}
 		}
 	}
 
 	m_TrackSimply = newObjects;
+}
+
+void SimpleTracker::AssociateOnly()
+{
+	MatchClosest();
 
 	for(unsigned int i =0; i&lt; m_TrackSimply.size(); i++)
-		m_TrackSimply.at(i).UpdateTracking(m_DT, m_TrackSimply.at(i).obj, m_TrackSimply.at(i).obj);
+		m_TrackSimply.at(i).UpdateAssociateOnly(m_dt, m_TrackSimply.at(i).obj, m_TrackSimply.at(i).obj);
 
 	m_DetectedObjects.clear();
 	for(unsigned int i = 0; i&lt; m_TrackSimply.size(); i++)
 		m_DetectedObjects.push_back(m_TrackSimply.at(i).obj);
 }
 
-void SimpleTracker::CreateTrackV2(DetectedObject&amp; o)
+void SimpleTracker::AssociateSimply()
 {
-	iTracksNumber = iTracksNumber + 1;
-	o.id = iTracksNumber;
-	KFTrackV* pT = new KFTrackV(o.center.pos.x, o.center.pos.y,o.center.pos.a, o.id, m_DT);
-	pT-&gt;obj = o;
-	AssociateToRegions(*pT);
-	m_Tracks.push_back(pT);
-}
+	for(unsigned int i = 0; i &lt; m_TrackSimply.size(); i++)
+		m_TrackSimply.at(i).m_bUpdated = false;
 
-void SimpleTracker::TrackV2()
-{
-	for(unsigned int i =0; i&lt; m_Tracks.size(); i++)
-	{
-		m_Tracks.at(i)-&gt;UpdateTracking(m_DT, m_Tracks.at(i)-&gt;obj, m_Tracks.at(i)-&gt;obj);
+	MatchClosest();
 
-		//std::cout&lt;&lt; "Obj ID: " &lt;&lt; m_Tracks.at(i)-&gt;GetTrackID() &lt;&lt; ", Remaining Time: " &lt;&lt;  m_Tracks.at(i)-&gt;forget_time  &lt;&lt; std::endl;
-	}
+	for(unsigned int i =0; i&lt; m_TrackSimply.size(); i++)
+		m_TrackSimply.at(i).UpdateTracking(m_dt, m_TrackSimply.at(i).obj, m_TrackSimply.at(i).obj);
+
+	m_DetectedObjects.clear();
+	for(unsigned int i = 0; i&lt; m_TrackSimply.size(); i++)
+		m_DetectedObjects.push_back(m_TrackSimply.at(i).obj);
 }
 
-void SimpleTracker::CleanOldTracks()
+void SimpleTracker::AssociateToRegions(KFTrackV&amp; detectedObject)
 {
-	m_DetectedObjects.clear();
-	for(int i = 0; i&lt; (int)m_Tracks.size(); i++)
+	for(unsigned int i = 0; i &lt; m_InterestRegions.size(); i++)
 	{
-		if(m_Tracks.at(i)-&gt;forget_time &lt; 0 &amp;&amp; m_Tracks.at(i)-&gt;forget_time &gt; NEVER_GORGET_TIME)
-		{
-			delete m_Tracks.at(i);
-			m_Tracks.erase(m_Tracks.begin()+i);
-			i--;
-		}
-		else if(m_Tracks.at(i)-&gt;m_iLife &gt; MIN_EVIDENCE_NUMBER)
+		m_InterestRegions.at(i)-&gt;pTrackers.clear();
+		if(detectedObject.obj.distance_to_center &lt;= m_InterestRegions.at(i)-&gt;radius)
 		{
-			m_DetectedObjects.push_back(m_Tracks.at(i)-&gt;obj);
+			detectedObject.region_id = m_InterestRegions.at(i)-&gt;id;
+			detectedObject.forget_time = m_InterestRegions.at(i)-&gt;forget_time;
+			return;
 		}
 	}
+
+	if(m_InterestRegions.size() &gt; 0)
+	{
+		detectedObject.region_id = m_InterestRegions.at(m_InterestRegions.size()-1)-&gt;id;
+		detectedObject.forget_time = m_InterestRegions.at(m_InterestRegions.size()-1)-&gt;forget_time;
+	}
 }
 
-void SimpleTracker::DoOneStep(const WayPoint&amp; currPose, const std::vector&lt;DetectedObject&gt;&amp; obj_list)
+void SimpleTracker::AssociateAndTrack()
 {
-	if(!m_bFirstCall)
-		m_DT = UtilityHNS::UtilityH::GetTimeDiffNow(m_TrackTimer);
-	else
-		m_bFirstCall = false;
-
-	UtilityHNS::UtilityH::GetTickCount(m_TrackTimer);
+	for(unsigned int i = 0; i &lt; m_TrackSimply.size(); i++)
+		m_TrackSimply.at(i).m_bUpdated = false;
 
-	//std::cout &lt;&lt; " Tracking Time : " &lt;&lt; m_DT &lt;&lt; std::endl;
-	m_DetectedObjects = obj_list;
 
-	AssociateSimply();
+	std::cout &lt;&lt; std::endl;
+	while(m_DetectedObjects.size() &gt; 0)
+	{
+		double iCloseset_track = -1;
+		double iCloseset_obj = -1;
+		double dCloseset = 99999999;
+		bool bFoundMatch = false;
+		double min_size = -1;
+		std::cout &lt;&lt; "DetObjSize: " &lt;&lt;  m_DetectedObjects.size() &lt;&lt;  ", TracksSize: " &lt;&lt; m_TrackSimply.size() &lt;&lt; std::endl;
+		for(unsigned int jj = 0; jj &lt; m_DetectedObjects.size(); jj++)
+		{
+			double object_size = hypot(m_DetectedObjects.at(jj).w, m_DetectedObjects.at(jj).l);
 
-//	AssociateAndTrack();
-//	TrackV2();
-//	CleanOldTracks();
+			for(unsigned int i = 0; i &lt; m_TrackSimply.size(); i++)
+			{
+				double old_size = hypot(m_TrackSimply.at(i).obj.w, m_TrackSimply.at(i).obj.l);
+				double obj_diff = fabs(object_size - old_size);
+				double d = hypot(m_DetectedObjects.at(jj).center.pos.y-m_TrackSimply.at(i).obj.center.pos.y, m_DetectedObjects.at(jj).center.pos.x-m_TrackSimply.at(i).obj.center.pos.x);
 
+				std::cout &lt;&lt; "Test: " &lt;&lt; m_TrackSimply.at(i).obj.id &lt;&lt; ", MinD: " &lt;&lt; d &lt;&lt; ", ObjS: " &lt;&lt; object_size &lt;&lt; ", ObjI: " &lt;&lt; jj &lt;&lt; ", TrackS: " &lt;&lt; old_size &lt;&lt; ", TrackI: " &lt;&lt; i &lt;&lt; std::endl;
 
+				if(obj_diff &lt; m_MAX_ASSOCIATION_SIZE_DIFF &amp;&amp; (InsidePolygon(m_TrackSimply.at(i).obj.contour, m_DetectedObjects.at(jj).center.pos) == 1 || InsidePolygon(m_DetectedObjects.at(jj).contour, m_TrackSimply.at(i).obj.center.pos) == 1) )
+				 {
+					 bFoundMatch = true;
+					 iCloseset_track = i;
+					 iCloseset_obj = jj;
+					 break;
+				 }
 
-//	AssociateObjects();
-//	Track(m_DetectedObjects);
-//	m_PrevDetectedObjects = m_DetectedObjects;
-//	m_PrevState = currPose;
-}
+				if(obj_diff &lt; m_MAX_ASSOCIATION_SIZE_DIFF &amp;&amp; d &lt; dCloseset)
+				{
+					dCloseset = d;
+					iCloseset_track = i;
+					iCloseset_obj = jj;
+					min_size = obj_diff;
+				}
+			}
 
-void SimpleTracker::AssociateObjects()
-{
-	std::vector&lt;DetectedObject&gt; hidden_list;
-	DetectedObject* prev_obj;
-	DetectedObject* curr_obj;
+			if(bFoundMatch)
+				break;
+		}
 
-	for(unsigned int i = 0 ; i &lt; m_DetectedObjects.size(); i++)
-	{
-		double minCost = 99999999;
-		double minID = -1;
 
-		curr_obj = &amp;m_DetectedObjects.at(i);
-		curr_obj-&gt;center.cost = 0;
 
-		for(unsigned int j = 0; j &lt; m_PrevDetectedObjects.size(); j++)
+		if(iCloseset_obj != -1 &amp;&amp; iCloseset_track != -1 &amp;&amp; (dCloseset &lt;= m_MAX_ASSOCIATION_DISTANCE || bFoundMatch == true))
 		{
-			prev_obj = &amp;m_PrevDetectedObjects.at(j);
-
-			if(m_bUseCenterOnly)
+			std::cout &lt;&lt; "MatchObj: " &lt;&lt; m_TrackSimply.at(iCloseset_track).obj.id &lt;&lt; ", MinD: " &lt;&lt; dCloseset &lt;&lt; ", MinS: " &lt;&lt; min_size &lt;&lt; ", ObjI" &lt;&lt; iCloseset_obj &lt;&lt;", TrackI: " &lt;&lt; iCloseset_track &lt;&lt; ", ContourMatch: " &lt;&lt; bFoundMatch &lt;&lt; std::endl;
+			m_DetectedObjects.at(iCloseset_obj).id = m_TrackSimply.at(iCloseset_track).obj.id;
+			MergeObjectAndTrack(m_TrackSimply.at(iCloseset_track), m_DetectedObjects.at(iCloseset_obj));
+			AssociateToRegions(m_TrackSimply.at(iCloseset_track));
+			m_DetectedObjects.erase(m_DetectedObjects.begin()+iCloseset_obj);
+		}
+		else
+		{
+			iTracksNumber = iTracksNumber + 1;
+			if(iCloseset_obj != -1)
 			{
-				curr_obj-&gt;center.cost = hypot(curr_obj-&gt;center.pos.y- prev_obj-&gt;center.pos.y, curr_obj-&gt;center.pos.x- prev_obj-&gt;center.pos.x);
+				m_DetectedObjects.at(iCloseset_obj).id = iTracksNumber;
+				KFTrackV track(m_DetectedObjects.at(iCloseset_obj).center.pos.x, m_DetectedObjects.at(iCloseset_obj).center.pos.y,m_DetectedObjects.at(iCloseset_obj).actual_yaw, m_DetectedObjects.at(iCloseset_obj).id, m_dt, m_nMinTrustAppearances);
+				track.obj = m_DetectedObjects.at(iCloseset_obj);
+				AssociateToRegions(track);
+				m_TrackSimply.push_back(track);
+				std::cout &lt;&lt; "UnMachedObj: " &lt;&lt; iTracksNumber  &lt;&lt; ", MinD: " &lt;&lt; dCloseset &lt;&lt; ", MinS: " &lt;&lt; min_size &lt;&lt; ", ObjI:" &lt;&lt; iCloseset_obj &lt;&lt;", TrackI: " &lt;&lt; iCloseset_track &lt;&lt; ", ContMatch: " &lt;&lt; bFoundMatch &lt;&lt; std::endl;
+				m_DetectedObjects.erase(m_DetectedObjects.begin()+iCloseset_obj);
 			}
 			else
 			{
-				for(unsigned int k = 0; k &lt; curr_obj-&gt;contour.size(); k++)
-					for(unsigned int pk = 0; pk &lt; prev_obj-&gt;contour.size(); pk++)
-						curr_obj-&gt;center.cost += hypot(curr_obj-&gt;contour.at(k).y -prev_obj-&gt;contour.at(pk).y, curr_obj-&gt;contour.at(k).x -prev_obj-&gt;contour.at(pk).x);
-
-				curr_obj-&gt;center.cost = curr_obj-&gt;center.cost/(double)(curr_obj-&gt;contour.size()*prev_obj-&gt;contour.size());
-			}
-
-//			if(DEBUG_TRACKER)
-//				std::cout &lt;&lt; "Cost (" &lt;&lt; i &lt;&lt; "), " &lt;&lt; prev_obj-&gt;center.pos.ToString() &lt;&lt; ", Cost: "
-//						&lt;&lt; curr_obj-&gt;center.cost &lt;&lt;  ", contour: " &lt;&lt; curr_obj-&gt;contour.size()
-//						&lt;&lt; ", " &lt;&lt; curr_obj-&gt;center.pos.ToString() &lt;&lt; std::endl;
-
-			if(curr_obj-&gt;center.cost &lt; minCost)
-			{
-				minCost = curr_obj-&gt;center.cost;
-				minID = prev_obj-&gt;id;
+				m_DetectedObjects.at(0).id = iTracksNumber;
+				KFTrackV track(m_DetectedObjects.at(0).center.pos.x, m_DetectedObjects.at(0).center.pos.y,m_DetectedObjects.at(0).actual_yaw, m_DetectedObjects.at(0).id, m_dt, m_nMinTrustAppearances);
+				track.obj = m_DetectedObjects.at(0);
+				AssociateToRegions(track);
+				m_TrackSimply.push_back(track);
+				std::cout &lt;&lt; "NewObj: " &lt;&lt; iTracksNumber  &lt;&lt; ", MinD: " &lt;&lt; dCloseset &lt;&lt; ", MinS: " &lt;&lt; min_size &lt;&lt; ", ObjI:" &lt;&lt; 0 &lt;&lt;", TrackI: " &lt;&lt; iCloseset_track &lt;&lt; ", ContMatch: " &lt;&lt; bFoundMatch &lt;&lt; std::endl;
+				m_DetectedObjects.erase(m_DetectedObjects.begin()+0);
 			}
 		}
+	}
 
-		if(minID &lt;= 0 || minCost &gt; m_MAX_ASSOCIATION_DISTANCE) // new Object enter the scene
-		{
-			iTracksNumber = iTracksNumber + 1;
-			 curr_obj-&gt;id = iTracksNumber;
-			if(DEBUG_TRACKER)
-				std::cout &lt;&lt; "New Matching " &lt;&lt; curr_obj-&gt;id &lt;&lt; ", "&lt;&lt; minCost&lt;&lt; ", " &lt;&lt; iTracksNumber &lt;&lt; std::endl;
-		}
-		else
-		{
-			 curr_obj-&gt;id = minID;
-			if(DEBUG_TRACKER)
-				std::cout &lt;&lt; "Matched with ID  " &lt;&lt; curr_obj-&gt;id &lt;&lt; ", "&lt;&lt; minCost&lt;&lt; std::endl;
-		}
+	for(unsigned int i =0; i&lt; m_TrackSimply.size(); i++)
+	{
+		//if(m_TrackSimply.at(i).m_bUpdated)
+			m_TrackSimply.at(i).UpdateTracking(m_dt, m_TrackSimply.at(i).obj, m_TrackSimply.at(i).obj);
+//		else
+//		{
+////			double dx = 0;
+////			double dy = 0;
+////
+////			if(m_TrackSimply.at(i).obj.bVelocity &amp;&amp; m_TrackSimply.at(i).obj.center.v &gt; 3)
+////			{
+////				dx = m_TrackSimply.at(i).obj.center.v * cos(m_TrackSimply.at(i).obj.center.pos.a) * m_dt;
+////				dy = m_TrackSimply.at(i).obj.center.v * sin(m_TrackSimply.at(i).obj.center.pos.a) * m_dt;
+////			}
+////
+////			m_TrackSimply.at(i).obj.center.pos.x += dx;
+////			m_TrackSimply.at(i).obj.center.pos.y += dy;
+////
+////			for(unsigned int k=0; k &lt; m_TrackSimply.at(i).obj.contour.size(); k++)
+////			{
+////				m_TrackSimply.at(i).obj.contour.at(k).x += dx;
+////				m_TrackSimply.at(i).obj.contour.at(k).y += dy;
+////			}
+//
+//			m_TrackSimply.at(i).PredictTracking(m_dt, m_TrackSimply.at(i).obj, m_TrackSimply.at(i).obj);
+//		}
 	}
+}
 
-	for(unsigned int i = 0 ; i &lt; m_PrevDetectedObjects.size(); i++)
+void SimpleTracker::CleanOldTracks()
+{
+	m_DetectedObjects.clear();
+	for(int i = 0; i&lt; (int)m_TrackSimply.size(); i++)
 	{
-		prev_obj = &amp;m_PrevDetectedObjects.at(i);
-		bool bFound = false;
-		for(unsigned int j = 0; j &lt; m_DetectedObjects.size(); j++)
+		if(m_TrackSimply.at(i).forget_time &lt; 0 &amp;&amp; m_TrackSimply.at(i).forget_time != NEVER_GORGET_TIME)
 		{
-			if(prev_obj-&gt;id == m_DetectedObjects.at(j).id)
-			{
-				bFound = true;
-				break;
-			}
+			m_TrackSimply.erase(m_TrackSimply.begin()+i);
+			i--;
 		}
-
-		if(!bFound &amp;&amp; prev_obj-&gt;predicted_center.cost &lt; m_MAX_TRACKS_AFTER_LOSING)
+		else if(m_TrackSimply.at(i).m_iLife &gt; m_nMinTrustAppearances)
 		{
-			prev_obj-&gt;predicted_center.cost++;
-			hidden_list.push_back(*prev_obj);
+			m_DetectedObjects.push_back(m_TrackSimply.at(i).obj);
 		}
 	}
-
-	m_DetectedObjects.insert(m_DetectedObjects.begin(), hidden_list.begin(), hidden_list.end());
 }
 
-void SimpleTracker::CreateTrack(DetectedObject&amp; o)
+void SimpleTracker::MergeObjectAndTrack(KFTrackV&amp; track, PlannerHNS::DetectedObject&amp; obj)
 {
-	KFTrackV* pT = new KFTrackV(o.center.pos.x, o.center.pos.y,o.center.pos.a, o.id, m_DT);
-	o.id = pT-&gt;GetTrackID();
-	pT-&gt;UpdateTracking(m_DT, o, o);
-	m_Tracks.push_back(pT);
+	obj.centers_list = track.obj.centers_list;
+	track.obj = obj;
+	track.m_bUpdated = true;
 }
 
-KFTrackV* SimpleTracker::FindTrack(long index)
+int SimpleTracker::InsidePolygon(const std::vector&lt;GPSPoint&gt;&amp; polygon,const GPSPoint&amp; p)
 {
-	for(unsigned int i=0; i&lt; m_Tracks.size(); i++)
+	int counter = 0;
+	int i;
+	double xinters;
+	GPSPoint p1,p2;
+	int N = polygon.size();
+	if(N &lt;=0 ) return -1;
+
+	p1 = polygon.at(0);
+	for (i=1;i&lt;=N;i++)
 	{
-		if(m_Tracks[i]-&gt;GetTrackID() == index)
-			return m_Tracks[i];
-	}
-
-	return 0;
-}
+		p2 = polygon.at(i % N);
 
-void SimpleTracker::Track(std::vector&lt;DetectedObject&gt;&amp; objects_list)
-{
-	for(unsigned int i =0; i&lt;objects_list.size(); i++)
-	{
-		if(objects_list[i].id &gt;= 0)
+		if (p.y &gt; MIN(p1.y,p2.y))
 		{
-			KFTrackV* pT = FindTrack(objects_list[i].id);
-			if(pT)
-			{
-//				pT-&gt;UpdateTracking(m_DT, objects_list[i].center.pos.x, objects_list//[i].center.pos.y, objects_list[i].center.pos.a,
-						//objects_list[i].center.pos.x, objects_list[i].center.pos.y, //objects_list[i].center.pos.a,
-//						objects_list[i].center.v);
-				//std::cout &lt;&lt; "Update Current Track " &lt;&lt; objects_list[i].id &lt;&lt; std::endl;
-			}
-			else
+			if (p.y &lt;= MAX(p1.y,p2.y))
 			{
-				CreateTrack(objects_list[i]);
-				//std::cout &lt;&lt; "Create New Track " &lt;&lt; objects_list[i].id &lt;&lt; std::endl;
+				if (p.x &lt;= MAX(p1.x,p2.x))
+				{
+					if (p1.y != p2.y)
+					{
+						xinters = (p.y-p1.y)*(p2.x-p1.x)/(p2.y-p1.y)+p1.x;
+						if (p1.x == p2.x || p.x &lt;= xinters)
+							counter++;
+					}
+				}
 			}
 		}
+		p1 = p2;
 	}
-}
 
-void SimpleTracker::CoordinateTransform(const WayPoint&amp; refCoordinate, DetectedObject&amp; obj)
-{
-	Mat3 rotationMat(-refCoordinate.pos.a);
-	Mat3 translationMat(-refCoordinate.pos.x, -refCoordinate.pos.y);
-	obj.center.pos = translationMat*obj.center.pos;
-	obj.center.pos = rotationMat*obj.center.pos;
-	for(unsigned int j = 0 ; j &lt; obj.contour.size(); j++)
-	{
-		obj.contour.at(j) = translationMat*obj.contour.at(j);
-		obj.contour.at(j) = rotationMat*obj.contour.at(j);
-	}
+	if (counter % 2 == 0)
+		return 0;
+	else
+		return 1;
 }
-
-void SimpleTracker::CoordinateTransformPoint(const WayPoint&amp; refCoordinate, GPSPoint&amp; obj)
-{
-	Mat3 rotationMat(-refCoordinate.pos.a);
-	Mat3 translationMat(-refCoordinate.pos.x, -refCoordinate.pos.y);
-	obj = translationMat*obj;
-	obj = rotationMat*obj;
 }
-
-} /* namespace BehaviorsNS */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" added_lines="1" deleted_lines="2">
				<diff>@@ -68,8 +68,7 @@ PlannerX::PlannerX()
 	bKmlMapLoaded = false;
 	m_bEnableTracking = true;
 	m_ObstacleTracking.m_MAX_ASSOCIATION_DISTANCE = 2.0;
-	m_ObstacleTracking.m_MAX_TRACKS_AFTER_LOSING = 5;
-	m_ObstacleTracking.m_DT = 0.12;
+	m_ObstacleTracking.m_dt = 0.12;
 	m_ObstacleTracking.m_bUseCenterOnly = true;
 
 	enablePlannerDynamicSwitch = false;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\op_simulator\nodes\OpenPlannerSimulator_core.cpp" new_path="ros\src\computing\planning\motion\packages\op_simulator\nodes\OpenPlannerSimulator_core.cpp" added_lines="1" deleted_lines="2">
				<diff>@@ -88,8 +88,7 @@ OpenPlannerSimulator::OpenPlannerSimulator()
 
 
 	m_ObstacleTracking.m_MAX_ASSOCIATION_DISTANCE = 6.0;
-	m_ObstacleTracking.m_MAX_TRACKS_AFTER_LOSING = 5;
-	m_ObstacleTracking.m_DT = 0.12;
+	m_ObstacleTracking.m_dt = 0.12;
 	m_ObstacleTracking.m_bUseCenterOnly = true;
 
 	m_PredControl.Init(m_ControlParams, m_CarInfo, false, false);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="13c08455122e782da8e4e274d447dafe722d048b" author="asimay">
		<msg>perfect the code. same commit with #920. 

remove duplicate "if" assert.
if v_info_.is_stored == false,  tw.twist.angular.z is not set value or previous value, it is abnormal, and later in convertSteeringAngleToAngularVelocity( ) function, it also need to assert v_info_.is_stored is true or not, duplicate assert.</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_info_translator\can_info_translator_core.cpp" new_path="ros\src\computing\perception\localization\packages\autoware_connector\nodes\can_info_translator\can_info_translator_core.cpp" added_lines="1" deleted_lines="2">
				<diff>@@ -91,8 +91,7 @@ void VelPoseConnectNode::publishVelocity(const autoware_msgs::CanInfoConstPtr &amp;m
   tw.twist.linear.x = kmph2mps(msg-&gt;speed);  // km/h -&gt; m/s
 
   // angular velocity
-  if (v_info_.is_stored)
-    tw.twist.angular.z = v_info_.convertSteeringAngleToAngularVelocity(kmph2mps(msg-&gt;speed), msg-&gt;angle);
+  tw.twist.angular.z = v_info_.convertSteeringAngleToAngularVelocity(kmph2mps(msg-&gt;speed), msg-&gt;angle);
 
   pub1_.publish(tw);
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="eb5fe7c5dd366fc42d769beb67893025f1b695fc" author="hatem-darweesh">
		<msg>- Test Tracking
- Add missing parameter to lunch file and runtime manager</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\SimpleTracker.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\include\SimpleTracker.h" added_lines="33" deleted_lines="6">
				<diff>@@ -421,20 +421,46 @@ public:
 class CostRecordSet
 {
 public:
-	int currobj;
-	int prevObj;
+	int i_obj;
+	int i_track;
 	double cost;
-	CostRecordSet(int curr_id, int prev_id, double _cost)
+	 double size_diff;
+	 double width_diff;
+	 double length_diff;
+	 double height_diff;
+	 double angle_diff;
+	 double distance_diff;
+	CostRecordSet(int obj_index, int track_index, double _distance_diff, double _size_diff, double _width_diff, double _length_diff, double _height_diff, double _angle_diff)
 	{
-		currobj = curr_id;
-		prevObj = prev_id;
-		cost = _cost;
+		i_obj = obj_index;
+		i_track = track_index;
+		size_diff = _size_diff;
+		angle_diff = _angle_diff;
+		distance_diff = _distance_diff;
+		width_diff = _width_diff;
+		length_diff = _length_diff;
+		height_diff = _height_diff;
+		cost = 0;
+	}
+
+	CostRecordSet()
+	{
+		i_obj = -1;
+		i_track = -1;
+		size_diff = 0;
+		angle_diff = 0;
+		distance_diff = 0;
+		width_diff = 0;
+		length_diff = 0;
+		height_diff = 0;
+		cost = 0;
 	}
 };
 
 class SimpleTracker
 {
 public:
+	std::vector&lt;CostRecordSet&gt; m_CostsLists;
 	std::vector&lt;InterestCircle*&gt; m_InterestRegions;
 	std::vector&lt;KFTrackV*&gt; m_Tracks;
 	std::vector&lt;KFTrackV&gt; m_TrackSimply;
@@ -475,6 +501,7 @@ private:
 	int InsidePolygon(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; polygon,const PlannerHNS::GPSPoint&amp; p);
 
 	void MatchClosest();
+	void MatchClosestCost();
 
 };
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\SimpleTracker.cpp" new_path="ros\src\computing\planning\common\lib\openplanner\op_simu\src\SimpleTracker.cpp" added_lines="193" deleted_lines="28">
				<diff>@@ -135,46 +135,38 @@ void SimpleTracker::MatchClosest()
 {
 	newObjects.clear();
 
+	std::cout &lt;&lt; std::endl &lt;&lt; std::endl  &lt;&lt; std::endl;
 	while(m_DetectedObjects.size() &gt; 0)
 	{
 		double iCloseset_track = -1;
 		double iCloseset_obj = -1;
 		double dCloseset = 99999999;
 		bool bFoundMatch = false;
-		double min_size = -1;
-		//std::cout &lt;&lt; "DetObjSize: " &lt;&lt;  m_DetectedObjects.size() &lt;&lt;  ", TracksSize: " &lt;&lt; m_TrackSimply.size() &lt;&lt; std::endl;
+
+		double size_diff = -1;
+		std::cout &lt;&lt; std::endl;
+
+		m_CostsLists.clear();
+
 		for(unsigned int jj = 0; jj &lt; m_DetectedObjects.size(); jj++)
 		{
-			double object_size = hypot(m_DetectedObjects.at(jj).w, m_DetectedObjects.at(jj).l);
+			double object_size = sqrt(m_DetectedObjects.at(jj).w*m_DetectedObjects.at(jj).w + m_DetectedObjects.at(jj).l*m_DetectedObjects.at(jj).l + m_DetectedObjects.at(jj).h*m_DetectedObjects.at(jj).h);
 
 			for(unsigned int i = 0; i &lt; m_TrackSimply.size(); i++)
 			{
-				double old_size = hypot(m_TrackSimply.at(i).obj.w, m_TrackSimply.at(i).obj.l);
-				double obj_diff = fabs(object_size - old_size);
 				double d = hypot(m_DetectedObjects.at(jj).center.pos.y-m_TrackSimply.at(i).obj.center.pos.y, m_DetectedObjects.at(jj).center.pos.x-m_TrackSimply.at(i).obj.center.pos.x);
+				double old_size = sqrt(m_TrackSimply.at(i).obj.w*m_TrackSimply.at(i).obj.w + m_TrackSimply.at(i).obj.l*m_TrackSimply.at(i).obj.l + m_TrackSimply.at(i).obj.h*m_TrackSimply.at(i).obj.h);
+				double obj_diff = fabs(object_size - old_size);
 
 				bool bInsidePolygon = (InsidePolygon(m_TrackSimply.at(i).obj.contour, m_DetectedObjects.at(jj).center.pos) == 1 || InsidePolygon(m_DetectedObjects.at(jj).contour, m_TrackSimply.at(i).obj.center.pos) == 1);
-				bool bDirectionMatch = false;
-				if(m_TrackSimply.at(i).obj.bDirection)
-				{
-					double diff_y = m_DetectedObjects.at(jj).center.pos.y - m_TrackSimply.at(i).obj.center.pos.y;
-					double diff_x = m_DetectedObjects.at(jj).center.pos.x - m_TrackSimply.at(i).obj.center.pos.x;
-					double angle_diff = 100;
-					if(hypot(diff_y, diff_x) &gt; 0.2)
-					{
-						angle_diff = UtilityHNS::UtilityH::FixNegativeAngle(atan2(diff_y, diff_x));
-						if(UtilityHNS::UtilityH::AngleBetweenTwoAnglesPositive(angle_diff,m_TrackSimply.at(i).obj.center.pos.a) &lt; m_MAX_ASSOCIATION_ANGLE_DIFF)
-							bDirectionMatch = true;
-					}
-				}
-
-				//std::cout &lt;&lt; "Test: " &lt;&lt; m_TrackSimply.at(i).obj.id &lt;&lt; ", MinD: " &lt;&lt; d &lt;&lt; ", ObjS: " &lt;&lt; object_size &lt;&lt; ", ObjI: " &lt;&lt; jj &lt;&lt; ", TrackS: " &lt;&lt; old_size &lt;&lt; ", TrackI: " &lt;&lt; i &lt;&lt; std::endl;
 
 				if(obj_diff &lt; m_MAX_ASSOCIATION_SIZE_DIFF &amp;&amp;  bInsidePolygon)
 				 {
 					 bFoundMatch = true;
 					 iCloseset_track = i;
 					 iCloseset_obj = jj;
+					 size_diff = obj_diff;
+					 std::cout &lt;&lt; "Polygon Size Match" &lt;&lt; std::endl;
 					 break;
 				 }
 
@@ -183,7 +175,8 @@ void SimpleTracker::MatchClosest()
 					dCloseset = d;
 					iCloseset_track = i;
 					iCloseset_obj = jj;
-					min_size = obj_diff;
+					size_diff = obj_diff;
+					size_diff = obj_diff;
 				}
 			}
 
@@ -191,11 +184,10 @@ void SimpleTracker::MatchClosest()
 				break;
 		}
 
-
-
 		if(iCloseset_obj != -1 &amp;&amp; iCloseset_track != -1 &amp;&amp; (dCloseset &lt;= m_MAX_ASSOCIATION_DISTANCE || bFoundMatch == true))
 		{
-			//std::cout &lt;&lt; "MatchObj: " &lt;&lt; m_TrackSimply.at(iCloseset_track).obj.id &lt;&lt; ", MinD: " &lt;&lt; dCloseset &lt;&lt; ", MinS: " &lt;&lt; min_size &lt;&lt; ", ObjI" &lt;&lt; iCloseset_obj &lt;&lt;", TrackI: " &lt;&lt; iCloseset_track &lt;&lt; ", ContourMatch: " &lt;&lt; bFoundMatch &lt;&lt; std::endl;
+			std::cout &lt;&lt; "MatchObj: " &lt;&lt; m_TrackSimply.at(iCloseset_track).obj.id &lt;&lt; ", MinD: " &lt;&lt; dCloseset &lt;&lt; ", SizeDiff: (" &lt;&lt; size_diff &lt;&lt;  ")" &lt;&lt; ", ObjI" &lt;&lt; iCloseset_obj &lt;&lt;", TrackI: " &lt;&lt; iCloseset_track &lt;&lt; ", CMatch: " &lt;&lt; bFoundMatch &lt;&lt; std::endl;
+
 			m_DetectedObjects.at(iCloseset_obj).id = m_TrackSimply.at(iCloseset_track).obj.id;
 			MergeObjectAndTrack(m_TrackSimply.at(iCloseset_track), m_DetectedObjects.at(iCloseset_obj));
 			newObjects.push_back(m_TrackSimply.at(iCloseset_track));
@@ -229,9 +221,184 @@ void SimpleTracker::MatchClosest()
 	m_TrackSimply = newObjects;
 }
 
+void SimpleTracker::MatchClosestCost()
+{
+	newObjects.clear();
+
+	//std::cout &lt;&lt; std::endl &lt;&lt; std::endl  &lt;&lt; std::endl;
+	while(m_DetectedObjects.size() &gt; 0)
+	{
+		//std::cout &lt;&lt; std::endl;
+		double max_d = -1;
+		double min_d = 999999999;
+		double max_s = -1;
+		double min_s = 999999999;
+		double max_a = -1;
+		double min_a = 999999999;
+		double max_w = -1;
+		double min_w = 999999999;
+		double max_l = -1;
+		double min_l = 999999999;
+		double max_h = -1;
+		double min_h = 999999999;
+
+		m_CostsLists.clear();
+
+		for(unsigned int jj = 0; jj &lt; m_DetectedObjects.size(); jj++)
+		{
+			double object_size = sqrt(m_DetectedObjects.at(jj).w*m_DetectedObjects.at(jj).w + m_DetectedObjects.at(jj).l*m_DetectedObjects.at(jj).l + m_DetectedObjects.at(jj).h*m_DetectedObjects.at(jj).h);
+
+			for(unsigned int i = 0; i &lt; m_TrackSimply.size(); i++)
+			{
+				double d = hypot(m_DetectedObjects.at(jj).center.pos.y-m_TrackSimply.at(i).obj.center.pos.y, m_DetectedObjects.at(jj).center.pos.x-m_TrackSimply.at(i).obj.center.pos.x);
+				double old_size = sqrt(m_TrackSimply.at(i).obj.w*m_TrackSimply.at(i).obj.w + m_TrackSimply.at(i).obj.l*m_TrackSimply.at(i).obj.l + m_TrackSimply.at(i).obj.h*m_TrackSimply.at(i).obj.h);
+				double obj_diff = fabs(object_size - old_size);
+				double w_diff = fabs(m_TrackSimply.at(i).obj.w - m_DetectedObjects.at(jj).w);
+				double h_diff = fabs(m_TrackSimply.at(i).obj.h - m_DetectedObjects.at(jj).h);
+				double l_diff = fabs(m_TrackSimply.at(i).obj.l - m_DetectedObjects.at(jj).l);
+
+				bool bDirectionMatch = false;
+				bool bSimilarSize = false;
+				double a_diff = M_PI;
+				if(m_TrackSimply.at(i).obj.bDirection)
+				{
+					double diff_y = m_DetectedObjects.at(jj).center.pos.y - m_TrackSimply.at(i).obj.center.pos.y;
+					double diff_x = m_DetectedObjects.at(jj).center.pos.x - m_TrackSimply.at(i).obj.center.pos.x ;
+					if(hypot(diff_y, diff_x) &gt; 0.2)
+					{
+						double a = UtilityHNS::UtilityH::FixNegativeAngle(atan2(diff_y, diff_x));
+						a_diff = UtilityHNS::UtilityH::AngleBetweenTwoAnglesPositive(a,m_TrackSimply.at(i).obj.center.pos.a);
+						if(a_diff &lt; m_MAX_ASSOCIATION_ANGLE_DIFF)
+							bDirectionMatch = true;
+					}
+				}
+
+				if(w_diff &lt; m_MAX_ASSOCIATION_SIZE_DIFF/3.0 &amp;&amp; h_diff &lt; m_MAX_ASSOCIATION_SIZE_DIFF/3.0 &amp;&amp; l_diff &lt; m_MAX_ASSOCIATION_SIZE_DIFF/3.0)
+					bSimilarSize = true;
+
+				if(d &gt; max_d) max_d = d; if(d &lt; min_d) min_d = d;
+				if(obj_diff &gt; max_s) max_s = obj_diff; if(obj_diff &lt; min_s) min_s = obj_diff;
+				if(w_diff &gt; max_w) max_w = w_diff; if(w_diff &lt; min_w) min_w = w_diff;
+				if(l_diff &gt; max_l) max_l = l_diff; if(l_diff &lt; min_l) min_l = l_diff;
+				if(h_diff &gt; max_h) max_h = h_diff; if(h_diff &lt; min_h) min_h = h_diff;
+				if(a_diff &gt; max_a) max_a = a_diff; if(a_diff &lt; min_a) min_a = a_diff;
+
+				m_CostsLists.push_back(CostRecordSet(jj, i, d, obj_diff, w_diff, l_diff, h_diff, a_diff));
+
+			//	std::cout &lt;&lt; "Test: " &lt;&lt; m_TrackSimply.at(i).obj.id &lt;&lt; ", MinD: " &lt;&lt; d &lt;&lt; ", ObjS: " &lt;&lt; obj_diff &lt;&lt; ", Angle: " &lt;&lt; a_diff &lt;&lt; ", ObjI: " &lt;&lt; jj &lt;&lt; ", TrackI: " &lt;&lt; i &lt;&lt; std::endl;
+			}
+
+		}
+
+		// Normalize and find the minimum
+		std::vector&lt;double&gt; vs;
+
+		double d_v = max_d - min_d;
+		double w_v = max_w - min_w;
+		double l_v = max_l - min_l;
+		double h_v = max_h - min_h;
+		double a_v = max_a - min_a;
+		double s_v = max_s - min_s;
+
+		for(unsigned int ic = 0 ; ic &lt; m_CostsLists.size() ; ic++)
+		{
+			int actual_count = 0;
+			if(d_v != 0)
+			{
+				m_CostsLists.at(ic).cost += m_CostsLists.at(ic).distance_diff/d_v;
+				actual_count++;
+			}
+
+			if(w_v != 0)
+			{
+				m_CostsLists.at(ic).cost += m_CostsLists.at(ic).width_diff/w_v;
+				actual_count++;
+			}
+
+			if(l_v != 0)
+			{
+				m_CostsLists.at(ic).cost += m_CostsLists.at(ic).length_diff/l_v;
+				actual_count++;
+			}
+
+			if(h_v != 0)
+			{
+				m_CostsLists.at(ic).cost += m_CostsLists.at(ic).height_diff/h_v;
+				actual_count++;
+			}
+
+			if(a_v != 0 &amp;&amp; m_CostsLists.at(ic).angle_diff &lt; M_PI_2)
+			{
+				m_CostsLists.at(ic).cost += m_CostsLists.at(ic).angle_diff/a_v;
+				actual_count++;
+			}
+			else
+				m_CostsLists.at(ic).angle_diff = 0;
+
+//			if(s_v != 0 )
+//			{
+//				m_CostsLists.at(ic).cost += m_CostsLists.at(ic).size_diff/s_v;
+//				actual_count++;
+//			}
+
+
+			if(actual_count &gt; 0)
+				m_CostsLists.at(ic).cost = m_CostsLists.at(ic).cost / (double)actual_count;
+		//	std::cout &lt;&lt; "Cost = " &lt;&lt; m_CostsLists.at(ic).cost &lt;&lt; std::endl;
+		}
+
+		CostRecordSet min_set;
+		min_set.cost = 99999999;
+
+		for(unsigned int ic = 0 ; ic &lt; m_CostsLists.size() ; ic++)
+		{
+			if(m_CostsLists.at(ic).cost &lt; min_set.cost)
+				min_set = m_CostsLists.at(ic);
+		}
+
+
+		if(min_set.i_obj != -1 &amp;&amp; min_set.i_track != -1 &amp;&amp;  min_set.distance_diff &lt;= m_MAX_ASSOCIATION_DISTANCE &amp;&amp; min_set.size_diff &lt; m_MAX_ASSOCIATION_SIZE_DIFF &amp;&amp; min_set.angle_diff &lt; m_MAX_ASSOCIATION_ANGLE_DIFF)
+		{
+		//	std::cout &lt;&lt; "MatchObj: " &lt;&lt; m_TrackSimply.at(min_set.i_track).obj.id &lt;&lt; ", MinD: " &lt;&lt; min_set.distance_diff &lt;&lt; ", SizeDiff: (" &lt;&lt; min_set.size_diff &lt;&lt; ")" &lt;&lt; ", AngDiff: " &lt;&lt; min_set.angle_diff  &lt;&lt; ", ObjI" &lt;&lt; min_set.i_obj &lt;&lt;", TrackI: " &lt;&lt; min_set.i_track &lt;&lt; std::endl;
+
+			m_DetectedObjects.at(min_set.i_obj).id = m_TrackSimply.at(min_set.i_track).obj.id;
+			MergeObjectAndTrack(m_TrackSimply.at(min_set.i_track), m_DetectedObjects.at(min_set.i_obj));
+			newObjects.push_back(m_TrackSimply.at(min_set.i_track));
+			m_TrackSimply.erase(m_TrackSimply.begin()+min_set.i_track);
+			m_DetectedObjects.erase(m_DetectedObjects.begin()+min_set.i_obj);
+		}
+		else
+		{
+			iTracksNumber = iTracksNumber + 1;
+
+			if(min_set.i_obj != -1)
+			{
+				m_DetectedObjects.at(min_set.i_obj).id = iTracksNumber;
+				KFTrackV track(m_DetectedObjects.at(min_set.i_obj).center.pos.x, m_DetectedObjects.at(min_set.i_obj).center.pos.y,m_DetectedObjects.at(min_set.i_obj).actual_yaw, m_DetectedObjects.at(min_set.i_obj).id, m_dt, m_nMinTrustAppearances);
+				track.obj = m_DetectedObjects.at(min_set.i_obj);
+				newObjects.push_back(track);
+
+				//std::cout &lt;&lt; "NewMatch: " &lt;&lt; iTracksNumber &lt;&lt; ", "&lt;&lt; ", MinD: " &lt;&lt; min_set.distance_diff &lt;&lt; ", SizeDiff: (" &lt;&lt; min_set.size_diff &lt;&lt; ")" &lt;&lt; ", AngDiff: " &lt;&lt; min_set.angle_diff &lt;&lt; ", ObjI" &lt;&lt; min_set.i_obj &lt;&lt;", TrackI: " &lt;&lt; min_set.i_track &lt;&lt; std::endl;
+				m_DetectedObjects.erase(m_DetectedObjects.begin()+min_set.i_obj);
+			}
+			else
+			{
+				m_DetectedObjects.at(0).id = iTracksNumber;
+				KFTrackV track(m_DetectedObjects.at(0).center.pos.x, m_DetectedObjects.at(0).center.pos.y,m_DetectedObjects.at(0).actual_yaw, m_DetectedObjects.at(0).id, m_dt, m_nMinTrustAppearances);
+				track.obj = m_DetectedObjects.at(0);
+				newObjects.push_back(track);
+				//std::cout &lt;&lt; "NewObj: " &lt;&lt; iTracksNumber &lt;&lt; ", "&lt;&lt; ", MinD: " &lt;&lt; min_set.distance_diff &lt;&lt; ", SizeDiff: (" &lt;&lt; min_set.size_diff &lt;&lt; ")" &lt;&lt; ", AngDiff: " &lt;&lt; min_set.angle_diff &lt;&lt; ", ObjI" &lt;&lt; min_set.i_obj &lt;&lt;", TrackI: " &lt;&lt; min_set.i_track &lt;&lt; std::endl;
+				m_DetectedObjects.erase(m_DetectedObjects.begin()+0);
+			}
+		}
+	}
+
+	m_TrackSimply = newObjects;
+}
+
 void SimpleTracker::AssociateOnly()
 {
-	MatchClosest();
+	MatchClosestCost();
 
 	for(unsigned int i =0; i&lt; m_TrackSimply.size(); i++)
 		m_TrackSimply.at(i).UpdateAssociateOnly(m_dt, m_TrackSimply.at(i).obj, m_TrackSimply.at(i).obj);
@@ -246,7 +413,7 @@ void SimpleTracker::AssociateSimply()
 	for(unsigned int i = 0; i &lt; m_TrackSimply.size(); i++)
 		m_TrackSimply.at(i).m_bUpdated = false;
 
-	MatchClosest();
+	MatchClosestCost();
 
 	for(unsigned int i =0; i&lt; m_TrackSimply.size(); i++)
 		m_TrackSimply.at(i).UpdateTracking(m_dt, m_TrackSimply.at(i).obj, m_TrackSimply.at(i).obj);
@@ -324,8 +491,6 @@ void SimpleTracker::AssociateAndTrack()
 				break;
 		}
 
-
-
 		if(iCloseset_obj != -1 &amp;&amp; iCloseset_track != -1 &amp;&amp; (dCloseset &lt;= m_MAX_ASSOCIATION_DISTANCE || bFoundMatch == true))
 		{
 			std::cout &lt;&lt; "MatchObj: " &lt;&lt; m_TrackSimply.at(iCloseset_track).obj.id &lt;&lt; ", MinD: " &lt;&lt; dCloseset &lt;&lt; ", MinS: " &lt;&lt; min_size &lt;&lt; ", ObjI" &lt;&lt; iCloseset_obj &lt;&lt;", TrackI: " &lt;&lt; iCloseset_track &lt;&lt; ", ContourMatch: " &lt;&lt; bFoundMatch &lt;&lt; std::endl;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e477ffb9d18e938432658a5e9199b3707fca5a07" author="Yusuke FUJII">
		<msg>Remove debug code and apply clang format</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="22" deleted_lines="17">
				<diff>@@ -33,10 +33,13 @@ bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
 {
   bool _ret;
   ctx-&gt;setEnableForceSetState(true);
-  if(!ctx-&gt;isCurrentState(_state_num)){
-	  _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
-  }else{
-	  _ret = ctx-&gt;disableCurrentState((state_machine::StateFlags)_state_num);
+  if (!ctx-&gt;isCurrentState(_state_num))
+  {
+    _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
+  }
+  else
+  {
+    _ret = ctx-&gt;disableCurrentState((state_machine::StateFlags)_state_num);
   }
   ctx-&gt;setEnableForceSetState(false);
   return _ret;
@@ -57,19 +60,21 @@ void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
 
 void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
 {
-	if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT)){
-		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
-		ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
-	}
-	else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT)){
-		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
-		ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
-	}
-	else
-	{
-		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
-		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
-	}
+  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
+  {
+    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
+    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
+  }
+  else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
+  {
+    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
+    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
+  }
+  else
+  {
+    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
+    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
+  }
 }
 
 void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="93" deleted_lines="106">
				<diff>@@ -11,88 +11,92 @@ namespace decision_maker
 {
 void DecisionMakerNode::setupStateCallback(void)
 {
-  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_LEFT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 1));
-  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_RIGHT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));
-  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_STRAIGHT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
-  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOPLINE_STATE, std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
-  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOP_STATE, std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_LEFT_STATE,
+                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 1));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_RIGHT_STATE,
+                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_STRAIGHT_STATE,
+                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
+                             std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOP_STATE,
+                             std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));
 
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
-                      std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 1));
-  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOP_STATE, std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 0));
-  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_KEEP_STATE, std::bind(&amp;DecisionMakerNode::callbackInStateKeep, this, 1));
+                         std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 1));
+  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOP_STATE,
+                         std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 0));
+  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_KEEP_STATE,
+                         std::bind(&amp;DecisionMakerNode::callbackInStateKeep, this, 1));
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_ACCELERATION_STATE,
-                      std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 1));
+                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 1));
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_DECELERATION_STATE,
-                      std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, -1));
+                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, -1));
 
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
-                      std::bind(&amp;DecisionMakerNode::updateStateObstacleAvoid, this, -1));
+                             std::bind(&amp;DecisionMakerNode::updateStateObstacleAvoid, this, -1));
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
-                      std::bind(&amp;DecisionMakerNode::callbackInStateObstacleAvoid, this, -1));
+                         std::bind(&amp;DecisionMakerNode::callbackInStateObstacleAvoid, this, -1));
   ctx-&gt;setCallbackOutFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
-                      std::bind(&amp;DecisionMakerNode::callbackOutStateObstacleAvoid, this, 1));
+                          std::bind(&amp;DecisionMakerNode::callbackOutStateObstacleAvoid, this, 1));
 }
 
 void DecisionMakerNode::createShiftLane(void)
 {
-  if(!created_shift_lane_flag_)
+  if (!created_shift_lane_flag_)
   {
-	  created_shift_lane_flag_ = true;
-	  autoware_msgs::lane shift_lane;
-	  current_shifted_lane_array_ = current_based_lane_array_;
-	  if (!current_shifted_lane_array_.lanes.empty())
-	  {
-		  shift_lane = current_shifted_lane_array_.lanes.at(0);
-		  size_t idx = 0;
-		  for (auto &amp;wp : shift_lane.waypoints)
-		  {
-			  double current_angle = getPoseAngle(wp.pose.pose);
-			  wp.pose.pose.position.x -= param_shift_width_ * cos(current_angle + M_PI / 2);
-			  wp.pose.pose.position.y -= param_shift_width_ * sin(current_angle + M_PI / 2);
-			  wp.change_flag = current_based_lane_array_.lanes.at(0).waypoints.at(idx++).change_flag;
-		  }
-		  auto it = current_shifted_lane_array_.lanes.insert(current_shifted_lane_array_.lanes.begin() + 1, shift_lane);
-
-		  for (auto &amp;wp : current_shifted_lane_array_.lanes.at(0).waypoints)
-		  {
-			  wp.change_flag = 1;
-		  }
-	  }
+    created_shift_lane_flag_ = true;
+    autoware_msgs::lane shift_lane;
+    current_shifted_lane_array_ = current_based_lane_array_;
+    if (!current_shifted_lane_array_.lanes.empty())
+    {
+      shift_lane = current_shifted_lane_array_.lanes.at(0);
+      size_t idx = 0;
+      for (auto &amp;wp : shift_lane.waypoints)
+      {
+        double current_angle = getPoseAngle(wp.pose.pose);
+        wp.pose.pose.position.x -= param_shift_width_ * cos(current_angle + M_PI / 2);
+        wp.pose.pose.position.y -= param_shift_width_ * sin(current_angle + M_PI / 2);
+        wp.change_flag = current_based_lane_array_.lanes.at(0).waypoints.at(idx++).change_flag;
+      }
+      auto it = current_shifted_lane_array_.lanes.insert(current_shifted_lane_array_.lanes.begin() + 1, shift_lane);
+
+      for (auto &amp;wp : current_shifted_lane_array_.lanes.at(0).waypoints)
+      {
+        wp.change_flag = 1;
+      }
+    }
   }
 }
 
-void DecisionMakerNode::changeShiftLane(void){
-	try{
-		for(size_t idx = 0; idx &lt; current_shifted_lane_array_.lanes.size(); idx+=2){
-			for(size_t wp_idx; wp_idx &lt; current_shifted_lane_array_.lanes.at(idx).waypoints.size(); wp_idx++){
-				current_shifted_lane_array_.lanes.at(idx).waypoints.at(wp_idx).change_flag = current_shifted_lane_array_.lanes.at(idx+1).waypoints.at(wp_idx).change_flag;
-				current_shifted_lane_array_.lanes.at(idx+1).waypoints.at(wp_idx).change_flag = 2;
-			}
-		}
-	}
-	catch(std::out_of_range){
-		fprintf(stderr,"out\n");
-	}
+void DecisionMakerNode::changeShiftLane(void)
+{
+  try
+  {
+    for (size_t idx = 0; idx &lt; current_shifted_lane_array_.lanes.size(); idx += 2)
+    {
+      for (size_t wp_idx; wp_idx &lt; current_shifted_lane_array_.lanes.at(idx).waypoints.size(); wp_idx++)
+      {
+        current_shifted_lane_array_.lanes.at(idx).waypoints.at(wp_idx).change_flag =
+            current_shifted_lane_array_.lanes.at(idx + 1).waypoints.at(wp_idx).change_flag;
+        current_shifted_lane_array_.lanes.at(idx + 1).waypoints.at(wp_idx).change_flag = 2;
+      }
+    }
+  }
+  catch (std::out_of_range)
+  {
+    fprintf(stderr, "out\n");
+  }
 }
 
-void DecisionMakerNode::removeShiftLane(void){
-	current_shifted_lane_array_ = current_based_lane_array_;
-	created_shift_lane_flag_ = false;
-#if 0
-	if(created_shift_lane_flag_){
-		if(!current_shifted_lane_array_.lanes.size()&gt;=2){
-			for(auto it = begin(current_shifted_lane_array_.lanes)+1; it!=end(current_shifted_lane_array_.lanes); it+=2)
-				current_shifted_lane_array_.lanes.erase(it);
-		}
-		created_shift_lane_flag_ = false;
-	}
-#endif
+void DecisionMakerNode::removeShiftLane(void)
+{
+  current_shifted_lane_array_ = current_based_lane_array_;
+  created_shift_lane_flag_ = false;
 }
 
 void DecisionMakerNode::updateLaneWaypointsArray(void)
 {
-  // current_stopped_lane_array_ = current_controlled_lane_array_;
   current_stopped_lane_array_ = current_controlled_lane_array_;
 
   for (auto &amp;lane : current_stopped_lane_array_.lanes)
@@ -107,25 +111,21 @@ void DecisionMakerNode::updateLaneWaypointsArray(void)
 
 void DecisionMakerNode::publishControlledLaneArray(void)
 {
-	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
   Pubs["lane_waypoints_array"].publish(current_controlled_lane_array_);
 }
 void DecisionMakerNode::publishStoppedLaneArray(void)
 {
-	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
   updateLaneWaypointsArray();
   Pubs["lane_waypoints_array"].publish(current_stopped_lane_array_);
 }
 
 void DecisionMakerNode::changeVelocityBasedLane(void)
 {
-	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
   current_controlled_lane_array_ = current_shifted_lane_array_;
 }
 
 void DecisionMakerNode::changeVelocityLane(int dir)
 {
-	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
   for (auto &amp;lane : current_controlled_lane_array_.lanes)
   {
     autoware_msgs::lane temp_lane = lane;
@@ -139,7 +139,8 @@ void DecisionMakerNode::changeVelocityLane(int dir)
                            temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);
 
       double distance = amathutils::find_distance(&amp;p0, &amp;p1);
-      double _weight = distance * 0.05 * dir;
+      double _rate = 0.2;                       // accelerated/decelerated rate
+      double _weight = distance * _rate * dir;  //
       lane.waypoints.at(wpi).twist.twist.linear.x =
           lane.waypoints.at(wpi).twist.twist.linear.x + (lane.waypoints.at(wpi).twist.twist.linear.x * _weight);
     }
@@ -148,20 +149,17 @@ void DecisionMakerNode::changeVelocityLane(int dir)
 
 void DecisionMakerNode::callbackInStateKeep(int status)
 {
-	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
   changeVelocityBasedLane();
   publishControlledLaneArray();
 }
 
 void DecisionMakerNode::callbackInStateAcc(int status)
 {
-	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
   changeVelocityLane(status);
   publishControlledLaneArray();
 }
 void DecisionMakerNode::updateStateStop(int status)
 {
-	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
   static ros::Timer stopping_timer;
   static bool timerflag = false;
   if (status)
@@ -171,7 +169,7 @@ void DecisionMakerNode::updateStateStop(int status)
       stopping_timer = nh_.createTimer(ros::Duration(1),
                                        [&amp;](const ros::TimerEvent &amp;) {
                                          ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE);
-                                         ROS_INFO("Change state to keep from stop\n");
+                                         ROS_INFO("Change state to [KEEP] from [STOP]\n");
                                          timerflag = false;
                                        },
                                        this, true);
@@ -182,58 +180,47 @@ void DecisionMakerNode::updateStateStop(int status)
 
 void DecisionMakerNode::updateStateObstacleAvoid(int status)
 {
-	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
-  static ros::Timer avoidance_timer;
-  static bool stopped_flag = false;
-
-  if(current_velocity_ == 0.0){
-	stopped_flag = true;
-  }
 }
 
 void DecisionMakerNode::callbackOutStateObstacleAvoid(int status)
 {
-	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
-	static ros::Timer avoidance_timer_2;
-	ROS_INFO("End of Avoidance\n");
-	changeShiftLane();
-	changeVelocityBasedLane();
-	publishControlledLaneArray();
-
-	ros::Rate loop_rate(1);
-	//blocking
-	
-	
-	do{
-		ros::spinOnce();
-		loop_rate.sleep();
-	}
-	while(!ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) &amp;&amp;
-				       	!ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) &amp;&amp; ros::ok());
-	do{
-		ros::spinOnce();
-		loop_rate.sleep();
-	}
-	while((ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) ||
-				       	ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) ||
-				       	ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE) )&amp;&amp; ros::ok() );
+  static ros::Timer avoidance_timer_2;
+  changeShiftLane();
+  changeVelocityBasedLane();
+  publishControlledLaneArray();
 
-	removeShiftLane();
-	changeVelocityBasedLane();
-	publishControlledLaneArray();
-	return;
+  ros::Rate loop_rate(1);
+  // wait for the start of lane change to the original lane
+  do
+  {
+    ros::spinOnce();
+    loop_rate.sleep();
+  } while (!ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) &amp;&amp;
+           !ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) &amp;&amp; ros::ok());
+  // wait for the end of lane change
+  do
+  {
+    ros::spinOnce();
+    loop_rate.sleep();
+  } while ((ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) ||
+            ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) ||
+            ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE)) &amp;&amp;
+           ros::ok());
+
+  removeShiftLane();
+  changeVelocityBasedLane();  // rebased controlled lane
+  publishControlledLaneArray();
+  return;
 }
 
 void DecisionMakerNode::callbackInStateObstacleAvoid(int status)
 {
-	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
   ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
   createShiftLane();
   changeVelocityBasedLane();
 }
 void DecisionMakerNode::callbackInStateStop(int status)
 {
-	fprintf(stderr,"[%s]:%d:\n",__func__,__LINE__);
   publishStoppedLaneArray();
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="50500a08c6456a77885080dd1216bfb6e1f14b30" author="hironari.yashiro">
		<msg>add state</msg>
		<modified_files>
			<file old_path="ui\web\runtime_manager\app\views\index.html" new_path="ui\web\runtime_manager\app\views\index.html" added_lines="3" deleted_lines="1">
				<diff>@@ -4,6 +4,8 @@
     &lt;title&gt;RuntimeManager&lt;/title&gt;
 
     &lt;meta charset="utf-8" /&gt;
+    &lt;meta http-equiv="Pragma" content="no-cache"&gt;
+    &lt;meta http-equiv="Cache-Control" content="no-cache"&gt;
     &lt;link href="./res/static/autoware_icon.ico" rel="shortcut icon"&gt;
 
     &lt;!-- ReactGridLayout --&gt;
@@ -23,6 +25,6 @@
   &lt;/head&gt;
   &lt;body&gt;
     &lt;div id="content"&gt;&lt;/div&gt;
-    &lt;script src="./res/build/app.js"&gt;&lt;/script&gt;
+    &lt;script src="./res/build/app.js?no-cache=true"&gt;&lt;/script&gt;
   &lt;/body&gt;
 &lt;/html&gt;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6827c1d70bd74136c0269395363137eee6e2bbe0" author="Yusuke FUJII">
		<msg>Add to support multiple lane shift</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -263,7 +263,6 @@ bool StateContext::disableCurrentState(uint64_t _state_num)
 	if(isCurrentState(_state_num)){
 		HolderMap[getStateKind(_state_num)] &amp;= ~_state_num;
 		getStateObject(_state_num)-&gt;outState();
-		fprintf(stderr,"[%s]:%d:%lx\n",__func__,__LINE__,_state_num);
 		return true;
 	}else{
 		return false;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" added_lines="0" deleted_lines="30">
				<diff>@@ -131,35 +131,5 @@ bool CrossRoadArea::isInsideArea(const CrossRoadArea *_TargetArea, geometry_msgs
   }
 
   return false;
-#if 0
-	// Winding Number Algorithm 
-	// not working
-	int wn = 0;
-	double vt;
-
-	double s = 0;
-
-	for(size_t i = _ClosestArea-&gt;points.size()-1; i &gt; 0 ; i--){
-		auto it = _ClosestArea-&gt;points.at(i);
-		auto it_n = _ClosestArea-&gt;points.at(i-1);
-		std::cout &lt;&lt; "point[" &lt;&lt; i &lt;&lt; "]:" &lt;&lt; it.x &lt;&lt; "," &lt;&lt; it.y &lt;&lt; std::endl;
-		if( (it.y &lt;= pt.y ) &amp;&amp; (it_n.y &gt; pt.y)){
-			vt = (pt.y - it.y) / (it_n.y - pt.y);
-			if(pt.x &lt; it.x + (vt * (it_n.x - it.x))){
-				++wn;
-			}
-		}
-		else if( (it.y &gt; pt.y) &amp;&amp; (it_n.y &lt;= pt.y)) {
-			vt = (pt.y - it.y) / (it_n.y - pt.y);
-			if(pt.x &lt; ( it.x + (vt * (it_n.x - it.x)))){
-				--wn;
-			}
-		}
-
-	}
-	if(wn &gt; 0 ) return true;
-	else return false;
-
-#endif
 }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="0" deleted_lines="15">
				<diff>@@ -174,19 +174,12 @@ void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
         steering_state = autoware_msgs::WaypointState::STR_STRAIGHT;
 
       for (auto &amp;wp_lane : laneinArea.waypoints)
-      {
         for (auto &amp;lane : lane_array.lanes)
-        {
           for (auto &amp;wp : lane.waypoints)
-          {
             if (wp.gid == wp_lane.gid &amp;&amp; wp.wpstate.aid == area.area_id)
             {
               wp.wpstate.steering_state = steering_state;
             }
-          }
-          // lane.waypoints.at(wp_lane.lid).wpstate.steering_state = steering_state;
-        }
-      }
     }
   }
   // STOP
@@ -325,26 +318,18 @@ void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;
 
 void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
 {
-  vMap_Areas = msg;
-  vMap_Areas_flag = true;
   initVectorMap();
 }
 void DecisionMakerNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
 {
-  vMap_Points = msg;
-  vMap_Points_flag = true;
   initVectorMap();
 }
 void DecisionMakerNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
 {
-  vMap_Lines = msg;
-  vMap_Lines_flag = true;
   initVectorMap();
 }
 void DecisionMakerNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
 {
-  vMap_CrossRoads = msg;
-  vMap_CrossRoads_flag = true;
   initVectorMap();
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" added_lines="0" deleted_lines="25">
				<diff>@@ -23,31 +23,6 @@
 
 namespace decision_maker
 {
-bool DecisionMakerNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg,
-                                                     const geometry_msgs::PoseStamped &amp;pose_msg)
-{
-#ifdef USE_VMAP_SERVER  // this is not successfully run
-  cross_road_srv.request.pose = pose_msg;
-  cross_road_srv.request.waypoints.waypoints.clear();
-
-  for (int i = 0; i &lt; 50; i++)
-  {
-    cross_road_srv.request.waypoints.waypoints.push_back(lane_msg.waypoints[i]);
-  }
-  for (const auto &amp;wayp : lane_msg.waypoints)
-    cross_road_srv.request.waypoints.waypoints.push_back(wayp);
-
-  cross_road_cli.call(cross_road_srv);
-
-  for (const auto &amp;cross_road_d : cross_road_srv.response.objects.data)
-  {
-    // for DEBUG
-    //   std::cout &lt;&lt; "DEBUG" &lt;&lt; cross_road_d.linkid &lt;&lt; std::endl;
-  }
-#endif
-  return false;
-}
-
 void DecisionMakerNode::update(void)
 {
   update_msgs();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="0" deleted_lines="18">
				<diff>@@ -164,22 +164,4 @@ void DecisionMakerNode::initVectorMap(void)
     intersects.push_back(carea);
   }
 }
-
-bool DecisionMakerNode::initVectorMapClient()
-{
-#ifdef USE_VMAP_SERVER  // This is not successfully run due to failing vmap
-  // server
-
-  vector_map::VectorMap vmap;
-  vmap.subscribe(nh_, vector_map::Category::AREA, ros::Duration(0));
-
-  cross_road_srv.request.pose = current_pose_;
-  cross_road_srv.request.waypoints = current_finalwaypoints_;
-
-  cross_road_cli = nh_.serviceClient&lt;vector_map_server::GetCrossRoad&gt;("vector_map_server/get_cross_road");
-
-  return cross_road_cli.call(cross_road_srv);
-#endif
-  return false;
-}
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="81" deleted_lines="28">
				<diff>@@ -1,6 +1,5 @@
 #include &lt;ros/ros.h&gt;
 
-// lib
 #include &lt;state.hpp&gt;
 #include &lt;state_context.hpp&gt;
 
@@ -11,28 +10,39 @@ namespace decision_maker
 {
 void DecisionMakerNode::setupStateCallback(void)
 {
+  // steering state. these state's update function change lamp
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_STRAIGHT_STATE,
+                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_LEFT_STATE,
                              std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 1));
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_RIGHT_STATE,
                              std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));
-  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_STRAIGHT_STATE,
-                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
+
+  // temporary stopping state
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
                              std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
-  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOP_STATE,
-                             std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));
-
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
                          std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 1));
+
+  // stopping state
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOP_STATE,
+                             std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOP_STATE,
                          std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 0));
+
+  // speed keep(original speed) state
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_KEEP_STATE,
                          std::bind(&amp;DecisionMakerNode::callbackInStateKeep, this, 1));
+
+  // acceleration
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_ACCELERATION_STATE,
                          std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 1));
+
+  // deceleration
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_DECELERATION_STATE,
                          std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, -1));
 
+  // obstacle avoidance
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                              std::bind(&amp;DecisionMakerNode::updateStateObstacleAvoid, this, -1));
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
@@ -41,52 +51,93 @@ void DecisionMakerNode::setupStateCallback(void)
                           std::bind(&amp;DecisionMakerNode::callbackOutStateObstacleAvoid, this, 1));
 }
 
+#define SHIFTED_LANE_FLAG -99999
 void DecisionMakerNode::createShiftLane(void)
 {
   if (!created_shift_lane_flag_)
   {
+
+    bool isRightShift = param_shift_width_ &gt;= 0;
+
     created_shift_lane_flag_ = true;
-    autoware_msgs::lane shift_lane;
-    current_shifted_lane_array_ = current_based_lane_array_;
+    autoware_msgs::LaneArray shift_lanes = current_shifted_lane_array_ = current_based_lane_array_;
     if (!current_shifted_lane_array_.lanes.empty())
     {
-      shift_lane = current_shifted_lane_array_.lanes.at(0);
-      size_t idx = 0;
-      for (auto &amp;wp : shift_lane.waypoints)
-      {
-        double current_angle = getPoseAngle(wp.pose.pose);
-        wp.pose.pose.position.x -= param_shift_width_ * cos(current_angle + M_PI / 2);
-        wp.pose.pose.position.y -= param_shift_width_ * sin(current_angle + M_PI / 2);
-        wp.change_flag = current_based_lane_array_.lanes.at(0).waypoints.at(idx++).change_flag;
-      }
-      auto it = current_shifted_lane_array_.lanes.insert(current_shifted_lane_array_.lanes.begin() + 1, shift_lane);
+	    size_t lane_idx = 0;
+	    for(auto &amp;lane : shift_lanes.lanes){
+		    lane.increment = SHIFTED_LANE_FLAG;
+		    size_t wp_idx = 0;
+		    for (auto &amp;wp : lane.waypoints)
+		    {
+			    double angle = getPoseAngle(wp.pose.pose);
+			    wp.pose.pose.position.x -= param_shift_width_ * cos(angle + M_PI / 2);
+			    wp.pose.pose.position.y -= param_shift_width_ * sin(angle + M_PI / 2);
+			    wp.change_flag = current_based_lane_array_.lanes.at(lane_idx).waypoints.at(wp_idx++).change_flag;
+		    }
+		    lane_idx++;
+	    }
+    }
+    int insert_lane_idx_offset = isRightShift ? 1 : 0;
+    auto it_shift = begin(shift_lanes.lanes);
+    try{
+    for(auto it = begin(current_shifted_lane_array_.lanes); it!=end(current_shifted_lane_array_.lanes) &amp;&amp; it_shift != end(shift_lanes.lanes) ;){
+	    for(auto &amp;wp : it-&gt;waypoints){
+		    wp.change_flag = isRightShift? 1:2;
+	    }
+	    it = current_shifted_lane_array_.lanes.insert(it + insert_lane_idx_offset,*(it_shift++));
+	    it++;
+	    if(!isRightShift)it++;
+    }
+    }catch(std::length_error)
+    {
 
-      for (auto &amp;wp : current_shifted_lane_array_.lanes.at(0).waypoints)
-      {
-        wp.change_flag = 1;
-      }
     }
   }
 }
 
 void DecisionMakerNode::changeShiftLane(void)
 {
+  int inserted_lane_idx_offset = param_shift_width_ &gt;= 0 ? -1 : +1;
+  auto based_it = begin(current_shifted_lane_array_.lanes);
+
+  for(auto &amp;lane : current_shifted_lane_array_.lanes){
+	  if(lane.increment == SHIFTED_LANE_FLAG){
+	    for(auto &amp;wp : lane.waypoints){
+		wp.change_flag = param_shift_width_ &gt;=  0 ? 2:1;
+	    }
+	  } else {
+            auto based_wp_it = begin(based_it++-&gt;waypoints);
+	    for(auto &amp;wp : lane.waypoints){
+		wp.change_flag = based_wp_it++-&gt;change_flag;
+	    }
+	  }
+  }
+#if 0
+
   try
   {
-    for (size_t idx = 0; idx &lt; current_shifted_lane_array_.lanes.size(); idx += 2)
+
+
+    for (size_t idx = 0; idx &lt; current_shifted_lane_array_.lanes.size(); idx++)
     {
-      for (size_t wp_idx; wp_idx &lt; current_shifted_lane_array_.lanes.at(idx).waypoints.size(); wp_idx++)
+      if (current_shifted_lane_array_.lanes.at(idx).increment == SHIFTED_LANE_FLAG)
       {
-        current_shifted_lane_array_.lanes.at(idx).waypoints.at(wp_idx).change_flag =
-            current_shifted_lane_array_.lanes.at(idx + 1).waypoints.at(wp_idx).change_flag;
-        current_shifted_lane_array_.lanes.at(idx + 1).waypoints.at(wp_idx).change_flag = 2;
+        for (size_t wp_idx=0; wp_idx &lt; current_shifted_lane_array_.lanes.at(idx).waypoints.size(); wp_idx++)
+        {
+	  current_shifted_lane_array_.lanes.at(idx + inserted_lane_idx_offset).waypoints.at(wp_idx).change_flag = 
+		  current_shifted_lane_array_.lanes.at(idx).waypoints.at(wp_idx).change_flag;
+
+	  current_shifted_lane_array_.lanes.at(idx).waypoints.at(wp_idx).change_flag = param_shift_width_ &gt;= 0 ? 2:1;
+           
+        }
       }
     }
   }
   catch (std::out_of_range)
   {
-    fprintf(stderr, "out\n");
+    ROS_WARN("Failed create lane for returning to the original lane");
   }
+#endif
 }
 
 void DecisionMakerNode::removeShiftLane(void)
@@ -215,7 +266,9 @@ void DecisionMakerNode::callbackOutStateObstacleAvoid(int status)
 
 void DecisionMakerNode::callbackInStateObstacleAvoid(int status)
 {
+  //if car shoud stop before avoidance,
   ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
+  
   createShiftLane();
   changeVelocityBasedLane();
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="75ed0099f070e0123f3ff2c74b0fefaded046b0b" author="Abraham Monrroy">
		<msg>Support for multi cameras in feat_proj node (#930)

[fix] feat_proj node multi cam support</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\feat_proj.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\feat_proj.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -353,11 +353,11 @@ int main (int argc, char *argv[])
   ros::NodeHandle rosnode;
   ros::NodeHandle private_nh("~");
   std::string cameraInfo_topic_name;
-  private_nh.param&lt;std::string&gt;("camera_info_topic", cameraInfo_topic_name, "/camera/camera_info");
+  private_nh.param&lt;std::string&gt;("camera_info_topic", cameraInfo_topic_name, "/camera_info");
 
   /* get camera ID */
   camera_id_str = cameraInfo_topic_name;
-  camera_id_str.erase(camera_id_str.find("/camera/camera_info"));
+  camera_id_str.erase(camera_id_str.find("/camera_info"));
   if (camera_id_str == "/") {
     camera_id_str = "camera";
   }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ed17eb463b0aced5d27c87e3f34cd3bb7c5a08e4" author="Yusuke FUJII">
		<msg>Add new state
- TrafficLight State (it will be planning to change "behavior" to
  another category)
- Crawl(slow speed)</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libamathutils\include\amathutils.hpp" new_path="ros\src\computing\planning\decision\libs\libamathutils\include\amathutils.hpp" added_lines="6" deleted_lines="1">
				<diff>@@ -32,7 +32,12 @@ double find_angle(point *_a, point *_b);
 
 inline double mps2kmph(double _mpsval)
 {
-  return (_mpsval * 0.36 );// mps * 60secs * 60minutes / 1000m
+  return (_mpsval * 3.6 );// mps * 60sec * 60minutes / 1000m
+}
+
+inline double kmph2mps(double _kmphval)
+{
+  return (_kmphval * 1000 / 60 / 60 );// kmph * 1000m / 60sec / 60sec
 }
 
 #define G_MPSS 9.80665 // m/s^2
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" added_lines="3" deleted_lines="0">
				<diff>@@ -50,11 +50,14 @@ public:
     StateStores[DRIVE_ACC_KEEP_STATE] = DriveAccKeepState::getInstance();
     StateStores[DRIVE_ACC_STOP_STATE] = DriveAccStopState::getInstance();
     StateStores[DRIVE_ACC_STOPLINE_STATE] = DriveAccStopLineState::getInstance();
+    StateStores[DRIVE_ACC_CRAWL_STATE] = DriveAccCrawlState::getInstance();
     StateStores[DRIVE_STR_STRAIGHT_STATE] = DriveStrStraightState::getInstance();
     StateStores[DRIVE_STR_LEFT_STATE] = DriveStrLeftState::getInstance();
     StateStores[DRIVE_STR_RIGHT_STATE] = DriveStrRightState::getInstance();
     StateStores[DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE] = DriveBehaviorLaneChangeLeftState::getInstance();
     StateStores[DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE] = DriveBehaviorLaneChangeRightState::getInstance();
+    StateStores[DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE] = DriveBehaviorTrafficLightRedState::getInstance();
+    StateStores[DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE] = DriveBehaviorTrafficLightGreenState::getInstance();
     StateStores[DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE] = DriveBehaviorObstacleAvoidanceState::getInstance();
     StateStores[MISSION_COMPLETE_STATE] = MissionCompleteState::getInstance();
     StateStores[EMERGENCY_STATE] = EmergencyState::getInstance();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" added_lines="43" deleted_lines="1">
				<diff>@@ -75,6 +75,20 @@ private:
 public:
 };
 
+class DriveAccCrawlState : public State&lt;DriveAccCrawlState&gt;
+{
+private:
+  friend class State&lt;DriveAccCrawlState&gt;;
+  DriveAccCrawlState(void)
+  {
+    StateName = "Crawl";
+    StateNum = DRIVE_ACC_CRAWL_STATE;
+    StateKind = ACC_STATE;
+  }
+
+public:
+};
+
 class DriveAccStopState : public State&lt;DriveAccStopState&gt;
 {
 private:
@@ -184,6 +198,34 @@ private:
 
 public:
 };
-}
 
+class DriveBehaviorTrafficLightRedState : public State&lt;DriveBehaviorTrafficLightRedState&gt;
+{
+private:
+  friend class State&lt;DriveBehaviorTrafficLightRedState&gt;;
+  DriveBehaviorTrafficLightRedState(void)
+  {
+    StateName = "TrafficLightRed";
+    StateNum = DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE;
+    StateKind = BEHAVIOR_STATE;
+  }
+
+public:
+};
+
+class DriveBehaviorTrafficLightGreenState : public State&lt;DriveBehaviorTrafficLightGreenState&gt;
+{
+private:
+  friend class State&lt;DriveBehaviorTrafficLightGreenState&gt;;
+  DriveBehaviorTrafficLightGreenState(void)
+  {
+    StateName = "TrafficLightGreen";
+    StateNum = DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE;
+    StateKind = BEHAVIOR_STATE;
+  }
+
+public:
+};
+
+}
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" added_lines="24" deleted_lines="21">
				<diff>@@ -5,31 +5,34 @@ namespace state_machine
 {
 enum StateFlags
 {
-  NULL_STATE 			= 1UL &lt;&lt; 0,
-  START_STATE 			= 1UL &lt;&lt; 1,
-  INITIAL_STATE 		= 1UL &lt;&lt; 2,
-  INITIAL_LOCATEVEHICLE_STATE 	= 1UL &lt;&lt; 3,
-  DRIVE_STATE 			= 1UL &lt;&lt; 4,
-  MISSION_COMPLETE_STATE 	= 1UL &lt;&lt; 5,
-  EMERGENCY_STATE 		= 1UL &lt;&lt; 6,
+  NULL_STATE 			= 1ULL &lt;&lt; 0,
+  START_STATE 			= 1ULL &lt;&lt; 1,
+  INITIAL_STATE 		= 1ULL &lt;&lt; 2,
+  INITIAL_LOCATEVEHICLE_STATE 	= 1ULL &lt;&lt; 3,
+  DRIVE_STATE 			= 1ULL &lt;&lt; 4,
+  MISSION_COMPLETE_STATE 	= 1ULL &lt;&lt; 5,
+  EMERGENCY_STATE 		= 1ULL &lt;&lt; 6,
  
-  DRIVE_SUB_STATE_START		= 1UL &lt;&lt; 10,
+  DRIVE_SUB_STATE_START		= 1ULL &lt;&lt; 10,
 
-  DRIVE_ACC_ACCELERATION_STATE 	= 1UL &lt;&lt; 11,
-  DRIVE_ACC_DECELERATION_STATE 	= 1UL &lt;&lt; 12,
-  DRIVE_ACC_KEEP_STATE		= 1UL &lt;&lt; 13,
-  DRIVE_ACC_STOP_STATE 		= 1UL &lt;&lt; 14,
-  DRIVE_ACC_STOPLINE_STATE 	= 1UL &lt;&lt; 15,
+  DRIVE_ACC_ACCELERATION_STATE 	= 1ULL &lt;&lt; 11,
+  DRIVE_ACC_DECELERATION_STATE 	= 1ULL &lt;&lt; 12,
+  DRIVE_ACC_KEEP_STATE		= 1ULL &lt;&lt; 13,
+  DRIVE_ACC_STOP_STATE 		= 1ULL &lt;&lt; 14,
+  DRIVE_ACC_STOPLINE_STATE 	= 1ULL &lt;&lt; 15,
+  DRIVE_ACC_CRAWL_STATE 	= 1ULL &lt;&lt; 16,
   
-  DRIVE_STR_STRAIGHT_STATE 	= 1UL &lt;&lt; 21,
-  DRIVE_STR_LEFT_STATE 		= 1UL &lt;&lt; 22,
-  DRIVE_STR_RIGHT_STATE 	= 1UL &lt;&lt; 23,
+  DRIVE_STR_STRAIGHT_STATE 	= 1ULL &lt;&lt; 21,
+  DRIVE_STR_LEFT_STATE 		= 1ULL &lt;&lt; 22,
+  DRIVE_STR_RIGHT_STATE 	= 1ULL &lt;&lt; 23,
  
-  DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE 		= 1UL &lt;&lt; 31,
-  DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE 	= 1UL &lt;&lt; 32,
-  DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE 	= 1UL &lt;&lt; 33,
-  STATE_SUB_END = 1UL &lt;&lt; 40,
-  STATE_END = 1UL &lt;&lt; 41,
+  DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE 		= 1ULL &lt;&lt; 31,
+  DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE 	= 1ULL &lt;&lt; 32,
+  DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE 	= 1ULL &lt;&lt; 33,
+  DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 	= 1ULL &lt;&lt; 34,
+  DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE 	= 1ULL &lt;&lt; 35,
+  STATE_SUB_END = 1ULL &lt;&lt; 40,
+  STATE_END = 1ULL &lt;&lt; 41,
 };
 
 enum StateKinds
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="8" deleted_lines="5">
				<diff>@@ -101,7 +101,8 @@ private:
   // Current way/behavior status
   double current_velocity_;
   double average_velocity_;
-  int current_traffic_light;
+  int current_traffic_light_;
+  int closest_waypoint_;
   CrossRoadArea *ClosestArea_;
   std::string CurrentStateName;
   std::string TextOffset;
@@ -116,6 +117,7 @@ private:
   double param_convergence_threshold_;
   uint32_t param_stopline_target_waypoint_;
   double param_shift_width_;
+  double param_crawl_velocity_;
 
   // for vectormap server
   // ros::ServiceClient cross_road_cli;
@@ -152,7 +154,7 @@ private:
   // in near future, these methods will be deprecate to decision_maker library
   bool isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
   bool isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch, double _yaw);
-  bool handleStateCmd(const unsigned long long _state_num);
+  bool handleStateCmd(const uint64_t _state_num);
   //double calcIntersectWayAngle(const CrossRoadArea&amp; area);
   double calcIntersectWayAngle(const autoware_msgs::lane&amp; laneinArea);
 
@@ -172,10 +174,10 @@ private:
   void changeShiftLane(void);
   void removeShiftLane(void);
   
+  void publishLightColor(int status);
   void callbackInStateObstacleAvoid(int status);
   void callbackOutStateObstacleAvoid(int status);
   void updateStateObstacleAvoid(int status);
-  
   void updateStateSTR(int status);
   void updateStateStop(int status);
   void callbackInStateStop(int status);
@@ -186,6 +188,7 @@ private:
   // callback by topic subscribing
   void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
   void callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg);
+  void callbackFromClosestWaypoint(const std_msgs::Int32 &amp;msg);
   void callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event);
   void callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg);
   void callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg);
@@ -214,14 +217,14 @@ public:
     param_target_waypoint_ = DEFAULT_TARGET_WAYPOINT;
     param_shift_width_ = DEFAULT_SHIFT_WIDTH;
     param_stopline_target_waypoint_ = DEFAULT_STOPLINE_TARGET_WAYPOINT;
+    param_crawl_velocity_ = DEFAULT_CRAWL_VELOCITY;
 
     ctx = new state_machine::StateContext();
     this-&gt;initROS(argc, argv);
 
     vector_map_init = false;
     created_shift_lane_flag_ = false;
-
-    vMap_Areas_flag = vMap_Lines_flag = vMap_Points_flag = vMap_CrossRoads_flag = false;
+    closest_waypoint_ = 0;
 
     ClosestArea_ = nullptr;
     displacement_from_path_ = 0.0;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_param.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_param.hpp" added_lines="1" deleted_lines="1">
				<diff>@@ -19,8 +19,8 @@ namespace decision_maker
 #define DEFAULT_STOP_DECELERATION 0.2
 #define DEFAULT_STOP_TIME 1 
 #define DEFAULT_STOPLINE_TARGET_WAYPOINT 10
-
 #define DEFAULT_SHIFT_WIDTH 1.0
+#define DEFAULT_CRAWL_VELOCITY 4.0
 
 #define ANGLE_NEUTRAL 0
 #define ANGLE_CURVE 40
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="14" deleted_lines="6">
				<diff>@@ -29,7 +29,7 @@ void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped
   }
 }
 
-bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
+bool DecisionMakerNode::handleStateCmd(const uint64_t _state_num)
 {
   bool _ret;
   ctx-&gt;setEnableForceSetState(true);
@@ -84,8 +84,9 @@ void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMa
   ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);
 
   param_target_waypoint_ = msg.target_waypoint;
-  // param_stopline_target_waypoint_ = msg.stopline_target_waypoint;
+  param_stopline_target_waypoint_ = msg.stopline_target_waypoint;
   param_shift_width_ = msg.shift_width;
+
 }
 
 void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
@@ -94,14 +95,16 @@ void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_
   std::string topic = header.at("topic");
   const autoware_msgs::traffic_light *light = event.getMessage().get();
 
-  current_traffic_light = light-&gt;traffic_light;
-  if (current_traffic_light == state_machine::E_RED || current_traffic_light == state_machine::E_YELLOW)
+  current_traffic_light_ = light-&gt;traffic_light;
+  if (current_traffic_light_ == state_machine::E_RED || current_traffic_light_ == state_machine::E_YELLOW)
   {
-    // ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
+    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
+    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
   }
   else
   {
-    // ctx-&gt;disableCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
+    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
+    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
   }
 }
 
@@ -316,6 +319,11 @@ void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;
     Twistflag = true;
 }
 
+void DecisionMakerNode::callbackFromClosestWaypoint(const std_msgs::Int32 &amp;msg)
+{
+  closest_waypoint_ = msg.data;
+}
+
 void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
 {
   initVectorMap();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="4" deleted_lines="1">
				<diff>@@ -35,7 +35,7 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   Subs["current_pose"] = nh_.subscribe("current_pose", 20, &amp;DecisionMakerNode::callbackFromCurrentPose, this);
   Subs["current_velocity"] =
       nh_.subscribe("current_velocity", 20, &amp;DecisionMakerNode::callbackFromCurrentVelocity, this);
-  Subs["light_color"] = nh_.subscribe("light_color", 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
+  // Subs["light_color"] = nh_.subscribe("light_color", 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
   Subs["light_color_managed"] =
       nh_.subscribe("light_color_managed", 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
   Subs["points_raw"] = nh_.subscribe("filtered_points", 1, &amp;DecisionMakerNode::callbackFromPointsRaw, this);
@@ -43,6 +43,8 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   Subs["twist_cmd"] = nh_.subscribe("twist_cmd", 10, &amp;DecisionMakerNode::callbackFromTwistCmd, this);
   Subs["change_flag"] = nh_.subscribe("change_flag", 1, &amp;DecisionMakerNode::callbackFromLaneChangeFlag, this);
   Subs["state_cmd"] = nh_.subscribe("state_cmd", 1, &amp;DecisionMakerNode::callbackFromStateCmd, this);
+  Subs["closest_waypoint"] =
+      nh_.subscribe("closest_waypoint", 1, &amp;DecisionMakerNode::callbackFromClosestWaypoint, this);
 
   // Config subscriber
   Subs["config/decision_maker"] =
@@ -54,6 +56,7 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   Pubs["states"] = nh_.advertise&lt;autoware_msgs::state&gt;("/decisionmaker/states", 1, true);
 
   Pubs["lamp_cmd"] = nh_.advertise&lt;autoware_msgs::lamp_cmd&gt;("/lamp_cmd", 1);
+  Pubs["light_color"] = nh_.advertise&lt;autoware_msgs::traffic_light&gt;("/light_color", 1);
 
   // for visualize
   Pubs["state_overlay"] = nh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;("/state/overlay_text", 1);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="93" deleted_lines="73">
				<diff>@@ -34,6 +34,10 @@ void DecisionMakerNode::setupStateCallback(void)
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_KEEP_STATE,
                          std::bind(&amp;DecisionMakerNode::callbackInStateKeep, this, 1));
 
+  // crawl
+  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_CRAWL_STATE,
+                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 0));
+
   // acceleration
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_ACCELERATION_STATE,
                          std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 1));
@@ -49,6 +53,24 @@ void DecisionMakerNode::setupStateCallback(void)
                          std::bind(&amp;DecisionMakerNode::callbackInStateObstacleAvoid, this, -1));
   ctx-&gt;setCallbackOutFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                           std::bind(&amp;DecisionMakerNode::callbackOutStateObstacleAvoid, this, 1));
+
+  // trraficlight
+  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
+                             [&amp;](){ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);});
+  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
+                             [&amp;](){ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);});
+  
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
+                             std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_RED));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
+                             std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_GREEN));
+}
+
+void DecisionMakerNode::publishLightColor(int status)
+{
+  autoware_msgs::traffic_light msg;
+  msg.traffic_light = status;
+  Pubs["light_color"].publish(msg);
 }
 
 #define SHIFTED_LANE_FLAG -99999
@@ -56,41 +78,46 @@ void DecisionMakerNode::createShiftLane(void)
 {
   if (!created_shift_lane_flag_)
   {
-
     bool isRightShift = param_shift_width_ &gt;= 0;
 
     created_shift_lane_flag_ = true;
     autoware_msgs::LaneArray shift_lanes = current_shifted_lane_array_ = current_based_lane_array_;
     if (!current_shifted_lane_array_.lanes.empty())
     {
-	    size_t lane_idx = 0;
-	    for(auto &amp;lane : shift_lanes.lanes){
-		    lane.increment = SHIFTED_LANE_FLAG;
-		    size_t wp_idx = 0;
-		    for (auto &amp;wp : lane.waypoints)
-		    {
-			    double angle = getPoseAngle(wp.pose.pose);
-			    wp.pose.pose.position.x -= param_shift_width_ * cos(angle + M_PI / 2);
-			    wp.pose.pose.position.y -= param_shift_width_ * sin(angle + M_PI / 2);
-			    wp.change_flag = current_based_lane_array_.lanes.at(lane_idx).waypoints.at(wp_idx++).change_flag;
-		    }
-		    lane_idx++;
-	    }
+      size_t lane_idx = 0;
+      for (auto &amp;lane : shift_lanes.lanes)
+      {
+        lane.increment = SHIFTED_LANE_FLAG;
+        size_t wp_idx = 0;
+        for (auto &amp;wp : lane.waypoints)
+        {
+          double angle = getPoseAngle(wp.pose.pose);
+          wp.pose.pose.position.x -= param_shift_width_ * cos(angle + M_PI / 2);
+          wp.pose.pose.position.y -= param_shift_width_ * sin(angle + M_PI / 2);
+          wp.change_flag = current_based_lane_array_.lanes.at(lane_idx).waypoints.at(wp_idx++).change_flag;
+        }
+        lane_idx++;
+      }
     }
     int insert_lane_idx_offset = isRightShift ? 1 : 0;
     auto it_shift = begin(shift_lanes.lanes);
-    try{
-    for(auto it = begin(current_shifted_lane_array_.lanes); it!=end(current_shifted_lane_array_.lanes) &amp;&amp; it_shift != end(shift_lanes.lanes) ;){
-	    for(auto &amp;wp : it-&gt;waypoints){
-		    wp.change_flag = isRightShift? 1:2;
-	    }
-	    it = current_shifted_lane_array_.lanes.insert(it + insert_lane_idx_offset,*(it_shift++));
-	    it++;
-	    if(!isRightShift)it++;
+    try
+    {
+      for (auto it = begin(current_shifted_lane_array_.lanes);
+           it != end(current_shifted_lane_array_.lanes) &amp;&amp; it_shift != end(shift_lanes.lanes);)
+      {
+        for (auto &amp;wp : it-&gt;waypoints)
+        {
+          wp.change_flag = isRightShift ? 1 : 2;
+        }
+        it = current_shifted_lane_array_.lanes.insert(it + insert_lane_idx_offset, *(it_shift++));
+        it++;
+        if (!isRightShift)
+          it++;
+      }
     }
-    }catch(std::length_error)
+    catch (std::length_error)
     {
-
     }
   }
 }
@@ -100,44 +127,24 @@ void DecisionMakerNode::changeShiftLane(void)
   int inserted_lane_idx_offset = param_shift_width_ &gt;= 0 ? -1 : +1;
   auto based_it = begin(current_shifted_lane_array_.lanes);
 
-  for(auto &amp;lane : current_shifted_lane_array_.lanes){
-	  if(lane.increment == SHIFTED_LANE_FLAG){
-	    for(auto &amp;wp : lane.waypoints){
-		wp.change_flag = param_shift_width_ &gt;=  0 ? 2:1;
-	    }
-	  } else {
-            auto based_wp_it = begin(based_it++-&gt;waypoints);
-	    for(auto &amp;wp : lane.waypoints){
-		wp.change_flag = based_wp_it++-&gt;change_flag;
-	    }
-	  }
-  }
-#if 0
-
-  try
+  for (auto &amp;lane : current_shifted_lane_array_.lanes)
   {
-
-
-    for (size_t idx = 0; idx &lt; current_shifted_lane_array_.lanes.size(); idx++)
+    if (lane.increment == SHIFTED_LANE_FLAG)
     {
-      if (current_shifted_lane_array_.lanes.at(idx).increment == SHIFTED_LANE_FLAG)
+      for (auto &amp;wp : lane.waypoints)
       {
-        for (size_t wp_idx=0; wp_idx &lt; current_shifted_lane_array_.lanes.at(idx).waypoints.size(); wp_idx++)
-        {
-	  current_shifted_lane_array_.lanes.at(idx + inserted_lane_idx_offset).waypoints.at(wp_idx).change_flag = 
-		  current_shifted_lane_array_.lanes.at(idx).waypoints.at(wp_idx).change_flag;
-
-	  current_shifted_lane_array_.lanes.at(idx).waypoints.at(wp_idx).change_flag = param_shift_width_ &gt;= 0 ? 2:1;
-           
-        }
+        wp.change_flag = param_shift_width_ &gt;= 0 ? 2 : 1;
+      }
+    }
+    else
+    {
+      auto based_wp_it = begin(based_it++-&gt;waypoints);
+      for (auto &amp;wp : lane.waypoints)
+      {
+        wp.change_flag = based_wp_it++-&gt;change_flag;
       }
     }
   }
-  catch (std::out_of_range)
-  {
-    ROS_WARN("Failed create lane for returning to the original lane");
-  }
-#endif
 }
 
 void DecisionMakerNode::removeShiftLane(void)
@@ -177,23 +184,36 @@ void DecisionMakerNode::changeVelocityBasedLane(void)
 
 void DecisionMakerNode::changeVelocityLane(int dir)
 {
-  for (auto &amp;lane : current_controlled_lane_array_.lanes)
+  if (dir != 0)
   {
-    autoware_msgs::lane temp_lane = lane;
-    for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
+    for (auto &amp;lane : current_controlled_lane_array_.lanes)
     {
-      amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
-                           temp_lane.waypoints.at(wpi).pose.pose.position.y,
-                           temp_lane.waypoints.at(wpi).pose.pose.position.z);
-      amathutils::point p1(temp_lane.waypoints.at(wpi - 1).pose.pose.position.x,
-                           temp_lane.waypoints.at(wpi - 1).pose.pose.position.y,
-                           temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);
-
-      double distance = amathutils::find_distance(&amp;p0, &amp;p1);
-      double _rate = 0.2;                       // accelerated/decelerated rate
-      double _weight = distance * _rate * dir;  //
-      lane.waypoints.at(wpi).twist.twist.linear.x =
-          lane.waypoints.at(wpi).twist.twist.linear.x + (lane.waypoints.at(wpi).twist.twist.linear.x * _weight);
+      autoware_msgs::lane temp_lane = lane;
+      for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
+      {
+        amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
+                             temp_lane.waypoints.at(wpi).pose.pose.position.y,
+                             temp_lane.waypoints.at(wpi).pose.pose.position.z);
+        amathutils::point p1(temp_lane.waypoints.at(wpi - 1).pose.pose.position.x,
+                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.y,
+                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);
+
+        double distance = amathutils::find_distance(&amp;p0, &amp;p1);
+        double _rate = 0.2;                       // accelerated/decelerated rate
+        double _weight = distance * _rate * dir;  //
+        lane.waypoints.at(wpi).twist.twist.linear.x =
+            lane.waypoints.at(wpi).twist.twist.linear.x + (lane.waypoints.at(wpi).twist.twist.linear.x * _weight);
+      }
+    }
+  }
+  else
+  {
+    for (auto &amp;lane : current_controlled_lane_array_.lanes)
+    {
+      for (auto &amp;wp : lane.waypoints)
+      {
+        wp.twist.twist.linear.x = amathutils::kmph2mps(param_crawl_velocity_);
+      }
     }
   }
 }
@@ -266,9 +286,9 @@ void DecisionMakerNode::callbackOutStateObstacleAvoid(int status)
 
 void DecisionMakerNode::callbackInStateObstacleAvoid(int status)
 {
-  //if car shoud stop before avoidance,
+  // if car shoud stop before avoidance,
   ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
-  
+
   createShiftLane();
   changeVelocityBasedLane();
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4c6cddf030d9f7e2474a1d5e16b43b124bb3e500" author="Yusuke FUJII">
		<msg>Checked coding by cppcheck and apply clang-format</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libamathutils\include\amathutils.hpp" new_path="ros\src\computing\planning\decision\libs\libamathutils\include\amathutils.hpp" added_lines="8" deleted_lines="13">
				<diff>@@ -8,7 +8,6 @@ using namespace std;
 
 namespace amathutils
 {
-
 class point
 {
 private:
@@ -32,37 +31,33 @@ double find_angle(point *_a, point *_b);
 
 inline double mps2kmph(double _mpsval)
 {
-  return (_mpsval * 3.6 );// mps * 60sec * 60minutes / 1000m
+  return (_mpsval * 3.6);  // mps * 60sec * 60minutes / 1000m
 }
 
 inline double kmph2mps(double _kmphval)
 {
-  return (_kmphval * 1000 / 60 / 60 );// kmph * 1000m / 60sec / 60sec
+  return (_kmphval * 1000 / 60 / 60);  // kmph * 1000m / 60sec / 60sec
 }
 
-#define G_MPSS 9.80665 // m/s^2
-
+#define G_MPSS 9.80665  // m/s^2
 
 inline double getGravityAcceleration(double acceleration_mpss)
 {
-	return acceleration_mpss /  G_MPSS;
+  return acceleration_mpss / G_MPSS;
 }
 
 inline double getAcceleration(double v0, double v, double x)
 {
-	return  (v * v - v0 * v0) / 2 / x;
+  return (v * v - v0 * v0) / 2 / x;
 }
 
 inline double getTimefromAcceleration(double v0, double v, double a)
 {
-	return  (v - v0) / a;
+  return (v - v0) / a;
 }
 
+bool isIntersectLine(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y, double p4x, double p4y);
 
-bool isIntersectLine(double p1x, double p1y, double p2x, double p2y,
-			double p3x, double p3y, double p4x, double p4y);
-
-int isPointLeftFromLine(double p1x, double p1y, double line_p1x, double line_p1y,
-		double line_p2x, double line_p2y);
+int isPointLeftFromLine(double p1x, double p1y, double line_p1x, double line_p1y, double line_p2x, double line_p2y);
 }
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libamathutils\src\Amathutils.cpp" new_path="ros\src\computing\planning\decision\libs\libamathutils\src\Amathutils.cpp" added_lines="33" deleted_lines="42">
				<diff>@@ -2,53 +2,44 @@
 
 namespace amathutils
 {
-  double find_distance(point *_a, point *_b)
-  {
-    return std::hypot(std::hypot(_a-&gt;x - _b-&gt;x, _a-&gt;y - _b-&gt;y), _a-&gt;z - _b-&gt;z);
-  }
-  double find_distance(point &amp;_a, point &amp;_b)
-  {
-    return std::hypot(std::hypot(_a.x - _b.x, _a.y - _b.y), _a.z - _b.z);
-  }
-
-  double find_angle(point *_a, point *_b)
-  {
-    double _angle = std::atan2(_b-&gt;y - _a-&gt;y, _b-&gt;x - _a-&gt;x);
-    if (_angle &lt; 0.0)
-      _angle = _angle + 2 * M_PI;
-
-    return _angle * 360 / (2 * M_PI);
-  }
+double find_distance(point *_a, point *_b)
+{
+  return std::hypot(std::hypot(_a-&gt;x - _b-&gt;x, _a-&gt;y - _b-&gt;y), _a-&gt;z - _b-&gt;z);
+}
+double find_distance(point &amp;_a, point &amp;_b)
+{
+  return std::hypot(std::hypot(_a.x - _b.x, _a.y - _b.y), _a.z - _b.z);
+}
 
-  bool isIntersectLine(double p1x, double p1y, double p2x, double p2y,
-		  double p3x, double p3y, double p4x, double p4y)
-  {
-	  double ta = (p3x - p4x) * (p1y-p3y) + (p3y - p4y) * (p3x - p4x);
-	  double tb = (p3x - p4x) * (p2y-p3y) + (p3y - p4y) * (p3x - p2x);
-	  double tc = (p1x - p2x) * (p3y-p1y) + (p1y - p2y) * (p1x - p3x);
-	  double td = (p1x - p2x) * (p4y-p1y) + (p1y - p2y) * (p1x - p4x);
+double find_angle(point *_a, point *_b)
+{
+  double _angle = std::atan2(_b-&gt;y - _a-&gt;y, _b-&gt;x - _a-&gt;x);
+  if (_angle &lt; 0.0)
+    _angle = _angle + 2 * M_PI;
 
+  return _angle * 360 / (2 * M_PI);
+}
 
-	  if( tc * td &lt; 0 &amp;&amp; ta * tb &lt; 0)
-		  return true;
-	  else
-		  return false;
-  }
+bool isIntersectLine(double p1x, double p1y, double p2x, double p2y, double p3x, double p3y, double p4x, double p4y)
+{
+  double ta = (p3x - p4x) * (p1y - p3y) + (p3y - p4y) * (p3x - p4x);
+  double tb = (p3x - p4x) * (p2y - p3y) + (p3y - p4y) * (p3x - p2x);
+  double tc = (p1x - p2x) * (p3y - p1y) + (p1y - p2y) * (p1x - p3x);
+  double td = (p1x - p2x) * (p4y - p1y) + (p1y - p2y) * (p1x - p4x);
+
+  if (tc * td &lt; 0 &amp;&amp; ta * tb &lt; 0)
+    return true;
+  else
+    return false;
+}
 #define LEFT 1
 #define RIGHT -1
 #define ONLINE 0
 
-  int isPointLeftFromLine(double p1x, double p1y, double line_p1x, double line_p1y,
-		  double line_p2x, double line_p2y){
-
-	  double n = p1x * (line_p1y - line_p2y) + 
-		  line_p1x * (line_p2y - p1y) + 
-		  line_p2x * (p1y - line_p1y);
-
-	  return n &gt; 0? 1:
-		  n &lt; 0? -1: 0;
-
-  }
-
+int isPointLeftFromLine(double p1x, double p1y, double line_p1x, double line_p1y, double line_p2x, double line_p2y)
+{
+  double n = p1x * (line_p1y - line_p2y) + line_p1x * (line_p2y - p1y) + line_p2x * (p1y - line_p1y);
 
-} 
+  return n &gt; 0 ? 1 : n &lt; 0 ? -1 : 0;
+}
+}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" added_lines="2" deleted_lines="2">
				<diff>@@ -90,12 +90,12 @@ public:
   virtual void inState(void)
   {
     if (StateCallbackInFunc)
-	    StateCallbackInFunc();
+      StateCallbackInFunc();
   }
   virtual void outState(void)
   {
     if (StateCallbackOutFunc)
-	    StateCallbackOutFunc();
+      StateCallbackOutFunc();
   }
   virtual void setCallbackUpdateFunc(std::function&lt;void(void)&gt; _f)
   {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" added_lines="10" deleted_lines="14">
				<diff>@@ -20,7 +20,6 @@ namespace state_machine
 class StateContext
 {
 private:
-  
   std::map&lt;uint8_t, uint64_t&gt; HolderMap;
   std::unordered_map&lt;uint64_t, BaseState *&gt; StateStores;
 
@@ -40,7 +39,6 @@ private:
 public:
   StateContext(void)
   {
-
     StateStores[START_STATE] = StartState::getInstance();
     StateStores[INITIAL_STATE] = InitialState::getInstance();
     StateStores[INITIAL_LOCATEVEHICLE_STATE] = LocateVehicleState::getInstance();
@@ -62,12 +60,12 @@ public:
     StateStores[MISSION_COMPLETE_STATE] = MissionCompleteState::getInstance();
     StateStores[EMERGENCY_STATE] = EmergencyState::getInstance();
 
-    HolderMap[MAIN_STATE] 	=  0ULL;
-    HolderMap[ACC_STATE] 	=  0ULL;
-    HolderMap[STR_STATE] 	=  0ULL;
-    HolderMap[BEHAVIOR_STATE] 	=  0ULL;
-    HolderMap[PERCEPTION_STATE] =  0ULL;
-    HolderMap[OTHER_STATE] 	=  0ULL;
+    HolderMap[MAIN_STATE] = 0ULL;
+    HolderMap[ACC_STATE] = 0ULL;
+    HolderMap[STR_STATE] = 0ULL;
+    HolderMap[BEHAVIOR_STATE] = 0ULL;
+    HolderMap[PERCEPTION_STATE] = 0ULL;
+    HolderMap[OTHER_STATE] = 0ULL;
 
     thread_loop = true;
 
@@ -93,22 +91,20 @@ public:
   bool disableCurrentState(uint64_t);
 
   BaseState *getStateObject(const uint64_t &amp;_state_num);
-  std::string getStateName(const uint64_t &amp;_state_num); 
-  uint8_t getStateKind(const uint64_t &amp;_state_num );
+  std::string getStateName(const uint64_t &amp;_state_num);
+  uint8_t getStateKind(const uint64_t &amp;_state_num);
 
   BaseState *getCurrentMainState(void);
   BaseState *getCurrentState(void);
   std::string getCurrentStateName(void);
   std::string getStateName(void);
 
-
-  std::vector&lt;BaseState*&gt; getMultipleStates(uint64_t _state_num_set);
+  std::vector&lt;BaseState *&gt; getMultipleStates(uint64_t _state_num_set);
 
   bool setCallbackInFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
   bool setCallbackOutFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
   bool setCallbackUpdateFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
-  
-  
+
   BaseState **getCurrentStateHolderPtr(uint8_t _kind);
   BaseState **getCurrentStateHolderPtr(uint64_t _state_num);
   BaseState **getCurrentStateHolderPtr(BaseState *_state);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" added_lines="2" deleted_lines="3">
				<diff>@@ -96,7 +96,7 @@ private:
   DriveAccStopState(void)
   {
     StateName = "Stop";
-    StateNum =  DRIVE_ACC_STOP_STATE;
+    StateNum = DRIVE_ACC_STOP_STATE;
     StateKind = ACC_STATE;
   }
 
@@ -110,7 +110,7 @@ private:
   DriveAccStopLineState(void)
   {
     StateName = "StopLine";
-    StateNum =  DRIVE_ACC_STOPLINE_STATE;
+    StateNum = DRIVE_ACC_STOPLINE_STATE;
     StateKind = ACC_STATE;
   }
 
@@ -226,6 +226,5 @@ private:
 
 public:
 };
-
 }
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" added_lines="26" deleted_lines="26">
				<diff>@@ -5,32 +5,32 @@ namespace state_machine
 {
 enum StateFlags
 {
-  NULL_STATE 			= 1ULL &lt;&lt; 0,
-  START_STATE 			= 1ULL &lt;&lt; 1,
-  INITIAL_STATE 		= 1ULL &lt;&lt; 2,
-  INITIAL_LOCATEVEHICLE_STATE 	= 1ULL &lt;&lt; 3,
-  DRIVE_STATE 			= 1ULL &lt;&lt; 4,
-  MISSION_COMPLETE_STATE 	= 1ULL &lt;&lt; 5,
-  EMERGENCY_STATE 		= 1ULL &lt;&lt; 6,
- 
-  DRIVE_SUB_STATE_START		= 1ULL &lt;&lt; 10,
-
-  DRIVE_ACC_ACCELERATION_STATE 	= 1ULL &lt;&lt; 11,
-  DRIVE_ACC_DECELERATION_STATE 	= 1ULL &lt;&lt; 12,
-  DRIVE_ACC_KEEP_STATE		= 1ULL &lt;&lt; 13,
-  DRIVE_ACC_STOP_STATE 		= 1ULL &lt;&lt; 14,
-  DRIVE_ACC_STOPLINE_STATE 	= 1ULL &lt;&lt; 15,
-  DRIVE_ACC_CRAWL_STATE 	= 1ULL &lt;&lt; 16,
-  
-  DRIVE_STR_STRAIGHT_STATE 	= 1ULL &lt;&lt; 21,
-  DRIVE_STR_LEFT_STATE 		= 1ULL &lt;&lt; 22,
-  DRIVE_STR_RIGHT_STATE 	= 1ULL &lt;&lt; 23,
- 
-  DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE 		= 1ULL &lt;&lt; 31,
-  DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE 	= 1ULL &lt;&lt; 32,
-  DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE 	= 1ULL &lt;&lt; 33,
-  DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 	= 1ULL &lt;&lt; 34,
-  DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE 	= 1ULL &lt;&lt; 35,
+  NULL_STATE = 1ULL &lt;&lt; 0,
+  START_STATE = 1ULL &lt;&lt; 1,
+  INITIAL_STATE = 1ULL &lt;&lt; 2,
+  INITIAL_LOCATEVEHICLE_STATE = 1ULL &lt;&lt; 3,
+  DRIVE_STATE = 1ULL &lt;&lt; 4,
+  MISSION_COMPLETE_STATE = 1ULL &lt;&lt; 5,
+  EMERGENCY_STATE = 1ULL &lt;&lt; 6,
+
+  DRIVE_SUB_STATE_START = 1ULL &lt;&lt; 10,
+
+  DRIVE_ACC_ACCELERATION_STATE = 1ULL &lt;&lt; 11,
+  DRIVE_ACC_DECELERATION_STATE = 1ULL &lt;&lt; 12,
+  DRIVE_ACC_KEEP_STATE = 1ULL &lt;&lt; 13,
+  DRIVE_ACC_STOP_STATE = 1ULL &lt;&lt; 14,
+  DRIVE_ACC_STOPLINE_STATE = 1ULL &lt;&lt; 15,
+  DRIVE_ACC_CRAWL_STATE = 1ULL &lt;&lt; 16,
+
+  DRIVE_STR_STRAIGHT_STATE = 1ULL &lt;&lt; 21,
+  DRIVE_STR_LEFT_STATE = 1ULL &lt;&lt; 22,
+  DRIVE_STR_RIGHT_STATE = 1ULL &lt;&lt; 23,
+
+  DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE = 1ULL &lt;&lt; 31,
+  DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE = 1ULL &lt;&lt; 32,
+  DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE = 1ULL &lt;&lt; 33,
+  DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE = 1ULL &lt;&lt; 34,
+  DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE = 1ULL &lt;&lt; 35,
   STATE_SUB_END = 1ULL &lt;&lt; 40,
   STATE_END = 1ULL &lt;&lt; 41,
 };
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="188" deleted_lines="137">
				<diff>@@ -23,124 +23,157 @@
 
 namespace state_machine
 {
-
 std::vector&lt;BaseState *&gt; StateContext::getMultipleStates(uint64_t _state_num_set)
 {
-	std::vector&lt;BaseState *&gt; ret;
-	for(uint64_t mask = STATE_SUB_END; _state_num_set!= 0 &amp;&amp; mask != 0; mask &gt;&gt;=1){
-		if(mask &amp; _state_num_set){
-			ret.push_back(getStateObject(mask));
-			_state_num_set &amp;= ~mask;
-		}
-	}
-	return ret;
+  std::vector&lt;BaseState *&gt; ret;
+  for (uint64_t mask = STATE_SUB_END; _state_num_set != 0 &amp;&amp; mask != 0; mask &gt;&gt;= 1)
+  {
+    if (mask &amp; _state_num_set)
+    {
+      ret.push_back(getStateObject(mask));
+      _state_num_set &amp;= ~mask;
+    }
+  }
+  return ret;
 }
 
 void StateContext::update(void)
 {
   for (auto &amp;p : HolderMap)
   {
-    if (p.first == BEHAVIOR_STATE){
-	    for(auto &amp;&amp;state :  getMultipleStates(p.second)){
-			state-&gt;update();
-	    }
-    }else{
-	    if (p.second)
-		    if(getStateObject(p.second))
-			    getStateObject(p.second)-&gt;update();
+    if (p.first == BEHAVIOR_STATE)
+    {
+      for (auto &amp;&amp;state : getMultipleStates(p.second))
+      {
+        state-&gt;update();
+      }
+    }
+    else
+    {
+      if (p.second)
+        if (getStateObject(p.second))
+          getStateObject(p.second)-&gt;update();
     }
   }
 }
 
 void StateContext::inState(uint8_t _kind, uint64_t _prev_state_num)
 {
-	if(_kind &gt;  UNKNOWN_STATE){
-		return;
-	}else if(_kind == BEHAVIOR_STATE){
-	    for(auto &amp;&amp;state :  getMultipleStates(HolderMap[_kind])){
-	    	if(!(_prev_state_num &amp; getStateNum(state)))
-		    state-&gt;inState();
-	    }
-	}else{
-		if(getStateObject(HolderMap[_kind]))
-			getStateObject(HolderMap[_kind])-&gt;inState();
-	}
+  if (_kind &gt; UNKNOWN_STATE)
+  {
+    return;
+  }
+  else if (_kind == BEHAVIOR_STATE)
+  {
+    for (auto &amp;&amp;state : getMultipleStates(HolderMap[_kind]))
+    {
+      if (!(_prev_state_num &amp; getStateNum(state)))
+        state-&gt;inState();
+    }
+  }
+  else
+  {
+    if (getStateObject(HolderMap[_kind]))
+      getStateObject(HolderMap[_kind])-&gt;inState();
+  }
 }
 
-
 BaseState *StateContext::getStateObject(const uint64_t &amp;_state_num)
 {
-	if(_state_num){
-		if(StateStores[_state_num]){
-			return StateStores[_state_num];
-		}
-	}
-	return nullptr;
+  if (_state_num)
+  {
+    if (StateStores[_state_num])
+    {
+      return StateStores[_state_num];
+    }
+  }
+  return nullptr;
 }
 
 bool StateContext::setCallbackUpdateFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f)
 {
-	if(getStateObject(_state_num))
-			getStateObject(_state_num)-&gt;setCallbackUpdateFunc(_f);
+  bool ret = false;
+  if (getStateObject(_state_num))
+  {
+    getStateObject(_state_num)-&gt;setCallbackUpdateFunc(_f);
+    ret = true;
+  }
+
+  return ret;
 }
 bool StateContext::setCallbackInFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f)
 {
-	if(getStateObject(_state_num))
-			getStateObject(_state_num)-&gt;setCallbackInFunc(_f);
+  bool ret = false;
+  if (getStateObject(_state_num))
+  {
+    getStateObject(_state_num)-&gt;setCallbackInFunc(_f);
+    ret = true;
+  }
+  return ret;
 }
 bool StateContext::setCallbackOutFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f)
 {
-	if(getStateObject(_state_num))
-			getStateObject(_state_num)-&gt;setCallbackOutFunc(_f);
+  bool ret = false;
+  if (getStateObject(_state_num))
+  {
+    getStateObject(_state_num)-&gt;setCallbackOutFunc(_f);
+    ret = true;
+  }
+  return ret;
 }
 
-
 std::string StateContext::getStateName(const uint64_t &amp;_state_num)
 {
-	if(getStateObject(_state_num)){
-		return getStateObject(_state_num)-&gt;getStateName();
-	}else 
-		return "";
+  if (getStateObject(_state_num))
+  {
+    return getStateObject(_state_num)-&gt;getStateName();
+  }
+  else
+    return "";
 }
 
 uint64_t StateContext::getStateNum(BaseState *_state)
 {
-  if (_state){
-	  return _state-&gt;getStateNum();
-  }else
-	  return 0;
+  if (_state)
+  {
+    return _state-&gt;getStateNum();
+  }
+  else
+    return 0;
 }
 
 uint8_t StateContext::getStateKind(BaseState *_state)
 {
-	if (_state){
-		return _state-&gt;getStateKind();
-	}else
-		return UNKNOWN_STATE;
+  if (_state)
+  {
+    return _state-&gt;getStateKind();
+  }
+  else
+    return UNKNOWN_STATE;
 }
 
 uint8_t StateContext::getStateKind(const uint64_t &amp;_state_num)
 {
-	if (_state_num){
-		return getStateKind(getStateObject(_state_num));
-	}
-	return UNKNOWN_STATE;
+  if (_state_num)
+  {
+    return getStateKind(getStateObject(_state_num));
+  }
+  return UNKNOWN_STATE;
 }
 
-
 void StateContext::showCurrentStateName(void)
 {
   for (auto &amp;p : HolderMap)
   {
     if (p.second)
-	    if(getStateObject(p.second))
-		    getStateObject(p.second)-&gt;showStateName();
+      if (getStateObject(p.second))
+        getStateObject(p.second)-&gt;showStateName();
   }
 }
 
 bool StateContext::isDifferentState(uint64_t _state_a, uint64_t _state_b)
 {
-	return !(_state_a &amp; _state_b);
+  return !(_state_a &amp; _state_b);
 }
 
 bool StateContext::isEmptyMainState(void)
@@ -167,55 +200,64 @@ bool StateContext::setCurrentState(BaseState *_state)
 {
   change_state_mutex.lock();
   bool ret = true;
-  if(_state){
-	  uint64_t prev_state = HolderMap[getStateKind(_state)];
-	  bool diff =  isDifferentState(getStateNum(_state), HolderMap[getStateKind(_state)]);
-	  if (isMainState(_state))
-	  {
-		  if (isEmptyMainState() || enableForceSetState ||
-				  (getStateTransMask(_state) &amp; HolderMap[MAIN_STATE]))
-		  {
-			  for(auto &amp;state : HolderMap){
-				  if(state.first == MAIN_STATE){
-					  state.second = getStateNum(_state);
-				  }else{
-					  state.second = 0ULL;
-				  }
-			  }
-		  }
-		  else
-		  {
-			  ret = false;
-		  }
-	  }
-	  else
-	  {
-		  if(getStateKind(_state) == BEHAVIOR_STATE){
-			  HolderMap[getStateKind(_state)] |= getStateNum(_state);
-		  }else{
-			  HolderMap[getStateKind(_state)] = getStateNum(_state);
-		  }
-	  }
-	  change_state_mutex.unlock();
-	  if(ret &amp;&amp; diff){
-		  this-&gt;inState(getStateKind(_state), prev_state);
-		  
-		  if(getStateKind(_state) == getStateKind(prev_state) &amp;&amp; 
-				  getStateKind(_state)!= BEHAVIOR_STATE)
-			  if(getStateObject(prev_state))
-					  getStateObject(prev_state)-&gt;outState();
-	  }
-  }else{
-	  change_state_mutex.unlock();
-	  ret = false;
+  if (_state)
+  {
+    uint64_t prev_state = HolderMap[getStateKind(_state)];
+    bool diff = isDifferentState(getStateNum(_state), HolderMap[getStateKind(_state)]);
+    if (isMainState(_state))
+    {
+      if (isEmptyMainState() || enableForceSetState || (getStateTransMask(_state) &amp; HolderMap[MAIN_STATE]))
+      {
+        for (auto &amp;state : HolderMap)
+        {
+          if (state.first == MAIN_STATE)
+          {
+            state.second = getStateNum(_state);
+          }
+          else
+          {
+            state.second = 0ULL;
+          }
+        }
+      }
+      else
+      {
+        ret = false;
+      }
+    }
+    else
+    {
+      if (getStateKind(_state) == BEHAVIOR_STATE)
+      {
+        HolderMap[getStateKind(_state)] |= getStateNum(_state);
+      }
+      else
+      {
+        HolderMap[getStateKind(_state)] = getStateNum(_state);
+      }
+    }
+    change_state_mutex.unlock();
+    if (ret &amp;&amp; diff)
+    {
+      this-&gt;inState(getStateKind(_state), prev_state);
+
+      if (getStateKind(_state) == getStateKind(prev_state) &amp;&amp; getStateKind(_state) != BEHAVIOR_STATE)
+        if (getStateObject(prev_state))
+          getStateObject(prev_state)-&gt;outState();
+    }
+  }
+  else
+  {
+    change_state_mutex.unlock();
+    ret = false;
   }
   return ret;
 }
 
 bool StateContext::setCurrentState(uint64_t flag)
 {
-	bool ret = this-&gt;setCurrentState(getStateObject(flag));
-	return ret;
+  bool ret = this-&gt;setCurrentState(getStateObject(flag));
+  return ret;
 }
 
 bool StateContext::setEnableForceSetState(bool force_flag)
@@ -231,50 +273,59 @@ std::string StateContext::getCurrentStateName(void)
 
 std::string StateContext::getCurrentStateName(uint8_t _kind)
 {
-	if (HolderMap[_kind]){
-		if(_kind == BEHAVIOR_STATE){
-			uint64_t _current_state = HolderMap[_kind];
-			std::string ret = "";
-			for(uint64_t mask = STATE_SUB_END; _current_state != 0 &amp;&amp; mask != 0; mask &gt;&gt;=1){
-				if(mask &amp; _current_state){
-					ret += "\n" + getStateName(mask);
-					_current_state &amp;= ~mask;
-				}
-			}
-			return ret;
-
-		}else{
-			return getStateName(HolderMap[_kind]);
-		}
-	}
-	return std::string("");
+  if (HolderMap[_kind])
+  {
+    if (_kind == BEHAVIOR_STATE)
+    {
+      uint64_t _current_state = HolderMap[_kind];
+      std::string ret = "";
+      for (uint64_t mask = STATE_SUB_END; _current_state != 0 &amp;&amp; mask != 0; mask &gt;&gt;= 1)
+      {
+        if (mask &amp; _current_state)
+        {
+          ret += "\n" + getStateName(mask);
+          _current_state &amp;= ~mask;
+        }
+      }
+      return ret;
+    }
+    else
+    {
+      return getStateName(HolderMap[_kind]);
+    }
+  }
+  return std::string("");
 }
 
 BaseState *StateContext::getCurrentMainState(void)
 {
-	return getStateObject(HolderMap[MAIN_STATE]);
+  return getStateObject(HolderMap[MAIN_STATE]);
 }
 
 bool StateContext::disableCurrentState(uint64_t _state_num)
 {
-	if(isMainState(getStateObject(_state_num))){
-		return false;
-	}
-	if(isCurrentState(_state_num)){
-		HolderMap[getStateKind(_state_num)] &amp;= ~_state_num;
-		getStateObject(_state_num)-&gt;outState();
-		return true;
-	}else{
-		return false;
-	}
+  if (isMainState(getStateObject(_state_num)))
+  {
+    return false;
+  }
+  if (isCurrentState(_state_num))
+  {
+    HolderMap[getStateKind(_state_num)] &amp;= ~_state_num;
+    getStateObject(_state_num)-&gt;outState();
+    return true;
+  }
+  else
+  {
+    return false;
+  }
 }
 
 bool StateContext::isCurrentState(uint64_t _state_num)
 {
-	if(_state_num)
-	  return HolderMap[getStateKind(_state_num)] &amp; _state_num;
-	else
-	  return false;
+  if (_state_num)
+    return HolderMap[getStateKind(_state_num)] &amp; _state_num;
+  else
+    return false;
 }
 
 bool StateContext::isState(BaseState *base, uint64_t _state_num)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\cross_road_area.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\cross_road_area.hpp" added_lines="12" deleted_lines="14">
				<diff>@@ -10,7 +10,6 @@
 
 namespace decision_maker
 {
-
 class CrossRoadArea
 {
 public:
@@ -32,23 +31,22 @@ public:
   }
 
   static CrossRoadArea *findClosestCrossRoad(const autoware_msgs::lane &amp;_finalwaypoints,
-		  std::vector&lt;CrossRoadArea&gt; &amp;intersects);
-  static bool isInsideArea(const CrossRoadArea* _TargetArea,
- 		  geometry_msgs::Point pt);
-
+                                             std::vector&lt;CrossRoadArea&gt; &amp;intersects);
+  static bool isInsideArea(const CrossRoadArea *_TargetArea, geometry_msgs::Point pt);
 
   static CrossRoadArea *getCrossRoadArea(std::vector&lt;CrossRoadArea&gt; &amp;areas, int aid)
   {
-	  CrossRoadArea *ret = nullptr;
-	  for( auto &amp;area : areas){
-		  if(area.area_id == aid){
-			  ret = &amp;area;
-			  break;
-		  }
-	  }
-	  return ret;
+    CrossRoadArea *ret = nullptr;
+    for (auto &amp;area : areas)
+    {
+      if (area.area_id == aid)
+      {
+        ret = &amp;area;
+        break;
+      }
+    }
+    return ret;
   }
-
 };
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="10" deleted_lines="13">
				<diff>@@ -5,8 +5,8 @@
 #include &lt;unordered_map&gt;
 
 #include &lt;autoware_msgs/ConfigDecisionMaker.h&gt;
-#include &lt;autoware_msgs/lane.h&gt;
 #include &lt;autoware_msgs/LaneArray.h&gt;
+#include &lt;autoware_msgs/lane.h&gt;
 #include &lt;autoware_msgs/traffic_light.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;geometry_msgs/TwistStamped.h&gt;
@@ -28,11 +28,11 @@
 #include &lt;geometry_msgs/Point.h&gt;
 
 // lib
-#include &lt;cross_road_area.hpp&gt;
 #include &lt;amathutils.hpp&gt;
+#include &lt;cross_road_area.hpp&gt;
+#include &lt;decision_maker_param.hpp&gt;
 #include &lt;state.hpp&gt;
 #include &lt;state_context.hpp&gt;
-#include &lt;decision_maker_param.hpp&gt;
 
 namespace decision_maker
 {
@@ -91,12 +91,10 @@ private:
 
   std::vector&lt;geometry_msgs::Point&gt; inside_points_;
 
-  autoware_msgs::LaneArray current_based_lane_array_; // with wpstate
-  autoware_msgs::LaneArray current_shifted_lane_array_; // with shiftedLane
-  autoware_msgs::LaneArray current_controlled_lane_array_; // modified lane
-  autoware_msgs::LaneArray current_stopped_lane_array_; // 0velocity
-
-
+  autoware_msgs::LaneArray current_based_lane_array_;       // with wpstate
+  autoware_msgs::LaneArray current_shifted_lane_array_;     // with shiftedLane
+  autoware_msgs::LaneArray current_controlled_lane_array_;  // modified lane
+  autoware_msgs::LaneArray current_stopped_lane_array_;     // 0velocity
 
   // Current way/behavior status
   double current_velocity_;
@@ -149,14 +147,13 @@ private:
   std::string createStateMessageText();
   int createCrossRoadAreaMarker(visualization_msgs::Marker &amp;crossroad_marker, double scale);
 
-
   // judge method
   // in near future, these methods will be deprecate to decision_maker library
   bool isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
   bool isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch, double _yaw);
   bool handleStateCmd(const uint64_t _state_num);
-  //double calcIntersectWayAngle(const CrossRoadArea&amp; area);
-  double calcIntersectWayAngle(const autoware_msgs::lane&amp; laneinArea);
+  // double calcIntersectWayAngle(const CrossRoadArea&amp; area);
+  double calcIntersectWayAngle(const autoware_msgs::lane &amp;laneinArea);
 
   void insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects, autoware_msgs::LaneArray &amp;lane_array);
 
@@ -173,7 +170,7 @@ private:
   void createShiftLane(void);
   void changeShiftLane(void);
   void removeShiftLane(void);
-  
+
   void publishLightColor(int status);
   void callbackInStateObstacleAvoid(int status);
   void callbackOutStateObstacleAvoid(int status);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_param.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_param.hpp" added_lines="5" deleted_lines="6">
				<diff>@@ -15,23 +15,22 @@ namespace decision_maker
 #define DOUBLE_MAX 1.7976931348623158e308
 #define DEFAULT_TARGET_WAYPOINT 14
 
-
 #define DEFAULT_STOP_DECELERATION 0.2
-#define DEFAULT_STOP_TIME 1 
+#define DEFAULT_STOP_TIME 1
 #define DEFAULT_STOPLINE_TARGET_WAYPOINT 10
 #define DEFAULT_SHIFT_WIDTH 1.0
 #define DEFAULT_CRAWL_VELOCITY 4.0
 
 #define ANGLE_NEUTRAL 0
 #define ANGLE_CURVE 40
-#define ANGLE_LEFT  (ANGLE_NEUTRAL - ANGLE_CURVE)
+#define ANGLE_LEFT (ANGLE_NEUTRAL - ANGLE_CURVE)
 #define ANGLE_RIGHT (ANGLE_NEUTRAL + ANGLE_CURVE)
 
 #define TPNAME_BASED_LANE_WAYPOINTS_ARRAY "/based/lane_waypoints_array"
 #define TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY "/lane_waypoints_array"
-#define LAMP_EMPTY  0
-#define LAMP_LEFT   1
-#define LAMP_RIGHT  2
+#define LAMP_EMPTY 0
+#define LAMP_LEFT 1
+#define LAMP_RIGHT 2
 #define LAMP_HAZARD 3
 #define LAMP_ON 1
 #define LAMP_OFF 0
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="14" deleted_lines="22">
				<diff>@@ -54,7 +54,7 @@ void DecisionMakerNode::callbackFromSimPose(const geometry_msgs::PoseStamped &amp;ms
 
 void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
 {
-  ROS_INFO("Received forcing state changing request: %lx", 1ULL &lt;&lt; (uint64_t)msg.data);
+  ROS_INFO("Received forcing state changing request: %llx", 1ULL &lt;&lt; (uint64_t)msg.data);
   handleStateCmd((uint64_t)1ULL &lt;&lt; (uint64_t)msg.data);
 }
 
@@ -86,13 +86,10 @@ void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMa
   param_target_waypoint_ = msg.target_waypoint;
   param_stopline_target_waypoint_ = msg.stopline_target_waypoint;
   param_shift_width_ = msg.shift_width;
-
 }
 
 void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
 {
-  const ros::M_string &amp;header = event.getConnectionHeader();
-  std::string topic = header.at("topic");
   const autoware_msgs::traffic_light *light = event.getMessage().get();
 
   current_traffic_light_ = light-&gt;traffic_light;
@@ -281,29 +278,24 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
   size_t idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_stopline_target_waypoint_ ?
                    param_stopline_target_waypoint_ :
                    current_finalwaypoints_.waypoints.size() - 1;
-  if (idx &gt;= 0)
-  {
-    if (current_finalwaypoints_.waypoints.at(idx).wpstate.stopline_state)
-      ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
-  }
+  
+  if (current_finalwaypoints_.waypoints.at(idx).wpstate.stopline_state)
+	  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
   // steering
   idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_target_waypoint_ ?
             param_target_waypoint_ :
             current_finalwaypoints_.waypoints.size() - 1;
-  if (idx &gt;= 0)
+  if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE))
   {
-    if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE))
-    {
-      ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
-    }
-    if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE))
-    {
-      ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
-    }
-    else
-    {
-      ctx-&gt;setCurrentState(getStateFlags(current_finalwaypoints_.waypoints.at(idx).wpstate.steering_state));
-    }
+	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
+  }
+  if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE))
+  {
+	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
+  }
+  else
+  {
+	  ctx-&gt;setCurrentState(getStateFlags(current_finalwaypoints_.waypoints.at(idx).wpstate.steering_state));
   }
 
   // for publish plan of velocity
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" added_lines="2" deleted_lines="6">
				<diff>@@ -68,7 +68,6 @@ bool DecisionMakerNode::isLocalizationConvergence(double _x, double _y, double _
 
   static std::vector&lt;double&gt; distances;
   static uint32_t distances_count = 0;
-  double avg_distances = 0.0;
 
   a-&gt;x = b-&gt;x;
   a-&gt;y = b-&gt;y;
@@ -83,15 +82,12 @@ bool DecisionMakerNode::isLocalizationConvergence(double _x, double _y, double _
   {
     distances.erase(distances.begin());
     distances_count--;
-    avg_distances = std::accumulate(distances.begin(), distances.end(), 0) / distances.size();
+    double avg_distances = std::accumulate(distances.begin(), distances.end(), 0) / distances.size();
     if (avg_distances &lt;= param_convergence_threshold_)
     {
       return ctx-&gt;setCurrentState(state_machine::DRIVE_STATE);
     }
   }
-  else
-  {
-    return false;
-  }
+  return false;
 }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="22" deleted_lines="8">
				<diff>@@ -51,15 +51,19 @@ void DecisionMakerNode::initROS(int argc, char **argv)
       nh_.subscribe("/config/decision_maker", 3, &amp;DecisionMakerNode::callbackFromConfig, this);
 
   // pub
+
+  // for controlling other planner
   Pubs["state"] = nh_.advertise&lt;std_msgs::String&gt;("state", 1);
   Pubs["lane_waypoints_array"] = nh_.advertise&lt;autoware_msgs::LaneArray&gt;(TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY, 10, true);
   Pubs["states"] = nh_.advertise&lt;autoware_msgs::state&gt;("/decisionmaker/states", 1, true);
+  Pubs["light_color"] = nh_.advertise&lt;autoware_msgs::traffic_light&gt;("/light_color", 1);
 
+  // for controlling vehicle
   Pubs["lamp_cmd"] = nh_.advertise&lt;autoware_msgs::lamp_cmd&gt;("/lamp_cmd", 1);
-  Pubs["light_color"] = nh_.advertise&lt;autoware_msgs::traffic_light&gt;("/light_color", 1);
+  Pubs["emergency"] =
 
-  // for visualize
-  Pubs["state_overlay"] = nh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;("/state/overlay_text", 1);
+      // for visualize status
+      Pubs["state_overlay"] = nh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;("/state/overlay_text", 1);
   Pubs["crossroad_marker"] = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("/state/cross_road_marker", 1);
   Pubs["crossroad_inside_marker"] = nh_.advertise&lt;visualization_msgs::Marker&gt;("/state/cross_inside_marker", 1);
   Pubs["crossroad_bbox"] = nh_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("/state/crossroad_bbox", 10);
@@ -68,14 +72,24 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   Pubs["target_velocity_array"] = nh_.advertise&lt;std_msgs::Float64MultiArray&gt;("/target_velocity_array", 1);
   Pubs["state_local_diffdistance"] = nh_.advertise&lt;std_msgs::Float64&gt;("/state/val_diff_distance", 1);
   Pubs["exectime"] = nh_.advertise&lt;std_msgs::Float64&gt;("/state/exectime", 1);
+
   // message setup
-  state_text_msg.text_size = 18;
-  state_text_msg.line_width = 0;
-  state_text_msg.font = "DejaVu Sans Mono";
-  state_text_msg.width = 500;
-  state_text_msg.height = 50;
+  state_text_msg.width = 400;
+  state_text_msg.height = 500;
   state_text_msg.top = 10;
   state_text_msg.left = 10;
+  state_text_msg.bg_color.r = 0;
+  state_text_msg.bg_color.g = 0;
+  state_text_msg.bg_color.b = 0;
+  state_text_msg.bg_color.a = 0.8;
+
+  state_text_msg.line_width = 2;
+  state_text_msg.text_size = 18;
+  state_text_msg.font = "DejaVu Sans Mono";
+  state_text_msg.fg_color.r = 0.1;
+  state_text_msg.fg_color.g = 1.0;
+  state_text_msg.fg_color.b = 0.94;
+  state_text_msg.fg_color.a = 0.8;
   state_text_msg.text = "UNDEFINED";
 
   // initial publishing state message
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -110,7 +110,6 @@ void DecisionMakerNode::displayMarker(void)
   }
   inside_line_marker.scale.x = 0.2;  // 0.3;
   inside_line_marker.scale.y = 0.2;  // 0.3;
-  int id = inside_line_marker.id;
   inside_line_marker.color.r = 0;
   inside_line_marker.color.g = 1;
   inside_line_marker.color.b = 0.3;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="67" deleted_lines="61">
				<diff>@@ -56,14 +56,19 @@ void DecisionMakerNode::setupStateCallback(void)
 
   // trraficlight
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
-                             [&amp;](){ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);});
+                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE); });
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
-                             [&amp;](){ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);});
-  
+                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE); });
+
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
                              std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_RED));
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                              std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_GREEN));
+
+  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
+                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE); });
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
+                             std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_GREEN));
 }
 
 void DecisionMakerNode::publishLightColor(int status)
@@ -76,55 +81,50 @@ void DecisionMakerNode::publishLightColor(int status)
 #define SHIFTED_LANE_FLAG -99999
 void DecisionMakerNode::createShiftLane(void)
 {
-  if (!created_shift_lane_flag_)
-  {
-    bool isRightShift = param_shift_width_ &gt;= 0;
+  bool isRightShift = param_shift_width_ &gt;= 0;
 
-    created_shift_lane_flag_ = true;
-    autoware_msgs::LaneArray shift_lanes = current_shifted_lane_array_ = current_based_lane_array_;
-    if (!current_shifted_lane_array_.lanes.empty())
+  autoware_msgs::LaneArray shift_lanes = current_shifted_lane_array_ = current_based_lane_array_;
+  if (!current_shifted_lane_array_.lanes.empty())
+  {
+    size_t lane_idx = 0;
+    for (auto &amp;lane : shift_lanes.lanes)
     {
-      size_t lane_idx = 0;
-      for (auto &amp;lane : shift_lanes.lanes)
+      lane.increment = SHIFTED_LANE_FLAG;
+      size_t wp_idx = 0;
+      for (auto &amp;wp : lane.waypoints)
       {
-        lane.increment = SHIFTED_LANE_FLAG;
-        size_t wp_idx = 0;
-        for (auto &amp;wp : lane.waypoints)
-        {
-          double angle = getPoseAngle(wp.pose.pose);
-          wp.pose.pose.position.x -= param_shift_width_ * cos(angle + M_PI / 2);
-          wp.pose.pose.position.y -= param_shift_width_ * sin(angle + M_PI / 2);
-          wp.change_flag = current_based_lane_array_.lanes.at(lane_idx).waypoints.at(wp_idx++).change_flag;
-        }
-        lane_idx++;
+        double angle = getPoseAngle(wp.pose.pose);
+        wp.pose.pose.position.x -= param_shift_width_ * cos(angle + M_PI / 2);
+        wp.pose.pose.position.y -= param_shift_width_ * sin(angle + M_PI / 2);
+        wp.change_flag = current_based_lane_array_.lanes.at(lane_idx).waypoints.at(wp_idx++).change_flag;
       }
+      lane_idx++;
     }
-    int insert_lane_idx_offset = isRightShift ? 1 : 0;
-    auto it_shift = begin(shift_lanes.lanes);
-    try
+  }
+  int insert_lane_idx_offset = isRightShift ? 1 : 0;
+  auto it_shift = begin(shift_lanes.lanes);
+  try
+  {
+    for (auto it = begin(current_shifted_lane_array_.lanes);
+         it != end(current_shifted_lane_array_.lanes) &amp;&amp; it_shift != end(shift_lanes.lanes);)
     {
-      for (auto it = begin(current_shifted_lane_array_.lanes);
-           it != end(current_shifted_lane_array_.lanes) &amp;&amp; it_shift != end(shift_lanes.lanes);)
+      for (auto &amp;wp : it-&gt;waypoints)
       {
-        for (auto &amp;wp : it-&gt;waypoints)
-        {
-          wp.change_flag = isRightShift ? 1 : 2;
-        }
-        it = current_shifted_lane_array_.lanes.insert(it + insert_lane_idx_offset, *(it_shift++));
-        it++;
-        if (!isRightShift)
-          it++;
+        wp.change_flag = isRightShift ? 1 : 2;
       }
+      it = current_shifted_lane_array_.lanes.insert(it + insert_lane_idx_offset, *(it_shift++));
+      it++;
+      if (!isRightShift)
+        it++;
     }
-    catch (std::length_error)
-    {
-    }
+  }
+  catch (std::length_error)
+  {
   }
 }
 
 void DecisionMakerNode::changeShiftLane(void)
 {
-  int inserted_lane_idx_offset = param_shift_width_ &gt;= 0 ? -1 : +1;
   auto based_it = begin(current_shifted_lane_array_.lanes);
 
   for (auto &amp;lane : current_shifted_lane_array_.lanes)
@@ -150,7 +150,6 @@ void DecisionMakerNode::changeShiftLane(void)
 void DecisionMakerNode::removeShiftLane(void)
 {
   current_shifted_lane_array_ = current_based_lane_array_;
-  created_shift_lane_flag_ = false;
 }
 
 void DecisionMakerNode::updateLaneWaypointsArray(void)
@@ -232,7 +231,6 @@ void DecisionMakerNode::callbackInStateAcc(int status)
 void DecisionMakerNode::updateStateStop(int status)
 {
   static ros::Timer stopping_timer;
-  static bool timerflag = false;
   if (status)
   {
     if (current_velocity_ == 0.0 &amp;&amp; !timerflag)
@@ -255,41 +253,49 @@ void DecisionMakerNode::updateStateObstacleAvoid(int status)
 
 void DecisionMakerNode::callbackOutStateObstacleAvoid(int status)
 {
-  static ros::Timer avoidance_timer_2;
   changeShiftLane();
   changeVelocityBasedLane();
   publishControlledLaneArray();
-
   ros::Rate loop_rate(1);
   // wait for the start of lane change to the original lane
-  do
-  {
-    ros::spinOnce();
-    loop_rate.sleep();
-  } while (!ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) &amp;&amp;
-           !ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) &amp;&amp; ros::ok());
-  // wait for the end of lane change
-  do
+  if (created_shift_lane_flag_)
   {
-    ros::spinOnce();
-    loop_rate.sleep();
-  } while ((ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) ||
-            ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) ||
-            ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE)) &amp;&amp;
-           ros::ok());
-
-  removeShiftLane();
+    do
+    {
+      ros::spinOnce();
+      loop_rate.sleep();
+    } while (!ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) &amp;&amp;
+             !ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) &amp;&amp; ros::ok());
+    // wait for the end of lane change
+    do
+    {
+      ros::spinOnce();
+      loop_rate.sleep();
+    } while ((ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) ||
+              ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) ||
+              ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE)) &amp;&amp;
+             ros::ok());
+    removeShiftLane();
+    created_shift_lane_flag_ = false;
+  }
   changeVelocityBasedLane();  // rebased controlled lane
   publishControlledLaneArray();
-  return;
+return;
 }
 
 void DecisionMakerNode::callbackInStateObstacleAvoid(int status)
 {
+  // this state is temporary implementation.
+  // It means this state is desirable to use a way which enables the avoidance plannner such as astar, state lattice.
+
   // if car shoud stop before avoidance,
-  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
+  if (!created_shift_lane_flag_)
+  {
+    created_shift_lane_flag_ = true;
+    ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
+    createShiftLane();
+  }
 
-  createShiftLane();
   changeVelocityBasedLane();
 }
 void DecisionMakerNode::callbackInStateStop(int status)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="bddb548341b4c539012aaee2776ecc09d1a3a3b4" author="Yusuke FUJII">
		<msg>fix a variable declaration was not enough.</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="1" deleted_lines="0">
				<diff>@@ -230,6 +230,7 @@ void DecisionMakerNode::callbackInStateAcc(int status)
 }
 void DecisionMakerNode::updateStateStop(int status)
 {
+  static bool timerflag;
   static ros::Timer stopping_timer;
   if (status)
   {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7b384fbdc97793d8bf7c1387d22c50e1fc9109e3" author="christopherho-ApexAI">
		<msg>decoupled ray ground filter into lib and exe, added unit test (#932)</msg>
		<modified_files>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\ray_ground_filter.cpp" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ray_ground_filter\ray_ground_filter.cpp" added_lines="341" deleted_lines="398">
				<diff>@@ -28,7 +28,7 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  ********************
  *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
-*/
+ */
 #include &lt;iostream&gt;
 #include &lt;algorithm&gt;
 #include &lt;vector&gt;
@@ -45,422 +45,365 @@
 
 #include &lt;opencv2/core/version.hpp&gt;
 #if (CV_MAJOR_VERSION == 3)
-	#include "gencolors.cpp"
+#include "gencolors.cpp"
 #else
-	#include &lt;opencv2/contrib/contrib.hpp&gt;
+#include &lt;opencv2/contrib/contrib.hpp&gt;
 #endif
 
+#include "ray_ground_filter.h"
 
-class RayGroundFilter
+void RayGroundFilter::update_config_params(const autoware_msgs::ConfigRayGroundFilter::ConstPtr&amp; param)
 {
-private:
-
-	ros::NodeHandle     node_handle_;
-	ros::Subscriber     points_node_sub_;
-	ros::Subscriber     config_node_sub_;
-	ros::Publisher      groundless_points_pub_;
-	ros::Publisher      ground_points_pub_;
-
-	std::string         input_point_topic_;
-
-	double              sensor_height_;//meters
-	double              general_max_slope_;//degrees
-	double              local_max_slope_;//degrees
-	double              radial_divider_angle_;//distance in rads between dividers
-	double              concentric_divider_distance_;//distance in meters between concentric divisions
-	double              min_height_threshold_;//minimum height threshold regardless the slope, useful for close points
-	double              clipping_height_; //the points higher than this will be removed from the input cloud.
-	double              min_point_distance_;//minimum distance from the origin to consider a point as valid
-	double              reclass_distance_threshold_;//distance between points at which re classification will occur
-
-	size_t              radial_dividers_num_;
-	size_t              concentric_dividers_num_;
-
-	std::vector&lt;cv::Scalar&gt; colors_;
-	const size_t        color_num_ = 60;//different number of color to generate
-
-	struct PointXYZIRTColor
-	{
-		pcl::PointXYZI point;
-
-		float radius;       //cylindric coords on XY Plane
-		float theta;        //angle deg on XY plane
-
-		size_t radial_div;  //index of the radial divsion to which this point belongs to
-		size_t concentric_div;//index of the concentric division to which this points belongs to
-
-		size_t red;         //Red component  [0-255]
-		size_t green;       //Green Component[0-255]
-		size_t blue;        //Blue component [0-255]
-
-		size_t original_index; //index of this point in the source pointcloud
-	};
-	typedef std::vector&lt;PointXYZIRTColor&gt; PointCloudXYZIRTColor;
-
-	void update_config_params(const autoware_msgs::ConfigRayGroundFilter::ConstPtr&amp; param)
-	{
-		sensor_height_          = param-&gt;sensor_height;
-		general_max_slope_      = param-&gt;general_max_slope;
-		local_max_slope_        = param-&gt;local_max_slope;
-		radial_divider_angle_   = param-&gt;radial_divider_angle;
-		concentric_divider_distance_ = param-&gt;concentric_divider_distance;
-		min_height_threshold_   = param-&gt;min_height_threshold;
-		clipping_height_        = param-&gt;clipping_height;
-		min_point_distance_     = param-&gt;min_point_distance;
-		reclass_distance_threshold_ = param-&gt;reclass_distance_threshold;
-	}
-
-	void publish_cloud(const ros::Publisher&amp; in_publisher,
-	                         const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_cloud_to_publish_ptr,
-	                         const std_msgs::Header&amp; in_header)
-	{
-		sensor_msgs::PointCloud2 cloud_msg;
-		pcl::toROSMsg(*in_cloud_to_publish_ptr, cloud_msg);
-		cloud_msg.header = in_header;
-		in_publisher.publish(cloud_msg);
-	}
-
-	/*!
-	 *
-	 * @param[in] in_cloud Input Point Cloud to be organized in radial segments
-	 * @param[out] out_organized_points Custom Point Cloud filled with XYZRTZColor data
-	 * @param[out] out_radial_divided_indices Indices of the points in the original cloud for each radial segment
-	 * @param[out] out_radial_ordered_clouds Vector of Points Clouds, each element will contain the points ordered
-	 */
-	void ConvertXYZIToRTZColor(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_cloud,
-	                           PointCloudXYZIRTColor&amp; out_organized_points,
-	                           std::vector&lt;pcl::PointIndices&gt;&amp; out_radial_divided_indices,
-	                           std::vector&lt;PointCloudXYZIRTColor&gt;&amp; out_radial_ordered_clouds)
-	{
-		out_organized_points.resize(in_cloud-&gt;points.size());
-		out_radial_divided_indices.clear();
-		out_radial_divided_indices.resize(radial_dividers_num_);
-		out_radial_ordered_clouds.resize(radial_dividers_num_);
-
-		for(size_t i=0; i&lt; in_cloud-&gt;points.size(); i++)
-		{
-			PointXYZIRTColor new_point;
-			auto radius         = (float) sqrt(
-								 in_cloud-&gt;points[i].x*in_cloud-&gt;points[i].x
-								+ in_cloud-&gt;points[i].y*in_cloud-&gt;points[i].y
-								);
-			auto theta          = (float) atan2(in_cloud-&gt;points[i].y, in_cloud-&gt;points[i].x) * 180 / M_PI;
-			if (theta &lt; 0){ theta+=360; }
-
-			auto radial_div     = (size_t) floor(theta/radial_divider_angle_);
-			auto concentric_div = (size_t) floor(fabs(radius/concentric_divider_distance_));
-
-			new_point.point    = in_cloud-&gt;points[i];
-			new_point.radius   = radius;
-			new_point.theta    = theta;
-			new_point.radial_div = radial_div;
-			new_point.concentric_div = concentric_div;
-			new_point.red      = (size_t) colors_[new_point.radial_div % color_num_].val[0];
-			new_point.green    = (size_t) colors_[new_point.radial_div % color_num_].val[1];
-			new_point.blue     = (size_t) colors_[new_point.radial_div % color_num_].val[2];
-			new_point.original_index = i;
-
-			out_organized_points[i] = new_point;
-
-			//radial divisions
-			out_radial_divided_indices[radial_div].indices.push_back(i);
-
-			out_radial_ordered_clouds[radial_div].push_back(new_point);
-
-		}//end for
-
-		//order radial points on each division
-		#pragma omp for
-		for(size_t i=0; i&lt; radial_dividers_num_; i++)
-		{
-			std::sort(out_radial_ordered_clouds[i].begin(), out_radial_ordered_clouds[i].end(),
-			          [](const PointXYZIRTColor&amp; a, const PointXYZIRTColor&amp; b){ return a.radius &lt; b.radius; });
-		}
-	}
-
-	/*!
-	 * Classifies Points in the PointCoud as Ground and Not Ground
-	 * @param in_radial_ordered_clouds Vector of an Ordered PointsCloud ordered by radial distance from the origin
-	 * @param out_ground_indices Returns the indices of the points classified as ground in the original PointCloud
-	 * @param out_no_ground_indices Returns the indices of the points classified as not ground in the original PointCloud
-	 */
-	void ClassifyPointCloud(std::vector&lt;PointCloudXYZIRTColor&gt;&amp; in_radial_ordered_clouds,
-	                        pcl::PointIndices&amp; out_ground_indices,
-	                        pcl::PointIndices&amp; out_no_ground_indices)
-	{
-		out_ground_indices.indices.clear();
-		out_no_ground_indices.indices.clear();
-		#pragma omp for
-		for (size_t i=0; i &lt; in_radial_ordered_clouds.size(); i++)//sweep through each radial division
-		{
-			float prev_radius = 0.f;
-			float prev_height = - sensor_height_;
-			bool prev_ground = false;
-			bool current_ground = false;
-			for (size_t j=0; j &lt; in_radial_ordered_clouds[i].size(); j++)//loop through each point in the radial div
-			{
-				float points_distance = in_radial_ordered_clouds[i][j].radius - prev_radius;
-				float height_threshold = tan(DEG2RAD(local_max_slope_)) * points_distance;
-				float current_height = in_radial_ordered_clouds[i][j].point.z;
-				float general_height_threshold = tan(DEG2RAD(general_max_slope_)) * in_radial_ordered_clouds[i][j].radius;
-
-				//for points which are very close causing the height threshold to be tiny, set a minimum value
-				if (points_distance &gt; concentric_divider_distance_ &amp;&amp; height_threshold &lt; min_height_threshold_)
-					{ height_threshold = min_height_threshold_; }
-
-				//check current point height against the LOCAL threshold (previous point)
-				if (current_height &lt;= (prev_height + height_threshold)
-				    &amp;&amp; current_height &gt;= (prev_height - height_threshold)
-					)
-				{
-					//Check again using general geometry (radius from origin) if previous points wasn't ground
-					if (!prev_ground)
-					{
-						if(current_height &lt;= (-sensor_height_ + general_height_threshold)
-						   &amp;&amp; current_height &gt;= (-sensor_height_ - general_height_threshold))
-						{
-							current_ground = true;
-						}
-						else
-							{current_ground = false;}
-					}
-					else
-					{
-						current_ground = true;
-					}
-				}
-				else
-				{
-					//check if previous point is too far from previous one, if so classify again
-					if (points_distance &gt; reclass_distance_threshold_ &amp;&amp;
-							(current_height &lt;= (-sensor_height_ + height_threshold)
-							 &amp;&amp; current_height &gt;= (-sensor_height_ - height_threshold))
-						)
-					{
-						current_ground = true;
-					}
-					else
-						{current_ground = false;}
-				}
-
-				if (current_ground)
-				{
-					out_ground_indices.indices.push_back(in_radial_ordered_clouds[i][j].original_index);
-					prev_ground=true;
-				}
-				else
-				{
-					out_no_ground_indices.indices.push_back(in_radial_ordered_clouds[i][j].original_index);
-					prev_ground = false;
-				}
-
-				prev_radius = in_radial_ordered_clouds[i][j].radius;
-				prev_height = in_radial_ordered_clouds[i][j].point.z;
-			}
-		}
-	}
-
-	/*!
-	 * Removes the points higher than a threshold
-	 * @param in_cloud_ptr PointCloud to perform Clipping
-	 * @param in_clip_height Maximum allowed height in the cloud
-	 * @param out_clipped_cloud_ptr Resultung PointCloud with the points removed
-	 */
-	void ClipCloud(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_cloud_ptr,
-	               double in_clip_height,
-	               pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr out_clipped_cloud_ptr)
-	{
-		pcl::ExtractIndices&lt;pcl::PointXYZI&gt; extractor;
-		extractor.setInputCloud (in_cloud_ptr);
-		pcl::PointIndices indices;
-
-		#pragma omp for
-		for (size_t i=0; i&lt; in_cloud_ptr-&gt;points.size(); i++)
-		{
-			if (in_cloud_ptr-&gt;points[i].z &gt; in_clip_height)
-			{
-				indices.indices.push_back(i);
-			}
-		}
-		extractor.setIndices(boost::make_shared&lt;pcl::PointIndices&gt;(indices));
-		extractor.setNegative(true);//true removes the indices, false leaves only the indices
-		extractor.filter(*out_clipped_cloud_ptr);
-	}
-
-	/*!
-	 * Returns the resulting complementary PointCloud, one with the points kept and the other removed as indicated
-	 * in the indices
-	 * @param in_cloud_ptr Input PointCloud to which the extraction will be performed
-	 * @param in_indices Indices of the points to be both removed and kept
-	 * @param out_only_indices_cloud_ptr Resulting PointCloud with the indices kept
-	 * @param out_removed_indices_cloud_ptr Resulting PointCloud with the indices removed
-	 */
-	void ExtractPointsIndices(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_cloud_ptr,
-	                          const pcl::PointIndices&amp; in_indices,
-	                          pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr out_only_indices_cloud_ptr,
-	                          pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr out_removed_indices_cloud_ptr)
-	{
-		pcl::ExtractIndices&lt;pcl::PointXYZI&gt; extract_ground;
-		extract_ground.setInputCloud (in_cloud_ptr);
-		extract_ground.setIndices(boost::make_shared&lt;pcl::PointIndices&gt;(in_indices));
-
-		extract_ground.setNegative(false);//true removes the indices, false leaves only the indices
-		extract_ground.filter(*out_only_indices_cloud_ptr);
-
-		extract_ground.setNegative(true);//true removes the indices, false leaves only the indices
-		extract_ground.filter(*out_removed_indices_cloud_ptr);
-	}
-
-	/*!
-	 * Removes points up to a certain distance in the XY Plane
-	 * @param in_cloud_ptr Input PointCloud
-	 * @param in_min_distance Minimum valid distance, points closer than this will be removed.
-	 * @param out_filtered_cloud_ptr Resulting PointCloud with the invalid points removed.
-	 */
-	void RemovePointsUpTo(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_cloud_ptr,
-	                      double in_min_distance,
-	                      pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr out_filtered_cloud_ptr)
-	{
-		pcl::ExtractIndices&lt;pcl::PointXYZI&gt; extractor;
-		extractor.setInputCloud (in_cloud_ptr);
-		pcl::PointIndices indices;
-
-		#pragma omp for
-		for (size_t i=0; i&lt; in_cloud_ptr-&gt;points.size(); i++)
-		{
-			if (sqrt(in_cloud_ptr-&gt;points[i].x*in_cloud_ptr-&gt;points[i].x +
-			         in_cloud_ptr-&gt;points[i].y*in_cloud_ptr-&gt;points[i].y)
-			            &lt; in_min_distance)
-			{
-				indices.indices.push_back(i);
-			}
-		}
-		extractor.setIndices(boost::make_shared&lt;pcl::PointIndices&gt;(indices));
-		extractor.setNegative(true);//true removes the indices, false leaves only the indices
-		extractor.filter(*out_filtered_cloud_ptr);
-	}
-
-	void CloudCallback(const sensor_msgs::PointCloud2ConstPtr &amp;in_sensor_cloud)
-	{
-		pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr current_sensor_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
-		pcl::fromROSMsg(*in_sensor_cloud, *current_sensor_cloud_ptr);
-
-		pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr clipped_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
-
-		//remove points above certain point
-		ClipCloud(current_sensor_cloud_ptr, clipping_height_, clipped_cloud_ptr);
-
-		//remove closer points than a threshold
-		pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
-		RemovePointsUpTo(clipped_cloud_ptr, min_point_distance_,filtered_cloud_ptr);
-
-		//GetCloud Normals
-		//pcl::PointCloud&lt;pcl::PointXYZINormal&gt;::Ptr cloud_with_normals_ptr (new pcl::PointCloud&lt;pcl::PointXYZINormal&gt;);
-		//GetCloudNormals(current_sensor_cloud_ptr, cloud_with_normals_ptr, 5.0);
-
-		PointCloudXYZIRTColor organized_points;
-		std::vector&lt;pcl::PointIndices&gt; radial_division_indices;
-		std::vector&lt;pcl::PointIndices&gt; closest_indices;
-		std::vector&lt;PointCloudXYZIRTColor&gt; radial_ordered_clouds;
-
-		radial_dividers_num_ = ceil(360 / radial_divider_angle_);
-
-		ConvertXYZIToRTZColor(filtered_cloud_ptr,
-		                      organized_points,
-		                      radial_division_indices,
-		                      radial_ordered_clouds);
-
-		pcl::PointIndices ground_indices, no_ground_indices;
-
-		ClassifyPointCloud(radial_ordered_clouds, ground_indices, no_ground_indices);
-
-		pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr ground_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
-		pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr no_ground_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
-
-		ExtractPointsIndices(filtered_cloud_ptr, ground_indices, ground_cloud_ptr, no_ground_cloud_ptr);
-
-		publish_cloud(ground_points_pub_, ground_cloud_ptr, in_sensor_cloud-&gt;header);
-		publish_cloud(groundless_points_pub_, no_ground_cloud_ptr, in_sensor_cloud-&gt;header);
-
-	}
-
-public:
-	RayGroundFilter():node_handle_("~")
-	{
-	}
-	void Run()
-	{
-		//Model   |   Horizontal   |   Vertical   | FOV(Vertical)    degrees / rads
-		//----------------------------------------------------------
-		//HDL-64  |0.08-0.35(0.32) |     0.4      |  -24.9 &lt;=x&lt;=2.0   (26.9  / 0.47)
-		//HDL-32  |     0.1-0.4    |     1.33     |  -30.67&lt;=x&lt;=10.67 (41.33 / 0.72)
-		//VLP-16  |     0.1-0.4    |     2.0      |  -15.0&lt;=x&lt;=15.0   (30    / 0.52)
-		//VLP-16HD|     0.1-0.4    |     1.33     |  -10.0&lt;=x&lt;=10.0   (20    / 0.35)
-		ROS_INFO("Initializing Ground Filter, please wait...");
-		node_handle_.param&lt;std::string&gt;("input_point_topic", input_point_topic_, "/points_raw");
-		ROS_INFO("Input point_topic: %s", input_point_topic_.c_str());
-
-		node_handle_.param("sensor_height", sensor_height_, 1.7);
-		ROS_INFO("sensor_height[meters]: %f", sensor_height_);
-
-		node_handle_.param("general_max_slope", general_max_slope_, 3.0);
-		ROS_INFO("general_max_slope[deg]: %f", general_max_slope_);
-
-		node_handle_.param("local_max_slope", local_max_slope_, 5.0);
-		ROS_INFO("local_max_slope[deg]: %f", local_max_slope_);
-
-		node_handle_.param("radial_divider_angle", radial_divider_angle_, 0.1); //1 degree default
-		ROS_INFO("radial_divider_angle[deg]: %f", radial_divider_angle_);
-		node_handle_.param("concentric_divider_distance", concentric_divider_distance_, 0.01);//0.1 meters default
-		ROS_INFO("concentric_divider_distance[meters]: %f", concentric_divider_distance_);
-		node_handle_.param("min_height_threshold", min_height_threshold_, 0.05);//0.05 meters default
-		ROS_INFO("min_height_threshold[meters]: %f", min_height_threshold_);
-		node_handle_.param("clipping_height", clipping_height_, 0.2);//0.2 meters default above the car
-		ROS_INFO("clipping_height[meters]: %f", clipping_height_);
-		node_handle_.param("min_point_distance", min_point_distance_, 1.85);//1.85 meters default
-		ROS_INFO("min_point_distance[meters]: %f", min_point_distance_);
-		node_handle_.param("reclass_distance_threshold", reclass_distance_threshold_, 0.2);//0.5 meters default
-		ROS_INFO("reclass_distance_threshold[meters]: %f", reclass_distance_threshold_);
+  sensor_height_          = param-&gt;sensor_height;
+  general_max_slope_      = param-&gt;general_max_slope;
+  local_max_slope_        = param-&gt;local_max_slope;
+  radial_divider_angle_   = param-&gt;radial_divider_angle;
+  concentric_divider_distance_ = param-&gt;concentric_divider_distance;
+  min_height_threshold_   = param-&gt;min_height_threshold;
+  clipping_height_        = param-&gt;clipping_height;
+  min_point_distance_     = param-&gt;min_point_distance;
+  reclass_distance_threshold_ = param-&gt;reclass_distance_threshold;
+}
 
+void RayGroundFilter::publish_cloud(const ros::Publisher&amp; in_publisher,
+    const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_cloud_to_publish_ptr,
+    const std_msgs::Header&amp; in_header)
+{
+  sensor_msgs::PointCloud2 cloud_msg;
+  pcl::toROSMsg(*in_cloud_to_publish_ptr, cloud_msg);
+  cloud_msg.header = in_header;
+  in_publisher.publish(cloud_msg);
+}
 
-#if (CV_MAJOR_VERSION == 3)
-		generateColors(colors_, color_num_);
-#else
-		cv::generateColors(colors_, color_num_);
-#endif
+/*!
+ *
+ * @param[in] in_cloud Input Point Cloud to be organized in radial segments
+ * @param[out] out_organized_points Custom Point Cloud filled with XYZRTZColor data
+ * @param[out] out_radial_divided_indices Indices of the points in the original cloud for each radial segment
+ * @param[out] out_radial_ordered_clouds Vector of Points Clouds, each element will contain the points ordered
+ */
+void RayGroundFilter::ConvertXYZIToRTZColor(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_cloud,
+    PointCloudXYZIRTColor&amp; out_organized_points,
+    std::vector&lt;pcl::PointIndices&gt;&amp; out_radial_divided_indices,
+    std::vector&lt;PointCloudXYZIRTColor&gt;&amp; out_radial_ordered_clouds)
+{
+  out_organized_points.resize(in_cloud-&gt;points.size());
+  out_radial_divided_indices.clear();
+  out_radial_divided_indices.resize(radial_dividers_num_);
+  out_radial_ordered_clouds.resize(radial_dividers_num_);
+
+  for(size_t i=0; i&lt; in_cloud-&gt;points.size(); i++)
+  {
+    PointXYZIRTColor new_point;
+    auto radius         = (float) sqrt(
+        in_cloud-&gt;points[i].x*in_cloud-&gt;points[i].x
+        + in_cloud-&gt;points[i].y*in_cloud-&gt;points[i].y
+        );
+    auto theta          = (float) atan2(in_cloud-&gt;points[i].y, in_cloud-&gt;points[i].x) * 180 / M_PI;
+    if (theta &lt; 0){ theta+=360; }
+
+    auto radial_div     = (size_t) floor(theta/radial_divider_angle_);
+    auto concentric_div = (size_t) floor(fabs(radius/concentric_divider_distance_));
+
+    new_point.point    = in_cloud-&gt;points[i];
+    new_point.radius   = radius;
+    new_point.theta    = theta;
+    new_point.radial_div = radial_div;
+    new_point.concentric_div = concentric_div;
+    new_point.red      = (size_t) colors_[new_point.radial_div % color_num_].val[0];
+    new_point.green    = (size_t) colors_[new_point.radial_div % color_num_].val[1];
+    new_point.blue     = (size_t) colors_[new_point.radial_div % color_num_].val[2];
+    new_point.original_index = i;
+
+    out_organized_points[i] = new_point;
+
+    //radial divisions
+    out_radial_divided_indices[radial_div].indices.push_back(i);
+
+    out_radial_ordered_clouds[radial_div].push_back(new_point);
+
+  }//end for
+
+  //order radial points on each division
+#pragma omp for
+  for(size_t i=0; i&lt; radial_dividers_num_; i++)
+  {
+    std::sort(out_radial_ordered_clouds[i].begin(), out_radial_ordered_clouds[i].end(),
+        [](const PointXYZIRTColor&amp; a, const PointXYZIRTColor&amp; b){ return a.radius &lt; b.radius; });
+  }
+}
+
+/*!
+ * Classifies Points in the PointCoud as Ground and Not Ground
+ * @param in_radial_ordered_clouds Vector of an Ordered PointsCloud ordered by radial distance from the origin
+ * @param out_ground_indices Returns the indices of the points classified as ground in the original PointCloud
+ * @param out_no_ground_indices Returns the indices of the points classified as not ground in the original PointCloud
+ */
+void RayGroundFilter::ClassifyPointCloud(std::vector&lt;PointCloudXYZIRTColor&gt;&amp; in_radial_ordered_clouds,
+    pcl::PointIndices&amp; out_ground_indices,
+    pcl::PointIndices&amp; out_no_ground_indices)
+{
+  out_ground_indices.indices.clear();
+  out_no_ground_indices.indices.clear();
+#pragma omp for
+  for (size_t i=0; i &lt; in_radial_ordered_clouds.size(); i++)//sweep through each radial division
+  {
+    float prev_radius = 0.f;
+    float prev_height = - sensor_height_;
+    bool prev_ground = false;
+    bool current_ground = false;
+    for (size_t j=0; j &lt; in_radial_ordered_clouds[i].size(); j++)//loop through each point in the radial div
+    {
+      float points_distance = in_radial_ordered_clouds[i][j].radius - prev_radius;
+      float height_threshold = tan(DEG2RAD(local_max_slope_)) * points_distance;
+      float current_height = in_radial_ordered_clouds[i][j].point.z;
+      float general_height_threshold = tan(DEG2RAD(general_max_slope_)) * in_radial_ordered_clouds[i][j].radius;
+
+      //for points which are very close causing the height threshold to be tiny, set a minimum value
+      if (points_distance &gt; concentric_divider_distance_ &amp;&amp; height_threshold &lt; min_height_threshold_)
+      { height_threshold = min_height_threshold_; }
+
+      //check current point height against the LOCAL threshold (previous point)
+      if (current_height &lt;= (prev_height + height_threshold)
+          &amp;&amp; current_height &gt;= (prev_height - height_threshold)
+         )
+      {
+        //Check again using general geometry (radius from origin) if previous points wasn't ground
+        if (!prev_ground)
+        {
+          if(current_height &lt;= (-sensor_height_ + general_height_threshold)
+              &amp;&amp; current_height &gt;= (-sensor_height_ - general_height_threshold))
+          {
+            current_ground = true;
+          }
+          else
+          {current_ground = false;}
+        }
+        else
+        {
+          current_ground = true;
+        }
+      }
+      else
+      {
+        //check if previous point is too far from previous one, if so classify again
+        if (points_distance &gt; reclass_distance_threshold_ &amp;&amp;
+            (current_height &lt;= (-sensor_height_ + height_threshold)
+             &amp;&amp; current_height &gt;= (-sensor_height_ - height_threshold))
+           )
+        {
+          current_ground = true;
+        }
+        else
+        {current_ground = false;}
+      }
+
+      if (current_ground)
+      {
+        out_ground_indices.indices.push_back(in_radial_ordered_clouds[i][j].original_index);
+        prev_ground=true;
+      }
+      else
+      {
+        out_no_ground_indices.indices.push_back(in_radial_ordered_clouds[i][j].original_index);
+        prev_ground = false;
+      }
+
+      prev_radius = in_radial_ordered_clouds[i][j].radius;
+      prev_height = in_radial_ordered_clouds[i][j].point.z;
+    }
+  }
+}
+
+/*!
+ * Removes the points higher than a threshold
+ * @param in_cloud_ptr PointCloud to perform Clipping
+ * @param in_clip_height Maximum allowed height in the cloud
+ * @param out_clipped_cloud_ptr Resultung PointCloud with the points removed
+ */
+void RayGroundFilter::ClipCloud(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_cloud_ptr,
+    double in_clip_height,
+    pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr out_clipped_cloud_ptr)
+{
+  pcl::ExtractIndices&lt;pcl::PointXYZI&gt; extractor;
+  extractor.setInputCloud (in_cloud_ptr);
+  pcl::PointIndices indices;
+
+#pragma omp for
+  for (size_t i=0; i&lt; in_cloud_ptr-&gt;points.size(); i++)
+  {
+    if (in_cloud_ptr-&gt;points[i].z &gt; in_clip_height)
+    {
+      indices.indices.push_back(i);
+    }
+  }
+  extractor.setIndices(boost::make_shared&lt;pcl::PointIndices&gt;(indices));
+  extractor.setNegative(true);//true removes the indices, false leaves only the indices
+  extractor.filter(*out_clipped_cloud_ptr);
+}
+
+/*!
+ * Returns the resulting complementary PointCloud, one with the points kept and the other removed as indicated
+ * in the indices
+ * @param in_cloud_ptr Input PointCloud to which the extraction will be performed
+ * @param in_indices Indices of the points to be both removed and kept
+ * @param out_only_indices_cloud_ptr Resulting PointCloud with the indices kept
+ * @param out_removed_indices_cloud_ptr Resulting PointCloud with the indices removed
+ */
+void RayGroundFilter::ExtractPointsIndices(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_cloud_ptr,
+    const pcl::PointIndices&amp; in_indices,
+    pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr out_only_indices_cloud_ptr,
+    pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr out_removed_indices_cloud_ptr)
+{
+  pcl::ExtractIndices&lt;pcl::PointXYZI&gt; extract_ground;
+  extract_ground.setInputCloud (in_cloud_ptr);
+  extract_ground.setIndices(boost::make_shared&lt;pcl::PointIndices&gt;(in_indices));
+
+  extract_ground.setNegative(false);//true removes the indices, false leaves only the indices
+  extract_ground.filter(*out_only_indices_cloud_ptr);
+
+  extract_ground.setNegative(true);//true removes the indices, false leaves only the indices
+  extract_ground.filter(*out_removed_indices_cloud_ptr);
+}
+
+/*!
+ * Removes points up to a certain distance in the XY Plane
+ * @param in_cloud_ptr Input PointCloud
+ * @param in_min_distance Minimum valid distance, points closer than this will be removed.
+ * @param out_filtered_cloud_ptr Resulting PointCloud with the invalid points removed.
+ */
+void RayGroundFilter::RemovePointsUpTo(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_cloud_ptr,
+    double in_min_distance,
+    pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr out_filtered_cloud_ptr)
+{
+  pcl::ExtractIndices&lt;pcl::PointXYZI&gt; extractor;
+  extractor.setInputCloud (in_cloud_ptr);
+  pcl::PointIndices indices;
+
+#pragma omp for
+  for (size_t i=0; i&lt; in_cloud_ptr-&gt;points.size(); i++)
+  {
+    if (sqrt(in_cloud_ptr-&gt;points[i].x*in_cloud_ptr-&gt;points[i].x +
+          in_cloud_ptr-&gt;points[i].y*in_cloud_ptr-&gt;points[i].y)
+        &lt; in_min_distance)
+    {
+      indices.indices.push_back(i);
+    }
+  }
+  extractor.setIndices(boost::make_shared&lt;pcl::PointIndices&gt;(indices));
+  extractor.setNegative(true);//true removes the indices, false leaves only the indices
+  extractor.filter(*out_filtered_cloud_ptr);
+}
+
+void RayGroundFilter::CloudCallback(const sensor_msgs::PointCloud2ConstPtr &amp;in_sensor_cloud)
+{
+  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr current_sensor_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
+  pcl::fromROSMsg(*in_sensor_cloud, *current_sensor_cloud_ptr);
+
+  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr clipped_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
+
+  //remove points above certain point
+  ClipCloud(current_sensor_cloud_ptr, clipping_height_, clipped_cloud_ptr);
+
+  //remove closer points than a threshold
+  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
+  RemovePointsUpTo(clipped_cloud_ptr, min_point_distance_,filtered_cloud_ptr);
 
-		radial_dividers_num_ = ceil(360 / radial_divider_angle_);
-		ROS_INFO("Radial Divisions: %d", (int)radial_dividers_num_);
+  //GetCloud Normals
+  //pcl::PointCloud&lt;pcl::PointXYZINormal&gt;::Ptr cloud_with_normals_ptr (new pcl::PointCloud&lt;pcl::PointXYZINormal&gt;);
+  //GetCloudNormals(current_sensor_cloud_ptr, cloud_with_normals_ptr, 5.0);
 
-		std::string no_ground_topic, ground_topic;
-		node_handle_.param&lt;std::string&gt;("no_ground_point_topic", no_ground_topic, "/points_no_ground");
-		ROS_INFO("No Ground Output Point Cloud no_ground_point_topic: %s", no_ground_topic.c_str());
-		node_handle_.param&lt;std::string&gt;("ground_point_topic", ground_topic, "/points_ground");
-		ROS_INFO("Only Ground Output Point Cloud ground_topic: %s", ground_topic.c_str());
+  PointCloudXYZIRTColor organized_points;
+  std::vector&lt;pcl::PointIndices&gt; radial_division_indices;
+  std::vector&lt;pcl::PointIndices&gt; closest_indices;
+  std::vector&lt;PointCloudXYZIRTColor&gt; radial_ordered_clouds;
 
-		ROS_INFO("Subscribing to... %s", input_point_topic_.c_str());
-		points_node_sub_ = node_handle_.subscribe(input_point_topic_, 1, &amp;RayGroundFilter::CloudCallback, this);
+  radial_dividers_num_ = ceil(360 / radial_divider_angle_);
 
-		config_node_sub_ = node_handle_.subscribe("/config/ray_ground_filter", 1, &amp;RayGroundFilter::update_config_params, this);
+  ConvertXYZIToRTZColor(filtered_cloud_ptr,
+      organized_points,
+      radial_division_indices,
+      radial_ordered_clouds);
 
-		groundless_points_pub_ = node_handle_.advertise&lt;sensor_msgs::PointCloud2&gt;(no_ground_topic, 2);
-		ground_points_pub_ = node_handle_.advertise&lt;sensor_msgs::PointCloud2&gt;(ground_topic, 2);
+  pcl::PointIndices ground_indices, no_ground_indices;
 
-		ROS_INFO("Ready");
+  ClassifyPointCloud(radial_ordered_clouds, ground_indices, no_ground_indices);
 
-		ros::spin();
+  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr ground_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
+  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr no_ground_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
 
-	}
+  ExtractPointsIndices(filtered_cloud_ptr, ground_indices, ground_cloud_ptr, no_ground_cloud_ptr);
 
-};
+  publish_cloud(ground_points_pub_, ground_cloud_ptr, in_sensor_cloud-&gt;header);
+  publish_cloud(groundless_points_pub_, no_ground_cloud_ptr, in_sensor_cloud-&gt;header);
+
+}
+
+RayGroundFilter::RayGroundFilter():node_handle_("~")
+{
+}
 
-int main(int argc, char **argv)
+void RayGroundFilter::Run()
 {
-	ros::init(argc, argv, "ray_ground_filter");
-	RayGroundFilter app;
+  //Model   |   Horizontal   |   Vertical   | FOV(Vertical)    degrees / rads
+  //----------------------------------------------------------
+  //HDL-64  |0.08-0.35(0.32) |     0.4      |  -24.9 &lt;=x&lt;=2.0   (26.9  / 0.47)
+  //HDL-32  |     0.1-0.4    |     1.33     |  -30.67&lt;=x&lt;=10.67 (41.33 / 0.72)
+  //VLP-16  |     0.1-0.4    |     2.0      |  -15.0&lt;=x&lt;=15.0   (30    / 0.52)
+  //VLP-16HD|     0.1-0.4    |     1.33     |  -10.0&lt;=x&lt;=10.0   (20    / 0.35)
+  ROS_INFO("Initializing Ground Filter, please wait...");
+  node_handle_.param&lt;std::string&gt;("input_point_topic", input_point_topic_, "/points_raw");
+  ROS_INFO("Input point_topic: %s", input_point_topic_.c_str());
+
+  node_handle_.param("sensor_height", sensor_height_, 1.7);
+  ROS_INFO("sensor_height[meters]: %f", sensor_height_);
+
+  node_handle_.param("general_max_slope", general_max_slope_, 3.0);
+  ROS_INFO("general_max_slope[deg]: %f", general_max_slope_);
+
+  node_handle_.param("local_max_slope", local_max_slope_, 5.0);
+  ROS_INFO("local_max_slope[deg]: %f", local_max_slope_);
+
+  node_handle_.param("radial_divider_angle", radial_divider_angle_, 0.1); //1 degree default
+  ROS_INFO("radial_divider_angle[deg]: %f", radial_divider_angle_);
+  node_handle_.param("concentric_divider_distance", concentric_divider_distance_, 0.01);//0.1 meters default
+  ROS_INFO("concentric_divider_distance[meters]: %f", concentric_divider_distance_);
+  node_handle_.param("min_height_threshold", min_height_threshold_, 0.05);//0.05 meters default
+  ROS_INFO("min_height_threshold[meters]: %f", min_height_threshold_);
+  node_handle_.param("clipping_height", clipping_height_, 0.2);//0.2 meters default above the car
+  ROS_INFO("clipping_height[meters]: %f", clipping_height_);
+  node_handle_.param("min_point_distance", min_point_distance_, 1.85);//1.85 meters default
+  ROS_INFO("min_point_distance[meters]: %f", min_point_distance_);
+  node_handle_.param("reclass_distance_threshold", reclass_distance_threshold_, 0.2);//0.5 meters default
+  ROS_INFO("reclass_distance_threshold[meters]: %f", reclass_distance_threshold_);
 
-	app.Run();
 
-	return 0;
+#if (CV_MAJOR_VERSION == 3)
+  generateColors(colors_, color_num_);
+#else
+  cv::generateColors(colors_, color_num_);
+#endif
+
+  radial_dividers_num_ = ceil(360 / radial_divider_angle_);
+  ROS_INFO("Radial Divisions: %d", (int)radial_dividers_num_);
+
+  std::string no_ground_topic, ground_topic;
+  node_handle_.param&lt;std::string&gt;("no_ground_point_topic", no_ground_topic, "/points_no_ground");
+  ROS_INFO("No Ground Output Point Cloud no_ground_point_topic: %s", no_ground_topic.c_str());
+  node_handle_.param&lt;std::string&gt;("ground_point_topic", ground_topic, "/points_ground");
+  ROS_INFO("Only Ground Output Point Cloud ground_topic: %s", ground_topic.c_str());
+
+  ROS_INFO("Subscribing to... %s", input_point_topic_.c_str());
+  points_node_sub_ = node_handle_.subscribe(input_point_topic_, 1, &amp;RayGroundFilter::CloudCallback, this);
+
+  config_node_sub_ = node_handle_.subscribe("/config/ray_ground_filter", 1, &amp;RayGroundFilter::update_config_params, this);
+
+  groundless_points_pub_ = node_handle_.advertise&lt;sensor_msgs::PointCloud2&gt;(no_ground_topic, 2);
+  ground_points_pub_ = node_handle_.advertise&lt;sensor_msgs::PointCloud2&gt;(ground_topic, 2);
+
+  ROS_INFO("Ready");
+
+  ros::spin();
 
 }
+
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5e3685262efa92e8f7de17edd4ba6058469b219b" author="Yusuke FUJII">
		<msg>fix a moving state</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="6" deleted_lines="2">
				<diff>@@ -30,12 +30,14 @@ namespace decision_maker
 {
 void DecisionMakerNode::initROS(int argc, char **argv)
 {
+  ctx-&gt;setCurrentState(state_machine::INITIAL_STATE);
+
   // status subscriber
   Subs["sim_pose"] = nh_.subscribe("sim_pose", 20, &amp;DecisionMakerNode::callbackFromSimPose, this);
   Subs["current_pose"] = nh_.subscribe("current_pose", 20, &amp;DecisionMakerNode::callbackFromCurrentPose, this);
   Subs["current_velocity"] =
       nh_.subscribe("current_velocity", 20, &amp;DecisionMakerNode::callbackFromCurrentVelocity, this);
-  // Subs["light_color"] = nh_.subscribe("light_color", 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
+  Subs["light_color"] = nh_.subscribe("light_color", 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
   Subs["light_color_managed"] =
       nh_.subscribe("light_color_managed", 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
   Subs["points_raw"] = nh_.subscribe("filtered_points", 1, &amp;DecisionMakerNode::callbackFromPointsRaw, this);
@@ -56,7 +58,7 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   Pubs["state"] = nh_.advertise&lt;std_msgs::String&gt;("state", 1);
   Pubs["lane_waypoints_array"] = nh_.advertise&lt;autoware_msgs::LaneArray&gt;(TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY, 10, true);
   Pubs["states"] = nh_.advertise&lt;autoware_msgs::state&gt;("/decisionmaker/states", 1, true);
-  Pubs["light_color"] = nh_.advertise&lt;autoware_msgs::traffic_light&gt;("/light_color", 1);
+ //Pubs["light_color"] = nh_.advertise&lt;autoware_msgs::traffic_light&gt;("/light_color", 1);
 
   // for controlling vehicle
   Pubs["lamp_cmd"] = nh_.advertise&lt;autoware_msgs::lamp_cmd&gt;("/lamp_cmd", 1);
@@ -110,6 +112,8 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   }
 
   ROS_INFO("Initialized OUT\n");
+  ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
+  
   Subs["lane_waypoints_array"] =
       nh_.subscribe(TPNAME_BASED_LANE_WAYPOINTS_ARRAY, 100, &amp;DecisionMakerNode::callbackFromLaneWaypoint, this);
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -75,7 +75,7 @@ void DecisionMakerNode::publishLightColor(int status)
 {
   autoware_msgs::traffic_light msg;
   msg.traffic_light = status;
-  Pubs["light_color"].publish(msg);
+  //Pubs["light_color"].publish(msg);
 }
 
 #define SHIFTED_LANE_FLAG -99999
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="6a25fa9007ba529637c66fe5bff8d7a8fa9d5835" author="Abraham Monrroy">
		<msg>Added support to Image Publisher for frames different than only "velodyne". (#946)</msg>
		<modified_files>
			<file old_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_publisher\calibration_publisher.cpp" new_path="ros\src\sensing\fusion\packages\calibration_camera_lidar\nodes\calibration_publisher\calibration_publisher.cpp" added_lines="6" deleted_lines="3">
				<diff>@@ -21,6 +21,7 @@ static bool isPublish_extrinsic;
 static bool isPublish_cameraInfo;
 
 static std::string camera_id_str;
+static std::string target_frame_;
 
 void tfRegistration (const cv::Mat &amp;camExtMat, const ros::Time&amp; timeStamp)
 {
@@ -44,8 +45,7 @@ void tfRegistration (const cv::Mat &amp;camExtMat, const ros::Time&amp; timeStamp)
 
   transform.setRotation(quaternion);
 
-  broadcaster.sendTransform(tf::StampedTransform(transform, timeStamp, "velodyne", camera_id_str));
-  //broadcaster.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "velodyne", "camera"));
+  broadcaster.sendTransform(tf::StampedTransform(transform, timeStamp, target_frame_, camera_id_str));
 }
 
 void projectionMatrix_sender(const cv::Mat  &amp;projMat, const ros::Time&amp; timeStamp)
@@ -143,9 +143,12 @@ int main(int argc, char* argv[])
   }
 
   if (!private_nh.getParam("publish_camera_info", isPublish_cameraInfo)) {
-    isPublish_extrinsic = false; /* doesn't publish camera_info in default */
+    isPublish_cameraInfo = false; /* doesn't publish camera_info in default */
   }
 
+  private_nh.param&lt;std::string&gt;("target_frame", target_frame_, "velodyne");
+  ROS_INFO("target_frame: %s", target_frame_.c_str());
+
   if (argc &lt; 2)
     {
       std::cout &lt;&lt; "Usage: calibration_publisher &lt;calibration-file&gt;." &lt;&lt; std::endl;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7923632d7f548d6235dc679af83a52e4b3215cef" author="Yusuke FUJII">
		<msg>add support to manual fixing light</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="3" deleted_lines="0">
				<diff>@@ -107,6 +107,8 @@ private:
   std::vector&lt;CrossRoadArea&gt; intersects;
   double displacement_from_path_;
 
+  bool isManualLight;
+
   // Param
   bool enableDisplayMarker;
   bool enableForceStateChange;
@@ -225,6 +227,7 @@ public:
 
     ClosestArea_ = nullptr;
     displacement_from_path_ = 0.0;
+    isManualLight = false;
   }
 
   void run(void);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="25" deleted_lines="12">
				<diff>@@ -36,12 +36,21 @@ bool DecisionMakerNode::handleStateCmd(const uint64_t _state_num)
   if (!ctx-&gt;isCurrentState(_state_num))
   {
     _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
+    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 
+		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFIC_LIGHT_GREEN_STATE){
+	    isManualLight = true;
+    }
   }
   else
   {
     _ret = ctx-&gt;disableCurrentState((state_machine::StateFlags)_state_num);
+    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 
+		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFIC_LIGHT_GREEN_STATE){
+	    isManualLight = false;
   }
   ctx-&gt;setEnableForceSetState(false);
+
+
   return _ret;
 }
 
@@ -89,19 +98,23 @@ void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMa
 }
 
 void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
-{
+{    
   const autoware_msgs::traffic_light *light = event.getMessage().get();
-
-  current_traffic_light_ = light-&gt;traffic_light;
-  if (current_traffic_light_ == state_machine::E_RED || current_traffic_light_ == state_machine::E_YELLOW)
-  {
-    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
-    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
-  }
-  else
-  {
-    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
-    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
+//  const ros::M_string &amp;header = event.getConnectionHeader();
+//  std::string topic = header.at("topic"); 
+  
+  if(!isManualLight){// &amp;&amp; topic.find("manage") == std::string::npos){
+	  current_traffic_light_ = light-&gt;traffic_light;
+	  if (current_traffic_light_ == state_machine::E_RED || current_traffic_light_ == state_machine::E_YELLOW)
+	  {
+		  ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
+		  ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
+	  }
+	  else
+	  {
+		  ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
+		  ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
+	  }
   }
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -38,8 +38,8 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   Subs["current_velocity"] =
       nh_.subscribe("current_velocity", 20, &amp;DecisionMakerNode::callbackFromCurrentVelocity, this);
   Subs["light_color"] = nh_.subscribe("light_color", 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
-  Subs["light_color_managed"] =
-      nh_.subscribe("light_color_managed", 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
+//  Subs["light_color_managed"] =
+  //    nh_.subscribe("light_color_managed", 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
   Subs["points_raw"] = nh_.subscribe("filtered_points", 1, &amp;DecisionMakerNode::callbackFromPointsRaw, this);
   Subs["final_waypoints"] = nh_.subscribe("final_waypoints", 100, &amp;DecisionMakerNode::callbackFromFinalWaypoint, this);
   Subs["twist_cmd"] = nh_.subscribe("twist_cmd", 10, &amp;DecisionMakerNode::callbackFromTwistCmd, this);
@@ -58,7 +58,7 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   Pubs["state"] = nh_.advertise&lt;std_msgs::String&gt;("state", 1);
   Pubs["lane_waypoints_array"] = nh_.advertise&lt;autoware_msgs::LaneArray&gt;(TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY, 10, true);
   Pubs["states"] = nh_.advertise&lt;autoware_msgs::state&gt;("/decisionmaker/states", 1, true);
- //Pubs["light_color"] = nh_.advertise&lt;autoware_msgs::traffic_light&gt;("/light_color", 1);
+  Pubs["light_color"] = nh_.advertise&lt;autoware_msgs::traffic_light&gt;("/light_color_managed", 1);
 
   // for controlling vehicle
   Pubs["lamp_cmd"] = nh_.advertise&lt;autoware_msgs::lamp_cmd&gt;("/lamp_cmd", 1);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="2" deleted_lines="1">
				<diff>@@ -60,6 +60,7 @@ void DecisionMakerNode::setupStateCallback(void)
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                          [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE); });
 
+
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
                              std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_RED));
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
@@ -75,7 +76,7 @@ void DecisionMakerNode::publishLightColor(int status)
 {
   autoware_msgs::traffic_light msg;
   msg.traffic_light = status;
-  //Pubs["light_color"].publish(msg);
+  Pubs["light_color"].publish(msg);
 }
 
 #define SHIFTED_LANE_FLAG -99999
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8c02a6e90c9e0c661d1e0bbd0cfcec527ab45d9d" author="Yusuke FUJII">
		<msg>fix a state num name</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -36,8 +36,8 @@ bool DecisionMakerNode::handleStateCmd(const uint64_t _state_num)
   if (!ctx-&gt;isCurrentState(_state_num))
   {
     _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
-    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 
-		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFIC_LIGHT_GREEN_STATE){
+    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHTRED_STATE 
+		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE){
 	    isManualLight = true;
     }
   }
@@ -45,7 +45,7 @@ bool DecisionMakerNode::handleStateCmd(const uint64_t _state_num)
   {
     _ret = ctx-&gt;disableCurrentState((state_machine::StateFlags)_state_num);
     if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 
-		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFIC_LIGHT_GREEN_STATE){
+		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE){
 	    isManualLight = false;
   }
   ctx-&gt;setEnableForceSetState(false);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="2f542e4f87ebabc3950b80e56c94aa95751dc4c0" author="Yusuke FUJII">
		<msg>fix a state num name</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -36,7 +36,7 @@ bool DecisionMakerNode::handleStateCmd(const uint64_t _state_num)
   if (!ctx-&gt;isCurrentState(_state_num))
   {
     _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
-    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHTRED_STATE 
+    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 
 		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE){
 	    isManualLight = true;
     }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b0ed94357601dcc06e14a43cb8f17b9d51dc84db" author="Yusuke FUJII">
		<msg>fix a build bug</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="2" deleted_lines="0">
				<diff>@@ -40,6 +40,7 @@ bool DecisionMakerNode::handleStateCmd(const uint64_t _state_num)
 		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE){
 	    isManualLight = true;
     }
+    }
   }
   else
   {
@@ -47,6 +48,7 @@ bool DecisionMakerNode::handleStateCmd(const uint64_t _state_num)
     if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 
 		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE){
 	    isManualLight = false;
+    }
   }
   ctx-&gt;setEnableForceSetState(false);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="7193d8e883e95a16e6a27a89b0f87a676fbfdb12" author="Yusuke FUJII">
		<msg>fix a build bug</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -40,7 +40,6 @@ bool DecisionMakerNode::handleStateCmd(const uint64_t _state_num)
 		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE){
 	    isManualLight = true;
     }
-    }
   }
   else
   {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="79d3dcaf8a4f56acbcdaa74e75768543dcba6d65" author="Yusuke FUJII">
		<msg>add new state for all stopline pause</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" added_lines="1" deleted_lines="0">
				<diff>@@ -57,6 +57,7 @@ public:
     StateStores[DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE] = DriveBehaviorTrafficLightRedState::getInstance();
     StateStores[DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE] = DriveBehaviorTrafficLightGreenState::getInstance();
     StateStores[DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE] = DriveBehaviorObstacleAvoidanceState::getInstance();
+    StateStores[DRIVE_BEHAVIOR_STOPLINE_PLAN_STATE] = DriveBehaviorStoplinePlanState::getInstance();
     StateStores[MISSION_COMPLETE_STATE] = MissionCompleteState::getInstance();
     StateStores[EMERGENCY_STATE] = EmergencyState::getInstance();
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" added_lines="14" deleted_lines="0">
				<diff>@@ -224,6 +224,20 @@ private:
     StateKind = BEHAVIOR_STATE;
   }
 
+public:
+};
+
+class DriveBehaviorStoplinePlanState : public State&lt;DriveBehaviorStoplinePlanState&gt;
+{
+private:
+  friend class State&lt;DriveBehaviorStoplinePlanState&gt;;
+  DriveBehaviorStoplinePlanState(void)
+  {
+    StateName = "STOPLINE_PLAN";
+    StateNum = DRIVE_BEHAVIOR_STOPLINE_PLAN_STATE;
+    StateKind = BEHAVIOR_STATE;
+  }
+
 public:
 };
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" added_lines="1" deleted_lines="0">
				<diff>@@ -31,6 +31,7 @@ enum StateFlags
   DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE = 1ULL &lt;&lt; 33,
   DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE = 1ULL &lt;&lt; 34,
   DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE = 1ULL &lt;&lt; 35,
+  DRIVE_BEHAVIOR_STOPLINE_PLAN_STATE = 1ULL &lt;&lt; 36,
   STATE_SUB_END = 1ULL &lt;&lt; 40,
   STATE_END = 1ULL &lt;&lt; 41,
 };
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="14" deleted_lines="0">
				<diff>@@ -38,6 +38,7 @@ namespace decision_maker
 {
 using namespace vector_map;
 
+
 enum class EControl : int32_t
 {
   KEEP = -1,
@@ -173,6 +174,10 @@ private:
   void changeShiftLane(void);
   void removeShiftLane(void);
 
+
+  void setAllStoplineStop(void);
+  void StoplinePlanIn(int status);
+  void StoplinePlanOut(int status);
   void publishLightColor(int status);
   void callbackInStateObstacleAvoid(int status);
   void callbackOutStateObstacleAvoid(int status);
@@ -231,6 +236,15 @@ public:
   }
 
   void run(void);
+  geometry_msgs::Point to_geoPoint(const vector_map_msgs::Point &amp;vp)
+  {
+	  geometry_msgs::Point gp;
+	  gp.x = vp.ly;
+	  gp.y = vp.bx;
+	  gp.z = vp.h;
+	  return gp;
+  }
+
 };
 
 }  // namespace decision_maker
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="0" deleted_lines="9">
				<diff>@@ -158,15 +158,6 @@ void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadAr
   }
 }
 
-geometry_msgs::Point to_geoPoint(const vector_map_msgs::Point &amp;vp)
-{
-  geometry_msgs::Point gp;
-  gp.x = vp.ly;
-  gp.y = vp.bx;
-  gp.z = vp.h;
-  return gp;
-}
-
 void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
 {
   insertPointWithinCrossRoad(intersects, lane_array);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="49" deleted_lines="0">
				<diff>@@ -30,6 +30,10 @@ void DecisionMakerNode::setupStateCallback(void)
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOP_STATE,
                          std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 0));
 
+  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_STOPLINE_PLAN_STATE,
+                         std::bind(&amp;DecisionMakerNode::StoplinePlanIn, this, 1));
+  ctx-&gt;setCallbackOutFunc(state_machine::DRIVE_BEHAVIOR_STOPLINE_PLAN_STATE,
+                         std::bind(&amp;DecisionMakerNode::StoplinePlanOut, this, 1));
   // speed keep(original speed) state
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_KEEP_STATE,
                          std::bind(&amp;DecisionMakerNode::callbackInStateKeep, this, 1));
@@ -182,6 +186,51 @@ void DecisionMakerNode::changeVelocityBasedLane(void)
   current_controlled_lane_array_ = current_shifted_lane_array_;
 }
 
+void DecisionMakerNode::setAllStoplineStop(void){
+  
+  std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([&amp;](const StopLine &amp;stopline) {
+    return true;
+  });
+
+  for (auto &amp;lane : current_controlled_lane_array_.lanes)
+  {
+    for (size_t wp_idx = 0; wp_idx &lt; lane.waypoints.size() - 1; wp_idx++)
+    {
+      for (auto &amp;stopline : stoplines)
+      {
+        geometry_msgs::Point bp =
+            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).bpid)));
+        geometry_msgs::Point fp =
+            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).fpid)));
+
+        if (amathutils::isIntersectLine(lane.waypoints.at(wp_idx).pose.pose.position.x,
+                                        lane.waypoints.at(wp_idx).pose.pose.position.y,
+                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
+                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.y, bp.x, bp.y, fp.x, fp.y))
+        {
+          geometry_msgs::Point center_point;
+          center_point.x = (bp.x * 2 + fp.x) / 3;
+          center_point.y = (bp.y * 2 + fp.y) / 3;
+          if (amathutils::isPointLeftFromLine(
+                  center_point.x, center_point.y, lane.waypoints.at(wp_idx).pose.pose.position.x,
+                  lane.waypoints.at(wp_idx).pose.pose.position.y, lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
+                  lane.waypoints.at(wp_idx + 1).pose.pose.position.y))
+          {
+            lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
+          }
+        }
+      }
+    }
+  }
+}
+
+void DecisionMakerNode::StoplinePlanIn(int status){
+	setAllStoplineStop();
+}
+void DecisionMakerNode::StoplinePlanOut(int status){
+	current_controlled_lane_array_ = current_based_lane_array_;
+}
+
 void DecisionMakerNode::changeVelocityLane(int dir)
 {
   if (dir != 0)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="92d8c5491276b9be65ac480f53c535be49452bd3" author="Yusuke FUJII">
		<msg>fix a judge intersect stopline</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="14" deleted_lines="3">
				<diff>@@ -192,7 +192,7 @@ void DecisionMakerNode::setAllStoplineStop(void){
     return true;
   });
 
-  for (auto &amp;lane : current_controlled_lane_array_.lanes)
+  for (auto &amp;lane : current_shifted_lane_array_.lanes)
   {
     for (size_t wp_idx = 0; wp_idx &lt; lane.waypoints.size() - 1; wp_idx++)
     {
@@ -216,7 +216,14 @@ void DecisionMakerNode::setAllStoplineStop(void){
                   lane.waypoints.at(wp_idx).pose.pose.position.y, lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                   lane.waypoints.at(wp_idx + 1).pose.pose.position.y))
           {
-            lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
+		  amathutils::point *a = new amathutils::point();
+		  amathutils::point *b = new amathutils::point();
+		  a-&gt;x = center_point.x;
+		  a-&gt;y = center_point.y;
+		  b-&gt;x = lane.waypoints.at(wp_idx).pose.pose.position.x;
+		  b-&gt;y = lane.waypoints.at(wp_idx).pose.pose.position.y;
+		  if(amathutils::find_distance(a,b) &lt;= 4)//
+			  lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
           }
         }
       }
@@ -226,9 +233,13 @@ void DecisionMakerNode::setAllStoplineStop(void){
 
 void DecisionMakerNode::StoplinePlanIn(int status){
 	setAllStoplineStop();
+	changeVelocityBasedLane();
+	publishControlledLaneArray();
 }
 void DecisionMakerNode::StoplinePlanOut(int status){
-	current_controlled_lane_array_ = current_based_lane_array_;
+	current_shifted_lane_array_ = current_based_lane_array_;
+	changeVelocityBasedLane();
+	publishControlledLaneArray();
 }
 
 void DecisionMakerNode::changeVelocityLane(int dir)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9276386def9de554026a4a8665881bcbcb0843da" author="Yamato ANDO">
		<msg>Support for multi cameras in pbj_reproj node</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\obj_reproj\obj_reproj.cpp" new_path="ros\src\computing\perception\detection\packages\cv_tracker\nodes\obj_reproj\obj_reproj.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -387,11 +387,11 @@ int main(int argc, char **argv){
   std::string projectionMat_topic_name;
   private_nh.param&lt;std::string&gt;("projection_matrix_topic", projectionMat_topic_name, "/projection_matrix");
   std::string camera_info_topic_name;
-  private_nh.param&lt;std::string&gt;("camera_info_topic", camera_info_topic_name, "/camera/camera_info");
+  private_nh.param&lt;std::string&gt;("camera_info_topic", camera_info_topic_name, "/camera_info");
 
   //get camera ID
   camera_id_str = camera_info_topic_name;
-  camera_id_str.erase(camera_id_str.find("/camera/camera_info"));
+  camera_id_str.erase(camera_id_str.find("/camera_info"));
   if (camera_id_str == "/") {
     camera_id_str = "camera";
   }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="09cef86bf432f1a3dd530a27d56bd4c2e47b1272" author="AMC">
		<msg>Initial modifications to feat_proj, tlr, context and vector_map loader, server and client to support different types of traffic signals</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\include\Context.h" new_path="ros\src\computing\perception\detection\packages\road_wizard\include\Context.h" added_lines="32" deleted_lines="21">
				<diff>@@ -5,33 +5,44 @@
 #include &lt;opencv2/core/core.hpp&gt;
 #include &lt;autoware_msgs/Signals.h&gt;
 
-enum LightState { GREEN, YELLOW, RED, UNDEFINED };
+enum LightState
+{
+	GREEN, YELLOW, RED, UNDEFINED
+};
+
 
-class Context {
+class Context
+{
 public:
-	Context(){};
+	Context()
+	{
+	};
+
 	Context(cv::Point aRedCenter, cv::Point aYellowCenter, cv::Point aGreenCenter,
-		int aLampRadius, cv::Point aTopLeft, cv::Point aBotRight);
-        static void SetContexts(std::vector&lt;Context&gt; &amp;contexts, 
-                                const autoware_msgs::Signals::ConstPtr &amp;extracted_pos,
-                                const int frame_row,
-                                const int frame_colmuns);
-
-	cv::Point redCenter;
-	cv::Point yellowCenter;
-	cv::Point greenCenter;
+	        int aLampRadius, cv::Point aTopLeft, cv::Point aBotRight);
+
+	static void SetContexts(std::vector&lt;Context&gt; &amp;out_contexts,
+	                        const autoware_msgs::Signals::ConstPtr &amp;in_extracted_pos,
+	                        const int in_image_height,
+	                        const int in_image_width);
+
+	cv::Point   redCenter;
+	cv::Point   yellowCenter;
+	cv::Point   greenCenter;
 	cv::Point3d redCenter3d;
 	cv::Point3d yellowCenter3d;
 	cv::Point3d greenCenter3d;
-	int lampRadius;
-	cv::Point topLeft;
-	cv::Point botRight;
-	LightState lightState;
-	int signalID;
-	int stateJudgeCount;
-
- private:
-        static bool CompareContext(const Context left, const Context right);
+	int         lampRadius;
+	cv::Point   topLeft;
+	cv::Point   botRight;
+	LightState  lightState;
+	int         signalID;
+	int         stateJudgeCount;
+	bool        leftTurnSignal;
+	bool        rightTurnSignal;
+	int         closestLaneId;
+private:
+	static bool CompareContext(const Context in_context_a, const Context in_context_b);
 };
 
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\lib\Context.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\lib\Context.cpp" added_lines="159" deleted_lines="123">
				<diff>@@ -1,7 +1,7 @@
 #include "Context.h"
 
 Context::Context(cv::Point aRedCenter, cv::Point aYellowCenter, cv::Point aGreenCenter,
-		 int aLampRadius, cv::Point aTopLeft, cv::Point aBotRight)
+                 int aLampRadius, cv::Point aTopLeft, cv::Point aBotRight)
 {
 	redCenter = aRedCenter;
 	yellowCenter = aYellowCenter;
@@ -9,136 +9,172 @@ Context::Context(cv::Point aRedCenter, cv::Point aYellowCenter, cv::Point aGreen
 	lampRadius = aLampRadius;
 	topLeft = aTopLeft;
 	botRight = aBotRight;
+	leftTurnSignal = false;
+	rightTurnSignal = false;
+	closestLaneId = -1;
 }
 
-
 /*
   define magnitude relationship of context
  */
-bool Context::CompareContext(const Context left, const Context right)
+bool Context::CompareContext(const Context in_context_a, const Context in_context_b)
 {
-  /* if lampRadius is bigger, context is smaller */
-  return left.lampRadius &gt;= right.lampRadius;
+	/* if lampRadius is bigger, context is smaller */
+	return in_context_a.lampRadius &gt;= in_context_b.lampRadius;
 } /* static bool compareContext() */
 
 
-void Context::SetContexts(std::vector&lt;Context&gt; &amp;contexts,
-                          const autoware_msgs::Signals::ConstPtr &amp;extracted_pos,
-                          const int frame_row,
-                          const int frame_column) {
-  /* copy parts of data to local variable */
-  std::vector&lt;autoware_msgs::ExtractedPosition&gt; signals;
-  std::vector&lt;autoware_msgs::ExtractedPosition&gt;::iterator sig_iterator;
-  for (unsigned int i=0; i&lt;extracted_pos-&gt;Signals.size(); i++ )
-    {
-      autoware_msgs::ExtractedPosition tmp;
-      tmp.signalId = extracted_pos-&gt;Signals.at(i).signalId;
-      tmp.u        = extracted_pos-&gt;Signals.at(i).u;
-      tmp.v        = extracted_pos-&gt;Signals.at(i).v;
-      tmp.radius   = extracted_pos-&gt;Signals.at(i).radius;
-      tmp.x        = extracted_pos-&gt;Signals.at(i).x;
-      tmp.y        = extracted_pos-&gt;Signals.at(i).y;
-      tmp.z        = extracted_pos-&gt;Signals.at(i).z;
-      tmp.type     = extracted_pos-&gt;Signals.at(i).type;
-      tmp.linkId   = extracted_pos-&gt;Signals.at(i).linkId;
-      tmp.plId     = extracted_pos-&gt;Signals.at(i).plId;
-      signals.push_back(tmp);
-    }
-
-  std::vector&lt;int&gt; plid_vector;
-  for (sig_iterator=signals.begin(); sig_iterator&lt;signals.end(); sig_iterator++) {
-    plid_vector.push_back(sig_iterator-&gt;plId);
-  }
-
-  /* get array that has unique PLID values as its element */
-  std::sort(plid_vector.begin(), plid_vector.end());
-  std::vector&lt;int&gt;::iterator new_end = std::unique(plid_vector.begin(), plid_vector.end());
-  plid_vector.erase(new_end, plid_vector.end());
-
-  std::vector&lt;Context&gt; updatedSignals;
-
-  /* assemble fragmented signal lamp in a context */
-  for (unsigned int ctx_idx=0; ctx_idx&lt;plid_vector.size(); ctx_idx++)
-    {
-      Context ctx;
-      int min_radius  = INT_MAX;
-      int most_left   = frame_column;
-      int most_top    = frame_row;
-      int most_right  = 0;
-      int most_bottom = 0;
-
-      for (sig_iterator=signals.begin(); sig_iterator&lt;signals.end(); sig_iterator++)
-        {
-          int img_x = sig_iterator-&gt;u;
-          int img_y = sig_iterator-&gt;v;
-          double map_x = sig_iterator-&gt;x;
-          double map_y = sig_iterator-&gt;y;
-          double map_z = sig_iterator-&gt;z;
-          int radius = sig_iterator-&gt;radius;
-          if (sig_iterator-&gt;plId == plid_vector.at(ctx_idx) &amp;&amp;
-              0 &lt; img_x - radius - 1.5 * radius &amp;&amp; img_x + radius + 1.5 * radius &lt; frame_column &amp;&amp;
-              0 &lt; img_y - radius - 1.5 * radius &amp;&amp; img_y + radius + 1.5 * radius &lt; frame_row)
-            {
-              switch (sig_iterator-&gt;type) {
-              case 1:           /* RED */
-                ctx.redCenter   = cv::Point( img_x, img_y );
-                ctx.redCenter3d = cv::Point3d( map_x, map_y, map_z );
-                break;
-              case 2:           /* GREEN */
-                ctx.greenCenter   = cv::Point( img_x, img_y );
-                ctx.greenCenter3d = cv::Point3d( map_x, map_y, map_z );
-                break;
-              case 3:           /* YELLOW */
-                ctx.yellowCenter   = cv::Point( img_x, img_y );
-                ctx.yellowCenter3d = cv::Point3d( map_x, map_y, map_z );
-                ctx.signalID       = sig_iterator-&gt;signalId; // use yellow light signalID as this context's representative
-                break;
-              default:          /* this signal is not for cars (for pedestrian or something) */
-                continue;
-              }
-              min_radius    = (min_radius &gt; radius) ? radius : min_radius;
-              most_left     = (most_left &gt; img_x - radius -   1.5 * min_radius)  ? img_x - radius - 1.5 * min_radius : most_left;
-              most_top      = (most_top &gt; img_y - radius -    1.5 * min_radius)  ? img_y - radius - 1.5 * min_radius : most_top;
-              most_right    = (most_right &lt; img_x + radius +  1.5 * min_radius)  ? img_x + radius + 1.5 * min_radius : most_right;
-              most_bottom   = (most_bottom &lt; img_y + radius + 1.5 * min_radius)  ? img_y + radius + 1.5 * min_radius : most_bottom;
-            }
-        }
-
-      ctx.lampRadius = min_radius;
-      ctx.topLeft    = cv::Point(most_left, most_top);
-      ctx.botRight   = cv::Point(most_right, most_bottom);
-      ctx.lightState = UNDEFINED;
-      ctx.stateJudgeCount = 0;
-
-      /* search whether this signal has already belonged in detector.contexts */
-      bool isInserted = false;
-      std::vector&lt;int&gt; eraseCandidate;
-      for (unsigned int i = 0; i &lt; contexts.size(); i++) {
-        if (ctx.signalID == contexts.at(i).signalID &amp;&amp; ctx.lampRadius != INT_MAX)
-          {
-            /* update to new information except to lightState */
-            updatedSignals.push_back(ctx);
-            updatedSignals.back().lightState      = contexts.at(i).lightState;
-            updatedSignals.back().stateJudgeCount = contexts.at(i).stateJudgeCount;
-            isInserted = true;
-            break;
-          }
-
-      }
-
-      if (isInserted == false &amp;&amp; ctx.lampRadius != INT_MAX)
-        updatedSignals.push_back(ctx); // this ctx is new in detector.contexts
-
-    }
-
-  /* sort by lampRadius */
-  std::sort(updatedSignals.begin(), updatedSignals.end(), CompareContext);
-
-  /* reset detector.contexts */
-  contexts.clear();
-  contexts.resize(updatedSignals.size());
-  for (unsigned int i=0; i&lt;updatedSignals.size(); i++) {
-    contexts.at(i) = updatedSignals.at(i);
-  }
+void Context::SetContexts(std::vector&lt;Context&gt; &amp;out_signal_contexts,
+                          const autoware_msgs::Signals::ConstPtr &amp;in_lamp_signals_positions,
+                          const int in_image_height,
+                          const int in_image_width)
+{
+	/* copy parts of data to local variable */
+	std::vector&lt;autoware_msgs::ExtractedPosition&gt; signals_lamps;
+	std::vector&lt;autoware_msgs::ExtractedPosition&gt;::iterator lamp_iterator;
+
+	std::vector&lt;int&gt; lane_id_vector;
+
+	for (unsigned int i = 0; i &lt; in_lamp_signals_positions-&gt;Signals.size(); i++)
+	{
+		autoware_msgs::ExtractedPosition tmp_lamp_position;
+		tmp_lamp_position.signalId = in_lamp_signals_positions-&gt;Signals.at(i).signalId;
+		tmp_lamp_position.u = in_lamp_signals_positions-&gt;Signals.at(i).u;
+		tmp_lamp_position.v = in_lamp_signals_positions-&gt;Signals.at(i).v;
+		tmp_lamp_position.radius = in_lamp_signals_positions-&gt;Signals.at(i).radius;
+		tmp_lamp_position.x = in_lamp_signals_positions-&gt;Signals.at(i).x;
+		tmp_lamp_position.y = in_lamp_signals_positions-&gt;Signals.at(i).y;
+		tmp_lamp_position.z = in_lamp_signals_positions-&gt;Signals.at(i).z;
+		tmp_lamp_position.type = in_lamp_signals_positions-&gt;Signals.at(i).type;
+		tmp_lamp_position.linkId = in_lamp_signals_positions-&gt;Signals.at(i).linkId;
+		tmp_lamp_position.plId = in_lamp_signals_positions-&gt;Signals.at(i).plId;
+		signals_lamps.push_back(tmp_lamp_position);
+
+		lane_id_vector.push_back(tmp_lamp_position.linkId); //store lanes ids, to later identify signals contexts
+	}
+
+	//get unique lane ids
+	std::sort(lane_id_vector.begin(), lane_id_vector.end());
+	std::vector&lt;int&gt;::iterator new_end = std::unique(lane_id_vector.begin(), lane_id_vector.end());
+	lane_id_vector.erase(new_end, lane_id_vector.end());
+
+	std::vector&lt;Context&gt; final_signal_contexts;
+
+	//one traffic signal per lane, check each lane and find the bulb belonging to this lane (this signal Context)
+	for (unsigned int ctx_idx = 0; ctx_idx &lt; lane_id_vector.size(); ctx_idx++)
+	{
+		Context current_signal_context;
+		int min_radius = INT_MAX;
+		int most_left = in_image_width;
+		int most_top = in_image_height;
+		int most_right = 0;
+		int most_bottom = 0;
+		current_signal_context.leftTurnSignal = false;
+		current_signal_context.rightTurnSignal = false;
+		current_signal_context.closestLaneId = -1;
+		//check which lamps belong to this lane
+		for (lamp_iterator = signals_lamps.begin(); lamp_iterator &lt; signals_lamps.end(); lamp_iterator++)
+		{
+			int img_x = lamp_iterator-&gt;u;
+			int img_y = lamp_iterator-&gt;v;
+			double map_x = lamp_iterator-&gt;x;
+			double map_y = lamp_iterator-&gt;y;
+			double map_z = lamp_iterator-&gt;z;
+			int radius = lamp_iterator-&gt;radius;
+			if (lamp_iterator-&gt;linkId == lane_id_vector.at(ctx_idx) &amp;&amp;
+			    0 &lt; img_x - radius - 1.5 * radius &amp;&amp; img_x + radius + 1.5 * radius &lt; in_image_width &amp;&amp;
+			    0 &lt; img_y - radius - 1.5 * radius &amp;&amp; img_y + radius + 1.5 * radius &lt; in_image_height)
+			{
+				switch (lamp_iterator-&gt;type)
+				{
+					case 1:             /* RED */
+						current_signal_context.redCenter = cv::Point(img_x, img_y);
+						current_signal_context.redCenter3d = cv::Point3d(map_x, map_y, map_z);
+						break;
+					case 2:             /* GREEN */
+						current_signal_context.greenCenter = cv::Point(img_x, img_y);
+						current_signal_context.greenCenter3d = cv::Point3d(map_x, map_y, map_z);
+						break;
+					case 3:             /* YELLOW */
+						current_signal_context.yellowCenter = cv::Point(img_x, img_y);
+						current_signal_context.yellowCenter3d = cv::Point3d(map_x, map_y, map_z);
+						// use yellow light bulb signalID as this context's representative
+						current_signal_context.signalID = lamp_iterator-&gt;signalId;
+						current_signal_context.closestLaneId = lamp_iterator-&gt;linkId;
+						break;
+					case 21:            /*RED LEFT*/
+						current_signal_context.redCenter = cv::Point(img_x, img_y);
+						current_signal_context.redCenter3d = cv::Point3d(map_x, map_y, map_z);
+						current_signal_context.leftTurnSignal = true;
+						break;
+					case 22:            /*GREEN LEFT*/
+						current_signal_context.greenCenter = cv::Point(img_x, img_y);
+						current_signal_context.greenCenter3d = cv::Point3d(map_x, map_y, map_z);
+						current_signal_context.leftTurnSignal = true;
+						break;
+					case 23:            /*YELLOW LEFT*/
+						current_signal_context.yellowCenter = cv::Point(img_x, img_y);
+						current_signal_context.yellowCenter3d = cv::Point3d(map_x, map_y, map_z);
+						current_signal_context.leftTurnSignal = true;
+						// use yellow light bulb signalID as this context's representative
+						current_signal_context.signalID = lamp_iterator-&gt;signalId;
+						current_signal_context.closestLaneId = lamp_iterator-&gt;linkId;
+						break;
+					default:          /* this signal is not for cars (for pedestrian or something) */
+						continue;
+				}
+				min_radius = (min_radius &gt; radius) ? radius : min_radius;
+				most_left = (most_left &gt; img_x - radius - 1.5 * min_radius) ? img_x - radius - 1.5 * min_radius
+				                                                            : most_left;
+				most_top = (most_top &gt; img_y - radius - 1.5 * min_radius) ? img_y - radius - 1.5 * min_radius
+				                                                          : most_top;
+				most_right = (most_right &lt; img_x + radius + 1.5 * min_radius) ? img_x + radius + 1.5 * min_radius
+				                                                              : most_right;
+				most_bottom = (most_bottom &lt; img_y + radius + 1.5 * min_radius) ? img_y + radius + 1.5 * min_radius
+				                                                                : most_bottom;
+			}//end if check this lamp belong to this lane and visible
+		}//end for to check if the lamp belongs to the lane
+
+		current_signal_context.lampRadius = min_radius;
+		current_signal_context.topLeft = cv::Point(most_left, most_top);
+		current_signal_context.botRight = cv::Point(most_right, most_bottom);
+		current_signal_context.lightState = UNDEFINED;
+		current_signal_context.stateJudgeCount = 0;
+
+		/* search whether this signal has already belonged in detector.out_signal_contexts */
+		bool isInserted = false;
+		std::vector&lt;int&gt; eraseCandidate;
+		for (unsigned int i = 0; i &lt; out_signal_contexts.size(); i++)
+		{
+			if (current_signal_context.signalID == out_signal_contexts.at(i).signalID &amp;&amp;
+				current_signal_context.lampRadius != INT_MAX)
+			{
+				/* update to new information except to lightState */
+				final_signal_contexts.push_back(current_signal_context);
+				final_signal_contexts.back().lightState = out_signal_contexts.at(i).lightState;
+				final_signal_contexts.back().stateJudgeCount = out_signal_contexts.at(i).stateJudgeCount;
+				isInserted = true;
+				break;
+			}
+		}
+
+		if (isInserted == false &amp;&amp; current_signal_context.lampRadius != INT_MAX)
+		{
+			final_signal_contexts.push_back(
+					current_signal_context); // this current_signal_context is new in detector.out_signal_contexts
+		}
+
+	}//end for check each lane
+
+	/* sort by lampRadius */
+	std::sort(final_signal_contexts.begin(), final_signal_contexts.end(), CompareContext);
+
+	/* reset detector.out_signal_contexts */
+	out_signal_contexts.clear();
+	out_signal_contexts.resize(final_signal_contexts.size());
+	for (unsigned int i = 0; i &lt; final_signal_contexts.size(); i++)
+	{
+		out_signal_contexts.at(i) = final_signal_contexts.at(i);
+	}
 
 } /* std::vector&lt;Context&gt; Context::SetContexts() */
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\feat_proj.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\feat_proj.cpp" added_lines="357" deleted_lines="321">
				<diff>@@ -33,23 +33,24 @@ static constexpr uint32_t SUBSCRIBE_QUEUE_SIZE = 1000;
 static int adjust_proj_x = 0;
 static int adjust_proj_y = 0;
 
-typedef struct {
-  double thiX;
-  double thiY;
-  double thiZ;
+typedef struct
+{
+	double thiX;
+	double thiY;
+	double thiZ;
 } Angle;
 
 static VectorMap vmap;
-static Angle cameraOrientation; // camera orientation = car's orientation
+//static Angle cameraOrientation; // camera orientation = car's orientation
 
 static Eigen::Vector3f position;
 static Eigen::Quaternionf orientation;
-static  float fx,
-  fy,
-  imageWidth,
-  imageHeight,
-  cx,
-  cy;
+static float fx,
+		fy,
+		imageWidth,
+		imageHeight,
+		cx,
+		cy;
 static tf::StampedTransform trf;
 
 static bool g_use_vector_map_server; // Switch flag whether vecter-map-server function will be used
@@ -60,98 +61,101 @@ static ros::ServiceClient g_ros_client;
 /* Define utility class to use vector map server */
 namespace
 {
-  class VectorMapClient
-  {
-  private:
-    geometry_msgs::PoseStamped pose_;
-    autoware_msgs::lane waypoints_;
-
-  public:
-    VectorMapClient()
-    {}
-
-    ~VectorMapClient()
-    {}
-
-    geometry_msgs::PoseStamped pose() const
-    {
-      return pose_;
-    }
-
-    autoware_msgs::lane waypoints() const
-    {
-      return waypoints_;
-    }
-
-    void set_pose(const geometry_msgs::PoseStamped&amp; pose)
-    {
-      pose_ = pose;
-    }
-
-    void set_waypoints(const autoware_msgs::lane&amp; waypoints)
-    {
-      waypoints_ = waypoints;
-    }
-  }; // Class VectorMapClient
+	class VectorMapClient
+	{
+	private:
+		geometry_msgs::PoseStamped pose_;
+		autoware_msgs::lane waypoints_;
+
+	public:
+		VectorMapClient()
+		{
+		}
+
+		~VectorMapClient()
+		{
+		}
+
+		geometry_msgs::PoseStamped pose() const
+		{
+			return pose_;
+		}
+
+		autoware_msgs::lane waypoints() const
+		{
+			return waypoints_;
+		}
+
+		void set_pose(const geometry_msgs::PoseStamped &amp;pose)
+		{
+			pose_ = pose;
+		}
+
+		void set_waypoints(const autoware_msgs::lane &amp;waypoints)
+		{
+			waypoints_ = waypoints;
+		}
+	}; // Class VectorMapClient
 } // namespace
 static VectorMapClient g_vector_map_client;
 
 
 /* Callback function to shift projection result */
-void adjust_xyCallback (const autoware_msgs::adjust_xy::ConstPtr&amp; config_msg)
+void adjust_xyCallback(const autoware_msgs::adjust_xy::ConstPtr &amp;config_msg)
 {
-  adjust_proj_x = config_msg-&gt;x;
-  adjust_proj_y = config_msg-&gt;y;
+	adjust_proj_x = config_msg-&gt;x;
+	adjust_proj_y = config_msg-&gt;y;
 }
 
-void cameraInfoCallback (const sensor_msgs::CameraInfo::ConstPtr camInfoMsg)
+void cameraInfoCallback(const sensor_msgs::CameraInfo::ConstPtr camInfoMsg)
 {
-  fx = static_cast&lt;float&gt;(camInfoMsg-&gt;P[0]);
-  fy = static_cast&lt;float&gt;(camInfoMsg-&gt;P[5]);
-  imageWidth = camInfoMsg-&gt;width;
-  imageHeight = camInfoMsg-&gt;height;
-  cx = static_cast&lt;float&gt;(camInfoMsg-&gt;P[2]);
-  cy = static_cast&lt;float&gt;(camInfoMsg-&gt;P[6]);
+	fx = static_cast&lt;float&gt;(camInfoMsg-&gt;P[0]);
+	fy = static_cast&lt;float&gt;(camInfoMsg-&gt;P[5]);
+	imageWidth = camInfoMsg-&gt;width;
+	imageHeight = camInfoMsg-&gt;height;
+	cx = static_cast&lt;float&gt;(camInfoMsg-&gt;P[2]);
+	cy = static_cast&lt;float&gt;(camInfoMsg-&gt;P[6]);
 }
 
 
 /* convert degree value into 0 to 360 range */
-static double setDegree0to360(double val)
+/*static double setDegree0to360(double val)
 {
-  if (val &lt; 0.0f) {
-    return (val + 360.0f);
-  }
-  else if (360.0f &lt; val) {
-    return (val - 360.0f);
-  }
-
-  return val;
-}
+	if (val &lt; 0.0f)
+	{
+		return (val + 360.0f);
+	} else if (360.0f &lt; val)
+	{
+		return (val - 360.0f);
+	}
+
+	return val;
+}*/
 
 
-static void get_cameraRollPitchYaw(double* roll,
-                                   double* pitch,
-                                   double* yaw)
+/*static void get_cameraRollPitchYaw(double *roll,
+                                   double *pitch,
+                                   double *yaw)
 {
-  geometry_msgs::Pose cameraPose;
-  cameraPose.position.x    = (double)(position.x());
-  cameraPose.position.y    = (double)(position.y());
-  cameraPose.position.z    = (double)(position.z());
-  cameraPose.orientation.x = (double)(orientation.x());
-  cameraPose.orientation.y = (double)(orientation.y());
-  cameraPose.orientation.z = (double)(orientation.z());
-  cameraPose.orientation.w = (double)(orientation.w());
-
-  tf::Quaternion quat;
-
-  tf::quaternionMsgToTF(cameraPose.orientation, quat);
-  tf::Matrix3x3(quat).getRPY(*roll, *pitch, *yaw);
-
-  /* convert from radian to degree */
-  *roll  = setDegree0to360(*roll  * 180.0f / M_PI);
-  *pitch = setDegree0to360(*pitch * 180.0f / M_PI);
-  *yaw   = setDegree0to360(*yaw   * 180.0f / M_PI);
-}
+	geometry_msgs::Pose cameraPose;
+	cameraPose.position.x = (double) (position.x());
+	cameraPose.position.y = (double) (position.y());
+	cameraPose.position.z = (double) (position.z());
+	cameraPose.orientation.x = (double) (orientation.x());
+	cameraPose.orientation.y = (double) (orientation.y());
+	cameraPose.orientation.z = (double) (orientation.z());
+	cameraPose.orientation.w = (double) (orientation.w());
+
+	tf::Quaternion quat;
+
+	tf::quaternionMsgToTF(cameraPose.orientation, quat);
+	tf::Matrix3x3(quat).getRPY(*roll, *pitch, *yaw);
+
+	// convert from radian to degree
+	*roll = setDegree0to360(*roll * 180.0f / M_PI);
+	*pitch = setDegree0to360(*pitch * 180.0f / M_PI);
+	*yaw = setDegree0to360(*yaw * 180.0f / M_PI);
+}*/
 
 
 /*
@@ -160,282 +164,314 @@ static void get_cameraRollPitchYaw(double* roll,
 */
 static bool isRange(const double lower, const double upper, const double val)
 {
-  if (lower &lt;= upper) {
-    if (lower &lt; val &amp;&amp; val &lt; upper) {
-      return true;
-    }
-  }
-  else {
-    if (val &lt; upper || lower &lt; val) {
-      return true;
-    }
-  }
-
-  return false;
+	if (lower &lt;= upper)
+	{
+		if (lower &lt; val &amp;&amp; val &lt; upper)
+		{
+			return true;
+		}
+	} else
+	{
+		if (val &lt; upper || lower &lt; val)
+		{
+			return true;
+		}
+	}
+
+	return false;
 }
 
 
-void getTransform (Eigen::Quaternionf &amp;ori, Point3 &amp;pos)
+void getTransform(Eigen::Quaternionf &amp;ori, Point3 &amp;pos)
 {
-  static tf::TransformListener listener;
-
-  // target_frame    source_frame
-  ros::Time now = ros::Time();
-  listener.waitForTransform (camera_id_str, "map", now, ros::Duration(10.0));
-  listener.lookupTransform (camera_id_str, "map", now, trf);
-
-  tf::Vector3 &amp;p = trf.getOrigin();
-  tf::Quaternion o = trf.getRotation();
-  pos.x()=p.x(); pos.y()=p.y(); pos.z()=p.z();
-  ori.w()=o.w(); ori.x()=o.x(); ori.y()=o.y(); ori.z()=o.z();
+	static tf::TransformListener listener;
+
+	// target_frame    source_frame
+	ros::Time now = ros::Time();
+	listener.waitForTransform(camera_id_str, "map", now, ros::Duration(10.0));
+	listener.lookupTransform(camera_id_str, "map", now, trf);
+
+	tf::Vector3 &amp;p = trf.getOrigin();
+	tf::Quaternion o = trf.getRotation();
+	pos.x() = p.x();
+	pos.y() = p.y();
+	pos.z() = p.z();
+	ori.w() = o.w();
+	ori.x() = o.x();
+	ori.y() = o.y();
+	ori.z() = o.z();
 }
 
 
-Point3 transform (const Point3 &amp;psrc, tf::StampedTransform &amp;tfsource)
+Point3 transform(const Point3 &amp;psrc, tf::StampedTransform &amp;tfsource)
 {
-  tf::Vector3 pt3 (psrc.x(), psrc.y(), psrc.z());
-  tf::Vector3 pt3s = tfsource * pt3;
-  return Point3 (pt3s.x(), pt3s.y(), pt3s.z());
+	tf::Vector3 pt3(psrc.x(), psrc.y(), psrc.z());
+	tf::Vector3 pt3s = tfsource * pt3;
+	return Point3(pt3s.x(), pt3s.y(), pt3s.z());
 }
 
 
 /*
  * Project a point from world coordinate to image plane
  */
-bool project2 (const Point3 &amp;pt, int &amp;u, int &amp;v, bool useOpenGLCoord=false)
+bool project2(const Point3 &amp;pt, int &amp;u, int &amp;v, bool useOpenGLCoord = false)
 {
-  float nearPlane = 1.0;
-  float farPlane = 200.0;
-  Point3 _pt = transform (pt, trf);
-  float _u = _pt.x()*fx/_pt.z() + cx;
-  float _v = _pt.y()*fy/_pt.z() + cy;
-
-  u = static_cast&lt;int&gt;(_u);
-  v = static_cast&lt;int&gt;(_v);
-  if ( u &lt; 0 || imageWidth &lt; u || v &lt; 0 || imageHeight &lt; v || _pt.z() &lt; nearPlane || farPlane &lt; _pt.z() ) {
-    u = -1, v = -1;
-    return false;
-  }
-
-  if (useOpenGLCoord) {
-    v = imageHeight - v;
-  }
-
-  return true;
+	float nearPlane = 1.0;
+	float farPlane = 200.0;
+	Point3 _pt = transform(pt, trf);
+	float _u = _pt.x() * fx / _pt.z() + cx;
+	float _v = _pt.y() * fy / _pt.z() + cy;
+
+	u = static_cast&lt;int&gt;(_u);
+	v = static_cast&lt;int&gt;(_v);
+	if (u &lt; 0 || imageWidth &lt; u || v &lt; 0 || imageHeight &lt; v || _pt.z() &lt; nearPlane || farPlane &lt; _pt.z())
+	{
+		u = -1, v = -1;
+		return false;
+	}
+
+	if (useOpenGLCoord)
+	{
+		v = imageHeight - v;
+	}
+
+	return true;
 }
 
 double ConvertDegreeToRadian(double degree)
 {
-  return degree * M_PI / 180.0f;
+	return degree * M_PI / 180.0f;
 }
 
 
 double ConvertRadianToDegree(double radian)
 {
-  return radian * 180.0f / M_PI;
+	return radian * 180.0f / M_PI;
 }
 
 
 double GetSignalAngleInCameraSystem(double hang, double vang)
 {
-  // Fit the vector map format into ROS style
-  double signal_pitch_in_map = ConvertDegreeToRadian(vang - 90);
-  double signal_yaw_in_map   = ConvertDegreeToRadian(-hang + 90);
-
-  tf::Quaternion signal_orientation_in_map_system;
-  signal_orientation_in_map_system.setRPY(0, signal_pitch_in_map, signal_yaw_in_map);
-
-  tf::Quaternion signal_orientation_in_cam_system = trf * signal_orientation_in_map_system;
-  double signal_roll_in_cam;
-  double signal_pitch_in_cam;
-  double signal_yaw_in_cam;
-  tf::Matrix3x3(signal_orientation_in_cam_system).getRPY(signal_roll_in_cam,
-                                                         signal_pitch_in_cam,
-                                                         signal_yaw_in_cam);
-
-  return ConvertRadianToDegree(signal_pitch_in_cam);   // holizontal angle of camera is represented by pitch
+	// Fit the vector map format into ROS style
+	double signal_pitch_in_map = ConvertDegreeToRadian(vang - 90);
+	double signal_yaw_in_map = ConvertDegreeToRadian(-hang + 90);
+
+	tf::Quaternion signal_orientation_in_map_system;
+	signal_orientation_in_map_system.setRPY(0, signal_pitch_in_map, signal_yaw_in_map);
+
+	tf::Quaternion signal_orientation_in_cam_system = trf * signal_orientation_in_map_system;
+	double signal_roll_in_cam;
+	double signal_pitch_in_cam;
+	double signal_yaw_in_cam;
+	tf::Matrix3x3(signal_orientation_in_cam_system).getRPY(signal_roll_in_cam,
+	                                                       signal_pitch_in_cam,
+	                                                       signal_yaw_in_cam);
+
+	return ConvertRadianToDegree(signal_pitch_in_cam);   // holizontal angle of camera is represented by pitch
 }  // double GetSignalAngleInCameraSystem()
 
 
-void echoSignals2 (ros::Publisher &amp;pub, bool useOpenGLCoord=false)
+void echoSignals2(ros::Publisher &amp;pub, bool useOpenGLCoord = false)
 {
-  int countPoint = 0;
-  autoware_msgs::Signals signalsInFrame;
-
-  /* Get signals on the path if vecter_map_server is enabled */
-  if (g_use_vector_map_server) {
-    vector_map_server::GetSignal service;
-    /* Set server's request */
-    service.request.pose = g_vector_map_client.pose();
-    service.request.waypoints = g_vector_map_client.waypoints();
-
-    /* Get server's response*/
-    if (g_ros_client.call(service)) {
-      /* Reset signal data container */
-      vmap.signals.clear();
-
-      /* Newle insert signal data on the path */
-      for (const auto&amp; response: service.response.objects.data) {
-        if (response.id == 0)
-          continue;
-
-        Signal signal;
-        signal.id = response.id;
-        signal.vid = response.vid;
-        signal.plid = response.plid;
-        signal.type = response.type;
-        signal.linkid = response.linkid;
-
-        vmap.signals.insert(std::map&lt;int, Signal&gt;::value_type(signal.id, signal));
-      }
-    }
-  }
-
-  for (unsigned int i=1; i&lt;=vmap.signals.size(); i++) {
-    Signal signal = vmap.signals[i];
-    int pid = vmap.vectors[signal.vid].pid;
-
-    Point3 signalcenter = vmap.getPoint(pid);
-    Point3 signalcenterx (signalcenter.x(), signalcenter.y(), signalcenter.z()+SignalLampRadius);
-
-    int u, v;
-    if (project2 (signalcenter, u, v, useOpenGLCoord) == true) {
-      countPoint++;
-      // std::cout &lt;&lt; u &lt;&lt; ", " &lt;&lt; v &lt;&lt; ", " &lt;&lt; std::endl;
-
-      int radius;
-      int ux, vx;
-      project2 (signalcenterx, ux, vx, useOpenGLCoord);
-      radius = (int)distance (ux, vx, u, v);
-
-      autoware_msgs::ExtractedPosition sign;
-      sign.signalId = signal.id;
-
-      sign.u = u + adjust_proj_x; // shift project position by configuration value from runtime manager
-      sign.v = v + adjust_proj_y; // shift project position by configuration value from runtime manager
-
-      sign.radius = radius;
-      sign.x = signalcenter.x(), sign.y = signalcenter.y(), sign.z = signalcenter.z();
-      sign.hang = vmap.vectors[signal.vid].hang; // hang is expressed in [0, 360] degree
-      sign.type = signal.type, sign.linkId = signal.linkid;
-      sign.plId = signal.plid;
-
-      // Get holizontal angle of signal in camera corrdinate system
-      double signal_angle = GetSignalAngleInCameraSystem(vmap.vectors[signal.vid].hang + 180.0f,
-                                                         vmap.vectors[signal.vid].vang + 180.0f);
-
-      // signal_angle will be zero if signal faces to x-axis
-      // Target signal should be face to -50 &lt;= z-axis (= 90 degree) &lt;= +50
-      if (isRange(-50, 50, signal_angle - 90)) {
-        signalsInFrame.Signals.push_back (sign);
-      }
-    }
-  }
-
-  signalsInFrame.header.stamp = ros::Time::now();
-  pub.publish (signalsInFrame);
-
-  // printf ("There are %d out of %u signals in frame\n", countPoint, static_cast&lt;unsigned int&gt;(vmap.signals.size()));
+	int countPoint = 0;
+	autoware_msgs::Signals signalsInFrame;
+
+	/* Get signals on the path if vecter_map_server is enabled */
+	if (g_use_vector_map_server)
+	{
+		vector_map_server::GetSignal service;
+		/* Set server's request */
+		service.request.pose = g_vector_map_client.pose();
+		service.request.waypoints = g_vector_map_client.waypoints();
+
+		/* Get server's response*/
+		if (g_ros_client.call(service))
+		{
+			/* Reset signal data container */
+			vmap.signals.clear();
+
+			/* Newle insert signal data on the path */
+			for (const auto &amp;response: service.response.objects.data)
+			{
+				if (response.id == 0)
+					continue;
+
+				Signal signal;
+				signal.id = response.id;
+				signal.vid = response.vid;
+				signal.plid = response.plid;
+				signal.type = response.type;
+				signal.linkid = response.linkid;
+
+				vmap.signals.insert(std::map&lt;int, Signal&gt;::value_type(signal.id, signal));
+			}
+		}
+	}
+
+	for (unsigned int i = 1; i &lt;= vmap.signals.size(); i++)
+	{
+		Signal signal = vmap.signals[i];
+		int pid = vmap.vectors[signal.vid].pid;
+
+		Point3 signalcenter = vmap.getPoint(pid);
+		Point3 signalcenterx(signalcenter.x(), signalcenter.y(), signalcenter.z() + SignalLampRadius);
+
+		int u, v;
+		if (project2(signalcenter, u, v, useOpenGLCoord) == true)
+		{
+			countPoint++;
+			// std::cout &lt;&lt; u &lt;&lt; ", " &lt;&lt; v &lt;&lt; ", " &lt;&lt; std::endl;
+
+			int radius;
+			int ux, vx;
+			project2(signalcenterx, ux, vx, useOpenGLCoord);
+			radius = (int) distance(ux, vx, u, v);
+
+			autoware_msgs::ExtractedPosition sign;
+			sign.signalId = signal.id;
+
+			sign.u = u + adjust_proj_x; // shift project position by configuration value from runtime manager
+			sign.v = v + adjust_proj_y; // shift project position by configuration value from runtime manager
+
+			sign.radius = radius;
+			sign.x = signalcenter.x(), sign.y = signalcenter.y(), sign.z = signalcenter.z();
+			sign.hang = vmap.vectors[signal.vid].hang; // hang is expressed in [0, 360] degree
+			sign.type = signal.type, sign.linkId = signal.linkid;
+			sign.plId = signal.plid;
+
+			// Get holizontal angle of signal in camera corrdinate system
+			double signal_angle = GetSignalAngleInCameraSystem(vmap.vectors[signal.vid].hang + 180.0f,
+			                                                   vmap.vectors[signal.vid].vang + 180.0f);
+
+			// signal_angle will be zero if signal faces to x-axis
+			// Target signal should be face to -50 &lt;= z-axis (= 90 degree) &lt;= +50
+			if (isRange(-50, 50, signal_angle - 90))
+			{
+				signalsInFrame.Signals.push_back(sign);
+			}
+		}
+	}
+	signalsInFrame.header.stamp = ros::Time::now();
+	pub.publish(signalsInFrame);
+
+	std::cout &lt;&lt; "There are " &lt;&lt; signalsInFrame.Signals.size() &lt;&lt; " signals in range" &lt;&lt; std::endl;
 }
 
 
-void interrupt (int s)
+void interrupt(int s)
 {
-  ros::shutdown();
-  exit(1);
+	ros::shutdown();
+	exit(1);
 }
 
 
-int main (int argc, char *argv[])
+int main(int argc, char *argv[])
 {
 
-  ros::init(argc, argv, "feat_proj", ros::init_options::NoSigintHandler);
-  ros::NodeHandle rosnode;
-  ros::NodeHandle private_nh("~");
-  std::string cameraInfo_topic_name;
-  private_nh.param&lt;std::string&gt;("camera_info_topic", cameraInfo_topic_name, "/camera_info");
-
-  /* get camera ID */
-  camera_id_str = cameraInfo_topic_name;
-  camera_id_str.erase(camera_id_str.find("/camera_info"));
-  if (camera_id_str == "/") {
-    camera_id_str = "camera";
-  }
-  
-  /* Get Flag wheter vecter_map_server function will be used  */
-  private_nh.param&lt;bool&gt;("use_path_info", g_use_vector_map_server, false);
-
-  /* load vector map */
-  ros::Subscriber sub_point     = rosnode.subscribe("vector_map_info/point",
-                                                    SUBSCRIBE_QUEUE_SIZE,
-                                                    &amp;VectorMap::load_points,
-                                                    &amp;vmap);
-  ros::Subscriber sub_line      = rosnode.subscribe("vector_map_info/line",
-                                                    SUBSCRIBE_QUEUE_SIZE,
-                                                    &amp;VectorMap::load_lines,
-                                                    &amp;vmap);
-  ros::Subscriber sub_lane      = rosnode.subscribe("vector_map_info/lane",
-                                                    SUBSCRIBE_QUEUE_SIZE,
-                                                    &amp;VectorMap::load_lanes,
-                                                    &amp;vmap);
-  ros::Subscriber sub_vector    = rosnode.subscribe("vector_map_info/vector",
-                                                    SUBSCRIBE_QUEUE_SIZE,
-                                                    &amp;VectorMap::load_vectors,
-                                                    &amp;vmap);
-  ros::Subscriber sub_signal    = rosnode.subscribe("vector_map_info/signal",
-                                                    SUBSCRIBE_QUEUE_SIZE,
-                                                    &amp;VectorMap::load_signals,
-                                                    &amp;vmap);
-  ros::Subscriber sub_whiteline = rosnode.subscribe("vector_map_info/white_line",
-                                                    SUBSCRIBE_QUEUE_SIZE,
-                                                    &amp;VectorMap::load_whitelines,
-                                                    &amp;vmap);
-  ros::Subscriber sub_dtlane    = rosnode.subscribe("vector_map_info/dtlane",
-                                                    SUBSCRIBE_QUEUE_SIZE,
-                                                    &amp;VectorMap::load_dtlanes,
-                                                    &amp;vmap);
-
-  /* wait until loading all vector map is completed */
-  ros::Rate wait_rate(1);
-  while(vmap.points.empty() || vmap.lines.empty() || vmap.whitelines.empty() ||
-        vmap.lanes.empty() || vmap.dtlanes.empty() || vmap.vectors.empty() || vmap.signals.empty())
-    {
-      ros::spinOnce();
-      wait_rate.sleep();
-    }
-
-  vmap.loaded = true;
-  std::cout &lt;&lt; "all vector map loaded." &lt;&lt; std::endl;
-
-  ros::Subscriber cameraInfoSubscriber = rosnode.subscribe (cameraInfo_topic_name, 100, cameraInfoCallback);
-  ros::Subscriber adjust_xySubscriber  = rosnode.subscribe("/config/adjust_xy", 100, adjust_xyCallback);
-  ros::Subscriber current_pose_subscriber;
-  ros::Subscriber waypoint_subscriber;
-  if (g_use_vector_map_server) {
-    /* Create subscribers which deliver informations requested by server */
-    current_pose_subscriber = rosnode.subscribe("/current_pose", 1, &amp;VectorMapClient::set_pose, &amp;g_vector_map_client);
-    waypoint_subscriber     = rosnode.subscribe("/final_waypoints", 1, &amp;VectorMapClient::set_waypoints, &amp;g_vector_map_client);
-
-    /* Create ros client to use Server-Client communication */
-    g_ros_client = rosnode.serviceClient&lt;vector_map_server::GetSignal&gt;("vector_map_server/get_signal");
-  }
-
-  ros::Publisher  signalPublisher      = rosnode.advertise &lt;autoware_msgs::Signals&gt; ("roi_signal", 100);
-  signal (SIGINT, interrupt);
-
-  Rate loop (25);
-  while (true) {
-
-    ros::spinOnce();
-
-    try {
-      getTransform (orientation, position);
-    } catch (tf::TransformException &amp;exc) {
-    }
-
-    echoSignals2 (signalPublisher, false);
-    loop.sleep();
-  }
-
+	ros::init(argc, argv, "feat_proj", ros::init_options::NoSigintHandler);
+	ros::NodeHandle rosnode;
+	ros::NodeHandle private_nh("~");
+	std::string cameraInfo_topic_name;
+	private_nh.param&lt;std::string&gt;("camera_info_topic", cameraInfo_topic_name, "/camera_info");
+
+	/* get camera ID */
+	camera_id_str = cameraInfo_topic_name;
+	camera_id_str.erase(camera_id_str.find("/camera_info"));
+	if (camera_id_str == "/")
+	{
+		camera_id_str = "camera";
+	}
+
+	/* Get Flag wheter vecter_map_server function will be used  */
+	private_nh.param&lt;bool&gt;("use_path_info", g_use_vector_map_server, false);
+
+	/* load vector map */
+	ros::Subscriber sub_point = rosnode.subscribe("vector_map_info/point",
+	                                              SUBSCRIBE_QUEUE_SIZE,
+	                                              &amp;VectorMap::load_points,
+	                                              &amp;vmap);
+	ros::Subscriber sub_line = rosnode.subscribe("vector_map_info/line",
+	                                             SUBSCRIBE_QUEUE_SIZE,
+	                                             &amp;VectorMap::load_lines,
+	                                             &amp;vmap);
+	ros::Subscriber sub_lane = rosnode.subscribe("vector_map_info/lane",
+	                                             SUBSCRIBE_QUEUE_SIZE,
+	                                             &amp;VectorMap::load_lanes,
+	                                             &amp;vmap);
+	ros::Subscriber sub_vector = rosnode.subscribe("vector_map_info/vector",
+	                                               SUBSCRIBE_QUEUE_SIZE,
+	                                               &amp;VectorMap::load_vectors,
+	                                               &amp;vmap);
+	ros::Subscriber sub_signal = rosnode.subscribe("vector_map_info/signal",
+	                                               SUBSCRIBE_QUEUE_SIZE,
+	                                               &amp;VectorMap::load_signals,
+	                                               &amp;vmap);
+	ros::Subscriber sub_whiteline = rosnode.subscribe("vector_map_info/white_line",
+	                                                  SUBSCRIBE_QUEUE_SIZE,
+	                                                  &amp;VectorMap::load_whitelines,
+	                                                  &amp;vmap);
+	ros::Subscriber sub_dtlane = rosnode.subscribe("vector_map_info/dtlane",
+	                                               SUBSCRIBE_QUEUE_SIZE,
+	                                               &amp;VectorMap::load_dtlanes,
+	                                               &amp;vmap);
+
+	/* wait until loading all vector map is completed */
+	ros::Rate wait_rate(100);
+	std::cout &lt;&lt; "Loading Vector Map. Please wait";
+	while (vmap.points.empty() || vmap.lines.empty() || vmap.whitelines.empty() ||
+	       vmap.lanes.empty() || vmap.dtlanes.empty() || vmap.vectors.empty() || vmap.signals.empty())
+	{
+		ros::spinOnce();
+		std::cout &lt;&lt; ".";
+		wait_rate.sleep();
+	}
+
+	vmap.loaded = true;
+	std::cout &lt;&lt; "Loaded." &lt;&lt; std::endl;
+
+	ros::Subscriber cameraInfoSubscriber = rosnode.subscribe(cameraInfo_topic_name, 100, cameraInfoCallback);
+	ros::Subscriber cameraImage = rosnode.subscribe(cameraInfo_topic_name, 100, cameraInfoCallback);
+	ros::Subscriber adjust_xySubscriber = rosnode.subscribe("/config/adjust_xy", 100, adjust_xyCallback);
+	ros::Subscriber current_pose_subscriber;
+	ros::Subscriber waypoint_subscriber;
+	if (g_use_vector_map_server)
+	{
+		/* Create subscribers which deliver informations requested by server */
+		current_pose_subscriber = rosnode.subscribe("/current_pose", 1, &amp;VectorMapClient::set_pose,
+		                                            &amp;g_vector_map_client);
+		waypoint_subscriber = rosnode.subscribe("/final_waypoints", 1, &amp;VectorMapClient::set_waypoints,
+		                                        &amp;g_vector_map_client);
+
+		/* Create ros client to use Server-Client communication */
+		g_ros_client = rosnode.serviceClient&lt;vector_map_server::GetSignal&gt;("vector_map_server/get_signal");
+	}
+
+	ros::Publisher signalPublisher = rosnode.advertise&lt;autoware_msgs::Signals&gt;("roi_signal", 100);
+	signal(SIGINT, interrupt);
+
+	Rate loop(50);
+	Eigen::Vector3f prev_position(0,0,0);
+	Eigen::Quaternionf prev_orientation(0,0,0,0);
+	while (true)
+	{
+		ros::spinOnce();
+
+		try
+		{
+			getTransform(orientation, position);
+		}
+		catch (tf::TransformException &amp;exc)
+		{
+		}
+
+		if (prev_orientation.vec() != orientation.vec()  &amp;&amp;
+		    prev_position != position)
+		{
+			echoSignals2(signalPublisher, false);
+		}
+		prev_orientation = orientation;
+		prev_position = position;
+		loop.sleep();
+	}
 
 }
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\TrafficLightDetector.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\TrafficLightDetector.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -11,7 +11,7 @@ struct regionCandidate {
   bool   isBlacked;
 };
 
-
+#define SHOW_DEBUG_INFO
 extern thresholdSet thSet;      // declared in traffic_light_lkf.cpp
 
 /*
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\region_tlr.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\region_tlr.cpp" added_lines="4" deleted_lines="0">
				<diff>@@ -109,6 +109,10 @@ static void putResult_inText(cv::Mat *image, const std::vector&lt;Context&gt; &amp;context
         label = "UNDEFINED";
         textColor = CV_RGB(0, 0, 0);
       }
+      if (ctx.leftTurnSignal)
+        {label+=" LEFT";}
+      if (ctx.rightTurnSignal)
+        {label+=" RIGHT";}
 
       cv::getTextSize(label,
 		      fontFace,
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_ssd\region_tlr_ssd.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_ssd\region_tlr_ssd.cpp" added_lines="6" deleted_lines="0">
				<diff>@@ -75,8 +75,10 @@ void RegionTlrSsdRosNode::RoiSignalCallback(const autoware_msgs::Signals::ConstP
   // If frame has not been prepared, abort this callback
   if (frame_.empty() ||
       frame_header_.stamp == previous_timestamp) {
+    std::cout &lt;&lt; "No Image" &lt;&lt; std::endl;
     return;
   }
+  std::cout &lt;&lt; "rois: " &lt;&lt; extracted_pos-&gt;Signals.size() &lt;&lt; std::endl;
 
   // Acquire signal posotion on the image
   Context::SetContexts(contexts_, extracted_pos, frame_.rows, frame_.cols);
@@ -89,9 +91,13 @@ void RegionTlrSsdRosNode::RoiSignalCallback(const autoware_msgs::Signals::ConstP
       continue;
     }
 
+    std::cout &lt;&lt; "roi inside: " &lt;&lt; cv::Rect(context.topLeft, context.botRight) &lt;&lt; std::endl;
     // extract region of interest from input image
     cv::Mat roi  = frame_(cv::Rect(context.topLeft, context.botRight)).clone();
 
+    cv::imshow("ssd_tlr", roi);
+	  cv::waitKey(200);
+
     // Get current state of traffic light from current frame
     LightState current_state = recognizer.RecognizeLightState(roi);
 
</diff>
			</file>
			<file old_path="ros\src\data\packages\map_file\nodes\vector_map_loader\vector_map_loader.cpp" new_path="ros\src\data\packages\map_file\nodes\vector_map_loader\vector_map_loader.cpp" added_lines="3" deleted_lines="2">
				<diff>@@ -541,8 +541,9 @@ visualization_msgs::MarkerArray createSignalMarkerArray(const VectorMap&amp; vmap, C
       vector_marker = createVectorMarker("signal", id++, other_color, vmap, vector);
       break;
     default:
-      ROS_ERROR_STREAM("[createSignalMarkerArray] unknown signal.type: " &lt;&lt; signal);
-      continue;
+      ROS_WARN_STREAM("[createSignalMarkerArray] unknown signal.type: " &lt;&lt; signal.type &lt;&lt; " Creating Marker as OTHER.");
+      vector_marker = createVectorMarker("signal", id++, other_color, vmap, vector);
+      break;
     }
     if (isValidMarker(vector_marker))
       marker_array.markers.push_back(vector_marker);
</diff>
			</file>
			<file old_path="ros\src\data\packages\vector_map_server\nodes\vector_map_client\vector_map_client.cpp" new_path="ros\src\data\packages\vector_map_server\nodes\vector_map_client\vector_map_client.cpp" added_lines="2" deleted_lines="1">
				<diff>@@ -237,7 +237,8 @@ int main(int argc, char **argv)
           vector_marker = createVectorMarker("signal", id++, Color::CYAN, vmap, vector);
           break;
         default:
-          continue;
+          vector_marker = createVectorMarker("signal", id++, Color::CYAN, vmap, vector);
+          break;
         }
         if (isValidMarker(vector_marker))
         {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="01135d0467a9d096073c1bc36d29b8ce58e2b2b2" author="AMC">
		<msg>Added support to publish result of multiple traffic signals according to the lane
VectorMapServer Support to publish signals on current lane if current_pose and final_waypoints available</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\feat_proj.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\feat_proj.cpp" added_lines="2" deleted_lines="1">
				<diff>@@ -305,6 +305,7 @@ void echoSignals2(ros::Publisher &amp;pub, bool useOpenGLCoord = false)
 
 				vmap.signals.insert(std::map&lt;int, Signal&gt;::value_type(signal.id, signal));
 			}
+			ROS_INFO("[feat_proj] VectorMapServer available. Publishing only TrafficSignals on the current lane");
 		}
 	}
 
@@ -384,7 +385,7 @@ int main(int argc, char *argv[])
 
 	/* Get Flag wheter vecter_map_server function will be used  */
 	private_nh.param&lt;bool&gt;("use_path_info", g_use_vector_map_server, false);
-
+	ROS_INFO("[feat_proj] Use VectorMapServer: %d", g_use_vector_map_server);
 	/* load vector map */
 	ros::Subscriber sub_point = rosnode.subscribe("vector_map_info/point",
 	                                              SUBSCRIBE_QUEUE_SIZE,
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\TrafficLight.h" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\TrafficLight.h" added_lines="1" deleted_lines="1">
				<diff>@@ -17,7 +17,7 @@
 void setContexts(TrafficLightDetector &amp;detector, const autoware_msgs::Signals::ConstPtr&amp; extractedPos);
 
 #define MINIMAM_RADIUS 3
-#define ROI_MARGINE 20
+#define ROI_MARGINE 25
 
 static inline bool IsNearlyZero(double x)
 {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\TrafficLightDetector.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\TrafficLightDetector.cpp" added_lines="9" deleted_lines="5">
				<diff>@@ -11,7 +11,7 @@ struct regionCandidate {
   bool   isBlacked;
 };
 
-#define SHOW_DEBUG_INFO
+//#define SHOW_DEBUG_INFO
 extern thresholdSet thSet;      // declared in traffic_light_lkf.cpp
 
 /*
@@ -153,7 +153,8 @@ static bool checkExtinctionLight(const cv::Mat&amp;  src_img,
 static cv::Mat signalDetect_inROI(const cv::Mat&amp; roi,
                                   const cv::Mat&amp;     src_img,
                                   const double       estimatedRadius,
-                                  const cv::Point roi_topLeft
+                                  const cv::Point roi_topLeft,
+                                  bool in_turn_signal //if true it will not try to mask by using "circularity""
                                   )
 {
   /* reduce noise */
@@ -253,7 +254,7 @@ static cv::Mat signalDetect_inROI(const cv::Mat&amp; roi,
   // std::cerr &lt;&lt; "before checkExtrinctionLight. candidates: " &lt;&lt; candidates_num &lt;&lt; std::endl;
 
   /* decrease candidates by checking existence of turned off light in their neighborhood */
-  if (candidates_num &gt; 1)    /* if there are multipule candidates */
+  if (!in_turn_signal &amp;&amp; candidates_num &gt; 1)    /* if there are multipule candidates */
     {
       for (unsigned int i=0; i&lt;candidates.size(); i++)
         {
@@ -298,7 +299,7 @@ static cv::Mat signalDetect_inROI(const cv::Mat&amp; roi,
   // std::cerr &lt;&lt; "after checkExtrinctionLight. candidates: " &lt;&lt; candidates_num &lt;&lt; std::endl;
 
   /* choose one candidate by comparing degree of circularity */
-  if (candidates_num &gt; 1)       /* if there are still multiple candidates */
+  if (!in_turn_signal &amp;&amp; candidates_num &gt; 1)       /* if there are still multiple candidates */
     {
       double min_diff = DBL_MAX;
       unsigned int min_idx = 0;
@@ -387,7 +388,10 @@ void TrafficLightDetector::brightnessDetect(const cv::Mat &amp;input) {
     cvtColor(roi, roi_HSV, CV_BGR2HSV);
 
     /* search the place where traffic signals seem to be */
-    cv::Mat    signalMask    = signalDetect_inROI(roi_HSV, input.clone(), context.lampRadius, context.topLeft);
+    cv::Mat    signalMask    = signalDetect_inROI(roi_HSV, input.clone(),
+                                                  context.lampRadius,
+                                                  context.topLeft,
+                                                  context.leftTurnSignal || context.rightTurnSignal);
 
     /* detect which color is dominant */
     cv::Mat extracted_HSV;
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\region_tlr.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\region_tlr.cpp" added_lines="411" deleted_lines="364">
				<diff>@@ -1,19 +1,24 @@
 #include &lt;vector&gt;
-#include &lt;ros/ros.h&gt;
-#include &lt;cv_bridge/cv_bridge.h&gt;
-#include &lt;sensor_msgs/Image.h&gt;
-#include &lt;sensor_msgs/image_encodings.h&gt;
-#include "TrafficLight.h"
 #include &lt;float.h&gt;
 #include &lt;math.h&gt;
 #include &lt;sstream&gt;
+#include &lt;ros/ros.h&gt;
+#include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;std_msgs/String.h&gt;
+#include &lt;std_msgs/Bool.h&gt;
+#include &lt;geometry_msgs/Pose.h&gt;
+#include &lt;geometry_msgs/PoseStamped.h&gt;
+#include &lt;sensor_msgs/Image.h&gt;
+#include &lt;sensor_msgs/image_encodings.h&gt;
+#include &lt;visualization_msgs/Marker.h&gt;
+#include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;autoware_msgs/traffic_light.h&gt;
 #include &lt;autoware_msgs/Signals.h&gt;
 #include &lt;autoware_msgs/TunedResult.h&gt;
-#include &lt;visualization_msgs/Marker.h&gt;
-#include &lt;visualization_msgs/MarkerArray.h&gt;
-#include &lt;std_msgs/Bool.h&gt;
+#include &lt;autoware_msgs/TrafficLightResultArray.h&gt;
+#include &lt;autoware_msgs/TrafficLightResult.h&gt;
+
+#include "TrafficLight.h"
 
 thresholdSet thSet;
 
@@ -21,424 +26,466 @@ static ros::Publisher signalState_pub;
 static ros::Publisher signalStateString_pub;
 static ros::Publisher marker_pub;
 static ros::Publisher superimpose_image_pub;
+static ros::Publisher signal_state_array_publisher_;
 static constexpr int32_t ADVERTISE_QUEUE_SIZE = 10;
-static constexpr bool    ADVERTISE_LATCH      = true;
-static uint32_t          shape                = visualization_msgs::Marker::SPHERE;
+static constexpr bool ADVERTISE_LATCH = true;
+static uint32_t shape = visualization_msgs::Marker::SPHERE;
 
 // Variables
 static TrafficLightDetector detector;
 
 static cv::Mat frame;
 
-static bool              show_superimpose_result = false;
-static const std::string window_name             = "superimpose result";
+static bool show_superimpose_result = false;
+static const std::string window_name = "superimpose result";
 
 static double cvtInt2Double_hue(int center, int range)
 {
-  /* convert value range from OpenCV to Definition */
-  double converted = (center + range) * 2.0f;
-
-  if (converted &lt; 0) {
-    converted = 0.0f;
-  } else if (360 &lt; converted) {
-    converted = converted - 360.0f;
-  }
-
-  return converted;
+	/* convert value range from OpenCV to Definition */
+	double converted = (center + range) * 2.0f;
+
+	if (converted &lt; 0)
+	{
+		converted = 0.0f;
+	} else if (360 &lt; converted)
+	{
+		converted = converted - 360.0f;
+	}
+
+	return converted;
 } /* static double cvtInt2Double_hue() */
 
 
 static double cvtInt2Double_sat(int center, int range)
 {
-  /* convert value range from OpenCV to Definition */
-  double converted = (center + range) / 255.0f;
-  if (converted &lt; 0) {
-    converted = 0.0f;
-  } else if (1.0f &lt; converted) {
-    converted = 1.0f;
-  }
-
-  return converted;
+	/* convert value range from OpenCV to Definition */
+	double converted = (center + range) / 255.0f;
+	if (converted &lt; 0)
+	{
+		converted = 0.0f;
+	} else if (1.0f &lt; converted)
+	{
+		converted = 1.0f;
+	}
+
+	return converted;
 } /* static double cvtInt2Double_sat() */
 
 
 static double cvtInt2Double_val(int center, int range)
 {
-  /* convert value range from OpenCV to Definition */
-  double converted = (center + range) / 255.0f;
-  if (converted &lt; 0) {
-    converted = 0;
-  } else if (1.0f &lt; converted) {
-    converted = 1.0f;
-  }
-
-  return converted;
+	/* convert value range from OpenCV to Definition */
+	double converted = (center + range) / 255.0f;
+	if (converted &lt; 0)
+	{
+		converted = 0;
+	} else if (1.0f &lt; converted)
+	{
+		converted = 1.0f;
+	}
+
+	return converted;
 } /* static double cvtInt2Double_val() */
 
 
 static void putResult_inText(cv::Mat *image, const std::vector&lt;Context&gt; &amp;contexts)
 {
-  std::string label;
-  const int fontFace = cv::FONT_HERSHEY_COMPLEX_SMALL;
-  const float fontScale = 1.0f;
-  const int fontThickness = 1;
-  int baseline = 0;
-  CvPoint textOrg;
-  CvScalar textColor;
-
-  for (unsigned int i=0; i&lt;contexts.size(); i++)
-    {
-      Context ctx = contexts.at(i);
+	std::string label;
+	const int fontFace = cv::FONT_HERSHEY_COMPLEX_SMALL;
+	const float fontScale = 1.0f;
+	const int fontThickness = 1;
+	int baseline = 0;
+	CvPoint textOrg;
+	CvScalar textColor;
+
+	for (unsigned int i = 0; i &lt; contexts.size(); i++)
+	{
+		Context ctx = contexts.at(i);
 //      if (ctx.lampRadius &lt; MINIMAM_RADIUS)
 //        continue;
 
-      switch(ctx.lightState) {
-      case GREEN:
-        label = "GREEN";
-        textColor = CV_RGB(0, 255, 0);
-        break;
-      case YELLOW:
-        label = "YELLOW";
-        textColor = CV_RGB(255, 255, 0);
-        break;
-      case RED:
-        label = "RED";
-        textColor = CV_RGB(255, 0, 0);
-        break;
-      case UNDEFINED:
-        label = "UNDEFINED";
-        textColor = CV_RGB(0, 0, 0);
-      }
-      if (ctx.leftTurnSignal)
-        {label+=" LEFT";}
-      if (ctx.rightTurnSignal)
-        {label+=" RIGHT";}
-
-      cv::getTextSize(label,
-		      fontFace,
-		      fontScale,
-		      fontThickness,
-		      &amp;baseline);
-
-      textOrg = cv::Point(ctx.topLeft.x, ctx.botRight.y + baseline);
-
-      putText(*image,
-              label,
-              textOrg,
-              fontFace,
-              fontScale,
-              textColor,
-              fontThickness,
-              CV_AA);
-    }
+		switch (ctx.lightState)
+		{
+			case GREEN:
+				label = "GREEN";
+				textColor = CV_RGB(0, 255, 0);
+				break;
+			case YELLOW:
+				label = "YELLOW";
+				textColor = CV_RGB(255, 255, 0);
+				break;
+			case RED:
+				label = "RED";
+				textColor = CV_RGB(255, 0, 0);
+				break;
+			case UNDEFINED:
+				label = "UNDEFINED";
+				textColor = CV_RGB(0, 0, 0);
+		}
+		if (ctx.leftTurnSignal)
+		{
+			label += " LEFT";
+		}
+		if (ctx.rightTurnSignal)
+		{
+			label += " RIGHT";
+		}
+
+		cv::getTextSize(label,
+		                fontFace,
+		                fontScale,
+		                fontThickness,
+		                &amp;baseline);
+
+		textOrg = cv::Point(ctx.topLeft.x, ctx.botRight.y + baseline);
+
+		putText(*image,
+		        label,
+		        textOrg,
+		        fontFace,
+		        fontScale,
+		        textColor,
+		        fontThickness,
+		        CV_AA);
+	}
 } /* static void putResult_inText() */
 
 
-static void image_raw_cb(const sensor_msgs::Image&amp; image_source)
+static void image_raw_cb(const sensor_msgs::Image &amp;image_source)
 {
-  cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_source, sensor_msgs::image_encodings::BGR8);
-  //  cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_source);
-  frame = cv_image-&gt;image.clone();
-
-  /* Draw superimpose result on image */
-  cv::Mat targetScope = frame.clone();
-  for (unsigned int i=0; i&lt;detector.contexts.size(); i++)
-    {
-      /* draw superimposed position of traffic lights */
-      circle(targetScope, detector.contexts.at(i).redCenter, detector.contexts.at(i).lampRadius, CV_RGB(255, 0, 0), 1, 0);
-      circle(targetScope, detector.contexts.at(i).yellowCenter, detector.contexts.at(i).lampRadius, CV_RGB(255, 255, 0), 1, 0);
-      circle(targetScope, detector.contexts.at(i).greenCenter, detector.contexts.at(i).lampRadius, CV_RGB(0, 255, 0), 1, 0);
-    }
-
-  /* draw detection results */
-  putResult_inText(&amp;targetScope, detector.contexts);
-
-
-  /* Publish superimpose result image */
-  cv_bridge::CvImage msg_converter;
-  msg_converter.header = image_source.header;
-  msg_converter.encoding = sensor_msgs::image_encodings::BGR8;
-  msg_converter.image = targetScope;
-  superimpose_image_pub.publish(msg_converter.toImageMsg());
-
-  /* Display superimpose result image in separate window*/
-  if (show_superimpose_result)
-    {
-      if (cvGetWindowHandle(window_name.c_str()) != NULL) // Guard not to write destroyed window by using close button on the window
-        {
-          imshow(window_name, targetScope);
-          cv::waitKey(5);
-        }
-    }
+	cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_source, sensor_msgs::image_encodings::BGR8);
+	//  cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_source);
+	frame = cv_image-&gt;image.clone();
+
+	/* Draw superimpose result on image */
+	cv::Mat targetScope = frame.clone();
+	for (unsigned int i = 0; i &lt; detector.contexts.size(); i++)
+	{
+		/* draw superimposed position of traffic lights */
+		circle(targetScope, detector.contexts.at(i).redCenter, detector.contexts.at(i).lampRadius, CV_RGB(255, 0, 0), 1,
+		       0);
+		circle(targetScope, detector.contexts.at(i).yellowCenter, detector.contexts.at(i).lampRadius,
+		       CV_RGB(255, 255, 0), 1, 0);
+		circle(targetScope, detector.contexts.at(i).greenCenter, detector.contexts.at(i).lampRadius, CV_RGB(0, 255, 0),
+		       1, 0);
+	}
+
+	/* draw detection results */
+	putResult_inText(&amp;targetScope, detector.contexts);
+
+
+	/* Publish superimpose result image */
+	cv_bridge::CvImage msg_converter;
+	msg_converter.header = image_source.header;
+	msg_converter.encoding = sensor_msgs::image_encodings::BGR8;
+	msg_converter.image = targetScope;
+	superimpose_image_pub.publish(msg_converter.toImageMsg());
+
+	/* Display superimpose result image in separate window*/
+	if (show_superimpose_result)
+	{
+		if (cvGetWindowHandle(window_name.c_str()) !=
+		    NULL) // Guard not to write destroyed window by using close button on the window
+		{
+			imshow(window_name, targetScope);
+			cv::waitKey(5);
+		}
+	}
 
 } /* static void image_raw_cb() */
 
 
-static void extractedPos_cb(const autoware_msgs::Signals::ConstPtr&amp; extractedPos)
+static void extractedPos_cb(const autoware_msgs::Signals::ConstPtr &amp;extractedPos)
 {
-  if (frame.empty())
-    return;
-
-  /* Set subscribed signal position into detector */
-  Context::SetContexts(detector.contexts, extractedPos, frame.rows, frame.cols);
-
-  detector.brightnessDetect(frame);
-
-  /* publish result */
-  autoware_msgs::traffic_light state_msg;
-  std_msgs::String state_string_msg;
-  const int32_t TRAFFIC_LIGHT_RED     = 0;
-  const int32_t TRAFFIC_LIGHT_GREEN   = 1;
-  const int32_t TRAFFIC_LIGHT_UNKNOWN = 2;
-  static int32_t prev_state = TRAFFIC_LIGHT_UNKNOWN;
-  state_msg.traffic_light = TRAFFIC_LIGHT_UNKNOWN;
-  for (unsigned int i=0; i&lt;detector.contexts.size(); i++) {
-	  switch (detector.contexts.at(i).lightState) {
-	  case GREEN:
-		  state_msg.traffic_light = TRAFFIC_LIGHT_GREEN;
-          state_string_msg.data = "green signal";
-		  break;
-	  case YELLOW:
-	  case RED:
-		  state_msg.traffic_light = TRAFFIC_LIGHT_RED;
-          state_string_msg.data = "red signal";
-		  break;
-	  case UNDEFINED:
-		  state_msg.traffic_light = TRAFFIC_LIGHT_UNKNOWN;
-          state_string_msg.data = "";
-		  break;
-	  }
-	  if (state_msg.traffic_light != TRAFFIC_LIGHT_UNKNOWN)
-		  break;  // publish the first state in detector.contexts
-  }
-
-  if (state_msg.traffic_light != prev_state) {
-    signalState_pub.publish(state_msg);
-    signalStateString_pub.publish(state_string_msg);
-  } else {
-    state_string_msg.data = "";
-    signalStateString_pub.publish(state_string_msg);
-  }
-
-  std_msgs::ColorRGBA color_black;
-  color_black.r = 0.0f;
-  color_black.g = 0.0f;
-  color_black.b = 0.0f;
-  color_black.a = 1.0f;
-
-  std_msgs::ColorRGBA color_red;
-  color_red.r = 1.0f;
-  color_red.g = 0.0f;
-  color_red.b = 0.0f;
-  color_red.a = 1.0f;
-
-  std_msgs::ColorRGBA color_yellow;
-  color_yellow.r = 1.0f;
-  color_yellow.g = 1.0f;
-  color_yellow.b = 0.0f;
-  color_yellow.a = 1.0f;
-
-  std_msgs::ColorRGBA color_green;
-  color_green.r = 0.0f;
-  color_green.g = 1.0f;
-  color_green.b = 0.0f;
-  color_green.a = 1.0f;
-
-  /* publish all detected result as ROS Marker */
-  for (unsigned int i=0; i&lt;detector.contexts.size(); i++)
-    {
-      Context ctx = detector.contexts.at(i);
-      visualization_msgs::MarkerArray signalSet;
-      visualization_msgs::Marker mk_red, mk_yellow, mk_green;
-
-      /* Set the frame ID */
-      mk_red.header.frame_id    = "map";
-      mk_yellow.header.frame_id = "map";
-      mk_green.header.frame_id  = "map";
-
-      /* Set the namespace and id for this marker */
-      mk_red.ns    = "tlr_result_red";
-      mk_yellow.ns = "tlr_result_yellow";
-      mk_green.ns  = "tlr_result_green";
-      mk_red.id    = ctx.signalID;
-      mk_yellow.id = ctx.signalID;
-      mk_green.id  = ctx.signalID;
-
-      /* Set the marker type */
-      mk_red.type    = shape;
-      mk_yellow.type = shape;
-      mk_green.type  = shape;
-
-      /* Set the pose of the marker */
-      mk_red.pose.position.x    = ctx.redCenter3d.x;
-      mk_red.pose.position.y    = ctx.redCenter3d.y;
-      mk_red.pose.position.z    = ctx.redCenter3d.z;
-      mk_yellow.pose.position.x = ctx.yellowCenter3d.x;
-      mk_yellow.pose.position.y = ctx.yellowCenter3d.y;
-      mk_yellow.pose.position.z = ctx.yellowCenter3d.z;
-      mk_green.pose.position.x  = ctx.greenCenter3d.x;
-      mk_green.pose.position.y  = ctx.greenCenter3d.y;
-      mk_green.pose.position.z  = ctx.greenCenter3d.z;
-
-      mk_red.pose.orientation.x    = 0.0;
-      mk_red.pose.orientation.y    = 0.0;
-      mk_red.pose.orientation.y    = 0.0;
-      mk_red.pose.orientation.w    = 0.0;
-      mk_yellow.pose.orientation.x = 0.0;
-      mk_yellow.pose.orientation.y = 0.0;
-      mk_yellow.pose.orientation.y = 0.0;
-      mk_yellow.pose.orientation.w = 0.0;
-      mk_green.pose.orientation.x  = 0.0;
-      mk_green.pose.orientation.y  = 0.0;
-      mk_green.pose.orientation.y  = 0.0;
-      mk_green.pose.orientation.w  = 0.0;
-
-      /* Set the scale of the marker -- We assume lamp radius as 30cm */
-      mk_red.scale.x    = (double)0.3;
-      mk_red.scale.y    = (double)0.3;
-      mk_red.scale.z    = (double)0.3;
-      mk_yellow.scale.x = (double)0.3;
-      mk_yellow.scale.y = (double)0.3;
-      mk_yellow.scale.z = (double)0.3;
-      mk_green.scale.x  = (double)0.3;
-      mk_green.scale.y  = (double)0.3;
-      mk_green.scale.z  = (double)0.3;
-
-      /* Set the color */
-      switch (ctx.lightState) {
-      case GREEN:
-        mk_red.color    = color_black;
-        mk_yellow.color = color_black;
-        mk_green.color  = color_green;
-        break;
-      case YELLOW:
-        mk_red.color    = color_black;
-        mk_yellow.color = color_yellow;
-        mk_green.color  = color_black;
-        break;
-      case RED:
-        mk_red.color    = color_red;
-        mk_yellow.color = color_black;
-        mk_green.color  = color_black;
-        break;
-      case UNDEFINED:
-        mk_red.color    = color_black;
-        mk_yellow.color = color_black;
-        mk_green.color  = color_black;
-        break;
-      }
-
-      mk_red.lifetime    = ros::Duration(0.1);
-      mk_yellow.lifetime = ros::Duration(0.1);
-      mk_green.lifetime  = ros::Duration(0.1);
-
-      signalSet.markers.push_back(mk_red);
-      signalSet.markers.push_back(mk_yellow);
-      signalSet.markers.push_back(mk_green);
-
-      marker_pub.publish(signalSet);
-    }
-
-  prev_state = state_msg.traffic_light;
+	if (frame.empty())
+		return;
+
+	/* Set subscribed signal position into detector */
+	Context::SetContexts(detector.contexts, extractedPos, frame.rows, frame.cols);
+
+	detector.brightnessDetect(frame);
+
+	/* publish result */
+	autoware_msgs::traffic_light state_msg;
+	autoware_msgs::TrafficLightResultArray tlr_result_array_msg;
+	tlr_result_array_msg.header = extractedPos-&gt;header;
+
+	std_msgs::String state_string_msg;
+	const int32_t TRAFFIC_LIGHT_RED = 0;
+	const int32_t TRAFFIC_LIGHT_GREEN = 1;
+	const int32_t TRAFFIC_LIGHT_UNKNOWN = 2;
+	static int32_t prev_state = TRAFFIC_LIGHT_UNKNOWN;
+	state_msg.traffic_light = TRAFFIC_LIGHT_UNKNOWN;
+
+	for (unsigned int i = 0; i &lt; detector.contexts.size(); i++)
+	{
+		Context current_context = detector.contexts.at(i);
+		switch (current_context.lightState)
+		{
+			case GREEN:
+				state_msg.traffic_light = TRAFFIC_LIGHT_GREEN;
+				state_string_msg.data = "green signal";
+				break;
+			case YELLOW:
+			case RED:
+				state_msg.traffic_light = TRAFFIC_LIGHT_RED;
+				state_string_msg.data = "red signal";
+				break;
+			case UNDEFINED:
+				state_msg.traffic_light = TRAFFIC_LIGHT_UNKNOWN;
+				state_string_msg.data = "";
+				break;
+		}
+
+		if (state_msg.traffic_light != TRAFFIC_LIGHT_UNKNOWN)
+			break;  // publish the first state in detector.contexts
+
+		autoware_msgs::TrafficLightResult tlr_result_msg;
+		tlr_result_msg.recognition_result = state_msg.traffic_light;
+		tlr_result_msg.recognition_result_str = state_string_msg.data;
+		tlr_result_msg.light_id = current_context.signalID;
+		tlr_result_msg.lane_id = current_context.closestLaneId;
+
+		tlr_result_array_msg.results.push_back(tlr_result_msg);
+	}
+
+	signal_state_array_publisher_.publish(tlr_result_array_msg);
+
+	if (state_msg.traffic_light != prev_state)
+	{
+		signalState_pub.publish(state_msg);
+		signalStateString_pub.publish(state_string_msg);
+	} else
+	{
+		state_string_msg.data = "";
+		signalStateString_pub.publish(state_string_msg);
+	}
+
+	std_msgs::ColorRGBA color_black;
+	color_black.r = 0.0f;
+	color_black.g = 0.0f;
+	color_black.b = 0.0f;
+	color_black.a = 1.0f;
+
+	std_msgs::ColorRGBA color_red;
+	color_red.r = 1.0f;
+	color_red.g = 0.0f;
+	color_red.b = 0.0f;
+	color_red.a = 1.0f;
+
+	std_msgs::ColorRGBA color_yellow;
+	color_yellow.r = 1.0f;
+	color_yellow.g = 1.0f;
+	color_yellow.b = 0.0f;
+	color_yellow.a = 1.0f;
+
+	std_msgs::ColorRGBA color_green;
+	color_green.r = 0.0f;
+	color_green.g = 1.0f;
+	color_green.b = 0.0f;
+	color_green.a = 1.0f;
+
+	/* publish all detected result as ROS Marker */
+	for (unsigned int i = 0; i &lt; detector.contexts.size(); i++)
+	{
+		Context ctx = detector.contexts.at(i);
+		visualization_msgs::MarkerArray signalSet;
+		visualization_msgs::Marker mk_red, mk_yellow, mk_green;
+
+		/* Set the frame ID */
+		mk_red.header.frame_id = "map";
+		mk_yellow.header.frame_id = "map";
+		mk_green.header.frame_id = "map";
+
+		/* Set the namespace and id for this marker */
+		mk_red.ns = "tlr_result_red";
+		mk_yellow.ns = "tlr_result_yellow";
+		mk_green.ns = "tlr_result_green";
+		mk_red.id = ctx.signalID;
+		mk_yellow.id = ctx.signalID;
+		mk_green.id = ctx.signalID;
+
+		/* Set the marker type */
+		mk_red.type = shape;
+		mk_yellow.type = shape;
+		mk_green.type = shape;
+
+		/* Set the pose of the marker */
+		mk_red.pose.position.x = ctx.redCenter3d.x;
+		mk_red.pose.position.y = ctx.redCenter3d.y;
+		mk_red.pose.position.z = ctx.redCenter3d.z;
+		mk_yellow.pose.position.x = ctx.yellowCenter3d.x;
+		mk_yellow.pose.position.y = ctx.yellowCenter3d.y;
+		mk_yellow.pose.position.z = ctx.yellowCenter3d.z;
+		mk_green.pose.position.x = ctx.greenCenter3d.x;
+		mk_green.pose.position.y = ctx.greenCenter3d.y;
+		mk_green.pose.position.z = ctx.greenCenter3d.z;
+
+		mk_red.pose.orientation.x = 0.0;
+		mk_red.pose.orientation.y = 0.0;
+		mk_red.pose.orientation.y = 0.0;
+		mk_red.pose.orientation.w = 0.0;
+		mk_yellow.pose.orientation.x = 0.0;
+		mk_yellow.pose.orientation.y = 0.0;
+		mk_yellow.pose.orientation.y = 0.0;
+		mk_yellow.pose.orientation.w = 0.0;
+		mk_green.pose.orientation.x = 0.0;
+		mk_green.pose.orientation.y = 0.0;
+		mk_green.pose.orientation.y = 0.0;
+		mk_green.pose.orientation.w = 0.0;
+
+		/* Set the scale of the marker -- We assume lamp radius as 30cm */
+		mk_red.scale.x = (double) 0.3;
+		mk_red.scale.y = (double) 0.3;
+		mk_red.scale.z = (double) 0.3;
+		mk_yellow.scale.x = (double) 0.3;
+		mk_yellow.scale.y = (double) 0.3;
+		mk_yellow.scale.z = (double) 0.3;
+		mk_green.scale.x = (double) 0.3;
+		mk_green.scale.y = (double) 0.3;
+		mk_green.scale.z = (double) 0.3;
+
+		/* Set the color */
+		switch (ctx.lightState)
+		{
+			case GREEN:
+				mk_red.color = color_black;
+				mk_yellow.color = color_black;
+				mk_green.color = color_green;
+				break;
+			case YELLOW:
+				mk_red.color = color_black;
+				mk_yellow.color = color_yellow;
+				mk_green.color = color_black;
+				break;
+			case RED:
+				mk_red.color = color_red;
+				mk_yellow.color = color_black;
+				mk_green.color = color_black;
+				break;
+			case UNDEFINED:
+				mk_red.color = color_black;
+				mk_yellow.color = color_black;
+				mk_green.color = color_black;
+				break;
+		}
+
+		mk_red.lifetime = ros::Duration(0.1);
+		mk_yellow.lifetime = ros::Duration(0.1);
+		mk_green.lifetime = ros::Duration(0.1);
+
+		signalSet.markers.push_back(mk_red);
+		signalSet.markers.push_back(mk_yellow);
+		signalSet.markers.push_back(mk_green);
+
+		marker_pub.publish(signalSet);
+	}
+
+	prev_state = state_msg.traffic_light;
 } /* static void extractedPos_cb() */
 
 
-static void tunedResult_cb(const autoware_msgs::TunedResult&amp; msg)
+static void tunedResult_cb(const autoware_msgs::TunedResult &amp;msg)
 {
-  thSet.Red.Hue.upper = cvtInt2Double_hue(msg.Red.Hue.center, msg.Red.Hue.range);
-  thSet.Red.Hue.lower = cvtInt2Double_hue(msg.Red.Hue.center, -msg.Red.Hue.range);
-  thSet.Red.Sat.upper = cvtInt2Double_sat(msg.Red.Sat.center, msg.Red.Sat.range);
-  thSet.Red.Sat.lower = cvtInt2Double_sat(msg.Red.Sat.center, -msg.Red.Sat.range);
-  thSet.Red.Val.upper = cvtInt2Double_val(msg.Red.Val.center, msg.Red.Val.range);
-  thSet.Red.Val.lower = cvtInt2Double_val(msg.Red.Val.center, -msg.Red.Val.range);
-
-  thSet.Yellow.Hue.upper = cvtInt2Double_hue(msg.Yellow.Hue.center, msg.Yellow.Hue.range);
-  thSet.Yellow.Hue.lower = cvtInt2Double_hue(msg.Yellow.Hue.center, -msg.Yellow.Hue.range);
-  thSet.Yellow.Sat.upper = cvtInt2Double_sat(msg.Yellow.Sat.center, msg.Yellow.Sat.range);
-  thSet.Yellow.Sat.lower = cvtInt2Double_sat(msg.Yellow.Sat.center, -msg.Yellow.Sat.range);
-  thSet.Yellow.Val.upper = cvtInt2Double_val(msg.Yellow.Val.center, msg.Yellow.Val.range);
-  thSet.Yellow.Val.lower = cvtInt2Double_val(msg.Yellow.Val.center, -msg.Yellow.Val.range);
-
-  thSet.Green.Hue.upper = cvtInt2Double_hue(msg.Green.Hue.center, msg.Green.Hue.range);
-  thSet.Green.Hue.lower = cvtInt2Double_hue(msg.Green.Hue.center, -msg.Green.Hue.range);
-  thSet.Green.Sat.upper = cvtInt2Double_sat(msg.Green.Sat.center, msg.Green.Sat.range);
-  thSet.Green.Sat.lower = cvtInt2Double_sat(msg.Green.Sat.center, -msg.Green.Sat.range);
-  thSet.Green.Val.upper = cvtInt2Double_val(msg.Green.Val.center, msg.Green.Val.range);
-  thSet.Green.Val.lower = cvtInt2Double_val(msg.Green.Val.center, -msg.Green.Val.range);
+	thSet.Red.Hue.upper = cvtInt2Double_hue(msg.Red.Hue.center, msg.Red.Hue.range);
+	thSet.Red.Hue.lower = cvtInt2Double_hue(msg.Red.Hue.center, -msg.Red.Hue.range);
+	thSet.Red.Sat.upper = cvtInt2Double_sat(msg.Red.Sat.center, msg.Red.Sat.range);
+	thSet.Red.Sat.lower = cvtInt2Double_sat(msg.Red.Sat.center, -msg.Red.Sat.range);
+	thSet.Red.Val.upper = cvtInt2Double_val(msg.Red.Val.center, msg.Red.Val.range);
+	thSet.Red.Val.lower = cvtInt2Double_val(msg.Red.Val.center, -msg.Red.Val.range);
+
+	thSet.Yellow.Hue.upper = cvtInt2Double_hue(msg.Yellow.Hue.center, msg.Yellow.Hue.range);
+	thSet.Yellow.Hue.lower = cvtInt2Double_hue(msg.Yellow.Hue.center, -msg.Yellow.Hue.range);
+	thSet.Yellow.Sat.upper = cvtInt2Double_sat(msg.Yellow.Sat.center, msg.Yellow.Sat.range);
+	thSet.Yellow.Sat.lower = cvtInt2Double_sat(msg.Yellow.Sat.center, -msg.Yellow.Sat.range);
+	thSet.Yellow.Val.upper = cvtInt2Double_val(msg.Yellow.Val.center, msg.Yellow.Val.range);
+	thSet.Yellow.Val.lower = cvtInt2Double_val(msg.Yellow.Val.center, -msg.Yellow.Val.range);
+
+	thSet.Green.Hue.upper = cvtInt2Double_hue(msg.Green.Hue.center, msg.Green.Hue.range);
+	thSet.Green.Hue.lower = cvtInt2Double_hue(msg.Green.Hue.center, -msg.Green.Hue.range);
+	thSet.Green.Sat.upper = cvtInt2Double_sat(msg.Green.Sat.center, msg.Green.Sat.range);
+	thSet.Green.Sat.lower = cvtInt2Double_sat(msg.Green.Sat.center, -msg.Green.Sat.range);
+	thSet.Green.Val.upper = cvtInt2Double_val(msg.Green.Val.center, msg.Green.Val.range);
+	thSet.Green.Val.lower = cvtInt2Double_val(msg.Green.Val.center, -msg.Green.Val.range);
 
 } /* static void tunedResult_cb() */
 
 
-static void superimpose_cb(const std_msgs::Bool::ConstPtr&amp; config_msg)
+static void superimpose_cb(const std_msgs::Bool::ConstPtr &amp;config_msg)
 {
-  show_superimpose_result = config_msg-&gt;data;
-
-  if (show_superimpose_result) {
-    cv::namedWindow(window_name, cv::WINDOW_NORMAL);
-    cv::startWindowThread();
-  }
-
-  if (!show_superimpose_result) {
-	  if (cvGetWindowHandle(window_name.c_str()) != NULL)
-	  {
-		  cv::destroyWindow(window_name);
-		  cv::waitKey(1);
-	  }
-  }
+	show_superimpose_result = config_msg-&gt;data;
+
+	if (show_superimpose_result)
+	{
+		cv::namedWindow(window_name, cv::WINDOW_NORMAL);
+		cv::startWindowThread();
+	}
+
+	if (!show_superimpose_result)
+	{
+		if (cvGetWindowHandle(window_name.c_str()) != NULL)
+		{
+			cv::destroyWindow(window_name);
+			cv::waitKey(1);
+		}
+	}
 
 } /* static void superimpose_cb() */
 
-int main(int argc, char* argv[]) {
+int main(int argc, char *argv[])
+{
 
-  //	printf("***** Traffic lights app *****\n");
+	//	printf("***** Traffic lights app *****\n");
 #ifdef SHOW_DEBUG_INFO
-  cv::namedWindow("tmpImage", cv::WINDOW_NORMAL);
-  cv::namedWindow("bright_mask", cv::WINDOW_NORMAL);
-  cv::startWindowThread();
+	cv::namedWindow("tmpImage", cv::WINDOW_NORMAL);
+	cv::namedWindow("bright_mask", cv::WINDOW_NORMAL);
+	cv::startWindowThread();
 #endif
 
-  thSet.Red.Hue.upper = (double)DAYTIME_RED_UPPER;
-  thSet.Red.Hue.lower = (double)DAYTIME_RED_LOWER;
-  thSet.Red.Sat.upper = 1.0f;
-  thSet.Red.Sat.lower = DAYTIME_S_SIGNAL_THRESHOLD;
-  thSet.Red.Val.upper = 1.0f;
-  thSet.Red.Val.lower = DAYTIME_V_SIGNAL_THRESHOLD;
+	thSet.Red.Hue.upper = (double) DAYTIME_RED_UPPER;
+	thSet.Red.Hue.lower = (double) DAYTIME_RED_LOWER;
+	thSet.Red.Sat.upper = 1.0f;
+	thSet.Red.Sat.lower = DAYTIME_S_SIGNAL_THRESHOLD;
+	thSet.Red.Val.upper = 1.0f;
+	thSet.Red.Val.lower = DAYTIME_V_SIGNAL_THRESHOLD;
+
+	thSet.Yellow.Hue.upper = (double) DAYTIME_YELLOW_UPPER;
+	thSet.Yellow.Hue.lower = (double) DAYTIME_YELLOW_LOWER;
+	thSet.Yellow.Sat.upper = 1.0f;
+	thSet.Yellow.Sat.lower = DAYTIME_S_SIGNAL_THRESHOLD;
+	thSet.Yellow.Val.upper = 1.0f;
+	thSet.Yellow.Val.lower = DAYTIME_V_SIGNAL_THRESHOLD;
 
-  thSet.Yellow.Hue.upper = (double)DAYTIME_YELLOW_UPPER;
-  thSet.Yellow.Hue.lower = (double)DAYTIME_YELLOW_LOWER;
-  thSet.Yellow.Sat.upper = 1.0f;
-  thSet.Yellow.Sat.lower = DAYTIME_S_SIGNAL_THRESHOLD;
-  thSet.Yellow.Val.upper = 1.0f;
-  thSet.Yellow.Val.lower = DAYTIME_V_SIGNAL_THRESHOLD;
+	thSet.Green.Hue.upper = (double) DAYTIME_GREEN_UPPER;
+	thSet.Green.Hue.lower = (double) DAYTIME_GREEN_LOWER;
+	thSet.Green.Sat.upper = 1.0f;
+	thSet.Green.Sat.lower = DAYTIME_S_SIGNAL_THRESHOLD;
+	thSet.Green.Val.upper = 1.0f;
+	thSet.Green.Val.lower = DAYTIME_V_SIGNAL_THRESHOLD;
 
-  thSet.Green.Hue.upper = (double)DAYTIME_GREEN_UPPER;
-  thSet.Green.Hue.lower = (double)DAYTIME_GREEN_LOWER;
-  thSet.Green.Sat.upper = 1.0f;
-  thSet.Green.Sat.lower = DAYTIME_S_SIGNAL_THRESHOLD;
-  thSet.Green.Val.upper = 1.0f;
-  thSet.Green.Val.lower = DAYTIME_V_SIGNAL_THRESHOLD;
 
+	ros::init(argc, argv, "region_tlr");
 
-  ros::init(argc, argv, "region_tlr");
+	ros::NodeHandle n;
+	ros::NodeHandle private_nh("~");
+	std::string image_topic_name;
+	private_nh.param&lt;std::string&gt;("image_raw_topic", image_topic_name, "/image_raw");
 
-  ros::NodeHandle n;
-  ros::NodeHandle private_nh("~");
-  std::string image_topic_name;
-  private_nh.param&lt;std::string&gt;("image_raw_topic", image_topic_name, "/image_raw");
+	ros::Subscriber image_sub = n.subscribe(image_topic_name, 1, image_raw_cb);
+	ros::Subscriber position_sub = n.subscribe("/roi_signal", 1, extractedPos_cb);
+	ros::Subscriber tunedResult_sub = n.subscribe("/tuned_result", 1, tunedResult_cb);
+	ros::Subscriber superimpose_sub = n.subscribe("/config/superimpose", 1, superimpose_cb);
 
-  ros::Subscriber image_sub       = n.subscribe(image_topic_name, 1, image_raw_cb);
-  ros::Subscriber position_sub    = n.subscribe("/roi_signal", 1, extractedPos_cb);
-  ros::Subscriber tunedResult_sub = n.subscribe("/tuned_result", 1, tunedResult_cb);
-  ros::Subscriber superimpose_sub = n.subscribe("/config/superimpose", 1, superimpose_cb);
+	signalState_pub = n.advertise&lt;autoware_msgs::traffic_light&gt;("/light_color", ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
+	signalStateString_pub = n.advertise&lt;std_msgs::String&gt;("/sound_player", ADVERTISE_QUEUE_SIZE);
+	marker_pub = n.advertise&lt;visualization_msgs::MarkerArray&gt;("tlr_result", ADVERTISE_QUEUE_SIZE);
+	superimpose_image_pub = n.advertise&lt;sensor_msgs::Image&gt;("tlr_superimpose_image", ADVERTISE_QUEUE_SIZE);
 
-  signalState_pub       = n.advertise&lt;autoware_msgs::traffic_light&gt;("/light_color", ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
-  signalStateString_pub = n.advertise&lt;std_msgs::String&gt;("/sound_player", ADVERTISE_QUEUE_SIZE);
-  marker_pub            = n.advertise&lt;visualization_msgs::MarkerArray&gt;("tlr_result", ADVERTISE_QUEUE_SIZE);
-  superimpose_image_pub= n.advertise&lt;sensor_msgs::Image&gt;("tlr_superimpose_image", ADVERTISE_QUEUE_SIZE);
+	signal_state_array_publisher_ = n.advertise&lt;autoware_msgs::TrafficLightResultArray&gt;("tlr_result_array", ADVERTISE_QUEUE_SIZE);
 
-  ros::spin();
+	ros::spin();
 
-  return 0;
+	return 0;
 } /* int main() */
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_ssd\region_tlr_ssd.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr_ssd\region_tlr_ssd.cpp" added_lines="4" deleted_lines="4">
				<diff>@@ -78,7 +78,7 @@ void RegionTlrSsdRosNode::RoiSignalCallback(const autoware_msgs::Signals::ConstP
     std::cout &lt;&lt; "No Image" &lt;&lt; std::endl;
     return;
   }
-  std::cout &lt;&lt; "rois: " &lt;&lt; extracted_pos-&gt;Signals.size() &lt;&lt; std::endl;
+  //std::cout &lt;&lt; "rois: " &lt;&lt; extracted_pos-&gt;Signals.size() &lt;&lt; std::endl;
 
   // Acquire signal posotion on the image
   Context::SetContexts(contexts_, extracted_pos, frame_.rows, frame_.cols);
@@ -91,12 +91,12 @@ void RegionTlrSsdRosNode::RoiSignalCallback(const autoware_msgs::Signals::ConstP
       continue;
     }
 
-    std::cout &lt;&lt; "roi inside: " &lt;&lt; cv::Rect(context.topLeft, context.botRight) &lt;&lt; std::endl;
+    //std::cout &lt;&lt; "roi inside: " &lt;&lt; cv::Rect(context.topLeft, context.botRight) &lt;&lt; std::endl;
     // extract region of interest from input image
     cv::Mat roi  = frame_(cv::Rect(context.topLeft, context.botRight)).clone();
 
-    cv::imshow("ssd_tlr", roi);
-	  cv::waitKey(200);
+    //cv::imshow("ssd_tlr", roi);
+	//  cv::waitKey(200);
 
     // Get current state of traffic light from current frame
     LightState current_state = recognizer.RecognizeLightState(roi);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="cb8a59318fd02296eb0f4907d2947096702d1725" author="AMC">
		<msg>Changed the publishing time of all the signals</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\TrafficLight.h" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\TrafficLight.h" added_lines="4" deleted_lines="0">
				<diff>@@ -13,6 +13,10 @@
 #define MAIN_WINDOW_NAME "Main"
 #define SETTINGS_WINDOW_NAME "Settings"
 
+#define TLR_GREEN_SIGNAL_STR "green signal"
+#define TLR_RED_SIGNAL_STR "red signal"
+#define TLR_UNKNOWN_SIGNAL_STR ""
+
 /* Functions declarations */
 void setContexts(TrafficLightDetector &amp;detector, const autoware_msgs::Signals::ConstPtr&amp; extractedPos);
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\region_tlr.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\region_tlr\region_tlr.cpp" added_lines="29" deleted_lines="12">
				<diff>@@ -224,37 +224,29 @@ static void extractedPos_cb(const autoware_msgs::Signals::ConstPtr &amp;extractedPos
 		{
 			case GREEN:
 				state_msg.traffic_light = TRAFFIC_LIGHT_GREEN;
-				state_string_msg.data = "green signal";
+				state_string_msg.data = TLR_GREEN_SIGNAL_STR;
 				break;
 			case YELLOW:
 			case RED:
 				state_msg.traffic_light = TRAFFIC_LIGHT_RED;
-				state_string_msg.data = "red signal";
+				state_string_msg.data = TLR_RED_SIGNAL_STR;
 				break;
 			case UNDEFINED:
 				state_msg.traffic_light = TRAFFIC_LIGHT_UNKNOWN;
-				state_string_msg.data = "";
+				state_string_msg.data = TLR_UNKNOWN_SIGNAL_STR;
 				break;
 		}
 
 		if (state_msg.traffic_light != TRAFFIC_LIGHT_UNKNOWN)
 			break;  // publish the first state in detector.contexts
 
-		autoware_msgs::TrafficLightResult tlr_result_msg;
-		tlr_result_msg.recognition_result = state_msg.traffic_light;
-		tlr_result_msg.recognition_result_str = state_string_msg.data;
-		tlr_result_msg.light_id = current_context.signalID;
-		tlr_result_msg.lane_id = current_context.closestLaneId;
-
-		tlr_result_array_msg.results.push_back(tlr_result_msg);
 	}
 
-	signal_state_array_publisher_.publish(tlr_result_array_msg);
-
 	if (state_msg.traffic_light != prev_state)
 	{
 		signalState_pub.publish(state_msg);
 		signalStateString_pub.publish(state_string_msg);
+
 	} else
 	{
 		state_string_msg.data = "";
@@ -292,6 +284,30 @@ static void extractedPos_cb(const autoware_msgs::Signals::ConstPtr &amp;extractedPos
 		visualization_msgs::MarkerArray signalSet;
 		visualization_msgs::Marker mk_red, mk_yellow, mk_green;
 
+		autoware_msgs::TrafficLightResult tlr_result_msg;
+		tlr_result_msg.recognition_result_str = state_string_msg.data;
+		tlr_result_msg.light_id = ctx.signalID;
+		tlr_result_msg.lane_id = ctx.closestLaneId;
+
+		switch (ctx.lightState)
+		{
+			case GREEN:
+				tlr_result_msg.recognition_result = TRAFFIC_LIGHT_GREEN;
+				tlr_result_msg.recognition_result_str = TLR_GREEN_SIGNAL_STR;
+				break;
+			case YELLOW:
+			case RED:
+				tlr_result_msg.recognition_result = TRAFFIC_LIGHT_RED;
+				tlr_result_msg.recognition_result_str = TLR_RED_SIGNAL_STR;
+				break;
+			case UNDEFINED:
+				tlr_result_msg.recognition_result = TRAFFIC_LIGHT_UNKNOWN;
+				tlr_result_msg.recognition_result_str = TLR_UNKNOWN_SIGNAL_STR;
+				break;
+		}
+
+		tlr_result_array_msg.results.push_back(tlr_result_msg);
+
 		/* Set the frame ID */
 		mk_red.header.frame_id = "map";
 		mk_yellow.header.frame_id = "map";
@@ -380,6 +396,7 @@ static void extractedPos_cb(const autoware_msgs::Signals::ConstPtr &amp;extractedPos
 
 		marker_pub.publish(signalSet);
 	}
+	signal_state_array_publisher_.publish(tlr_result_array_msg);
 
 	prev_state = state_msg.traffic_light;
 } /* static void extractedPos_cb() */
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f8706b88ff7577a49f39cb97c0b3a7e04340283e" author="Yusuke FUJII">
		<msg>add new state for lanechange</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" added_lines="1" deleted_lines="0">
				<diff>@@ -58,6 +58,7 @@ public:
     StateStores[DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE] = DriveBehaviorTrafficLightGreenState::getInstance();
     StateStores[DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE] = DriveBehaviorObstacleAvoidanceState::getInstance();
     StateStores[DRIVE_BEHAVIOR_STOPLINE_PLAN_STATE] = DriveBehaviorStoplinePlanState::getInstance();
+    StateStores[DRIVE_BEHAVIOR_ACCEPT_LANECHANGE_STATE] = DriveBehaviorAcceptLanechangeState::getInstance();
     StateStores[MISSION_COMPLETE_STATE] = MissionCompleteState::getInstance();
     StateStores[EMERGENCY_STATE] = EmergencyState::getInstance();
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" added_lines="16" deleted_lines="0">
				<diff>@@ -157,6 +157,7 @@ private:
 public:
 };
 
+// Planning to change str state
 class DriveBehaviorLaneChangeLeftState : public State&lt;DriveBehaviorLaneChangeLeftState&gt;
 {
 private:
@@ -171,6 +172,7 @@ private:
 public:
 };
 
+// Planning to change str state
 class DriveBehaviorLaneChangeRightState : public State&lt;DriveBehaviorLaneChangeRightState&gt;
 {
 private:
@@ -238,6 +240,20 @@ private:
     StateKind = BEHAVIOR_STATE;
   }
 
+public:
+};
+
+class DriveBehaviorAcceptLanechangeState : public State&lt;DriveBehaviorAcceptLanechangeState&gt;
+{
+private:
+  friend class State&lt;DriveBehaviorAcceptLanechangeState&gt;;
+  DriveBehaviorAcceptLanechangeState(void)
+  {
+    StateName = "AcceptLaneChange";
+    StateNum = DRIVE_BEHAVIOR_ACCEPT_LANECHANGE_STATE;
+    StateKind = BEHAVIOR_STATE;
+  }
+
 public:
 };
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" added_lines="1" deleted_lines="0">
				<diff>@@ -32,6 +32,7 @@ enum StateFlags
   DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE = 1ULL &lt;&lt; 34,
   DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE = 1ULL &lt;&lt; 35,
   DRIVE_BEHAVIOR_STOPLINE_PLAN_STATE = 1ULL &lt;&lt; 36,
+  DRIVE_BEHAVIOR_ACCEPT_LANECHANGE_STATE = 1ULL &lt;&lt; 37,
   STATE_SUB_END = 1ULL &lt;&lt; 40,
   STATE_END = 1ULL &lt;&lt; 41,
 };
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -70,12 +70,12 @@ void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
 
 void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
 {
-  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
+  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT) &amp;&amp; ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_ACCEPT_LANECHANGE_STATE))
   {
     ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
     ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
   }
-  else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
+  else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT) &amp;&amp; ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_ACCEPT_LANECHANGE_STATE))
   {
     ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
     ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="97ca4a3c0ac2a06e7ec3322d2189c5d27d63a7a6" author="Yusuke FUJII">
		<msg>stop light_color publish every state update</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="6" deleted_lines="4">
				<diff>@@ -60,16 +60,18 @@ void DecisionMakerNode::setupStateCallback(void)
 
   // trraficlight
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
-                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE); });
+                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
+			 publishLightColor((int)state_machine::E_GREEN); });
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
-                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE); });
-
+		  [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
+		  publishLightColor((int)state_machine::E_RED); });
 
+#if 0
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
                              std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_RED));
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                              std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_GREEN));
-
+#endif
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                          [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE); });
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="961c3c4312ea775fa97ee6208cb7cf0fc18cef9e" author="Yusuke FUJII">
		<msg>fix a duplicate state update</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="12" deleted_lines="5">
				<diff>@@ -60,22 +60,29 @@ void DecisionMakerNode::setupStateCallback(void)
 
   // trraficlight
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
-                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
-			 publishLightColor((int)state_machine::E_GREEN); });
+                         [&amp;]() { 
+			 //debug
+			 fprintf(stderr,"[RED]callbackin\n");
+			 //
+			 ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
+			 publishLightColor((int)state_machine::E_RED); });
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
-		  [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
-		  publishLightColor((int)state_machine::E_RED); });
+		  [&amp;]() { 
+		  fprintf(stderr,"[GREEN]callbackin\n");
+		  ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
+		  publishLightColor((int)state_machine::E_GREEN); });
 
 #if 0
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
                              std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_RED));
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                              std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_GREEN));
-#endif
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                          [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE); });
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                              std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_GREEN));
+#endif
+
 }
 
 void DecisionMakerNode::publishLightColor(int status)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5ec3f459c0f94dbaf80707ea41771fa0551463ad" author="Yusuke FUJII">
		<msg>R.I.P.</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_stateupdate.cpp" added_lines="3" deleted_lines="7">
				<diff>@@ -61,16 +61,12 @@ void DecisionMakerNode::setupStateCallback(void)
   // trraficlight
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
                          [&amp;]() { 
-			 //debug
-			 fprintf(stderr,"[RED]callbackin\n");
-			 //
 			 ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
 			 publishLightColor((int)state_machine::E_RED); });
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
-		  [&amp;]() { 
-		  fprintf(stderr,"[GREEN]callbackin\n");
-		  ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
-		  publishLightColor((int)state_machine::E_GREEN); });
+		  	 [&amp;]() { 
+		  	 ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
+		  	 publishLightColor((int)state_machine::E_GREEN); });
 
 #if 0
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="33567105bc5dda68680958874522265453351bbe" author="kitsukawa">
		<msg>fix tf_mapping regarding number of digits of pose</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\tf_mapping\tf_mapping.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\tf_mapping\tf_mapping.cpp" added_lines="5" deleted_lines="2">
				<diff>@@ -131,11 +131,14 @@ void points_callback(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::ConstPtr &amp;input)
 
     for (int i = 0; i &lt; (int)pcl_out.points.size(); i++)
     {
-      ofs &lt;&lt; pcl_out.points[i].x &lt;&lt; "," &lt;&lt; pcl_out.points[i].y &lt;&lt; "," &lt;&lt; pcl_out.points[i].z &lt;&lt; "," &lt;&lt; pcl_out.points[i].intensity &lt;&lt; std::endl;
+      ofs &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; pcl_out.points[i].x &lt;&lt; ","
+          &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; pcl_out.points[i].y &lt;&lt; ","
+          &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; pcl_out.points[i].z &lt;&lt; ","
+          &lt;&lt; pcl_out.points[i].intensity &lt;&lt; std::endl;
     }
     std::cout &lt;&lt; "Wrote " &lt;&lt; pcl_out.size() &lt;&lt; " points to " &lt;&lt; filename &lt;&lt; "." &lt;&lt; std::endl;
     added_scan_num++;
-    if(added_scan_num == 50)
+    if(added_scan_num == 300)
     {
       added_scan_num = 0;
       map_id++;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3dac9b3a46fa7d4baf5d722918568bbd825e35e1" author="Yamato ANDO">
		<msg>use header.frame_id included in initialpose topic</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\icp_localizer\nodes\icp_matching\icp_matching.cpp" new_path="ros\src\computing\perception\localization\packages\icp_localizer\nodes\icp_matching\icp_matching.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -302,8 +302,8 @@ static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped:
   try
   {
     ros::Time now = ros::Time(0);
-    listener.waitForTransform("/map", "/world", now, ros::Duration(10.0));
-    listener.lookupTransform("/map", "world", now, transform);
+    listener.waitForTransform("/map", input-&gt;header.frame_id, now, ros::Duration(10.0));
+    listener.lookupTransform("/map", input-&gt;header.frame_id, now, transform);
   }
   catch (tf::TransformException&amp; ex)
   {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching_tku\ndt_matching_tku.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching_tku\ndt_matching_tku.cpp" added_lines="3" deleted_lines="3">
				<diff>@@ -137,8 +137,8 @@ static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped:
   try
   {
     ros::Time now = ros::Time(0);
-    listener.waitForTransform("/map", "/world", now, ros::Duration(10.0));
-    listener.lookupTransform("/map", "world", now, transform);
+    listener.waitForTransform("/map", input-&gt;header.frame_id, now, ros::Duration(10.0));
+    listener.lookupTransform("/map", input-&gt;header.frame_id, now, transform);
   }
   catch (tf::TransformException &amp;ex)
   {
@@ -555,4 +555,4 @@ int main(int argc, char *argv[])
   ros::spin();
 
   return 1;
-}
\ No newline at end of file
+}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" new_path="ros\src\computing\planning\motion\packages\waypoint_follower\nodes\wf_simulator\wf_simulator.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -116,7 +116,7 @@ void getTransformFromTF(const std::string parent_frame, const std::string child_
 void initialposeCallback(const geometry_msgs::PoseWithCovarianceStampedConstPtr &amp;input)
 {
   tf::StampedTransform transform;
-  getTransformFromTF(MAP_FRAME, "world", transform);
+  getTransformFromTF(MAP_FRAME, input-&gt;header.frame_id, transform);
 
   _initial_pose.position.x = input-&gt;pose.pose.position.x + transform.getOrigin().x();
   _initial_pose.position.y = input-&gt;pose.pose.position.y + transform.getOrigin().y();
</diff>
			</file>
			<file old_path="ros\src\data\packages\map_file\nodes\points_map_loader\points_map_loader.cpp" new_path="ros\src\data\packages\map_file\nodes\points_map_loader\points_map_loader.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -403,8 +403,8 @@ void publish_dragged_pcd(const geometry_msgs::PoseWithCovarianceStamped&amp; msg)
 	tf::StampedTransform transform;
 	try {
 		ros::Time zero = ros::Time(0);
-		listener.waitForTransform("map", "world", zero, ros::Duration(10));
-		listener.lookupTransform("map", "world", zero, transform);
+		listener.waitForTransform("map", msg.header.frame_id, zero, ros::Duration(10));
+		listener.lookupTransform("map", msg.header.frame_id, zero, transform);
 	} catch (tf::TransformException &amp;ex) {
 		ROS_ERROR_STREAM("failed to create transform from " &lt;&lt; ex.what());
 	}
</diff>
			</file>
			<file old_path="ros\src\util\packages\map_tools\nodes\map_extender\map_extender.cpp" new_path="ros\src\util\packages\map_tools\nodes\map_extender\map_extender.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -104,8 +104,8 @@ static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped:
   try
   {
     ros::Time now = ros::Time(0);
-    listener.waitForTransform("/map", "/world", now, ros::Duration(10.0));
-    listener.lookupTransform("/map", "world", now, transform);
+    listener.waitForTransform("/map", input-&gt;header.frame_id, now, ros::Duration(10.0));
+    listener.lookupTransform("/map", input-&gt;header.frame_id, now, transform);
   }
   catch (tf::TransformException&amp; ex)
   {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1b100fd62ddb11c5e380f916d1b9a396575dcc8a" author="Yamato ANDO">
		<msg>reset window position(0,0), remove /obj_car/obj_pose topic in rviz</msg>
		<modified_files>
			<file old_path="ros\src\.config\rviz\default.rviz" new_path="ros\src\.config\rviz\default.rviz" added_lines="32" deleted_lines="56">
				<diff>@@ -13,7 +13,7 @@ Panels:
         - /Local Rollouts1/Namespaces1
         - /GlobalPathAnimation1/Status1
       Splitter Ratio: 0.695804
-    Tree Height: 640
+    Tree Height: 651
   - Class: rviz/Selection
     Name: Selection
   - Class: rviz/Tool Properties
@@ -22,7 +22,7 @@ Panels:
       - /2D Nav Goal1
       - /Publish Point1
     Name: Tool Properties
-    Splitter Ratio: 0.588679
+    Splitter Ratio: 0.588679016
   - Class: rviz/Views
     Expanded:
       - /Current View1
@@ -32,7 +32,7 @@ Panels:
     Experimental: false
     Name: Time
     SyncMode: 0
-    SyncSource: Points Map
+    SyncSource: ""
 Visualization Manager:
   Class: ""
   Displays:
@@ -42,7 +42,7 @@ Visualization Manager:
       Color: 160; 160; 164
       Enabled: false
       Line Style:
-        Line Width: 0.03
+        Line Width: 0.0299999993
         Value: Lines
       Name: Grid
       Normal Cell Count: 0
@@ -59,28 +59,16 @@ Visualization Manager:
       Frame Timeout: 15
       Frames:
         All Enabled: true
-        base_link:
-          Value: true
-        map:
-          Value: true
-        velodyne:
-          Value: true
-        world:
-          Value: true
       Marker Scale: 5
       Name: TF
       Show Arrows: true
       Show Axes: true
       Show Names: true
       Tree:
-        world:
-          map:
-            base_link:
-              velodyne:
-                {}
+        {}
       Update Interval: 0
       Value: true
-    - Alpha: 0.05
+    - Alpha: 0.0500000007
       Autocompute Intensity Bounds: true
       Autocompute Value Bounds:
         Max Value: 10
@@ -103,7 +91,7 @@ Visualization Manager:
       Queue Size: 10
       Selectable: true
       Size (Pixels): 2
-      Size (m): 0.01
+      Size (m): 0.00999999978
       Style: Points
       Topic: /points_map
       Unreliable: false
@@ -123,13 +111,12 @@ Visualization Manager:
       Image Rendering: overlay
       Image Topic: /image_raw
       Name: Camera
-      Overlay Alpha: 0.4
+      Overlay Alpha: 0.400000006
       Queue Size: 10
       Transport Hint: raw
       Unreliable: false
       Value: false
       Visibility:
-        "": true
         A* Sim Obstacle: true
         Behavior State: true
         Control Pose: true
@@ -139,11 +126,10 @@ Visualization Manager:
         Global Waypoints: true
         GlobalPathAnimation: true
         Grid: true
-        Laserscan Costmap: true
         Local Rollouts: true
         Local Waypoints: true
         Next Waypoint Mark: true
-        Object Pose: true
+        Occupancy Grid Map: true
         PP Trajectory Mark: true
         Points Cluster: true
         Points Map: true
@@ -157,6 +143,7 @@ Visualization Manager:
         Vector Map: true
         Vector Map CenterLines: true
         Vehicle Model: true
+        Velocity (km/h): true
         Vscan Points: true
         Waypoint Guide: true
       Zoom Factor: 1
@@ -183,7 +170,7 @@ Visualization Manager:
       Queue Size: 10
       Selectable: true
       Size (Pixels): 1
-      Size (m): 0.01
+      Size (m): 0.00999999978
       Style: Points
       Topic: /points_raw
       Unreliable: false
@@ -213,7 +200,7 @@ Visualization Manager:
       Queue Size: 10
       Selectable: true
       Size (Pixels): 3
-      Size (m): 0.01
+      Size (m): 0.00999999978
       Style: Points
       Topic: /vscan_points
       Unreliable: false
@@ -222,7 +209,7 @@ Visualization Manager:
       Value: false
     - Alpha: 1
       Axes Length: 1
-      Axes Radius: 0.1
+      Axes Radius: 0.100000001
       Class: rviz/Pose
       Color: 255; 25; 0
       Enabled: false
@@ -237,7 +224,7 @@ Visualization Manager:
       Value: false
     - Alpha: 1
       Axes Length: 1
-      Axes Radius: 0.1
+      Axes Radius: 0.100000001
       Class: rviz/Pose
       Color: 255; 170; 255
       Enabled: false
@@ -255,10 +242,7 @@ Visualization Manager:
       Marker Topic: /detection_range
       Name: Detection Range
       Namespaces:
-        Crosswalk Detection: true
-        Decelerate Detection: true
-        Stop Detection: true
-        Stop Line: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -295,7 +279,7 @@ Visualization Manager:
         Expand Link Details: false
         Expand Tree: false
         Link Tree Style: Links in Alphabetic Order
-        base_link:
+        sim_base_link:
           Alpha: 1
           Show Axes: false
           Show Trail: false
@@ -329,29 +313,19 @@ Visualization Manager:
       Queue Size: 10
       Selectable: true
       Size (Pixels): 5
-      Size (m): 0.01
+      Size (m): 0.00999999978
       Style: Points
       Topic: /points_cluster
       Unreliable: false
       Use Fixed Frame: true
       Use rainbow: true
       Value: true
-    - Class: rviz/MarkerArray
-      Enabled: true
-      Marker Topic: /obj_car/obj_pose
-      Name: Object Pose
-      Namespaces:
-        {}
-      Queue Size: 100
-      Value: true
     - Class: rviz/MarkerArray
       Enabled: true
       Marker Topic: /local_waypoints_mark
       Name: Local Waypoints
       Namespaces:
-        local_path_marker: true
-        local_point_marker: true
-        local_waypoint_velocity: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -378,7 +352,7 @@ Visualization Manager:
         {}
       Queue Size: 100
       Value: true
-    - Alpha: 0.7
+    - Alpha: 0.699999988
       Class: rviz/Map
       Color Scheme: map
       Draw Behind: true
@@ -386,6 +360,7 @@ Visualization Manager:
       Name: Occupancy Grid Map
       Topic: /grid_map_visualization/distance_transform
       Unreliable: false
+      Use Timestamp: false
       Value: true
     - Class: rviz/MarkerArray
       Enabled: true
@@ -449,10 +424,10 @@ Visualization Manager:
       Topic: /dp_planner_tracked_boxes
       Unreliable: false
       Value: true
-      alpha: 0.8
+      alpha: 0.800000012
       color: 25; 255; 0
       coloring: Value
-      line width: 0.01
+      line width: 0.00999999978
       only edge: false
       show coords: false
     - Buffer length: 100
@@ -467,7 +442,7 @@ Visualization Manager:
       background color: 0; 0; 0
       backround alpha: 0
       border: true
-      foreground alpha: 0.7
+      foreground alpha: 0.699999988
       foreground color: 85; 255; 0
       height: 80
       left: 40
@@ -478,7 +453,7 @@ Visualization Manager:
       show caption: true
       text size: 8
       top: 30
-      update interval: 0.04
+      update interval: 0.0399999991
       width: 80
   Enabled: true
   Global Options:
@@ -506,12 +481,13 @@ Visualization Manager:
       Angle: 0
       Class: rviz/TopDownOrtho
       Enable Stereo Rendering:
-        Stereo Eye Separation: 0.06
+        Stereo Eye Separation: 0.0599999987
         Stereo Focal Distance: 1
         Swap Stereo Eyes: false
         Value: false
+      Invert Z Axis: false
       Name: Current View
-      Near Clip Distance: 0.01
+      Near Clip Distance: 0.00999999978
       Scale: 10
       Target Frame: &lt;Fixed Frame&gt;
       Value: TopDownOrtho (rviz)
@@ -523,10 +499,10 @@ Window Geometry:
     collapsed: false
   Displays:
     collapsed: false
-  Height: 873
+  Height: 900
   Hide Left Dock: false
   Hide Right Dock: false
-  QMainWindow State: 000000ff00000000fd00000004000000000000016a000002c1fc020000000dfb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006400fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afc00000028000002c1000000dd00fffffffa000000020100000003fb0000000a0049006d0061006700650000000000ffffffff0000000000000000fb0000000c00430061006d0065007200610000000000ffffffff0000006500fffffffb000000100044006900730070006c0061007900730100000000000001360000016a00fffffffb0000000a0049006d006100670065010000028e000000d20000000000000000fb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000120049006d006100670065005f0072006100770000000000ffffffff0000000000000000fb0000000c00430061006d006500720061000000024e000001710000000000000000fb000000120049006d00610067006500200052006100770100000421000000160000000000000000fb0000000a0049006d00610067006501000002f4000000cb00000000000000000000000100000163000002c1fc0200000003fb0000000a005600690065007700730100000028000002c1000000b000fffffffb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b20000000000000000000000020000073f000000a8fc0100000001fb0000000a00560069006500770073030000004e00000080000002e100000197000000030000066d0000005cfc0100000002fb0000000800540069006d006501000000000000066d000002f600fffffffb0000000800540069006d0065010000000000000450000000000000000000000394000002c100000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
+  QMainWindow State: 000000ff00000000fd000000040000000000000179000002d2fc020000000dfb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006600fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afc0000002e000002d2000000e300fffffffa000000020100000003fb0000000a0049006d0061006700650000000000ffffffff0000000000000000fb0000000c00430061006d0065007200610000000000ffffffff0000007300fffffffb000000100044006900730070006c0061007900730100000000000001360000017900fffffffb0000000a0049006d006100670065010000028e000000d20000000000000000fb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000120049006d006100670065005f0072006100770000000000ffffffff0000000000000000fb0000000c00430061006d006500720061000000024e000001710000000000000000fb000000120049006d00610067006500200052006100770100000421000000160000000000000000fb0000000a0049006d00610067006501000002f4000000cb00000000000000000000000100000163000002d2fc0200000003fb0000000a00560069006500770073010000002e000002d2000000ba00fffffffb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b20000000000000000000000020000073f000000a8fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000006400000005cfc0100000002fb0000000800540069006d00650100000000000006400000038300fffffffb0000000800540069006d0065010000000000000450000000000000000000000356000002d200000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
   Selection:
     collapsed: false
   Time:
@@ -535,6 +511,6 @@ Window Geometry:
     collapsed: false
   Views:
     collapsed: false
-  Width: 1645
-  X: 1861
-  Y: 91
+  Width: 1600
+  X: 0
+  Y: 0
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ddc93a4c536a129acfc7c082bb0fc0cd10b93518" author="Yamato ANDO">
		<msg>restore other parameters</msg>
		<modified_files>
			<file old_path="ros\src\.config\rviz\default.rviz" new_path="ros\src\.config\rviz\default.rviz" added_lines="44" deleted_lines="28">
				<diff>@@ -13,7 +13,7 @@ Panels:
         - /Local Rollouts1/Namespaces1
         - /GlobalPathAnimation1/Status1
       Splitter Ratio: 0.695804
-    Tree Height: 651
+    Tree Height: 640
   - Class: rviz/Selection
     Name: Selection
   - Class: rviz/Tool Properties
@@ -22,7 +22,7 @@ Panels:
       - /2D Nav Goal1
       - /Publish Point1
     Name: Tool Properties
-    Splitter Ratio: 0.588679016
+    Splitter Ratio: 0.588679
   - Class: rviz/Views
     Expanded:
       - /Current View1
@@ -32,7 +32,7 @@ Panels:
     Experimental: false
     Name: Time
     SyncMode: 0
-    SyncSource: ""
+    SyncSource: Points Map
 Visualization Manager:
   Class: ""
   Displays:
@@ -42,7 +42,7 @@ Visualization Manager:
       Color: 160; 160; 164
       Enabled: false
       Line Style:
-        Line Width: 0.0299999993
+        Line Width: 0.03
         Value: Lines
       Name: Grid
       Normal Cell Count: 0
@@ -59,16 +59,28 @@ Visualization Manager:
       Frame Timeout: 15
       Frames:
         All Enabled: true
+        base_link:
+          Value: true
+        map:
+          Value: true
+        velodyne:
+          Value: true
+        world:
+          Value: true
       Marker Scale: 5
       Name: TF
       Show Arrows: true
       Show Axes: true
       Show Names: true
       Tree:
-        {}
+        world:
+          map:
+            base_link:
+              velodyne:
+                {}
       Update Interval: 0
       Value: true
-    - Alpha: 0.0500000007
+    - Alpha: 0.05
       Autocompute Intensity Bounds: true
       Autocompute Value Bounds:
         Max Value: 10
@@ -91,7 +103,7 @@ Visualization Manager:
       Queue Size: 10
       Selectable: true
       Size (Pixels): 2
-      Size (m): 0.00999999978
+      Size (m): 0.01
       Style: Points
       Topic: /points_map
       Unreliable: false
@@ -111,12 +123,13 @@ Visualization Manager:
       Image Rendering: overlay
       Image Topic: /image_raw
       Name: Camera
-      Overlay Alpha: 0.400000006
+      Overlay Alpha: 0.4
       Queue Size: 10
       Transport Hint: raw
       Unreliable: false
       Value: false
       Visibility:
+        "": true
         A* Sim Obstacle: true
         Behavior State: true
         Control Pose: true
@@ -126,10 +139,11 @@ Visualization Manager:
         Global Waypoints: true
         GlobalPathAnimation: true
         Grid: true
+        Laserscan Costmap: true
         Local Rollouts: true
         Local Waypoints: true
         Next Waypoint Mark: true
-        Occupancy Grid Map: true
+        Object Pose: true
         PP Trajectory Mark: true
         Points Cluster: true
         Points Map: true
@@ -143,7 +157,6 @@ Visualization Manager:
         Vector Map: true
         Vector Map CenterLines: true
         Vehicle Model: true
-        Velocity (km/h): true
         Vscan Points: true
         Waypoint Guide: true
       Zoom Factor: 1
@@ -170,7 +183,7 @@ Visualization Manager:
       Queue Size: 10
       Selectable: true
       Size (Pixels): 1
-      Size (m): 0.00999999978
+      Size (m): 0.01
       Style: Points
       Topic: /points_raw
       Unreliable: false
@@ -200,7 +213,7 @@ Visualization Manager:
       Queue Size: 10
       Selectable: true
       Size (Pixels): 3
-      Size (m): 0.00999999978
+      Size (m): 0.01
       Style: Points
       Topic: /vscan_points
       Unreliable: false
@@ -209,7 +222,7 @@ Visualization Manager:
       Value: false
     - Alpha: 1
       Axes Length: 1
-      Axes Radius: 0.100000001
+      Axes Radius: 0.1
       Class: rviz/Pose
       Color: 255; 25; 0
       Enabled: false
@@ -224,7 +237,7 @@ Visualization Manager:
       Value: false
     - Alpha: 1
       Axes Length: 1
-      Axes Radius: 0.100000001
+      Axes Radius: 0.1
       Class: rviz/Pose
       Color: 255; 170; 255
       Enabled: false
@@ -242,7 +255,10 @@ Visualization Manager:
       Marker Topic: /detection_range
       Name: Detection Range
       Namespaces:
-        {}
+        Crosswalk Detection: true
+        Decelerate Detection: true
+        Stop Detection: true
+        Stop Line: true
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -279,7 +295,7 @@ Visualization Manager:
         Expand Link Details: false
         Expand Tree: false
         Link Tree Style: Links in Alphabetic Order
-        sim_base_link:
+        base_link:
           Alpha: 1
           Show Axes: false
           Show Trail: false
@@ -313,7 +329,7 @@ Visualization Manager:
       Queue Size: 10
       Selectable: true
       Size (Pixels): 5
-      Size (m): 0.00999999978
+      Size (m): 0.01
       Style: Points
       Topic: /points_cluster
       Unreliable: false
@@ -325,7 +341,9 @@ Visualization Manager:
       Marker Topic: /local_waypoints_mark
       Name: Local Waypoints
       Namespaces:
-        {}
+        local_path_marker: true
+        local_point_marker: true
+        local_waypoint_velocity: true
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -352,7 +370,7 @@ Visualization Manager:
         {}
       Queue Size: 100
       Value: true
-    - Alpha: 0.699999988
+    - Alpha: 0.7
       Class: rviz/Map
       Color Scheme: map
       Draw Behind: true
@@ -360,7 +378,6 @@ Visualization Manager:
       Name: Occupancy Grid Map
       Topic: /grid_map_visualization/distance_transform
       Unreliable: false
-      Use Timestamp: false
       Value: true
     - Class: rviz/MarkerArray
       Enabled: true
@@ -424,10 +441,10 @@ Visualization Manager:
       Topic: /dp_planner_tracked_boxes
       Unreliable: false
       Value: true
-      alpha: 0.800000012
+      alpha: 0.8
       color: 25; 255; 0
       coloring: Value
-      line width: 0.00999999978
+      line width: 0.01
       only edge: false
       show coords: false
     - Buffer length: 100
@@ -442,7 +459,7 @@ Visualization Manager:
       background color: 0; 0; 0
       backround alpha: 0
       border: true
-      foreground alpha: 0.699999988
+      foreground alpha: 0.7
       foreground color: 85; 255; 0
       height: 80
       left: 40
@@ -453,7 +470,7 @@ Visualization Manager:
       show caption: true
       text size: 8
       top: 30
-      update interval: 0.0399999991
+      update interval: 0.04
       width: 80
   Enabled: true
   Global Options:
@@ -481,13 +498,12 @@ Visualization Manager:
       Angle: 0
       Class: rviz/TopDownOrtho
       Enable Stereo Rendering:
-        Stereo Eye Separation: 0.0599999987
+        Stereo Eye Separation: 0.06
         Stereo Focal Distance: 1
         Swap Stereo Eyes: false
         Value: false
-      Invert Z Axis: false
       Name: Current View
-      Near Clip Distance: 0.00999999978
+      Near Clip Distance: 0.01
       Scale: 10
       Target Frame: &lt;Fixed Frame&gt;
       Value: TopDownOrtho (rviz)
@@ -502,7 +518,7 @@ Window Geometry:
   Height: 900
   Hide Left Dock: false
   Hide Right Dock: false
-  QMainWindow State: 000000ff00000000fd000000040000000000000179000002d2fc020000000dfb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006600fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afc0000002e000002d2000000e300fffffffa000000020100000003fb0000000a0049006d0061006700650000000000ffffffff0000000000000000fb0000000c00430061006d0065007200610000000000ffffffff0000007300fffffffb000000100044006900730070006c0061007900730100000000000001360000017900fffffffb0000000a0049006d006100670065010000028e000000d20000000000000000fb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000120049006d006100670065005f0072006100770000000000ffffffff0000000000000000fb0000000c00430061006d006500720061000000024e000001710000000000000000fb000000120049006d00610067006500200052006100770100000421000000160000000000000000fb0000000a0049006d00610067006501000002f4000000cb00000000000000000000000100000163000002d2fc0200000003fb0000000a00560069006500770073010000002e000002d2000000ba00fffffffb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b20000000000000000000000020000073f000000a8fc0100000001fb0000000a00560069006500770073030000004e00000080000002e10000019700000003000006400000005cfc0100000002fb0000000800540069006d00650100000000000006400000038300fffffffb0000000800540069006d0065010000000000000450000000000000000000000356000002d200000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
+  QMainWindow State: 000000ff00000000fd00000004000000000000016a000002c1fc020000000dfb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006400fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afc00000028000002c1000000dd00fffffffa000000020100000003fb0000000a0049006d0061006700650000000000ffffffff0000000000000000fb0000000c00430061006d0065007200610000000000ffffffff0000006500fffffffb000000100044006900730070006c0061007900730100000000000001360000016a00fffffffb0000000a0049006d006100670065010000028e000000d20000000000000000fb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000120049006d006100670065005f0072006100770000000000ffffffff0000000000000000fb0000000c00430061006d006500720061000000024e000001710000000000000000fb000000120049006d00610067006500200052006100770100000421000000160000000000000000fb0000000a0049006d00610067006501000002f4000000cb00000000000000000000000100000163000002c1fc0200000003fb0000000a005600690065007700730100000028000002c1000000b000fffffffb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b20000000000000000000000020000073f000000a8fc0100000001fb0000000a00560069006500770073030000004e00000080000002e100000197000000030000066d0000005cfc0100000002fb0000000800540069006d006501000000000000066d000002f600fffffffb0000000800540069006d0065010000000000000450000000000000000000000394000002c100000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
   Selection:
     collapsed: false
   Time:
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="46633e1436b58ce6ca4e091d59d7d7e8d36c5c7e" author="Yamato ANDO">
		<msg>fix typo</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1004,8 +1004,8 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
           ndt.omp_align(*output_cloud, init_guess);
         #else
           ndt.align(*output_cloud, init_guess);
-        align_end = std::chrono::system_clock::now();
         #endif
+        align_end = std::chrono::system_clock::now();
 
         has_converged = ndt.hasConverged();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="288316d2154b16d29c4fa338d09950a17f4fc78b" author="Yamato ANDO">
		<msg>remove currnet_pose publisher</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\icp_localizer\nodes\icp_matching\icp_matching.cpp" new_path="ros\src\computing\perception\localization\packages\icp_localizer\nodes\icp_matching\icp_matching.cpp" added_lines="0" deleted_lines="4">
				<diff>@@ -112,7 +112,6 @@ static geometry_msgs::PoseStamped predict_pose_msg;
 static ros::Publisher icp_pose_pub;
 static geometry_msgs::PoseStamped icp_pose_msg;
 
-static ros::Publisher current_pose_pub;
 static geometry_msgs::PoseStamped current_pose_msg;
 
 static ros::Publisher localizer_pose_pub;
@@ -537,7 +536,6 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
     predict_pose_pub.publish(predict_pose_msg);
     icp_pose_pub.publish(icp_pose_msg);
-    current_pose_pub.publish(current_pose_msg);
     localizer_pose_pub.publish(localizer_pose_msg);
 
     // Send TF "/base_link" to "/map"
@@ -748,7 +746,6 @@ int main(int argc, char** argv)
   // Publishers
   predict_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/predict_pose", 1000);
   icp_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/icp_pose", 1000);
-  // current_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/current_pose", 1000);
   localizer_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;("/localizer_pose", 1000);
   estimate_twist_pub = nh.advertise&lt;geometry_msgs::TwistStamped&gt;("/estimate_twist", 1000);
   estimated_vel_mps_pub = nh.advertise&lt;std_msgs::Float32&gt;("/estimated_vel_mps", 1000);
@@ -756,7 +753,6 @@ int main(int argc, char** argv)
   estimated_vel_pub = nh.advertise&lt;geometry_msgs::Vector3Stamped&gt;("/estimated_vel", 1000);
   time_icp_matching_pub = nh.advertise&lt;std_msgs::Float32&gt;("/time_icp_matching", 1000);
   icp_stat_pub = nh.advertise&lt;autoware_msgs::icp_stat&gt;("/icp_stat", 1000);
-//  ndt_reliability_pub = nh.advertise&lt;std_msgs::Float32&gt;("/ndt_reliability", 1000);
 
   // Subscribers
   ros::Subscriber param_sub = nh.subscribe("config/icp", 10, param_callback);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="564be3e809a86c284fffb9d78b12c59fdfcba025" author="Yusuke FUJII">
		<msg>migrated web_ui to another repo
- https://github.com/TierIV/autoware_web_runtime_manager</msg>
		<modified_files>
			<file old_path="ui\web\runtime_manager\app\views\index.html" new_path="" added_lines="0" deleted_lines="30">
				<diff>@@ -1,30 +0,0 @@
-&lt;!DOCTYPE html&gt;
-&lt;html&gt;
-  &lt;head&gt;
-    &lt;title&gt;RuntimeManager&lt;/title&gt;
-
-    &lt;meta charset="utf-8" /&gt;
-    &lt;meta http-equiv="Pragma" content="no-cache"&gt;
-    &lt;meta http-equiv="Cache-Control" content="no-cache"&gt;
-    &lt;link href="./res/static/autoware_icon.ico" rel="shortcut icon"&gt;
-
-    &lt;!-- ReactGridLayout --&gt;
-    &lt;link href="./res/node_modules/react-grid-layout/css/styles.css" rel="stylesheet"&gt;
-    &lt;link href="./res/node_modules/react-resizable/css/styles.css" rel="stylesheet"&gt;
-
-    &lt;!-- RobotWebTools --&gt;
-    &lt;script type="text/javascript" src="./res/lib/threejs/three.min.js"&gt;&lt;/script&gt;
-    &lt;script type="text/javascript" src="./res/lib/threejs/STLLoader.min.js"&gt;&lt;/script&gt;
-    &lt;script type="text/javascript" src="./res/lib/collada/ColladaLoader.min.js"&gt;&lt;/script&gt;
-    &lt;script type="text/javascript" src="./res/lib/collada/ColladaLoader2.min.js"&gt;&lt;/script&gt;
-    &lt;script type="text/javascript" src="./res/lib/robotwebtools/eventemitter2.min.js"&gt;&lt;/script&gt;
-    &lt;script type="text/javascript" src="./res/lib/robotwebtools/easeljs.min.js"&gt;&lt;/script&gt;
-    &lt;script type="text/javascript" src="./res/lib/robotwebtools/roslib.js"&gt;&lt;/script&gt;
-    &lt;script type="text/javascript" src="./res/lib/robotwebtools/ros3d.js"&gt;&lt;/script&gt;
-
-  &lt;/head&gt;
-  &lt;body&gt;
-    &lt;div id="content"&gt;&lt;/div&gt;
-    &lt;script src="./res/build/app.js?no-cache=true"&gt;&lt;/script&gt;
-  &lt;/body&gt;
-&lt;/html&gt;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1b3bbba70b214853cfa861d243d4083e68a49c45" author="Yamato ANDO">
		<msg>use_fast_pcl set default false</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="2" deleted_lines="1">
				<diff>@@ -225,7 +225,7 @@ static std_msgs::Float32 ndt_reliability;
 static bool _use_gpu = false;
 static bool _use_openmp = false;
 
-static bool _use_fast_pcl = true;
+static bool _use_fast_pcl = false;
 
 static bool _get_height = false;
 static bool _use_local_transform = false;
@@ -514,6 +514,7 @@ static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
       new_ndt.setResolution(ndt_res);
       new_ndt.setStepSize(step_size);
       new_ndt.setTransformationEpsilon(trans_eps);
+
       #ifdef USE_FAST_PCL
         new_ndt.omp_align(*output_cloud, Eigen::Matrix4f::Identity());
       #else
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="4ce1766897f549393bb82843d9cfaf69984c8965" author="Yamato ANDO">
		<msg>modified setResolution to be called before setInputTarget is applied</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" new_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\ndt_matching\ndt_matching.cpp" added_lines="3" deleted_lines="4">
				<diff>@@ -466,9 +466,9 @@ static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     if (_use_gpu == true)
     {
       std::shared_ptr&lt;gpu::GNormalDistributionsTransform&gt; new_gpu_ndt_ptr = std::make_shared&lt;gpu::GNormalDistributionsTransform&gt;();
+      new_gpu_ndt_ptr-&gt;setResolution(ndt_res);
       new_gpu_ndt_ptr-&gt;setInputTarget(map_ptr);
       new_gpu_ndt_ptr-&gt;setMaximumIterations(max_iter);
-      new_gpu_ndt_ptr-&gt;setResolution(ndt_res);
       new_gpu_ndt_ptr-&gt;setStepSize(step_size);
       new_gpu_ndt_ptr-&gt;setTransformationEpsilon(trans_eps);
 
@@ -488,9 +488,9 @@ static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     if (_use_fast_pcl)
     {
       cpu::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; new_cpu_ndt;
+      new_cpu_ndt.setResolution(ndt_res);
       new_cpu_ndt.setInputTarget(map_ptr);
       new_cpu_ndt.setMaximumIterations(max_iter);
-      new_cpu_ndt.setResolution(ndt_res);
       new_cpu_ndt.setStepSize(step_size);
       new_cpu_ndt.setTransformationEpsilon(trans_eps);
 
@@ -509,12 +509,11 @@ static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     {
       pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; new_ndt;
       pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
+      new_ndt.setResolution(ndt_res);
       new_ndt.setInputTarget(map_ptr);
       new_ndt.setMaximumIterations(max_iter);
-      new_ndt.setResolution(ndt_res);
       new_ndt.setStepSize(step_size);
       new_ndt.setTransformationEpsilon(trans_eps);
-
       #ifdef USE_FAST_PCL
         new_ndt.omp_align(*output_cloud, Eigen::Matrix4f::Identity());
       #else
</diff>
			</file>
		</modified_files>
	</commit>
</Root>
