<?xml version="1.0" encoding="utf-8"?>
<Root>
	<commit hash="7417a0d4bdbe3a784e01c418cb3caa23139fca04" author="Yukihiro.Saito">
		<msg>Fixed zero division in scan2image</msg>
		<modified_files>
			<file old_path="ros\src\sensing\fusion\packages\scan2image\nodes\scan2image\scan2image.cpp" new_path="ros\src\sensing\fusion\packages\scan2image\nodes\scan2image\scan2image.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -56,7 +56,7 @@ void trans_depth_points_to_image_points(Scan_points_dataset* scan_points_dataset
                     + cameraExtrinsicMat.at&lt;double&gt;(2,1) * scan_points_dataset-&gt;scan_points.y.at(i)*1000
                     + cameraExtrinsicMat.at&lt;double&gt;(2,2) * scan_points_dataset-&gt;scan_points.z.at(i)*1000)
             + (cameraExtrinsicMat.at&lt;double&gt;(2,3));
-        if (camera_z &gt;= 0.0) {
+        if (camera_z &gt; 0.0) {
             /*
              * Projection transformation. Change from camera coordinate to image coordinate
              */
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3ce0c5f6d143c2c9e669abbbea8b97cead27069c" author="yukikitsukawa">
		<msg>support Garmin GPS 18x LVC</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\nmea2tfpose\nmea2tfpose_core.cpp" new_path="ros\src\computing\perception\localization\packages\gnss_localizer\nodes\nmea2tfpose\nmea2tfpose_core.cpp" added_lines="9" deleted_lines="0">
				<diff>@@ -131,6 +131,15 @@ void Nmea2TFPoseNode::convert(std::vector&lt;std::string&gt; nmea, ros::Time current_s
       geo_.set_llh_nmea_degrees(lat, lon, h);
       ROS_INFO("GGA is subscribed.");
     }
+    else if(nmea.at(0) == "$GPRMC")
+    {
+      position_time_ = stoi(nmea.at(1));
+      double lat = stod(nmea.at(3));
+      double lon = stod(nmea.at(5));
+      double h = 0.0;
+      geo_.set_llh_nmea_degrees(lat, lon, h);
+      ROS_INFO("GPRMC is subscribed.");
+    }
   }catch (const std::exception &amp;e)
   {
     ROS_WARN_STREAM("Message is invalid : " &lt;&lt; e.what());
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="155ac89979b1c00444959ea4a17691be797085c3" author="TomohitoAndo">
		<msg>Add parameter to ignore points nearby the vehicle</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" added_lines="6" deleted_lines="0">
				<diff>@@ -42,6 +42,8 @@ VelocitySetInfo::VelocitySetInfo()
     temporal_waypoints_size_(100),
     set_pose_(false)
 {
+  ros::NodeHandle private_nh_("~");
+  private_nh_.param&lt;double&gt;("remove_points_upto", remove_points_upto_, 2.3);
 }
 
 VelocitySetInfo::~VelocitySetInfo()
@@ -80,6 +82,10 @@ void VelocitySetInfo::pointsCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg
     if (v.z &gt; detection_height_top_ || v.z &lt; detection_height_bottom_)
       continue;
 
+    // ignore points nearby the vehicle
+    if (v.x * v.x + v.y * v.y &lt; remove_points_upto_ * remove_points_upto_)
+      continue;
+
     points_.push_back(v);
   }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.h" added_lines="3" deleted_lines="0">
				<diff>@@ -52,6 +52,9 @@ class VelocitySetInfo
   double velocity_change_limit_;    // (m/s)
   double temporal_waypoints_size_;  // (meter)
 
+  // ROS param
+  double remove_points_upto_;
+
   pcl::PointCloud&lt;pcl::PointXYZ&gt; points_;
   geometry_msgs::PoseStamped localizer_pose_;  // pose of sensor
   geometry_msgs::PoseStamped control_pose_;    // pose of base_link
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="fe1a697876b02ae03381b514d876dcc22c87d397" author="TomohitoAndo">
		<msg>Change the method to decide stop point</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.h" added_lines="23" deleted_lines="0">
				<diff>@@ -145,4 +145,27 @@ inline double calcSquareOfLength(const geometry_msgs::Point &amp;p1, const geometry_
   return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);
 }
 
+// Calculate waypoint index corresponding to distance from begin_waypoint
+inline int calcWaypointIndexReverse(const autoware_msgs::lane&amp; lane, const int begin_waypoint, const double distance)
+{
+  double dist_sum = 0;
+  for (int i = begin_waypoint; i &gt; 0; i--)
+  {
+    tf::Vector3 v1(lane.waypoints[i].pose.pose.position.x,
+                   lane.waypoints[i].pose.pose.position.y, 0);
+
+    tf::Vector3 v2(lane.waypoints[i - 1].pose.pose.position.x,
+                   lane.waypoints[i - 1].pose.pose.position.y, 0);
+
+    dist_sum += tf::tfDistance(v1, v2);
+
+    if (dist_sum &gt; distance)
+      return i;
+  }
+
+  // reach the first waypoint
+  return 0;
+}
+
+
 #endif /* _VELOCITY_SET_H */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="2" deleted_lines="8">
				<diff>@@ -432,14 +432,8 @@ void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_r
 {
   if (detection_result == EControl::STOP)
   {  // STOP for obstacle
-    // stop_waypoint is about stop distance meter away from obstacles
-    int stop_waypoint = 0;
-    if (vs_path-&gt;getPrevWaypointsSize() &gt; 1)
-    {
-      stop_waypoint = obstacle_waypoint - vs_info.getStopDistance() / vs_path-&gt;calcInterval(0, 1);
-    }
-    if (stop_waypoint &lt; 0)
-      stop_waypoint = 0;
+    // stop_waypoint is about stop_distance meter away from obstacles
+    int stop_waypoint = calcWaypointIndexReverse(vs_path-&gt;getPrevWaypoints(), obstacle_waypoint, vs_info.getStopDistance());
 
     // change waypoints to stop by the stop_waypoint
     vs_path-&gt;changeWaypointsForStopping(stop_waypoint, obstacle_waypoint, closest_waypoint, vs_info.getDeceleration());
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5da9a160d7097d91204523b892b0127032328e33" author="Yusuke FUJII">
		<msg>add multiple crosswalk detection</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.cpp" added_lines="16" deleted_lines="3">
				<diff>@@ -256,6 +256,11 @@ int CrossWalk::findClosestCrosswalk(const int closest_waypoint, const autoware_m
   double find_distance = 2.0 * 2.0;      // meter
   double ignore_distance = 20.0 * 20.0;  // meter
   static std::vector&lt;int&gt; bdid = getBDID();
+
+  int _return_val = 0;
+  
+  initDetectionCrossWalkIDs();//for multiple
+  
   // Find near cross walk
   for (int num = closest_waypoint; num &lt; closest_waypoint + search_distance; num++)
   {
@@ -274,13 +279,21 @@ int CrossWalk::findClosestCrosswalk(const int closest_waypoint, const autoware_m
         p.z = waypoint.z;
         if (calcSquareOfLength(p, waypoint) &lt; find_distance)
         {
-          setDetectionCrossWalkID(i);
-          return num;
-        }
+		addDetectionCrossWalkIDs(i);
+		if(!this-&gt;isMultipleDetection()){
+			setDetectionCrossWalkID(i);
+			return num;
+		}else if(!_return_val){
+			setDetectionCrossWalkID(i);
+			_return_val = num;
+		}
+	}
       }
     }
   }
 
+  if(_return_val) return _return_val;
+  
   setDetectionCrossWalkID(-1);
   return -1;  // no near crosswalk
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.h" added_lines="30" deleted_lines="0">
				<diff>@@ -37,6 +37,9 @@ private:
   int detection_crosswalk_id_;
   std::vector&lt;geometry_msgs::Point&gt; obstacle_points_;
   std::vector&lt;int&gt; bdID_;
+  
+  bool enable_multiple_crosswalk_detection_;
+  std::vector&lt;int&gt; detection_crosswalk_array_;
 
 public:
   bool loaded_crosswalk;
@@ -45,6 +48,7 @@ public:
   bool loaded_point;
   bool loaded_all;
   bool set_points;
+
   vector_map::CrossWalkArray crosswalk_;
   vector_map::AreaArray area_;
   vector_map::LineArray line_;
@@ -92,6 +96,32 @@ public:
   {
     return detection_crosswalk_id_;
   }
+  
+  void initDetectionCrossWalkIDs()
+  {
+    return detection_crosswalk_array_.clear();
+  }
+  void addDetectionCrossWalkIDs(const int &amp;id)
+  {
+	  auto itr = std::find(detection_crosswalk_array_.begin(), detection_crosswalk_array_.end(), id);
+	  if(detection_crosswalk_array_.empty() || itr == detection_crosswalk_array_.end()){
+		  detection_crosswalk_array_.push_back(id);
+	  }
+
+  }
+  std::vector&lt;int&gt; getDetectionCrossWalkIDs() const
+  {
+    return detection_crosswalk_array_;
+  }
+  void setMultipleDetectionFlag(const bool _multiple_flag)
+  {
+	enable_multiple_crosswalk_detection_ = _multiple_flag;
+  }
+  bool isMultipleDetection() const
+  {
+	  return enable_multiple_crosswalk_detection_;
+  }
+ 
 
   CrossWalk()
     : detection_waypoint_(-1)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="49" deleted_lines="30">
				<diff>@@ -174,16 +174,27 @@ void displayDetectionRange(const autoware_msgs::lane&amp; lane, const CrossWalk&amp; cro
     waypoint_marker_stop.points.push_back(point);
 
     if (i &gt; DECELERATION_SEARCH_DISTANCE)
-      continue;
+	    continue;
     waypoint_marker_decelerate.points.push_back(point);
   }
 
   if (crosswalk_id &gt; 0)
   {
-    for (const auto &amp;p : crosswalk.getDetectionPoints(crosswalk_id).points)
-      crosswalk_marker.points.push_back(p);
+	  if(!crosswalk.isMultipleDetection()){
+		  for (const auto &amp;p : crosswalk.getDetectionPoints(crosswalk_id).points)
+			  crosswalk_marker.points.push_back(p);
+	  }else {
+		  for (const auto &amp;c_id : crosswalk.getDetectionCrossWalkIDs()){
+			  for (const auto &amp;p : crosswalk.getDetectionPoints(c_id).points){
+				  scale = crosswalk.getDetectionPoints(c_id).width;
+				  crosswalk_marker.scale.x = scale;
+				  crosswalk_marker.scale.y = scale;
+				  crosswalk_marker.scale.z = scale;
+				  crosswalk_marker.points.push_back(p);
+			  }
+		  }
+	  }
   }
-
   // publish marker
   marker_array.markers.push_back(crosswalk_marker);
   marker_array.markers.push_back(waypoint_marker_stop);
@@ -199,35 +210,38 @@ EControl crossWalkDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const
 {
   int crosswalk_id = crosswalk.getDetectionCrossWalkID();
   double search_radius = crosswalk.getDetectionPoints(crosswalk_id).width / 2;
+  //std::vector&lt;int&gt; crosswalk_ids crosswalk.getDetectionCrossWalkIDs();
 
   // Search each calculated points in the crosswalk
-  for (const auto &amp;p : crosswalk.getDetectionPoints(crosswalk_id).points)
-  {
-    geometry_msgs::Point detection_point = calcRelativeCoordinate(p, localizer_pose.pose);
-    tf::Vector3 detection_vector = point2vector(detection_point);
-    detection_vector.setZ(0.0);
-
-    int stop_count = 0;  // the number of points in the detection area
-    for (const auto &amp;p : points)
-    {
-      tf::Vector3 point_vector(p.x, p.y, 0.0);
-      double distance = tf::tfDistance(point_vector, detection_vector);
-      if (distance &lt; search_radius)
-      {
-        stop_count++;
-        geometry_msgs::Point point_temp;
-        point_temp.x = p.x;
-        point_temp.y = p.y;
-        point_temp.z = p.z;
-	obstacle_points-&gt;setStopPoint(calcAbsoluteCoordinate(point_temp, localizer_pose.pose));
-      }
-      if (stop_count &gt; points_threshold)
-        return EControl::STOP;
-    }
-
-    obstacle_points-&gt;clearStopPoints();
+  for (const auto &amp;c_id : crosswalk.getDetectionCrossWalkIDs()){
+	  for (const auto &amp;p : crosswalk.getDetectionPoints(c_id).points)
+	  {
+		  geometry_msgs::Point detection_point = calcRelativeCoordinate(p, localizer_pose.pose);
+		  tf::Vector3 detection_vector = point2vector(detection_point);
+		  detection_vector.setZ(0.0);
+
+		  int stop_count = 0;  // the number of points in the detection area
+		  for (const auto &amp;p : points)
+		  {
+			  tf::Vector3 point_vector(p.x, p.y, 0.0);
+			  double distance = tf::tfDistance(point_vector, detection_vector);
+			  if (distance &lt; search_radius)
+			  {
+				  stop_count++;
+				  geometry_msgs::Point point_temp;
+				  point_temp.x = p.x;
+				  point_temp.y = p.y;
+				  point_temp.z = p.z;
+				  obstacle_points-&gt;setStopPoint(calcAbsoluteCoordinate(point_temp, localizer_pose.pose));
+			  }
+			  if (stop_count &gt; points_threshold)
+				  return EControl::STOP;
+		  }
+	  }
+
+	  obstacle_points-&gt;clearStopPoints();
+	  if(!crosswalk.isMultipleDetection())break;
   }
-
   return EControl::KEEP;  // find no obstacles
 }
 
@@ -472,8 +486,11 @@ int main(int argc, char **argv)
   ros::NodeHandle private_nh("~");
 
   bool use_crosswalk_detection;
+  bool enable_multiple_crosswalk_detection;
   std::string points_topic;
   private_nh.param&lt;bool&gt;("use_crosswalk_detection", use_crosswalk_detection, true);
+  private_nh.param&lt;bool&gt;("enable_multiple_crosswalk_detection", enable_multiple_crosswalk_detection, true);
+
   private_nh.param&lt;std::string&gt;("points_topic", points_topic, "points_lanes");
 
   // class
@@ -520,6 +537,8 @@ int main(int argc, char **argv)
       continue;
     }
 
+    crosswalk.setMultipleDetectionFlag(enable_multiple_crosswalk_detection);
+
     if (use_crosswalk_detection)
       crosswalk.setDetectionWaypoint(crosswalk.findClosestCrosswalk(closest_waypoint, vs_path.getPrevWaypoints(), STOP_SEARCH_DISTANCE));
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="26e6cdb393658fbc3d04041d0f4cb126a0b64479" author="Yusuke FUJII">
		<msg>apply clang-format</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.cpp" added_lines="21" deleted_lines="17">
				<diff>@@ -248,7 +248,8 @@ void CrossWalk::setCrossWalkPoints()
   set_points = true;
 }
 
-int CrossWalk::findClosestCrosswalk(const int closest_waypoint, const autoware_msgs::lane&amp; lane, const int search_distance)
+int CrossWalk::findClosestCrosswalk(const int closest_waypoint, const autoware_msgs::lane &amp;lane,
+                                    const int search_distance)
 {
   if (!set_points || closest_waypoint &lt; 0)
     return -1;
@@ -258,9 +259,9 @@ int CrossWalk::findClosestCrosswalk(const int closest_waypoint, const autoware_m
   static std::vector&lt;int&gt; bdid = getBDID();
 
   int _return_val = 0;
-  
-  initDetectionCrossWalkIDs();//for multiple
-  
+
+  initDetectionCrossWalkIDs();  // for multiple
+
   // Find near cross walk
   for (int num = closest_waypoint; num &lt; closest_waypoint + search_distance; num++)
   {
@@ -279,24 +280,27 @@ int CrossWalk::findClosestCrosswalk(const int closest_waypoint, const autoware_m
         p.z = waypoint.z;
         if (calcSquareOfLength(p, waypoint) &lt; find_distance)
         {
-		addDetectionCrossWalkIDs(i);
-		if(!this-&gt;isMultipleDetection()){
-			setDetectionCrossWalkID(i);
-			return num;
-		}else if(!_return_val){
-			setDetectionCrossWalkID(i);
-			_return_val = num;
-		}
-	}
+          addDetectionCrossWalkIDs(i);
+          if (!this-&gt;isMultipleDetection())
+          {
+            setDetectionCrossWalkID(i);
+            return num;
+          }
+          else if (!_return_val)
+          {
+            setDetectionCrossWalkID(i);
+            _return_val = num;
+          }
+        }
       }
     }
   }
 
-  if(_return_val) return _return_val;
-  
+  if (_return_val)
+    return _return_val;
+
   setDetectionCrossWalkID(-1);
   return -1;  // no near crosswalk
-
 }
 
 geometry_msgs::Point ObstaclePoints::getObstaclePoint(const EControl &amp;kind) const
@@ -317,7 +321,7 @@ geometry_msgs::Point ObstaclePoints::getObstaclePoint(const EControl &amp;kind) cons
 
     return point;
   }
-  else // kind == DECELERATE
+  else  // kind == DECELERATE
   {
     for (const auto &amp;p : decelerate_points_)
     {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.h" added_lines="16" deleted_lines="20">
				<diff>@@ -1,14 +1,14 @@
 #ifndef _VELOCITY_SET_H
 #define _VELOCITY_SET_H
 
+#include &lt;math.h&gt;
 #include &lt;iostream&gt;
-#include &lt;vector&gt;
 #include &lt;map&gt;
 #include &lt;unordered_map&gt;
-#include &lt;math.h&gt;
+#include &lt;vector&gt;
 
-#include &lt;ros/ros.h&gt;
 #include &lt;geometry_msgs/Point.h&gt;
+#include &lt;ros/ros.h&gt;
 #include &lt;vector_map/vector_map.h&gt;
 
 #include "waypoint_follower/libwaypoint_follower.h"
@@ -37,7 +37,7 @@ private:
   int detection_crosswalk_id_;
   std::vector&lt;geometry_msgs::Point&gt; obstacle_points_;
   std::vector&lt;int&gt; bdID_;
-  
+
   bool enable_multiple_crosswalk_detection_;
   std::vector&lt;int&gt; detection_crosswalk_array_;
 
@@ -67,7 +67,7 @@ public:
   geometry_msgs::Point getPoint(const int &amp;pid) const;
   void calcCenterPoints();
   void setCrossWalkPoints();
-  int findClosestCrosswalk(const int closest_waypoint, const autoware_msgs::lane&amp; lane, const int search_distance);
+  int findClosestCrosswalk(const int closest_waypoint, const autoware_msgs::lane &amp;lane, const int search_distance);
   int getSize() const
   {
     return detection_points_.size();
@@ -96,18 +96,18 @@ public:
   {
     return detection_crosswalk_id_;
   }
-  
+
   void initDetectionCrossWalkIDs()
   {
     return detection_crosswalk_array_.clear();
   }
   void addDetectionCrossWalkIDs(const int &amp;id)
   {
-	  auto itr = std::find(detection_crosswalk_array_.begin(), detection_crosswalk_array_.end(), id);
-	  if(detection_crosswalk_array_.empty() || itr == detection_crosswalk_array_.end()){
-		  detection_crosswalk_array_.push_back(id);
-	  }
-
+    auto itr = std::find(detection_crosswalk_array_.begin(), detection_crosswalk_array_.end(), id);
+    if (detection_crosswalk_array_.empty() || itr == detection_crosswalk_array_.end())
+    {
+      detection_crosswalk_array_.push_back(id);
+    }
   }
   std::vector&lt;int&gt; getDetectionCrossWalkIDs() const
   {
@@ -115,13 +115,12 @@ public:
   }
   void setMultipleDetectionFlag(const bool _multiple_flag)
   {
-	enable_multiple_crosswalk_detection_ = _multiple_flag;
+    enable_multiple_crosswalk_detection_ = _multiple_flag;
   }
   bool isMultipleDetection() const
   {
-	  return enable_multiple_crosswalk_detection_;
+    return enable_multiple_crosswalk_detection_;
   }
- 
 
   CrossWalk()
     : detection_waypoint_(-1)
@@ -176,16 +175,14 @@ inline double calcSquareOfLength(const geometry_msgs::Point &amp;p1, const geometry_
 }
 
 // Calculate waypoint index corresponding to distance from begin_waypoint
-inline int calcWaypointIndexReverse(const autoware_msgs::lane&amp; lane, const int begin_waypoint, const double distance)
+inline int calcWaypointIndexReverse(const autoware_msgs::lane &amp;lane, const int begin_waypoint, const double distance)
 {
   double dist_sum = 0;
   for (int i = begin_waypoint; i &gt; 0; i--)
   {
-    tf::Vector3 v1(lane.waypoints[i].pose.pose.position.x,
-                   lane.waypoints[i].pose.pose.position.y, 0);
+    tf::Vector3 v1(lane.waypoints[i].pose.pose.position.x, lane.waypoints[i].pose.pose.position.y, 0);
 
-    tf::Vector3 v2(lane.waypoints[i - 1].pose.pose.position.x,
-                   lane.waypoints[i - 1].pose.pose.position.y, 0);
+    tf::Vector3 v2(lane.waypoints[i - 1].pose.pose.position.x, lane.waypoints[i - 1].pose.pose.position.y, 0);
 
     dist_sum += tf::tfDistance(v1, v2);
 
@@ -197,5 +194,4 @@ inline int calcWaypointIndexReverse(const autoware_msgs::lane&amp; lane, const int b
   return 0;
 }
 
-
 #endif /* _VELOCITY_SET_H */
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="108" deleted_lines="78">
				<diff>@@ -33,8 +33,8 @@
 #include &lt;iostream&gt;
 
 #include "libvelocity_set.h"
-#include "velocity_set_path.h"
 #include "velocity_set_info.h"
+#include "velocity_set_path.h"
 
 namespace
 {
@@ -42,9 +42,8 @@ constexpr int LOOP_RATE = 10;
 constexpr double DECELERATION_SEARCH_DISTANCE = 30;
 constexpr double STOP_SEARCH_DISTANCE = 60;
 
-
 // Display a detected obstacle
-void displayObstacle(const EControl &amp;kind, const ObstaclePoints&amp; obstacle_points, const ros::Publisher&amp; obstacle_pub)
+void displayObstacle(const EControl&amp; kind, const ObstaclePoints&amp; obstacle_points, const ros::Publisher&amp; obstacle_pub)
 {
   visualization_msgs::Marker marker;
   marker.header.frame_id = "/map";
@@ -60,7 +59,7 @@ void displayObstacle(const EControl &amp;kind, const ObstaclePoints&amp; obstacle_points
     marker.pose.position = obstacle_points.getObstaclePoint(kind);
     prev_obstacle_point = marker.pose.position;
   }
-  else // kind == OTHERS
+  else  // kind == OTHERS
   {
     marker.pose.position = prev_obstacle_point;
   }
@@ -86,10 +85,12 @@ void displayObstacle(const EControl &amp;kind, const ObstaclePoints&amp; obstacle_points
   marker.lifetime = ros::Duration(0.1);
   marker.frame_locked = true;
 
-  //obstacle_pub.publish(marker);
+  // obstacle_pub.publish(marker);
 }
 
-void displayDetectionRange(const autoware_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, const int closest_waypoint, const EControl &amp;kind, const int obstacle_waypoint, const double stop_range, const double deceleration_range, const ros::Publisher&amp; detection_range_pub)
+void displayDetectionRange(const autoware_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, const int closest_waypoint,
+                           const EControl&amp; kind, const int obstacle_waypoint, const double stop_range,
+                           const double deceleration_range, const ros::Publisher&amp; detection_range_pub)
 {
   // set up for marker array
   visualization_msgs::MarkerArray marker_array;
@@ -174,26 +175,31 @@ void displayDetectionRange(const autoware_msgs::lane&amp; lane, const CrossWalk&amp; cro
     waypoint_marker_stop.points.push_back(point);
 
     if (i &gt; DECELERATION_SEARCH_DISTANCE)
-	    continue;
+      continue;
     waypoint_marker_decelerate.points.push_back(point);
   }
 
   if (crosswalk_id &gt; 0)
   {
-	  if(!crosswalk.isMultipleDetection()){
-		  for (const auto &amp;p : crosswalk.getDetectionPoints(crosswalk_id).points)
-			  crosswalk_marker.points.push_back(p);
-	  }else {
-		  for (const auto &amp;c_id : crosswalk.getDetectionCrossWalkIDs()){
-			  for (const auto &amp;p : crosswalk.getDetectionPoints(c_id).points){
-				  scale = crosswalk.getDetectionPoints(c_id).width;
-				  crosswalk_marker.scale.x = scale;
-				  crosswalk_marker.scale.y = scale;
-				  crosswalk_marker.scale.z = scale;
-				  crosswalk_marker.points.push_back(p);
-			  }
-		  }
-	  }
+    if (!crosswalk.isMultipleDetection())
+    {
+      for (const auto&amp; p : crosswalk.getDetectionPoints(crosswalk_id).points)
+        crosswalk_marker.points.push_back(p);
+    }
+    else
+    {
+      for (const auto&amp; c_id : crosswalk.getDetectionCrossWalkIDs())
+      {
+        for (const auto&amp; p : crosswalk.getDetectionPoints(c_id).points)
+        {
+          scale = crosswalk.getDetectionPoints(c_id).width;
+          crosswalk_marker.scale.x = scale;
+          crosswalk_marker.scale.y = scale;
+          crosswalk_marker.scale.z = scale;
+          crosswalk_marker.points.push_back(p);
+        }
+      }
+    }
   }
   // publish marker
   marker_array.markers.push_back(crosswalk_marker);
@@ -206,46 +212,53 @@ void displayDetectionRange(const autoware_msgs::lane&amp; lane, const CrossWalk&amp; cro
 }
 
 // obstacle detection for crosswalk
-EControl crossWalkDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const CrossWalk&amp; crosswalk, const geometry_msgs::PoseStamped&amp; localizer_pose, const int points_threshold, ObstaclePoints* obstacle_points)
+EControl crossWalkDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const CrossWalk&amp; crosswalk,
+                            const geometry_msgs::PoseStamped&amp; localizer_pose, const int points_threshold,
+                            ObstaclePoints* obstacle_points)
 {
   int crosswalk_id = crosswalk.getDetectionCrossWalkID();
   double search_radius = crosswalk.getDetectionPoints(crosswalk_id).width / 2;
-  //std::vector&lt;int&gt; crosswalk_ids crosswalk.getDetectionCrossWalkIDs();
+  // std::vector&lt;int&gt; crosswalk_ids crosswalk.getDetectionCrossWalkIDs();
 
   // Search each calculated points in the crosswalk
-  for (const auto &amp;c_id : crosswalk.getDetectionCrossWalkIDs()){
-	  for (const auto &amp;p : crosswalk.getDetectionPoints(c_id).points)
-	  {
-		  geometry_msgs::Point detection_point = calcRelativeCoordinate(p, localizer_pose.pose);
-		  tf::Vector3 detection_vector = point2vector(detection_point);
-		  detection_vector.setZ(0.0);
-
-		  int stop_count = 0;  // the number of points in the detection area
-		  for (const auto &amp;p : points)
-		  {
-			  tf::Vector3 point_vector(p.x, p.y, 0.0);
-			  double distance = tf::tfDistance(point_vector, detection_vector);
-			  if (distance &lt; search_radius)
-			  {
-				  stop_count++;
-				  geometry_msgs::Point point_temp;
-				  point_temp.x = p.x;
-				  point_temp.y = p.y;
-				  point_temp.z = p.z;
-				  obstacle_points-&gt;setStopPoint(calcAbsoluteCoordinate(point_temp, localizer_pose.pose));
-			  }
-			  if (stop_count &gt; points_threshold)
-				  return EControl::STOP;
-		  }
-	  }
-
-	  obstacle_points-&gt;clearStopPoints();
-	  if(!crosswalk.isMultipleDetection())break;
+  for (const auto&amp; c_id : crosswalk.getDetectionCrossWalkIDs())
+  {
+    for (const auto&amp; p : crosswalk.getDetectionPoints(c_id).points)
+    {
+      geometry_msgs::Point detection_point = calcRelativeCoordinate(p, localizer_pose.pose);
+      tf::Vector3 detection_vector = point2vector(detection_point);
+      detection_vector.setZ(0.0);
+
+      int stop_count = 0;  // the number of points in the detection area
+      for (const auto&amp; p : points)
+      {
+        tf::Vector3 point_vector(p.x, p.y, 0.0);
+        double distance = tf::tfDistance(point_vector, detection_vector);
+        if (distance &lt; search_radius)
+        {
+          stop_count++;
+          geometry_msgs::Point point_temp;
+          point_temp.x = p.x;
+          point_temp.y = p.y;
+          point_temp.z = p.z;
+          obstacle_points-&gt;setStopPoint(calcAbsoluteCoordinate(point_temp, localizer_pose.pose));
+        }
+        if (stop_count &gt; points_threshold)
+          return EControl::STOP;
+      }
+    }
+
+    obstacle_points-&gt;clearStopPoints();
+    if (!crosswalk.isMultipleDetection())
+      break;
   }
   return EControl::KEEP;  // find no obstacles
 }
 
-int detectStopObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint, const autoware_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, double stop_range, double points_threshold, const geometry_msgs::PoseStamped&amp; localizer_pose, ObstaclePoints* obstacle_points)
+int detectStopObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint,
+                       const autoware_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, double stop_range,
+                       double points_threshold, const geometry_msgs::PoseStamped&amp; localizer_pose,
+                       ObstaclePoints* obstacle_points)
 {
   int stop_obstacle_waypoint = -1;
   // start search from the closest waypoint
@@ -285,7 +298,7 @@ int detectStopObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int c
         point_temp.x = p.x;
         point_temp.y = p.y;
         point_temp.z = p.z;
-	obstacle_points-&gt;setStopPoint(calcAbsoluteCoordinate(point_temp, localizer_pose.pose));
+        obstacle_points-&gt;setStopPoint(calcAbsoluteCoordinate(point_temp, localizer_pose.pose));
       }
     }
 
@@ -304,7 +317,10 @@ int detectStopObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int c
   return stop_obstacle_waypoint;
 }
 
-int detectDecelerateObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint, const autoware_msgs::lane&amp; lane, const double stop_range, const double deceleration_range, const double points_threshold, const geometry_msgs::PoseStamped&amp; localizer_pose, ObstaclePoints* obstacle_points)
+int detectDecelerateObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint,
+                             const autoware_msgs::lane&amp; lane, const double stop_range, const double deceleration_range,
+                             const double points_threshold, const geometry_msgs::PoseStamped&amp; localizer_pose,
+                             ObstaclePoints* obstacle_points)
 {
   int decelerate_obstacle_waypoint = -1;
   // start search from the closest waypoint
@@ -333,7 +349,7 @@ int detectDecelerateObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const
         point_temp.x = p.x;
         point_temp.y = p.y;
         point_temp.z = p.z;
-	obstacle_points-&gt;setDeceleratePoint(calcAbsoluteCoordinate(point_temp, localizer_pose.pose));
+        obstacle_points-&gt;setDeceleratePoint(calcAbsoluteCoordinate(point_temp, localizer_pose.pose));
       }
     }
 
@@ -352,14 +368,17 @@ int detectDecelerateObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const
   return decelerate_obstacle_waypoint;
 }
 
-
 // Detect an obstacle by using pointcloud
-EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint, const autoware_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo&amp; vs_info, int* obstacle_waypoint, ObstaclePoints* obstacle_points)
+EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint,
+                         const autoware_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo&amp; vs_info,
+                         int* obstacle_waypoint, ObstaclePoints* obstacle_points)
 {
   if (points.empty() == true || closest_waypoint &lt; 0)
     return EControl::KEEP;
 
-  int stop_obstacle_waypoint = detectStopObstacle(points, closest_waypoint, lane, crosswalk, vs_info.getStopRange(), vs_info.getPointsThreshold(), vs_info.getLocalizerPose(), obstacle_points);
+  int stop_obstacle_waypoint =
+      detectStopObstacle(points, closest_waypoint, lane, crosswalk, vs_info.getStopRange(),
+                         vs_info.getPointsThreshold(), vs_info.getLocalizerPose(), obstacle_points);
 
   // skip searching deceleration range
   if (vs_info.getDecelerationRange() &lt; 0.01)
@@ -368,12 +387,14 @@ EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int
     return stop_obstacle_waypoint &lt; 0 ? EControl::KEEP : EControl::STOP;
   }
 
-  int decelerate_obstacle_waypoint = detectDecelerateObstacle(points, closest_waypoint, lane, vs_info.getStopRange(), vs_info.getDecelerationRange(), vs_info.getPointsThreshold(), vs_info.getLocalizerPose(), obstacle_points);
+  int decelerate_obstacle_waypoint =
+      detectDecelerateObstacle(points, closest_waypoint, lane, vs_info.getStopRange(), vs_info.getDecelerationRange(),
+                               vs_info.getPointsThreshold(), vs_info.getLocalizerPose(), obstacle_points);
 
   // stop obstacle was not found
   if (stop_obstacle_waypoint &lt; 0)
   {
-    *obstacle_waypoint  = decelerate_obstacle_waypoint;
+    *obstacle_waypoint = decelerate_obstacle_waypoint;
     return decelerate_obstacle_waypoint &lt; 0 ? EControl::KEEP : EControl::DECELERATE;
   }
 
@@ -385,7 +406,8 @@ EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int
   }
 
   // about 5.0 meter
-  double waypoint_interval = getPlaneDistance(lane.waypoints[0].pose.pose.position, lane.waypoints[1].pose.pose.position);
+  double waypoint_interval =
+      getPlaneDistance(lane.waypoints[0].pose.pose.position, lane.waypoints[1].pose.pose.position);
   int stop_decelerate_threshold = 5 / waypoint_interval;
 
   // both were found
@@ -399,14 +421,17 @@ EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int
     *obstacle_waypoint = stop_obstacle_waypoint;
     return EControl::STOP;
   }
-
 }
 
-EControl obstacleDetection(int closest_waypoint, const autoware_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo vs_info, const ros::Publisher&amp; detection_range_pub, const ros::Publisher&amp; obstacle_pub, int* obstacle_waypoint)
+EControl obstacleDetection(int closest_waypoint, const autoware_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk,
+                           const VelocitySetInfo vs_info, const ros::Publisher&amp; detection_range_pub,
+                           const ros::Publisher&amp; obstacle_pub, int* obstacle_waypoint)
 {
   ObstaclePoints obstacle_points;
-  EControl detection_result = pointsDetection(vs_info.getPoints(), closest_waypoint, lane, crosswalk, vs_info, obstacle_waypoint, &amp;obstacle_points);
-  displayDetectionRange(lane, crosswalk, closest_waypoint, detection_result, *obstacle_waypoint, vs_info.getStopRange(), vs_info.getDecelerationRange(), detection_range_pub);
+  EControl detection_result = pointsDetection(vs_info.getPoints(), closest_waypoint, lane, crosswalk, vs_info,
+                                              obstacle_waypoint, &amp;obstacle_points);
+  displayDetectionRange(lane, crosswalk, closest_waypoint, detection_result, *obstacle_waypoint, vs_info.getStopRange(),
+                        vs_info.getDecelerationRange(), detection_range_pub);
 
   static int false_count = 0;
   static EControl prev_detection = EControl::KEEP;
@@ -416,10 +441,10 @@ EControl obstacleDetection(int closest_waypoint, const autoware_msgs::lane&amp; lane
   if (detection_result == EControl::STOP || detection_result == EControl::DECELERATE)
   {
     displayObstacle(detection_result, obstacle_points, obstacle_pub);
-      prev_detection = detection_result;
-      false_count = 0;
-      prev_obstacle_waypoint = *obstacle_waypoint;
-      return detection_result;
+    prev_detection = detection_result;
+    false_count = 0;
+    prev_obstacle_waypoint = *obstacle_waypoint;
+    return detection_result;
   }
 
   // there are no obstacles, but wait a little for safety
@@ -442,12 +467,14 @@ EControl obstacleDetection(int closest_waypoint, const autoware_msgs::lane&amp; lane
   return detection_result;
 }
 
-void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_result, int closest_waypoint, int obstacle_waypoint, const ros::Publisher&amp; final_waypoints_pub, VelocitySetPath* vs_path)
+void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_result, int closest_waypoint,
+                     int obstacle_waypoint, const ros::Publisher&amp; final_waypoints_pub, VelocitySetPath* vs_path)
 {
   if (detection_result == EControl::STOP)
   {  // STOP for obstacle
     // stop_waypoint is about stop_distance meter away from obstacles
-    int stop_waypoint = calcWaypointIndexReverse(vs_path-&gt;getPrevWaypoints(), obstacle_waypoint, vs_info.getStopDistance());
+    int stop_waypoint =
+        calcWaypointIndexReverse(vs_path-&gt;getPrevWaypoints(), obstacle_waypoint, vs_info.getStopDistance());
 
     // change waypoints to stop by the stop_waypoint
     vs_path-&gt;changeWaypointsForStopping(stop_waypoint, obstacle_waypoint, closest_waypoint, vs_info.getDeceleration());
@@ -475,10 +502,9 @@ void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_r
   }
 }
 
-} // end namespace
-
+}  // end namespace
 
-int main(int argc, char **argv)
+int main(int argc, char** argv)
 {
   ros::init(argc, argv, "velocity_set");
 
@@ -500,14 +526,16 @@ int main(int argc, char **argv)
 
   // velocity set subscriber
   ros::Subscriber waypoints_sub = nh.subscribe("safety_waypoints", 1, &amp;VelocitySetPath::waypointsCallback, &amp;vs_path);
-  ros::Subscriber current_vel_sub = nh.subscribe("current_velocity", 1, &amp;VelocitySetPath::currentVelocityCallback, &amp;vs_path);
+  ros::Subscriber current_vel_sub =
+      nh.subscribe("current_velocity", 1, &amp;VelocitySetPath::currentVelocityCallback, &amp;vs_path);
 
   // velocity set info subscriber
   ros::Subscriber config_sub = nh.subscribe("config/velocity_set", 1, &amp;VelocitySetInfo::configCallback, &amp;vs_info);
   ros::Subscriber points_sub = nh.subscribe(points_topic, 1, &amp;VelocitySetInfo::pointsCallback, &amp;vs_info);
   ros::Subscriber localizer_sub = nh.subscribe("localizer_pose", 1, &amp;VelocitySetInfo::localizerPoseCallback, &amp;vs_info);
   ros::Subscriber control_pose_sub = nh.subscribe("current_pose", 1, &amp;VelocitySetInfo::controlPoseCallback, &amp;vs_info);
-  //ros::Subscriber closest_waypoint_sub = nh.subscribe("closest_waypoint", 1, &amp;VelocitySetInfo::closestWaypointCallback, &amp;vs_info);
+  // ros::Subscriber closest_waypoint_sub = nh.subscribe("closest_waypoint", 1,
+  // &amp;VelocitySetInfo::closestWaypointCallback, &amp;vs_info);
 
   // vector map subscriber
   ros::Subscriber sub_dtlane = nh.subscribe("vector_map_info/cross_walk", 1, &amp;CrossWalk::crossWalkCallback, &amp;crosswalk);
@@ -540,10 +568,12 @@ int main(int argc, char **argv)
     crosswalk.setMultipleDetectionFlag(enable_multiple_crosswalk_detection);
 
     if (use_crosswalk_detection)
-      crosswalk.setDetectionWaypoint(crosswalk.findClosestCrosswalk(closest_waypoint, vs_path.getPrevWaypoints(), STOP_SEARCH_DISTANCE));
+      crosswalk.setDetectionWaypoint(
+          crosswalk.findClosestCrosswalk(closest_waypoint, vs_path.getPrevWaypoints(), STOP_SEARCH_DISTANCE));
 
     int obstacle_waypoint = -1;
-    EControl detection_result = obstacleDetection(closest_waypoint, vs_path.getPrevWaypoints(), crosswalk, vs_info, detection_range_pub, obstacle_pub, &amp;obstacle_waypoint);
+    EControl detection_result = obstacleDetection(closest_waypoint, vs_path.getPrevWaypoints(), crosswalk, vs_info,
+                                                  detection_range_pub, obstacle_pub, &amp;obstacle_waypoint);
 
     changeWaypoints(vs_info, detection_result, closest_waypoint, obstacle_waypoint, final_waypoints_pub, &amp;vs_path);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ad11d9289f6785125510c2ed52c3c6a4d3c7811c" author="Yusuke FUJII">
		<msg>R.I.P.</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="0" deleted_lines="3">
				<diff>@@ -193,9 +193,6 @@ void displayDetectionRange(const autoware_msgs::lane&amp; lane, const CrossWalk&amp; cro
         for (const auto&amp; p : crosswalk.getDetectionPoints(c_id).points)
         {
           scale = crosswalk.getDetectionPoints(c_id).width;
-          crosswalk_marker.scale.x = scale;
-          crosswalk_marker.scale.y = scale;
-          crosswalk_marker.scale.z = scale;
           crosswalk_marker.points.push_back(p);
         }
       }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="9f11a4b6cb8ff63fa406d5a285234b9f9faa9f10" author="TomohitoAndo">
		<msg>Add feature to put simulated obstacles in astar planner</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\semantics\packages\object_map\nodes\points2costmap\points2costmap.cpp" new_path="ros\src\computing\perception\semantics\packages\object_map\nodes\points2costmap\points2costmap.cpp" added_lines="27" deleted_lines="0">
				<diff>@@ -49,6 +49,24 @@ double g_offset_x;
 double g_offset_y;
 double g_offset_z;
 
+pcl::PointCloud&lt;pcl::PointXYZ&gt; g_obstacle_sim_points;
+bool g_use_obstacle_sim = false;
+
+void callbackFromObstacleSim(const sensor_msgs::PointCloud2ConstPtr &amp;msg)
+{
+  pcl::fromROSMsg(*msg, g_obstacle_sim_points);
+
+  g_use_obstacle_sim = true;
+}
+
+void joinPoints(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points1, pcl::PointCloud&lt;pcl::PointXYZ&gt;* points2)
+{
+  for (const auto&amp; p : points1)
+  {
+    points2-&gt;push_back(p);
+  }
+}
+
 std::vector&lt;int&gt; createCostMap(const pcl::PointCloud&lt;pcl::PointXYZ&gt; &amp;scan)
 {
   std::vector&lt;int&gt; cost_map(g_cell_width * g_cell_height, 0);
@@ -147,6 +165,14 @@ void createOccupancyGrid(const sensor_msgs::PointCloud2::ConstPtr &amp;input)
   pcl::PointCloud&lt;pcl::PointXYZ&gt; scan;
   pcl::fromROSMsg(*input, scan);
 
+  // use simulated obstacle
+  if (g_use_obstacle_sim)
+  {
+    joinPoints(g_obstacle_sim_points, &amp;scan);
+    g_obstacle_sim_points.clear();
+  }
+  // ---
+
   static nav_msgs::OccupancyGrid og;
   if (!count)
     setOccupancyGrid(&amp;og);
@@ -189,6 +215,7 @@ int main(int argc, char **argv)
 
   g_costmap_pub = nh.advertise&lt;nav_msgs::OccupancyGrid&gt;("realtime_cost_map", 10);
   ros::Subscriber points_sub = nh.subscribe(points_topic, 10, createOccupancyGrid);
+  ros::Subscriber obstacle_sim_points_sub = nh.subscribe("obstacle_sim_pointcloud", 1, callbackFromObstacleSim);
 
   ros::spin();
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="1" deleted_lines="0">
				<diff>@@ -490,6 +490,7 @@ int main(int argc, char **argv)
   ros::Subscriber points_sub = nh.subscribe(points_topic, 1, &amp;VelocitySetInfo::pointsCallback, &amp;vs_info);
   ros::Subscriber localizer_sub = nh.subscribe("localizer_pose", 1, &amp;VelocitySetInfo::localizerPoseCallback, &amp;vs_info);
   ros::Subscriber control_pose_sub = nh.subscribe("current_pose", 1, &amp;VelocitySetInfo::controlPoseCallback, &amp;vs_info);
+  ros::Subscriber obstacle_sim_points_sub = nh.subscribe("obstacle_sim_pointcloud", 1, &amp;VelocitySetInfo::obstacleSimCallback, &amp;vs_info);
   //ros::Subscriber closest_waypoint_sub = nh.subscribe("closest_waypoint", 1, &amp;VelocitySetInfo::closestWaypointCallback, &amp;vs_info);
 
   // vector map subscriber
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.cpp" added_lines="23" deleted_lines="1">
				<diff>@@ -30,6 +30,14 @@
 
 #include "velocity_set_info.h"
 
+void joinPoints(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points1, pcl::PointCloud&lt;pcl::PointXYZ&gt;* points2)
+{
+  for (const auto&amp; p : points1)
+  {
+    points2-&gt;push_back(p);
+  }
+}
+
 VelocitySetInfo::VelocitySetInfo()
   : stop_range_(1.3),
     deceleration_range_(0),
@@ -40,7 +48,8 @@ VelocitySetInfo::VelocitySetInfo()
     decel_(0.8),
     velocity_change_limit_(2.77),
     temporal_waypoints_size_(100),
-    set_pose_(false)
+    set_pose_(false),
+    use_obstacle_sim_(false)
 {
   ros::NodeHandle private_nh_("~");
   private_nh_.param&lt;double&gt;("remove_points_upto", remove_points_upto_, 2.3);
@@ -88,6 +97,12 @@ void VelocitySetInfo::pointsCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg
 
     points_.push_back(v);
   }
+
+  if (use_obstacle_sim_)
+  {
+    joinPoints(obstacle_sim_points_, &amp;points_);
+    obstacle_sim_points_.clear();
+  }
 }
 
 void VelocitySetInfo::controlPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
@@ -102,3 +117,10 @@ void VelocitySetInfo::localizerPoseCallback(const geometry_msgs::PoseStampedCons
 {
   localizer_pose_ = *msg;
 }
+
+void VelocitySetInfo::obstacleSimCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg)
+{
+  pcl::fromROSMsg(*msg, obstacle_sim_points_);
+
+  use_obstacle_sim_ = true;
+}
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.h" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set_info.h" added_lines="3" deleted_lines="0">
				<diff>@@ -56,9 +56,11 @@ class VelocitySetInfo
   double remove_points_upto_;
 
   pcl::PointCloud&lt;pcl::PointXYZ&gt; points_;
+  pcl::PointCloud&lt;pcl::PointXYZ&gt; obstacle_sim_points_;
   geometry_msgs::PoseStamped localizer_pose_;  // pose of sensor
   geometry_msgs::PoseStamped control_pose_;    // pose of base_link
   bool set_pose_;
+  bool use_obstacle_sim_;
 
  public:
   VelocitySetInfo();
@@ -69,6 +71,7 @@ class VelocitySetInfo
   void pointsCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg);
   void controlPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void localizerPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
+  void obstacleSimCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg);
 
   void clearPoints();
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="e624c0f31800e99b1bbbde20f5ede2be7bdcd142" author="Yusuke FUJII">
		<msg>fix segv</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\libvelocity_set.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -263,7 +263,7 @@ int CrossWalk::findClosestCrosswalk(const int closest_waypoint, const autoware_m
   initDetectionCrossWalkIDs();  // for multiple
 
   // Find near cross walk
-  for (int num = closest_waypoint; num &lt; closest_waypoint + search_distance; num++)
+  for (int num = closest_waypoint; num &lt; closest_waypoint + search_distance &amp;&amp; num &lt; (int)lane.waypoints.size(); num++)
   {
     geometry_msgs::Point waypoint = lane.waypoints[num].pose.pose.position;
     waypoint.z = 0.0;  // ignore Z axis
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="3a123324f6d82c56a1fc4cf656ac52289ae1f58e" author="Yusuke FUJII">
		<msg>Add changing topic name option for the planner selector.</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\RoadNetwork.h" new_path="ros\src\computing\planning\common\lib\openplanner\op_planner\include\RoadNetwork.h" added_lines="5" deleted_lines="0">
				<diff>@@ -739,6 +739,8 @@ public:
 	bool 	enableHeadingSmoothing;
 	bool 	enableTrafficLightBehavior;
 	bool 	enableStopSignBehavior;
+	
+	bool	enableDynamicPlannerSwitch;
 
 	bool 	enabTrajectoryVelocities;
 
@@ -773,6 +775,9 @@ public:
 		enableLaneChange 				= false;
 		enableStopSignBehavior			= false;
 		enabTrajectoryVelocities		= false;
+
+		enableDynamicPlannerSwitch 		= false;
+
 	}
 };
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="11" deleted_lines="1">
				<diff>@@ -510,9 +510,13 @@ int main(int argc, char** argv)
 
   bool use_crosswalk_detection;
   bool enable_multiple_crosswalk_detection;
+  bool enablePlannerDynamicSwitch;
+
   std::string points_topic;
   private_nh.param&lt;bool&gt;("use_crosswalk_detection", use_crosswalk_detection, true);
   private_nh.param&lt;bool&gt;("enable_multiple_crosswalk_detection", enable_multiple_crosswalk_detection, true);
+  private_nh.param&lt;bool&gt;("enablePlannerDynamicSwitch", enablePlannerDynamicSwitch, true);
+
 
   private_nh.param&lt;std::string&gt;("points_topic", points_topic, "points_lanes");
 
@@ -542,10 +546,16 @@ int main(int argc, char** argv)
 
   // publisher
   ros::Publisher detection_range_pub = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("detection_range", 1);
-  ros::Publisher final_waypoints_pub = nh.advertise&lt;autoware_msgs::lane&gt;("final_waypoints", 1, true);
   ros::Publisher obstacle_pub = nh.advertise&lt;visualization_msgs::Marker&gt;("obstacle", 1);
   ros::Publisher obstacle_waypoint_pub = nh.advertise&lt;std_msgs::Int32&gt;("obstacle_waypoint", 1, true);
 
+  ros::Publisher final_waypoints_pub;
+  if(enablePlannerDynamicSwitch){
+	  final_waypoints_pub = nh.advertise&lt;autoware_msgs::lane&gt;("astar/final_waypoints", 1, true);
+  }else{
+	  final_waypoints_pub = nh.advertise&lt;autoware_msgs::lane&gt;("final_waypoints", 1, true);
+  }
+
   ros::Rate loop_rate(LOOP_RATE);
   while (ros::ok())
   {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\include\dp_planner_core.h" new_path="ros\src\computing\planning\motion\packages\dp_planner\include\dp_planner_core.h" added_lines="3" deleted_lines="0">
				<diff>@@ -157,6 +157,7 @@ protected:
 
   	std::vector&lt;std::string&gt;    m_LogData;
 
+	bool  enablePlannerDynamicSwitch;
 
 protected:
 	//ROS messages (topics)
@@ -173,10 +174,12 @@ protected:
 	ros::Publisher pub_GoalPoint;
 	ros::Publisher pub_AStarStartPoint;
 	ros::Publisher pub_AStarGoalPoint;
+	ros::Publisher pub_EnableLattice;
 
 	ros::Publisher pub_DetectedPolygonsRviz;
 	ros::Publisher pub_TrackedObstaclesRviz;
 	ros::Publisher pub_LocalTrajectoriesRviz;
+	ros::Publisher pub_LocalTrajectoriesRviz_dynamic;
 	ros::Publisher pub_TestLineRviz;
 	ros::Publisher pub_BehaviorStateRviz;
 	ros::Publisher pub_SafetyBorderRviz;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" new_path="ros\src\computing\planning\motion\packages\dp_planner\nodes\dp_planner_core.cpp" added_lines="43" deleted_lines="5">
				<diff>@@ -74,6 +74,8 @@ PlannerX::PlannerX()
 	m_ObstacleTracking.m_DT = 0.12;
 	m_ObstacleTracking.m_bUseCenterOnly = true;
 
+	enablePlannerDynamicSwitch = false;
+
 
 	int iSource = 0;
 	nh.getParam("/dp_planner/mapSource", iSource);
@@ -95,9 +97,17 @@ PlannerX::PlannerX()
 	m_OriginPos.position.z  = transform.getOrigin().z();
 
 
-	pub_LocalPath = nh.advertise&lt;autoware_msgs::lane&gt;("final_waypoints", 100,true);
-	pub_LocalBasePath = nh.advertise&lt;autoware_msgs::lane&gt;("base_waypoints", 100,true);
-	pub_ClosestIndex = nh.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 100,true);
+	std::string topic_prefix;
+	nh.getParam("/dp_planner/enablePlannerDynamicSwitch", enablePlannerDynamicSwitch);
+	if(enablePlannerDynamicSwitch){
+		topic_prefix = "/dp";
+		pub_LocalTrajectoriesRviz_dynamic = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("local_trajectories_dynamic", 1);
+		pub_EnableLattice = nh.advertise&lt;std_msgs::Int32&gt;("enableLattice", 1);
+	}
+
+	pub_LocalPath = nh.advertise&lt;autoware_msgs::lane&gt;(topic_prefix + "/final_waypoints", 100,true);
+	pub_LocalBasePath = nh.advertise&lt;autoware_msgs::lane&gt;(topic_prefix + "/base_waypoints", 100,true);
+	pub_ClosestIndex = nh.advertise&lt;std_msgs::Int32&gt;(topic_prefix + "/closest_waypoint", 100,true);
 
 	pub_BehaviorState = nh.advertise&lt;geometry_msgs::TwistStamped&gt;("current_behavior", 1);
 	pub_GlobalPlanNodes = nh.advertise&lt;geometry_msgs::PoseArray&gt;("global_plan_nodes", 1);
@@ -109,6 +119,7 @@ PlannerX::PlannerX()
 	pub_DetectedPolygonsRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("detected_polygons", 1, true);
 	pub_TrackedObstaclesRviz = nh.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("dp_planner_tracked_boxes", 1);
 	pub_LocalTrajectoriesRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;("local_trajectories", 1);
+	
 	pub_TestLineRviz	= nh.advertise&lt;visualization_msgs::MarkerArray&gt;("testing_line", 1);
 	pub_BehaviorStateRviz = nh.advertise&lt;visualization_msgs::Marker&gt;("behavior_state", 1);
 	pub_SafetyBorderRviz  = nh.advertise&lt;visualization_msgs::Marker&gt;("safety_border", 1);
@@ -410,6 +421,7 @@ void PlannerX::UpdatePlanningParams()
 	nh.getParam("/dp_planner/enableObjectTracking", m_bEnableTracking);
 	nh.getParam("/dp_planner/enableOutsideControl", m_bEnableOutsideControl);
 
+
 	PlannerHNS::ControllerParams controlParams;
 	controlParams.Steering_Gain = PlannerHNS::PID_CONST(0.07, 0.02, 0.01);
 	controlParams.Velocity_Gain = PlannerHNS::PID_CONST(0.1, 0.005, 0.1);
@@ -429,6 +441,7 @@ void PlannerX::UpdatePlanningParams()
 	m_LocalPlanner.m_SimulationSteeringDelayFactor = controlParams.SimulationSteeringDelay;
 	m_LocalPlanner.Init(controlParams, params, vehicleInfo);
 	m_LocalPlanner.m_pCurrentBehaviorState-&gt;m_Behavior = PlannerHNS::INITIAL_STATE;
+
 }
 
 void PlannerX::callbackGetInitPose(const geometry_msgs::PoseWithCovarianceStampedConstPtr &amp;msg)
@@ -902,6 +915,7 @@ void PlannerX::PlannerMainLoop()
 			 }
 		}
 
+		int iDirection = 0;
 		if(bInitPos &amp;&amp; m_LocalPlanner.m_TotalPath.size()&gt;0)
 		{
 //			bool bMakeNewPlan = false;
@@ -919,7 +933,6 @@ void PlannerX::PlannerMainLoop()
 
 			visualization_msgs::Marker behavior_rviz;
 
-			int iDirection = 0;
 			if(m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory &gt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
 				iDirection = 1;
 			else if(m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory &lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
@@ -1036,9 +1049,35 @@ void PlannerX::PlannerMainLoop()
 		pub_LocalBasePath.publish(current_trajectory);
 		pub_LocalPath.publish(current_trajectory);
 		visualization_msgs::MarkerArray all_rollOuts;
+
+	
 		RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(m_LocalPlanner.m_Path, m_LocalPlanner.m_RollOuts, m_LocalPlanner, all_rollOuts);
 		pub_LocalTrajectoriesRviz.publish(all_rollOuts);
 
+		//Publish markers that visualize only when avoiding objects
+		if(enablePlannerDynamicSwitch){
+			visualization_msgs::MarkerArray all_rollOuts_dynamic;
+			std_msgs::Int32 enableLattice;
+			if(iDirection != 0) { // if obstacle avoidance state,
+				all_rollOuts_dynamic = all_rollOuts;
+		   		
+			     	for(auto &amp;ro : all_rollOuts_dynamic.markers){
+					ro.ns = "global_lane_array_marker_dynamic";
+				}
+				pub_LocalTrajectoriesRviz_dynamic.publish(all_rollOuts_dynamic);
+				enableLattice.data = 1;
+			}else{
+				visualization_msgs::Marker delMarker;
+				delMarker.action = visualization_msgs::Marker::DELETEALL;
+				delMarker.ns = "global_lane_array_marker_dynamic";
+				all_rollOuts_dynamic.markers.push_back(delMarker);
+				pub_LocalTrajectoriesRviz_dynamic.publish(all_rollOuts_dynamic);
+				enableLattice.data = 0;
+			}
+			pub_EnableLattice.publish(enableLattice); //Publish flag of object avoidance
+		}
+
+
 		if(m_CurrentBehavior.bNewPlan)
 		{
 			std::ostringstream str_out;
@@ -1050,7 +1089,6 @@ void PlannerX::PlannerMainLoop()
 		}
 
 
-
 		//Traffic Light Simulation Part
 		if(m_bGreenLight &amp;&amp; UtilityHNS::UtilityH::GetTimeDiffNow(m_TrafficLightTimer) &gt; 5)
 		{
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="176ec761ae859d6236ff6d0205a1c465eb5d19d7" author="Yusuke FUJII">
		<msg>organize package files and directories</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libeuc\include\euclidean_space.hpp" new_path="ros\src\computing\planning\decision\libs\libeuc\include\euclidean_space.hpp" added_lines="0" deleted_lines="1">
				<diff>@@ -47,7 +47,6 @@ public:
   }
 
 
-
 };
 }  // namespace euclidean_space
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\planner_selector\src\planner_selector_node.cpp" new_path="ros\src\computing\planning\decision\packages\planner_selector\nodes\planner_selector\planner_selector_node.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="037c080c6874ee0948a5d7035a4716f67139b339" author="Yusuke FUJII">
		<msg>apply clang-format</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libeuc\include\euclidean_space.hpp" new_path="ros\src\computing\planning\decision\libs\libeuc\include\euclidean_space.hpp" added_lines="5" deleted_lines="7">
				<diff>@@ -34,19 +34,17 @@ private:
 public:
   static double find_distance(point *_a, point *_b)
   {
-	  return std::hypot(std::hypot(_a-&gt;x - _b-&gt;x, _a-&gt;y - _b-&gt;y), _a-&gt;z - _b-&gt;z);
+    return std::hypot(std::hypot(_a-&gt;x - _b-&gt;x, _a-&gt;y - _b-&gt;y), _a-&gt;z - _b-&gt;z);
   }
 
   static double find_angle(point *_a, point *_b)
   {
-	  double _angle = std::atan2(_b-&gt;y - _a-&gt;y, _b-&gt;x - _a-&gt;x);
-	  if(_angle &lt; 0.0)
-		  _angle = _angle + 2 * M_PI;
+    double _angle = std::atan2(_b-&gt;y - _a-&gt;y, _b-&gt;x - _a-&gt;x);
+    if (_angle &lt; 0.0)
+      _angle = _angle + 2 * M_PI;
 
-	  return _angle * 360 / (2 * M_PI);
+    return _angle * 360 / (2 * M_PI);
   }
-
-
 };
 }  // namespace euclidean_space
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libeuc\src\main.cpp" new_path="ros\src\computing\planning\decision\libs\libeuc\src\main.cpp" added_lines="3" deleted_lines="5">
				<diff>@@ -2,8 +2,8 @@
 
 using namespace euclidean_space;
 
-
-int main(void) {
+int main(void)
+{
   double distance = 0;
 
   point *a = new point(5.0, 5.0, 1.0);
@@ -12,10 +12,8 @@ int main(void) {
   distance = EuclideanSpace::find_distance(a, b);
   std::cout &lt;&lt; "distance = " &lt;&lt; distance &lt;&lt; std::endl;
 
-
   double angle = 0.0;
 
-  angle = EuclideanSpace::find_angle(b,a);
+  angle = EuclideanSpace::find_angle(b, a);
   std::cout &lt;&lt; "angle = " &lt;&lt; angle &lt;&lt; std::endl;
-
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" added_lines="3" deleted_lines="4">
				<diff>@@ -85,18 +85,17 @@ public:
 
   bool isState(unsigned long long _state_num);
   bool inState(unsigned long long _state_num);
-  
+
   void StateDecider(void);
 
- 
   bool setCurrentState(BaseState *state);
   bool setCurrentState(BaseState *state, BaseState *substate);
   bool setCurrentState(BaseState *state, BaseState *substate, BaseState *subsubstate);
- 
+
   BaseState *getCurrentState(void);
   std::unique_ptr&lt;std::string&gt; getCurrentStateName(void);
   void showCurrentStateName(void);
-  
+
   BaseState *getStateObject(unsigned long long _state_num);
   void InitContext(void);
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" added_lines="6" deleted_lines="5">
				<diff>@@ -135,7 +135,8 @@ private:
   DriveLaneChangeRightAvoidanceState(void)
   {
     StateName = "LaneChangeRightAvoidanceState";
-    StateNum = DRIVE_STATE | DRIVE_LANECHANGE_STATE | DRIVE_LANECHANGE_RIGHT_STATE |  DRIVE_LANECHANGE_RIGHT_AVOIDANCE_STATE;
+    StateNum =
+        DRIVE_STATE | DRIVE_LANECHANGE_STATE | DRIVE_LANECHANGE_RIGHT_STATE | DRIVE_LANECHANGE_RIGHT_AVOIDANCE_STATE;
     StateTransMask = DRIVE_STATE | DRIVE_LANECHANGE_STATE;
   }
 
@@ -189,7 +190,7 @@ private:
   DriveStopState(void)
   {
     StateName = "DriveStop";
-    StateNum  = DRIVE_STATE | DRIVE_STOP_STATE;
+    StateNum = DRIVE_STATE | DRIVE_STOP_STATE;
     StateTransMask = DRIVE_STATE;
   }
 
@@ -204,7 +205,7 @@ private:
   DriveStopAvoidanceState(void)
   {
     StateName = "DriveStopAvoidance";
-    StateNum  = DRIVE_STATE | DRIVE_STOP_STATE | DRIVE_STOP_AVOIDANCE_STATE;
+    StateNum = DRIVE_STATE | DRIVE_STOP_STATE | DRIVE_STOP_AVOIDANCE_STATE;
     StateTransMask = DRIVE_STATE;
   }
 
@@ -219,7 +220,7 @@ private:
   DriveStopStopLineState(void)
   {
     StateName = "DriveStopStopLine";
-    StateNum  = DRIVE_STATE | DRIVE_STOP_STATE | DRIVE_STOP_STOPLINE_STATE;
+    StateNum = DRIVE_STATE | DRIVE_STOP_STATE | DRIVE_STOP_STOPLINE_STATE;
     StateTransMask = DRIVE_STATE;
   }
 
@@ -232,7 +233,7 @@ private:
   DriveStopTrafficLightState(void)
   {
     StateName = "DriveStopTrafficLight";
-    StateNum  = DRIVE_STATE | DRIVE_STOP_STATE | DRIVE_STOP_TRAFFICLIGHT_STATE;
+    StateNum = DRIVE_STATE | DRIVE_STOP_STATE | DRIVE_STOP_TRAFFICLIGHT_STATE;
     StateTransMask = DRIVE_STATE;
   }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="61" deleted_lines="59">
				<diff>@@ -9,8 +9,8 @@
 #include &lt;euclidean_space.hpp&gt;
 #include &lt;state_context.hpp&gt;
 
-#include &lt;state_common.hpp&gt;
 #include &lt;state.hpp&gt;
+#include &lt;state_common.hpp&gt;
 
 using namespace std;
 
@@ -65,43 +65,43 @@ bool StateContext::setCurrentState(BaseState *_state, BaseState *_substate)
 
 bool StateContext::setCurrentState(BaseState *_state, BaseState *_substate, BaseState *_subsubstate)
 {
-	BaseState *prevState = state_;
-
-	if (!state_)
-	{
-		state_ = _state;
-
-		std::cout &lt;&lt; "Successed to set state \""
-			&lt;&lt; "NULL"
-			&lt;&lt; "\" to \"" &lt;&lt; *_state-&gt;GetStateName().get() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;GetStateTransMask() &lt;&lt; "/"
-			&lt;&lt; "NULL"
-			&lt;&lt; "-" &lt;&lt; _state-&gt;GetStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
-	}
-	else
-	{
-		if (_state &amp;&amp; (_state-&gt;GetStateTransMask() &amp; state_-&gt;GetStateNum()))
-		{
-
-			if(!(state_ == _state)){  
-				state_ = _state;
-				sub_state = _substate;
-				sub_sub_state = _subsubstate;
-
-				std::cout &lt;&lt; "Successed to set state \"" &lt;&lt; *prevState-&gt;GetStateName().get() &lt;&lt; "\" to \""
-					&lt;&lt; *_state-&gt;GetStateName().get() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;GetStateTransMask() &lt;&lt; "/"
-					&lt;&lt; prevState-&gt;GetStateNum() &lt;&lt; "-" &lt;&lt; _state-&gt;GetStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
-			}
-		}
-		else
-		{
-			std::cerr &lt;&lt; "Failed to set state \"" &lt;&lt; *state_-&gt;GetStateName().get() &lt;&lt; "\" to \""
-				&lt;&lt; *_state-&gt;GetStateName().get() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;GetStateTransMask() &lt;&lt; "/"
-				&lt;&lt; state_-&gt;GetStateNum() &lt;&lt; "-" &lt;&lt; _state-&gt;GetStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
-			prevState = nullptr;
-			return false;
-		}
-	}
-	return true;
+  BaseState *prevState = state_;
+
+  if (!state_)
+  {
+    state_ = _state;
+
+    std::cout &lt;&lt; "Successed to set state \""
+              &lt;&lt; "NULL"
+              &lt;&lt; "\" to \"" &lt;&lt; *_state-&gt;GetStateName().get() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;GetStateTransMask() &lt;&lt; "/"
+              &lt;&lt; "NULL"
+              &lt;&lt; "-" &lt;&lt; _state-&gt;GetStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
+  }
+  else
+  {
+    if (_state &amp;&amp; (_state-&gt;GetStateTransMask() &amp; state_-&gt;GetStateNum()))
+    {
+      if (!(state_ == _state))
+      {
+        state_ = _state;
+        sub_state = _substate;
+        sub_sub_state = _subsubstate;
+
+        std::cout &lt;&lt; "Successed to set state \"" &lt;&lt; *prevState-&gt;GetStateName().get() &lt;&lt; "\" to \""
+                  &lt;&lt; *_state-&gt;GetStateName().get() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;GetStateTransMask() &lt;&lt; "/"
+                  &lt;&lt; prevState-&gt;GetStateNum() &lt;&lt; "-" &lt;&lt; _state-&gt;GetStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
+      }
+    }
+    else
+    {
+      std::cerr &lt;&lt; "Failed to set state \"" &lt;&lt; *state_-&gt;GetStateName().get() &lt;&lt; "\" to \""
+                &lt;&lt; *_state-&gt;GetStateName().get() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;GetStateTransMask() &lt;&lt; "/"
+                &lt;&lt; state_-&gt;GetStateNum() &lt;&lt; "-" &lt;&lt; _state-&gt;GetStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
+      prevState = nullptr;
+      return false;
+    }
+  }
+  return true;
 }
 
 BaseState *StateContext::getCurrentState(void)
@@ -139,30 +139,32 @@ void StateContext::handleTrafficLight(uint32_t _light_color)
   }
 }
 
-
-
 #define ANGLE_STRAIGHT 50.0
-#define ANGLE_LEFT  360.0
+#define ANGLE_LEFT 360.0
 #define ANGLE_RIGHT 180.0
 bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
 {
-	if (_hasIntersection){
-		// *Temporary implementation*
-		// To straight/left/right recognition by using angle between
-		// first-waypoint
-		// and end-waypoint in intersection area.
-		int temp = (int)std::floor(_angle+360.0) % 360;
-
-		if (std::abs(temp) &lt;= ANGLE_STRAIGHT)
-			return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_STRAIGHT_STATE]);
-		else if (temp &lt;= ANGLE_RIGHT)
-			return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_RIGHT_STATE]);
-		else if (temp &lt;= ANGLE_LEFT)
-			return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_LEFT_STATE]);
-		else return false;
-	}else{
-		return false;
-	}
+  if (_hasIntersection)
+  {
+    // *Temporary implementation*
+    // To straight/left/right recognition by using angle between
+    // first-waypoint
+    // and end-waypoint in intersection area.
+    int temp = (int)std::floor(_angle + 360.0) % 360;
+
+    if (std::abs(temp) &lt;= ANGLE_STRAIGHT)
+      return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_STRAIGHT_STATE]);
+    else if (temp &lt;= ANGLE_RIGHT)
+      return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_RIGHT_STATE]);
+    else if (temp &lt;= ANGLE_LEFT)
+      return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_LEFT_STATE]);
+    else
+      return false;
+  }
+  else
+  {
+    return false;
+  }
 }
 
 bool StateContext::handleTwistCmd(bool _hasTwistCmd)
@@ -213,7 +215,7 @@ bool StateContext::handleCurrentPose(double _x, double _y, double _z, double _ro
   else
   {
     avg_distances = (avg_distances + distances[0]) / CONV_NUM;
-    
+
     if (avg_distances &lt;= CONVERGENCE_THRESHOLD)
       return this-&gt;setCurrentState(StateStores[DRIVE_STATE]);
     else
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\cross_road_area.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\cross_road_area.hpp" added_lines="19" deleted_lines="21">
				<diff>@@ -8,30 +8,28 @@
 
 #include &lt;autoware_msgs/lane.h&gt;
 
-
 namespace state_machine
 {
 #define CROSS_ROAD 3232
-	class CrossRoadArea
-	{
-		public:
-			int id;
-			int area_id;
-			std::vector&lt;geometry_msgs::Point&gt; points;
-
-			jsk_recognition_msgs::BoundingBox bbox;
-
-			CrossRoadArea(void)
-			{
-				id = 0;
-				area_id = 0;
-				points.clear();
-			}
-
-			static CrossRoadArea *findClosestCrossRoad(const autoware_msgs::lane &amp;_finalwaypoints, std::vector&lt;CrossRoadArea&gt; &amp;intersects);
-
-	};
-
+class CrossRoadArea
+{
+public:
+  int id;
+  int area_id;
+  std::vector&lt;geometry_msgs::Point&gt; points;
+
+  jsk_recognition_msgs::BoundingBox bbox;
+
+  CrossRoadArea(void)
+  {
+    id = 0;
+    area_id = 0;
+    points.clear();
+  }
+
+  static CrossRoadArea *findClosestCrossRoad(const autoware_msgs::lane &amp;_finalwaypoints,
+                                             std::vector&lt;CrossRoadArea&gt; &amp;intersects);
+};
 }
 
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\state_machine_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\state_machine_node.hpp" added_lines="19" deleted_lines="23">
				<diff>@@ -27,29 +27,25 @@
 
 namespace state_machine
 {
-
-
-	enum class EControl
-	{
-		KEEP = -1,
-		STOP = 1,
-		DECELERATE = 2,
-		ACCELERATE = 3,
-		OTHERS = 4,
-	};
+enum class EControl
+{
+  KEEP = -1,
+  STOP = 1,
+  DECELERATE = 2,
+  ACCELERATE = 3,
+  OTHERS = 4,
+};
 
 inline bool hasvMap(void)
 {
-	return true;
+  return true;
 }
 
 inline double mps2kmph(double _mpsval)
 {
-	return (_mpsval * 60 * 60) / 1000;  // mps * 60sec * 60m / 1000m
+  return (_mpsval * 60 * 60) / 1000;  // mps * 60sec * 60m / 1000m
 }
 
-
-
 class StateMachineNode
 {
 private:
@@ -74,9 +70,9 @@ private:
   vector_map_msgs::CrossRoadArray vMap_CrossRoads;
 
   // Current way/behavior status
-  double 	current_velocity_;
-  double 	average_velocity_;
-  int 		CurrentTrafficlight;
+  double current_velocity_;
+  double average_velocity_;
+  int CurrentTrafficlight;
   CrossRoadArea *ClosestArea_;
   std::string CurrentStateName;
   std::string TextOffset;
@@ -105,14 +101,14 @@ private:
   void update_msgs(void);
   void update_pubsub(void);
   void displayMarker(void);
-  
-  // 
+
+  //
   bool isInsideArea(geometry_msgs::Point pt);
   bool isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
 
   double calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
- 
-  //callback by topic subscribing
+
+  // callback by topic subscribing
   void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
   void callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg);
   void callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg);
@@ -128,7 +124,7 @@ private:
 
   // for ros dynamic reconfigure
   // Currently. this feature is not working.
-  //static void callbackFromDynamicReconfigure(state_machine::state_machineConfig &amp;config, uint32_t level);
+  // static void callbackFromDynamicReconfigure(state_machine::state_machineConfig &amp;config, uint32_t level);
 
   // in near future, these function will be deprecate
   CrossRoadArea *findClosestCrossRoad(void);
@@ -142,7 +138,7 @@ public:
 
     ctx = new StateContext();
     this-&gt;initROS(argc, argv);
- 
+
     vector_map_init = false;
     vMap_Areas_flag = vMap_Lines_flag = vMap_Points_flag = vMap_CrossRoads_flag = false;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" added_lines="33" deleted_lines="34">
				<diff>@@ -3,49 +3,48 @@
 
 namespace state_machine
 {
-
-#define TARGET_WAYPOINTS_NUM 15 //need to change rosparam
-CrossRoadArea *CrossRoadArea::findClosestCrossRoad(const autoware_msgs::lane &amp;_finalwaypoints, std::vector&lt;CrossRoadArea&gt; &amp;intersects)
+#define TARGET_WAYPOINTS_NUM 15  // need to change rosparam
+CrossRoadArea *CrossRoadArea::findClosestCrossRoad(const autoware_msgs::lane &amp;_finalwaypoints,
+                                                   std::vector&lt;CrossRoadArea&gt; &amp;intersects)
 {
-	CrossRoadArea *_area = nullptr;
-	
-	euclidean_space::point _pa;
-	euclidean_space::point _pb;
+  CrossRoadArea *_area = nullptr;
 
-	double _min_distance = DBL_MAX;
+  euclidean_space::point _pa;
+  euclidean_space::point _pb;
 
-	int _label = 1;
+  double _min_distance = DBL_MAX;
 
-	if (!_finalwaypoints.waypoints.empty())
-	{
-		_pa.x = _finalwaypoints.waypoints[TARGET_WAYPOINTS_NUM].pose.pose.position.x;
-		_pa.y = _finalwaypoints.waypoints[TARGET_WAYPOINTS_NUM].pose.pose.position.y;
-		_pa.z = 0.0;
-	}
+  int _label = 1;
 
-	for (size_t i = 0; i &lt; intersects.size(); i++)
-	{
-		_pb.x = intersects[i].bbox.pose.position.x;
-		_pb.y = intersects[i].bbox.pose.position.y;
+  if (!_finalwaypoints.waypoints.empty())
+  {
+    _pa.x = _finalwaypoints.waypoints[TARGET_WAYPOINTS_NUM].pose.pose.position.x;
+    _pa.y = _finalwaypoints.waypoints[TARGET_WAYPOINTS_NUM].pose.pose.position.y;
+    _pa.z = 0.0;
+  }
 
-		_pb.z = 0.0;
+  for (size_t i = 0; i &lt; intersects.size(); i++)
+  {
+    _pb.x = intersects[i].bbox.pose.position.x;
+    _pb.y = intersects[i].bbox.pose.position.y;
 
-		double __temp_dis = euclidean_space::EuclideanSpace::find_distance(&amp;_pa, &amp;_pb);
+    _pb.z = 0.0;
 
-		intersects[i].bbox.label = 0;
-		if (_min_distance &gt;= __temp_dis)
-		{
-			_area = &amp;intersects[i];
-			_min_distance = __temp_dis;  //
-		}
-	}
+    double __temp_dis = euclidean_space::EuclideanSpace::find_distance(&amp;_pa, &amp;_pb);
 
-	if (_area)
-	{
-		_area-&gt;bbox.label = 3;
-	}
+    intersects[i].bbox.label = 0;
+    if (_min_distance &gt;= __temp_dis)
+    {
+      _area = &amp;intersects[i];
+      _min_distance = __temp_dis;  //
+    }
+  }
 
-	return _area;
-}
+  if (_area)
+  {
+    _area-&gt;bbox.label = 3;
+  }
 
+  return _area;
+}
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node.cpp" added_lines="3" deleted_lines="5">
				<diff>@@ -5,12 +5,10 @@
 #include &lt;stdio.h&gt;
 #include &lt;tf/transform_listener.h&gt;
 
-//lib
+// lib
+#include &lt;euclidean_space.hpp&gt;
 #include &lt;state.hpp&gt;
 #include &lt;state_context.hpp&gt;
-#include &lt;euclidean_space.hpp&gt;
-
-
 
 #include &lt;state_machine_node.hpp&gt;
 
@@ -25,7 +23,7 @@
 #include &lt;geometry_msgs/Pose.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 
-//for dynamic reconfigure
+// for dynamic reconfigure
 //#include &lt;dynamic_reconfigure/server.h&gt;
 //#include &lt;state_machine/state_machineConfig.h&gt;
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="102" deleted_lines="104">
				<diff>@@ -1,127 +1,125 @@
 #include &lt;stdio.h&gt;
 
-#include &lt;ros/ros.h&gt;
-#include &lt;std_msgs/String.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;jsk_rviz_plugins/OverlayText.h&gt;
+#include &lt;ros/ros.h&gt;
+#include &lt;std_msgs/String.h&gt;
 
-#include &lt;autoware_msgs/traffic_light.h&gt;
 #include &lt;autoware_msgs/lane.h&gt;
+#include &lt;autoware_msgs/traffic_light.h&gt;
 
+#include &lt;cross_road_area.hpp&gt;
 #include &lt;state.hpp&gt;
 #include &lt;state_context.hpp&gt;
 #include &lt;state_machine_node.hpp&gt;
-#include &lt;cross_road_area.hpp&gt;
 
 namespace state_machine
 {
 #define VEL_COUNT 10
-	void StateMachineNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
-	{
-		geometry_msgs::PoseStamped _pose = current_pose_ = msg;
-		bool initLocalizationFlag = ctx-&gt;isState(INITIAL_LOCATEVEHICLE_STATE);
-
-		if (initLocalizationFlag &amp;&amp;
-				ctx-&gt;handleCurrentPose(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
-					_pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
-		{
-			ROS_INFO("Localization was convergence");
-		}
-	}
-
-	void StateMachineNode::callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg)
-	{
-		ROS_INFO("Light color callback");
-		CurrentTrafficlight = msg.traffic_light;
-		ctx-&gt;handleTrafficLight(CurrentTrafficlight);
-	}
-
-	//
-	void StateMachineNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
-	{
-		if (ctx-&gt;handlePointsRaw(true))
-		{
-			Subs["points_raw"].shutdown();
-		}
-	}
-
-
-
-	void StateMachineNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
-	{
-		if (!hasvMap())
-		{
-			std::cerr &lt;&lt; "Not found vmap subscribe" &lt;&lt; std::endl;
-			// return;
-		}
-
-		current_finalwaypoints_ = msg;
-		ClosestArea_ = CrossRoadArea::findClosestCrossRoad(current_finalwaypoints_, intersects);
-
-		if(ctx-&gt;inState(DRIVE_STATE)){
-			double intersect_wayangle = calcIntersectWayAngle(current_finalwaypoints_, current_pose_);
-			ctx-&gt;handleIntersection(true, intersect_wayangle);
-		}
-
-		double _temp_sum = 0;
-		for (int i = 0; i &lt; VEL_COUNT; i++)
-		{
-			_temp_sum += mps2kmph(msg.waypoints[i].twist.twist.linear.x);
-		}
+void StateMachineNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
+{
+  geometry_msgs::PoseStamped _pose = current_pose_ = msg;
+  bool initLocalizationFlag = ctx-&gt;isState(INITIAL_LOCATEVEHICLE_STATE);
+
+  if (initLocalizationFlag &amp;&amp;
+      ctx-&gt;handleCurrentPose(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
+                             _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
+  {
+    ROS_INFO("Localization was convergence");
+  }
+}
 
-		average_velocity_ = _temp_sum / VEL_COUNT;
+void StateMachineNode::callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg)
+{
+  ROS_INFO("Light color callback");
+  CurrentTrafficlight = msg.traffic_light;
+  ctx-&gt;handleTrafficLight(CurrentTrafficlight);
+}
 
-		if (std::fabs(average_velocity_ - current_velocity_) &lt;= 2.0)
-		{
-			TextOffset = "Keep";
-		}
-		else if (average_velocity_ - current_velocity_)
-		{
-			TextOffset = "Accelerate";
-		}
-		else
-		{
-			TextOffset = "Decelerate";
-		}
+//
+void StateMachineNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
+{
+  if (ctx-&gt;handlePointsRaw(true))
+  {
+    Subs["points_raw"].shutdown();
+  }
+}
 
-		std::cout &lt;&lt; "Velocity: " &lt;&lt; current_velocity_  &lt;&lt; " to " &lt;&lt; average_velocity_ &lt;&lt; std::endl;
+void StateMachineNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
+{
+  if (!hasvMap())
+  {
+    std::cerr &lt;&lt; "Not found vmap subscribe" &lt;&lt; std::endl;
+    // return;
+  }
+
+  current_finalwaypoints_ = msg;
+  ClosestArea_ = CrossRoadArea::findClosestCrossRoad(current_finalwaypoints_, intersects);
+
+  if (ctx-&gt;inState(DRIVE_STATE))
+  {
+    double intersect_wayangle = calcIntersectWayAngle(current_finalwaypoints_, current_pose_);
+    ctx-&gt;handleIntersection(true, intersect_wayangle);
+  }
+
+  double _temp_sum = 0;
+  for (int i = 0; i &lt; VEL_COUNT; i++)
+  {
+    _temp_sum += mps2kmph(msg.waypoints[i].twist.twist.linear.x);
+  }
+
+  average_velocity_ = _temp_sum / VEL_COUNT;
+
+  if (std::fabs(average_velocity_ - current_velocity_) &lt;= 2.0)
+  {
+    TextOffset = "Keep";
+  }
+  else if (average_velocity_ - current_velocity_)
+  {
+    TextOffset = "Accelerate";
+  }
+  else
+  {
+    TextOffset = "Decelerate";
+  }
+
+  std::cout &lt;&lt; "Velocity: " &lt;&lt; current_velocity_ &lt;&lt; " to " &lt;&lt; average_velocity_ &lt;&lt; std::endl;
+}
+void StateMachineNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
+{
+  static bool Twistflag = false;
 
-	}
-	void StateMachineNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
-	{
-		static bool Twistflag = false;
-
-		if(Twistflag)
-			ctx-&gt;handleTwistCmd(false);
-		else
-			Twistflag = true;
-	}
+  if (Twistflag)
+    ctx-&gt;handleTwistCmd(false);
+  else
+    Twistflag = true;
+}
 
-	void StateMachineNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
-	{
-		vMap_Areas = msg;
-		vMap_Areas_flag = true;
-	}
-	void StateMachineNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
-	{
-		vMap_Points = msg;
-		vMap_Points_flag = true;
-	}
-	void StateMachineNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
-	{
-		vMap_Lines = msg;
-		vMap_Lines_flag = true;
-	}
-	void StateMachineNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
-	{
-		vMap_CrossRoads = msg;
-		vMap_CrossRoads_flag = true;
-	}
+void StateMachineNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
+{
+  vMap_Areas = msg;
+  vMap_Areas_flag = true;
+}
+void StateMachineNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
+{
+  vMap_Points = msg;
+  vMap_Points_flag = true;
+}
+void StateMachineNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
+{
+  vMap_Lines = msg;
+  vMap_Lines_flag = true;
+}
+void StateMachineNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
+{
+  vMap_CrossRoads = msg;
+  vMap_CrossRoads_flag = true;
+}
 
-	void StateMachineNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
-	{
-		current_velocity_ = mps2kmph(msg.twist.linear.x);
-	}
+void StateMachineNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
+{
+  current_velocity_ = mps2kmph(msg.twist.linear.x);
+}
 #if 0
 	void StateMachineNode::callbackFromDynamicReconfigure(state_machine::state_machineConfig &amp;config, uint32_t level){
 		ROS_INFO("Reconfigure Request: %d ", config.TARGET_WAYPOINT_COUNT);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\planner_selector\nodes\planner_selector\planner_selector_node.cpp" new_path="ros\src\computing\planning\decision\packages\planner_selector\nodes\planner_selector\planner_selector_node.cpp" added_lines="87" deleted_lines="86">
				<diff>@@ -1,66 +1,65 @@
+#include &lt;autoware_msgs/lane.h&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
-#include &lt;autoware_msgs/lane.h&gt;
 
-#include &lt;unordered_map&gt;
 #include &lt;mutex&gt;
 #include &lt;thread&gt;
-
+#include &lt;unordered_map&gt;
 
 namespace decision_maker
 {
-
 class PlannerSelectorNode
 {
-	private:
-
-		ros::NodeHandle nh_;
-		
-		std::unordered_map&lt;std::string, autoware_msgs::lane&gt; waypoints_;
-		std::unordered_map&lt;std::string, ros::Publisher&gt; Pubs;
-		std::unordered_map&lt;std::string, ros::Subscriber&gt; Subs;
+private:
+  ros::NodeHandle nh_;
 
-		std::unordered_map&lt;std::string, int &gt; closest_waypoints_;
-		int  __closest_waypoint_astar;
-		int  __closest_waypoint_dp;
+  std::unordered_map&lt;std::string, autoware_msgs::lane&gt; waypoints_;
+  std::unordered_map&lt;std::string, ros::Publisher&gt; Pubs;
+  std::unordered_map&lt;std::string, ros::Subscriber&gt; Subs;
 
-		std::mutex _mutex;
+  std::unordered_map&lt;std::string, int&gt; closest_waypoints_;
+  int __closest_waypoint_astar;
+  int __closest_waypoint_dp;
 
-		int enableLattice_;
-	public:
-		PlannerSelectorNode(){
-			this-&gt;initROS();
-		enableLattice_ = 0;
+  std::mutex _mutex;
 
-		}
+  int enableLattice_;
 
-		void initROS();
-
-		void callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int32&gt; &amp;event);
-		void callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::lane const&gt; &amp;event);
-		void callbackFromLattice(const std_msgs::Int32 &amp;msg);
+public:
+  PlannerSelectorNode()
+  {
+    this-&gt;initROS();
+    enableLattice_ = 0;
+  }
 
+  void initROS();
 
+  void callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int32&gt; &amp;event);
+  void callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::lane const&gt; &amp;event);
+  void callbackFromLattice(const std_msgs::Int32 &amp;msg);
 };
 
 void PlannerSelectorNode::initROS()
 {
-	Subs["/dp/final_waypoints"] = nh_.subscribe("/dp/final_waypoints", 1, &amp;PlannerSelectorNode::callbackFromWaypoints, this);
-	Subs["/astar/final_waypoints"] = nh_.subscribe("/astar/final_waypoints", 1, &amp;PlannerSelectorNode::callbackFromWaypoints, this);
-	Subs["/enableLattice"] = nh_.subscribe("/enableLattice", 10 ,&amp;PlannerSelectorNode::callbackFromLattice,this);
-	
-	Subs["/dp/closest_waypoint"] = nh_.subscribe("/dp/closest_waypoint", 1, &amp;PlannerSelectorNode::callbackFromClosest, this);
-	Subs["/astar/closest_waypoint"] = nh_.subscribe("/astar/closest_waypoint", 1, &amp;PlannerSelectorNode::callbackFromClosest, this);
-
-	Pubs["final_waypoints"] = nh_.advertise&lt;autoware_msgs::lane&gt;("/final_waypoints",1);
-	Pubs["closest_waypoint"] = nh_.advertise&lt;std_msgs::Int32&gt;("/closest_waypoint",1);
-
+  Subs["/dp/final_waypoints"] =
+      nh_.subscribe("/dp/final_waypoints", 1, &amp;PlannerSelectorNode::callbackFromWaypoints, this);
+  Subs["/astar/final_waypoints"] =
+      nh_.subscribe("/astar/final_waypoints", 1, &amp;PlannerSelectorNode::callbackFromWaypoints, this);
+  Subs["/enableLattice"] = nh_.subscribe("/enableLattice", 10, &amp;PlannerSelectorNode::callbackFromLattice, this);
+
+  Subs["/dp/closest_waypoint"] =
+      nh_.subscribe("/dp/closest_waypoint", 1, &amp;PlannerSelectorNode::callbackFromClosest, this);
+  Subs["/astar/closest_waypoint"] =
+      nh_.subscribe("/astar/closest_waypoint", 1, &amp;PlannerSelectorNode::callbackFromClosest, this);
+
+  Pubs["final_waypoints"] = nh_.advertise&lt;autoware_msgs::lane&gt;("/final_waypoints", 1);
+  Pubs["closest_waypoint"] = nh_.advertise&lt;std_msgs::Int32&gt;("/closest_waypoint", 1);
 }
 
 #define LATENCY_NUM 3
 void PlannerSelectorNode::callbackFromLattice(const std_msgs::Int32 &amp;msg)
 {
-	static int prev[LATENCY_NUM] = {1};
+  static int prev[LATENCY_NUM] = { 1 };
 #if 0
 	if(enableLattice_ == 1)	{
 		for(int i = 1; i&lt;LATENCY_NUM; i++)
@@ -71,69 +70,71 @@ void PlannerSelectorNode::callbackFromLattice(const std_msgs::Int32 &amp;msg)
 		enableLattice_ = msg.data;
 	}
 #else
-	_mutex.lock();
-	if(msg.data != enableLattice_)
-		enableLattice_ = msg.data;
-	std::cout &lt;&lt; "[" &lt;&lt; __func__ &lt;&lt; "]: setEnableLattice"&lt;&lt;enableLattice_&lt;&lt;" &lt;=" &lt;&lt; msg.data&lt;&lt;std::endl;
-	_mutex.unlock();
+  _mutex.lock();
+  if (msg.data != enableLattice_)
+    enableLattice_ = msg.data;
+  std::cout &lt;&lt; "[" &lt;&lt; __func__ &lt;&lt; "]: setEnableLattice" &lt;&lt; enableLattice_ &lt;&lt; " &lt;=" &lt;&lt; msg.data &lt;&lt; std::endl;
+  _mutex.unlock();
 #endif
-//	ROS_INFO("\n***** EnableLattice = %d  **** \n",enableLattice_,msg.data);
+  //	ROS_INFO("\n***** EnableLattice = %d  **** \n",enableLattice_,msg.data);
 }
 
-
-void PlannerSelectorNode::callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::lane const&gt; &amp;event){
-	
-	const ros::M_string &amp;header = event.getConnectionHeader();
-	std::string topic = header.at("topic");
-	const autoware_msgs::lane *waypoints = event.getMessage().get();
-	
-	///ROS_INFO("%s", enableLattice_?"flag = True":"flag = False");
-
-	_mutex.lock();
-	if(this-&gt;enableLattice_ &amp;&amp; topic.find("dp") != std::string::npos ){
-		Pubs["final_waypoints"].publish(*waypoints);
-		std::cout &lt;&lt; "ENABLE_LATTTICE" &lt;&lt; enableLattice_ &lt;&lt; topic;
-	}else if(!this-&gt;enableLattice_ &amp;&amp; topic.find("astar") != std::string::npos ){
-		std::cout &lt;&lt; "ENABLE_ASTAR:" &lt;&lt; enableLattice_ &lt;&lt; topic;
-		Pubs["final_waypoints"].publish(*waypoints);
-	}
-	ROS_INFO("%s, %d-%d-%d", topic.c_str(), __closest_waypoint_dp, __closest_waypoint_astar, this-&gt;enableLattice_);
-	_mutex.unlock();
-
+void PlannerSelectorNode::callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::lane const&gt; &amp;event)
+{
+  const ros::M_string &amp;header = event.getConnectionHeader();
+  std::string topic = header.at("topic");
+  const autoware_msgs::lane *waypoints = event.getMessage().get();
+
+  /// ROS_INFO("%s", enableLattice_?"flag = True":"flag = False");
+
+  _mutex.lock();
+  if (this-&gt;enableLattice_ &amp;&amp; topic.find("dp") != std::string::npos)
+  {
+    Pubs["final_waypoints"].publish(*waypoints);
+    std::cout &lt;&lt; "ENABLE_LATTTICE" &lt;&lt; enableLattice_ &lt;&lt; topic;
+  }
+  else if (!this-&gt;enableLattice_ &amp;&amp; topic.find("astar") != std::string::npos)
+  {
+    std::cout &lt;&lt; "ENABLE_ASTAR:" &lt;&lt; enableLattice_ &lt;&lt; topic;
+    Pubs["final_waypoints"].publish(*waypoints);
+  }
+  ROS_INFO("%s, %d-%d-%d", topic.c_str(), __closest_waypoint_dp, __closest_waypoint_astar, this-&gt;enableLattice_);
+  _mutex.unlock();
 }
 
 void PlannerSelectorNode::callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int32&gt; &amp;event)
 {
-	const ros::M_string &amp;header = event.getConnectionHeader();
-	std::string topic = header.at("topic");
+  const ros::M_string &amp;header = event.getConnectionHeader();
+  std::string topic = header.at("topic");
 
-	int temp = event.getMessage().get()-&gt;data;
-	std_msgs::Int32 msg;
+  int temp = event.getMessage().get()-&gt;data;
+  std_msgs::Int32 msg;
 
 #if 1
-	if(topic.find("/dp") == 0){
-		closest_waypoints_["dp"] = temp;
-		
-		if(closest_waypoints_["astar"]){
-			msg.data =  __closest_waypoint_astar;
-		}
-		__closest_waypoint_dp = temp;
-
-	}else if (topic.find("/astar") == 0) {
-		closest_waypoints_["astar"] = temp;
-		__closest_waypoint_astar = temp;
-	}
-	msg.data = __closest_waypoint_astar;
+  if (topic.find("/dp") == 0)
+  {
+    closest_waypoints_["dp"] = temp;
+
+    if (closest_waypoints_["astar"])
+    {
+      msg.data = __closest_waypoint_astar;
+    }
+    __closest_waypoint_dp = temp;
+  }
+  else if (topic.find("/astar") == 0)
+  {
+    closest_waypoints_["astar"] = temp;
+    __closest_waypoint_astar = temp;
+  }
+  msg.data = __closest_waypoint_astar;
 #endif
-	Pubs["closest_waypoint"].publish(msg);
-	
+  Pubs["closest_waypoint"].publish(msg);
 }
-
 }
 int main(int argc, char **argv)
 {
-	ros::init(argc, argv, "planner_selector");
+  ros::init(argc, argv, "planner_selector");
 
-	decision_maker::PlannerSelectorNode _psn;
-	ros::spin();
+  decision_maker::PlannerSelectorNode _psn;
+  ros::spin();
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f9ace9e138b61a9738ef60a4ea6c0b1bf2ca97bd" author="Yusuke FUJII">
		<msg>disabling debug massages on planner_selector</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\planner_selector\nodes\planner_selector\planner_selector_node.cpp" new_path="ros\src\computing\planning\decision\packages\planner_selector\nodes\planner_selector\planner_selector_node.cpp" added_lines="3" deleted_lines="4">
				<diff>@@ -73,9 +73,9 @@ void PlannerSelectorNode::callbackFromLattice(const std_msgs::Int32 &amp;msg)
   _mutex.lock();
   if (msg.data != enableLattice_)
     enableLattice_ = msg.data;
-  std::cout &lt;&lt; "[" &lt;&lt; __func__ &lt;&lt; "]: setEnableLattice" &lt;&lt; enableLattice_ &lt;&lt; " &lt;=" &lt;&lt; msg.data &lt;&lt; std::endl;
   _mutex.unlock();
 #endif
+  // for debug
   //	ROS_INFO("\n***** EnableLattice = %d  **** \n",enableLattice_,msg.data);
 }
 
@@ -91,14 +91,13 @@ void PlannerSelectorNode::callbackFromWaypoints(const ros::MessageEvent&lt;autoware
   if (this-&gt;enableLattice_ &amp;&amp; topic.find("dp") != std::string::npos)
   {
     Pubs["final_waypoints"].publish(*waypoints);
-    std::cout &lt;&lt; "ENABLE_LATTTICE" &lt;&lt; enableLattice_ &lt;&lt; topic;
   }
   else if (!this-&gt;enableLattice_ &amp;&amp; topic.find("astar") != std::string::npos)
   {
-    std::cout &lt;&lt; "ENABLE_ASTAR:" &lt;&lt; enableLattice_ &lt;&lt; topic;
     Pubs["final_waypoints"].publish(*waypoints);
   }
-  ROS_INFO("%s, %d-%d-%d", topic.c_str(), __closest_waypoint_dp, __closest_waypoint_astar, this-&gt;enableLattice_);
+//for debug
+//ROS_INFO("%s, %d-%d-%d", topic.c_str(), __closest_waypoint_dp, __closest_waypoint_astar, this-&gt;enableLattice_);
   _mutex.unlock();
 }
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="28ce05e727d1205f93c7596c24ab5fadde3c6b2b" author="Yusuke FUJII">
		<msg>fix a planner selector
- lane select got to be able to change topicname for planner selector</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\velocity_set\velocity_set.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -515,7 +515,7 @@ int main(int argc, char** argv)
   std::string points_topic;
   private_nh.param&lt;bool&gt;("use_crosswalk_detection", use_crosswalk_detection, true);
   private_nh.param&lt;bool&gt;("enable_multiple_crosswalk_detection", enable_multiple_crosswalk_detection, true);
-  private_nh.param&lt;bool&gt;("enablePlannerDynamicSwitch", enablePlannerDynamicSwitch, true);
+  private_nh.param&lt;bool&gt;("enablePlannerDynamicSwitch", enablePlannerDynamicSwitch, false);
 
 
   private_nh.param&lt;std::string&gt;("points_topic", points_topic, "points_lanes");
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="d76e93d91a9899dea5e0d4a5012f62664354ba0f" author="Yusuke FUJII">
		<msg>Add decision packages into runtime_manager</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" new_path="ros\src\computing\planning\mission\packages\lane_planner\nodes\lane_select\lane_select_core.cpp" added_lines="11" deleted_lines="1">
				<diff>@@ -68,9 +68,19 @@ void LaneSelectNode::initForROS()
   sub4_ = nh_.subscribe("state", 1, &amp;LaneSelectNode::callbackFromState, this);
   sub5_ = nh_.subscribe("/config/lane_select", 1, &amp;LaneSelectNode::callbackFromConfig, this);
 
+  
+  bool enablePlannerDynamicSwitch;
+  private_nh_.param&lt;bool&gt;("enablePlannerDynamicSwitch", enablePlannerDynamicSwitch, false);
   // setup publisher
+  
   pub1_ = nh_.advertise&lt;autoware_msgs::lane&gt;("base_waypoints", 1);
-  pub2_ = nh_.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 1);
+  
+  if(enablePlannerDynamicSwitch){
+	  pub2_ = nh_.advertise&lt;std_msgs::Int32&gt;("/astar/closest_waypoint", 1);
+  }else{
+	  pub2_ = nh_.advertise&lt;std_msgs::Int32&gt;("closest_waypoint", 1);
+  }
+  
   pub3_ = nh_.advertise&lt;std_msgs::Int32&gt;("change_flag", 1);
   vis_pub1_ = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("lane_select_marker", 1);
 
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="fb9198f8b106b3f6f0760473682f26df86828ce1" author="Abraham Monrroy">
		<msg>[hotfix] fixes to lidar_tracker package(#787)

-Fixed a typo in the ground_filter launch file from points_preprocessor
-Fixed ID duplication in kf_lidar_tracker
Tested on Ubuntu 14.04 and 16.04</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_lidar_track\KfLidarTracker.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_lidar_track\KfLidarTracker.cpp" added_lines="27" deleted_lines="12">
				<diff>@@ -3,7 +3,14 @@
 // ---------------------------------------------------------------------------
 // Tracker. Manage tracks. Create, remove, update.
 // ---------------------------------------------------------------------------
-KfLidarTracker::KfLidarTracker(float in_time_delta,	float in_acceleration_noise_magnitude, float in_distance_threshold, float in_tracker_merging_threshold, size_t maximum_allowed_skipped_frames, size_t maximum_trace_length, bool pose_estimation) :
+KfLidarTracker::KfLidarTracker(float in_time_delta,
+		float in_acceleration_noise_magnitude,
+		float in_distance_threshold,
+		float in_tracker_merging_threshold,
+		size_t maximum_allowed_skipped_frames,
+		size_t maximum_trace_length,
+		bool pose_estimation,
+		size_t maximum_track_id) :
 	time_delta_(in_time_delta),
 	acceleration_noise_magnitude_(in_acceleration_noise_magnitude),
 	distance_threshold_(in_distance_threshold),
@@ -11,7 +18,8 @@ KfLidarTracker::KfLidarTracker(float in_time_delta,	float in_acceleration_noise_
 	maximum_allowed_skipped_frames_(maximum_allowed_skipped_frames),
 	maximum_trace_length_(maximum_trace_length),
 	next_track_id_(0),
-	pose_estimation_(false)
+	pose_estimation_(false),
+	maximum_track_id_(maximum_track_id)
 {
 }
 
@@ -162,25 +170,32 @@ void KfLidarTracker::Update(const autoware_msgs::CloudClusterArray&amp; in_cloud_clu
 										acceleration_noise_magnitude_,
 										next_track_id_++)
 								);
-				if (next_track_id_ &gt; 200)
+				if (next_track_id_ &gt; maximum_track_id_)
 					next_track_id_ = 0;
 				una++;
 			}
 		}
-		//std::cout &lt;&lt; "Trackers added: " &lt;&lt; una &lt;&lt; std::endl;
-
-		//finally check trackers among them
+		//finally check trackers among them. Remove previously merged objects, causing ID duplication
 		for(size_t i=0; i&lt; tracks_.size(); i++)
-			std::cout &lt;&lt; tracks_[i].track_id &lt;&lt; ",";
-		std::cout &lt;&lt; std::endl &lt;&lt; "Check" &lt;&lt; std::endl;
+		{
+			for (size_t j=0; j&lt; tracks_.size(); j++)
+			{
+				if (i != j &amp;&amp;
+					 (tracks_[i].GetCluster().centroid_point.point.x == tracks_[j].GetCluster().centroid_point.point.x &amp;&amp;
+					  tracks_[i].GetCluster().centroid_point.point.y == tracks_[j].GetCluster().centroid_point.point.y &amp;&amp;
+					  tracks_[i].GetCluster().centroid_point.point.z == tracks_[j].GetCluster().centroid_point.point.z
+					 )
+					)
+				{
+					tracks_.erase(tracks_.begin() + j);
+					j--;
+				}
+			}
+		}
 		CheckAllTrackersForMerge(final_tracks);
 
 		tracks_ = final_tracks;
 
-		for(size_t i=0; i&lt; tracks_.size(); i++)
-			std::cout &lt;&lt; tracks_[i].track_id &lt;&lt; ",";
-		std::cout &lt;&lt; std::endl;
-
 		//std::cout &lt;&lt; "Final Trackers " &lt;&lt; tracks_.size() &lt;&lt; std::endl;
 	}//endof matching
 
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_lidar_track\includes\KfLidarTracker.h" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_lidar_track\includes\KfLidarTracker.h" added_lines="9" deleted_lines="1">
				<diff>@@ -102,6 +102,7 @@ class KfLidarTracker
 	size_t maximum_allowed_skipped_frames_;
 	size_t maximum_trace_length_;
 	size_t next_track_id_;
+	size_t maximum_track_id_;
 
 	bool pose_estimation_;
 	void CheckTrackerMerge(size_t in_tracker_id, std::vector&lt;CTrack&gt;&amp; in_trackers, std::vector&lt;bool&gt;&amp; in_out_visited_trackers, std::vector&lt;size_t&gt;&amp; out_merge_indices, double in_merge_threshold);
@@ -109,7 +110,14 @@ class KfLidarTracker
 	void MergeTrackers(std::vector&lt;CTrack&gt;&amp; in_trackers, std::vector&lt;CTrack&gt;&amp; out_trackers, std::vector&lt;size_t&gt; in_merge_indices, const size_t&amp; current_index, std::vector&lt;bool&gt;&amp; in_out_merged_trackers);
 	void CreatePolygonFromPoints(const geometry_msgs::Polygon&amp; in_points, boost_polygon&amp; out_polygon);
 public:
-	KfLidarTracker(float in_time_delta, float accel_noise_mag, float dist_thres = 3, float tracker_merging_threshold=2, size_t maximum_allowed_skipped_frames = 10, size_t max_trace_length = 10, bool in_pose_estimation = false);
+	KfLidarTracker(float in_time_delta,
+					float accel_noise_mag,
+					float dist_thres = 3,
+					float tracker_merging_threshold=2,
+					size_t maximum_allowed_skipped_frames = 10,
+					size_t max_trace_length = 10,
+					bool in_pose_estimation = false,
+					size_t maximum_track_id = 200);
 	~KfLidarTracker(void);
 
 	enum DistType
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_lidar_track\kf_lidar_track.cpp" new_path="ros\src\computing\perception\detection\packages\lidar_tracker\nodes\kf_lidar_track\kf_lidar_track.cpp" added_lines="15" deleted_lines="7">
				<diff>@@ -5,6 +5,8 @@
  *      Author: ne0
  */
 
+#include &lt;vector&gt;
+
 #include "ros/ros.h"
 
 #include &lt;pcl_ros/transforms.h&gt;
@@ -24,8 +26,6 @@
 #include &lt;jsk_rviz_plugins/PictogramArray.h&gt;
 #include &lt;jsk_recognition_msgs/PolygonArray.h&gt;
 
-#include &lt;vector&gt;
-
 #include "KfLidarTracker.h"
 
 class KfLidarTrackNode
@@ -46,6 +46,7 @@ private:
 
 	bool pose_estimation_;
 	int keep_alive_;
+	int maximum_track_id_;
 
 	boost::shared_ptr&lt;KfLidarTracker&gt; tracker_ptr;
 
@@ -65,10 +66,16 @@ KfLidarTrackNode::KfLidarTrackNode() :
 	pub_jsk_hulls_ = node_handle_.advertise&lt;jsk_recognition_msgs::PolygonArray&gt;("/cluster_hulls_tracked",1);
 	pub_jsk_pictograms_ = node_handle_.advertise&lt;jsk_rviz_plugins::PictogramArray&gt;("/cluster_ids_tracked",1);
 
-	node_handle_.param("distance_matching_threshold", distance_matching_threshold_, 1.5);	ROS_INFO("distance_matching_threshold: %f", distance_matching_threshold_);// distance threshold to match objects between scans
-	node_handle_.param("tracker_merging_threshold", tracker_merging_threshold_, 1.0);	ROS_INFO("tracker_merging_threshold: %f", tracker_merging_threshold_);// distance threshold to match objects between scans
-	node_handle_.param("pose_estimation", pose_estimation_, false);	ROS_INFO("pose_estimation: %d", pose_estimation_);// whether or not to estimate pose
-	node_handle_.param("keep_alive", keep_alive_, 2);	ROS_INFO("keep_alive: %d", keep_alive_);// frames to keep an object
+	node_handle_.param("distance_matching_threshold", distance_matching_threshold_, 1.5);
+	ROS_INFO("distance_matching_threshold: %f", distance_matching_threshold_);// distance threshold to match objects between scans
+	node_handle_.param("tracker_merging_threshold", tracker_merging_threshold_, 1.0);
+	ROS_INFO("tracker_merging_threshold: %f", tracker_merging_threshold_);// distance threshold to match objects between scans
+	node_handle_.param("pose_estimation", pose_estimation_, false);
+	ROS_INFO("pose_estimation: %d", pose_estimation_);// whether or not to estimate pose
+	node_handle_.param("keep_alive", keep_alive_, 2);
+	ROS_INFO("keep_alive: %d", keep_alive_);// frames to keep an object
+	node_handle_.param("maximum_track_id", maximum_track_id_, 200);
+	ROS_INFO("maximum_track_id: %d", maximum_track_id_);// frames to keep an object
 
 
 
@@ -77,7 +84,8 @@ KfLidarTrackNode::KfLidarTrackNode() :
 							distance_matching_threshold_, 			//matching distance threshold
 							tracker_merging_threshold_, //tracker merging threshold
 							keep_alive_, 				//life span
-							keep_alive_));			//trace length
+							keep_alive_,
+							maximum_track_id_));			//trace length
 }
 
 KfLidarTrackNode::~KfLidarTrackNode()
</diff>
			</file>
			<file old_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ground_filter\ground_filter.cpp" new_path="ros\src\sensing\filters\packages\points_preprocessor\nodes\ground_filter\ground_filter.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -205,7 +205,7 @@ void GroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::Point
 				}
 				else
 				{//this should never execute due to Sensor specs
-					ROS_ERROR("GroundFilter: Division by Zero avoided on pair_angle");
+					ROS_WARN("GroundFilter: Division by Zero avoided on pair_angle");
 					pair_angle = 0;
 				}
 				if (
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ece16aae14bf5286ccb705f62be9dda624883155" author="Dejan Pangercic">
		<msg>fixed cmake and package.xml for libvectormap
moved headers into include/libvectormap since otherwise this otherwise can conflict with other files elsewhere.</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\detection\lib\libvectormap\include\Math.h" new_path="ros\src\computing\perception\detection\lib\libvectormap\include\libvectormap\Math.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\libvectormap\include\vector_map.h" new_path="ros\src\computing\perception\detection\lib\libvectormap\include\libvectormap\vector_map.h" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\lib\libvectormap\src\vector_map.cpp" new_path="ros\src\computing\perception\detection\lib\libvectormap\src\vector_map.cpp" added_lines="1" deleted_lines="4">
				<diff>@@ -1,12 +1,9 @@
-//#include "ros/ros.h"
-//#include "std_msgs/String.h"
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;math.h&gt;
-#include "vector_map.h"
+#include "libvectormap/vector_map.h"
 #include &lt;vector&gt;
 #include &lt;map&gt;
-#include &lt;tf/transform_listener.h&gt;
 
 void VectorMap::load_points(const vector_map::PointArray&amp; msg)
 {
</diff>
			</file>
			<file old_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\feat_proj.cpp" new_path="ros\src\computing\perception\detection\packages\road_wizard\nodes\feat_proj\feat_proj.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -9,7 +9,7 @@
 #include &lt;iostream&gt;
 #include &lt;ros/ros.h&gt;
 #include "Rate.h"
-#include "vector_map.h"
+#include "libvectormap/vector_map.h"
 #include &lt;tf/tf.h&gt;
 #include &lt;tf/transform_listener.h&gt;
 #include &lt;sensor_msgs/CameraInfo.h&gt;
@@ -18,7 +18,7 @@
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;signal.h&gt;
 #include &lt;cstdio&gt;
-#include "Math.h"
+#include "libvectormap/Math.h"
 #include &lt;Eigen/Eigen&gt;
 #include &lt;autoware_msgs/Signals.h&gt;
 #include &lt;autoware_msgs/adjust_xy.h&gt;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ec373ea856f04a2db24f3989522c3d7cb144494a" author="Dejan Pangercic">
		<msg>static functions were never defined, so I removed them</msg>
		<modified_files>
			<file old_path="ros\src\data\packages\vector_map\include\vector_map\vector_map.h" new_path="ros\src\data\packages\vector_map\include\vector_map\vector_map.h" added_lines="35" deleted_lines="35">
				<diff>@@ -323,41 +323,41 @@ std::vector&lt;T&gt; parse(const std::string&amp; csv_file)
   return objs;
 }
 
-namespace
-{
-void updatePoint(std::map&lt;Key&lt;Point&gt;, Point&gt;&amp; map, const PointArray&amp; msg);
-void updateVector(std::map&lt;Key&lt;Vector&gt;, Vector&gt;&amp; map, const VectorArray&amp; msg);
-void updateLine(std::map&lt;Key&lt;Line&gt;, Line&gt;&amp; map, const LineArray&amp; msg);
-void updateArea(std::map&lt;Key&lt;Area&gt;, Area&gt;&amp; map, const AreaArray&amp; msg);
-void updatePole(std::map&lt;Key&lt;Pole&gt;, Pole&gt;&amp; map, const PoleArray&amp; msg);
-void updateBox(std::map&lt;Key&lt;Box&gt;, Box&gt;&amp; map, const BoxArray&amp; msg);
-void updateDTLane(std::map&lt;Key&lt;DTLane&gt;, DTLane&gt;&amp; map, const DTLaneArray&amp; msg);
-void updateNode(std::map&lt;Key&lt;Node&gt;, Node&gt;&amp; map, const NodeArray&amp; msg);
-void updateLane(std::map&lt;Key&lt;Lane&gt;, Lane&gt;&amp; map, const LaneArray&amp; msg);
-void updateWayArea(std::map&lt;Key&lt;WayArea&gt;, WayArea&gt;&amp; map, const WayAreaArray&amp; msg);
-void updateRoadEdge(std::map&lt;Key&lt;RoadEdge&gt;, RoadEdge&gt;&amp; map, const RoadEdgeArray&amp; msg);
-void updateGutter(std::map&lt;Key&lt;Gutter&gt;, Gutter&gt;&amp; map, const GutterArray&amp; msg);
-void updateCurb(std::map&lt;Key&lt;Curb&gt;, Curb&gt;&amp; map, const CurbArray&amp; msg);
-void updateWhiteLine(std::map&lt;Key&lt;WhiteLine&gt;, WhiteLine&gt;&amp; map, const WhiteLineArray&amp; msg);
-void updateStopLine(std::map&lt;Key&lt;StopLine&gt;, StopLine&gt;&amp; map, const StopLineArray&amp; msg);
-void updateZebraZone(std::map&lt;Key&lt;ZebraZone&gt;, ZebraZone&gt;&amp; map, const ZebraZoneArray&amp; msg);
-void updateCrossWalk(std::map&lt;Key&lt;CrossWalk&gt;, CrossWalk&gt;&amp; map, const CrossWalkArray&amp; msg);
-void updateRoadMark(std::map&lt;Key&lt;RoadMark&gt;, RoadMark&gt;&amp; map, const RoadMarkArray&amp; msg);
-void updateRoadPole(std::map&lt;Key&lt;RoadPole&gt;, RoadPole&gt;&amp; map, const RoadPoleArray&amp; msg);
-void updateRoadSign(std::map&lt;Key&lt;RoadSign&gt;, RoadSign&gt;&amp; map, const RoadSignArray&amp; msg);
-void updateSignal(std::map&lt;Key&lt;Signal&gt;, Signal&gt;&amp; map, const SignalArray&amp; msg);
-void updateStreetLight(std::map&lt;Key&lt;StreetLight&gt;, StreetLight&gt;&amp; map, const StreetLightArray&amp; msg);
-void updateUtilityPole(std::map&lt;Key&lt;UtilityPole&gt;, UtilityPole&gt;&amp; map, const UtilityPoleArray&amp; msg);
-void updateGuardRail(std::map&lt;Key&lt;GuardRail&gt;, GuardRail&gt;&amp; map, const GuardRailArray&amp; msg);
-void updateSideWalk(std::map&lt;Key&lt;SideWalk&gt;, SideWalk&gt;&amp; map, const SideWalkArray&amp; msg);
-void updateDriveOnPortion(std::map&lt;Key&lt;DriveOnPortion&gt;, DriveOnPortion&gt;&amp; map, const DriveOnPortionArray&amp; msg);
-void updateCrossRoad(std::map&lt;Key&lt;CrossRoad&gt;, CrossRoad&gt;&amp; map, const CrossRoadArray&amp; msg);
-void updateSideStrip(std::map&lt;Key&lt;SideStrip&gt;, SideStrip&gt;&amp; map, const SideStripArray&amp; msg);
-void updateCurveMirror(std::map&lt;Key&lt;CurveMirror&gt;, CurveMirror&gt;&amp; map, const CurveMirrorArray&amp; msg);
-void updateWall(std::map&lt;Key&lt;Wall&gt;, Wall&gt;&amp; map, const WallArray&amp; msg);
-void updateFence(std::map&lt;Key&lt;Fence&gt;, Fence&gt;&amp; map, const FenceArray&amp; msg);
-void updateRailCrossing(std::map&lt;Key&lt;RailCrossing&gt;, RailCrossing&gt;&amp; map, const RailCrossingArray&amp; msg);
-} // namespace
+/* namespace */
+/* { */
+/* void updatePoint(std::map&lt;Key&lt;Point&gt;, Point&gt;&amp; map, const PointArray&amp; msg); */
+/* void updateVector(std::map&lt;Key&lt;Vector&gt;, Vector&gt;&amp; map, const VectorArray&amp; msg); */
+/* void updateLine(std::map&lt;Key&lt;Line&gt;, Line&gt;&amp; map, const LineArray&amp; msg); */
+/* void updateArea(std::map&lt;Key&lt;Area&gt;, Area&gt;&amp; map, const AreaArray&amp; msg); */
+/* void updatePole(std::map&lt;Key&lt;Pole&gt;, Pole&gt;&amp; map, const PoleArray&amp; msg); */
+/* void updateBox(std::map&lt;Key&lt;Box&gt;, Box&gt;&amp; map, const BoxArray&amp; msg); */
+/* void updateDTLane(std::map&lt;Key&lt;DTLane&gt;, DTLane&gt;&amp; map, const DTLaneArray&amp; msg); */
+/* void updateNode(std::map&lt;Key&lt;Node&gt;, Node&gt;&amp; map, const NodeArray&amp; msg); */
+/* void updateLane(std::map&lt;Key&lt;Lane&gt;, Lane&gt;&amp; map, const LaneArray&amp; msg); */
+/* void updateWayArea(std::map&lt;Key&lt;WayArea&gt;, WayArea&gt;&amp; map, const WayAreaArray&amp; msg); */
+/* void updateRoadEdge(std::map&lt;Key&lt;RoadEdge&gt;, RoadEdge&gt;&amp; map, const RoadEdgeArray&amp; msg); */
+/* void updateGutter(std::map&lt;Key&lt;Gutter&gt;, Gutter&gt;&amp; map, const GutterArray&amp; msg); */
+/* void updateCurb(std::map&lt;Key&lt;Curb&gt;, Curb&gt;&amp; map, const CurbArray&amp; msg); */
+/* void updateWhiteLine(std::map&lt;Key&lt;WhiteLine&gt;, WhiteLine&gt;&amp; map, const WhiteLineArray&amp; msg); */
+/* void updateStopLine(std::map&lt;Key&lt;StopLine&gt;, StopLine&gt;&amp; map, const StopLineArray&amp; msg); */
+/* void updateZebraZone(std::map&lt;Key&lt;ZebraZone&gt;, ZebraZone&gt;&amp; map, const ZebraZoneArray&amp; msg); */
+/* void updateCrossWalk(std::map&lt;Key&lt;CrossWalk&gt;, CrossWalk&gt;&amp; map, const CrossWalkArray&amp; msg); */
+/* void updateRoadMark(std::map&lt;Key&lt;RoadMark&gt;, RoadMark&gt;&amp; map, const RoadMarkArray&amp; msg); */
+/* void updateRoadPole(std::map&lt;Key&lt;RoadPole&gt;, RoadPole&gt;&amp; map, const RoadPoleArray&amp; msg); */
+/* void updateRoadSign(std::map&lt;Key&lt;RoadSign&gt;, RoadSign&gt;&amp; map, const RoadSignArray&amp; msg); */
+/* void updateSignal(std::map&lt;Key&lt;Signal&gt;, Signal&gt;&amp; map, const SignalArray&amp; msg); */
+/* void updateStreetLight(std::map&lt;Key&lt;StreetLight&gt;, StreetLight&gt;&amp; map, const StreetLightArray&amp; msg); */
+/* void updateUtilityPole(std::map&lt;Key&lt;UtilityPole&gt;, UtilityPole&gt;&amp; map, const UtilityPoleArray&amp; msg); */
+/* void updateGuardRail(std::map&lt;Key&lt;GuardRail&gt;, GuardRail&gt;&amp; map, const GuardRailArray&amp; msg); */
+/* void updateSideWalk(std::map&lt;Key&lt;SideWalk&gt;, SideWalk&gt;&amp; map, const SideWalkArray&amp; msg); */
+/* void updateDriveOnPortion(std::map&lt;Key&lt;DriveOnPortion&gt;, DriveOnPortion&gt;&amp; map, const DriveOnPortionArray&amp; msg); */
+/* void updateCrossRoad(std::map&lt;Key&lt;CrossRoad&gt;, CrossRoad&gt;&amp; map, const CrossRoadArray&amp; msg); */
+/* void updateSideStrip(std::map&lt;Key&lt;SideStrip&gt;, SideStrip&gt;&amp; map, const SideStripArray&amp; msg); */
+/* void updateCurveMirror(std::map&lt;Key&lt;CurveMirror&gt;, CurveMirror&gt;&amp; map, const CurveMirrorArray&amp; msg); */
+/* void updateWall(std::map&lt;Key&lt;Wall&gt;, Wall&gt;&amp; map, const WallArray&amp; msg); */
+/* void updateFence(std::map&lt;Key&lt;Fence&gt;, Fence&gt;&amp; map, const FenceArray&amp; msg); */
+/* void updateRailCrossing(std::map&lt;Key&lt;RailCrossing&gt;, RailCrossing&gt;&amp; map, const RailCrossingArray&amp; msg); */
+/* } // namespace */
 
 class VectorMap
 {
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="fdf4a27da30a284d9a1c53110d153041b9c7fa4b" author="Yusuke FUJII">
		<msg>add smoothing switch</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\planner_selector\nodes\planner_selector\planner_selector_node.cpp" new_path="ros\src\computing\planning\decision\packages\planner_selector\nodes\planner_selector\planner_selector_node.cpp" added_lines="118" deleted_lines="16">
				<diff>@@ -1,4 +1,5 @@
 #include &lt;autoware_msgs/lane.h&gt;
+#include &lt;autoware_msgs/ConfigPlannerSelector.h&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
 
@@ -6,8 +7,13 @@
 #include &lt;thread&gt;
 #include &lt;unordered_map&gt;
 
+#include &lt;euclidean_space.hpp&gt;
+
 namespace decision_maker
 {
+#define DEFAULT_LATENCY_NUM 5
+#define DEFAULT_WAYPOINTS_NUM 3
+#define DEFAULT_CONVERGENCE_NUM 2.0
 class PlannerSelectorNode
 {
 private:
@@ -17,19 +23,33 @@ private:
   std::unordered_map&lt;std::string, ros::Publisher&gt; Pubs;
   std::unordered_map&lt;std::string, ros::Subscriber&gt; Subs;
 
+
+  autoware_msgs::lane final_waypoints_dp;
+  autoware_msgs::lane final_waypoints_astar;
+
   std::unordered_map&lt;std::string, int&gt; closest_waypoints_;
   int __closest_waypoint_astar;
   int __closest_waypoint_dp;
 
+  unsigned int way_offset;
+
   std::mutex _mutex;
 
   int enableLattice_;
+  bool pastWaypoint;
+  unsigned int config_latency_num;
+  unsigned int config_waypoints_num;
+  double config_convergence_num;
 
 public:
   PlannerSelectorNode()
   {
     this-&gt;initROS();
     enableLattice_ = 0;
+    pastWaypoint = false;
+    config_latency_num = DEFAULT_LATENCY_NUM;
+    config_waypoints_num = DEFAULT_WAYPOINTS_NUM;
+    config_convergence_num = DEFAULT_CONVERGENCE_NUM;
   }
 
   void initROS();
@@ -37,6 +57,7 @@ public:
   void callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int32&gt; &amp;event);
   void callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::lane const&gt; &amp;event);
   void callbackFromLattice(const std_msgs::Int32 &amp;msg);
+  void callbackFromConfig(const autoware_msgs::ConfigPlannerSelector &amp;msg);
 };
 
 void PlannerSelectorNode::initROS()
@@ -52,27 +73,75 @@ void PlannerSelectorNode::initROS()
   Subs["/astar/closest_waypoint"] =
       nh_.subscribe("/astar/closest_waypoint", 1, &amp;PlannerSelectorNode::callbackFromClosest, this);
 
+  Subs["/config/planner_selector"] = nh_.subscribe("/config/PlannerSelector", 1, &amp;PlannerSelectorNode::callbackFromConfig, this);
+
   Pubs["final_waypoints"] = nh_.advertise&lt;autoware_msgs::lane&gt;("/final_waypoints", 1);
   Pubs["closest_waypoint"] = nh_.advertise&lt;std_msgs::Int32&gt;("/closest_waypoint", 1);
 }
 
-#define LATENCY_NUM 3
 void PlannerSelectorNode::callbackFromLattice(const std_msgs::Int32 &amp;msg)
 {
-  static int prev[LATENCY_NUM] = { 1 };
+  //static int prev[LATENCY_NUM] = { 1 };
+  static int counter = 0;
+  
+  double _distance = 100.0;
+
+  try{
+	  autoware_msgs::waypoint dp_point = final_waypoints_dp.waypoints.at(config_waypoints_num);
+	  autoware_msgs::waypoint astar_point = final_waypoints_astar.waypoints.at(config_waypoints_num);
+
+	  euclidean_space::point p_dp, p_astar;
+	  p_dp.x = dp_point.pose.pose.position.x;
+	  p_dp.x = dp_point.pose.pose.position.y;
+	  p_dp.z = 0.0;
+
+	  p_astar.x = astar_point.pose.pose.position.x;
+	  p_astar.x = astar_point.pose.pose.position.y;
+	  p_astar.z = 0.0;
+
+	  _distance = euclidean_space::EuclideanSpace::find_distance(&amp;p_dp, &amp;p_astar);
+	//  ROS_INFO("distance=%f. %d:%d", _distance, dp_point.dtlane.dist,astar_point.dtlane.dist);
+  }catch(const std::out_of_range &amp;ex){
+  }
+
 #if 0
-	if(enableLattice_ == 1)	{
-		for(int i = 1; i&lt;LATENCY_NUM; i++)
-			prev[i] = prev[i-1];
-		prev[0] = msg.data;
-		enableLattice_ = prev[LATENCY_NUM];
-	}else{
-		enableLattice_ = msg.data;
-	}
+  _mutex.lock();
+  if(enableLattice_){
+	  if (msg.data == 0){
+		  if(counter++ &gt;= config_latency_num){
+			  enableLattice_ = 0;
+			  counter = 0;
+		  }
+	  }
+  }else{
+	  enableLattice_ = msg.data;
+  }
+  ROS_INFO("msg.data=%d, enableLattice_ = %d", msg.data, enableLattice_);
+  _mutex.unlock();
 #else
   _mutex.lock();
-  if (msg.data != enableLattice_)
-    enableLattice_ = msg.data;
+  if (msg.data != enableLattice_){
+	  if(enableLattice_ == 1 &amp;&amp; msg.data == 0){
+		  if(pastWaypoint == false){
+			  pastWaypoint  = true;
+			  counter = 0;
+			  way_offset = config_waypoints_num;
+		  }
+	  }
+	  enableLattice_ = msg.data;
+  }
+  if(counter++ &gt;= config_latency_num)
+  {
+	  counter = 0;
+	  if(way_offset&gt;0)
+		  way_offset--;
+	  else
+		  pastWaypoint = false;
+  }
+
+
+
+  //ROS_INFO("msg.data=%d, enableLattice_ = %d", msg.data, enableLattice_);
   _mutex.unlock();
 #endif
   // for debug
@@ -91,16 +160,43 @@ void PlannerSelectorNode::callbackFromWaypoints(const ros::MessageEvent&lt;autoware
   if (this-&gt;enableLattice_ &amp;&amp; topic.find("dp") != std::string::npos)
   {
     Pubs["final_waypoints"].publish(*waypoints);
+    final_waypoints_dp = *waypoints;
   }
   else if (!this-&gt;enableLattice_ &amp;&amp; topic.find("astar") != std::string::npos)
   {
-    Pubs["final_waypoints"].publish(*waypoints);
+
+    if(pastWaypoint){
+	    static bool initflag = true;
+	    for(int i=0; i&lt;config_waypoints_num; i++){
+		    if(!final_waypoints_astar.waypoints.empty())
+			    final_waypoints_astar.waypoints.erase(final_waypoints_astar.waypoints.begin());
+		    else{
+			    pastWaypoint = false;
+			    way_offset=0;
+
+		    }
+	    }
+	    Pubs["final_waypoints"].publish(final_waypoints_astar);
+    }else{
+	    Pubs["final_waypoints"].publish(*waypoints);
+    }
+    final_waypoints_astar = *waypoints;
   }
-//for debug
-//ROS_INFO("%s, %d-%d-%d", topic.c_str(), __closest_waypoint_dp, __closest_waypoint_astar, this-&gt;enableLattice_);
+  //for debug
+  //ROS_INFO("%s, %d-%d-%d", topic.c_str(), __closest_waypoint_dp, __closest_waypoint_astar, this-&gt;enableLattice_);
   _mutex.unlock();
 }
 
+void PlannerSelectorNode::callbackFromConfig(const autoware_msgs::ConfigPlannerSelector &amp;msg)
+{
+	config_latency_num = msg.latency_num;
+	config_waypoints_num = msg.waypoints_num;
+	config_convergence_num = msg.convergence_num;
+
+	ROS_INFO("PARAM_SET-latency:%d, waypoints:%d, convergence:%f", config_latency_num, config_waypoints_num, config_convergence_num);
+}
+
+
 void PlannerSelectorNode::callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int32&gt; &amp;event)
 {
   const ros::M_string &amp;header = event.getConnectionHeader();
@@ -125,7 +221,13 @@ void PlannerSelectorNode::callbackFromClosest(const ros::MessageEvent&lt;std_msgs::
     closest_waypoints_["astar"] = temp;
     __closest_waypoint_astar = temp;
   }
-  msg.data = __closest_waypoint_astar;
+
+//  ROS_INFO("PastWaypoint:%s-offset:%d, latency:%d, closest:%d", pastWaypoint?"true":"false", way_offset, config_latency_num,__closest_waypoint_astar);
+  if(pastWaypoint &amp;&amp;  final_waypoints_astar.waypoints.size() &gt; __closest_waypoint_astar + way_offset){
+	  msg.data = __closest_waypoint_astar + way_offset;
+  }else{
+	  msg.data = __closest_waypoint_astar;
+  }
 #endif
   Pubs["closest_waypoint"].publish(msg);
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="c5329ebb21f4d627bb364539d39ff1bdd265bf3c" author="Yusuke FUJII">
		<msg>add config parameter</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\planner_selector\nodes\planner_selector\planner_selector_node.cpp" new_path="ros\src\computing\planning\decision\packages\planner_selector\nodes\planner_selector\planner_selector_node.cpp" added_lines="57" deleted_lines="50">
				<diff>@@ -24,12 +24,12 @@ private:
   std::unordered_map&lt;std::string, ros::Subscriber&gt; Subs;
 
 
-  autoware_msgs::lane final_waypoints_dp;
-  autoware_msgs::lane final_waypoints_astar;
+  autoware_msgs::lane final_waypoints_dp_;
+  autoware_msgs::lane final_waypoints_astar_;
 
   std::unordered_map&lt;std::string, int&gt; closest_waypoints_;
-  int __closest_waypoint_astar;
-  int __closest_waypoint_dp;
+  int closest_waypoint_astar_;
+  int closest_waypoint_dp_;
 
   unsigned int way_offset;
 
@@ -37,9 +37,11 @@ private:
 
   int enableLattice_;
   bool pastWaypoint;
-  unsigned int config_latency_num;
-  unsigned int config_waypoints_num;
-  double config_convergence_num;
+  unsigned int 	config_latency_num_;
+  unsigned int 	config_waypoints_num_;
+  double 	config_convergence_num_;
+
+  bool existWaypoints(const int _config_waypoints_num); 
 
 public:
   PlannerSelectorNode()
@@ -47,9 +49,9 @@ public:
     this-&gt;initROS();
     enableLattice_ = 0;
     pastWaypoint = false;
-    config_latency_num = DEFAULT_LATENCY_NUM;
-    config_waypoints_num = DEFAULT_WAYPOINTS_NUM;
-    config_convergence_num = DEFAULT_CONVERGENCE_NUM;
+    config_latency_num_ = DEFAULT_LATENCY_NUM;
+    config_waypoints_num_ = DEFAULT_WAYPOINTS_NUM;
+    config_convergence_num_ = DEFAULT_CONVERGENCE_NUM;
   }
 
   void initROS();
@@ -79,16 +81,23 @@ void PlannerSelectorNode::initROS()
   Pubs["closest_waypoint"] = nh_.advertise&lt;std_msgs::Int32&gt;("/closest_waypoint", 1);
 }
 
+inline bool PlannerSelectorNode::existWaypoints(const int _config_waypoints_num)
+{
+	bool ret;
+	ret = ( _config_waypoints_num &lt; final_waypoints_dp_.waypoints.size() ) 
+		&amp;&amp; ( _config_waypoints_num &lt; final_waypoints_dp_.waypoints.size() ) ;
+	return ret;
+}
+
 void PlannerSelectorNode::callbackFromLattice(const std_msgs::Int32 &amp;msg)
 {
   //static int prev[LATENCY_NUM] = { 1 };
-  static int counter = 0;
-  
+  static int counter = 0;  
   double _distance = 100.0;
 
   try{
-	  autoware_msgs::waypoint dp_point = final_waypoints_dp.waypoints.at(config_waypoints_num);
-	  autoware_msgs::waypoint astar_point = final_waypoints_astar.waypoints.at(config_waypoints_num);
+	  autoware_msgs::waypoint dp_point = final_waypoints_dp_.waypoints.at(config_waypoints_num_);
+	  autoware_msgs::waypoint astar_point = final_waypoints_astar_.waypoints.at(config_waypoints_num_);
 
 	  euclidean_space::point p_dp, p_astar;
 	  p_dp.x = dp_point.pose.pose.position.x;
@@ -100,15 +109,16 @@ void PlannerSelectorNode::callbackFromLattice(const std_msgs::Int32 &amp;msg)
 	  p_astar.z = 0.0;
 
 	  _distance = euclidean_space::EuclideanSpace::find_distance(&amp;p_dp, &amp;p_astar);
-	//  ROS_INFO("distance=%f. %d:%d", _distance, dp_point.dtlane.dist,astar_point.dtlane.dist);
+	  //  ROS_INFO("distance=%f. %d:%d", _distance, dp_point.dtlane.dist,astar_point.dtlane.dist);
   }catch(const std::out_of_range &amp;ex){
+	  ROS_ERROR("Out of Range:%s", ex.what() );
   }
 
-#if 0
+#if 0 // delay switch
   _mutex.lock();
   if(enableLattice_){
 	  if (msg.data == 0){
-		  if(counter++ &gt;= config_latency_num){
+		  if(counter++ &gt;= config_latency_num_){
 			  enableLattice_ = 0;
 			  counter = 0;
 		  }
@@ -125,12 +135,12 @@ void PlannerSelectorNode::callbackFromLattice(const std_msgs::Int32 &amp;msg)
 		  if(pastWaypoint == false){
 			  pastWaypoint  = true;
 			  counter = 0;
-			  way_offset = config_waypoints_num;
+			  way_offset = config_waypoints_num_;
 		  }
 	  }
 	  enableLattice_ = msg.data;
   }
-  if(counter++ &gt;= config_latency_num)
+  if(counter++ &gt;= config_latency_num_)
   {
 	  counter = 0;
 	  if(way_offset&gt;0)
@@ -154,46 +164,43 @@ void PlannerSelectorNode::callbackFromWaypoints(const ros::MessageEvent&lt;autoware
   std::string topic = header.at("topic");
   const autoware_msgs::lane *waypoints = event.getMessage().get();
 
-  /// ROS_INFO("%s", enableLattice_?"flag = True":"flag = False");
-
   _mutex.lock();
+
   if (this-&gt;enableLattice_ &amp;&amp; topic.find("dp") != std::string::npos)
   {
     Pubs["final_waypoints"].publish(*waypoints);
-    final_waypoints_dp = *waypoints;
+    final_waypoints_dp_ = *waypoints;
   }
   else if (!this-&gt;enableLattice_ &amp;&amp; topic.find("astar") != std::string::npos)
   {
-
     if(pastWaypoint){
-	    static bool initflag = true;
-	    for(int i=0; i&lt;config_waypoints_num; i++){
-		    if(!final_waypoints_astar.waypoints.empty())
-			    final_waypoints_astar.waypoints.erase(final_waypoints_astar.waypoints.begin());
+	    for(int i=0; i &lt; config_waypoints_num_; i++){
+		    if(!final_waypoints_astar_.waypoints.empty())
+			    final_waypoints_astar_.waypoints.erase(final_waypoints_astar_.waypoints.begin());
 		    else{
 			    pastWaypoint = false;
 			    way_offset=0;
-
 		    }
 	    }
-	    Pubs["final_waypoints"].publish(final_waypoints_astar);
+	    Pubs["final_waypoints"].publish(final_waypoints_astar_);
     }else{
 	    Pubs["final_waypoints"].publish(*waypoints);
     }
-    final_waypoints_astar = *waypoints;
+    final_waypoints_astar_ = *waypoints;
   }
+
   //for debug
-  //ROS_INFO("%s, %d-%d-%d", topic.c_str(), __closest_waypoint_dp, __closest_waypoint_astar, this-&gt;enableLattice_);
+  //ROS_INFO("%s, %d-%d-%d", topic.c_str(), closest_waypoint_dp_, closest_waypoint_astar_, this-&gt;enableLattice_);
   _mutex.unlock();
 }
 
 void PlannerSelectorNode::callbackFromConfig(const autoware_msgs::ConfigPlannerSelector &amp;msg)
 {
-	config_latency_num = msg.latency_num;
-	config_waypoints_num = msg.waypoints_num;
-	config_convergence_num = msg.convergence_num;
+	config_latency_num_ = msg.latency_num;
+	config_waypoints_num_ = msg.waypoints_num;
+	config_convergence_num_ = msg.convergence_num;
 
-	ROS_INFO("PARAM_SET-latency:%d, waypoints:%d, convergence:%f", config_latency_num, config_waypoints_num, config_convergence_num);
+	ROS_INFO("PARAM_SET-latency:%d, waypoints:%d, convergence:%f", config_latency_num_, config_waypoints_num_, config_convergence_num_);
 }
 
 
@@ -208,25 +215,25 @@ void PlannerSelectorNode::callbackFromClosest(const ros::MessageEvent&lt;std_msgs::
 #if 1
   if (topic.find("/dp") == 0)
   {
-    closest_waypoints_["dp"] = temp;
+	  closest_waypoints_["dp"] = temp;
 
-    if (closest_waypoints_["astar"])
-    {
-      msg.data = __closest_waypoint_astar;
-    }
-    __closest_waypoint_dp = temp;
+	  if (closest_waypoints_["astar"])
+	  {
+		  msg.data = closest_waypoint_astar_;
+	  }
+	  closest_waypoint_dp_ = temp;
   }
   else if (topic.find("/astar") == 0)
   {
-    closest_waypoints_["astar"] = temp;
-    __closest_waypoint_astar = temp;
+	  closest_waypoints_["astar"] = temp;
+	  closest_waypoint_astar_ = temp;
   }
 
-//  ROS_INFO("PastWaypoint:%s-offset:%d, latency:%d, closest:%d", pastWaypoint?"true":"false", way_offset, config_latency_num,__closest_waypoint_astar);
-  if(pastWaypoint &amp;&amp;  final_waypoints_astar.waypoints.size() &gt; __closest_waypoint_astar + way_offset){
-	  msg.data = __closest_waypoint_astar + way_offset;
+  //  ROS_INFO("PastWaypoint:%s-offset:%d, latency:%d, closest:%d", pastWaypoint?"true":"false", way_offset, config_latency_num_,closest_waypoint_astar);
+  if(pastWaypoint &amp;&amp;  final_waypoints_astar_.waypoints.size() &gt; closest_waypoint_astar_ + way_offset){
+	  msg.data = closest_waypoint_astar_ + way_offset;
   }else{
-	  msg.data = __closest_waypoint_astar;
+	  msg.data = closest_waypoint_astar_;
   }
 #endif
   Pubs["closest_waypoint"].publish(msg);
@@ -234,8 +241,8 @@ void PlannerSelectorNode::callbackFromClosest(const ros::MessageEvent&lt;std_msgs::
 }
 int main(int argc, char **argv)
 {
-  ros::init(argc, argv, "planner_selector");
+	ros::init(argc, argv, "planner_selector");
 
-  decision_maker::PlannerSelectorNode _psn;
-  ros::spin();
+	decision_maker::PlannerSelectorNode _psn;
+	ros::spin();
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8fec0f3f4c4a9a1b5248ca67188083463a951170" author="TomohitoAndo">
		<msg>Change color of a simulated obstacle</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\obstacle_sim\obstacle_sim.cpp" new_path="ros\src\computing\planning\motion\packages\astar_planner\nodes\obstacle_avoid\obstacle_sim\obstacle_sim.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -168,7 +168,7 @@ void ObstacleSim::displayObstacleMarker(const geometry_msgs::Point&amp; p1, const ge
 
   marker.scale.x = 0.1;
   marker.color.a = 1.0;
-  marker.color.r = 0.0;
+  marker.color.r = 1.0;
   marker.color.g = 1.0;
   marker.color.b = 0.0;
   //marker.lifetime = ros::Duration(0.1);
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="31fb966b914ace3d664db69d4b6e69317a7f66cb" author="TomohitoAndo">
		<msg>Update Rviz config</msg>
		<modified_files>
			<file old_path="ros\src\.config\rviz\default.rviz" new_path="ros\src\.config\rviz\default.rviz" added_lines="64" deleted_lines="43">
				<diff>@@ -13,7 +13,7 @@ Panels:
         - /Local Rollouts1/Namespaces1
         - /GlobalPathAnimation1/Status1
       Splitter Ratio: 0.695804
-    Tree Height: 1183
+    Tree Height: 640
   - Class: rviz/Selection
     Name: Selection
   - Class: rviz/Tool Properties
@@ -115,26 +115,7 @@ Visualization Manager:
       Marker Topic: /vector_map
       Name: Vector Map
       Namespaces:
-        cross_road: true
-        cross_walk: true
-        curb: true
-        curve_mirror: true
-        fence: true
-        guard_rail: true
-        gutter: true
-        rail_crossing: true
-        road_edge: true
-        road_mark: true
-        road_pole: true
-        road_sign: true
-        side_walk: true
-        signal: true
-        stop_line: true
-        street_light: true
-        utility_pole: true
-        wall: true
-        white_line: true
-        zebra_zone: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/Camera
@@ -148,8 +129,9 @@ Visualization Manager:
       Unreliable: false
       Value: false
       Visibility:
+        "": true
+        A* Sim Obstacle: true
         Behavior State: true
-        Bounding Boxes: true
         Control Pose: true
         Current Pose: true
         Detection Range: true
@@ -193,7 +175,7 @@ Visualization Manager:
       Enabled: true
       Invert Rainbow: false
       Max Color: 255; 255; 255
-      Max Intensity: 237
+      Max Intensity: 137
       Min Color: 0; 0; 0
       Min Intensity: 0
       Name: Points Raw
@@ -273,7 +255,10 @@ Visualization Manager:
       Marker Topic: /detection_range
       Name: Detection Range
       Namespaces:
-        {}
+        Crosswalk Detection: true
+        Decelerate Detection: true
+        Stop Detection: true
+        Stop Line: true
       Queue Size: 100
       Value: true
     - Class: rviz/Marker
@@ -364,7 +349,9 @@ Visualization Manager:
       Marker Topic: /local_waypoints_mark
       Name: Local Waypoints
       Namespaces:
-        {}
+        local_path_marker: true
+        local_point_marker: true
+        local_waypoint_velocity: true
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -383,15 +370,23 @@ Visualization Manager:
         {}
       Queue Size: 100
       Value: true
+    - Class: rviz/Marker
+      Enabled: true
+      Marker Topic: /astar_sim_obstacle
+      Name: A* Sim Obstacle
+      Namespaces:
+        {}
+      Queue Size: 100
+      Value: true
     - Alpha: 0.7
       Class: rviz/Map
       Color Scheme: map
-      Draw Behind: false
-      Enabled: false
-      Name: Laserscan Costmap
-      Topic: /ring_ogm
+      Draw Behind: true
+      Enabled: true
+      Name: Occupancy Grid Map
+      Topic: /grid_map_visualization/distance_transform
       Unreliable: false
-      Value: false
+      Value: true
     - Class: rviz/MarkerArray
       Enabled: true
       Marker Topic: /vector_map_center_lines_rviz
@@ -405,9 +400,7 @@ Visualization Manager:
       Marker Topic: /global_waypoints_rviz
       Name: Global Path
       Namespaces:
-        global_lane_array_marker: true
-        global_lane_waypoint_orientation_marker: true
-        global_velocity_lane_1: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -415,7 +408,7 @@ Visualization Manager:
       Marker Topic: /local_trajectories
       Name: Local Rollouts
       Namespaces:
-        global_lane_array_marker: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -431,7 +424,7 @@ Visualization Manager:
       Marker Topic: /behavior_state
       Name: Behavior State
       Namespaces:
-        detected_polygons_velocity: true
+        {}
       Queue Size: 100
       Value: true
     - Class: rviz/MarkerArray
@@ -447,7 +440,7 @@ Visualization Manager:
       Marker Topic: /safety_border
       Name: Safety Box
       Namespaces:
-        global_lane_array_marker: true
+        {}
       Queue Size: 100
       Value: true
     - Class: jsk_rviz_plugin/BoundingBoxArray
@@ -462,6 +455,31 @@ Visualization Manager:
       line width: 0.01
       only edge: false
       show coords: false
+    - Buffer length: 100
+      Class: jsk_rviz_plugin/Plotter2D
+      Enabled: true
+      Name: Velocity (km/h)
+      Show Value: true
+      Topic: /linear_velocity_viz
+      Value: true
+      auto color change: false
+      auto scale: true
+      background color: 0; 0; 0
+      backround alpha: 0
+      border: true
+      foreground alpha: 0.7
+      foreground color: 85; 255; 0
+      height: 80
+      left: 40
+      linewidth: 1
+      max color: 255; 0; 0
+      max value: 1
+      min value: -1
+      show caption: true
+      text size: 8
+      top: 30
+      update interval: 0.04
+      width: 80
   Enabled: true
   Global Options:
     Background Color: 48; 48; 48
@@ -485,7 +503,7 @@ Visualization Manager:
   Value: true
   Views:
     Current:
-      Angle: 0.00500008
+      Angle: 0
       Class: rviz/TopDownOrtho
       Enable Stereo Rendering:
         Stereo Eye Separation: 0.06
@@ -494,21 +512,21 @@ Visualization Manager:
         Value: false
       Name: Current View
       Near Clip Distance: 0.01
-      Scale: 22.8087
-      Target Frame: world
+      Scale: 10
+      Target Frame: &lt;Fixed Frame&gt;
       Value: TopDownOrtho (rviz)
-      X: 3.80643
-      Y: -18.6686
+      X: 0
+      Y: 0
     Saved: ~
 Window Geometry:
   Camera:
     collapsed: false
   Displays:
     collapsed: false
-  Height: 1416
+  Height: 873
   Hide Left Dock: false
   Hide Right Dock: false
-  QMainWindow State: 000000ff00000000fd0000000400000000000001fc000004e0fc020000000dfb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006400fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afc00000028000004e0000000dd00fffffffa000000020100000003fb0000000a0049006d0061006700650000000000ffffffff0000005c00fffffffb0000000c00430061006d0065007200610000000000ffffffff0000006500fffffffb000000100044006900730070006c0061007900730100000000000001360000016a00fffffffb0000000a0049006d006100670065010000028e000000d20000000000000000fb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000120049006d006100670065005f0072006100770000000000ffffffff0000000000000000fb0000000c00430061006d006500720061000000024e000001710000000000000000fb000000120049006d00610067006500200052006100770100000421000000160000000000000000fb0000000a0049006d00610067006501000002f4000000cb00000000000000000000000100000163000004e0fc0200000003fb0000000a005600690065007700730100000028000004e0000000b000fffffffb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b20000000000000000000000020000073f000000a8fc0100000001fb0000000a00560069006500770073030000004e00000080000002e1000001970000000300000a000000005cfc0100000002fb0000000800540069006d0065010000000000000a00000002f600fffffffb0000000800540069006d0065010000000000000450000000000000000000000695000004e000000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
+  QMainWindow State: 000000ff00000000fd00000004000000000000016a000002c1fc020000000dfb0000001200530065006c0065006300740069006f006e00000001e10000009b0000006400fffffffb0000001e0054006f006f006c002000500072006f007000650072007400690065007302000001ed000001df00000185000000a3fb000000120056006900650077007300200054006f006f02000001df000002110000018500000122fb000000200054006f006f006c002000500072006f0070006500720074006900650073003203000002880000011d000002210000017afc00000028000002c1000000dd00fffffffa000000020100000003fb0000000a0049006d0061006700650000000000ffffffff0000000000000000fb0000000c00430061006d0065007200610000000000ffffffff0000006500fffffffb000000100044006900730070006c0061007900730100000000000001360000016a00fffffffb0000000a0049006d006100670065010000028e000000d20000000000000000fb0000002000730065006c0065006300740069006f006e00200062007500660066006500720200000138000000aa0000023a00000294fb00000014005700690064006500530074006500720065006f02000000e6000000d2000003ee0000030bfb0000000c004b0069006e0065006300740200000186000001060000030c00000261fb000000120049006d006100670065005f0072006100770000000000ffffffff0000000000000000fb0000000c00430061006d006500720061000000024e000001710000000000000000fb000000120049006d00610067006500200052006100770100000421000000160000000000000000fb0000000a0049006d00610067006501000002f4000000cb00000000000000000000000100000163000002c1fc0200000003fb0000000a005600690065007700730100000028000002c1000000b000fffffffb0000001e0054006f006f006c002000500072006f00700065007200740069006500730100000041000000780000000000000000fb0000001200530065006c0065006300740069006f006e010000025a000000b20000000000000000000000020000073f000000a8fc0100000001fb0000000a00560069006500770073030000004e00000080000002e100000197000000030000066d0000005cfc0100000002fb0000000800540069006d006501000000000000066d000002f600fffffffb0000000800540069006d0065010000000000000450000000000000000000000394000002c100000004000000040000000800000008fc0000000100000002000000010000000a0054006f006f006c00730100000000ffffffff0000000000000000
   Selection:
     collapsed: false
   Time:
@@ -517,3 +535,6 @@ Window Geometry:
     collapsed: false
   Views:
     collapsed: false
+  Width: 1645
+  X: 1861
+  Y: 91
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="5fa7446a80470302d64450fcfac87f48b109908c" author="Yusuke FUJII">
		<msg>integrate planner_selector package to decision_maker package</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\planner_selector\nodes\planner_selector\planner_selector_node.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\planner_selector\planner_selector_node.cpp" added_lines="31" deleted_lines="3">
				<diff>@@ -40,6 +40,7 @@ private:
   unsigned int 	config_latency_num_;
   unsigned int 	config_waypoints_num_;
   double 	config_convergence_num_;
+  double current_velocity_;
 
   bool existWaypoints(const int _config_waypoints_num); 
 
@@ -60,6 +61,7 @@ public:
   void callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::lane const&gt; &amp;event);
   void callbackFromLattice(const std_msgs::Int32 &amp;msg);
   void callbackFromConfig(const autoware_msgs::ConfigPlannerSelector &amp;msg);
+  void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
 };
 
 void PlannerSelectorNode::initROS()
@@ -77,7 +79,10 @@ void PlannerSelectorNode::initROS()
 
   Subs["/config/planner_selector"] = nh_.subscribe("/config/PlannerSelector", 1, &amp;PlannerSelectorNode::callbackFromConfig, this);
 
-  Pubs["final_waypoints"] = nh_.advertise&lt;autoware_msgs::lane&gt;("/final_waypoints", 1);
+  Subs["current_velocity"] =
+      nh_.subscribe("current_velocity", 3, &amp;PlannerSelectorNode::callbackFromCurrentVelocity, this);
+  
+Pubs["final_waypoints"] = nh_.advertise&lt;autoware_msgs::lane&gt;("/final_waypoints", 1);
   Pubs["closest_waypoint"] = nh_.advertise&lt;std_msgs::Int32&gt;("/closest_waypoint", 1);
 }
 
@@ -143,10 +148,11 @@ void PlannerSelectorNode::callbackFromLattice(const std_msgs::Int32 &amp;msg)
   if(counter++ &gt;= config_latency_num_)
   {
 	  counter = 0;
-	  if(way_offset&gt;0)
+	  if(way_offset&gt;0){
 		  way_offset--;
-	  else
+	  }else{
 		  pastWaypoint = false;
+	  }
   }
 
 
@@ -157,6 +163,10 @@ void PlannerSelectorNode::callbackFromLattice(const std_msgs::Int32 &amp;msg)
   // for debug
   //	ROS_INFO("\n***** EnableLattice = %d  **** \n",enableLattice_,msg.data);
 }
+inline double mps2kmph(double _mpsval)
+{
+  return (_mpsval * 60 * 60) / 1000;  // mps * 60sec * 60m / 1000m
+}
 
 void PlannerSelectorNode::callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::lane const&gt; &amp;event)
 {
@@ -182,6 +192,18 @@ void PlannerSelectorNode::callbackFromWaypoints(const ros::MessageEvent&lt;autoware
 			    way_offset=0;
 		    }
 	    }
+#if 0
+	    if(final_waypoints_astar_.waypoints.empty()){
+		    int _size = final_waypoints_astar_.waypoints.size();
+		    _size = _size&gt;=5?5:_size;
+		    auto itr = final_waypoints_astar_.waypoints.begin();
+		    for(int i=0; i &lt; 5;  i++){
+			    itr-&gt;twist.twist.linear.x =  (current_velocity_*2 + itr-&gt;twist.twist.linear.x) / 3;
+			    std::cout &lt;&lt; "set linear velocity:" &lt;&lt;  mps2kmph(itr-&gt;twist.twist.linear.x)  &lt;&lt; std::endl; 
+			    itr++;
+		    }
+	    }
+#endif
 	    Pubs["final_waypoints"].publish(final_waypoints_astar_);
     }else{
 	    Pubs["final_waypoints"].publish(*waypoints);
@@ -194,6 +216,11 @@ void PlannerSelectorNode::callbackFromWaypoints(const ros::MessageEvent&lt;autoware
   _mutex.unlock();
 }
 
+void PlannerSelectorNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
+{
+	current_velocity_ = msg.twist.linear.x;
+}
+
 void PlannerSelectorNode::callbackFromConfig(const autoware_msgs::ConfigPlannerSelector &amp;msg)
 {
 	config_latency_num_ = msg.latency_num;
@@ -204,6 +231,7 @@ void PlannerSelectorNode::callbackFromConfig(const autoware_msgs::ConfigPlannerS
 }
 
 
+
 void PlannerSelectorNode::callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int32&gt; &amp;event)
 {
   const ros::M_string &amp;header = event.getConnectionHeader();
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="1ef267b18f1164562ca1ad5ca423aefb0d7ae768" author="Yusuke FUJII">
		<msg>Fixed forgetting to rename(state_machine node to decision_maker node)</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\cross_road_area.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\cross_road_area.hpp" added_lines="1" deleted_lines="1">
				<diff>@@ -8,7 +8,7 @@
 
 #include &lt;autoware_msgs/lane.h&gt;
 
-namespace state_machine
+namespace decision_maker
 {
 #define CROSS_ROAD 3232
 class CrossRoadArea
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\state_machine_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="16" deleted_lines="10">
				<diff>@@ -1,5 +1,5 @@
-#ifndef __STATE_MACHINE_NODE__
-#define __STATE_MACHINE_NODE__
+#ifndef __DECISION_MAKER_NODE__
+#define __DECISION_MAKER_NODE__
 
 #include &lt;unordered_map&gt;
 
@@ -20,12 +20,18 @@
 
 #include &lt;geometry_msgs/Point.h&gt;
 
+// lib
+#include &lt;euclidean_space.hpp&gt;
+#include &lt;state.hpp&gt;
+#include &lt;state_context.hpp&gt;
+
 #include &lt;cross_road_area.hpp&gt;
 
+
 //#include &lt;dynamic_reconfigure/server.h&gt;
-//#include &lt;state_machine/state_machineConfig.h&gt;
+//#include &lt;decision_maker/decision_makerConfig.h&gt;
 
-namespace state_machine
+namespace decision_maker
 {
 enum class EControl
 {
@@ -46,7 +52,7 @@ inline double mps2kmph(double _mpsval)
   return (_mpsval * 60 * 60) / 1000;  // mps * 60sec * 60m / 1000m
 }
 
-class StateMachineNode
+class DecisionMakerNode
 {
 private:
   ros::NodeHandle nh_;
@@ -124,19 +130,19 @@ private:
 
   // for ros dynamic reconfigure
   // Currently. this feature is not working.
-  // static void callbackFromDynamicReconfigure(state_machine::state_machineConfig &amp;config, uint32_t level);
+  // static void callbackFromDynamicReconfigure(decision_maker::decision_makerConfig &amp;config, uint32_t level);
 
   // in near future, these function will be deprecate
   CrossRoadArea *findClosestCrossRoad(void);
 
 public:
-  StateContext *ctx;
+  state_machine::StateContext *ctx;
 
-  StateMachineNode(int argc, char **argv)
+  DecisionMakerNode(int argc, char **argv)
   {
     SimulationMode = false;
 
-    ctx = new StateContext();
+    ctx = new state_machine::StateContext();
     this-&gt;initROS(argc, argv);
 
     vector_map_init = false;
@@ -148,6 +154,6 @@ public:
   void run(void);
 };
 
-}  // namespace state_machine
+}  // namespace decision_maker
 
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\cross_road_area.cpp" added_lines="1" deleted_lines="1">
				<diff>@@ -1,7 +1,7 @@
 #include &lt;cross_road_area.hpp&gt;
 #include &lt;euclidean_space.hpp&gt;
 
-namespace state_machine
+namespace decision_maker
 {
 #define TARGET_WAYPOINTS_NUM 15  // need to change rosparam
 CrossRoadArea *CrossRoadArea::findClosestCrossRoad(const autoware_msgs::lane &amp;_finalwaypoints,
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node.cpp" added_lines="30" deleted_lines="31">
				<diff>@@ -10,8 +10,7 @@
 #include &lt;state.hpp&gt;
 #include &lt;state_context.hpp&gt;
 
-#include &lt;state_machine_node.hpp&gt;
-
+#include &lt;decision_maker_node.hpp&gt;
 //#include &lt;vector_map/vector_map.h&gt;
 
 #include &lt;autoware_msgs/lane.h&gt;
@@ -25,14 +24,14 @@
 
 // for dynamic reconfigure
 //#include &lt;dynamic_reconfigure/server.h&gt;
-//#include &lt;state_machine/state_machineConfig.h&gt;
+//#include &lt;decision_maker/decision_makerConfig.h&gt;
 
-namespace state_machine
+namespace decision_maker
 {
 #define DOUBLE_MAX 1.7976931348623158e308
 #define TARGET_WAYPOINTS_NUM 14
 
-CrossRoadArea *StateMachineNode::findClosestCrossRoad(void)
+CrossRoadArea *DecisionMakerNode::findClosestCrossRoad(void)
 {
   CrossRoadArea *_area = nullptr;
 
@@ -75,7 +74,7 @@ CrossRoadArea *StateMachineNode::findClosestCrossRoad(void)
   return _area;
 }
 
-bool StateMachineNode::isInsideArea(geometry_msgs::Point pt)
+bool DecisionMakerNode::isInsideArea(geometry_msgs::Point pt)
 {
   // simply implementation
   //
@@ -98,30 +97,30 @@ bool StateMachineNode::isInsideArea(geometry_msgs::Point pt)
   return false;
 }
 
-void StateMachineNode::initStateMsgs(void)
+void DecisionMakerNode::initStateMsgs(void)
 {
 }
 
-void StateMachineNode::initROS(int argc, char **argv)
+void DecisionMakerNode::initROS(int argc, char **argv)
 {
   // status subscriber
-  Subs["current_pose"] = nh_.subscribe("current_pose", 20, &amp;StateMachineNode::callbackFromCurrentPose, this);
+  Subs["current_pose"] = nh_.subscribe("current_pose", 20, &amp;DecisionMakerNode::callbackFromCurrentPose, this);
   Subs["current_velocity"] =
-      nh_.subscribe("current_velocity", 20, &amp;StateMachineNode::callbackFromCurrentVelocity, this);
-  Subs["light_color"] = nh_.subscribe("light_color", 10, &amp;StateMachineNode::callbackFromLightColor, this);
-  Subs["points_raw"] = nh_.subscribe("filtered_points", 1, &amp;StateMachineNode::callbackFromPointsRaw, this);
-  Subs["final_waypoints"] = nh_.subscribe("final_waypoints", 100, &amp;StateMachineNode::callbackFromFinalWaypoint, this);
-  Subs["twist_cmd"] = nh_.subscribe("twist_cmd", 10, &amp;StateMachineNode::callbackFromTwistCmd, this);
+      nh_.subscribe("current_velocity", 20, &amp;DecisionMakerNode::callbackFromCurrentVelocity, this);
+  Subs["light_color"] = nh_.subscribe("light_color", 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
+  Subs["points_raw"] = nh_.subscribe("filtered_points", 1, &amp;DecisionMakerNode::callbackFromPointsRaw, this);
+  Subs["final_waypoints"] = nh_.subscribe("final_waypoints", 100, &amp;DecisionMakerNode::callbackFromFinalWaypoint, this);
+  Subs["twist_cmd"] = nh_.subscribe("twist_cmd", 10, &amp;DecisionMakerNode::callbackFromTwistCmd, this);
 
   // vector map subscriber
   Subs["vector_map_area"] =
-      nh_.subscribe("/vector_map_info/area", 1, &amp;StateMachineNode::callbackFromVectorMapArea, this);
+      nh_.subscribe("/vector_map_info/area", 1, &amp;DecisionMakerNode::callbackFromVectorMapArea, this);
   Subs["vector_map_point"] =
-      nh_.subscribe("/vector_map_info/point", 1, &amp;StateMachineNode::callbackFromVectorMapPoint, this);
+      nh_.subscribe("/vector_map_info/point", 1, &amp;DecisionMakerNode::callbackFromVectorMapPoint, this);
   Subs["vector_map_line"] =
-      nh_.subscribe("/vector_map_info/line", 1, &amp;StateMachineNode::callbackFromVectorMapLine, this);
+      nh_.subscribe("/vector_map_info/line", 1, &amp;DecisionMakerNode::callbackFromVectorMapLine, this);
   Subs["vector_map_crossroad"] =
-      nh_.subscribe("/vector_map_info/cross_road", 1, &amp;StateMachineNode::callbackFromVectorMapCrossRoad, this);
+      nh_.subscribe("/vector_map_info/cross_road", 1, &amp;DecisionMakerNode::callbackFromVectorMapCrossRoad, this);
 
   // pub
   Pubs["state"] = nh_.advertise&lt;std_msgs::String&gt;("state", 1);
@@ -135,8 +134,8 @@ void StateMachineNode::initROS(int argc, char **argv)
 
 #if 0
   // dynamic reconfigure
-  dynamic_reconfigure::Server&lt;state_machine::state_machineConfig&gt; dr_server;
-  dynamic_reconfigure::Server&lt;state_machine::state_machineConfig&gt;::CallbackType dr_server_f;
+  dynamic_reconfigure::Server&lt;decision_maker::decision_makerConfig&gt; dr_server;
+  dynamic_reconfigure::Server&lt;decision_maker::decision_makerConfig&gt;::CallbackType dr_server_f;
 
   dr_server_f = boost::bind(&amp;callbackFromDynamicReconfigure, _1, _2);
   dr_server.setCallback(dr_server_f);
@@ -170,7 +169,7 @@ void StateMachineNode::initROS(int argc, char **argv)
   }
 }
 
-void StateMachineNode::run(void)
+void DecisionMakerNode::run(void)
 {
   ros::Rate loop_rate(0.3);
 
@@ -187,13 +186,13 @@ void StateMachineNode::run(void)
   }
 }
 
-void StateMachineNode::update_pubsub(void)
+void DecisionMakerNode::update_pubsub(void)
 {
   // if state machine require to re-subscribe topic,
   // this function will re-definition subscriber.
 }
 
-void StateMachineNode::initVectorMap(void)
+void DecisionMakerNode::initVectorMap(void)
 {
   if (!vector_map_init &amp;&amp; vMap_Areas_flag &amp; vMap_Points_flag &amp; vMap_Lines_flag &amp; vMap_CrossRoads_flag)
   {
@@ -258,7 +257,7 @@ void StateMachineNode::initVectorMap(void)
   }
 }
 
-void StateMachineNode::displayMarker(void)
+void DecisionMakerNode::displayMarker(void)
 {
   // vector_map init
   // parse vectormap
@@ -327,7 +326,7 @@ void StateMachineNode::displayMarker(void)
   marker_array.markers.clear();
 }
 
-void StateMachineNode::update_msgs(void)
+void DecisionMakerNode::update_msgs(void)
 {
   if (ctx)
   {
@@ -350,7 +349,7 @@ void StateMachineNode::update_msgs(void)
     std::cerr &lt;&lt; "ctx is not found " &lt;&lt; std::endl;
 }
 
-bool StateMachineNode::initVectorMapClient()
+bool DecisionMakerNode::initVectorMapClient()
 {
 #ifdef USE_VMAP_SERVER  // This is not successfully run due to failing vmap
   // server
@@ -367,7 +366,7 @@ bool StateMachineNode::initVectorMapClient()
 #endif
 }
 
-bool StateMachineNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg,
+bool DecisionMakerNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg,
                                                     const geometry_msgs::PoseStamped &amp;pose_msg)
 {
 #ifdef USE_VMAP_SERVER  // this is not successfully run
@@ -392,7 +391,7 @@ bool StateMachineNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;l
 #endif
 }
 
-double StateMachineNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_msg,
+double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_msg,
                                                const geometry_msgs::PoseStamped &amp;pose_msg)
 {
   if (vMap_CrossRoads_flag)
@@ -468,7 +467,7 @@ double StateMachineNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_m
   }
 }
 
-void StateMachineNode::update(void)
+void DecisionMakerNode::update(void)
 {
   update_msgs();
 }
@@ -476,8 +475,8 @@ void StateMachineNode::update(void)
 
 int main(int argc, char **argv)
 {
-  ros::init(argc, argv, "state_machine");
-  state_machine::StateMachineNode smn(argc, argv);
+  ros::init(argc, argv, "decision_maker");
+  decision_maker::DecisionMakerNode smn(argc, argv);
   smn.run();
 
   return 0;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="15" deleted_lines="15">
				<diff>@@ -11,15 +11,15 @@
 #include &lt;cross_road_area.hpp&gt;
 #include &lt;state.hpp&gt;
 #include &lt;state_context.hpp&gt;
-#include &lt;state_machine_node.hpp&gt;
+#include &lt;decision_maker_node.hpp&gt;
 
-namespace state_machine
+namespace decision_maker
 {
 #define VEL_COUNT 10
-void StateMachineNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
+void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
 {
   geometry_msgs::PoseStamped _pose = current_pose_ = msg;
-  bool initLocalizationFlag = ctx-&gt;isState(INITIAL_LOCATEVEHICLE_STATE);
+  bool initLocalizationFlag = ctx-&gt;isState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
 
   if (initLocalizationFlag &amp;&amp;
       ctx-&gt;handleCurrentPose(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
@@ -29,7 +29,7 @@ void StateMachineNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped
   }
 }
 
-void StateMachineNode::callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg)
+void DecisionMakerNode::callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg)
 {
   ROS_INFO("Light color callback");
   CurrentTrafficlight = msg.traffic_light;
@@ -37,7 +37,7 @@ void StateMachineNode::callbackFromLightColor(const autoware_msgs::traffic_light
 }
 
 //
-void StateMachineNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
+void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
 {
   if (ctx-&gt;handlePointsRaw(true))
   {
@@ -45,7 +45,7 @@ void StateMachineNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::Con
   }
 }
 
-void StateMachineNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
+void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
 {
   if (!hasvMap())
   {
@@ -56,7 +56,7 @@ void StateMachineNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
   current_finalwaypoints_ = msg;
   ClosestArea_ = CrossRoadArea::findClosestCrossRoad(current_finalwaypoints_, intersects);
 
-  if (ctx-&gt;inState(DRIVE_STATE))
+  if (ctx-&gt;inState(state_machine::DRIVE_STATE))
   {
     double intersect_wayangle = calcIntersectWayAngle(current_finalwaypoints_, current_pose_);
     ctx-&gt;handleIntersection(true, intersect_wayangle);
@@ -85,7 +85,7 @@ void StateMachineNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
 
   std::cout &lt;&lt; "Velocity: " &lt;&lt; current_velocity_ &lt;&lt; " to " &lt;&lt; average_velocity_ &lt;&lt; std::endl;
 }
-void StateMachineNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
+void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
 {
   static bool Twistflag = false;
 
@@ -95,33 +95,33 @@ void StateMachineNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;m
     Twistflag = true;
 }
 
-void StateMachineNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
+void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
 {
   vMap_Areas = msg;
   vMap_Areas_flag = true;
 }
-void StateMachineNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
+void DecisionMakerNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
 {
   vMap_Points = msg;
   vMap_Points_flag = true;
 }
-void StateMachineNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
+void DecisionMakerNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
 {
   vMap_Lines = msg;
   vMap_Lines_flag = true;
 }
-void StateMachineNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
+void DecisionMakerNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
 {
   vMap_CrossRoads = msg;
   vMap_CrossRoads_flag = true;
 }
 
-void StateMachineNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
+void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
 {
   current_velocity_ = mps2kmph(msg.twist.linear.x);
 }
 #if 0
-	void StateMachineNode::callbackFromDynamicReconfigure(state_machine::state_machineConfig &amp;config, uint32_t level){
+	void DecisionMakerNode::callbackFromDynamicReconfigure(decision_maker::decision_makerConfig &amp;config, uint32_t level){
 		ROS_INFO("Reconfigure Request: %d ", config.TARGET_WAYPOINT_COUNT);
 	}
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\planner_selector\planner_selector_node.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\planner_selector\planner_selector_node.cpp" added_lines="17" deleted_lines="68">
				<diff>@@ -8,85 +8,33 @@
 #include &lt;unordered_map&gt;
 
 #include &lt;euclidean_space.hpp&gt;
+#include &lt;planner_selector.hpp&gt;
 
 namespace decision_maker
 {
-#define DEFAULT_LATENCY_NUM 5
-#define DEFAULT_WAYPOINTS_NUM 3
-#define DEFAULT_CONVERGENCE_NUM 2.0
-class PlannerSelectorNode
-{
-private:
-  ros::NodeHandle nh_;
-
-  std::unordered_map&lt;std::string, autoware_msgs::lane&gt; waypoints_;
-  std::unordered_map&lt;std::string, ros::Publisher&gt; Pubs;
-  std::unordered_map&lt;std::string, ros::Subscriber&gt; Subs;
-
-
-  autoware_msgs::lane final_waypoints_dp_;
-  autoware_msgs::lane final_waypoints_astar_;
-
-  std::unordered_map&lt;std::string, int&gt; closest_waypoints_;
-  int closest_waypoint_astar_;
-  int closest_waypoint_dp_;
-
-  unsigned int way_offset;
-
-  std::mutex _mutex;
-
-  int enableLattice_;
-  bool pastWaypoint;
-  unsigned int 	config_latency_num_;
-  unsigned int 	config_waypoints_num_;
-  double 	config_convergence_num_;
-  double current_velocity_;
-
-  bool existWaypoints(const int _config_waypoints_num); 
-
-public:
-  PlannerSelectorNode()
-  {
-    this-&gt;initROS();
-    enableLattice_ = 0;
-    pastWaypoint = false;
-    config_latency_num_ = DEFAULT_LATENCY_NUM;
-    config_waypoints_num_ = DEFAULT_WAYPOINTS_NUM;
-    config_convergence_num_ = DEFAULT_CONVERGENCE_NUM;
-  }
-
-  void initROS();
-
-  void callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int32&gt; &amp;event);
-  void callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::lane const&gt; &amp;event);
-  void callbackFromLattice(const std_msgs::Int32 &amp;msg);
-  void callbackFromConfig(const autoware_msgs::ConfigPlannerSelector &amp;msg);
-  void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
-};
-
-void PlannerSelectorNode::initROS()
+void PlannerSelector::initROS()
 {
   Subs["/dp/final_waypoints"] =
-      nh_.subscribe("/dp/final_waypoints", 1, &amp;PlannerSelectorNode::callbackFromWaypoints, this);
+      nh_.subscribe("/dp/final_waypoints", 1, &amp;PlannerSelector::callbackFromWaypoints, this);
   Subs["/astar/final_waypoints"] =
-      nh_.subscribe("/astar/final_waypoints", 1, &amp;PlannerSelectorNode::callbackFromWaypoints, this);
-  Subs["/enableLattice"] = nh_.subscribe("/enableLattice", 10, &amp;PlannerSelectorNode::callbackFromLattice, this);
+      nh_.subscribe("/astar/final_waypoints", 1, &amp;PlannerSelector::callbackFromWaypoints, this);
+  Subs["/enableLattice"] = nh_.subscribe("/enableLattice", 10, &amp;PlannerSelector::callbackFromLattice, this);
 
   Subs["/dp/closest_waypoint"] =
-      nh_.subscribe("/dp/closest_waypoint", 1, &amp;PlannerSelectorNode::callbackFromClosest, this);
+      nh_.subscribe("/dp/closest_waypoint", 1, &amp;PlannerSelector::callbackFromClosest, this);
   Subs["/astar/closest_waypoint"] =
-      nh_.subscribe("/astar/closest_waypoint", 1, &amp;PlannerSelectorNode::callbackFromClosest, this);
+      nh_.subscribe("/astar/closest_waypoint", 1, &amp;PlannerSelector::callbackFromClosest, this);
 
-  Subs["/config/planner_selector"] = nh_.subscribe("/config/PlannerSelector", 1, &amp;PlannerSelectorNode::callbackFromConfig, this);
+  Subs["/config/planner_selector"] = nh_.subscribe("/config/PlannerSelector", 1, &amp;PlannerSelector::callbackFromConfig, this);
 
   Subs["current_velocity"] =
-      nh_.subscribe("current_velocity", 3, &amp;PlannerSelectorNode::callbackFromCurrentVelocity, this);
+      nh_.subscribe("current_velocity", 3, &amp;PlannerSelector::callbackFromCurrentVelocity, this);
   
 Pubs["final_waypoints"] = nh_.advertise&lt;autoware_msgs::lane&gt;("/final_waypoints", 1);
   Pubs["closest_waypoint"] = nh_.advertise&lt;std_msgs::Int32&gt;("/closest_waypoint", 1);
 }
 
-inline bool PlannerSelectorNode::existWaypoints(const int _config_waypoints_num)
+inline bool PlannerSelector::existWaypoints(const int _config_waypoints_num)
 {
 	bool ret;
 	ret = ( _config_waypoints_num &lt; final_waypoints_dp_.waypoints.size() ) 
@@ -94,7 +42,7 @@ inline bool PlannerSelectorNode::existWaypoints(const int _config_waypoints_num)
 	return ret;
 }
 
-void PlannerSelectorNode::callbackFromLattice(const std_msgs::Int32 &amp;msg)
+void PlannerSelector::callbackFromLattice(const std_msgs::Int32 &amp;msg)
 {
   //static int prev[LATENCY_NUM] = { 1 };
   static int counter = 0;  
@@ -168,7 +116,7 @@ inline double mps2kmph(double _mpsval)
   return (_mpsval * 60 * 60) / 1000;  // mps * 60sec * 60m / 1000m
 }
 
-void PlannerSelectorNode::callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::lane const&gt; &amp;event)
+void PlannerSelector::callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::lane const&gt; &amp;event)
 {
   const ros::M_string &amp;header = event.getConnectionHeader();
   std::string topic = header.at("topic");
@@ -216,12 +164,12 @@ void PlannerSelectorNode::callbackFromWaypoints(const ros::MessageEvent&lt;autoware
   _mutex.unlock();
 }
 
-void PlannerSelectorNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
+void PlannerSelector::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
 {
 	current_velocity_ = msg.twist.linear.x;
 }
 
-void PlannerSelectorNode::callbackFromConfig(const autoware_msgs::ConfigPlannerSelector &amp;msg)
+void PlannerSelector::callbackFromConfig(const autoware_msgs::ConfigPlannerSelector &amp;msg)
 {
 	config_latency_num_ = msg.latency_num;
 	config_waypoints_num_ = msg.waypoints_num;
@@ -232,7 +180,7 @@ void PlannerSelectorNode::callbackFromConfig(const autoware_msgs::ConfigPlannerS
 
 
 
-void PlannerSelectorNode::callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int32&gt; &amp;event)
+void PlannerSelector::callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int32&gt; &amp;event)
 {
   const ros::M_string &amp;header = event.getConnectionHeader();
   std::string topic = header.at("topic");
@@ -267,10 +215,11 @@ void PlannerSelectorNode::callbackFromClosest(const ros::MessageEvent&lt;std_msgs::
   Pubs["closest_waypoint"].publish(msg);
 }
 }
+
 int main(int argc, char **argv)
 {
 	ros::init(argc, argv, "planner_selector");
 
-	decision_maker::PlannerSelectorNode _psn;
+	decision_maker::PlannerSelector _psn;
 	ros::spin();
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="46bd6d52052c15c8538519cac27f310d4b077369" author="Yusuke FUJII">
		<msg>Removed dynamic reconfigure</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\cfg\state.cfg" new_path="" added_lines="0" deleted_lines="11">
				<diff>@@ -1,11 +0,0 @@
-#!/usr/bin/env python
-
-PACKAGE = "state_machine"
-
-from dynamic_reconfigure.parameter_generator_catkin import *
-
-gen = ParameterGenerator()
-
-gen.add("TARGET_WAYPOINT_COUNT", int_t, 0, "An Integer parameter", 15, 0, 100)
-
-exit(gen.generate(PACKAGE, "state_machine" ,"state_machine"))
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node.cpp" added_lines="0" deleted_lines="12">
				<diff>@@ -22,10 +22,6 @@
 #include &lt;geometry_msgs/Pose.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 
-// for dynamic reconfigure
-//#include &lt;dynamic_reconfigure/server.h&gt;
-//#include &lt;decision_maker/decision_makerConfig.h&gt;
-
 namespace decision_maker
 {
 #define DOUBLE_MAX 1.7976931348623158e308
@@ -132,14 +128,6 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   Pubs["crossroad_inside_visual"] = nh_.advertise&lt;visualization_msgs::Marker&gt;("/state/cross_inside_marker", 1);
   Pubs["crossroad_bbox"] = nh_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("/state/bbox", 10);
 
-#if 0
-  // dynamic reconfigure
-  dynamic_reconfigure::Server&lt;decision_maker::decision_makerConfig&gt; dr_server;
-  dynamic_reconfigure::Server&lt;decision_maker::decision_makerConfig&gt;::CallbackType dr_server_f;
-
-  dr_server_f = boost::bind(&amp;callbackFromDynamicReconfigure, _1, _2);
-  dr_server.setCallback(dr_server_f);
-#endif
   // message setup
   state_text_msg.text_size = 18;
   state_text_msg.line_width = 0;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="87f02b8766eede88bdd1eec5e0f856470526247b" author="Yusuke FUJII">
		<msg>Add publisher for target velocities</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="6" deleted_lines="0">
				<diff>@@ -83,6 +83,7 @@ private:
   std::string CurrentStateName;
   std::string TextOffset;
   std::vector&lt;CrossRoadArea&gt; intersects;
+  bool isDisplay;
 
   // for vectormap server
   // ros::ServiceClient cross_road_cli;
@@ -108,6 +109,8 @@ private:
   void update_pubsub(void);
   void displayMarker(void);
 
+  void publishToVelocityArray();
+
   //
   bool isInsideArea(geometry_msgs::Point pt);
   bool isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
@@ -141,6 +144,7 @@ public:
   DecisionMakerNode(int argc, char **argv)
   {
     SimulationMode = false;
+    isDisplay = true;
 
     ctx = new state_machine::StateContext();
     this-&gt;initROS(argc, argv);
@@ -154,6 +158,8 @@ public:
   void run(void);
 };
 
+
+
 }  // namespace decision_maker
 
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node.cpp" added_lines="6" deleted_lines="100">
				<diff>@@ -1,6 +1,7 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;ros/spinner.h&gt;
 #include &lt;std_msgs/Float64.h&gt;
+#include &lt;std_msgs/Float64MultiArray.h&gt;
 #include &lt;std_msgs/String.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;tf/transform_listener.h&gt;
@@ -127,6 +128,7 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   Pubs["crossroad_visual"] = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("/state/cross_road_marker", 1);
   Pubs["crossroad_inside_visual"] = nh_.advertise&lt;visualization_msgs::Marker&gt;("/state/cross_inside_marker", 1);
   Pubs["crossroad_bbox"] = nh_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("/state/bbox", 10);
+  Pubs["target_velocity_array"] = nh_.advertise&lt;std_msgs::Float64MultiArray&gt;("/target_velocity_array",1);
 
   // message setup
   state_text_msg.text_size = 18;
@@ -153,7 +155,8 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   }
   {
     initVectorMapClient();
-    displayMarker();
+    if(isDisplay)
+	    displayMarker();
   }
 }
 
@@ -169,17 +172,12 @@ void DecisionMakerNode::run(void)
   while (ros::ok())
   {
     update();
-    displayMarker();
+    if(isDisplay)
+	    displayMarker();
     loop_rate.sleep();
   }
 }
 
-void DecisionMakerNode::update_pubsub(void)
-{
-  // if state machine require to re-subscribe topic,
-  // this function will re-definition subscriber.
-}
-
 void DecisionMakerNode::initVectorMap(void)
 {
   if (!vector_map_init &amp;&amp; vMap_Areas_flag &amp; vMap_Points_flag &amp; vMap_Lines_flag &amp; vMap_CrossRoads_flag)
@@ -245,98 +243,6 @@ void DecisionMakerNode::initVectorMap(void)
   }
 }
 
-void DecisionMakerNode::displayMarker(void)
-{
-  // vector_map init
-  // parse vectormap
-  initVectorMap();
-
-  jsk_recognition_msgs::BoundingBoxArray bbox_array;
-
-  static visualization_msgs::MarkerArray marker_array;
-  static visualization_msgs::Marker crossroad_marker;
-  static visualization_msgs::Marker inside_marker;
-
-  crossroad_marker.header.frame_id = "/map";
-  crossroad_marker.header.stamp = ros::Time();
-  crossroad_marker.id = 1;
-  crossroad_marker.type = visualization_msgs::Marker::SPHERE_LIST;
-  crossroad_marker.action = visualization_msgs::Marker::ADD;
-  crossroad_marker.ns = "crossroad";
-
-  double scale = 3.0;
-  crossroad_marker.scale.x = scale;
-  crossroad_marker.scale.y = scale;
-  crossroad_marker.scale.z = 0.5;
-  crossroad_marker.color.a = 0.15;
-  crossroad_marker.color.r = 1.0;
-  crossroad_marker.color.g = 0.0;
-  /// www.sinet.ad.jp/aboutsinettd::cout &lt;&lt; "x: "&lt;&lt; _point.x &lt;&lt; std::endl;
-  crossroad_marker.color.b = 0.0;
-  crossroad_marker.frame_locked = true;
-  crossroad_marker.lifetime = ros::Duration(0.3);
-
-  inside_marker = crossroad_marker;
-  inside_marker.color.a = 0.5;
-  inside_marker.color.r = 1.0;
-  inside_marker.color.g = 1.0;
-  inside_marker.color.b = 0.0;
-  inside_marker.ns = "inside";
-  inside_marker.lifetime = ros::Duration();
-
-  bbox_array.header = crossroad_marker.header;
-
-  for (auto &amp;area : intersects)
-  {
-    for (const auto &amp;p : area.points)
-    {
-      // if(isInsideArea(p))
-      // inside_marker.points.push_back(p);
-      crossroad_marker.points.push_back(p);
-    }
-    area.bbox.header = crossroad_marker.header;
-    bbox_array.boxes.push_back(area.bbox);
-  }
-
-  Pubs["crossroad_bbox"].publish(bbox_array);
-  bbox_array.boxes.clear();
-
-  // marker_array.markers.push_back(inside_marker);
-  marker_array.markers.push_back(crossroad_marker);
-
-  Pubs["crossroad_visual"].publish(marker_array);
-
-  for (const auto &amp;p : inside_points_)
-    inside_marker.points.push_back(p);
-
-  Pubs["crossroad_inside_visual"].publish(inside_marker);
-
-  marker_array.markers.clear();
-}
-
-void DecisionMakerNode::update_msgs(void)
-{
-  if (ctx)
-  {
-    static std::string prevStateName;
-    CurrentStateName = *ctx-&gt;getCurrentStateName();
-
-    if (prevStateName != CurrentStateName)
-    {
-      prevStateName = CurrentStateName;
-      update_pubsub();
-    }
-
-    state_string_msg.data = CurrentStateName;
-    state_text_msg.text = CurrentStateName + "\n" + TextOffset;
-
-    Pubs["state"].publish(state_string_msg);
-    Pubs["state_overlay"].publish(state_text_msg);
-  }
-  else
-    std::cerr &lt;&lt; "ctx is not found " &lt;&lt; std::endl;
-}
-
 bool DecisionMakerNode::initVectorMapClient()
 {
 #ifdef USE_VMAP_SERVER  // This is not successfully run due to failing vmap
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="3" deleted_lines="1">
				<diff>@@ -69,7 +69,6 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
   }
 
   average_velocity_ = _temp_sum / VEL_COUNT;
-
   if (std::fabs(average_velocity_ - current_velocity_) &lt;= 2.0)
   {
     TextOffset = "Keep";
@@ -83,6 +82,9 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
     TextOffset = "Decelerate";
   }
 
+  // for publish plan of velocity
+  publishToVelocityArray();
+
   std::cout &lt;&lt; "Velocity: " &lt;&lt; current_velocity_ &lt;&lt; " to " &lt;&lt; average_velocity_ &lt;&lt; std::endl;
 }
 void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="a8e82d7ee7843d83b129bae28de7b60815c75693" author="Yusuke FUJII">
		<msg>Change file composition</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node.cpp" added_lines="0" deleted_lines="366">
				<diff>@@ -1,371 +1,5 @@
 #include &lt;ros/ros.h&gt;
-#include &lt;ros/spinner.h&gt;
-#include &lt;std_msgs/Float64.h&gt;
-#include &lt;std_msgs/Float64MultiArray.h&gt;
-#include &lt;std_msgs/String.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;tf/transform_listener.h&gt;
-
-// lib
-#include &lt;euclidean_space.hpp&gt;
-#include &lt;state.hpp&gt;
-#include &lt;state_context.hpp&gt;
-
 #include &lt;decision_maker_node.hpp&gt;
-//#include &lt;vector_map/vector_map.h&gt;
-
-#include &lt;autoware_msgs/lane.h&gt;
-#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
-#include &lt;visualization_msgs/MarkerArray.h&gt;
-#include &lt;random&gt;
-
-#include &lt;geometry_msgs/Point.h&gt;
-#include &lt;geometry_msgs/Pose.h&gt;
-#include &lt;geometry_msgs/PoseStamped.h&gt;
-
-namespace decision_maker
-{
-#define DOUBLE_MAX 1.7976931348623158e308
-#define TARGET_WAYPOINTS_NUM 14
-
-CrossRoadArea *DecisionMakerNode::findClosestCrossRoad(void)
-{
-  CrossRoadArea *_area = nullptr;
-
-  euclidean_space::point _pa;
-  euclidean_space::point _pb;
-
-  double _min_distance = DBL_MAX;
-
-  int _label = 1;
-
-  if (!current_finalwaypoints_.waypoints.empty())
-  {
-    _pa.x = current_finalwaypoints_.waypoints[TARGET_WAYPOINTS_NUM].pose.pose.position.x;
-    _pa.y = current_finalwaypoints_.waypoints[TARGET_WAYPOINTS_NUM].pose.pose.position.y;
-    _pa.z = 0.0;
-  }
-
-  for (size_t i = 0; i &lt; intersects.size(); i++)
-  {
-    _pb.x = intersects[i].bbox.pose.position.x;
-    _pb.y = intersects[i].bbox.pose.position.y;
-
-    _pb.z = 0.0;
-
-    double __temp_dis = euclidean_space::EuclideanSpace::find_distance(&amp;_pa, &amp;_pb);
-
-    intersects[i].bbox.label = 0;
-    if (_min_distance &gt;= __temp_dis)
-    {
-      _area = &amp;intersects[i];
-      _min_distance = __temp_dis;  //
-    }
-  }
-
-  if (_area)
-  {
-    _area-&gt;bbox.label = 3;
-  }
-
-  return _area;
-}
-
-bool DecisionMakerNode::isInsideArea(geometry_msgs::Point pt)
-{
-  // simply implementation
-  //
-  if (ClosestArea_ != nullptr)
-  {
-    double x1 = ClosestArea_-&gt;bbox.pose.position.x - (ClosestArea_-&gt;bbox.dimensions.x / 2);
-    double x2 = ClosestArea_-&gt;bbox.pose.position.x + (ClosestArea_-&gt;bbox.dimensions.x / 2);
-
-    double y1 = ClosestArea_-&gt;bbox.pose.position.y - (ClosestArea_-&gt;bbox.dimensions.y / 2);
-    double y2 = ClosestArea_-&gt;bbox.pose.position.y + (ClosestArea_-&gt;bbox.dimensions.y / 2);
-
-    if ((x1 &lt;= pt.x &amp;&amp; pt.x &lt;= x2))
-    {
-      if (y1 &lt;= pt.y &amp;&amp; pt.y &lt;= y2)
-      {
-        return true;
-      }
-    }
-  }
-  return false;
-}
-
-void DecisionMakerNode::initStateMsgs(void)
-{
-}
-
-void DecisionMakerNode::initROS(int argc, char **argv)
-{
-  // status subscriber
-  Subs["current_pose"] = nh_.subscribe("current_pose", 20, &amp;DecisionMakerNode::callbackFromCurrentPose, this);
-  Subs["current_velocity"] =
-      nh_.subscribe("current_velocity", 20, &amp;DecisionMakerNode::callbackFromCurrentVelocity, this);
-  Subs["light_color"] = nh_.subscribe("light_color", 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
-  Subs["points_raw"] = nh_.subscribe("filtered_points", 1, &amp;DecisionMakerNode::callbackFromPointsRaw, this);
-  Subs["final_waypoints"] = nh_.subscribe("final_waypoints", 100, &amp;DecisionMakerNode::callbackFromFinalWaypoint, this);
-  Subs["twist_cmd"] = nh_.subscribe("twist_cmd", 10, &amp;DecisionMakerNode::callbackFromTwistCmd, this);
-
-  // vector map subscriber
-  Subs["vector_map_area"] =
-      nh_.subscribe("/vector_map_info/area", 1, &amp;DecisionMakerNode::callbackFromVectorMapArea, this);
-  Subs["vector_map_point"] =
-      nh_.subscribe("/vector_map_info/point", 1, &amp;DecisionMakerNode::callbackFromVectorMapPoint, this);
-  Subs["vector_map_line"] =
-      nh_.subscribe("/vector_map_info/line", 1, &amp;DecisionMakerNode::callbackFromVectorMapLine, this);
-  Subs["vector_map_crossroad"] =
-      nh_.subscribe("/vector_map_info/cross_road", 1, &amp;DecisionMakerNode::callbackFromVectorMapCrossRoad, this);
-
-  // pub
-  Pubs["state"] = nh_.advertise&lt;std_msgs::String&gt;("state", 1);
-  Pubs["state_overlay"] = nh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;("/state/overlay_text", 1);
-
-  Pubs["state_local_diffdistance"] = nh_.advertise&lt;std_msgs::Float64&gt;("/state/val_diff_distance", 1);
-
-  Pubs["crossroad_visual"] = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("/state/cross_road_marker", 1);
-  Pubs["crossroad_inside_visual"] = nh_.advertise&lt;visualization_msgs::Marker&gt;("/state/cross_inside_marker", 1);
-  Pubs["crossroad_bbox"] = nh_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("/state/bbox", 10);
-  Pubs["target_velocity_array"] = nh_.advertise&lt;std_msgs::Float64MultiArray&gt;("/target_velocity_array",1);
-
-  // message setup
-  state_text_msg.text_size = 18;
-  state_text_msg.line_width = 0;
-  state_text_msg.font = "DejaVu Sans Mono";
-  state_text_msg.width = 500;
-  state_text_msg.height = 50;
-  state_text_msg.top = 10;
-  state_text_msg.left = 10;
-  state_text_msg.text = "UNDEFINED";
-
-  // initial publishing state message
-  update_msgs();
-
-  // to move initial state from start state
-  // this part confirm broadcasting tf(map to world)
-  {
-    std::cout &lt;&lt; "wait for tf of map to world" &lt;&lt; std::endl;
-    tf::TransformListener tf;
-    tf.waitForTransform("map", "world", ros::Time(), ros::Duration(999));
-
-    if (!ctx-&gt;TFInitialized())
-      std::cerr &lt;&lt; "failed initialization " &lt;&lt; std::endl;
-  }
-  {
-    initVectorMapClient();
-    if(isDisplay)
-	    displayMarker();
-  }
-}
-
-void DecisionMakerNode::run(void)
-{
-  ros::Rate loop_rate(0.3);
-
-  // for subscribe callback function
-  ros::AsyncSpinner spinner(1);
-  spinner.start();
-  // ros::MultiThreadedSpinner spinner(2);
-  // spinner.spin();
-  while (ros::ok())
-  {
-    update();
-    if(isDisplay)
-	    displayMarker();
-    loop_rate.sleep();
-  }
-}
-
-void DecisionMakerNode::initVectorMap(void)
-{
-  if (!vector_map_init &amp;&amp; vMap_Areas_flag &amp; vMap_Points_flag &amp; vMap_Lines_flag &amp; vMap_CrossRoads_flag)
-  {
-    vector_map_init = true;
-
-    int _index = 0;
-
-    for (const auto &amp;cross_road : vMap_CrossRoads.data)
-    {
-      for (const auto &amp;area : vMap_Areas.data)
-      {
-        if (cross_road.aid == area.aid)
-        {
-          CrossRoadArea carea;
-          carea.id = _index++;
-          carea.area_id = area.aid;
-
-          double x_avg = 0.0, x_min = 0.0, x_max = 0.0;
-          double y_avg = 0.0, y_min = 0.0, y_max = 0.0;
-          double z = 0.0;
-
-          int points_count = 0;
-          for (const auto &amp;line : vMap_Lines.data)
-          {
-            if (area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid)
-            {
-              for (const auto &amp;point : vMap_Points.data)
-              {
-                if (line.fpid &lt;= point.pid &amp;&amp; point.pid &lt;= line.fpid)
-                {
-                  geometry_msgs::Point _point;
-                  _point.x = point.ly;
-                  _point.y = point.bx;
-                  _point.z = point.h;
-
-                  x_avg += _point.x;
-                  y_avg += _point.y;
-
-                  x_min = (x_min == 0.0) ? _point.x : std::min(_point.x, x_min);
-                  x_max = (x_max == 0.0) ? _point.x : std::max(_point.x, x_max);
-                  y_min = (y_min == 0.0) ? _point.y : std::min(_point.y, y_min);
-                  y_max = (y_max == 0.0) ? _point.y : std::max(_point.y, y_max);
-                  z = _point.z;
-                  points_count++;
-
-                  carea.points.push_back(_point);
-                }  // if pid
-              }    // points iter
-            }      // if lid
-          }        // line iter
-          carea.bbox.pose.position.x = x_avg / (double)points_count;
-          carea.bbox.pose.position.y = y_avg / (double)points_count;
-          carea.bbox.pose.position.z = z;
-          carea.bbox.dimensions.x = x_max - x_min;
-          carea.bbox.dimensions.y = y_max - y_min;
-          carea.bbox.dimensions.z = 2;
-          carea.bbox.label = 1;
-          intersects.push_back(carea);
-        }
-      }
-    }
-  }
-}
-
-bool DecisionMakerNode::initVectorMapClient()
-{
-#ifdef USE_VMAP_SERVER  // This is not successfully run due to failing vmap
-  // server
-
-  vector_map::VectorMap vmap;
-  vmap.subscribe(nh_, vector_map::Category::AREA, ros::Duration(0));
-
-  cross_road_srv.request.pose = current_pose_;
-  cross_road_srv.request.waypoints = current_finalwaypoints_;
-
-  cross_road_cli = nh_.serviceClient&lt;vector_map_server::GetCrossRoad&gt;("vector_map_server/get_cross_road");
-
-  return cross_road_cli.call(cross_road_srv);
-#endif
-}
-
-bool DecisionMakerNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg,
-                                                    const geometry_msgs::PoseStamped &amp;pose_msg)
-{
-#ifdef USE_VMAP_SERVER  // this is not successfully run
-  cross_road_srv.request.pose = pose_msg;
-  cross_road_srv.request.waypoints.waypoints.clear();
-  std::cout &lt;&lt; "test" &lt;&lt; std::endl;
-
-  for (int i = 0; i &lt; 50; i++)
-  {
-    cross_road_srv.request.waypoints.waypoints.push_back(lane_msg.waypoints[i]);
-  }
-  for (const auto &amp;wayp : lane_msg.waypoints)
-    cross_road_srv.request.waypoints.waypoints.push_back(wayp);
-
-  cross_road_cli.call(cross_road_srv);
-
-  for (const auto &amp;cross_road_d : cross_road_srv.response.objects.data)
-  {
-    std::cout &lt;&lt; "EEEEEEEEE" &lt;&lt; cross_road_d.linkid &lt;&lt; std::endl;
-  }
-#else
-#endif
-}
-
-double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_msg,
-                                               const geometry_msgs::PoseStamped &amp;pose_msg)
-{
-  if (vMap_CrossRoads_flag)
-  {
-    int FirstPoint = 0;
-    int EndPoint = 0;
-    int index = 0;
-    int PrevPoint = 0;
-    double diff = 0.0;
-    inside_points_.clear();
-    for (int index = 0; index &lt; lane_msg.waypoints.size(); index++)
-    {
-      if (isInsideArea(lane_msg.waypoints[index].pose.pose.position))
-      {
-        if (!FirstPoint)
-          FirstPoint = index;
-
-        inside_points_.push_back(lane_msg.waypoints[index].pose.pose.position);
-      }
-      else if (FirstPoint &amp;&amp; !EndPoint)
-      {
-        EndPoint = PrevPoint;
-        break;
-      }
-      PrevPoint = index;
-    }
-
-    if (EndPoint == 0)
-    {
-      std::cerr &lt;&lt; "Not inside Cross Road" &lt;&lt; std::endl;
-    }
-    else
-    {
-      geometry_msgs::Pose _end_point;
-      _end_point = lane_msg.waypoints[EndPoint].pose.pose;
-
-      double r, p, y, _y;
-
-      tf::Quaternion quat_end(_end_point.orientation.x, _end_point.orientation.y, _end_point.orientation.z,
-                              _end_point.orientation.w);
-      tf::Quaternion quat_in(pose_msg.pose.orientation.x, pose_msg.pose.orientation.y, pose_msg.pose.orientation.z,
-                             pose_msg.pose.orientation.w);
-
-      tf::Matrix3x3(quat_end).getRPY(r, p, y);
-      tf::Matrix3x3(quat_in).getRPY(r, p, _y);
-
-      diff = std::floor(_y - y) * 180.0 / M_PI;
-#if 1
-      /* DEBUG */
-      std::cout &lt;&lt; "Yaw:" &lt;&lt; _y &lt;&lt; "-" &lt;&lt; y &lt;&lt; ":" &lt;&lt; _y - y &lt;&lt; std::endl;
-      if (diff &gt; 50)
-      {
-        std::cout &lt;&lt; "Right Turn!!!!!!" &lt;&lt; diff &lt;&lt; std::endl;
-      }
-      else if (diff &lt; -50)
-      {
-        std::cout &lt;&lt; "Left Turn!!!!!!" &lt;&lt; diff &lt;&lt; std::endl;
-      }
-      else
-      {
-        std::cout &lt;&lt; "Straight" &lt;&lt; diff &lt;&lt; std::endl;
-      }
-      std::cout &lt;&lt; "Size:" &lt;&lt; lane_msg.waypoints.size() &lt;&lt; ":"
-                &lt;&lt; "First Point = " &lt;&lt; FirstPoint &lt;&lt; "/ End Point = " &lt;&lt; EndPoint &lt;&lt; std::endl;
-#endif
-    }
-
-    return diff;
-  }
-  else
-  {
-    return 0.0;
-  }
-}
-
-void DecisionMakerNode::update(void)
-{
-  update_msgs();
-}
-}
 
 int main(int argc, char **argv)
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="0" deleted_lines="0">
				<diff></diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="92fef8c0c51cdf136a7dcdaf08044dfffbddca2e" author="Yusuke FUJII">
		<msg>fix a header dependencies and remove unnecessary part</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="3" deleted_lines="0">
				<diff>@@ -10,6 +10,7 @@
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 #include &lt;jsk_rviz_plugins/OverlayText.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
+#include &lt;std_msgs/String.h&gt;
 
 //#include &lt;vector_map_server/GetCrossRoad.h&gt;
 
@@ -33,6 +34,7 @@
 
 namespace decision_maker
 {
+//#define DEBUG_PRINT
 enum class EControl
 {
   KEEP = -1,
@@ -125,6 +127,7 @@ private:
   void callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg);
   void callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg);
   void callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg);
+  void callbackFromStateCmd(const std_msgs::String &amp;msg);
 
   void callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg);
   void callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="6" deleted_lines="5">
				<diff>@@ -15,7 +15,8 @@
 
 namespace decision_maker
 {
-#define VEL_COUNT 10
+#define VEL_AVERAGE_COUNT 10
+
 void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
 {
   geometry_msgs::PoseStamped _pose = current_pose_ = msg;
@@ -33,7 +34,7 @@ void DecisionMakerNode::callbackFromLightColor(const autoware_msgs::traffic_ligh
 {
   ROS_INFO("Light color callback");
   CurrentTrafficlight = msg.traffic_light;
-  ctx-&gt;handleTrafficLight(CurrentTrafficlight);
+  //ctx-&gt;handleTrafficLight(CurrentTrafficlight);
 }
 
 //
@@ -63,12 +64,12 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
   }
 
   double _temp_sum = 0;
-  for (int i = 0; i &lt; VEL_COUNT; i++)
+  for (int i = 0; i &lt; VEL_AVERAGE_COUNT; i++)
   {
     _temp_sum += mps2kmph(msg.waypoints[i].twist.twist.linear.x);
   }
-
-  average_velocity_ = _temp_sum / VEL_COUNT;
+  average_velocity_ = _temp_sum / VEL_AVERAGE_COUNT;
+  
   if (std::fabs(average_velocity_ - current_velocity_) &lt;= 2.0)
   {
     TextOffset = "Keep";
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" added_lines="20" deleted_lines="23">
				<diff>@@ -25,6 +25,7 @@
 
 namespace decision_maker
 {
+
 #define DOUBLE_MAX 1.7976931348623158e308
 #define TARGET_WAYPOINTS_NUM 14
 
@@ -95,24 +96,6 @@ bool DecisionMakerNode::isInsideArea(geometry_msgs::Point pt)
 }
 
 
-void DecisionMakerNode::run(void)
-{
-  ros::Rate loop_rate(0.3);
-
-  // for subscribe callback function
-  ros::AsyncSpinner spinner(1);
-  spinner.start();
-  // ros::MultiThreadedSpinner spinner(2);
-  // spinner.spin();
-  while (ros::ok())
-  {
-    update();
-    if(isDisplay)
-	    displayMarker();
-    loop_rate.sleep();
-  }
-}
-
 
 bool DecisionMakerNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg,
                                                     const geometry_msgs::PoseStamped &amp;pose_msg)
@@ -120,7 +103,6 @@ bool DecisionMakerNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;
 #ifdef USE_VMAP_SERVER  // this is not successfully run
   cross_road_srv.request.pose = pose_msg;
   cross_road_srv.request.waypoints.waypoints.clear();
-  std::cout &lt;&lt; "test" &lt;&lt; std::endl;
 
   for (int i = 0; i &lt; 50; i++)
   {
@@ -133,9 +115,8 @@ bool DecisionMakerNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;
 
   for (const auto &amp;cross_road_d : cross_road_srv.response.objects.data)
   {
-    std::cout &lt;&lt; "EEEEEEEEE" &lt;&lt; cross_road_d.linkid &lt;&lt; std::endl;
+ //   std::cout &lt;&lt; "EEEEEEEEE" &lt;&lt; cross_road_d.linkid &lt;&lt; std::endl;
   }
-#else
 #endif
 }
 
@@ -187,8 +168,8 @@ double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_
       tf::Matrix3x3(quat_in).getRPY(r, p, _y);
 
       diff = std::floor(_y - y) * 180.0 / M_PI;
-#if 1
-      /* DEBUG */
+
+#ifdef DEBUG_PRINT
       std::cout &lt;&lt; "Yaw:" &lt;&lt; _y &lt;&lt; "-" &lt;&lt; y &lt;&lt; ":" &lt;&lt; _y - y &lt;&lt; std::endl;
       if (diff &gt; 50)
       {
@@ -219,4 +200,20 @@ void DecisionMakerNode::update(void)
 {
   update_msgs();
 }
+
+void DecisionMakerNode::run(void)
+{
+  ros::Rate loop_rate(0.3);
+
+  // for subscribe callback function
+  ros::AsyncSpinner spinner(1);
+  spinner.start();
+  while (ros::ok())
+  {
+    update();
+    if(isDisplay)
+	    displayMarker();
+    loop_rate.sleep();
+  }
+}
 }
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="30661e0ba49576e597de13d6b975b78b721bbb6a" author="Yusuke FUJII">
		<msg>Fixed configuration of state</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" added_lines="42" deleted_lines="30">
				<diff>@@ -14,30 +14,30 @@ namespace state_machine
 class StartState;
 class InitialState;
 class LocateVehicleState;
+
 class DriveState;
-class DriveMoveFwdState;
-class DriveMoveFwdLeftState;
-class DriveMoveFwdRightState;
-class DriveMoveFwdStraightState;
-class DriveLaneChangeState;
-class DriveLaneChangeLeftState;
-class DriveLaneChangeRightState;
-class DriveLaneChangeRightAvoidanceState;
-class DriveObstacleAvoidanceState;
-class DriveObstacleAvoidanceStaticState;
-class DriveObstacleAvoidanceDynamicState;
-class DriveStopState;
-class DriveStopAvoidanceState;
-class DriveStopStopLineState;
-class DriveStopTrafficLightState;
+ //Accel/Brake subState
+ class DriveAccAccelerationState;
+ class DriveAccDecelerationState;
+ class DriveAccKeepState;
+ class DriveAccStopState;
+ //Steering subState
+ class DriveStrStraightState;
+ class DriveStrLeftTurnState;
+ class DriveStrRightTurnState;
+
+ //Behavior subState
+ class DriveBehaviorLaneChangeLeftState;
+ class DriveBehaviorLaneChangeRightState;
+ class DriveBehaviorObstacleAvoidanceState;
+
+ //Perception subState
+ class DriveDetectObstacleState;
+ class DriveDetectStoplineState;
+ class DriveDetectTrafficlightRedState;
+
 class MissionCompleteState;
 class EmergencyState;
-class EmergencyHWState;
-class EmergencyHWVehicleState;
-class EmergencyHWControllerState;
-class EmergencySWState;
-class EmergencySWAutowareState;
-class EmergencySWControllerState;
 
 // base class
 class BaseState
@@ -47,10 +47,11 @@ public:
   BaseState()
   {
   }
-  virtual void ShowStateName(void) = 0;
-  virtual unsigned long long GetStateTransMask() = 0;
-  virtual unsigned long long GetStateNum() = 0;
-  virtual std::unique_ptr&lt;std::string&gt; GetStateName() = 0;
+  virtual void showStateName(void) = 0;
+  virtual unsigned long long getStateTransMask() = 0;
+  virtual unsigned long long getStateNum() = 0;
+  virtual std::unique_ptr&lt;std::string&gt; getStateName() = 0;
+  virtual unsigned char getStateKind() = 0;
 };
 
 // Interface
@@ -61,34 +62,41 @@ protected:
   std::string StateName = "Base";
   unsigned long long StateNum;
   unsigned long long StateTransMask;
+  unsigned char StateKind;
 
 public:
   State()
   {
     StateNum = 0;
     StateTransMask = (unsigned long long)STATE_END - 1;
+    StateKind = UNKNOWN_STATE;
   }
-  void ShowStateName(void)
+  void showStateName(void)
   {
     std::cout &lt;&lt; StateName &lt;&lt; "-";
   }
 
-  static T* GetInstance(void)
+  static T* getInstance(void)
   {
     static T singleton;
     return &amp;singleton;
   }
 
-  std::unique_ptr&lt;std::string&gt; GetStateName(void)
+  std::unique_ptr&lt;std::string&gt; getStateName(void)
   {
     return std::unique_ptr&lt;std::string&gt;(new std::string(StateName));
   }
 
-  unsigned long long GetStateTransMask(void)
+  unsigned char getStateKind(void)
+  {
+    return StateKind;
+  }
+
+  unsigned long long getStateTransMask(void)
   {
     return StateTransMask;
   }
-  unsigned long long GetStateNum(void)
+  unsigned long long getStateNum(void)
   {
     return StateNum;
   }
@@ -104,6 +112,7 @@ private:
     StateName = "Start";
     StateNum = START_STATE;
     StateTransMask = (unsigned long long)STATE_END - 1;
+    StateKind = MAIN_STATE;
   }
 
 public:
@@ -119,6 +128,7 @@ private:
     StateName = "Initial";
     StateNum = StateTransMask = INITIAL_STATE;
     StateTransMask |= START_STATE | EMERGENCY_STATE | MISSION_COMPLETE_STATE;
+    StateKind = MAIN_STATE;
   }
 
 public:
@@ -132,6 +142,7 @@ private:
     StateName = "Locate Vehicle";
     StateNum = StateTransMask = INITIAL_LOCATEVEHICLE_STATE;
     StateTransMask |= INITIAL_STATE;
+    StateKind = MAIN_STATE;
   }
 
 public:
@@ -146,6 +157,7 @@ private:
     StateName = "MissionComplete";
     StateNum = MISSION_COMPLETE_STATE;
     StateTransMask = DRIVE_STATE;
+    StateKind = MAIN_STATE;
   }
 
 public:
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" added_lines="44" deleted_lines="46">
				<diff>@@ -15,63 +15,59 @@ namespace state_machine
 class StateContext
 {
 private:
-  BaseState *state_;
-  BaseState *sub_state;
-  BaseState *sub_sub_state;
+	class StateHolder{
+		public:
+			BaseState *MainState;
+			BaseState *AccState;
+			BaseState *StrState;
+			BaseState *BehaviorState;
+			BaseState *PerceptionState;
+			BaseState *OtherState;
+	} current_state_;
+
   std::unordered_map&lt;uint64_t, BaseState *&gt; StateStores;
-  unsigned long long st;
+  
+  bool enableForceSetState;
   unsigned long long ChangeStateFlags;
   std::atomic&lt;bool&gt; thread_loop;
 
   std::thread *thr_state_dec;
 
-  void ShowStateMove(unsigned long long _state_num)
+  void showStateMove(unsigned long long _state_num)
   {
-    std::cout &lt;&lt; "State will be [" &lt;&lt; *StateStores[_state_num]-&gt;GetStateName() &lt;&lt; "]" &lt;&lt; std::endl;
+    std::cout &lt;&lt; "State will be [" &lt;&lt; *StateStores[_state_num]-&gt;getStateName() &lt;&lt; "]" &lt;&lt; std::endl;
   }
 
 public:
-  void debug_next_state()
-  {
-    if (st &gt;= STATE_END)
-      st = 1;
-    state_ = StateStores[st];
-    st = st &lt;&lt; 1;
-  }
   StateContext(void)
   {
-    st = 1;
-    state_ = nullptr;
-    sub_state = nullptr;
-    sub_sub_state = nullptr;
-
-    StateStores[START_STATE] = StartState::GetInstance();
-    StateStores[INITIAL_STATE] = InitialState::GetInstance();
-    StateStores[INITIAL_LOCATEVEHICLE_STATE] = LocateVehicleState::GetInstance();
-    StateStores[DRIVE_STATE] = DriveState::GetInstance();
-    StateStores[DRIVE_MOVEFWD_STATE] = DriveMoveFwdState::GetInstance();
-    StateStores[DRIVE_MOVEFWD_LEFT_STATE] = DriveMoveFwdLeftState::GetInstance();
-    StateStores[DRIVE_MOVEFWD_RIGHT_STATE] = DriveMoveFwdRightState::GetInstance();
-    StateStores[DRIVE_MOVEFWD_STRAIGHT_STATE] = DriveMoveFwdStraightState::GetInstance();
-    StateStores[DRIVE_LANECHANGE_STATE] = DriveLaneChangeState::GetInstance();
-    StateStores[DRIVE_LANECHANGE_LEFT_STATE] = DriveLaneChangeLeftState::GetInstance();
-    StateStores[DRIVE_LANECHANGE_RIGHT_STATE] = DriveLaneChangeRightState::GetInstance();
-    StateStores[DRIVE_LANECHANGE_RIGHT_AVOIDANCE_STATE] = DriveLaneChangeRightAvoidanceState::GetInstance();
-    StateStores[DRIVE_OBSTACLE_AVOIDANCE_STATE] = DriveObstacleAvoidanceState::GetInstance();
-    StateStores[DRIVE_OBSTACLE_AVOIDANCE_STATIC_STATE] = DriveObstacleAvoidanceStaticState::GetInstance();
-    StateStores[DRIVE_OBSTACLE_AVOIDANCE_DYNAMIC_STATE] = DriveObstacleAvoidanceDynamicState::GetInstance();
-    StateStores[DRIVE_STOP_STATE] = DriveStopState::GetInstance();
-    StateStores[DRIVE_STOP_AVOIDANCE_STATE] = DriveStopAvoidanceState::GetInstance();
-    StateStores[DRIVE_STOP_STOPLINE_STATE] = DriveStopStopLineState::GetInstance();
-    StateStores[DRIVE_STOP_TRAFFICLIGHT_STATE] = DriveStopTrafficLightState::GetInstance();
-    StateStores[MISSION_COMPLETE_STATE] = MissionCompleteState::GetInstance();
-    StateStores[EMERGENCY_STATE] = EmergencyState::GetInstance();
-    StateStores[EMERGENCY_HW_STATE] = EmergencyHWState::GetInstance();
-    StateStores[EMERGENCY_HWVEHICLE_STATE] = EmergencyHWVehicleState::GetInstance();
-    StateStores[EMERGENCY_HWCONTROLLER_STATE] = EmergencyHWControllerState::GetInstance();
-    StateStores[EMERGENCY_SW_STATE] = EmergencySWState::GetInstance();
-    StateStores[EMERGENCY_SWAUTOWARE_STATE] = EmergencySWAutowareState::GetInstance();
-    StateStores[EMERGENCY_SWCONTROLLER_STATE] = EmergencySWControllerState::GetInstance();
+
+    StateStores[START_STATE] = StartState::getInstance();
+    StateStores[INITIAL_STATE] = InitialState::getInstance();
+    StateStores[INITIAL_LOCATEVEHICLE_STATE] = LocateVehicleState::getInstance();
+    StateStores[DRIVE_STATE] = DriveState::getInstance();
+    StateStores[DRIVE_ACC_ACCELERATION_STATE] = DriveAccAccelerationState::getInstance();
+    StateStores[DRIVE_ACC_DECELERATION_STATE] = DriveAccDecelerationState::getInstance();
+    StateStores[DRIVE_ACC_KEEP_STATE] = DriveAccKeepState::getInstance();
+    StateStores[DRIVE_ACC_STOP_STATE] = DriveAccStopState::getInstance();
+    StateStores[DRIVE_STR_STRAIGHT_STATE] = DriveStrStraightState::getInstance();
+    StateStores[DRIVE_STR_LEFT_STATE] = DriveStrLeftState::getInstance();
+    StateStores[DRIVE_STR_RIGHT_STATE] = DriveStrRightState::getInstance();
+    StateStores[DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE] = DriveBehaviorLaneChangeLeftState::getInstance();
+    StateStores[DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE] = DriveBehaviorLaneChangeRightState::getInstance();
+    StateStores[DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE] = DriveBehaviorObstacleAvoidanceState::getInstance();
+    StateStores[DRIVE_DETECT_OBSTACLE_STATE] = DriveDetectObstacleState::getInstance();
+    StateStores[DRIVE_DETECT_STOPLINE_STATE] = DriveDetectStoplineState::getInstance();
+    StateStores[DRIVE_DETECT_TRAFFICLIGHT_RED_STATE] = DriveDetectTrafficlightRedState::getInstance();
+    StateStores[MISSION_COMPLETE_STATE] = MissionCompleteState::getInstance();
+    StateStores[EMERGENCY_STATE] = EmergencyState::getInstance();
+    
+    current_state_.MainState = nullptr;
+    current_state_.AccState = nullptr;
+    current_state_.StrState = nullptr;
+    current_state_.BehaviorState = nullptr;
+    current_state_.PerceptionState = nullptr;
+    current_state_.OtherState = nullptr;
 
     ChangeStateFlags = 0;
     thread_loop = true;
@@ -86,16 +82,18 @@ public:
   bool isState(unsigned long long _state_num);
   bool inState(unsigned long long _state_num);
 
-  void StateDecider(void);
+  void stateDecider(void);
 
   bool setCurrentState(BaseState *state);
   bool setCurrentState(BaseState *state, BaseState *substate);
   bool setCurrentState(BaseState *state, BaseState *substate, BaseState *subsubstate);
 
+  BaseState *getCurrentMainState(void);
   BaseState *getCurrentState(void);
   std::unique_ptr&lt;std::string&gt; getCurrentStateName(void);
   void showCurrentStateName(void);
 
+  bool setEnableForceSetState(bool force_flag);
   BaseState *getStateObject(unsigned long long _state_num);
   void InitContext(void);
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" added_lines="95" deleted_lines="99">
				<diff>@@ -23,20 +23,22 @@ private:
     StateName = "Drive";
     StateNum = StateTransMask = DRIVE_STATE;
     StateTransMask |= INITIAL_LOCATEVEHICLE_STATE;
+    StateKind = MAIN_STATE;
   }
 
 public:
 };
 
-class DriveMoveFwdState : public State&lt;DriveMoveFwdState&gt;
+class DriveAccAccelerationState : public State&lt;DriveAccAccelerationState&gt;
 {
 private:
-  friend class State&lt;DriveMoveFwdState&gt;;
-  DriveMoveFwdState(void)
+  friend class State&lt;DriveAccAccelerationState&gt;;
+  DriveAccAccelerationState(void)
   {
-    StateName = "MoveFwd";
-    StateNum = DRIVE_STATE | DRIVE_MOVEFWD_STATE;
-    StateTransMask = 0;
+    StateName = "Acceleration";
+    StateNum = DRIVE_STATE | DRIVE_ACC_ACCELERATION_STATE;
+    StateTransMask = DRIVE_STATE;
+    StateKind = ACC_STATE;
   }
 
 public:
@@ -46,195 +48,189 @@ public:
   }
 };
 
-class DriveMoveFwdLeftState : public State&lt;DriveMoveFwdLeftState&gt;
+class DriveAccDecelerationState : public State&lt;DriveAccDecelerationState&gt;
 {
 private:
-  friend class State&lt;DriveMoveFwdLeftState&gt;;
-  DriveMoveFwdLeftState(void)
+  friend class State&lt;DriveAccDecelerationState&gt;;
+  DriveAccDecelerationState(void)
   {
-    StateName = "MoveFwdLeft";
-    StateNum = DRIVE_STATE | DRIVE_MOVEFWD_LEFT_STATE;
-    StateTransMask = DRIVE_STATE | DRIVE_MOVEFWD_STATE;
+    StateName = "Deceleration";
+    StateNum = DRIVE_STATE | DRIVE_ACC_DECELERATION_STATE;
+    StateTransMask = DRIVE_STATE;
+    StateKind = ACC_STATE;
   }
 
 public:
-};
-class DriveMoveFwdRightState : public State&lt;DriveMoveFwdRightState&gt;
-{
-private:
-  friend class State&lt;DriveMoveFwdRightState&gt;;
-  DriveMoveFwdRightState(void)
+  void ShowStateName(void)
   {
-    StateName = "MoveFwdRight";
-    StateNum = DRIVE_STATE | DRIVE_MOVEFWD_STATE | DRIVE_MOVEFWD_RIGHT_STATE;
-    StateTransMask = DRIVE_STATE | DRIVE_MOVEFWD_STATE;
+    std::cout &lt;&lt; StateName &lt;&lt; "-";
   }
-
-public:
 };
-class DriveMoveFwdStraightState : public State&lt;DriveMoveFwdStraightState&gt;
+
+class DriveAccKeepState : public State&lt;DriveAccKeepState&gt;
 {
 private:
-  friend class State&lt;DriveMoveFwdStraightState&gt;;
-  DriveMoveFwdStraightState(void)
+  friend class State&lt;DriveAccKeepState&gt;;
+  DriveAccKeepState(void)
   {
-    StateName = "MoveFwdStraight";
-    StateNum = DRIVE_STATE | DRIVE_MOVEFWD_STATE | DRIVE_MOVEFWD_STRAIGHT_STATE;
+    StateName = "Keep";
+    StateNum = DRIVE_STATE | DRIVE_ACC_KEEP_STATE;
     StateTransMask = DRIVE_STATE;
+    StateKind = ACC_STATE;
   }
 
 public:
+  void ShowStateName(void)
+  {
+    std::cout &lt;&lt; StateName &lt;&lt; "-";
+  }
 };
 
-class DriveLaneChangeState : public State&lt;DriveLaneChangeState&gt;
+class DriveAccStopState : public State&lt;DriveAccStopState&gt;
 {
 private:
-  friend class State&lt;DriveLaneChangeState&gt;;
-  DriveLaneChangeState(void)
+  friend class State&lt;DriveAccStopState&gt;;
+  DriveAccStopState(void)
   {
-    StateName = "LaneChange";
-    StateNum = DRIVE_STATE | DRIVE_LANECHANGE_STATE;
+    StateName = "Stop";
+    StateNum = DRIVE_STATE | DRIVE_ACC_STOP_STATE;
     StateTransMask = DRIVE_STATE;
+    StateKind = ACC_STATE;
   }
 
 public:
-};
-
-class DriveLaneChangeLeftState : public State&lt;DriveLaneChangeLeftState&gt;
-{
-private:
-  friend class State&lt;DriveLaneChangeLeftState&gt;;
-  DriveLaneChangeLeftState(void)
+  void ShowStateName(void)
   {
-    StateName = "LaneChangeLeft";
-    StateNum = DRIVE_STATE | DRIVE_LANECHANGE_STATE | DRIVE_LANECHANGE_LEFT_STATE;
-    StateTransMask = DRIVE_STATE | DRIVE_LANECHANGE_STATE;
+    std::cout &lt;&lt; StateName &lt;&lt; "-";
   }
-
-public:
 };
 
-class DriveLaneChangeRightState : public State&lt;DriveLaneChangeRightState&gt;
+class DriveStrLeftState : public State&lt;DriveStrLeftState&gt;
 {
 private:
-  friend class State&lt;DriveLaneChangeRightState&gt;;
-  DriveLaneChangeRightState(void)
+  friend class State&lt;DriveStrLeftState&gt;;
+  DriveStrLeftState(void)
   {
-    StateName = "LaneChangeRight";
-    StateNum = DRIVE_STATE | DRIVE_LANECHANGE_STATE | DRIVE_LANECHANGE_RIGHT_STATE;
-    StateTransMask = DRIVE_STATE | DRIVE_LANECHANGE_STATE;
+    StateName = "Left Turn";
+    StateNum = DRIVE_STATE | DRIVE_STR_LEFT_STATE;
+    StateTransMask = DRIVE_STATE;
+    StateKind = STR_STATE;
   }
 
 public:
 };
-
-class DriveLaneChangeRightAvoidanceState : public State&lt;DriveLaneChangeRightAvoidanceState&gt;
+class DriveStrRightState : public State&lt;DriveStrRightState&gt;
 {
 private:
-  friend class State&lt;DriveLaneChangeRightAvoidanceState&gt;;
-  DriveLaneChangeRightAvoidanceState(void)
+  friend class State&lt;DriveStrRightState&gt;;
+  DriveStrRightState(void)
   {
-    StateName = "LaneChangeRightAvoidanceState";
-    StateNum =
-        DRIVE_STATE | DRIVE_LANECHANGE_STATE | DRIVE_LANECHANGE_RIGHT_STATE | DRIVE_LANECHANGE_RIGHT_AVOIDANCE_STATE;
-    StateTransMask = DRIVE_STATE | DRIVE_LANECHANGE_STATE;
+    StateName = "Right Turn";
+    StateNum = DRIVE_STATE | DRIVE_STR_RIGHT_STATE;
+    StateTransMask = DRIVE_STATE;
+    StateKind = STR_STATE;
   }
 
 public:
 };
-
-class DriveObstacleAvoidanceState : public State&lt;DriveObstacleAvoidanceState&gt;
+class DriveStrStraightState : public State&lt;DriveStrStraightState&gt;
 {
 private:
-  friend class State&lt;DriveObstacleAvoidanceState&gt;;
-  DriveObstacleAvoidanceState(void)
+  friend class State&lt;DriveStrStraightState&gt;;
+  DriveStrStraightState(void)
   {
-    StateName = "ObstacleAvoidance";
-    StateTransMask = 0;
+    StateName = "Straight";
+    StateNum = DRIVE_STATE | DRIVE_STR_STRAIGHT_STATE;
+    StateTransMask = DRIVE_STATE;
+    StateKind = STR_STATE;
   }
 
 public:
 };
 
-class DriveObstacleAvoidanceStaticState : public State&lt;DriveObstacleAvoidanceStaticState&gt;
+class DriveBehaviorLaneChangeLeftState : public State&lt;DriveBehaviorLaneChangeLeftState&gt;
 {
 private:
-  friend class State&lt;DriveObstacleAvoidanceStaticState&gt;;
-  DriveObstacleAvoidanceStaticState(void)
+  friend class State&lt;DriveBehaviorLaneChangeLeftState&gt;;
+  DriveBehaviorLaneChangeLeftState(void)
   {
-    StateName = "ObstacleAvoidanceStatic";
-    StateTransMask = 0;
+    StateName = "LaneChangeLeft";
+    StateNum = DRIVE_STATE | DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE;
+    StateTransMask = DRIVE_STATE;
+    StateKind = BEHAVIOR_STATE;
   }
 
 public:
 };
 
-class DriveObstacleAvoidanceDynamicState : public State&lt;DriveObstacleAvoidanceDynamicState&gt;
+class DriveBehaviorLaneChangeRightState : public State&lt;DriveBehaviorLaneChangeRightState&gt;
 {
 private:
-  friend class State&lt;DriveObstacleAvoidanceDynamicState&gt;;
-  DriveObstacleAvoidanceDynamicState(void)
+  friend class State&lt;DriveBehaviorLaneChangeRightState&gt;;
+  DriveBehaviorLaneChangeRightState(void)
   {
-    StateName = "ObstacleAvoidanceDynamic";
-    StateTransMask = 0;
+    StateName = "LaneChangeRight";
+    StateNum = DRIVE_STATE | DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE;
+    StateTransMask = DRIVE_STATE;
+    StateKind = BEHAVIOR_STATE;
   }
 
 public:
 };
 
-// DriveStopState
-class DriveStopState : public State&lt;DriveStopState&gt;
+class DriveBehaviorObstacleAvoidanceState : public State&lt;DriveBehaviorObstacleAvoidanceState&gt;
 {
 private:
-  friend class State&lt;DriveStopState&gt;;
-  DriveStopState(void)
+  friend class State&lt;DriveBehaviorObstacleAvoidanceState&gt;;
+  DriveBehaviorObstacleAvoidanceState(void)
   {
-    StateName = "DriveStop";
-    StateNum = DRIVE_STATE | DRIVE_STOP_STATE;
+    StateName = "ObstacleAvoidance";
     StateTransMask = DRIVE_STATE;
+    StateKind = BEHAVIOR_STATE;
   }
-
 public:
 };
 
-// DriveStopAvoidanceState
-class DriveStopAvoidanceState : public State&lt;DriveStopAvoidanceState&gt;
+class DriveDetectObstacleState : public State&lt;DriveDetectObstacleState&gt;
 {
 private:
-  friend class State&lt;DriveStopAvoidanceState&gt;;
-  DriveStopAvoidanceState(void)
+  friend class State&lt;DriveDetectObstacleState&gt;;
+  DriveDetectObstacleState(void)
   {
-    StateName = "DriveStopAvoidance";
-    StateNum = DRIVE_STATE | DRIVE_STOP_STATE | DRIVE_STOP_AVOIDANCE_STATE;
+    StateName = "DetectObstacle";
+    StateNum = DRIVE_STATE | DRIVE_DETECT_OBSTACLE_STATE;
     StateTransMask = DRIVE_STATE;
+    StateKind = PERCEPTION_STATE;
   }
 
 public:
 };
 
-// DriveStopStopLineState
-class DriveStopStopLineState : public State&lt;DriveStopStopLineState&gt;
+class DriveDetectStoplineState : public State&lt;DriveDetectStoplineState&gt;
 {
 private:
-  friend class State&lt;DriveStopStopLineState&gt;;
-  DriveStopStopLineState(void)
+  friend class State&lt;DriveDetectStoplineState&gt;;
+  DriveDetectStoplineState(void)
   {
-    StateName = "DriveStopStopLine";
-    StateNum = DRIVE_STATE | DRIVE_STOP_STATE | DRIVE_STOP_STOPLINE_STATE;
+    StateName = "DetectStopline";
+    StateNum = DRIVE_STATE | DRIVE_DETECT_STOPLINE_STATE;
     StateTransMask = DRIVE_STATE;
+    StateKind = PERCEPTION_STATE;
   }
 
 public:
 };
-class DriveStopTrafficLightState : public State&lt;DriveStopTrafficLightState&gt;
+
+class DriveDetectTrafficlightRedState : public State&lt;DriveDetectTrafficlightRedState&gt;
 {
 private:
-  friend class State&lt;DriveStopTrafficLightState&gt;;
-  DriveStopTrafficLightState(void)
+  friend class State&lt;DriveDetectTrafficlightRedState&gt;;
+  DriveDetectTrafficlightRedState(void)
   {
-    StateName = "DriveStopTrafficLight";
-    StateNum = DRIVE_STATE | DRIVE_STOP_STATE | DRIVE_STOP_TRAFFICLIGHT_STATE;
+    StateName = "DetectTrafficLightRed";
+    StateNum = DRIVE_STATE | DRIVE_DETECT_TRAFFICLIGHT_RED_STATE;
     StateTransMask = DRIVE_STATE;
+    StateKind = PERCEPTION_STATE;
   }
 
 public:
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" added_lines="27" deleted_lines="24">
				<diff>@@ -10,30 +10,33 @@ enum StateFlags
   INITIAL_STATE = 1 &lt;&lt; 2,
   INITIAL_LOCATEVEHICLE_STATE = 1 &lt;&lt; 3,
   DRIVE_STATE = 1 &lt;&lt; 4,
-  DRIVE_MOVEFWD_STATE = 1 &lt;&lt; 5,
-  DRIVE_MOVEFWD_LEFT_STATE = 1 &lt;&lt; 6,
-  DRIVE_MOVEFWD_RIGHT_STATE = 1 &lt;&lt; 7,
-  DRIVE_MOVEFWD_STRAIGHT_STATE = 1 &lt;&lt; 8,
-  DRIVE_LANECHANGE_STATE = 1 &lt;&lt; 9,
-  DRIVE_LANECHANGE_LEFT_STATE = 1 &lt;&lt; 10,
-  DRIVE_LANECHANGE_RIGHT_STATE = 1 &lt;&lt; 11,
-  DRIVE_LANECHANGE_RIGHT_AVOIDANCE_STATE = 1 &lt;&lt; 12,
-  DRIVE_OBSTACLE_AVOIDANCE_STATE = 1 &lt;&lt; 13,
-  DRIVE_OBSTACLE_AVOIDANCE_STATIC_STATE = 1 &lt;&lt; 14,
-  DRIVE_OBSTACLE_AVOIDANCE_DYNAMIC_STATE = 1 &lt;&lt; 15,
-  DRIVE_STOP_STATE = 1 &lt;&lt; 16,
-  DRIVE_STOP_AVOIDANCE_STATE = 1 &lt;&lt; 17,
-  DRIVE_STOP_STOPLINE_STATE = 1 &lt;&lt; 18,
-  DRIVE_STOP_TRAFFICLIGHT_STATE = 1 &lt;&lt; 19,
-  MISSION_COMPLETE_STATE = 1 &lt;&lt; 20,
-  EMERGENCY_STATE = 1 &lt;&lt; 21,
-  EMERGENCY_HW_STATE = 1 &lt;&lt; 22,
-  EMERGENCY_HWVEHICLE_STATE = 1 &lt;&lt; 23,
-  EMERGENCY_HWCONTROLLER_STATE = 1 &lt;&lt; 24,
-  EMERGENCY_SW_STATE = 1 &lt;&lt; 25,
-  EMERGENCY_SWAUTOWARE_STATE = 1 &lt;&lt; 26,
-  EMERGENCY_SWCONTROLLER_STATE = 1 &lt;&lt; 27,
-  STATE_END = 1 &lt;&lt; 28,
+  DRIVE_ACC_ACCELERATION_STATE = 1 &lt;&lt; 5,
+  DRIVE_ACC_DECELERATION_STATE = 1 &lt;&lt; 6,
+  DRIVE_ACC_KEEP_STATE = 1 &lt;&lt; 7,
+  DRIVE_ACC_STOP_STATE = 1 &lt;&lt; 8,
+  DRIVE_STR_STRAIGHT_STATE = 1 &lt;&lt; 9,
+  DRIVE_STR_LEFT_STATE = 1 &lt;&lt; 10,
+  DRIVE_STR_RIGHT_STATE = 1 &lt;&lt; 11,
+  DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE = 1 &lt;&lt; 12,
+  DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE = 1 &lt;&lt; 13,
+  DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE = 1 &lt;&lt; 13,
+  DRIVE_DETECT_OBSTACLE_STATE = 1 &lt;&lt; 14,
+  DRIVE_DETECT_STOPLINE_STATE = 1 &lt;&lt; 15,
+  DRIVE_DETECT_TRAFFICLIGHT_RED_STATE = 1 &lt;&lt; 16,
+  MISSION_COMPLETE_STATE = 1 &lt;&lt; 17,
+  EMERGENCY_STATE = 1 &lt;&lt; 18,
+  STATE_END = 1 &lt;&lt; 19,
+};
+
+enum StateKinds
+{
+  MAIN_STATE,
+  ACC_STATE,
+  STR_STATE,
+  BEHAVIOR_STATE,
+  PERCEPTION_STATE,
+  OTHER_STATE,
+  UNKNOWN_STATE,
 };
 
 enum TrafficLightColors
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="62" deleted_lines="64">
				<diff>@@ -12,8 +12,6 @@
 #include &lt;state.hpp&gt;
 #include &lt;state_common.hpp&gt;
 
-using namespace std;
-
 /**
  *
  * @file StateContext.cpp
@@ -33,70 +31,78 @@ namespace state_machine
  */
 void StateContext::showCurrentStateName(void)
 {
-  state_-&gt;ShowStateName();
+  current_state_.MainState-&gt;showStateName();
+#if 0
   if (sub_state)
-    sub_state-&gt;ShowStateName();
+    sub_state-&gt;showStateName();
   if (sub_sub_state)
-    sub_sub_state-&gt;ShowStateName();
+    sub_sub_state-&gt;showStateName();
+#endif
   std::cout &lt;&lt; std::endl;
 }
 
 std::unique_ptr&lt;std::string&gt; StateContext::getCurrentStateName(void)
 {
-  return state_-&gt;GetStateName();
+  return current_state_.MainState-&gt;getStateName();
 }
 
 /**
  * @fn
- * set to current state, substate, subsubstate
+ * set to current state
  * @brief standard out a state name
  * @param (state) Setting class
  * @return void
  */
 bool StateContext::setCurrentState(BaseState *_state)
 {
-  return _state ? this-&gt;setCurrentState(_state, nullptr, nullptr) : false;
-}
-
-bool StateContext::setCurrentState(BaseState *_state, BaseState *_substate)
-{
-  return _state ? this-&gt;setCurrentState(_state, _substate, nullptr) : false;
-}
-
-bool StateContext::setCurrentState(BaseState *_state, BaseState *_substate, BaseState *_subsubstate)
-{
-  BaseState *prevState = state_;
+  BaseState *prevState = current_state_.MainState;
 
-  if (!state_)
+  if (!prevState)
   {
-    state_ = _state;
-
+    current_state_.MainState = _state;
     std::cout &lt;&lt; "Successed to set state \""
               &lt;&lt; "NULL"
-              &lt;&lt; "\" to \"" &lt;&lt; *_state-&gt;GetStateName().get() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;GetStateTransMask() &lt;&lt; "/"
+              &lt;&lt; "\" to \"" &lt;&lt; *_state-&gt;getStateName().get() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/"
               &lt;&lt; "NULL"
-              &lt;&lt; "-" &lt;&lt; _state-&gt;GetStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
+              &lt;&lt; "-" &lt;&lt; _state-&gt;getStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
   }
   else
   {
-    if (_state &amp;&amp; (_state-&gt;GetStateTransMask() &amp; state_-&gt;GetStateNum()))
+    if (_state &amp;&amp; (enableForceSetState || (_state-&gt;getStateTransMask() &amp; prevState-&gt;getStateNum())))
     {
-      if (!(state_ == _state))
-      {
-        state_ = _state;
-        sub_state = _substate;
-        sub_sub_state = _subsubstate;
-
-        std::cout &lt;&lt; "Successed to set state \"" &lt;&lt; *prevState-&gt;GetStateName().get() &lt;&lt; "\" to \""
-                  &lt;&lt; *_state-&gt;GetStateName().get() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;GetStateTransMask() &lt;&lt; "/"
-                  &lt;&lt; prevState-&gt;GetStateNum() &lt;&lt; "-" &lt;&lt; _state-&gt;GetStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
+	switch(_state-&gt;getStateKind()){
+		case MAIN_STATE:
+			current_state_.MainState = _state;
+			current_state_.AccState = nullptr;
+			current_state_.StrState = nullptr;
+			current_state_.BehaviorState = nullptr;
+			current_state_.PerceptionState = nullptr;
+			current_state_.OtherState = nullptr;
+			break;
+		case ACC_STATE:
+			current_state_.AccState = _state;
+			break;
+		case STR_STATE:
+			current_state_.StrState = _state;
+			break;
+		case BEHAVIOR_STATE:
+			current_state_.BehaviorState = _state;
+			break;
+		case PERCEPTION_STATE:
+			current_state_.PerceptionState = _state;
+			break;
+		case OTHER_STATE:
+			current_state_.OtherState = _state;
+			break;
+	}
+        std::cout &lt;&lt; "Successed to set state \"" &lt;&lt; *prevState-&gt;getStateName().get() &lt;&lt; "\" to \""
+                  &lt;&lt; *_state-&gt;getStateName().get() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/"
+                  &lt;&lt; prevState-&gt;getStateNum() &lt;&lt; "-" &lt;&lt; _state-&gt;getStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
       }
-    }
-    else
-    {
-      std::cerr &lt;&lt; "Failed to set state \"" &lt;&lt; *state_-&gt;GetStateName().get() &lt;&lt; "\" to \""
-                &lt;&lt; *_state-&gt;GetStateName().get() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;GetStateTransMask() &lt;&lt; "/"
-                &lt;&lt; state_-&gt;GetStateNum() &lt;&lt; "-" &lt;&lt; _state-&gt;GetStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
+    else{
+      std::cerr &lt;&lt; "Failed to set state \"" &lt;&lt; *current_state_.MainState-&gt;getStateName().get() &lt;&lt; "\" to \""
+                &lt;&lt; *_state-&gt;getStateName().get() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/"
+                &lt;&lt; current_state_.MainState-&gt;getStateNum() &lt;&lt; "-" &lt;&lt; _state-&gt;getStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
       prevState = nullptr;
       return false;
     }
@@ -104,39 +110,31 @@ bool StateContext::setCurrentState(BaseState *_state, BaseState *_substate, Base
   return true;
 }
 
-BaseState *StateContext::getCurrentState(void)
+
+bool StateContext::setEnableForceSetState(bool force_flag)
+{
+	enableForceSetState = force_flag;
+	return true;
+}
+
+BaseState *StateContext::getCurrentMainState(void)
 {
-  return state_;
+  return current_state_.MainState;
 }
 
 BaseState *StateContext::getStateObject(unsigned long long _state_num)
 {
   return StateStores[_state_num];
 }
+
 bool StateContext::isState(unsigned long long _state_num)
 {
-  return state_-&gt;GetStateNum() == _state_num;
+  return current_state_.MainState?current_state_.MainState-&gt;getStateNum() == _state_num:false;
 }
 
 bool StateContext::inState(unsigned long long _state_num)
 {
-  return state_-&gt;GetStateNum() &amp; _state_num;
-}
-
-void StateContext::handleTrafficLight(uint32_t _light_color)
-{
-  switch (_light_color)
-  {
-    case RED:
-    case YELLOW:
-      setCurrentState(StateStores[DRIVE_STOP_TRAFFICLIGHT_STATE]);
-      break;
-    case GREEN:
-      break;
-
-    default:
-      break;
-  }
+  return current_state_.MainState?current_state_.MainState-&gt;getStateNum() &amp; _state_num:false;
 }
 
 #define ANGLE_STRAIGHT 50.0
@@ -151,7 +149,7 @@ bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
     // first-waypoint
     // and end-waypoint in intersection area.
     int temp = (int)std::floor(_angle + 360.0) % 360;
-
+#if 0
     if (std::abs(temp) &lt;= ANGLE_STRAIGHT)
       return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_STRAIGHT_STATE]);
     else if (temp &lt;= ANGLE_RIGHT)
@@ -160,6 +158,7 @@ bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
       return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_LEFT_STATE]);
     else
       return false;
+#endif
   }
   else
   {
@@ -170,7 +169,7 @@ bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
 bool StateContext::handleTwistCmd(bool _hasTwistCmd)
 {
   if (_hasTwistCmd)
-    return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_STATE]);
+    return this-&gt;setCurrentState(StateStores[DRIVE_STATE]);
   else
     return false;
 }
@@ -223,7 +222,7 @@ bool StateContext::handleCurrentPose(double _x, double _y, double _z, double _ro
   }
 }
 
-void StateContext::StateDecider(void)
+void StateContext::stateDecider(void)
 {
   while (thread_loop)
   {
@@ -244,10 +243,9 @@ void StateContext::StateDecider(void)
 
 void StateContext::InitContext(void)
 {
-  thr_state_dec = new std::thread(&amp;StateContext::StateDecider, this);
+  thr_state_dec = new std::thread(&amp;StateContext::stateDecider, this);
   thr_state_dec-&gt;detach();
   this-&gt;setCurrentState(StateStores[START_STATE]);
-
   return;
 }
 bool StateContext::TFInitialized(void)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="85b8c32902acb9d4f93cd1d7eb82bd30238376d3" author="Yusuke FUJII">
		<msg>Move the decision part of the state machine library to decision_Maker node. This is WIP.</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" added_lines="1" deleted_lines="3">
				<diff>@@ -5,9 +5,7 @@
 #include &lt;memory&gt;
 #include &lt;vector&gt;
 
-#include "state_flags.hpp"
-
-using namespace std;
+#include &lt;state_flags.hpp&gt;
 
 namespace state_machine
 {
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" added_lines="17" deleted_lines="3">
				<diff>@@ -24,11 +24,15 @@ private:
 			BaseState *PerceptionState;
 			BaseState *OtherState;
 	} current_state_;
+	
+  std::vector&lt;BaseState **&gt; HolderList;
+
 
   std::unordered_map&lt;uint64_t, BaseState *&gt; StateStores;
   
   bool enableForceSetState;
-  unsigned long long ChangeStateFlags;
+  //unsigned long long ChangeStateFlags;
+  std::queue&lt;unsigned long long&gt; ChangeStateFlags;
   std::atomic&lt;bool&gt; thread_loop;
 
   std::thread *thr_state_dec;
@@ -61,15 +65,25 @@ public:
     StateStores[DRIVE_DETECT_TRAFFICLIGHT_RED_STATE] = DriveDetectTrafficlightRedState::getInstance();
     StateStores[MISSION_COMPLETE_STATE] = MissionCompleteState::getInstance();
     StateStores[EMERGENCY_STATE] = EmergencyState::getInstance();
+
+    HolderList.push_back(&amp;current_state_.MainState); 
+    HolderList.push_back(&amp;current_state_.AccState); 
+    HolderList.push_back(&amp;current_state_.StrState); 
+    HolderList.push_back(&amp;current_state_.BehaviorState); 
+    HolderList.push_back(&amp;current_state_.PerceptionState); 
+ e   HolderList.push_back(&amp;current_state_.OtherState); 
     
+    for(auto &amp;&amp;p : HolderList){
+      *p = nullptr;
+    }
+#if 0
     current_state_.MainState = nullptr;
     current_state_.AccState = nullptr;
     current_state_.StrState = nullptr;
     current_state_.BehaviorState = nullptr;
     current_state_.PerceptionState = nullptr;
     current_state_.OtherState = nullptr;
-
-    ChangeStateFlags = 0;
+#endif
     thread_loop = true;
 
     this-&gt;InitContext();
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" added_lines="4" deleted_lines="4">
				<diff>@@ -41,10 +41,10 @@ enum StateKinds
 
 enum TrafficLightColors
 {
-  RED,
-  YELLOW,
-  GREEN,
-  COLOR_ERROR
+  E_RED,
+  E_YELLOW,
+  E_GREEN,
+  E_COLOR_ERROR
 };
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="14" deleted_lines="56">
				<diff>@@ -31,7 +31,12 @@ namespace state_machine
  */
 void StateContext::showCurrentStateName(void)
 {
-  current_state_.MainState-&gt;showStateName();
+  for(auto &amp;&amp;p : HolderList){
+    if(*p){
+	(*p)-&gt;showStateName();
+    }
+  }
+
 #if 0
   if (sub_state)
     sub_state-&gt;showStateName();
@@ -110,7 +115,10 @@ bool StateContext::setCurrentState(BaseState *_state)
   return true;
 }
 
-
+bool StateContext::setCurrentState(StateFlags flag)
+{
+   this-&gt;setCurrentState(StateStores[flag]);
+}
 bool StateContext::setEnableForceSetState(bool force_flag)
 {
 	enableForceSetState = force_flag;
@@ -174,65 +182,15 @@ bool StateContext::handleTwistCmd(bool _hasTwistCmd)
     return false;
 }
 
-bool StateContext::handlePointsRaw(bool _hasLidarData)
-{
-  return _hasLidarData ? this-&gt;setCurrentState(StateStores[INITIAL_LOCATEVEHICLE_STATE]) : false;
-}
-
-#define CONV_NUM 10
-#define CONVERGENCE_THRESHOLD 0.01
-
-bool StateContext::handleCurrentPose(double _x, double _y, double _z, double _roll, double _pitch, double _yaw)
-{
-  static int _init_count = 0;
-  static euclidean_space::point *a = new euclidean_space::point();
-  static euclidean_space::point *b = new euclidean_space::point();
-
-  static double distances[CONV_NUM] = { 0.0 };
-  double avg_distances = 0.0;
-
-  for (int i = 1; i &lt; CONV_NUM; i++)
-  {
-    distances[i] = distances[i - 1];
-    avg_distances += distances[i];
-  }
-
-  a-&gt;x = b-&gt;x;
-  a-&gt;y = b-&gt;y;
-  a-&gt;z = b-&gt;z;
-
-  b-&gt;x = _x;
-  b-&gt;y = _y;
-  b-&gt;z = _z;
-
-  distances[0] = euclidean_space::EuclideanSpace::find_distance(a, b);
-
-  if (++_init_count &lt;= CONV_NUM)
-  {
-    return false;
-  }
-  else
-  {
-    avg_distances = (avg_distances + distances[0]) / CONV_NUM;
-
-    if (avg_distances &lt;= CONVERGENCE_THRESHOLD)
-      return this-&gt;setCurrentState(StateStores[DRIVE_STATE]);
-    else
-      return false;
-  }
-}
 
 void StateContext::stateDecider(void)
 {
+// not running
   while (thread_loop)
   {
-    if (ChangeStateFlags)
-      for (unsigned long long l = 1; l &lt; STATE_END; l = l * 2)
-      {
-        if (ChangeStateFlags &amp; l &amp;&amp; StateStores[l])
-        {
-          setCurrentState(StateStores[l]);
-          ChangeStateFlags -= l;
+    if (!ChangeStateFlags.empty())
+	  setCurrentState(StateStores[ChangeStateFlags.front()]);
+          ChangeStateFlags.pop();
         }
       }
     std::this_thread::sleep_for(std::chrono::microseconds(1000));
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="66" deleted_lines="5">
				<diff>@@ -12,16 +12,75 @@
 #include &lt;state.hpp&gt;
 #include &lt;state_context.hpp&gt;
 #include &lt;decision_maker_node.hpp&gt;
+#include &lt;euclidean_space.hpp&gt;
 
 namespace decision_maker
 {
 #define VEL_AVERAGE_COUNT 10
+#define CONV_NUM 10
+#define CONVERGENCE_THRESHOLD 0.01
 
+bool DecisionMakerNode::isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch, double _yaw)
+{
+  static int _init_count = 0;
+  static euclidean_space::point *a = new euclidean_space::point();
+  static euclidean_space::point *b = new euclidean_space::point();
+
+  static double distances[CONV_NUM] = { 0.0 };
+  double avg_distances = 0.0;
+
+  for (int i = 1; i &lt; CONV_NUM; i++)
+  {
+    distances[i] = distances[i - 1];
+    avg_distances += distances[i];
+  }
+
+  a-&gt;x = b-&gt;x;
+  a-&gt;y = b-&gt;y;
+  a-&gt;z = b-&gt;z;
+
+  b-&gt;x = _x;
+  b-&gt;y = _y;
+  b-&gt;z = _z;
+
+  distances[0] = euclidean_space::EuclideanSpace::find_distance(a, b);
+
+  if (++_init_count &lt;= CONV_NUM)
+  {
+    return false;
+  }else
+  {
+    avg_distances = (avg_distances + distances[0]) / CONV_NUM;
+    if (avg_distances &lt;= CONVERGENCE_THRESHOLD){
+      return this-&gt;setCurrentState(StateStores[state_machine::DRIVE_STATE]);
+    }else
+    {
+      return false;
+    }
+  }
+}
+
+void StateContext::stateDecider(void)
+{
+// not running
+  while (thread_loop)
+  {
+    if (!ChangeStateFlags.empty())
+	  setCurrentState(StateStores[ChangeStateFlags.front()]);
+          ChangeStateFlags.pop();
+        }
+      }
+    std::this_thread::sleep_for(std::chrono::microseconds(1000));
+  }
+  std::cerr &lt;&lt; "StateDecider thread will be closed" &lt;&lt; std::endl;
+  return;
+    
+
+}
 void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
 {
   geometry_msgs::PoseStamped _pose = current_pose_ = msg;
   bool initLocalizationFlag = ctx-&gt;isState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
-
   if (initLocalizationFlag &amp;&amp;
       ctx-&gt;handleCurrentPose(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
                              _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
@@ -34,16 +93,18 @@ void DecisionMakerNode::callbackFromLightColor(const autoware_msgs::traffic_ligh
 {
   ROS_INFO("Light color callback");
   CurrentTrafficlight = msg.traffic_light;
+  if(CurrentTrafficLight == state_machine::E_RED ||
+	CurrentTrafficLight == state_machine::E_YELLOW ){
+	ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
+  }
   //ctx-&gt;handleTrafficLight(CurrentTrafficlight);
 }
 
 //
 void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
 {
-  if (ctx-&gt;handlePointsRaw(true))
-  {
-    Subs["points_raw"].shutdown();
-  }
+  if(ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATE_VEHICLE_STATE]);
+  Subs["points_raw"].shutdown();
 }
 
 void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="8b07ef3bfc99fe6cd1100623be82710b2e1b42c4" author="Yusuke FUJII">
		<msg>Fix a build error for libstate</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" added_lines="3" deleted_lines="1">
				<diff>@@ -3,6 +3,7 @@
 
 #include &lt;atomic&gt;
 #include &lt;iostream&gt;
+#include &lt;queue&gt;
 #include &lt;thread&gt;
 #include &lt;unordered_map&gt;
 #include &lt;utility&gt;
@@ -71,7 +72,7 @@ public:
     HolderList.push_back(&amp;current_state_.StrState); 
     HolderList.push_back(&amp;current_state_.BehaviorState); 
     HolderList.push_back(&amp;current_state_.PerceptionState); 
- e   HolderList.push_back(&amp;current_state_.OtherState); 
+    HolderList.push_back(&amp;current_state_.OtherState); 
     
     for(auto &amp;&amp;p : HolderList){
       *p = nullptr;
@@ -98,6 +99,7 @@ public:
 
   void stateDecider(void);
 
+  bool setCurrentState(StateFlags flag);
   bool setCurrentState(BaseState *state);
   bool setCurrentState(BaseState *state, BaseState *substate);
   bool setCurrentState(BaseState *state, BaseState *substate, BaseState *subsubstate);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="5" deleted_lines="6">
				<diff>@@ -188,12 +188,11 @@ void StateContext::stateDecider(void)
 // not running
   while (thread_loop)
   {
-    if (!ChangeStateFlags.empty())
-	  setCurrentState(StateStores[ChangeStateFlags.front()]);
-          ChangeStateFlags.pop();
-        }
-      }
-    std::this_thread::sleep_for(std::chrono::microseconds(1000));
+	  if (!ChangeStateFlags.empty()){
+		  this-&gt;setCurrentState(StateStores[ChangeStateFlags.front()]);
+		  ChangeStateFlags.pop();
+	  }
+	  std::this_thread::sleep_for(std::chrono::microseconds(1000));
   }
   std::cerr &lt;&lt; "StateDecider thread will be closed" &lt;&lt; std::endl;
   return;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="dcdd4e66d42fb83d3a5f59f29e17412dbfede389" author="Yusuke FUJII">
		<msg>Fix a build error for decision maker node</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="9" deleted_lines="6">
				<diff>@@ -68,19 +68,20 @@ private:
   geometry_msgs::PoseStamped current_pose_;
 
   jsk_rviz_plugins::OverlayText state_text_msg;
-  autoware_msgs::lane current_finalwaypoints_;
-
-  std::vector&lt;geometry_msgs::Point&gt; inside_points_;
 
+  // ROS Messages(Autoware)
+  autoware_msgs::lane current_finalwaypoints_;
   vector_map_msgs::AreaArray vMap_Areas;
   vector_map_msgs::PointArray vMap_Points;
   vector_map_msgs::LineArray vMap_Lines;
   vector_map_msgs::CrossRoadArray vMap_CrossRoads;
+  
+  std::vector&lt;geometry_msgs::Point&gt; inside_points_;
 
   // Current way/behavior status
   double current_velocity_;
   double average_velocity_;
-  int CurrentTrafficlight;
+  int current_traffic_light;
   CrossRoadArea *ClosestArea_;
   std::string CurrentStateName;
   std::string TextOffset;
@@ -113,9 +114,11 @@ private:
 
   void publishToVelocityArray();
 
-  //
+  // judge method
+  // in near future, these methods will be deprecate to decision_maker library 
   bool isInsideArea(geometry_msgs::Point pt);
   bool isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
+  bool isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch, double _yaw);
 
   double calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
 
@@ -138,7 +141,7 @@ private:
   // Currently. this feature is not working.
   // static void callbackFromDynamicReconfigure(decision_maker::decision_makerConfig &amp;config, uint32_t level);
 
-  // in near future, these function will be deprecate
+  // in near future, these methods will be deprecate to ADAS library 
   CrossRoadArea *findClosestCrossRoad(void);
 
 public:
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="7" deleted_lines="24">
				<diff>@@ -52,37 +52,20 @@ bool DecisionMakerNode::isLocalizationConvergence(double _x, double _y, double _
   {
     avg_distances = (avg_distances + distances[0]) / CONV_NUM;
     if (avg_distances &lt;= CONVERGENCE_THRESHOLD){
-      return this-&gt;setCurrentState(StateStores[state_machine::DRIVE_STATE]);
+      return ctx-&gt;setCurrentState(state_machine::DRIVE_STATE);
     }else
     {
       return false;
     }
   }
 }
-
-void StateContext::stateDecider(void)
-{
-// not running
-  while (thread_loop)
-  {
-    if (!ChangeStateFlags.empty())
-	  setCurrentState(StateStores[ChangeStateFlags.front()]);
-          ChangeStateFlags.pop();
-        }
-      }
-    std::this_thread::sleep_for(std::chrono::microseconds(1000));
-  }
-  std::cerr &lt;&lt; "StateDecider thread will be closed" &lt;&lt; std::endl;
-  return;
     
-
-}
 void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
 {
   geometry_msgs::PoseStamped _pose = current_pose_ = msg;
   bool initLocalizationFlag = ctx-&gt;isState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
   if (initLocalizationFlag &amp;&amp;
-      ctx-&gt;handleCurrentPose(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
+      isLocalizationConvergence(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
                              _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
   {
     ROS_INFO("Localization was convergence");
@@ -92,9 +75,9 @@ void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped
 void DecisionMakerNode::callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg)
 {
   ROS_INFO("Light color callback");
-  CurrentTrafficlight = msg.traffic_light;
-  if(CurrentTrafficLight == state_machine::E_RED ||
-	CurrentTrafficLight == state_machine::E_YELLOW ){
+  current_traffic_light = msg.traffic_light;
+  if(current_traffic_light == state_machine::E_RED ||
+	current_traffic_light == state_machine::E_YELLOW ){
 	ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
   }
   //ctx-&gt;handleTrafficLight(CurrentTrafficlight);
@@ -103,8 +86,8 @@ void DecisionMakerNode::callbackFromLightColor(const autoware_msgs::traffic_ligh
 //
 void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
 {
-  if(ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATE_VEHICLE_STATE]);
-  Subs["points_raw"].shutdown();
+	if(ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
+		Subs["points_raw"].shutdown();
 }
 
 void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="f1f94a9dc9c24f0bd907fffb11c225957c048dbc" author="yukikitsukawa">
		<msg>add map_extender</msg>
		<modified_files>
			<file old_path="ros\src\computing\perception\localization\packages\ndt_localizer\nodes\local2global\local2global.cpp" new_path="" added_lines="0" deleted_lines="476">
				<diff>@@ -1,476 +0,0 @@
-/*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*
- Localization program using Normal Distributions Transform
-
- Yuki KITSUKAWA
- */
-
-// #define VIEW_TIME
-
-// If you want to output "position_log.txt", "#define OUTPUT".
-//#define OUTPUT 
-
-#include &lt;iostream&gt;
-#include &lt;sstream&gt;
-#include &lt;fstream&gt;
-#include &lt;string&gt;
-
-#include &lt;ros/ros.h&gt;
-#include &lt;std_msgs/String.h&gt;
-#include &lt;std_msgs/Bool.h&gt;
-#include &lt;sensor_msgs/PointCloud2.h&gt;
-#include &lt;velodyne_pointcloud/point_types.h&gt;
-#include &lt;velodyne_pointcloud/rawdata.h&gt;
-
-#include &lt;tf/transform_broadcaster.h&gt;
-#include &lt;tf/transform_datatypes.h&gt;
-
-#include &lt;pcl/io/io.h&gt;
-#include &lt;pcl/io/pcd_io.h&gt;
-#include &lt;pcl/point_types.h&gt;
-#include &lt;pcl_conversions/pcl_conversions.h&gt;
-#include &lt;pcl/registration/ndt.h&gt;
-#include &lt;pcl/filters/approximate_voxel_grid.h&gt;
-#include &lt;pcl/filters/voxel_grid.h&gt;
-
-struct Position {
-    double x;
-    double y;
-    double z;
-    double roll;
-    double pitch;
-    double yaw;
-};
-
-// global variables
-static Position previous_pos, guess_pos, current_pos;
-
-static double offset_x = 0.0;
-static double offset_y = 0.0;
-static double offset_z = 0.0;
-static double offset_yaw = 0.0; // current_pos - previous_pos
-
-// Initial position (updated in param_callback)
-static double initial_x = 0.0;
-static double initial_y = 0.0;
-static double initial_z = 0.0;
-static double initial_roll = 0.0;
-static double initial_pitch = 0.0;
-static double initial_yaw = 0.0;
-
-//Can't load if typed "pcl::PointCloud&lt;pcl::PointXYZRGB&gt; map, add;"
-static pcl::PointCloud&lt;pcl::PointXYZI&gt; map, add;
-static pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr;
-
-static pcl::PointCloud&lt;pcl::PointXYZI&gt; additional_map;
-pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr additional_map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
-
-// If the map is loaded, map_loaded will be 1.
-static int map_loaded = 0;
-static int use_gnss = 1;
-static int init_pos_set = 1;
-
-static pcl::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt; ndt;
-// Default values
-static int iter = 100; // Maximum iterations
-static float ndt_res = 1.0; // Resolution
-static double step_size = 0.1; // Step size
-static double trans_eps = 0.01; // Transformation epsilon
-
-// Leaf size of VoxelGrid filter.
-static double voxel_leaf_size = 2.0;
-
-static ros::Time callback_start, callback_end, t1_start, t1_end, t2_start, t2_end, t3_start, t3_end, t4_start, t4_end, t5_start, t5_end;
-static ros::Duration d_callback, d1, d2, d3, d4, d5;
-
-static ros::Publisher ndt_pose_pub;
-static geometry_msgs::PoseStamped ndt_pose_msg;
-
-static ros::Publisher ndt_map_pub;
-
-static void gnss_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
-{
-    if (use_gnss == 1 &amp;&amp; init_pos_set == 0) {
-        tf::Quaternion q(input-&gt;pose.orientation.x, input-&gt;pose.orientation.y, input-&gt;pose.orientation.z, input-&gt;pose.orientation.w);
-        tf::Matrix3x3 m(q);
-        initial_x = input-&gt;pose.position.x;
-        initial_y = input-&gt;pose.position.y;
-        initial_z = input-&gt;pose.position.z;
-        m.getRPY(initial_roll, initial_pitch, initial_yaw);
-
-        // Setting position and posture for the fist time.
-        previous_pos.x = initial_x;
-        previous_pos.y = initial_y;
-        previous_pos.z = initial_z;
-        previous_pos.roll = initial_roll;
-        previous_pos.pitch = initial_pitch;
-        previous_pos.yaw = initial_yaw;
-
-        current_pos.x = initial_x;
-        current_pos.y = initial_y;
-        current_pos.z = initial_z;
-        current_pos.roll = initial_roll;
-        current_pos.pitch = initial_pitch;
-        current_pos.yaw = initial_yaw;
-
-        init_pos_set = 1;
-        std::cout &lt;&lt; "--- Initial Position (gnss) ---" &lt;&lt; std::endl;
-        std::cout &lt;&lt; "initial_x: " &lt;&lt; initial_x &lt;&lt; std::endl;
-        std::cout &lt;&lt; "initial_y: " &lt;&lt; initial_y &lt;&lt; std::endl;
-        std::cout &lt;&lt; "initial_z: " &lt;&lt; initial_z &lt;&lt; std::endl;
-        std::cout &lt;&lt; "initial_roll: " &lt;&lt; initial_roll &lt;&lt; std::endl;
-        std::cout &lt;&lt; "initial_pitch: " &lt;&lt; initial_pitch &lt;&lt; std::endl;
-        std::cout &lt;&lt; "initial_yaw: " &lt;&lt; initial_yaw &lt;&lt; std::endl;
-        std::cout &lt;&lt; "NDT ready..." &lt;&lt; std::endl;
-    }
-}
-
-//static void velodyne_callback(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr&amp; input)
-static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
-{
-
-  if (map_loaded == 0) {
-    std::cout &lt;&lt; "Loading map data... ";
-    map.header.frame_id = "/pointcloud_map_frame";
-    
-    // Convert the data type(from sensor_msgs to pcl).
-    pcl::fromROSMsg(*input, map);
-    
-    pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(map));
-    // Setting point cloud to be aligned to.
-    ndt.setInputTarget(map_ptr);
-	
-    // Setting NDT parameters to default values
-    ndt.setMaximumIterations(iter);
-    ndt.setResolution(ndt_res);
-    ndt.setStepSize(step_size);
-    ndt.setTransformationEpsilon(trans_eps);
-    
-    map_loaded = 1;
-    std::cout &lt;&lt; "Map Loaded." &lt;&lt; std::endl;
-  }
-
-
-
-    if (map_loaded == 1 &amp;&amp; init_pos_set == 1) {
-        callback_start = ros::Time::now();
-
-        static tf::TransformBroadcaster br;
-        tf::Transform transform;
-        tf::Quaternion q;
-
-        // 1 scan
-	/*
-        pcl::PointCloud&lt;pcl::PointXYZI&gt; scan;
-        pcl::PointXYZI p;
-        scan.header = input-&gt;header;
-        scan.header.frame_id = "velodyne_scan_frame";
-	*/
-
-        ros::Time scan_time;
-        scan_time.sec = additional_map.header.stamp / 1000000.0;
-        scan_time.nsec = (additional_map.header.stamp - scan_time.sec * 1000000.0) * 1000.0;
-
-        /*
-         std::cout &lt;&lt; "scan.header.stamp: " &lt;&lt; scan.header.stamp &lt;&lt; std::endl;
-         std::cout &lt;&lt; "scan_time: " &lt;&lt; scan_time &lt;&lt; std::endl;
-         std::cout &lt;&lt; "scan_time.sec: " &lt;&lt; scan_time.sec &lt;&lt; std::endl;
-         std::cout &lt;&lt; "scan_time.nsec: " &lt;&lt; scan_time.nsec &lt;&lt; std::endl;
-         */
-
-        t1_start = ros::Time::now();
-	/*
-        for (pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::const_iterator item = input-&gt;begin(); item != input-&gt;end(); item++) {
-            p.x = (double) item-&gt;x;
-            p.y = (double) item-&gt;y;
-            p.z = (double) item-&gt;z;
-
-            scan.points.push_back(p);
-        }
-	*/
-	//	pcl::fromROSMsg(*input, scan);
-        t1_end = ros::Time::now();
-        d1 = t1_end - t1_start;
-
-        Eigen::Matrix4f t(Eigen::Matrix4f::Identity());
-
-	//        pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(scan));
-        pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_additional_map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
-
-        // Downsampling the velodyne scan using VoxelGrid filter
-        t2_start = ros::Time::now();
-        pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter;
-        voxel_grid_filter.setLeafSize(voxel_leaf_size, voxel_leaf_size, voxel_leaf_size);
-        voxel_grid_filter.setInputCloud(additional_map_ptr);
-        voxel_grid_filter.filter(*filtered_additional_map_ptr);
-        t2_end = ros::Time::now();
-        d2 = t2_end - t2_start;
-
-        // Setting point cloud to be aligned.
-        ndt.setInputSource(filtered_additional_map_ptr);
-
-        // Guess the initial gross estimation of the transformation
-        t3_start = ros::Time::now();
-        tf::Matrix3x3 init_rotation;
-
-        guess_pos.x = previous_pos.x + offset_x;
-        guess_pos.y = previous_pos.y + offset_y;
-        guess_pos.z = previous_pos.z + offset_z;
-        guess_pos.roll = previous_pos.roll;
-        guess_pos.pitch = previous_pos.pitch;
-        guess_pos.yaw = previous_pos.yaw + offset_yaw;
-
-        Eigen::AngleAxisf init_rotation_x(guess_pos.roll, Eigen::Vector3f::UnitX());
-        Eigen::AngleAxisf init_rotation_y(guess_pos.pitch, Eigen::Vector3f::UnitY());
-        Eigen::AngleAxisf init_rotation_z(guess_pos.yaw, Eigen::Vector3f::UnitZ());
-
-        Eigen::Translation3f init_translation(guess_pos.x, guess_pos.y, guess_pos.z);
-
-        Eigen::Matrix4f init_guess = (init_translation * init_rotation_z * init_rotation_y * init_rotation_x).matrix();
-
-        t3_end = ros::Time::now();
-        d3 = t3_end - t3_start;
-
-        t4_start = ros::Time::now();
-        pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
-        ndt.align(*output_cloud, init_guess);
-
-        t = ndt.getFinalTransformation();
-	pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr transformed_additional_map_ptr (new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
-	transformed_additional_map_ptr-&gt;header.frame_id = "/map";
-	pcl::transformPointCloud(*additional_map_ptr, *transformed_additional_map_ptr, t);
-	sensor_msgs::PointCloud2::Ptr msg_ptr(new sensor_msgs::PointCloud2);
-
-	pcl::toROSMsg(*transformed_additional_map_ptr, *msg_ptr);
-	msg_ptr-&gt;header.frame_id = "/map";
-	ndt_map_pub.publish(*msg_ptr);
-
-	// Writing Point Cloud data to PCD file
-	pcl::io::savePCDFileASCII("global_map.pcd", *transformed_additional_map_ptr);
-	std::cout &lt;&lt; "Saved " &lt;&lt; transformed_additional_map_ptr-&gt;points.size() &lt;&lt; " data points to global_map.pcd." &lt;&lt; std::endl;
-
-	pcl::PointCloud&lt;pcl::PointXYZRGB&gt; output;
-	output.width = transformed_additional_map_ptr-&gt;width;
-	output.height = transformed_additional_map_ptr-&gt;height;
-	output.points.resize(output.width * output.height);
-
-	for(size_t i = 0; i &lt; output.points.size(); i++){
-	  output.points[i].x = transformed_additional_map_ptr-&gt;points[i].x;
-	  output.points[i].y = transformed_additional_map_ptr-&gt;points[i].y;
-	  output.points[i].z = transformed_additional_map_ptr-&gt;points[i].z;
-	  output.points[i].rgb = 255 &lt;&lt; 8;
-	}
-
-	pcl::io::savePCDFileASCII("global_map_rgb.pcd", output);
-	std::cout &lt;&lt; "Saved " &lt;&lt; output.points.size() &lt;&lt; " data points to global_map_rgb.pcd." &lt;&lt; std::endl;
-
-        t4_end = ros::Time::now();
-        d4 = t4_end - t4_start;
-
-        t5_start = ros::Time::now();
-        /*
-         tf::Vector3 origin;
-         origin.setValue(static_cast&lt;double&gt;(t(0,3)), static_cast&lt;double&gt;(t(1,3)), static_cast&lt;double&gt;(t(2,3)));
-         */
-
-        tf::Matrix3x3 tf3d;
-
-        tf3d.setValue(static_cast&lt;double&gt;(t(0, 0)), static_cast&lt;double&gt;(t(0, 1)), static_cast&lt;double&gt;(t(0, 2)), static_cast&lt;double&gt;(t(1, 0)), static_cast&lt;double&gt;(t(1, 1)), static_cast&lt;double&gt;(t(1, 2)), static_cast&lt;double&gt;(t(2, 0)), static_cast&lt;double&gt;(t(2, 1)), static_cast&lt;double&gt;(t(2, 2)));
-
-        // Update current_pos.
-        current_pos.x = t(0, 3);
-        current_pos.y = t(1, 3);
-        current_pos.z = t(2, 3);
-        tf3d.getRPY(current_pos.roll, current_pos.pitch, current_pos.yaw, 1);
-
-        // transform "/velodyne" to "/map"
-        transform.setOrigin(tf::Vector3(current_pos.x, current_pos.y, current_pos.z));
-        q.setRPY(current_pos.roll, current_pos.pitch, current_pos.yaw);
-        transform.setRotation(q);
-
-        /*
-         std::cout &lt;&lt; "ros::Time::now(): " &lt;&lt; ros::Time::now() &lt;&lt; std::endl;
-         std::cout &lt;&lt; "ros::Time::now().sec: " &lt;&lt; ros::Time::now().sec &lt;&lt; std::endl;
-         std::cout &lt;&lt; "ros::Time::now().nsec: " &lt;&lt; ros::Time::now().nsec &lt;&lt; std::endl;
-         */
-
-	//        br.sendTransform(tf::StampedTransform(transform, scan_time, "map", "velodyne"));
-
-        static tf::TransformBroadcaster pose_broadcaster;
-        tf::Transform pose_transform;
-        tf::Quaternion pose_q;
-
-/*        pose_transform.setOrigin(tf::Vector3(0, 0, 0));
-        pose_q.setRPY(0, 0, 0);
-        pose_transform.setRotation(pose_q);
-        pose_broadcaster.sendTransform(tf::StampedTransform(pose_transform, scan_time, "map", "ndt_frame"));
-*/
-        // publish the position
-       // ndt_pose_msg.header.frame_id = "/ndt_frame";
-        ndt_pose_msg.header.frame_id = "/map";
-        ndt_pose_msg.header.stamp = scan_time;
-        ndt_pose_msg.pose.position.x = current_pos.x;
-        ndt_pose_msg.pose.position.y = current_pos.y;
-        ndt_pose_msg.pose.position.z = current_pos.z;
-        ndt_pose_msg.pose.orientation.x = q.x();
-        ndt_pose_msg.pose.orientation.y = q.y();
-        ndt_pose_msg.pose.orientation.z = q.z();
-        ndt_pose_msg.pose.orientation.w = q.w();
-
-     /*   pose_transform_control.setOrigin(tf::Vector3(0, 0, 0));
-        pose_q_control.setRPY(0, 0, 0);
-        pose_transform_control.setRotation(pose_q_control);
-        pose_broadcaster_control.sendTransform(tf::StampedTransform(pose_transform_control, scan_time, "map", "ndt_frame"));
-*/
-        /*
-         std::cout &lt;&lt; "ros::Time::now(): " &lt;&lt; ros::Time::now() &lt;&lt; std::endl;
-         std::cout &lt;&lt; "ros::Time::now().sec: " &lt;&lt; ros::Time::now().sec &lt;&lt; std::endl;
-         std::cout &lt;&lt; "ros::Time::now().nsec: " &lt;&lt; ros::Time::now().nsec &lt;&lt; std::endl;
-         */
-
-        ndt_pose_pub.publish(ndt_pose_msg);
-
-        t5_end = ros::Time::now();
-        d5 = t5_end - t5_start;
-
-#ifdef OUTPUT
-        // Writing position to position_log.txt
-        std::ofstream ofs("position_log.txt", std::ios::app);
-        if (ofs == NULL) {
-            std::cerr &lt;&lt; "Could not open 'position_log.txt'." &lt;&lt; std::endl;
-            exit(1);
-        }
-        ofs &lt;&lt; current_pos.x &lt;&lt; " " &lt;&lt; current_pos.y &lt;&lt; " " &lt;&lt; current_pos.z &lt;&lt; " " &lt;&lt; current_pos.roll &lt;&lt; " " &lt;&lt; current_pos.pitch &lt;&lt; " " &lt;&lt; current_pos.yaw &lt;&lt; std::endl;
-#endif
-
-        // Calculate the offset (curren_pos - previous_pos)
-        offset_x = current_pos.x - previous_pos.x;
-        offset_y = current_pos.y - previous_pos.y;
-        offset_z = current_pos.z - previous_pos.z;
-        offset_yaw = current_pos.yaw - previous_pos.yaw;
-
-        // Update position and posture. current_pos -&gt; previous_pos
-        previous_pos.x = current_pos.x;
-        previous_pos.y = current_pos.y;
-        previous_pos.z = current_pos.z;
-        previous_pos.roll = current_pos.roll;
-        previous_pos.pitch = current_pos.pitch;
-        previous_pos.yaw = current_pos.yaw;
-
-        callback_end = ros::Time::now();
-        d_callback = callback_end - callback_start;
-
-        std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
-        std::cout &lt;&lt; "Sequence number: " &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
-        std::cout &lt;&lt; "Number of scan points: " &lt;&lt; additional_map_ptr-&gt;size() &lt;&lt; " points." &lt;&lt; std::endl;
-        std::cout &lt;&lt; "Number of filtered scan points: " &lt;&lt; filtered_additional_map_ptr-&gt;size() &lt;&lt; " points." &lt;&lt; std::endl;
-        std::cout &lt;&lt; "NDT has converged: " &lt;&lt; ndt.hasConverged() &lt;&lt; std::endl;
-        std::cout &lt;&lt; "Fitness score: " &lt;&lt; ndt.getFitnessScore() &lt;&lt; std::endl;
-        std::cout &lt;&lt; "Number of iteration: " &lt;&lt; ndt.getFinalNumIteration() &lt;&lt; std::endl;
-        std::cout &lt;&lt; "(x,y,z,roll,pitch,yaw):" &lt;&lt; std::endl;
-        std::cout &lt;&lt; "(" &lt;&lt; current_pos.x &lt;&lt; ", " &lt;&lt; current_pos.y &lt;&lt; ", " &lt;&lt; current_pos.z &lt;&lt; ", " &lt;&lt; current_pos.roll &lt;&lt; ", " &lt;&lt; current_pos.pitch &lt;&lt; ", " &lt;&lt; current_pos.yaw &lt;&lt; ")" &lt;&lt; std::endl;
-        std::cout &lt;&lt; "Transformation Matrix:" &lt;&lt; std::endl;
-        std::cout &lt;&lt; t &lt;&lt; std::endl;
-#ifdef VIEW_TIME
-        std::cout &lt;&lt; "Duration of velodyne_callback: " &lt;&lt; d_callback.toSec() &lt;&lt; " secs." &lt;&lt; std::endl;
-        std::cout &lt;&lt; "Adding scan points: " &lt;&lt; d1.toSec() &lt;&lt; " secs." &lt;&lt; std::endl;
-        std::cout &lt;&lt; "VoxelGrid Filter: " &lt;&lt; d2.toSec() &lt;&lt; " secs." &lt;&lt; std::endl;
-        std::cout &lt;&lt; "Guessing the initial gross estimation: " &lt;&lt; d3.toSec() &lt;&lt; " secs." &lt;&lt; std::endl;
-        std::cout &lt;&lt; "NDT: " &lt;&lt; d4.toSec() &lt;&lt; " secs." &lt;&lt; std::endl;
-        std::cout &lt;&lt; "tf: " &lt;&lt; d5.toSec() &lt;&lt; " secs." &lt;&lt; std::endl;
-#endif
-        std::cout &lt;&lt; "-----------------------------------------------------------------" &lt;&lt; std::endl;
-    }
-}
-
-int main(int argc, char **argv)
-{
-    if(argc != 8){
-      std::cout &lt;&lt; "Usage: rosrun ndt_localizer local2global \"filename\" \"x\" \"y\" \"z\" \"roll\" \"pitch\" \"yaw\"" &lt;&lt; std::endl;
-      exit(1);
-    }
-
-    ros::init(argc, argv, "local2global");
-    ros::NodeHandle n;
-
-    std::string filename = argv[1];
-    std::cout &lt;&lt; filename &lt;&lt; std::endl;
-
-    if(pcl::io::loadPCDFile&lt;pcl::PointXYZI&gt; (filename, *additional_map_ptr) == -1){
-      std::cout &lt;&lt; "Couldn't read " &lt;&lt; filename &lt;&lt; "." &lt;&lt; std::endl;
-      return(-1);
-    }
-    std::cout &lt;&lt; "Loaded " &lt;&lt; additional_map_ptr-&gt;size() &lt;&lt; " data points from " &lt;&lt; filename &lt;&lt; "." &lt;&lt; std::endl;
-
-    initial_x = std::stod(argv[2]);
-    initial_y = std::stod(argv[3]);
-    initial_z = std::stod(argv[4]);
-    initial_roll = std::stod(argv[5]);
-    initial_pitch = std::stod(argv[6]);
-    initial_yaw = std::stod(argv[7]);
-
-    std::cout &lt;&lt; "initial_pose: "
-	      &lt;&lt; initial_x &lt;&lt; " " &lt;&lt; initial_y &lt;&lt; " " &lt;&lt; initial_z &lt;&lt; " "
-	      &lt;&lt; initial_roll &lt;&lt; " " &lt;&lt; initial_pitch &lt;&lt; " " &lt;&lt; initial_yaw &lt;&lt; std::endl;
-
-    previous_pos.x = initial_x;
-    previous_pos.y = initial_y;
-    previous_pos.z = initial_z;
-    previous_pos.roll = initial_roll;
-    previous_pos.pitch = initial_pitch;
-    previous_pos.yaw = initial_yaw;
-    
-    current_pos.x = initial_x;
-    current_pos.y = initial_y;
-    current_pos.z = initial_z;
-    current_pos.roll = initial_roll;
-    current_pos.pitch = initial_pitch;
-    current_pos.yaw = initial_yaw;
-
-    ndt_pose_pub = n.advertise&lt;geometry_msgs::PoseStamped&gt;("/current_pose", 1000);
-
-    ndt_map_pub = n.advertise&lt;sensor_msgs::PointCloud2&gt;("/ndt_map", 1000, true);
-
-    // subscribing gnss position
-    ros::Subscriber gnss_sub = n.subscribe("gnss_pose", 10, gnss_callback);
-
-    // subscribing map data (only once)
-    ros::Subscriber map_sub = n.subscribe("points_map", 10, map_callback);
-
-    // subscribing the velodyne data
-    //    ros::Subscriber velodyne_sub = n.subscribe("points_raw", 1000, velodyne_callback);
-    //    ros::Subscriber velodyne_sub = n.subscribe("cloud_pcd", 1000, velodyne_callback);
-
-    ros::spin();
-
-    return 0;
-}
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="2637ea879cc5e0398f2cfa7414f6483d571a5163" author="Yusuke FUJII">
		<msg>reformat</msg>
		<modified_files>
			<file old_path="ros\src\util\packages\autoware_rviz_plugins\src\sim_object\autoware_flag_tool.cpp" new_path="ros\src\util\packages\autoware_rviz_plugins\src\sim_object\autoware_flag_tool.cpp" added_lines="2" deleted_lines="2">
				<diff>@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2017, TierIV, Inc.
+ * Copyright (c) 2012, Willow Garage, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -167,7 +168,6 @@ void AutowareSimObjTool::save( rviz::Config config ) const
 
 void AutowareSimObjTool::load( const rviz::Config&amp; config )
 {
-  // Here we get the "Flags" sub-config from the tool config and loop over its entries:
   rviz::Config flags_config = config.mapGetChild( "Flags" );
   int num_flags = flags_config.listLength();
   for( int i = 0; i &lt; num_flags; i++ )
@@ -182,7 +182,7 @@ void AutowareSimObjTool::load( const rviz::Config&amp; config )
     makeFlag( prop-&gt;getVector() );
   }
 }
-} // end namespace rviz_plugin_tutorials
+} 
 
 #include &lt;pluginlib/class_list_macros.h&gt;
 PLUGINLIB_EXPORT_CLASS(autoware_sim_object::AutowareSimObjTool,rviz::Tool )
</diff>
			</file>
			<file old_path="ros\src\util\packages\autoware_rviz_plugins\src\sim_object\autoware_flag_tool.h" new_path="ros\src\util\packages\autoware_rviz_plugins\src\sim_object\autoware_flag_tool.h" added_lines="3" deleted_lines="2">
				<diff>@@ -1,4 +1,5 @@
 /*
+ * Copyright (c) 2017, TierIV, Inc.
  * Copyright (c) 2012, Willow Garage, Inc.
  * All rights reserved.
  *
@@ -26,8 +27,8 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-#ifndef PLANT_FLAG_TOOL_H
-#define PLANT_FLAG_TOOL_H
+#ifndef AUTOWARE_FLAG_TOOL_H
+#define AUTOWARE_FLAG_TOOL_H
 
 #include &lt;ros/node_handle.h&gt;
 #include &lt;ros/publisher.h&gt;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="ecd815c799b0383c3e9716ec8fcb7c44a923bb56" author="Yusuke FUJII">
		<msg>Add to support dynamical parameter for decision_maker</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" added_lines="3" deleted_lines="3">
				<diff>@@ -48,7 +48,7 @@ public:
   virtual void showStateName(void) = 0;
   virtual unsigned long long getStateTransMask() = 0;
   virtual unsigned long long getStateNum() = 0;
-  virtual std::unique_ptr&lt;std::string&gt; getStateName() = 0;
+  virtual std::string getStateName() = 0;
   virtual unsigned char getStateKind() = 0;
 };
 
@@ -80,9 +80,9 @@ public:
     return &amp;singleton;
   }
 
-  std::unique_ptr&lt;std::string&gt; getStateName(void)
+  std::string getStateName(void)
   {
-    return std::unique_ptr&lt;std::string&gt;(new std::string(StateName));
+    return std::string(StateName);
   }
 
   unsigned char getStateKind(void)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" added_lines="10" deleted_lines="6">
				<diff>@@ -40,7 +40,7 @@ private:
 
   void showStateMove(unsigned long long _state_num)
   {
-    std::cout &lt;&lt; "State will be [" &lt;&lt; *StateStores[_state_num]-&gt;getStateName() &lt;&lt; "]" &lt;&lt; std::endl;
+    std::cout &lt;&lt; "State will be [" &lt;&lt; StateStores[_state_num]-&gt;getStateName() &lt;&lt; "]" &lt;&lt; std::endl;
   }
 
 public:
@@ -93,21 +93,25 @@ public:
   {
     thread_loop = false;
   }
+  void stateDecider(void);
 
-  bool isState(unsigned long long _state_num);
+  bool isState(BaseState *base, unsigned long long _state_num);
+  bool isCurrentState(unsigned long long _state_num);
+  bool isCurrentState(unsigned char _state_kind, unsigned long long _state_num);
   bool inState(unsigned long long _state_num);
 
-  void stateDecider(void);
 
   bool setCurrentState(StateFlags flag);
   bool setCurrentState(BaseState *state);
-  bool setCurrentState(BaseState *state, BaseState *substate);
-  bool setCurrentState(BaseState *state, BaseState *substate, BaseState *subsubstate);
+  bool disableCurrentState(unsigned long long);
 
   BaseState *getCurrentMainState(void);
   BaseState *getCurrentState(void);
-  std::unique_ptr&lt;std::string&gt; getCurrentStateName(void);
+  std::string getCurrentStateName(void);
+  std::string getStateName(void);
+  BaseState **getCurrentStateHolderPtr(unsigned long long _state_num);
   void showCurrentStateName(void);
+  std::string createStateMessageText(void);
 
   bool setEnableForceSetState(bool force_flag);
   BaseState *getStateObject(unsigned long long _state_num);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" added_lines="20" deleted_lines="20">
				<diff>@@ -10,22 +10,22 @@ enum StateFlags
   INITIAL_STATE = 1 &lt;&lt; 2,
   INITIAL_LOCATEVEHICLE_STATE = 1 &lt;&lt; 3,
   DRIVE_STATE = 1 &lt;&lt; 4,
-  DRIVE_ACC_ACCELERATION_STATE = 1 &lt;&lt; 5,
-  DRIVE_ACC_DECELERATION_STATE = 1 &lt;&lt; 6,
-  DRIVE_ACC_KEEP_STATE = 1 &lt;&lt; 7,
-  DRIVE_ACC_STOP_STATE = 1 &lt;&lt; 8,
-  DRIVE_STR_STRAIGHT_STATE = 1 &lt;&lt; 9,
-  DRIVE_STR_LEFT_STATE = 1 &lt;&lt; 10,
-  DRIVE_STR_RIGHT_STATE = 1 &lt;&lt; 11,
-  DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE = 1 &lt;&lt; 12,
-  DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE = 1 &lt;&lt; 13,
-  DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE = 1 &lt;&lt; 13,
-  DRIVE_DETECT_OBSTACLE_STATE = 1 &lt;&lt; 14,
-  DRIVE_DETECT_STOPLINE_STATE = 1 &lt;&lt; 15,
-  DRIVE_DETECT_TRAFFICLIGHT_RED_STATE = 1 &lt;&lt; 16,
-  MISSION_COMPLETE_STATE = 1 &lt;&lt; 17,
-  EMERGENCY_STATE = 1 &lt;&lt; 18,
-  STATE_END = 1 &lt;&lt; 19,
+  MISSION_COMPLETE_STATE = 1 &lt;&lt; 5,
+  EMERGENCY_STATE = 1 &lt;&lt; 6,
+  DRIVE_ACC_ACCELERATION_STATE = 1 &lt;&lt; 7,
+  DRIVE_ACC_DECELERATION_STATE = 1 &lt;&lt; 8,
+  DRIVE_ACC_KEEP_STATE = 1 &lt;&lt; 9,
+  DRIVE_ACC_STOP_STATE = 1 &lt;&lt; 10,
+  DRIVE_STR_STRAIGHT_STATE = 1 &lt;&lt; 11,
+  DRIVE_STR_LEFT_STATE = 1 &lt;&lt; 12,
+  DRIVE_STR_RIGHT_STATE = 1 &lt;&lt; 13,
+  DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE = 1 &lt;&lt; 14,
+  DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE = 1 &lt;&lt; 15,
+  DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE = 1 &lt;&lt; 16,
+  DRIVE_DETECT_OBSTACLE_STATE = 1 &lt;&lt; 17,
+  DRIVE_DETECT_STOPLINE_STATE = 1 &lt;&lt; 18,
+  DRIVE_DETECT_TRAFFICLIGHT_RED_STATE = 1 &lt;&lt; 19,
+  STATE_END = 1 &lt;&lt; 20,
 };
 
 enum StateKinds
@@ -41,10 +41,10 @@ enum StateKinds
 
 enum TrafficLightColors
 {
-  E_RED,
-  E_YELLOW,
-  E_GREEN,
-  E_COLOR_ERROR
+  E_RED = 0, 
+  E_YELLOW = 0,
+  E_GREEN = 1,
+  E_COLOR_ERROR = 2
 };
 }
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="80" deleted_lines="9">
				<diff>@@ -46,7 +46,7 @@ void StateContext::showCurrentStateName(void)
   std::cout &lt;&lt; std::endl;
 }
 
-std::unique_ptr&lt;std::string&gt; StateContext::getCurrentStateName(void)
+std::string StateContext::getCurrentStateName(void)
 {
   return current_state_.MainState-&gt;getStateName();
 }
@@ -67,7 +67,7 @@ bool StateContext::setCurrentState(BaseState *_state)
     current_state_.MainState = _state;
     std::cout &lt;&lt; "Successed to set state \""
               &lt;&lt; "NULL"
-              &lt;&lt; "\" to \"" &lt;&lt; *_state-&gt;getStateName().get() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/"
+              &lt;&lt; "\" to \"" &lt;&lt; _state-&gt;getStateName() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/"
               &lt;&lt; "NULL"
               &lt;&lt; "-" &lt;&lt; _state-&gt;getStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
   }
@@ -100,13 +100,13 @@ bool StateContext::setCurrentState(BaseState *_state)
 			current_state_.OtherState = _state;
 			break;
 	}
-        std::cout &lt;&lt; "Successed to set state \"" &lt;&lt; *prevState-&gt;getStateName().get() &lt;&lt; "\" to \""
-                  &lt;&lt; *_state-&gt;getStateName().get() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/"
+        std::cout &lt;&lt; "Successed to set state \"" &lt;&lt; prevState-&gt;getStateName() &lt;&lt; "\" to \""
+                  &lt;&lt; _state-&gt;getStateName() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/"
                   &lt;&lt; prevState-&gt;getStateNum() &lt;&lt; "-" &lt;&lt; _state-&gt;getStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
       }
     else{
-      std::cerr &lt;&lt; "Failed to set state \"" &lt;&lt; *current_state_.MainState-&gt;getStateName().get() &lt;&lt; "\" to \""
-                &lt;&lt; *_state-&gt;getStateName().get() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/"
+      std::cerr &lt;&lt; "Failed to set state \"" &lt;&lt; current_state_.MainState-&gt;getStateName() &lt;&lt; "\" to \""
+                &lt;&lt; _state-&gt;getStateName() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/"
                 &lt;&lt; current_state_.MainState-&gt;getStateNum() &lt;&lt; "-" &lt;&lt; _state-&gt;getStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
       prevState = nullptr;
       return false;
@@ -119,6 +119,7 @@ bool StateContext::setCurrentState(StateFlags flag)
 {
    this-&gt;setCurrentState(StateStores[flag]);
 }
+
 bool StateContext::setEnableForceSetState(bool force_flag)
 {
 	enableForceSetState = force_flag;
@@ -135,14 +136,68 @@ BaseState *StateContext::getStateObject(unsigned long long _state_num)
   return StateStores[_state_num];
 }
 
-bool StateContext::isState(unsigned long long _state_num)
+BaseState **StateContext::getCurrentStateHolderPtr(unsigned long long _state_num)
+{
+  BaseState **state_ptr;
+  switch(getStateObject(_state_num)-&gt;getStateKind())
+  {
+		case MAIN_STATE:
+			state_ptr = &amp;current_state_.MainState;
+			break;
+		case ACC_STATE:
+			state_ptr = &amp;current_state_.AccState;
+			break;
+		case STR_STATE:
+			state_ptr = &amp;current_state_.StrState;
+			break;
+		case BEHAVIOR_STATE:
+			state_ptr = &amp;current_state_.BehaviorState;
+			break;
+		case PERCEPTION_STATE:
+			state_ptr = &amp;current_state_.PerceptionState;
+			break;
+		case OTHER_STATE:
+			state_ptr = &amp;current_state_.OtherState;
+			break;
+		default:
+			state_ptr = nullptr;
+			break;
+  }
+  return state_ptr;
+
+}
+
+bool StateContext::disableCurrentState(unsigned long long _state_num)
+{
+  BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
+  if(state_ptr &amp;&amp; this-&gt;isState((*state_ptr), _state_num)){
+	  *state_ptr = nullptr;
+	  return true;
+  }else{
+	  return false;
+  }
+}
+
+
+bool StateContext::isCurrentState(unsigned long long _state_num)
 {
-  return current_state_.MainState?current_state_.MainState-&gt;getStateNum() == _state_num:false;
+  BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
+  return (*state_ptr)?(*state_ptr)-&gt;getStateNum() == _state_num?true:false:false;
+ // return current_state_.MainState?current_state_.MainState-&gt;getStateNum() == _state_num?true:false:false;
+}
+
+bool StateContext::isState(BaseState *base, unsigned long long _state_num)
+{
+  return base?base-&gt;getStateNum() == _state_num?true:false:false;
 }
 
 bool StateContext::inState(unsigned long long _state_num)
 {
-  return current_state_.MainState?current_state_.MainState-&gt;getStateNum() &amp; _state_num:false;
+	if(current_state_.MainState){
+		return ((current_state_.MainState-&gt;getStateNum() &amp; _state_num) != 0)?true:false;
+	}else{
+		return false;
+	}
 }
 
 #define ANGLE_STRAIGHT 50.0
@@ -174,6 +229,22 @@ bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
   }
 }
 
+
+std::string StateContext::createStateMessageText(void)
+{
+	std::string ret;
+
+	for(auto &amp;&amp;p : HolderList){
+		if(*p){
+			ret = ret + "\n" + (*p)-&gt;getStateName();
+		}
+	}
+	return ret;
+
+
+}
+
+
 bool StateContext::handleTwistCmd(bool _hasTwistCmd)
 {
   if (_hasTwistCmd)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="44" deleted_lines="11">
				<diff>@@ -2,8 +2,11 @@
 #define __DECISION_MAKER_NODE__
 
 #include &lt;unordered_map&gt;
+#include &lt;mutex&gt;
+
 
 #include &lt;autoware_msgs/lane.h&gt;
+#include &lt;autoware_msgs/ConfigDecisionMaker.h&gt;
 #include &lt;autoware_msgs/traffic_light.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;geometry_msgs/TwistStamped.h&gt;
@@ -11,6 +14,7 @@
 #include &lt;jsk_rviz_plugins/OverlayText.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
 #include &lt;std_msgs/String.h&gt;
+#include &lt;std_msgs/Int32.h&gt;
 
 //#include &lt;vector_map_server/GetCrossRoad.h&gt;
 
@@ -25,17 +29,18 @@
 #include &lt;euclidean_space.hpp&gt;
 #include &lt;state.hpp&gt;
 #include &lt;state_context.hpp&gt;
-
 #include &lt;cross_road_area.hpp&gt;
 
 
+#include &lt;decision_maker_param.hpp&gt;
+
+
 //#include &lt;dynamic_reconfigure/server.h&gt;
 //#include &lt;decision_maker/decision_makerConfig.h&gt;
 
 namespace decision_maker
 {
-//#define DEBUG_PRINT
-enum class EControl
+enum class EControl : int32_t
 {
   KEEP = -1,
   STOP = 1,
@@ -44,6 +49,20 @@ enum class EControl
   OTHERS = 4,
 };
 
+enum class E_ChangeFlags : int32_t
+{
+  STRAIGHT,
+  LEFT,
+  RIGHT,
+  
+  UNKNOWN = -1,
+};
+
+template &lt;class T&gt;
+typename std::underlying_type&lt;T&gt;::type enumToInteger(T t)
+{
+	return static_cast&lt;typename std::underlying_type&lt;T&gt;::type&gt;(t);
+}
 inline bool hasvMap(void)
 {
   return true;
@@ -86,7 +105,14 @@ private:
   std::string CurrentStateName;
   std::string TextOffset;
   std::vector&lt;CrossRoadArea&gt; intersects;
-  bool isDisplay;
+  double displacement_from_path_;
+
+  // Param
+  bool enableDisplayMarker;
+  bool enableForceStateChange;
+  double param_convergence_threshold_;
+  int param_convergence_count_;
+  int param_target_waypoint_;
 
   // for vectormap server
   // ros::ServiceClient cross_road_cli;
@@ -99,6 +125,7 @@ private:
   bool vMap_Lines_flag;
   bool vMap_CrossRoads_flag;
   bool SimulationMode;
+  std::mutex vMap_mutex;
 
   // initialization method
   void initROS(int argc, char **argv);
@@ -113,6 +140,7 @@ private:
   void displayMarker(void);
 
   void publishToVelocityArray();
+  std::string createStateMessageText();
 
   // judge method
   // in near future, these methods will be deprecate to decision_maker library 
@@ -120,27 +148,27 @@ private:
   bool isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
   bool isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch, double _yaw);
 
+  bool handleStateCmd(const unsigned long long _state_num);
+
   double calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
 
   // callback by topic subscribing
   void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
   void callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg);
-  void callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg);
+  void callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event);
+  void callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg);
   void callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg);
   void callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg);
   void callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg);
   void callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg);
-  void callbackFromStateCmd(const std_msgs::String &amp;msg);
+  void callbackFromStateCmd(const std_msgs::Int32 &amp;msg);
+  void callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg);
 
   void callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg);
   void callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg);
   void callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg);
   void callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg);
 
-  // for ros dynamic reconfigure
-  // Currently. this feature is not working.
-  // static void callbackFromDynamicReconfigure(decision_maker::decision_makerConfig &amp;config, uint32_t level);
-
   // in near future, these methods will be deprecate to ADAS library 
   CrossRoadArea *findClosestCrossRoad(void);
 
@@ -150,7 +178,10 @@ public:
   DecisionMakerNode(int argc, char **argv)
   {
     SimulationMode = false;
-    isDisplay = true;
+    enableDisplayMarker = DEFAULT_DISPLAY_FLAG;
+    param_convergence_threshold_ = DEFAULT_CONVERGENCE_THRESHOLD; 
+    param_convergence_count_ = DEFAULT_CONVERGENCE_COUNT;
+    param_target_waypoint_ = DEFAULT_TARGET_WAYPOINT;
 
     ctx = new state_machine::StateContext();
     this-&gt;initROS(argc, argv);
@@ -159,6 +190,8 @@ public:
     vMap_Areas_flag = vMap_Lines_flag = vMap_Points_flag = vMap_CrossRoads_flag = false;
 
     ClosestArea_ = nullptr;
+    displacement_from_path_ = 0.0;
+
   }
 
   void run(void);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="95" deleted_lines="63">
				<diff>@@ -16,69 +16,81 @@
 
 namespace decision_maker
 {
-#define VEL_AVERAGE_COUNT 10
-#define CONV_NUM 10
-#define CONVERGENCE_THRESHOLD 0.01
 
-bool DecisionMakerNode::isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch, double _yaw)
-{
-  static int _init_count = 0;
-  static euclidean_space::point *a = new euclidean_space::point();
-  static euclidean_space::point *b = new euclidean_space::point();
-
-  static double distances[CONV_NUM] = { 0.0 };
-  double avg_distances = 0.0;
-
-  for (int i = 1; i &lt; CONV_NUM; i++)
-  {
-    distances[i] = distances[i - 1];
-    avg_distances += distances[i];
-  }
-
-  a-&gt;x = b-&gt;x;
-  a-&gt;y = b-&gt;y;
-  a-&gt;z = b-&gt;z;
-
-  b-&gt;x = _x;
-  b-&gt;y = _y;
-  b-&gt;z = _z;
+	// TODO for Decision_maker
+	// - lane_change
+	// - change substate class to state_context
+	// - fix a light_color_changed
+	// - disable/clear_subclassa
+	// - object detection
+	// - changed subscribing waypoint topic to base_waypoints from final_waypoints 
+	//
 
-  distances[0] = euclidean_space::EuclideanSpace::find_distance(a, b);
-
-  if (++_init_count &lt;= CONV_NUM)
-  {
-    return false;
-  }else
-  {
-    avg_distances = (avg_distances + distances[0]) / CONV_NUM;
-    if (avg_distances &lt;= CONVERGENCE_THRESHOLD){
-      return ctx-&gt;setCurrentState(state_machine::DRIVE_STATE);
-    }else
-    {
-      return false;
-    }
-  }
-}
-    
 void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
 {
   geometry_msgs::PoseStamped _pose = current_pose_ = msg;
-  bool initLocalizationFlag = ctx-&gt;isState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
+  bool initLocalizationFlag = ctx-&gt;isCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
   if (initLocalizationFlag &amp;&amp;
       isLocalizationConvergence(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
                              _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
   {
     ROS_INFO("Localization was convergence");
   }
+
+  //displacement_from_path_ =  getDisplacementFromPath(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z);
 }
 
-void DecisionMakerNode::callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg)
+bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
 {
-  ROS_INFO("Light color callback");
-  current_traffic_light = msg.traffic_light;
+	return ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
+}
+
+void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
+{
+	ROS_INFO("Received forcing state changing request");
+	handleStateCmd((unsigned long long)msg.data);
+}
+
+
+void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
+{
+	if(msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
+		ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
+	else if(msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
+		ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
+	else{
+		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
+		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
+	}
+}
+
+void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg)
+{
+	ROS_INFO("Param setted by Runtime Manager");
+	enableDisplayMarker = msg.enable_display_marker;
+	ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);
+	if(msg.MainState_ChangeFlag)
+		handleStateCmd((unsigned long long)1 &lt;&lt; msg.MainState_ChangeFlag);
+	if(msg.SubState_ChangeFlag)
+		handleStateCmd((unsigned long long)1 &lt;&lt; (msg.SubState_ChangeFlag + 7));
+
+
+
+}
+
+//void DecisionMakerNode::callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg)
+void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
+{
+  const ros::M_string &amp;header = event.getConnectionHeader();
+  std::string topic = header.at("topic");
+  const autoware_msgs::traffic_light *light = event.getMessage().get();
+
+  current_traffic_light = light-&gt;traffic_light;
   if(current_traffic_light == state_machine::E_RED ||
 	current_traffic_light == state_machine::E_YELLOW ){
 	ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
+  }else{
+	  ctx-&gt;disableCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
   }
   //ctx-&gt;handleTrafficLight(CurrentTrafficlight);
 }
@@ -90,23 +102,41 @@ void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::Co
 		Subs["points_raw"].shutdown();
 }
 
+#define ANGLE_STRAIGHT 50.0
+#define ANGLE_LEFT 360.0
+#define ANGLE_RIGHT 180.0
+
+
+
 void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
 {
   if (!hasvMap())
   {
     std::cerr &lt;&lt; "Not found vmap subscribe" &lt;&lt; std::endl;
-    // return;
+    return;
   }
-
-  current_finalwaypoints_ = msg;
-  ClosestArea_ = CrossRoadArea::findClosestCrossRoad(current_finalwaypoints_, intersects);
-
-  if (ctx-&gt;inState(state_machine::DRIVE_STATE))
+  if (!ctx-&gt;isCurrentState(state_machine::DRIVE_STATE))
   {
-    double intersect_wayangle = calcIntersectWayAngle(current_finalwaypoints_, current_pose_);
-    ctx-&gt;handleIntersection(true, intersect_wayangle);
+    std::cerr &lt;&lt; "State is not DRIVE_STATE["&lt;&lt; ctx-&gt;getCurrentStateName() &lt;&lt;"]" &lt;&lt; std::endl;
+    return;
   }
 
+  // steering
+  current_finalwaypoints_ = msg;
+  ClosestArea_ = CrossRoadArea::findClosestCrossRoad(current_finalwaypoints_, intersects);
+  double intersect_wayangle = calcIntersectWayAngle(current_finalwaypoints_, current_pose_);
+  // *Temporary implementation*
+  // To straight/left/right recognition by using angle
+  // between first-waypoint and end-waypoint in intersection area.
+  int temp = (int)std::floor(intersect_wayangle + 360.0) % 360;
+  if (std::abs(temp) &lt;= ANGLE_STRAIGHT)
+	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_STRAIGHT_STATE);
+  else if (temp &lt;= ANGLE_RIGHT)
+	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
+  else if (temp &lt;= ANGLE_LEFT)
+	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
+
+  // velocity
   double _temp_sum = 0;
   for (int i = 0; i &lt; VEL_AVERAGE_COUNT; i++)
   {
@@ -115,22 +145,19 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
   average_velocity_ = _temp_sum / VEL_AVERAGE_COUNT;
   
   if (std::fabs(average_velocity_ - current_velocity_) &lt;= 2.0)
-  {
-    TextOffset = "Keep";
-  }
+	  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE);
   else if (average_velocity_ - current_velocity_)
-  {
-    TextOffset = "Accelerate";
-  }
+	  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE);
   else
-  {
-    TextOffset = "Decelerate";
-  }
+	  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE);
 
   // for publish plan of velocity
   publishToVelocityArray();
 
+#ifdef DEBUG_PRINT
   std::cout &lt;&lt; "Velocity: " &lt;&lt; current_velocity_ &lt;&lt; " to " &lt;&lt; average_velocity_ &lt;&lt; std::endl;
+#endif
+
 }
 void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
 {
@@ -140,27 +167,32 @@ void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;
     ctx-&gt;handleTwistCmd(false);
   else
     Twistflag = true;
+
 }
 
 void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
 {
   vMap_Areas = msg;
   vMap_Areas_flag = true;
+  initVectorMap();
 }
 void DecisionMakerNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
 {
   vMap_Points = msg;
   vMap_Points_flag = true;
+  initVectorMap();
 }
 void DecisionMakerNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
 {
   vMap_Lines = msg;
   vMap_Lines_flag = true;
+  initVectorMap();
 }
 void DecisionMakerNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
 {
   vMap_CrossRoads = msg;
   vMap_CrossRoads_flag = true;
+  initVectorMap();
 }
 
 void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" added_lines="5" deleted_lines="8">
				<diff>@@ -26,9 +26,6 @@
 namespace decision_maker
 {
 
-#define DOUBLE_MAX 1.7976931348623158e308
-#define TARGET_WAYPOINTS_NUM 14
-
 CrossRoadArea *DecisionMakerNode::findClosestCrossRoad(void)
 {
   CrossRoadArea *_area = nullptr;
@@ -42,8 +39,8 @@ CrossRoadArea *DecisionMakerNode::findClosestCrossRoad(void)
 
   if (!current_finalwaypoints_.waypoints.empty())
   {
-    _pa.x = current_finalwaypoints_.waypoints[TARGET_WAYPOINTS_NUM].pose.pose.position.x;
-    _pa.y = current_finalwaypoints_.waypoints[TARGET_WAYPOINTS_NUM].pose.pose.position.y;
+    _pa.x = current_finalwaypoints_.waypoints[param_target_waypoint_].pose.pose.position.x;
+    _pa.y = current_finalwaypoints_.waypoints[param_target_waypoint_].pose.pose.position.y;
     _pa.z = 0.0;
   }
 
@@ -173,11 +170,11 @@ double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_
       std::cout &lt;&lt; "Yaw:" &lt;&lt; _y &lt;&lt; "-" &lt;&lt; y &lt;&lt; ":" &lt;&lt; _y - y &lt;&lt; std::endl;
       if (diff &gt; 50)
       {
-        std::cout &lt;&lt; "Right Turn!!!!!!" &lt;&lt; diff &lt;&lt; std::endl;
+        std::cout &lt;&lt; "Right Turn" &lt;&lt; diff &lt;&lt; std::endl;
       }
       else if (diff &lt; -50)
       {
-        std::cout &lt;&lt; "Left Turn!!!!!!" &lt;&lt; diff &lt;&lt; std::endl;
+        std::cout &lt;&lt; "Left Turn" &lt;&lt; diff &lt;&lt; std::endl;
       }
       else
       {
@@ -211,7 +208,7 @@ void DecisionMakerNode::run(void)
   while (ros::ok())
   {
     update();
-    if(isDisplay)
+    if(enableDisplayMarker)
 	    displayMarker();
     loop_rate.sleep();
   }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="63" deleted_lines="52">
				<diff>@@ -5,6 +5,7 @@
 #include &lt;std_msgs/String.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;tf/transform_listener.h&gt;
+#include &lt;mutex&gt;
 
 // lib
 #include &lt;euclidean_space.hpp&gt;
@@ -39,9 +40,11 @@ namespace decision_maker{
 		Subs["current_velocity"] =
 			nh_.subscribe("current_velocity", 20, &amp;DecisionMakerNode::callbackFromCurrentVelocity, this);
 		Subs["light_color"] = nh_.subscribe("light_color", 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
+		Subs["light_color_managed"] = nh_.subscribe("light_color_managed", 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
 		Subs["points_raw"] = nh_.subscribe("filtered_points", 1, &amp;DecisionMakerNode::callbackFromPointsRaw, this);
 		Subs["final_waypoints"] = nh_.subscribe("final_waypoints", 100, &amp;DecisionMakerNode::callbackFromFinalWaypoint, this);
 		Subs["twist_cmd"] = nh_.subscribe("twist_cmd", 10, &amp;DecisionMakerNode::callbackFromTwistCmd, this);
+		Subs["change_flag"] = nh_.subscribe("change_flag", 1, &amp;DecisionMakerNode::callbackFromLaneChangeFlag, this);
 
 		// vector map subscriber
 		Subs["vector_map_area"] =
@@ -53,6 +56,9 @@ namespace decision_maker{
 		Subs["vector_map_crossroad"] =
 			nh_.subscribe("/vector_map_info/cross_road", 1, &amp;DecisionMakerNode::callbackFromVectorMapCrossRoad, this);
 
+		// Config subscriber
+		Subs["config/decision_maker"] = nh_.subscribe("/config/decision_maker", 3, &amp;DecisionMakerNode::callbackFromConfig, this);
+
 		// pub
 		Pubs["state"] = nh_.advertise&lt;std_msgs::String&gt;("state", 1);
 		Pubs["state_overlay"] = nh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;("/state/overlay_text", 1);
@@ -89,73 +95,77 @@ namespace decision_maker{
 		}
 		{
 			initVectorMapClient();
-			if(isDisplay)
+			if(enableDisplayMarker)
 				displayMarker();
 		}
 	}
 
 	void DecisionMakerNode::initVectorMap(void)
 	{
-		if (!vector_map_init &amp;&amp; vMap_Areas_flag &amp; vMap_Points_flag &amp; vMap_Lines_flag &amp; vMap_CrossRoads_flag)
-		{
-			vector_map_init = true;
-
-			int _index = 0;
-
-			for (const auto &amp;cross_road : vMap_CrossRoads.data)
-			{
-				for (const auto &amp;area : vMap_Areas.data)
+		if(!vector_map_init){
+			vMap_mutex.lock();
+				if (!vector_map_init &amp;&amp; vMap_Areas_flag &amp; vMap_Points_flag &amp; vMap_Lines_flag &amp; vMap_CrossRoads_flag)
 				{
-					if (cross_road.aid == area.aid)
-					{
-						CrossRoadArea carea;
-						carea.id = _index++;
-						carea.area_id = area.aid;
+					vector_map_init = true;
 
-						double x_avg = 0.0, x_min = 0.0, x_max = 0.0;
-						double y_avg = 0.0, y_min = 0.0, y_max = 0.0;
-						double z = 0.0;
+					int _index = 0;
 
-						int points_count = 0;
-						for (const auto &amp;line : vMap_Lines.data)
+					for (const auto &amp;cross_road : vMap_CrossRoads.data)
+					{
+						for (const auto &amp;area : vMap_Areas.data)
 						{
-							if (area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid)
+							if (cross_road.aid == area.aid)
 							{
-								for (const auto &amp;point : vMap_Points.data)
+								CrossRoadArea carea;
+								carea.id = _index++;
+								carea.area_id = area.aid;
+
+								double x_avg = 0.0, x_min = 0.0, x_max = 0.0;
+								double y_avg = 0.0, y_min = 0.0, y_max = 0.0;
+								double z = 0.0;
+
+								int points_count = 0;
+								for (const auto &amp;line : vMap_Lines.data)
 								{
-									if (line.fpid &lt;= point.pid &amp;&amp; point.pid &lt;= line.fpid)
+									if (area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid)
 									{
-										geometry_msgs::Point _point;
-										_point.x = point.ly;
-										_point.y = point.bx;
-										_point.z = point.h;
-
-										x_avg += _point.x;
-										y_avg += _point.y;
-
-										x_min = (x_min == 0.0) ? _point.x : std::min(_point.x, x_min);
-										x_max = (x_max == 0.0) ? _point.x : std::max(_point.x, x_max);
-										y_min = (y_min == 0.0) ? _point.y : std::min(_point.y, y_min);
-										y_max = (y_max == 0.0) ? _point.y : std::max(_point.y, y_max);
-										z = _point.z;
-										points_count++;
-
-										carea.points.push_back(_point);
-									}  // if pid
-								}    // points iter
-							}      // if lid
-						}        // line iter
-						carea.bbox.pose.position.x = x_avg / (double)points_count;
-						carea.bbox.pose.position.y = y_avg / (double)points_count;
-						carea.bbox.pose.position.z = z;
-						carea.bbox.dimensions.x = x_max - x_min;
-						carea.bbox.dimensions.y = y_max - y_min;
-						carea.bbox.dimensions.z = 2;
-						carea.bbox.label = 1;
-						intersects.push_back(carea);
+										for (const auto &amp;point : vMap_Points.data)
+										{
+											if (line.fpid &lt;= point.pid &amp;&amp; point.pid &lt;= line.fpid)
+											{
+												geometry_msgs::Point _point;
+												_point.x = point.ly;
+												_point.y = point.bx;
+												_point.z = point.h;
+
+												x_avg += _point.x;
+												y_avg += _point.y;
+
+												x_min = (x_min == 0.0) ? _point.x : std::min(_point.x, x_min);
+												x_max = (x_max == 0.0) ? _point.x : std::max(_point.x, x_max);
+												y_min = (y_min == 0.0) ? _point.y : std::min(_point.y, y_min);
+												y_max = (y_max == 0.0) ? _point.y : std::max(_point.y, y_max);
+												z = _point.z;
+												points_count++;
+
+												carea.points.push_back(_point);
+											}  // if pid
+										}    // points iter
+									}      // if lid
+								}        // line iter
+								carea.bbox.pose.position.x = x_avg / (double)points_count;
+								carea.bbox.pose.position.y = y_avg / (double)points_count;
+								carea.bbox.pose.position.z = z;
+								carea.bbox.dimensions.x = x_max - x_min;
+								carea.bbox.dimensions.y = y_max - y_min;
+								carea.bbox.dimensions.z = 2;
+								carea.bbox.label = 1;
+								intersects.push_back(carea);
+							}
+						}
 					}
 				}
-			}
+			vMap_mutex.unlock();
 		}
 	}
 
@@ -174,5 +184,6 @@ namespace decision_maker{
 
 		return cross_road_cli.call(cross_road_srv);
 #endif
+		return false;
 	}
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="7" deleted_lines="2">
				<diff>@@ -106,7 +106,7 @@ void DecisionMakerNode::update_msgs(void)
   if (ctx)
   {
     static std::string prevStateName;
-    CurrentStateName = *ctx-&gt;getCurrentStateName();
+    CurrentStateName = ctx-&gt;getCurrentStateName();
 
     if (prevStateName != CurrentStateName)
     {
@@ -115,7 +115,7 @@ void DecisionMakerNode::update_msgs(void)
     }
 
     state_string_msg.data = CurrentStateName;
-    state_text_msg.text = CurrentStateName + "\n" + TextOffset;
+    state_text_msg.text = createStateMessageText();
 
     Pubs["state"].publish(state_string_msg);
     Pubs["state_overlay"].publish(state_text_msg);
@@ -124,6 +124,11 @@ void DecisionMakerNode::update_msgs(void)
     std::cerr &lt;&lt; "ctx is not found " &lt;&lt; std::endl;
 }
 
+std::string DecisionMakerNode::createStateMessageText()
+{
+	return ctx-&gt;createStateMessageText();
+}
+
 void DecisionMakerNode::publishToVelocityArray()
 {
   int count = 0;
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="13d22c66d76406f2394bbfd97a5fe2144dc127fa" author="Yusuke FUJII">
		<msg>update decision maker config</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_param.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_param.hpp" added_lines="4" deleted_lines="2">
				<diff>@@ -12,11 +12,13 @@ namespace decision_maker{
 #define DEFAULT_CONVERGENCE_COUNT 5
 #define DEFAULT_CONVERGENCE_THRESHOLD 0.01
 
-
-
 #define DOUBLE_MAX 1.7976931348623158e308
 #define DEFAULT_TARGET_WAYPOINT 14
 
+#define ANGLE_STRAIGHT 50.0
+#define ANGLE_LEFT 360.0
+#define ANGLE_RIGHT 180.0
+
 
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="12" deleted_lines="10">
				<diff>@@ -69,13 +69,18 @@ void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMa
 	ROS_INFO("Param setted by Runtime Manager");
 	enableDisplayMarker = msg.enable_display_marker;
 	ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);
-	if(msg.MainState_ChangeFlag)
-		handleStateCmd((unsigned long long)1 &lt;&lt; msg.MainState_ChangeFlag);
-	if(msg.SubState_ChangeFlag)
-		handleStateCmd((unsigned long long)1 &lt;&lt; (msg.SubState_ChangeFlag + 7));
-
-
-
+	if(msg.enable_force_state_change){
+		if(msg.MainState_ChangeFlag)
+			handleStateCmd((unsigned long long)1 &lt;&lt; msg.MainState_ChangeFlag);
+		if(msg.SubState_Acc_ChangeFlag)
+			handleStateCmd(state_machine::DRIVE_ACC_ACCELERATION_STATE &lt;&lt; (msg.SubState_Acc_ChangeFlag-1));
+		if(msg.SubState_Str_ChangeFlag)
+			handleStateCmd(state_machine::DRIVE_STR_STRAIGHT_STATE &lt;&lt; (msg.SubState_Str_ChangeFlag-1));
+		if(msg.SubState_Behavior_ChangeFlag)
+			handleStateCmd(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE &lt;&lt; (msg.SubState_Behavior_ChangeFlag-1));
+		if(msg.SubState_Perception_ChangeFlag)
+			handleStateCmd(state_machine::DRIVE_DETECT_OBSTACLE_STATE &lt;&lt; (msg.SubState_Perception_ChangeFlag -1));
+	}
 }
 
 //void DecisionMakerNode::callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg)
@@ -102,9 +107,6 @@ void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::Co
 		Subs["points_raw"].shutdown();
 }
 
-#define ANGLE_STRAIGHT 50.0
-#define ANGLE_LEFT 360.0
-#define ANGLE_RIGHT 180.0
 
 
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" added_lines="0" deleted_lines="1">
				<diff>@@ -47,4 +47,3 @@ bool DecisionMakerNode::isLocalizationConvergence(double _x, double _y, double _
 
 }
 }
-    
</diff>
			</file>
			<file old_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" new_path="ros\src\computing\planning\state\state_machine\nodes\state_machine\state_machine.h" added_lines="2" deleted_lines="1">
				<diff>@@ -83,6 +83,7 @@ public:
   {
     return 0;
   };
+  
   virtual std::unique_ptr&lt;std::string&gt; getStateNameString()
   {
     return 0;
@@ -289,4 +290,4 @@ private:
 };
 
 }  // state_machine
-#endif  // STATE_MACHINE_H
\ No newline at end of file
+#endif  // STATE_MACHINE_H
</diff>
			</file>
		</modified_files>
	</commit>
	<commit hash="b2a16cac8c8d843e80824d376935034fed8025ba" author="Yusuke FUJII">
		<msg>apply clang-format</msg>
		<modified_files>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state.hpp" added_lines="19" deleted_lines="19">
				<diff>@@ -14,25 +14,25 @@ class InitialState;
 class LocateVehicleState;
 
 class DriveState;
- //Accel/Brake subState
- class DriveAccAccelerationState;
- class DriveAccDecelerationState;
- class DriveAccKeepState;
- class DriveAccStopState;
- //Steering subState
- class DriveStrStraightState;
- class DriveStrLeftTurnState;
- class DriveStrRightTurnState;
-
- //Behavior subState
- class DriveBehaviorLaneChangeLeftState;
- class DriveBehaviorLaneChangeRightState;
- class DriveBehaviorObstacleAvoidanceState;
-
- //Perception subState
- class DriveDetectObstacleState;
- class DriveDetectStoplineState;
- class DriveDetectTrafficlightRedState;
+// Accel/Brake subState
+class DriveAccAccelerationState;
+class DriveAccDecelerationState;
+class DriveAccKeepState;
+class DriveAccStopState;
+// Steering subState
+class DriveStrStraightState;
+class DriveStrLeftTurnState;
+class DriveStrRightTurnState;
+
+// Behavior subState
+class DriveBehaviorLaneChangeLeftState;
+class DriveBehaviorLaneChangeRightState;
+class DriveBehaviorObstacleAvoidanceState;
+
+// Perception subState
+class DriveDetectObstacleState;
+class DriveDetectStoplineState;
+class DriveDetectTrafficlightRedState;
 
 class MissionCompleteState;
 class EmergencyState;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_context.hpp" added_lines="22" deleted_lines="23">
				<diff>@@ -16,23 +16,23 @@ namespace state_machine
 class StateContext
 {
 private:
-	class StateHolder{
-		public:
-			BaseState *MainState;
-			BaseState *AccState;
-			BaseState *StrState;
-			BaseState *BehaviorState;
-			BaseState *PerceptionState;
-			BaseState *OtherState;
-	} current_state_;
-	
-  std::vector&lt;BaseState **&gt; HolderList;
+  class StateHolder
+  {
+  public:
+    BaseState *MainState;
+    BaseState *AccState;
+    BaseState *StrState;
+    BaseState *BehaviorState;
+    BaseState *PerceptionState;
+    BaseState *OtherState;
+  } current_state_;
 
+  std::vector&lt;BaseState **&gt; HolderList;
 
   std::unordered_map&lt;uint64_t, BaseState *&gt; StateStores;
-  
+
   bool enableForceSetState;
-  //unsigned long long ChangeStateFlags;
+  // unsigned long long ChangeStateFlags;
   std::queue&lt;unsigned long long&gt; ChangeStateFlags;
   std::atomic&lt;bool&gt; thread_loop;
 
@@ -46,7 +46,6 @@ private:
 public:
   StateContext(void)
   {
-
     StateStores[START_STATE] = StartState::getInstance();
     StateStores[INITIAL_STATE] = InitialState::getInstance();
     StateStores[INITIAL_LOCATEVEHICLE_STATE] = LocateVehicleState::getInstance();
@@ -67,14 +66,15 @@ public:
     StateStores[MISSION_COMPLETE_STATE] = MissionCompleteState::getInstance();
     StateStores[EMERGENCY_STATE] = EmergencyState::getInstance();
 
-    HolderList.push_back(&amp;current_state_.MainState); 
-    HolderList.push_back(&amp;current_state_.AccState); 
-    HolderList.push_back(&amp;current_state_.StrState); 
-    HolderList.push_back(&amp;current_state_.BehaviorState); 
-    HolderList.push_back(&amp;current_state_.PerceptionState); 
-    HolderList.push_back(&amp;current_state_.OtherState); 
-    
-    for(auto &amp;&amp;p : HolderList){
+    HolderList.push_back(&amp;current_state_.MainState);
+    HolderList.push_back(&amp;current_state_.AccState);
+    HolderList.push_back(&amp;current_state_.StrState);
+    HolderList.push_back(&amp;current_state_.BehaviorState);
+    HolderList.push_back(&amp;current_state_.PerceptionState);
+    HolderList.push_back(&amp;current_state_.OtherState);
+
+    for (auto &amp;&amp;p : HolderList)
+    {
       *p = nullptr;
     }
 #if 0
@@ -100,7 +100,6 @@ public:
   bool isCurrentState(unsigned char _state_kind, unsigned long long _state_num);
   bool inState(unsigned long long _state_num);
 
-
   bool setCurrentState(StateFlags flag);
   bool setCurrentState(BaseState *state);
   bool disableCurrentState(unsigned long long);
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_drive.hpp" added_lines="1" deleted_lines="0">
				<diff>@@ -188,6 +188,7 @@ private:
     StateTransMask = DRIVE_STATE;
     StateKind = BEHAVIOR_STATE;
   }
+
 public:
 };
 
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" new_path="ros\src\computing\planning\decision\libs\libstate\include\state_flags.hpp" added_lines="1" deleted_lines="1">
				<diff>@@ -41,7 +41,7 @@ enum StateKinds
 
 enum TrafficLightColors
 {
-  E_RED = 0, 
+  E_RED = 0,
   E_YELLOW = 0,
   E_GREEN = 1,
   E_COLOR_ERROR = 2
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" new_path="ros\src\computing\planning\decision\libs\libstate\src\state_context.cpp" added_lines="96" deleted_lines="90">
				<diff>@@ -31,9 +31,11 @@ namespace state_machine
  */
 void StateContext::showCurrentStateName(void)
 {
-  for(auto &amp;&amp;p : HolderList){
-    if(*p){
-	(*p)-&gt;showStateName();
+  for (auto &amp;&amp;p : HolderList)
+  {
+    if (*p)
+    {
+      (*p)-&gt;showStateName();
     }
   }
 
@@ -75,36 +77,38 @@ bool StateContext::setCurrentState(BaseState *_state)
   {
     if (_state &amp;&amp; (enableForceSetState || (_state-&gt;getStateTransMask() &amp; prevState-&gt;getStateNum())))
     {
-	switch(_state-&gt;getStateKind()){
-		case MAIN_STATE:
-			current_state_.MainState = _state;
-			current_state_.AccState = nullptr;
-			current_state_.StrState = nullptr;
-			current_state_.BehaviorState = nullptr;
-			current_state_.PerceptionState = nullptr;
-			current_state_.OtherState = nullptr;
-			break;
-		case ACC_STATE:
-			current_state_.AccState = _state;
-			break;
-		case STR_STATE:
-			current_state_.StrState = _state;
-			break;
-		case BEHAVIOR_STATE:
-			current_state_.BehaviorState = _state;
-			break;
-		case PERCEPTION_STATE:
-			current_state_.PerceptionState = _state;
-			break;
-		case OTHER_STATE:
-			current_state_.OtherState = _state;
-			break;
-	}
-        std::cout &lt;&lt; "Successed to set state \"" &lt;&lt; prevState-&gt;getStateName() &lt;&lt; "\" to \""
-                  &lt;&lt; _state-&gt;getStateName() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/"
-                  &lt;&lt; prevState-&gt;getStateNum() &lt;&lt; "-" &lt;&lt; _state-&gt;getStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
+      switch (_state-&gt;getStateKind())
+      {
+        case MAIN_STATE:
+          current_state_.MainState = _state;
+          current_state_.AccState = nullptr;
+          current_state_.StrState = nullptr;
+          current_state_.BehaviorState = nullptr;
+          current_state_.PerceptionState = nullptr;
+          current_state_.OtherState = nullptr;
+          break;
+        case ACC_STATE:
+          current_state_.AccState = _state;
+          break;
+        case STR_STATE:
+          current_state_.StrState = _state;
+          break;
+        case BEHAVIOR_STATE:
+          current_state_.BehaviorState = _state;
+          break;
+        case PERCEPTION_STATE:
+          current_state_.PerceptionState = _state;
+          break;
+        case OTHER_STATE:
+          current_state_.OtherState = _state;
+          break;
       }
-    else{
+      std::cout &lt;&lt; "Successed to set state \"" &lt;&lt; prevState-&gt;getStateName() &lt;&lt; "\" to \"" &lt;&lt; _state-&gt;getStateName()
+                &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/" &lt;&lt; prevState-&gt;getStateNum() &lt;&lt; "-"
+                &lt;&lt; _state-&gt;getStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
+    }
+    else
+    {
       std::cerr &lt;&lt; "Failed to set state \"" &lt;&lt; current_state_.MainState-&gt;getStateName() &lt;&lt; "\" to \""
                 &lt;&lt; _state-&gt;getStateName() &lt;&lt; "\" : Mask is [" &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; "/"
                 &lt;&lt; current_state_.MainState-&gt;getStateNum() &lt;&lt; "-" &lt;&lt; _state-&gt;getStateNum() &lt;&lt; "]" &lt;&lt; std::endl;
@@ -117,13 +121,13 @@ bool StateContext::setCurrentState(BaseState *_state)
 
 bool StateContext::setCurrentState(StateFlags flag)
 {
-   this-&gt;setCurrentState(StateStores[flag]);
+  this-&gt;setCurrentState(StateStores[flag]);
 }
 
 bool StateContext::setEnableForceSetState(bool force_flag)
 {
-	enableForceSetState = force_flag;
-	return true;
+  enableForceSetState = force_flag;
+  return true;
 }
 
 BaseState *StateContext::getCurrentMainState(void)
@@ -139,65 +143,69 @@ BaseState *StateContext::getStateObject(unsigned long long _state_num)
 BaseState **StateContext::getCurrentStateHolderPtr(unsigned long long _state_num)
 {
   BaseState **state_ptr;
-  switch(getStateObject(_state_num)-&gt;getStateKind())
+  switch (getStateObject(_state_num)-&gt;getStateKind())
   {
-		case MAIN_STATE:
-			state_ptr = &amp;current_state_.MainState;
-			break;
-		case ACC_STATE:
-			state_ptr = &amp;current_state_.AccState;
-			break;
-		case STR_STATE:
-			state_ptr = &amp;current_state_.StrState;
-			break;
-		case BEHAVIOR_STATE:
-			state_ptr = &amp;current_state_.BehaviorState;
-			break;
-		case PERCEPTION_STATE:
-			state_ptr = &amp;current_state_.PerceptionState;
-			break;
-		case OTHER_STATE:
-			state_ptr = &amp;current_state_.OtherState;
-			break;
-		default:
-			state_ptr = nullptr;
-			break;
+    case MAIN_STATE:
+      state_ptr = &amp;current_state_.MainState;
+      break;
+    case ACC_STATE:
+      state_ptr = &amp;current_state_.AccState;
+      break;
+    case STR_STATE:
+      state_ptr = &amp;current_state_.StrState;
+      break;
+    case BEHAVIOR_STATE:
+      state_ptr = &amp;current_state_.BehaviorState;
+      break;
+    case PERCEPTION_STATE:
+      state_ptr = &amp;current_state_.PerceptionState;
+      break;
+    case OTHER_STATE:
+      state_ptr = &amp;current_state_.OtherState;
+      break;
+    default:
+      state_ptr = nullptr;
+      break;
   }
   return state_ptr;
-
 }
 
 bool StateContext::disableCurrentState(unsigned long long _state_num)
 {
   BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
-  if(state_ptr &amp;&amp; this-&gt;isState((*state_ptr), _state_num)){
-	  *state_ptr = nullptr;
-	  return true;
-  }else{
-	  return false;
+  if (state_ptr &amp;&amp; this-&gt;isState((*state_ptr), _state_num))
+  {
+    *state_ptr = nullptr;
+    return true;
+  }
+  else
+  {
+    return false;
   }
 }
 
-
 bool StateContext::isCurrentState(unsigned long long _state_num)
 {
   BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
-  return (*state_ptr)?(*state_ptr)-&gt;getStateNum() == _state_num?true:false:false;
- // return current_state_.MainState?current_state_.MainState-&gt;getStateNum() == _state_num?true:false:false;
+  return (*state_ptr) ? (*state_ptr)-&gt;getStateNum() == _state_num ? true : false : false;
+  // return current_state_.MainState?current_state_.MainState-&gt;getStateNum() == _state_num?true:false:false;
 }
 
 bool StateContext::isState(BaseState *base, unsigned long long _state_num)
 {
-  return base?base-&gt;getStateNum() == _state_num?true:false:false;
+  return base ? base-&gt;getStateNum() == _state_num ? true : false : false;
 }
 
 bool StateContext::inState(unsigned long long _state_num)
 {
-	if(current_state_.MainState){
-		return ((current_state_.MainState-&gt;getStateNum() &amp; _state_num) != 0)?true:false;
-	}else{
-		return false;
-	}
+  if (current_state_.MainState)
+  {
+    return ((current_state_.MainState-&gt;getStateNum() &amp; _state_num) != 0) ? true : false;
+  }
+  else
+  {
+    return false;
+  }
 }
 
 #define ANGLE_STRAIGHT 50.0
@@ -229,22 +237,20 @@ bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
   }
 }
 
-
 std::string StateContext::createStateMessageText(void)
 {
-	std::string ret;
-
-	for(auto &amp;&amp;p : HolderList){
-		if(*p){
-			ret = ret + "\n" + (*p)-&gt;getStateName();
-		}
-	}
-	return ret;
-
+  std::string ret;
 
+  for (auto &amp;&amp;p : HolderList)
+  {
+    if (*p)
+    {
+      ret = ret + "\n" + (*p)-&gt;getStateName();
+    }
+  }
+  return ret;
 }
 
-
 bool StateContext::handleTwistCmd(bool _hasTwistCmd)
 {
   if (_hasTwistCmd)
@@ -253,17 +259,17 @@ bool StateContext::handleTwistCmd(bool _hasTwistCmd)
     return false;
 }
 
-
 void StateContext::stateDecider(void)
 {
-// not running
+  // not running
   while (thread_loop)
   {
-	  if (!ChangeStateFlags.empty()){
-		  this-&gt;setCurrentState(StateStores[ChangeStateFlags.front()]);
-		  ChangeStateFlags.pop();
-	  }
-	  std::this_thread::sleep_for(std::chrono::microseconds(1000));
+    if (!ChangeStateFlags.empty())
+    {
+      this-&gt;setCurrentState(StateStores[ChangeStateFlags.front()]);
+      ChangeStateFlags.pop();
+    }
+    std::this_thread::sleep_for(std::chrono::microseconds(1000));
   }
   std::cerr &lt;&lt; "StateDecider thread will be closed" &lt;&lt; std::endl;
   return;
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_node.hpp" added_lines="10" deleted_lines="16">
				<diff>@@ -1,20 +1,19 @@
 #ifndef __DECISION_MAKER_NODE__
 #define __DECISION_MAKER_NODE__
 
-#include &lt;unordered_map&gt;
 #include &lt;mutex&gt;
+#include &lt;unordered_map&gt;
 
-
-#include &lt;autoware_msgs/lane.h&gt;
 #include &lt;autoware_msgs/ConfigDecisionMaker.h&gt;
+#include &lt;autoware_msgs/lane.h&gt;
 #include &lt;autoware_msgs/traffic_light.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 #include &lt;jsk_rviz_plugins/OverlayText.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
-#include &lt;std_msgs/String.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
+#include &lt;std_msgs/String.h&gt;
 
 //#include &lt;vector_map_server/GetCrossRoad.h&gt;
 
@@ -26,15 +25,13 @@
 #include &lt;geometry_msgs/Point.h&gt;
 
 // lib
+#include &lt;cross_road_area.hpp&gt;
 #include &lt;euclidean_space.hpp&gt;
 #include &lt;state.hpp&gt;
 #include &lt;state_context.hpp&gt;
-#include &lt;cross_road_area.hpp&gt;
-
 
 #include &lt;decision_maker_param.hpp&gt;
 
-
 //#include &lt;dynamic_reconfigure/server.h&gt;
 //#include &lt;decision_maker/decision_makerConfig.h&gt;
 
@@ -54,14 +51,14 @@ enum class E_ChangeFlags : int32_t
   STRAIGHT,
   LEFT,
   RIGHT,
-  
+
   UNKNOWN = -1,
 };
 
 template &lt;class T&gt;
 typename std::underlying_type&lt;T&gt;::type enumToInteger(T t)
 {
-	return static_cast&lt;typename std::underlying_type&lt;T&gt;::type&gt;(t);
+  return static_cast&lt;typename std::underlying_type&lt;T&gt;::type&gt;(t);
 }
 inline bool hasvMap(void)
 {
@@ -94,7 +91,7 @@ private:
   vector_map_msgs::PointArray vMap_Points;
   vector_map_msgs::LineArray vMap_Lines;
   vector_map_msgs::CrossRoadArray vMap_CrossRoads;
-  
+
   std::vector&lt;geometry_msgs::Point&gt; inside_points_;
 
   // Current way/behavior status
@@ -143,7 +140,7 @@ private:
   std::string createStateMessageText();
 
   // judge method
-  // in near future, these methods will be deprecate to decision_maker library 
+  // in near future, these methods will be deprecate to decision_maker library
   bool isInsideArea(geometry_msgs::Point pt);
   bool isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
   bool isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch, double _yaw);
@@ -169,7 +166,7 @@ private:
   void callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg);
   void callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg);
 
-  // in near future, these methods will be deprecate to ADAS library 
+  // in near future, these methods will be deprecate to ADAS library
   CrossRoadArea *findClosestCrossRoad(void);
 
 public:
@@ -179,7 +176,7 @@ public:
   {
     SimulationMode = false;
     enableDisplayMarker = DEFAULT_DISPLAY_FLAG;
-    param_convergence_threshold_ = DEFAULT_CONVERGENCE_THRESHOLD; 
+    param_convergence_threshold_ = DEFAULT_CONVERGENCE_THRESHOLD;
     param_convergence_count_ = DEFAULT_CONVERGENCE_COUNT;
     param_target_waypoint_ = DEFAULT_TARGET_WAYPOINT;
 
@@ -191,14 +188,11 @@ public:
 
     ClosestArea_ = nullptr;
     displacement_from_path_ = 0.0;
-
   }
 
   void run(void);
 };
 
-
-
 }  // namespace decision_maker
 
 #endif
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_param.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\decision_maker_param.hpp" added_lines="2" deleted_lines="10">
				<diff>@@ -1,8 +1,8 @@
 #ifndef __DECISION_MAKER_PARAM_HPP__
 #define __DECISION_MAKER_PARAM_HPP__
 
-namespace decision_maker{
-
+namespace decision_maker
+{
 //#define DEBUG_PRINT
 
 #define DEFAULT_DISPLAY_FLAG false
@@ -18,14 +18,6 @@ namespace decision_maker{
 #define ANGLE_STRAIGHT 50.0
 #define ANGLE_LEFT 360.0
 #define ANGLE_RIGHT 180.0
-
-
-
-
 }
 
-
-
-
 #endif
-
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\include\planner_selector.hpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\include\planner_selector.hpp" added_lines="5" deleted_lines="6">
				<diff>@@ -1,8 +1,8 @@
 #ifndef __PLANNER_SELECTOR_HPP__
 #define __PLANNER_SELECTOR_HPP__
 
-#include &lt;autoware_msgs/lane.h&gt;
 #include &lt;autoware_msgs/ConfigPlannerSelector.h&gt;
+#include &lt;autoware_msgs/lane.h&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
 
@@ -26,7 +26,6 @@ private:
   std::unordered_map&lt;std::string, ros::Publisher&gt; Pubs;
   std::unordered_map&lt;std::string, ros::Subscriber&gt; Subs;
 
-
   autoware_msgs::lane final_waypoints_dp_;
   autoware_msgs::lane final_waypoints_astar_;
 
@@ -40,12 +39,12 @@ private:
 
   int enableLattice_;
   bool pastWaypoint;
-  unsigned int 	config_latency_num_;
-  unsigned int 	config_waypoints_num_;
-  double 	config_convergence_num_;
+  unsigned int config_latency_num_;
+  unsigned int config_waypoints_num_;
+  double config_convergence_num_;
   double current_velocity_;
 
-  bool existWaypoints(const int _config_waypoints_num); 
+  bool existWaypoints(const int _config_waypoints_num);
 
 public:
   PlannerSelector()
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_callback.cpp" added_lines="60" deleted_lines="62">
				<diff>@@ -9,22 +9,21 @@
 #include &lt;autoware_msgs/traffic_light.h&gt;
 
 #include &lt;cross_road_area.hpp&gt;
-#include &lt;state.hpp&gt;
-#include &lt;state_context.hpp&gt;
 #include &lt;decision_maker_node.hpp&gt;
 #include &lt;euclidean_space.hpp&gt;
+#include &lt;state.hpp&gt;
+#include &lt;state_context.hpp&gt;
 
 namespace decision_maker
 {
-
-	// TODO for Decision_maker
-	// - lane_change
-	// - change substate class to state_context
-	// - fix a light_color_changed
-	// - disable/clear_subclassa
-	// - object detection
-	// - changed subscribing waypoint topic to base_waypoints from final_waypoints 
-	//
+// TODO for Decision_maker
+// - lane_change
+// - change substate class to state_context
+// - fix a light_color_changed
+// - disable/clear_subclassa
+// - object detection
+// - changed subscribing waypoint topic to base_waypoints from final_waypoints
+//
 
 void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
 {
@@ -32,58 +31,60 @@ void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped
   bool initLocalizationFlag = ctx-&gt;isCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
   if (initLocalizationFlag &amp;&amp;
       isLocalizationConvergence(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
-                             _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
+                                _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
   {
     ROS_INFO("Localization was convergence");
   }
 
-  //displacement_from_path_ =  getDisplacementFromPath(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z);
+  // displacement_from_path_ =  getDisplacementFromPath(_pose.pose.position.x, _pose.pose.position.y,
+  // _pose.pose.position.z);
 }
 
 bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
 {
-	return ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
+  return ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
 }
 
 void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
 {
-	ROS_INFO("Received forcing state changing request");
-	handleStateCmd((unsigned long long)msg.data);
+  ROS_INFO("Received forcing state changing request");
+  handleStateCmd((unsigned long long)msg.data);
 }
 
-
 void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
 {
-	if(msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
-		ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
-	else if(msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
-		ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
-	else{
-		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
-		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
-	}
+  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
+    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
+  else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
+    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
+  else
+  {
+    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
+    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
+  }
 }
 
 void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg)
 {
-	ROS_INFO("Param setted by Runtime Manager");
-	enableDisplayMarker = msg.enable_display_marker;
-	ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);
-	if(msg.enable_force_state_change){
-		if(msg.MainState_ChangeFlag)
-			handleStateCmd((unsigned long long)1 &lt;&lt; msg.MainState_ChangeFlag);
-		if(msg.SubState_Acc_ChangeFlag)
-			handleStateCmd(state_machine::DRIVE_ACC_ACCELERATION_STATE &lt;&lt; (msg.SubState_Acc_ChangeFlag-1));
-		if(msg.SubState_Str_ChangeFlag)
-			handleStateCmd(state_machine::DRIVE_STR_STRAIGHT_STATE &lt;&lt; (msg.SubState_Str_ChangeFlag-1));
-		if(msg.SubState_Behavior_ChangeFlag)
-			handleStateCmd(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE &lt;&lt; (msg.SubState_Behavior_ChangeFlag-1));
-		if(msg.SubState_Perception_ChangeFlag)
-			handleStateCmd(state_machine::DRIVE_DETECT_OBSTACLE_STATE &lt;&lt; (msg.SubState_Perception_ChangeFlag -1));
-	}
+  ROS_INFO("Param setted by Runtime Manager");
+  enableDisplayMarker = msg.enable_display_marker;
+  ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);
+  if (msg.enable_force_state_change)
+  {
+    if (msg.MainState_ChangeFlag)
+      handleStateCmd((unsigned long long)1 &lt;&lt; msg.MainState_ChangeFlag);
+    if (msg.SubState_Acc_ChangeFlag)
+      handleStateCmd(state_machine::DRIVE_ACC_ACCELERATION_STATE &lt;&lt; (msg.SubState_Acc_ChangeFlag - 1));
+    if (msg.SubState_Str_ChangeFlag)
+      handleStateCmd(state_machine::DRIVE_STR_STRAIGHT_STATE &lt;&lt; (msg.SubState_Str_ChangeFlag - 1));
+    if (msg.SubState_Behavior_ChangeFlag)
+      handleStateCmd(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE &lt;&lt; (msg.SubState_Behavior_ChangeFlag - 1));
+    if (msg.SubState_Perception_ChangeFlag)
+      handleStateCmd(state_machine::DRIVE_DETECT_OBSTACLE_STATE &lt;&lt; (msg.SubState_Perception_ChangeFlag - 1));
+  }
 }
 
-//void DecisionMakerNode::callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg)
+// void DecisionMakerNode::callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg)
 void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
 {
   const ros::M_string &amp;header = event.getConnectionHeader();
@@ -91,25 +92,24 @@ void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_
   const autoware_msgs::traffic_light *light = event.getMessage().get();
 
   current_traffic_light = light-&gt;traffic_light;
-  if(current_traffic_light == state_machine::E_RED ||
-	current_traffic_light == state_machine::E_YELLOW ){
-	ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
-  }else{
-	  ctx-&gt;disableCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
+  if (current_traffic_light == state_machine::E_RED || current_traffic_light == state_machine::E_YELLOW)
+  {
+    ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
+  }
+  else
+  {
+    ctx-&gt;disableCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
   }
-  //ctx-&gt;handleTrafficLight(CurrentTrafficlight);
+  // ctx-&gt;handleTrafficLight(CurrentTrafficlight);
 }
 
 //
 void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
 {
-	if(ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
-		Subs["points_raw"].shutdown();
+  if (ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
+    Subs["points_raw"].shutdown();
 }
 
-
-
-
 void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
 {
   if (!hasvMap())
@@ -119,7 +119,7 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
   }
   if (!ctx-&gt;isCurrentState(state_machine::DRIVE_STATE))
   {
-    std::cerr &lt;&lt; "State is not DRIVE_STATE["&lt;&lt; ctx-&gt;getCurrentStateName() &lt;&lt;"]" &lt;&lt; std::endl;
+    std::cerr &lt;&lt; "State is not DRIVE_STATE[" &lt;&lt; ctx-&gt;getCurrentStateName() &lt;&lt; "]" &lt;&lt; std::endl;
     return;
   }
 
@@ -132,11 +132,11 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
   // between first-waypoint and end-waypoint in intersection area.
   int temp = (int)std::floor(intersect_wayangle + 360.0) % 360;
   if (std::abs(temp) &lt;= ANGLE_STRAIGHT)
-	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_STRAIGHT_STATE);
+    ctx-&gt;setCurrentState(state_machine::DRIVE_STR_STRAIGHT_STATE);
   else if (temp &lt;= ANGLE_RIGHT)
-	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
+    ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
   else if (temp &lt;= ANGLE_LEFT)
-	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
+    ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
 
   // velocity
   double _temp_sum = 0;
@@ -145,13 +145,13 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
     _temp_sum += mps2kmph(msg.waypoints[i].twist.twist.linear.x);
   }
   average_velocity_ = _temp_sum / VEL_AVERAGE_COUNT;
-  
+
   if (std::fabs(average_velocity_ - current_velocity_) &lt;= 2.0)
-	  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE);
+    ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE);
   else if (average_velocity_ - current_velocity_)
-	  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE);
+    ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE);
   else
-	  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE);
+    ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE);
 
   // for publish plan of velocity
   publishToVelocityArray();
@@ -159,7 +159,6 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
 #ifdef DEBUG_PRINT
   std::cout &lt;&lt; "Velocity: " &lt;&lt; current_velocity_ &lt;&lt; " to " &lt;&lt; average_velocity_ &lt;&lt; std::endl;
 #endif
-
 }
 void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
 {
@@ -169,7 +168,6 @@ void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;
     ctx-&gt;handleTwistCmd(false);
   else
     Twistflag = true;
-
 }
 
 void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_core.cpp" added_lines="5" deleted_lines="8">
				<diff>@@ -25,7 +25,6 @@
 
 namespace decision_maker
 {
-
 CrossRoadArea *DecisionMakerNode::findClosestCrossRoad(void)
 {
   CrossRoadArea *_area = nullptr;
@@ -92,10 +91,8 @@ bool DecisionMakerNode::isInsideArea(geometry_msgs::Point pt)
   return false;
 }
 
-
-
 bool DecisionMakerNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg,
-                                                    const geometry_msgs::PoseStamped &amp;pose_msg)
+                                                     const geometry_msgs::PoseStamped &amp;pose_msg)
 {
 #ifdef USE_VMAP_SERVER  // this is not successfully run
   cross_road_srv.request.pose = pose_msg;
@@ -112,13 +109,13 @@ bool DecisionMakerNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;
 
   for (const auto &amp;cross_road_d : cross_road_srv.response.objects.data)
   {
- //   std::cout &lt;&lt; "EEEEEEEEE" &lt;&lt; cross_road_d.linkid &lt;&lt; std::endl;
+    //   std::cout &lt;&lt; "EEEEEEEEE" &lt;&lt; cross_road_d.linkid &lt;&lt; std::endl;
   }
 #endif
 }
 
 double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_msg,
-                                               const geometry_msgs::PoseStamped &amp;pose_msg)
+                                                const geometry_msgs::PoseStamped &amp;pose_msg)
 {
   if (vMap_CrossRoads_flag)
   {
@@ -208,8 +205,8 @@ void DecisionMakerNode::run(void)
   while (ros::ok())
   {
     update();
-    if(enableDisplayMarker)
-	    displayMarker();
+    if (enableDisplayMarker)
+      displayMarker();
     loop_rate.sleep();
   }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_decision.cpp" added_lines="15" deleted_lines="12">
				<diff>@@ -9,14 +9,15 @@
 #include &lt;autoware_msgs/traffic_light.h&gt;
 
 #include &lt;cross_road_area.hpp&gt;
-#include &lt;state.hpp&gt;
-#include &lt;state_context.hpp&gt;
 #include &lt;decision_maker_node.hpp&gt;
 #include &lt;euclidean_space.hpp&gt;
+#include &lt;state.hpp&gt;
+#include &lt;state_context.hpp&gt;
 
 namespace decision_maker
 {
-bool DecisionMakerNode::isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch, double _yaw)
+bool DecisionMakerNode::isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch,
+                                                  double _yaw)
 {
   static int _init_count = 0;
   static euclidean_space::point *a = new euclidean_space::point();
@@ -35,15 +36,17 @@ bool DecisionMakerNode::isLocalizationConvergence(double _x, double _y, double _
   b-&gt;z = _z;
 
   distances.push_back(euclidean_space::EuclideanSpace::find_distance(a, b));
-  if(++distances_count &gt; param_convergence_count_){
-	  distances.erase(distances.begin());
-	  distances_count--;
-	  avg_distances = std::accumulate(distances.begin(), distances.end(), 0) / distances.size();
-	  if (avg_distances &lt;= param_convergence_threshold_)
-		  return ctx-&gt;setCurrentState(state_machine::DRIVE_STATE);
-  }else{
-	  return false;
+  if (++distances_count &gt; param_convergence_count_)
+  {
+    distances.erase(distances.begin());
+    distances_count--;
+    avg_distances = std::accumulate(distances.begin(), distances.end(), 0) / distances.size();
+    if (avg_distances &lt;= param_convergence_threshold_)
+      return ctx-&gt;setCurrentState(state_machine::DRIVE_STATE);
+  }
+  else
+  {
+    return false;
   }
-
 }
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_init.cpp" added_lines="155" deleted_lines="155">
				<diff>@@ -24,166 +24,166 @@
 #include &lt;geometry_msgs/Pose.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 
+namespace decision_maker
+{
+void DecisionMakerNode::initStateMsgs(void)
+{
+}
+
+void DecisionMakerNode::initROS(int argc, char **argv)
+{
+  // status subscriber
+  Subs["current_pose"] = nh_.subscribe("current_pose", 20, &amp;DecisionMakerNode::callbackFromCurrentPose, this);
+  Subs["current_velocity"] =
+      nh_.subscribe("current_velocity", 20, &amp;DecisionMakerNode::callbackFromCurrentVelocity, this);
+  Subs["light_color"] = nh_.subscribe("light_color", 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
+  Subs["light_color_managed"] =
+      nh_.subscribe("light_color_managed", 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
+  Subs["points_raw"] = nh_.subscribe("filtered_points", 1, &amp;DecisionMakerNode::callbackFromPointsRaw, this);
+  Subs["final_waypoints"] = nh_.subscribe("final_waypoints", 100, &amp;DecisionMakerNode::callbackFromFinalWaypoint, this);
+  Subs["twist_cmd"] = nh_.subscribe("twist_cmd", 10, &amp;DecisionMakerNode::callbackFromTwistCmd, this);
+  Subs["change_flag"] = nh_.subscribe("change_flag", 1, &amp;DecisionMakerNode::callbackFromLaneChangeFlag, this);
+
+  // vector map subscriber
+  Subs["vector_map_area"] =
+      nh_.subscribe("/vector_map_info/area", 1, &amp;DecisionMakerNode::callbackFromVectorMapArea, this);
+  Subs["vector_map_point"] =
+      nh_.subscribe("/vector_map_info/point", 1, &amp;DecisionMakerNode::callbackFromVectorMapPoint, this);
+  Subs["vector_map_line"] =
+      nh_.subscribe("/vector_map_info/line", 1, &amp;DecisionMakerNode::callbackFromVectorMapLine, this);
+  Subs["vector_map_crossroad"] =
+      nh_.subscribe("/vector_map_info/cross_road", 1, &amp;DecisionMakerNode::callbackFromVectorMapCrossRoad, this);
+
+  // Config subscriber
+  Subs["config/decision_maker"] =
+      nh_.subscribe("/config/decision_maker", 3, &amp;DecisionMakerNode::callbackFromConfig, this);
+
+  // pub
+  Pubs["state"] = nh_.advertise&lt;std_msgs::String&gt;("state", 1);
+  Pubs["state_overlay"] = nh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;("/state/overlay_text", 1);
+
+  Pubs["state_local_diffdistance"] = nh_.advertise&lt;std_msgs::Float64&gt;("/state/val_diff_distance", 1);
+
+  Pubs["crossroad_visual"] = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("/state/cross_road_marker", 1);
+  Pubs["crossroad_inside_visual"] = nh_.advertise&lt;visualization_msgs::Marker&gt;("/state/cross_inside_marker", 1);
+  Pubs["crossroad_bbox"] = nh_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("/state/bbox", 10);
+  Pubs["target_velocity_array"] = nh_.advertise&lt;std_msgs::Float64MultiArray&gt;("/target_velocity_array", 1);
+
+  // message setup
+  state_text_msg.text_size = 18;
+  state_text_msg.line_width = 0;
+  state_text_msg.font = "DejaVu Sans Mono";
+  state_text_msg.width = 500;
+  state_text_msg.height = 50;
+  state_text_msg.top = 10;
+  state_text_msg.left = 10;
+  state_text_msg.text = "UNDEFINED";
+
+  // initial publishing state message
+  update_msgs();
+
+  // to move initial state from start state
+  // this part confirm broadcasting tf(map to world)
+  {
+    std::cout &lt;&lt; "wait for tf of map to world" &lt;&lt; std::endl;
+    tf::TransformListener tf;
+    tf.waitForTransform("map", "world", ros::Time(), ros::Duration(999));
+
+    if (!ctx-&gt;TFInitialized())
+      std::cerr &lt;&lt; "failed initialization " &lt;&lt; std::endl;
+  }
+  {
+    initVectorMapClient();
+    if (enableDisplayMarker)
+      displayMarker();
+  }
+}
 
-namespace decision_maker{
-
-
-
-	void DecisionMakerNode::initStateMsgs(void)
-	{
-	}
-
-	void DecisionMakerNode::initROS(int argc, char **argv)
-	{
-		// status subscriber
-		Subs["current_pose"] = nh_.subscribe("current_pose", 20, &amp;DecisionMakerNode::callbackFromCurrentPose, this);
-		Subs["current_velocity"] =
-			nh_.subscribe("current_velocity", 20, &amp;DecisionMakerNode::callbackFromCurrentVelocity, this);
-		Subs["light_color"] = nh_.subscribe("light_color", 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
-		Subs["light_color_managed"] = nh_.subscribe("light_color_managed", 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
-		Subs["points_raw"] = nh_.subscribe("filtered_points", 1, &amp;DecisionMakerNode::callbackFromPointsRaw, this);
-		Subs["final_waypoints"] = nh_.subscribe("final_waypoints", 100, &amp;DecisionMakerNode::callbackFromFinalWaypoint, this);
-		Subs["twist_cmd"] = nh_.subscribe("twist_cmd", 10, &amp;DecisionMakerNode::callbackFromTwistCmd, this);
-		Subs["change_flag"] = nh_.subscribe("change_flag", 1, &amp;DecisionMakerNode::callbackFromLaneChangeFlag, this);
-
-		// vector map subscriber
-		Subs["vector_map_area"] =
-			nh_.subscribe("/vector_map_info/area", 1, &amp;DecisionMakerNode::callbackFromVectorMapArea, this);
-		Subs["vector_map_point"] =
-			nh_.subscribe("/vector_map_info/point", 1, &amp;DecisionMakerNode::callbackFromVectorMapPoint, this);
-		Subs["vector_map_line"] =
-			nh_.subscribe("/vector_map_info/line", 1, &amp;DecisionMakerNode::callbackFromVectorMapLine, this);
-		Subs["vector_map_crossroad"] =
-			nh_.subscribe("/vector_map_info/cross_road", 1, &amp;DecisionMakerNode::callbackFromVectorMapCrossRoad, this);
-
-		// Config subscriber
-		Subs["config/decision_maker"] = nh_.subscribe("/config/decision_maker", 3, &amp;DecisionMakerNode::callbackFromConfig, this);
-
-		// pub
-		Pubs["state"] = nh_.advertise&lt;std_msgs::String&gt;("state", 1);
-		Pubs["state_overlay"] = nh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;("/state/overlay_text", 1);
-
-		Pubs["state_local_diffdistance"] = nh_.advertise&lt;std_msgs::Float64&gt;("/state/val_diff_distance", 1);
-
-		Pubs["crossroad_visual"] = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;("/state/cross_road_marker", 1);
-		Pubs["crossroad_inside_visual"] = nh_.advertise&lt;visualization_msgs::Marker&gt;("/state/cross_inside_marker", 1);
-		Pubs["crossroad_bbox"] = nh_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;("/state/bbox", 10);
-		Pubs["target_velocity_array"] = nh_.advertise&lt;std_msgs::Float64MultiArray&gt;("/target_velocity_array",1);
-
-		// message setup
-		state_text_msg.text_size = 18;
-		state_text_msg.line_width = 0;
-		state_text_msg.font = "DejaVu Sans Mono";
-		state_text_msg.width = 500;
-		state_text_msg.height = 50;
-		state_text_msg.top = 10;
-		state_text_msg.left = 10;
-		state_text_msg.text = "UNDEFINED";
-
-		// initial publishing state message
-		update_msgs();
-
-		// to move initial state from start state
-		// this part confirm broadcasting tf(map to world)
-		{
-			std::cout &lt;&lt; "wait for tf of map to world" &lt;&lt; std::endl;
-			tf::TransformListener tf;
-			tf.waitForTransform("map", "world", ros::Time(), ros::Duration(999));
-
-			if (!ctx-&gt;TFInitialized())
-				std::cerr &lt;&lt; "failed initialization " &lt;&lt; std::endl;
-		}
-		{
-			initVectorMapClient();
-			if(enableDisplayMarker)
-				displayMarker();
-		}
-	}
-
-	void DecisionMakerNode::initVectorMap(void)
-	{
-		if(!vector_map_init){
-			vMap_mutex.lock();
-				if (!vector_map_init &amp;&amp; vMap_Areas_flag &amp; vMap_Points_flag &amp; vMap_Lines_flag &amp; vMap_CrossRoads_flag)
-				{
-					vector_map_init = true;
-
-					int _index = 0;
-
-					for (const auto &amp;cross_road : vMap_CrossRoads.data)
-					{
-						for (const auto &amp;area : vMap_Areas.data)
-						{
-							if (cross_road.aid == area.aid)
-							{
-								CrossRoadArea carea;
-								carea.id = _index++;
-								carea.area_id = area.aid;
-
-								double x_avg = 0.0, x_min = 0.0, x_max = 0.0;
-								double y_avg = 0.0, y_min = 0.0, y_max = 0.0;
-								double z = 0.0;
-
-								int points_count = 0;
-								for (const auto &amp;line : vMap_Lines.data)
-								{
-									if (area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid)
-									{
-										for (const auto &amp;point : vMap_Points.data)
-										{
-											if (line.fpid &lt;= point.pid &amp;&amp; point.pid &lt;= line.fpid)
-											{
-												geometry_msgs::Point _point;
-												_point.x = point.ly;
-												_point.y = point.bx;
-												_point.z = point.h;
-
-												x_avg += _point.x;
-												y_avg += _point.y;
-
-												x_min = (x_min == 0.0) ? _point.x : std::min(_point.x, x_min);
-												x_max = (x_max == 0.0) ? _point.x : std::max(_point.x, x_max);
-												y_min = (y_min == 0.0) ? _point.y : std::min(_point.y, y_min);
-												y_max = (y_max == 0.0) ? _point.y : std::max(_point.y, y_max);
-												z = _point.z;
-												points_count++;
-
-												carea.points.push_back(_point);
-											}  // if pid
-										}    // points iter
-									}      // if lid
-								}        // line iter
-								carea.bbox.pose.position.x = x_avg / (double)points_count;
-								carea.bbox.pose.position.y = y_avg / (double)points_count;
-								carea.bbox.pose.position.z = z;
-								carea.bbox.dimensions.x = x_max - x_min;
-								carea.bbox.dimensions.y = y_max - y_min;
-								carea.bbox.dimensions.z = 2;
-								carea.bbox.label = 1;
-								intersects.push_back(carea);
-							}
-						}
-					}
-				}
-			vMap_mutex.unlock();
-		}
-	}
-
-	bool DecisionMakerNode::initVectorMapClient()
-	{
+void DecisionMakerNode::initVectorMap(void)
+{
+  if (!vector_map_init)
+  {
+    vMap_mutex.lock();
+    if (!vector_map_init &amp;&amp; vMap_Areas_flag &amp; vMap_Points_flag &amp; vMap_Lines_flag &amp; vMap_CrossRoads_flag)
+    {
+      vector_map_init = true;
+
+      int _index = 0;
+
+      for (const auto &amp;cross_road : vMap_CrossRoads.data)
+      {
+        for (const auto &amp;area : vMap_Areas.data)
+        {
+          if (cross_road.aid == area.aid)
+          {
+            CrossRoadArea carea;
+            carea.id = _index++;
+            carea.area_id = area.aid;
+
+            double x_avg = 0.0, x_min = 0.0, x_max = 0.0;
+            double y_avg = 0.0, y_min = 0.0, y_max = 0.0;
+            double z = 0.0;
+
+            int points_count = 0;
+            for (const auto &amp;line : vMap_Lines.data)
+            {
+              if (area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid)
+              {
+                for (const auto &amp;point : vMap_Points.data)
+                {
+                  if (line.fpid &lt;= point.pid &amp;&amp; point.pid &lt;= line.fpid)
+                  {
+                    geometry_msgs::Point _point;
+                    _point.x = point.ly;
+                    _point.y = point.bx;
+                    _point.z = point.h;
+
+                    x_avg += _point.x;
+                    y_avg += _point.y;
+
+                    x_min = (x_min == 0.0) ? _point.x : std::min(_point.x, x_min);
+                    x_max = (x_max == 0.0) ? _point.x : std::max(_point.x, x_max);
+                    y_min = (y_min == 0.0) ? _point.y : std::min(_point.y, y_min);
+                    y_max = (y_max == 0.0) ? _point.y : std::max(_point.y, y_max);
+                    z = _point.z;
+                    points_count++;
+
+                    carea.points.push_back(_point);
+                  }  // if pid
+                }    // points iter
+              }      // if lid
+            }        // line iter
+            carea.bbox.pose.position.x = x_avg / (double)points_count;
+            carea.bbox.pose.position.y = y_avg / (double)points_count;
+            carea.bbox.pose.position.z = z;
+            carea.bbox.dimensions.x = x_max - x_min;
+            carea.bbox.dimensions.y = y_max - y_min;
+            carea.bbox.dimensions.z = 2;
+            carea.bbox.label = 1;
+            intersects.push_back(carea);
+          }
+        }
+      }
+    }
+    vMap_mutex.unlock();
+  }
+}
+
+bool DecisionMakerNode::initVectorMapClient()
+{
 #ifdef USE_VMAP_SERVER  // This is not successfully run due to failing vmap
-		// server
+  // server
 
-		vector_map::VectorMap vmap;
-		vmap.subscribe(nh_, vector_map::Category::AREA, ros::Duration(0));
+  vector_map::VectorMap vmap;
+  vmap.subscribe(nh_, vector_map::Category::AREA, ros::Duration(0));
 
-		cross_road_srv.request.pose = current_pose_;
-		cross_road_srv.request.waypoints = current_finalwaypoints_;
+  cross_road_srv.request.pose = current_pose_;
+  cross_road_srv.request.waypoints = current_finalwaypoints_;
 
-		cross_road_cli = nh_.serviceClient&lt;vector_map_server::GetCrossRoad&gt;("vector_map_server/get_cross_road");
+  cross_road_cli = nh_.serviceClient&lt;vector_map_server::GetCrossRoad&gt;("vector_map_server/get_cross_road");
 
-		return cross_road_cli.call(cross_road_srv);
+  return cross_road_cli.call(cross_road_srv);
 #endif
-		return false;
-	}
+  return false;
+}
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\decision_maker\decision_maker_node_publish.cpp" added_lines="6" deleted_lines="7">
				<diff>@@ -24,14 +24,12 @@
 
 namespace decision_maker
 {
-
 void DecisionMakerNode::update_pubsub(void)
 {
   // if state machine require to re-subscribe topic,
   // this function will re-definition subscriber.
 }
 
-
 void DecisionMakerNode::displayMarker(void)
 {
   // vector_map init
@@ -126,7 +124,7 @@ void DecisionMakerNode::update_msgs(void)
 
 std::string DecisionMakerNode::createStateMessageText()
 {
-	return ctx-&gt;createStateMessageText();
+  return ctx-&gt;createStateMessageText();
 }
 
 void DecisionMakerNode::publishToVelocityArray()
@@ -134,11 +132,12 @@ void DecisionMakerNode::publishToVelocityArray()
   int count = 0;
   std_msgs::Float64MultiArray msg;
 
-  for(const auto &amp;i : current_finalwaypoints_.waypoints ){
-	  msg.data.push_back(mps2kmph(i.twist.twist.linear.x));
-	  if(++count&gt;=10)break;
+  for (const auto &amp;i : current_finalwaypoints_.waypoints)
+  {
+    msg.data.push_back(mps2kmph(i.twist.twist.linear.x));
+    if (++count &gt;= 10)
+      break;
   }
   Pubs["target_velocity_array"].publish(msg);
 }
-
 }
</diff>
			</file>
			<file old_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\planner_selector\planner_selector_node.cpp" new_path="ros\src\computing\planning\decision\packages\decision_maker\nodes\planner_selector\planner_selector_node.cpp" added_lines="100" deleted_lines="87">
				<diff>@@ -1,5 +1,5 @@
-#include &lt;autoware_msgs/lane.h&gt;
 #include &lt;autoware_msgs/ConfigPlannerSelector.h&gt;
+#include &lt;autoware_msgs/lane.h&gt;
 #include &lt;ros/ros.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
 
@@ -14,60 +14,61 @@ namespace decision_maker
 {
 void PlannerSelector::initROS()
 {
-  Subs["/dp/final_waypoints"] =
-      nh_.subscribe("/dp/final_waypoints", 1, &amp;PlannerSelector::callbackFromWaypoints, this);
+  Subs["/dp/final_waypoints"] = nh_.subscribe("/dp/final_waypoints", 1, &amp;PlannerSelector::callbackFromWaypoints, this);
   Subs["/astar/final_waypoints"] =
       nh_.subscribe("/astar/final_waypoints", 1, &amp;PlannerSelector::callbackFromWaypoints, this);
   Subs["/enableLattice"] = nh_.subscribe("/enableLattice", 10, &amp;PlannerSelector::callbackFromLattice, this);
 
-  Subs["/dp/closest_waypoint"] =
-      nh_.subscribe("/dp/closest_waypoint", 1, &amp;PlannerSelector::callbackFromClosest, this);
+  Subs["/dp/closest_waypoint"] = nh_.subscribe("/dp/closest_waypoint", 1, &amp;PlannerSelector::callbackFromClosest, this);
   Subs["/astar/closest_waypoint"] =
       nh_.subscribe("/astar/closest_waypoint", 1, &amp;PlannerSelector::callbackFromClosest, this);
 
-  Subs["/config/planner_selector"] = nh_.subscribe("/config/PlannerSelector", 1, &amp;PlannerSelector::callbackFromConfig, this);
+  Subs["/config/planner_selector"] =
+      nh_.subscribe("/config/PlannerSelector", 1, &amp;PlannerSelector::callbackFromConfig, this);
 
-  Subs["current_velocity"] =
-      nh_.subscribe("current_velocity", 3, &amp;PlannerSelector::callbackFromCurrentVelocity, this);
-  
-Pubs["final_waypoints"] = nh_.advertise&lt;autoware_msgs::lane&gt;("/final_waypoints", 1);
+  Subs["current_velocity"] = nh_.subscribe("current_velocity", 3, &amp;PlannerSelector::callbackFromCurrentVelocity, this);
+
+  Pubs["final_waypoints"] = nh_.advertise&lt;autoware_msgs::lane&gt;("/final_waypoints", 1);
   Pubs["closest_waypoint"] = nh_.advertise&lt;std_msgs::Int32&gt;("/closest_waypoint", 1);
 }
 
 inline bool PlannerSelector::existWaypoints(const int _config_waypoints_num)
 {
-	bool ret;
-	ret = ( _config_waypoints_num &lt; final_waypoints_dp_.waypoints.size() ) 
-		&amp;&amp; ( _config_waypoints_num &lt; final_waypoints_dp_.waypoints.size() ) ;
-	return ret;
+  bool ret;
+  ret = (_config_waypoints_num &lt; final_waypoints_dp_.waypoints.size()) &amp;&amp;
+        (_config_waypoints_num &lt; final_waypoints_dp_.waypoints.size());
+  return ret;
 }
 
 void PlannerSelector::callbackFromLattice(const std_msgs::Int32 &amp;msg)
 {
-  //static int prev[LATENCY_NUM] = { 1 };
-  static int counter = 0;  
+  // static int prev[LATENCY_NUM] = { 1 };
+  static int counter = 0;
   double _distance = 100.0;
 
-  try{
-	  autoware_msgs::waypoint dp_point = final_waypoints_dp_.waypoints.at(config_waypoints_num_);
-	  autoware_msgs::waypoint astar_point = final_waypoints_astar_.waypoints.at(config_waypoints_num_);
+  try
+  {
+    autoware_msgs::waypoint dp_point = final_waypoints_dp_.waypoints.at(config_waypoints_num_);
+    autoware_msgs::waypoint astar_point = final_waypoints_astar_.waypoints.at(config_waypoints_num_);
 
-	  euclidean_space::point p_dp, p_astar;
-	  p_dp.x = dp_point.pose.pose.position.x;
-	  p_dp.x = dp_point.pose.pose.position.y;
-	  p_dp.z = 0.0;
+    euclidean_space::point p_dp, p_astar;
+    p_dp.x = dp_point.pose.pose.position.x;
+    p_dp.x = dp_point.pose.pose.position.y;
+    p_dp.z = 0.0;
 
-	  p_astar.x = astar_point.pose.pose.position.x;
-	  p_astar.x = astar_point.pose.pose.position.y;
-	  p_astar.z = 0.0;
+    p_astar.x = astar_point.pose.pose.position.x;
+    p_astar.x = astar_point.pose.pose.position.y;
+    p_astar.z = 0.0;
 
-	  _distance = euclidean_space::EuclideanSpace::find_distance(&amp;p_dp, &amp;p_astar);
-	  //  ROS_INFO("distance=%f. %d:%d", _distance, dp_point.dtlane.dist,astar_point.dtlane.dist);
-  }catch(const std::out_of_range &amp;ex){
-	  ROS_ERROR("Out of Range:%s", ex.what() );
+    _distance = euclidean_space::EuclideanSpace::find_distance(&amp;p_dp, &amp;p_astar);
+    //  ROS_INFO("distance=%f. %d:%d", _distance, dp_point.dtlane.dist,astar_point.dtlane.dist);
+  }
+  catch (const std::out_of_range &amp;ex)
+  {
+    ROS_ERROR("Out of Range:%s", ex.what());
   }
 
-#if 0 // delay switch
+#if 0  // delay switch
   _mutex.lock();
   if(enableLattice_){
 	  if (msg.data == 0){
@@ -83,29 +84,33 @@ void PlannerSelector::callbackFromLattice(const std_msgs::Int32 &amp;msg)
   _mutex.unlock();
 #else
   _mutex.lock();
-  if (msg.data != enableLattice_){
-	  if(enableLattice_ == 1 &amp;&amp; msg.data == 0){
-		  if(pastWaypoint == false){
-			  pastWaypoint  = true;
-			  counter = 0;
-			  way_offset = config_waypoints_num_;
-		  }
-	  }
-	  enableLattice_ = msg.data;
+  if (msg.data != enableLattice_)
+  {
+    if (enableLattice_ == 1 &amp;&amp; msg.data == 0)
+    {
+      if (pastWaypoint == false)
+      {
+        pastWaypoint = true;
+        counter = 0;
+        way_offset = config_waypoints_num_;
+      }
+    }
+    enableLattice_ = msg.data;
   }
-  if(counter++ &gt;= config_latency_num_)
+  if (counter++ &gt;= config_latency_num_)
   {
-	  counter = 0;
-	  if(way_offset&gt;0){
-		  way_offset--;
-	  }else{
-		  pastWaypoint = false;
-	  }
+    counter = 0;
+    if (way_offset &gt; 0)
+    {
+      way_offset--;
+    }
+    else
+    {
+      pastWaypoint = false;
+    }
   }
 
-
-
-  //ROS_INFO("msg.data=%d, enableLattice_ = %d", msg.data, enableLattice_);
+  // ROS_INFO("msg.data=%d, enableLattice_ = %d", msg.data, enableLattice_);
   _mutex.unlock();
 #endif
   // for debug
@@ -131,15 +136,18 @@ void PlannerSelector::callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msg
   }
   else if (!this-&gt;enableLattice_ &amp;&amp; topic.find("astar") != std::string::npos)
   {
-    if(pastWaypoint){
-	    for(int i=0; i &lt; config_waypoints_num_; i++){
-		    if(!final_waypoints_astar_.waypoints.empty())
-			    final_waypoints_astar_.waypoints.erase(final_waypoints_astar_.waypoints.begin());
-		    else{
-			    pastWaypoint = false;
-			    way_offset=0;
-		    }
-	    }
+    if (pastWaypoint)
+    {
+      for (int i = 0; i &lt; config_waypoints_num_; i++)
+      {
+        if (!final_waypoints_astar_.waypoints.empty())
+          final_waypoints_astar_.waypoints.erase(final_waypoints_astar_.waypoints.begin());
+        else
+        {
+          pastWaypoint = false;
+          way_offset = 0;
+        }
+      }
 #if 0
 	    if(final_waypoints_astar_.waypoints.empty()){
 		    int _size = final_waypoints_astar_.waypoints.size();
@@ -152,34 +160,35 @@ void PlannerSelector::callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msg
 		    }
 	    }
 #endif
-	    Pubs["final_waypoints"].publish(final_waypoints_astar_);
-    }else{
-	    Pubs["final_waypoints"].publish(*waypoints);
+      Pubs["final_waypoints"].publish(final_waypoints_astar_);
+    }
+    else
+    {
+      Pubs["final_waypoints"].publish(*waypoints);
     }
     final_waypoints_astar_ = *waypoints;
   }
 
-  //for debug
-  //ROS_INFO("%s, %d-%d-%d", topic.c_str(), closest_waypoint_dp_, closest_waypoint_astar_, this-&gt;enableLattice_);
+  // for debug
+  // ROS_INFO("%s, %d-%d-%d", topic.c_str(), closest_waypoint_dp_, closest_waypoint_astar_, this-&gt;enableLattice_);
   _mutex.unlock();
 }
 
 void PlannerSelector::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
 {
-	current_velocity_ = msg.twist.linear.x;
+  current_velocity_ = msg.twist.linear.x;
 }
 
 void PlannerSelector::callbackFromConfig(const autoware_msgs::ConfigPlannerSelector &amp;msg)
 {
-	config_latency_num_ = msg.latency_num;
-	config_waypoints_num_ = msg.waypoints_num;
-	config_convergence_num_ = msg.convergence_num;
+  config_latency_num_ = msg.latency_num;
+  config_waypoints_num_ = msg.waypoints_num;
+  config_convergence_num_ = msg.convergence_num;
 
-	ROS_INFO("PARAM_SET-latency:%d, waypoints:%d, convergence:%f", config_latency_num_, config_waypoints_num_, config_convergence_num_);
+  ROS_INFO("PARAM_SET-latency:%d, waypoints:%d, convergence:%f", config_latency_num_, config_waypoints_num_,
+           config_convergence_num_);
 }
 
-
-
 void PlannerSelector::callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int32&gt; &amp;event)
 {
   const ros::M_string &amp;header = event.getConnectionHeader();
@@ -191,25 +200,29 @@ void PlannerSelector::callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int3
 #if 1
   if (topic.find("/dp") == 0)
   {
-	  closest_waypoints_["dp"] = temp;
+    closest_waypoints_["dp"] = temp;
 
-	  if (closest_waypoints_["astar"])
-	  {
-		  msg.data = closest_waypoint_astar_;
-	  }
-	  closest_waypoint_dp_ = temp;
+    if (closest_waypoints_["astar"])
+    {
+      msg.data = closest_waypoint_astar_;
+    }
+    closest_waypoint_dp_ = temp;
   }
   else if (topic.find("/astar") == 0)
   {
-	  closest_waypoints_["astar"] = temp;
-	  closest_waypoint_astar_ = temp;
+    closest_waypoints_["astar"] = temp;
+    closest_waypoint_astar_ = temp;
   }
 
-  //  ROS_INFO("PastWaypoint:%s-offset:%d, latency:%d, closest:%d", pastWaypoint?"true":"false", way_offset, config_latency_num_,closest_waypoint_astar);
-  if(pastWaypoint &amp;&amp;  final_waypoints_astar_.waypoints.size() &gt; closest_waypoint_astar_ + way_offset){
-	  msg.data = closest_waypoint_astar_ + way_offset;
-  }else{
-	  msg.data = closest_waypoint_astar_;
+  //  ROS_INFO("PastWaypoint:%s-offset:%d, latency:%d, closest:%d", pastWaypoint?"true":"false", way_offset,
+  //  config_latency_num_,closest_waypoint_astar);
+  if (pastWaypoint &amp;&amp; final_waypoints_astar_.waypoints.size() &gt; closest_waypoint_astar_ + way_offset)
+  {
+    msg.data = closest_waypoint_astar_ + way_offset;
+  }
+  else
+  {
+    msg.data = closest_waypoint_astar_;
   }
 #endif
   Pubs["closest_waypoint"].publish(msg);
@@ -218,8 +231,8 @@ void PlannerSelector::callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int3
 
 int main(int argc, char **argv)
 {
-	ros::init(argc, argv, "planner_selector");
+  ros::init(argc, argv, "planner_selector");
 
-	decision_maker::PlannerSelector _psn;
-	ros::spin();
+  decision_maker::PlannerSelector _psn;
+  ros::spin();
 }
</diff>
			</file>
		</modified_files>
	</commit>
</Root>
